<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【算法】赫夫曼树（Huffman）的构建和应用（编码、译码） - 外婆的彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/8308324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/8308324.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《算法（java）》                           — — Robert Sedgewick， Kevin Wayne&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《数据结构》                                  — — 严蔚敏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;赫夫曼树的概念&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;要了解赫夫曼树，我们要首先从扩充二叉树说起&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二叉树结点的度&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;结点的度指的是二叉树结点的分支数目， 如果某个结点没有孩子结点，即没有分支，那么它的度是0；如果有一个孩子结点， 那么它的度数是1；如果既有左孩子也有右孩子， 那么这个结点的度是2.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;扩充二叉树&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对于一颗已有的二叉树， 如果我们为它添加一系列新结点， 使得它原有的所有结点的度都为2，那么我们就得到了一颗扩充二叉树， 如下图所示：&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117231448537-1408176767.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/650f6221c0c74e06a709133b8e2f4e40/%257Di428s_dwkdkxn%255Do%2524up4d3u.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;1BA034535DA14C3F90846FD99E0FFDE9&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中原有的结点叫做内结点（非叶子结点）， 新增的结点叫做外结点（叶子结点）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以得出： 外结点数 = 内结点数 + 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并进一步得出： 总结点数 = 2 × 外结点数 -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩充二叉树，构成了赫夫曼树的基本形态，而上面的公式，也是我们构建赫夫曼树的依据之一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;赫夫曼树的外结点和内结点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;赫夫曼树的外结点和内结点的性质区别：外节点是携带了关键数据的结点， 而内部结点没有携带这种数据， 只作为导向最终的外结点所走的路径而使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正因如此，我们的关注点最后是落在赫夫曼树的外结点上， 而不是内结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;带权路径长度WPL&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们思考一下： 在一颗在外结点上存储了数据的扩充二叉树中进行查找时，数据结点怎么分布才能尽可能减少查找的开销呢？ 这里我们再加上一个前提：不同的数据结点搜索的频率（或概率）是不一致的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然， 我们大致的思路是： 如果一个数据结点搜索频率越高，就让它分布在离根结点越近的地方，也即从根结点走到该结点经过的路径长度越短。 这样就能从整体上优化整颗树的性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;频率是个细化的量，这里我们用一个更加标准的一个词描述它——“权值”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综上， 我们为扩充二叉树的外结点（叶子结点）定义两条属性： 权值（w）和路径长度(l)。同时规定带权路径长度（WPL）为扩充二叉树的外结点的权值和路径长度乘积之和：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117231519896-459287945.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/be24a7e6bf4048f3bc07f822687a0e4b/%25248xrid%255B%257E%2529%255D52@ncg%2524pq9gkb.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;750DDD624FC446EE88C4530181CD98A0&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（注意只是外结点！）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;赫夫曼树（最优二叉树）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由n个权值构造一颗有n个叶子结点的二叉树， 则其中带权路径长度WPL最小的二叉树， 就是赫夫曼树，或者叫做最优二叉树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如下图中对a, b, c&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117231555412-1315284149.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/d7b1dcf0d42c476f9bfed4540263f1f8/qml%257B7d%252828m4v_yha%2528m_l7%25604.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;24A9CC7F53FE40B0B57386A759E943D0&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对a: WPL = 7×2 + 5×2 + 2×2 + 4×2 = 36；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对b: WPL = 7×3 + 5×3 + 2×1 + 4×2 = 46;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对c: WPL = 7×1 + 5×2 + 2×3 + 4×3  = 35;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;c中WPL最小， 可以验证， 它就是赫夫曼树， 而a和b都不是赫夫曼树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于同一组权值的叶结点， 构成的赫夫曼树可以有多种形态， 但是最小WPL值是唯一的。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117231626740-1383924626.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/776b7d7b17a74dd3873afc8c6a3572c9/gxq7jr%2529@kt12b%2529y6z0dlcur.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;B92FF73899584A7997C7B9DBF83DE447&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;赫夫曼树的构建&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;构建过程分四步：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 根据给定的n个权值{w1, w2, w3 ... wn }构成n棵二叉树的集合， 每棵二叉树都只包含一个结点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 在上面的二叉树中选出两颗根结点权值最小的树， 同时另外取一个新的结点作为这两颗树的根结点， 设新节点的权值为两颗权值最小的树的权值和， 将得到的这颗树也加入到树的集合中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 在2操作后， 从集合中删除权值最小的那两颗树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 重复2和3，直到集合中的树只剩下一棵为止， 剩下的这颗树就是我们要求得的赫夫曼树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117231649896-1722470520.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/e8dbfd1192b040beb0297d2cbdd638dd/%254090d474a@_x%2524vp%255Bed%2560a0lq7.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;F991D584495B4248BC7AC2BBB5E987A1&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（注意a和b的分界线在4和7中间，图中画的不是很清晰）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们上面提到过WPL相同的情况下， 赫夫曼树不止一种，在我们介绍的算法中，人为要求某个内结点的左儿子的权值要比右儿子大， 这样一来， 就将我们算法中的赫夫曼树变为唯一一种了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构建赫夫曼树的的方法有多种，但基于实际应用的考虑（赫夫曼编码和译码）， 下面我给出基于数组存储实现的赫夫曼树：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Node类的设计&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们首先需要一个编写一个结点类， 结点类里有5种实例变量： weight表示权值， data表示外结点存储的字符，data属性在下面的编码/解码中会用到。  而同样因为赫夫曼编码，解码的需求，这里我们使用三叉链实现二叉树，，即在left和right属性的基础上，为结点增加了parent属性，目的是能够从叶子结点上溯到根结点，从而实现赫夫曼编码。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: HuWan Peng
 * @Date Created in 23:21 2018/1/14
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;  data; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt; weight;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 权值&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt; left, right, parent; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 三条链接&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; Node (&lt;span&gt;char&lt;/span&gt; data, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
  }
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Node (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;buildTree方法的设计&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入参数和返回值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入参数： 一个由外结点对象组成的Node数组， 假设其为nodes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回值： 一个由内、外结点共同组成，且建立了链接关系的Node数组, 假设其为HT（HuffmanTree）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先要做的事情是： 获取输入的nodes数组的长度 n , 创建一个长度为 2n - 1的数组——HT，在数组HT中, 前n个元素用来存放外结点， 后n个元素用来存放内结点， 如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图A&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/a08c71acfc904acca539f5f6d042c98b/4y2p%257Ef%2525%25248hix_@34w%255Bn01%2525r.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;4AE1B7269ECC45188F46514495F3FB7C&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117231717646-1795399738.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;图B&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/731f9ebdd6914d14abaa8dcc446f8619/0lgn%255D%257B%2529_739j9qovxa%2524%252831i.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;83D2FB4ADB0D4569B3D844380D6E06DF&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117231732162-841909630.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;接下来要做的是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 初始化HT中的结点对象，此时各个结点对象的weight都被置为0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 将输入的nodes数组中的各结点对象的权值赋给HT[0]~ HT[n-1]， 如上图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.通过循环， 依次计算各个内结点的权值，同时建立该内结点和作为它左右孩子的两个外结点的链接关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;易知：当最后一个内结点的权值也计算完毕后， 整颗赫夫曼树也就构建完毕了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图 （方框内数字表示结点对象的权值）&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117231803037-1838493735.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/8fa21d496e6d48b9a5ad9cc56adc1ddd/bf%257B%25288hg%257Dizpnehabbec3c%25254.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;B4F38BA1BC194F8587685F1A1AD5F763&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注意要点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要注意的是： 我们为Node设置的链接变量left/right/parent是整型的， 它指向的是某个结点对象在HT中的下标， 而不是结点对象本身！ 这种实现方式和一般的树是有区别的&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117231837146-271436172.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/20c3e4c0783a4ce7a0d34c4800ac9b83/p%257Bpyx9j44e5xny%257E3di%2528a%257B%25283.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;A91D286118FF4B5AB2CD79A7988EA33D&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;具体代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是buildTre方法的代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（select方法尚未给出）&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 构建赫夫曼树
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  Node[] buildTree (Node [] nodes) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s1, s2,p;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = nodes.length; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 外结点的数量&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; m = 2*n - 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内结点 + 外结点的总数量&lt;/span&gt;
    Node [] HT = &lt;span&gt;new&lt;/span&gt; Node [m]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储结点对象的HT数组&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;m;i++) HT[i] = &lt;span&gt;new&lt;/span&gt; Node(0); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化HT数组元素&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;n;i++&lt;span&gt;) {
      HT[i].data   &lt;/span&gt;=&lt;span&gt; nodes[i].data;
      HT[i].weight &lt;/span&gt;= nodes[i].weight; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将给定的权值列表赋给外结点对象&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=n;i&amp;lt;m;i++&lt;span&gt;) {
      s1 &lt;/span&gt;= select(HT,i,0); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得HT数组中权值最小的结点对象的下标&lt;/span&gt;
      s2 = select(HT,i,1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得HT数组中权值次小的结点对象的下标&lt;/span&gt;
      HT[i].left  = s1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建立链接&lt;/span&gt;
      HT[i].right =&lt;span&gt; s2;
      HT[s1].parent &lt;/span&gt;=&lt;span&gt; i;
      HT[s2].parent &lt;/span&gt;=&lt;span&gt; i;
      HT[i].weight &lt;/span&gt;= HT[s1].weight + HT[s2].weight;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算当前外结点的权值&lt;/span&gt;
      selectStart+=2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个变量表示之前“被删除”的最小结点的数量和&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HT; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将处理后的HT数组返回&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;buildTree方法的用例：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: buildTree方法的用例
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main (String [] args) {
    Node [] nodes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node[4&lt;span&gt;];
    nodes[&lt;/span&gt;0] = &lt;span&gt;new&lt;/span&gt; Node('a',7&lt;span&gt;);
    nodes[&lt;/span&gt;1] = &lt;span&gt;new&lt;/span&gt; Node('b',5&lt;span&gt;);
    nodes[&lt;/span&gt;2] = &lt;span&gt;new&lt;/span&gt; Node('c',2&lt;span&gt;);
    nodes[&lt;/span&gt;3] = &lt;span&gt;new&lt;/span&gt; Node('d',4&lt;span&gt;);
    HuffmanTree ht &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HuffmanTree();
    Node [] n &lt;/span&gt;= ht.buildTree(nodes);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; n是构建完毕的赫夫曼树&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;select方法的设计&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;buildTree方法的实现依赖于select方法：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; select (Node[] HT,&lt;span&gt;int&lt;/span&gt; range, &lt;span&gt;int&lt;/span&gt; rank)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面代码中调用select的部分为：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
s1 = select(HT,i,0); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得HT数组中权值最小的结点对象的下标&lt;/span&gt;
s2 = select(HT,i,1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得HT数组中权值次小的结点对象的下标&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;思考3个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.  求给定权值排名的结点，可以先对数组进行从小到大的快速排序， 然后就可以取得给定排名的结点对象了， 但是如果直接对输入的HT数组进行排序的话， 会改变HT数组元素的排列顺序， 这将不利于我们下面要介绍的赫夫曼编码的方法的实现。 所以这里我们先将HT数组拷贝到一个辅助数组copyNodes中， 对copyNodes进行快排，并取得给定权值排名的结点对象。然后通过遍历HT数组，比较得到该结点对象在HT中的下标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 在上面我们提到过， 在构建一颗新二叉树后， 要把原来的两颗权值最小的树从集合中 ”删除“，这里我们通过类内的selectStart实例变量实现， selectStart初始值为0， 每次构建一棵新二叉树后都通过 selectStart+=2; 增加它的值。（见上文buildTree代码） 这样， 在select方法中就可以通过copyNodes[selectStart + rank]，去取得 &quot;删除&quot; 后权值排名为rank的结点对象了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.  引入range这一参数是为了排除那些weight仍为0，即尚未使用到的内结点， 防止排序后取到它们。注意， 随着循环中 i 的增长， range也是不断增长的：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/2c2cdcc5eed04b8f8de4f0b67da09769/ubfpx%257Ev3s@%257B%257Dks1lm%2525%255D%2525%2524qx.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;EAF152CDD06840B1A9779227F3D58FD2&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117231912881-1727155723.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;具体代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（QuickSort的代码文末将给出）&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 返回权值排名为rank的结点对象在HT中的下标（按权值从小到大排）
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; select (Node[] HT,&lt;span&gt;int&lt;/span&gt; range, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; rank) {
    Node [] copyNodes &lt;/span&gt;= Arrays.copyOf(HT, range);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将HT[0]~HT[range]拷贝到copyNodes中&lt;/span&gt;
    QuickSort.sort(copyNodes); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对copyNodes进行从小到大的快速排序&lt;/span&gt;
    Node target = copyNodes[rank + selectStart]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得“删除”后权值排名为rank的结点对象&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=0;j&amp;lt;HT.length;j++&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (target == HT[j]) &lt;span&gt;return&lt;/span&gt; j; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回该结点对象在数组HT中的下标&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;过程图解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117231933443-1345793173.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/8a783e2ac6be44398a51e7d52294c1d4/36j7t0m%257Eu%257Dg4ilbld6%257Dr75a.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;32FA52BB10534844BB7B84EC291DE0B0&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样，通过调用buildTree方法， 我们的赫夫曼树就构造好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;赫夫曼树的应用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;赫夫曼树可以用于优化编码， 在这之前， 先让我们了解下什么是等长编码和不等长编码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;等长编码和不等长编码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;等长编码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如一段电文为 'A B A C C D A', 它只有4种字符，只需要两个字符的串就可以分辨， 所以我们可以按等长编码的设计原则， 将A，B，C，D表示为00、01、10、11, 'A B A C C D A'就被编码为‘00010010101100’， 共14位。 它的优点是： 因为间隔相同， 译码时不存在二义性的问题。 但缺点在于， 有些字符本可以被设计为更短的编码， 也就是说，设计为等长编码， 我们实际上浪费了一部分编码的空间（长度）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;不等长编码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同上， 如果采用不等长编码， 可以把A，B，C，D表示为0、00、1、01, 那么 'A B A C C D A'就可以被编码为‘000011010’， 总长只要9就够了！ 比起等长编码我们节约了5位的长度。 但问题是： 由于长度间隔不一致， 译码时可能存在二义性，这导致无法翻译，例如 ‘00‘，到底是看成'00'还是’0‘ + ’0‘呢？ 前者被翻译为B，而后者被翻译为A。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117232011428-934413502.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/6ebec7ad07a14280a6b710ada066dd51/tkoo%2525pil%255B8d9_%2529uzc%2528q%257D%2528%2524u.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;E0CF21DBFB784581B893E05F59974604&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;前缀编码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;所以，要设计长短不等的编码， 则必须保证： 任意一个字符的编码都不是另一个字符的编码的前缀，这种编码就叫做前缀编码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;赫夫曼编码的作用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;赫夫曼编码就是一种前缀编码， 它能解决不等长编码时的译码问题， 通过它，我们既能尽可能减少编码的长度， 同时还能够避免二义性， 实现正确译码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;赫夫曼编码是如何实现前缀编码的 ？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设有一棵如下图所示的二叉树， 其4个叶结点分别表示A，B，C，D这4个字符，且约定左分支表示字符'0', 右分支代表字符'1', 则可以从根结点到叶子结点的路径上的各分支字符组成的字符串作为该叶子结点字符的编码。 从而得到A，B，C，D的二进制编码分别为0， 10， 110， 111。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117232044599-2061462819.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/f04be0786ceb4be4a646983be5887245/rlv_9%257E%25281f%255B%2528u_wtq%2524%25257%257El_7.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;41EE0C299EDD45B083BB8520D7FB729D&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;具体如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/c9f47c78fe104fd0aa1ca9305b76a822/e0byw%257Decmoob%2524b%257B9%255B5oh@44.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;5C301D8CBACB4627BB2BE97E7540409A&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117232101506-1692052052.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;赫夫曼编码和解码都要调用上文讲述的buildTree方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;实现赫夫曼编码(encode)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;根据给定的字符和权值， 输出字符和对应的赫夫曼编码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意要点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 我们编写一个HuffmanCode内部类用于存放字符（data实例变量）和它对应的二进制字符串（bit实例变量）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 要求所有字符对应的编码时，如果采用从根结点下行到叶结点的思路处理，逻辑会相对复杂一些， 所以我们用逆向的方式获取： 按照从叶子结点到根结点的路径累加二进制字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117232123834-93460458.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/228cad02eab9492287e6eb773750bdf0/v4%255Dz5ijk%2560n84%2560r83f8h%255Dbqq.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;4328DBAA86204A2E89CA7B3B5FB547BF&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.  因为 2 的原因， 累加二进制字符串的时候也必须反向累加，例如写成bit= &quot;0&quot; + bit;  而不是写成bit= bit+ &quot;0&quot;; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 上溯时候要做的工作是： 判断当前经过的是 0 还是 1， 判断的方法如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设P是X的父节点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果P.left==X在HT中的下标，则说明X是P的左分支，说明经过的是 0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果P.right==X在HT中的下标，则说明X是P的右分支，说明经过的是 1&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/903bc6f156a84df4b2e50b18e36fbadc/q1%257Dmqw2t%25253ikkoyf6xizb5t.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;188E1E5810B3484DADFCE0FADC5DE3F4&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117232210021-584760922.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: HuWan Peng
 * @Date Created in 22:54 2018/1/14
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HuffmanTree {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HuffmanCode {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; data; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存放字符，例如 'C'&lt;/span&gt;
    String bit; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存放编码后的字符串, 例如&quot;111&quot;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; HuffmanCode (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; data, String bit) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bit  =&lt;span&gt; bit;
    }
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 构建赫夫曼树
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  Node[] buildTree (Node [] nodes) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 具体代码见上文&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 进行赫夫曼编码
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  HuffmanCode [] encode(Node [] nodes) {
    Node [] HT &lt;/span&gt;= buildTree(nodes); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据输入的nodes数组构造赫夫曼树&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; nodes.length;
    HuffmanCode [] HC &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HuffmanCode [n];
    String bit;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;n;i++) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历各个叶子结点&lt;/span&gt;
      bit = &quot;&quot;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; c=i,f=HT[i].parent;f!=0;c=f,f=HT[f].parent) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从叶子结点上溯到根结点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(HT[f].left == c) bit= &quot;0&quot; + bit; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反向编码&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;                bit= &quot;1&quot; +&lt;span&gt; bit;
      }
      HC[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HuffmanCode(HT[i].data,bit); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将字符和对应的编码存储起来&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; HC;
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: encode方法的用例
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main (String [] args) {
    Node [] nodes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node[4&lt;span&gt;];
    nodes[&lt;/span&gt;0] = &lt;span&gt;new&lt;/span&gt; Node('A',7&lt;span&gt;);
    nodes[&lt;/span&gt;1] = &lt;span&gt;new&lt;/span&gt; Node('B',5&lt;span&gt;);
    nodes[&lt;/span&gt;2] = &lt;span&gt;new&lt;/span&gt; Node('C',2&lt;span&gt;);
    nodes[&lt;/span&gt;3] = &lt;span&gt;new&lt;/span&gt; Node('D',4&lt;span&gt;);
    HuffmanTree ht &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HuffmanTree();
    HuffmanCode[] hc &lt;/span&gt;=&lt;span&gt; ht.encode(nodes);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对A，B，C，D进行编码&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;hc.length;i++) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将赫夫曼编码打印出来&lt;/span&gt;
      System.out.println(hc[i].data + &quot;:&quot; +&lt;span&gt;hc[i].bit);
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
A:0&lt;span&gt;
B:&lt;/span&gt;10&lt;span&gt;
C:&lt;/span&gt;110&lt;span&gt;
D:&lt;/span&gt;111
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;赫夫曼译码(decode)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;根据给定的字符和权值， 将输入的赫夫曼编码翻译回原字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;译码的时候，从根结点HT[HT.length -1] 开始, 向下行走， 通过charAt方法取得字符串当前的字符， 如果为 '0'则向左走， 为'1'则向右走， 当下行到叶子结点时候，取得叶子结点包含的字符， 添加到当前的译码字符串中，同时有回到根结点，继续循环。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: HuWan Peng
 * @Date Created in 22:54 2018/1/14
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HuffmanTree {
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; selectStart = 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HuffmanCode {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; data; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存放字符，例如 'C'&lt;/span&gt;
    String bit; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存放编码后的字符串, 例如&quot;111&quot;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; HuffmanCode (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; data, String bit) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bit  =&lt;span&gt; bit;
    }
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 构建赫夫曼树
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  Node[] buildTree (Node [] nodes) {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代码见上文&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 进行赫夫曼译码
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String decode (Node [] nodes, String code) {
    String str&lt;/span&gt;=&quot;&quot;&lt;span&gt;;
    Node [] HT &lt;/span&gt;=&lt;span&gt; buildTree(nodes);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =HT.length -1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;code.length();i++&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c =&lt;span&gt; code.charAt(i);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(c == '1'&lt;span&gt;) {
        n &lt;/span&gt;=&lt;span&gt; HT[n].right;
      }
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        n &lt;/span&gt;=&lt;span&gt; HT[n].left;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(HT[n].left == 0&lt;span&gt;) {
        str&lt;/span&gt;+=&lt;span&gt; HT[n].data;
        n &lt;/span&gt;=HT.length -1&lt;span&gt;;
      }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
  }
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: decode方法的用例
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main (String [] args) {
    Node [] nodes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node[4&lt;span&gt;];
    nodes[&lt;/span&gt;0] = &lt;span&gt;new&lt;/span&gt; Node('A',7&lt;span&gt;);
    nodes[&lt;/span&gt;1] = &lt;span&gt;new&lt;/span&gt; Node('B',5&lt;span&gt;);
    nodes[&lt;/span&gt;2] = &lt;span&gt;new&lt;/span&gt; Node('C',2&lt;span&gt;);
    nodes[&lt;/span&gt;3] = &lt;span&gt;new&lt;/span&gt; Node('D',4&lt;span&gt;);
    HuffmanTree ht &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HuffmanTree();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对 010110111 进行译码&lt;/span&gt;
    System.out.println(ht.decode(nodes,&quot;010110111&quot;&lt;span&gt;));
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;输出：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;全部代码：&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;代码共三份：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.HuffmanTree.java&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.Node.java&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.QuickSort.java&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Node.java&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: HuWan Peng
 * @Date Created in 23:21 2018/1/14
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;  data;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; left, right, parent;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Node (&lt;span&gt;char&lt;/span&gt; data, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
  }
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Node (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;HuffmanTree.java&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;17.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: HuWan Peng
 * @Date Created in 22:54 2018/1/14
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HuffmanTree {
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; selectStart = 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HuffmanCode {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; data; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存放字符，例如 'C'&lt;/span&gt;
    String bit; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存放编码后的字符串, 例如&quot;111&quot;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; HuffmanCode (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; data, String bit) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bit  =&lt;span&gt; bit;
    }
  }
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 返回权值排名为rank的结点对象在nodes中的下标（按权值从小到大排）
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; select (Node[] HT,&lt;span&gt;int&lt;/span&gt; range, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; rank) {
    Node [] copyNodes &lt;/span&gt;= Arrays.copyOf(HT, range);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将HT[0]~HT[range]拷贝到copyNodes中&lt;/span&gt;
    QuickSort.sort(copyNodes); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对copyNodes进行从小到大的快速排序&lt;/span&gt;
    Node target = copyNodes[rank + selectStart]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得“删除”后权值排名为rank的结点对象&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=0;j&amp;lt;HT.length;j++&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (target == HT[j]) &lt;span&gt;return&lt;/span&gt; j; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回该结点对象在数组HT中的下标&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 构建赫夫曼树
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  Node[] buildTree (Node [] nodes) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s1, s2,p;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = nodes.length; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 外结点的数量&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; m = 2*n - 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内结点 + 外结点的总数量&lt;/span&gt;
    Node [] HT = &lt;span&gt;new&lt;/span&gt; Node [m]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储结点对象的HT数组&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;m;i++) HT[i] = &lt;span&gt;new&lt;/span&gt; Node(0); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化HT数组元素&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;n;i++&lt;span&gt;) {
      HT[i].data   &lt;/span&gt;=&lt;span&gt; nodes[i].data;
      HT[i].weight &lt;/span&gt;= nodes[i].weight; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将给定的权值列表赋给外结点对象&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=n;i&amp;lt;m;i++&lt;span&gt;) {
      s1 &lt;/span&gt;= select(HT,i,0); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得HT数组中权值最小的结点对象的下标&lt;/span&gt;
      s2 = select(HT,i,1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得HT数组中权值次小的结点对象的下标&lt;/span&gt;
      HT[i].left  = s1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建立链接&lt;/span&gt;
      HT[i].right =&lt;span&gt; s2;
      HT[s1].parent &lt;/span&gt;=&lt;span&gt; i;
      HT[s2].parent &lt;/span&gt;=&lt;span&gt; i;
      HT[i].weight &lt;/span&gt;= HT[s1].weight + HT[s2].weight;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算当前外结点的权值&lt;/span&gt;
      selectStart+=2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个变量表示之前“被删除”的最小结点的数量和&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HT; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将处理后的HT数组返回&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 进行赫夫曼编码
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  HuffmanCode [] encode(Node [] nodes) {
    Node [] HT &lt;/span&gt;= buildTree(nodes); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据输入的nodes数组构造赫夫曼树&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; nodes.length;
    HuffmanCode [] HC &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HuffmanCode [n];
    String bit;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;n;i++) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历各个叶子结点&lt;/span&gt;
      bit = &quot;&quot;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; c=i,f=HT[i].parent;f!=0;c=f,f=HT[f].parent) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从叶子结点上溯到根结点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(HT[f].left == c) bit= &quot;0&quot; + bit; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反向编码&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;                bit= &quot;1&quot; +&lt;span&gt; bit;
      }
      HC[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HuffmanCode(HT[i].data,bit); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将字符和对应的编码存储起来&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; HC;
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 进行赫夫曼译码
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String decode (Node [] nodes, String code) {
    String str&lt;/span&gt;=&quot;&quot;&lt;span&gt;;
    Node [] HT &lt;/span&gt;=&lt;span&gt; buildTree(nodes);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =HT.length -1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;code.length();i++&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c =&lt;span&gt; code.charAt(i);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(c == '1'&lt;span&gt;) {
        n &lt;/span&gt;=&lt;span&gt; HT[n].right;
      }
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        n &lt;/span&gt;=&lt;span&gt; HT[n].left;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(HT[n].left == 0&lt;span&gt;) {
        str&lt;/span&gt;+=&lt;span&gt; HT[n].data;
        n &lt;/span&gt;=HT.length -1&lt;span&gt;;
      }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
  }
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: buildTree方法的用例
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main (String [] args) {
    Node [] nodes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node[4&lt;span&gt;];
    nodes[&lt;/span&gt;0] = &lt;span&gt;new&lt;/span&gt; Node('A',7&lt;span&gt;);
    nodes[&lt;/span&gt;1] = &lt;span&gt;new&lt;/span&gt; Node('B',5&lt;span&gt;);
    nodes[&lt;/span&gt;2] = &lt;span&gt;new&lt;/span&gt; Node('C',2&lt;span&gt;);
    nodes[&lt;/span&gt;3] = &lt;span&gt;new&lt;/span&gt; Node('D',4&lt;span&gt;);
    HuffmanTree ht &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HuffmanTree();
    System.out.println(ht.decode(nodes,&lt;/span&gt;&quot;010110111&quot;&lt;span&gt;));
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3&gt;&lt;span&gt; QuickSort.java&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;18.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: HuWan Peng
 * @Date Created in 22:56 2018/1/14
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QuickSort {
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 交换两个数组元素
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exchange(Node [] a , &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {
    Node temp &lt;/span&gt;=&lt;span&gt; a[i];
    a[i] &lt;/span&gt;=&lt;span&gt; a[j];
    a[j] &lt;/span&gt;=&lt;span&gt; temp;
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 切分函数
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; partition (Node [] a, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = low, j = high+1;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i, j为左右扫描指针&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; pivotkey = a[low].weight;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pivotkey 为选取的基准元素（头元素）&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (a[--j].weight&amp;gt;pivotkey) {   &lt;span&gt;if&lt;/span&gt;(j == low) &lt;span&gt;break&lt;/span&gt;; }  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右游标左移&lt;/span&gt;
      &lt;span&gt;while&lt;/span&gt;(a[++i].weight&amp;lt;pivotkey) {   &lt;span&gt;if&lt;/span&gt;(i == high) &lt;span&gt;break&lt;/span&gt;;  }  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左游标右移&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(i&amp;gt;=j) &lt;span&gt;break&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左右游标相遇时候停止， 所以跳出外部while循环&lt;/span&gt;
      &lt;span&gt;else&lt;/span&gt; exchange(a,i, j) ;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左右游标未相遇时停止, 交换各自所指元素，循环继续&lt;/span&gt;
&lt;span&gt;    }
    exchange(a, low, j); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基准元素和游标相遇时所指元素交换，为最后一次交换&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; j;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一趟排序完成， 返回基准元素位置&lt;/span&gt;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * @description: 根据给定的权值对数组进行排序
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort (Node [] a, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(high&amp;lt;= low) { &lt;span&gt;return&lt;/span&gt;; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当high == low, 此时已是单元素子数组，自然有序， 故终止递归&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; j = partition(a, low, high);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用partition进行切分&lt;/span&gt;
    sort(a,  low,  j-1);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对上一轮排序(切分)时，基准元素左边的子数组进行递归&lt;/span&gt;
    sort(a,  j+1,  high); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对上一轮排序(切分)时，基准元素右边的子数组进行递归&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort (Node [] a){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sort函数重载， 只向外暴露一个数组参数&lt;/span&gt;
    sort(a, 0, a.length-1&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060770/201801/1060770-20180117232336162-1566907346.jpg&quot; alt=&quot;&quot; width=&quot;418&quot; height=&quot;388&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Wed, 17 Jan 2018 22:19:00 +0000</pubDate>
<dc:creator>外婆的彭湖湾</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/penghuwan/p/8308324.html</dc:identifier>
</item>
<item>
<title>算法9 五大查找之：哈希查找 - nnngu</title>
<link>http://www.cnblogs.com/nnngu/p/8307743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnngu/p/8307743.html</guid>
<description>&lt;p&gt;前面的几篇文章分别总结了：&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8286082.html&quot; target=&quot;_blank&quot;&gt;顺序查找&lt;/a&gt;、&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8286401.html&quot; target=&quot;_blank&quot;&gt;二分查找&lt;/a&gt;、&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8290367.html&quot; target=&quot;_blank&quot;&gt;索引查找&lt;/a&gt;、&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8294714.html&quot; target=&quot;_blank&quot;&gt;二叉排序树&lt;/a&gt;。这一篇文章要总结的是五大查找的最后一个：哈希查找（也称为散列查找）。提起哈希，我的第一印象就是java中的Hashtable类，它是由 key/value 的键值对组成的集合，它就是应用了哈希技术。&lt;/p&gt;
&lt;p&gt;那什么是哈希查找呢？在弄清楚什么是哈希查找之前，我们要弄清楚哈希技术，哈希技术是在记录的存储位置和记录的 key 之间建立一个确定的映射 f()，使得每个 key 对应一个存储位置 f(key)。若查找集合中存在这个记录，则必定在 f(key) 的位置上。哈希技术既是一种存储方法，也是一种查找方法。&lt;/p&gt;
&lt;h2&gt;六种哈希函数 f(key) 的构造方法：&lt;/h2&gt;
&lt;h3&gt;1、直接定址法&lt;/h3&gt;
&lt;p&gt;哈希地址：f(key) = a*key+b  (a,b为常数)&lt;/p&gt;
&lt;p&gt;这种方法的优点是：简单，均匀，不会产生冲突。但是需要事先知道 key 的分布情况，适合查找表较小并且连续的情况。&lt;/p&gt;

&lt;h3&gt;2、数字分析法&lt;/h3&gt;
&lt;p&gt;比如我们的11位手机号码“136xxxx5889”，其中前三位是接入号，一般对应不同运营公司的子品牌，如130是联通如意通，136是移动神州行等等。中间四位表示归属地。最后四位才是用户号。&lt;/p&gt;
&lt;p&gt;若我们现在要存储某家公司员工登记表，如果用手机号码作为 key，那么极有可能前7位都是相同的，所以我们选择最后四位作为 f(key) 就是不错的选择。&lt;/p&gt;

&lt;h3&gt;3、平方取中法&lt;/h3&gt;
&lt;p&gt;故名思义，比如 key 是1234，那么它的平方就是1522756，再抽取中间的3位就是227作为 f(key) 。&lt;/p&gt;

&lt;h3&gt;4、折叠法&lt;/h3&gt;
&lt;p&gt;折叠法是将 key 从左到右分割成位数相等的几个部分(最后一部分位数不够可以短些)，然后将这几部分叠加求和，并按哈希表的表长，取后几位作为 f(key) 。&lt;/p&gt;
&lt;p&gt;比如我们的 key 是 9876543210，哈希表的表长为3位，我们将 key 分为4组，987|654|321|0 ，然后将它们叠加求和 987+654+321+0=1962，再取后3位即得到 f(key) = 962 。&lt;/p&gt;

&lt;h3&gt;5、除留余数法&lt;/h3&gt;
&lt;p&gt;哈希地址：f(key) = key mod p (p&amp;lt;=m) m为哈希表表长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这种方法是最常用的哈希函数构造方法。下面的代码中也使用了这种方法。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;6、随机数法&lt;/h3&gt;
&lt;p&gt;哈希地址：f(key) = random(key)  &lt;/p&gt;
&lt;p&gt;这里 random 是随机函数，当 key 的长度不等时，采用这种方法比较合适。&lt;/p&gt;

&lt;h2&gt;哈希函数冲突的两种解决方法：&lt;/h2&gt;
&lt;p&gt;我们设计得再好的哈希函数也不可能完全避免冲突，当我们使用哈希函数后发现有 key1 != key2，但却有 f(key1) = f(key2) ，即发生冲突。&lt;/p&gt;
&lt;h3&gt;1、开放定址法：&lt;/h3&gt;
&lt;p&gt;开放定址法就是一旦发生了冲突，就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总是能找到，然后将记录插入。这种方法是最常用的解决冲突的方法。下面的代码中也使用了这种方法。&lt;/p&gt;
&lt;h3&gt;2、链地址法：&lt;/h3&gt;
&lt;p&gt;链地址法不做详细展开。&lt;/p&gt;

&lt;h2&gt;代码：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;HashSearch.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Scanner;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HashSearch {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化哈希表&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hashLength = 7&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] hashTable = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[hashLength];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原始数据&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] list = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{13, 29, 27, 28, 26, 30, 38&lt;span&gt;};

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        System.out.println(&lt;/span&gt;&quot;*******哈希查找*******&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建哈希表&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; list.length; i++&lt;span&gt;) {
            insert(hashTable, list[i]);
        }
        System.out.println(&lt;/span&gt;&quot;展示哈希表中的数据：&quot; +&lt;span&gt; display(hashTable));

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈希表查找&lt;/span&gt;
            System.out.print(&quot;请输入要查找的数据：&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in).nextInt();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; search(hashTable, data);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result == -1&lt;span&gt;) {
                System.out.println(&lt;/span&gt;&quot;对不起，没有找到！&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                System.out.println(&lt;/span&gt;&quot;数据的位置是：&quot; +&lt;span&gt; result);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 方法：哈希表插入
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(&lt;span&gt;int&lt;/span&gt;[] hashTable, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; data) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈希函数，除留余数法&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; hashAddress =&lt;span&gt; hash(hashTable, data);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不为0，则说明发生冲突&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (hashTable[hashAddress] != 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用 开放定址法 解决冲突&lt;/span&gt;
            hashAddress = (++hashAddress) %&lt;span&gt; hashTable.length;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将待插入值存入字典中&lt;/span&gt;
        hashTable[hashAddress] =&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 方法：哈希表查找
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; search(&lt;span&gt;int&lt;/span&gt;[] hashTable, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; data) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈希函数，除留余数法&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; hashAddress =&lt;span&gt; hash(hashTable, data);

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (hashTable[hashAddress] !=&lt;span&gt; data) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用 开放定址法 解决冲突&lt;/span&gt;
            hashAddress = (++hashAddress) %&lt;span&gt; hashTable.length;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找到开放单元 或者 循环回到原点，表示查找失败&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (hashTable[hashAddress] == 0 || hashAddress ==&lt;span&gt; hash(hashTable, data)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找成功，返回下标&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashAddress;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 方法：构建哈希函数（除留余数法）
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; hashTable
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; data
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash(&lt;span&gt;int&lt;/span&gt;[] hashTable, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; data) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; data %&lt;span&gt; hashTable.length;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 方法：展示哈希表
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String display(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] hashTable) {
        StringBuffer stringBuffer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : hashTable) {
            stringBuffer &lt;/span&gt;= stringBuffer.append(i + &quot; &quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; String.valueOf(stringBuffer);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180118022459349-786643860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;欢迎转载，但请保留文章原始出处&lt;/p&gt;
&lt;p&gt;本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 算法9 五大查找之：哈希查找&quot; href=&quot;http://www.cnblogs.com/nnngu/p/8307743.html&quot;&gt;http://www.cnblogs.com/nnngu/p/8307743.html&lt;/a&gt; &lt;/p&gt;

</description>
<pubDate>Wed, 17 Jan 2018 18:30:00 +0000</pubDate>
<dc:creator>nnngu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnngu/p/8307743.html</dc:identifier>
</item>
<item>
<title>内核知识第八讲,PDE,PTE,页目录表,页表的内存管理 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/8307728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/8307728.html</guid>
<description>&lt;h2&gt;一丶查看GDT表.&lt;/h2&gt;
&lt;p&gt;我们通过WinDbg + 虚拟机可以进行双机调试.调试一下看下GDT表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118004330084-1487142799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道,GDT表中.存储的是存储段信息. 保存了一系列的段和内存的属性.&lt;/p&gt;
&lt;p&gt;但是微软并没有使用.&lt;/p&gt;
&lt;p&gt;我们可以通过ring3的段寄存器. 当作GDT表的下标.进行查表. 查询GDT表.&lt;/p&gt;
&lt;p&gt;例如我们用OD随便打开一个ring3的exe,然后看下段和虚拟地址.:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118004844318-529664131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虚拟地址: 0040256f  段选择子: cs:1B&lt;/p&gt;
&lt;p&gt;那么此时段选择字当下表.虚拟地址当作偏移.去查询GDT表&lt;/p&gt;
&lt;p&gt;下图为选择子结构&lt;/p&gt;
&lt;p&gt;段选择子结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118003848474-46604932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 首先先拆分选择子.&lt;/p&gt;
&lt;p&gt;1B =   0000000000011 011&lt;/p&gt;
&lt;p&gt;查询出来下表为3,那么去GDT表的第三项进行查找.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118011303381-1665941264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们从中取出段首地址 加上我们的偏移&lt;/p&gt;
&lt;p&gt;00000000  + 40256F = 0040256F(线性地址)&lt;/p&gt;
&lt;p&gt;那么通过查询GDT表.那么可以找到线性地址. 而我们GDT表,微软没有使用它来进行进程隔离. &lt;/p&gt;
&lt;p&gt;PS: 微软因为不使用GDT表进行进程隔离,所以段选择子都是一样的.基地址都是0,我们的虚拟地址就是线性地址.&lt;/p&gt;
&lt;p&gt;如果没有开分页保护.那么就是物理地址了.但是注意FS寄存器. FS寄存器很特殊.并不能说GDT表没用.&lt;/p&gt;
&lt;h2&gt;二丶控制寄存器CR0&lt;/h2&gt;
&lt;p&gt;我们上面说过.如果没有开启分页保护.那么虚拟地址就是线性地址,线性地址就是物理地址&lt;/p&gt;
&lt;p&gt;而微软是通过分页进行进程内存的隔离的.&lt;/p&gt;
&lt;p&gt;首先说一下什么分页的历史,和CR0控制寄存器.&lt;/p&gt;
&lt;p&gt;在保护模式下, 寄存器CR0的高位1表示开启分页.0表示不开启.&lt;/p&gt;
&lt;p&gt;而这个在操作系统初始化的是否就已经完成了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118012201053-941188018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们不开启,那么访问虚拟内存,就等价于访问物理内存了.&lt;/p&gt;
&lt;p&gt;但是我们的三环是不可以操作的.这个属于特权指令.如果用汇编进行操作.例如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
__asm mov cr0,&lt;span&gt;8000000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序会崩溃,提示你权限不够,并且报告错误码为 C096&lt;/p&gt;
&lt;p&gt;但是我们0环可以进行操作的.&lt;/p&gt;
&lt;p&gt;看一下CR0的结构:&lt;/p&gt;
&lt;p&gt;但是我们0环可以进行操作的.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118013214834-572972881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此图是从inter手册上截图下来的.有兴趣的可以查询CR0查看.&lt;/p&gt;
&lt;p&gt;刚才我们说的高位为1的是否就去掉分页保护,此时访问虚拟内存 等价于访问物理内存,其实我们修改的是PG位&lt;/p&gt;
&lt;p&gt;关于位怎么说的,inter手册也说.这里我总结一下重要的,如果不相信我可以查看inter手册.&lt;/p&gt;
&lt;p&gt;PG:  PG位表示是否分页管理机制是否有效. PG = 1,有效, PG = 0 无效.&lt;/p&gt;
&lt;p&gt;WP: Wp位 写保护位, WP为0禁用写保护,为1则启动  &lt;/p&gt;
&lt;p&gt;PS: 通过修改WP位可以进行过保护. 详情请看&lt;a target=&quot;_blank&quot;&gt; https://www.cnblogs.com/hongfei/archive/2013/06/18/3142162.html&lt;/a&gt; 转载&lt;/p&gt;
&lt;h2&gt;三丶分页管理机制&lt;/h2&gt;
&lt;p&gt;讲解分页管理机制之前,我们要明白以下几个关键词的意思.&lt;/p&gt;
&lt;p&gt;页码:&lt;/p&gt;
&lt;p&gt;　　在80386下,一个页的固定大小是4K个字节,也就是4096,一个页的辩解地址,不许死4K的倍数.&lt;/p&gt;
&lt;p&gt;所以4G大小的内存.就可以划分为1M个节. 而我们的页的开始一般具有一个特点.&lt;/p&gt;
&lt;p&gt;比如我们的虚拟地址:&lt;/p&gt;
&lt;p&gt;　　004010123,而页的首地址是00401000&lt;/p&gt;
&lt;p&gt;后12位都是0.&lt;/p&gt;
&lt;p&gt;所以我们把页的高20位称为页码.&lt;/p&gt;

&lt;p&gt;进程内存的保护.&lt;/p&gt;
&lt;p&gt;进程内存的保护就通过页的方式进行保护的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118014753818-555995507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 当我们的线性地址转化为物理地址的是否,会进行查表. 进而查询到物理地址是那个.&lt;/p&gt;
&lt;p&gt;微软采用的是这种方式.&lt;/p&gt;

&lt;p&gt; 线性地址转物理地址需要注意的页问题.&lt;/p&gt;
&lt;p&gt;这个问题则是页的映射.&lt;/p&gt;
&lt;p&gt;我们知道,页码是高20位,那么低12为就是偏移了.&lt;/p&gt;
&lt;p&gt;当32位的线性地址转为32为的物理地址的是否,只需要记录页码就可以了.低12位都是一样的.所以不用记录.&lt;/p&gt;
&lt;p&gt;比如线性地址:&lt;/p&gt;
&lt;p&gt;　　004010123 映射到物理地址 002010123&lt;/p&gt;
&lt;p&gt;那么我只需要记录前20位即可.&lt;/p&gt;
&lt;p&gt;　　004010  -&amp;gt; 002010   ,然后物理地址加上我们的后12位即可. 002010+123 = 002010123&lt;/p&gt;
&lt;h2&gt;四丶线性地址到物理地址的转换.&lt;/h2&gt;

&lt;p&gt;我们说过,操作系统为了隔离内存.采用了分页管理.而我们线性地址转化到物理地址的时候.&lt;/p&gt;
&lt;p&gt;则需要查表.&lt;/p&gt;
&lt;p&gt;那么我们觉着这个表应该怎么做?&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p&gt;物理地址&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p&gt;Xxxx&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p&gt;内存保护属性&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 类似于这样,我们只需要让虚拟地址当标进行查表即可.&lt;/p&gt;
&lt;p&gt;我们每一个进程都提供这样的一张表.但是在那个时代.资源是匮乏的.我们这样做.开不了几个进程内存就会耗光了.&lt;/p&gt;
&lt;p&gt;所以微软提供了自己的表.而硬件上也提供了支持.&lt;/p&gt;
&lt;p&gt;我们看下微软的表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118015700693-1503322998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们的CR3寄存器保存了表的首地址.&lt;/p&gt;
&lt;p&gt;这里有一个页目录表,还有页表的关键词.&lt;/p&gt;
&lt;p&gt;页目录表: 也称为PDE,而页表称之为PTE.&lt;/p&gt;
&lt;p&gt;CPU会通过虚拟地址,当作下表.去页目录表中查询.然后查到的结果再去页表中查询.这样就查到对应的物理地址了.&lt;/p&gt;
&lt;p&gt;PDE表的大小:&lt;/p&gt;
&lt;p&gt;　　页目录表,存储在一个4K字节的物理页中,其中每一项是4个字节.保存了页表的地址.&lt;/p&gt;
&lt;p&gt;　　而最大是1M个页.&lt;/p&gt;
&lt;p&gt;PTE表的大小.&lt;/p&gt;
&lt;p&gt;　　PTE的大小也和PDE一样的.&lt;/p&gt;
&lt;p&gt;微软为什么这样设计.有人会问.这样设计不就资源用的更多了吗.其实不是的. 虽然我们设计怎么大.&lt;/p&gt;
&lt;p&gt;但是通过两个表查询.可以映射4G内存.而上面的设计方法不行.&lt;/p&gt;

&lt;p&gt;表格式:&lt;/p&gt;

&lt;h2&gt;一丶查看GDT表.&lt;/h2&gt;
&lt;p&gt;我们通过WinDbg + 虚拟机可以进行双机调试.调试一下看下GDT表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118004330084-1487142799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道,GDT表中.存储的是存储段信息. 保存了一系列的段和内存的属性.&lt;/p&gt;
&lt;p&gt;但是微软并没有使用.&lt;/p&gt;
&lt;p&gt;我们可以通过ring3的段寄存器. 当作GDT表的下标.进行查表. 查询GDT表.&lt;/p&gt;
&lt;p&gt;例如我们用OD随便打开一个ring3的exe,然后看下段和虚拟地址.:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118004844318-529664131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虚拟地址: 0040256f  段选择子: cs:1B&lt;/p&gt;
&lt;p&gt;那么此时段选择字当下表.虚拟地址当作偏移.去查询GDT表&lt;/p&gt;
&lt;p&gt;下图为选择子结构&lt;/p&gt;
&lt;p&gt;段选择子结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118003848474-46604932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 首先先拆分选择子.&lt;/p&gt;
&lt;p&gt;1B =   0000000000011 011&lt;/p&gt;
&lt;p&gt;查询出来下表为3,那么去GDT表的第三项进行查找.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118011303381-1665941264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们从中取出段首地址 加上我们的偏移&lt;/p&gt;
&lt;p&gt;00000000  + 40256F = 0040256F(线性地址)&lt;/p&gt;
&lt;p&gt;那么通过查询GDT表.那么可以找到线性地址. 而我们GDT表,微软没有使用它来进行进程隔离. &lt;/p&gt;
&lt;p&gt;PS: 微软因为不使用GDT表进行进程隔离,所以段选择子都是一样的.基地址都是0,我们的虚拟地址就是线性地址.&lt;/p&gt;
&lt;p&gt;如果没有开分页保护.那么就是物理地址了.但是注意FS寄存器. FS寄存器很特殊.并不能说GDT表没用.&lt;/p&gt;
&lt;h2&gt;二丶控制寄存器CR0&lt;/h2&gt;
&lt;p&gt;我们上面说过.如果没有开启分页保护.那么虚拟地址就是线性地址,线性地址就是物理地址&lt;/p&gt;
&lt;p&gt;而微软是通过分页进行进程内存的隔离的.&lt;/p&gt;
&lt;p&gt;首先说一下什么分页的历史,和CR0控制寄存器.&lt;/p&gt;
&lt;p&gt;在保护模式下, 寄存器CR0的高位1表示开启分页.0表示不开启.&lt;/p&gt;
&lt;p&gt;而这个在操作系统初始化的是否就已经完成了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118012201053-941188018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们不开启,那么访问虚拟内存,就等价于访问物理内存了.&lt;/p&gt;
&lt;p&gt;但是我们的三环是不可以操作的.这个属于特权指令.如果用汇编进行操作.例如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
__asm mov cr0,8000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序会崩溃,提示你权限不够,并且报告错误码为 C096&lt;/p&gt;
&lt;p&gt;但是我们0环可以进行操作的.&lt;/p&gt;
&lt;p&gt;看一下CR0的结构:&lt;/p&gt;
&lt;p&gt;但是我们0环可以进行操作的.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118013214834-572972881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此图是从inter手册上截图下来的.有兴趣的可以查询CR0查看.&lt;/p&gt;
&lt;p&gt;刚才我们说的高位为1的是否就去掉分页保护,此时访问虚拟内存 等价于访问物理内存,其实我们修改的是PG位&lt;/p&gt;
&lt;p&gt;关于位怎么说的,inter手册也说.这里我总结一下重要的,如果不相信我可以查看inter手册.&lt;/p&gt;
&lt;p&gt;PG:  PG位表示是否分页管理机制是否有效. PG = 1,有效, PG = 0 无效.&lt;/p&gt;
&lt;p&gt;WP: Wp位 写保护位, WP为0禁用写保护,为1则启动  &lt;/p&gt;
&lt;p&gt;PS: 通过修改WP位可以进行过保护. 详情请看&lt;a target=&quot;_blank&quot;&gt; https://www.cnblogs.com/hongfei/archive/2013/06/18/3142162.html&lt;/a&gt; 转载&lt;/p&gt;
&lt;h2&gt;三丶分页管理机制&lt;/h2&gt;
&lt;p&gt;讲解分页管理机制之前,我们要明白以下几个关键词的意思.&lt;/p&gt;
&lt;p&gt;页码:&lt;/p&gt;
&lt;p&gt;　　在80386下,一个页的固定大小是4K个字节,也就是4096,一个页的辩解地址,不许死4K的倍数.&lt;/p&gt;
&lt;p&gt;所以4G大小的内存.就可以划分为1M个节. 而我们的页的开始一般具有一个特点.&lt;/p&gt;
&lt;p&gt;比如我们的虚拟地址:&lt;/p&gt;
&lt;p&gt;　　004010123,而页的首地址是00401000&lt;/p&gt;
&lt;p&gt;后12位都是0.&lt;/p&gt;
&lt;p&gt;所以我们把页的高20位称为页码.&lt;/p&gt;

&lt;p&gt;进程内存的保护.&lt;/p&gt;
&lt;p&gt;进程内存的保护就通过页的方式进行保护的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118014753818-555995507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 当我们的线性地址转化为物理地址的是否,会进行查表. 进而查询到物理地址是那个.&lt;/p&gt;
&lt;p&gt;微软采用的是这种方式.&lt;/p&gt;

&lt;p&gt; 线性地址转物理地址需要注意的页问题.&lt;/p&gt;
&lt;p&gt;这个问题则是页的映射.&lt;/p&gt;
&lt;p&gt;我们知道,页码是高20位,那么低12为就是偏移了.&lt;/p&gt;
&lt;p&gt;当32位的线性地址转为32为的物理地址的是否,只需要记录页码就可以了.低12位都是一样的.所以不用记录.&lt;/p&gt;
&lt;p&gt;比如线性地址:&lt;/p&gt;
&lt;p&gt;　　004010123 映射到物理地址 002010123&lt;/p&gt;
&lt;p&gt;那么我只需要记录前20位即可.&lt;/p&gt;
&lt;p&gt;　　004010  -&amp;gt; 002010   ,然后物理地址加上我们的后12位即可. 002010+123 = 002010123&lt;/p&gt;
&lt;h2&gt;四丶线性地址到物理地址的转换.&lt;/h2&gt;

&lt;p&gt;我们说过,操作系统为了隔离内存.采用了分页管理.而我们线性地址转化到物理地址的时候.&lt;/p&gt;
&lt;p&gt;则需要查表.&lt;/p&gt;
&lt;p&gt;那么我们觉着这个表应该怎么做?&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p&gt;物理地址&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p&gt;Xxxx&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p&gt;内存保护属性&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 类似于这样,我们只需要让虚拟地址当标进行查表即可.&lt;/p&gt;
&lt;p&gt;我们每一个进程都提供这样的一张表.但是在那个时代.资源是匮乏的.我们这样做.开不了几个进程内存就会耗光了.&lt;/p&gt;
&lt;p&gt;所以微软提供了自己的表.而硬件上也提供了支持.&lt;/p&gt;
&lt;p&gt;我们看下微软的表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118015700693-1503322998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们的CR3寄存器保存了表的首地址.&lt;/p&gt;
&lt;p&gt;这里有一个页目录表,还有页表的关键词.&lt;/p&gt;
&lt;p&gt;页目录表: 也称为PDE,而页表称之为PTE.&lt;/p&gt;
&lt;p&gt;CPU会通过虚拟地址,当作下表.去页目录表中查询.然后查到的结果再去页表中查询.这样就查到对应的物理地址了.&lt;/p&gt;
&lt;p&gt;PDE表的大小:&lt;/p&gt;
&lt;p&gt;　　页目录表,存储在一个4K字节的物理页中,其中每一项是4个字节.保存了页表的地址.&lt;/p&gt;
&lt;p&gt;　　而最大是1M个页.&lt;/p&gt;
&lt;p&gt;PTE表的大小.&lt;/p&gt;
&lt;p&gt;　　PTE的大小也和PDE一样的.&lt;/p&gt;
&lt;p&gt;微软为什么这样设计.有人会问.这样设计不就资源用的更多了吗.其实不是的. 虽然我们设计怎么大.&lt;/p&gt;
&lt;p&gt;但是通过两个表查询.可以映射4G内存.而上面的设计方法不行.&lt;/p&gt;

&lt;h2&gt;一丶查看GDT表.&lt;/h2&gt;
&lt;p&gt;我们通过WinDbg + 虚拟机可以进行双机调试.调试一下看下GDT表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118004330084-1487142799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道,GDT表中.存储的是存储段信息. 保存了一系列的段和内存的属性.&lt;/p&gt;
&lt;p&gt;但是微软并没有使用.&lt;/p&gt;
&lt;p&gt;我们可以通过ring3的段寄存器. 当作GDT表的下标.进行查表. 查询GDT表.&lt;/p&gt;
&lt;p&gt;例如我们用OD随便打开一个ring3的exe,然后看下段和虚拟地址.:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118004844318-529664131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虚拟地址: 0040256f  段选择子: cs:1B&lt;/p&gt;
&lt;p&gt;那么此时段选择字当下表.虚拟地址当作偏移.去查询GDT表&lt;/p&gt;
&lt;p&gt;下图为选择子结构&lt;/p&gt;
&lt;p&gt;段选择子结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118003848474-46604932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 首先先拆分选择子.&lt;/p&gt;
&lt;p&gt;1B =   0000000000011 011&lt;/p&gt;
&lt;p&gt;查询出来下表为3,那么去GDT表的第三项进行查找.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118011303381-1665941264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们从中取出段首地址 加上我们的偏移&lt;/p&gt;
&lt;p&gt;00000000  + 40256F = 0040256F(线性地址)&lt;/p&gt;
&lt;p&gt;那么通过查询GDT表.那么可以找到线性地址. 而我们GDT表,微软没有使用它来进行进程隔离. &lt;/p&gt;
&lt;p&gt;PS: 微软因为不使用GDT表进行进程隔离,所以段选择子都是一样的.基地址都是0,我们的虚拟地址就是线性地址.&lt;/p&gt;
&lt;p&gt;如果没有开分页保护.那么就是物理地址了.但是注意FS寄存器. FS寄存器很特殊.并不能说GDT表没用.&lt;/p&gt;
&lt;h2&gt;二丶控制寄存器CR0&lt;/h2&gt;
&lt;p&gt;我们上面说过.如果没有开启分页保护.那么虚拟地址就是线性地址,线性地址就是物理地址&lt;/p&gt;
&lt;p&gt;而微软是通过分页进行进程内存的隔离的.&lt;/p&gt;
&lt;p&gt;首先说一下什么分页的历史,和CR0控制寄存器.&lt;/p&gt;
&lt;p&gt;在保护模式下, 寄存器CR0的高位1表示开启分页.0表示不开启.&lt;/p&gt;
&lt;p&gt;而这个在操作系统初始化的是否就已经完成了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118012201053-941188018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们不开启,那么访问虚拟内存,就等价于访问物理内存了.&lt;/p&gt;
&lt;p&gt;但是我们的三环是不可以操作的.这个属于特权指令.如果用汇编进行操作.例如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
__asm mov cr0,8000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序会崩溃,提示你权限不够,并且报告错误码为 C096&lt;/p&gt;
&lt;p&gt;但是我们0环可以进行操作的.&lt;/p&gt;
&lt;p&gt;看一下CR0的结构:&lt;/p&gt;
&lt;p&gt;但是我们0环可以进行操作的.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118013214834-572972881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此图是从inter手册上截图下来的.有兴趣的可以查询CR0查看.&lt;/p&gt;
&lt;p&gt;刚才我们说的高位为1的是否就去掉分页保护,此时访问虚拟内存 等价于访问物理内存,其实我们修改的是PG位&lt;/p&gt;
&lt;p&gt;关于位怎么说的,inter手册也说.这里我总结一下重要的,如果不相信我可以查看inter手册.&lt;/p&gt;
&lt;p&gt;PG:  PG位表示是否分页管理机制是否有效. PG = 1,有效, PG = 0 无效.&lt;/p&gt;
&lt;p&gt;WP: Wp位 写保护位, WP为0禁用写保护,为1则启动  &lt;/p&gt;
&lt;p&gt;PS: 通过修改WP位可以进行过保护. 详情请看&lt;a target=&quot;_blank&quot;&gt; https://www.cnblogs.com/hongfei/archive/2013/06/18/3142162.html&lt;/a&gt; 转载&lt;/p&gt;
&lt;h2&gt;三丶分页管理机制&lt;/h2&gt;
&lt;p&gt;讲解分页管理机制之前,我们要明白以下几个关键词的意思.&lt;/p&gt;
&lt;p&gt;页码:&lt;/p&gt;
&lt;p&gt;　　在80386下,一个页的固定大小是4K个字节,也就是4096,一个页的辩解地址,不许死4K的倍数.&lt;/p&gt;
&lt;p&gt;所以4G大小的内存.就可以划分为1M个节. 而我们的页的开始一般具有一个特点.&lt;/p&gt;
&lt;p&gt;比如我们的虚拟地址:&lt;/p&gt;
&lt;p&gt;　　004010123,而页的首地址是00401000&lt;/p&gt;
&lt;p&gt;后12位都是0.&lt;/p&gt;
&lt;p&gt;所以我们把页的高20位称为页码.&lt;/p&gt;

&lt;p&gt;进程内存的保护.&lt;/p&gt;
&lt;p&gt;进程内存的保护就通过页的方式进行保护的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118014753818-555995507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 当我们的线性地址转化为物理地址的是否,会进行查表. 进而查询到物理地址是那个.&lt;/p&gt;
&lt;p&gt;微软采用的是这种方式.&lt;/p&gt;

&lt;p&gt; 线性地址转物理地址需要注意的页问题.&lt;/p&gt;
&lt;p&gt;这个问题则是页的映射.&lt;/p&gt;
&lt;p&gt;我们知道,页码是高20位,那么低12为就是偏移了.&lt;/p&gt;
&lt;p&gt;当32位的线性地址转为32为的物理地址的是否,只需要记录页码就可以了.低12位都是一样的.所以不用记录.&lt;/p&gt;
&lt;p&gt;比如线性地址:&lt;/p&gt;
&lt;p&gt;　　004010123 映射到物理地址 002010123&lt;/p&gt;
&lt;p&gt;那么我只需要记录前20位即可.&lt;/p&gt;
&lt;p&gt;　　004010  -&amp;gt; 002010   ,然后物理地址加上我们的后12位即可. 002010+123 = 002010123&lt;/p&gt;
&lt;h2&gt;四丶线性地址到物理地址的转换.&lt;/h2&gt;

&lt;p&gt;我们说过,操作系统为了隔离内存.采用了分页管理.而我们线性地址转化到物理地址的时候.&lt;/p&gt;
&lt;p&gt;则需要查表.&lt;/p&gt;
&lt;p&gt;那么我们觉着这个表应该怎么做?&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p&gt;物理地址&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p&gt;Xxxx&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p&gt;内存保护属性&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 类似于这样,我们只需要让虚拟地址当标进行查表即可.&lt;/p&gt;
&lt;p&gt;我们每一个进程都提供这样的一张表.但是在那个时代.资源是匮乏的.我们这样做.开不了几个进程内存就会耗光了.&lt;/p&gt;
&lt;p&gt;所以微软提供了自己的表.而硬件上也提供了支持.&lt;/p&gt;
&lt;p&gt;我们看下微软的表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118015700693-1503322998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们的CR3寄存器保存了表的首地址.&lt;/p&gt;
&lt;p&gt;这里有一个页目录表,还有页表的关键词.&lt;/p&gt;
&lt;p&gt;页目录表: 也称为PDE,而页表称之为PTE.&lt;/p&gt;
&lt;p&gt;CPU会通过虚拟地址,当作下表.去页目录表中查询.然后查到的结果再去页表中查询.这样就查到对应的物理地址了.&lt;/p&gt;
&lt;p&gt;PDE表的大小:&lt;/p&gt;
&lt;p&gt;　　页目录表,存储在一个4K字节的物理页中,其中每一项是4个字节.保存了页表的地址.&lt;/p&gt;
&lt;p&gt;　　而最大是1M个页.&lt;/p&gt;
&lt;p&gt;PTE表的大小.&lt;/p&gt;
&lt;p&gt;　　PTE的大小也和PDE一样的.&lt;/p&gt;
&lt;p&gt;微软为什么这样设计.有人会问.这样设计不就资源用的更多了吗.其实不是的. 虽然我们设计怎么大.&lt;/p&gt;
&lt;p&gt;但是通过两个表查询.可以映射4G内存.而上面的设计方法不行.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118020338803-1495463054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先前边20位保存了页表或者物理地址的基地址.&lt;/p&gt;
&lt;p&gt;比如我们的页目录表. 查到了第5项.那么从中取出千20位来,加上000就等于页表了. &lt;/p&gt;
&lt;p&gt;然后从页表中查询千20位.+虚拟地址的偏移就等价于实际的物理地址了.&lt;/p&gt;

&lt;p&gt;AVL 位: 可利用位.&lt;/p&gt;
&lt;p&gt;D    位: 表示这个分页是否写过.&lt;/p&gt;
&lt;p&gt;A   位: 表示这个分页是否读过&lt;/p&gt;
&lt;p&gt;U/S位: 表示这个分页是否用户可以访问还是ring0可以访问.&lt;/p&gt;
&lt;p&gt;R/W位: 内存保护位. 可读可写可执行. 还是可读可执行.&lt;/p&gt;
&lt;p&gt;P   位:   内存是否有效.&lt;/p&gt;

&lt;p&gt;R/W位: 注意我这里说的有两种方式. 可读可执行,和可读可写可执行.  有没有发现,我们的Ring3程序.不过是那个内存区域也好.都是可以读的.&lt;/p&gt;
&lt;p&gt;而我们Ring3下的修改内存分页保护属性,其实就是将这个页表的这个RW位进行置位.&lt;/p&gt;

&lt;p&gt;而我们的虚拟地址当作下表进行查表. 我们的虚拟地址不是分为了20位了吗. 前10位当作 页目录表的下表. 后10位当作页表的下表&lt;/p&gt;

&lt;p&gt;设有物理地址为:&lt;/p&gt;
&lt;p&gt;　　00401 000&lt;/p&gt;
&lt;p&gt;那么下表则为:&lt;/p&gt;
&lt;p&gt;　　00401 = 0000000001 0000000001&lt;/p&gt;
&lt;p&gt;通过虚拟地址得知,页目录表是第一项,而页表也是第一项.&lt;/p&gt;

&lt;p&gt;设页目录表第一项为&lt;/p&gt;
&lt;p&gt;　　　　003f0111,  此时页表为 取前20位,加上3个0.  003f0 + 000 = 003f0000&lt;/p&gt;
&lt;p&gt;设页表为&lt;br/&gt;　　      00201456, 此时取出前20位加上虚拟地址的后边20位偏移 物理地址= 00201 + 000 = 00201000,那么物理地址就是201000&lt;/p&gt;
&lt;p&gt;图示:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201801/1197364-20180118022031037-710995279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设虚拟地址为00402567H, 取出前20位. 分为高10位,和低10位做 PDE,和PTE的索引.&lt;/p&gt;
&lt;p&gt;然后进行查表.&lt;/p&gt;
&lt;p&gt;最后的通过PTE查询的高20位加上原虚拟地址的低12位, 然后就找到了物理地址.&lt;/p&gt;

</description>
<pubDate>Wed, 17 Jan 2018 18:18:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/8307728.html</dc:identifier>
</item>
<item>
<title>MVVM 框架解析之双向绑定 - 牧云云</title>
<link>http://www.cnblogs.com/MuYunyun/p/8306928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MuYunyun/p/8306928.html</guid>
<description>&lt;blockquote readability=&quot;3.6046511627907&quot;&gt;
&lt;p&gt;更好的阅读体验，点击 &lt;a href=&quot;http://muyunyun.cn/posts/384a97b3/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;mvvm-框架&quot;&gt;MVVM 框架&lt;/h3&gt;
&lt;p&gt;近年来前端一个明显的开发趋势就是架构从传统的 MVC 模式向 MVVM 模式迁移。在传统的 MVC 下，当前前端和后端发生数据交互后会刷新整个页面，从而导致比较差的用户体验。因此我们通过 Ajax 的方式和网关 REST API 作通讯，异步的刷新页面的某个区块，来优化和提升体验。&lt;/p&gt;
&lt;h4 id=&quot;mvvm-框架基本概念&quot;&gt;MVVM 框架基本概念&lt;/h4&gt;
&lt;p&gt;&lt;embed src=&quot;http://oqhtscus0.bkt.clouddn.com/203d14fb02edc5f37ae3841a2372434b.jpg-400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 MVVM 框架中，View(视图) 和 Modal(数据) 是不可以直接通讯的，在它们之间存在着 ViewModal 这个中间介充当着观察者的角色。当用户操作 View(视图)，ViewModal 感知到变化，然后通知 Modal 发生相应改变；反之当 Modal(数据) 发生改变，ViewModal 也能感知到变化，使 View 作出相应更新。这个一来一回的过程就是我们所熟知的双向绑定。&lt;/p&gt;
&lt;h4 id=&quot;mvvm-框架的应用场景&quot;&gt;MVVM 框架的应用场景&lt;/h4&gt;
&lt;p&gt;MVVM 框架的好处显而易见：当前端对数据进行操作的时候，可以通过 Ajax 请求对数据持久化，只需改变 dom 里需要改变的那部分数据内容，而不必刷新整个页面。特别是在移动端，刷新页面的代价太昂贵。虽然有些资源会被缓存，但是页面的 dom、css、js 都会被浏览器重新解析一遍，因此移动端页面通常会被做成 SPA 单页应用。由此在这基础上诞生了很多 MVVM 框架，比如 React.js、Vue.js、Angular.js 等等。&lt;/p&gt;
&lt;h3 id=&quot;mvvm-框架的简单实现&quot;&gt;MVVM 框架的简单实现&lt;/h3&gt;
&lt;p&gt;&lt;embed src=&quot;http://oqhtscus0.bkt.clouddn.com/195b692078c1f5c3807182321401b0fa.jpg-600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模拟 Vue 的双向绑定流，实现了一个简单的 &lt;a href=&quot;https://github.com/MuYunyun/mvvm&quot;&gt;MVVM 框架&lt;/a&gt;，从上图中可以看出虚线方形中就是之前提到的 ViewModal 中间介层，它充当着观察者的角色。另外可以发现双向绑定流中的 View 到 Modal 其实是通过 input 的事件监听函数实现的，如果换成 React(单向绑定流) 的话，它在这一步交给状态管理工具(比如 Redux)来实现。另外双向绑定流中的 Modal 到 View 其实各个 MVVM 框架实现的都是大同小异的，都用到的核心方法是 &lt;code&gt;Object.defineProperty()&lt;/code&gt;，通过这个方法可以进行数据劫持，当数据发生变化时可以捕捉到相应变化，从而进行后续的处理。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://oqhtscus0.bkt.clouddn.com/77034821ca0ddd1ed01460f143106ada.jpg-300&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;mvvm入口文件-的实现&quot;&gt;Mvvm(入口文件) 的实现&lt;/h4&gt;
&lt;p&gt;一般会这样调用 Mvvm 框架&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; vm &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Mvvm&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'#app'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mvvm title'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;dt&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mvvm name'&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
          &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这样子的话，如果要得到 title 属性就要形如 vm.data.title 这样取得，为了让 vm.title 就能获得 title 属性，从而在 Mvvm 的 prototype 上加上一个代理方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Mvvm&lt;/span&gt; (options) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;options&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; self &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;keys&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(key &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;proxyKeys&lt;/span&gt;(key)
  )
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;Mvvm&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;proxyKeys&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(key) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; self &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;defineProperty&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; key&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 这里的 get 和 set 实现了 vm.data.title 和 vm.title 的值同步&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;[key]
      &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (newValue) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;[key] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; newValue
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现了代理方法后，就步入主流程的实现&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Mvvm&lt;/span&gt; (options) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;options&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;observe&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;)
  &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Compile&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;options&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;observer观察者-的实现&quot;&gt;observer(观察者) 的实现&lt;/h4&gt;
&lt;p&gt;observer 的职责是监听 Modal(JS 对象) 的变化，最核心的部分就是用到了 Object.defineProperty() 的 get 和 set 方法，当要获取 Modal(JS 对象) 的值时，会自动调用 get 方法；当改动了 Modal(JS 对象) 的值时，会自动调用 set 方法；从而实现了对数据的劫持，代码如下所示。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;observe&lt;/span&gt;(data)

&lt;span class=&quot;va&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 值发生变化&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;observe&lt;/span&gt;(data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;data &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt;(data) &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'object'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; self &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;keys&lt;/span&gt;(data).&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(key &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;defineReactive&lt;/span&gt;(data&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; key&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; data[key])
  )
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;defineReactive&lt;/span&gt;(data&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; key&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;observe&lt;/span&gt;(value) &lt;span class=&quot;co&quot;&gt;// 遍历嵌套对象&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;defineProperty&lt;/span&gt;(data&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; key&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; value
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(newValue) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (value &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; newValue) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'值发生变化'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'newValue:'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; newValue &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;' '&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'oldValue:'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; value)
        value &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; newValue
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行代码，可以看到控制台输出 &lt;code&gt;值发生变化 newValue:1 oldValue:0&lt;/code&gt;，至此就完成了 observer 的逻辑。&lt;/p&gt;
&lt;h4 id=&quot;dep订阅者数组-和-watcher订阅者-的关系&quot;&gt;Dep(订阅者数组) 和 watcher(订阅者) 的关系&lt;/h4&gt;
&lt;p&gt;观测到变化后，我们总要通知给特定的人群，让他们做出相应的处理吧。为了更方便地理解，我们可以把订阅当成是订阅了一个微信公众号，当微信公众号的内容有更新时，那么它会把内容推送(update) 到订阅了它的人。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://oqhtscus0.bkt.clouddn.com/42bd217acd8b2ef5c76de1ca65ba7581.jpg-200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么订阅了同个微信公众号的人有成千上万个，那么首先想到的就是要 new Array() 去存放这些人(html 节点)吧。于是就有了如下代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// observer.js&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Dep&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;subs&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [] &lt;span class=&quot;co&quot;&gt;// 存放订阅者&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;Dep&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;addSub&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(sub) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 添加订阅者&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;subs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(sub)
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 通知订阅者更新&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;subs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(sub) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;sub&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;update&lt;/span&gt;()
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;observe&lt;/span&gt;(data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;...&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;defineReactive&lt;/span&gt;(data&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; key&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; dep &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Dep&lt;/span&gt;()
  &lt;span class=&quot;at&quot;&gt;observe&lt;/span&gt;(value) &lt;span class=&quot;co&quot;&gt;// 遍历嵌套对象&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;defineProperty&lt;/span&gt;(data&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; key&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;Dep&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;target&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 往订阅器添加订阅者&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;dep&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addSub&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;Dep&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;target&lt;/span&gt;)
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; value
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(newValue) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (value &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; newValue) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'值发生变化'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'newValue:'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; newValue &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;' '&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'oldValue:'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; value)
        value &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; newValue
        &lt;span class=&quot;va&quot;&gt;dep&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;notify&lt;/span&gt;()
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初看代码也比较顺畅了，但可能会卡在 &lt;code&gt;Dep.target&lt;/code&gt; 和 &lt;code&gt;sub.update&lt;/code&gt;，由此自然而然地将目光移向 watcher，&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// watcher.js&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Watcher&lt;/span&gt;(vm&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; exp&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; cb) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;vm&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; vm
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; exp
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; cb
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;Watcher&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;run&lt;/span&gt;()
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;

  &lt;span class=&quot;dt&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (value &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; oldVal) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;cb&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value) &lt;span class=&quot;co&quot;&gt;// 触发 compile 中的回调&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;

  &lt;span class=&quot;dt&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;Dep&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 缓存自己&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; value &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;vm&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exp&lt;/span&gt;] &lt;span class=&quot;co&quot;&gt;// 强制执行监听器里的 get 函数&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;Dep&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 释放自己&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; value
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从代码中可以看到当构造 Watcher 实例时，会调用 get() 方法，接着重点关注 &lt;code&gt;const value = this.vm.data[this.exp]&lt;/code&gt; 这句，前面说了当要获取 Modal(JS 对象) 的值时，会自动调用 Object.defineProperty 的 get 方法，也就是当执行完这句的时候，Dep.target 的值传进了 observer.js 中的 Object.defineProperty 的 get 方法中。同时也一目了然地在 Watcher.prototype 中发现了 update 方法，其作用即触发 compile 中绑定的回调来更新界面。至此解释了 Observer 中 Dep.target 和 sub.update 的由来。&lt;/p&gt;
&lt;p&gt;来归纳下 Watcher 的作用，其充当了 observer 和 compile 的桥梁。&lt;/p&gt;
&lt;p&gt;1 在自身实例化的过程中，往订阅器(dep) 中添加自己&lt;/p&gt;
&lt;p&gt;2 当 modal 发生变动，dep.notify() 通知时，其能调用自身的 update 函数，并触发 compile 绑定的回调函数实现视图更新&lt;/p&gt;
&lt;p&gt;最后再来看下生成 Watcher 实例的 compile.js 文件。&lt;/p&gt;
&lt;h4 id=&quot;compile编译-的实现&quot;&gt;compile(编译) 的实现&lt;/h4&gt;
&lt;p&gt;首先遍历解析的过程有多次操作 dom 节点，为提高性能和效率，会先将跟节点 el 转换成 fragment(文档碎片) 进行解析编译，解析完成，再将 fragment 添加回原来的真实 dom 节点中。代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Compile&lt;/span&gt;(el&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; vm) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;vm&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; vm
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;el&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;querySelector&lt;/span&gt;(el)
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fragment&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;init&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;Compile&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;el&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fragment&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;nodeToFragment&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;el&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// 将节点转为 fragment 文档碎片&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;compileElement&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fragment&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// 对 fragment 进行编译解析&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;appendChild&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fragment&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;nodeToFragment&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(el) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; fragment &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createDocumentFragment&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; child &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;firstChild&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// △ 第一个 firstChild 是 text&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt;(child) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;fragment&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;appendChild&lt;/span&gt;(child)
      child &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;firstChild&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; fragment
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;compileElement&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(el) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;...&lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个简单的 mvvm 框架在对 fragment 编译解析的过程中对 &lt;code&gt;{{}} 文本元素&lt;/code&gt;、&lt;code&gt;v-on:click 事件指令&lt;/code&gt;、&lt;code&gt;v-model 指令&lt;/code&gt;三种类型进行了相应的处理。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;30&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;Compile&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;el&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fragment&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;nodeToFragment&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;el&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// 将节点转为 fragment 文档碎片&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;compileElement&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fragment&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// 对 fragment 进行编译解析&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;appendChild&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fragment&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;nodeToFragment&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(el) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;...&lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;compileElement&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(el) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;...&lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;compileText&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (node&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; exp) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 对文本类型进行处理，将 {{abc}} 替换掉&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; self &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; initText &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;vm&lt;/span&gt;[exp]
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;updateText&lt;/span&gt;(node&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; initText) &lt;span class=&quot;co&quot;&gt;// 初始化&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Watcher&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; exp&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 实例化订阅者&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;updateText&lt;/span&gt;(node&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;

  &lt;span class=&quot;dt&quot;&gt;compileEvent&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (node&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; vm&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; exp&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; dir) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 对事件指令进行处理&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; eventType &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;dir&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;':'&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; cb &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;vm&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;methods&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;vm&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;methods&lt;/span&gt;[exp]

    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (eventType &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; cb) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addEventListener&lt;/span&gt;(eventType&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;cb&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bind&lt;/span&gt;(vm)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;

  &lt;span class=&quot;dt&quot;&gt;compileModel&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (node&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; vm&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; exp) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 对 v-model 进行处理&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; val &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; vm[exp]
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; self &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;modelUpdater&lt;/span&gt;(node&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; val)
    &lt;span class=&quot;va&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addEventListener&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'input'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (e) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; newValue &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;vm&lt;/span&gt;[exp] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; newValue &lt;span class=&quot;co&quot;&gt;// 实现 view 到 modal 的绑定&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上述代码的 compileTest 函数中看到了期盼已久的 Watcher 实例化，对 Watcher 作用模糊的朋友可以往上回顾下 Watcher 的作用。另外在 compileModel 函数中看到了本文最开始提到的双向绑定流中的 View 到 Modal 是借助 input 监听事件变化实现的。&lt;/p&gt;
&lt;h3 id=&quot;项目地址&quot;&gt;项目地址&lt;/h3&gt;
&lt;p&gt;本文记录了些阅读 mvvm 框架源码关于双向绑定的心得，并动手实践了一个简版的 mvvm 框架，不足之处在所难免，欢迎指正。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://muyunyun.cn/mvvm/&quot;&gt;项目演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MuYunyun/mvvm&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 16:21:00 +0000</pubDate>
<dc:creator>牧云云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MuYunyun/p/8306928.html</dc:identifier>
</item>
<item>
<title>聊聊C#与冲顶大会 - LightSmaile</title>
<link>http://www.cnblogs.com/LightSmile/p/8306869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LightSmile/p/8306869.html</guid>
<description>&lt;p&gt;一、由跳一跳开始&lt;/p&gt;
&lt;p&gt;2018年初，跳一跳小程序着实火了一把。一时间，各种攻略，甚至辅助工具也应运而生。作为.net阵营的一员，园友的这篇http://www.cnblogs.com/bqh10086/p/8253973.html跳一跳辅助程序文章，可以说是让人眼前一亮。实现思路大体如下：&lt;/p&gt;
&lt;p&gt;1.下载adb工具；&lt;/p&gt;
&lt;p&gt;2.打开手机usb调试模式；&lt;/p&gt;
&lt;p&gt;3.通过命令行调用adb工具，向手机发送命令&lt;/p&gt;
&lt;p&gt;    3.1发送截图命令&lt;/p&gt;
&lt;p&gt;    3.2将截图从手机复制到磁盘&lt;/p&gt;
&lt;p&gt;    3.3将手机截图绘制到winform窗体的PixtureBox&lt;/p&gt;
&lt;p&gt;    3.4鼠标左键单击小人底部，右键单击目标点&lt;/p&gt;
&lt;p&gt;    3.5将小人底部的点，目标点之间的距离转换为屏幕按压时间&lt;/p&gt;
&lt;p&gt;    3.6发送屏幕按压命令&lt;/p&gt;
&lt;p&gt;4.手动完成一次跳跃&lt;/p&gt;
&lt;p&gt;二、偶遇冲顶大会&lt;/p&gt;
&lt;p&gt;有意无意得总是遇见冲顶大会几个字，通过搜索后，发现是一款在线限时答题类app。每道题三个选项，10s内作答，共12道题目，去不答对以后与其他全答对的人均分奖金。奖金从50000-300000不等。&lt;/p&gt;
&lt;p&gt;https://livc.io/blog/204?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io 这篇文章提供了一个答题辅助思路：&lt;/p&gt;
&lt;p&gt;1.截取手机屏幕图片&lt;/p&gt;
&lt;p&gt;2.识别截图中的题目&lt;/p&gt;
&lt;p&gt;3.调用浏览器，搜索题目&lt;/p&gt;
&lt;p&gt;不过，此思路是基于ios手机操作系统，采用 iOS + Mac+WDA+免费ocr识别来实现的。&lt;/p&gt;
&lt;p&gt;三、跳一跳与冲顶大会&lt;/p&gt;
&lt;p&gt;本着生命在于折腾的原则，想着在android手机操作系统+windows操作系统上也能实现一个答题辅助工具。借（剽）鉴（窃）上面的实现思路，说下，具体的实现过程。&lt;/p&gt;
&lt;p&gt;1.发送获取屏幕截图命令 ”adb &lt;span class=&quot;pl-s&quot;&gt;shell screencap -p /sdcard/xxx.png”&lt;span class=&quot;pl-pds&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-s&quot;&gt;2.发送将手机截图复制到本地磁盘的命令  ”&lt;span class=&quot;pl-s&quot;&gt;pull /sdcard/xxx.png&lt;span class=&quot;pl-pds&quot;&gt;&quot; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;3.获取题目所在区域&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;    3.1 自己的手机屏幕分辨率为1080*1920，手机截图长度为16.5cm，题目开始出现的位置距离图片顶部为3cm,题目宽度大概为2cm（题目为2行文字），这一步，跳一跳辅助工具已经实现了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;    3.2 调用算法，从手机截图中截取题目所在区域大小的图片 &lt;span class=&quot;pl-en&quot;&gt;Bitmap &lt;span class=&quot;pl-en&quot;&gt;map = GetPart(file, &lt;span class=&quot;pl-c1&quot;&gt;0, &lt;span class=&quot;pl-c1&quot;&gt;0, &lt;span class=&quot;pl-c1&quot;&gt;1080, (&lt;span class=&quot;pl-k&quot;&gt;int)(&lt;span class=&quot;pl-c1&quot;&gt;1920 * (&lt;span class=&quot;pl-c1&quot;&gt;5.5 - &lt;span class=&quot;pl-c1&quot;&gt;3) / &lt;span class=&quot;pl-c1&quot;&gt;16.5), &lt;span class=&quot;pl-c1&quot;&gt;0, (&lt;span class=&quot;pl-k&quot;&gt;int)(&lt;span class=&quot;pl-c1&quot;&gt;1920 * &lt;span class=&quot;pl-c1&quot;&gt;3 / &lt;span class=&quot;pl-c1&quot;&gt;16.5))；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_7c110dc9-43c9-46c2-ba35-958daec0876d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7c110dc9-43c9-46c2-ba35-958daec0876d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7c110dc9-43c9-46c2-ba35-958daec0876d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取图片指定部分
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;图片路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pPartStartPointX&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;目标图片开始绘制处的坐标X值(通常为0)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pPartStartPointY&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;目标图片开始绘制处的坐标Y值(通常为0)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pPartWidth&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;目标图片的宽度&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pPartHeight&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;目标图片的高度&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pOrigStartPointX&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;原始图片开始截取处的坐标X值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pOrigStartPointY&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;原始图片开始截取处的坐标Y值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;  Bitmap GetPart(&lt;span&gt;string&lt;/span&gt; pPath, &lt;span&gt;int&lt;/span&gt; pPartStartPointX, &lt;span&gt;int&lt;/span&gt; pPartStartPointY, &lt;span&gt;int&lt;/span&gt; pPartWidth, &lt;span&gt;int&lt;/span&gt; pPartHeight, &lt;span&gt;int&lt;/span&gt; pOrigStartPointX, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pOrigStartPointY)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             Image originalImg =&lt;span&gt; Image.FromFile(pPath);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             Bitmap partImg = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bitmap(pPartWidth, pPartHeight);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             Graphics graphics =&lt;span&gt; Graphics.FromImage(partImg);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             Rectangle destRect = &lt;span&gt;new&lt;/span&gt; Rectangle(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point(pPartStartPointX, pPartStartPointY), 
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; Size(pPartWidth, pPartHeight));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标位置&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             Rectangle origRect = &lt;span&gt;new&lt;/span&gt; Rectangle(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point(pOrigStartPointX, pOrigStartPointY), 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; Size(pPartWidth, pPartHeight));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原图位置（默认从原图中截取的图片大小等于目标图片的大小）&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            graphics.DrawImage(originalImg, destRect, origRect, GraphicsUnit.Pixel);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; partImg;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;GetPartPicture&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;    3.3 使用开源ocr识别库Tesseract，识别上一步截图map中的题目&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_d7bd6ae4-28d0-40fc-86b6-24cbc45a2ced&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d7bd6ae4-28d0-40fc-86b6-24cbc45a2ced&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d7bd6ae4-28d0-40fc-86b6-24cbc45a2ced&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;      
&lt;span&gt; 2&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetOcrText(&lt;span&gt;string&lt;/span&gt; startPath,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; fileName)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(fileName))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 
&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; engine = &lt;span&gt;new&lt;/span&gt; TesseractEngine(startPath + &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;/tessdata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chi_sim&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, EngineMode.Default))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; img =&lt;span&gt; Pix.LoadFromFile(fileName))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; page =&lt;span&gt; engine.Process(img))
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                             result =&lt;span&gt; page.GetText();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;             
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;GetOcrText&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;    3.4 去除题目中的换行，处理特殊字符。&lt;/p&gt;
&lt;p&gt;    3.5调用浏览器，搜索题目&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_c5dfbd1c-8b1b-4891-be28-094a0530a706&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c5dfbd1c-8b1b-4891-be28-094a0530a706&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c5dfbd1c-8b1b-4891-be28-094a0530a706&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Search(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; searchContent)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             
&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;s就是你的默认浏览器，不过后面带了参数，把它截去，不过需要注意的是：不同的浏览器后面的参数不一样！  
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;D:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot; -- &quot;%1&quot;  &lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;             Process.Start(browserPath, &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.baidu.com/s?wd={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, searchContent));
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Search&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;四、问题&lt;/p&gt;
&lt;p&gt;1.问题1：题目所在区域的获取，题目有时为一行，有时为两行，图片大小不太固定&lt;/p&gt;
&lt;p&gt;2.问题2：从获取发送截图命令，将截图复制到本地磁盘，截取题目所在区域大小图片，识别图片中题目内容，调用浏览器搜索，呈现搜索结果共耗时6s左右，答题时间仅有10s，有点不太够用&lt;/p&gt;
&lt;p&gt;五、总结&lt;/p&gt;
&lt;p&gt;虽然，到头来结果不是太理想，但这个举一反三的探索过程却是有收获的。从一开始ocr识别不支持中文，到Tesseract库项目编译失败，再到搜索Tesseract支持的中文识别依赖文件&lt;a id=&quot;0ac8b7b83e198f1456c5a55e48e86449-c58c6c172915a3d73a111dcb633557bfe48eb6fa&quot; class=&quot;js-navigation-open&quot; title=&quot;chi_sim.traineddata&quot; href=&quot;https://github.com/LightSmileMu/JumpToTop/blob/master/JumpToTop/tessdata/chi_sim.traineddata&quot;&gt;chi_sim.traineddata&lt;/a&gt;，是解决问题能力的锻炼，也是涨姿势的过程。总的来说还不错。欢迎交流，欢迎点赞。&lt;/p&gt;
&lt;p&gt;项目地址：https://github.com/LightSmileMu/JumpToTop&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 15:47:00 +0000</pubDate>
<dc:creator>LightSmaile</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LightSmile/p/8306869.html</dc:identifier>
</item>
<item>
<title>K：平衡二叉树(AVL) - 林学徒</title>
<link>http://www.cnblogs.com/MyStringIsNotNull/p/8306848.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MyStringIsNotNull/p/8306848.html</guid>
<description>&lt;h3 id=&quot;相关介绍&quot;&gt;相关介绍：&lt;/h3&gt;
&lt;p&gt; 二叉查找树的查找效率与二叉树的形状有关，对于按给定序列建立的二叉排序树，若其左、右子树均匀分布，则查找过程类似于有序表的二分查找，时间复杂度变为O(log2n)。当若给定序列原来有序，则建立的二叉查找树就蜕化为单链表，其查找效率同顺序查找一样，时间复杂度为O（n）。因此，在构造二叉查找树的过程中，当出现左右子树分布不均匀时，若能对其进行调整，使其依然保持均匀，则就能有效的保证二叉查找树仍具有较高的查找效率。而平衡二叉树，正是这样的一棵树。&lt;/p&gt;
&lt;p&gt; 平衡二叉树，又称为AVL树，它或是一棵空树，或是一棵具有如下性质的二叉树:它的左子树和右子树均为平衡二叉树，且左子树和右子树深度之差的绝对值不超过1&lt;/p&gt;
&lt;p&gt; 在平衡二叉树上插入或删除节点后，可能使二叉树失去平衡。因此，需要对失去平衡的二叉树进行调整，以保持平衡二叉树的性质。以下，主要介绍如何动态地使一棵二叉查找树保持平衡，即对失去平衡的二叉查找树进行平衡化调整。这里引入了&lt;strong&gt;平衡因子&lt;/strong&gt;的概念。&lt;/p&gt;
&lt;p&gt; 所谓的平衡因子，指的是二叉树中某个节点的左子树深度与右子树深度之差，平衡因子也称为平衡度。平衡二叉树也就是树中任意节点的平衡因子的绝对值小于等于1的二叉树。在AVL树中的节点的平衡因子有3种取值情况：1(左子树深度大于右子树深度)，0(左子树深度等于右子树深度)，-1(左子树深度小于右子树深度)&lt;/p&gt;
&lt;p&gt;在以下给出的例子中，为了叙述方便，假设在AVL树上因插入新节点而失去平衡的最小子树的根节点为A，即A为距离插入节点最近的，平衡因子不是-1、0和1的节点。失去平衡后的操作可 &lt;strong&gt;依据失去平衡的原因(此处为便于记忆的诀窍的一个关键，如“LL型平衡旋转”，指的是，在A的左孩子节点(L)的左孩子节点（L）中插入一个新的节点所导致的不平衡问题)&lt;/strong&gt; 归纳为下列4种情况分别进行介绍：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LL型平衡旋转(单向右旋)：由于在A的左孩子的左子树上插入新节点，使得A的平衡度由1增加至2，致使以A为根的子树失去平衡。此时，应该进行一次向右的顺时针旋转操作，“提升”B（即为A的左孩子）为新子树的根节点，A下降为B的右孩子，同时将B原来的右子树B-R调整为A的左子树。其过程如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117233710459-2062736009.png&quot; alt=&quot;LL型平衡旋转&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RR型平衡旋转(单向左旋):由于在A的右孩子的右子树上插入新节点，使得A的平衡度由-1转变为-2，致使以A为根的子树失去平衡。此时，应该进行一次的向左的逆时针旋转操作，“提升”B(即A的右孩子)为新子树的根节点，A下降为B的左子树，同时将B原来的左子树B-L调整为A的右子树。其过程如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117233755631-1087190624.png&quot; alt=&quot;RR型平衡旋转&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LR型平衡旋转(先左旋后右旋)：由于在A的左孩子的右子树上插入新节点，使得A的平衡度由1变为2，致使以A为根的子树失去平衡。此时，应当进行两次选装操作（先逆时针，后顺时针）“提升”C（即A的左孩子的右孩子）为新子树的根节点；A下降为C的右孩子；B变为C的左孩子；C原来的左子树C-L调整为B现在的右子树；C原来的右子树C-R调整为A的左子树。其过程如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117233847334-1077663180.png&quot; alt=&quot;LR型平衡旋转,变为B的右子树&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117233922615-1948736469.png&quot; alt=&quot;LR型平衡旋转,变为A的左子树&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RL型平衡旋转（先右旋后左旋）：由于在A的右孩子的左子树上插入新节点，使A的平衡度由-1变为-2，致使以A为根的子树失去平衡，此时，应进行两次旋转操作（先顺时针，后逆时针），“提升”C（即A的右孩子的左孩子）为新子树的根节点；A下降为C的左孩子；B变为C的右孩子；C原来的左子树C-L调整为A现在的右子树；C原来的右子树C-R调整为B的左子树。其过程如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117234003349-1883853452.png&quot; alt=&quot;RL型平衡旋转，变为B的左子树&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117234038021-74697466.png&quot; alt=&quot;RL型平衡旋转，变为A的右子树&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综上所述&lt;/strong&gt;：在平衡二叉查找树T上插入一个新记录x的算法描述如下：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li&gt;若AVL树为空树，则插入一个记录为x的新节点作为T的根节点，树的深度增加1。&lt;/li&gt;
&lt;li&gt;若x的关键字值和AVL树T的根节点的关键字值相等，则不进行插入操作。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;若X的关键字值小于AVL树的根节点的关键字值，则将x插入在该树的左子树上，并且当插入之后的左子树深度增加1时，分别就下列不同情况进行处理：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;若AVL树的根节点的平衡因子为-1（右子树的深度大于左子树的深度），则将根节点的平衡因子调整为0，并且树的深度不变&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;若AVL树的根节点的平衡因子为0（左右子树的深度相等）。则将根节点的平衡因子调整为1，树的深度同时增加1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;若AVL树的根节点的平衡因子为1（左子树的深度大于右子树的深度），则当该树的左子树的根节点的平衡因子为1时需要进行LL型平衡旋转；当该树的左子树的根节点的平衡因子为-1时需进行LR型平衡旋转&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;若x的关键字值大于AVL树的根节点的关键字值，则将x插入在该树的右子树上，并且当插入之后的右子树深度增加1时，分别就下列不同情况进行处理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;若AVL树的根节点的平衡因子为-1时（右子树的深度大于左子树的深度），则当该树的右子树的根节点的平衡因子为-1时需进行RR型平衡旋转；当该树的右子树的根节点的平衡因子为1时需进行RL型平衡旋转&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;2.若AVL树的根节点的平衡因子为0时（左右子树的深度相等），则将根节点的平衡因子调整为-1，树的深度同时增加1&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;若AVL树的根节点的平衡因子为1时（左子树的深度大于右子树的深度），则将根节点的平衡因子调整为0，并且树的深度保持不变&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;平衡二叉树的优缺点分析&quot;&gt;平衡二叉树的优缺点分析：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：使二叉树的结构更好(即不会出现“偏拐”严重的情况)，从而提高了查找操作的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：使插入和删除操作复杂化，从而减低了插入和删除操作的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：平衡二叉树适用于二叉查找树一经建立就很少进行插入和删除操作，而主要进行查找操作的应用场合上。由于其在查找过程中和给定值进行比较的关键字个数不超过树的深度。因此，在平衡二叉树上进行查找的时间复杂度为O（log2n）&lt;/p&gt;
&lt;h4 id=&quot;相关操作示例代码&quot;&gt;相关操作示例代码：&lt;/h4&gt;
&lt;p&gt; 对于平衡二叉树，其常见的操作有插入、删除、查找操作。其中，插入和删除某个节点时，需要对失去平衡的平衡二叉查找树进行相应的旋转操作，以使平衡二叉树保持结构上的稳定。&lt;/p&gt;
&lt;p&gt;下面代码定义了平衡二叉查找树的节点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;相关代码：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 该类用于定义平衡二叉树的节点的相关数据
 * @author 学徒
 *
 */
class AVLTreeNode
{
    //节点的关键字
    Comparable key;
    //节点的数据
    Object data;
    //节点的左子树指针
    AVLTreeNode left;
    //节点的右子树指针
    AVLTreeNode right;
    
    public AVLTreeNode(Comparable key,Object data)
    {
        this(key,data,null,null);
    }
    public AVLTreeNode(Comparable key,Object data,AVLTreeNode left,AVLTreeNode right)
    {
        this.data=data;
        this.key=key;
        this.left=left;
        this.right=right;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 对于查找操作，其先与根节点的关键字的值进行比较，根据比较所得的结果，选择返回其相关的数据或者是递归的在该节点的左右子树中进行查找&lt;/p&gt;
&lt;p&gt;下面代码演示了查找的操作：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;相关代码：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 用于平衡二叉树中的查找操作，并返回相应节点的相关数据，当未查找到时，返回null
 * @param key 要进行查找的节点的关键字
 * @return 得到要进行查找节点的相关数据
 */
public Object search(Comparable key)
{
    if(key==null)
        return null;
    return getSearchResult(root,key);
}

/**
 * 用于辅助平衡二叉树的查找操作，并返回相应的相关节点的数据，当未查找到时，返回null
 * @param root 要进行查找的二叉查找树的根节点
 * @param key 要进行查找的节点的关键字
 * @return 得到要进行查找节点的相关数据
 */
private Object getSearchResult(AVLTreeNode root,Comparable key)
{
    if(root==null)
        return null;
    int compare=key.compareTo(root.key);
    if(compare==0)
        return root.data;
    else if(compare==1)
        return getSearchResult(root.right,key);
    else
        return getSearchResult(root.left,key);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 对于插入操作，先根据其关键字值的大小关系，在平衡二叉树中插入相应的节点。之后，遍历该新插入节点的路径中各个根节点的平衡因子的情况，根据其平衡因子的值，选择性的对其进行旋转操作，需要注意的是在该路径上最多只存在一次“失衡”的情况。为此，在对其路径上的节点进行过旋转操作之后，其平衡二叉树整体便是处于“平衡”的状态的&lt;/p&gt;
&lt;p&gt;下面代码演示了插入操作：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;相关代码：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 用于往二叉树中插入新的节点
 * @param key 二叉树中新节点的关键字
 * @param data 二叉树中新节点的数据
 * @return 插入新节点的结果，如果成功插入一个新节点则返回true，否则返回false，当新增的节点存在于树中时，返回false
 */
public boolean insert(Comparable key,Object data)
{
    if(key==null)
        return false;
    else if(root!=null)
    {
        return insertAVLTreeNode(root,null,key,data);
    }
    else
    {
        root=new AVLTreeNode(key,data);
        return true;
    }
}

/**
 * 辅助往二叉树中插入新的节点
 * @param node 要进行比较的二叉树的节点
 * @param parent 要进行比较的二叉树的节点的父节点
  * @param key 新增节点的关键字值
 * @param data 新增节点的数据
 * @return 新增的结果
 */
private boolean insertAVLTreeNode(AVLTreeNode node,AVLTreeNode parent,Comparable key,Object data)
{
    //当当前比较的节点不为空的时候，进行比较操作
    if(node!=null)
    {
        int compare=key.compareTo(node.key);
        if(compare==0)
            return false;
        else if(compare&amp;gt;0)
            return insertAVLTreeNode(node.right,node,key,data);
        else
            return insertAVLTreeNode(node.left,node,key,data);
    }
    //当前的节点为空的时候，进行从其父节点处插入节点的操作。同时，进行旋转判断和相应的操作
    else
    {
        Comparable parentKey=parent.key;
        AVLTreeNode newNode=new AVLTreeNode(key,data);
        int comparable=parentKey.compareTo(key);
        //插入新增节点
        if(comparable&amp;gt;0)
            parent.left=newNode;
        else
            parent.right=newNode;
        //对插入完后的节点进行判断，查看其是否需要进行旋转操作，当需要时，对其进行进行旋转调整平衡二叉树相应的节点情况
        rotate(root,null,newNode);
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 对于删除操作，其只需要在二叉树中找到要进行删除的节点的父节点。之后移动相应的指针即可对其进行删除操作，同时用其按照关键字有序的后继节点对其进行补充即可，之后从对到其进行删除节点的父节点的路径上的所有节点进行遍历，当存在因为删除节点而导致其失去平衡的情况，则对其进行相应的平衡旋转操作&lt;/p&gt;
&lt;p&gt;下面代码演示了删除操作：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;相关代码：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 用于进行删除操作
 * @param key 要进行删除操作的节点的关键字值
 * @return 返回所删除节点的数据值,当无相关的删除节点的时候，返回null
 */
public Object delete(Comparable key)
{
    if(key==null)
        return null;
    else
        return remove(root,key,null);
}
/**
 * 用于辅助进行删除操作的方法
 * @param node 当前比较节点
 * @param parent 当前比较节点的双亲节点
 * @param key 需要进行删除的节点的关键字值
 * @return 返回所删除节点的关键字
 */
public Object remove(AVLTreeNode node,Comparable key,AVLTreeNode parent)
{
    if (node != null)
    {
        int compare = key.compareTo(node.key);
        // 从左子树中进行删除
        if (compare &amp;lt; 0)
        {
            return remove(node.left, key, node);
        }
        // 从右子树中进行删除
        else if (compare &amp;gt; 0)
        {
            return remove(node.right, key, node);
        }
        // 当前节点即为要进行删除的节点
        else
        {
            // 当前要进行删除的节点的数据
            Object result = node.data;
            // 当前要进行删除的节点的左右子树均存在
            if (node.left != null &amp;amp;&amp;amp; node.right != null)
            {
                // 寻找要进行删除节点的替换节点
                AVLTreeNode innext = node.right;
                //要进行替换的节点的双亲节点
                AVLTreeNode innextParent=node;
                // 寻找右子树下的最左孩子节点
                while (innext.left != null)
                {
                    innextParent=innext;
                    innext = innext.left;
                }
                // 改变删除节点的相关数据
                node.data = innext.data;
                node.key = innext.key;
                //递归的删除其进行替换的节点  
                remove(node.right,innext.key,node);
                //对从当前被删除节点开始的到其相应的替换节点的父节点的路径上判断其是否“失衡”且进行相关的旋转操作
                rotate(node,null,innextParent);
            }
            // 以下考虑的情况均当前删除节点缺少左子树或者右子树的情况
            else
            {
                // 当前要进行删除的节点不为根节点的时候
                if (parent != null)
                {
                    // 当左子树不为空的时候
                    if (node.left != null &amp;amp;&amp;amp; node.right == null)
                    {
                        // 当前节点为其左子树节点的时候
                        if (node == parent.left)
                        {
                            parent.left = node.left;
                        }
                        // 当前节点为其右子树节点的时候
                        else
                        {
                            parent.right = node.left;
                        }
                        if(node.left!=null)
                        {
                            //由于其删除节点缺少左子树或者右子树。为此，其只需判断当前删除节点的父节点的失衡情况并进行相应的调整即可
                            rotate(parent,null,node.left);
                        }
                    }
                    // 当右子树不为空的时候或为叶子节点的时候
                    else
                    {
                        // 当前节点为其左子树节点的时候
                        if (node == parent.left)
                        {
                            parent.left = node.right;
                        }
                        // 当前节点为其右子树节点的时候
                        else
                        {
                            parent.right = node.right;
                        }
                        if(node.right!=null)
                        {
                            //由于其删除节点缺少左子树或者右子树。为此，其只需判断当前删除节点的父节点的失衡情况并进行相应的调整即可
                            rotate(parent,null,node.right);
                        }
                    }
                    
                }
                // 当前删除的节点为根节点的时候
                else
                {
                    if (node.left != null)
                        root = node.left;
                    else
                        root = node.right;
                }
            }
            // 返回其进行删除的节点的值
            return result;
        }
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整示例代码如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;相关代码：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package all_in_tree;
/**
 * 该类用于演示平衡二叉树的相关操作
 * @author 学徒
 *
 */
public class AVLTree
{
    //该平衡二叉树的根节点
    private AVLTreeNode root;
    
    /**
     * 对该平衡二叉树进行后续遍历操作(后序遍历的结果是按序排序的)，以便用于验证其测试的结果
     */
    public static void inTravel(AVLTreeNode root)
    {
        if(root!=null)
        {
            inTravel(root.left);
            System.out.print(root.key+&quot;-&quot;+root.data+&quot;\t&quot;);
            inTravel(root.right);
            
        }
    }
    
    /**
     * 用于获取该平衡二叉树
     * @return 该平衡二叉树的根节点指针
     */
    public AVLTreeNode getTree()
    {
        return this.root;
    }
    
    /**
     * 用于得到一棵以root为根节点的树的深度
     * @param root 需要获取的树的深度的根节点指针
     * @return 以root为根节点的树的深度
     */
    private int getDepth(AVLTreeNode root)
    {
        if(root==null)
            return 0;
        return Math.max(getDepth(root.left),getDepth(root.right))+1;
    }
    
    /**
     * 用于判断以root为根节点的二叉树的平衡情况，true为平衡的，false表示并不平衡
     * @param root 要判断其平衡因子的子树的根节点指针
     * @return 以root为根节点的平衡二叉树的平衡情况
     */
    private boolean isBalance(AVLTreeNode root)
    {
        return Math.abs(getDepth(root.left)-getDepth(root.right))&amp;lt;=1;
    }
    
    /**
     * 用于获取以root为根节点的二叉树的平衡因子
     * @param root为求取其平衡因子的子树的根节点的指针
     * @return 平衡因子
     */
    private int getBalance(AVLTreeNode root)
    {
        return getDepth(root.left)-getDepth(root.right);
    }
    
    /**
     * 用于平衡二叉树中的查找操作，并返回相应节点的相关数据，当未查找到时，返回null
     * @param key 要进行查找的节点的关键字
     * @return 得到要进行查找节点的相关数据
     */
    public Object search(Comparable key)
    {
        if(key==null)
            return null;
        return getSearchResult(root,key);
    }
    
    /**
     * 用于辅助平衡二叉树的查找操作，并返回相应的相关节点的数据，当未查找到时，返回null
     * @param root 要进行查找的二叉查找树的根节点
     * @param key 要进行查找的节点的关键字
     * @return 得到要进行查找节点的相关数据
     */
    private Object getSearchResult(AVLTreeNode root,Comparable key)
    {
        if(root==null)
            return null;
        int compare=key.compareTo(root.key);
        if(compare==0)
            return root.data;
        else if(compare==1)
            return getSearchResult(root.right,key);
        else
            return getSearchResult(root.left,key);
    }
    
    /**
     * 以所传入的节点的指针为根节点的二叉树，进行右旋的操作
     * @param node 要进行右旋的二叉树的根节点
     * @return 旋转后的二叉树的根节点的指针
     */
    private AVLTreeNode rightRotate(AVLTreeNode node)
    {
        //用于记录旋转后的结果
        AVLTreeNode result=node.left;
        node.left=result.right;
        result.right=node;
        return result;
    }
    
    /**
     * 以所传入的节点的指针为根节点的二叉树，进行左旋的操作
     * @param node 要进行左旋的二叉树的根节点
     * @return 旋转后的二叉树的根节点的指针
     */
    private AVLTreeNode leftRotate(AVLTreeNode node)
    {
        //用于记录旋转后的结果
        AVLTreeNode result=node.right;
        node.right=result.left;
        result.left=node;
        return result;
    }
    
    /**
     * 用于往二叉树中插入新的节点
     * @param key 二叉树中新节点的关键字
     * @param data 二叉树中新节点的数据
     * @return 插入新节点的结果，如果成功插入一个新节点则返回true，否则返回false，当新增的节点存在于树中时，返回false
     */
    public boolean insert(Comparable key,Object data)
    {
        if(key==null)
            return false;
        else if(root!=null)
        {
            return insertAVLTreeNode(root,null,key,data);
        }
        else
        {
            root=new AVLTreeNode(key,data);
            return true;
        }
    }
    
    /**
     * 辅助往二叉树中插入新的节点
     * @param node 要进行比较的二叉树的节点
     * @param parent 要进行比较的二叉树的节点的父节点
     * @param key 新增节点的关键字值
     * @param data 新增节点的数据
     * @return 新增的结果
     */
    private boolean insertAVLTreeNode(AVLTreeNode node,AVLTreeNode parent,Comparable key,Object data)
    {
        //当当前比较的节点不为空的时候，进行比较操作
        if(node!=null)
        {
            int compare=key.compareTo(node.key);
            if(compare==0)
                return false;
            else if(compare&amp;gt;0)
                return insertAVLTreeNode(node.right,node,key,data);
            else
                return insertAVLTreeNode(node.left,node,key,data);
        }
        //当前的节点为空的时候，进行从其父节点处插入节点的操作。同时，进行旋转判断和相应的操作
        else
        {
            Comparable parentKey=parent.key;
            AVLTreeNode newNode=new AVLTreeNode(key,data);
            int comparable=parentKey.compareTo(key);
            //插入新增节点
            if(comparable&amp;gt;0)
                parent.left=newNode;
            else
                parent.right=newNode;
            //对插入完后的节点进行判断，查看其是否需要进行旋转操作，当需要时，对其进行进行旋转调整平衡二叉树相应的节点情况
            rotate(root,null,newNode);
            return true;
        }
    }
    
    /**
     * 用于辅助新插入节点是否旋转的判断，并作出相应的操作
     * @param root 当前查找的节点的情况
     * @param parent 当前查找节点的双亲节点
     * @param node 进行旋转操作的路径的终止节点
     */
    private void rotate(AVLTreeNode root,AVLTreeNode parent,AVLTreeNode node)
    {
        //由此得出当前查找节点的查找方向
        int compare=root.key.compareTo(node.key);
        //当找到该新增节点的时候，其路径上的各个节点的平衡因子均不“失衡”则直接进行返回,不进行操作
        if(compare==0)
        {
            return;
        }
        //当平衡且当前节点的关键字值小于新增节点的关键字值的时候，往右边进行查找
        else if(compare&amp;lt;0&amp;amp;&amp;amp;isBalance(root))
        {
            //当其路径上的根节点平衡的时候，往右边查找
            rotate(root.right,root,node);
        }
        //当平衡且当前节点的关键字值大于新增节点的关键字值的时候，往左边进行查找
        else if(compare&amp;gt;0&amp;amp;&amp;amp;isBalance(root))
        {
            //当其路径上的子树的根节点平衡的时候，往左边进行查找
            rotate(root.left,root,node);
        }
        //当失衡的时候，对其进行旋转操作
        else 
        {
            //当其父节点为null的时候，不需要对其进行旋转操作，因为此时表示树中的节点数目不超过3个，所以一定不会有失衡的情况产生
            if(parent!=null)
            {
                //当其失衡的时候，对其进行旋转操作
                //用于判断是从其父节点的左边失衡的还是右边
                boolean isLeft=parent.left.key.compareTo(root.key)==0?true:false;
                //用于获取该失衡节点的平衡因子
                int balance=getBalance(root);
                //大于0的时候，要么进行LL型旋转，要么进行LR型旋转
                if(balance&amp;gt;0)
                {
                    //用于获取其孩子节点的平衡因子，根据其平衡因子的情况，进行相应的旋转操作
                    int childBalance=getBalance(root.left);
                    //对其相应的孩子节点为根节点的子树进行左旋
                    if(childBalance&amp;lt;0)
                    {
                        root.left=leftRotate(root.left);
                    }
                    //对以失衡的树的根节点为子树的树进行右旋操作
                    AVLTreeNode rotateNode=rightRotate(root);
                    if(isLeft)
                        parent.left=rotateNode;
                    else
                        parent.right=rotateNode;
                }
                //小于0的时候，要么进行RR型旋转，要么进行RL型旋转
                else
                {
                    //用于获取其孩子节点的平衡因子，根据其平衡因子的情况，进行相应的旋转操作
                    int childBalance=getBalance(root.right);
                    //对其相应的孩子节点为根的子树进行右旋
                    if(childBalance&amp;gt;0)
                    {
                        root.right=rightRotate(root.right);
                    }
                    //对以失衡的树的根节点为子树的树进行左旋操作
                    AVLTreeNode rotateNode=leftRotate(root);
                    if(isLeft)
                        parent.left=rotateNode;
                    else
                        parent.right=rotateNode;
                }
            }
        }
    }
    
    /**
     * 用于进行删除操作
     * @param key 要进行删除操作的节点的关键字值
     * @return 返回所删除节点的数据值,当无相关的删除节点的时候，返回null
     */
    public Object delete(Comparable key)
    {
        if(key==null)
            return null;
        else
            return remove(root,key,null);
    }
    /**
     * 用于辅助进行删除操作的方法
     * @param node 当前比较节点
     * @param parent 当前比较节点的双亲节点
     * @param key 需要进行删除的节点的关键字值
     * @return 返回所删除节点的关键字
     */
    public Object remove(AVLTreeNode node,Comparable key,AVLTreeNode parent)
    {
        if (node != null)
        {
            int compare = key.compareTo(node.key);
            // 从左子树中进行删除
            if (compare &amp;lt; 0)
            {
                return remove(node.left, key, node);
            }
            // 从右子树中进行删除
            else if (compare &amp;gt; 0)
            {
                return remove(node.right, key, node);
            }
            // 当前节点即为要进行删除的节点
            else
            {
                // 当前要进行删除的节点的数据
                Object result = node.data;
                // 当前要进行删除的节点的左右子树均存在
                if (node.left != null &amp;amp;&amp;amp; node.right != null)
                {
                    // 寻找要进行删除节点的替换节点
                    AVLTreeNode innext = node.right;
                    //要进行替换的节点的双亲节点
                    AVLTreeNode innextParent=node;
                    // 寻找右子树下的最左孩子节点
                    while (innext.left != null)
                    {
                        innextParent=innext;
                        innext = innext.left;
                    }
                    // 改变删除节点的相关数据
                    node.data = innext.data;
                    node.key = innext.key;
                    //递归的删除其进行替换的节点  
                    remove(node.right,innext.key,node);
                    //对从当前被删除节点开始的到其相应的替换节点的父节点的路径上判断其是否“失衡”且进行相关的旋转操作
                    rotate(node,null,innextParent);
                }
                // 以下考虑的情况均当前删除节点缺少左子树或者右子树的情况
                else
                {
                    // 当前要进行删除的节点不为根节点的时候
                    if (parent != null)
                    {
                        // 当左子树不为空的时候
                        if (node.left != null &amp;amp;&amp;amp; node.right == null)
                        {
                            // 当前节点为其左子树节点的时候
                            if (node == parent.left)
                            {
                                parent.left = node.left;
                            }
                            // 当前节点为其右子树节点的时候
                            else
                            {
                                parent.right = node.left;
                            }
                            if(node.left!=null)
                            {
                                //由于其删除节点缺少左子树或者右子树。为此，其只需判断当前删除节点的父节点的失衡情况并进行相应的调整即可
                                rotate(parent,null,node.left);
                            }
                        }
                        // 当右子树不为空的时候或为叶子节点的时候
                        else
                        {
                            // 当前节点为其左子树节点的时候
                            if (node == parent.left)
                            {
                                parent.left = node.right;
                            }
                            // 当前节点为其右子树节点的时候
                            else
                            {
                                parent.right = node.right;
                            }
                            if(node.right!=null)
                            {
                                //由于其删除节点缺少左子树或者右子树。为此，其只需判断当前删除节点的父节点的失衡情况并进行相应的调整即可
                                rotate(parent,null,node.right);
                            }
                        }
                        
                    }
                    // 当前删除的节点为根节点的时候
                    else
                    {
                        if (node.left != null)
                            root = node.left;
                        else
                            root = node.right;
                    }
                }
                // 返回其进行删除的节点的值
                return result;
            }
        }
        return null;
    }
    
    /**
     * 测试用例
     * @param args 初始化参数数组
     */
    public static void main(String[] args)
    {
        AVLTree tree=new AVLTree();
        tree.insert(5,&quot;A&quot;);
        tree.insert(2,&quot;B&quot;);
        tree.insert(6,&quot;D&quot;);
        tree.insert(1,&quot;E&quot;);
        tree.insert(3,&quot;C&quot;);
        tree.insert(4,&quot;F&quot;);
        AVLTree.inTravel(tree.getTree());
        System.out.println();
        System.out.println(tree.delete(1));
        AVLTree.inTravel(tree.getTree());
        System.out.println();
        System.out.println(tree.search(5));
    }
}


运行结果如下：

1-E 2-B 3-C 4-F 5-A 6-D 
E
2-B 3-C 4-F 5-A 6-D 
A
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其测试用例所用图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117234123131-2064566707.png&quot; alt=&quot;完整代码测试用例图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/MyStringIsNotNull/p/8270433.html&quot;&gt;回到目录|·(工)·）&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 15:43:00 +0000</pubDate>
<dc:creator>林学徒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MyStringIsNotNull/p/8306848.html</dc:identifier>
</item>
<item>
<title>ABP架构学习系列 - 心存善念</title>
<link>http://www.cnblogs.com/xcsn/p/8306837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcsn/p/8306837.html</guid>
<description>[unable to retrieve full-text content]ABP实践学习系列 ABP Zero 本地化语言的初始化和扩展 ABP Zero 导航菜单之角色权限 ABP Zero示例项目问题总结 ABP后台服务之作业调度Quartz.NET ABP Zero示例项目问题总结 ABP后台服务之作业调度Quartz.NET ABP架构学习系列 ABP架构学习系列</description>
<pubDate>Wed, 17 Jan 2018 15:38:00 +0000</pubDate>
<dc:creator>心存善念</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcsn/p/8306837.html</dc:identifier>
</item>
<item>
<title>[linux] C语言Linux系统编程-TCP通信的11种状态 - 陶士涵</title>
<link>http://www.cnblogs.com/taoshihan/p/8306594.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taoshihan/p/8306594.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/726254/201801/726254-20180117224115615-2051273205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三次握手&lt;/strong&gt;&lt;br/&gt;由client主动发出SYN请求, 此时client处于SYN_SENT状态(第一次握手)&lt;br/&gt;当server收到之后会由LISTEN转变为SYN_REVD状态, 并回复client, client收到应答后处于ESTABLISHED状态, 这个状态就表示client已经准备好通信了(第二次握手)&lt;br/&gt;client收到二次握手应答后回复server, server收到应答之后也处于ESTABLISHED, 表示握手成功, 可以通信了(第三次握手)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据传输&lt;/strong&gt;&lt;br/&gt;然后client和server都处于通信状态, 不会改变&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四次挥手&lt;/strong&gt;&lt;br/&gt;client主动发送FIN请求关闭, 此时client处于FIN_WAIT_1状态(短暂)(第一次挥手)&lt;br/&gt;server收到之后处于CLOSE_WAIT状态(半关闭状态), 并做出应答(第二次挥手)&lt;br/&gt;client收到之后处于FIN_WAIT_2状态, 等待server发送关闭请求.&lt;br/&gt;server会紧接着发送FIN断开请求, 并处于LAST_ACK(第三次挥手)&lt;br/&gt;client收到之后并应答, 此时处于TIME_WAIT状态, 这是主动断开的一端的最后一个状态, 意思是会等待一定的时间(2MSL-1min), 等待之后会变成CLOSED状态(第四次挥手)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP的11种状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CLOSED最初状态&lt;br/&gt;1.建立连接三次握手&lt;br/&gt;client                                               server&lt;br/&gt;(1)SYN_SENT       ========&amp;gt;     (2)LISTEN&lt;br/&gt;(4)ESTABLISHED &amp;lt;========      (3)SYN_RCVD&lt;br/&gt;(5)                        =========&amp;gt;    (6)ESTABLISHED&lt;br/&gt;2.数据传输阶段&lt;br/&gt;3.断开连接四次挥手&lt;br/&gt;(1)FIN_WAIT_1  =========&amp;gt;      (2)CLOSE_WAIT&lt;br/&gt;(4)FIN_WAIT_2  &amp;lt;==========    (3)&lt;br/&gt;(6)TIME_WAIT  &amp;lt;==========     (5)LAST_ACK&lt;br/&gt;(7)                     ==========&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用netstat命令查看各种状态：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/726254/201801/726254-20180117230137318-1530903441.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/726254/201801/726254-20180117230152662-514360244.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/726254/201801/726254-20180117230634459-1693215450.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/726254/201801/726254-20180117230716412-1106790126.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务端监听本机1234端口，客户端进行连接,TIME_WAIT状态维持时间是两个MSL时间长度，也就是在1-4分钟,自动关掉&lt;/p&gt;
&lt;p&gt;参照代码：&lt;/p&gt;
&lt;p&gt;client.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/socket.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建套接字&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; sock = socket(AF_INET, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向服务器（特定的IP和端口）发起请求&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in serv_addr;
    memset(&lt;/span&gt;&amp;amp;serv_addr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(serv_addr));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个字节都用0填充&lt;/span&gt;
    serv_addr.sin_family = AF_INET;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用IPv4地址&lt;/span&gt;
    serv_addr.sin_addr.s_addr = inet_addr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体的IP地址&lt;/span&gt;
    serv_addr.sin_port = htons(&lt;span&gt;1234&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口&lt;/span&gt;
    connect(sock, (&lt;span&gt;struct&lt;/span&gt; sockaddr*)&amp;amp;serv_addr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(serv_addr));
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取服务器传回的数据&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; buffer[&lt;span&gt;40&lt;/span&gt;&lt;span&gt;];
    read(sock, buffer, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;(buffer)-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message form server: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buffer);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sleep(60);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭套接字&lt;/span&gt;
&lt;span&gt;    close(sock);
    sleep(&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;server.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/socket.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;netinet/&lt;span&gt;in&lt;/span&gt;.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建套接字&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; serv_sock =&lt;span&gt; socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将套接字和IP、端口绑定&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in serv_addr;
    memset(&lt;/span&gt;&amp;amp;serv_addr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(serv_addr));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个字节都用0填充&lt;/span&gt;
    serv_addr.sin_family = AF_INET;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用IPv4地址&lt;/span&gt;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体的IP地址&lt;/span&gt;
    serv_addr.sin_port = htons(&lt;span&gt;1234&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口&lt;/span&gt;
    bind(serv_sock, (&lt;span&gt;struct&lt;/span&gt; sockaddr*)&amp;amp;serv_addr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(serv_addr));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入监听状态，等待用户发起请求&lt;/span&gt;
    listen(serv_sock, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收客户端请求&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in clnt_addr;
    socklen_t clnt_addr_size &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(clnt_addr);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; clnt_sock = accept(serv_sock, (&lt;span&gt;struct&lt;/span&gt; sockaddr*)&amp;amp;clnt_addr, &amp;amp;&lt;span&gt;clnt_addr_size);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向客户端发送数据&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; str[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    write(clnt_sock, str, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(str));
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭套接字&lt;/span&gt;
&lt;span&gt;    close(clnt_sock);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    close(serv_sock);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5.c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;36L&lt;/span&gt;, 1183C                                                                                    &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;           Top
    close(serv_sock);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 17 Jan 2018 15:16:00 +0000</pubDate>
<dc:creator>陶士涵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taoshihan/p/8306594.html</dc:identifier>
</item>
<item>
<title>【jQuery】(7)---jQueryAjax同步异步区别 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/8306693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/8306693.html</guid>
<description>&lt;p&gt;   今天在项目开发过程中，要实现这么一个功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 当我点击就业的时候，触发onclick时间,check()方法里通过ajax请求返回数据，
  如果该用户已经毕业可以跳转到job.html如果没有毕业不能跳转页面同时弹框提示 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;job.html&quot;&lt;/span&gt;&lt;span&gt;  onclick&lt;/span&gt;&lt;span&gt;=&quot;return check()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;就业&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们都知道onclick是优先执行于href属性的，只有onclick返回true才会执行href。接下来看js怎么写的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; check(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fal=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        $.post(&lt;/span&gt;&quot;URL&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(date){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(date==&lt;span&gt;null&lt;/span&gt; || date==&quot;&quot;&lt;span&gt;){
                fal&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fal;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实这个return也只是返回ajax中function的返回值。而不是check()的返回值&lt;/span&gt;
            }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                alert(&lt;/span&gt;&quot;请先毕业才能就业&quot;&lt;span&gt;)
            }
        })
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fal;
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;最终发现如果该用户已经毕业，a标签没有任何反应，
        如果还没有毕业，会提示：请先毕业才能就业。界面也是没有反应&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就很纳闷了，明明返回数据是空，fal变成了ture，怎么最终返回还是false。这就是同步和异步的区别了。&lt;/p&gt;
&lt;p&gt;首先，ajax默认情况下是异步的，那什么是异步呢&lt;/p&gt;
&lt;p&gt;async默认的设置值为true，这种情况为异步方式，就是说当ajax发送请求后，在等待server端返回的这个过程中，前台会继续 执行ajax块后面的脚本，直到server端返回正确的结果才会去执行success，也就是说这时候执行的是两个线程，ajax块发出请求后一个线程 和ajax块后面的脚本（另一个线程）&lt;/p&gt;
&lt;p&gt;js举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    $(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {  
            $.ajax({  
                type : &lt;/span&gt;'post'&lt;span&gt;,  
               &lt;span&gt;&lt;strong&gt; async : &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;, &lt;/strong&gt; &lt;/span&gt;
                url : &lt;/span&gt;''&lt;span&gt;,  
                cache : &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,  
                data : {},  
                success : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){  
                    alert(&lt;/span&gt;&quot;1111&quot;&lt;span&gt;);  
                }  
            });  
            alert(&lt;/span&gt;&quot;22222&quot;&lt;span&gt;);  
        });  
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;在这里方法中，因为它是异步的，所以它在通过ajax向后端交互的同时，它还会向下执行js代码，就相当于有两个线程
        所以这里是会先弹出&quot;2222&quot;,才会弹出&quot;1111&quot;,到这个时候，才知道为什么上面js为什么总是返回false，因为异步的时候
        它先执行了下面的return fal,就已经返回flase了&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以我们只要把async的属性值改为false就变成同步了&lt;/p&gt;
&lt;p&gt;$.post没有这个同步异步设置 ，如果一定要设置异步，只能在执行$.post之前加$.ajaxSettings.async = false; (同步执 &lt;br/&gt;行) &lt;/p&gt;
&lt;p&gt;所以把最上面js改成同步，就可以实现相关功能了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; check(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fal=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
         $.ajax({  
                type: &lt;/span&gt;&quot;POST&quot;&lt;span&gt;,  
                url: &lt;/span&gt;&quot;url&quot;&lt;span&gt;,  
               &lt;strong&gt;&lt;span&gt; async:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;false, &lt;/span&gt; &lt;/strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步方式   &lt;/span&gt;
                success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(re){  
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(re==&lt;span&gt;null&lt;/span&gt;||re==&quot;&quot;&lt;span&gt;){
                        fal&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;        
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        alert(&lt;/span&gt;&quot;请先毕业才能就业&quot;&lt;span&gt;);    
                  } 
                } 
            }); 
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fal; 
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步和异步的区别                                         &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;简单理解：&lt;/strong&gt;&lt;/span&gt;同步的意思是当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，页面出去假死状态，当这个AJAX执行完毕后才会继续运行其他代码页面假死状态解除。 &lt;br/&gt;而异步则这个AJAX代码运行中的时候其他代码一样可以运行。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;异步：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在异步模式下，当我们使用AJAX发送完请求后，可能还有代码需要执行。这个时候可能由于种种原因导致服务器还没有响应我们的请求，但是因为我们采用了异步执行方式，所有包含AJAX请求代码的函数中的剩余代码将继续执行。如果我们是将请求结果交由另外一个JS函数去处理的，那么，这个时候就好比两条线程同时执行一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;在同步模式下，当我们使用AJAX发送完请求后，后续还有代码需要执行，我们同样将服务器响应交由另一个JS函数去处理，但是这时的代码执行情况是：在服务器没有响应或者处理响应结果的JS函数还没有处理完成return时，包含请求代码的函数的剩余代码是不能够执行的。就好比单线程一样，请求发出后就进入阻塞状态，知道接触阻塞余下的代码才会继续执行。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;如果哪里理解不到位，或者理解错了，欢迎指点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;想的太多，做的太少，中间的落差就是烦恼，要么去做，要么别想 &lt;/strong&gt;少尉【17】&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 17 Jan 2018 15:06:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/8306693.html</dc:identifier>
</item>
<item>
<title>别让自己跟着思维走 - skyflask</title>
<link>http://www.cnblogs.com/skyflask/p/8306590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyflask/p/8306590.html</guid>
<description>&lt;p&gt;今天和几个同事一边吃饭一边瞎聊，期间从《人民的名义》中高育良，谈到大学校长的级别，再谈到一个县长在现实中都了不得，随随便便都是手里流水几个亿。突然，禄总冒出一句，“你们是不是每次看小说时，都把自己都当主角？”，禄总接着说，“其实在现实中你只是个路人甲。上大学那会儿看《射雕英雄传》，看到江南七怪这么差的武功，都有些轻视。但是从学校毕业出来以后，发现自己连电影里江南七怪一个脚趾头都比不上，现实中自己连电影中的路人甲都不是。”&lt;/p&gt;
&lt;p&gt;回家的路上，在车上想着自己当初毕业的那会儿，和所有将要毕业的大学生一样。意气风发，想着年薪百万，当上CEO迎娶白富美的美梦。自从步入社会后，逐渐才知道梦想太丰满，现实太骨感。一切和自己毕业前想想的完全不一样，一路升级打怪，可谓举步维艰。&lt;/p&gt;
&lt;p&gt;我想每个人都应该有过类似的经历：时常在工作中生怕自己做得不够好而自责，心里抱怨自己还可以更做得更好；或者某次同学聚会后，发现同学们都混得那么好，每次聚会回家后都责怪自己不够努力。。。。。由此，人生也便有了烦恼，久而久之，就成了痛苦，一直伴随在你生活中。&lt;/p&gt;
&lt;p&gt;虽然我们生活慢慢变得好了起来，工资也越来越可观。但是，快乐似乎并没有和工资一样上涨，而是随着房子、车子、妻子、孩子.....，反而是痛苦增加。&lt;/p&gt;
&lt;p&gt;为什么会变得这样呢？很久之前我一直在苦苦思考这其中的原因。&lt;/p&gt;
&lt;p&gt;今天听到禄总这句话后，突然冒出一个想法：我是不是一直让自己跟着思维走，才会让自己无法从中脱离出来，而导致作茧自缚，将自己越绑越紧。那么，问题又来了，我让自己跟着思维走，这里是不是出现了三个对象：我、自己、思维。那么，谁才是真正的我呢？我？自己？思维？很奇特吧。&lt;/p&gt;
&lt;p&gt;经过一番分析，三个对象如下：&lt;/p&gt;
&lt;p&gt;&quot;我&quot;是真正的我，或者说是最真实的自己、最本质的自己；&lt;/p&gt;
&lt;p&gt;&quot;自己&quot;是一个虚我，也就是思维勾画出来的我，虚的。关于真我和虚我，后面我会继续思考并搞清楚，为什么会产生这两个对象以及他们是怎么产生的？&lt;/p&gt;
&lt;p&gt;“思维”是大脑通过后天在社会中形成自己的思维体系后，对所接触的事务进行分析、对比、归类、类比而形成的一些方式，也就是一些常规模式或套路。&lt;/p&gt;
&lt;p&gt;比如一个正常的成年男孩，看到一个成年女孩后，可能在大脑里会对女孩进行分析，是美是丑？是否有男友？是否可以做她的男友？这样，“自己”就会随着思维去思考，自己就会随着思维把自己当住主角去上演电影或者一些生活中的情景。其实，此时你已经被思维控制，你已然已经成为了思维的奴隶。其实，佛教里面的有一句比较经典的话：众生为了短暂的欲乐，终日作五欲的奴隶，不得出离三界。少欲知足，才是幸福安乐之道。&lt;/p&gt;
&lt;p&gt;如此一来，“虚我”不知不觉的成为了思维的奴隶。一旦在现实中和“虚我”所想的或所欲望得到的不一样时，痛苦变产生了。就像上面你看到一个美丽的女孩后，思维里面想着是否可以和她一起吃饭、一起玩啊，一旦你看到这个美丽女孩亲切的挽着她男朋友的手，步入了豪车中时，“虚我”就开始变得失望或者羡慕，如果心态或者三观不正，则会产生仇视或嫉妒的心里。正所谓没有希望就不会失望，正是因为你希望的太多，才会失望得越多。&lt;/p&gt;
&lt;p&gt;以上，你清清楚楚的看到了自己跟着思维走的后果了吧。它不但时你痛苦的来源，更是你产生欲望的原因。&lt;/p&gt;
&lt;p&gt;不要让自己跟着思维走，看到美好事物的时候，请不要心生邪念，静静地欣赏，默默地祝福就好；&lt;/p&gt;
&lt;p&gt;不要让自己跟着思维走，遇到难事的时候，请不要带有情绪，内心对自己说，事情已经发生，时间会帮我解决；&lt;/p&gt;
&lt;p&gt;不要让自己跟着思维走，不如意的时候，请不要抱怨，其实如意不如意都是思维的产物，和你没有任何关系。&lt;/p&gt;
&lt;p&gt;不要让自己跟着思维走，其实，思维只是让你觉得自己存在而已。&lt;/p&gt;

</description>
<pubDate>Wed, 17 Jan 2018 14:44:00 +0000</pubDate>
<dc:creator>skyflask</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyflask/p/8306590.html</dc:identifier>
</item>
</channel>
</rss>