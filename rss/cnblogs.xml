<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Redis Cluster(集群) - pursuer.chen</title>
<link>http://www.cnblogs.com/chenmh/p/9221468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmh/p/9221468.html</guid>
<description>&lt;h2&gt;一、概述&lt;/h2&gt;
&lt;p&gt;在前面的文章中介绍过了redis的主从和哨兵两种集群方案，redis从3.0版本开始引入了redis-cluster(集群)。可以说从主从-哨兵-集群可以看到redis的不断完善；主从复制是最简单的节点同步方案无法主从自动故障转移。哨兵可以同时管理多个主从同步方案同时也可以处理主从自动故障转移，通过配置多个哨兵节点可以解决单点网络故障问题，但是单个节点的性能压力问题无法解决。集群解决了前面两个方案的所有问题。&lt;/p&gt;

&lt;p&gt;Redis-Cluster架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/135426/201806/135426-20180624185758226-2069219423.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.Redis-Cluster采用无中心结构，每个节点都和其它节点通过互ping保持连接，每个节点保存整个集群的状态信息，可以通过连接任意节点读取或者写入数据(甚至是没有数据的空节点)。&lt;/p&gt;
&lt;p&gt;2.只有当集群中的大多数节点同时fail整个集群才fail。&lt;/p&gt;
&lt;p&gt;3.整个集群有16384个slot，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。读取一个key时也是相同的算法。&lt;/p&gt;
&lt;p&gt;4.当主节点fail时从节点会升级为主节点，fail的主节点online之后自动变成了从节点。&lt;/p&gt;

&lt;h2&gt;二、集群安装&lt;/h2&gt;
&lt;h3&gt;1.插件安装&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum -y install ruby rubygems
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下周ruby依赖的redis.gem&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wget https://rubygems.&lt;span&gt;global&lt;/span&gt;.ssl.fastly.net/gems/redis-3.2.2.gem
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装redis.gem&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
gem install redis-3.2.2.gem 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：不要使用gem install redis来默认安装，默认安装可能会安装redis-4.0.0版本。之前因为安装默认的版本过高导致reshard的时候一直失败&lt;/span&gt;。可以参考：&lt;a href=&quot;http://www.cnblogs.com/chenmh/p/9221672.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/chenmh/p/9221672.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装redis-stat&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gem install redis-stat
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果操作系统是7.0以上版本，可能会因为yum方式安装的ruby的版本太低，报“&lt;strong&gt;redis requires Ruby version &amp;gt;= 2.2.2&lt;/strong&gt;”错误，这时可以这样处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
gpg --keyserver hkp:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
\curl -sSL https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get.rvm.io | bash -s stable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
source  /etc/profile.d/rvm.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看可以安装的版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rvm list known
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装其中的一个版本，大于2.2.2的版本即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rvm install &lt;span&gt;2.4&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看已安装的gem,ruby版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ruby -&lt;span&gt;v 
gem &lt;/span&gt;-v
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行gem安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gem install redis
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.安装redis&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
tar -xvf redis-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;.tar.gz
cd redis&lt;/span&gt;-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
make MALLOC&lt;/span&gt;=&lt;span&gt;libc
cp src&lt;/span&gt;/redis-server redis-cli redis-trib.rb redis-benchmark redis-check-aof redis-check-rdb redis-sentinel /usr/local/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建redis目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mkdir -p /redis/redis-cluster/&lt;span&gt;
cd &lt;/span&gt;/redis/redis-cluster/&lt;span&gt;
mkdir &lt;/span&gt;-p &lt;span&gt;7001&lt;/span&gt;/data &lt;span&gt;7001&lt;/span&gt;/log &lt;span&gt;7001&lt;/span&gt;/&lt;span&gt;tmp
cp &lt;/span&gt;-rp &lt;span&gt;7002&lt;/span&gt;&lt;span&gt;
cp &lt;/span&gt;-rp 7003&lt;span&gt; 
cp &lt;/span&gt;-rp &lt;span&gt;8001&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cd &lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
vim redis.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
port &lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
daemonize yes
timeout &lt;/span&gt;&lt;span&gt;300&lt;/span&gt;&lt;span&gt;
databases &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;
save &lt;/span&gt;&lt;span&gt;900&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
save &lt;/span&gt;&lt;span&gt;300&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
save &lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
stop&lt;/span&gt;-writes-on-bgsave-&lt;span&gt;error yes
rdbcompression yes
rdbchecksum yes 
lua&lt;/span&gt;-time-limit &lt;span&gt;5000&lt;/span&gt;&lt;span&gt;
bind 192.168.191.11&lt;br/&gt;######################################limit#######################
maxclients &lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
maxmemory 512mb
maxmemory&lt;/span&gt;-policy &lt;span&gt;volatile&lt;/span&gt;-&lt;span&gt;ttl
maxmemory&lt;/span&gt;-samples &lt;span&gt;5&lt;/span&gt;&lt;span&gt;

#######################################file#######################
pidfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/redis/redis-cluster/7001/tmp/redis_7001.pid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
loglevel notice
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/redis/redis-cluster/7001/log/redis_7001.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dbfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dump.rdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/redis/redis-cluster/7001/data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 

appendonly yes
appendfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appendonly.aof&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
appendfsync everysec
no&lt;/span&gt;-appendfsync-on-&lt;span&gt;rewrite no
auto&lt;/span&gt;-aof-rewrite-percentage &lt;span&gt;100&lt;/span&gt;&lt;span&gt;
auto&lt;/span&gt;-aof-rewrite-min-&lt;span&gt;size 64mb
######################################replication###########################
slave&lt;/span&gt;-serve-stale-&lt;span&gt;data yes
slave&lt;/span&gt;-read-&lt;span&gt;only yes
repl&lt;/span&gt;-diskless-&lt;span&gt;sync no
repl&lt;/span&gt;-diskless-sync-delay &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
repl&lt;/span&gt;-disable-tcp-&lt;span&gt;nodelay no
slave&lt;/span&gt;-priority &lt;span&gt;100&lt;/span&gt;&lt;span&gt;
requirepass &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
masterauth &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

######################################slowlog################################
slowlog&lt;/span&gt;-log-slower-than &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
slowlog&lt;/span&gt;-max-len &lt;span&gt;128&lt;/span&gt;&lt;span&gt;
latency&lt;/span&gt;-monitor-threshold &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
 
####################################cluster####################################
cluster&lt;/span&gt;-&lt;span&gt;enabled yes
cluster&lt;/span&gt;-config-file &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/redis/redis-cluster/7001/nodes.conf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
cluster&lt;/span&gt;-node-timeout &lt;span&gt;5000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将redis.conf配置文件拷贝到其它的几个节点并修改对应的端口、路径等相关信息。&lt;/p&gt;
&lt;h3&gt;3.启动redis集群 &lt;/h3&gt;
&lt;p&gt;启动所有的redis集群&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./redis-server redis.conf 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以写在bash脚本文件中启动&lt;/p&gt;
&lt;h2&gt;三、集群管理&lt;/h2&gt;
&lt;h3&gt;1.创建集群&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-trib.rb create 192.168.191.11:7001 192.168.191.11:7002 192.168.191.11:7003
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果加上参数--replicas 1表示为每一个主节点创建一个从节点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：其实也不建议使用-replicas 1来自动创建主从关系，因为这种创建方法没办法指定哪个从节点对应哪个主节点，无法控制交叉主从。可以先创建好主节点，然后再通过创建从节点指定主节点。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.集群配置密码处理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;默认如果redis cluster节点配置了密码验证，redis-trib.rb操作会失败，则需要在需要执行redis-trib.rb操作的节点修改client.rb文件，操作如下：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
find / -name &lt;span&gt;'&lt;/span&gt;&lt;span&gt;client.rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /usr/lib/ruby/gems/1.8/gems/redis-3.2.1/lib/redis/client.rb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：由于每个人安装的版本不一样所以路径也可能有所差别，在passwd参数后面设置验证的密码，注意所有节点的密码必须是相同的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/135426/201807/135426-20180708223044940-799333529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.检查集群&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-trib.rb check 192.168.191.11:7001
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/135426/201807/135426-20180708223159412-250187845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 4.增加节点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.增加主节点&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-trib.rb add-node 192.168.191.11:7004 192.168.191.11:7001
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：最后后面的ip和端口是目前集群中已经存在的节点，前面的ip和端口是要增加的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.增加从节点&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
----&lt;span&gt;增加从节点
redis&lt;/span&gt;-trib.rb add-node --slave 192.168.191.11:8001 192.168.191.11:7001 
----&lt;span&gt;增加从节点并指定主节点
redis&lt;/span&gt;-trib.rb add-node --slave --master-id 64ee652b75a78fc08253fddab5a920988a870f68 192.168.191.11:8001 192.168.191.11:7001 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：最后面的ip和端口是现集群中已经存在的节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/135426/201807/135426-20180708224744811-431946222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.移动slot&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-trib.rb reshard 192.168.191.11:7001
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;iphe端口随便指定集群中的某一个，然后输入要移动的slot个数和源节点目标节点id,最后输入done即可。&lt;/p&gt;
&lt;h3&gt;6.移动节点&lt;/h3&gt;
&lt;p&gt;可以指定当前节点的master,或者改变当前节点所属的master,登入到当前节点执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cluster replicate 5d8ef5a7fbd72ac586bef04fa6de8a88c0671052  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;##新master的nodeid&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7.删除节点&lt;/h3&gt;
&lt;p&gt;注意： 删除主节点之前需要先将主节点上的所有slot移动到别的主节点，并且保证没有从节点，否则需要先将从节点移走或者删除&lt;/p&gt;
&lt;p&gt;删除节点时需要指定节点的id&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-trib.rb &lt;span&gt;del&lt;/span&gt;-node 192.168.191.11:7001 af0f17b501b9f9f5e71ff6be1cf8114c9e11a80b 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面的id即为需要删除的节点id,删除节点和增加节点语法节点的循序正好相反&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、集群相关命令&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CLUSTER INFO 打印集群的信息
CLUSTER NODES 列出集群当前已知的所有节点（node），以及这些节点的相关信息。 &lt;/span&gt;
CLUSTER MEET &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;&lt;span&gt; 将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。
CLUSTER FORGET &lt;/span&gt;&amp;lt;node_id&amp;gt;&lt;span&gt; 从集群中移除 node_id 指定的节点。
CLUSTER REPLICATE &lt;/span&gt;&amp;lt;node_id&amp;gt;&lt;span&gt; 将当前节点设置为 node_id 指定的节点的从节点。
CLUSTER SAVECONFIG 将节点的配置文件保存到硬盘里面。
CLUSTER ADDSLOTS &lt;/span&gt;&amp;lt;slot&amp;gt;&lt;span&gt; [slot ...] 将一个或多个槽（slot）指派（assign）给当前节点。
CLUSTER DELSLOTS &lt;/span&gt;&amp;lt;slot&amp;gt;&lt;span&gt; [slot ...] 移除一个或多个槽对当前节点的指派。
CLUSTER FLUSHSLOTS 移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。
CLUSTER SETSLOT &lt;/span&gt;&amp;lt;slot&amp;gt; NODE &amp;lt;node_id&amp;gt;&lt;span&gt; 将槽 slot 指派给 node_id 指定的节点。
CLUSTER SETSLOT &lt;/span&gt;&amp;lt;slot&amp;gt; MIGRATING &amp;lt;node_id&amp;gt;&lt;span&gt; 将本节点的槽 slot 迁移到 node_id 指定的节点中。
CLUSTER SETSLOT &lt;/span&gt;&amp;lt;slot&amp;gt; IMPORTING &amp;lt;node_id&amp;gt;&lt;span&gt; 从 node_id 指定的节点中导入槽 slot 到本节点。
CLUSTER SETSLOT &lt;/span&gt;&amp;lt;slot&amp;gt;&lt;span&gt; STABLE 取消对槽 slot 的导入（import）或者迁移（migrate）。 &lt;/span&gt;
CLUSTER KEYSLOT &amp;lt;key&amp;gt;&lt;span&gt; 计算键 key 应该被放置在哪个槽上。
CLUSTER COUNTKEYSINSLOT &lt;/span&gt;&amp;lt;slot&amp;gt;&lt;span&gt; 返回槽 slot 目前包含的键值对数量。
CLUSTER GETKEYSINSLOT &lt;/span&gt;&amp;lt;slot&amp;gt; &amp;lt;count&amp;gt;&lt;span&gt; 返回 count 个 slot 槽中的键。 &lt;/span&gt;
CLUSTER SLAVES node-id 返回一个master节点的slaves 列表
&lt;/pre&gt;&lt;/div&gt;






&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.7112676056338&quot;&gt;&lt;tr readability=&quot;6.4172535211268&quot;&gt;&lt;td readability=&quot;8.556338028169&quot;&gt;
&lt;p&gt;&lt;span&gt;备注：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    作者：&lt;/span&gt;&lt;span&gt;&lt;a title=&quot;点击跳转到原文&quot; href=&quot;http://www.cnblogs.com/chenmh/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;pursuer.chen&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    博客：&lt;span&gt;&lt;a id=&quot;lnkMyHome&quot; title=&quot;点击跳转到原文&quot; href=&quot;http://www.cnblogs.com/chenmh/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/chenmh&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本站点所有随笔都是原创，欢迎大家转载；但转载时必须注明文章来源，且在文章开头明显处给明链接，否则保留追究责任的权利。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《欢迎交流讨论》&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</description>
<pubDate>Sun, 08 Jul 2018 15:25:00 +0000</pubDate>
<dc:creator>pursuer.chen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmh/p/9221468.html</dc:identifier>
</item>
<item>
<title>初识Spring - lukely</title>
<link>http://www.cnblogs.com/lukely/p/9281647.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lukely/p/9281647.html</guid>
<description>
&lt;p&gt;不使用框架，我们写按照mvc结构来写代码是这样的：&lt;/p&gt;
&lt;p&gt;业务层：service&lt;/p&gt;
&lt;p&gt;定义一个业务层接口UserService ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserService {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后根据这个几口写一个业务层实现类UserServiceImpl ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; UserDao userDao = &lt;span&gt;new&lt;/span&gt; UserDaoImpl();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口的实例化问题，自己来new 代码的耦合性很高。&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser() {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;userDao.addUser();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;持久层UserDao ：&lt;/p&gt;
&lt;p&gt;定义一个接口持久层接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserDao {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后根据这个接口写一个持久层实现类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt; @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; System.out.println(&quot;添加用户！&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  
&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们来模拟，层持久层获取数据返回。数据就是“添加用户”这几个字&lt;/p&gt;

&lt;p&gt;然后写一个测试类来测试取回的数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserDaoTest {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; UserService userService = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserServiceImpl();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private UserService userService;&lt;/span&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;userService = (UserService) context.getBean(&quot;userService&quot;);&lt;/span&gt;
&lt;span&gt; userService.addUser();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;整个流程下来，我们可以发现，传统的方式我们需要在业务层new 持久层的对象。在测试类中，需要new 业务层的对象。也就是说，传统的方式我们获取被依赖对象的方式是使用new关键字，自己在需要的地方自己new。&lt;/p&gt;

&lt;p&gt;这种方式使用javaSE里面说的“组合”，通过组合来复用了被依赖对象里面的方法。但是这种方法是很笨重的，笨重表现如下：&lt;/p&gt;
&lt;p&gt;1、需要用到1个依赖对象，我们就需要在这个类中主动new1个依赖类的对象，需要用到N个不同的依赖对象，我们就需要主动new N个对象。这样的话，就会使代码变得臃肿，如果业务逻辑很复杂，那这种方式也会增加代码的复杂程度，无论是开发过程中还是给别人看，都不能很容易就梳理出这里的业务。&lt;/p&gt;
&lt;p&gt;2、耦合性很强。这一点我以前也一直不明白为什么说耦合性很强，不灵活。现在我终于明白了一点。耦合性强，就意味着可扩展性差。我们可以试想一种情况：&lt;/p&gt;
&lt;p&gt;就是项目完成后。发布上线一年了。突然业务的木偶一个小部分需要发生了变化C对象，之前是调用A对象的，现在要改成B对象才合适。这种情况之下：&lt;/p&gt;
&lt;p&gt;如果使用传统的new的方法，如何做出修改呢？这时候就需要将C类里面new A对像的地方改为new B对象。然后重新打包，替换原来的包。这项工作就比较负责。也根本谈不上扩展性。&lt;/p&gt;

&lt;p&gt;这个时候，如果我们使用另外一种方式---工厂模式，会怎么样呢？肯定会简单很多。&lt;/p&gt;
&lt;p&gt;比如：先创建一个工厂类，专门用于创建对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyFactoryUtils {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T getInstance(Class&amp;lt;T&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; String interfaceName =&lt;span&gt; c.getSimpleName();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; String interfaceImplName = ResourceBundle.getBundle(&quot;myinterface&quot;&lt;span&gt;).getString(interfaceName);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T) Class.forName(interfaceImplName).newInstance();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;e.printStackTrace();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;加载接口实例失败..&quot; +&lt;span&gt; e);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后业务层的代码就可以变成这样了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; UserDao userDao = MyFactoryUtils.getInstance(UserDao .&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser() {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;userDao.addUser();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们通过工厂类，来获取持久层的对象，如：第2行&lt;/p&gt;
&lt;p&gt;这个对象是怎么获取的呢？是通过配置文件获取的：&lt;/p&gt;
&lt;p&gt;myinterface.properties.&lt;/p&gt;
&lt;p&gt;在这个配置文件中，以key--value的方式配置好&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UserDao=com.mytest.dao.imple.UserDaoImpl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 通过这种方式，我们就大大增强了之前代码的灵活性。如果我们在要更换成别的对象了。我们只要将配置文件中的value换掉就好了。&lt;/p&gt;
&lt;p&gt;可是这种方式只能解决耦合性强的问题啊，代码臃肿的问题还是不能解决的。这个时候，spring框架的价值就体现出来了。spring框架不仅较大程度低解决了耦合性强的问题，也解决了代码臃肿的问题。那spring是如何解决耦合性强的问题的呢？&lt;/p&gt;
&lt;p&gt;也是通过配置文件。此时spring就相当于一个bean工厂（bean可以简单地理解为那些一类对象）。跟上面的工厂模式一样，只要在配置文件中设置好相应的配置，就可以像上面一样灵活了。&lt;/p&gt;
&lt;p&gt;此时使用spring框架的代码是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserDaoTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService userService;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; ClassPathXmlApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; userService = (UserService) context.getBean(&quot;userService&quot;&lt;span&gt;);&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;userService.addUser();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
 &lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们通过spring提供的工厂对象 context 并根据这个工厂的getBean方法获取需要的对象。配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
&lt;span&gt;3&lt;/span&gt; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt;4&lt;/span&gt; xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &amp;lt;bean id=&quot;userService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.myTest.service.impl.UserServiceImpl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;span&gt;7&lt;/span&gt; &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样也就可以实现像工厂模式那样降低了代码的耦合性。可是我们这里明明看到的是，代码要比工厂的那个写得更多啊？其实不是，在这个类里面：ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);&lt;/p&gt;
&lt;p&gt;这个语句，只要写一次就够了，就可以根据：&lt;/p&gt;
&lt;p&gt;userService = (UserService) context.getBean(&quot;userService&quot;);这种方式获取不同的对象了。要获取不同的对象只要将getBean（id）。里的id换掉就可以了。这样相对工厂方式来说，代码量减少了，灵活性得到了保持。但是这种方式，还是会需要需要很多getBean方法来获取不同的对象，业务一复杂了，也会需要很多个相似的代码来获得不同的对象，灵活性上和代码冗余量可不可以更好一点呢？&lt;span&gt;这个时候就是DI---依赖注入闪亮登场了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDao userDao;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserDao(UserDao userDao) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.userDao =&lt;span&gt; userDao;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;userDao.addUser();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，我们现在的代码及编程了现在这个样子，代码量明显比之前要少了很多了。配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
&lt;span&gt; 3&lt;/span&gt; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt; 4&lt;/span&gt; xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &amp;lt;bean id=&quot;userDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.itcast.dao.impl.UserDaoImpl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;span&gt; 7&lt;/span&gt;  &amp;lt;bean id=&quot;userService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.itcast.service.impl.UserServiceImpl&quot;&amp;gt;
&lt;span&gt; 8&lt;/span&gt;  &amp;lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;span&gt; 9&lt;/span&gt;  &amp;lt;/bean&amp;gt;
&lt;span&gt;10&lt;/span&gt; &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到在业务层实现类的配置里面，配置了一个属性&amp;lt;&lt;span&gt;property &amp;gt;,这个正是我们的持久层的对象。这样只要这个业务层一旦初始化，就会同时初始化持久层对象了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样，就代码来说，因为使用了工厂，使用了配置文件，相比什么都不使用，直接new的传统写法来说，这样的代码就更加精简，更加具有灵活性了。业务层代码，因为主要代码都集中在了业务上，所以业务也及更好理解了。也因为使用配置文件的方式，想换什么实现方式，在配置文件中将配置文件改了，也就好了，更加地灵活。&lt;/p&gt;

&lt;p&gt;到这里，我们可以发现，spring核心的&lt;span&gt;IOC控制反转，其实就是将创建对象的过程由原来的自己使用new关键字，转变成由spring的工厂去创建。将获得依赖对象的方式由原来的创建式，变成了配置式（在spring的配置文件中配置。）。但是，我个人无法理解的是为什么说是“反转”。我理解的反转是，本来是我为你做的事情，现在变成了你为我做，这叫反转。可是在spring这里，明显就是，本来我为自己做的事情，现在由别人为我做了。所以翻译成了”反转“，会不会对理解上有些误解呢？见仁见智了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DI，依赖注入。关于这一点，我也是不太能理解（不能理解依赖注入成了spring的特性这一点）。这个依赖注入按照我的理解，就是同样的功能随着IOC而采用了不同的实现方式而已。因为注入，本质是将A对象注入到B对象里面，好让B对象可以使用A对象的方法，而达到复用代码的目的。这个目的使用组合的方式本身就可以实现。或者说为了达到“注入”这种更形象的样子（不考虑spring本身，单论注入），使用组合，完全可以实现。所以为什么依赖注入成了Spring专有的了呢？所以我认为，所谓依赖注入：实际上也就是代码复用的另一种形式，或者干脆说是组合的另外一种形式罢了。（这个问题我的确是有些钻牛角尖了，欢迎多多批评。）&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 14:45:00 +0000</pubDate>
<dc:creator>lukely</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lukely/p/9281647.html</dc:identifier>
</item>
<item>
<title>[netcore]CentOS安装使用.netcore极简教程（免费提供学习服务器） - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/netcore_centos.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/netcore_centos.html</guid>
<description>&lt;p&gt;本文目标是指引从未使用过Linux的.Neter，如何在CentOS7上安装.Net Core环境，以及部署.Net Core应用。&lt;/p&gt;

&lt;p&gt;仅针对CentOS，其它Linux系统类似，命令环节稍加调整；&lt;/p&gt;
&lt;p&gt;需要提前准备好服务器地址、用户名、密码；&lt;/p&gt;
&lt;p&gt;如果手上没有Linux系统，可使用新生命团队免费提供的公网服务器 &lt;span&gt;&lt;strong&gt;centos.newlifex.com&lt;/strong&gt;&lt;/span&gt;  &lt;/p&gt;



&lt;p&gt;在Windows开发机上安装 xshell 和 xftp ，前者用于SSH连接Linux服务器，后者用于FTP上传下载文件。&lt;/p&gt;
&lt;p&gt;打开xshell，新建连接，名称和主机都填 &lt;span&gt;&lt;strong&gt;centos.newlifex.com&lt;/strong&gt;&lt;/span&gt; ，（实际应用中就是你的Linux服务器地址或域名），其它默认，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708114452335-1250298170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击连接，弹出一个SSH安全警告，需要接受并保存SSH密钥。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708114558980-1970286277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 接受后要求输入用户名，我们这里输入&lt;strong&gt;&lt;span&gt;root&lt;/span&gt;&lt;/strong&gt;，选择记住用户名&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708114725291-711940989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 确定后，要求输入密码，新生命团队开放服务器本周的密码是 &lt;strong&gt;&lt;span&gt;nx@1250407685&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708114945342-1398310216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了省事，我们同样选择记住密码。&lt;/p&gt;
&lt;p&gt;确定后，我们可以看到登录成功！同时在左边会话管理器看到了刚才创建的这个连接，以后需要同时管理很多Linux服务器的时候，这样子就方便多了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708115201982-2001968391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我来试试几个可能用得到的命令：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;w 查看现在谁在连接这台服务器&lt;/strong&gt;&lt;/span&gt;。下图看到只有我自己连着。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;free -h 查看服务器内存使用情况&lt;/span&gt;&lt;/strong&gt;。下图看到已用内存119M，Linux这点非常漂亮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708115543394-173715349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;top 命令查看系统进程占用资源情况&lt;/span&gt;&lt;/strong&gt;。类似于Windows任务管理器，定时刷新，按键Q退出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708115812533-2037633259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;共63个进程，只有1个在运行，挺干净。不过底下看到有个java进程，不太爽，后面想办法干掉它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ps aux 查看进程详细信息&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708121255563-1354465336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这下子知道，那个java进程来自 cloudmonitor，应该是云监控。&lt;/p&gt;


&lt;p&gt;我们是奔着.Net Core而来的，重点是安装运行时环境。&lt;/p&gt;
&lt;p&gt;为了方便和一劳永逸，我们抄捷径，先看我的配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708121537377-1322348860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开xshell的快速命令工具栏，然后添加几组快捷命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708121810719-977019569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708121821975-1360231203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;按钮“&lt;strong&gt;&lt;span&gt;.Net Core&lt;/span&gt;&lt;/strong&gt;”&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;sudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm&lt;br/&gt;sudo yum update -y&lt;br/&gt;sudo yum install -y dotnet-runtime-2.1&lt;br/&gt;dotnet --info&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt; （注意：&lt;span&gt;&lt;strong&gt;最后一行命令后面必须有一个换行，否则最后命令无法得到执行，下同&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt; 按钮“&lt;strong&gt;&lt;span&gt;.Net Core SDK&lt;/span&gt;&lt;/strong&gt;”&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;sudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm&lt;br/&gt;sudo yum update -y&lt;br/&gt;sudo yum install -y dotnet-sdk-2.1&lt;br/&gt;dotnet --version&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt;按钮“&lt;strong&gt;&lt;span&gt;Asp.Net Core&lt;/span&gt;&lt;/strong&gt;”&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;sudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm&lt;br/&gt;sudo yum update -y&lt;br/&gt;sudo yum install -y aspnetcore-runtime-2.1&lt;br/&gt;dotnet --info&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt;按钮“&lt;strong&gt;&lt;span&gt;卸载.Net Core&lt;/span&gt;&lt;/strong&gt;”&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;sudo yum remove -y aspnetcore-*&lt;br/&gt;sudo yum remove -y dotnet-*&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt;具体功能就不介绍了，来源于：https://www.microsoft.com/net/download/linux-package-manager/centos/sdk-current&lt;/p&gt;
&lt;p&gt;我们试试第一个按钮，安装.net core运行时，没有asp.net core，也没有.net core sdk&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708122352258-657160089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图看到，安装了netcore运行时2.1.1&lt;/p&gt;
&lt;p&gt;可以用卸载按钮，然后再装另外两个，看看有什么不同。&lt;/p&gt;


&lt;p&gt; 用vs2017新建一个netcore控制台项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708122613205-2070970134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Nuget引用 NewLife.Core ，建立一个稍微高级一点的例程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708122720463-1550216535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main(String[] args)
{
    XTrace.UseConsole();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; svr = &lt;span&gt;new&lt;/span&gt; ApiServer(&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;)
    {
        Log &lt;/span&gt;=&lt;span&gt; XTrace.Log,
        EncoderLog &lt;/span&gt;=&lt;span&gt; XTrace.Log,
        StatPeriod &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ns = svr.EnsureCreate() &lt;span&gt;as&lt;/span&gt;&lt;span&gt; NetServer;
    ns.SocketLog &lt;/span&gt;=&lt;span&gt; XTrace.Log;
    ns.SessionLog &lt;/span&gt;=&lt;span&gt; XTrace.Log;
    ns.LogSend &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    ns.LogReceive &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    svr.Start();

    Console.ReadKey();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上，我们用ApiServer建立一个RPC服务，并打开全部调试日志，它内置有两个服务接口很方便测试RPC通信。&lt;/p&gt;
&lt;p&gt;编译并发布为可移植应用：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708220406911-465511875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们可以得到这样一个目录，运行必要的文件是dll和那个runtimeconfig.json&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708220511329-168608216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用xshell连上服务，我们这里可以是 &lt;span&gt;&lt;strong&gt;centos.newlifex.com&lt;/strong&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;xshell工具栏上有一个绿色图标，打开xftp，左窗口地址栏进入刚才的发布目录，右窗口新建/root/ApiServer目录，并&lt;span&gt;&lt;strong&gt;把左边必要的文件拖到右边&lt;/strong&gt;&lt;/span&gt;，即可实现上传！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708220733085-1524020471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 回到xshell中，&lt;strong&gt;&lt;span&gt;cd ApiServer&lt;/span&gt;&lt;/strong&gt;进入目录，&lt;strong&gt;&lt;span&gt;dotnet ConsoleApp5.dll&lt;/span&gt;&lt;/strong&gt; 即可执行应用，（前提是已安装netcore运行时）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708220948906-638233925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 客户端用码神工具XCoder（https://github.com/NewLifeX/XCoder）连接地址 &lt;span&gt;&lt;strong&gt;tcp://centos.newlifex.com:1234&lt;/strong&gt;&lt;/span&gt;，选择 &lt;strong&gt;&lt;span&gt;Api/All&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;Api/Info&lt;/span&gt;&lt;/strong&gt; 两个服务接口均测试通过，表明我们的&lt;strong&gt;&lt;span&gt;.Net Core&lt;/span&gt;&lt;/strong&gt;应用成功在&lt;strong&gt;&lt;span&gt;CentOS&lt;/span&gt;&lt;/strong&gt;上跑起来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708221322608-1567368892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 光有运行还不够，有时候我们还要查看应用工作日志。还是用xftp，刚才右边的窗口刷新一下，可以看到多出来Log目录，就是我们的应用日志，右键传输即可下载到本地，当然也可以简单直接的往左边拖过去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708221128440-996081899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; vscode打开日志文件，可以看到很详细的信息，特别是日志头，便于分析查找问题&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708221714097-1891187654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这一篇面向Linux零基础的Windows工程师的极简教程，终于写完了，基本上足以应付八成以上的日常工作。&lt;/p&gt;
&lt;p&gt;其它更多细节，可以在网上找到，比如&lt;strong&gt;怎么样把应用安装成为服务、怎么样做到开机启动&lt;/strong&gt;，等等。&lt;/p&gt;

&lt;p&gt; &lt;span&gt;&lt;strong&gt;综合过去20年写代码的经验，netcore具有极强的优势，尽管有一些小问题，但我要说，只要微软不放弃，我坚决不放弃！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我是大石头，打1999年起，19年老码农。目前在快递行业从事数据分析架构工作，分析跑在路上的上亿包裹。欢迎大家一起C#大数据！&lt;/p&gt;

&lt;p&gt;End.&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 14:37:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/netcore_centos.html</dc:identifier>
</item>
<item>
<title>基于HTTP协议的几种实时数据获取技术 - 五月的仓颉</title>
<link>http://www.cnblogs.com/xrq730/p/9280404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xrq730/p/9280404.html</guid>
<description>

&lt;p&gt;&lt;span&gt;HTTP协议大家都很熟悉了，开始本文之前，首先简单回顾一下HTTP协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HTTP协议是建立在TCP协议上的应用层协议，协议的本质是&lt;strong&gt;&lt;span&gt;请求----应答&lt;/span&gt;&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708160705118-1294702638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即对于HTTP协议来说，服务端给一次响应后整个请求就结束了，这是HTTP请求最大的特点，也是由于这个特点，HTTP请求无法做到的是服务端向客户端主动推送数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但由于HTTP协议的广泛应用，很多时候确实又想使用HTTP协议去实现实时的数据获取，这种时候应当怎么办呢？下面首先介绍几种基于HTTP协议的实时数据获取方法。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;轮询是最普遍的基于HTTP协议获取实时数据的方式，轮询又分为短轮询和长轮询。短轮询非常简单，用一张图表示一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708160838824-343690762.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端向服务端请求数据，服务端立即将数据返回给客户端，客户端没有拿到想要的数据（比如返回结果告诉客户端，数据处理中），客户端继续发请求，服务端继续立即响应，周而复始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种实时数据获取的方式比较粗暴，优点在于编程简单，客户端发请求，服务端实时回响应即可。缺点主要有两个：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;无效请求多，每一次无效请求都在浪费带宽和服务器的计算资源&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对服务器压力大，定时发请求，并发一高，可能服务端瞬间会收到成千上万个请求，很容易拖垮服务器甚至导致宕机&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;那么短轮询适合哪种使用场景呢，按照我的理解如果&lt;span&gt;&lt;strong&gt;数据变化比较频繁&lt;/strong&gt;&lt;/span&gt;或者&lt;span&gt;&lt;strong&gt;能预期到数据在短时间内会发生一次变化&lt;/strong&gt;&lt;/span&gt;的场景可以使用短轮询，比如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708171452543-1194967339.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户在PC端买了一个东西唤起网页端，由于PC端和网页端是不通的，我们预期到用户应该很快会完成付款，这种时候为了开发简单短轮询是一种可以使用的方式，直接服务端提供一个接口告诉客户端订单状态，客户端每5秒请求一次即可，拿到结果就可以不用请求了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用短轮询注意要做好请求次数上限的控制，比如请求100次还没检测到用户付款，可以弹窗&quot;请完成付款后去我的订单页面查询&quot;就可以不用请求了。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;长轮询是另一种实时获取数据的方式，看一下流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708161146922-2090036041.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本质上没有改变，依然是客户端在没有收到自己想要数据的情况下不断发送请求给服务端，差别在于服务端收到请求不再直接给响应，而是将请求挂起，自己去定时判断数据的变化，有变化就立马返回给客户端，没有就等到超时为止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以很明显的看到，长轮询的优点就是客户端的请求少了很多避免了无谓的客户端请求，缺点则是服务端会挂起大量请求增加资源消耗且服务器对HTTP请求并发数量是有限制的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微信网页版的登陆是一个典型的长轮询的例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708161328381-1835976845.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从图上看，客户端不断发送请求到服务器，服务器第一时间并没有给出回应，于是客户端等待，在超时的情况下继续发送请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总的来说我理解一般使用长轮询会更多一点，短轮询更加看重的是编程简单，适合小型应用。像微信网页端登录这种，成千上万个用户同时登陆，隔一段时间服务端收成千上个请求去处理哪里受得了，堆机器分摊每台服务器上处理请求的数量终究不是解决问题的办法。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;上面介绍了两种轮询方式，但是两种综合起来都有比较明显的缺点，总结起来有以下几个：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;伪实时，即上述两种方式都不是真正的实时，无论短轮询的客户端轮询时间多短，还是长轮询的服务端轮询时间多短，都存在一定程度的延时&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有的轮询只要没有需要的数据返回，都是对计算资源的一种浪费&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;HTTP协议本身是一个重的协议，每一次都必须带有HTTP首部+HTTP头部，实际上对我们来说需要的只是HTTP Body而已，多余的数据都是对带宽的一种浪费&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因此，最好我们可以做到的事情是：客户端和服务端之间有一条通路，当服务端数据有变化的时候，服务端可以主动推送到客户端。WebSocket就是HTML5之后为了做到这一点而诞生的一种协议，虽然这是一种新的协议，但也是基于HTTP协议的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看一下WebSocket的原理，很简单：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708161546262-572559871.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WebSocket客户端首先通过HTTP协议发送几个特别的header到服务端，告诉服务端现在我发起的是HTTP请求，但我要升级到WebSocket了：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Upgrade:websocket&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Connection：Upgrade&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Sec-WebSocket-Key: XXX&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Sec-WebSocket-Protocol: chat, superchat&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Sec-WebSocket-Version: XX&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;只要服务器支持WebSocket协议（Tomcat7、Jetty7之后都是支持WebSocket的），那么服务端收到请求且建立连接成功后会返回Sec-WebSocket-Accept、Sec-WebSocket-Protocol这两个header给客户端，且Http Status为101表示协议切换成功，这样客户端和服务端只要任意一方没有断开连接，就可以基于这一条通路进行通讯了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再谈一下之前提的WebSocket相比长短轮询对于带宽资源的节省。有一个测试，假设HTTP Header是871字节，WebSocket由于数据传输是基于帧的，帧传输更加高效，对比长短轮询，2个字节即可代替871个字节的Header，测试结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708164206777-1353691310.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相同的每秒客户端轮询的次数，当次数高达10W/s的高频率次数的时候，轮询需要消耗665Mbps，而WebSocket仅仅只花费了1.526Mbps，将近435倍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WebSocket做到了真正的实时且大量节省带宽资源，但是我理解也有自己的问题，就是开发成本比较高，这里的开发成本倒不是说自己去实现WebSocket，这个在Java语言层面上直接使用Netty-Socketio即可，API很简单，提供了对WebSocket完整的实现，真正的开发成本在于分布式环境下的数据同步问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子，有一个在线聊天系统10W人同时在线，此时有一个用户发了一条1K的语音消息，单机保持10W的连接倒是可以（这里不是HTTP请求，因此不受连接池数影响），问题在于带宽。单机同时向10W用户推送1K语音消息，需要的带宽至少10M，这还只是纯粹推送数据出去，没有考虑到数据进来的场景，实际运行过程中需要的带宽会更多，对于企业来说这是一笔非常大的成本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，大量连接的场景下都会做集群（实际就算没有大量连接，为了高可用性，也会做集群），10W并发分出5台机器，平均每台机器有2W连接，考虑集群下会出现的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708161921082-348442478.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端1把数据发送到服务器1，服务器1连接的所有客户端都可以推送该条语音，但是问题在于：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;服务器2~服务器5连的所有客户端如何拿到数据？简单的一种方式是使用消息队列，将数据通过消息队列发送到所有订阅的服务器上&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;那如果传输的是一张1M的图片，数据太大不适合使用消息队列怎么办，可以先将数据存储下来，消息队列只发送id，收到消息的服务器再根据id去取真正的数据并推送&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果依赖消息队列，那么不仅仅需要对应用进行代码开发，还需要对消息服务器做分布式集群、做压力测试，保证高可用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2W连接正常预计发送1K的消息是没问题的，但是万一用户发送了1M图片导致远超预估带宽怎么办，是业务上取舍不能发送超过XXX的数据还是技术上处理&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其他太多需要考虑的问题没有列出来，总而言之，用WebSocket在大量请求、高并发的场景下，代码开发成本是非常高的。但是由于WebSocket可以做到真正的实时服务端对客户端的数据推送且对带宽资源有大量的节省，因此很多IM、音视频、弹幕等应用都会使用WebSocket。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 14:09:00 +0000</pubDate>
<dc:creator>五月的仓颉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xrq730/p/9280404.html</dc:identifier>
</item>
<item>
<title>读特朗普，这是个什么样的对手 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/9281409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/9281409.html</guid>
<description>&lt;p&gt;若不是贸易战我想我是不会读特朗普的书的，因为他给我的第一印象就是满嘴大话，狂妄自傲。简直是来搞笑的，比如宣布要在美墨边境修墙，费用还要墨西哥承担。但到了今年3月份，特朗普扬言要对华500亿产品加收25%关税，虽然期间双方团队经过反复协商，但本月6号还是落下实锤。这让我非常好奇这到底是个什么样的人，于是最近我读了《特朗普自传》和《从20万到30亿》，下面就来聊聊我所理解的特朗普。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-0e51986b9f188e29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;h3&gt;成长历程&lt;/h3&gt;
&lt;p&gt;特朗普祖父年幼时从苏格兰移民到美国，特朗普的父亲弗瑞德·特朗普，开始是一名木匠，靠自己的打拼成为了一名房地产商，但主要出租廉租房。家中五个孩子，父母从小教育他们钱来之不易，他们也不以自诩为富家子弟。特朗普出生在1946年，自小就会跟着父亲去工地，少年时代放假回家都会跟着他父亲学做生意，学着跟承包商周旋，参观楼盘，讨价还价，等等。 &lt;/p&gt;
&lt;p&gt;除此之外，年少的特朗普还有很高的社交天赋，在面对比他强势的对手时他明白：如果你跟他对着干，一旦他发现你的弱点，就能轻而易举击败你。但是，&lt;strong&gt;如果你也很强势，但是你尊重他，他就会真诚对你。不卑不亢才能赢得尊重，卑躬屈膝只有招来更甚的压迫&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-4896c1a88bc179ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;    年轻特朗普&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 1964年，特朗普从纽约军校毕业后，去了宾夕法尼亚大学沃顿商学院读书。沃顿让他明白，“学习成绩不代表一切，我的同学根本没有那么独一无二或令人敬畏，我一点也不比他们差。”而特朗普的内心觉得自己不会做父亲的房产生意，而想做更大、刺激、有吸引力的生意，因为他觉得父亲的方式赚钱太慢了。特朗普大学毕业之后，自己已经有了20万的资产，一边继续帮父亲打理生意，一边自己在曼哈顿发展。&lt;/p&gt;
&lt;h3&gt;地产大亨养成记&lt;/h3&gt;
&lt;p&gt;不得不说特朗普在房地产项目上很有造诣，必须得提一下特朗普大厦。&lt;/p&gt;
&lt;p&gt;1971年，年轻的特朗普常走街串巷考察地段，看中了纽约57号大街和第五大道交会处的一座11层的建筑，这个地块位置极佳，面积又大，特朗普坚信在这个地方建一座大厦，前景一定不错。当时这块地属于格涅斯科公司，由富兰克林管理。特朗普第一次去找富兰克林，对方礼貌的回绝了他，说：“你居然认为我们会把这块风水宝地卖出去，真是天方夜谭”。&lt;/p&gt;
&lt;p&gt;回去后特朗普还是不想放弃，于是开始给富兰克林写信，第一封信是表达感谢对方愿意见他，一个月之后，特朗普再次写信请他重新考虑之前的申请，不过这封信没有得到回音。于是又写了一封信询问是否可以再次去拜访，三个月后，特朗普再去造访富兰克林，但是对方还是没有改变初衷。不过这为后面的事情埋下了伏笔。真是福兮祸所依。&lt;/p&gt;
&lt;p&gt;格涅斯科公司这三年来经历了财务危机，公司换了一位行政总裁约翰·哈尼根，他不停地卖出公司资产，以便甩掉累累负债，偿还银行贷款。而特朗普的这些信打动了这位后来者。他主动联系了特朗普，表示有意向出售。而特朗普心里明白：&lt;strong&gt;像哈尼根这样的人职业经理人，每新到一家公司是不会对公司员工和产品有什么感情的，冷酷无情是他的一贯作风，比起过程更注重结果&lt;/strong&gt;。不过，格涅斯科公司只拥有这块地的租用权，租期还剩29年，特朗普同意以2500万美元买下这块土地的租用权。考虑到没签合同之前，最主要的就是保密，如果将生意公开化，一定会遭到所有人的哄抢，价格自然也会一路飙升。于是特朗普告诉哈尼根：“咱们先拟一份合同草约，写上你同意我出2500万美元买你的地方，前提是我们要制定出双方满意的合同。这样的话，我们都得对这笔生意负责到底。”哈尼根没有任何异议。哈尼根虽然精明，可毕竟不是纽约本地人。他不知道这个地方是个烫手的山芋，即使经济不景气，也有很多人垂青于此。这样，特朗普&lt;strong&gt;不仅口头上谈成了生意，还得到了书面的保障&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;后来特朗普又为银行贷款和上空使用权奔波，一切快准备就续的时候，到了1979年1月，消息泄露了，很多买家找上了格涅斯科公司，包括石油发家的阿拉伯商人。这个时候，之前跟约翰·哈尼根签订的那份合同草约成了保证特朗普生意顺利进行的幸运星。虽然他不敢保证那份草约具有法律约束力，但至少他可以凭此向法院上诉，使邦维泰勒几年之内无法卖出。特朗普要让格涅斯科公司知道，&lt;strong&gt;他们敢毁约，我就敢上诉。而且格涅斯科公司的债权人现在催得很紧，他们没有太多时间为这笔生意周旋&lt;/strong&gt;。不久《纽约时报》记者前来采访特朗普，特朗普干脆放出消息说自己已经跟格涅斯科公司达成了协议，我会在邦维泰勒所在的地方新建一座大厦，所以邦维百货几个月之内就要关闭了。正是这条消息给对方造成了很大的舆论压力，邦维百货的高管纷纷离职，生意做不下去了，消息见报5天后，格涅斯科公司顺利地跟特朗普签订了合同。到1980年3月份，大厦开始动工，落成后成为了北美地区第二高楼。大厦的设计、建造、营销都很成功。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-f85f766619ed9c4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;特朗普大厦&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;要了解一个人不能只听他说什么，还要观察他的行为，特朗普的耐心和谈判技巧毋庸置疑。 此后特朗普集团在酒店赌场、高尔夫球场、溜冰场的建设方面都很出色。一手缔造了他的商业帝国。无疑他是一位非常成功的地产商人，而且是在出手时机，谈判，设计，建造，营销各方面都很出色的商人。&lt;/p&gt;
&lt;h3&gt;爱名狂人&lt;/h3&gt;
&lt;p&gt;这个特点也要从特朗普大厦说起，在建造的过程中，因为他不愿意为几件艺术装饰雕塑花钱，便拆除了他们，没想到却引起了轩然大波，《纽约时报》指责他“高楼大厦的背后没有高尚的人格，大宗生意必然牺牲艺术作品。”，进而后续的许多宣传报道都是负面的，但起到的作用却并不全是消极的，而且新闻报道为特朗普大厦吸引了很多注意力，公寓的销售量也猛增。作为一名商人，特朗普从中悟出一个道理：&lt;strong&gt;好名声比坏名声强，不过，坏名声比没名声强。说白了，争议也能促进销售&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-dda3ed3473628667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;所以我们现在看到的特朗普充满争议性，没准就是他自己想要的结果。比如曾经有一名记者写了一本《特朗普国度》骂他，特朗普就控告该作者以及出版社，有一条他不能忍的是，作者有意把他的财产减少了几十亿美元，说自己最多只有几亿美元。2007年9月，《福布斯》杂志确认特朗普的资产总额上升到了30亿美元。但特朗普认为他们的估计还是太保守了，比其实际资产低很多。&lt;/p&gt;
&lt;p&gt;此外，特朗普非常喜欢用自己的名字命名他的杰作，比如特朗普大厦、特朗普国家高尔夫球场、特朗普苏荷区酒店式公寓、特朗普国际饭店、迪拜的特朗普国际棕榈酒店以及特朗普海滨大道等等。在出书这件事情，他照样也很成功。往往一个爱名的人，比较惜名，因为名誉带来的附加值让维护是值得的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;有人说我言语粗鲁，也有人说我桀骜不驯，还有人说我满嘴废话。这些评价都没错，&lt;strong&gt;我倒是把它们当成了褒奖&lt;/strong&gt;，因为这样的我还实现了这么多成就。我并非做事没有耐心，但是当我意识到应该把注意力集中到别的事情上去的时候，我认为最明智的就是转移精力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实在当选总统之前，特朗普通过《飞黄腾达》真人秀节目，已经成为了一名网红。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果你有自己值得自豪的优点，而且又有足够的理由来支撑自己的这份自信，那么你就大胆秀出你的自信。对于自己取得的成就根本无须遮遮掩掩。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特朗普确实善于作秀。比如他非常期待因为朝鲜核问题而获得诺贝尔和平奖，在郭台铭决定在美国建厂之后，他宣传那是&quot;世界八大奇迹&quot;。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-77c8b410fdc57123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;特朗普参加富士康开工&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;Q&amp;amp;A&lt;/h3&gt;
&lt;p&gt;每年特朗普会收到很多信，他回复了其中的一些问题，我选了几个比较有意思的。&lt;/p&gt;
&lt;p&gt;1.如果你的下属一而再再而三地因为同样的问题出错，你会怎么处理？&lt;/p&gt;
&lt;p&gt;答：我没有这样的下属。这样的人现在应该在为别人效力。&lt;/p&gt;
&lt;p&gt;2.你崇拜哪些历史人物，为什么？&lt;/p&gt;
&lt;p&gt;答：亚伯拉罕·林肯是一个，因为他在我们国家最困难的时候担任总统。他也是自学成才，在成为总统之前还吃了很多年苦。另一位就是温斯顿·丘吉尔，他在人类历史关键的第二次世界大战中挺身而出。他是一位出色的演说家，他那激动人心的演说鼓舞了成千上万人的斗志，他还因为自己写作的历史小说获得了诺贝尔文学奖。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-a18524e02b25470c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;特朗普与里根总统&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;3.对于想自己创业的人，你有什么建议吗？&lt;/p&gt;
&lt;p&gt;答：准备好迎接各种各样的问题，它们每天都会发生。不论发生什么问题，你都要打起精神来，要有兵来将挡、水来土掩的气概。永不放弃！&lt;/p&gt;
&lt;p&gt;4.即便我们已经努力奋斗了，但结果还是不如人意该怎么办呢？&lt;/p&gt;
&lt;p&gt;答：首先你要知道有这种疑虑的不仅仅是你一个人。我曾经为了等待某些事的发生花了整整30年，有些人等待了比我更长的时间。你要想到自己做的事有可能并不正确，因此不管你多么努力都看不到成效。但是，你要确信自己手里干的事是适合自己的，你要喜欢自己所干的事业，并坚持到底。&lt;/p&gt;
&lt;p&gt;5.你小时候的梦想是什么？&lt;/p&gt;
&lt;p&gt;答：我的梦想是要么当棒球运动员，要么当建筑商。我喜欢用自己的积木来搭建摩天大楼。我的棒球打得也很好，还因此得到了奖学金。我曾经想过去美国南加州大学进修电影拍摄，但因为对房地产业的了解和热爱让我最终选择了沃顿商学院。&lt;/p&gt;
&lt;h3&gt;这样的对手&lt;/h3&gt;
&lt;p&gt;特朗普高调、聪明，在谈判中发现了对方的弱点会毫不吝啬的杀价，为做好一件事他有十足的耐心和充分的准备。他爱名，但也很乐意成为争论的焦点。回顾贸易战前夕，特朗普与2017年11月份来华访问，三天拿下了两千多亿美元的订单，回去没多久就开始变脸，但变脸的时候还不忘说一句和我们的习大大是好朋友。真是得了便宜还卖乖，而且谈判期间揪住中兴死死不放，直到开出天价罚单，现在中兴也是刚从ICU出来，头上的氧气管子还被美国捏在手里。这一切基本上美方是按照剧本在本色出演。&lt;/p&gt;
&lt;p&gt;我不清楚管理企业和管理国家有多大的区别，企业竞争可以吃掉对手，但国家之间多是寻求互利共赢。很显然，特朗普正在像治理企业一样治理国家，为了企业有更好的发展，于是先退出巴黎气候协定，降低国内企业税收。然后为了让本国企业在国外有多的销路和竞争力，于是发动贸易战，贸易战的初衷之一就是各国有同样互惠的关税。但美国优先和以邻为壑的态度还是激起了全世界的反击，不见得是一条正确的路。面对特朗普这样的人，就如他自己所说的一样，在强势的对手面前，你也要保持强势，并且尊重对方，才有可能获得公平相待。以其人之道还治其人之身。另外就是要有十足的准备，不要对其抱有侥幸心理。按照既定目标，不断前进，不受其阻扰。&lt;/p&gt;
&lt;p&gt;最后说明一下，其实《永不放弃》和《从20万到30亿》中大量素材是重复的，基本上都是特朗普引以为傲的地产项目，前者更像是一位成功学导师的姿态灌输鸡汤，后者更贴近原型。如果你时间有限，我建议你读《从20万到30亿：特朗普自传》，这里有很多谈判协商的细节。想要资源可以留言&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 13:45:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/9281409.html</dc:identifier>
</item>
<item>
<title>（一）mvc与mvvm设计模式 - 狗尾草的博客</title>
<link>http://www.cnblogs.com/bgwhite/p/9281332.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bgwhite/p/9281332.html</guid>
<description>&lt;p&gt;&lt;span&gt;前沿：了解设计模式对我们而言，具有很大意义，对语言没有限制，它适用于任何语言，是一种变成思想。&lt;/span&gt;设计模式最初有四人帮提出，有兴趣的同学可以去了解下，今天给大家主要分析mvc与mvvm设计模式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.mvc设计模式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;字面理解，mvc就是model，view，controller。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    三者又分别是什么呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    model有模型的意思，不过这里他代表的数据模型。就是说整个项目运行中担任了数据供给的部分。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    view是视图的意思，这里代表即前端ui视图，就是界面。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    cotroller是控制器的意思，在mvc中起着关联view与model的作用。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    三者如何团结合作完成项目的运行呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    先来说说前端工程师等级的区别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们说前端程序员的等级可以通过分析设计稿看出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    较为初级的拿到设计稿。第一眼看到的往往是视图界面，    设计稿上有哪些功能，颜色分类，层级等。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    中级的前端开发工程师拿到设计稿后，第一眼往往会看设计稿有那些功能，轮播图，分页，三级联动等等。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    而高级开发工程师在看到设计稿后，往往会思考，该页面中有哪些模块，那些数据分类。如广告，商品列表等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    一个前端项目的完成往往是从建模开始，又牵扯到一个问题，什么是建模?&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    建模说白了，就是对ui视图即界面的抽象。抽象这一过程就是将页面中的数据分类并分离出来。其实掌握了 这一点，在开发的过程中，往往在没有后端数据的 情况下，可以精确的mock出准备的数据。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    回到三者的团结运行，view视图还原成功后，静态页面就算是完成了，要实现动态，我们就需要从model（数据模型）中拿到我们需要的数据。在这个过程中，view会去controller中查找属性和方法。属性从model中拿到数据后反馈给view，最终完成数据的渲染并展示在用户眼前。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    值得我们注意的是，mvc的流程中 ，controller其实是被动的一个过程，被动接受view发起的请求，然后进行相应的处理。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.mvvm设计模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    model（数据模型），view（视图），viewmodel（视图模型）&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;大家可以看到，里面是没有controller了，但是他将viewmodel代替了controller。在运行过程中起了view和 model的链接桥梁，但是又有一点区别与mvc的是，mvc中被动接受view请求的controller在这里，viewmodel给他做了升级，不再是被动接受，而是不断监听view，当有新的需求时，就去链接model拿去数据，然后返回给页面，很好的将view和model做了分离，使view和viewmodel可以独立完成开发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   缺点：不断的监听页面，性能消耗很大！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三.mvc和mvvm的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    1.mvc中controller是被动接受请求，而mvvm中作为控制器这一环节的是主动地。&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    2.mvc中view可以直接访问model，因此view中必然包含了业务逻辑，并没有实现view和model的分离，而mvvm主要是通过数据的双向绑定机制，在js中实现业务逻辑，进行view和model的关联，因此mvvm真正意义上实现了view和model的分离。&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 以上就是总结的有关mvc与mvvm的设计模式，不过都还比较浅层，如果要继续深究，可以关注这几个词汇：脏治检查，数据监听，劫持。好了就总结到这里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有什么问题记得评论，24小时答复。我们一起 进步！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 13:21:00 +0000</pubDate>
<dc:creator>狗尾草的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bgwhite/p/9281332.html</dc:identifier>
</item>
<item>
<title>深入理解String, StringBuffer, StringBuilder的区别（基于JDK1.8） - 姜小泮</title>
<link>http://www.cnblogs.com/jpcflyer/p/9280501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpcflyer/p/9280501.html</guid>
<description>&lt;p&gt;&lt;span&gt;        String、StringBuffer、StringBuilder都是JAVA中常用的字符串操作类，对于他们的区别大家也都能耳熟能详，但底层到底是怎样实现的呢？今天就再深入分析下这三种字符串操作的区别、各自的原理及使用场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       请尊重作者劳动成果，转载请标明原文链接：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 深入理解String, StringBuffer, StringBuilder的区别（基于JDK1.8）&quot; href=&quot;https://www.cnblogs.com/jpcflyer/p/9280501.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/jpcflyer/p/9280501.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、String&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       先来看一下JDK中String中的部分源码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_ae05d225-2490-4cd1-b7bf-64fb802b147f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ae05d225-2490-4cd1-b7bf-64fb802b147f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_ae05d225-2490-4cd1-b7bf-64fb802b147f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; String
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt; java.io.Serializable, Comparable&amp;lt;String&amp;gt;&lt;span&gt;, CharSequence {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt; value[];
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Default to 0&lt;/span&gt;

     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[0&lt;span&gt;];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String(String original) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; original.value;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hash =&lt;span&gt; original.hash;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; value[]) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; Arrays.copyOf(value, value.length);
    }    
    
    ...
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        可以看到String类、以及value都是final类型的，这样就表明String是无法被继承的，value是无法被改写的。当通过String的构造函数初始化新的String对象时，也只是根据传入的引用对象的value和hashcode进行了赋值。看下面的例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_4c7b2972-c076-4287-bd9e-3c0ce0bc921f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4c7b2972-c076-4287-bd9e-3c0ce0bc921f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_4c7b2972-c076-4287-bd9e-3c0ce0bc921f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String str1 &lt;/span&gt;= &quot;abc&quot;&lt;span&gt;;
        String str2 &lt;/span&gt;= &quot;abc&quot;&lt;span&gt;;
        String Str3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;abc&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Vew Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       执行javac StringTest.java后，通过javap -v StringTest.class看下生成的class文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_04e630b7-f02b-4aaa-b300-5b3914ef2d8d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_04e630b7-f02b-4aaa-b300-5b3914ef2d8d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_04e630b7-f02b-4aaa-b300-5b3914ef2d8d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Classfile /C:/Users/jiang/workspace/test/src/test/StringTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;
  Last modified &lt;/span&gt;2018-7-8; size 363&lt;span&gt; bytes
  MD5 checksum f7e4243b0247fb20c5a336d4ba0a580f
  Compiled from &lt;/span&gt;&quot;StringTest.java&quot;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; test.StringTest
  minor version: &lt;/span&gt;0&lt;span&gt;
  major version: &lt;/span&gt;52&lt;span&gt;
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #&lt;/span&gt;1 = Methodref          #6.#15         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
   #2 = String             #16            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; abc&lt;/span&gt;
   #3 = Class              #17            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/String&lt;/span&gt;
   #4 = Methodref          #3.#18         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/String.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V&lt;/span&gt;
   #5 = Class              #19            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; test/StringTest&lt;/span&gt;
   #6 = Class              #20            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/Object&lt;/span&gt;
   #7 = Utf8               &amp;lt;init&amp;gt;&lt;span&gt;
   #&lt;/span&gt;8 =&lt;span&gt; Utf8               ()V
   #&lt;/span&gt;9 =&lt;span&gt; Utf8               Code
  #&lt;/span&gt;10 =&lt;span&gt; Utf8               LineNumberTable
  #&lt;/span&gt;11 =&lt;span&gt; Utf8               main
  #&lt;/span&gt;12 = Utf8               ([Ljava/lang/&lt;span&gt;String;)V
  #&lt;/span&gt;13 =&lt;span&gt; Utf8               SourceFile
  #&lt;/span&gt;14 =&lt;span&gt; Utf8               StringTest.java
  #&lt;/span&gt;15 = NameAndType        #7:#8          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
  #16 =&lt;span&gt; Utf8               abc
  #&lt;/span&gt;17 = Utf8               java/lang/&lt;span&gt;String
  #&lt;/span&gt;18 = NameAndType        #7:#21         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V&lt;/span&gt;
  #19 = Utf8               test/&lt;span&gt;StringTest
  #&lt;/span&gt;20 = Utf8               java/lang/&lt;span&gt;Object
  #&lt;/span&gt;21 = Utf8               (Ljava/lang/&lt;span&gt;String;)V
{
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; test.StringTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack&lt;/span&gt;=1, locals=1, args_size=1
         0&lt;span&gt;: aload_0
         &lt;/span&gt;1: invokespecial #1                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
         4: &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      LineNumberTable:
        line &lt;/span&gt;3: 0

  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(java.lang.String[]);
    descriptor: ([Ljava&lt;/span&gt;/lang/&lt;span&gt;String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack&lt;/span&gt;=3, locals=4, args_size=1
         0: ldc           #2                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; String abc&lt;/span&gt;
         2&lt;span&gt;: astore_1
         &lt;/span&gt;3: ldc           #2                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; String abc&lt;/span&gt;
         5&lt;span&gt;: astore_2
         &lt;/span&gt;6: &lt;span&gt;new&lt;/span&gt;           #3                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; class java/lang/String&lt;/span&gt;
         9&lt;span&gt;: dup
        &lt;/span&gt;10: ldc           #2                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; String abc&lt;/span&gt;
        12: invokespecial #4                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/String.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V&lt;/span&gt;
        15&lt;span&gt;: astore_3
        &lt;/span&gt;16: &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      LineNumberTable:
        line &lt;/span&gt;6: 0&lt;span&gt;
        line &lt;/span&gt;7: 3&lt;span&gt;
        line &lt;/span&gt;8: 6&lt;span&gt;
        line &lt;/span&gt;9: 16&lt;span&gt;
}
SourceFile: &lt;/span&gt;&quot;StringTest.java&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        可以看到对于相同的字符串“abc”的引用都是相同的（对于常量池中的相同位置），这样能够节省内存空间，但是缺点就是对于频繁的字符串拼接操作，会造成内存空间的浪费。（&lt;span&gt;需要注意的是这种字符串的拼接操作，从JDK8 开始，会自动被编译成StringBuilder，是不是很666^_^，但还是建议不通过JDK途径去自动转。&lt;/span&gt;）看下面的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_c325b65a-6efe-4c2e-bbe5-9539e0bbb7ca&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c325b65a-6efe-4c2e-bbe5-9539e0bbb7ca&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_c325b65a-6efe-4c2e-bbe5-9539e0bbb7ca&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String str1 &lt;/span&gt;= &quot;abc&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String str2 = &quot;abc&quot;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String str3 = new String(&quot;abc&quot;);&lt;/span&gt;
        String str4 = str1 + &quot;d&quot;&lt;span&gt;;
        String str5 &lt;/span&gt;= str4 + &quot;e&quot;&lt;span&gt;;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       然后再通过javap看下class文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_140bd427-47aa-44a7-8892-7dc3d35c4950&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_140bd427-47aa-44a7-8892-7dc3d35c4950&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_140bd427-47aa-44a7-8892-7dc3d35c4950&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Classfile /C:/Users/jiang/workspace/test/src/test/StringTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;
  Last modified &lt;/span&gt;2018-7-8; size 493&lt;span&gt; bytes
  MD5 checksum c02bd18ed3ecbe46f9859bf5e272c663
  Compiled from &lt;/span&gt;&quot;StringTest.java&quot;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; test.StringTest
  minor version: &lt;/span&gt;0&lt;span&gt;
  major version: &lt;/span&gt;52&lt;span&gt;
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #&lt;/span&gt;1 = Methodref          #10.#19        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
   #2 = String             #20            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; abc&lt;/span&gt;
   #3 = Class              #21            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/StringBuilder&lt;/span&gt;
   #4 = Methodref          #3.#19         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/StringBuilder.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
   #5 = Methodref          #3.#22         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;/span&gt;
   #6 = String             #23            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; d&lt;/span&gt;
   #7 = Methodref          #3.#24         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/StringBuilder.toString:()Ljava/lang/String;&lt;/span&gt;
   #8 = String             #25            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;
   #9 = Class              #26            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; test/StringTest&lt;/span&gt;
  #10 = Class              #27            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java/lang/Object&lt;/span&gt;
  #11 = Utf8               &amp;lt;init&amp;gt;&lt;span&gt;
  #&lt;/span&gt;12 =&lt;span&gt; Utf8               ()V
  #&lt;/span&gt;13 =&lt;span&gt; Utf8               Code
  #&lt;/span&gt;14 =&lt;span&gt; Utf8               LineNumberTable
  #&lt;/span&gt;15 =&lt;span&gt; Utf8               main
  #&lt;/span&gt;16 = Utf8               ([Ljava/lang/&lt;span&gt;String;)V
  #&lt;/span&gt;17 =&lt;span&gt; Utf8               SourceFile
  #&lt;/span&gt;18 =&lt;span&gt; Utf8               StringTest.java
  #&lt;/span&gt;19 = NameAndType        #11:#12        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
  #20 =&lt;span&gt; Utf8               abc
  #&lt;/span&gt;21 = Utf8               java/lang/&lt;span&gt;StringBuilder
  #&lt;/span&gt;22 = NameAndType        #28:#29        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;/span&gt;
  #23 =&lt;span&gt; Utf8               d
  #&lt;/span&gt;24 = NameAndType        #30:#31        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; toString:()Ljava/lang/String;&lt;/span&gt;
  #25 =&lt;span&gt; Utf8               e
  #&lt;/span&gt;26 = Utf8               test/&lt;span&gt;StringTest
  #&lt;/span&gt;27 = Utf8               java/lang/&lt;span&gt;Object
  #&lt;/span&gt;28 =&lt;span&gt; Utf8               append
  #&lt;/span&gt;29 = Utf8               (Ljava/lang/String;)Ljava/lang/&lt;span&gt;StringBuilder;
  #&lt;/span&gt;30 =&lt;span&gt; Utf8               toString
  #&lt;/span&gt;31 = Utf8               ()Ljava/lang/&lt;span&gt;String;
{
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; test.StringTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack&lt;/span&gt;=1, locals=1, args_size=1
         0&lt;span&gt;: aload_0
         &lt;/span&gt;1: invokespecial #1                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
         4: &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      LineNumberTable:
        line &lt;/span&gt;3: 0

  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(java.lang.String[]);
    descriptor: ([Ljava&lt;/span&gt;/lang/&lt;span&gt;String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack&lt;/span&gt;=2, locals=4, args_size=1
         0: ldc           #2                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; String abc&lt;/span&gt;
         2&lt;span&gt;: astore_1
         &lt;/span&gt;3: &lt;span&gt;new&lt;/span&gt;           #3                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; class java/lang/StringBuilder&lt;/span&gt;
         6&lt;span&gt;: dup
         &lt;/span&gt;7: invokespecial #4                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/StringBuilder.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
        10&lt;span&gt;: aload_1
        &lt;/span&gt;11: invokevirtual #5                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;/span&gt;
        14: ldc           #6                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; String d&lt;/span&gt;
        16: invokevirtual #5                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;/span&gt;
        19: invokevirtual #7                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/StringBuilder.toString:()Ljava/lang/String;&lt;/span&gt;
        22&lt;span&gt;: astore_2
        &lt;/span&gt;23: &lt;span&gt;new&lt;/span&gt;           #3                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; class java/lang/StringBuilder&lt;/span&gt;
        26&lt;span&gt;: dup
        &lt;/span&gt;27: invokespecial #4                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/StringBuilder.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;
        30&lt;span&gt;: aload_2
        &lt;/span&gt;31: invokevirtual #5                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;/span&gt;
        34: ldc           #8                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; String e&lt;/span&gt;
        36: invokevirtual #5                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;/span&gt;
        39: invokevirtual #7                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method java/lang/StringBuilder.toString:()Ljava/lang/String;&lt;/span&gt;
        42&lt;span&gt;: astore_3
        &lt;/span&gt;43: &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      LineNumberTable:
        line &lt;/span&gt;6: 0&lt;span&gt;
        line &lt;/span&gt;9: 3&lt;span&gt;
        line &lt;/span&gt;10: 23&lt;span&gt;
        line &lt;/span&gt;11: 43&lt;span&gt;
}
SourceFile: &lt;/span&gt;&quot;StringTest.java&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、StringBuilder&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       也是先来看StringBuilder的源码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_6f3798d5-e1e3-491b-b569-bb75a9129001&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6f3798d5-e1e3-491b-b569-bb75a9129001&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_6f3798d5-e1e3-491b-b569-bb75a9129001&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringBuilder
    &lt;/span&gt;&lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractStringBuilder
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.io.Serializable, CharSequence
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringBuilder() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(16&lt;span&gt;);
    }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringBuilder(String str) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(str.length() + 16&lt;span&gt;);
        append(str);
    }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringBuilder append(String str) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.append(str);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
    
    ...
}

&lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractStringBuilder &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Appendable, CharSequence {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;[] value;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
        AbstractStringBuilder(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
        value &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt;[capacity];
    }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AbstractStringBuilder append(String str) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; appendNull();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; str.length();
        ensureCapacityInternal(count &lt;/span&gt;+&lt;span&gt; len);
        str.getChars(&lt;/span&gt;0&lt;span&gt;, len, value, count);
        count &lt;/span&gt;+=&lt;span&gt; len;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    ...
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        可以看到StringBuilder的value是个char数组，（&lt;span&gt;当然从JDK9开始，value从char数组变成了byte数组&lt;/span&gt;）。每次append时都是通过调用native的System.arraycopy实现的（在getChars中调用的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、StringBuffer&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;S       tringBuffer的源码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_dfb3f0cb-b2ab-4aa3-a8a3-4d88caa6c45f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dfb3f0cb-b2ab-4aa3-a8a3-4d88caa6c45f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_dfb3f0cb-b2ab-4aa3-a8a3-4d88caa6c45f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringBuffer
    &lt;/span&gt;&lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractStringBuilder
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.io.Serializable, CharSequence
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt;[] toStringCache;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringBuffer() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(16&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringBuffer(String str) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(str.length() + 16&lt;span&gt;);
        append(str);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; StringBuffer append(String str) {
        toStringCache &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.append(str);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
    ...
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        和StringBuilder一样，都是用了char数组保存value，append也是调用了AbstractStringBuilder的append方法。区别只是在于char数组加了transient关键字，以及方法上加了synchronized方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       综上所述，String、StringBuilder、StringBuffer的使用场景如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       当处理定长字符串时，建议用String；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       当处理变长字符串时，并且是单线程环境时，建议用StringBuilder；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       当处理变长字符串时，并且是多线程环境时，建议用StringBuffer。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 13:08:00 +0000</pubDate>
<dc:creator>姜小泮</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jpcflyer/p/9280501.html</dc:identifier>
</item>
<item>
<title>Javascript装饰器的妙用 - 贾顺名</title>
<link>http://www.cnblogs.com/jiasm/p/9281113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiasm/p/9281113.html</guid>
<description>&lt;p&gt;最近新开了一个Node项目，采用TypeScript来开发，在数据库及路由管理方面用了不少的装饰器，发觉这的确是一个好东西。&lt;br/&gt;装饰器是一个还处于草案中的特性，目前木有直接支持该语法的环境，但是可以通过 babel 之类的进行转换为旧语法来实现效果，所以在TypeScript中，可以放心的使用&lt;code&gt;@Decorator&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;什么是装饰器&quot;&gt;什么是装饰器&lt;/h2&gt;
&lt;p&gt;装饰器是对类、函数、属性之类的一种装饰，可以针对其添加一些额外的行为。&lt;br/&gt;通俗的理解可以认为就是在原有代码外层包装了一层处理逻辑。&lt;br/&gt;个人认为装饰器是一种解决方案，而并非是狭义的&lt;code&gt;@Decorator&lt;/code&gt;，后者仅仅是一个语法糖罢了。&lt;/p&gt;
&lt;p&gt;装饰器在身边的例子随处可见，一个简单的例子，水龙头上边的起泡器就是一个装饰器，在装上以后就会把空气混入水流中，掺杂很多泡泡在水里。&lt;br/&gt;但是起泡器安装与否对水龙头本身并没有什么影响，即使拆掉起泡器，也会照样工作，水龙头的作用在于阀门的控制，至于水中掺不掺杂气泡则不是水龙头需要关心的。&lt;/p&gt;
&lt;p&gt;所以，对于装饰器，可以简单地理解为是非侵入式的行为修改。&lt;/p&gt;
&lt;h2 id=&quot;为什么要用装饰器&quot;&gt;为什么要用装饰器&lt;/h2&gt;
&lt;p&gt;可能有些时候，我们会对传入参数的类型判断、对返回值的排序、过滤，对函数添加节流、防抖或其他的功能性代码，基于多个类的继承，各种各样的与函数逻辑本身无关的、重复性的代码。&lt;/p&gt;
&lt;h3 id=&quot;函数中的作用&quot;&gt;函数中的作用&lt;/h3&gt;
&lt;p&gt;可以想像一下，我们有一个工具类，提供了一个获取数据的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Model1 {
  getData() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处省略获取数据的逻辑&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [{
      id: &lt;/span&gt;1&lt;span&gt;,
      name: &lt;/span&gt;'Niko'&lt;span&gt;
    }, {
      id: &lt;/span&gt;2&lt;span&gt;,
      name: &lt;/span&gt;'Bellic'&lt;span&gt;
    }]
  }
}

console.log(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Model1().getData())     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ { id: 1, name: 'Niko'}, { id: 2, name: 'Bellic' } ]&lt;/span&gt;
console.log(Model1.prototype.getData()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ { id: 1, name: 'Niko'}, { id: 2, name: 'Bellic' } ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在我们想要添加一个功能，记录该函数执行的耗时。&lt;br/&gt;因为这个函数被很多人使用，在调用方添加耗时统计逻辑是不可取的，所以我们要在&lt;code&gt;Model1&lt;/code&gt;中进行修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Model1 {
  getData() {
&lt;/span&gt;+   let start = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
&lt;/span&gt;+   &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处省略获取数据的逻辑&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [{
        id: &lt;/span&gt;1&lt;span&gt;,
        name: &lt;/span&gt;'Niko'&lt;span&gt;
      }, {
        id: &lt;/span&gt;2&lt;span&gt;,
        name: &lt;/span&gt;'Bellic'&lt;span&gt;
      }]
&lt;/span&gt;+   } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;+     let end = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
&lt;/span&gt;+     console.log(`start: ${start} end: ${end} consume: ${end -&lt;span&gt; start}`)
&lt;/span&gt;+&lt;span&gt;   }
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; start: XXX end: XXX consume: XXX&lt;/span&gt;
console.log(&lt;span&gt;new&lt;/span&gt; Model1().getData())     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ { id: 1, name: 'Niko'}, { id: 2, name: 'Bellic' } ]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; start: XXX end: XXX consume: XXX&lt;/span&gt;
console.log(Model1.prototype.getData()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ { id: 1, name: 'Niko'}, { id: 2, name: 'Bellic' } ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样在调用方法后我们就可以在控制台看到耗时的输出了。&lt;br/&gt;但是这样直接修改原函数代码有以下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;统计耗时的相关代码与函数本身逻辑并无一点关系，影响到了对原函数本身的理解，对函数结构造成了破坏性的修改&lt;/li&gt;
&lt;li&gt;如果后期还有更多类似的函数需要添加统计耗时的代码，在每个函数中都添加这样的代码显然是低效的，维护成本太高&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以，为了让统计耗时的逻辑变得更加灵活，我们将创建一个新的工具函数，用来包装需要设置统计耗时的函数。&lt;br/&gt;通过将&lt;code&gt;Class&lt;/code&gt;与目标函数的&lt;code&gt;name&lt;/code&gt;传递到函数中，实现了通用的耗时统计：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; wrap(Model, key) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Class对应的原型&lt;/span&gt;
  let target =&lt;span&gt; Model.prototype

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取函数对应的描述符&lt;/span&gt;
  let descriptor =&lt;span&gt; Object.getOwnPropertyDescriptor(target, key)

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成新的函数，添加耗时统计逻辑&lt;/span&gt;
  let log = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (...arg) {
    let start &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; descriptor.value.apply(&lt;span&gt;this&lt;/span&gt;, arg) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用之前的函数&lt;/span&gt;
    } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
      let end &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
      console.log(`start: ${start} end: ${end} consume: ${end &lt;/span&gt;-&lt;span&gt; start}`)
    }
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将修改后的函数重新定义到原型链上&lt;/span&gt;
&lt;span&gt;  Object.defineProperty(target, key, {
    ...descriptor,
    value: log      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 覆盖描述符重的value&lt;/span&gt;
&lt;span&gt;  })
}

wrap(Model1, &lt;/span&gt;'getData'&lt;span&gt;)
wrap(Model2, &lt;/span&gt;'getData'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; start: XXX end: XXX consume: XXX&lt;/span&gt;
console.log(&lt;span&gt;new&lt;/span&gt; Model1().getData())     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ { id: 1, name: 'Niko'}, { id: 2, name: 'Bellic' } ]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; start: XXX end: XXX consume: XXX&lt;/span&gt;
console.log(Model2.prototype.getData()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ { id: 1, name: 'Niko'}, { id: 2, name: 'Bellic' } ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来，我们想控制其中一个&lt;code&gt;Model&lt;/code&gt;的函数不可被其他人修改覆盖，所以要添加一些新的逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; wrap(Model, key) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Class对应的原型&lt;/span&gt;
  let target =&lt;span&gt; Model.prototype

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取函数对应的描述符&lt;/span&gt;
  let descriptor =&lt;span&gt; Object.getOwnPropertyDescriptor(target, key)

  Object.defineProperty(target, key, {
    ...descriptor,
    writable: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置属性不可被修改&lt;/span&gt;
&lt;span&gt;  })
}

wrap(Model1, &lt;/span&gt;'getData')
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;line-numbers language-javascript&quot;&gt;
&lt;code class=&quot; language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token function&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，两个&lt;code&gt;wrap&lt;/code&gt;函数中有不少重复的地方，而修改程序行为的逻辑，实际上依赖的是&lt;code&gt;Object.defineProperty&lt;/code&gt;中传递的三个参数。&lt;br/&gt;所以，我们针对&lt;code&gt;wrap&lt;/code&gt;在进行一次修改，将其变为一个通用类的转换：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; wrap(decorator) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (Model, key) {
    let target &lt;/span&gt;=&lt;span&gt; Model.prototype
    let dscriptor &lt;/span&gt;=&lt;span&gt; Object.getOwnPropertyDescriptor(target, key)

    decorator(target, key, descriptor)
  }
}

let log &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (target, key, descriptor) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将修改后的函数重新定义到原型链上&lt;/span&gt;
&lt;span&gt;  Object.defineProperty(target, key, {
    ...descriptor,
    value: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (...arg) {
      let start &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; descriptor.value.apply(&lt;span&gt;this&lt;/span&gt;, arg) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用之前的函数&lt;/span&gt;
      } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        let end &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
        console.log(`start: ${start} end: ${end} consume: ${end &lt;/span&gt;-&lt;span&gt; start}`)
      }
    }
  })
}

let seal &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (target, key, descriptor) {
  Object.defineProperty(target, key, {
    ...descriptor,
    writable: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  })
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数的转换处理&lt;/span&gt;
log =&lt;span&gt; wrap(log)
seal &lt;/span&gt;=&lt;span&gt; warp(seal)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加耗时统计&lt;/span&gt;
log(Model1, 'getData'&lt;span&gt;)
log(Model2, &lt;/span&gt;'getData'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置属性不可被修改&lt;/span&gt;
seal(Model1, 'getData')
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;到了这一步以后，我们就可以称&lt;code&gt;log&lt;/code&gt;和&lt;code&gt;seal&lt;/code&gt;为装饰器了，可以很方便的让我们对一些函数添加行为。&lt;br/&gt;而拆分出来的这些功能可以用于未来可能会有需要的地方，而不用重新开发一遍相同的逻辑。&lt;/p&gt;
&lt;h3 id=&quot;Class-中的作用&quot;&gt;Class 中的作用&lt;/h3&gt;
&lt;p&gt;就像上边提到了，现阶段在JS中继承多个&lt;code&gt;Class&lt;/code&gt;是一件头疼的事情，没有直接的语法能够继承多个 Class。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
class A { say () { &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt; } }
class B { hi () { &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 2&lt;span&gt; } }
class C extends A, B {}        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Error&lt;/span&gt;
class C extends A extends B {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Error&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这样才是可以的&lt;/span&gt;
&lt;span&gt;class C {}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let key of Object.getOwnPropertyNames(A.prototype)) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key === 'constructor') &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
  Object.defineProperty(C.prototype, key, Object.getOwnPropertyDescriptor(A.prototype, key))
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let key of Object.getOwnPropertyNames(B.prototype)) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key === 'constructor') &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
  Object.defineProperty(C.prototype, key, Object.getOwnPropertyDescriptor(B.prototype, key))
}

let c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; C()
console.log(c.say(), c.hi()) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1, 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以，在&lt;code&gt;React&lt;/code&gt;中就有了一个&lt;code&gt;mixin&lt;/code&gt;的概念，用来将多个&lt;code&gt;Class&lt;/code&gt;的功能复制到一个新的&lt;code&gt;Class&lt;/code&gt;上。&lt;br/&gt;大致思路就是上边列出来的，但是这个&lt;code&gt;mixin&lt;/code&gt;是&lt;code&gt;React&lt;/code&gt;中内置的一个操作，我们可以将其转换为更接近装饰器的实现。&lt;br/&gt;在不修改原&lt;code&gt;Class&lt;/code&gt;的情况下，将其他&lt;code&gt;Class&lt;/code&gt;的属性复制过来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mixin(constructor) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (...args) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let arg of args) {
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let key of Object.getOwnPropertyNames(arg.prototype)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key === 'constructor') &lt;span&gt;continue&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳过构造函数&lt;/span&gt;
&lt;span&gt;        Object.defineProperty(constructor.prototype, key, Object.getOwnPropertyDescriptor(arg.prototype, key))
      }
    }
  }
}

mixin(C)(A, B)

let c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; C()
console.log(c.say(), c.hi()) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1, 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上，就是装饰器在函数、&lt;code&gt;Class&lt;/code&gt;上的实现方法（至少目前是的），但是草案中还有一颗特别甜的语法糖，也就是&lt;code&gt;@Decorator&lt;/code&gt;了。&lt;br/&gt;能够帮你省去很多繁琐的步骤来用上装饰器。&lt;/p&gt;
&lt;h2 id=&quot;Decorator的使用方法&quot;&gt;@Decorator的使用方法&lt;/h2&gt;
&lt;p&gt;草案中的装饰器、或者可以说是TS实现的装饰器，将上边的两种进一步地封装，将其拆分成为更细的装饰器应用，目前支持以下几处使用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Class&lt;/li&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;li&gt;get set访问器&lt;/li&gt;
&lt;li&gt;实例属性、静态函数及属性&lt;/li&gt;
&lt;li&gt;函数参数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;@Decorator的语法规定比较简单，就是通过&lt;code&gt;@&lt;/code&gt;符号后边跟一个装饰器函数的引用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@tag
class A { 
  @method
  hi () {}
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; tag(constructor) {
  console.log(constructor &lt;/span&gt;=== A) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; method(target) {
  console.log(target.constructor &lt;/span&gt;=== A, target === A.prototype) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true, true&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;函数&lt;code&gt;tag&lt;/code&gt;与&lt;code&gt;method&lt;/code&gt;会在&lt;code&gt;class A&lt;/code&gt;定义的时候执行。&lt;/p&gt;
&lt;h3 id=&quot;Decorator-在-Class-中的使用&quot;&gt;@Decorator 在 Class 中的使用&lt;/h3&gt;
&lt;p&gt;该装饰器会在class定义前调用，如果函数有返回值，则会认为是一个新的构造函数来替代之前的构造函数。&lt;/p&gt;
&lt;p&gt;函数接收一个参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;constructor 之前的构造函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们可以针对原有的构造函数进行一些改造:&lt;/p&gt;
&lt;h4 id=&quot;新增一些属性&quot;&gt;新增一些属性&lt;/h4&gt;
&lt;p&gt;如果想要新增一些属性之类的，有两种方案可以选择：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个新的&lt;code&gt;class&lt;/code&gt;继承自原有&lt;code&gt;class&lt;/code&gt;，并添加属性&lt;/li&gt;
&lt;li&gt;针对当前&lt;code&gt;class&lt;/code&gt;进行修改&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;后者的适用范围更窄一些，更接近mixin的处理方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@name
class Person {
  sayHi() {
    console.log(`My name is: ${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name}`)
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个继承自Person的匿名类&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 直接返回并替换原有的构造函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; name(constructor) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; class extends constructor {
    name &lt;/span&gt;= 'Niko'&lt;span&gt;
  }
}

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person().sayHi()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;修改原有属性的描述符&quot;&gt;修改原有属性的描述符&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@seal
class Person {
  sayHi() {}
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; seal(constructor) {
  let descriptor &lt;/span&gt;= Object.getOwnPropertyDescriptor(constructor.prototype, 'sayHi'&lt;span&gt;)
  Object.defineProperty(constructor.prototype, &lt;/span&gt;'sayHi'&lt;span&gt;, {
    ...descriptor,
    writable: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  })
}

Person.prototype.sayHi &lt;/span&gt;= 1 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无效&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;使用闭包来增强装饰器的功能&quot;&gt;使用闭包来增强装饰器的功能&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在TS文档中被称为装饰器工厂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为&lt;code&gt;@&lt;/code&gt;符号后边跟的是一个函数的引用，所以对于mixin的实现，我们可以很轻易的使用闭包来实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
class A { say() { &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt; } }
class B { hi() { &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 2&lt;span&gt; } }

@mixin(A, B)
class C { }

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mixin(...args) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用函数返回装饰器实际应用的函数&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(constructor) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let arg of args) {
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let key of Object.getOwnPropertyNames(arg.prototype)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key === 'constructor') &lt;span&gt;continue&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳过构造函数&lt;/span&gt;
&lt;span&gt;        Object.defineProperty(constructor.prototype, key, Object.getOwnPropertyDescriptor(arg.prototype, key))
      }
    }
  }
}

let c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; C()
console.log(c.say(), c.hi()) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1, 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;多个装饰器的应用&quot;&gt;多个装饰器的应用&lt;/h4&gt;
&lt;p&gt;装饰器是可以同时应用多个的（不然也就失去了最初的意义）。&lt;br/&gt;用法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@decorator1
@decorator2
class { }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行的顺序为&lt;code&gt;decorator2&lt;/code&gt; -&amp;gt; &lt;code&gt;decorator1&lt;/code&gt;，离&lt;code&gt;class&lt;/code&gt;定义最近的先执行。&lt;br/&gt;可以想像成函数嵌套的形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
decorator1(decorator2(class {}))
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;Decorator-在-Class-成员中的使用&quot;&gt;@Decorator 在 Class 成员中的使用&lt;/h3&gt;
&lt;p&gt;类成员上的 @Decorator 应该是应用最为广泛的一处了，函数，属性，&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;访问器，这几处都可以认为是类成员。&lt;br/&gt;在TS文档中被分为了&lt;code&gt;Method Decorator&lt;/code&gt;、&lt;code&gt;Accessor Decorator&lt;/code&gt;和&lt;code&gt;Property Decorator&lt;/code&gt;，实际上如出一辙。&lt;/p&gt;
&lt;p&gt;关于这类装饰器，会接收如下三个参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型&lt;/li&gt;
&lt;li&gt;装饰器挂载的成员名称&lt;/li&gt;
&lt;li&gt;成员的描述符，也就是&lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt;的返回值&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;Property Decorator&lt;/code&gt;不会返回第三个参数，但是可以自己手动获取&lt;br/&gt;前提是静态成员，而非实例成员，因为装饰器都是运行在类创建时，而实例成员是在实例化一个类的时候才会执行的，所以没有办法获取对应的descriptor&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;静态成员与实例成员在返回值上的区别&quot;&gt;静态成员与实例成员在返回值上的区别&lt;/h4&gt;
&lt;p&gt;可以稍微明确一下，静态成员与实例成员的区别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Model {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例成员&lt;/span&gt;
&lt;span&gt;  method1 () {}
  method2 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {}

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态成员&lt;/span&gt;
&lt;span&gt;  static method3 () {}
  static method4 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;method1&lt;/code&gt;和&lt;code&gt;method2&lt;/code&gt;是实例成员，&lt;code&gt;method1&lt;/code&gt;存在于&lt;code&gt;prototype&lt;/code&gt;之上，而&lt;code&gt;method2&lt;/code&gt;只在实例化对象以后才有。&lt;br/&gt;作为静态成员的&lt;code&gt;method3&lt;/code&gt;和&lt;code&gt;method4&lt;/code&gt;，两者的区别在于是否可枚举描述符的设置，所以可以简单地认为，上述代码转换为ES5版本后是这样子的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Model () {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成员仅在实例化时赋值&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;.method2 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {}
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成员被定义在原型链上&lt;/span&gt;
Object.defineProperty(Model.prototype, 'method1'&lt;span&gt;, {
  value: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {}, 
  writable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, 
  enumerable: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置不可被枚举&lt;/span&gt;
  configurable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成员被定义在构造函数上，且是默认的可被枚举&lt;/span&gt;
Model.method4 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成员被定义在构造函数上&lt;/span&gt;
Object.defineProperty(Model, 'method3'&lt;span&gt;, {
  value: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {}, 
  writable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, 
  enumerable: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置不可被枚举&lt;/span&gt;
  configurable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看出，只有&lt;code&gt;method2&lt;/code&gt;是在实例化时才赋值的，一个不存在的属性是不会有&lt;code&gt;descriptor&lt;/code&gt;的，所以这就是为什么TS在针对&lt;code&gt;Property Decorator&lt;/code&gt;不传递第三个参数的原因，至于为什么静态成员也没有传递&lt;code&gt;descriptor&lt;/code&gt;，目前没有找到合理的解释，但是如果明确的要使用，是可以手动获取的。&lt;/p&gt;
&lt;p&gt;就像上述的示例，我们针对四个成员都添加了装饰器以后，&lt;code&gt;method1&lt;/code&gt;和&lt;code&gt;method2&lt;/code&gt;第一个参数就是&lt;code&gt;Model.prototype&lt;/code&gt;，而&lt;code&gt;method3&lt;/code&gt;和&lt;code&gt;method4&lt;/code&gt;的第一个参数就是&lt;code&gt;Model&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Model {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例成员&lt;/span&gt;
&lt;span&gt;  @instance
  method1 () {}
  @instance
  method2 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {}

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态成员&lt;/span&gt;
&lt;span&gt;  @static
  static method3 () {}
  @static
  static method4 &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {}
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; instance(target) {
  console.log(target.constructor &lt;/span&gt;===&lt;span&gt; Model)
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; static(target) {
  console.log(target &lt;/span&gt;===&lt;span&gt; Model)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;函数，访问器，和属性装饰器三者之间的区别&quot;&gt;函数，访问器，和属性装饰器三者之间的区别&lt;/h3&gt;
&lt;h4 id=&quot;函数&quot;&gt;函数&lt;/h4&gt;
&lt;p&gt;首先是函数，函数装饰器的返回值会默认作为属性的&lt;code&gt;value&lt;/code&gt;描述符存在，如果返回值为&lt;code&gt;undefined&lt;/code&gt;则会忽略，使用之前的&lt;code&gt;descriptor&lt;/code&gt;引用作为函数的描述符。&lt;br/&gt;所以针对我们最开始的统计耗时的逻辑可以这么来做：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Model {
  @log1
  getData1() {}
  @log2
  getData2() {}
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方案一，返回新的value描述符&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; log1(tag, name, descriptor) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    ...descriptor,
    value(...args) {
      let start &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; descriptor.value.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args)
      } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        let end &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
        console.log(`start: ${start} end: ${end} consume: ${end &lt;/span&gt;-&lt;span&gt; start}`)
      }
    }
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方案二、修改现有描述符&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; log2(tag, name, descriptor) {
  let func &lt;/span&gt;= descriptor.value &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先获取之前的函数&lt;/span&gt;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改对应的value&lt;/span&gt;
  descriptor.value = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (...args) {
    let start &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args)
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
      let end &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
      console.log(`start: ${start} end: ${end} consume: ${end &lt;/span&gt;-&lt;span&gt; start}`)
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;访问器&quot;&gt;访问器&lt;/h4&gt;
&lt;p&gt;访问器就是添加有&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;前缀的函数，用于控制属性的赋值及取值操作，在使用上与函数没有什么区别，甚至在返回值的处理上也没有什么区别。&lt;br/&gt;只不过我们需要按照规定设置对应的&lt;code&gt;get&lt;/code&gt;或者&lt;code&gt;set&lt;/code&gt;描述符罢了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Modal {
  _name &lt;/span&gt;= 'Niko'&lt;span&gt;

  @prefix
  get name() { &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._name }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; prefix(target, name, descriptor) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    ...descriptor,
    get () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `wrap_${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._name}`
    }
  }
}

console.log(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Modal().name) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; wrap_Niko&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;属性&quot;&gt;属性&lt;/h4&gt;
&lt;p&gt;对于属性的装饰器，是没有返回&lt;code&gt;descriptor&lt;/code&gt;的，并且装饰器函数的返回值也会被忽略掉，如果我们想要修改某一个静态属性，则需要自己获取&lt;code&gt;descriptor&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Modal {
  @prefix
  static name1 &lt;/span&gt;= 'Niko'&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; prefix(target, name) {
  let descriptor &lt;/span&gt;=&lt;span&gt; Object.getOwnPropertyDescriptor(target, name)

  Object.defineProperty(target, name, {
    ...descriptor,
    value: `wrap_${descriptor.value}`
  })
}

console.log(Modal.name1) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wrap_Niko&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于一个实例的属性，则没有直接修改的方案，不过我们可以结合着一些其他装饰器来曲线救国。&lt;/p&gt;
&lt;p&gt;比如，我们有一个类，会传入姓名和年龄作为初始化的参数，然后我们要针对这两个参数设置对应的格式校验：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const validateConf = {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储校验信息&lt;/span&gt;
&lt;span&gt;
@validator
class Person {
  @validate(&lt;/span&gt;'string'&lt;span&gt;)
  name
  @validate(&lt;/span&gt;'number'&lt;span&gt;)
  age

  constructor(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; validator(constructor) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; class extends constructor {
    constructor(...args) {
      super(...args)

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历所有的校验信息进行验证&lt;/span&gt;
      &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let [key, type] of Object.entries(validateConf)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;[key] !== type) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(`${key} must be ${type}`)
      }
    }
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; validate(type) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (target, name, descriptor) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向全局对象中传入要校验的属性名及类型&lt;/span&gt;
    validateConf[name] =&lt;span&gt; type
  }
}

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person('Niko', '18')  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; throw new error: [age must be number]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先，在类上边添加装饰器&lt;code&gt;@validator&lt;/code&gt;，然后在需要校验的两个参数上添加&lt;code&gt;@validate&lt;/code&gt;装饰器，两个装饰器用来向一个全局对象传入信息，来记录哪些属性是需要进行校验的。&lt;br/&gt;然后在&lt;code&gt;validator&lt;/code&gt;中继承原有的类对象，并在实例化之后遍历刚才设置的所有校验信息进行验证，如果发现有类型错误的，直接抛出异常。&lt;br/&gt;这个类型验证的操作对于原&lt;code&gt;Class&lt;/code&gt;来说几乎是无感知的。&lt;/p&gt;
&lt;h3 id=&quot;函数参数装饰器&quot;&gt;函数参数装饰器&lt;/h3&gt;
&lt;p&gt;最后，还有一个用于函数参数的装饰器，这个装饰器也是像实例属性一样的，没有办法单独使用，毕竟函数是在运行时调用的，而无论是何种装饰器，都是在声明类时（可以认为是伪编译期）调用的。&lt;/p&gt;
&lt;p&gt;函数参数装饰器会接收三个参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;类似上述的操作，类的原型或者类的构造函数&lt;/li&gt;
&lt;li&gt;参数所处的函数名称&lt;/li&gt;
&lt;li&gt;参数在函数中形参中的位置（函数签名中的第几个参数）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一个简单的示例，我们可以结合着函数装饰器来完成对函数参数的类型转换：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
const parseConf =&lt;span&gt; {}
class Modal {
  @parseFunc
  addOne(@parse(&lt;/span&gt;'number'&lt;span&gt;) num) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num + 1&lt;span&gt;
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在函数调用前执行格式化操作&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; parseFunc (target, name, descriptor) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    ...descriptor,
    value (...arg) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取格式化配置&lt;/span&gt;
      &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let [index, type] of parseConf) {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (type) {
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'number':  arg[index] = Number(arg[index])             &lt;span&gt;break&lt;/span&gt;
          &lt;span&gt;case&lt;/span&gt; 'string':  arg[index] = String(arg[index])             &lt;span&gt;break&lt;/span&gt;
          &lt;span&gt;case&lt;/span&gt; 'boolean': arg[index] = String(arg[index]) === 'true'  &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; descriptor.value.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arg)
      }
    }
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向全局对象中添加对应的格式化信息&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; parse(type) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (target, name, index) {
    parseConf[index] &lt;/span&gt;=&lt;span&gt; type
  }
}

console.log(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Modal().addOne('10')) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用装饰器实现一个有趣的Koa封装&quot;&gt;使用装饰器实现一个有趣的Koa封装&lt;/h2&gt;
&lt;p&gt;比如在写Node接口时，可能是用的&lt;code&gt;koa&lt;/code&gt;或者&lt;code&gt;express&lt;/code&gt;，一般来说可能要处理很多的请求参数，有来自&lt;code&gt;headers&lt;/code&gt;的，有来自&lt;code&gt;body&lt;/code&gt;的，甚至有来自&lt;code&gt;query&lt;/code&gt;、&lt;code&gt;cookie&lt;/code&gt;的。&lt;br/&gt;所以很有可能在&lt;code&gt;router&lt;/code&gt;的开头数行都是这样的操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
router.get('/', async (ctx, next) =&amp;gt;&lt;span&gt; {
  let id &lt;/span&gt;=&lt;span&gt; ctx.query.id
  let uid &lt;/span&gt;= ctx.cookies.get('uid'&lt;span&gt;)
  let device &lt;/span&gt;= ctx.header['device'&lt;span&gt;]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以及如果我们有大量的接口，可能就会有大量的&lt;code&gt;router.get&lt;/code&gt;、&lt;code&gt;router.post&lt;/code&gt;。&lt;br/&gt;以及如果要针对模块进行分类，可能还会有大量的&lt;code&gt;new Router&lt;/code&gt;的操作。&lt;/p&gt;
&lt;p&gt;这些代码都是与业务逻辑本身无关的，所以我们应该尽可能的简化这些代码的占比，而使用装饰器就能够帮助我们达到这个目的。&lt;/p&gt;
&lt;h3 id=&quot;装饰器的准备&quot;&gt;装饰器的准备&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先，我们要创建几个用来存储信息的全局List&lt;/span&gt;
export const routerList      =&lt;span&gt; []
export const controllerList  &lt;/span&gt;=&lt;span&gt; []
export const parseList       &lt;/span&gt;=&lt;span&gt; []
export const paramList       &lt;/span&gt;=&lt;span&gt; []

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 虽说我们要有一个能够创建Router实例的装饰器&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 但是并不会直接去创建，而是在装饰器执行的时候进行一次注册&lt;/span&gt;
export &lt;span&gt;function&lt;/span&gt; Router(basename = ''&lt;span&gt;) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (constrcutor) =&amp;gt;&lt;span&gt; {
    routerList.push({
      constrcutor,
      basename
    })
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后我们在创建对应的Get Post请求监听的装饰器&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 同样的，我们并不打算去修改他的任何属性，只是为了获取函数的引用&lt;/span&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Method(type) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (path) =&amp;gt; (target, name, descriptor) =&amp;gt;&lt;span&gt; {
    controllerList.push({
      target,
      type,
      path,
      method: name,
      controller: descriptor.value
    })
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接下来我们还需要用来格式化参数的装饰器&lt;/span&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Parse(type) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (target, name, index) =&amp;gt;&lt;span&gt; {
    parseList.push({
      target,
      type,
      method: name,
      index
    })
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以及最后我们要处理的各种参数的获取&lt;/span&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Param(position) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (key) =&amp;gt; (target, name, index) =&amp;gt;&lt;span&gt; {
    paramList.push({
      target,
      key,
      position,
      method: name,
      index
    })
  }
}

export const Body   &lt;/span&gt;= Param('body'&lt;span&gt;)
export const Header &lt;/span&gt;= Param('header'&lt;span&gt;)
export const Cookie &lt;/span&gt;= Param('cookie'&lt;span&gt;)
export const Query  &lt;/span&gt;= Param('query'&lt;span&gt;)
export const Get    &lt;/span&gt;= Method('get'&lt;span&gt;)
export const Post   &lt;/span&gt;= Method('post')
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;Koa服务的处理&quot;&gt;Koa服务的处理&lt;/h3&gt;
&lt;p&gt;上边是创建了所有需要用到的装饰器，但是也仅仅是把我们所需要的各种信息存了起来，而怎么利用这些装饰器则是下一步需要做的事情了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const routers =&lt;span&gt; []

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历所有添加了装饰器的Class，并创建对应的Router对象&lt;/span&gt;
routerList.forEach(item =&amp;gt;&lt;span&gt; {
  let { basename, constrcutor } &lt;/span&gt;=&lt;span&gt; item
  let router &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Router({
    prefix: basename
  })

  controllerList
    .filter(i &lt;/span&gt;=&amp;gt; i.target ===&lt;span&gt; constrcutor.prototype)
    .forEach(controller &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      router[controller.type](controller.path, async (ctx, next) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        let args &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前函数对应的参数获取&lt;/span&gt;
&lt;span&gt;        paramList
          .filter( param &lt;/span&gt;=&amp;gt; param.target === constrcutor.prototype &amp;amp;&amp;amp; param.method ===&lt;span&gt; controller.method )
          .map(param &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            let { index, key } &lt;/span&gt;=&lt;span&gt; param
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (param.position) {
              &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'body':    args[index] = ctx.request.body[key] &lt;span&gt;break&lt;/span&gt;
              &lt;span&gt;case&lt;/span&gt; 'header':  args[index] = ctx.headers[key]      &lt;span&gt;break&lt;/span&gt;
              &lt;span&gt;case&lt;/span&gt; 'cookie':  args[index] = ctx.cookies.get(key)  &lt;span&gt;break&lt;/span&gt;
              &lt;span&gt;case&lt;/span&gt; 'query':   args[index] = ctx.query[key]        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            }
          })

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前函数对应的参数格式化&lt;/span&gt;
&lt;span&gt;        parseList
          .filter( parse &lt;/span&gt;=&amp;gt; parse.target === constrcutor.prototype &amp;amp;&amp;amp; parse.method ===&lt;span&gt; controller.method )
          .map(parse &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            let { index } &lt;/span&gt;=&lt;span&gt; parse
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (parse.type) {
              &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'number':  args[index] = Number(args[index])             &lt;span&gt;break&lt;/span&gt;
              &lt;span&gt;case&lt;/span&gt; 'string':  args[index] = String(args[index])             &lt;span&gt;break&lt;/span&gt;
              &lt;span&gt;case&lt;/span&gt; 'boolean': args[index] = String(args[index]) === 'true'  &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            }
          })

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用实际的函数，处理业务逻辑&lt;/span&gt;
        let results =&lt;span&gt; controller.controller(...args)

        ctx.body &lt;/span&gt;=&lt;span&gt; results
      })
    })

  routers.push(router.routes())
})

const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Koa()

app.use(bodyParse())
app.use(compose(routers))

app.listen(&lt;/span&gt;12306, () =&amp;gt; console.log('server run as http://127.0.0.1:12306'))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上边的代码就已经搭建出来了一个Koa的封装，以及包含了对各种装饰器的处理，接下来就是这些装饰器的实际应用了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
import { Router, Get, Query, Parse } from &quot;../decorators&quot;&lt;span&gt;

@Router(&lt;/span&gt;''&lt;span&gt;)
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class {
  @Get(&lt;/span&gt;'/'&lt;span&gt;)
  index (@Parse(&lt;/span&gt;'number') @Query('id'&lt;span&gt;) id: number) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      code: &lt;/span&gt;200&lt;span&gt;,
      id,
      type: &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; id
    }
  }

  @Post(&lt;/span&gt;'/detail'&lt;span&gt;)
  detail (
    @Parse(&lt;/span&gt;'number') @Query('id'&lt;span&gt;) id: number, 
    @Parse(&lt;/span&gt;'number') @Body('age'&lt;span&gt;) age: number
  ) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      code: &lt;/span&gt;200&lt;span&gt;,
      age: age &lt;/span&gt;+ 1&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;很轻易的就实现了一个&lt;code&gt;router&lt;/code&gt;的创建，路径、method的处理，包括各种参数的获取，类型转换。&lt;br/&gt;将各种非业务逻辑相关的代码统统交由装饰器来做，而函数本身只负责处理自身逻辑即可。&lt;br/&gt;这里有完整的代码：&lt;a href=&quot;https://github.com/Jiasm/notebook/tree/master/labs/demo/typescript/koa-decorators&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;。安装依赖后&lt;code&gt;npm start&lt;/code&gt;即可看到效果。&lt;/p&gt;
&lt;p&gt;这样开发带来的好处就是，让代码可读性变得更高，在函数中更专注的做自己应该做的事情。&lt;br/&gt;而且装饰器本身如果名字起的足够好的好，也是在一定程度上可以当作文档注释来看待了（Java中有个类似的玩意儿叫做注解）。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;合理利用装饰器可以极大的提高开发效率，对一些非逻辑相关的代码进行封装提炼能够帮助我们快速完成重复性的工作，节省时间。&lt;br/&gt;但是糖再好吃，也不要吃太多，容易坏牙齿的，同样的滥用装饰器也会使代码本身逻辑变得扑朔迷离，如果确定一段代码不会在其他地方用到，或者一个函数的核心逻辑就是这些代码，那么就没有必要将它取出来作为一个装饰器来存在。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;h3 class=&quot;heading&quot;&gt; &lt;/h3&gt;
&lt;h3 class=&quot;heading&quot;&gt; &lt;/h3&gt;
&lt;h3 class=&quot;heading&quot;&gt;One more thing&lt;/h3&gt;
&lt;p&gt;我司现在大量招人咯，前端、Node方向都有HC&lt;br/&gt;公司名：&lt;strong&gt;Blued&lt;/strong&gt;，坐标帝都朝阳双井&lt;br/&gt;主要技术栈是React，也会有机会玩ReactNative和Electron&lt;br/&gt;Node方向8.x版本+koa 新项目会以TS为主&lt;br/&gt;有兴趣的小伙伴可以联系我详谈：&lt;br/&gt;email: jiashunming@blued.com&lt;br/&gt;wechat: github_jiasm&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 12:09:00 +0000</pubDate>
<dc:creator>贾顺名</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiasm/p/9281113.html</dc:identifier>
</item>
<item>
<title>mac下编译openjdk8？so easy！ - ntchan</title>
<link>http://www.cnblogs.com/JunFengChan/p/9266033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JunFengChan/p/9266033.html</guid>
<description>&lt;p&gt;写在最前面的话：建议第一次编译jdk的朋友，查阅任何博客都不如认真读一遍源码中的README-builds.html&lt;/p&gt;
&lt;p&gt;环境：macOS High Sierra(10.13.5)&lt;/p&gt;
&lt;p&gt;编译jdk：openjdk8&lt;/p&gt;
&lt;p&gt;操作流程就不多写了，README-builds.html写的很清晰，当然，即使跟着README-builds.html操作不代表就不会遇到任何问题，但网上很多教程（mac环境的）都偏过时，并且在解决问题上本人有不同的想法，因此本文只针对编译过程中遇到的问题以及解决问题的思考总结；&lt;/p&gt;
&lt;p&gt;在开始之前先进行环境变量配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vi&lt;/span&gt; ~/.bash_profile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在.bash_profile文件底部插入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 设定语言选项，必须设置
export LANG&lt;/span&gt;=&lt;span&gt;C
# Mac平台，C编译器不再是GCC，是clang
export CC&lt;/span&gt;=&lt;span&gt;gcc&lt;/span&gt;&lt;span&gt;   #如果想使用clang，这里把gcc换成clang即可
export CXX&lt;/span&gt;=g++&lt;span&gt; 
# 跳过clang的一些严格的语法检查，不然会将N多的警告作为Error
export COMPILER_WARNINGS_FATAL&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
# 链接时使用的参数
export LFLAGS&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-Xlinker -lstdc++&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
# 是否使用clang
export USE_CLANG&lt;/span&gt;=false&lt;span&gt;
# 使用64位数据模型
export LP64&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
# 告诉编译平台是64位，不然会按32位来编译
export ARCH_DATA_MODEL&lt;/span&gt;=&lt;span&gt;64&lt;/span&gt;&lt;span&gt;
# 允许自动下载依赖
export ALLOW_DOWNLOADS&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
# 并行编译的线程数，编译时间长，为了不影响其他工作，我选择为2
export HOTSPOT_BUILD_JOBS&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
# 是否跳过与先前版本的比较
export SKIP_COMPARE_IMAGES&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
# 是否使用预编译头文件，加快编译速度
export USE_PRECOMPILED_HEADER&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
# 是否使用增量编译
export INCREMENTAL_BUILD&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
# 编译内容
export BUILD_LANGTOOLS&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
export BUILD_JAXP&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
export BUILD_JAXWS&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
export BUILD_CORBA&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
export BUILD_HOTSPOT&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
export BUILD_JDK&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
# 编译版本
export SKIP_DEBUG_BUILD&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
export SKIP_FASTDEBUG_BUILD&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
export DEBUG_NAME&lt;/span&gt;=&lt;span&gt;debug
# 避开javaws和浏览器Java插件之类的部分的build
export BUILD_DEPLOY&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
export BUILD_INSTALL&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
unset JAVA_HOME&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入完记得执行以下命令让刚刚的修改生效：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
source ~/.bash_profile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遇到的问题：&lt;/p&gt;
&lt;p&gt;一、在执行（在configure时，一共可以指定三种级别: &lt;code&gt;release, fastdebug, slowdebug&lt;/code&gt;, &lt;code&gt;slowdebug&lt;/code&gt; 含有最丰富的调试信息，没有这些信息，很多执行可能被优化掉，我们单步执行时，可能看不到一些变量的值。所以最好指定&lt;strong&gt;&lt;code&gt;slowdebug&lt;/code&gt;&lt;/strong&gt; 为编译级别）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
bash ./configure --with-debug-level=slowdebug--with-boot-jdk=/Library/Java/JavaVirtualMachines/jdk1.&lt;span&gt;7&lt;/span&gt;.0_80.jdk/Contents/Home
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;的时候报：&lt;span&gt;configure: error: GCC compiler is required&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;遇到的第一个报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201807/435918-20180706000914865-926344389.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原因：从XCode 4.2开始，Clang已经取代GCC成为macOS的默认的编译器：&lt;a href=&quot;http://clang.llvm.org/get_started.html&quot; target=&quot;_blank&quot;&gt;http://clang.llvm.org/get_started.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解决过程（不想换jdk9或者装旧版XCode&lt;strong&gt; &lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;没有GCC，那就安装一个呗（可以选择注释掉GCC compiler 报错的代码，这样就可以不必安装gcc，并用clang编译），不要安装编译器版本高于5的，因为默认启用c++14 导致编译中断，我选择安装的是gcc4.9：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
brew &lt;span&gt;install&lt;/span&gt; &lt;span&gt;gcc&lt;/span&gt;@&lt;span&gt;4.9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完需要把安装的gcc4.9指向系统默认调的gcc：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sudo ln -s /usr/local/Cellar/gcc@4.9/4.9.4_1/bin/gcc-4.9 /usr/bin/gcc&lt;br/&gt;sudo ln -s /usr/local/Cellar/gcc@4.9/4.9.4_1/bin/g++-4.9 /usr/bin/g++
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时遇到一个问题：&lt;span&gt;ln: /usr/bin/gcc: Operation not permitted&lt;/span&gt;，搜了一下，原来mac从El Capitan开始启用了&lt;a href=&quot;https://support.apple.com/en-us/ht204899&quot; target=&quot;_blank&quot;&gt;SIP&lt;/a&gt;，目的是提高系统安全性，避免第三方软件对系统级别目录进行修改。针对以下目录即使root用户也有权限限制：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201807/435918-20180707183044489-441071901.png&quot; alt=&quot;&quot; width=&quot;790&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据官网的提示，推荐用户使用以下路径代替：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201807/435918-20180707183240472-1006696719.png&quot; alt=&quot;&quot; width=&quot;770&quot; height=&quot;149&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网上普遍的做法是无脑粗暴的关闭SIP，不给用/usr/bin 可以用/usr/local/bin 的嘛，变通一下不就可以跳过这个报错了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;ln&lt;/span&gt; -s /usr/local/Cellar/&lt;span&gt;gcc&lt;/span&gt;@&lt;span&gt;4.9&lt;/span&gt;/&lt;span&gt;4.9&lt;/span&gt;.4_1/bin/&lt;span&gt;gcc&lt;/span&gt;-&lt;span&gt;4.9&lt;/span&gt; /usr/local/bin/&lt;span&gt;gcc&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;ln&lt;/span&gt; -s /usr/local/Cellar/&lt;span&gt;gcc&lt;/span&gt;@&lt;span&gt;4.9&lt;/span&gt;/&lt;span&gt;4.9&lt;/span&gt;.4_1/bin/g++-&lt;span&gt;4.9&lt;/span&gt; /usr/local/bin/g++&lt;span&gt;
alias &lt;/span&gt;&lt;span&gt;gcc&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/local/bin/gcc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
alias g&lt;/span&gt;++=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/local/bin/g++&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置完再运行configure，这次没报GCC的问题了，但报了：configure: error: Could not find freetype!，缺少字体库就装个字体库： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
brew &lt;span&gt;install&lt;/span&gt; freetype
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完再运行configure，这次返回：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201807/435918-20180707185522938-1656812764.png&quot; alt=&quot;&quot; width=&quot;646&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表示配置没问题了，但最好装个ccache提速，fine，再装个ccache:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
brew &lt;span&gt;install&lt;/span&gt; ccache
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、配置没问题后，开始执行make all，报下面这个错误：&lt;/p&gt;
&lt;p&gt;报错：&lt;span&gt;error: ordered comparison between pointer and zero ('char *' and 'int')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个报错是因为编译器环境不同导致，XCode的编译器是LLVM，而openjdk8默认使用的是GCC。因此只要把报这个错的代码从&lt;span&gt;pointer&amp;gt;0&lt;/span&gt;改成&lt;span&gt;pointer!=NULL&lt;span&gt; 即可，例如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201807/435918-20180708112136578-1760434058.png&quot; alt=&quot;&quot; width=&quot;1346&quot; height=&quot;76&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;只要把 base()&amp;gt;0 改成 base!=NULL 即可&lt;/p&gt;

&lt;p&gt;三、报错：&lt;span&gt;'X11/Xlib.h' file not found&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;查了一下，需要安装XQuartz。见：&lt;a href=&quot;https://support.apple.com/zh-cn/HT201341&quot; target=&quot;_blank&quot;&gt;https://support.apple.com/zh-cn/HT201341&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完需要配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;ln&lt;/span&gt; -s /opt/X11/include/X11 /usr/local/include/X11
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着就编译完成了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201807/435918-20180708132918076-1645619879.png&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后验证一波编译出来的jdk：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
build/macosx-x86_64-normal-server-fastdebug/jdk/bin/java -version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出以下内容表示编译成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435918/201807/435918-20180708134308921-1314794465.png&quot; alt=&quot;&quot; width=&quot;670&quot; height=&quot;81&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-clang/&quot; target=&quot;_blank&quot;&gt;https://www.ibm.com/developerworks/cn/opensource/os-cn-clang/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gvsmirnov.ru/blog/tech/2014/02/07/building-openjdk-8-on-osx-maverick.html&quot; target=&quot;_blank&quot;&gt;https://gvsmirnov.ru/blog/tech/2014/02/07/building-openjdk-8-on-osx-maverick.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d9a1e1072f37&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/d9a1e1072f37&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 08 Jul 2018 11:41:00 +0000</pubDate>
<dc:creator>ntchan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JunFengChan/p/9266033.html</dc:identifier>
</item>
<item>
<title>Netty 系列四（ChannelHandler 和 ChannelPipeline）. - JMCui</title>
<link>http://www.cnblogs.com/jmcui/p/9280733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmcui/p/9280733.html</guid>
<description>&lt;h2&gt;一、概念&lt;/h2&gt;
&lt;p&gt;    先来整体的介绍一下这篇博文要介绍的几个概念（Channel、ChannelHandler、ChannelPipeline、ChannelHandlerContext、ChannelPromise）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Channel&lt;/strong&gt;：Netty 中传入或传出数据的载体；&lt;br/&gt;&lt;strong&gt;ChannelHandler&lt;/strong&gt;：Netty 中处理入站和出站数据的应用程序逻辑的容器；&lt;br/&gt;&lt;strong&gt;ChannelPipeline&lt;/strong&gt;：ChannelHandler链 的容器；&lt;br/&gt;&lt;strong&gt;ChannelHandlerContext&lt;/strong&gt;：代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext；&lt;br/&gt;&lt;strong&gt;ChannelPromise&lt;/strong&gt;：ChannelPromise是ChannelFuture的一个子类，其定义了一些可写的方法，如setSuccess()和setFailure()， 从而使ChannelFuture不可变。&lt;/p&gt;
&lt;p&gt;    我们来举一个例子描述这些概念之间的逻辑关系：服务端接收到客户端的连接请求，创建一个Channel同客户端进行绑定，新创建的 Channel 会都将会被分配一个新的ChannelPipeline（这项关联是永久性的，Channel 既不会附加另外一个ChannelPipeline，也不能分离当前的）。而 ChannelPipeline 作为 ChannelHandler链 的容器，当Channel 生命周期中状态发生改变时，将会生成对应的事件，这些事件将会被 ChannelPipeline 中 ChannelHandler 所响应，响应方法的参数一般都有一个 ChannelHandlerContext ，一个 ChannelHandler 对应一个 ChannelHandlerContext。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153954/201807/1153954-20180708162550211-1503911556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、ChannelHandler&lt;/h2&gt;
&lt;p&gt;    Netty提供了大量预定义的可以开箱即用的ChannelHandler实现，包括用于各种协议的ChannelHandler。因此，我们在自定义ChannelHandler实现用于处理我们的程序逻辑时，只需要继承Netty 的一些默认实现即可，主要有两种：&lt;/p&gt;
&lt;p&gt;1、继承 ChannelHandlerAdapter （在4.0 中 处理入站事件继承 ChannelInboundHandlerAdapter，处理出站事件继承 &lt;span class=&quot;fontstyle0&quot;&gt;ChannelOutboundHandlerAdapter ；在5.0 推荐直接继承 ChannelHandlerAdapter）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;2、继承 SimpleChannelInboundHandler&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;    这两种方式有什么区别呢？  当我们处理 入站数据 和 出站数据时，都需要确保没有任何的资源泄露。在入站方向，继承 SimpleChannelInboundHandler 的实现类会在消息被处理之后自动处理消息，而继承 ChannelHandlerAdapter 的实现类需要手动的释放消息（ReferenceCountUtil.release(msg)）；在出站方向，不管继承的是哪一种的实现类，当你处理了 write() 操作并丢弃了一个消息，那么你就应该释放它，不仅如此，还要通知 ChannelPromise。否则可能会出现 ChannelFutureListener 收不到某个消息已经被处理了的通知的情况。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    ReferenceCountUtil.release(msg);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ChannelPromise 是ChannelFuture的一个子类，设置成 true 通知 ChannelFutureListener 消息已经被处理了
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当一个 Promise 被完成之后，其对应的 Future 的值便不能再进行任何修改了&lt;/span&gt;
&lt;span&gt;    promise.setSuccess();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;tips:&lt;span&gt;总之，如果一个消息被消费或者丢弃了， 并且没有传递给 ChannelPipeline 中的下一个ChannelOutboundHandler， 那么用户就有责任调用 ReferenceCountUtil.release()。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    来看看 ChannelHandler 的 API：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;isSharable ：如果其对应的实现被标注为 Sharable， 那么这个方法将返回 true， 表示它可以被添加到多个 ChannelPipeline中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-- ChannelHandler 生命周期方法 --&lt;br/&gt;&lt;span&gt;handlerAdded ：当把 ChannelHandler 添加到 ChannelPipeline 中时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;handlerRemoved ：当从 ChannelPipeline 中移除 ChannelHandler 时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;exceptionCaught ： 当处理过程中在 ChannelPipeline 中有错误产生时被调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-- 处理入站数据以及各种状态变化 --&lt;br/&gt;&lt;span&gt;channelRegistered : 当 Channel 已经注册到它的 EventLoop 并且能够处理 I/O 时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;channelUnregistered : 当 Channel 从它的 EventLoop 注销并且无法处理任何 I/O 时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;channelActive : 当 Channel 处于活动状态时被调用；Channel 已经连接/绑定并且已经就绪&lt;/span&gt;&lt;br/&gt;&lt;span&gt;channelInactive : 当 Channel 离开活动状态并且不再连接它的远程节点时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;channelReadComplete : 当Channel上的一个读操作完成时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;channelRead : 当从 Channel 读取数据时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ChannelWritabilityChanged :当 Channel 的可写状态发生改变时被调用。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;userEventTriggered : 当 ChannelnboundHandler.fireUserEventTriggered()方法被调用时被调用，因为一个 POJO 被传经了 ChannelPipeline&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-- 处理出站数据并且允许拦截所有的操作 --&lt;br/&gt;&lt;span&gt;bind : 当请求将 Channel 绑定到本地地址时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;connect : 当请求将 Channel 连接到远程节点时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;disconnect : 当请求将 Channel 从远程节点断开时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;close : 当请求关闭 Channel 时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;deregister : 当请求将 Channel 从它的 EventLoop 注销时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;read : 当请求从 Channel 读取更多的数据时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;flush : 当请求通过 Channel 将入队数据冲刷到远程节点时被调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;write :当请求通过 Channel 将数据写到远程节点时被调用&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三、ChannelPipeline&lt;/h2&gt;
&lt;p&gt;    ChannelPipeline 是一个拦截流经 Channel 的入站和出站事件的ChannelHandler 实例链，它和 ChannelHandler 之间的交互组成了应用程序数据和事件处理逻辑的核心，而它们之间的关联交互就是通过 ChannelHandlerContext。&lt;/p&gt;
&lt;p&gt;    如果一个入站事件被触发，它将被从 ChannelPipeline 的头部开始一直被传播到 Channel Pipeline 的尾端。如图，Netty 总是将 ChannelPipeline 的入站口作为头部，而将出站口作为尾端，如图，第一个被入站事件看到的 ChannelHandler 将是1，而第一个被出站事件看到的是 ChannelHandler 将是 5。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153954/201807/1153954-20180708180016939-44829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    既然 ChannelPipeline 是 ChannelHandler链 的容器，让我们来看看ChannelPipeline 是如何管理 ChannelHandler的吧！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;addFirst : 将一个 ChannelHandler 添加到 ChannelPipeline 最开始位置中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;addBefore ：将一个 ChannelHandler 添加到 ChannelPipeline 某个ChannelHandler前&lt;/span&gt;&lt;br/&gt;&lt;span&gt;addAfter：将一个 ChannelHandler 添加到 ChannelPipeline 某个ChannelHandler后&lt;/span&gt;&lt;br/&gt;&lt;span&gt;addLast : 将一个 ChannelHandler 添加到 ChannelPipeline 最末尾位置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;remove ：将一个 ChannelHandler 从 ChannelPipeline 中移除&lt;/span&gt;&lt;br/&gt;&lt;span&gt;replace ：将 ChannelPipeline 中的一个 ChannelHandler 替换为另一个 ChannelHandler&lt;/span&gt;&lt;br/&gt;&lt;span&gt;get ：通过类型或者名称返回 ChannelHandler&lt;/span&gt;&lt;br/&gt;&lt;span&gt;context ：返回和 ChannelHandler 绑定的 ChannelHandlerContext&lt;/span&gt;&lt;br/&gt;&lt;span&gt;names ：返回 ChannelPipeline 中所有 ChannelHandler 的名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt; ChannelPipeline 的API 用于调用入站操作的附加方法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fireChannelRegistered： 调用 ChannelPipeline 中下一个 ChannelInboundHandler 的 channelRegistered(ChannelHandlerContext)方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;fireChannelUnregistered： 调用 ChannelPipeline 中下一个 ChannelInboundHandler 的channelUnregistered(ChannelHandlerContext)方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;fireChannelActive： 调用 ChannelPipeline 中下一个 ChannelInboundHandler 的channelActive(ChannelHandlerContext)方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;fireChannelInactive： 调用 ChannelPipeline 中下一个 ChannelInboundHandler 的channelInactive(ChannelHandlerContext)方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;fireExceptionCaught： 调用 ChannelPipeline 中下一个 ChannelInboundHandler 的exceptionCaught(ChannelHandlerContext, Throwable)方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;fireUserEventTriggered： 调用 ChannelPipeline 中下一个 ChannelInboundHandler 的userEventTriggered(ChannelHandlerContext, Object)方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;fireChannelRead： 调用 ChannelPipeline 中下一个 ChannelInboundHandler 的channelRead(ChannelHandlerContext, Object msg)方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;fireChannelReadComplete： 调用 ChannelPipeline 中下一个 ChannelInboundHandler 的channelReadComplete(ChannelHandlerContext)方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;fireChannelWritabilityChanged： 调用 ChannelPipeline 中下一个 ChannelInboundHandler 的channelWritabilityChanged(ChannelHandlerContext)方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt;ChannelPipeline 的API 用于调用出站操作的附加方法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bind： 将 Channel 绑定到一个本地地址，这将调用 ChannelPipeline 中的下一个ChannelOutboundHandler 的 bind方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;connect： 将 Channel 连接到一个远程地址，这将调用 ChannelPipeline 中的下一个ChannelOutboundHandler 的 connect方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;disconnect： 将 Channel 断开连接。这将调用 ChannelPipeline 中的下一个 ChannelOutboundHandler 的 disconnect方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;close： 将 Channel 关闭。这将调用 ChannelPipeline 中的下一个 ChannelOutboundHandler 的 close方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;deregister： 将 Channel 从它先前所分配的 EventExecutor（即 EventLoop）中注销。这将调用 ChannelPipeline 中的下一个 ChannelOutboundHandler 的 deregister方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;flush： 冲刷Channel所有挂起的写入。这将调用ChannelPipeline中的下一个ChannelOutboundHandler 的 flush方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;write： 将消息写入 Channel。这将调用 ChannelPipeline 中的下一个 ChannelOutboundHandler的write方法。注意：这并不会将消息写入底层的 Socket，而只会将它放入队列中。要将它写入 Socket，需要调用 flush()或者 writeAndFlush()方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;writeAndFlush： 这是一个先调用 write()方法再接着调用 flush()方法的便利方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;read： 请求从 Channel 中读取更多的数据。这将调用 ChannelPipeline 中的下一个ChannelOutboundHandler 的 read(ChannelHandlerContext)方法&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;四、ChannelHandlerContext&lt;/h2&gt;
&lt;p&gt;    ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联。&lt;/p&gt;
&lt;p&gt;    ChannelHandlerContext 有很多的方法，其中一些方法也存在于 Channel 和 ChannelPipeline 本身上，但是有一点重要的不同。如果调用 Channel 或者 ChannelPipeline 上的这些方法，它们将沿着整个 ChannelPipeline 进行传播。而调用位于 ChannelHandlerContext上的相同方法，则将从当前所关联的 ChannelHandler 开始，并且只会传播给位于该ChannelPipeline 中的下一个能够处理该事件的 ChannelHandler。因此，尽量使用 ChannelHandlerContext 的同名方法来处理逻辑，因为它将产生更短的事件流， 应该尽可能地利用这个特性来获得最大的性能。&lt;/p&gt;
&lt;h2&gt;五、寄语&lt;/h2&gt;
&lt;p&gt;    有时候也会迷茫，身边的人理论基础差一些的的，代码不一样敲的好好的？而我花大量时间细细的去研究这么理论真的值得吗？仔细想想，人生很多事情本来就是徒劳无功的啊，没必要急功近利，欲速则不达。要坚信，一切的付出总会在人生的某个时刻回报在我们身上。&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 10:37:00 +0000</pubDate>
<dc:creator>JMCui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jmcui/p/9280733.html</dc:identifier>
</item>
</channel>
</rss>