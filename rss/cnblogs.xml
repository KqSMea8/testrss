<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>可迭代对象、迭代器、生成器的理解 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/7628049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/7628049.html</guid>
<description>&lt;p&gt;所有的生成器都是迭代器&lt;/p&gt;
&lt;p&gt;关于迭代器和生成器的一种定义：迭代器用于从集合中取出元素；生成器用于凭空生成元素。&lt;/p&gt;
&lt;p&gt;Python中，所有的集合都是可以迭代的，在Python语言内部，迭代器用于支持：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;for 循环&lt;/li&gt;
&lt;li&gt;构建和扩展集合类型&lt;/li&gt;
&lt;li&gt;逐行遍历文本文件&lt;/li&gt;
&lt;li&gt;列表推导，字典推导，集合推导&lt;/li&gt;
&lt;li&gt;元组拆包&lt;/li&gt;
&lt;li&gt;调用函数时，使用*拆包实参&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如同标题本文的标题一样，这边文章主要讲解三个方面，可迭代对象，迭代器，生成器，下面逐个开始理解&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;可迭代对象&lt;/h2&gt;
&lt;p&gt;先通过下面单词序列例子来理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reprlib
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; RE_WORD = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sentence(object):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,text):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         self.text =&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self.words =&lt;span&gt; RE_WORD.findall(text)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, index):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.words[index]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; len(self.words)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        用于打印实例化对象时，显示自定义内容，
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        reprlib.repr函数生成的字符换最多有30个字符，当超过怎会通过省略号显示
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        :return: 自定义内容格式
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sentence(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; reprlib.repr(self.text)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; s = Sentence(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;the time has come,&quot; the Walrus said,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(s))
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; s:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(word)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list(s))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码的运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201710/997599-20171004232705771-1608875321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先从结果来看，我们可以看出这个类的实例是可以迭代的，&lt;br/&gt;并且我们从打印print(s)的结果可以看出，显示的也是我们定义的内容，如果我们在类中没有通过__repr__自定义，打印结果将为：&lt;br/&gt;&amp;lt;__main__.Sentence object at 0x102a08fd0&amp;gt;&lt;br/&gt;同时这里的实例化对象也是一个序列，所以我们可以通过s[0]这种方式来获取每个元素&lt;br/&gt;我们都知道序列可以迭代，那么序列为啥可以迭代，继续深入理解&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;序列可以迭代原因&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;解释器需要迭代对象x时，会自动调用iter(x)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;内置的iter函数作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查对象是否实现了__iter__方法，如果实现调用它，获取一个迭代器&lt;/li&gt;
&lt;li&gt;如果没有实现__iter__方法，但是实现了__getitem__方法，python会创建一个迭代器，尝试按顺序（从0开始）获取元素&lt;/li&gt;
&lt;li&gt;如果尝试失败，会抛出TypeError异常，通常会提示：“C object is not iterable”,其中C是目标对象所属的类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;任何python序列可以迭代的原因是，他们都实现了__getitem__方法，并且标准的序列也实现了__iter__方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于如何判断x对象是否为可迭代对象，&lt;span&gt;有两种方法：iter(x)或者isinstance(x,abc.Iterable)&lt;/span&gt;&lt;br/&gt;那么这两种判断法有什么区别么？&lt;br/&gt;其实从Python3.4之后建议是通过iter(x)方法来进行判断，因为iter方法会考虑__getitem__方法，而abc.Iterable不会考虑，所以iter(x)的判断方法更加准确&lt;/p&gt;
&lt;p&gt;就像我最开始写的那个例子，分别通过这两种方式来测试,可以看出，其实这个类是可以迭代的，但是通过abc.Iterable的方式来判断，确实不可迭代的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201710/997599-20171004232739896-1369565500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于可迭代对象的一个小结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用iter内置函数可以获取迭代器的对象，如果对象实现了能返回迭代器的__iter__方法，那么对象就是可迭代的&lt;/li&gt;
&lt;li&gt;序列都可以迭代&lt;/li&gt;
&lt;li&gt;实现了__getitem__方法，而且其参数是从零开始的索引，这种对象也可以迭代&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;toc_3&quot;&gt;迭代器&lt;/h2&gt;
&lt;p&gt;首先我们要明白可迭代的对象和迭代器之间的关系：&lt;br/&gt;Python从可迭代的对象中获取迭代器&lt;/p&gt;
&lt;p&gt;一个简单的例子，当我们循环字符串的时候，字符串就是一个可迭代的对象，背后就是有迭代器，只不过我们看不到，下面为代码例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过for循环方式&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; s:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;''&lt;/span&gt;.center(50, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过while循环方式&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; it =&lt;span&gt; iter(s)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(next(it))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopIteration:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;del&lt;/span&gt;&lt;span&gt; it
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种方式都可以获取可迭代对象里的内容，但是while循环的方式如果不通过try/except方式获取异常，最后就会提示StopIteration的错误，这是因为Python语言内部会处理for循环和其他迭代上下文（如列表推导，元组拆包等等）中的StopIteration&lt;/p&gt;
&lt;p&gt;标准的迭代器接口有两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;__next__：返回下一个可用的元素，如果没有元素了抛出StopIteration异常&lt;/li&gt;
&lt;li&gt;__iter__：返回self,以便在应该使用迭代器的地方使用迭代器，例如for循环&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为迭代器只需要__next__和__iter__两个方法，所以除了调用next()方法，以及捕获StopIteration异常之外，没有办法检查是否还有遗留元素，并且没有办法还原迭代器，如果想要再次迭代，就需要调用iter(...)传入之前构建迭代器的可迭代对象&lt;/p&gt;
&lt;p&gt;我们把刚开始写的sentence类通过迭代器的方式来实现，要说的是这种写法不符合python的习惯做法，这里是为了更好的理解迭代器和可迭代对象之间的重要区别&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reprlib
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; abc
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; RE_WORD = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sentence:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,text):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.text =&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         self.words =&lt;span&gt; RE_WORD.findall(text)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sentence(%s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; reprlib.repr(self.text)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; SentenceIterator(self.words)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SentenceIterator:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,words):
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         self.words =&lt;span&gt; words
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         self.index =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             word =&lt;span&gt; self.words[self.index]
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; IndexError:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; StopIteration()
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         self.index += 1
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; word
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以很清楚的明白，我们定义了一个SenteneIterator是一个迭代器，也实现了迭代器应该有的两种方法：__next__和__iter__方法，这样我们通过 issubclass(SentenceIterator,abc.Iterator)检查&lt;br/&gt;这里我们还能看到可迭代对象和迭代器的区别：&lt;br/&gt;&lt;span&gt;可迭代对象有__iter__方法，每次都实例化一个新的迭代器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;迭代器要实现__next__和__iter__两个方法，__next__用于获取下一个元素，__iter__方法用于迭代器本身，因此迭代器可以迭代，但是可迭代对象不是迭代器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有人肯定在想在Sentence类中实现__next__方法，让Sentence类既是可迭代对象也是自身的迭代器，但是这种想法是不对的，这是也是常见的反模式。所以&lt;span&gt;可迭代对象一定不能是自身的迭代器&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;生成器&lt;/h2&gt;
&lt;p&gt;先通过用生成器方式替换上个例子中SentenceIterator类，例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reprlib
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; RE_WORD = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sentence:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,text):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self.text =&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.words =&lt;span&gt; RE_WORD.findall(text)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sentence(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; reprlib.repr(self.text)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.words:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt; word
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面这个代码中，我们通过yield关键字，这里的__iter__函数其实就是生成器函数，迭代器其实是生成器对象，每次调用__iter__方法，都会自动创建。&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;生成器的工作原理&lt;/h3&gt;
&lt;p&gt;Python函数定义体中有yield关键字，该函数就是生成器函数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生成器函数会创建一个生成器对象，包装生成器函数的定义体，把生成器传给next(...)函数时，生成器函数会向前，执行函数定义体中的下一个yield语句，返回产出的值，并在函数定义体的当前位置暂停，最终，函数的定义体返回时，外层的生成器对象会抛出SotpIteration异常，这一点和迭代器协议一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面是一个生成器的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201710/997599-20171004232936224-1963899459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里其实我们要明白进行for循环的过程其实就是在隐式的调用next()函数&lt;br/&gt;当我们写了好几种Sentence类的时候，感觉我们通过生成器方式实现的挺简单了，其实还有更简单的方法的，代码例子如下,这里的finditer函数构建了一个迭代器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reprlib
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; RE_WORD = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sentence:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,text):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.text =&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sentence(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; reprlib.repr(self.text)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; match &lt;span&gt;in&lt;/span&gt;&lt;span&gt; RE_WORD.finditer(self.text):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt; match.group()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;关于生成器表达式&lt;/h3&gt;
&lt;p&gt;生成器表达式可以理解为列表推导的惰性版本，不会直接构成列表，而是返回一个生成器，按需惰性生成元素。&lt;br/&gt;关于实现Sentence,还可以通过生成器表达式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reprlib
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; RE_WORD = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sentence:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,text):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self.text =&lt;span&gt; text
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sentence(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; reprlib.repr(self.text)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (match.group() &lt;span&gt;for&lt;/span&gt; match &lt;span&gt;in&lt;/span&gt; RE_WORD.finditer(self.text))
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 04 Oct 2017 15:31:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/7628049.html</dc:identifier>
</item>
<item>
<title>httpd2.2配置文件详解 - LinuxerMaster</title>
<link>http://www.cnblogs.com/xuelong3/p/7628036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuelong3/p/7628036.html</guid>
<description>&lt;p&gt;注意：关闭防火墙，iptables规则&lt;/p&gt;
&lt;p&gt;vim /etc/sysconfig/selinux&lt;/p&gt;
&lt;p&gt;SELINUX=disabled&lt;/p&gt;
&lt;p&gt;iptables -F&lt;/p&gt;
&lt;p&gt;httpd-2.2的常用配置&lt;/p&gt;
&lt;p&gt;    主配置文件：/etc/httpd/conf/httpd.conf&lt;/p&gt;
&lt;p&gt;        ### Section 1: Global Environment&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;### Section 2: 'Main' server configuration&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;### Section 3: Virtual Hosts&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    配置格式：&lt;/p&gt;
&lt;p&gt;        directive  value&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;    directive：不区分字符大小写；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;    value：为路径时，是否区分字符大小写，取决于文件系统； &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;常用配置：&lt;/p&gt;
&lt;p&gt;1、修改监听的IP和PORT&lt;/p&gt;
&lt;p&gt;    Listen  [IP:]PORT&lt;/p&gt;
&lt;p&gt;        (1) 省略IP表示为0.0.0.0；表示本机上的所有ip地址&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;(2) Listen指令可重复出现多次；&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;23.436649677773&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Listen  &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
Listen  &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  (3) 修改监听socket，重启服务进程方可生效；&lt;/p&gt;
&lt;p&gt;2、持久连续&lt;/p&gt;
&lt;p&gt;    Persistent Connection：tcp连续建立后，每个资源获取完成后不全断开连接，而是继续等待其它资源请求的进行； &lt;/p&gt;
&lt;p&gt;        如何断开？&lt;/p&gt;
&lt;p&gt;            数量限制&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;    时间限制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;        副作用：对并发访问量较大的服务器，长连接机制会使得后续某些请求无法得到正常响应；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;            折衷：使用较短的持久连接时长，以及较少的请求数量；&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;25.928189193855&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; KeepAlive  On|&lt;span&gt;Off    #注意,只有在keepAlive的状态为on时,下面的两项才是启用的;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; KeepAliveTimeout  &lt;span&gt;15&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; MaxKeepAliveRequests  &lt;span&gt;100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试：使用telnet工具&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -&lt;span&gt;y telnet    #安装telnet
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;(keepalive off)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@httpd ~]# telnet &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.16&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; Trying &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.16&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; Connected to &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.16&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Escape character is &lt;span&gt;'&lt;/span&gt;&lt;span&gt;^]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; GET /test.html HTTP/&lt;span&gt;1.1&lt;/span&gt;&lt;span&gt;               #表示使用HTTP1.1的协议
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; Host: &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.16&lt;/span&gt;                    #请求的主机是192.&lt;span&gt;168.1&lt;/span&gt;.&lt;span&gt;16&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处回车两次出现结果&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; HTTP/&lt;span&gt;1.1&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt; OK
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; Date: Thu, &lt;span&gt;27&lt;/span&gt; Apr &lt;span&gt;2017&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;33&lt;/span&gt;:&lt;span&gt;40&lt;/span&gt;&lt;span&gt; GMT
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; Server: Apache/&lt;span&gt;2.2&lt;/span&gt;.&lt;span&gt;15&lt;/span&gt;&lt;span&gt; (CentOS)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; Last-Modified: Thu, &lt;span&gt;27&lt;/span&gt; Apr &lt;span&gt;2017&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt;&lt;span&gt; GMT
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; ETag: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8023f-1e-54e1c94668f44&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; Accept-&lt;span&gt;Ranges: bytes
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; Content-Length: &lt;span&gt;30&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;Connection: close
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; Content-Type: text/html; charset=UTF-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &amp;lt;h1&amp;gt;this www.linuxedu.top&amp;lt;h1&amp;gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;Connection closed by foreign host.    #此处是断开的
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;(keepalive on)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; [root@httpd ~]# telnet &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.16&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; Trying &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.16&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; Connected to &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.16&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; Escape character is &lt;span&gt;'&lt;/span&gt;&lt;span&gt;^]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; GET /test.html HTTP/&lt;span&gt;1.1&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; Host: &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.16&lt;/span&gt;&lt;span&gt;                    #此处回车两次出现结果
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; HTTP/&lt;span&gt;1.1&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt; OK
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; Date: Thu, &lt;span&gt;27&lt;/span&gt; Apr &lt;span&gt;2017&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt;&lt;span&gt; GMT
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; Server: Apache/&lt;span&gt;2.2&lt;/span&gt;.&lt;span&gt;15&lt;/span&gt;&lt;span&gt; (CentOS)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; Last-Modified: Thu, &lt;span&gt;27&lt;/span&gt; Apr &lt;span&gt;2017&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt;&lt;span&gt; GMT
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; ETag: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8023f-1e-54e1c94668f44&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; Accept-&lt;span&gt;Ranges: bytes
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; Content-Length: &lt;span&gt;30&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; Content-Type: text/html; charset=UTF-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &amp;lt;h1&amp;gt;this www.linuxedu.top&amp;lt;h1&amp;gt;
&lt;span&gt;40&lt;/span&gt;                                      #此处是回车,并没有断开,但是受到MaxKeepAliveRequests以及KeepAliveTimeout的限制最终也会断开
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、MPM &lt;/p&gt;
&lt;p&gt;    httpd-2.2不支持同时编译多个MPM模块，所以只能编译选定要使用的那个；CentOS 6的rpm包为此专门提供了三个应用程序文件，httpd(prefork), httpd.worker, httpd.event，分别用于实现对不同的MPM机制的支持；确认现在使用的是哪下程序文件的方法：&lt;/p&gt;
&lt;div readability=&quot;20.936990154712&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@httpd ~]# &lt;span&gt;ps&lt;/span&gt;  aux  | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; httpd
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; root       &lt;span&gt;1658&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.2&lt;/span&gt; &lt;span&gt;177816&lt;/span&gt;  &lt;span&gt;3872&lt;/span&gt; ?        Ss   &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/sbin/&lt;span&gt;httpd
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; apache     &lt;span&gt;1660&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.1&lt;/span&gt; &lt;span&gt;177816&lt;/span&gt;  &lt;span&gt;2496&lt;/span&gt; ?        S    &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/sbin/&lt;span&gt;httpd
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; apache     &lt;span&gt;1661&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.1&lt;/span&gt; &lt;span&gt;177816&lt;/span&gt;  &lt;span&gt;2496&lt;/span&gt; ?        S    &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/sbin/&lt;span&gt;httpd
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; apache     &lt;span&gt;1662&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.1&lt;/span&gt; &lt;span&gt;177816&lt;/span&gt;  &lt;span&gt;2496&lt;/span&gt; ?        S    &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/sbin/httpd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认使用的为/usr/sbin/httpd，其为prefork的MPM模块 ；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@httpd ~]# /usr/sbin/httpd -&lt;span&gt;l
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Compiled &lt;span&gt;in&lt;/span&gt;&lt;span&gt; modules:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  core.c
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  prefork.c
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;  http_core.c
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;   mod_so.c
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;查看httpd程序的模块列表：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    查看静态编译的模块：&lt;/p&gt;
&lt;p&gt;        # httpd  -l&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;查看静态编译及动态编译的模块：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19.938206044221&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@httpd ~]# httpd -&lt;span&gt;M
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; httpd: Could not reliably determine the server&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s fully qualified domain name, using 0.0.0.0 for ServerName&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;Loaded Modules:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; core_module (static)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; mpm_prefork_module (static)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; http_module (static)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; so_module (static)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; auth_basic_module (shared)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; auth_digest_module (shared)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; ...
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;更换使用httpd程序，以支持其它MPM机制；/etc/sysconfig/httpd&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    MPM更改的选项有：HTTPD=/usr/sbin/httpd.{worker，event}&lt;/p&gt;
&lt;p&gt;    注意：对于centos6来讲，httpd2.2版本的event还是测试的阶段，因此不建议在生产环境中使用；&lt;/p&gt;
&lt;p&gt;操作步骤：建议先停止服务，然后修改配置文件，最后启动服务才能生效&lt;/p&gt;
&lt;div readability=&quot;19.437690348994&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@httpd ~&lt;span&gt;]# service httpd stop
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;停止 httpd：                                               [确定]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@httpd ~]# vim /etc/sysconfig/&lt;span&gt;httpd       
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@httpd ~]# &lt;span&gt;cat&lt;/span&gt; /etc/sysconfig/httpd | &lt;span&gt;grep&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;^HTTPD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; HTTPD=/usr/sbin/&lt;span&gt;httpd.worker
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; [root@httpd ~&lt;span&gt;]# service httpd start
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 正在启动 httpd：httpd.worker: apr_sockaddr_info_get() failed &lt;span&gt;for&lt;/span&gt;&lt;span&gt; httpd
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; httpd.worker: Could not reliably determine the server&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s fully qualified domain name, using 127.0.0.1 for ServerName&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                                                           [确定]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; [root@httpd ~]# &lt;span&gt;ps&lt;/span&gt;  aux  | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; httpd
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; root       &lt;span&gt;1746&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.2&lt;/span&gt; &lt;span&gt;178024&lt;/span&gt;  &lt;span&gt;4132&lt;/span&gt; ?        Ss   &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/sbin/&lt;span&gt;httpd.worker
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; apache     &lt;span&gt;1860&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.2&lt;/span&gt; &lt;span&gt;522284&lt;/span&gt;  &lt;span&gt;5372&lt;/span&gt; ?        Sl   &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/sbin/&lt;span&gt;httpd.worker
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; root       &lt;span&gt;1889&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt; &lt;span&gt;103256&lt;/span&gt;   &lt;span&gt;840&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    S+   &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;grep&lt;/span&gt; --color httpd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;思考：为什么编辑/etc/sysconfig/httpd就会生效呢？先来了解一下什么是脚本的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@httpd ~]# &lt;span&gt;cat&lt;/span&gt; useradd.&lt;span&gt;sh&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; #!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; [ -f /tmp/useradd.conf ] &amp;amp;&amp;amp; source /tmp/&lt;span&gt;useradd.conf
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; username=${username:-&lt;span&gt;testuser}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $username
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; [root@httpd ~]# &lt;span&gt;cat&lt;/span&gt; /tmp/&lt;span&gt;useradd.conf
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; username=myuser
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;1、脚本首先会判断/tmp/useradd.conf这个文件是否存在，如果存在就会把文件中的内容读取到当前环境中，&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2、${username:-testuser}，表示如果当前环境中username这个变量有值，那么echo $username就是当前环境中的值myuser，如果没有值，echo $username的值就是testuser&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----&amp;gt;这样看来就很好理解为什么编辑/etc/sysconfig/httpd就会生效的&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11.958691910499&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;MPM详细的参数配置：/etc/httpd/conf/httpd.conf中&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;prefork&lt;/strong&gt;的配置&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;16.941246354898&quot;&gt;
&lt;p&gt;# StartServers:服务器刚启动时启动多少个进程&lt;/p&gt;
&lt;p&gt;# MinSpareServers:最小保持空闲进程的数量&lt;/p&gt;
&lt;p&gt;# MaxSpareServers:最大保持空闲进程的数量&lt;/p&gt;
&lt;p&gt;# ServerLimit: MaxClients在服务器生命周期中的最大值&lt;/p&gt;
&lt;p&gt;# MaxClients:最大并发客户端连接数&lt;/p&gt;
&lt;p&gt;# MaxRequestsPerChild: 服务器进程服务的最大请求数&lt;/p&gt;
&lt;div readability=&quot;12.954240457595&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;IfModule prefork.c&amp;gt;&lt;span&gt;    #条件式参数,表示如果模块是
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; StartServers       &lt;span&gt;8&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; MinSpareServers    &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; MaxSpareServers   &lt;span&gt;20&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; ServerLimit      &lt;span&gt;256&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; MaxClients       &lt;span&gt;256&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; MaxRequestsPerChild  &lt;span&gt;4000&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &amp;lt;/IfModule&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;worker&lt;/strong&gt;的配置：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;21.423415149997&quot;&gt;
&lt;p&gt;# StartServers: 启动服务器进程的初始数量&lt;/p&gt;
&lt;p&gt;# MaxClients:最大并发客户端连接数&lt;/p&gt;
&lt;p&gt;# MinSpareThreads: 保留多少空余线程数量&lt;/p&gt;
&lt;p&gt;# MaxSpareThreads:最大保留多少空余线程数量&lt;/p&gt;
&lt;p&gt;# ThreadsPerChild: 每个服务器进程中不断的工作线程数&lt;/p&gt;
&lt;p&gt;# MaxRequestsPerChild: 服务器进程服务的最大请求数&lt;/p&gt;
&lt;div readability=&quot;18.931030571153&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;IfModule worker.c&amp;gt;
&lt;span&gt;2&lt;/span&gt; StartServers         &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; MaxClients         &lt;span&gt;300&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; MinSpareThreads     &lt;span&gt;25&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; MaxSpareThreads     &lt;span&gt;75&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; ThreadsPerChild     &lt;span&gt;25&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; MaxRequestsPerChild  &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &amp;lt;/IfModule&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：这里虽然定义的StartServers是4个，但是每次查看都是3个，我们可以通过以下查看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;ps&lt;/span&gt; aux | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; httpd
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;service httpd restart
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; watch -n.&lt;span&gt;5&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ps aux | grep httpd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;         #每0.5秒监测一下发现会自动销毁一个
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/742708/201710/742708-20171004232150130-2061440182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/742708/201710/742708-20171004232159958-872988987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    PV：Page View，页面访问，一个页面可能就上百个资源；&lt;/p&gt;
&lt;p&gt;    UV: User View，用户浏览量，指的是浏览的独立IP&lt;/p&gt;
&lt;p&gt;4、DSO&lt;/p&gt;
&lt;p&gt;    配置指定实现模块加载&lt;/p&gt;
&lt;div readability=&quot;14.943615646658&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; #LoadModule  &amp;lt;mod_name&amp;gt;  &amp;lt;mod_path&amp;gt;
&lt;span&gt;2&lt;/span&gt; LoadModule auth_basic_module modules/mod_auth_basic.so
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模块文件路径可使用相对路径：&lt;/p&gt;
&lt;p&gt;    相对于ServerRoot（默认/etc/httpd）&lt;/p&gt;
&lt;div readability=&quot;19.425895136868&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; lrwxrwxrwx. &lt;span&gt;1&lt;/span&gt; root root   &lt;span&gt;29&lt;/span&gt; 4月  &lt;span&gt;27&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt; modules -&amp;gt; ../../usr/lib64/httpd/modules
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、定义'Main' server的文档页面路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/www/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;        #注意更改此路径时,一定要确定你的selinux是关闭的
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;p&gt;文档路径映射：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;        DoucmentRoot指向的路径为URL路径的起始位置，其相当于站点URL的根路径；&lt;/p&gt;
&lt;p&gt;        (FileSystem) /web/host1/index.html  --&amp;gt;  (URL)  /index.html&lt;/p&gt;
&lt;p&gt;注意：在httpd2.4上只修改DocumentRoot是一定不会生效的，必须要设置站点访问控制机制；如下&lt;/p&gt;
&lt;div readability=&quot;22.909621170258&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/www/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/www/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、站点访问控制常见机制&lt;/p&gt;
&lt;p&gt;可基于两种机制指明对资源进行何种访问控制&lt;/p&gt;
&lt;p&gt;(1)文件系统路径：&lt;/p&gt;
&lt;div readability=&quot;36.354951878299&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;Directory  &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;   ...            #表示对该目录下的所有包含子目录生效
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &amp;lt;/Directory&amp;gt;
&lt;span&gt;4&lt;/span&gt; &amp;lt;File  &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;   ...            #表示对单个文件进行访问控制
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &amp;lt;/File&amp;gt;
&lt;span&gt;7&lt;/span&gt; &amp;lt;FileMatch  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PATTERN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;   ...            #表示对一类文件进行访问控制(被PATTERN匹配的一类文件)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &amp;lt;/FileMatch&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)URL路径：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;Location  &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;2&lt;/span&gt;   ...             #表示对&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;中指定的位置下的所有做访问控制
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &amp;lt;/Location&amp;gt;
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &amp;lt;LocationMatch &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;  ...             #表示对匹配到的位置进行访问控制
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &amp;lt;/LocationMatch&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&amp;lt;Directory&amp;gt;中“基于源地址”实现访问控制：&lt;/p&gt;
&lt;p&gt;    (1)&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;Options&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;        后跟1个或多个以空白字符分隔的“选项”列表；&lt;/p&gt;
&lt;p&gt;        选项：Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;Indexes：指明的URL路径下不存在与定义的主页面资源相符的资源文件时，返回索引列表给用户；&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;一般只是做为下载站点时才采用；默认是启用的；&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;FollowSymLinks：允许跟踪符号链接文件所指向的源文件；就是可以读取访问控制目录下的所有被链接到的文件的内容；有风险&lt;/li&gt;
&lt;li&gt;None：表示不启用，不使用任何选项&lt;/li&gt;
&lt;li&gt;All：包含除了MultiViews的所有选项&lt;/li&gt;
&lt;li&gt;includes ：表示包含服务器端由mod_include提供的&lt;/li&gt;
&lt;li&gt;SymLinksifOwnerMatch:服务器将仅跟踪目标文件或目录所拥有的符号链接与链接相同的用户标识&lt;/li&gt;
&lt;li&gt;ExecCGI:表示允许执行mod_CGI提供的脚本&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;    (2)  &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;AllowOverride 允许覆盖&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        与访问控制相关的哪些指令可以放在.htaccess文件（网站目录下的每个子目录都可以有一个）中；&lt;/p&gt;
&lt;p&gt;        All: 所有的指定都可以放进去&lt;/p&gt;
&lt;p&gt;       None：不放任何指定&lt;/p&gt;
&lt;p&gt;        注意：还有一些其他的选项：FileInfo(文件信息) AuthConfig Limit&lt;/p&gt;
&lt;p&gt;    (3) order和allow、deny&lt;/p&gt;
&lt;p&gt;        order：定义生效次序；表示对源地址进行访问控制；写在后面的表示默认法则；&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;    Allow from：表示允许那些范围(白名单)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            Deny from：表示拒绝那些范围(黑名单)&lt;/p&gt;
&lt;p&gt;7、定义站点主页面：&lt;/p&gt;
&lt;div readability=&quot;22.89511187117&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; DirectoryIndex  index.html  index.html.var index.php
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;注意：如果匹配不到以上的所有的后缀索引，那么访问站点时可能会有以下集中情况&lt;/p&gt;
&lt;div&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;告诉用户你所访问的资源不存在&lt;/li&gt;
&lt;li&gt;返回该路径下的所有可用的URL给列出来；相当于暴露了网站的源码，但是又可以用于作为下载站点；&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;8、定义路径别名&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    格式：Alias  /URL&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;/&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  &quot;/PATH/TO/SOMEDIR&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;/&lt;/strong&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;58.22504957039&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/www/htdocs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.magedu.com/download/bash-4.4.2-3.el6.x86_64.rpm     #正常情况下基于URL映射&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         /www/htdocs/download/bash-&lt;span&gt;4.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.el6.x86_64.rpm           #正常情况下基于文件系统映射
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                     
&lt;span&gt; 5&lt;/span&gt; Alias  /download/  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/rpms/pub/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.magedu.com/download/bash-4.4.2-3.el6.x86_64.rpm &lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         /rpms/pub/bash-&lt;span&gt;4.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.el6.x86_64.rpm
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.magedu.com/images/logo.png&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     /www/htdocs/images/logo.png
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;9、设定默认字符集&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    AddDefaultCharset  UTF-8&lt;/p&gt;
&lt;p&gt;    中文字符集：GBK, GB2312, GB18030&lt;/p&gt;
&lt;p&gt;10、日志设定&lt;/p&gt;
&lt;p&gt;    日志类型：访问日志 和 错误日志&lt;/p&gt;
&lt;p&gt;        错误日志：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;    ErrorLog  logs/error_log&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;    LogLevel  warn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;        可能存在的值有: debug, info, notice, warn, error, crit, alert, emerg.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;访问日志：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;    LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&amp;gt;s %b \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; combined&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;    CustomLog  logs/access_log  combined&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                combined：表示使用自定义格式的格式名称，如&lt;/p&gt;
&lt;div readability=&quot;54.720812182741&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; LogFormat &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%h %l %u %t \&quot;%r\&quot; %&amp;gt;s %b \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; combined
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; LogFormat &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%h %l %u %t \&quot;%r\&quot; %&amp;gt;s %b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; common
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; LogFormat &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{Referer}i -&amp;gt; %U&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; referer
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; LogFormat &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{User-agent}i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; agent
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;4.2627737226277&quot;&gt;

&lt;p&gt;    %h：客户端IP地址；&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    %l：Remote User, 通常为一个减号（“-”）；&lt;/p&gt;
&lt;p&gt;    %u：Remote user (from auth; may be bogus if return status (%s) is 401)；非为登录访问时，其为一个减号；&lt;/p&gt;
&lt;p&gt;    %t：服务器收到请求时的时间；&lt;/p&gt;
&lt;p&gt;    %r：First line of request，即表示请求报文的首行；记录了此次请求的“方法”，“URL”以及协议版本；&lt;/p&gt;
&lt;p&gt;    %&amp;gt;s：响应状态码；&lt;/p&gt;
&lt;p&gt;    %b：响应报文的大小，单位是字节；不包括响应报文的http首部；&lt;/p&gt;
&lt;p&gt;    %{Referer}i：请求报文中首部“referer”的值；即从哪个页面中的超链接跳转至当前页面的；&lt;/p&gt;
&lt;p&gt;    %{User-Agent}i：请求报文中首部“User-Agent”的值；即发出请求的应用程序；&lt;/p&gt;
&lt;p&gt;11、基于用户的访问控制&lt;/p&gt;
&lt;p&gt;    认证质询：&lt;/p&gt;
&lt;p&gt;        WWW-Authenticate：响应码为401，拒绝客户端请求，并说明要求客户端提供账号和密码；&lt;/p&gt;
&lt;p&gt;    认证：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;Authorization：客户端用户填入账号和密码后再次发送请求报文；认证通过时，则服务器发送响应的资源；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    认证方式有两种：&lt;/p&gt;
&lt;p&gt;        basic：明文 &lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;digest：消息摘要认证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    安全域：需要用户认证后方能访问的路径；应该通过名称对其进行标识，以便于告知用户认证的原因；&lt;/p&gt;
&lt;p&gt;    用户的账号和密码存放于何处？&lt;/p&gt;
&lt;p&gt;    虚拟账号：仅用于访问某服务时用到的认证标识&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;存储：文本文件，SQL数据库，ldap目录存储；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;basic认证配置示例：&lt;/p&gt;
&lt;p&gt;(1) 定义安全域&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;Directory &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    Options None
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    AllowOverride None
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    AuthType Basic
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     AuthName &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;String“&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     AuthUserFile  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/PATH/TO/HTTPD_USER_PASSWD_FILE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     Require  user  username1  username2 ...                #授权指定用户可以访问,如果需要让所有的人可访,改成Require valid-&lt;span&gt;user
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &amp;lt;/Directory&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;允许账号文件中的所有用户登录访问：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    Require  valid-user&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;Directory &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    Options None
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    AllowOverride None
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    AuthType Basic
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     AuthName &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;String“&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     AuthUserFile  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/PATH/TO/HTTPD_USER_PASSWD_FILE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     Require  valid-user              #授权指定用户可以访问,如果需要让所有的人可访,改成Require valid-&lt;span&gt;user
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &amp;lt;/Directory&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2) 提供账号和密码存储（文本文件）&lt;/p&gt;
&lt;p&gt;使用专用命令完成此类文件的创建及用户管理&lt;/p&gt;
&lt;p&gt;    htpasswd  [options]   /PATH/TO/HTTPD_PASSWD_FILE  username &lt;/p&gt;
&lt;p&gt;        -c：自动创建此处指定的文件，因此，仅应该在此文件不存在时使用；&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;-m：md5格式加密&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;-s: sha格式加密&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;-D：删除指定用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;范例1：&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; /var/www/html/&lt;span&gt;admin
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h1&amp;gt;admin page&amp;lt;/h1&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&lt;span&gt; index.html
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &amp;lt;Directory /var/www/html/admin/&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    Options None
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    AllowOverride None
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    AuthType Basic
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     AuthName &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Admin Realm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     AuthUserFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/httpd/conf/.htpasswd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    Require user tom
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &amp;lt;/Directory&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置加密文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; cd /etc/httpd/conf/
&lt;span&gt;2&lt;/span&gt; [root@httpd conf]# htpasswd -c -m ./&lt;span&gt;.htpasswd tom
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;New password: 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; Re-type new password: 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;访问浏览器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/742708/201710/742708-20171004232714771-633897913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/742708/201710/742708-20171004232723974-1583099909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外：基于组账号进行认证；&lt;/p&gt;
&lt;p&gt;(1) 定义安全域&lt;/p&gt;
&lt;div readability=&quot;23.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;Directory &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  Options None
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  AllowOverride None
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  AuthType Basic
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   AuthName &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;String“&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;   AuthUserFile  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/PATH/TO/HTTPD_USER_PASSWD_FILE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;   AuthGroupFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/PATH/TO/HTTPD_GROUP_FILE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;  Require  group  grpname1  grpname2 ...
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &amp;lt;/Directory&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;(2) 创建用户账号和组账号文件；&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    组文件：每一行定义一个组&lt;/p&gt;
&lt;p&gt;        GRP_NAME: username1  username2  ...&lt;/p&gt;
&lt;p&gt;案例2&lt;/p&gt;
&lt;div readability=&quot;33.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; /var/www/html/upload;&lt;span&gt;cp&lt;/span&gt; /var/www/html/admin/index.html /var/www/html/upload/
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h1&amp;gt;upload page&amp;lt;/h1&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; /var/www/html/upload/&lt;span&gt;index.html
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &amp;lt;Directory /var/www/html/upload/&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    Options None
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    AllowOverride None
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    AuthType Basic
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     AuthName &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Admin Realm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     AuthUserFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/httpd/conf/.htpasswd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     AuthGroupFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/httpd/conf/.htgroup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    Require group mygroup
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &amp;lt;/Directory&amp;gt;
&lt;span&gt;12&lt;/span&gt; [root@httpd conf]# &lt;span&gt;cat&lt;/span&gt; ./&lt;span&gt;.htgroup 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;mygroup: tom Jason
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; othergroup: obama
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/742708/201710/742708-20171004232842849-1796036784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/742708/201710/742708-20171004232850990-946141095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;12、虚拟主机&lt;/p&gt;
&lt;p&gt;    站点标识： socket&lt;/p&gt;
&lt;p&gt;        IP相同，但端口不同；&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;IP不同，但端口均为默认端口；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;FQDN不同；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;    请求报文中首部&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;    Host: www.linuxedu.top&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有三种实现方案：&lt;/p&gt;
&lt;p&gt;    基于ip：&lt;/p&gt;
&lt;p&gt;        为每个虚拟主机准备至少一个ip地址；&lt;/p&gt;
&lt;p&gt;    基于port：&lt;/p&gt;
&lt;p&gt;        为每个虚拟主机使用至少一个独立的port；&lt;/p&gt;
&lt;p&gt;    基于FQDN:&lt;/p&gt;
&lt;p&gt;        为每个虚拟主机使用至少一个FQDN；&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;注意：一般虚拟机不要与中心主机混用；因此，要使用虚拟主机，得先禁用'main'主机；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;禁用方法：注释中心主机的DocumentRoot指令即可；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虚拟主机的配置方法：&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;VirtualHost  IP:PORT&amp;gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  ServerName FQDN
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   DocumentRoot  &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;
&lt;p&gt;其它可用指令：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    ServerAlias：虚拟主机的别名；可多次使用；&lt;/p&gt;
&lt;p&gt;    ErrorLog：&lt;/p&gt;
&lt;p&gt;    CustomLog：&lt;/p&gt;
&lt;p&gt;    &amp;lt;Directory &quot;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;/Directory&amp;gt;&lt;/p&gt;
&lt;p&gt;    Alias&lt;/p&gt;
&lt;p&gt;    ...&lt;/p&gt;
&lt;p&gt;完成以下三种方案：&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;注意注释掉中心主机，关闭selinux，清空防火墙规则；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基于IP的虚拟主机示例：&lt;/p&gt;
&lt;div readability=&quot;20.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;VirtualHost &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;100.6&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        ServerName www.a.com
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/www/a.com/htdocs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &amp;lt;/VirtualHost&amp;gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;VirtualHost &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;100.7&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        ServerName www.b.net
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/www/b.net/htdocs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;/VirtualHost&amp;gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &amp;lt;VirtualHost &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;100.8&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&amp;gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        ServerName www.c.org
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/www/c.org/htdocs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基于端口的虚拟主机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &amp;lt;VirtualHost &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;100.6&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        ServerName www.a.com
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/www/a.com/htdocs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &amp;lt;/VirtualHost&amp;gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;VirtualHost &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;100.6&lt;/span&gt;:&lt;span&gt;808&lt;/span&gt;&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        ServerName www.b.net
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/www/b.net/htdocs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;/VirtualHost&amp;gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &amp;lt;VirtualHost &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;100.6&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&amp;gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        ServerName www.c.org
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/www/c.org/htdocs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基于FQDN的虚拟主机：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; NameVirtualHost &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;100.6&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;VirtualHost &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;100.6&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        ServerName www.a.com
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/www/a.com/htdocs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;/VirtualHost&amp;gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;VirtualHost &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;100.6&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&amp;gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        ServerName www.b.net
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/www/b.net/htdocs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &amp;lt;/VirtualHost&amp;gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &amp;lt;VirtualHost &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;100.6&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&amp;gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        ServerName www.c.org
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/www/c.org/htdocs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &amp;lt;/VirtualHost&amp;gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;13、status页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; LoadModule  status_module  modules/&lt;span&gt;mod_status.so
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &amp;lt;Location /server-status&amp;gt;
&lt;span&gt;3&lt;/span&gt;         SetHandler server-&lt;span&gt;status
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        Order allow,deny
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         Allow from &lt;span&gt;172.16&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &amp;lt;/Location&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/742708/201710/742708-20171004233049458-794348736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;
&lt;h2&gt; 思考如何实现虚拟主机的https&lt;/h2&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;参考文献&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt; 要实现一个Apache服务器上提供多个SSL虚拟主机，可以：&lt;/p&gt;
&lt;div class=&quot;bct fc05 fc11 nbw-blog ztag js-fs2&quot; readability=&quot;40&quot;&gt;&lt;span&gt;* 使用多域名SSL证书，可以实现一个IP，一个443端口上多个SSL虚拟主机；&lt;br/&gt;* 一个ip，为所有SSL虚拟主机配置单独的端口。比如，默认的虚拟主机使用443，其他的使用8080或8081等，且每个SSL虚&lt;br/&gt;  拟主机必须独占一个端口；&lt;br/&gt;* 为Apache服务器配置多个IP，每个SSL虚拟主机独占IP。如果只有一张物理网卡，可以配置为网卡配置子接口；&lt;br/&gt;* 使用mod_gnutls模块，创建多个SSL虚拟主机 &lt;/span&gt;&lt;span readability=&quot;8&quot;&gt;&lt;br/&gt;1. Apache中同一IP多个HTTPS虚拟主机的实现&lt;br/&gt;在 Apache 文档中提到，不能在单个 IP 上同时有多个按名字识别的虚拟主机(&quot;named virtual host&quot;)。不完全是这样。&lt;p&gt;HTTPS协议的过程是：服务器首先与客户机之间进行服务器身份验证并协商安全会话，然后，客户端向服务器发送 HTTP 请求。这样一来，在客户端开始发送HTTP请求之前，服务器就已经把证书发给了客户端（客户端根据本地的根证书去验证证书链，等等）。而最重要的是，为了表明身份，这个证书的&quot;Common Name&quot;填写的应该是域名，否则浏览器会给出警告。&lt;br/&gt;既然在这个过程中，客户端就所访问的域名所处的地位是&quot;被告知&quot;的地位，因此，客户端再发出的 Host: 请求头也就显得不那么有意义了。另一方面，如果客户请求的域名与Common Name不符，浏览器也会给出警告。至少，在表面上看是这样。&lt;/p&gt;&lt;p&gt;不过，对于自行签署的证书，以及一些发证机构而言，其实还可以签署一种普适HTTPS证书，这种证书的&lt;/p&gt;&lt;/span&gt;&lt;span&gt;Common Name&lt;/span&gt;&lt;span readability=&quot;12&quot;&gt;一栏是 *.domain.tld 这样的形式，即其主机名部分可以是任意字符串，而只有域名部分是确定的。&lt;br/&gt;当然，这种证书的安全性有一定的负面影响：由于一个证书可以验证整个域下面的所有服务器，一旦其被破解，则所有加密通讯也就同时失密了（当然，可以每台服务器使用自己的单独的证书），不过这个问题并不是太严重，通常还算是尚可接受的范围。另一个潜在的影响是，某些手机上运行的浏览器不能正确处理这种证书，不过这个问题仅限于希望给手机提供服务的网站。&lt;p&gt;因此，简而言之，符合这样几个条件的前提下，是可以在同一个IP上部署多个HTTPS虚拟主机的：&lt;br/&gt;    a) 这些虚拟主机是同属于同一域名的子域名 &lt;br/&gt;    b) 拥有普适证书 &lt;br/&gt;    c) 正确地配置Apache。&lt;/p&gt;&lt;p&gt;如果要在一个IP地址上需要部署多个SSL网站，&lt;br/&gt;（1）一种方法：如果要在同一个IP地址的443端口上部署多个网站，必须保证这些网站的域名都能匹配相同的一张SSL证书。这是因为SSL握手协议过程中,是通过IP+Port来进行通信，一个IP的一个端口只能返给客户一张SSL证书（即使有多张证书，也只能返回第一张，因为无法分辨用户会需要返回哪张证书），如果这张证书能够满足这些网站的主机名匹配要求（访问b.test.com时，使用a.test.com段的证书，证书中包含a.test.com,于虚拟主机中的主机名之一匹配），就可以使用。&lt;br/&gt;一般能匹配多个主机名的证书有通配符证书*.domain.com和多域名证书(www.domain.com,ftp.domain.com 等)，以下我们提供一个典型同一个IP上的多主机名部署配置，www.domain.com对应的根目录在WWW下，ftp.domain.com对应的根目录在FTP下，&lt;/p&gt;&lt;/span&gt;&lt;span&gt;www.domain.com&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;ftp.domain.com&lt;/span&gt;&lt;span&gt;使用相同的证书：&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;bct fc05 fc11 nbw-blog ztag js-fs2&quot; readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; NameVirtualHost &lt;span&gt;11.22&lt;/span&gt;.&lt;span&gt;33.44&lt;/span&gt;:&lt;span&gt;443&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &amp;lt;VirtualHost &lt;span&gt;11.22&lt;/span&gt;.&lt;span&gt;33.44&lt;/span&gt;:&lt;span&gt;443&lt;/span&gt;&amp;gt;
&lt;span&gt; 4&lt;/span&gt; DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/htdocs/www&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;ServerName www.domain.com
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;SSLEngine on
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; SSLCertificateFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/conf/server.cer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; SSLCertificateKeyFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/conf/server.key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &amp;lt;/VirtualHost&amp;gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &amp;lt;VirtualHost &lt;span&gt;11.22&lt;/span&gt;.&lt;span&gt;33.44&lt;/span&gt;:&lt;span&gt;443&lt;/span&gt;&amp;gt;
&lt;span&gt;12&lt;/span&gt; DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/htdocs/ftp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; ServerName &lt;span&gt;ftp&lt;/span&gt;&lt;span&gt;.domain.com
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;SSLEngine on
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; SSLCertificateFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/conf/server.cer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; SSLCertificateKeyFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/conf/server.key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &amp;lt;/VirtualHost&amp;gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; （&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）另一种办法就是给每个网站分配不同的端口号；
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &amp;lt;VirtualHost &lt;span&gt;11.22&lt;/span&gt;.&lt;span&gt;33.44&lt;/span&gt;:&lt;span&gt;443&lt;/span&gt;&amp;gt;
&lt;span&gt;21&lt;/span&gt; DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/htdocs/www&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;ServerName www.domain.com
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;SSLEngine on
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; SSLCertificateFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/conf/server.cer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; SSLCertificateKeyFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/conf/server.key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &amp;lt;/VirtualHost&amp;gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &amp;lt;VirtualHost &lt;span&gt;11.22&lt;/span&gt;.&lt;span&gt;33.44&lt;/span&gt;:&lt;span&gt;8443&lt;/span&gt;&amp;gt;
&lt;span&gt;29&lt;/span&gt; DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/htdocs/ftp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; ServerName &lt;span&gt;ftp&lt;/span&gt;&lt;span&gt;.domain.com
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;SSLEngine on
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; SSLCertificateFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/conf/server.cer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; SSLCertificateKeyFile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Apache2.2/conf/server.key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;基于域名的虚拟主机只能使用同一个证书，或者说，即使有不同的证书，最终使用的都是排在前面的默认的第一个&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;2. Apache中一张网卡绑定不同IP实现多个HTTPS虚拟主机&lt;br/&gt;&lt;/span&gt;&lt;span&gt;一张网卡绑定多个ip，ifconfig eth0:0......&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;VirtualHost &lt;span&gt;220.181&lt;/span&gt;.&lt;span&gt;75.109&lt;/span&gt;:&lt;span&gt;8443&lt;/span&gt;&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     ServerAdmin lala@corp.net.com
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      DocumentRoot /home/lala/apache/htdocs/&lt;span&gt;test
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     ServerName a.test.com
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     SSLEngine on
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      SSLCipherSuite ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP:+&lt;span&gt;eNULL
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      SSLCertificateFile /home/lala/apache/conf/ssl.key/&lt;span&gt;server.crt
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      SSLCertificateKeyFile /home/lala/apache/conf/ssl.key/&lt;span&gt;server.key
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      #Include /home/lala/apache/conf/&lt;span&gt;ssl.conf
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      #ErrorLog logs/dummy-a.test.com-&lt;span&gt;error_log
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      #CustomLog logs/a.test.com-&lt;span&gt;access_log common
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &amp;lt;/VirtualHost&amp;gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &amp;lt;VirtualHost &lt;span&gt;220.181&lt;/span&gt;.&lt;span&gt;75.65&lt;/span&gt;:&lt;span&gt;8443&lt;/span&gt;&amp;gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     ServerAdmin lala@corp.net.com
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      DocumentRoot /home/lala/apache/htdocs/&lt;span&gt;test2
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     ServerName d.test.com
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     SSLEngine on
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;      SSLCipherSuite ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP:+&lt;span&gt;eNULL
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;      SSLCertificateFile /home/lala/apache/conf/ssl.key/&lt;span&gt;server2.crt
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;      SSLCertificateKeyFile /home/lala/apache/conf/ssl.key/&lt;span&gt;server2.key
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;      #Include /home/lala/apache/conf/&lt;span&gt;ssl.conf
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;      #ErrorLog logs/dummy-a.test.com-&lt;span&gt;error_log
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;      #CustomLog logs/a.test.com-&lt;span&gt;access_log common
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 04 Oct 2017 15:16:00 +0000</pubDate>
<dc:creator>LinuxerMaster</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuelong3/p/7628036.html</dc:identifier>
</item>
<item>
<title>用 Python 撸一个区块链 - kidney</title>
<link>http://www.cnblogs.com/kidney/p/7627145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kidney/p/7627145.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文翻译自 Daniel van Flymen 的文章 Learn Blockchains by Building One&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;略有删改。原文地址：&lt;a href=&quot;https://hackernoon.com/learn-blockchains-by-building-one-117428612f46&quot; target=&quot;_blank&quot;&gt;https://hackernoon.com/learn-blockchains-by-building-one-117428612f46&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;相信你和我一样对数字货币的崛起感到新奇，并且想知道其背后的技术——区块链是怎样实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是理解区块链并非易事，至少对于我来说是如此。晦涩难懂的视频、漏洞百出的教程以及示例的匮乏令我倍受挫折。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。如果你也这样做，那么读完本文，你将获得一个可用的区块链以及对区块链的深刻理解。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;开始之前...&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先你需要知道区块链是由被称为区块的记录构成的不可变的、有序的链式结构，这些记录可以是交易、文件或任何你想要的数据，最重要的是它们是通过 Hash 连接起来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你不了解 Hash，这里有个例子 &lt;a href=&quot;https://learncryptography.com/hash-functions/what-are-hash-functions&quot;&gt;https://learncryptography.com/hash-functions/what-are-hash-functions&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其次，你需要安装 Python3.6+，Flask，Request&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip install Flask==0.12.2 requests==2.18.4
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;同时你还需要一个 HTTP 客户端，比如 Postman，cURL 或任何其它客户端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终的源代码在这里：&lt;a href=&quot;https://github.com/dvf/blockchain&quot;&gt;https://github.com/dvf/blockchain&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一步： 打造一个 Blockchain&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中。首先创建一个 Blockchain 类，在构造函数中我们创建了两个列表，一个用于储存区块链，一个用于储存交易。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.chain =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.current_transactions =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_block(self):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Creates a new Block and adds it to the chain&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_transaction(self):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Adds a new transaction to the list of transactions&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; hash(block):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Hashes a Block&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; last_block(self):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Returns the last Block in the chain&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;一个区块有五个基本属性：index，timestamp（in Unix time），transaction 列表，工作量证明（稍后解释）以及前一个区块的 Hash 值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; block =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1506057125.900785&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;transactions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8527147fe1f5426f9dd545de4b27ee00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a77f5cdfa2934df3954a5c7c7da5df1f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 5&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    ],
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 324984774000&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;previous_hash&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;到这里，区块链的概念应该比较清楚了：每个新的区块都会包含上一个区块的 Hash 值。这一点非常关键，它是区块链不可变性的根本保障。如果攻击者破坏了前面的某个区块，那么后面所有区块的 Hash 都会变得不正确。不理解？慢慢消化~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们需要一个向区块添加交易的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_transaction(self, sender, recipient, amount):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        Creates a new transaction to go into the next mined Block
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        :param sender: &amp;lt;str&amp;gt; Address of the Sender
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        :param recipient: &amp;lt;str&amp;gt; Address of the Recipient
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        :param amount: &amp;lt;int&amp;gt; Amount
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        :return: &amp;lt;int&amp;gt; The index of the Block that will hold this transaction
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        self.current_transactions.append({
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: sender,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: recipient,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: amount,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.last_block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] + 1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;new_transaction() 方法向列表中添加一个交易记录，并返回该记录将被添加到的区块——下一个待挖掘的区块——的索引，稍后在用户提交交易时会有用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当 Blockchain 实例化后，我们需要创建一个初始的区块（创世块），并且给它预设一个工作量证明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了添加创世块的代码，我们还需要补充 new_block(), new_transaction() 和 hash() 方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; hashlib
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.current_transactions =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.chain =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create the genesis block&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         self.new_block(previous_hash=1, proof=100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; new_block(self, proof, previous_hash=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         block =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: len(self.chain) + 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: time(),
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;transactions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: self.current_transactions,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: proof,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;previous_hash&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: previous_hash &lt;span&gt;or&lt;/span&gt; self.hash(self.chain[-1&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Reset the current list of transactions&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         self.current_transactions =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        self.chain.append(block)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; block
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_transaction(self, sender, recipient, amount):
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        self.current_transactions.append({
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: sender,
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: recipient,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: amount,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.last_block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] + 1
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; last_block(self):
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.chain[-1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; hash(block):
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         block_string = json.dumps(block, sort_keys=&lt;span&gt;True).encode()
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; hashlib.sha256(block_string).hexdigest()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;上面的代码应该很直观，我们基本上有了区块链的雏形。但此时你肯定很想知道一个区块究竟是怎样被创建或挖掘出来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新的区块来自工作量证明（PoW）算法。PoW 的目标是计算出一个符合特定条件的数字，这个数字对于所有人而言必须在计算上非常困难，但易于验证。这就是工作量证明的核心思想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc...0。设 x = 5，求 y？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; hashlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sha256
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; x = 5
&lt;span&gt;3&lt;/span&gt; y = 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; We don't know what y should be yet...&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; sha256(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{x*y}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode()).hexdigest()[-1] != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     y += 1
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;The solution is y = {y}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;结果是 y = 21 // hash(5 * 21) = 1253e9373e...5e3600155e860&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在比特币中，工作量证明算法被称为 Hashcash，它和上面的问题很相似，只不过计算难度非常大。这就是矿工们为了争夺创建区块的权利而争相计算的问题。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，就会获得一定数量的比特币奖励（通过交易）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网络要验证结果，当然非常容易。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们来实现一个 PoW 算法，和上面的例子非常相似，规则是：寻找一个数 p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; hashlib
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; uuid &lt;span&gt;import&lt;/span&gt;&lt;span&gt; uuid4
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; proof_of_work(self, last_proof):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         proof =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; self.valid_proof(last_proof, proof) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; False:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             proof += 1
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proof
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; valid_proof(last_proof, proof):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         guess = f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{last_proof}{proof}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.encode()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         guess_hash =&lt;span&gt; hashlib.sha256(guess).hexdigest()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; guess_hash[:4] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;衡量算法复杂度的办法是修改零的个数。4 个零足够用于演示了，你会发现哪怕多一个零都会大大增加计算出结果所需的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的 Blockchain 基本已经完成了，接下来我们将使用 HTTP requests 来与之交互。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二步：作为 API 的 Blockchain&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将使用 Flask 框架，它十分轻量并且很容易将网络请求映射到 Python 函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将创建三个接口：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    /transactions/new 创建一个交易并添加到区块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    /mine 告诉服务器去挖掘新的区块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    /chain 返回整个区块链&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的服务器将扮演区块链网络中的一个节点。我们先添加一些常规代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; hashlib
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; textwrap &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dedent
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; uuid &lt;span&gt;import&lt;/span&gt;&lt;span&gt; uuid4
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask, jsonify, request
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Instantiate our Node&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; app = Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Generate a globally unique address for this node&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; node_identifier = str(uuid4()).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Instantiate the Blockchain&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; blockchain =&lt;span&gt; Blockchain()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/mine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; mine():
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;We'll mine a new Block&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;   
&lt;span&gt;24&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/transactions/new&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_transaction():
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;We'll add a new transaction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/chain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; full_chain():
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     response =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: blockchain.chain,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: len(blockchain.chain),
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; jsonify(response), 200
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     app.run(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=5000)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这是用户发起交易时发送到服务器的请求：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;someone else's address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 5
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们已经有了向区块添加交易的方法，因此剩下的部分就很简单了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/transactions/new&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_transaction():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     values =&lt;span&gt; request.get_json()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Check that the required fields are in the POST'ed data&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     required = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; all(k &lt;span&gt;in&lt;/span&gt; values &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; required):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Missing values&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 400
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create a new Transaction&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     index = blockchain.new_transaction(values[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], values[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;recipient&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], values[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     response = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Transaction will be added to Block {index}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; jsonify(response), 201
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;挖掘端正是奇迹发生的地方，它只做三件事：计算 PoW；通过新增一个交易授予矿工一定数量的比特币；构造新的区块并将其添加到区块链中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/mine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; mine():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; We run the proof of work algorithm to get the next proof...&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     last_block =&lt;span&gt; blockchain.last_block
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     last_proof = last_block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     proof =&lt;span&gt; blockchain.proof_of_work(last_proof)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; We must receive a reward for finding the proof.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; The sender is &quot;0&quot; to signify that this node has mined a new coin.&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    blockchain.new_transaction(
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         sender=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         recipient=&lt;span&gt;node_identifier,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         amount=1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Forge the new Block by adding it to the chain&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     block =&lt;span&gt; blockchain.new_block(proof)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     response =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;New Block Forged&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;transactions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;transactions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;previous_hash&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;previous_hash&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; jsonify(response), 200
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;需注意交易的接收者是我们自己的服务器节点，目前我们做的大部分事情都只是围绕 Blockchain 类进行交互。到此，我们的区块链就算完成了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三步：交互演示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用 Postman 演示，略。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第四步：一致性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这真的很棒，我们已经有了一个基本的区块链可以添加交易和挖矿。但是，整个区块链系统必须是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点运行在同一条链上呢？这就是一致性问题，我们要想在网络中添加新的节点，就必须实现保证一致性的算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。让我们新增几个接口：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1. /nodes/register 接收以 URL 的形式表示的新节点的列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2. /nodes/resolve 用于执行一致性算法，用于解决任何冲突，确保节点拥有正确的链&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; urllib.parse &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urlparse
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        ...
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.nodes =&lt;span&gt; set()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        ...
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; register_node(self, address):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         parsed_url =&lt;span&gt; urlparse(address)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         self.nodes.add(parsed_url.netloc)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;注意到我们用 set 来储存节点，这是一种避免重复添加节点的简便方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面提到的冲突是指不同的节点拥有的链存在差异，要解决这个问题，我们规定最长的合规的链就是最有效的链，换句话说，只有最长且合规的链才是实际存在的链。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们再添加两个方法，一个用于添加相邻节点，另一个用于解决冲突。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blockchain(object)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; valid_chain(self, chain):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         last_block =&lt;span&gt; chain[0]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         current_index = 1
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; current_index &amp;lt;&lt;span&gt; len(chain):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             block =&lt;span&gt; chain[current_index]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{last_block}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{block}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n-----------\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Check that the hash of the block is correct&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;previous_hash&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] !=&lt;span&gt; self.hash(last_block):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Check that the Proof of Work is correct&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; self.valid_proof(last_block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], block[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proof&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             last_block =&lt;span&gt; block
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             current_index += 1
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; resolve_conflicts(self):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         neighbours =&lt;span&gt; self.nodes
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         new_chain =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; We're only looking for chains longer than ours&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         max_length =&lt;span&gt; len(self.chain)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Grab and verify the chains from all the nodes in our network&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; node &lt;span&gt;in&lt;/span&gt;&lt;span&gt; neighbours:
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             response = requests.get(f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://{node}/chain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; response.status_code == 200&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 length = response.json()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 chain = response.json()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Check if the length is longer and the chain is valid&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; length &amp;gt; max_length &lt;span&gt;and&lt;/span&gt;&lt;span&gt; self.valid_chain(chain):
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     max_length =&lt;span&gt; length
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                     new_chain =&lt;span&gt; chain
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Replace our chain if we discovered a new, valid chain longer than ours&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; new_chain:
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             self.chain =&lt;span&gt; new_chain
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;现在你可以新开一台机器，或者在本机上开启不同的网络接口来模拟多节点的网络，或者邀请一些朋友一起来测试你的区块链。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我希望本文能激励你创造更多新东西。我之所以对数字货币入迷，是因为我相信区块链会很快改变我们看待事物的方式，包括经济、政府、档案管理等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;译者补充参考：&lt;a href=&quot;https://www.zhihu.com/question/22076666&quot; target=&quot;_blank&quot;&gt;比特币是什么&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Oct 2017 12:50:00 +0000</pubDate>
<dc:creator>kidney</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kidney/p/7627145.html</dc:identifier>
</item>
<item>
<title>简单说明CGI是什么 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/7627035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/7627035.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog1&quot;&gt;&lt;span&gt;1. CGI是什么&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog2&quot;&gt;&lt;span&gt;2. 各种术语解释&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog3&quot;&gt;&lt;span&gt;3. web server和CGI的交互模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog3.1&quot;&gt;&lt;span&gt;3.1 CGI模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog3.2&quot;&gt;&lt;span&gt;3.2 模块模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html#blog3.3&quot;&gt;&lt;span&gt;3.3 php-fpm模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;CGI是common gateway interface的缩写，大家都译作通用网关接口，但很不幸，我们无法见名知意。&lt;/p&gt;
&lt;p&gt;我们知道，web服务器所处理的内容都是静态的，要想处理动态内容，需要依赖于web应用程序，如php、jsp、python、perl等。但是web server如何将动态的请求传递给这些应用程序？它所依赖的就是cgi协议。没错，是协议，也就是web server和web应用程序交流时的规范。换句话说，通过cgi协议，再结合已搭建好的web应用程序，就可以让web server也能&quot;处理&quot;动态请求，你肯定知道处理两字为什么要加上双引号。&lt;/p&gt;
&lt;p&gt;简单版的cgi工作方式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171004193828411-28489808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，在谷歌搜索栏中搜索一个关键词&quot;http&quot;，对应的URL为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https:
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当谷歌的web server收到该请求后，先分析该url，从中知道了要执行search程序，并且还知道了一系列要传递给search的参数及其对应的value。web server会将这些程序参数和其它一些环境变量根据cgi协议通过TCP或套接字等方式传递给已启动的cgi程序(可能是cgi进程，或者是已加载的模块cgi模块)。当cgi进程接收到web server的请求后，调用search程序并执行，同时还会传递参数给search程序。search执行结束后，cgi进程/线程将处理结果返回给web server，web server再返回给浏览器。&lt;/p&gt;
&lt;p&gt;有多种方式可以执行cgi程序，但对http的请求方法来说，只有get和post两种方法允许执行cgi脚本(即上面的search程序)。&lt;/p&gt;


&lt;p&gt;说实话，对于一个没接触过编程语言的人来说，刚接触cgi概念的时候肯定会有一堆疑问，这到底是什么鬼，处理动态内容的东西不是像php一样的应用程序吗，跟cgi有几毛钱关系，fastcgi又是什么？我想，非科班出身的强迫症患者(包括我)一定会被这些概念折腾的死去活来。&lt;/p&gt;
&lt;p&gt;以php为例，我将一次动态请求相关的概念大致都简单解释一遍。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;cgi&lt;/code&gt;：它是一种协议。通过cgi协议，web server可以将动态请求和相关参数发送给专门处理动态内容的应用程序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fastcgi&lt;/code&gt;：也是一种协议，只不过是cgi的优化版。cgi的性能较烂，fastcgi则在其基础上进行了改进。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;php-cgi&lt;/code&gt;：fastcgi是一种协议，而php-cgi实现了这种协议。不过这种实现比较烂。它是单进程的，一个进程处理一个请求，处理结束后进程就销毁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;php-fmp&lt;/code&gt;：是对php-cgi的改进版，它直接管理多个php-cgi进程/线程。也就是说，&lt;strong&gt;php-fpm是php-cgi的进程管理器&lt;/strong&gt;因此它也算是fastcgi协议的实现。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgi进程/线程&lt;/code&gt;：在php上，就是php-cgi进程/线程。专门用于接收web server的动态请求，&lt;strong&gt;调用并初始化zend虚拟机&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgi脚本&lt;/code&gt;：被执行的php源代码文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zend虚拟机&lt;/code&gt;：对php文件做词法分析、语法分析、编译成opcode，并执行。最后关闭zend虚拟机。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgi进程/线程和zend虚拟机的关系&lt;/code&gt;：cgi进程调用并初始化zend虚拟机的各种环境。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以php-fpm为例，web server从转发动态请求到结束的过程大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171004193620568-1574617626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而每个php-cgi进程的作用大致包括：(有些功能分类错误，请无视，知道大致功能就够了)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171004193753208-1919724771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，尽管php-fpm的全称为PHP FastCGI Process Manager，但严格地讲，php-fpm不是fastcgi的进程管理器，而是php fastcgi即php-cgi的进程管理器。fastcgi只是一种协议，不是进程。就像http协议一样，apache对它的实现是httpd，nginx对它的实现就叫nginx。&lt;/p&gt;
&lt;p&gt;再次说明，cgi和fastcgi是一种协议。各种支持和WEB交互的编程语言对cgi/fastcgi协议都做了各自的实现(当然，任何一种语言都能写cgi脚本)，而php上的php-cgi和php-fpm正是php对fastcgi协议的实现。&lt;/p&gt;


&lt;p&gt;web server对cgi进程/线程来说，它的作用就是发起动态处理请求，传递一些参数和环境变量，最后接收cgi的返回结果。再通俗而不严谨地说，web server通过cgi/fastcgi协议将动态请求转发给执行cgi脚本的应用程序。通过下面httpd.conf中的转发配置应该很容易理解(httpd和php-fpm的交互)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-constant&quot;&gt;ProxyRequests&lt;/span&gt; off
&lt;span class=&quot;hljs-constant&quot;&gt;ProxyPassMatch&lt;/span&gt; ^&lt;span class=&quot;hljs-regexp&quot;&gt;/(.*\.php)$ fcgi:/&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/127.0.0.1:9000/usr&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/local/apache&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/htdocs/&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以最典型的apache httpd和php为例，对于httpd来说，web server和php-cgi有3种交互模式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;cgi模式&lt;/code&gt;：httpd接收到一个动态请求就fork一个cgi进程，cgi进程返回结果给httpd进程后自我销毁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;动态模块模式&lt;/code&gt;：将php-cgi的模块(例如php5_module)编译进httpd。在httpd启动时会加载模块，加载时也将对应的模块激活，php-cgi也就启动了。(注：纠正一个小小错误，很多人以为动态编译的模块是可以在需要的时候随时加载调用，不需要的时候它们就停止了，实际上不是这样的。和静态编译的模块一样，动态加载的模块在被加载时就被加入到激活链表中，无论是否使用它，它都已经运行在apache httpd的内部。可参考LoadModule指令的官方手册)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;php-fpm模式&lt;/code&gt;：使用php-fpm管理php-cgi，此时httpd不再控制php-cgi进程的启动。可以将php-fpm独立运行在非web服务器上，实现所谓的动静分离。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，借助模块mod_fastcgi还可以实现fastcgi模式。同cgi一样，管理模式的先天缺陷决定了这并不是一种好方法。&lt;/p&gt;

&lt;h2 id=&quot;3-1-cgi-&quot;&gt;3.1 CGI模式&lt;/h2&gt;
&lt;p&gt;使用CGI模式时，当动态请求到达，httpd临时启动一个cgi解释器，并通过cgi协议转发要运行的内容。当cgi脚本运行结束后，将结果返回给httpd，然后cgi解释器进程自我销毁。当多个动态请求到达时，将先后启动懂个cgi解释器。因此，这种方法效率极低。&lt;/p&gt;
&lt;p&gt;在注释掉php5_module的LoadModule相关行后，使用action指令指定要使用cgi运行的类型。但注意，action指令是mod_action提供的，所以必须已经加载该模块。&lt;/p&gt;
&lt;p&gt;例如：指定MIME类型为image/gif的请求使用images.cgi运行。显然，images.cgi脚本你必须先写好。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;Action&lt;/span&gt; image/gif /cgi-bin/images.cgi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以通过添加handler来复合文件类型，再使用某个cgi脚本去运行这个handler中的任意类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AddHandler &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt;-file-type .xyz
Action &lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt;-file-type &lt;span class=&quot;hljs-string&quot;&gt;&quot;/cgi-bin/program.cgi&quot;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于php来说，则可以使用安装php时bin目录下提供的php-cgi程序作为cgi程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; php]
pear  peardev  pecl  phar  phar.phar  php  php-cgi  php-config  phpize


[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; php]


Action application/&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;-httpd-php /usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/php/bin/cgi-bin/php-cgi
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;3-2-&quot;&gt;3.2 模块方式&lt;/h2&gt;
&lt;p&gt;在编译php时，将php5_module模块编译到apache中，例如在编译php时在./configure配置中加上&quot;--with-apxs2=/usr/local/apache/bin/apxs&quot;。&lt;/p&gt;
&lt;p&gt;这种交互模式下，httpd在启动时加载并激活php_module。也就是说，php-cgi常驻在httpd进程内部。当动态请求到达时，httpd不用再生成cgi解释器，而是直接将动态请求转发给它内部php-cgi。&lt;/p&gt;
&lt;p&gt;配置实用这种交互模式非常简单，只需使用LoadModule加载php_module，再添加对应的MIME处理器即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;LoadModule&lt;/span&gt;&lt;/span&gt; php5_module modules/libphp5.so


&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;IfModule mime_module&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;AddType&lt;/span&gt; application/x-httpd-php .php
&lt;span class=&quot;hljs-keyword&quot;&gt;AddType&lt;/span&gt; applicaiton/x-httpd-php-source .phps
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/IfModule&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;3-3-php-fpm-&quot;&gt;3.3 php-fpm方式&lt;/h2&gt;
&lt;p&gt;前面说了，php-fpm是php-cgi的进程管理器。这种交互方式实际上是让php-cgi以独立于httpd的方式存在，目前基本使用php-fpm的方式管理php-cgi进程。也就是说，这种模式下，php-cgi和httpd已经分离了，它们的分离意味着请求的动静分离变为可能：httpd和php-fpm分别运行在不同服务器上。动静分离后，压力也分散到各自的服务器上。&lt;/p&gt;
&lt;p&gt;要让php-fpm以这种方式运行，需要在编译的./configure配置选项中添加&quot;--enable-fpm&quot;选项。当然，还得启动php-fpm服务。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service php-fpm &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;start&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样php-cgi进程就开放着端口(默认9000)等待httpd转发动态请求。要让httpd能够转发请求到php-cgi上，需要在httpd.conf中关闭正向代理，并设置fastcgi协议代理参数。例如，转发到192.168.100.54主机上的php-fpm。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&lt;span class=&quot;hljs-constant&quot;&gt;LoadModule&lt;/span&gt; proxy_module modules/mod_proxy.so
&lt;span class=&quot;hljs-constant&quot;&gt;LoadModule&lt;/span&gt; proxy_fcgi_module modules/mod_proxy_fcgi.so


&lt;span class=&quot;hljs-constant&quot;&gt;AddType&lt;/span&gt; application/x-httpd-php .php
&lt;span class=&quot;hljs-constant&quot;&gt;AddType&lt;/span&gt; application/x-httpd-php-source .phps


&lt;span class=&quot;hljs-constant&quot;&gt;ProxyRequests&lt;/span&gt; off
&lt;span class=&quot;hljs-constant&quot;&gt;ProxyPassMatch&lt;/span&gt; ^&lt;span class=&quot;hljs-regexp&quot;&gt;/(.*\.php)$ fcgi:/&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/192.168.100.54:9000/usr&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/local/apache&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/htdocs/&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7627035.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/7627035.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/h3&gt;
</description>
<pubDate>Wed, 04 Oct 2017 11:50:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/7627035.html</dc:identifier>
</item>
<item>
<title>使用docker部署standalone cinder - 孤独的居士</title>
<link>http://www.cnblogs.com/sting2me/p/7625776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sting2me/p/7625776.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;| &lt;/span&gt;&lt;/strong&gt;版权：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接。如有问题，可以邮件：wangxu198709@gmail.com&lt;/p&gt;

&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;OpenStack社区一直在尝试用Container技术来部署其各个组件，由此还发展出了kolla这个big tent项目，以及衍生项目kolla-ansible。&lt;/p&gt;
&lt;p&gt;最近项目上有些调整，有了些自由时间，于是开始尝试使用container方式部署OpenStack的组件，自然是从最熟悉的Cinder开始。&lt;/p&gt;
&lt;p&gt;惊喜的发现Cinder项目自身就有一个简单易上手的脚步，可以帮助理解以container部署Cinder的基本步骤和方式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; [请在ROOT用户下执行下面所有的命令，主要是docker和后面的local-attach都需要root或者sudo，直接使用root会少掉很多坑]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;配置环境&lt;/h2&gt;
&lt;h3&gt;首先clone下来cinder的源代码：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/openstack/cinder&lt;/span&gt;
&lt;span&gt;
cd contrib&lt;/span&gt;/block-box/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就是安装相关的依赖了，如make, docker，docker-compose&lt;/p&gt;
&lt;h3&gt;安装make及相关包&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; build-essential
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;安装docker&lt;/h3&gt;
&lt;p&gt;https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-16-04&lt;/p&gt;
&lt;h3&gt;安装docker-compose&lt;/h3&gt;
&lt;p&gt;https://www.digitalocean.com/community/tutorials/how-to-install-docker-compose-on-ubuntu-16-04&lt;/p&gt;
&lt;p&gt;接下来就是build需要的docker image了&lt;/p&gt;

&lt;p&gt;这个过程中，会clone loci-cinder项目，如果遇到不能clone这个项目，你可以把loci-cinder项目clone到本地，然后修改目录下的Makefile, 指向本地的loci-cinder就行。我就遇到这种问题，于是我做了如下修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
# git &lt;span&gt;diff&lt;/span&gt;&lt;span&gt; Makefile
&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; --git a/contrib/block-box/Makefile b/contrib/block-box/&lt;span&gt;Makefile
index ca173cc..ff60a56 &lt;/span&gt;&lt;span&gt;100644&lt;/span&gt;
--- a/contrib/block-box/&lt;span&gt;Makefile
&lt;/span&gt;+++ b/contrib/block-box/&lt;span&gt;Makefile
@@ &lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt; +&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;&lt;span&gt; @@
 CINDER_BRANCH &lt;/span&gt;?= master # master, stable/ocata, refs/changes/&lt;span&gt;67&lt;/span&gt;/&lt;span&gt;418167&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
 NAME_PREFIX &lt;/span&gt;?= &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;-PLATFORM ?= debian # ubuntu, centos
&lt;/span&gt;&lt;span&gt;+PLATFORM ?=&lt;/span&gt;&lt;span&gt;&lt;span&gt; ubuntu # debian, centos
&lt;/span&gt; TAG &lt;/span&gt;?=&lt;span&gt; latest
 
 all: base lvm devbox
 
 base:
&lt;/span&gt;&lt;span&gt;-       docker build https://git.openstack.org/openstack/loci-cinder.git\#:$(PLATFORM) --tag cinder:$(TAG) --build-arg PROJECT_REF=$(CINDER_BRANCH)
&lt;/span&gt;&lt;span&gt;+       docker build /root/containerized/loci-cinder/$(PLATFORM) --tag cinder:$(TAG) --build-arg PROJECT_REF=&lt;/span&gt;&lt;span&gt;&lt;span&gt;$(CINDER_BRANCH)
&lt;/span&gt; 
 lvm:
        docker build &lt;/span&gt;-t cinder-lvm -f ./docker_files/Dockerfile.cinder-lvm .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Docker 的image build好过后，马上就可以使用docker-compose命令启动cinder的相关service了。&lt;/p&gt;
&lt;h2&gt;启动docker的相关service&lt;/h2&gt;
&lt;p&gt;启动之前你要按照自己的需求，修改目录下的&lt;strong&gt;etc-cinder/cinder.conf&lt;/strong&gt; 和 &lt;strong&gt;docker-compose.yml&lt;/strong&gt;文件，你可以参考我的gist文件 &lt;a title=&quot;cinder conf for docker&quot; href=&quot;https://gist.github.com/peter-wangxu/7c310888c9c78694efb91bb2cfd2ca69&quot; target=&quot;_blank&quot;&gt;cinder.conf&lt;/a&gt; 和 &lt;a title=&quot;docker-compose.yml for docker&quot; href=&quot;https://gist.github.com/peter-wangxu/f5bcbf6f904ef9706d604e571a8693d2&quot; target=&quot;_blank&quot;&gt;docker-compose.yml&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;p&gt;docker-compose -f docker-compose.yml up -d&lt;/p&gt;
&lt;p&gt;docker-compose up -d&lt;br/&gt;Creating network &quot;blockbox_cindernet&quot; with driver &quot;bridge&quot;&lt;br/&gt;Creating blockbox_mariadb_1 ...&lt;br/&gt;Creating blockbox_rabbitmq_1 ...&lt;br/&gt;Creating blockbox_mariadb_1&lt;br/&gt;Creating blockbox_mariadb_1 ... done&lt;br/&gt;Creating blockbox_rabbitmq_1 ... done&lt;br/&gt;Creating blockbox_cinder-api_1 ... done&lt;br/&gt;Creating blockbox_cinder-scheduler_1 ...&lt;br/&gt;Creating blockbox_cinder-scheduler_1 ... done&lt;br/&gt;Creating blockbox_cinder-volume_1 ...&lt;br/&gt;Creating blockbox_cinder-volume_1 ... done&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;启动后，查看启动的container，发现cinder-api服务启动后又退出了。&lt;/p&gt;

&lt;p&gt;最后发现，cinder api的相关code有变动，需要在 当前目录(contrib/block-box)的 etc-cinder/cinder.conf，加入下面&lt;span&gt;绿色&lt;/span&gt;内容，cinder-api才能启动成功，不让会因为找不到key manager而退出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[database]
&lt;span&gt;connection = mysql+pymysql://cinder:password@mariadb/cinder?charset=utf8
&lt;/span&gt;&lt;span&gt;[key_manager]
backend = cinder.keymgr.conf_key_mgr.ConfKeyManager&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更改后，重新启动所有docker containers&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker-compose -f docker-&lt;span&gt;compose.yml down
docker&lt;/span&gt;-compose -f docker-compose.yml up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等一段时间，重新检查所有的docker containers&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
docker &lt;span&gt;ps&lt;/span&gt;&lt;span&gt;
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                   NAMES
67180a6e8056        cinder              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bash -c 'pip inst...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;38&lt;/span&gt; seconds ago      Up &lt;span&gt;37&lt;/span&gt; seconds                                                               blockbox_cinder-&lt;span&gt;volume_1
d963f200be2a        cinder              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cinder-scheduler&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;       &lt;span&gt;39&lt;/span&gt; seconds ago      Up &lt;span&gt;38&lt;/span&gt; seconds                                                               blockbox_cinder-&lt;span&gt;scheduler_1
5166d688bbbd        cinder              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sh /init-scripts/...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;39&lt;/span&gt; seconds ago      Up &lt;span&gt;38&lt;/span&gt; seconds                                                               blockbox_cinder-&lt;span&gt;api_1
a14757b40830        mariadb             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;docker-entrypoint...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;40&lt;/span&gt; seconds ago      Up &lt;span&gt;38&lt;/span&gt; seconds       &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;3306&lt;/span&gt;-&amp;gt;&lt;span&gt;3306&lt;/span&gt;/&lt;span&gt;tcp                                  blockbox_mariadb_1
b23d77e10bad        rabbitmq            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;docker-entrypoint...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;40&lt;/span&gt; seconds ago      Up &lt;span&gt;38&lt;/span&gt; seconds       &lt;span&gt;4369&lt;/span&gt;/tcp, &lt;span&gt;5671&lt;/span&gt;/tcp, &lt;span&gt;25672&lt;/span&gt;/tcp, &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;5672&lt;/span&gt;-&amp;gt;&lt;span&gt;5672&lt;/span&gt;/tcp   blockbox_rabbitmq_1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有服务都启动成功，后面使用cinder client请求cinder volume&lt;/p&gt;
&lt;p&gt;TIPS: 可以使用下面命令查看docker里面的log。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker logs &amp;lt;container &lt;span&gt;id&lt;/span&gt;&amp;gt; -f 
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;使用cinder volume&lt;/h2&gt;
&lt;h3&gt;安装cinder client&lt;/h3&gt;
&lt;p&gt;接下来，在host上新建virtual environment并在venv中安装最新的cinder client（只有最新的cinder client才有对noauth这种认证方式的支持）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 创建venv
virtualenv pyenv

. pyenv&lt;/span&gt;/bin/&lt;span&gt;activate
git clone https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/openstack/python-cinderclient&lt;/span&gt;
pip &lt;span&gt;install&lt;/span&gt; -e python-cinderclient
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接请求请求cinder api&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
(pyenv) peter@ubuntu16:~/pyenv$ cinder --os-auth-type=noauth --os-endpoint=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:8776/v3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --os-user-&lt;span&gt;id&lt;/span&gt;=admin --os-tenant-&lt;span&gt;id&lt;/span&gt;=&lt;span&gt;admin list
&lt;/span&gt;+--------------------------------------+-----------+--------+------+-------------+----------+-------------+
| ID                                   | Status    | Name   | Size | Volume Type | Bootable | Attached to |
+--------------------------------------+-----------+--------+------+-------------+----------+-------------+
| 0fefa93d-475e-4cde-&lt;span&gt;9246&lt;/span&gt;-cc5666fde991 | available | peter1 | &lt;span&gt;10&lt;/span&gt;   | -           | &lt;span&gt;false&lt;/span&gt;    |             |
+--------------------------------------+-----------+--------+------+-------------+----------+-------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意上面使用了--os-auth-type-noauth,这就是让它直接请求cinder api，而不是先到keystone去认证。使用--os-endpoint=127.0.0.1:8776/v3是因为cinder-api同时暴露在了host上的这个端口上。&lt;/p&gt;
&lt;p&gt;这样，就可以使用很多cinder的命令，比如cinder create，list，snapshot-create等等，相关的storage就可以被这个standalone的cinder来管理了。&lt;/p&gt;

&lt;h3&gt;使用local-attach&lt;/h3&gt;
&lt;p&gt;volume创建好后，这里不能给到VM直接使用，因为没有nova:)。尴尬，难道volume就不能给host用了吗？当然可以。opestack社区提供了一个cinder client的plugin，让volume可以直接attach给一个host&lt;/p&gt;

&lt;p&gt;安装python-brick-cinderclient-ext&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/openstack/python-brick-cinderclient-ext&lt;/span&gt;
pip &lt;span&gt;install&lt;/span&gt; -e python-brick-cinderclient-ext/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我把刚才创建的volume暴露给host使用（记得在host上安装open-iscsi包）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cinder --os-auth-type=noauth --os-endpoint=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:8776/v3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --os-user-&lt;span&gt;id&lt;/span&gt;=admin --os-tenant-&lt;span&gt;id&lt;/span&gt;=admin local-attach 0fefa93d-475e-4cde-&lt;span&gt;9246&lt;/span&gt;-cc5666fde991
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，要保证--os-user-id和--os-tenant-id使用与create volume一样的参数，否则会出现NotVolumeFound类似的error&lt;/p&gt;

&lt;h2&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;https://thenewstack.io/deploying-cinder-stand-alone-storage-service/&lt;/p&gt;
&lt;p&gt;https://gorka.eguileor.com/standalone-cinder/&lt;/p&gt;
</description>
<pubDate>Wed, 04 Oct 2017 11:21:00 +0000</pubDate>
<dc:creator>孤独的居士</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sting2me/p/7625776.html</dc:identifier>
</item>
<item>
<title>如何使用windows版Docker并在IntelliJ IDEA使用Docker运行Spring Cloud项目 - 嘿123</title>
<link>http://www.cnblogs.com/hei12138/p/ideausedocker.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hei12138/p/ideausedocker.html</guid>
<description>

&lt;h2&gt;#1：前提准备&lt;/h2&gt;
&lt;p&gt;　　1.1 首先请确认你的电脑是windows10专业版或企业版，只有这只有这两个版本才带有hyper-v&lt;/p&gt;
&lt;h2&gt;#2：介绍&lt;/h2&gt;
&lt;p&gt;　　以往我们如果想要在windows上使用docker，都是使用virual box来创建虚拟机，自从windows10发布以来，微软宣布了一系列的linux软件登陆windows，其中就包括了docker，现在我们可以使用windows自带的hyper-v虚拟机来创建运行docker服务。&lt;/p&gt;
&lt;p&gt;　　InteliiJ Idea作为目前最实用的IDE对Docker也提供了支持。&lt;/p&gt;
&lt;h2&gt;#3：安装Docker for windows&lt;/h2&gt;
&lt;p&gt;　　3.1 从官网下载docker for windows，https://store.docker.com/editions/community/docker-ce-desktop-windows，下载完毕后进入安装界面,docker会自动安装，界面一闪而过，电脑运行速度还不错，安装完成之后，docker会弹个窗告诉你hyper-v未开启，像这样。&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915101354438-566977396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不过如果你现在点击OK基本上是没有用的，得先去BIOS里打开硬件虚拟化，本机是惠普的机器，开启点按f10进入bios，其他品牌的机器自行搜索进入，像这样&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915102029407-479666203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重启电脑后docker会自动运行，依然弹出上面那个hyper-v未开启的窗口，这回可以点击OK让docker来帮你开启hyper-v，或者是自己在控制面板-程序-程序和功能-启用或关闭windows功能里开启hyper-v&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915102317860-1492440511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，我们的docker for windows已经安装完成。在命令行中输入docker --version可以查看已经安装的docker版本&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915102525047-1664902951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.2 使用docker中的镜像 &lt;/p&gt;
&lt;p&gt;　　　　3.2.1  先用官方镜像作个示例 &lt;/p&gt;
&lt;p&gt;　　　　　　使用 docker search &amp;lt;imageName&amp;gt; 来搜索对应的镜像 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915103256860-698319588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后使用 docker pull &amp;lt;镜像名:tag&amp;gt; 例如docker pull nginx:latest  ,tag不输入是默认拉取最新的　&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201709/760273-20170915111606313-812271906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当镜像下载玩之后我们通过docker images命令来查看所有本地的镜像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004161120521-390528689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里下载了java以及nginx的镜像 其中还有我已经打包好的spring cloud的eureka注册中心的镜像&lt;/p&gt;
&lt;p&gt;使用docker run命令来运行镜像，我这里运行nginx的镜像&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004161757849-323512683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用docker运行nginx成功后访问localhost:80就可以访问到nginx的主页，说明我们已经在docker运行了我们的第一个镜像，虽然是官方镜像，但心里的成就感还是不低的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004161918224-949237030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好的，在运行了第一个镜像之后，我们要开始在IntelliJ IDEA中使用docker并构建我们的第一个spring boot程序放到docker中去运行&lt;/p&gt;
&lt;h2&gt;#4:IDEA的准备工作&lt;/h2&gt;
&lt;p&gt;1：Docker插件，首先需要在你的IDEA中安装Docker插件，定位到File-Setting-Plugins后搜索Docker Integration安装。&lt;/p&gt;
&lt;p&gt;2：配置Docker服务器，在IDEA中定位到File-Setting-build,Execution,Deployment-Docker&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004162612380-651440164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你没用使用Docker Machine来管理虚拟机的需求的话,我们使用默认的Docker守护进程就OK了，不过在此之前我们还需要设置一下docker&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004163101646-304599227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004163227693-1287318838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;将docker与本地的连接设置为不需要TLS加密。&lt;/p&gt;
&lt;p&gt;在完成这一步之后，可以在IDEA的配置窗口看到成功连接到了本机上的docker&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004163401349-1138898720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们已经完成对docker的配置，接下来就可以进入真正的实施阶段。&lt;/p&gt;
&lt;h2&gt;#5：创建spring cloud项目&lt;/h2&gt;
&lt;p&gt;　1.首先在Idea中创建一个spring boot项目，怎么创建在此就不再赘述了&lt;/p&gt;
&lt;p&gt;创建完成之后，我们在pom.xml中添加依赖项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004164149615-518635213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本地编写的是spring cloud的注册中心项目，所以还需要加上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004164229130-1305494229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;spring的版本需要与spring cloud的版本号对应，详细的对应信息可以去http://projects.spring.io/spring-cloud/查看&lt;/p&gt;
&lt;p&gt; 由于本次只是简单地示范如何在IDEA中部署spring boot项目到docker中，所以在项目中只需要对eureka注册中心进行简单的配置就OK了，&lt;/p&gt;
&lt;p&gt;在启动类中加上注解标明这是一个eureka注册中心的项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004164846411-1118389797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在配置文件中配置端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004164935552-726189701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们就完成了项目的编写，可以先启动看看项目是否能够启动，启动之后我们访问http://localhost:8761/ ,可以看到我们的eureka注册中心已经启动，项目编写没有问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004165126458-522792399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就到了如何把项目部署到docker中去的问题了&lt;/p&gt;
&lt;h2&gt;#6：将项目部署到Docker中&lt;/h2&gt;
&lt;p&gt;首先我们需要编写Dockerfile文件，在src-main目录下新建docker文件夹，然后在其中新建Dockerfile文件&lt;/p&gt;
&lt;p&gt;文件内容如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004165945568-635777686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其中红框的地方是本项目打包之后的jar包名字，默认是artifactId-version.jar,同时我们可以看到在左上叫有个运行的标记，很对，这个就是用来在IDEA构建jar包到镜像，然后放到Docker中运行的按钮,不过我们还是需要先配置一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004170030661-1071842763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先配置镜像名称以及容器名称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004170451161-1746553335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后需要对docker容器需要映射的端口号进行配置&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004170919865-309353323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们点击run,可以看到，很快就报错了，这是由于DockerFile与我们生成的jar包不在同一个文件夹造成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004170956443-919319526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我找到了两种方案：&lt;/p&gt;
&lt;h3&gt;方案1：先使用maven命令&lt;/h3&gt;
&lt;p&gt;mvn clean package&lt;/p&gt;
&lt;p&gt;对项目进行打包，命令执行完毕之后可以在target目录下看到已经打包完成的jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004171402661-1703226286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后把jar包放到Dockerfile所在的目录下，像这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004171506083-1084820071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后接着点击Dockerfile中的运行，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004171701443-1614590011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Deploylog窗口中，可以看到，这次构建镜像就成功了,在log窗口中可以看到我们的项目在运行过程中打出的日志信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004171747630-37221645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显，这次的构建和部署都成功了,访问http://localhost:8761/，出现了我们想要看到的东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004180412958-215432444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在命令行中使用docker ps 命令查看正在运行的容器信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004172007802-837286534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们在IDEA中编写的项目已经运行到了docker中。&lt;/p&gt;
&lt;h3&gt;方案2：使用docker-maven-plugin插件，在pom.xml中配置插件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004174136458-2020532391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在ternimal中运行 mvn clean package -DskipTests=true docker:build命令，打包项目并构建镜像，命令执行完毕可以看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004174311646-167541329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在docker窗口下，我们构建的镜像已经出现在窗口中了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004174411740-825246592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右键点击创建一个新的容器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004174538802-73797904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跳转到我们的部署配置里面，只需要像方案1中的一样进行配置完毕后点击run就OK了,访问http://localhost:8761/，同样可以看到我们的eureka的运行信息。docker ps 命令也显示我们的容器已经运行起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/760273/201710/760273-20171004175255521-1104190253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;#7：总结&lt;/h2&gt;
&lt;p&gt;好的，到这里我们先是在安装了windows版的docker,然后使用IDEA创建了一个spring cloud项目，并在IDEA中将此项目部署到了docker中，本次随笔就到此为止了。&lt;/p&gt;
&lt;p&gt;如果你对本篇博客有兴趣的话，欢迎共同交流和讨论&lt;/p&gt;
&lt;p&gt;有任何问题请联系hei12138@outlook,com&lt;/p&gt;
</description>
<pubDate>Wed, 04 Oct 2017 10:07:00 +0000</pubDate>
<dc:creator>嘿123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hei12138/p/ideausedocker.html</dc:identifier>
</item>
<item>
<title>深入理解计算机系统（3.6）------汇编的流程控制 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/7593368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/7593368.html</guid>
<description>&lt;p&gt;　　前面我们所讲的所有指令，代码执行顺序都是一条接着一条顺序的执行。但是实际上在编码过程中，会有某些结构，比如条件语句（if-else），循环语句（for,do-while）和分支语句（switch）等等，都要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。&lt;/p&gt;
&lt;p&gt;　　在机器代码中，提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。&lt;/p&gt;
&lt;p&gt;　　那么本篇博客我们就来详细介绍在汇编语言中的流程控制。&lt;/p&gt;

&lt;h3&gt;1、条件码&lt;/h3&gt;
&lt;p&gt;　　前面我们在 &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/ysocean/p/7593362.html&quot;&gt;操作数指示符和数据传送指令&lt;/a&gt; 中介绍了整数寄存器，在 32位 CPU 中包含一组 8 个存储 32 位值的寄存器，即整数寄存器。它可以存储一些地址或者整数的数据，有的用来记录某些重要的程序状态，有的则用来保存临时数据。&lt;/p&gt;
&lt;p&gt;　　而这里我们要介绍的是条件码（condition code）寄存器。它与整数寄存器不同，它是由单个位组成的寄存器，也就是它们当中的值只能为 0 或者 1。当有算术与逻辑操作发生时，这些条件码寄存器当中的值会相应的发生变化。&lt;/p&gt;
&lt;p&gt;　　也就是说可以检测这些寄存器来执行条件分支指令。常用的条件码如下：&lt;/p&gt;
&lt;p&gt;　　①、CF：进位标志寄存器。最近的操作是最高位产生了进位。它可以记录无符号操作的溢出，当溢出时会被设为1。&lt;/p&gt;
&lt;p&gt;　　②、ZF：零标志寄存器，最近的操作得出的结果为0。当计算结果为0时将会被设为1。&lt;/p&gt;
&lt;p&gt;　　③、SF：符号标志寄存器，最近的操作得到的结果为负数。当计算结果为负数时会被设为1。&lt;/p&gt;
&lt;p&gt;　　④、OF：溢出标志寄存器，最近的操作导致一个补码溢出（正溢出或负溢出）。当计算结果导致了补码溢出时，会被设为1。&lt;/p&gt;
&lt;p&gt;　　从上面可以看出，CF和OF可以判断有符号和补码的溢出，ZF判断结果是否为0，SF判断结果的符号。这是底层机器的设定，而我们所编程用的高级语言（比如C，Java）就是靠这四个寄存器，演化出各种各样的流程控制。&lt;/p&gt;

&lt;h3&gt;2、设置条件码&lt;/h3&gt;
&lt;p&gt;　　通常情况下，条件码寄存器的值无法主动被改变，它们大多时候是被动改变，这算是条件码寄存器的特色。这其实理解起来并不困难，因为条件码寄存器是1位的，而我们的数据格式最低为b，也就是8位，因此你无法使用任何数据传送指令去传送一个单个位的值。&lt;/p&gt;
&lt;p&gt;　　几乎所有的算术与逻辑指令都会改变条件码寄存器的值，不过改变的前提是触发了条件码寄存器的条件。比如对于subl %edx,%eax这个减法指令，假设%edx和%eax寄存器的值都为0x10，则两者相减的结果为0，此时ZF寄存器将会被自动设为1。对于其它的指令运算，都是类似的，会根据结果的不同而设置不同的条件码寄存器。&lt;/p&gt;
&lt;p&gt;　　这里我们需要说明的是，leal 指令作为地址计算的时候，是不改变任何条件码的。&lt;/p&gt;
&lt;p&gt;　　前面我们所讲的算术逻辑指令，在改变整数寄存器的值后，会根据结果设置不同的条件码。而这里还有另外两种指令，它们只设置条件码，而不改变任何其他寄存器的值。如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004111725599-1349960030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　①、CMP 指令，指令形式 CMP S2，S1。然后会根据 S1-S2 的差来设置条件码。除了只设置条件码而不更新目标寄存器外，CMP 指令和 SUB 指令的行为是一样的。比如两个操作数相等，那么之差为0，那么就会将零标志设置为 1；其他的标志也可以用来确定两个数的大小关系。&lt;/p&gt;
&lt;p&gt;　　②、TEST 指令，和 AND 指令一样，除了TEST指令只设置条件码而不改变目的寄存器的值。比如对于如下指令：&lt;/p&gt;
&lt;p&gt;　　　　MOV AL,40H&lt;/p&gt;
&lt;p&gt;　　　　TESTB AL,08H&lt;/p&gt;
&lt;p&gt;　　　　上面的指令就是用来测试 AL 寄存器的左起第四位是否为0，结果就是 0100 0000（40H）&amp;amp; 0000 1000（08H），测试结果左起第4位是0，所以各个标志位：CF=0,OF=0,SF=0,ZF=1&lt;/p&gt;

&lt;h3&gt;3、访问条件码&lt;/h3&gt;
&lt;p&gt;　　对于普通寄存器来讲，使用的时候一般是直接读取它的值，而对于条件码，通常不会直接读取。常用的有如下三种方法：&lt;/p&gt;
&lt;p&gt;　　①、可以根据条件码寄存器的某个组合，将一个字节设置为0或1。&lt;/p&gt;
&lt;p&gt;　　②、可以直接条件跳转到程序的某个其它的部分。&lt;/p&gt;
&lt;p&gt;　　③、可以有条件的传送数据。&lt;/p&gt;
&lt;p&gt;　　对于第一种情况，下图描述的指令便是根据条件码的某个组合，将一个字节设置为0或1，这一整类指令称为 SET 指令，它们的区别就在与它们考虑的条件码的组合是什么，这些指令名字的不同后缀指明了它们所考虑的条件码的组合。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意：这些指令的后缀表示不同的条件而不是操作数的大小。比如指令 setl 和 setb 表示 “小于时设置（set less）”和“低于时设置（set below）”，而不是“设置长字（set long word）”和“设置字节（set byte）”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004115643880-1175035796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;上图所说的同义名，比如说setg（表示“设置大于”）和 setnle（表示“不小于等于”）指的就是同一条机器指令，编译器和反编译器会随意决定使用哪个名字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　还有set指令中的目的操作数，只能是前面我们所讲的8个单字节的寄存器或者是存储一个字节的存储器位置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下面我们分别对 set 指令出现的后缀做简单介绍：&lt;/p&gt;
&lt;p&gt;　　①、e-&amp;gt;ZF（相等）:equals的意思，这里代表的组合是ZF，因为ZF在结果为0时设为1。因此ZF代表的意义是相等。&lt;/p&gt;
&lt;p&gt;　　②、ne-&amp;gt;~ZF（不相等）:not equals 的意思，这里代表的组合是~ZF，也就是ZF做“非运算”，则很明显是不相等的意思。&lt;/p&gt;
&lt;p&gt;　　③、s-&amp;gt;SF（负数）：这里代表的组合是SF，因为SF在计算结果为负数时设为1，此时可以认为b为0，即a&amp;lt;0。因此这里是负数的意思。&lt;/p&gt;
&lt;p&gt;　　④、ns-&amp;gt;~SF（非负数）：与s相反，加上n则是not的意思，因此这里代表非负数。&lt;/p&gt;
&lt;p&gt;　　⑤、l-&amp;gt;SF^OF（有符号的小于）：l代表的是less。这里的组合是SF^OF，即对SF和OF做“异或运算”。“异或运算”的意思则是代表，SF和OF不能相等。那么有两种情况，当OF为0时，则代表没有溢出，此时SF必须为1，SF为1则代表结果为负。即a-b&amp;lt;0，也就是a&amp;lt;b，也就是小于的意思。当OF为1时，则代表产生了溢出，而此时SF必须为0，也就是说结果最后为正数，那么此时则是负溢出，也可以得到a-b&amp;lt;0，即a&amp;lt;b。综合前面两种情况，SF^OF则代表小于的意思。&lt;/p&gt;
&lt;p&gt;　　⑥、le-&amp;gt;(SF^OF)|ZF（有符号的小于等于）：le是less equals的意思。有了前面小于的基础，这里就很容易理解了。SF^OF代表小于，ZF代表等于，因此两者的“或运算”则代表小于等于。&lt;/p&gt;
&lt;p&gt;　　⑦、g-&amp;gt;~(SF^OF)&amp;amp;~ZF（有符号的大于）：g是greater的意思。这里的组合是~(SF^OF)&amp;amp;~ZF，相对来说就比较复杂了。不过有了前面的铺垫，这个也非常好理解。SF^OF代表小于，则~(SF^OF)代表大于等于，而~ZF代表不等于，将~(SF^OF)与~ZF取“与运算”，则代表大于等于且不等于，也就是大于。&lt;/p&gt;
&lt;p&gt;　　⑧、ge-&amp;gt;~(SF^OF)（有符号的大于等于）：ge是greater equals的意思。&lt;/p&gt;
&lt;p&gt;　　⑨、b-&amp;gt;CF（无符号的小于）：b是below的意思。CF是无符号溢出标志，这里的意思是指如果a-b结果溢出了，则代表a是小于b的，即a&amp;lt;b。其实这个结论很显然，关键点就在于，无符号减法只有在减出负数的时候才可能溢出，也就是说只要结果溢出了，那么一定有a-b&amp;lt;0。因此这个结论就显而易见了。&lt;/p&gt;
&lt;p&gt;　　⑩、be-&amp;gt;CF|ZF（无符号的小于等于）：这里是below equals的意思。因此这里会与ZF计算“或运算”，字面上也很容易理解，即CF（小于）|（或）ZF（等于），也就是小于等于。&lt;/p&gt;
&lt;p&gt;　　⑪、a-&amp;gt;~CF&amp;amp;~ZF（无符号的大于）：a代表的是above。这个组合也是非常好理解的，CF代表小于，则~CF代表大于等于，~ZF代表不等于，因此~CF&amp;amp;~ZF则代表大于等于且不等于，即大于。&lt;/p&gt;
&lt;p&gt;　　⑫、ae-&amp;gt;~CF（无符号的大于等于）：ae是above equals的意思。&lt;/p&gt;
&lt;p&gt;　　比如对于setae %al指令来说，%al是%eax寄存器中的最后一个字节，这个指令的含义是，将~CF的值设置到%eax寄存器的最后一个字节。&lt;/p&gt;

&lt;h3&gt;4、跳转指令 jump&lt;/h3&gt;
&lt;p&gt;　　正常情况下，指令会按照他们出现的顺序一条一条地执行。而跳转指令（jump）会导致执行切换到程序中一个全新的位置，我们可以理解为方法或者函数的调用。在汇编代码中，这些跳转的目的地通常用一个标号（label）指明。比如如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    movl $0,%eax
    jmpl  .L1
    movl (%eax),%edx
.L1:
    popl %edx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　指令 jmpl .L1 会导致程序跳过 movl 指令，从 popl 开始执行。在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的地址）编码为跳转指令的一部分。&lt;/p&gt;
&lt;p&gt;　　如下图所示，jump 指令有三种跳转方式：&lt;/p&gt;
&lt;p&gt;　　①直接跳转：跳转目标是作为指令的一部分编码的，比如上面的直接给一个标号作为跳转目标&lt;/p&gt;
&lt;p&gt;　　②间接跳转：跳转目标是从寄存器或者存储器位置中读出的，比如 jmp *%eax 表示用寄存器 %eax 中的值作为跳转目标；再比如 jmp *(%eax) 以 %eax 中的值作为读地址，从存储器中读取跳转目标。&lt;/p&gt;
&lt;p&gt;　　③其他条件跳转：根据条件码的某个组合，或者跳转，或者继续执行代码序列中的下一条指令。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004155623161-873652680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　比如对于如下代码：文件名为 hello.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int exchange(int x,int y)
{
        if(x &amp;lt; y){
                return y-x;
        }else{
                return x-y;
        }
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们执行如下命令，将C程序hello.c变为汇编程序 hello.s&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
gcc -O0 -S hello.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　-O0是优化选项，还有O0 --&amp;gt;&amp;gt; O1 --&amp;gt;&amp;gt; O2 --&amp;gt;&amp;gt; O3，分别是从没有优化到优化级别最高。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004171357333-1793876232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　相信看了前面几篇博客的相关指令介绍，这个汇编代码不难理解。x,y分别存放于栈顶地址偏移量为-4和-8的位置，然后比较x-y的值，也就是指令 cmpl -8(%rbp),%eax，如果x大于或等于y,那么跳转到 .L2 的位置，然后计算 subl %eax,%ecx 的值，即x-y。&lt;/p&gt;
&lt;p&gt;　　我们还可以通过如下命令生成目标文件 hello.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
gcc -O0 -c hello.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后通过如下命令查看反汇编代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
objdump -d hello.o
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004173456396-819661583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5、循环 &lt;/h3&gt;
&lt;p&gt;　　C 语言提供了多种循环结构，比如 do-while、while和for。汇编中没有相应的指令存在，我们可以用条件测试和跳转指令组合起来实现循环的效果。而大多数汇编器会根据一个循环的do-while 循环形式来产生循环代码，即其他的循环一般也会先转换成 do-while 形式，然后在编译成机器代码。&lt;/p&gt;
&lt;p&gt;　　比如如下 do-while 循环：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004174324755-885008959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面的汇编代码就不做过多的介绍了，应该很容易看明白。&lt;/p&gt;

&lt;h3&gt;6、条件传送指令 cmov&lt;/h3&gt;
&lt;p&gt;　　条件传送指令。顾名思义，条件传送指令的意思就是在满足条件的时候进行传送的指令，也就是cmov指令。它与set指令十分相似，同样有12种，也就是加上12种条件码寄存器的组合即可，如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004174749599-2077484997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　条件传送指令相当于一个if/else的赋值判断，一般情况下，条件传送指令的性能高于if/else的赋值判断。但是因为条件传送指令将对两个表达式都求值，因此如果两个表达式计算量很大时，那么条件传送指令的性能就可能不如if/else的分支判断了。不过总的来说，这种情况还是很少的，因此条件传送指令还是很有用的，只是并不是所有的处理器都支持条件传送指令，这依赖于处理器以及编译器的编译方式。&lt;/p&gt;
&lt;p&gt;　　条件传送指令最大的缺点便是可能引起意料之外的错误，比如对于下面这一段代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int cread(int *xp){
    return (xp ? *xp : 0);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　咋一看，这一段代码是没问题的，不过如果使用条件传送指令去实现这段代码的话，将可能引起空指针引用的错误。因为条件传送指令会先对两个表达式进行计算，也就是说无论xp是否有值，都将计算*xp这个表达式，因此当xp为空指针0时，则会产生错误。由此可见，条件传送指令也不是哪都能用的，通常情况下，编译器会帮我们尽力处理这种错误。&lt;/p&gt;

</description>
<pubDate>Wed, 04 Oct 2017 10:02:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/7593368.html</dc:identifier>
</item>
<item>
<title>TeamFlowy——结合Teambition与Workflowy提高生产力 - 青南</title>
<link>http://www.cnblogs.com/xieqiankun/p/teamflowy.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieqiankun/p/teamflowy.html</guid>
<description>&lt;p&gt;Teambition是一个跨平台的团队协作和项目管理工具，相当于国外的Trello。使用Teambition可以像使用白板与便签纸一样来管理项目进度，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-45-13.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Teambition虽然便于管理项目，但是如果直接在Teambition上面创建一个项目对应的任务，却容易陷入面对茫茫白板，不知道如何拆分任务的尴尬境地。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-47-38.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面对这个空荡荡的窗口，应该添加哪些任务进去？直接用脑子现想，恐怕容易出现顾此失彼或者干脆漏掉了任务的情况。&lt;/p&gt;
&lt;p&gt;当我要开始一个项目的时候，我一般不会直接打开Teambition就写任务，而是使用一个大纲工具——Workflowy来梳理思路，切分任务。等任务已经切分好了，在誊写到Teambition中，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-53-06.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但这样就出现了一个问题：首先在Workflowy上面把需要做的任务写好。然后再打开Teambition，把这些任务又誊写到Teambition中。为了减少“誊写”这一步重复劳动，于是就有了TeamFlowy这个小工具。它的作用是自动誊写Workflowy中的特定条目到Teambition中。&lt;/p&gt;
&lt;h2 id=&quot;功能介绍&quot;&gt;功能介绍&lt;/h2&gt;
&lt;p&gt;TeamFlowy是一个Python脚本，运行以后，它会登录Workflowy账号，读取上面所有的条目。名为[Teambition]的条目是任务开始的标记，这个条目下面的一级条目会作为任务被添加到Teambition中。如果任务下面还有二级条目，这些二级条目会作为子任务被添加到任务中。由于Teambition是按照项目-Stage-任务-子任务的形式组织一个工程（其中Stage对应了Teambition中工程下面的面板，例如：“待处理”，“进行中”，“完成”。）不会存在子任务的子任务，所以Workflowy中[Teambition]这个条目下面最多出现二级缩进。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-28-13.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;实现原理&lt;/h2&gt;
&lt;h3 id=&quot;workflowy&quot;&gt;Workflowy&lt;/h3&gt;
&lt;p&gt;获取Workflowy上面的条目，需要进行三步操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;登录Workflowy&lt;/li&gt;
&lt;li&gt;获取所有条目对应的JSON字符串&lt;/li&gt;
&lt;li&gt;提取需要添加到Teambition中的条目&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;登录workflowy&quot;&gt;登录Workflowy&lt;/h4&gt;
&lt;p&gt;打开Chrome监控登录Wokrflowy的过程，可以看到登录Workflowy需要访问的接口为：&lt;code&gt;https://workflowy.com/accounts/login/&lt;/code&gt;。使用HTTP &lt;code&gt;POST&lt;/code&gt;方式发送请求，提交的数据包括&lt;code&gt;username&lt;/code&gt;，&lt;code&gt;password&lt;/code&gt;和一个不知道用途的&lt;code&gt;next&lt;/code&gt;。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-47-51.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Python的第三方网络模块&lt;code&gt;requests&lt;/code&gt;向这个模块发送&lt;code&gt;POST&lt;/code&gt;请求，提交用户名和密码即可实现登录。其代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;login_url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'https://workflowy.com/accounts/login/'&lt;/span&gt;
session &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.Session()
session.post(login_url,
             data&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{&lt;span class=&quot;st&quot;&gt;'username'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'12345@qq.com'&lt;/span&gt;,
                   &lt;span class=&quot;co&quot;&gt;'password'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'8888888'&lt;/span&gt;,
                   &lt;span class=&quot;co&quot;&gt;'next'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;})&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;获取所有条目&quot;&gt;获取所有条目&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;requests&lt;/code&gt;的&lt;code&gt;session&lt;/code&gt;登录Workflowy以后，Cookies会被自动保存到&lt;code&gt;session&lt;/code&gt;这个对象里面。于是使用&lt;code&gt;session&lt;/code&gt;继续访问Workfowy就可以以登录后的身份查看自己的各个条目。&lt;/p&gt;
&lt;p&gt;通过Chrome可以看到获取所有条目的接口为&lt;code&gt;https://workflowy.com/get_initialization_data?client_version=18&lt;/code&gt;，接口返回的数据是一个包含所有条目的超大型JSON字符串，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-55-40.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Python的json模块可以解析这个JSON字符串为字典，并获取所有条目，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;outline_url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'https://workflowy.com/get_initialization_data?client_version=18'&lt;/span&gt;
outlines_json &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; session.get(outline_url).text
outlines_dict &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; json.loads(outlines_json)
project_list &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; outlines_dict.get(&lt;span class=&quot;st&quot;&gt;'projectTreeData'&lt;/span&gt;, {})&lt;span class=&quot;op&quot;&gt;\&lt;/span&gt;
    .get(&lt;span class=&quot;st&quot;&gt;'mainProjectTreeInfo'&lt;/span&gt;, {})&lt;span class=&quot;op&quot;&gt;\&lt;/span&gt;
    .get(&lt;span class=&quot;st&quot;&gt;'rootProjectChildren'&lt;/span&gt;, [])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;提取任务与子任务&quot;&gt;提取任务与子任务&lt;/h4&gt;
&lt;p&gt;所有的条目层层嵌套在列表-字典结构中，其基本的形态如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;{
    &lt;span class=&quot;st&quot;&gt;&quot;ch&quot;&lt;/span&gt;: [子条目], 
    &lt;span class=&quot;co&quot;&gt;&quot;lm&quot;&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;308496&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;957996b9-67ce-51c7-a796-bfbee44e3d3f&quot;&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;&quot;nm&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;AutoEmo&quot;&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的&lt;code&gt;nm&lt;/code&gt;为这个条目的名字。如果一个条目有子条目，那么&lt;code&gt;ch&lt;/code&gt;列表中就会有很多个字典，每个字典的都是这个结构，如果一个条目没有子条目，那么就没有&lt;code&gt;ch&lt;/code&gt;这个key。这样一层一层嵌套下去：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt; {
    &lt;span class=&quot;st&quot;&gt;&quot;ch&quot;&lt;/span&gt;: [
        {
            &lt;span class=&quot;st&quot;&gt;&quot;lm&quot;&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;558612&lt;/span&gt;, 
            &lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;5117e20b-25ba-ba91-59e1-790c0636f78e&quot;&lt;/span&gt;, 
            &lt;span class=&quot;co&quot;&gt;&quot;nm&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;准备并熟背一段自我介绍，在任何需要自我介绍的场合都有用&quot;&lt;/span&gt;
        }, 
        {
            &lt;span class=&quot;st&quot;&gt;&quot;lm&quot;&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;558612&lt;/span&gt;, 
            &lt;span class=&quot;co&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;4894b23e-6f47-8028-a26a-5fb315fc4e6f&quot;&lt;/span&gt;, 
            &lt;span class=&quot;co&quot;&gt;&quot;nm&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;姓名，来自哪里，什么工作&quot;&lt;/span&gt;,
            &lt;span class=&quot;co&quot;&gt;&quot;ch&quot;&lt;/span&gt;: [
                {&lt;span class=&quot;st&quot;&gt;&quot;lm&quot;&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;5435246&lt;/span&gt;, 
                 &lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;4894b23e-6f47-8028-a26a-5fbadfasdc4e6f&quot;&lt;/span&gt;, 
                 &lt;span class=&quot;co&quot;&gt;&quot;nm&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;工作经验&quot;&lt;/span&gt;}
            ]
        }
    ], 
    &lt;span class=&quot;co&quot;&gt;&quot;lm&quot;&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;558612&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;ea282a1c-94f3-1a44-c5b3-7907792e9e6e&quot;&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;&quot;nm&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;自我介绍&quot;&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于条目和子条目的结构是一样的，那么就可以使用递归来解析每一个条目。由于需要添加到Teambition的任务，从名为[Teambition]的条目开始，于是可以使用下面这样一个函数来解析：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;task_dict &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {}
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; extract_task(sections, task_dict, target_section&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;):
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; section &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; sections:
        name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; section[&lt;span class=&quot;st&quot;&gt;'nm'&lt;/span&gt;]
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; target_section:
            task_dict[name] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [x[&lt;span class=&quot;st&quot;&gt;'nm'&lt;/span&gt;] &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; section.get(&lt;span class=&quot;st&quot;&gt;'ch'&lt;/span&gt;, [])]
            &lt;span class=&quot;cf&quot;&gt;continue&lt;/span&gt;

        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; name &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'[Teambition]'&lt;/span&gt;:
            target_section &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;
        sub_sections &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; section.get(&lt;span class=&quot;st&quot;&gt;'ch'&lt;/span&gt;, [])
        extract_task(sub_sections, task_dict, target_section&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;target_section)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下图所示为一段需要添加到Teambition中的条目，运行这段函数以后，得到的结果为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;{&lt;span class=&quot;st&quot;&gt;'登录Workflowy'&lt;/span&gt;: [], &lt;span class=&quot;st&quot;&gt;'获取需要添加到Teambition的内容'&lt;/span&gt;: [&lt;span class=&quot;st&quot;&gt;'获取任务'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'获取子任务'&lt;/span&gt;], &lt;span class=&quot;st&quot;&gt;'调试Teambition API'&lt;/span&gt;: [], &lt;span class=&quot;st&quot;&gt;'添加任务到Teambition'&lt;/span&gt;: []}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-09-03.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;teambition&quot;&gt;Teambition&lt;/h2&gt;
&lt;p&gt;将任务添加到Teambition，需要使用Teambition的Python SDK登录Teambition并调用API添加任务。Teambition的Python SDK在使用&lt;code&gt;OAuth2&lt;/code&gt;获取&lt;code&gt;access_token&lt;/code&gt;的时候有一个坑，需要特别注意。&lt;/p&gt;
&lt;h3 id=&quot;登录teambition&quot;&gt;登录Teambition&lt;/h3&gt;
&lt;h4 id=&quot;设置teambition应用&quot;&gt;设置Teambition应用&lt;/h4&gt;
&lt;p&gt;Teambition 是使用&lt;code&gt;OAuth2&lt;/code&gt;来进行权限验证的，所以需要获取&lt;code&gt;access_token&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;首先打开Teambition的&lt;a href=&quot;https://developer.teambition.com/dashboard&quot;&gt;开发者中心&lt;/a&gt;并单击&lt;code&gt;新建应用&lt;/code&gt;，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-14-38.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用名称可以随便写。创建好应用以后，可以看到应用的信息，需要记录&lt;code&gt;Client ID&lt;/code&gt;和&lt;code&gt;Client Secret&lt;/code&gt;，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-18-20.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击左侧的&lt;code&gt;OAuth2&lt;/code&gt;配置，填写回调URL，如下图所示。这里的这个URL其实使用任何一个可以访问的网站的域名都可以，这里以我的博客地址为例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-20-49.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用python获取access_token&quot;&gt;使用Python获取access_token&lt;/h4&gt;
&lt;p&gt;首先在Python中安装Teambition的SDK：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;pip&lt;/span&gt; install teambition&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，在Python中获取授权URL：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; teambition &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Teambition

tb_client_id &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'7bfae080-a8dc-11e7-b543-77a936726657'&lt;/span&gt;
tb_client_secret &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'9830fc8c-81b3-45ed-b3c0-e039ab8f2d8b'&lt;/span&gt;
tb &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Teambition(tb_client_id,
                tb_client_secret)
authorize_url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tb.oauth.get_authorize_url(&lt;span class=&quot;st&quot;&gt;'https://kingname.info'&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(authorize_url)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码运行以后，会得到一段形如下面这段URL的授权URL：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://account.teambition.com/oauth2/authorize?client_id=7bfae080-a8dc-11e7-b543-77a936726657&amp;amp;redirect_uri=https://kingname.info&amp;amp;state=&amp;amp;lang=zh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在电脑浏览器中&lt;strong&gt;人工&lt;/strong&gt;访问这个URL，会出现下面这样的页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-31-25.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击&lt;code&gt;授权并登录&lt;/code&gt;，可以看到浏览器上面的网址变为形如：&lt;code&gt;https://kingname.info/?code=Pn7ebs4sZh3NYOz2FvVJQ4uu&lt;/code&gt;，此时，需要记录&lt;code&gt;code=&lt;/code&gt;后面的这一串字符串&lt;code&gt;Pn7ebs4sZh3NYOz2FvVJQ4uu&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来就是Teambition的SDK的坑点了，根据Teambition官方文档的说法，要获取access_token，只需要如下两段代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;code &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Pn7ebs4sZh3NYOz2FvVJQ4uu'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;#前面浏览器中的字符串&lt;/span&gt;
tb.oauth.fetch_access_token(code)
&lt;span class=&quot;co&quot;&gt;# 上面的代码完成授权，接下来直接使用tb.xxxx就可以操作任务了。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但实际上，上面这一段代码一定会报错。提示&lt;code&gt;grant invaild&lt;/code&gt;。要解决这个问题，就必需使用Teambition的HTTP 接口来人工获取access_token。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;code &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Pn7ebs4sZh3NYOz2FvVJQ4uu'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;#前面浏览器中的字符串&lt;/span&gt;
fetch_result_dict &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; session.post(&lt;span class=&quot;st&quot;&gt;'https://account.teambition.com/oauth2/access_token'&lt;/span&gt;,
                  data&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{&lt;span class=&quot;st&quot;&gt;'client_id'&lt;/span&gt;: tb_client_id,
                        &lt;span class=&quot;co&quot;&gt;'client_secret'&lt;/span&gt;: tb_client_secret,
                        &lt;span class=&quot;co&quot;&gt;'code'&lt;/span&gt;: code,
                        &lt;span class=&quot;co&quot;&gt;'grant_type'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'code'&lt;/span&gt;}).json()
tb_access_token &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fetch_result_dict.get(&lt;span class=&quot;st&quot;&gt;'access_token'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时得到的access_token是一段非常长的字符串。接下来，重新初始化tb变量：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;tb &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Teambition(tb_client_id,
                tb_client_secret,
                access_token&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;tb_access_token)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化以后，使用tb这个变量，就可以对工程和任务进行各种操作了。&lt;/p&gt;
&lt;h4 id=&quot;teambition的简单使用&quot;&gt;Teambition的简单使用&lt;/h4&gt;
&lt;p&gt;要在某个工程里面创建任务，就需要知道工程的ID。首先在Teambition中手动创建一个工程，在浏览器中打开工程，URL中可以看到工程的ID，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-45-51.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了工程ID以后，就可以使用下面的代码创建任务：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; create_task(task_name, sub_task_list):
        tasklist &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tb.tasklists.get(project_id&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'59d396ee1013d919f3348675'&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
        tasklist_id &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tasklist[&lt;span class=&quot;st&quot;&gt;'_id'&lt;/span&gt;]
        todo_stage_id &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tasklist[&lt;span class=&quot;st&quot;&gt;'stageIds'&lt;/span&gt;][&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
        task_info &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tb.tasks.create(task_name, tasklist_id&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;tasklist_id, stage_id&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;todo_stage_id)
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; sub_task_list:
            task_id &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; task_info[&lt;span class=&quot;st&quot;&gt;'_id'&lt;/span&gt;]
            &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; sub_task_name &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; sub_task_list:
                tb.subtasks.create(sub_task_name, task_id&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;task_id)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f&lt;span class=&quot;st&quot;&gt;'task: &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{task_name}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; with sub tasks: &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{sub_task_list}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; added.'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码首先使用&lt;code&gt;tb.tasklists.get()&lt;/code&gt;根据工程ID获得任务组的ID和&lt;code&gt;待处理&lt;/code&gt;这个面板的ID，接下来调用&lt;code&gt;tb.tasks.create()&lt;/code&gt;接口添加任务。从添加任务返回的信息里面拿到任务的ID，再根据任务ID，调用&lt;code&gt;tb.subtasks.create()&lt;/code&gt;添加子任务ID。&lt;/p&gt;
&lt;h2 id=&quot;效果测试&quot;&gt;效果测试&lt;/h2&gt;
&lt;p&gt;上面的代码实现了TeamFlowy的基本逻辑。运行TeamFlowy脚本以后，[Teambition]这个条目下面的任务被成功的添加到了Teambition中，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-55-34.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将代码组合起来并进行完善，让代码更容易使用，完整的代码可以查看&lt;a href=&quot;https://github.com/kingname/TeamFlowy&quot; class=&quot;uri&quot;&gt;https://github.com/kingname/TeamFlowy&lt;/a&gt;。完整的代码运行效果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-17-01-11.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Oct 2017 09:23:00 +0000</pubDate>
<dc:creator>青南</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieqiankun/p/teamflowy.html</dc:identifier>
</item>
<item>
<title>JavaWeb（一）之细说Servlet - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7625851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7625851.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　其实javaWeb的知识早就学过了，可是因为现在在搞大数据开发，所以web的知识都忘记了。准备开始慢慢的把Web的知识一点一点的回忆起来，多学一点没有关系，就怕到时候要用的话，什么都不会了。&lt;/p&gt;

&lt;h2&gt;1.1、Servlet简介&lt;/h2&gt;
&lt;p&gt;　　Servlet 运行&lt;span&gt;在服务端的Java小程序&lt;/span&gt;，是sun公司提供&lt;span&gt;一套规范（接口）&lt;/span&gt;，用来&lt;span&gt;处理客户端请求、响应给浏览器的动态资源&lt;/span&gt;。但&lt;span&gt;servlet的实质就是java代码&lt;/span&gt;，通过java的API 动态的向客户端输出内容。&lt;/p&gt;
&lt;p&gt;　　Servlet是Java Web的三大组件（Servlet,Filter,Listener）之一，属于动态资源 ,运行在 Web 服务器或应用服务器上的程序作用为处理请求，服务器会把接收的请求交给Servlet来处理，在Servlet中通常需要：&lt;/p&gt;
&lt;p&gt;　　　　接受请求数据、处理请求、完成响应&lt;/p&gt;
&lt;p&gt;　　例如：客户端发出登录请求，或输出注册请求，这些请求都应该有Servlet来完成处理。每个Servlet都必须实现javax.servle.Servlet接口。&lt;/p&gt;
&lt;p&gt;　　总结：　　　&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;处理请求和发送响应的过程是由一种叫做Servlet的程序来完成的&lt;/span&gt;，并且Servlet是为了解决实现动态页面而衍生的东西。理解这个的前提是了解一些http协议的东西，并且知道B/S模式(浏览器/服务器)。&lt;/p&gt;
&lt;p&gt;　　　　B/S:浏览器/服务器。 浏览器通过网址来访问服务器，比如访问百度，在浏览器中输入www.baidu.com，这个时候浏览器就会显示百度的首页。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004151503943-34533384.png&quot; alt=&quot;&quot; width=&quot;637&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　补充1：&lt;/p&gt;
&lt;p&gt;　　　　servlet规范（sun公司自己制定了一种&lt;span&gt;用于扩展web服务器功能的组件规范&lt;/span&gt;）：包含三个技术点（三大组件）　　　&lt;/p&gt;
&lt;p&gt;　　　　servlet技术&lt;br/&gt;　　　　filter技术---过滤器&lt;br/&gt;　　　　listener技术---监听器&lt;/p&gt;
&lt;p&gt;　　　　1）扩展web服务器功能&lt;/p&gt;
&lt;p&gt;　　　　　　web服务器(tomcat、Weblogic、iis、apache)&lt;span&gt;没有处理动态资源请求的能&lt;/span&gt;力(即该请求需要计算),只能处理静态资源的请求(如果浏览器请求某个html页面，&lt;br/&gt;　　　　　　web服务器查看请求的html页面是否存在，存在则返回。)如果要让web服务器处理动态资源的请求，则需要使用cgi程序、组件加容器的方式。&lt;/p&gt;
&lt;p&gt;　　　　2）组件（可以单独部署的软件模块，组件必须要符合相应的规范。）&lt;/p&gt;
&lt;p&gt;　　　　　　优点是可以加快软件开发的速度，提高软件的可维护性。容器：为组件提供运行环境，并且管理组件的生命周期。组件并不完全依赖特定的容器，只要符合相应的规范就可以。&lt;/p&gt;
&lt;p&gt;　　补充2：　　　&lt;/p&gt;
&lt;p&gt;　　　　Servlet和普通java类的区别：&lt;/p&gt;
&lt;p&gt;　　　　　　客户不能直接&lt;span&gt;创建Servlet对象和调用Servlet的方法&lt;/span&gt;，只能通过向Web服务器发出HTTP请求，间接调用Servlet的方法。　&lt;/p&gt;
&lt;h2&gt;1.2、实现Servlet的方式　&lt;/h2&gt;
&lt;p&gt;　　实现javax.servlet.Servlet接口&lt;br/&gt;　　继承javax.servlet.GenericServlet类&lt;br/&gt;　　继承javax.servlet.http.HttpServlet类&lt;/p&gt;
&lt;p&gt;　　通常会去继承HttpServlet类来完成Servlet&lt;/p&gt;
&lt;h2&gt;1.3、Servlet与线程安全问题&lt;/h2&gt;
&lt;p&gt;　　一个类型的Servlet只有一个实例对象，那么就有可能会出现一个Servlet同时处理多个请求，线程不安全，但Servlet工作效率高。&lt;/p&gt;
&lt;p&gt;　　解决方案：　　　　&lt;/p&gt;
&lt;p&gt;　　　　不要在Servlet中创建成员，创建局部变量变量即可！&lt;br/&gt;　　　　可以创建无状态成员！&lt;br/&gt;　　　　可以创建有状态的成员，但状态必须位为只读的！　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3b2160aa-86ed-4a53-8a46-d7e4d5229106')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_3b2160aa-86ed-4a53-8a46-d7e4d5229106&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3b2160aa-86ed-4a53-8a46-d7e4d5229106&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3b2160aa-86ed-4a53-8a46-d7e4d5229106',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3b2160aa-86ed-4a53-8a46-d7e4d5229106&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Servlet extends HttpServlet {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无状态成员&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;public class User {
        public void hello() {
            System.out.println(&quot;Hello&quot;);
        }
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建有状态的成员，但状态必须位为只读的&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;public class User {
        private String name = &quot;zhangsan&quot;;
        public String getName() {
            return name;
        }
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;doPost()...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;doGet()...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;示例代码&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　Tomcat 是&lt;span&gt;Web应用服务器,是一个Servlet/JSP容器&lt;/span&gt;. Tomcat 作为&lt;span&gt;Servlet容器,负责处理客户请求,把请求传送给Servlet,&lt;/span&gt;并将&lt;span&gt;Servlet的响应传送回给客户&lt;/span&gt;.而&lt;span&gt;Servlet是一种运行在支持&lt;/span&gt;&lt;span class=&quot;baidu-highlight&quot;&gt;&lt;span&gt;Java语言的服务器上的组件&lt;/span&gt;.。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;baidu-highlight&quot;&gt;　　Servlet最常见的用途是扩展Java Web服务器功能,提供非常安全的,可移植的,易于使用的CGI替代品。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;baidu-highlight&quot;&gt;　　从http协议中的请求和响应可以得知，浏览器发出的请求是一个请求文本，而浏览器接收到的也应该是一个响应文本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;baidu-highlight&quot;&gt;　　但是在上面这个图中，并不知道是如何转变的，只知道浏览器发送过来的请求也就是request，我们响应回去的就用response。忽略了其中的细节，现在就来探究一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;baidu-highlight&quot;&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004152356927-1466503539.png&quot; alt=&quot;&quot; width=&quot;728&quot; height=&quot;334&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1）Tomcat将&lt;span&gt;http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象&lt;/span&gt;，所有的HTTP头数据读可以通过request对象调用对应的方法查询到。&lt;/p&gt;
&lt;p&gt;　　2）Tomcat同时会要&lt;span&gt;响应的信息封装为HttpServletResponse类型的response对象&lt;/span&gt;，通过设置response属性就可以控制要输出到浏览器的内容，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器。&lt;/p&gt;
&lt;p&gt;　　Java Servlet API 是&lt;span&gt;Servlet容器(tomcat)和servlet之间的接口&lt;/span&gt;，它定义了serlvet的各种方法，还定义了Servlet容器传送给Servlet的对象类，其中最重要的就是ServletRequest和ServletResponse。&lt;/p&gt;
&lt;p&gt;　　所以说我们在编写servlet时，需要实现Servlet接口，按照其规范进行操作。&lt;/p&gt;

&lt;h2&gt;3.1、手动编写一个Servlet&lt;/h2&gt;
&lt;p&gt;　　1）创建一个Servlet_demo_0010继承HttpServlet，重写doGet和doPost方法，也就是看请求的方式是get还是post，然后用不同的处理方式来处理请求。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004154455193-1338293430.png&quot; alt=&quot;&quot; width=&quot;962&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）在web.xml中配置Servlet_demo_0010，为什么需要配置？让浏览器发出的请求知道到达哪个servlet，也就是让tomcat将封装好的request找到对应的servlet让其使用。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004155214240-1913840074.png&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分析：&lt;/p&gt;
&lt;p&gt;　　　　按照步骤，首先浏览器通过http://localhost:4040/Web_Servlet/ServletTest来找到web.xml中的url-pattern，这就是第一步，匹配到了url-pattern后，就会找到第二步servlet的名字MyServlet，知道了名字，&lt;/p&gt;
&lt;p&gt;　　　　就可以通过servlet-name找到第三步，到了第三步，也就能够知道servlet的位置了。然后到其中找到对应的处理方式进行处理。&lt;/p&gt;
&lt;p&gt;　　3）测试&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004155537974-857003946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004155605193-177148756.png&quot; alt=&quot;&quot;/&gt;说明配置成功了！（输出get因为http请求默认是get请求）&lt;/p&gt;
&lt;h2&gt;3.2、使用Eclipse向导创建一个Servlet&lt;/h2&gt;
&lt;p&gt;　　这个就相对简单了，web.xml不用我们手动配置，工具直接帮我们自动配置了&lt;/p&gt;
&lt;p&gt;　　1）右击项目，在new选项中有直接新建servlet的选项&lt;/p&gt;
&lt;p&gt;　　2）配置Servlet_demo_0020类中的信息&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004155947536-939879966.png&quot; alt=&quot;&quot; width=&quot;387&quot; height=&quot;424&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）配置web.xml中的servlet信息&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004160342865-2021108287.png&quot; alt=&quot;&quot; width=&quot;386&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4）查看Servlet_demo_0020类中的代码和web.xml，其中的配置跟手动的配置是一样的，只是用图形化界面，让我们更方便的创建servlet而产生的。&lt;/p&gt;

&lt;h2&gt;4.1、生命周期方法与特性&lt;/h2&gt;
&lt;p&gt;　　void init(ServletConfig servletConfig)：Servlet对象创建之后马上执行的初始化方法，只执行一次；&lt;br/&gt;　　void service(ServletRequest servletRequest, ServletResponse servletResponse)：每次处理请求都是在调用这个方法，它会被调用多次；&lt;br/&gt;　　void destroy()：在Servlet被销毁之前调用，负责释放Servlet对象占用的资源的方法；&lt;/p&gt;
&lt;p&gt;　　特性：　　&lt;/p&gt;
&lt;p&gt;　　　　单例，一个类只有一个对象，当然可能存在多个Servlet类&lt;br/&gt;　　　　线程不安全的，所以它的效率高。&lt;/p&gt;
&lt;p&gt;　　Servlet类由自己编写，但&lt;span&gt;对象由服务器来创建，并由服务器来调用相应的方法　&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.2、Servlet生命周期　&lt;/h2&gt;
&lt;p&gt;　　服务器启动时(web.xml中配置load-on-startup=1，默认为0)或者第一次请求该servlet时，就会初始化一个Servlet对象，也就是会执行初始化方法init(ServletConfig conf)&lt;/p&gt;
&lt;p&gt;　　该servlet对象去&lt;span&gt;处理所有客户端请求&lt;/span&gt;，在service(ServletRequest req，ServletResponse res)方法中执行&lt;/p&gt;
&lt;p&gt;　　最后服务器关闭时，才会销毁这个servlet对象，执行destroy()方法。&lt;/p&gt;
&lt;p&gt;　　图解：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004161231755-1999767937.png&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　详细说明：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004161403880-897398880.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;377&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　总结（面试会问）：　　　&lt;/p&gt;
&lt;p&gt;　　1）Servlet何时创建&lt;br/&gt;　　　　默认第一次访问servlet时创建该对象（调用init()方法）&lt;br/&gt;　　2）Servlet何时销毁&lt;br/&gt;　　　　服务器关闭servlet就销毁了(调用destroy()方法)&lt;br/&gt;　　3）每次访问必须执行的方法&lt;br/&gt;　　　　public void service(ServletRequest arg0, ServletResponse arg1)&lt;/p&gt;

&lt;h2&gt;5.1、Servlet执行过程&lt;/h2&gt;
&lt;p&gt;　　在浏览器的地址栏输入：http://ip:port/appNames/servlet&lt;/p&gt;
&lt;p&gt;　　1）通过浏览器和ip：port和这个服务器建立连接。&lt;br/&gt;　　2） 浏览器会生成&lt;span&gt;一个请求数据包（路径appNames/servlet）向服务器发送请求&lt;/span&gt;。&lt;br/&gt;　　3） 服务器收到请求数据包，分析请求资源路径做精准定位，通过请求的appName查找webapps文件下面的appName做匹配，匹配上了需要获取web.xml中的servlet(mapping)。　&lt;br/&gt;　　4） 服务器创建两个对象：&lt;br/&gt;　　　　第一个对象：请求对象，该对象实现了HttpServletRequest接口，服务器会将请求数据包中的数据解析出来,存储在该对象里。这样做的好处是没有必要理解http协议，只需要读取request。&lt;br/&gt;　　　　第二个对象：响应对象，实现了HttpServletResponse接口，作用是servlet处理完成后的结果可以存放到该对象上，然后服务器依据该对象的数据生成响应数据包。&lt;br/&gt;　　5） servlet在执行servlet()方法时，可以通过request获取请求数据，也可以将处理结果存放到response上。然后服务器与响应对象直接形成一个默契，生成一个响应数据包给浏览器。&lt;br/&gt;　　6）浏览器解析服务器返回的响应数据包，生成响应的结果。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004162348458-448911593.png&quot; alt=&quot;&quot; width=&quot;1012&quot; height=&quot;280&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　Servlet访问的过程：&lt;/p&gt;
&lt;p&gt;　　　　Http请求----&amp;gt;web.xml--------&amp;gt;  url -pattern-----&amp;gt;servlet-name-----&amp;gt;servlet-class-----&amp;gt;   QuickStratServlet(对应的Class文件)&lt;/p&gt;
&lt;h2&gt;5.2、Servlet配置&lt;/h2&gt;
&lt;div readability=&quot;30&quot;&gt;
&lt;p&gt;　　1）基本配置web.xml文件&lt;br/&gt;　　　　&amp;lt;!--servlet的类的配置--&amp;gt;&lt;br/&gt;　　　　&amp;lt;!--servlet的虚拟路径的配置--&amp;gt;&lt;br/&gt;　　  其中url-pattern的配置方式：&lt;br/&gt;　　　　1）完全匹配：访问的资源与配置的资源完全相同才能访问到　　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　绝对地址只能映射到1个地址&lt;br/&gt;　　　　　　格式：/目录/目录/文件名.扩展名&lt;/p&gt;
&lt;p&gt;　　　　　　&amp;lt;url-pattern&amp;gt;/quickStartServlet&amp;lt;/url-pattern&amp;gt;&lt;br/&gt;　　　　2）目录匹配：格式：/虚拟的目录..../*　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　格式：/目录/目录/*&lt;/p&gt;
&lt;p&gt;　　　　　　这类映射重点匹配目录，只要目录符合映射模式，不考虑文件名，这个Servlet可以响应多个请求URL。&lt;/p&gt;
&lt;p&gt;　　　　　　&amp;lt;url-pattern&amp;gt;/aaa/bbb/ccc/*&amp;lt;/url-pattern&amp;gt; //* 代表任意&lt;br/&gt;　　　　3）匹配扩展名：格式：*.扩展名；　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　格式：*.扩展名&lt;/p&gt;
&lt;p&gt;　　　　　　以匹配扩展名的方式进行URL映射，不考虑文件的目录信息，也可以响应多地址的请求。&lt;/p&gt;
&lt;p&gt;　　　　　　&amp;lt;url-pattern&amp;gt;*.abcd&amp;lt;/url-pattern&amp;gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　　　注意：第二种与第三种混用   如 ：/aaa/bbb/*.cba  （错误）&lt;/p&gt;

&lt;div readability=&quot;96.5&quot;&gt;
&lt;p&gt;　　2）服务器启动实例化Servlet配置&lt;br/&gt;　　　　Servlet何时创建：默认第一次访问时创建&lt;br/&gt;　　　　为什么是默认？&lt;br/&gt;　　　　当在Servlet的配置是，加上一个配置&amp;lt;load-onstartup&amp;gt; ；&lt;br/&gt;　　　　servlet对象在服务器启动时就创建。&amp;lt;!--数字代表优先级，数字越小优先级越高--&amp;gt;&lt;br/&gt;　　　　&amp;lt;load-on-startup&amp;gt;4&amp;lt;/load-on-startup&amp;gt; 最好取中间数字 4/5。&lt;/p&gt;
&lt;p&gt;　　3）缺省Servlet　　&lt;/p&gt;
&lt;p&gt;　　　　可以将url-pattern 配置一个/，代表该servlet是缺省的servlet。&lt;/p&gt;
&lt;p&gt;　　　　什么是缺省的servlet？&lt;/p&gt;
&lt;p&gt;    　　　　　　当你访问资源地址所有的servlet都不匹配时，缺省的servlet赋值处理。&lt;/p&gt;
&lt;p&gt;　　　　其实，web应用中所有的资源的响应都是servlet负责，包括静态资源（html页面）。（有配置缺省的servlet，无法访问到静态资源。）&lt;/p&gt;
&lt;h2&gt;5.3、创建的servlet是继承自httpServlet，而不是直接实现Servlet接口的原理&lt;/h2&gt;
&lt;p&gt;　　servlet的生命周期中，可以看出，执行的是service方法，为什么我们就只需要写doGet和doPost方法呢？&lt;/p&gt;
&lt;p&gt;　　查看源码，httpServlet的继承结构&lt;/p&gt;
&lt;p&gt;　　httpServlet继承GenericServlet。懂的人立马就应该知道，GenericServlet(通用Servlet)的作用是什么？大概的就是&lt;span&gt;将实现Servlet接口的方法，简化编写servlet的步骤&lt;/span&gt;。具体下面详解&lt;/p&gt;
&lt;div readability=&quot;136&quot;&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004164924177-2105983718.png&quot; alt=&quot;&quot; width=&quot;683&quot; height=&quot;35&quot;/&gt;&lt;p&gt;　　GenericServlet的继承结构，实现了Servlet接口和ServletConfig接口&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004164954068-1717596710.png&quot; alt=&quot;&quot; width=&quot;714&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Servlet接口内容&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165049802-57023843.png&quot; alt=&quot;&quot; width=&quot;270&quot; height=&quot;149&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从这里可以看到，Servlet生命周期的三个关键方法，init、service、destroy。还有另外两个方法，一个&lt;span&gt;getServletConfig()方法来获取ServletConfig对象&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;　　ServletConfig对象可以&lt;span&gt;获取到Servlet的一些信息&lt;/span&gt;，ServletName、ServletContext、InitParameter、InitParameterNames、通过查看ServletConfig这个接口就可以知道：&lt;/p&gt;
&lt;p&gt;　　ServletConfig接口内容&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165238911-1211686638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中&lt;span&gt;ServletContext对象是servlet上下文对象&lt;/span&gt;，功能有很多，获得了ServletContext对象，就能&lt;span&gt;获取大部分我们需要的信息，比如获取servlet的路径，等方法&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　到此，就知道了Servlet接口中的内容和作用，总结起来就是，三个生命周期运行的方法，&lt;span&gt;获取ServletConfig，而通过ServletConfig又可以获取到ServletContext&lt;/span&gt;。而GenericServlet实现了Servlet接口后，&lt;/p&gt;
&lt;p&gt;　　也就说明我们可以直接继承GenericServlet，就可以使用上面我们所介绍Servlet接口中的那几个方法了，能拿到ServletConfig，也可以拿到ServletContext，不过那样太麻烦，不能直接获取ServletContext，&lt;/p&gt;
&lt;p&gt;　　所以&lt;span&gt;GenericServlet除了实现Servlet接口外，还实现了ServletConfig接口，那样，就可以直接获取ServletContext&lt;/span&gt;了。&lt;/p&gt;
&lt;p&gt;　　GenericServlet类的内容详解&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165531396-1686459379.png&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;354&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看上图，用红色框框起来的就是实现Servlet和ServletConfig接口所实现的方法，有9个，这很正常，但是我们可以发现，init方法有两个，一个是带有参数ServletConfig的，一个有无参的方法，为什么这样设计？&lt;/p&gt;
&lt;p&gt;　　这里需要知道其中做了什么事情，来看看这两个方法分别做了什么事？&lt;/p&gt;
&lt;p&gt;　　　　init(ServletConfig config)&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165755130-1171472805.png&quot; alt=&quot;&quot; width=&quot;736&quot; height=&quot;96&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　init()&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165833052-1089090448.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;65&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　一个成员变量config&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165918599-247610247.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;27&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　getServletConfig()&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004165943396-344420017.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;66&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过这几个方法一起来讲解，首先看init(ServletConfig config)方法，&lt;span&gt;因为只有init(ServletConfig config)中带有ServletConfig对象，为了方便能够在其他地方也能直接使用ServletConfig对象，而不仅仅局限在init(ServletConfig config)方法中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以创建一个私有的成员变量config，在init(ServletConfig config)方法中就将其赋值给config，然后通过getServletConfig()方法就能够获取ServletConfig对象了&lt;/span&gt;，这个可以理解，但是在init(ServletConfig config)中，158行，还调用了一个init()方法，&lt;/p&gt;
&lt;p&gt;　　并且这个init()方法是空的，什么读没有，这是为什么呢？这个原因是为了防止一件事情，当我们需要在init方法中做一点别的事情，我们想到的方法就是继承GenericServlet并且重写了init(ServletConfig config)方法，这样依赖，&lt;/p&gt;
&lt;p&gt;　　就破坏了原本在GenericServlet类中init(ServletConfig config)写的代码了，也就是在GenericServlet类中的成员变量config会一直是null，无法得到赋值，因为被重写了，就不会在执行GenericServlet中init(ServletConfig config)方法中的代码。&lt;/p&gt;
&lt;p&gt;　　要想赋值，就必须在重写的init(ServletConfig config)方法中调用父类的init(ServletConfig config)方法，也就是super.init(ServletConfig config)，这样一来，就很不方便，怕有时候会忘了写这句代码，所以在GenericServlet类中增加一个init()方法，&lt;/p&gt;
&lt;p&gt;　　以后需要在init方法中需要初始化别的数据，只需要重写init()这个方法，而不需要去覆盖init(ServletConfig config)这个方法，这样设计，就好很多，不用在管init(ServletConfig config)这个其中的内容了。也不用出现其他的问题。&lt;/p&gt;
&lt;p&gt;　　service(ServletRequest req, ServletResponse res)&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004170337661-218506448.png&quot; alt=&quot;&quot; width=&quot;661&quot; height=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一个抽象方法，说明在GenericServlet类中并没有实现该内容，那么我们想到的是，在它上面肯定还有一层，也就是还有一个子类继承它，实现该方法，要是让我们自己写的Servlet继承GenericServlet，&lt;/p&gt;
&lt;p&gt;　　需要自己写service方法，那岂不是累死，并且我们可以看到，service方法中的参数还是ServletRequest，ServletResponse。并没有跟http相关对象挂钩，所以我们接着往下面看。&lt;/p&gt;
&lt;p&gt;　　HttpServlet类详解&lt;/p&gt;
&lt;p&gt;　　　　继承了GenericServlet类，通过我们上面的推测，这个类主要的功能肯定是实现service方法的各种细节和设计。并且通过类名可以知道，该类就跟http挂钩了。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004170533099-1296713229.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　关注service(HttpServletRequest req, HttpServletResponse resp)方法和service(ServletRequest req, ServletResponse res)方法。&lt;/p&gt;
&lt;p&gt;　　　　service(ServletRequest req, ServletResponse res)方法&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004170648021-401084464.png&quot; alt=&quot;&quot; width=&quot;622&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　该方法中就做一件事情，就是将ServletRequest和ServletResponse这两个对象强转为HttpServletRequest和HttpServletResponse对象。为什么能这样转？&lt;/p&gt;
&lt;p&gt;　　　　首先要知道req、res是什么类型，通过打印System.out.println(req)，可以知道，req实际上的类型是org.apache.catalina.connector.RequestFacade&lt;/p&gt;
&lt;p&gt;　　　　Tomcat中的源码：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171004170755240-1909992374.png&quot; alt=&quot;&quot;/&gt;　　　&lt;/p&gt;
&lt;p&gt;　　　　通过图可以得知，&lt;span&gt;req的继承结构：RequestFacade、httpServletRequest、ServletRequest&lt;/span&gt;，我们知道本身req是ServletRequest，那么从继承结构上看，它也可以看成HttpServletRequest，也可以看成ServletRequest，&lt;/p&gt;
&lt;p&gt;　　　　所以强转为HttpServletRequest是可以的，如果不明白，我举个例子，ArrayList、List、Object 这个，Object obj = new ArrayList();  List list = new ArrayList();  一个ArrayList对象可以看成List对象， 也可以看成一个Object对象，&lt;/p&gt;
&lt;p&gt;　　　　现在obj是不是可以堪称List对象呢？答案是可以的，因为obj就是ArrayList对象，既然是ArrayList对象，那么就可以看成是List对象。一样的道理，RequestFacade 对应 ArrayList、httpServleRequest对应 List、 ServletRequest 对应 Object。&lt;/p&gt;
&lt;p&gt;　　　　转换为httpServletRequest和HttpServletResponse对象之后，在调用service(HttpServletRequest req, HttpServletResponse resp)方法。&lt;/p&gt;
&lt;p&gt;　　　　service(HttpServletRequest req, HttpServletResponse resp)&lt;/p&gt;
&lt;p&gt;　　　　这个方法就是&lt;span&gt;判断浏览器过来的请求方式是哪种&lt;/span&gt;，每种的处理方式不一样，我们常用的就是get，post，并且，我们处理的方式可能有很多的内容，所以，在该方法内会将get，post等其他5种请求方式提取出来，&lt;/p&gt;
&lt;p&gt;　　　　变成单个的方法，然后我们需要编写servlet时，就可以直接重写doGet或者doPost方法就行了，而不是重写service方法，更加有针对性。所以这里就回到了我们上面编写servlet时的情况，继承httpServlet，&lt;/p&gt;
&lt;p&gt;　　　　而只要重写两个方法，一个doGet，一个doPost，其实就是service方法会调用这两个方法中的一个(看请求方式)。所&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 喜欢就点个“推荐”哦！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 04 Oct 2017 09:16:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7625851.html</dc:identifier>
</item>
<item>
<title>UI自动化测试（三）对页面中定位到的元素对象做相应操作 - 温一壶清酒</title>
<link>http://www.cnblogs.com/hong-fithing/p/7625800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hong-fithing/p/7625800.html</guid>
<description>&lt;p&gt; 前两天分别讲述了UI自动化测试基础以及对页面元素该如何进行定位，这一篇自然就是对定位到的页面元素对象进行相应操作啦。&lt;/p&gt;&lt;p&gt;　　send_keys : 在对象上模拟按键输入， 注意如果是函数需要增加转义符&lt;/p&gt;&lt;p&gt;　　submit : 提交表单， 要求对象必须是表单， 强调对象必须是表单&lt;/p&gt;&lt;p&gt;submit()：提交表单（按钮），无法点击链接，当按钮无法在页面上点击到时用submit()（按钮被遮挡）&lt;/p&gt;&lt;div readability=&quot;232.20278044104&quot;&gt;

&lt;p&gt;在实际的web产品测试中，对于鼠标的操作，不单单只有click()，有时候还要用到右击、双击、拖动等操作，这些操作包含在Actions类中。&lt;/p&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;p&gt;Actions类中鼠标操作常用方法：&lt;/p&gt;
&lt;p&gt;1. contextClick() ：右击&lt;/p&gt;
&lt;p&gt;2. doubleClick() ：双击&lt;/p&gt;
&lt;p&gt;3. dragAndDrop() ：拖动&lt;/p&gt;
&lt;p&gt;4. moveToElement() ：鼠标移动到一个元素上      (悬停)&lt;/p&gt;
&lt;p&gt;5. click_and_hold() ：按下鼠标左键在一个元素上   （左）&lt;/p&gt;
&lt;p&gt;6. release() ：鼠标释放&lt;/p&gt;
&lt;p&gt;代码举例部分方法，仅供参考：&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.Keys;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.interactions.Actions;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo3_mouse {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器要加载的url&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         driver.get(&quot;https://www.baidu.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口最大化&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右击操作
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        WebElement e=driver.findElement(By.cssSelector(&quot;div#lg&amp;gt;img&quot;));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Actions action=new Actions(driver);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        action.contextClick(e).perform();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标移动&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         WebElement move=driver.findElement(By.cssSelector(&quot;a[name='tj_briicon']&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         Actions action=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Actions(driver);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        action.moveToElement(move).perform();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Thread.sleep(2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         driver.findElement(By.cssSelector(&quot;a[name='tj_mp3']&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        driver.close();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ActionChains用于生成用户的行为，所有的行为都存储在action对象，通过perform()执行存储的行为perform()执行所有ActionChains存储的行为，perform()同样也是ActionChains类提供的方法，经常结合在一起使用&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在实际的web测试工作中， 需要配合键盘按键来操作， 对于键盘的模拟操作，Actions 类中有提供 keyUp(theKey)、 keyDown(theKey)、 sendKeys(keysToSend)等方法来实现。&lt;/p&gt;
&lt;p&gt;在 WebDriver API 中，&lt;span&gt;&lt;strong&gt;KeyDown(Keys theKey)、KeyUp(Keys theKey)&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;方法的参数只能是修饰键&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;Keys.SHIFT、Keys.ALT、Keys.CONTROL&lt;/span&gt;, 否者将抛出IllegalArgumentException 异常。其次对于action.keyDown(theKey) 方法的调用，如果没有显示的调用 action.keyUp(theKey) 或者 action.sendKeys(Keys.NULL) 来释放的话， 这个按键将一直保持按住状态。&lt;/p&gt;
&lt;p&gt;代码实现如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.Keys;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.interactions.Actions;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo3_mouse {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器要加载的url&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         driver.get(&quot;https://www.baidu.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口最大化&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下tab键
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        WebElement tab=driver.findElement(By.cssSelector(&quot;#kw&quot;));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        tab.sendKeys(Keys.TAB);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下退格键
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        WebElement tab1=driver.findElement(By.cssSelector(&quot;#kw&quot;));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        tab1.sendKeys(&quot;12306&quot;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Thread.sleep(1000);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        tab1.sendKeys(Keys.BACK_SPACE);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Thread.sleep(1000);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下组合键
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Actions action=new Actions(driver);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        WebElement ctr1=driver.findElement(By.cssSelector(&quot;#kw&quot;));
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        action.keyDown(Keys.CONTROL).sendKeys(&quot;v&quot;).sendKeys(Keys.NULL).keyUp(Keys.CONTROL).perform();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下ctrl+f4
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        WebElement ctr1=driver.findElement(By.cssSelector(&quot;#kw&quot;));
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        ctr1.sendKeys(&quot;12306&quot;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Thread.sleep(1000);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Actions action=new Actions(driver);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        action.keyDown(Keys.CONTROL).sendKeys(Keys.F4).keyUp(Keys.CONTROL).perform();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下ctrl+shift+delete&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         Actions action=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Actions(driver);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        action.keyDown(Keys.CONTROL).keyDown(Keys.SHIFT).sendKeys(Keys.DELETE).keyUp(Keys.CONTROL).keyUp(Keys.SHIFT).perform();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        driver.close();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;WebElement&lt;/strong&gt;&lt;strong&gt;接口常用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;getSize(): 返回对象的尺寸&lt;/p&gt;
&lt;p&gt;getText(): 获取对象的文本&lt;/p&gt;
&lt;p&gt;get_attribute(&quot;属性名&quot;)： 获取对象的属性值&lt;/p&gt;
&lt;p&gt;isDisplayed()： 用来判断对象是否可见， 即css的display属性是否为none&lt;/p&gt;
&lt;p&gt;isEnabled()： 判断对象是否被禁用&lt;/p&gt;
&lt;p&gt;isSelected()： 判断对象是否被选中&lt;/p&gt;
&lt;p&gt;getTagName()： 获取对象标签名称&lt;/p&gt;
&lt;p&gt;getLocation()： 获取元素坐标&lt;/p&gt;
&lt;p&gt;getCookies()/getCookieNamed(cookie_name)： 返回当前会话中的cookies&lt;/p&gt;
&lt;p&gt;代码实现举例如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo3_WebElement {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器要加载的url&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         driver.get(&quot;https://www.baidu.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口最大化&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回对象尺寸
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        int height=driver.findElement(By.cssSelector(&quot;#kw&quot;)).getSize().height;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        int width=driver.findElement(By.cssSelector(&quot;#kw&quot;)).getSize().width;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;height:&quot;+height+&quot;...&quot;+&quot;width:&quot;+width);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取对象文本
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        String text=driver.findElement(By.cssSelector(&quot;a[name='tj_trmap']&quot;)).getText();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(text);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取对象属性值
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        String id=driver.findElement(By.cssSelector(&quot;#su&quot;)).getAttribute(&quot;id&quot;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(id);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        String value=driver.findElement(By.cssSelector(&quot;#su&quot;)).getAttribute(&quot;value&quot;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(value);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断对象是否可见
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        boolean su =driver.findElement(By.cssSelector(&quot;#su&quot;)).isDisplayed();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(su);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断对象是否被禁用
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        boolean su1=driver.findElement(By.cssSelector(&quot;#kw&quot;)).isEnabled();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(su1);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断对象是否被选中
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        boolean su2=driver.findElement(By.cssSelector(&quot;#su&quot;)).isSelected();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(su2);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取对象标签名称
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        String input=driver.findElement(By.cssSelector(&quot;#kw&quot;)).getTagName();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(input);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取元素坐标,获取到的只是左上角的坐标&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; x=driver.findElement(By.cssSelector(&quot;#su&quot;&lt;span&gt;)).getLocation().x;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        System.out.println(x);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; y=driver.findElement(By.cssSelector(&quot;#su&quot;&lt;span&gt;)).getLocation().y;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        System.out.println(y);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         String z=driver.findElement(By.cssSelector(&quot;#su&quot;&lt;span&gt;)).getLocation().toString();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        System.out.println(z);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        driver.close();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         
&lt;span&gt;50&lt;/span&gt;         
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了保证脚本的稳定性， 这就需要引入等待时间， 等待页面加载元素后再进行操作，不然会出现后者页面元素定位不到，而导致脚本运行出错， selenium提供三种等待时间设置方式。&lt;/p&gt;
&lt;p&gt;①Thread.sleep()： 固定休眠时间设置，Java的Thread类里提供了休眠方法sleep,导入包后就能使用；需要注意的是：sleep()方法以毫秒为单位。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Thread.sleep(2000);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;固定延时2秒&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② implicitlyWait()：implicitlyWait()方法比sleep()方法智能，sleep()方法只能在一个固定的时间等待，而implicitlyWait()可以在一个时间范围内等待，称为隐式等待。&lt;/p&gt;
&lt;p&gt;       好比如：设置等待时间5s，页面上的元素3s后出现，只等待3s。不会等待5s隐性的等待其实就相当于设置全局的等待，在定位元素时，对所有元素设置超时时间，但对于页面跳转的地方该方法会导致出错，会抛出异常信息，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Exception in thread &quot;main&quot; org.openqa.selenium.StaleElementReferenceException: stale element reference: element is not attached to the page document
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是提醒页面元素过期，解决办法，在出错的上一行代码加一个固定等待即可。&lt;/p&gt;
&lt;p&gt;隐式等待代码举例如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.JavascriptExecutor;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.support.ui.ExpectedCondition;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.support.ui.WebDriverWait;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_wait {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器要加载的url&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         driver.get(&quot;https://www.baidu.com/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口最大化&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐式等待&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         driver.manage().timeouts().implicitlyWait(30&lt;span&gt;, TimeUnit.SECONDS);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位百度首页输入框&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         driver.findElement(By.cssSelector(&quot;#kw&quot;)).sendKeys(&quot;苏宁易购&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点位搜索按钮&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         WebElement su=driver.findElement(By.cssSelector(&quot;#su&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        su.click();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         String cl = driver.findElement(By.cssSelector(&quot;#su&quot;)).getAttribute(&quot;class&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        System.out.println(cl);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位苏宁易购的官方网址&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         Thread.sleep(2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         WebElement left=driver.findElement(By.cssSelector(&quot;div#content_left a:nth-of-type(1)&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        left.click();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;高亮代码&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        ((JavascriptExecutor) driver).executeScript(
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &quot;arguments[0].style.border='5px solid yellow'&quot;&lt;span&gt;, su);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        ((JavascriptExecutor) driver).executeScript(
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &quot;arguments[0].style.border='5px solid yellow'&quot;&lt;span&gt;, left);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处的高亮代码指的是，定位到的元素位置用js加个效果，从而实现高亮，效果图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171004170634693-211838791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③WebDriverWait():显示等待就是明确的要等到某个元素的出现或者是某个元素的可点击等条件,等不到,就一直等,除非在规定的时间之内都没找到,那么就跳出Exception。&lt;/p&gt;
&lt;p&gt;显示等待检查机制：每隔500毫秒检查一次页面上的元素是否存在，如果存在则返回&lt;/p&gt;
&lt;p&gt;代码举例如下，仅供参考：&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.JavascriptExecutor;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.support.ui.ExpectedCondition;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.support.ui.WebDriverWait;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_wait {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器要加载的url&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         driver.get(&quot;https://www.baidu.com/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口最大化&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示等待
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位百度首页输入框&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         driver.findElement(By.cssSelector(&quot;#kw&quot;)).sendKeys(&quot;苏宁易购&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点位搜索按钮&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         WebElement su=driver.findElement(By.cssSelector(&quot;#su&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        su.click();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         WebDriverWait wait = &lt;span&gt;new&lt;/span&gt; WebDriverWait(driver, 10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         WebElement wt = wait.until(&lt;span&gt;new&lt;/span&gt; ExpectedCondition&amp;lt;WebElement&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; WebElement apply(WebDriver d) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; d.findElement(By.cssSelector(&quot;div#content_left a:nth-of-type(1)&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         String cl = driver.findElement(By.cssSelector(&quot;#su&quot;)).getAttribute(&quot;class&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        System.out.println(cl);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        ((JavascriptExecutor) driver).executeScript(
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &quot;arguments[0].style.border='5px solid yellow'&quot;&lt;span&gt;, wt);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示等待是使用了一个匿名函数来实现，代码中，driver会传给d，d就相当于浏览器的驱动，然后再去查找需要的元素，其中只有十秒钟的时间，时间可更改。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;通过获取页面的title、URL地址，页面上的标识信息来判断用例是否执行成功。&lt;/p&gt;
&lt;p&gt;代码试下如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui_auto;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_12306 {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;chrom浏览器驱动的位置&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;,&quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;web驱动指向chrom驱动并创建对象driver&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取网址&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         driver.get(&quot;https://www.baidu.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器最大化&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;kw是输入框的id，12306是在输入框中药输入的内容&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         driver.findElement(By.id(&quot;kw&quot;)).sendKeys(&quot;12306&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;su是搜索按钮的id&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         WebElement btn=driver.findElement(By.id(&quot;su&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击事件&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        btn.submit();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;休眠时间&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         Thread.sleep(3000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         String title =&lt;span&gt; driver.getTitle();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 　　　　　　&lt;span&gt;if&lt;/span&gt;((title.compareTo(&quot;百度一下， 你就知道&quot;))==0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 　　　　　　　　　　System.out.println(&quot;title is correct!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 　　　　　　&lt;span&gt;else
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 　　　　　　　　　　System.out.println(&quot;title is error!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭页面&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        driver.close();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;webdriver使用findElement方法定位一个特定的对象，不过我们有时需定位一组对象， webdriver同样提供了定位一组元素的方法叫findElements。&lt;/p&gt;
&lt;p&gt;定位一组对象一般用于如下两个场景：&lt;/p&gt;
&lt;p&gt;①批量操作对象，比如将页面上的checkbox都勾选上。&lt;/p&gt;
&lt;p&gt;②先获取一组对象，再在这组对象中过滤需要具体定位的一些对象。&lt;/p&gt;
&lt;p&gt;代码实现方式多样，可使用for循环，集合列表，多个节点，遍历，迭代器等方式实现，试下部分代码如下，仅供参考：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单个元素定位
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; driver.findElement(By.cssSelector(&quot;#web&quot;)).click();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; driver.findElement(By.cssSelector(&quot;#training&quot;)).click();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; driver.findElement(By.cssSelector(&quot;#friend&quot;)).click();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; driver.findElement(By.cssSelector(&quot;#other&quot;)).click();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单个元素for循环定位
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for(int i=1;i&amp;lt;5;i++)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; driver.findElement(By.cssSelector(&quot;div#checkbox &amp;gt; input:nth-of-type(&quot;+&quot;i&quot;+&quot;)&quot;)).click();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;集合&lt;/span&gt;
List&amp;lt;WebElement&amp;gt; lt=driver.findElements(By.cssSelector(&quot;input[type='checkbox']&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;lt.size();i++&lt;span&gt;)
lt.get(i).click();
Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for循环遍历&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(WebElement e:lt)
e.click();
Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;迭代器&lt;/span&gt;
Iterator&amp;lt;WebElement&amp;gt; itr=&lt;span&gt;lt.iterator();
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(itr.hasNext())
itr.next().click();
Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
driver.quit();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;经常会遇到无法直接定位到需要选取的元素， 但是其父元素比较容易定位， 通过定位父元素再遍历其子元素选择需要的目标元素，或者需要定位某个元素下所有的子元素。层级定位的思想是先定位父对象，然后再从父对象中精确定位出其我们需要选取的后代元素。&lt;/p&gt;
&lt;p&gt;以登录百度账号为例，代码实现如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day2;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_tese_baidu_login {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;,&quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         driver.get(&quot;https://www.baidu.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位登录按钮
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.cssSelector(&quot;div#u1 a[name='tj_login']&quot;)).click();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;列表定位&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         List&amp;lt;WebElement&amp;gt; list=driver.findElements(By.cssSelector(&quot;a[name='tj_login']&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         list.get(1&lt;span&gt;).click();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要等待时间，不然定位不到&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         driver.findElement(By.id(&quot;TANGRAM__PSP_10__userNameWrapper&quot;)).findElement(By.id(&quot;TANGRAM__PSP_10__userName&quot;)).sendKeys(&quot;223456789@qq.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread.sleep(1000);&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         driver.findElement(By.id(&quot;TANGRAM__PSP_10__passwordWrapper&quot;)).findElement(By.id(&quot;TANGRAM__PSP_10__password&quot;)).sendKeys(&quot;1234567890&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在web应用中经常会出现frame嵌套的应用，假设页面上有A,B两个frame,其中B在A内，那么定位B中的内容则需要先到A，再到B。switchTo().frame方法可以把当前定位的主题切换到frame里，在frame里实际是嵌套了另外一个页面，而webdriver每次只能在一个页面识别，所以需要用&lt;span&gt;&lt;strong&gt;switchTo().frame方法&lt;/strong&gt;&lt;/span&gt;去获取frame中嵌套的页面。&lt;/p&gt;
&lt;p&gt;代码实现以禅道提Bug中的重现操作步骤为例，仅供参考：&lt;/p&gt;
&lt;div readability=&quot;13.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.JavascriptExecutor;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.Keys;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo3_chandao {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         driver.get(&quot;http://127.0.0.1/zentao/my/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         driver.findElement(By.id(&quot;account&quot;)).sendKeys(&quot;admin&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         driver.findElement(By.name(&quot;password&quot;)).sendKeys(&quot;123456&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击登录&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         driver.findElement(By.xpath(&quot;//button[@id='submit']&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         Thread.sleep(2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击测试&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         driver.findElement(By.linkText(&quot;测试&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击Bug&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         driver.findElement(By.linkText(&quot;Bug&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击提交Bug&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         driver.findElement(By.xpath(&quot;//a[@href='/zentao/bug-create-5-0-moduleID=0.html']&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重现步骤
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;switchTo()从外html文件跳到内html文件中&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         driver.switchTo().frame(driver.findElement(By.xpath(&quot;//div[@class='ke-edit']/iframe&quot;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         WebElement step=driver.findElement(By.xpath(&quot;//body[@class='article-content']&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        step.sendKeys(Keys.ARROW_RIGHT);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        step.sendKeys(Keys.ARROW_RIGHT);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        step.sendKeys(Keys.ARROW_RIGHT);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        step.sendKeys(Keys.ARROW_RIGHT);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         step.sendKeys(&quot;打开禅道&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;step.sendKeys(Keys.ARROW_DOWN);&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        step.sendKeys(Keys.ARROW_DOWN);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         step.sendKeys(&quot;不能打开&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        step.sendKeys(Keys.ARROW_DOWN);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;step.sendKeys(Keys.ARROW_DOWN);&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         step.sendKeys(&quot;正常打开&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        driver.switchTo().defaultContent();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器拉到最底部&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;         ((JavascriptExecutor)driver).executeScript(&quot;window.scrollTo(0,document.body.scrollHeight)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击保存按钮&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;         driver.findElement(By.xpath(&quot;//button[@id='submit']&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;switch_to_frame的参数必须是id或者是name， 所以一个frame只要有id和name处理起来很容易。如果没有的话，两种解决思路：&lt;/p&gt;
&lt;p&gt;①加上id或者name&lt;/p&gt;
&lt;p&gt;②使用xpath等方式定位然后实现跳转&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;27&quot;&gt;
&lt;p align=&quot;left&quot;&gt;WebDriver中处理原生JS的 alert 、confirm 以及prompt非常方便。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;具体思路是使用switchTo.alert()方法定位到当前的 alert/confirm/prompt(这里注意当前页面只能同时含有一个控件，如果多了会报错的，所以这就需要一一处理了)，然后在调用Alert 的方法进行操作&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　alert只有确定按钮&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　confirm有确定和取消按钮&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　prompt可以输入文字，有确定和取消按钮&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Alert提供了以下几个方法：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;①getText： 返回alert/confirm/prompt中的文字内容&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;②accept : 点击确认按钮&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;③dismiss : 点击取消按钮如果有取消按钮的话&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;④sendKeys :  向prompt中输入文字&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/strong&gt;：send_keys这个方法在&lt;span&gt;chromedriver&lt;/span&gt;中输入后&lt;span&gt;不会显示&lt;/span&gt;，js弹窗延时用固定等待&lt;/p&gt;
&lt;p&gt;实现代码如下，仅供参考：&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.Alert;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo_js {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;chrom浏览器驱动的位置&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;,&quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;web驱动指向chrom驱动并创建对象driver&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取网址&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         driver.get(&quot;file:///C:/Users/hongboss/Desktop/js%E4%BB%A3%E7%A0%81/%E5%AF%B9%E8%B1%A1.html?&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器最大化&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         driver.findElement(By.cssSelector(&quot;#btn&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         Alert alter=&lt;span&gt;driver.switchTo().alert();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        System.out.println(alter.getText());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        alter.accept();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         driver.findElement(By.cssSelector(&quot;#btn1&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         Alert alter1=&lt;span&gt;driver.switchTo().alert();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        System.out.println(alter1.getText());
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        alter1.dismiss();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         driver.findElement(By.cssSelector(&quot;#btn2&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         Alert alter2=&lt;span&gt;driver.switchTo().alert();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        System.out.println(alter2.getText());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         alter2.sendKeys(&quot;hello&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        alter2.accept();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;web页面上经常会有下拉框，对下拉框的处理比较简单，一般分为两种情况：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;①普通下拉框通过层级定位识别&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;②有些下拉框是鼠标移上去直接弹出的，可以使用（鼠标移动上去自动显示的下拉框）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;方法一实现代码如层级定位中所举例代码思想一致，这里就不再列举&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;方法二实现代码如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day2;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.interactions.Actions;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_baidu_float {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         driver.get(&quot;https://www.baidu.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位更多产品&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         WebElement move=driver.findElement(By.cssSelector(&quot;.bri&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         Actions action=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Actions(driver);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        action.moveToElement(move).perform();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.cssSelector(&quot;.bdbriimgitem_3&quot;)).click();&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         driver.findElement(By.cssSelector(&quot;.bdbriimgitem_6&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;实现方法有如下四种：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;①鼠标点击事件，move&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;②层级关系&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;③list列表&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;④selector方法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;方法一实现代码如下拉框处理中方法二所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;方法二实现代码如层级定位中所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;方法三实现代码如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo_list {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         driver.get(&quot;https://www.baidu.com/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把列表内容放到list中&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         List&amp;lt;WebElement&amp;gt; list=driver.findElements(By.cssSelector(&quot;a.mnav&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread.sleep(3000);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出列表中的具体值，并点击&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         list.get(2&lt;span&gt;).click();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法四中还包含三种方法，分别是：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　selectByIndex(int index)   //通过index&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　selectByVisibleText(String text)   //通过匹配到的可见字符&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　selectByValue(String value)    //通过匹配到标签里的value&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;代码实现如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.support.ui.Select;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo_select {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         driver.get(&quot;file:///F:/17new/12%20UI%E8%87%AA%E5%8A%A8%E5%8C%96/html/ui_day1_test.html&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         WebElement selector=driver.findElement(By.id(&quot;select&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Select select = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Select(selector);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         select.selectByVisibleText(&quot;有经验&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Thread.sleep(2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         select.selectByValue(&quot;无经验&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         Thread.sleep(2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         select.selectByIndex(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特殊下拉框：&lt;/p&gt;
&lt;p&gt;还有一种下拉框就是联想形式的，比如下百度搜索框中输入12306，会出现多个选项，用代码实现去选择下拉中的内容，代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day3;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_select_12306 {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         driver.get(&quot;https://www.baidu.com/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位输入框，并输入内容&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         driver.findElement(By.cssSelector(&quot;#kw&quot;)).sendKeys(&quot;12306&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击输入框&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         driver.findElement(By.cssSelector(&quot;#kw&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把列表内容放到list中&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         List&amp;lt;WebElement&amp;gt; list=driver.findElements(By.cssSelector(&quot;form#form div.bdsug ul li&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread.sleep(3000);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出列表中的具体值，并点击&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         list.get(1&lt;span&gt;).click();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;当webdriver遇到无法完成的操作时候，这个时候可以使用javascript来完成，webdriver提供了execute_script()接口来调用js代码。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;执行js有两种场景：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;①在页面上直接执行js&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;②在某个已经定位的元素上执行js&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;场景①其实在alter/confirm/prompt处理已介绍过在页面上如何执行js了，可参考。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;场景②在设置等待时间已介绍如何高亮处理，都有介绍。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;js还可以做下拉滚动条，在做自动化测试的时候，这个办法缺一不可。之前我在做自动化时，就因为没加滚动条，而导致脚本一直运行不成功，因为脚本只能执行在当前页面所显示的操作，因此需要滚动条。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
JavascriptExecutor js =&lt;span&gt; (JavascriptExecutor)driver;
js.executeScript(&lt;/span&gt;&quot;scrollTo(0,10000)&quot;);----------------------------------------------&lt;span&gt;向下拉到底
Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
js.executeScript(&lt;/span&gt;&quot;scrollBy(0, 0-document.body.scrollHeight *99/100)&quot;);--------------&lt;span&gt;向上拉到顶
Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
js.executeScript(&lt;/span&gt;&quot;scrollTo(0,100000)&quot;);---------------------------------------------&lt;span&gt;向下拉到底
Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
js.executeScript(&lt;/span&gt;&quot;scrollTo(0,1)&quot;);--------------------------------------------------&lt;span&gt;向上拉到顶
Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
js.executeScript(&lt;/span&gt;&quot;scrollTo(0,1000)&quot;&lt;span&gt;);
Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
js.executeScript(&lt;/span&gt;&quot;scrollBy(0, 0-document.body.scrollHeight *1/2)&quot;);-----------------&lt;span&gt;拉到中间
Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
js.executeScript(&lt;/span&gt;&quot;scrollBy(0, 0-document.body.scrollWidht *1/2)&quot;);------------------左右拉到中间
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;23.41935483871&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;本文仅代表作者观点，系作者@温一壶清酒发表。转载请注明出处：&lt;a href=&quot;http://www.cnblogs.com/hong-fithing/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hong-fithing/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 04 Oct 2017 08:46:00 +0000</pubDate>
<dc:creator>温一壶清酒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hong-fithing/p/7625800.html</dc:identifier>
</item>
</channel>
</rss>