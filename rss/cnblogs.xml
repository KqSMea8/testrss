<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.Net Core SignalR 初体验 - 丶Pz</title>
<link>http://www.cnblogs.com/panzi/p/9649315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/panzi/p/9649315.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　Asp.Net SignalR已经出来很久了，但是一直没有静下心来好好看看。昨天花了几个小时的时间看了下。首先借鉴了官方文档，如何搭建一个SignalR的Demo。&lt;/p&gt;
&lt;p&gt;　　参考文章：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/signalr?view=aspnetcore-2.1&amp;amp;tabs=visual-studio&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/signalr?view=aspnetcore-2.1&amp;amp;tabs=visual-studio&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;　　SignalR地址：&lt;a href=&quot;https://github.com/aspnet/SignalR&quot; target=&quot;_blank&quot;&gt;https://github.com/aspnet/SignalR&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　所以为了快速搭建和体验.Net Core版本的SignalR，我选择了下载官方的Demo和参考官方给的教程。所以具体的搭建过程我就不再本文中写了。&lt;/p&gt;
&lt;h2&gt;体验效果&lt;/h2&gt;
&lt;p&gt;　　官网给出的DEMO运行如下图：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914223526794-466631285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击connect，查看一下network。可以发现，它在当前浏览器支持三种方式。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914223715706-28944197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而且和.NET Framework版本不同的是，新版SignalR中的Hub类型也是蛮丰富的。Demo中给出了 普通Hub，DynamicHub，Hub&amp;lt;T&amp;gt; 三种类型。我们去看看其中的区别吧。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;普通Hub&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;查看定义，可以看到普通Hub中的Clients类型是 &lt;strong&gt;IHubCallerClients &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
namespace Microsoft.AspNetCore.SignalR
{
    //
    // 摘要:
    //     A base class for a SignalR hub.
    public abstract class Hub : IDisposable
    {
        protected Hub();

        //
        // 摘要:
        //     Gets or sets an object that can be used to invoke methods on the clients connected
        //     to this hub.
        public IHubCallerClients Clients { get; set; }
        //
        // 摘要:
        //     Gets or sets the hub caller context.
        public HubCallerContext Context { get; set; }
        //
        // 摘要:
        //     Gets or sets the group manager.
        public IGroupManager Groups { get; set; }

        //
        public void Dispose();
        //
        // 摘要:
        //     Called when a new connection is established with the hub.
        //
        // 返回结果:
        //     A System.Threading.Tasks.Task that represents the asynchronous connect.
        public virtual Task OnConnectedAsync();
        //
        // 摘要:
        //     Called when a connection with the hub is terminated.
        //
        // 返回结果:
        //     A System.Threading.Tasks.Task that represents the asynchronous disconnect.
        public virtual Task OnDisconnectedAsync(Exception exception);
        //
        // 摘要:
        //     Releases all resources currently used by this Microsoft.AspNetCore.SignalR.Hub
        //     instance.
        //
        // 参数:
        //   disposing:
        //     true if this method is being invoked by the Microsoft.AspNetCore.SignalR.Hub.Dispose
        //     method, otherwise false.
        protected virtual void Dispose(bool disposing);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　IHubCallerClients 定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  public interface IHubCallerClients : IHubCallerClients&amp;lt;IClientProxy&amp;gt;, IHubClients&amp;lt;IClientProxy&amp;gt;
    {
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而框架又给IClientProxy增加了扩展方法：SendAsync&lt;/p&gt;
&lt;p&gt;　　所以在普通Hub中，定义客户端方法的时候，需要把方法名当作参数传入SendAsync方法中。例如如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public Task Send(string message)
        {
            return Clients.All.SendAsync(&quot;Receive&quot;, $&quot;{Context.ConnectionId}: {message}&quot;);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;DynamicHub&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;DynamicHub我是比较喜欢的，因为他和 Framework版的是一样（或者说看起来是一样的）的。动态Hub我们就可以不必拘泥于只能调用SendAsync方法了。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  public Task SendToOthers(string message)
        {
            return Clients.Others.ThisIsMyReceiveMethod($&quot;{Context.ConnectionId}: {message}&quot;);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　DynamicHub的Clients类型为：&lt;strong&gt;DynamicHubClients ，&lt;/strong&gt;它的内部变量全都是dynamic类型的。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914225214997-63517270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Hub&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;泛型Hub就把规约交给开发者制定。在Demo中 Hub&amp;lt;IChatClient&amp;gt; 中的IChatClient接口定义了Receive方法，因此Clients中的对象可以调用Receive方法。同理，我们可以根据业务需要定义自己的方法。至少从代码上看会显得更加通俗易懂一些。比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public interface IChatClient
    {
        Task Receive(string message);
        Task LoginSuccess(long userId);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
     public Task Login(long userId)
        {
            return Clients.Caller.LoginSuccess(userId);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实从代码上来看的话，他们都是Hub，只不过是不同的扩展实现而已。而泛型Hub不过是用户自定义泛型接口，而默认Hub中的默认泛型接口为：&lt;strong&gt;IClientProxy.&lt;/strong&gt;所以看到这里，如果我就想使用原生的Hub而又想自定义方法怎么办呢？很简单，加扩展就可以了。&lt;/p&gt;
&lt;p&gt;　　为什么自己加就可以呢，其实 SendAsync 就是扩展方法，它内部也是调用了SendCoreAsync方法。于是乎，写下自己的扩展方法，那这样子就很灵活了。我们把method参数去掉，直接写死试试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  public static Task LoginAsync(this IClientProxy clientProxy, string message, CancellationToken cancellationToken = default(CancellationToken))
        {
            return clientProxy.SendCoreAsync(&quot;LoginSuccess&quot;, new object[] { message}, cancellationToken);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实说白了，这个扩展方法还是需要传入method参数的，只不过封装了一层（似乎感觉这么做有意义吗？哈哈，还是老老实实用泛型吧），那么我们在去看Hub中的方法，修改Send方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  public Task Send(string message)
        {
            return Clients.All.LoginAsync($&quot;{Context.ConnectionId}: {message}&quot;);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　是不是这样子就实现了自己自定义方法了呢？个人觉得这么写还绕了一圈，不如用泛型或者Dynamic了。&lt;/p&gt;
&lt;p&gt;　　运行一下，看看效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914231333034-715982704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其实我也是抱着试试的态度，没想到还真是这样，和新方法就是SendCoreAsync，而其他方法只不过是上层封装使得代码更加通俗易懂。&lt;/p&gt;
&lt;h2&gt;使用Redis&lt;/h2&gt;
&lt;p&gt;　　Demo中的其他例子就不再演示了。广播，一对一，一对多，加入组，退出组等基本和之前一样。这里在演示一下使用Redis做不同实例之间的通信效果。&lt;/p&gt;
&lt;p&gt;　　首先程序集是不能少的：Microsoft.AspNetCore.SignalR.Redis，然后在Startup中补充代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914231827667-2057780583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开Redis客户端，使用MONITOR命令监听一下，从程序启动，到连接，在发送一条广播消息：hello redis。  redis 监听结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914232013627-257213017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以，PUB/SUB还是立了大功呢。&lt;/p&gt;
&lt;p&gt;　　这里用CMD运行了两个实例，端口分别为 8881，8882来模拟两个站点。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914232656753-561781680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　演示效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/841545/201809/841545-20180914232929976-158374628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　没问题的哦，其实仔细想想，虽然运行了两个网站实例，但是连接信息都保存在同一个Redis上，那肯定通信是木的问题的啦。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　只是简单的运行了一下DEMO，大致了解了一下 .Net Core SignalR的表层，至少跑Demo是跑起来了，并且使用Redis也是没有问题的。不过好像会出现运行一旦时间，程序自动停掉的问题，不知道是不是我电脑的问题。。今天就到这里吧，希望大家能有所收获。 本文代码地址：&lt;a href=&quot;https://github.com/fanpan26/LayIM.AspNetCore/tree/master/src/LayIM.AspNetCore.Demo/SignalRSamples&quot; target=&quot;_blank&quot;&gt;https://github.com/fanpan26/LayIM.AspNetCore/tree/master/src/LayIM.AspNetCore.Demo/SignalRSamples&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fanpan26/LayIM.AspNetCore/tree/master/src/LayIM.AspNetCore.Demo/SignalRSamples&quot; target=&quot;_blank&quot;&gt;　&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Sep 2018 15:35:00 +0000</pubDate>
<dc:creator>丶Pz</dc:creator>
<og:description>.NET CORE SignalR</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/panzi/p/9649315.html</dc:identifier>
</item>
<item>
<title>二叉搜索树 Rust实现 - 弱冠</title>
<link>http://www.cnblogs.com/kwebi/p/9649462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kwebi/p/9649462.html</guid>
<description>&lt;ul&gt;&lt;li&gt;二叉搜索树是一颗二叉树&lt;/li&gt;
&lt;li&gt;每个节点应该包含三个属性 &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt;, 根节点&lt;code&gt;p&lt;/code&gt;为&lt;code&gt;NIL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设x是二叉搜索树的一个节点, y是x左子树的一个节点, 那么&lt;code&gt;y.key &amp;lt;= x.key&lt;/code&gt;, 若y是x右子树的一个节点, 那么&lt;code&gt;y.key &amp;gt;= x.key&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;遍历&quot;&gt;遍历&lt;/h3&gt;
&lt;p&gt;遍历分前中后, 以根节点的遍历顺序而划分&lt;/p&gt;
&lt;p&gt;之前写过一篇二叉搜索树的, 用C语言实现, 可以参考一下&lt;a href=&quot;https://www.cnblogs.com/kwebi/p/9185594.html&quot;&gt;C语言实现&lt;/a&gt;&lt;br/&gt;感受一下区别&lt;/p&gt;
&lt;p&gt;以下是代码, 来源于&lt;a href=&quot;https://rustcc.gitbooks.io/rustprimer/content/data-structure/binary_tree.html&quot;&gt;RustPrimer&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;type TreeNode&amp;lt;K, V&amp;gt; = Option&amp;lt;Box&amp;lt;Node&amp;lt;K, V&amp;gt;&amp;gt;&amp;gt;;
#[derive(Debug)]
struct Node&amp;lt;K, V: std::fmt::Display&amp;gt; {
    left: TreeNode&amp;lt;K, V&amp;gt;,
    right: TreeNode&amp;lt;K, V&amp;gt;,
    key: K,
    value: V,
}
trait BinaryTree&amp;lt;K, V&amp;gt; {
    fn pre_order(&amp;amp;self);
    fn in_order(&amp;amp;self);
    fn pos_order(&amp;amp;self);
}
trait BinarySearchTree&amp;lt;K: PartialOrd, V&amp;gt;: BinaryTree&amp;lt;K, V&amp;gt; {
    fn insert(&amp;amp;mut self, key: K, value: V);
}
impl&amp;lt;K, V: std::fmt::Display&amp;gt; Node&amp;lt;K, V&amp;gt; {
    fn new(key: K, value: V) -&amp;gt; Self {
        Node {
            left: None,
            right: None,
            value: value,
            key: key,
        }
    }
}
impl&amp;lt;K: PartialOrd, V: std::fmt::Display&amp;gt; BinarySearchTree&amp;lt;K, V&amp;gt; for Node&amp;lt;K, V&amp;gt; {
    fn insert(&amp;amp;mut self, key: K, value: V) {
        if self.key &amp;lt; key {
            if let Some(ref mut right) = self.right {
                right.insert(key, value);
            } else {
                self.right = Some(Box::new(Node::new(key, value)));
            }
        } else {
            if let Some(ref mut left) = self.left {
                left.insert(key, value);
            } else {
                self.left = Some(Box::new(Node::new(key, value)));
            }
        }
    }
}
impl&amp;lt;K, V: std::fmt::Display&amp;gt; BinaryTree&amp;lt;K, V&amp;gt; for Node&amp;lt;K, V&amp;gt; {
    fn pre_order(&amp;amp;self) {
        println!(&quot;{}&quot;, self.value);

        if let Some(ref left) = self.left {
            left.pre_order();
        }
        if let Some(ref right) = self.right {
            right.pre_order();
        }
    }

    fn in_order(&amp;amp;self) {
        if let Some(ref left) = self.left {
            left.in_order();
        }
        println!(&quot;{}&quot;, self.value);
        if let Some(ref right) = self.right {
            right.in_order();
        }
    }
    fn pos_order(&amp;amp;self) {
        if let Some(ref left) = self.left {
            left.pos_order();
        }
        if let Some(ref right) = self.right {
            right.pos_order();
        }
        println!(&quot;{}&quot;, self.value);
    }
}

type BST&amp;lt;K, V&amp;gt; = Node&amp;lt;K, V&amp;gt;;

fn test_insert() {
    let mut root = BST::&amp;lt;i32, i32&amp;gt;::new(3, 4);
    root.insert(2, 3);
    root.insert(4, 6);
    root.insert(5, 5);
    root.insert(6, 6);
    root.insert(1, 8);
    if let Some(ref left) = root.left {
        assert_eq!(left.value, 3);
    }

    if let Some(ref right) = root.right {
        assert_eq!(right.value, 6);
        if let Some(ref right) = right.right {
            assert_eq!(right.value, 5);
        }
    }
    println!(&quot;Pre Order traversal&quot;);
    root.pre_order();
    println!(&quot;In Order traversal&quot;);
    root.in_order();
    println!(&quot;Pos Order traversal&quot;);
    root.pos_order();
}

fn main() {
    test_insert();
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 14 Sep 2018 15:22:00 +0000</pubDate>
<dc:creator>弱冠</dc:creator>
<og:description>二叉搜索树 + 二叉搜索树是一颗二叉树 + 每个节点应该包含三个属性 , , , 根节点 为`NIL` + 设x是二叉搜索树的一个节点, y是x左子树的一个节点, 那么 遍历 遍历分前中后, 以根节点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kwebi/p/9649462.html</dc:identifier>
</item>
<item>
<title>Spring系列(五) 容器初始化过程源码 - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/9649415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/9649415.html</guid>
<description>&lt;h2 id=&quot;iocdi-的概念&quot;&gt;IoC/DI 的概念&lt;/h2&gt;
&lt;p&gt;容器是Spring的核心之一(另一个核心是AOP). 有了容器, IOC才可能实现.&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;什么使IoC? IoC就是将类自身管理的与其由依赖关系的对象的创建/关联和管理交予容器实现, 容器按照配置(比如xml文件)来组织应用对象的创建和关联.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;什么使DI? DI是IoC的实现方式, 由容器在程序初始化的时候将类的依赖对象注入进去.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;IoC和DI的关系? IoC(Inversion of Control)是一种设计原则, 可以减少代码的耦合度, DI(Dependency Injection)是IOC的具体实现方式, 还有其他的实现方式如 DL(Dependency Lookup).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-容器&quot;&gt;Spring 容器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt;类应该都比较熟悉, 从熟悉的事物开始寻找线索.&lt;/p&gt;
&lt;p&gt;下载Spring源码后用idea打开, 找到类&lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt;, idea可以使用 &lt;code&gt;ctrl+N&lt;/code&gt; 输入类名搜索, 打开源文件, 按 &lt;code&gt;ctrl+Alt+U&lt;/code&gt; 可以生成类图.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794700/201809/794700-20180914230257650-1174502810.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt;和&lt;code&gt;ResourceLoader&lt;/code&gt;是两个顶层接口. &lt;code&gt;BeanFactory&lt;/code&gt;是Bean的工厂,定义了IoC基本的功能. &lt;code&gt;ResourceLoader&lt;/code&gt;是资源加载的策略接口,定义了加载资源的基本规范, &lt;code&gt;ApplicationContext&lt;/code&gt;需要此接口的功能.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt;提供了容器最基本的功能, 其中定义的方法会频繁使用, 接口定义如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanFactory {
    // 一个标记, 带有此标记开头的类不是bean, 而是工厂本身
    String FACTORY_BEAN_PREFIX = &quot;&amp;amp;&quot;;
    // 下面几个方法是各种获取bean的方式
    Object getBean(String name) throws BeansException;
    &amp;lt;T&amp;gt; T getBean(String name, @Nullable Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
    Object getBean(String name, Object... args) throws BeansException;
    &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
    &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType, Object... args) throws BeansException;
    // 判断bean是否存在
    boolean containsBean(String name);
    // bean作用域是否单例
    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
    // bean作用域是否原型
    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
    // bean是否与给定解析类型匹配
    boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
    boolean isTypeMatch(String name, @Nullable Class&amp;lt;?&amp;gt; typeToMatch) throws NoSuchBeanDefinitionException;
    // 获取bean类型
    @Nullable
    Class&amp;lt;?&amp;gt; getType(String name) throws NoSuchBeanDefinitionException;
    //获取bean别名数组
    String[] getAliases(String name);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt; 扩展了&lt;code&gt;BeanFactory&lt;/code&gt;的功能, 除了作为工厂外, 它还提供了消息国际化(&lt;code&gt;MessageSource&lt;/code&gt;), 获取环境bean(&lt;code&gt;EnvironmentCapable&lt;/code&gt;), 容器消息发布(&lt;code&gt;ApplicationEventPublisher&lt;/code&gt;)等功能. 因为它包含了容器以外的这些功能, 所以对了解容器来说多少会产生干扰. 事实上, 查看&lt;code&gt;BeanFactory&lt;/code&gt;的子类(在类图上选中类,或者在源代码视图中按&lt;code&gt;Ctrl+Alt+B&lt;/code&gt;)能从它的实现中找到&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;, 从名称上二者在继承该关系上应该比较近, 功能也比较纯粹, 没有类似ApplicationContext的其他干扰.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; 类是最基本的容器实现类, 它的继承关系如下图. 作为bean的工厂, 它的职责就是生产bean, 基本功能正是顶级接口&lt;code&gt;BeanFactory&lt;/code&gt;定义的那些方法. 它上级的接口扩展了自动装配的能力(&lt;code&gt;AutowireCapableBeanFactory&lt;/code&gt;), 注册和获取等操作&lt;code&gt;BeanDefinition&lt;/code&gt;实例的能力(&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794700/201809/794700-20180914230347312-962792398.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;beandefinition&quot;&gt;BeanDefinition&lt;/h2&gt;
&lt;p&gt;BeanDefinition 用来抽象bean定义在spring中的抽象, 最终spring将外部配置的bean转化为&lt;code&gt;BeanDefinition&lt;/code&gt;的实例存储.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794700/201809/794700-20180914230405534-1633823476.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;容器初始化过程&quot;&gt;容器初始化过程&lt;/h2&gt;
&lt;p&gt;容器初始化过程分为三步, 资源Resource定位, 解析加载, 注册.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;是工厂, 继承它的子类只有一个&lt;code&gt;XmlBeanFactory&lt;/code&gt;, 它被标注为&lt;code&gt;@Deprecated&lt;/code&gt;.所以不应该在应用中使用该类, 但它可以作为了解源码的入口. 它有个&lt;code&gt;XmlBeanDefinitionReader&lt;/code&gt;的私有变量直接new初始化, 参数this将工厂实例传给这个对象, 这样它就有了工厂的引用, 方便内部处理.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class XmlBeanFactory extends DefaultListableBeanFactory {

    private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);


    public XmlBeanFactory(Resource resource) throws BeansException {
        this(resource, null);
    }

    public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
        super(parentBeanFactory);
        // 这个是调用实际加载资源的方法
        this.reader.loadBeanDefinitions(resource);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大概串一下初始化的执行流程:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获得一个&lt;code&gt;Resource&lt;/code&gt;实例resource, 其实就是xml文件生成的输入流&lt;/li&gt;
&lt;li&gt;实例化&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;工厂beanFactory, 将resource作为构造参数传入&lt;/li&gt;
&lt;li&gt;beanFactory实例化, 生成&lt;code&gt;XmlBeanDefinitionReader&lt;/code&gt;的实例reader, 并将beanFactory的引用传递给他&lt;/li&gt;
&lt;li&gt;在beanFactory构造函数中调用reader的方法加载resource, 解析生成一系列&lt;code&gt;BeanDefinition&lt;/code&gt;的实例, 因为readere有工厂的实例, 所以这些实例可以注册到工厂中&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;加载xml-bean的关键代码&quot;&gt;加载XML Bean的关键代码&lt;/h2&gt;
&lt;p&gt;下面按照调用关系跟踪代码, 忽略其他的xml元素, 最终目标是找到加载注册bean的机制.&lt;/p&gt;
&lt;p&gt;XmlBeanDefinitionReader&lt;br/&gt;--&amp;gt; loadBeanDefinitions&lt;br/&gt;--&amp;gt; doLoadBeanDefinitions&lt;br/&gt;--&amp;gt; registerBeanDefinitions&lt;br/&gt;DefaultBeanDefinitionDocumentReader: BeanDefinitionDocumentReader&lt;br/&gt;--&amp;gt; registerBeanDefinitions&lt;br/&gt;--&amp;gt; doRegisterBeanDefinitions&lt;br/&gt;--&amp;gt; parseBeanDefinitions&lt;br/&gt;--&amp;gt; parseDefaultElement / processBeanDefinition&lt;br/&gt;BeanDefinitionParserDelegate&lt;br/&gt;--&amp;gt; parseBeanDefinitionElement&lt;br/&gt;BeanDefinitionReaderUtils&lt;br/&gt;--&amp;gt; registerBeanDefinition&lt;br/&gt;DetaultListableBeanFactory&lt;br/&gt;--&amp;gt; registerBeanDefinition&lt;/p&gt;
&lt;p&gt;一. &lt;code&gt;XmlBeanDefinitionReader.loadBeanDefinitions(EncodedResource encodedResource)&lt;/code&gt; 生成InputSource对象(用来初始化XML Dom对象)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;InputStream inputStream = encodedResource.getResource().getInputStream();
try {
    // 生成实例, 后面用来加载dom
    InputSource inputSource = new InputSource(inputStream);
    if (encodedResource.getEncoding() != null) {
        inputSource.setEncoding(encodedResource.getEncoding());
    }
    // 生成InputSource后,调用这个方法
    return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
}
finally {
    inputStream.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二. &lt;code&gt;XmlBeanDefinitionReader.doLoadBeanDefinitions(InputSource inputSource, Resource resource)&lt;/code&gt; 加载生成Xml Document对象&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 生成doc实例
Document doc = doLoadDocument(inputSource, resource);
return registerBeanDefinitions(doc, resource);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三. &lt;code&gt;XmlBeanDefinitionReader.registerBeanDefinitions(Document doc, Resource resource)&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 生成BeanDefinitionDocumentReader的实例, 默认实现为生成DefaultBeanDefinitionDocumentReader类的实例, 通过BeanUtil工具的实例化方法生成
BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
int countBefore = getRegistry().getBeanDefinitionCount();
// 传入doc和资源的上下文对象, 注册bean
documentReader.registerBeanDefinitions(doc, createReaderContext(resource));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;四. &lt;code&gt;registerBeanDefinitions(Document doc, XmlReaderContext readerContext)&lt;/code&gt; &lt;code&gt;BeanDefinitionDocumentReader&lt;/code&gt;是接口, 实现类为&lt;code&gt;DefaultBeanDefinitionDocumentReader&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    this.readerContext = readerContext;
    logger.debug(&quot;Loading bean definitions&quot;);
    // 获取根节点
    Element root = doc.getDocumentElement();
    // 从根节点开始, 调用的这个方法会递归子节点
    doRegisterBeanDefinitions(root);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;五. &lt;code&gt;doRegisterBeanDefinitions(Element root)&lt;/code&gt; 类为&lt;code&gt;DefaultBeanDefinitionDocumentReader&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void doRegisterBeanDefinitions(Element root) {
    //任何嵌套的&amp;lt;beans&amp;gt;元素都将导致此方法的递归。为了正确传播和保留&amp;lt;beans&amp;gt; default- *属性，请跟踪当前（父）委托，该委托可以为null。创建新的（子）委托，引用父项以进行回退，然后最终将this.delegate重置为其原始（父）引用。此行为模拟了一堆代理，而实际上并不需要一个代理。
    BeanDefinitionParserDelegate parent = this.delegate;
    this.delegate = createDelegate(getReaderContext(), root, parent);

    if (this.delegate.isDefaultNamespace(root)) {
        // 下面这一块代码主要是做profile检查, 没有启用profile的bean不加载, 将直接return
        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
        if (StringUtils.hasText(profileSpec)) {
            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
                if (logger.isInfoEnabled()) {
                    logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +
                            &quot;] not matching: &quot; + getReaderContext().getResource());
                }
                return;
            }
        }
    }

    preProcessXml(root);
    // 具体解析的方法, pre和post的在这个类中为空方法
    parseBeanDefinitions(root, this.delegate);
    postProcessXml(root);

    this.delegate = parent;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;六. &lt;code&gt;parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)&lt;/code&gt; 类为&lt;code&gt;DefaultBeanDefinitionDocumentReader&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* 解析文档中的根节点
* &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;.
*/
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    // 是根节点,就获取子节点, 遍历,如果是根&quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;, 就调用parseDefaultElement, 否则parseCustomElement
    if (delegate.isDefaultNamespace(root)) {
        NodeList nl = root.getChildNodes();
        for (int i = 0; i &amp;lt; nl.getLength(); i++) {
            Node node = nl.item(i);
            if (node instanceof Element) {
                Element ele = (Element) node;
                if (delegate.isDefaultNamespace(ele)) {
                    parseDefaultElement(ele, delegate);
                }
                else {
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    else {
        delegate.parseCustomElement(root);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;七. &lt;code&gt;parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)&lt;/code&gt; 类为&lt;code&gt;DefaultBeanDefinitionDocumentReader&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
            // 解析&quot;import&quot;元素, 这个方法会定位import的资源位置并重复第一步开始的步骤
            importBeanDefinitionResource(ele);
        }
        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
            // 别名&quot;alias&quot;注册
            processAliasRegistration(ele);
        }
        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
            // 前方高能... 处理bean元素
            processBeanDefinition(ele, delegate);
        }
        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
            // 递归&quot;beans&quot;
            doRegisterBeanDefinitions(ele);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;八. &lt;code&gt;processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)&lt;/code&gt; 类为&lt;code&gt;DefaultBeanDefinitionDocumentReader&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
*  处理bean元素的定义, 并且注册
*/
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    // 获取bean的包装对象,代码见第九步
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    if (bdHolder != null) {
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            // 注册最终的bean装饰对象
            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
                    bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
        }
        // Send registration event.
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;九. &lt;code&gt;parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean)&lt;/code&gt; 类为 &lt;code&gt;BeanDefinitionParserDelegate&lt;/code&gt; 关注两个实例化过程,一个是&lt;code&gt;BeanDefinition&lt;/code&gt;, 一个是其装饰对象&lt;code&gt;BeanDefinitionHolder&lt;/code&gt;的实例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* 解析bean元素, 可能会返回null, 如果有错误则报告给
* {@link org.springframework.beans.factory.parsing.ProblemReporter}.
*/
@Nullable
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
    String id = ele.getAttribute(ID_ATTRIBUTE);
    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

    List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;&amp;gt;();
    if (StringUtils.hasLength(nameAttr)) {
        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
        aliases.addAll(Arrays.asList(nameArr));
    }

    String beanName = id;
    if (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !aliases.isEmpty()) {
        beanName = aliases.remove(0);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;No XML 'id' specified - using '&quot; + beanName +
                    &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
        }
    }

    if (containingBean == null) {
        checkNameUniqueness(beanName, aliases, ele);
    }
    // 实例化一个 BeanDefination 实例
    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
    if (beanDefinition != null) {
        if (!StringUtils.hasText(beanName)) {
            try {
                if (containingBean != null) {
                    beanName = BeanDefinitionReaderUtils.generateBeanName(
                            beanDefinition, this.readerContext.getRegistry(), true);
                }
                else {
                    beanName = this.readerContext.generateBeanName(beanDefinition);
                    String beanClassName = beanDefinition.getBeanClassName();
                    if (beanClassName != null &amp;amp;&amp;amp;
                            beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp;
                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                        aliases.add(beanClassName);
                    }
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Neither XML 'id' nor 'name' specified - &quot; +
                            &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
                }
            }
            catch (Exception ex) {
                error(ex.getMessage(), ele);
                return null;
            }
        }
        String[] aliasesArray = StringUtils.toStringArray(aliases);
        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
    }

    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;十. &lt;code&gt;registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)&lt;/code&gt; 是类的静态方法&lt;code&gt;BeanDefinitionReaderUtils&lt;/code&gt; ;给registry对象调用&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 注册bean的最终方法
public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException {

    // 使用首要名称注册bean
    String beanName = definitionHolder.getBeanName();
    // 注册bean, 具体实现在类DetaultListableBeanFactory中
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // 注册bean的别名
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;十一. &lt;code&gt;registerBeanDefinition(String beanName, BeanDefinition beanDefinition)&lt;/code&gt; 在类&lt;code&gt;DetaultListableBeanFactory&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
        throws BeanDefinitionStoreException {
    ....

    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
    if (existingDefinition != null) {
        ....
        // 存到map里面
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        if (hasBeanCreationStarted()) {
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List&amp;lt;String&amp;gt; updatedDefinitions = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                if (this.manualSingletonNames.contains(beanName)) {
                    Set&amp;lt;String&amp;gt; updatedSingletons = new LinkedHashSet&amp;lt;&amp;gt;(this.manualSingletonNames);
                    updatedSingletons.remove(beanName);
                    this.manualSingletonNames = updatedSingletons;
                }
            }
        }
        else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            this.manualSingletonNames.remove(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }

    if (existingDefinition != null || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到目前为止, bean就注册到工厂里面去了, 实际上工厂里面保存了BeanDefinition的一个映射Map, 这样有助于Spring做一些验证, 当获取bean的时候也可以方便实现懒加载.&lt;/p&gt;
</description>
<pubDate>Fri, 14 Sep 2018 15:05:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>IoC/DI 的概念 容器是Spring的核心之一(另一个核心是AOP). 有了容器, IOC才可能实现. 什么使IoC? IoC就是将类自身管理的与其由依赖关系的对象的创建/关联和管理交予容器实现,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/9649415.html</dc:identifier>
</item>
<item>
<title>.NetCore实践篇：分布式监控系统zipkin踩坑之路（二） - 从此启程</title>
<link>http://www.cnblogs.com/fancunwei/p/9649192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9649192.html</guid>
<description>&lt;div id=&quot;main&quot; readability=&quot;118.07919847328&quot;&gt;
&lt;div id=&quot;mainContent&quot; readability=&quot;32.31221719457&quot;&gt;
&lt;div class=&quot;forFlow&quot; readability=&quot;8.5756327251324&quot;&gt;
&lt;div id=&quot;post_detail&quot; readability=&quot;34.625941136208&quot;&gt;
&lt;div id=&quot;topics&quot; readability=&quot;14.135802469136&quot;&gt;
&lt;div class=&quot;post&quot; readability=&quot;26.796341463415&quot;&gt;


&lt;div class=&quot;postBody&quot; readability=&quot;31.08064516129&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;58&quot;&gt;
&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;《牧神记》有一句话说的好，破心中神。当不再对分布式，微服务，CLR畏惧迷茫的时候，你就破了心中神。&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;zipkin复习&lt;/h2&gt;
&lt;p&gt;第一篇: &lt;a href=&quot;https://www.cnblogs.com/fancunwei/p/9625841.html&quot; title=&quot;.Net架构篇:思考如何设计一款实用的分布式监控系统？&quot;&gt;.Net架构篇:思考如何设计一款实用的分布式监控系统？&lt;/a&gt; &lt;/p&gt;

&lt;h4&gt;zipkin作用&lt;/h4&gt;

&lt;p&gt;全链路追踪工具（根据依赖关系）&lt;/p&gt;
&lt;p&gt;查看每个接口、每个service的执行速度（定位问题发生点或者寻找性能瓶颈）&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;zipkin工作原理&lt;/h4&gt;

&lt;p&gt;创造一些追踪标识符（tracingId，spanId，parentId），最终将一个request的流程树构建出来&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;zipkin架构&lt;/h4&gt;

&lt;p&gt;Collector接收各service传输的数据；&lt;/p&gt;
&lt;p&gt;Cassandra作为Storage的一种，默认存储在内存中，也支持ElasticSearch和mysql用于生产落库；&lt;/p&gt;
&lt;p&gt;Query负责查询Storage中存储的数据,提供简单的JSON API获取数据，主要提供给web UI使用；&lt;/p&gt;
&lt;p&gt;Web 提供简单的web界面；&lt;/p&gt;
&lt;/div&gt;
&lt;h5&gt;zipkin分布式跟踪系统的目的&lt;/h5&gt;

&lt;p&gt;zipkin为分布式链路调用监控系统，聚合各业务系统调用延迟数据，达到链路调用监控跟踪；&lt;/p&gt;
&lt;p&gt;zipkin通过采集跟踪数据可以帮助开发者深入了解在分布式系统中某一个特定的请求时如何执行的；&lt;/p&gt;
&lt;p&gt;参考如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kevingrace/p/5570258.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;zipkin参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zipkin.io/&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;zipkin官网&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;zipkin4net简介&lt;/h2&gt;

&lt;p&gt;zipkin4net是.NET客户端库。&lt;/p&gt;
&lt;p&gt;它为您提供：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Zipkin 原语（跨度，注释，二进制注释，......）【Zipkin primitives (spans, annotations, binary annotations, ...)】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步跟踪发送&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟踪传输抽象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4&gt;简单用法&lt;/h4&gt;

&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; logger = CreateLogger(); 
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; sender = CreateYourTransport(); 
TraceManager.SamplingRate = &lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;f; 
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; tracer = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ZipkinTracer(sender);
TraceManager.RegisterTracer(tracer);
TraceManager.Start(logger);


TraceManager.Stop();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简介到此为止，剩余您可参考&lt;a href=&quot;https://github.com/openzipkin/zipkin4net&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;zipkin4net&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Show me the Code&lt;/h2&gt;

&lt;p&gt;废话少说，一杯代码为敬。&lt;/p&gt;
&lt;p&gt;进入代码之前，我先来演示下代码结构。这个结构对应我之前的代码实践。内存队列，爬虫在我的博客内都能找到博客对应。&lt;/p&gt;
&lt;br/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;400&quot; data-height=&quot;444&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-062d3b5f6243c4f4.png&quot; data-original-width=&quot;400&quot; data-original-height=&quot;444&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;26963&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-062d3b5f6243c4f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;演示结构图&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;今天我们只说zipkin4Net的实践。为了测试查看zipkin是否能够汇集不同的站点,我特意建立了两个站点Demo.ZipKinWeb和Demo.ZipKinWeb2。类似下图：&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;image-container&quot; readability=&quot;7&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;642&quot; data-height=&quot;138&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-51a77a199069b15e.png&quot; data-original-width=&quot;642&quot; data-original-height=&quot;138&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;16262&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-51a77a199069b15e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;为了能真实落库，我创建了FanQuick.Repository,用于提供mongodb存储帮助。IRepository泛型接口声明如下&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; FanQuick.Repository
{
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; interface IRepository&amp;lt;TDocument&amp;gt; where TDocument:EntityBase
{
IQueryable&amp;lt;TDocument&amp;gt; Queryable { get; }
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Expression&amp;lt;Func&amp;lt;TDocument, &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; filter)&lt;/span&gt;&lt;/span&gt;;





&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Delete&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Expression&amp;lt;Func&amp;lt;TDocument, &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; filter)&lt;/span&gt;&lt;/span&gt;;





IEnumerable&amp;lt;TDocument&amp;gt; Find(Expression&amp;lt;Func&amp;lt;TDocument, &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; filter);




&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(TDocument document)&lt;/span&gt;&lt;/span&gt;;




&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IEnumerable&amp;lt;TDocument&amp;gt; documents)&lt;/span&gt;&lt;/span&gt;;





&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Expression&amp;lt;Func&amp;lt;TDocument, &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; filter)&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;hljs-function&quot;&gt;TDocument &lt;span class=&quot;hljs-title&quot;&gt;FindOneAndDelete&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Expression&amp;lt;Func&amp;lt;TDocument, &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; filter)&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;hljs-function&quot;&gt;TDocument &lt;span class=&quot;hljs-title&quot;&gt;FindOneAndUpdate&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(FilterDefinition&amp;lt;TDocument&amp;gt; filter, UpdateDefinition&amp;lt;TDocument&amp;gt; update)&lt;/span&gt;&lt;/span&gt;;
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了两个站点能够复用调用zipkin4net的通知，我将代码抽离出来放到了 Demo.ZipkinCommon。&lt;br/&gt;可复用的抽象类CommonStartUp，代码如下：重点关注下调用zipkin4net的代码。并将抽象Run方法暴漏给了子类，需要子类实现。要特别注意，appsettings.json需要设置&lt;span&gt;applicationName&lt;/span&gt;,不然发送到zipkin就是未命名服务，这就不能区分站点了!&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;namespace Demo.ZipkinCommon
{
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CommonStartup&lt;/span&gt;
&lt;/span&gt;{


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IServiceCollection services)&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)&lt;/span&gt;
&lt;/span&gt;{
var config = ConfigureSettings.CreateConfiguration();
var applicationName = config[&lt;span class=&quot;hljs-string&quot;&gt;&quot;applicationName&quot;&lt;/span&gt;];









var lifetime = app.ApplicationServices.GetService&amp;lt;IApplicationLifetime&amp;gt;();
lifetime.ApplicationStarted.Register(() =&amp;gt;
{
TraceManager.SamplingRate = &lt;span class=&quot;hljs-number&quot;&gt;1.0f&lt;/span&gt;;
var logger = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TracingLogger(loggerFactory, &lt;span class=&quot;hljs-string&quot;&gt;&quot;zipkin4net&quot;&lt;/span&gt;);
var httpSender = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HttpZipkinSender(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://weixinhe.cn:9411&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/json&quot;&lt;/span&gt;);
var tracer = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ZipkinTracer(httpSender, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; JSONSpanSerializer());
TraceManager.RegisterTracer(tracer);
TraceManager.Start(logger);
});
lifetime.ApplicationStopped.Register(() =&amp;gt; TraceManager.Stop());
app.UseTracing(applicationName);
Run(app, config);
}
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app, IConfiguration configuration)&lt;/span&gt;&lt;/span&gt;;
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读取配置类，也独立了出来，可支持读取appsettings.json，&lt;span&gt;每个站点需要把appsettings.json设置允许复制&lt;/span&gt;，不然会找不到文件！！&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; Demo.ZipkinCommon
{
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConfigureSettings&lt;/span&gt;
{&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; IConfiguration &lt;span class=&quot;hljs-title&quot;&gt;CreateConfiguration&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;
&lt;/span&gt;{
var builder = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ConfigurationBuilder()
.AddJsonFile(&lt;span class=&quot;hljs-string&quot;&gt;&quot;appsettings.json&quot;&lt;/span&gt;, optional: &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;, reloadOnChange: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)
.AddEnvironmentVariables();
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; builder.Build();
}
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;公用部分完成了。我们看看站点Demo.ZipKinWeb代码。Startup继承抽象类CommonStartup，并利用.netCore内置依赖注入，将Service和仓储注入进来。由于不支持直接注入泛型，但支持type类型的注入，间接也解决了泛型注入问题。关于依赖注入的讲解，你可以参考上篇文中依赖注入部分，加深理解。&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; Demo.ZipKinWeb
{
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Startup&lt;/span&gt; :&lt;/span&gt; CommonStartup
{
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Startup&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IConfiguration configuration)&lt;/span&gt;
&lt;/span&gt;{
Configuration = configuration;
}
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; IConfiguration Configuration { get; }
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; override &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IServiceCollection services)&lt;/span&gt;
&lt;/span&gt;{
services.Configure&amp;lt;CookiePolicyOptions&amp;gt;(options =&amp;gt;
{

options.CheckConsentNeeded = context =&amp;gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;
options.MinimumSameSitePolicy = SameSiteMode.None;
});
services.AddScoped(typeof(IRepository&amp;lt;&amp;gt;), typeof(BaseRepository&amp;lt;&amp;gt;));
services.AddScoped&amp;lt;IUserService, UserService&amp;gt;();
services.AddScoped&amp;lt;IAddressService, AddressService&amp;gt;();
services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
}
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; override &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IApplicationBuilder app, IConfiguration configuration)&lt;/span&gt;
&lt;/span&gt;{
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseCookiePolicy();
app.UseMvc(routes =&amp;gt;
{
routes.MapRoute(
name: &lt;span class=&quot;hljs-string&quot;&gt;&quot;default&quot;&lt;/span&gt;,
&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;{controller=Home}/{action=Index}/{id?}&quot;&lt;/span&gt;);
});
}
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了实现聚合两个站点的效果，在Add的方法内，特意调用一下另外个站点的get&lt;/p&gt;
&lt;pre class=&quot;hljs php&quot;&gt;
&lt;code class=&quot;php&quot;&gt; [HttpPost]
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; IActionResult Add([FromBody]User user)
{
_userService.AddUser(user);

&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; client = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; RestClient($&lt;span class=&quot;hljs-string&quot;&gt;&quot;{ConfigEx.WebSite}&quot;&lt;/span&gt;);
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; request = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; RestRequest($&lt;span class=&quot;hljs-string&quot;&gt;&quot;/user/get&quot;&lt;/span&gt;, Method.POST);
request.AddParameter(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;, user.Id); 
IRestResponse response = client.Execute(request);
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; content = response.Content;

&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Content(content+_addressService.Test());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建好必要的Controller和Action后，将两个站点都设为已启动。就可以查看效果了。&lt;br/&gt;postman是个测试接口的好工具，点击Send。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;710&quot; data-height=&quot;403&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-52c5045a738d73b7.png&quot; data-original-width=&quot;710&quot; data-original-height=&quot;403&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;27919&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-52c5045a738d73b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/710/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;postman接口测试&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;打开我们的zipkin服务器链接，在WebUI上，可以看到两条请求数据。这是正确的，一条是Add,里面又调了另外一个站点的get,也能看到消耗的时间。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;778&quot; data-height=&quot;567&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-bed01fda6fc38fe0.png&quot; data-original-width=&quot;778&quot; data-original-height=&quot;567&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;29868&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-bed01fda6fc38fe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/778/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;span&gt;&lt;span&gt;监测数据&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;span&gt;点击去查看详情，我们能看到更多数据。&lt;/span&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;806&quot; data-height=&quot;627&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-4daef21a3ea31540.png&quot; data-original-width=&quot;806&quot; data-original-height=&quot;627&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;47349&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-4daef21a3ea31540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/806/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;请求详情&lt;/p&gt;
&lt;/div&gt;
&lt;span&gt;然后继续点击 菜单中的&lt;/span&gt;&lt;span&gt;Dependencies&lt;/span&gt;&lt;span&gt;，确发现是空值，按道理来讲，请求了两个站点，又访问了数据库。怎么会是空值呢？？？&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1177&quot; data-height=&quot;223&quot;&gt;&lt;img data-original-src=&quot;//upload-images.jianshu.io/upload_images/7234228-7d8bc31cd0cdc510.png&quot; data-original-width=&quot;1177&quot; data-original-height=&quot;223&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;19549&quot; class=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/7234228-7d8bc31cd0cdc510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;依赖&lt;/p&gt;
&lt;/div&gt;
&lt;span&gt;这个时候，我只能又求助bing了。&lt;/span&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;zipkin Dependencies no data&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;果然网友是万能的。&lt;a href=&quot;https://github.com/openzipkin/zipkin/issues/2016&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;elasticsearch存储,zipkin依赖没有数据&lt;/a&gt;&lt;br/&gt;里面有位外国同仁提到了&lt;/p&gt;
&lt;blockquote readability=&quot;4.4845360824742&quot;&gt;
&lt;p&gt;当你用你elasticsearch 或 Cassandra的时候，需要执行zipkin-dependencies&lt;br/&gt;（you need to run &lt;a href=&quot;https://github.com/openzipkin/zipkin-dependencies&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;https://github.com/openzipkin/zipkin-dependencies&lt;/a&gt; when using elasticsearch or Cassandra）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;p&gt;这是一个Spark作业，它将从您的数据存储区收集跨度，分析服务之间的链接，并存储它们以供以后在&lt;a href=&quot;https://github.com/openzipkin/zipkin/tree/master/zipkin-ui&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Web UI中&lt;/a&gt;呈现（例如&lt;a href=&quot;http://localhost:8080/dependency&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8080/dependency&lt;/a&gt;)。&lt;br/&gt;什么是Spark?&lt;br/&gt;Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎。&lt;/p&gt;&lt;p&gt;此作业以UTC时间分析当天的所有跟踪。这意味着您应该将其安排在UTC午夜之前运行。&lt;/p&gt;&lt;p&gt;&lt;span&gt;这真是一个弱鸡的设计，作为内存运行的演示，竟然不提供及时汇总分析，还要跑定时任务&lt;/span&gt;&lt;br/&gt;依据官方提示，按最快的方式进行。&lt;/p&gt;</description>
<pubDate>Fri, 14 Sep 2018 13:57:00 +0000</pubDate>
<dc:creator>从此启程</dc:creator>
<og:description>前言 《牧神记》有一句话说的好，破心中神。当不再对分布式，微服务，CLR畏惧迷茫的时候，你就破了心中神。 《牧神记》有一句话说的好，破心中神。当不再对分布式，微服务，CLR畏惧迷茫的时候，你就破了心中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9649192.html</dc:identifier>
</item>
<item>
<title>Plasma Cash合约解读 - baizx</title>
<link>http://www.cnblogs.com/baizx/p/9649153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baizx/p/9649153.html</guid>
<description>&lt;p&gt;每条 Plasma 链都会将有关交易顺序的消息换算成一个哈希值存储在根链上。比特币和以太坊都属于根链——这两条区块链具有很高的安全性，并且通过去中心化保证了（安全性和活性）。&lt;/p&gt;
&lt;p&gt;Plasma 设计模型有两个主要的分支：Plasma MVP 和 Plasma Cash 。这里我们来研究 SmartPlasma 实现的 Plasma Cash 合约,并通过合约分析来回答大家关于 Plasma Cash 的一系列疑问.&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;1. 合约代码&lt;/h2&gt;
&lt;p&gt;SmartPlasma的合约代码肯定会不断升级,我针对他们在今天(2018-09-14)最新版本进行分析,这份代码目前保存在我的 github 上 &lt;a href=&quot;https://github.com/nkbai/blog/tree/master/smartplasma/contracts&quot;&gt;plasma cash&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;2. 合约文件简单介绍&lt;/h2&gt;
&lt;p&gt;文件夹中有不少与 Plasma Cash 无关的合约,这里只关注直接与 Plasma Cash 相关合约,像 ERC20Token 相关合约就忽略,自行查看.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Mediator.sol 是 Plasma Cash 链中资产的进出口&lt;/li&gt;
&lt;li&gt;RootChain.sol 处理 Plasma Cash 子链(相对于以太坊而言)中的交易以及打包等&lt;/li&gt;
&lt;li&gt;libraries/MerkleProof.sol 是子链中交易用到的默克尔树,用于子链参与方进行欺诈证明 fraud proof.&lt;/li&gt;
&lt;li&gt;libraris/RLP.sol RLP编码支持,可以暂时忽略,子链中所有的交易都是用RLP 编码的.&lt;/li&gt;
&lt;li&gt;libraries/PlasmaLib.sol 生成 uid 的辅助函数&lt;/li&gt;
&lt;li&gt;ECRecovery.sol 签名验证&lt;/li&gt;
&lt;li&gt;datastructures/Transaction.sol 描述交易的数据结构&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;plasma-cash-1&quot;&gt;3. Plasma Cash 的基础数据结构&lt;/h2&gt;
&lt;p&gt;Plasma Cash 是一种子链结构,可以认为 Plasma Cash 是以太坊的一个是基于 =一种简化的UTXO模型的子链.&lt;/p&gt;
&lt;h3 id=&quot;plasma-cash-2&quot;&gt;3.1 Plasma Cash 中的资产&lt;/h3&gt;
&lt;p&gt;Plasma Cash 中的资产都来自于以太坊,但是一旦进入 Plasma Cash 就会拥有唯一的 ID,并且不可分割. 可以参考 &lt;a href=&quot;https://github.com/nkbai/blog/blob/master/smartplasma/contracts/Mediator.sol&quot;&gt;Mediator.sol&lt;/a&gt;的deposit函数. Mediator就是 Plasma Cash 资产存放的地方.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt;        /** @dev Adds deposits on Smart Plasma.
     *  @param currency Currency address.
     *  @param amount Amount amount of currency.
     */
    function deposit(address currency, uint amount) public {
        require(amount &amp;gt; 0);

        Token token = Token(currency);
        token.transferFrom(msg.sender, this, amount); /// deposit test1

        bytes32 uid = rootChain.deposit(msg.sender, currency, amount); /// deposit test2
        cash[uid] = entry({
            currency: currency,
            amount: amount
        });
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过合约可以看出进入 Plasma Cash 的资产必须是 ERC20 Token,这些资产实际上是存在 Mediator 这个合约上,然后由 RootChain 为其分配一个唯一的 ID, 也就是 uid. 这个 uid 代表着什么 token, 有多少个.&lt;/p&gt;
&lt;h3 id=&quot;plasma-cash-3&quot;&gt;3.2 Plasma Cash中的交易&lt;/h3&gt;
&lt;p&gt;关键代码在 &lt;a href=&quot;https://github.com/nkbai/blog/blob/master/smartplasma/contracts/libraries/datastructures/Transaction.sol&quot;&gt;Transaction.sol&lt;/a&gt;中.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt;    struct Tx {
        uint prevBlock;
        uint uid;
        uint amount;
        address newOwner;
        uint nonce;
        address signer;
        bytes32 hash;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可能不太明显,需要解释才能看出来这是一个 UTXO 交易的模型. 这里面的amount 和 hash 实际上都有点啰唆,可以忽略. 那么剩下的成员需要来解释.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;prevBlock&lt;/code&gt;就是 UTXO 中的输入,来自于哪块. 至于为什么没有像比特币一样的OutPoint 结构,也就是 TxHash+Index, 后续会讲到. &lt;code&gt;uid&lt;/code&gt; 就是交易的资产 ID &lt;code&gt;newOwner&lt;/code&gt; 交易输出给谁, 这里也不支持像 比特币一样的脚本. &lt;code&gt;nonce&lt;/code&gt; 是这笔资产的第多少次交易,在双花证明中有重要作用. &lt;code&gt;signer&lt;/code&gt;必须由资产原拥有者的签名.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;amount&lt;/code&gt; 不重要,是因为资产不可分割,导致这里的 Amount 不会随交易发生而发生变化. 而 &lt;code&gt;hash&lt;/code&gt; 则是可以直接计算出来.&lt;/p&gt;
&lt;h3 id=&quot;plasma-cash-block&quot;&gt;3.3 Plasma Cash 中的 Block&lt;/h3&gt;
&lt;p&gt;如果一般区块链中的 Block 一样,他是交易的集合.但是不同于一般链的是,这里面的矿工(不一定是 Operator)不仅需要维护好子链,还需要周期性的将每一个 Block 对应的默克尔树根保存到以太坊中,这个工作只能有 Operator 来完成. 具体代码可见 &lt;a href=&quot;https://github.com/nkbai/blog/blob/master/smartplasma/contracts/RootChain.sol&quot;&gt;RootChain.sol&lt;/a&gt;的.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt;    function newBlock(bytes32 hash) public onlyOperator {
        blockNumber = blockNumber.add(uint256(1));
        childChain[blockNumber] = hash;

        NewBlock(hash);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;交易证据提交者只能是 Operator, 也就是合约的创建者. 这个 Operator 既可以是普通账户,这时他就是这个子链的管理员.也可以是一份合约,那么就可以通过合约来规定子链的出块规则.&lt;/p&gt;
&lt;h3 id=&quot;plasma-cash-4&quot;&gt;3.4 Plasma Cash 中资产的回归主链以太坊&lt;/h3&gt;
&lt;p&gt;当资产在 Plasma 中交易一段时间以后,持有者Bob如果想退出Plasma Cash 子链,那么就需要向以太坊合约也就是 RootChain证明,他确实拥有这一笔资产.&lt;/p&gt;
&lt;h4 id=&quot;section-2&quot;&gt;3.4.1 资产拥有证明&lt;/h4&gt;
&lt;p&gt;这个思路和 UTXO 的思路是一样的,Bob能证明这笔资产是从哪里转给我的即可.具体见&lt;a href=&quot;http://www.cnblogs.com/baizx/p/9649153.html&quot;&gt;RootChain.sol&lt;/a&gt;中的&lt;code&gt;startExit&lt;/code&gt;函数. 其思路非常简单,证明&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这笔资产来自哪里(在哪 M块中转移到了 Alice 手中)&lt;/li&gt;
&lt;li&gt;经过 Alice 签名转移给了Bob(在N块中 Alice 做了签名给我) 具体看代码 startExit&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt;/** @dev Starts the procedure for withdrawal of the deposit from the system.
     *  @param previousTx Penultimate deposit transaction.
     *  @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block.
     *  @param previousTxBlockNum The number of the block in which the penultimate transaction is included.
     *  @param lastTx Last deposit transaction.
     *  @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block.
     *  @param lastTxBlockNum The number of the block in which the last transaction is included.
     */
    function startExit(
        bytes previousTx,
        bytes previousTxProof,
        uint256 previousTxBlockNum,
        bytes lastTx,
        bytes lastTxProof,
        uint256 lastTxBlockNum
    )
        public
    {
        Transaction.Tx memory prevDecodedTx = previousTx.createTx();
        Transaction.Tx memory decodedTx = lastTx.createTx();
        // 证明在 prevBlock的时候 Alice 拥有资产 uid
        require(previousTxBlockNum == decodedTx.prevBlock);
        require(prevDecodedTx.uid == decodedTx.uid);
        //amount 不变,证明资产不可分割
        require(prevDecodedTx.amount == decodedTx.amount);
        //Alice 确实签名转移给了我,并且交易是相邻的两笔交易
        require(prevDecodedTx.newOwner == decodedTx.signer);
        require(decodedTx.nonce == prevDecodedTx.nonce.add(uint256(1))); //紧挨着的两笔交易
        //我是 Bob, 我要来拿走这笔资产
        require(msg.sender == decodedTx.newOwner);
        require(wallet[bytes32(decodedTx.uid)] != 0);

        bytes32 prevTxHash = prevDecodedTx.hash;
        bytes32 prevBlockRoot = childChain[previousTxBlockNum];
        bytes32 txHash = decodedTx.hash;
        bytes32 blockRoot = childChain[lastTxBlockNum];

        require(
            prevTxHash.verifyProof(
                prevDecodedTx.uid,
                prevBlockRoot,
                previousTxProof
            )
        );
        require(
            txHash.verifyProof(
                decodedTx.uid,
                blockRoot,
                lastTxProof
            )
        );

        /// Record the exit tx.
        require(exits[decodedTx.uid].state == 0);
        require(challengesLength(decodedTx.uid) == 0);

        exits[decodedTx.uid] = exit({
            state: 2,
            exitTime: now.add(challengePeriod),
            exitTxBlkNum: lastTxBlockNum,
            exitTx: lastTx,
            txBeforeExitTxBlkNum: previousTxBlockNum,
            txBeforeExitTx: previousTx
        });

        StartExit(prevDecodedTx.uid, previousTxBlockNum, lastTxBlockNum);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码的前一半都是在用来证明在&lt;code&gt;lastTxBlockNum&lt;/code&gt;的时候,资产 uid 归Bob所有. 然后后一半就是提出来,Bob想把资产 uid 提走. 我的这个想法会暂时保存在合约中,等待别人来挑战.&lt;/p&gt;
&lt;h4 id=&quot;section-3&quot;&gt;3.4.2 等待其他人来挑战我&lt;/h4&gt;
&lt;p&gt;有了以上信息, 就可以证明在 N 块时,这笔资产归Bob所用.但是这肯定不够,无法证明现在资产仍然属于Bob,也无法证明Alice 没有在 M 块以后再给别人. 更加不能证明在 M 块的时候 Alice 真的是 uid 的拥有者? 这些问题,看起来很难回答,其实思路也很简单. 这个思路和雷电网络中解决问题的办法是一样的, 让这笔资产的利益攸关者站出来举证. 比如: 如果 Carol能够举证这笔资产Bob 后来又转移给了 Carol, 那么实际上 Bob 就是在双花. 具体的挑战以及迎战代码比较复杂,但是这也是 Plasma Cash 的核心安全性所在.如果没有这些,所有的参与者都将无法保证自己的权益.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//challengeExit 挑战资产uid 其实不属于 Bob
  /** @dev Challenges a exit.
     *  @param uid Unique identifier of a deposit.
     *  @param challengeTx Transaction that disputes an exit.
     *  @param proof Proof of inclusion of the transaction in a Smart Plasma block.
     *  @param challengeBlockNum The number of the block in which the transaction is included.
     */
    function challengeExit(
        uint256 uid,
        bytes challengeTx,
        bytes proof,
        uint256 challengeBlockNum
    )
        public
    {
        require(exits[uid].state == 2);

        Transaction.Tx memory exitDecodedTx = (exits[uid].exitTx).createTx();
        Transaction.Tx memory beforeExitDecodedTx = (exits[uid].txBeforeExitTx).createTx();
        Transaction.Tx memory challengeDecodedTx = challengeTx.createTx();

        require(exitDecodedTx.uid == challengeDecodedTx.uid);
        require(exitDecodedTx.amount == challengeDecodedTx.amount);

        bytes32 txHash = challengeDecodedTx.hash;
        bytes32 blockRoot = childChain[challengeBlockNum];

        require(txHash.verifyProof(uid, blockRoot, proof));

        // test challenge #1 &amp;amp; test challenge #2 最后一笔交易后面又进行了其他交易, Bob 在进行双花
        if (exitDecodedTx.newOwner == challengeDecodedTx.signer &amp;amp;&amp;amp;
        exitDecodedTx.nonce &amp;lt; challengeDecodedTx.nonce) {
            delete exits[uid];
            return;
        }

        // test challenge #3, 双花了,  Alice 给了两个人,并且挑战者 Carol的BlockNumer 更小,也就是发生的更早.
        if (challengeBlockNum &amp;lt; exits[uid].exitTxBlkNum &amp;amp;&amp;amp;
            (beforeExitDecodedTx.newOwner == challengeDecodedTx.signer &amp;amp;&amp;amp;
            challengeDecodedTx.nonce &amp;gt; beforeExitDecodedTx.nonce)) {
            delete exits[uid];
            return;
        }

        // test challenge #4   在 M块之前,还有一笔交易,Alice 需要证明自己在 M 块确实拥有 uid
        if (challengeBlockNum &amp;lt; exits[uid].txBeforeExitTxBlkNum ) {
            exits[uid].state = 1;
            addChallenge(uid, challengeTx, challengeBlockNum);
        }

        require(exits[uid].state == 1);

        ChallengeExit(uid);
    }

//Bob应战,再次举证,实际上这个过程就是要不断的追加证据,将所有的交易连起来,最终证明 Alice 在 M块确实拥有 uid
 /** @dev Answers a challenge exit.
     *  @param uid Unique identifier of a deposit.
     *  @param challengeTx Transaction that disputes an exit.
     *  @param respondTx Transaction that answers to a dispute transaction.
     *  @param proof Proof of inclusion of the respond transaction in a Smart Plasma block.
     *  @param blockNum The number of the block in which the respond transaction is included.
     */
    function respondChallengeExit(
        uint256 uid,
        bytes challengeTx,
        bytes respondTx,
        bytes proof,
        uint blockNum
    )
        public
    {
        require(challengeExists(uid, challengeTx));
        require(exits[uid].state == 1);

        Transaction.Tx memory challengeDecodedTx = challengeTx.createTx();
        Transaction.Tx memory respondDecodedTx = respondTx.createTx();

        require(challengeDecodedTx.uid == respondDecodedTx.uid);
        require(challengeDecodedTx.amount == respondDecodedTx.amount);
        require(challengeDecodedTx.newOwner == respondDecodedTx.signer);
        require(challengeDecodedTx.nonce.add(uint256(1)) == respondDecodedTx.nonce);
        require(blockNum &amp;lt; exits[uid].txBeforeExitTxBlkNum);

        bytes32 txHash = respondDecodedTx.hash;
        bytes32 blockRoot = childChain[blockNum];

        require(txHash.verifyProof(uid, blockRoot, proof));

        removeChallenge(uid, challengeTx);

        if (challengesLength(uid) == 0) {
            exits[uid].state = 2;
        }

        RespondChallengeExit(uid);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;bob-uid&quot;&gt;3.4.3 挑战期过了, Bob 拿回资产 uid&lt;/h4&gt;
&lt;p&gt;挑战期过后,Bob 在Mediator.sol 中提出将资产退回到以太坊中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt; /** @dev withdraws deposit from Smart Plasma.
     *  @param prevTx Penultimate deposit transaction.
     *  @param prevTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block.
     *  @param prevTxBlkNum The number of the block in which the penultimate transaction is included.
     *  @param txRaw lastTx Last deposit transaction.
     *  @param txProof Proof of inclusion of a last transaction in a Smart Plasma block.
     *  @param txBlkNum The number of the block in which the last transaction is included.
     */
    function withdraw(
        bytes prevTx,
        bytes prevTxProof,
        uint prevTxBlkNum,
        bytes txRaw,
        bytes txProof,
        uint txBlkNum
    )
        public
    {
        bytes32 uid = rootChain.finishExit(
            msg.sender,
            prevTx,
            prevTxProof,
            prevTxBlkNum,
            txRaw,
            txProof,
            txBlkNum
        );

        entry invoice = cash[uid];

        Token token = Token(invoice.currency);
        token.transfer(msg.sender, invoice.amount); /// 真正的资产转移

        delete(cash[uid]); 
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RootChain 再次验证&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-solidity&quot;&gt; /** @dev Finishes the procedure for withdrawal of the deposit from the system.
     *       Can only call the owner. Usually the owner is the mediator contract.
     *  @param account Account that initialized the deposit withdrawal.
     *  @param previousTx Penultimate deposit transaction.
     *  @param previousTxProof Proof of inclusion of a penultimate transaction in a Smart Plasma block.
     *  @param previousTxBlockNum The number of the block in which the penultimate transaction is included.
     *  @param lastTx Last deposit transaction.
     *  @param lastTxProof Proof of inclusion of a last transaction in a Smart Plasma block.
     *  @param lastTxBlockNum The number of the block in which the last transaction is included.
     */
    function finishExit(
        address account,
        bytes previousTx,
        bytes previousTxProof,
        uint256 previousTxBlockNum,
        bytes lastTx,
        bytes lastTxProof,
        uint256 lastTxBlockNum
    )
        public
        onlyOwner
        returns (bytes32)
    {
        Transaction.Tx memory prevDecodedTx = previousTx.createTx();
        Transaction.Tx memory decodedTx = lastTx.createTx();

        require(previousTxBlockNum == decodedTx.prevBlock);
        require(prevDecodedTx.uid == decodedTx.uid);
        require(prevDecodedTx.amount == decodedTx.amount);
        require(prevDecodedTx.newOwner == decodedTx.signer);
        require(account == decodedTx.newOwner);

        bytes32 prevTxHash = prevDecodedTx.hash;
        bytes32 prevBlockRoot = childChain[previousTxBlockNum];
        bytes32 txHash = decodedTx.hash;
        bytes32 blockRoot = childChain[lastTxBlockNum];

        require(
            prevTxHash.verifyProof(
                prevDecodedTx.uid,
                prevBlockRoot,
                previousTxProof
            )
        );

        require(
            txHash.verifyProof(
                decodedTx.uid,
                blockRoot,
                lastTxProof
            )
        );

        require(exits[decodedTx.uid].exitTime &amp;lt; now); //挑战期过了
        require(exits[decodedTx.uid].state == 2); //并且没有人挑战或者我都给出了合适的证据
        require(challengesLength(decodedTx.uid) == 0);

        exits[decodedTx.uid].state = 3;

        delete(wallet[bytes32(decodedTx.uid)]);

        FinishExit(decodedTx.uid);

        return bytes32(decodedTx.uid);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;plasma-cash-5&quot;&gt;4. Plasma Cash 中的退出示例&lt;/h2&gt;
&lt;p&gt;sequenceDiagram participant o as operator participant u1 as alice participant u2 as bob participant u3 as carol participant u4 as david u1-&amp;gt;&amp;gt;rootchain: deposit asset to RootChain, get unique id asset1 o-&amp;gt;&amp;gt;rootchain: 生成 NewBlock 3, 记录此笔资产 u1-&amp;gt;&amp;gt;u2: transfer asset1 to bob o-&amp;gt;&amp;gt;rootchain: 生成 NewBlock 7, 记录此笔交易 u1-&amp;gt;&amp;gt;u3: transfer asset1 to carol o-&amp;gt;&amp;gt;rootchain: 生成 Newblock 11 记录此笔交易 u3-&amp;gt;&amp;gt;rootchain: 我要提现asset1到主链,提供asset1来自 alice,由 alice签名,发生在 11 u2-&amp;gt;&amp;gt;rootchain: 提出挑战,asset1应该属于我,提供 asset1 来自 alice,由 aice签名,发生在 7,rootchain 判定bob证据有效,拒绝carol提现 u2-&amp;gt;&amp;gt;u4: transfer asset1 to devid o-&amp;gt;&amp;gt;rootchain:生成 Newblock 27, 记录此笔交易 u4-&amp;gt;&amp;gt;rootchain:提现 asset1,来自 bob,有 bob的签名,发生在 27 loop david wait for challenge u4-&amp;gt;&amp;gt;u4:等待挑战期两周时间 end u4-&amp;gt;&amp;gt; rootchain: withdraw,提现,将asset1从rootchain 转走&lt;/p&gt;
&lt;h2 id=&quot;section-4&quot;&gt;5. 其他问题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;为什么 Plasma Cash 中的资产是不可分割的?&lt;br/&gt;进入 rootchain 的资产类似于比特币的 UTXO 模型,但是是不可分割的,这个可以通过交易验证时每次都要求 amount 不变可以得出.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;operator 的作用是什么?&lt;br/&gt;operator 负责将子链中的交易证据(默克尔树)提交证明到以太坊主链中.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;operator 是否必须可信任的?&lt;br/&gt;是的. 虽然 operator 不能将他人资产随意转移,但是却可以阻止他人资产转移.也就是说无法从 Plasma 子链中退回到以太坊中. 当然这部分是可以改进,降低 operator 作恶带来的风险.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;operator 是否可以是一个合约呢?&lt;br/&gt;是的. 如果 operator 是一个 Pos 共识合约,那么可以降低问题3中的风险&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 14 Sep 2018 13:46:00 +0000</pubDate>
<dc:creator>baizx</dc:creator>
<og:description>Plasma Cash合约解读</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baizx/p/9649153.html</dc:identifier>
</item>
<item>
<title>c#实战开发：用.net core开发一个简单的Web以太坊钱包 （六） - 薛定谔家的猫</title>
<link>http://www.cnblogs.com/yuanzijian-ruiec/p/9607194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanzijian-ruiec/p/9607194.html</guid>
<description>
&lt;p&gt;今天就来开发一个C# 版的简易钱包 先回顾以前的内容&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yuanzijian-ruiec/p/9601219.html&quot;&gt;c#实战开发：以太坊Geth 命令发布智能合约 （五）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_1&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yuanzijian-ruiec/p/9601176.html&quot;&gt;c#实战开发：以太坊Geth 常用命令 （四）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_2&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yuanzijian-ruiec/p/9601026.html&quot;&gt;c#实战开发：以太坊钱包快速同步区块和钱包卡死解决方案 （三）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_3&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yuanzijian-ruiec/p/9600954.html&quot;&gt;c#实战开发：以太坊钱包对接私链 （二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_4&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/yuanzijian-ruiec/p/9332961.html&quot;&gt;c#实战开发：以太坊私链搭建（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先看一下可视化钱包有哪些功能呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201809/1222663-20180907211912142-365121827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那这个钱包得有什么功能呢？ &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.查看用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.查看交易记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.转账&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.发布智能合约&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.代币转账&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.代币查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.实时同步区块对比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.智能填写手续费&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先新建一个项目 导入以太坊.net实现类库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package Nethereum.Geth -Version 2.5.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222663/201809/1222663-20180914202618064-327875938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;初始对象 记住初始化连接记得把Geth客户端打开建立连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:8546/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
private static Web3Geth Web3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Web3Geth(url);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个url端口号就是你的公链端口 可以不填直接默认 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Web3Geth Web3 = &lt;span&gt;new&lt;/span&gt; Web3Geth();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们来一一实现功能  可以先用私链测试结果 不会的看前面的文章导读&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.用户操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先新增一个用户  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;string&lt;/span&gt; passPhrase = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Result = &lt;span&gt;await&lt;/span&gt; Web3.Personal.NewAccount.SendRequestAsync(passPhrase);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 传入用户密码 等待异步结果返回 用户公钥 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222663/201809/1222663-20180914203117059-1281738418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户新增好了&lt;/p&gt;
&lt;p&gt; 查询余额  把刚刚新建的用户地址传入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Result = &lt;span&gt;await&lt;/span&gt; Web3.Eth.GetBalance.SendRequestAsync(address);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不知道命令可以看&lt;/p&gt;
&lt;p&gt;以太坊API中文文档:http://web3.tryblockchain.org/Web3.js-api-refrence.html  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.以太坊操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先考虑钱包的稳定性和同步的差异性 要让转账有效   就要多准备几个客户端 防客户端死掉 先模拟三个客户端IP&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; url1 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:8545/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; url2 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:8546/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; url3 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:8547/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;private static Web3Geth 1Web3 = new Web3Geth(url1);&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;private static Web3Geth 2Web3 = new Web3Geth(url2);&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;private static Web3Geth 3Web3 = new Web3Geth(url3);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;怎么知道哪个客户端死掉了呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; BlockNumber =&lt;span&gt;await&lt;/span&gt; Web3.Eth.Blocks.GetBlockNumber.SendRequestAsync();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取的当前客户端区块同步高度 0就直接切换 初始化对象继续查     比如在查到5400  但是以太坊浏览器上同步区块是5800 这时你的客户端同步差异性  区块太别太大？ 手续费输入多少?&lt;/p&gt;
&lt;p&gt;看以太坊的区块链也不是及时同步 怎么办呢？&lt;/p&gt;
&lt;p&gt;好在发现了一个区块链同步网站&lt;/p&gt;
&lt;p&gt; https://ethstats.net/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222663/201809/1222663-20180914210046605-1071339971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到最新的区块高度 和交易手续费  每秒都在刷  底下各大节点同步最新的数据  把这些数据拿到就可以知道我的客户端区块和最高区块的差距 已经当前最新手续费  这样可以告诉要转账的人 最合理的手续费输入值。  &lt;/p&gt;
&lt;p&gt;我们可以用  HttpClient 但是建立连接之后数据相应太慢根本不能做到实时推送给用户最新的区块记录和手续费 。&lt;/p&gt;
&lt;p&gt;不过认真观察了一下应该是用的websocket 所以&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222663/201809/1222663-20180914210704863-1093463016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;地址被我找到了  这样就不用爬了  用他的地址写成exe客户端建立连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; ws = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wss://ethstats.net&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是发现数据不准 什么情况  发现后面有一个参数&lt;/p&gt;
&lt;p&gt;_primuscb=1536930413898-0    那他的规则是什么呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222663/201809/1222663-20180914211059089-450716933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数了一个10秒请求一个新连接 之间没有回传 那这个规则只能是写在JS了 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222663/201809/1222663-20180914211221423-804000013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整整3万行 不过还是被我找到了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt; data()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222663/201809/1222663-20180914211318028-439611690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来是获取当前js的时间戳+1；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
DateTime startTime = TimeZone.CurrentTimeZone.ToLocalTime(&lt;span&gt;new&lt;/span&gt; System.DateTime(&lt;span&gt;1970&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; timeStamp = (&lt;span&gt;long&lt;/span&gt;)(DateTime.Now - startTime).TotalMilliseconds+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ws = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wss://ethstats.net/primus/?_primuscb=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + timeStamp + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过数据太多要对获取数据进行筛选 &lt;/p&gt;
&lt;p&gt;这些都做好了 就准备转账了 先要解锁要转账的用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;ulong&lt;/span&gt;? ul = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; resultunlock =&lt;span&gt;await&lt;/span&gt; Web3.Personal.UnlockAccount.SendRequestAsync(From, FromPassPhrase, ul);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ul  解锁时间   空默认一次   from 用户地址    from 用户地址的私钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转账&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; txId =&lt;span&gt; Web3.Eth.Transactions.SendTransaction.SendRequestAsync(
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TransactionInput { From = From, To = To, Value = &lt;span&gt;new&lt;/span&gt; HexBigInteger(&lt;span&gt;long&lt;/span&gt;.Parse(GasPrice)), Gas = &lt;span&gt;new&lt;/span&gt; HexBigInteger(&lt;span&gt;long&lt;/span&gt;.Parse(GasLimit)) }).Result;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From  要转账地址  To 被转账地址    GasPrice 转账可以数量   Gas 数量  可以直接用 websocket 获取到最新的数据 填入 GasPrice,Gas &lt;/p&gt;
&lt;p&gt;转账成功后  会返回交易哈希 可以在以太坊浏览器上查看&lt;/p&gt;
&lt;p&gt;把刚刚的交易回传的哈希传入 看交易详情&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Transaction Result =&lt;span&gt;await&lt;/span&gt; Web3.Eth.Transactions.GetTransactionByHash.SendRequestAsync(txId);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.智能合约&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先生成智能合约abi 网站&lt;/p&gt;
&lt;p&gt;https://ethereum.github.io/browser-solidity/#optimize=false&amp;amp;version=soljson-v0.4.24+commit.e67f0147.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; BYTECODE = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x6060......5654“&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很长&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;var&lt;/span&gt; senderAddress = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x12890d2cce102216644c59daE5baed380d84830c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; privatekey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://rinkeby.infura.io/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deploymentMessage = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StandardTokenDeployment
            {
                TotalSupply &lt;/span&gt;= &lt;span&gt;100000&lt;/span&gt;&lt;span&gt;,
                FromAddress &lt;/span&gt;=&lt;span&gt; senderAddress
            };
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; web3 = &lt;span&gt;new&lt;/span&gt; Web3.Web3(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Account(privatekey), url);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deploymentHandler = web3.Eth.GetContractDeploymentHandler&amp;lt;StandardTokenDeployment&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transactionReceipt = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; deploymentHandler.SendRequestAndWaitForReceiptAsync(deploymentMessage);

            ContractAddress &lt;/span&gt;= transactionReceipt.ContractAddress;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先获取发只能合约用户的私钥 让后&lt;/p&gt;
&lt;p&gt;填入发布数量 名字 返回合约哈希&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; senderAddress = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x12890d2cce102216644c59daE5baed380d84830c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; balanceOfFunctionMessage = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BalanceOfFunction()
            {
                Owner &lt;/span&gt;=&lt;span&gt; senderAddress,
            };
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; balanceHandler = web3.Eth.GetContractQueryHandler&amp;lt;BalanceOfFunction&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; balance = &lt;span&gt;await&lt;/span&gt; balanceHandler.QueryAsync&amp;lt;BigInteger&amp;gt;(balanceOfFunctionMessage, contractAddress);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222663/201809/1222663-20180914213549556-820329571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查询合同剩余币数  让后就是合同代笔转账&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; senderAddress = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x12890d2cce102216644c59daE5baed380d84830c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; receiverAddress = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; privatekey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://rinkeby.infura.io/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; web3 =  &lt;span&gt;new&lt;/span&gt; Web3.Web3(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Account(privatekey), url);

     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transactionMessage = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TransferFunction()
            {
                FromAddress &lt;/span&gt;=&lt;span&gt; senderAddress,
                To &lt;/span&gt;=&lt;span&gt; receiverAddress,
                TokenAmount &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Set our own price&lt;/span&gt;
                GasPrice =  Web3.Web3.Convert.ToWei(&lt;span&gt;25&lt;/span&gt;&lt;span&gt;, UnitConversion.EthUnit.Gwei)
                
            };


  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transferHandler = web3.Eth.GetContractTransactionHandler&amp;lt;TransferFunction&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; this is done automatically so is not needed.&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; estimate = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; transferHandler.EstimateGasAsync(transactionMessage, ContractAddress);
            transactionMessage.Gas &lt;/span&gt;=&lt;span&gt; estimate.Value;


            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; transactionHash = &lt;span&gt;await&lt;/span&gt; transferHandler.SendRequestAsync(transactionMessage, ContractAddress);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后返回交易哈希  &lt;/p&gt;
&lt;p&gt;一下是上面用到的开源实例库 他还可以还发以太坊游戏 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222663/201809/1222663-20180914214032294-6443310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222663/201809/1222663-20180914214046833-1913401353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222663/201809/1222663-20180914214053344-387442309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;https://nethereum.readthedocs.io/en/latest/introduction/web3/&lt;/p&gt;
&lt;p&gt;https://github.com/Nethereum/Nethereum&lt;/p&gt;
&lt;p&gt;因为是开源的大家可以自己去学习  &lt;/p&gt;
&lt;p&gt;https://gitter.im/Nethereum/Nethereum  ETH学习论坛&lt;/p&gt;
&lt;p&gt;智能合约&lt;/p&gt;
&lt;p&gt;https://github.com/Nethereum/Nethereum/blob/master/src/Nethereum.Accounts.IntegrationTests/SignOfflineTransactionTest.cs#L23-L39&lt;/p&gt;
&lt;p&gt;https://github.com/Nethereum/Nethereum.Workbooks/blob/master/docs/nethereum-infura-transfer.workbook&lt;/p&gt;
&lt;p&gt;https://github.com/Nethereum/Nethereum.Workbooks/blob/master/docs/nethereum-cqs-test.workbook&lt;/p&gt;
&lt;p&gt;至此 大致功能已经完成！ 感谢观看！ 下期比特币！&lt;/p&gt;

</description>
<pubDate>Fri, 14 Sep 2018 13:45:00 +0000</pubDate>
<dc:creator>薛定谔家的猫</dc:creator>
<og:description>今天就来开发一个C# 版的简易钱包 先回顾以前的内容 c#实战开发：以太坊Geth 命令发布智能合约 （五） c#实战开发：以太坊Geth 常用命令 （四） c#实战开发：以太坊钱包快速同步区块和钱包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanzijian-ruiec/p/9607194.html</dc:identifier>
</item>
<item>
<title>利用ZYNQ SOC快速打开算法验证通路（6）——利用AXI总线实时配置sysGen子系统 - 没落骑士</title>
<link>http://www.cnblogs.com/moluoqishi/p/9648928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moluoqishi/p/9648928.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;利用ZYNQ验证算法的一大优势在于，可以在上位机发送指令借助CPU的控制能力和C语言易开发特点，实时配置算法模块的工作模式、参数等对来对其算法模块性能进行全面的评估。最重要的是无需重新综合硬件模块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着上篇该系列博文，在sysGen中设计模块功能为：根据模式选择输入，来完成乘2或除2两种运算，0乘1除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914204401455-334988900.png&quot; alt=&quot;&quot; width=&quot;789&quot; height=&quot;328&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　测试激励选用From Workspace模块，从MATLAB工作空间导入数据。利用MALTAB脚本可以非常容易地生成任意数据集，极大体现了sysGen开发的优势。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914205126374-1050400773.png&quot; alt=&quot;&quot; width=&quot;375&quot; height=&quot;238&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　设计完成调用xilinx waveform viewer，两种运算行为仿真波形如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914204547388-1851889649.png&quot; alt=&quot;&quot; width=&quot;1008&quot; height=&quot;192&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914204602925-361847194.png&quot; alt=&quot;&quot; width=&quot;1006&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;功能验证无误，关键的一点是让mode端口以AXI总线形式传递数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914204756340-342446569.png&quot; alt=&quot;&quot; width=&quot;408&quot; height=&quot;605&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;现在将sysGen算法子系统生成IP核，并导出到IP Integrator中作为CPU外设。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914205247270-509906948.png&quot; alt=&quot;&quot; width=&quot;1287&quot; height=&quot;642&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;可以看到multi_div_constant模块多出一个multi_div_constant_s_axi总线接口集。这里本人有个疑问：&lt;strong&gt;为什么sysGen中选择mode接口服从AXI-Lite总线形式，而生成的接口却为AXI-Full形式？虽然不影响使用，也希望有看到的朋友帮忙解答这个疑惑。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;硬件系统设计完毕，导出硬件启动SDK。当新建工程后，能看到AXI总线驱动自动添加进来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914205736716-1966350120.png&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;609&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;multi_div_constant_hw.h内部为AXI-Lite总线寄存器地址，multi_div_constant.c内是驱动函数的具体实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914211128577-899694047.png&quot; alt=&quot;&quot; width=&quot;1360&quot; height=&quot;397&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　C代码对算法模块进行板级验证：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914211119048-906232055.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;323&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;启动Debug，点击运行查看软件运行结果和AXI-Stream总线时序波形。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914211335799-1495964630.png&quot; alt=&quot;&quot; width=&quot;1206&quot; height=&quot;239&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914211350320-594369540.png&quot; alt=&quot;&quot; width=&quot;1206&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914211407340-1441231572.png&quot; alt=&quot;&quot; width=&quot;1208&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;SDK中串口打印结果及Memory窗口查看DDR接收缓存绝对地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201809/1201289-20180914211538057-893342235.png&quot; alt=&quot;&quot; width=&quot;1252&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;正确启动了两次DMA环回传输，第一次算法模块工作在乘2模式，第二次则除2.C代码中测试返回数据与生成测试数据关系无误，DDR绝对地址数据也别正确更新。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Sep 2018 13:21:00 +0000</pubDate>
<dc:creator>没落骑士</dc:creator>
<og:description>利用ZYNQ验证算法的一大优势在于，可以在上位机发送指令借助CPU的控制能力和C语言易开发特点，实时配置算法模块的工作模式、参数等对来对其算法模块性能进行全面的评估。最重要的是无需重新综合硬件模块。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moluoqishi/p/9648928.html</dc:identifier>
</item>
<item>
<title>SpringBoot | 第二十八章：监控管理之Spring Boot Admin使用 - oKong_趔趄的猿</title>
<link>http://www.cnblogs.com/okong/p/springboot-twenty-eight.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okong/p/springboot-twenty-eight.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上一章节，我们介绍了&lt;code&gt;Actuator&lt;/code&gt;的使用，知道了可通过访问不同的端点路径，获取相应的监控信息。但使用后也能发现，返回的监控数据都是以JSON串的形式进行返回的，对于实施或者其他人员来说，不是很直观，而当需要监控的应用越来越多时，依次去访问对应的应用也过于繁琐和低效了。所以，本章节来介绍下&lt;code&gt;Spring Boot Admin&lt;/code&gt;这个UI监控工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;spring-boot-admin是什么&quot;&gt;Spring-Boot-Admin是什么&lt;/h2&gt;
&lt;p&gt;先看看，官网给其定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/26602227.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单来说，&lt;code&gt;Spring Boot Admin&lt;/code&gt;是一个管理和监控&lt;code&gt;Spring Boot&lt;/code&gt;应用程序的开源软件。每个应用都认为是一个客户端，通过&lt;code&gt;HTTP&lt;/code&gt;或者&lt;code&gt;服务注册发现Spring Cloud&lt;/code&gt;(Eureka、Consul等等)注册到&lt;code&gt;admin server&lt;/code&gt;中进行展示，&lt;code&gt;Spring Boot Admin UI&lt;/code&gt;部分使用&lt;code&gt;AngularJs&lt;/code&gt;将数据展示在前端。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Spring Boot Admin&lt;/code&gt;是一个针对&lt;code&gt;spring-boot&lt;/code&gt;的&lt;code&gt;actuator&lt;/code&gt;接口进行UI美化封装的监控工具。它可以：在列表中浏览所有被监控spring-boot项目的基本信息，详细的Health信息、内存信息、JVM信息、垃圾回收信息、各种配置信息（比如数据源、缓存列表和命中率）等，还可以直接修改&lt;code&gt;logger&lt;/code&gt;的&lt;code&gt;level&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;监控实例&quot;&gt;监控实例&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Spring Boot Admin&lt;/code&gt;包含&lt;code&gt;admin-server&lt;/code&gt;与&lt;code&gt;admin-client&lt;/code&gt;两个组件，&lt;code&gt;admin-server&lt;/code&gt;通过采集&lt;code&gt;actuator&lt;/code&gt;端点数据，显示在&lt;code&gt;spring-boot-admin-ui&lt;/code&gt;上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提醒：为了演示服务端和客户端，本实例创建了一个&lt;code&gt;maven多模块&lt;/code&gt;项目。&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;admin-server端&quot;&gt;admin-server端&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;admin-server&lt;/code&gt;端主要是数据展现功能，包含了一个ui页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建一个&lt;code&gt;spring-boot-admin-server&lt;/code&gt;工程。&lt;/p&gt;
&lt;p&gt;0.引入pom依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-admin-starter-server&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
          &amp;lt;dependencyManagement&amp;gt;
      &amp;lt;dependencies&amp;gt;
          &amp;lt;dependency&amp;gt;
              &amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
              &amp;lt;artifactId&amp;gt;spring-boot-admin-dependencies&amp;lt;/artifactId&amp;gt;
              &amp;lt;version&amp;gt;1.5.7&amp;lt;/version&amp;gt;
              &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
              &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
          &amp;lt;/dependency&amp;gt;
      &amp;lt;/dependencies&amp;gt;
  &amp;lt;/dependencyManagement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：由于使用的&lt;code&gt;SprinBoot&lt;/code&gt;为&lt;code&gt;1.5.15&lt;/code&gt;版本，所以选用的&lt;code&gt;Spring Boot Admin&lt;/code&gt;版本为&lt;code&gt;1.5.7&lt;/code&gt;版本。同时为了版本依赖，使用&lt;code&gt;dependencyManagement&lt;/code&gt;加入了&lt;code&gt;spring-boot-admin-dependencies&lt;/code&gt;进行版本管理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.启动类，加入注解&lt;code&gt;@EnableAdminServer&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableAdminServer
@Slf4j
public class Chapter28AdminServerApplication {
    public static void main(String[] args) throws Exception {
        SpringApplication.run(Chapter28AdminServerApplication.class, args);
        log.info(&quot;Chapter28AdminServer启动!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个服务端就基本配置结束了，启动应用，访问：http://127.0.0.1:8080 ,即可看见监控页面了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/99132541.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于现在还没有加入客户端，所以应用列表都是空的。&lt;/p&gt;
&lt;h3 id=&quot;admin-client端&quot;&gt;admin-client端&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被监控的应用只需要加入相关依赖和服务端配置即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建一个&lt;code&gt;spring-boot-admin-client&lt;/code&gt;项目&lt;/p&gt;
&lt;p&gt;0.引入pom依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-admin-starter-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.配置文件加入服务端地址等信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;application.properties&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 应用名称 便于识别
spring.application.name=spring-boot-admin-client
server.port=8081
#服务端地址
spring.boot.admin.url=http://127.0.0.1:8080
# 关闭安全认证
management.security.enabled=false
# 利用info端点，加入版本等信息  
info.version=@project.version@
info.name=@project.artifactId@
# 可自定义信息
info.author=oKong
info.blog=http://blog.lqdev.cn/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：为了能获取maven的配置内容，需要在pom文件中加入以下配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;build-info&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要这两部，客户端就配置完了，启动下，访问http://127.0.0.1:8080 ,即可看见监控页面已经包含了此应用数据了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/68693191.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，我们点击详情，即可看见各类监控数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/52661589.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;环境变量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/59611622.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/91413540.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;日志相关：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/23451118.jpg&quot; alt=&quot;logger&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若需要动态的修改日志级别，按官网的提示，需要加入&lt;code&gt;logback-spring.xml&lt;/code&gt;文件，具体的可查看官网文档吧，写的很详细了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/77056233.jpg&quot; alt=&quot;loglevel-management&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他监控指标，大家可以自行查看下。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;注意：在生产环境中，为了数据的安全，还是需要加上安全认证的，具体的可以查看官方文档：&lt;a href=&quot;http://codecentric.github.io/spring-boot-admin/1.5.7/#_securing_spring_boot_admin_server&quot; title=&quot;securing-spring-boot-admin&quot;&gt;securing-spring-boot-admin&lt;/a&gt;，相对比较简单，简单来说就是加入&lt;code&gt;spring-boot-starter-security&lt;/code&gt;进行安全认证，这里可以直接引入&lt;code&gt;spring-boot-admin-server-ui-login&lt;/code&gt;进行登录安全认证。本文就不阐述了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/90985287.jpg&quot; alt=&quot;securing_spring_boot_admin_server&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;监控通知&quot;&gt;监控通知&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;虽然我们可以通过界面进行可视化监控，但不可能实时去盯着屏幕的，我们希望在服务有问题，比如下线、CPU异常等情况时，能通过邮件等形式及时通知对应责任人，这样就能做到预警效果了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;SpingBootAdmin&lt;/code&gt;中，提供了多种通知机制，来实现监控告警功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/5705403.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看见，其集成了国外的一些通讯软件，而对于我们而言，还是使用邮件通知比较靠谱。当然也能自定义通知，进行个性化消息通知功能，比如钉钉机器人通知等。&lt;/p&gt;
&lt;h3 id=&quot;发送邮件通知&quot;&gt;发送邮件通知&lt;/h3&gt;
&lt;blockquote readability=&quot;4.7234042553191&quot;&gt;
&lt;p&gt;这里简单以邮件通知为例。具体邮件发送相关知识点，可查看：&lt;a href=&quot;http://blog.lqdev.cn/2018/08/29/springboot/chapter-twenty-six/&quot; title=&quot;第二十六章：邮件发送&quot;&gt;第二十六章：邮件发送&lt;/a&gt;，这里不在阐述了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;以下配置都是在服务端&lt;code&gt;spring-boot-admin-server&lt;/code&gt;进行添加。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0.引入pom依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-mail&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.配置邮箱信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 邮件相关
# SMTP服务器地址
spring.mail.host=smtp.qq.com
# SMTP服务器端口号 默认-1
# spring.mail.port=-1
# 发送方帐号
spring.mail.username=邮箱
# 发送方密码（授权码）
spring.mail.password=邮箱密码
#javaMailProperties 配置
# 开启用户身份验证
spring.mail.properties.mail.smtp.auth=true
# 发送给谁
spring.boot.admin.notify.mail.to=499452441@qq.com
# 谁发的
spring.boot.admin.notify.mail.from=499452441@qq.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次启动服务端应用和客户端，之后停止客户端，就可以收到下线通知邮件了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/78772685.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时，我们还能自定义发送邮件的主题和内容，配置文件加入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 主题格式
# 使用中文会乱码，可使用yml文件格式解决
# 之类直接unicode编码了
# 应用#{application.name}(#{application.id}) 状态为：#{to.status}
spring.boot.admin.notify.mail.subject=\u5e94\u7528#{application.name}(#{application.id}) \u72b6\u6001\u4e3a\uff1a#{to.status}
# 邮件内容
#应用#{application.name} (#{application.id})\n状态从 #{from.status} 变为 #{to.status}\n\n 应用健康地址：#{application.healthUrl}
spring.boot.admin.notify.mail.text=\u5e94\u7528#{application.name} (#{application.id})\n\u72b6\u6001\u4ece #{from.status} \u53d8\u4e3a #{to.status}\n\n \u5e94\u7528\u5065\u5eb7\u5730\u5740\uff1a#{application.healthUrl}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多说几句：这里的&lt;code&gt;subject&lt;/code&gt;和&lt;code&gt;text&lt;/code&gt;都支持&lt;code&gt;SpEL(Spring Expression Language)&lt;/code&gt;表达式的，关于&lt;code&gt;SpEL&lt;/code&gt;表达式，有兴趣的同学可以自行搜索下，是一个支持运行时查询和操作对象图的强大的表达式语言，类似于&lt;code&gt;EL&lt;/code&gt;表达式，定界符为&lt;code&gt;#{}&lt;/code&gt;，一种简化开发的表达式，通过使用表达式来简化开发，减少一些逻辑、配置的编写。&lt;/p&gt;
&lt;p&gt;而此次，发送邮件的参数，通过跟踪源码获悉，入口的参数为&lt;code&gt;ClientApplicationEvent&lt;/code&gt;，对应路径为：&lt;code&gt;de.codecentric.boot.admin.event.ClientApplicationEvent&lt;/code&gt;，即应用信息。其继承的类如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/29165909.jpg&quot; alt=&quot;ClientApplicationEvent继承类&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当应用发送状态变更时，就会触发&lt;code&gt;ClientApplicationStatusChangedEvent&lt;/code&gt;事件了，对应的参数如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/95831983.jpg&quot; alt=&quot;ClientApplicationStatusChangedEvent&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，需要额外一些参数时，可以根据&lt;code&gt;de.codecentric.boot.admin.model.Application&lt;/code&gt;的属性获取更加详细的信息，如&lt;code&gt;metadata&lt;/code&gt;、&lt;code&gt;info&lt;/code&gt;等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/68759361.jpg&quot; alt=&quot;Application&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后，发送的邮件内如如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/33003952.jpg&quot; alt=&quot;自定义邮件内容&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自定义通知&quot;&gt;自定义通知&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;除了使用自带的一些通知机制外，我们还能通过自定义，来进行个性化通知的创建，比如在一些场景下，我们会把消息推送到MQ服务器上或者手机上等等。实现通知比较简单，就是实现&lt;code&gt;Notifier&lt;/code&gt;接口，而官方提供给了一个抽象类&lt;code&gt;AbstractStatusChangeNotifier&lt;/code&gt;，我们直接继承此类就好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;0.创建一个自定义通知类&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CustomNotifier.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 自定义通知
 * @author oKong
 *
 */
@Component
@ConfigurationProperties(&quot;okong.custom.notify&quot;)
@Setter
@Getter
@Slf4j
public class CustomNotifier extends AbstractStatusChangeNotifier{
    String name;
    @Override
    protected void doNotify(ClientApplicationEvent event) throws Exception {
        //这里只是为了示例 ，直接输出到控制台了。
        log.info(&quot;{}-自定义通知：应用-{}&quot;, name,event.getApplication().getName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.配置文件配置属性name的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 自定义通知类型
okong.custom.notify.name=oKong&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次，启动应用，当监控的应用状态发生变动时，可以看见邮件和自定义通知都生效了，控制台可以看见自定义输出内容了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-9-14/29360138.jpg&quot; alt=&quot;自定义通知&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家可以结合实际的业务需求，编写不同的自定义通知类的，比如利用小程序或者微信公众号，发送微信信息；或者发送短信；或者其他的通讯工具都可以的,自由发挥~&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://codecentric.github.io/spring-boot-admin/1.5.7/&quot; class=&quot;uri&quot; title=&quot;http://codecentric.github.io/spring-boot-admin/1.5.7/&quot;&gt;http://codecentric.github.io/spring-boot-admin/1.5.7/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本章节主要讲解了利用&lt;code&gt;Spring Boot Admin&lt;/code&gt;这个web监控工具进行可视化的监控应用各指标信息。关于使用&lt;code&gt;Spring Cloud&lt;/code&gt;注册中心来进行客户端自动注册与发现的，本系列就不阐述了，因为涉及到一些&lt;code&gt;Eureka&lt;/code&gt;的相关知识点，后期会在&lt;code&gt;白话SpringCloud&lt;/code&gt;的实施监控里面进行详细阐述，而且基于&lt;code&gt;Spring Boot2&lt;/code&gt;的界面风格也有大变动，使用&lt;code&gt;Vue.js&lt;/code&gt;来进行构建了，同时很会集成&lt;code&gt;Hystrix&lt;/code&gt;和&lt;code&gt;turbine&lt;/code&gt;的集成监控，会更加方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;目前互联网上很多大佬都有&lt;code&gt;SpringBoot&lt;/code&gt;系列教程，如有雷同，请多多包涵了。&lt;strong&gt;原创不易，码字不易&lt;/strong&gt;，还希望大家多多支持。若文中有所错误之处，还望提出，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;老生常谈&quot;&gt;老生常谈&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;个人QQ：&lt;code&gt;499452441&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;微信公众号：&lt;code&gt;lqdevOps&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/default/wxgzh8cm.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;http://blog.lqdev.cn/&quot; class=&quot;uri&quot; title=&quot;http://blog.lqdev.cn&quot;&gt;http://blog.lqdev.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完整示例：&lt;a href=&quot;https://github.com/xie19900123/spring-boot-learning/tree/master/chapter-28&quot; class=&quot;uri&quot; title=&quot;https://github.com/xie19900123/spring-boot-learning/tree/master/chapter-28&quot;&gt;https://github.com/xie19900123/spring-boot-learning/tree/master/chapter-28&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;http://blog.lqdev.cn/2018/09/14/springboot/chapter-twenty-eight/&quot; class=&quot;uri&quot;&gt;http://blog.lqdev.cn/2018/09/14/springboot/chapter-twenty-eight/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Sep 2018 12:29:00 +0000</pubDate>
<dc:creator>oKong_趔趄的猿</dc:creator>
<og:description>前言 上一章节，我们介绍了 的使用，知道了可通过访问不同的端点路径，获取相应的监控信息。但使用后也能发现，返回的监控数据都是以JSON串的形式进行返回的，对于实施或者其他人员来说，不是很直观，而当需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okong/p/springboot-twenty-eight.html</dc:identifier>
</item>
<item>
<title>Web框架的原理 - o微凉o</title>
<link>http://www.cnblogs.com/liuye1990/p/9648455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuye1990/p/9648455.html</guid>
<description>&lt;p&gt;
&lt;h2 id=&quot;catalog&quot;&gt;Web框架本质&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;我们可以这样理解：所有的Web应用本质上就是一个socket服务端，而用户的浏览器就是一个socket客户端。 这样我们就可以自己实现Web框架了。&lt;/p&gt;

&lt;h3&gt;socket服务端&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;dp-highlighter&quot;&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import socket  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk = socket.socket()  &lt;/li&gt;
&lt;li&gt;sk.bind((&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;, &lt;span class=&quot;number&quot;&gt;80))  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk.listen()  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;while &lt;span class=&quot;special&quot;&gt;True:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn, addr = sk.accept()  &lt;/li&gt;
&lt;li&gt;    data = conn.recv(&lt;span class=&quot;number&quot;&gt;8096)  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn.send(b&lt;span class=&quot;string&quot;&gt;&quot;OK&quot;)  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    conn.close()  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;可以说Web服务本质上都是在这十几行代码基础上扩展出来的。这段代码就是它们的祖宗。&lt;/p&gt;
&lt;p&gt;用户在浏览器中输入网址，浏览器会向服务端发送数据，那浏览器会发送什么数据？怎么发？这个谁来定？ 你这个网站是这个规定，他那个网站按照他那个规定，那互联网还能玩么？&lt;/p&gt;
&lt;p&gt;所以，必须有一个统一的规则，让大家发送消息、接收消息的时候都有个格式依据，不能随便写。&lt;/p&gt;
&lt;p&gt;这个规则就是HTTP协议，以后浏览器发送请求信息也好，服务器回复响应信息也罢，都要按照这个规则来。&lt;/p&gt;
&lt;p&gt;HTTP协议主要规定了客户端和服务器之间的通信格式，那HTTP协议是怎么规定消息格式的呢？&lt;/p&gt;
&lt;p&gt;让我们首先打印下我们在服务端接收到的消息是什么。&lt;/p&gt;
&lt;div class=&quot;dp-highlighter&quot;&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import socket    &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk = socket.socket()    &lt;/li&gt;
&lt;li&gt;sk.bind((&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;, &lt;span class=&quot;number&quot;&gt;80))    &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk.listen()    &lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;while &lt;span class=&quot;special&quot;&gt;True:    &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn, addr = sk.accept()    &lt;/li&gt;
&lt;li&gt;    data = conn.recv(&lt;span class=&quot;number&quot;&gt;8096)    &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print(data)  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    conn.send(b&lt;span class=&quot;string&quot;&gt;&quot;OK&quot;)    &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn.close()    &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;

&lt;pre&gt;
b'GET / HTTP/1.1\r\nHost: 127.0.0.1:8080\r\nConnection: keep-alive\r\nCache-Control: max-age=0\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3355.4 Safari/537.36\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q=0.9\r\nCookie: csrftoken=CtHePYARJOKNx5oNVwxIteOJXpNyJ29L4bW4506YoVqFaIFFaHm0EWDZqKmw6Jm8\r\n\r\n'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们将\r\n替换成换行看得更清晰点：&lt;/p&gt;
&lt;div class=&quot;dp-highlighter&quot;&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;&gt;GET / HTTP/&lt;span class=&quot;number&quot;&gt;1.1  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Host: &lt;span class=&quot;number&quot;&gt;127.0.&lt;span class=&quot;number&quot;&gt;0.1:&lt;span class=&quot;number&quot;&gt;8080  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;Connection: keep-alive  &lt;/li&gt;
&lt;li&gt;Cache-Control: max-age=&lt;span class=&quot;number&quot;&gt;0  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;Upgrade-Insecure-Requests: &lt;span class=&quot;number&quot;&gt;1  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;User-Agent: Mozilla/&lt;span class=&quot;number&quot;&gt;5.0 (Windows NT &lt;span class=&quot;number&quot;&gt;6.1; WOW64) AppleWebKit/&lt;span class=&quot;number&quot;&gt;537.36 (KHTML, like Gecko) Chrome/&lt;span class=&quot;number&quot;&gt;66.0.&lt;span class=&quot;number&quot;&gt;3355.4 Safari/&lt;span class=&quot;number&quot;&gt;537.36  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;Accept: text/html,application/xhtml+xml,application/xml;q=&lt;span class=&quot;number&quot;&gt;0.9,image/webp,image/apng,*/*;q=&lt;span class=&quot;number&quot;&gt;0.8  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Accept-Encoding: gzip, deflate, br  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;Accept-Language: zh-CN,zh;q=&lt;span class=&quot;number&quot;&gt;0.9  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Cookie: csrftoken=CtHePYARJOKNx5oNVwxIteOJXpNyJ29L4bW4506YoVqFaIFFaHm0EWDZqKmw6Jm8  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;然后我们再看一下我们访问博客园官网时浏览器收到的响应信息是什么。&lt;/p&gt;
&lt;p&gt;响应相关信息可以在浏览器调试窗口的Network标签页中看到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201803/867021-20180323150019047-1023274645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击view source之后显示如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201803/867021-20180323150139312-1752889895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现收发的消息需要按照一定的格式来，这里就需要了解一下HTTP协议了。&lt;/p&gt;

&lt;p&gt;HTTP协议对收发消息的格式要求&lt;/p&gt;
&lt;p&gt;每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。&lt;/p&gt;
&lt;p&gt;HTTP响应的Header中有一个 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Content&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;typ&quot;&gt;Type&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;表明响应的内容格式。它的值如text/html; charset=utf-8。&lt;/p&gt;
&lt;p&gt;text/html则表示是网页，charset=utf-8则表示编码为utf-8。&lt;/p&gt;

&lt;h3&gt;HTTP GET请求的格式：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201803/867021-20180330221943115-1291906159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;HTTP响应的格式：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201803/867021-20180330222031912-1851965755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 自定义web框架&lt;/h3&gt;
&lt;p&gt;经过上面的学习，那我们基于socket服务端的十几行代码写一个我们自己的web框架。我们先不处理浏览器发送的请求，先让浏览器能显示我们web框架返回的信息，那我们就要按照HTTP协议的格式来发送响应。&lt;/p&gt;
&lt;div class=&quot;dp-highlighter&quot;&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import socket    &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    &lt;/li&gt;
&lt;li&gt;sock.bind((&lt;span class=&quot;string&quot;&gt;'127.0.0.1', &lt;span class=&quot;number&quot;&gt;8000))    &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sock.listen()    &lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while &lt;span class=&quot;special&quot;&gt;True:    &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    conn, addr = sock.accept()    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    data = conn.recv(&lt;span class=&quot;number&quot;&gt;8096)    &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn.send(b&lt;span class=&quot;string&quot;&gt;&quot;HTTP/1.1 200 OK\r\n\r\n&quot;)    &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    conn.send(b&lt;span class=&quot;string&quot;&gt;&quot;OK&quot;)    &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn.close()    &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;我们通过十几行代码简单地演示了web 框架的本质。&lt;/p&gt;
&lt;p&gt;接下来就让我们继续完善我们的自定义web框架吧！&lt;/p&gt;

&lt;h3&gt;根据不同的路径返回不同的内容&lt;/h3&gt;
&lt;p&gt;这样就结束了吗？ 如何让我们的Web服务根据用户请求的URL不同而返回不同的内容呢？ &lt;/p&gt;
&lt;p&gt;小事一桩，我们可以从请求相关数据里面拿到请求URL的路径，然后拿路径做一个判断...&lt;/p&gt;
&lt;div class=&quot;dp-highlighter&quot;&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;/&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;/&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import socket  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk = socket.socket()  &lt;/li&gt;
&lt;li&gt;sk.bind((&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;, &lt;span class=&quot;number&quot;&gt;8080))  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk.listen()  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while &lt;span class=&quot;special&quot;&gt;True:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn, add = sk.accept()  &lt;/li&gt;
&lt;li&gt;    data = conn.recv(&lt;span class=&quot;number&quot;&gt;8096)  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    data = str(data, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    data1 = data.split(&lt;span class=&quot;string&quot;&gt;&quot;\r\n&quot;)[&lt;span class=&quot;number&quot;&gt;0]  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    url = data1.split()[&lt;span class=&quot;number&quot;&gt;1]  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    conn.send(b&lt;span class=&quot;string&quot;&gt;'HTTP/1.1 200 OK\r\n\r\n')  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;if url == &lt;span class=&quot;string&quot;&gt;&quot;/index/&quot;:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        response = b&lt;span class=&quot;string&quot;&gt;&quot;index&quot;  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;elif url == &lt;span class=&quot;string&quot;&gt;&quot;/home/&quot;:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        response = b&lt;span class=&quot;string&quot;&gt;&quot;home&quot;  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;else:  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        response = b&lt;span class=&quot;string&quot;&gt;&quot;404 not found!&quot;  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn.send(response)  &lt;/li&gt;
&lt;li&gt;    conn.close()  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;h3&gt;根据不同的路径返回不同的内容--函数版&lt;/h3&gt;
&lt;p&gt;上面的代码解决了不同URL路径返回不同内容的需求。&lt;/p&gt;
&lt;p&gt;我们返回的内容是简单的几个字符，那如果我可以将返回的结果封装成一个函数呢？&lt;/p&gt;
&lt;div class=&quot;dp-highlighter&quot;&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;/&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;/&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import socket  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk = socket.socket()  &lt;/li&gt;
&lt;li&gt;sk.bind((&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;, &lt;span class=&quot;number&quot;&gt;8080))  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk.listen()  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def func(url):  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    s = &lt;span class=&quot;string&quot;&gt;&quot;这是{}页面！&quot;.format(url)  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;while &lt;span class=&quot;special&quot;&gt;True:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    conn, add = sk.accept()  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    data = conn.recv(&lt;span class=&quot;number&quot;&gt;8096)  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    data = str(data, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    data1 = data.split(&lt;span class=&quot;string&quot;&gt;&quot;\r\n&quot;)[&lt;span class=&quot;number&quot;&gt;0]  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    url = data1.split()[&lt;span class=&quot;number&quot;&gt;1]  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn.send(b&lt;span class=&quot;string&quot;&gt;'HTTP/1.1 200 OK\r\n\r\n')  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if url == &lt;span class=&quot;string&quot;&gt;&quot;/index/&quot;:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        response = func(url)  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;elif url == &lt;span class=&quot;string&quot;&gt;&quot;/home/&quot;:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        response = func(url)  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else:  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        response = b&lt;span class=&quot;string&quot;&gt;&quot;404 not found!&quot;  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;    conn.send(response)  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn.close()  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;h3&gt;根据不同的路径返回不同的内容--函数进阶版&lt;/h3&gt;
&lt;p&gt;看起来上面的代码写了一个函数，那肯定可以写多个函数，不同的路径对应执行不同的函数拿到结果，但是我们要一个个判断路径，是不是很麻烦？我们有简单的办法来解决。&lt;/p&gt;
&lt;div class=&quot;dp-highlighter&quot;&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;/&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;/&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import socket  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk = socket.socket()  &lt;/li&gt;
&lt;li&gt;sk.bind((&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;, &lt;span class=&quot;number&quot;&gt;8080))  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk.listen()  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def index(url):  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    s = &lt;span class=&quot;string&quot;&gt;&quot;这是{}页面XX！&quot;.format(url)  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;def home(url):  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    s = &lt;span class=&quot;string&quot;&gt;&quot;这是{}页面。。！&quot;.format(url)  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;/&gt;
&lt;li&gt;list1 = [  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/index/&quot;, index),  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/home/&quot;, home),  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;]  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while &lt;span class=&quot;special&quot;&gt;True:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn, add = sk.accept()  &lt;/li&gt;
&lt;li&gt;    data = conn.recv(&lt;span class=&quot;number&quot;&gt;8096)  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    data = str(data, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    data1 = data.split(&lt;span class=&quot;string&quot;&gt;&quot;\r\n&quot;)[&lt;span class=&quot;number&quot;&gt;0]  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    url = data1.split()[&lt;span class=&quot;number&quot;&gt;1]  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    conn.send(b&lt;span class=&quot;string&quot;&gt;'HTTP/1.1 200 OK\r\n\r\n')  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    func = &lt;span class=&quot;special&quot;&gt;None  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for item &lt;span class=&quot;keyword&quot;&gt;in list1:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        &lt;span class=&quot;keyword&quot;&gt;if item[&lt;span class=&quot;number&quot;&gt;0] == url:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;            func = item[&lt;span class=&quot;number&quot;&gt;1]  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            &lt;span class=&quot;keyword&quot;&gt;break  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if func:  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        response = func(url)  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else:  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        response = b&lt;span class=&quot;string&quot;&gt;&quot;404 not found!&quot;  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn.send(response)  &lt;/li&gt;
&lt;li&gt;    conn.close()  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;h3&gt;返回具体的HTML文件&lt;/h3&gt;
&lt;p&gt;完美解决了不同URL返回不同内容的问题。 但是我不想仅仅返回几个字符串，我想给浏览器返回完整的HTML内容，这又该怎么办呢？&lt;/p&gt;
&lt;p&gt;没问题，不管是什么内容，最后都是转换成字节数据发送出去的。 我们可以打开HTML文件，读取出它内部的二进制数据，然后再发送给浏览器。&lt;/p&gt;
&lt;div class=&quot;dp-highlighter&quot;&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;/&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;/&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;import socket  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;sk = socket.socket()  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk.bind((&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;, &lt;span class=&quot;number&quot;&gt;8080))  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;sk.listen()  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;/&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;def index(url):  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    with open(&lt;span class=&quot;string&quot;&gt;&quot;index.html&quot;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;) as f:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        s = f.read()  &lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;def home(url):  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    with open(&lt;span class=&quot;string&quot;&gt;&quot;home.html&quot;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;) as f:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        s = f.read()  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;&gt;list1 = [  &lt;/li&gt;
&lt;li&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/index/&quot;, index),  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/home/&quot;, home),  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;]  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;while &lt;span class=&quot;special&quot;&gt;True:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    conn, add = sk.accept()  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    data = conn.recv(&lt;span class=&quot;number&quot;&gt;8096)  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    data = str(data, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    data1 = data.split(&lt;span class=&quot;string&quot;&gt;&quot;\r\n&quot;)[&lt;span class=&quot;number&quot;&gt;0]  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    url = data1.split()[&lt;span class=&quot;number&quot;&gt;1]  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn.send(b&lt;span class=&quot;string&quot;&gt;'HTTP/1.1 200 OK\r\n\r\n')  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    func = &lt;span class=&quot;special&quot;&gt;None  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;for item &lt;span class=&quot;keyword&quot;&gt;in list1:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if item[&lt;span class=&quot;number&quot;&gt;0] == url:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            func = item[&lt;span class=&quot;number&quot;&gt;1]  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;if func:  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        response = func(url)  &lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;else:  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        response = b&lt;span class=&quot;string&quot;&gt;&quot;404 not found!&quot;  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    conn.send(response)  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn.close()  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ccd5d0ef-d66e-4e10-884f-c1cc4693bfb8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ccd5d0ef-d66e-4e10-884f-c1cc4693bfb8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ccd5d0ef-d66e-4e10-884f-c1cc4693bfb8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;x-ua-compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是index页面&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;index.html&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_1458daee-5720-40be-a292-e4d3afdd9809&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1458daee-5720-40be-a292-e4d3afdd9809&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1458daee-5720-40be-a292-e4d3afdd9809&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;x-ua-compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是home页面&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;home.html&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3&gt;让网页动态起来&lt;/h3&gt;
&lt;p&gt;这网页能够显示出来了，但是都是静态的啊。页面的内容都不会变化的，我想要的是动态网站。&lt;/p&gt;
&lt;p&gt;没问题，我也有办法解决。我选择使用字符串替换来实现这个需求。（这里使用时间戳来模拟动态的数据）&lt;/p&gt;
&lt;div class=&quot;dp-highlighter&quot;&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;/&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;/&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;import socket  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;sk = socket.socket()  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;sk.bind((&lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;, &lt;span class=&quot;number&quot;&gt;8080))  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;sk.listen()  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;/&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;def index(url):  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    with open(&lt;span class=&quot;string&quot;&gt;&quot;index.html&quot;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;) as f:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        s = f.read()  &lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;def home(url):  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    with open(&lt;span class=&quot;string&quot;&gt;&quot;home.html&quot;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;) as f:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        s = f.read()  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;def timer(url):  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;import time  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    with open(&lt;span class=&quot;string&quot;&gt;&quot;time.html&quot;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;) as f:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        s = f.read()  &lt;/li&gt;
&lt;li&gt;        s = s.replace(&lt;span class=&quot;string&quot;&gt;'@@time@@', time.strftime(&lt;span class=&quot;string&quot;&gt;&quot;%Y-%m-%d %H:%M:%S&quot;))  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;&gt;list1 = [  &lt;/li&gt;
&lt;li&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/index/&quot;, index),  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/home/&quot;, home),  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/time/&quot;, timer),  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;]  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while &lt;span class=&quot;special&quot;&gt;True:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn, add = sk.accept()  &lt;/li&gt;
&lt;li&gt;    data = conn.recv(&lt;span class=&quot;number&quot;&gt;8096)  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    data = str(data, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    data1 = data.split(&lt;span class=&quot;string&quot;&gt;&quot;\r\n&quot;)[&lt;span class=&quot;number&quot;&gt;0]  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    url = data1.split()[&lt;span class=&quot;number&quot;&gt;1]  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    conn.send(b&lt;span class=&quot;string&quot;&gt;'HTTP/1.1 200 OK\r\n\r\n')  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    func = &lt;span class=&quot;special&quot;&gt;None  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for item &lt;span class=&quot;keyword&quot;&gt;in list1:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        &lt;span class=&quot;keyword&quot;&gt;if item[&lt;span class=&quot;number&quot;&gt;0] == url:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;            func = item[&lt;span class=&quot;number&quot;&gt;1]  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            &lt;span class=&quot;keyword&quot;&gt;break  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if func:  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        response = func(url)  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else:  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        response = b&lt;span class=&quot;string&quot;&gt;&quot;404 not found!&quot;  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    conn.send(response)  &lt;/li&gt;
&lt;li&gt;    conn.close()  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;h2&gt;服务器程序和应用程序&lt;/h2&gt;
&lt;p&gt;对于真实开发中的python web程序来说，一般会分为两部分：服务器程序和应用程序。&lt;/p&gt;
&lt;p&gt;服务器程序负责对socket服务端进行封装，并在请求到来时，对请求的各种数据进行整理。&lt;/p&gt;
&lt;p&gt;应用程序则负责具体的逻辑处理。为了方便应用程序的开发，就出现了众多的Web框架，例如：Django、Flask、web.py 等。不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。&lt;/p&gt;

&lt;p&gt;这样，服务器程序就需要为不同的框架提供不同的支持。这样混乱的局面无论对于服务器还是框架，都是不好的。对服务器来说，需要支持各种不同框架，对框架来说，只有支持它的服务器才能被开发出的应用使用。&lt;/p&gt;
&lt;p&gt;这时候，标准化就变得尤为重要。我们可以设立一个标准，只要服务器程序支持这个标准，框架也支持这个标准，那么他们就可以配合使用。一旦标准确定，双方各自实现。这样，服务器可以支持更多支持标准的框架，框架也可以使用更多支持标准的服务器。&lt;/p&gt;
&lt;p&gt;WSGI（Web Server Gateway Interface）就是一种规范，它定义了使用Python编写的web应用程序与web服务器程序之间的接口格式，实现web应用程序与web服务器程序间的解耦。&lt;/p&gt;
&lt;p&gt;常用的WSGI服务器有uwsgi、Gunicorn。而Python标准库提供的独立WSGI服务器叫wsgiref，Django开发环境用的就是这个模块来做服务器。&lt;/p&gt;

&lt;p&gt;从这继续...&lt;/p&gt;

&lt;h3&gt;wsgiref&lt;/h3&gt;
&lt;p&gt;我们利用wsgiref模块来替换我们自己写的web框架的socket server部分：&lt;/p&gt;
&lt;div class=&quot;dp-highlighter&quot;&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;/&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;/&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;/&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;&gt;     &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;from wsgiref.simple_server &lt;span class=&quot;keyword&quot;&gt;import make_server   &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;     &lt;/li&gt;
&lt;li&gt;     &lt;/li&gt;
&lt;li class=&quot;alt&quot;/&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;def index(url):   &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;/li&gt;
&lt;li&gt;    with open(&lt;span class=&quot;string&quot;&gt;&quot;index.html&quot;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;) as f:   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        s = f.read()   &lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)   &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;     &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;     &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;def home(url):   &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    with open(&lt;span class=&quot;string&quot;&gt;&quot;home.html&quot;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;) as f:   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        s = f.read()   &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)   &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;     &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;     &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;def timer(url):   &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;import time   &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    with open(&lt;span class=&quot;string&quot;&gt;&quot;time.html&quot;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;) as f:   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        s = f.read()   &lt;/li&gt;
&lt;li&gt;        s = s.replace(&lt;span class=&quot;string&quot;&gt;'@@time@@', time.strftime(&lt;span class=&quot;string&quot;&gt;&quot;%Y-%m-%d %H:%M:%S&quot;))   &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)   &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;     &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;     &lt;/li&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;&gt;list1 = [   &lt;/li&gt;
&lt;li&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/index/&quot;, index),   &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/home/&quot;, home),   &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/time/&quot;, timer),   &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;]   &lt;/li&gt;
&lt;li&gt;     &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;     &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;def run_server(environ, start_response):   &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    start_response(&lt;span class=&quot;string&quot;&gt;'200 OK', [(&lt;span class=&quot;string&quot;&gt;'Content-Type', &lt;span class=&quot;string&quot;&gt;'text/html;charset=utf8'), ])  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    url = environ[&lt;span class=&quot;string&quot;&gt;'PATH_INFO']  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    func = &lt;span class=&quot;special&quot;&gt;None   &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;for i &lt;span class=&quot;keyword&quot;&gt;in list1:   &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if i[&lt;span class=&quot;number&quot;&gt;0] == url:   &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            func = i[&lt;span class=&quot;number&quot;&gt;1]   &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break   &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;if func:   &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        response = func(url)   &lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;else:   &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        response = b&lt;span class=&quot;string&quot;&gt;&quot;404 not found!&quot;   &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;return [response, ]   &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;     &lt;/li&gt;
&lt;li&gt;     &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if __name__ == &lt;span class=&quot;string&quot;&gt;'__main__':   &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    httpd = make_server(&lt;span class=&quot;string&quot;&gt;'127.0.0.1', &lt;span class=&quot;number&quot;&gt;8090, run_server)   &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;我在8090等你哦...&quot;)   &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    httpd.serve_forever()  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;h3&gt;jinja2&lt;/h3&gt;
&lt;p&gt;上面的代码实现了一个简单的动态，我完全可以从数据库中查询数据，然后去替换我html中的对应内容，然后再发送给浏览器完成渲染。 这个过程就相当于HTML模板渲染数据。 本质上就是HTML内容中利用一些特殊的符号来替换要展示的数据。 我这里用的特殊符号是我定义的，其实模板渲染有个现成的工具： &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;jinja2&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pln&quot;&gt;下载jinja2:&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
pip install jinja2
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_837ff554-07aa-413e-92f5-a35794350e6d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_837ff554-07aa-413e-92f5-a35794350e6d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_837ff554-07aa-413e-92f5-a35794350e6d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;zh-CN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;x-ua-compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名：{{name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;爱好：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {% for hobby in hobby_list %}
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{hobby}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {% endfor %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;index2.html文件&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;pln&quot;&gt;使用jinja2渲染index2.html文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;dp-highlighter&quot;&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from wsgiref.simple_server &lt;span class=&quot;keyword&quot;&gt;import make_server  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;from jinja2 &lt;span class=&quot;keyword&quot;&gt;import Template  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def index(url):  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    with open(&lt;span class=&quot;string&quot;&gt;&quot;index2.html&quot;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;) as f:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        data = f.read()  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;        template = Template(data)   &lt;/li&gt;
&lt;li&gt;        ret = template.render({&lt;span class=&quot;string&quot;&gt;'name': &lt;span class=&quot;string&quot;&gt;'alex', &lt;span class=&quot;string&quot;&gt;'hobby_list': [&lt;span class=&quot;string&quot;&gt;'抽烟', &lt;span class=&quot;string&quot;&gt;'喝酒', &lt;span class=&quot;string&quot;&gt;'烫头']})   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(ret, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;def home(url):  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    with open(&lt;span class=&quot;string&quot;&gt;&quot;home.html&quot;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;) as f:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        s = f.read()  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return bytes(s, encoding=&lt;span class=&quot;string&quot;&gt;&quot;utf8&quot;)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li/&gt;
&lt;li class=&quot;alt&quot;&gt;list1 = [  &lt;/li&gt;
&lt;li&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/index/&quot;, index),  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    (&lt;span class=&quot;string&quot;&gt;&quot;/home/&quot;, home),  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;]  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def run_server(environ, start_response):  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    start_response(&lt;span class=&quot;string&quot;&gt;'200 OK', [(&lt;span class=&quot;string&quot;&gt;'Content-Type', &lt;span class=&quot;string&quot;&gt;'text/html;charset=utf8'), ])  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    url = environ[&lt;span class=&quot;string&quot;&gt;'PATH_INFO']  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    func = &lt;span class=&quot;special&quot;&gt;None  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for i &lt;span class=&quot;keyword&quot;&gt;in list1:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        &lt;span class=&quot;keyword&quot;&gt;if i[&lt;span class=&quot;number&quot;&gt;0] == url:  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;            func = i[&lt;span class=&quot;number&quot;&gt;1]  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;            &lt;span class=&quot;keyword&quot;&gt;break  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if func:  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        response = func(url)  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else:  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;        response = b&lt;span class=&quot;string&quot;&gt;&quot;404 not found!&quot;  &lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return [response, ]  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;if __name__ == &lt;span class=&quot;string&quot;&gt;'__main__':  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    httpd = make_server(&lt;span class=&quot;string&quot;&gt;'127.0.0.1', &lt;span class=&quot;number&quot;&gt;8090, run_server)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;    &lt;span class=&quot;keyword&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;我在8090等你哦...&quot;)  &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;    httpd.serve_forever()  &lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;现在的数据是我们自己手写的，那可不可以从数据库中查询数据，来填充页面呢？&lt;/p&gt;
&lt;p&gt;使用pymysql连接数据库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;

&lt;pre&gt;
conn = pymysql.connect(host=&quot;127.0.0.1&quot;, port=3306, user=&quot;root&quot;, passwd=&quot;xxx&quot;, db=&quot;xxx&quot;, charset=&quot;utf8&quot;)
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
cursor.execute(&quot;select name, age, department_id from userinfo&quot;)
user_list = cursor.fetchall()
cursor.close()
conn.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个测试的user表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
CREATE TABLE user(
  id int auto_increment PRIMARY KEY,
  name CHAR(10) NOT NULL,
  hobby CHAR(20) NOT NULL
)engine=innodb DEFAULT charset=UTF8;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模板的原理就是字符串替换，我们只要在HTML页面中遵循jinja2的语法规则写上，其内部就会按照指定的语法进行相应的替换，从而达到动态的返回内容。&lt;/p&gt;

</description>
<pubDate>Fri, 14 Sep 2018 11:32:00 +0000</pubDate>
<dc:creator>o微凉o</dc:creator>
<og:description>Web框架本质 Web框架本质 我们可以这样理解：所有的Web应用本质上就是一个socket服务端，而用户的浏览器就是一个socket客户端。 这样我们就可以自己实现Web框架了。 socket服务端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuye1990/p/9648455.html</dc:identifier>
</item>
<item>
<title>Perl正则表达式超详细教程 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9648439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9648439.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;想必学习perl的人，对基础正则表达式都已经熟悉，所以学习perl正则会很轻松。这里我不打算解释基础正则的内容，而是直接介绍基础正则中不具备的但perl支持的功能。关于基础正则表达式的内容，可参阅&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9621130.html&quot;&gt;基础正则表达式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我第一个要说明的是，perl如何使用正则。还记得当初把《精通正则表达式》的书看了一遍，把perl正则也学了个七七八八，但是学完后却不知道怎么去使用perl正则，虽然里面也介绍了一点如何使用perl语言，grep的&quot;-P&quot;选项使用的也是perl正则，ack工具支持的也完全是perl正则，但都没有完整地体现perl正则的功能，总感觉缺点啥。最大的无奈莫过于此了，学了知识，却不知道怎么完整地应用。所以，我把如何使用perl正则来匹配数据放在最开头介绍，包括匹配指定字符串、匹配变量、匹配标准输入(如管道传递的数据)以及匹配文件中的每一行数据，而且后文我假设各位和我当初一样，完全没有perl语言基础，所以我会介绍一些perl语言和后文相关的语法，确保全文学习过程没有任何阻塞。&lt;/p&gt;
&lt;p&gt;另外，本系列只介绍匹配操作，关于内容替换，因为和学习使用perl正则并无多大关系，所以替换相关的将在下一篇文章单独解释。&lt;/p&gt;
&lt;p&gt;这里推荐一个学正则非常好的资料：stackflow上关于各种语言(perl/python/.net/java/ruby等等)的正则的解释、示例，这里收集的都是对问题解释的非常清晰且非常经典的回答。在我学习perl正则的时候，对有些功能实在理解不了(想必你也一定会)，就会从这里找答案，而它，也从来没让我失望：https://stackoverflow.com/questions/22937618/reference-what-does-this-regex-mean/22944075#22944075&lt;/p&gt;
&lt;p&gt;以下是perl正则的man文档：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;perl正则快速入门：man perlrequick&lt;/li&gt;
&lt;li&gt;perl正则教程：man perlretut&lt;/li&gt;
&lt;li&gt;perl正则完整文档：man perlre&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;学perl正则必备的一点基本语法&quot;&gt;学perl正则必备的一点基本语法&lt;/h2&gt;
&lt;p&gt;新建一个文件作为perl脚本文件，在其首行写上&lt;code&gt;#!/usr/bin/perl&lt;/code&gt;，它表示用perl作为本文件的解释器。写入一些perl程序后，再赋予执行权限就可以执行了，或者直接使用perl命令去调用这个脚本文件，前面的两个过程都可以省略，这和shell脚本的方式是完全一样的，无非是将bash替换为了perl，想必各位都理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.print用来输出信息&lt;/strong&gt;，相当于shell中的echo命令，但需要手动输入换行符&quot;\n&quot;进行换行。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl

print &quot;hello world\n&quot;;      # 注意每一句后面都使用分号结尾&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存后，执行它(假设脚本文件名为test.pl)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ chmod +x test.pl
$ perl test.pl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.变量赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;perl中的变量可以不用事先声明，可以直接赋值甚至直接引用。注意变量名前面总是需要加上$符号，无论是赋值的时候还是引用的时候，这和其它语言不太一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl

$name=&quot;longshuai&quot;;
$age=18;
print &quot;$name $age \n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.if语句用来判断&lt;/strong&gt;，语法格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(condition){
    body
}else{
    body
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$age = 18;
if($age &amp;lt;= 20){
    print &quot;age less than 20\n&quot;;
} else {
    print &quot;age greate than 20\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.默认参数变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在perl中，对于需要参数的函数或表达式，但却没有给参数，这是将会使用perl的默认参数变量&lt;code&gt;$_&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如，下面的print本来是需要参数的，但是因为没有给参数，print将输出默认的参数变量&lt;code&gt;$_&lt;/code&gt;，也就是输出&quot;abcde&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$_=&quot;abcde&quot;;
print ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;perl中使用&lt;code&gt;$_&lt;/code&gt;的地方非常多，后文还会出现，不过用到的时候我会解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.读取标准输入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;perl中使用一对尖括号格式的&lt;code&gt;&amp;lt;STDIN&amp;gt;&lt;/code&gt;来读取来自非文件的标准输入，例如来自管道的数据，来自输入重定向的数据或者来自键盘的输入。需要注意的是，&lt;code&gt;&amp;lt;STDIN&amp;gt;&lt;/code&gt;读取的输入会自带换行符，所以print输出的时候不要加上额外的换行符。&lt;/p&gt;
&lt;p&gt;例如，在test.pl文件中写入如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl

$data=&amp;lt;STDIN&amp;gt;;
print &quot;$data&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后用管道传递一行数据给perl程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo &quot;abcdefg&quot; | perl test.pl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只是需要注意，将&lt;code&gt;&amp;lt;STDIN&amp;gt;&lt;/code&gt;赋值给变量时，将只能读取一行(遇到换行符就结束读取)。例如下面的perl将读取不了&quot;hijklmn&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo -e &quot;abcdefg\nhijklmn&quot; | perl test.pl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要读取多行标准输入，就不能将其赋值给变量，而是使用foreach来遍历各行(此处不介绍其它方式)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foreach $line (&amp;lt;STDIN&amp;gt;){
    print &quot;$line&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是foreach的语法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;圆括号中的内容是待遍历对象，通常是一个列表，比如上面用&lt;code&gt;&amp;lt;STDIN&amp;gt;&lt;/code&gt;读取的多行数据就是一个列表，每一行都是列表中的一个元素；&lt;/li&gt;
&lt;li&gt;$line称为控制变量，foreach在每次迭代过程中都会选中一个列表中的元素赋值给$line，例如将读取的每一行都赋值给$line。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以省略$line，这时就采用默认的参数变量&lt;code&gt;$_&lt;/code&gt;，所以以下两个表达式是等价的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foreach (&amp;lt;STDIN&amp;gt;){
    print &quot;$_&quot;;
}

foreach $_ (&amp;lt;STDIN&amp;gt;){
    print &quot;$_&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6.读取文件中的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正则强大的用处就是处理文本数据，所以必须要说明perl如何读取文件数据来做正则匹配。&lt;/p&gt;
&lt;p&gt;我们可以将文件作为perl命令行的参数，perl会使用&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;去读取这些文件中的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foreach (&amp;lt;&amp;gt;){
    print &quot;$_&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行的时候，只要把文件作为perl命令或脚本文件的参数即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;perl test.pl /etc/passwd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;7.去掉行尾分隔符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;STDIN&amp;gt;&lt;/code&gt;读取文件、读取标准输入的时候总是自带换行符，很多时候这个自带的换行符都会带来格式问题。所以，有必要在每次读取数据时将行尾的换行符去掉，使用chomp即可。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foreach $line (&amp;lt;STDIN&amp;gt;) {
    chomp $line;
    print &quot;$line read\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi ~]# echo -e &quot;malongshuai gaoxiaofang&quot; | perl 26.plx 
malongshuai gaoxiaofang read&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果上面的例子中不加上chomp，那么执行结果将像下面一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi perlapp]# echo -e &quot;malongshuai gaoxiaofang&quot; | perl 26.plx 
malongshuai gaoxiaofang
 read&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，输出格式和print语句中期待的输出格式不一样。&lt;/p&gt;
&lt;p&gt;前面说过，可以省略&lt;code&gt;$line&lt;/code&gt;，让其使用默认的参数变量&lt;code&gt;$_&lt;/code&gt;，所以可以这样读取来自perl命令行参数文件的数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foreach (&amp;lt;&amp;gt;) {
    chomp;
    print &quot;$_ read\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;8.命令行的操作模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实就是一行式。perl命令行加上&quot;-e&quot;选项，就能在perl命令行中直接写perl表达式，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo &quot;malongshuai&quot; | perl -e '$name=&amp;lt;STDIN&amp;gt;;print $name;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为perl最为人所知的就是它应用了各种符号的组合，让人看着怪异无比，而这些符号放在命令行中很可能会被shell先解析，所以强烈建议&quot;-e&quot;后表达式使用单引号包围，而不是双引号。&lt;/p&gt;
&lt;p&gt;更建议，如果可以，不要使用perl命令行的方式，调试起来容易混乱。&lt;/p&gt;
&lt;h2 id=&quot;perl如何使用正则进行匹配&quot;&gt;perl如何使用正则进行匹配&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;=~&lt;/code&gt;符号表示要用右边的正则表达式对左边的数据进行匹配。正则表达式的书写方式为&lt;code&gt;m//&lt;/code&gt;。关于&lt;code&gt;m//&lt;/code&gt;，其中斜线可以替换为其它符号，规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;双斜线可以替换为任意其它对应符号，例如对称的括号类，&lt;code&gt;m()&lt;/code&gt;，&lt;code&gt;m{}&lt;/code&gt;，相同的标点类，&lt;code&gt;m!!&lt;/code&gt;，&lt;code&gt;m%%&lt;/code&gt;等等&lt;/li&gt;
&lt;li&gt;只有当m模式采用双斜线的时候，可以省略m字母，即&lt;code&gt;//&lt;/code&gt;等价于&lt;code&gt;m//&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果正则表达式中出现了和分隔符相同的字符，可以转义表达式中的符号，但更建议换分隔符，例如&lt;code&gt;/http:\/\//&lt;/code&gt;转换成&lt;code&gt;m%http://%&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以要匹配内容，有以下两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方式一：使用&lt;code&gt;data =~ m/reg/&lt;/code&gt;，可以明确指定要对data对应的内容进行正则匹配&lt;/li&gt;
&lt;li&gt;方式二：直接&lt;code&gt;/reg/&lt;/code&gt;，因为省略了参数，所以使用默认参数变量，它等价于&lt;code&gt;$_ =~ m/reg/&lt;/code&gt;，也就是对&lt;code&gt;$_&lt;/code&gt;保存的内容进行正则匹配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;perl中匹配操作返回的是匹配成功与否，成功则返回真，匹配不成功则返回假。当然，perl提供了特殊变量允许访问匹配到的内容，甚至匹配内容之前的数据、匹配内容之后的数据都提供了相关变量以便访问。见下面的示例。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.匹配给定字符串内容&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$name = &quot;hello gaoxiaofang&quot;;
if ($name =~ m/gao/){
    print &quot;matched\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，直接将字符串拿来匹配：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;hello gaoxiaofang&quot; =~ m/gao/;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.匹配来自管道的每一行内容，匹配成功的行则输出&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foreach (&amp;lt;STDIN&amp;gt;){
    chomp;
    if (/gao/){
        print &quot;$_ was matched 'gao'\n&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面使用了默认的参数变量&lt;code&gt;$_&lt;/code&gt;，它表示foreach迭代的每一行数据；上面还简写的正则匹配方式&lt;code&gt;/gao/&lt;/code&gt;，它等价于&lt;code&gt;$_ =~ m/gao/&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以下是执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi perlapp]# echo -e &quot;malongshuai gaoxiaofang&quot; | perl 26.plx  
malongshuai gaoxiaofang was matched 'gao'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.匹配文件中每行数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foreach (&amp;lt;&amp;gt;){
    chomp;
    if(/gao/){
        print &quot;$_ was matched 'gao'\n&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.如果想要输出匹配到的内容，可以使用特殊变量&lt;code&gt;$&amp;amp;&lt;/code&gt;来引用匹配到的内容，还可以使用&lt;code&gt;$`&lt;/code&gt;引用匹配前面部分的内容，&lt;code&gt;$'&lt;/code&gt;引用匹配后面部分的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aAbBcC =~ /bB/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于匹配的内容是bB，匹配内容之前的部分是aA，匹配之后的部分是cC，于是可以看作下面对应关系：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; (aA)(bB)(cC)
 |    |   |
 $`   $&amp;amp;  $'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是使用这三个特殊变量的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$name=&quot;aAbBcC&quot;;
if(/bB/){
    print &quot;pre match: $` \n&quot;;
    print &quot;match: $&amp;amp; \n&quot;;
    print &quot;post match: $' \n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，正则中一般都提供全局匹配的功能，perl中使用修饰符&lt;code&gt;/g&lt;/code&gt;开启。当开启了全局匹配功能，这3个变量保存的值需要使用循环语句去遍历，否则将只保存第一次匹配的内容。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$name=&quot;aAbBcCbB&quot;;
if(/bB/g){        # 匹配完第一个bB就结束
    print &quot;pre match: $` \n&quot;;
    print &quot;match: $&amp;amp; \n&quot;;
    print &quot;post match: $' \n&quot;;
}

while(/bB/g){   # 将迭代两次
    print &quot;pre match: $` \n&quot;;
    print &quot;match: $&amp;amp; \n&quot;;
    print &quot;post match: $' \n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;perl支持的正则&quot;&gt;perl支持的正则&lt;/h2&gt;
&lt;p&gt;从这里开始，正式介绍perl支持的正则。&lt;/p&gt;
&lt;p&gt;出于方便，我全部都直接在perl程序内部定义待匹配的内容，如果想要匹配管道传递的输入，或者匹配文件数据，请看上文获取操作方法。&lt;/p&gt;
&lt;p&gt;为了完整性，每一节中我都是先把一大堆的内容列出来做个简单介绍，然后再用示例解释每个(或某几个)。但perl正则的内容太多，而且很多功能前后关联，所以如果列出来的内容没有在同一小节内介绍，那么就是在后面需要的地方介绍。当然，也有些没什么用或者用的很少的功能(比如unicode相关的)，通篇都不会介绍。&lt;/p&gt;
&lt;h3 id=&quot;模式匹配修饰符&quot;&gt;模式匹配修饰符&lt;/h3&gt;
&lt;p&gt;指定模式匹配的修饰符，可以改变正则表达式的匹配行为。例如，下面的i就是一种修饰符，它让前面的正则REG匹配时忽略大小写。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;m/REG/i&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;perl总共支持以下几种修饰符：msixpodualngc&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;i&lt;/code&gt;：匹配时忽略大小写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt;：全局匹配，默认情况下，正则表达式&quot;abc&quot;匹配&quot;abcdabc&quot;字符串的时候，将之匹配左边的abc，使用g将匹配两个&quot;abc&quot;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt;：在开启g的情况下，如果匹配失败，将不重置搜索位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt;：多行匹配模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt;：让&lt;code&gt;.&lt;/code&gt;可以匹配换行符&quot;\n&quot;，也就是说该修饰符让&lt;code&gt;.&lt;/code&gt;真的可以匹配任意字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;：允许正则表达式使用空白符号，免得让整个表达式难读难懂，但这样会让原本的空白符号失去意义，这是可以使用&lt;code&gt;\s&lt;/code&gt;来表示空白&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt;：只编译一次正则表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;：非捕获模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt;：保存匹配的字符串到&lt;code&gt;${^PREMATCH}&lt;/code&gt;、&lt;code&gt;${^MATCH}&lt;/code&gt;、&lt;code&gt;${^POSTMATCH}&lt;/code&gt;中，它们在结果上对应&lt;code&gt;$`&lt;/code&gt;、&lt;code&gt;$&amp;amp;&lt;/code&gt;和&lt;code&gt;$'&lt;/code&gt;，但性能上要更好&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;u&lt;/code&gt;和&lt;code&gt;l&lt;/code&gt;：分别表示用ASCII、Unicode和Locale的方式来解释正则表达式，一般不用考虑这几个修饰符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;：使用unicode或原生字符集，就像5.12和之前那样，也不用考虑这个修饰符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些修饰符可以连用，连用时顺序可随意。例如下面两行是等价的行为：全局忽略大小写的匹配行为。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;m/REG/ig
m/REG/gi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的修饰符，本节介绍igcmsxpo这几个修饰符，n修饰符在后面分组捕获的地方解释，auld修饰符和字符集相关，不打算解释。&lt;/p&gt;
&lt;h4 id=&quot;i修饰符忽略大小写&quot;&gt;i修饰符：忽略大小写&lt;/h4&gt;
&lt;p&gt;该修饰符使得正则匹配的时候，忽略大小写。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$name=&quot;aAbBcC&quot;;
if($name =~ m/ab/i){
    print &quot;pre match: $` \n&quot;;     # 输出a
    print &quot;match: $&amp;amp; \n&quot;;         # 输出Ab
    print &quot;post match: $' \n&quot;;    # 输出BcC
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;g和c修饰符以及g&quot;&gt;g和c修饰符以及\G&lt;/h4&gt;
&lt;p&gt;g修饰符(global)使得正则匹配的时候，对字符串做全局匹配，也就是说，即使前面匹配成功了，还会继续向后匹配，看是否还能匹配成功。&lt;/p&gt;
&lt;p&gt;例如，字符串&quot;abcabc&quot;，正则表达式&quot;ab&quot;，在默认情况下(不是全局匹配)该正则在匹配到第一个ab后就结束了，如果使用了g修饰符，匹配完第一个ab，还会继续向后匹配，而且正好还能匹配到第二个ab，所以最终有两个ab被匹配成功。&lt;/p&gt;
&lt;p&gt;要验证多次匹配，需要使用循环遍历的方式，而不能用if语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$name=&quot;aAbBcCaBc&quot;;
while($name =~ m/ab/gi){
    print &quot;pre match: $` \n&quot;;
    print &quot;match: $&amp;amp; \n&quot;;
    print &quot;post match: $' \n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行它，将输出如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pre match: a 
match: Ab 
post match: BcCabd 
pre match: aAbBcC 
match: ab 
post match: d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下内容，如果仅仅只是为了学perl正则，那么可以跳过，因为很难，如果是学perl语言，那么可以继续看下去。&lt;/p&gt;
&lt;p&gt;实际上，&lt;strong&gt;在开启了g全局匹配后&lt;/strong&gt;，perl每次在&lt;strong&gt;成功匹配&lt;/strong&gt;的时候都会记下匹配的字符位移，以便在下次匹配该内容时候，可以从指定位移处继续向后匹配。每次&lt;strong&gt;匹配成功后&lt;/strong&gt;的位移值(pos的位移从0开始算，0位移代表的是第一个字符左边的位置)，都可以通过pos()函数获取。如果本次匹配导致位移指针重置，pos将返回undef。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$name=&quot;123ab456&quot;;
$name =~ m/\d\d/g;     # 第一次匹配，匹配成功后记下位移
print &quot;matched string: $&amp;amp;, position: &quot;,pos $name,&quot;\n&quot;;
$name =~ m/\d\d/g;     # 第二次匹配，匹配成功后记下位移
print &quot;matched string: $&amp;amp;, position: &quot;,pos $name,&quot;\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行它，将输出如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;matched string: 12, position: 2
matched string: 45, position: 7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于匹配失败的时候，正则匹配操作会返回假，所以可以作为if或while等的条件语句。例如，改为while循环多次匹配：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$name=&quot;123ab456&quot;;
while($name =~ m/\d\d/g){
    print &quot;matched string: $&amp;amp;, position: &quot;,pos $name,&quot;\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认全局匹配情况下，当本次匹配失败，位移指针将重置到起始位置0处，也就是说，下次匹配将从头开始匹配。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt=&quot;1234a56&quot;;
$txt =~ /\d\d/g;      # 匹配成功：12，位移向后移两位
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d\d/g;      # 匹配成功：34，位移向后移两位
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d\d\d/g;      # 匹配失败，位移指针回到0处，pos()返回undef
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d/g;          # 匹配成功：1，位移向后移1位
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上述程序，将输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;matched 12: 2
matched 34: 4
matched 34: 
matched 1: 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果&quot;g&quot;修饰符下同时使用&quot;c&quot;修饰符，也就是&quot;gc&quot;，它表示全局匹配失败的时候不重置位移指针。也就是说，本次匹配失败后，位移指针会向后移一位，下次匹配将从后移的这个位置处开始匹配。当位移移到了结尾，将无法再移动，此时位移指针将一直指向最后一个位置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt=&quot;1234a56&quot;;
$txt =~ /\d\d/g;
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d\d/g;
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d\d\d/gc;   # 匹配失败，位移向后移1位，$&amp;amp;和pos()保留上一次匹配成功的内容
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d/g;        # 匹配成功：5，位移向后移1位
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d/g;        # 匹配成功：6，位移向后移1位
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d/gc;        # 匹配失败：位移无法再后移，将一直指向最后一个位置
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上述程序，将输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;matched 12: 2
matched 34: 4
matched 34: 4
matched 5: 6
matched 6: 7
matched 6: 7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续上面的问题，如果第三个匹配语句不是&lt;code&gt;\d\d\d&lt;/code&gt;，而是&quot;\d&quot;，它匹配字母a的时候也失败，不用c修饰符的时候会重置位移吗？显然是不会。因为它会继续向后匹配。所以该&lt;code&gt;\G&lt;/code&gt;登场了。&lt;/p&gt;
&lt;p&gt;默认全局匹配情况下，匹配时是可以跳过匹配失败的字符继续匹配的：当某个字符匹配失败，它会后移一位继续去匹配，直到匹配成功或匹配结束。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt=&quot;1234ab56&quot;;
$txt =~ /\d\d/g;
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d\d/g;
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d/g;       # 字母a匹配失败，后移一位，字母b匹配失败，后移一位，数值5匹配成功
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d/g;       # 数值6匹配成功
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上述程序，将输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;matched 12: 2
matched 34: 4
matched 5: 7
matched 6: 8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以指定&lt;code&gt;\G&lt;/code&gt;，使得本次匹配强制从位移处进行匹配，不允许跳过任何匹配失败的字符。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果本次&lt;code&gt;\G&lt;/code&gt;全局匹配成功，位移指针自然会后移&lt;/li&gt;
&lt;li&gt;如果本次&lt;code&gt;\G&lt;/code&gt;全局匹配失败，且没有加上c修饰符，那么位移指针将重置&lt;/li&gt;
&lt;li&gt;如果本次&lt;code&gt;\G&lt;/code&gt;全局匹配失败，且加上了c修饰符，那么位移指针将卡在那不动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt=&quot;1234ab56&quot;;
$txt =~ /\d\d/g;
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d\d/g;
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\G\d/g;     # 强制从位移4开始匹配，无法匹配字母a，但又不允许跳过
                     # 所以本次\G全局匹配失败，由于没有修饰符c，指针重置
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\G\d/g;     # 指针回到0，强制从0处开始匹配，数值1能匹配成功
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是输出内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;matched 12: 2
matched 34: 4
matched 34: 
matched 1: 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果将上面第三个匹配语句加上修饰符c，甚至后面的语句也都加上&lt;code&gt;\G&lt;/code&gt;和c修饰符，那么位移指针将卡在那个位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt=&quot;1234ab56&quot;;
$txt =~ /\d\d/g;
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\d\d/g;
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\G\d/gc;        # 匹配失败，指针卡在原地
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\G\d/gc;        # 匹配失败，指针继续卡在原地
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;
$txt =~ /\G\d/gc;        # 匹配失败，指针继续卡在原地
print &quot;matched $&amp;amp;: &quot;,pos $txt,&quot;\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;matched 12: 2
matched 34: 4
matched 34: 4
matched 34: 4
matched 34: 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说，全局匹配都会用循环去多次迭代，和上面一次一次列出匹配表达式不一样。所以，下面使用while循环的例子来对&lt;code&gt;\G&lt;/code&gt;和c修饰符稍作解释，其实理解了上面的内容，在循环中使用&lt;code&gt;\G&lt;/code&gt;和c修饰符也一样很容易理解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt=&quot;1234ab56&quot;;
while($txt =~ m/\G\d\d/gc){
    print &quot;matched: $&amp;amp;, &quot;,pos $txt,&quot;\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;matched: 12, 2
matched: 34, 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当第三轮循环匹配到a字母的时候，由于使用了&lt;code&gt;\G&lt;/code&gt;，导致匹配失败，结束循环。&lt;/p&gt;
&lt;p&gt;上面使用c与否是无关紧要的，但如果这个while循环的后面后还有对&lt;code&gt;$txt&lt;/code&gt;的匹配，那么使用c修饰符与否就有关系了。例如下面两段程序，返回结果不一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt=&quot;1234ab56&quot;;
while($txt =~ m/\G\d\d/gc){   # 使用c修饰符
    print &quot;matched: $&amp;amp;, &quot;,pos $txt,&quot;\n&quot;;
}

$txt =~ m/\G\d\d/gc;
print &quot;matched: $&amp;amp;, &quot;,pos $txt,&quot;\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt=&quot;1234ab56&quot;;
while($txt =~ m/\G\d\d/g){   # 不使用c修饰符
    print &quot;matched: $&amp;amp;, &quot;,pos $txt,&quot;\n&quot;;
}

$txt =~ m/\G\d\d/gc;
print &quot;matched: $&amp;amp;, &quot;,pos $txt,&quot;\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;m修饰符多行匹配模式&quot;&gt;m修饰符：多行匹配模式&lt;/h4&gt;
&lt;p&gt;正则表达式一般都只用来匹配单行数据，但有时候却需要一次性匹配多行。比如匹配跨行单词、匹配跨行词组，匹配跨行的对称分隔符(如一对括号)。&lt;/p&gt;
&lt;p&gt;使用m修饰符可以开启多行匹配模式。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt=&quot;ab\ncd&quot;;
$txt =~ /a.*\nc/m;
print &quot;===match start===\n$&amp;amp;\n===match end===\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行，将输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;===match start===
ab
c
===match end===&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于多行匹配，需要注意的是元字符&lt;code&gt;.&lt;/code&gt;默认情况下无法匹配换行符。可以使用&lt;code&gt;[\d\D]&lt;/code&gt;代替点，也可以开启s修饰符使得&lt;code&gt;.&lt;/code&gt;能匹配换行符。&lt;/p&gt;
&lt;p&gt;例如，下面两个匹配输出的结果和上面是一致的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt=&quot;ab\ncd&quot;;
$txt =~ /a.*c/ms;
print &quot;===match start===\n$&amp;amp;\n===match end===\n&quot;;

$txt=&quot;ab\ncd&quot;;
$txt =~ /a[\d\D]*c/m;
print &quot;===match start===\n$&amp;amp;\n===match end===\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;s修饰符&quot;&gt;s修饰符&lt;/h4&gt;
&lt;p&gt;默认情况下，&lt;code&gt;.&lt;/code&gt;元字符是不能匹配换行符&lt;code&gt;\n&lt;/code&gt;的，开启了s修饰符功能后，可以让&lt;code&gt;.&lt;/code&gt;匹配换行符。正如刚才的那个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt=&quot;ab\ncd&quot;;
$txt =~ /a.*c/m;        # 匹配失败
print &quot;===match start===\n$&amp;amp;\n===match end===\n&quot;;

$txt=&quot;ab\ncd&quot;;
$txt =~ /a.*c/ms;       # 匹配成功
print &quot;===match start===\n$&amp;amp;\n===match end===\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;x修饰符&quot;&gt;x修饰符&lt;/h4&gt;
&lt;p&gt;正则表达式最为人所抱怨的就是它的可读性极差，无论你的正则能力有多强，看着一大堆乱七八糟的符号组合在一起，都得一个符号一个符号地从左向右读。&lt;/p&gt;
&lt;p&gt;万幸，perl正则支持表达式的分隔，甚至支持注释，只需加上x修饰符即可。这时候正则表达式中出现的所有空白符号都不会当作正则的匹配对象，而是直接被忽略。如果想要匹配空白符号，可以使用&lt;code&gt;\s&lt;/code&gt;表示，或者将空格使用&lt;code&gt;\Q...\E&lt;/code&gt;包围。&lt;/p&gt;
&lt;p&gt;例如，以下4个匹配操作是完全等价的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ans=&quot;cat sheep tiger&quot;;
$ans =~ /(\w) *(\w) *(\w)/;       # 正常情况下的匹配表达式
$ans =~ /(\w)\s*   (\w)\s*   (\w)/x;
$ans = ~ /
        (\w)\s*      # 可以加上本行注释：匹配第一个单词
        (\w)\s*      # 可以加上本行注释：匹配第二个单词
        (\w)         # 可以加上本行注释：匹配第三个单词
        /x;
$ans =~ /
         (\w)\Q \E   # \Q \E强制将中间的空格当作字面符号被匹配
         (\w)\Q \E
         (\w)
        /x;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于稍微复杂一些的正则表达式，常常都会使用x修饰符来增强其可读性，最重要的是加上注释。这一点真的非常人性化。&lt;/p&gt;
&lt;h4 id=&quot;p修饰符&quot;&gt;p修饰符&lt;/h4&gt;
&lt;p&gt;前面说过，通过3个特殊变量&lt;code&gt;$`&lt;/code&gt;、&lt;code&gt;$&amp;amp;&lt;/code&gt;和&lt;code&gt;$'&lt;/code&gt;可以保存匹配内容之前的内容，匹配内容以及匹配内容之后的内容。但是，只要使用了这3个变量中的任何一个，后面的所有分组效率都会降低。perl提供了一个p修饰符，能实现完全相同的功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;${^PREMATCH}    &amp;lt;=&amp;gt;   $`
${^MATCH}       &amp;lt;=&amp;gt;   $&amp;amp;
${^POSTMATCH}   &amp;lt;=&amp;gt;   $'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个例子即可描述：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ans=&quot;cat sheep tiger&quot;;
$ans =~ /sheep/p;
print &quot;${^PREMATCH}\n&quot;;     # 输出&quot;cat &quot;
print &quot;${^MATCH}\n&quot;;        # 输出&quot;sheep&quot;
print &quot;${^POSTMATCH}\n&quot;;    # 输出&quot; tiger&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;o修饰符&quot;&gt;o修饰符&lt;/h4&gt;
&lt;p&gt;在较老的perl版本中，如果使用同一个正则表达式做多次匹配，正则引擎将只多次编译正则表达式。很多时候正则表达式并不会改变，比如循环匹配文件中的行，这样的多次编译导致性能下降很明显，于是可以使用o修饰符让正则引擎对同一个正则表达式不重复编译。&lt;/p&gt;
&lt;p&gt;在perl5.6中，默认情况下对同一正则表达式只编译一次，但同样可以指定o修饰符，使得即使正则表达式变化了也不要重新编译。&lt;/p&gt;
&lt;p&gt;一般情况下，可以无视这个修饰符。&lt;/p&gt;
&lt;h3 id=&quot;范围模式匹配修饰符imsx-imsxpattern&quot;&gt;范围模式匹配修饰符(?imsx-imsx:pattern)&lt;/h3&gt;
&lt;p&gt;前文介绍的修饰符&lt;code&gt;adluoimsxpngc&lt;/code&gt;都是放在&lt;code&gt;m//{FLAG}&lt;/code&gt;的flag处的，放在这个位置会对整个正则表达式产生影响，所以它的作用范围有点广。&lt;/p&gt;
&lt;p&gt;例如&lt;code&gt;m/pattern1 pattern2/i&lt;/code&gt;的i修饰符会影响pattern1和pattern2。&lt;/p&gt;
&lt;p&gt;perl允许我们定义只在一定范围内生效的修饰符，方式是&lt;code&gt;(?imsx:pattern)&lt;/code&gt;或&lt;code&gt;(?-imsx:pattern)&lt;/code&gt;或&lt;code&gt;(?imsx-imsx:pattern)&lt;/code&gt;，其中加上&lt;code&gt;-&lt;/code&gt;表示去除这个修饰符的影响。这里只列出了imsx，因为这几个最常用，其他的修饰符也一样有效。&lt;/p&gt;
&lt;p&gt;例如，对于待匹配字符串&quot;Hello world gaoxiaofang&quot;，使用以下几种模式去匹配的话：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/(?i:hello) world/&lt;/code&gt;&lt;br/&gt;表示匹配hello时，可忽略大小写，但匹配world时仍然区分大小写。所以匹配成功&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/(?ims:hello.)world/&lt;/code&gt;&lt;br/&gt;表示可以跨行匹配helloworld，也可以匹配单行的hellosworld，且hello部分忽略大小写。所以匹配成功&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/(?i:hello (?-i:world) gaoxiaoFANG)/&lt;/code&gt;&lt;br/&gt;表示在第二个括号之前，可用忽略大小写进行匹配，但因为第二个括号里指明了去除i的影响，所以对world的匹配会区分大小写，但是对gaoxiaofang部分的匹配又不区分大小写。所以匹配成功&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/(?i:hello (?-i:world) gaoxiao)FANG/&lt;/code&gt;&lt;br/&gt;和前面的类似，但是将&quot;FANG&quot;放到了括号外，意味着这部分要区分大小写。所以匹配失败&lt;/p&gt;
&lt;h3 id=&quot;perl支持的反斜线序列&quot;&gt;perl支持的反斜线序列&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.锚定类的反斜线序列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓锚定，是指它匹配的是位置，而非字符，比如锚定行首的意思是匹配第一个字母前的空字符。也就是很多人说的&quot;零宽断言(zero-width assertions)&quot;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;\b&lt;/code&gt;：匹配单词边界处的空字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\B&lt;/code&gt;：匹配非单词边界处的空字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&amp;lt;&lt;/code&gt;：匹配单词开头处的空字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&amp;gt;&lt;/code&gt;：匹配单词结尾处的空字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\A&lt;/code&gt;：匹配绝对行首，换句话说，就是输入内容的开头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\z&lt;/code&gt;：匹配绝对行尾，换句话说，就是输入内容的绝对尾部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\Z&lt;/code&gt;：匹配绝对行尾或绝对行尾换行符前的位置，换句话说，就是输入内容的尾部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\G&lt;/code&gt;：强制从位移指针处进行匹配，详细内容见&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/9648439.html#bloggcG&quot;&gt;g和c修饰符以及\G&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要解释下&lt;code&gt;\A \z \Z&lt;/code&gt;，其它的属于基础正则的内容，不多做解释了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\A \z \Z&lt;/code&gt;和&lt;code&gt;^ $&lt;/code&gt;的区别主要体现在多行模式下。在多行模式下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201809/733013-20180912234030307-1579497375.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$txt = &quot;abcd\nABCD\n&quot;;
$txt1 = &quot;abcd\nABCD&quot;;

$txt =~ /^ABC*/;   # 无法匹配
$txt =~ /^ABC*/m;  # 匹配

$txt =~ /\Aabc/;   # 匹配
$txt =~ /\Aabc/m;  # 匹配
$txt =~ /\AABC/m;  # 无法匹配

$txt =~ /cd\n$/m;  # 不匹配
$txt =~ /cd$\n/m;  # 不匹配
$txt =~ /cd$/m;    # 匹配

$txt =~ /CD\Z\n/m  # 匹配
$txt =~ /CD\Z\n\Z/m; # 匹配
$txt =~ /CD\n\z/m; # 匹配

$txt1 =~ /CD\Z/m;  # 匹配
$txt1 =~ /CD\z/m;  # 匹配&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的&lt;code&gt;$&lt;/code&gt;匹配示例可知，&lt;code&gt;$&lt;/code&gt;代表的行尾，其实它在有换行符的时候匹配&quot;\n&quot;，而不是&quot;\n&quot;的前、后，在没有换行符的时候，匹配行尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.字符匹配反斜线序列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，除了以下这几种，还有&lt;code&gt;\v \V \h \H \R \p \c \X&lt;/code&gt;，这些基本不会用上，所以都不会在本文解释。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;\w&lt;/code&gt;：匹配单词构成部分，等价于&lt;code&gt;[_[:alnum:]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\W&lt;/code&gt;：匹配非单词构成部分，等价于&lt;code&gt;[^_[:alnum:]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\s&lt;/code&gt;：匹配空白字符，等价于&lt;code&gt;[[:space:]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\S&lt;/code&gt;：匹配非空白字符，等价于&lt;code&gt;[^[:space:]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\d&lt;/code&gt;：匹配数字，等价于&lt;code&gt;[0-9]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\D&lt;/code&gt;：匹配非数字，等价于&lt;code&gt;[^0-9]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\N&lt;/code&gt;：不匹配换行符，等价于&lt;code&gt;[^\n]&lt;/code&gt;。但&lt;code&gt;\N{NAME}&lt;/code&gt;有特殊意义，表示匹配已命名(名为NAME)的unicode字符序列，本文不介绍该特殊用法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于元字符&lt;code&gt;.&lt;/code&gt;默认无法匹配换行符，所以需要匹配换行符的时候，可以使用特殊组合&lt;code&gt;[\d\D]&lt;/code&gt;或者&lt;code&gt;(\n|\N)&lt;/code&gt;来替换&lt;code&gt;.&lt;/code&gt;，换句话说，如果想匹配任意长度的任意字符，可以换成&lt;code&gt;[\d\D]*&lt;/code&gt;或者&lt;code&gt;(\n|\N)*&lt;/code&gt;，当然，前提是必须支持这3个反斜线序列。&lt;/p&gt;
&lt;p&gt;之所以不用&lt;code&gt;[\n\N]&lt;/code&gt;替代元字符&lt;code&gt;.&lt;/code&gt;，是因为&lt;code&gt;\N&lt;/code&gt;有特殊意义，不能随意接符号和字母。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.分组引用的反斜线序列&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;\1&lt;/code&gt;：反向引用，其中1可以替换为任意一个正整数，即使超出9，例如&lt;code&gt;\111&lt;/code&gt;表示匹配第111个分组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\g1&lt;/code&gt;或&lt;code&gt;\g{1}&lt;/code&gt;：也是反向引用，只不过这种写法可以避免歧义，例如&lt;code&gt;\g{1}11&lt;/code&gt;表示匹配第一个分组内容后两个数字1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\g{-1}&lt;/code&gt;：还可以使用负数，表示距离&lt;code&gt;\g&lt;/code&gt;左边的分组号，也就是相对距离。例如&lt;code&gt;(abc)([a-z])\g{-1}&lt;/code&gt;中的&lt;code&gt;\g&lt;/code&gt;引用的是&lt;code&gt;[a-z]&lt;/code&gt;，如果-1换成-2，则引用的&lt;code&gt;abc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\g{name}&lt;/code&gt;：引用已命名的分组(命名捕获)，其中name为分组的名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt;：同上，引用已命名的分组(命名捕获)，其中name为分组的名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\K&lt;/code&gt;：不要将&lt;code&gt;\K&lt;/code&gt;左边的内容放进&lt;code&gt;$&amp;amp;&lt;/code&gt;。换句话说，&lt;code&gt;\K&lt;/code&gt;左边的内容即使匹配成功了，也会重置匹配的位置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;\1&lt;/code&gt;表示引用第一个分组，&lt;code&gt;\11&lt;/code&gt;表示引用第11个分组，在基础正则中，是不支持引用超出9个分组的，但显然perl会将&lt;code&gt;\11&lt;/code&gt;的第二个1解析为引用，以便能引用更多分组。&lt;/p&gt;
&lt;p&gt;同理&lt;code&gt;\g1&lt;/code&gt;和&lt;code&gt;\g11&lt;/code&gt;，只是使用&lt;code&gt;\g&lt;/code&gt;引用的方式可以加上大括号使引用变得更安全，更易读，且&lt;code&gt;\g&lt;/code&gt;可以使用负数来表示从右向左相对引用。这样在&lt;code&gt;\g{-2}&lt;/code&gt;的左边添加新的分组括号时，无须修改引用表达式。&lt;/p&gt;
&lt;p&gt;此处暂时还没介绍到命名分组，所以&lt;code&gt;\g{name}&lt;/code&gt;和&lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt;留在后面再介绍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\K&lt;/code&gt;表示强制中断前面已完成的匹配。例如&lt;code&gt;&quot;abc22ABC&quot; =~ /abc\K2.*/;&lt;/code&gt;，虽然abc三个字母也被匹配，如果没有&lt;code&gt;\K&lt;/code&gt;，这3个字母将放进&lt;code&gt;$&amp;amp;&lt;/code&gt;中，但是&lt;code&gt;\K&lt;/code&gt;使得匹配完abc后立即切断前面的匹配，也就是从c字母后面开始重新匹配，所以这里匹配的结果是22ABC。&lt;/p&gt;
&lt;p&gt;再例如，&lt;code&gt;&quot;abc123abcfoo&quot;=~ /(abc)123\K\g1foo/;&lt;/code&gt;，它匹配到123后被切断，但是分组引用还可以继续引用，所以匹配的结果是&quot;abcfoo&quot;。&lt;/p&gt;
&lt;h3 id=&quot;贪婪匹配非贪婪匹配占有优先匹配&quot;&gt;贪婪匹配、非贪婪匹配、占有优先匹配&lt;/h3&gt;
&lt;p&gt;在基础正则中，那些能匹配多次的量词都会匹配最长内容。这种尽量多匹配的行为称为&quot;贪婪匹配&quot;(greedy match)。&lt;/p&gt;
&lt;p&gt;例如字符串&quot;aa1122ccbb&quot;，用正则表达式&lt;code&gt;a.*c&lt;/code&gt;去匹配这个字符串，其中的&lt;code&gt;.*&lt;/code&gt;将直接从第二个字母a开始匹配到最结尾的b，因为从第二个字母a开始到最后一个字母b都符合&lt;code&gt;.*&lt;/code&gt;的匹配模式。再然后，去匹配字母c，但因为已经把所有字母匹配完了，只能回退一个字母一个字母地释放，每释放一个就匹配一次字母c，发现回退释放到倒数第三个字母就能满足匹配要求，于是这里的&lt;code&gt;.*&lt;/code&gt;最终匹配的内容是&quot;a1122c&quot;。&lt;/p&gt;
&lt;p&gt;上面涉及到回溯的概念，也就是将那些已经被量词匹配的内容回退释放。&lt;/p&gt;
&lt;p&gt;上面描述的是贪婪匹配行为，还有非贪婪匹配、占有优先匹配，以下简单描述下他们的意义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非贪婪匹配：(lazy match,reluctant)尽可能少地匹配，也叫做懒惰匹配&lt;/li&gt;
&lt;li&gt;占有优先匹配：(possessive)占有优先和固化分组是相同的，只要占有了就不再交换，不允许进行回溯。相关内容见后文&quot;固化分组&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有必要搞清楚这几种匹配模式在匹配机制上的区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;贪婪匹配：对于那些量词，将一次性从左到右匹配到最大长度，然后再往回回溯释放&lt;/li&gt;
&lt;li&gt;非贪婪匹配：对于那些量词，将从左向右逐字符匹配最短长度，然后直接结束这次的量词匹配行为&lt;/li&gt;
&lt;li&gt;占有优先匹配：按照贪婪模式匹配，匹配后内容就锁住，不进行回溯(后文固化分组有具体示例)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了上面描述的&lt;code&gt;*&lt;/code&gt;量词会进行贪婪匹配，其他所有能进行多次匹配的量词可以选择贪婪匹配模式、非贪婪匹配模式和占有优先匹配模式，只需选择对应的量词元字符即可。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;                        (量词后加上?)             (量词后加上+)
  贪婪匹配量词           非贪婪匹配量词           占有优先匹配量词
-----------------------------------------------------------------
      *                    *?                         *+
      ?                    ??                         ?+
      +                    +?                         ++
      {M,}                 {M,}?                      {M,}+
      {M,N}                {M,N}?                     {M,N}+
      {N}                  {N}?                       {N}+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;几点需要说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非贪婪匹配时的&lt;code&gt;{M,}?&lt;/code&gt;和&lt;code&gt;{M,N}?&lt;/code&gt;，它们是等价的，因为最多只匹配M次&lt;/li&gt;
&lt;li&gt;在perl中不支持&lt;code&gt;{,N}&lt;/code&gt;的模式，所以也没有对应的非贪婪和占有优先匹配模式&lt;/li&gt;
&lt;li&gt;关于&lt;code&gt;{N}&lt;/code&gt;这个量词，由于是精确匹配N次，所以贪婪与否对最终结果无关紧要，但是却影响匹配时的行为：贪婪匹配最长，需要回溯，非贪婪匹配最短，不回溯，占有优先匹配最长不回溯。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看以下示例即可理解贪婪和非贪婪匹配的行为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str=&quot;abc123abc1234&quot;;

# greedy match
if( $str =~ /(a\w*3)/){
    print &quot;$&amp;amp;\n&quot;;       # abc123abc123
}

# lazy match
if( $str =~ /(a\w*?3)/){
    print &quot;$&amp;amp;\n&quot;;      # abc123
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是占有优先匹配模式的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str=&quot;abc123abc1234&quot;;

if( $str =~ /a\w*+/){     # 成功
        print &quot;possessive1: $&amp;amp;\n&quot;;
}
if( $str =~ /a\w*+3/){    # 失败
        print &quot;possesive2: $&amp;amp;\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，在使用占有优先匹配模式时，它后面不应该跟其他表达式，例如&lt;code&gt;a*+x&lt;/code&gt;永远匹配不了东西。绝大多数时候都是不会回溯的。但是少数情况下，它并非强制锁住回溯，这个和正则引擎匹配原理有本文不多做解释。&lt;/p&gt;
&lt;p&gt;另外，固化分组和占有优先并不完全等价，它们只是匹配行为相同：匹配后不回溯。具体可对比后文对应内容。&lt;/p&gt;
&lt;h3 id=&quot;perl的分组捕获和分组引用&quot;&gt;perl的分组捕获和分组引用&lt;/h3&gt;
&lt;h4 id=&quot;分组的基本应用&quot;&gt;分组的基本应用&lt;/h4&gt;
&lt;p&gt;在基础正则中，使用括号可以对匹配的内容进行分组，这种行为称为分组捕获。捕获后可以通过&lt;code&gt;\1&lt;/code&gt;这种反向引用方式去引用(访问)保存在分组中的匹配结果。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;abc11ddabc11&quot; =~ /([a-z]*)([0-9]*)dd\1\2/;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在perl中，还可以使用&lt;code&gt;\gN&lt;/code&gt;的方式来反向引用分组，这个在上一节&quot;反斜线序列&quot;中已经解释过了。例如，以下是和上面等价的几种写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;abc11ddabc11&quot; =~ /([a-z]*)([0-9]*)dd\g1\g2/;
&quot;abc11ddabc11&quot; =~ /([a-z]*)([0-9]*)dd\g{1}\g{2}/;
&quot;abc11ddabc11&quot; =~ /([a-z]*)([0-9]*)dd\g{-2}\g{-1}/;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;perl还会把分组的内容放进perl自带的特殊变量&lt;code&gt;$1,$2,...,$N&lt;/code&gt;中，它们和&lt;code&gt;\1,\2,...\N&lt;/code&gt;在&lt;strong&gt;匹配成功时&lt;/strong&gt;的结果上没有区别，但是&lt;code&gt;\N&lt;/code&gt;这种类型的反向引用只在正则匹配中有效，正则匹配结束后就消亡了，而&lt;code&gt;$N&lt;/code&gt;因为是perl的变量，即使正则已经退出匹配，也依然可以引用。所以，我们可以使用&lt;code&gt;$N&lt;/code&gt;的方式来输出分组匹配的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;abc11ddabc11&quot; =~ /([a-z]*)([0-9]*)dd\1\2/;
print &quot;first group \\1: $1\n&quot;;
print &quot;second group \\2: $2\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有两点需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这些分组可能捕获到的是空值(比如那些允许匹配0次的量词)，但是整个匹配是成功的。这时候引用分组时，得到的结果也将是空值&lt;/li&gt;
&lt;li&gt;当分组匹配失败的时候，&lt;code&gt;\1&lt;/code&gt;会在识别括号的时候重置，而$1仍保存上一次分组成功的值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一点，示例可知：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;abcde&quot; =~ /([0-9]*)de/;
print &quot;null group: $1\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二点，从机制上去分析。&lt;code&gt;\1&lt;/code&gt;是每个正则匹配都相互独立的，而&lt;code&gt;$1&lt;/code&gt;则保存分组捕获成功的值，即使这次值是上次捕获的。&lt;/p&gt;
&lt;p&gt;这里稍微解释下正则匹配关于分组捕获的匹配过程：&lt;/p&gt;
&lt;p&gt;例如，匹配表达式&lt;code&gt;&quot;12abc22abc&quot; =~ /\d(abc)\d\d\1/;&lt;/code&gt;，当正则引擎去匹配数据时：&lt;br/&gt;1.首先匹配第一个数字1，发现符合&lt;code&gt;\d&lt;/code&gt;，于是继续用&lt;code&gt;(abc)&lt;/code&gt;去匹配字符串，因为发现了是分组括号，于是会将第二个字符2放进分组，发现不匹配字母a，于是匹配失败，丢弃这个分组中的内容。&lt;br/&gt;2.正则引擎继续向后匹配数值2，发现符合&lt;code&gt;\d&lt;/code&gt;，于是用&lt;code&gt;(abc)&lt;/code&gt;去匹配字符串，接着会将第三个字符a放进分组，发现能匹配，继续匹配字符串中的b、c发现都能匹配，于是分组捕获完成，将其赋值给&lt;code&gt;$1&lt;/code&gt;，之后就能用&lt;code&gt;\1&lt;/code&gt;和&lt;code&gt;$1&lt;/code&gt;去引用这个分组的内容。&lt;br/&gt;3.后面继续去匹配&lt;code&gt;\d\d\1&lt;/code&gt;，直到匹配结束。&lt;/p&gt;
&lt;p&gt;当然，具体匹配的过程不会真的这么简单，它会有一些优化匹配方式，以上只是用逻辑去描述匹配的过程。&lt;/p&gt;
&lt;h4 id=&quot;perl中更强大的分组捕获&quot;&gt;perl中更强大的分组捕获&lt;/h4&gt;
&lt;p&gt;在perl中，支持的分组捕获更强大、更完整，它除了支持普通分组(也就是直接用括号的分组)，还支持：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命名捕获&lt;code&gt;(?&amp;lt;NAME&amp;gt;...)&lt;/code&gt;：捕获后放进一个已分配好名称(即NAME)的分组中，以后可以使用这个名称来引用这个分组，如&lt;code&gt;\g{NAME}&lt;/code&gt;引用&lt;/li&gt;
&lt;li&gt;匿名捕获&lt;code&gt;(?:...)&lt;/code&gt;：仅分组，不捕获，所以后面无法再引用这个捕获&lt;/li&gt;
&lt;li&gt;固化分组&lt;code&gt;(?&amp;gt;...)&lt;/code&gt;：一匹配成功就永不交回内容(用回溯的想法理解很容易)&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;匿名捕获&quot;&gt;匿名捕获&lt;/h5&gt;
&lt;p&gt;匿名捕获是指仅分组，不捕获。因为不捕获，所以无法使用反向引用，也不会将分组结果赋值给&lt;code&gt;$1&lt;/code&gt;这种特殊变量。&lt;/p&gt;
&lt;p&gt;虽然有了分组捕获功能，就可以实现任何需求，但有时候可以让这种行为变得更人性化，减少维护力度。&lt;/p&gt;
&lt;p&gt;例如字符串&quot;xiaofang or longshuai&quot;，使用模式&lt;code&gt;/(\w+) or (\w+)/&lt;/code&gt;去捕获，用&lt;code&gt;$1&lt;/code&gt;和&lt;code&gt;$2&lt;/code&gt;分别引用or左右两个单词：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str = &quot;xiaofang or longshuai&quot;;
if ($str =~ /(\w+) or (\w+)/){
    print &quot;name1: $1, name2: $2\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但如果需求是中间的关系or也可以换成and，为了同时满足and和or两种需求，使用模式&lt;code&gt;/(\w+) (and|or) (\w+)/&lt;/code&gt;去匹配，但是这时引用的序号就得由&lt;code&gt;$2&lt;/code&gt;变为&lt;code&gt;$3&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str = &quot;xiaofang or longshuai&quot;;
if ($str =~ /(\w+) (or|and) (\w+)/){
    print &quot;name1: $1, name2: $3\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用匿名捕获，对and和or这样无关紧要，却有可能改变匹配行为的内容，可以将其放进一个无关的分组中。这样不会对原有的其余正则表达式产生任何影响：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str = &quot;xiaofang or longshuai&quot;;
if ($str =~ /(\w+) (?:or|and) (\w+)/){
    print &quot;name1: $1, name2: $2\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面仍然使用&lt;code&gt;$2&lt;/code&gt;引用第三个括号。&lt;/p&gt;
&lt;p&gt;同样，如果要在正则内部使用反向引用，也一样使用&lt;code&gt;\2&lt;/code&gt;来引用第三个括号。&lt;/p&gt;
&lt;p&gt;另外，在前文还介绍过一个&lt;code&gt;n&lt;/code&gt;修饰符，它也表示非捕获仅分组行为。但它只对普通分组有效，对命名分组无效。且因为它是修饰符，它会使所有的普通分组都变成非捕获模式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str = &quot;xiaofang or longshuai&quot;;
if ($str =~ /(\w+) (or|and) (\w+)/n){
    print &quot;name1: $1, name2: $2\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于上面开启了n修饰符，使得3个普通分组括号都变成非捕获仅分组行为，所以&lt;code&gt;\1&lt;/code&gt;和&lt;code&gt;$1&lt;/code&gt;都无法使用。除非正则中使用了命名分组。&lt;/p&gt;
&lt;h5 id=&quot;命名捕获&quot;&gt;命名捕获&lt;/h5&gt;
&lt;p&gt;命名捕获是指将捕获到的内容放进分组，这个分组是有名称的分组，所以后面可以使用分组名去引用已捕获进这个分组的内容。除此之外，和普通分组并无区别。&lt;/p&gt;
&lt;p&gt;当要进行命名捕获时，使用&lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt;的方式替代以前的分组括号&lt;code&gt;()&lt;/code&gt;即可。例如，要匹配abc并将其分组，以前普通分组的方式是&lt;code&gt;(abc)&lt;/code&gt;，如果将其放进命名为name1的分组中：&lt;code&gt;(?&amp;lt;name1&amp;gt;abc)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当使用命名捕获的时候，要在正则内部引用这个命名捕获，除了可以使用序号类的绝对引用(如&lt;code&gt;\1&lt;/code&gt;或&lt;code&gt;\g1&lt;/code&gt;或&lt;code&gt;\g{1}&lt;/code&gt;)，还可以使用以下任意一种按名称引用方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;\g{NAME}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\k{NAME}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\k&amp;lt;NAME&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\k'NAME'&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果要在正则外部引用这个命名捕获，除了可以使用序号类的绝对应用(如&lt;code&gt;$1&lt;/code&gt;)，还可以使用&lt;code&gt;$+{NAME}&lt;/code&gt;的方式。&lt;/p&gt;
&lt;p&gt;实际上，后一种引用方式的本质是perl将命名捕获的内容放进了一个名为&lt;code&gt;%+&lt;/code&gt;的特殊hash类型中，所以可以使用&lt;code&gt;$+{NAME}&lt;/code&gt;的方式引用，如果你不知道这一点，那就无视与此相关的内容即可，不过都很简单，一看就懂。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str = &quot;ma xiaofang or ma longshuai&quot;;
if ($str =~ /
            (?&amp;lt;firstname&amp;gt;\w+)\s  # firstname -&amp;gt; ma
            (?&amp;lt;name1&amp;gt;\w+)\s      # name1 -&amp;gt; xiaofang
            (?:or|and)\s      # group only, no capture
            \g1\s                # \g1 -&amp;gt; ma
            (?&amp;lt;name2&amp;gt;\w+)        # name2 -&amp;gt; longshuai
            /x){
    print &quot;$1\n&quot;;
    print &quot;$2\n&quot;;
    print &quot;$3\n&quot;;
    # 或者指定名称来引用
    print &quot;$+{firstname}\n$+{name1}\n$+{name2}\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中上述代码中的&lt;code&gt;\g1&lt;/code&gt;还可以替换为&lt;code&gt;\1&lt;/code&gt;、&lt;code&gt;\g{firstname}&lt;/code&gt;、&lt;code&gt;\k{firstname}&lt;/code&gt;或&lt;code&gt;\k&amp;lt;firstname&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过使用命名捕获，可以无视序号，直接使用名称即可准确引用。&lt;/p&gt;

&lt;h5 id=&quot;固化分组&quot;&gt;固化分组&lt;/h5&gt;
&lt;p&gt;首先&lt;strong&gt;固化分组不是一种分组，所以无法去引用它&lt;/strong&gt;。它和&quot;占有优先&quot;匹配模式(贪婪匹配、惰性匹配、占有优先匹配三种匹配模式，见后文)是等价的除了这两种称呼，在不同的书、不同的语言里还有一种称呼：原子匹配。&lt;/p&gt;
&lt;p&gt;它的表示形式类似于分组&lt;code&gt;(?&amp;gt;)&lt;/code&gt;，所以有些地方将其称呼为&quot;固化分组&quot;。再次说明，固化分组不是分组，无法进行引用。如果非要将其看作是分组，可以将其理解为被限定的匿名分组：不捕获，只分组。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按照&quot;占有优先&quot;的字面意义来理解比较容易：只要匹配成功了，就绝不回溯。&lt;/li&gt;
&lt;li&gt;如果按照固化分组的概念来理解，就是将匹配成功的内容放进分组后，将其固定，不允许进行回溯。但是需要注意，&lt;strong&gt;这里的不回溯是放进分组中的内容不会回溯给分组外面，而分组内部的内容是可以回溯的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果不知道什么是回溯，看完下面的例子就明白。&lt;/p&gt;
&lt;p&gt;例如&quot;hello world&quot;可以被&lt;code&gt;hel.* world&lt;/code&gt;成功匹配，但不能被&lt;code&gt;hel(?&amp;gt;.*) world&lt;/code&gt;匹配。因为正常情况下，&lt;code&gt;.*&lt;/code&gt;匹配到所有内容，然后往回释放已匹配的内容直到释放完空格为止，这种往回释放字符的行为在正则术语中称为&quot;回溯&quot;。而固化分组后，&lt;code&gt;.*&lt;/code&gt;已匹配后面所有内容，这些内容一经匹配绝不交回，即无法回溯。&lt;/p&gt;
&lt;p&gt;但是，如果正则表达式是&lt;code&gt;hel(?&amp;gt;.* world)&lt;/code&gt;，即将原来分组外面的内容放进了分组内部，这时在分组内部是会回溯的，也就是说能匹配&quot;hello world&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str=&quot;ma longshuai gao xiaofang&quot;;
if($str =~ /ma (?&amp;gt;long.*)/){     # 成功
    print &quot;matched\n&quot;;
}

if($str =~ /ma (?&amp;gt;long.*)gao/){   # 失败
    print &quot;matched\n&quot;;
}

if($str =~ /ma (?&amp;gt;long.*gao)/){   # 成功
    print &quot;matched\n&quot;;
}

if($str =~ /ma (?&amp;gt;long.*g)ao/){   # 成功
    print &quot;matched\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;固化分组看上去挺简单的，此处也仅介绍了它最简单的形式。但实际上固化分组很复杂，它涉及了非常复杂的正则引擎匹配原理和回溯机制。如果有兴趣，可以阅读《精通正则表达式》一书的第四章。&lt;/p&gt;
&lt;h3 id=&quot;环视锚定断言&quot;&gt;环视锚定(断言)&lt;/h3&gt;
&lt;p&gt;&quot;环视&quot;锚定，即lookaround anchor，也称为&quot;零宽断言&quot;，它表示匹配的是位置，不是字符。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;(?=...)&lt;/code&gt;：表示从左向右的顺序环视。例如&lt;code&gt;(?=\d)&lt;/code&gt;表示当前字符的右边是一个数字时就满足条件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(?!...)&lt;/code&gt;：表示顺序环视的取反。如&lt;code&gt;(?!\d)&lt;/code&gt;表示当前字符的右边不是一个数字时就满足条件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(?&amp;lt;=...)&lt;/code&gt;：表示从右向左的逆序环视。例如&lt;code&gt;(?&amp;lt;=\d)&lt;/code&gt;表示当前字符的左边是一个数字时就满足条件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(?&amp;lt;!)...&lt;/code&gt;：表示逆序环视的取反。如&lt;code&gt;(?&amp;lt;!\d)&lt;/code&gt;表示当前字符的左边不是一个数字时就满足条件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于&quot;环视&quot;锚定，最需要注意的一点是匹配的结果不占用任何字符，它仅仅只是锚定位置。&lt;/p&gt;
&lt;p&gt;例如&quot;your name is longshuai MA&quot;和&quot;your name is longfei MA&quot;。使用&lt;code&gt;(?=longshuai)&lt;/code&gt;将能锚定第一个句子中单词&quot;longshuai&quot;前面的空字符，但它的匹配结果是&quot;longshuai&quot;前的空白字符，所以&lt;code&gt;(?=longshuai)long&lt;/code&gt;才能代表&quot;long&quot;这几个字符串，所以仅对于此处的两个句子，&lt;code&gt;long(?=shuai)&lt;/code&gt;和&lt;code&gt;(?=longshuai)long&lt;/code&gt;是等价的。&lt;/p&gt;
&lt;p&gt;一般为了方便理解，在顺序环视的时候会将匹配内容放在锚定括号的左边(如&lt;code&gt;long(?=longshuai)&lt;/code&gt;)，在逆序环视的时候会将匹配的内容放在锚定括号的右边(如&lt;code&gt;(?&amp;lt;=long)shuai&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;另外，无论是哪种锚定，都是从左向右匹配再做回溯的(假设允许回溯)，即使是逆序环视。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str=&quot;abc123abcc12c34&quot;;

# 顺序环视
$str =~ /a.*c(?=\d)/;     # abc123abcc12c
print &quot;$&amp;amp;\n&quot;;

# 顺序否定环视
$str =~ /a.*c(?!\d)/;     # abc123abc
print &quot;$&amp;amp;\n&quot;;

# 逆序环视，这里能逆序匹配成功，靠的是锚定括号后面的c
$str =~ /a.*(?&amp;lt;=\d)c/;    # abc123abcc12c
print &quot;$&amp;amp;\n&quot;;

# 逆序否定环视
$str =~ /a.*(?&amp;lt;!\d)c/;    # abc123abcc
print &quot;$&amp;amp;\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;逆序环视的表达式必须只能表示固定长度的字符串。例如&lt;code&gt;(?&amp;lt;=word)&lt;/code&gt;或&lt;code&gt;(?&amp;lt;=word|word)&lt;/code&gt;可以，但&lt;code&gt;(?&amp;lt;=word?)&lt;/code&gt;不可以，因为&lt;code&gt;?&lt;/code&gt;匹配0或1长度，长度不定，它无法对左边是word还是wordx做正确判断。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str=&quot;hello worlds Gaoxiaofang&quot;;
$str =~ /he.*(?&amp;lt;=worlds?) Gao/;         # 报错
$str =~ /he.*(?&amp;lt;=worlds|world) Gao/;    # 报错&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在PCRE中，这种变长的逆序环视锚定可重写为&lt;code&gt;(?&amp;lt;=word|words)&lt;/code&gt;，但perl中不允许，因为perl严格要求长度必须固定。&lt;/p&gt;
&lt;h3 id=&quot;q...e&quot;&gt;\Q...\E&lt;/h3&gt;
&lt;p&gt;perl中的&lt;code&gt;\Q...\E&lt;/code&gt;用来强制包围一段字符，使得里面的正则符号都当做普通字符，不会有特殊意义，它是一种非常强的引用。但注意，它无法强制变量的替换。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$sub=&quot;world&quot;;
$str=&quot;hello worlds gaoxiaofang&quot;;
$str =~ /\Q$sub\E/;  # $sub会替换，所以匹配成功world
$str =~ /\Q$sub.\E/; # 元字符&quot;.&quot;被当做普通的字符，所以无法匹配&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;qr创建正则对象&quot;&gt;qr//创建正则对象&lt;/h3&gt;
&lt;p&gt;因为可以在正则模式中使用变量替换，所以我们可以将正则中的一部分表达式事先保存在变量中。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str=&quot;hello worlds gaoxiaofang&quot;;
$pattern=&quot;w.*d&quot;;
$str =~ /$pattern/;
print &quot;$&amp;amp;\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，这样缺陷很大，在保存正则表达式的变量中存放的特殊字符要防止有特殊意义。例如，当使用&lt;code&gt;m//&lt;/code&gt;的方式做匹配分隔符时，不能在变量中保存&lt;code&gt;/&lt;/code&gt;，除非转义。&lt;/p&gt;
&lt;p&gt;perl提供了&lt;code&gt;qr/pattern/&lt;/code&gt;的功能，它把pattern部分构建成一个正则表达式对象，然后就可以在正则表达式中直接引用这个对象，更方便的是可用将这个对象保存到变量中，通过引用变量的方式来引用这个以保存好的正则对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str=&quot;hello worlds gaoxiaofang&quot;;

# 直接作为正则表达式
$str =~ qr/w.*d/;
print &quot;$&amp;amp;\n&quot;;

# 保存为变量，再作为正则表达式
$pattern=qr/w.*d/;
$str =~ /$pattern/;
print &quot;$&amp;amp;\n&quot;;

# 保存为变量，作为正则表达式的一部分
$pattern=qr/w.*d/;
$str =~ /hel.* $pattern/;
print &quot;$&amp;amp;\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还允许为这个正则对象设置修饰符，比如忽略大小写的匹配修饰符为i，这样在真正匹配的时候，就只有这一部分正则对象会忽略大小写，其余部分仍然区分大小写。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$str=&quot;HELLO wORLDs gaoxiaofang&quot;;

$pattern=qr/w.*d/i;         # 忽略大小写

$str =~ /HEL.* $pattern/;   # 匹配成功，$pattern部分忽略大小写
$str =~ /hel.* $pattern/;   # 匹配失败
$str =~ /hel.* $pattern/i;  # 匹配成功，所有都忽略大小写&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 14 Sep 2018 11:28:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>前言 想必学习perl的人，对基础正则表达式都已经熟悉，所以学习perl正则会很轻松。这里我不打算解释基础正则的内容，而是直接介绍基础正则中不具备的但perl支持的功能。关于基础正则表达式的内容，可参</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9648439.html</dc:identifier>
</item>
</channel>
</rss>