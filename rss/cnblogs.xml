<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用sklearn进行数据挖掘-房价预测(4)—数据预处理 - Wanna_Go</title>
<link>http://www.cnblogs.com/wxshi/p/7764518.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxshi/p/7764518.html</guid>
<description>&lt;p&gt;在使用机器算法之前，我们先把数据做下预处理，先把特征和标签拆分出来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;housing = strat_train_set.drop(&quot;median_house_value&quot;,axis=1) #原始数据集并未发生改变
housing_labels=strat_train_set[&quot;median_house_value&quot;].copy()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据清洗&quot;&gt;数据清洗&lt;/h3&gt;
&lt;p&gt;大多数机器学习算法是不能在有缺失值的数据集上面运行的，而本数据集特征&lt;code&gt;total_bedrooms&lt;/code&gt;是存在数据缺失现象的，所以就需要想办法处理，有以下几个思路：&lt;/p&gt;
&lt;ul readability=&quot;75.5&quot;&gt;&lt;li&gt;1.将存在缺失数据的样本去除掉&lt;/li&gt;
&lt;li&gt;2.将存在缺失数据的特征去除掉&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;3.将缺失值用统一的值替换，如：均值、中值等&lt;br/&gt;上面对应的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;housing.dropna(subset=[&quot;total_bedrooms&quot;]) # 1.删除样本
housing.drop(&quot;total_bedrooms&quot;, axis=1) # 2.删除特征，注意参数的用法和1不一样
median = housing[&quot;total_bedrooms&quot;].median()
housing[&quot;total_bedrooms&quot;].fillna(median) # 3. 中值填充&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;去过采用的是方法3那么就需要将替换的值保存起来，在后续的工作中需要将它应用到测试集，以及可能添加的新数据。上面这个操作是使用pandas，sklearn提供了&lt;code&gt;Imputer&lt;/code&gt;,同样能够很好解决缺失值问题，下面其用法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.preprocessing import Imputer
imputer = Imputer(strategy=&quot;median&quot;)
housing_num = housing.drop(&quot;ocean_proximity&quot;, axis=1) #去除非数值类特征
imputer.fit(housing_num)&lt;/code&gt;
&lt;/pre&gt;
imputer提供了以下几种填充策略&lt;/li&gt;
&lt;li&gt;If &quot;mean&quot;, then replace missing values using the mean along the axis.&lt;/li&gt;
&lt;li&gt;If &quot;median&quot;, then replace missing values using the median along the axis.&lt;/li&gt;
&lt;li readability=&quot;138&quot;&gt;
&lt;p&gt;If &quot;most_frequent&quot;, then replace missing using the most frequent value along the axis.&lt;br/&gt;通过&lt;code&gt;statistics_&lt;/code&gt; 查看填充的数值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;imputer.statistics_
array([-118.51      ,   34.26      ,   29.        , ...,    5.23228423,
      0.20303137,    2.8176527 ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看一看pandas计算出来的中值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;housing_num.median().values
array([-118.51      ,   34.26      ,   29.        , ...,    5.23228423,
      0.20303137,    2.8176527 ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就需要将计算得到的数值应用到数据集中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;X = imputer.transform(housing_num) 
&amp;gt;&amp;gt;type(X)
numpy.ndarray&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终得到的是结果是array类型，如果想转为pandas类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;housing_tr = pd.DataFrame(X, columns=housing_num.columns)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们把&lt;code&gt;ocean_proximity&lt;/code&gt;这一特征去掉，所以这些操作是处理数值类型的特征，那么非数值类型的该如何处理呢？&lt;/p&gt;
&lt;h3 id=&quot;处理文本和类别特征&quot;&gt;处理文本和类别特征&lt;/h3&gt;
&lt;p&gt;决策树、贝叶斯等分类器能够处理标签类特征，但很多算法是不能处理这类特征，需要转换为数值类型，sklearn提供了&lt;code&gt;LabelEncoder&lt;/code&gt;特征转换方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.preprocessing import LabelEncoder
encoder = LabelEncoder()
housing_cat = housing[&quot;ocean_proximity&quot;]
housing_cat_encoded = encoder.fit_transform(housing_cat)
&amp;gt;&amp;gt;housing_cat_encoded 
 array([0, 0, 4, ..., 1, 0, 3], dtype=int64)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是输出编码的结果，那么对应的0、1...是指的什么呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;encoder.clases_
array(['&amp;lt;1H OCEAN', 'INLAND', 'ISLAND', 'NEAR BAY', 'NEAR OCEAN'], dtype=object)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过类别号可以表示类别，还有一种方法能够表示类别---&lt;code&gt;one hot&lt;/code&gt;,该特征取的值位置为1，其余为0；当然sklearn也提供了实现方法&lt;code&gt;OneHotEncoder&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.preprocessing import OneHotEncoder
encoder = OneHotEncoder()
housing_cat_1hot = encoder.fit_transform(housing_cat_encoded.reshape(-1,1))#返回的为稀疏矩阵
&amp;gt;&amp;gt;housing_cat_1hot.toarray()
array([[ 1.,  0.,  0.,  0.,  0.],
   [ 1.,  0.,  0.,  0.,  0.],
   [ 0.,  0.,  0.,  0.,  1.],
   ..., 
   [ 0.,  1.,  0.,  0.,  0.],
   [ 1.,  0.,  0.,  0.,  0.],
   [ 0.,  0.,  0.,  1.,  0.]])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;code&gt;housing_cat_encoded&lt;/code&gt;返回的为1D 数组，fit_transform需要传入的为一个2D数组，需要先转为列向量。&lt;br/&gt;可以将上面&lt;code&gt;encoder&lt;/code&gt;和&lt;code&gt;one hot&lt;/code&gt;过程合并为一个&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.preprocessing import LabelBinarizer
encoder = LabelBinarizer()
housing_cat_1hot=encoder.fit_transform(housing_cat)
&amp;gt;&amp;gt;housing_cat_1hot #numpy array
array([[1, 0, 0, 0, 0],
   [1, 0, 0, 0, 0],
   [0, 0, 0, 0, 1],
   ..., 
   [0, 1, 0, 0, 0],
   [1, 0, 0, 0, 0],
   [0, 0, 0, 1, 0]])&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义处理方法&quot;&gt;自定义处理方法&lt;/h3&gt;
&lt;p&gt;尽管sklearn提供了强大的数据处理功能，有些时候我们需要根据自己的需求自定义一些数据预处理方法，并且让我们这些操作有着sklearnAPI相似的用法，我们所需要做的就是继承&lt;code&gt;BaseEstimator&lt;/code&gt;类，并覆写三个方法&lt;code&gt;fit&lt;/code&gt;，&lt;code&gt;transform&lt;/code&gt;和&lt;code&gt;fit_transform&lt;/code&gt;，第三个方法是前两个的整合，如果不想覆写&lt;code&gt;fit_transform&lt;/code&gt;,可以继承&lt;code&gt;TransformerMixin&lt;/code&gt;(从类名称就可以看出其作用)这个类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;from sklearn.base import BaseEstimator, TransformerMixin
rooms_ix, bedrooms_ix, population_ix, household_ix = 3, 4, 5, 6
class CombinedAttributesAdder(BaseEstimator, TransformerMixin):
    def __init__(self, add_bedrooms_per_room = True): # no *args or **kargs
                self.add_bedrooms_per_room = add_bedrooms_per_room
    def fit(self, X, y=None):
        return self # nothing else to do
    def transform(self, X, y=None):
        rooms_per_household = X[:, rooms_ix] / X[:, household_ix]
        population_per_household = X[:, population_ix] / X[:, household_ix]
        if self.add_bedrooms_per_room:
            bedrooms_per_room = X[:, bedrooms_ix] / X[:, rooms_ix]
            return np.c_[X, rooms_per_household, population_per_household,bedrooms_per_room]
        else:
            return np.c_[X, rooms_per_household, population_per_household]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;attr_adder = CombinedAttributesAdder(add_bedrooms_per_room=False)
housing_extra_attribs = attr_adder.transform(housing.values) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面定义的类的功能是为原数据集添加新的特征，&lt;code&gt;X[:,3]&lt;/code&gt;表示的是第4列所有数据，&lt;code&gt;np.c_&lt;/code&gt;表示的是拼接数组。&lt;br/&gt;&lt;strong&gt;另外&lt;/strong&gt;sklearn是不能直接处理&lt;code&gt;DataFrames&lt;/code&gt;的，那么我们需要自定义一个处理的方法将之转化为numpy类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class DataFrameSelector(BaseEstimator,TransformerMixin):
    def __init__(self,attribute_names): #可以为列表
        self.attribute_names = attribute_names
    def fit(self,X,y=None):
        return self
    def transform(self,X):
        return X[self.attribute_names].values #返回的为numpy array&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;特征缩放&quot;&gt;特征缩放&lt;/h3&gt;
&lt;p&gt;机器学习算法在缩放尺度不一样的数据效果比较差，比就如房价数据集&lt;code&gt;total_bedrooms&lt;/code&gt;的取值范围为1~6445，而&lt;code&gt;median_income&lt;/code&gt;的范围是0.5~15，所以需要对特征进行缩放。&lt;br/&gt;&lt;strong&gt;note:&lt;/strong&gt;通常情况下Target特征不需缩放&lt;br/&gt;有两种缩放数据的方法&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;min-max方式,对应的方法为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MinMaxScaler(self, feature_range=(0, 1), copy=True)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;standardization 标准化数据,对应的方法为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;StandardScaler(self, copy=True, with_mean=True, with_std=True)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;特征处理流程&quot;&gt;特征处理流程&lt;/h3&gt;
&lt;p&gt;目前在数据预处理阶段，我们需要对缺失值进行处理、特征组合和特征缩放。每一步的执行都有着先后顺序，sklearn提供了&lt;code&gt;Pipeline&lt;/code&gt;帮助顺序完成转换。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;num_attribs = list(housing_num)#返回的为列名[col1,col2,....]
cat_attribs = [&quot;ocean_proximity&quot;]

num_pipeline = Pipeline([ #数值类型
        ('selector', DataFrameSelector(num_attribs)),
        ('imputer', Imputer(strategy=&quot;median&quot;)),
        ('attribs_adder', CombinedAttributesAdder()),
        ('std_scaler', StandardScaler()),
    ])

cat_pipeline = Pipeline([ #标签类型
        ('selector', DataFrameSelector(cat_attribs)),
        ('cat_encoder', CategoricalEncoder(encoding=&quot;onehot-dense&quot;)),
    ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面定义的为分别处理数值类型和标签类型的转换流程，&lt;code&gt;housing_num&lt;/code&gt;为&lt;code&gt;DataFrame&lt;/code&gt;类型，&lt;code&gt;list(DataFrame)&lt;/code&gt;的结果会是什么？返回的为列名字，不管你们信不信，反正我是信了。pandas真是太强大了。上面着两个流程还可以再整合一起&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.pipeline import FeatureUnion
full_pipeline = FeatureUnion(transformer_list=[
        (&quot;num_pipeline&quot;, num_pipeline),
        (&quot;cat_pipeline&quot;, cat_pipeline),
    ])
housing_prepared = full_pipeline.fit_transform(housing)#最终的结果&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;今天就到这里把，工作了一天好困、眼疼，先发出去，明天再看看有没有什么错误。&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 15:55:00 +0000</pubDate>
<dc:creator>Wanna_Go</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wxshi/p/7764518.html</dc:identifier>
</item>
<item>
<title>Web性能测试工具之ab入门篇 - lovesoo</title>
<link>http://www.cnblogs.com/lovesoo/p/7762796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovesoo/p/7762796.html</guid>
<description>&lt;p&gt;ab全称Apache Bench，是apache附带的一个小工具，它可以同时模拟多个并发请求，测试apache等Web服务器的最大负载压力。&lt;/p&gt;
&lt;p&gt;本文通过一个简单的示例，介绍了使用ab进行web页面性能测试、查看结果方法及运行参数详解。&lt;/p&gt;
&lt;p&gt;运行环境为Windows 10系统。&lt;/p&gt;


&lt;h2&gt;2.1 Windows系统&lt;/h2&gt;

&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201710/445074-20171031232944185-233482869.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;h2&gt;2.2 linux系统&lt;/h2&gt;
&lt;p&gt;使用如下命令安装Apache&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; httpd
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;使用cmd/shell进入到Apache24\bin目录下，运行ab即可&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/yws/public/resource/6198d73bf23289361757538ca7f02a97/xmlnote/121C298EE35744C8AF79B53360FB5018/11331&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;http://note.youdao.com/yws/public/resource/6198d73bf23289361757538ca7f02a97/xmlnote/121C298EE35744C8AF79B53360FB5018/11331&quot;/&gt;&lt;/div&gt;



&lt;p&gt;最常用两种运行命令如下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ab -n &lt;span&gt;10&lt;/span&gt; -c &lt;span&gt;10&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.baidu.com/&lt;/span&gt;
# -n 总共10次请求，-&lt;span&gt;c 模拟10个并发用户，即10个并发请求百度首页，共请求10次
 
ab &lt;/span&gt;-t &lt;span&gt;10&lt;/span&gt; -c &lt;span&gt;10&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.baidu.com/&lt;/span&gt;
# -t 是测试执行时间，-c 模拟10个并发用户，即10个并发请求百度首页，持续10秒
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201710/445074-20171031233316998-837358653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
Server Software: BWS/&lt;span&gt;1.1&lt;/span&gt;&lt;span&gt;
Server Hostname: www.baidu.com
Server Port: &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;
 
Document Path: &lt;/span&gt;/&lt;span&gt;
Document Length: &lt;/span&gt;&lt;span&gt;113316&lt;/span&gt;&lt;span&gt; bytes HTTP响应数据的正文长度
 
Concurrency Level: &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;　#并发数
Time taken &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; tests: &lt;span&gt;10.013&lt;/span&gt;&lt;span&gt; seconds #测试执行时间
Complete requests: &lt;/span&gt;&lt;span&gt;276&lt;/span&gt;&lt;span&gt; #完成请求数
Failed requests: &lt;/span&gt;&lt;span&gt;271&lt;/span&gt;&lt;span&gt; #失败请求数
(Connect: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, Receive: &lt;span&gt;0&lt;/span&gt;, Length: &lt;span&gt;271&lt;/span&gt;, Exceptions: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
Total transferred: &lt;/span&gt;&lt;span&gt;31552184&lt;/span&gt;&lt;span&gt; bytes #网络总传输量
HTML transferred: &lt;/span&gt;&lt;span&gt;31287062&lt;/span&gt;&lt;span&gt; bytes #HTML内容传输量
Requests per second: &lt;/span&gt;&lt;span&gt;27.56&lt;/span&gt; [#/&lt;span&gt;sec] (mean) #每秒请求数
Time per request: &lt;/span&gt;&lt;span&gt;362.801&lt;/span&gt; [ms] (mean) #用户平均请求等待时间，计算公式：测试执行总时间/（总请求数/&lt;span&gt;并发用户数）
Time per request: &lt;/span&gt;&lt;span&gt;36.280&lt;/span&gt; [ms] (mean, across all concurrent requests) #服务器平均请求等待时间，计算公式：测试执行总时间/&lt;span&gt;总请求数
Transfer rate: &lt;/span&gt;&lt;span&gt;3077.17&lt;/span&gt; [Kbytes/&lt;span&gt;sec] received    #平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题
 
Connection Times (ms)    #响应时间小、中、大值
min mean[&lt;/span&gt;+/-&lt;span&gt;sd] median max
Connect: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;9&lt;/span&gt; &lt;span&gt;8.4&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; &lt;span&gt;55&lt;/span&gt;&lt;span&gt;
Processing: &lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;346&lt;/span&gt; &lt;span&gt;77.2&lt;/span&gt; &lt;span&gt;353&lt;/span&gt; &lt;span&gt;509&lt;/span&gt;&lt;span&gt;
Waiting: &lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;236&lt;/span&gt; &lt;span&gt;41.0&lt;/span&gt; &lt;span&gt;237&lt;/span&gt; &lt;span&gt;365&lt;/span&gt;&lt;span&gt;
Total: &lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;355&lt;/span&gt; &lt;span&gt;76.1&lt;/span&gt; &lt;span&gt;362&lt;/span&gt; &lt;span&gt;522&lt;/span&gt;&lt;span&gt;
 
Percentage of the requests served within a certain &lt;/span&gt;&lt;span&gt;time&lt;/span&gt; (ms)    #一定时间内请求完成的百分比，如50%用户完成的响应时间在362ms内, &lt;span&gt;66&lt;/span&gt;%用户完成的响应时间在390ms内，&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;用户在522ms内完成
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;% &lt;span&gt;362&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;% &lt;span&gt;390&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;% &lt;span&gt;413&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;% &lt;span&gt;421&lt;/span&gt;
&lt;span&gt;90&lt;/span&gt;% &lt;span&gt;460&lt;/span&gt;
&lt;span&gt;95&lt;/span&gt;% &lt;span&gt;476&lt;/span&gt;
&lt;span&gt;98&lt;/span&gt;% &lt;span&gt;490&lt;/span&gt;
&lt;span&gt;99&lt;/span&gt;% &lt;span&gt;500&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;% &lt;span&gt;522&lt;/span&gt; (longest request)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;官方帮助文档如下：&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Usage: ab [options] [http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;]hostname[:port]/path&lt;/span&gt;
&lt;span&gt;Options are:
&lt;/span&gt;-&lt;span&gt;n requests Number of requests to perform
&lt;/span&gt;-c concurrency Number of multiple requests to &lt;span&gt;make&lt;/span&gt; at a &lt;span&gt;time&lt;/span&gt;
-&lt;span&gt;t timelimit Seconds to max. to spend on benchmarking
This implies &lt;/span&gt;-n &lt;span&gt;50000&lt;/span&gt;
-s timeout Seconds to max. &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; each response
Default is &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt; seconds
&lt;/span&gt;-b windowsize Size of TCP send/receive buffer, &lt;span&gt;in&lt;/span&gt;&lt;span&gt; bytes
&lt;/span&gt;-&lt;span&gt;B address Address to bind to when making outgoing connections
&lt;/span&gt;-p postfile File containing data to POST. Remember also to set -&lt;span&gt;T
&lt;/span&gt;-u putfile File containing data to PUT. Remember also to set -&lt;span&gt;T
&lt;/span&gt;-T content-type Content-type header to use &lt;span&gt;for&lt;/span&gt; POST/&lt;span&gt;PUT data, eg.
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Default is &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/plain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
-v verbosity How much troubleshooting &lt;span&gt;info&lt;/span&gt;&lt;span&gt; to print
&lt;/span&gt;-&lt;span&gt;w&lt;/span&gt; Print out results &lt;span&gt;in&lt;/span&gt;&lt;span&gt; HTML tables
&lt;/span&gt;-&lt;span&gt;i Use HEAD instead of GET
&lt;/span&gt;-&lt;span&gt;x attributes String to insert as table attributes
&lt;/span&gt;-y attributes String to insert as &lt;span&gt;tr&lt;/span&gt;&lt;span&gt; attributes
&lt;/span&gt;-&lt;span&gt;z attributes String to insert as td or th attributes
&lt;/span&gt;-C attribute Add cookie, eg. &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Apache=1234&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;. (repeatable)
&lt;/span&gt;-H attribute Add Arbitrary header line, eg. &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accept-Encoding: gzip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Inserted after all normal header lines. (repeatable)
&lt;/span&gt;-&lt;span&gt;A attribute Add Basic WWW Authentication, the attributes
are a colon separated username and password.
&lt;/span&gt;-&lt;span&gt;P attribute Add Basic Proxy Authentication, the attributes
are a colon separated username and password.
&lt;/span&gt;-&lt;span&gt;X proxy:port Proxyserver and port number to use
&lt;/span&gt;-&lt;span&gt;V Print version number and exit
&lt;/span&gt;-&lt;span&gt;k Use HTTP KeepAlive feature
&lt;/span&gt;-&lt;span&gt;d Do not show percentiles served table.
&lt;/span&gt;-&lt;span&gt;S Do not show confidence estimators and warnings.
&lt;/span&gt;-q Do not show progress when doing &lt;span&gt;more&lt;/span&gt; than &lt;span&gt;150&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;-l Accept variable document length (use this &lt;span&gt;for&lt;/span&gt;&lt;span&gt; dynamic pages)
&lt;/span&gt;-g filename Output collected data to gnuplot format &lt;span&gt;file&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;-e filename Output CSV &lt;span&gt;file&lt;/span&gt;&lt;span&gt; with percentages served
&lt;/span&gt;-r Don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t exit on socket receive errors.&lt;/span&gt;
-&lt;span&gt;m method Method name
&lt;/span&gt;-h Display usage information (this message)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;中文翻译如下：&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
-n 即requests，用于指定压力测试/&lt;span&gt;总请求数。
&lt;/span&gt;-&lt;span&gt;c 即concurrency，用于指定压力测试的并发数。
&lt;/span&gt;-&lt;span&gt;t 即timelimit，测试执行最大秒数，它可以让测试限制在一个固定的总时间以内，默认值为50000。
&lt;/span&gt;-&lt;span&gt;s 即timeout，请求最大等待时长，默认30s
&lt;/span&gt;-b 即windowsize，TCP发送/&lt;span&gt;接收的缓冲大小(单位：字节)。
&lt;/span&gt;-p 即postfile，发送POST请求时需要上传的文件，文件格式如&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1=1&amp;amp;p2=2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;。使用方法是 -p &lt;span&gt;123&lt;/span&gt;.txt 。 （配合-&lt;span&gt;T）
&lt;/span&gt;-u 即putfile，发送PUT请求时需要上传的文件。（配合-&lt;span&gt;T）
&lt;/span&gt;-T 即content-type，用于设置Content-Type请求头信息，如 -T &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded”，默认值为text/plain。（配合-p）&lt;/span&gt;
-v 即verbosity，设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(&lt;span&gt;404&lt;/span&gt;&lt;span&gt;, 200等), 2或更大值可以显示警告和其他信息。
&lt;/span&gt;-&lt;span&gt;w&lt;/span&gt;&lt;span&gt; 以HTML表格形式打印结果。
&lt;/span&gt;-&lt;span&gt;i 使用HEAD请求代替GET请求。
&lt;/span&gt;-&lt;span&gt;x 插入字符串作为table标签的属性。
&lt;/span&gt;-&lt;span&gt;y 插入字符串作为tr标签的属性。
&lt;/span&gt;-&lt;span&gt;z 插入字符串作为td标签的属性。
&lt;/span&gt;-C 添加cookie信息，例如：&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apache=1234&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;。此参数可以重复，用逗号分割。提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如&lt;/span&gt;-C &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;。
&lt;/span&gt;-H 添加任意的请求头，例如：&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Accept-Encoding: gzip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，请求头将会添加在现有的多个请求头之后(可以重复该参数选项以添加多个)。
&lt;/span&gt;-&lt;span&gt;A 添加一个基本的网络认证信息，用户名和密码之间用英文冒号隔开。
&lt;/span&gt;-P 添加一个基本的代理认证信息，用户名和密码之间用英文冒号隔开。如-P proxy-auth-&lt;span&gt;username:password
&lt;/span&gt;-X 指定使用的代理服务器和端口号，例如:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;126.10.10.3:88&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;。
&lt;/span&gt;-&lt;span&gt;V 显示版本号并退出。
&lt;/span&gt;-&lt;span&gt;k 使用HTTP的KeepAlive特性。
&lt;/span&gt;-&lt;span&gt;d 不显示百分比。
&lt;/span&gt;-&lt;span&gt;S 不显示预估和警告信息。
&lt;/span&gt;-&lt;span&gt;q 超过150个请求后不显示进度
&lt;/span&gt;-&lt;span&gt;l 接受可变文档长度（用于动态页面）
&lt;/span&gt;-&lt;span&gt;g filename 输出结果信息到gnuplot格式的文件中。
&lt;/span&gt;-&lt;span&gt;e filename 输出结果信息到CSV格式的文件中。
&lt;/span&gt;-&lt;span&gt;r 指定接收到错误信息时不退出程序。
&lt;/span&gt;-&lt;span&gt;m method 方法名
&lt;/span&gt;-h 帮助
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 31 Oct 2017 15:43:00 +0000</pubDate>
<dc:creator>lovesoo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovesoo/p/7762796.html</dc:identifier>
</item>
<item>
<title>脱壳第三讲,UPX压缩壳,以及补充壳知识 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7764483.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7764483.html</guid>
<description>&lt;h2&gt;一丶什么是压缩壳.以及壳的原理&lt;/h2&gt;
&lt;p&gt;在理解什么是压缩壳的时候,我们先了解一下什么是壳&lt;/p&gt;
&lt;h3&gt;1.什么是壳&lt;/h3&gt;
&lt;p&gt;　　壳可以简单理解为就是在自己的PE文件中包含了代码.而有不影响我们的PE文件的执行.&lt;/p&gt;
&lt;h3&gt;2.什么是压缩壳&lt;/h3&gt;
&lt;p&gt;　　压缩壳指的是让我们的PE文件变小.&lt;/p&gt;
&lt;h3&gt;3.压缩壳原理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031225316591-1696939120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先可以看到,我们的PE文件&lt;/p&gt;
&lt;p&gt;一个PE头,两个节数据,其中节和节之间还有对齐值.而上图是我们的一个正常壳映射到内存中的示意图.&lt;/p&gt;
&lt;h3&gt;4.压缩壳的思路&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031225626748-1437822251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出, 我们的PE文件,压缩一下变成了一个新的PE文件,其中我们的PE文件,压缩的数据是节里面的数据&lt;/p&gt;
&lt;p&gt;也就是说,压缩壳的原理就是压缩PE文件中节的数据.然后产生新的PE,这个新的PE我们成为带壳的PE&lt;/p&gt;
&lt;p&gt; 而我们运行带壳PE的时候,这时候壳中的解压缩代码开始执行,从而把我们以前压缩数据的节重新映射到内存.&lt;/p&gt;
&lt;h3&gt;5.压缩壳方法1(PE的生成)&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031225948591-1255335936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时观察方法1我们会发现,我们新的PE, 解压缩的代码在压缩数据(节)的上面,那么这个时候则会面临一个问题&lt;/p&gt;
&lt;p&gt;如果我们解压缩的时候,那么压缩数据的地址应该在我们解压缩代码的哪里,那么此时我们一边解压缩,一边压缩数据会覆盖解压缩代码,此时我们不知道是先解压完成,还是先覆盖完成&lt;/p&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;p&gt;　　首先我们知道原PE的节的个数以及大小,那么此时我们生成的新的带壳PE,则会获得大小.然后在其带壳PE的下面申请怎么大小的节用来占位置即可.&lt;/p&gt;
&lt;p&gt;那么此时我们解压的数据,则会写到我们占位置的地方.&lt;/p&gt;

&lt;p&gt;如果不懂可以看下图理解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031230426185-739480095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 此时Shell(中文翻译为壳)代表的就是解压缩的代码&lt;/p&gt;
&lt;p&gt;这个图是映射到内存中的带壳PE分布图.&lt;/p&gt;
&lt;p&gt;很简单,解压缩代码执行,然后解压的代码正好在我们占地方的位置.&lt;/p&gt;
&lt;h3&gt;二丶脱壳步骤,以及手脱UPX壳&lt;/h3&gt;
&lt;p&gt;首先我们知道压缩壳了,压缩壳就是缩小PE文件&lt;/p&gt;
&lt;p&gt;那么在壳的世界 还有加密壳.  原理是一样的,只不过 &lt;/p&gt;
&lt;p&gt;压缩壳:　用来压缩数据，减小ＰＥ体积&lt;/p&gt;
&lt;p&gt;加密壳：用来防住你们我们他们等等逆向人员的　＾＿＾&lt;/p&gt;
&lt;h3&gt;1.脱壳步骤：&lt;/h3&gt;
&lt;p&gt;１．查找OEP(入口点 )&lt;/p&gt;
&lt;p&gt;　　 方法: 经验,这个主要看经验&lt;/p&gt;
&lt;p&gt;　　 不过这个经验也好分辨.&lt;/p&gt;
&lt;p&gt; 2.脱壳手法&lt;/p&gt;
&lt;p&gt;  　2.1 ESP 定律&lt;/p&gt;
&lt;p&gt;      2.2 API&lt;/p&gt;
&lt;p&gt;      2.3 单步跟踪(步过循环,只向下跳转)&lt;/p&gt;
&lt;p&gt;3. 经过上面步骤开始脱壳&lt;/p&gt;
&lt;p&gt;　　手工DMP内存(把内存拷贝下来)&lt;/p&gt;
&lt;p&gt;       然后修复PE (一般加密壳汇编PE中的导入表给抹掉)&lt;/p&gt;
&lt;p&gt;首先ESP定律,在壳的第一讲已经讲解过了&lt;/p&gt;
&lt;p&gt;这里我们说下怎么查看入口点,以及脱壳手法的API 跟踪,和单步跟踪.&lt;/p&gt;
&lt;h3&gt;2.识别入口点&lt;/h3&gt;
&lt;p&gt;如果要识别入口点,这里只简单说下,因为比如 VC++6.0  VSXXX  VB...等等入口点都是不一样的&lt;/p&gt;
&lt;p&gt;这里直说一下VC和VS入口点的识别方法.&lt;/p&gt;
&lt;p&gt;首先随便打开一个没有加壳的程序(VC++6.0的)OD打开查看.&lt;/p&gt;
&lt;p&gt;1.VC6.0的识别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031231530279-196779325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;往下拖动一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031231551685-119112498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,VC6.0的入口点会固定的调用这三个API&lt;/p&gt;
&lt;p&gt;只需要记住即可.看下VS的识别方法&lt;/p&gt;
&lt;h3&gt;&lt;sup&gt;2.VS系列识别方法&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031232418357-1564861789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不知道还是电脑原因还是编译器原因,编译的程序不能在XP下使用OD打开,所以只能用IDA说下了&lt;/p&gt;
&lt;p&gt;如果OD能打开,那么则是一个Call 然后下方紧接着跟着一个JMP跳转&lt;/p&gt;
&lt;p&gt;那么它的入口点特征则是调用以上的API&lt;/p&gt;
&lt;h3&gt;3.使用API定位脱壳&lt;/h3&gt;
&lt;p&gt;因为ESP定律已经说过了,这里使用API进行脱壳.&lt;/p&gt;
&lt;p&gt;思路:&lt;/p&gt;
&lt;p&gt;　　因为我们知道入口点的特征,比如VC6.0的,它会调用API,那么我们API下段点即可.肯定会过去的.&lt;/p&gt;
&lt;p&gt;首先我们脱一个VC6.0的upx压缩壳.&lt;/p&gt;
&lt;p&gt;首先我们知道入口点会调用的API&lt;/p&gt;
&lt;p&gt;那么我们下断点即可.&lt;/p&gt;
&lt;p&gt;(注意,这里使用UPX随便压缩了一个VC的程序,UPX可以官网下载,VC程序也可以自己编写一个)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031232922248-1281315030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;F9以下,看看能不能断下来.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031233231810-637147263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;断下来了,只不过是断在里面了,然后我们执行到返回  CTRL + F9 即可看到我们的熟悉的特征&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031233325216-1994969802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确实使我们的入口点位置&lt;/p&gt;
&lt;p&gt;那么此时移动汇编代码到入口点,也就是一开始的地方,(因为此时程序已经执行的API可能数据已经破坏了,所以我们在入口点位置下段点,重新运行则可以断在入口点)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031233610357-1589795334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时重新运行程序,当我们的EIP 位置是4014EC的地方我们则可以DMP内存了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031234248435-1962653786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存一份即可.&lt;/p&gt;
&lt;h3&gt;3.使用单步方法定位入口点.&lt;/h3&gt;
&lt;p&gt;这个就比较简单了,我们遇到循环,不看直接往下单步走,直到走到一个远跳即可.&lt;/p&gt;
&lt;p&gt;比如我模拟一下OD&lt;/p&gt;
&lt;p&gt;地址:     汇编代码&lt;/p&gt;
&lt;p&gt;1　　　add eax,eax&lt;/p&gt;
&lt;p&gt;2          mov eax,eax&lt;/p&gt;
&lt;p&gt;3          jnz   1 　　 　　　　EIP = 3&lt;/p&gt;
&lt;p&gt;4　　  mov edx,edx&lt;/p&gt;
&lt;p&gt;5         jmp  00401000&lt;/p&gt;
&lt;p&gt; 此时EIP = 3,那么会跳转到1,那么这个时候我们在4地址下段点即可,不看它的循环,一直到5地址,有个远跳,即可.&lt;/p&gt;
&lt;p&gt;关于DMP内存和上面一样,不说了.&lt;/p&gt;

</description>
<pubDate>Tue, 31 Oct 2017 15:43:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7764483.html</dc:identifier>
</item>
<item>
<title>服务端事件EventSource揭秘 - royalrover</title>
<link>http://www.cnblogs.com/accordion/p/7764460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/accordion/p/7764460.html</guid>
<description>&lt;h2 id=&quot;服务端推&quot;&gt;服务端推&lt;/h2&gt;
&lt;p&gt;服务端推，指的是由服务器主动的向客户端发送消息（响应）。在应用层的HTTP协议实现中，“请求-响应”是一个round trip，它的起点来自客户端，因此在应用层之上无法实现简易的服务端推功能。当前解决服务端推送的方案有这几个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端长轮询&lt;/li&gt;
&lt;li&gt;websocket双向连接&lt;/li&gt;
&lt;li&gt;iframe永久帧&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;长轮训虽然可以避免短轮训造成的服务端过载，但在服务端返回数据后仍需要客户端主动发起下一个长轮训请求，等待服务端响应，这样仍需要底层的连接建立而且服务端处理逻辑需要相应处理，不符合逻辑上的流程简单的服务端推送；&lt;/p&gt;
&lt;p&gt;websocket连接相对而言功能最强大，但是它对服务器的版本有要求，在可以使用websocket协议的服务器上尽量采用此种方式；&lt;/p&gt;
&lt;p&gt;iframe永久帧则是在在页面嵌入一个专用来接受数据的iframe页面，该页面由服务器输出相关信息，如&lt;strong/&gt;，服务器不停的向iframe中写入类似的script标签和数据，实现另一种形式的服务端推送。不过永久帧的技术会导致主页面的加载条始终处于“loading”状态，体验很差。&lt;/p&gt;
&lt;p&gt;HTML5规范中提供了服务端事件EventSource，浏览器在实现了该规范的前提下创建一个EventSource连接后，便可收到服务端的发送的消息，这些消息需要遵循一定的格式，对于前端开发人员而言，只需在浏览器中侦听对应的事件皆可。&lt;/p&gt;
&lt;p&gt;相比较上文中提到的3中实现方式，EventSource流的实现方式对客户端开发人员而言非常简单，兼容性上出了IE系的浏览器（IE、Edge）外其他都良好；对于服务端，它可以兼容老的浏览器，无需upgrade为其他协议，在简单的服务端推送的场景下可以满足需求。在浏览器与服务端需要强交互的场景下，websocket仍是不二的选择。&lt;/p&gt;
&lt;h2 id=&quot;eventsource规范简析&quot;&gt;EventSource规范简析&lt;/h2&gt;
&lt;h3 id=&quot;浏览器端&quot;&gt;浏览器端&lt;/h3&gt;
&lt;p&gt;浏览器端，需要创建一个EventSource对象，并且传入一个服务端的接口URI作为参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var evtSource = new EventSource('http://localhost:9111/es');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，'&lt;a href=&quot;http://localhost:9111/es'%E4%B8%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%90%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%82%E7%9B%AE%E5%89%8D%EF%BC%8CEventSource%E5%9C%A8%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E4%B8%8D%E6%94%AF%E6%8C%81&quot; class=&quot;uri&quot;&gt;http://localhost:9111/es'为服务端吐出数据的接口。目前，EventSource在大多数浏览器端不支持&lt;/a&gt;&lt;br/&gt;跨域，因此它不是一种跨域的解决方案。&lt;/p&gt;
&lt;p&gt;默认EventSource对象通过侦听“message”事件获取服务端传来的消息，“open”事件则在http连接建立后触发，”error“事件会在通信错误（连接中断、服务端返回数据失败）的情况下触发。同时，EventSource规范允许服务端指定自定义事件，客户端侦听该事件即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;evtSource.addEventListener('message',function(e){
    console.log(e.data);
});
evtSource.addEventListener('error',function(e){
    console.log(e);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;服务端&quot;&gt;服务端&lt;/h3&gt;
&lt;p&gt;事件流的对应MIME格式为&lt;strong&gt;text/event-stream&lt;/strong&gt;，而且其基于HTTP长连接。针对HTTP1.1规范默认采用长连接，针对HTTP1.0的服务器需要特殊设置。&lt;/p&gt;
&lt;p&gt;服务端返回数据需要特殊的格式，它分为四种消息类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;event, data, id, retry&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，event指定自定义消息的名称，如&lt;strong&gt;event: customMessage\n&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;data指定具体的消息体，可以是对象或者字符串，如&lt;strong&gt;data: &lt;code&gt;JSON.stringify(jsonObj)\n\n&lt;/code&gt;&lt;/strong&gt;,在消息体后面有两个换行符\n，代表当前消息体发送完毕，一个换行符标识当前消息并未结束，浏览器需要等待后面数据的到来后再触发事件；&lt;/p&gt;
&lt;p&gt;id为当前消息的标识符，可以不设置。一旦设置则在浏览器端的eventSource对象中就会有体现(假设服务端返回&lt;strong&gt;id: 369\n&lt;/strong&gt;)，&lt;code&gt;eventSource.lastEventId == 369&lt;/code&gt;。该字段使用场景不大;&lt;/p&gt;
&lt;p&gt;retry设置当前http连接失败后，重新连接的间隔。EventSource规范规定，客户端在http连接失败后默认进行重新连接，重连间隔为3s，通过设置retry字段可指定重连间隔;&lt;/p&gt;
&lt;p&gt;每个字段都有名称，紧接着有个”:“。当出现一个没有名称的字段而只有”:“时，这就会被服务端理解为”注释“，并不会被发送至浏览器端，如&lt;em&gt;: commision&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;由于EventSource是基于HTTP连接之上的，因此在一段没有数据的时期会出现超时问题。&lt;strong&gt;服务器默认HTTP超时时间为2分钟，在node端可以通过response.connection.setTimeou(0)设置为默认的2min超时&lt;/strong&gt;， 因此需要服务端做心跳保活，否则客户端在连接超时的情况下出现&lt;strong&gt;net::ERR_INCOMPLETE_CHUNKED_ENCODING&lt;/strong&gt;错误。通过阅读相关规范，发现注释行可以用来防止连接超时,服务器可以定期发送一条消息注释行,以保持连接不断。&lt;/p&gt;
&lt;p&gt;下面提供koa的服务端代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var fs = require('fs');
var path = require('path');
var PassThrough = require('stream').PassThrough;
var Readable = require('stream').Readable;
var koa = require('koa');
var Router = require('koa-router');
var app = new koa();
var router = new Router();

function RR(){
    Readable.call(this,arguments);
}
RR.prototype = new Readable();
RR.prototype._read = function(data){
}

router.get('/',function(ctx,next){
    ctx.set('content-type','text/html');
    ctx.body = fs.readFileSync(path.join(process.cwd(),'eventServer.html'));
});

const sse = (stream,event, data) =&amp;gt; {
    return stream.push(`event:${ event }\ndata: ${ JSON.stringify(data) }\n\n`)
//    return stream.write(`event:${ event }\ndata: ${ JSON.stringify(data) }\n\n`);
}
router.get('/es',function(ctx,next){
    var stream = new RR()//PassThrough();
    ctx.set({
        'Content-Type':'text/event-stream',
        'Cache-Control':'no-cache',
        Connection: 'keep-alive'
    });
    sse(stream,'test',{a: &quot;yango&quot;,b: &quot;tango&quot;});
    ctx.body = stream;
    setInterval(()=&amp;gt;{
        sse(stream,'test',{a: &quot;yango&quot;,b: Date.now()});
    },3000); 
});

app.use(router.routes());
app.listen(9111,function(){
    console.log('listening port 9111');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处需要注意的是koa-router的返回值必须是一个Stream（Readable），这是由于koa的特殊性造成的。如果context.body不是Stream是一个字符串或者Buffer实例，会直接在node原生中调用res.end(buffer),结束了HTTP响应：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;koa lib/application.js

// responses
if (Buffer.isBuffer(body)) return res.end(body);
if ('string' == typeof body) return res.end(body);
if (body instanceof Stream) return body.pipe(res);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此造成了服务端事件流无法正确响应。而返回Stream类型的方式有几种，如通过扩展stream模块的Readable可读流返回或者直接采用PassThrough流返回，亦可通过through2模块或者Transform对象实现，归根到底保证可以从该stream对象中pipe出数据至http.ServerResponse对象中。&lt;/p&gt;
&lt;p&gt;附页面代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        hello world
    &amp;lt;/div&amp;gt;
    &amp;lt;p id=&quot;info&quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;script&amp;gt;
        var infoShow = document.querySelector('#info');
        var se = new EventSource('http://localhost:9111/es');
        se.addEventListener('test',function(e){
            infoShow.textContent += e.data+'\n';
        });
        se.addEventListener('error',function(e){
            console.log(e);
        })
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events&quot;&gt;使用服务器发送事件&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8761025/why-is-eventsource-connection-closed-every-30-60-sec-when-no-data-transported-w&quot;&gt;EventSource超时&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 15:36:00 +0000</pubDate>
<dc:creator>royalrover</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/accordion/p/7764460.html</dc:identifier>
</item>
<item>
<title>JavaScript数组去重方法汇总 - three_world</title>
<link>http://www.cnblogs.com/linwx/p/7764422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linwx/p/7764422.html</guid>
<description>&lt;h3&gt;1.运用数组的特性&lt;/h3&gt;
&lt;p&gt;　　1.遍历数组，也遍历辅助数组，找出两个数组中是否有相同的项，若有则break，没有的话就push进去。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一版本数组去重&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; unique(arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  res =&lt;span&gt; [],
         len &lt;/span&gt;=&lt;span&gt; arr.length;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0;i &amp;lt; len; i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reslen =&lt;span&gt; res.length;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let j = 0;j &amp;lt; reslen; j++){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历辅助数组&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(arr[i] ===&lt;span&gt; res[j]){
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(j ===&lt;span&gt; reslen){
            res.push(arr[i]); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有就添加进去&lt;/span&gt;
&lt;span&gt;        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2.运用es5的indexOf方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二版本数组去重 es5语法， IE8不能用&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; unique(arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; len =&lt;span&gt; arr.length,
        res &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( let i = 0; i &amp;lt; len ; i++&lt;span&gt;){
        let val &lt;/span&gt;=&lt;span&gt; arr[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(res.indexOf(val) === -1){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找不到返回-1&lt;/span&gt;
&lt;span&gt;            res.push(arr[i]);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3.如果数组已经排好序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; unique(arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; len =&lt;span&gt; arr.length;
        last,
        res &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0;i &amp;lt; len; i++&lt;span&gt;){
        let val &lt;/span&gt;=&lt;span&gt; arr[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(val !== last){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用last存储上一次的值&lt;/span&gt;
&lt;span&gt;            res.push(val);
        }
        last &lt;/span&gt;=&lt;span&gt; val;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4.留一个接口，传一个参数判断数组是否已经排好序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; unique(arr, isSort){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; len =&lt;span&gt; arr.length,
        res &lt;/span&gt;=&lt;span&gt; [],
        last;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isSort !== 'boolean'&lt;span&gt;){
        isSort &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0;i &amp;lt; len; i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val =&lt;span&gt; arr[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isSort){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!i || val!==&lt;span&gt; last){
                res.push(val);
            }
            last &lt;/span&gt;=&lt;span&gt; val;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(res.indexOf(val) === -1&lt;span&gt;){
                res.push(val);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5.如果有特殊需求的话，留一个接口，更灵活&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; unique(arr, isSort, fn){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; [],
        len &lt;/span&gt;=&lt;span&gt; arr.length,
        newArr &lt;/span&gt;=&lt;span&gt; [],
        last;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0;i &amp;lt; len; i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val =&lt;span&gt; arr[i],
            com &lt;/span&gt;= fn ?&lt;span&gt; fn(val, i, arr) : val;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isSort){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!i || com ===&lt;span&gt; last){
                res.push(val);
            }
            last &lt;/span&gt;=&lt;span&gt; com;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(fn){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(newArr.indexOf(com) === -1&lt;span&gt;){
                newArr.push(com);
                res.push(val);
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(res.indexOf(val === -1&lt;span&gt;)){
            res.push(val);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　6.用内部 filter 方法优化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; unique(arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; [],
    res &lt;/span&gt;= arr.filter(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item, index, arr){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res.indexOf(item) === index;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回true则添加到数组res,否则不添加&lt;/span&gt;
&lt;span&gt;    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.运用对象的特性&lt;/h3&gt;
&lt;p&gt;　　1.第一种方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; unique(arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {},
        res &lt;/span&gt;=&lt;span&gt; [],
    res &lt;/span&gt;= arr.filter(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item, index, aee){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj.hasOwnProperty(item) ? &lt;span&gt;false&lt;/span&gt; : (obj[item] = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　注意： 有一个Bug，var  = [ 1,1,&quot;1&quot;,2]，不能识别number类型的和string类型，添加到对象中都会转化为string。&lt;/p&gt;
&lt;p&gt;　　2.第二种方法&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; unique(arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {},
        res &lt;/span&gt;=&lt;span&gt; [],
        len &lt;/span&gt;=&lt;span&gt; arr.length;
    res &lt;/span&gt;= arr.filter(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item, index, arr){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj.hasOwnProperty(&lt;span&gt;typeof&lt;/span&gt; item + item) ? &lt;span&gt;false&lt;/span&gt; : (&lt;span&gt;typeof&lt;/span&gt; item + item) = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：这里也有bug，因为typeof的返回类型，检测不了对象。&lt;/p&gt;
&lt;p&gt;　　3.第三种方法&lt;/p&gt;
&lt;p&gt;　　运用json方法进行优化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; unique(arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {},
        res &lt;/span&gt;=&lt;span&gt; [],
        len &lt;/span&gt;=&lt;span&gt; arr.length;
    res &lt;/span&gt;= arr.filter(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item, index, arr){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj.hasOwnProperty(&lt;span&gt;typeof&lt;/span&gt; item + JSON.stringify(item)) ? &lt;span&gt;false&lt;/span&gt; : (&lt;span&gt;typeof&lt;/span&gt; item + JSON.stringify(item)) = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    })
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.ES6中的Set()对象&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; unique(arr){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [...&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set(arr)];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 31 Oct 2017 15:35:00 +0000</pubDate>
<dc:creator>three_world</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linwx/p/7764422.html</dc:identifier>
</item>
<item>
<title>idea配置jetty服务器，通过mvn实现 - 大战风车的男人</title>
<link>http://www.cnblogs.com/zuopy/p/7764431.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuopy/p/7764431.html</guid>
<description>&lt;p&gt;今天想试试除了tomcat之外的另一个服务器jetty的使用；&lt;/p&gt;
&lt;p&gt;关于项目在tomcat中的启动大概有多种，尤其是在本地环境下，ide关于tomcat的优化做的很好，但是在idea上面部署tomcat总不能正确的部署war包；&lt;/p&gt;
&lt;p&gt;会提示错误404 not found，此时jetty确实可以正常的跑起来的；&lt;/p&gt;
&lt;p&gt;虽然它只是一个war包部署到jetty里面就可以正常的运行，但是网上的资料很难找，或者干脆就是下面的通过mvn配置的；遂放弃；&lt;/p&gt;
&lt;p&gt;同时也感觉是不是配置的情况出了问题，eclipse的产品，对idea的支持有点不友好；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093418/201710/1093418-20171031231619888-1285997992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;除此之外，还可以通过自己写一个main方法实现jetty的启动，但是我觉得太过复杂，就放弃了；&lt;/p&gt;
&lt;p&gt;综合考虑，可以通过maven的plugin配置一下启动；&lt;/p&gt;
&lt;p&gt;比较简单，主要是可以很快的找到资源；&lt;/p&gt;
&lt;p&gt;首先，要找到jar包的坐标：&lt;/p&gt;
&lt;p&gt;　　我的方法是通过maven reposity 搜索；&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093418/201710/1093418-20171031231851373-1789967557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　在pom文件中添加如下配置：&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&amp;lt;build&amp;gt;&lt;br/&gt;&amp;lt;finalName&amp;gt;SmartTalent&amp;lt;/finalName&amp;gt;&lt;br/&gt;&amp;lt;plugins&amp;gt;&lt;br/&gt;&amp;lt;plugin&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;tomcat7-maven-plugin&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;configuration&amp;gt;&lt;br/&gt;&amp;lt;port&amp;gt;8080&amp;lt;/port&amp;gt;&lt;br/&gt;&amp;lt;path&amp;gt;/&amp;lt;/path&amp;gt;&lt;br/&gt;&amp;lt;uriEncoding&amp;gt;UTF-8&amp;lt;/uriEncoding&amp;gt;&lt;br/&gt;&amp;lt;server&amp;gt;tomcat7&amp;lt;/server&amp;gt;&lt;br/&gt;&amp;lt;/configuration&amp;gt;&lt;br/&gt;&amp;lt;/plugin&amp;gt;&lt;p&gt;&amp;lt;plugin&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.eclipse.jetty&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;jetty-maven-plugin&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;9.4.5.v20170502&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;configuration&amp;gt;&lt;br/&gt;&amp;lt;stopPort&amp;gt;9966&amp;lt;/stopPort&amp;gt;&lt;br/&gt;&amp;lt;stopKey&amp;gt;foo&amp;lt;/stopKey&amp;gt;&lt;br/&gt;&amp;lt;scanIntervalSeconds&amp;gt;10&amp;lt;/scanIntervalSeconds&amp;gt;&lt;br/&gt;&amp;lt;webApp&amp;gt;&lt;br/&gt;&amp;lt;!-- web项目根路径 --&amp;gt;&lt;br/&gt;&amp;lt;contextPath&amp;gt;/&amp;lt;/contextPath&amp;gt;&lt;br/&gt;&amp;lt;/webApp&amp;gt;&lt;br/&gt;&amp;lt;/configuration&amp;gt;&lt;br/&gt;&amp;lt;/plugin&amp;gt;&lt;br/&gt;&amp;lt;/plugins&amp;gt;&lt;br/&gt;&amp;lt;/build&amp;gt;&lt;br/&gt;通过引入包，通过配置简单的mvn命令即可正确的实现服务器的启动；&lt;br/&gt;通过点击 edit configurations-&amp;gt; +号 -&amp;gt;maven-&amp;gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093418/201710/1093418-20171031232645076-1695872312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
点击ok即可正常的启动；&lt;/pre&gt;</description>
<pubDate>Tue, 31 Oct 2017 15:28:00 +0000</pubDate>
<dc:creator>大战风车的男人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuopy/p/7764431.html</dc:identifier>
</item>
<item>
<title>js原生API妙用（一） - leung_blog</title>
<link>http://www.cnblogs.com/leungUwah/p/7758415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leungUwah/p/7758415.html</guid>
<description>&lt;h3&gt;复制数组&lt;/h3&gt;
&lt;p&gt;我们都知道数组是引用类型数据。这里使用slice复制一个数组，原数组不受影响。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; let list1 = [1, 2, 3, 4&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; let newList =&lt;span&gt; list1.slice();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; list1.push(5); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [1,2,3,4,5]&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;newList [1,2,3,4] 不受影响&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; console.log(newList); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1,2,3,4]&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; console.log(list1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1, 2, 3, 4, 5]&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; let list2 = [5,6,7,8&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; let newList2 =&lt;span&gt; list2.concat();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; newList2.push(9); &lt;span&gt;//&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; console.log(newList2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[5, 6, 7, 8, 9]&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; console.log(list2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1, 2, 3, 4, 5]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;函数参数转数组&quot;&gt;函数参数转数组&lt;/h3&gt;
&lt;p&gt;将函数参数转数组，利用arguments伪数组形式，再用slice拷贝为新数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; argsParam() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;arguments伪数组形式，再用slice拷贝为新数组&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Array.prototype.slice.call(arguments);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; console.log(argsParam(1,2,3,4)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1, 2, 3, 4]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;重复n个字符a&quot;&gt;重复n个字符&lt;/h3&gt;
&lt;p&gt;利用Array构造函数传参，再使用join函数分隔指定的字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @params
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    num: 重复次数
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    str: 重复字符串
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; repeatStr(num, str) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Array(num+1&lt;span&gt;).join(str);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; console.log(repeatStr(5, 's'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sssss&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;创建-n-x-n-二维矩阵并初始化数据&quot;&gt;创建 N x N 二维矩阵，并初始化数据&lt;/h3&gt;
&lt;p&gt;使用Array对象传入数组length参数，调用fill再用map循环fill替换对应的值返回一个新数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @params
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    num: 矩阵次数
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    str: 矩阵数组中的值，由于fill函数替换所以值都是一致的
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; arrayMatrix(num, matrixStr) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; Array(num).fill(&lt;span&gt;null&lt;/span&gt;).map(() =&amp;gt;&lt;span&gt; Array(num).fill(matrixStr));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]  [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;] [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;] [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; console.log(arrayMatrix(4, 'a'));
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;类数组nodelist转数组array&quot;&gt;类数组（NodeList）转数组（Array）&lt;/h3&gt;
&lt;p&gt;其实，前面几个例子也有。如slice，这里加多数组的from方法,ES6语法糖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回的不是真正的Array（你无法使用filter、map、reduce等方法）&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; const nodeList = document.querySelectorAll('div'&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法1: 使用Array.from&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; const arrayList1 =&lt;span&gt; Array.from(nodeList);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法2: 使用slice&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; const arrayList2 =&lt;span&gt; Array.prototype.slice.call(nodeList);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法3: 使用ES6语法糖&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; const arrayList3 = [...nodeList];
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;数组内记录重复次数&quot;&gt;数组内记录重复次数&lt;/h3&gt;
&lt;p&gt;使用reduce函数，reduce函数接收4个参数：1.累计变量：默认数组的第一个值；2.当前变量：默认数组的第二个值；3.当前位置：重0开始；4.原数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; const arrs = [1, 1, 1, 2, 2, 3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到{1: 3, 2: 2, 3: 1}&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; arrs.reduce((obj, item) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;obj[item]) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         obj[item] = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     obj[item]++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }, {}); 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;数组去重-利用es6中的set&quot;&gt;数组去重&lt;/h3&gt;
&lt;p&gt;数组去重有很多种方式如传统的for循环等，这里例子使用最新的ES6 set不重复方式，并使用set的has、add等 API操作；注意set返回的也是一个不重复的类数组形式要使用Array.from方法转成数组形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @params
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    arr: 需要去重的数组
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; uniqueArray(arr) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     const setArr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; arr.filter(val =&amp;gt; !setArr.has(val) &amp;amp;&amp;amp;&lt;span&gt; setArr.add(val));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; console.log(uniqueArray([1,1,2,1,1,2,3,4,5,3,2,4]));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1, 2, 3, 4, 5]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考：http://hectorguo.com/zh/magic-js/&lt;/p&gt;


&lt;h3&gt; &lt;/h3&gt;
</description>
<pubDate>Tue, 31 Oct 2017 15:25:00 +0000</pubDate>
<dc:creator>leung_blog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leungUwah/p/7758415.html</dc:identifier>
</item>
<item>
<title>fastDFS文件服务器迁移 - 无涯Ⅱ</title>
<link>http://www.cnblogs.com/wlandwl/p/fastdfsmove.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wlandwl/p/fastdfsmove.html</guid>
<description>&lt;p&gt;    在实际的项目应用中，由于服务器替换或项目变更难免会存在fastDFS文件服务器迁移的工作。本文重点介绍fastDFS文件系统在不同情况下的文件迁移处理方案。&lt;/p&gt;
&lt;h3&gt;1.迁移时IP地址不变&lt;/h3&gt;
&lt;p&gt;    通过文件服务器存储规则定义，发现当ip地址没有发生变化时，这种文件服务器迁移是最简单的，只需要在新的服务器上安装fastDFS,把原来服务器上的tracker和storage下面的所有目录文件拷贝到新服务器，把所有的配置文件拷贝到新服务器，启动tracker和storage服务即可。&lt;/p&gt;
&lt;h3&gt;2.迁移时IP地址变化采用自定义server ID模式安装&lt;/h3&gt;
&lt;p&gt;    在fastDFS文件服务器安装时，若前期考虑了文件迁移的需求采用了自定义server ID特性安装文件服务器（fastDFS安装请参考上一篇博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/wlandwl/p/fastdfs.html&quot;&gt;FastDFS与Nginx的配置说明&lt;/a&gt;），在做新文件迁移时仅需如下操作(这种迁移测试很简单，变化ip时既可测试)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装新的fastDFS文件服务器；&lt;/li&gt;
&lt;li&gt;关闭tracker服务和storage服务；&lt;/li&gt;
&lt;li&gt;拷贝原有文件服务器tracker和storage下面的所有目录文件；&lt;/li&gt;
&lt;li&gt;拷贝原有文件服务器的配置文件，如图：&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201710/626790-20171031225215998-1108354503.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;编辑stroage_ids.conf文件，修改新的ip地址，如下图：&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201710/626790-20171031225338357-1261203257.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;修改client.conf,storage.conf,mod_fastdfs.conf（若配置了 Servier ID模式，可以不修改）文件中的ip地址为新的ip地址。&lt;/li&gt;
&lt;li&gt;启动tracker服务和storage服务；&lt;/li&gt;
&lt;li&gt;利用ngigx测试下载以前服务器中存成的文件，下载原文件成功表示迁移成功。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3.迁移时IP地址变化采用默认配置安装&lt;/h3&gt;
&lt;p&gt;     在这种模式下，文件迁移本质就是替换ip地址，找到文件服务器中配置文件与ip地址相关的文件替换后就可以了。但不建议采用这种模式安装，且一旦使用这样的模式安装后，需要切换为自定义 Server ID时，会报ip已经重复的异常，导致切换自定义安装失败（除非删除以前的存储文件）。为了迁移以前的文件数据，需进行如下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新服务器停止tracker和storage，分别将其数据文件目录用旧服务器的文件替换掉。&lt;/li&gt;
&lt;li&gt;删除新服务器data数据，使用旧服务器data替换&lt;/li&gt;
&lt;li&gt; 修改tracker的data文件，主要是修改以下文件中的ip信息。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;data/storage_groups_new.dat&lt;/li&gt;
&lt;li&gt;data/storage_servers_new.dat&lt;/li&gt;
&lt;li&gt;data/storage_sync_timestamp.dat&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;修改storage的data文件，主要是修改以下文件中的ip信息 。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;data/.data_init_flag&lt;/li&gt;
&lt;li&gt;data/sync/${ip_addr}_${port}.mark：此类文件，需要将文件名中的IP地址调整过来。若sync目录下面没有文件，可不修改。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;修改client.conf,storage.conf,mod_fastdfs.conf文件中的ip地址为新的ip地址。&lt;/li&gt;
&lt;li&gt;利用ngigx测试下载以前服务器中存成的文件，下载原文件成功表示迁移成功。&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201710/626790-20171031230346013-158256172.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.FastDFS服务器端运行时目录结构&lt;/h3&gt;
&lt;p&gt;  ${base_path}&lt;br/&gt;    |__data：存放数据文件&lt;br/&gt;    |__logs：存放日志文件&lt;br/&gt;  其中，${base_path}由配置文件中的参数“base_path”设定。&lt;/p&gt;
&lt;h4&gt;4.1 .tracker server&lt;/h4&gt;
&lt;p&gt;tracker server目录及文件结构：&lt;br/&gt;  ${base_path}&lt;br/&gt;    |__data&lt;br/&gt;    |     |__storage_groups.dat：存储分组信息&lt;br/&gt;    |     |__storage_servers.dat：存储服务器列表&lt;br/&gt;    |__logs&lt;br/&gt;          |__trackerd.log：tracker server日志文件&lt;br/&gt;数据文件storage_groups.dat和storage_servers.dat中的记录之间以换行符（\n）分隔，字段之间以西文逗号（,）分隔。&lt;br/&gt;&lt;strong&gt;storage_groups.dat中的字段依次为：&lt;/strong&gt;&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. group_name：组名&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. storage_port：storage server端口号&lt;br/&gt;&lt;strong&gt;storage_servers.dat中记录storage server相关信息，字段依次为：&lt;/strong&gt;&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. group_name：所属组名&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. ip_addr：ip地址&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. status：状态&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. sync_src_ip_addr：向该storage server同步已有数据文件的源服务器&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #.&lt;/em&gt; sync_until_timestamp：同步已有数据文件的截至时间（UNIX时间戳）&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.total_upload_count：上传文件次数&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.success_upload_count：成功上传文件次数&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.total_set_meta_count：更改meta data次数&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.success_set_meta_count：成功更改meta data次数&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.total_delete_count：删除文件次数&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.success_delete_count：成功删除文件次数&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.total_download_count：下载文件次数&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.success_download_count：成功下载文件次数&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.total_get_meta_count：获取meta data次数&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.success_get_meta_count：成功获取meta data次数&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.last_source_update：最近一次源头更新时间（更新操作来自客户端）&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;  #&lt;/em&gt;. stat.last_sync_update：最近一次同步更新时间（更新操作来自其他storage server的同步）&lt;/p&gt;
&lt;h4&gt;4.2 .storage serverstorage server目录及文件结构：&lt;/h4&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;  ${base_path}&lt;br/&gt;    |__data&lt;br/&gt;    |     |__.data_init_flag：当前storage server初始化信息&lt;br/&gt;    |     |__storage_stat.dat：当前storage server统计信息&lt;br/&gt;    |     |__sync：存放数据同步相关文件&lt;br/&gt;    |     |     |__binlog.index：当前的binlog（更新操作日志）文件索引号&lt;br/&gt;    |     |     |__binlog.###：存放更新操作记录（日志）&lt;br/&gt;    |     |     |__${ip_addr}_${port}.mark：存放向目标服务器同步的完成情况&lt;br/&gt;    |     |&lt;br/&gt;    |     |__一级目录：256个存放数据文件的目录，目录名为十六进制字符，如：00, 1F&lt;br/&gt;    |           |__二级目录：256个存放数据文件的目录，目录名为十六进制字符，如：0A, CF&lt;br/&gt;    |__logs&lt;br/&gt;          |__storaged.log：storage server日志文件&lt;br/&gt;&lt;strong&gt;.data_init_flag文件格式为ini配置文件方式，各个参数如下：&lt;/strong&gt;&lt;br/&gt;  # storage_join_time：本storage server创建时间&lt;br/&gt;  # sync_old_done：本storage server是否已完成同步的标志（源服务器向本服务器同步已有数据）&lt;br/&gt;  # sync_src_server：向本服务器同步已有数据的源服务器IP地址，没有则为空&lt;br/&gt;  # sync_until_timestamp：同步已有数据文件截至时间（UNIX时间戳）&lt;br/&gt;&lt;strong&gt;storage_stat.dat文件格式为ini配置文件方式，各个参数如下：&lt;/strong&gt;&lt;br/&gt;  # total_upload_count：上传文件次数&lt;br/&gt;  # success_upload_count：成功上传文件次数&lt;br/&gt;  # total_set_meta_count：更改meta data次数&lt;br/&gt;  # success_set_meta_count：成功更改meta data次数&lt;br/&gt;  # total_delete_count：删除文件次数&lt;br/&gt;  # success_delete_count：成功删除文件次数&lt;br/&gt;  # total_download_count：下载文件次数&lt;br/&gt;  # success_download_count：成功下载文件次数&lt;br/&gt;  # total_get_meta_count：获取meta data次数&lt;br/&gt;  # success_get_meta_count：成功获取meta data次数&lt;br/&gt;  # last_source_update：最近一次源头更新时间（更新操作来自客户端）&lt;br/&gt;  # last_sync_update：最近一次同步更新时间（更新操作来自其他storage server）&lt;br/&gt;binlog.index中只有一个数据项：当前binlog的文件索引号&lt;br/&gt;&lt;strong&gt;binlog.###&lt;/strong&gt;，###为索引号对应的3位十进制字符，不足三位，前面补0。索引号基于0，最大为999。一个binlog文件最大为1GB。记录之间以换行符（\n）分隔，字段之间以西文空格分隔。字段依次为：&lt;br/&gt;  1. timestamp：更新发生时间（Unix时间戳）&lt;br/&gt;  2. op_type：操作类型，一个字符&lt;br/&gt;  3. filename：操作（更新）的文件名，包括相对路径，如：5A/3D/VKQ-CkpWmo0AAAAAAKqTJj0eiic6891.a&lt;br/&gt;&lt;strong&gt;${ip_addr}_${port}.mark：&lt;/strong&gt;ip_addr为同步的目标服务器IP地址，port为本组storage server端口。例如：10.0.0.1_23000.mark。文件格式为ini配置文件方式，各个参数如下：&lt;br/&gt;  # binlog_index：已处理（同步）到的binlog索引号&lt;br/&gt;  # binlog_offset：已处理（同步）到的binlog文件偏移量（字节数）&lt;br/&gt;  # need_sync_old：同步已有数据文件标记，0表示没有数据文件需要同步&lt;br/&gt;  # sync_old_done：同步已有数据文件是否完成标记，0表示未完成，1表示已完成&lt;br/&gt;  # until_timestamp：同步已有数据截至时间点（UNIX时间戳）&lt;br/&gt;  # scan_row_count：已扫描的binlog记录数&lt;br/&gt;  # sync_row_count：已同步的binlog记录数&lt;br/&gt; 数据文件名由系统自动生成，包括5部分：存储服务器IP地址、当前时间（Unix时间戳）、文件大小（字节数）、随机数和文件后缀。文件名长度为33字 节。文件可以按目录顺序存放，也可以按照PJW Hash算法hash到65536（256*256）个目录中分散存储，通过配置文件控制。&lt;/em&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 31 Oct 2017 15:16:00 +0000</pubDate>
<dc:creator>无涯Ⅱ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wlandwl/p/fastdfsmove.html</dc:identifier>
</item>
<item>
<title>Appium python自动化测试系列之页面滑动原理讲解（十） - Mushishi_xu</title>
<link>http://www.cnblogs.com/Mushishi_xu/p/7764381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mushishi_xu/p/7764381.html</guid>
<description>&lt;h4&gt;10.1.1 页面滑动原理分析&lt;/h4&gt;
&lt;p&gt;　　在页面滑动查找章节我们就讲了滑动的知识点，只是不知道大家是否有认真练习以及去理解，如果你认真练习、理解了那么我相信这一章节的东西不用看也能够完成，下面我们还是简单分析一下。&lt;/p&gt;
&lt;p&gt;　　所谓的页面滑动在我们实际操作手机的过程中就是不断的从屏幕的下面滑到上面，或者右边滑到左边，反之亦然。其实在做自动化滑动的时候我们遵循的也是这个道理，我们只需要按着一个点然后在屏幕上拖动到另外一个点就行，这就实现了一个简单的滑动。还不懂？回去看第六章的滑动定位吧。&lt;/p&gt;
&lt;h3&gt;10.2 常见页面滑动方式实战&lt;/h3&gt;
&lt;h4&gt;10.2.1 滑动实战&lt;/h4&gt;
&lt;p&gt;　　前面没动也没问题，我们这里从基础的讲一下。首先我们应该很高心appium将滑动的操作封装成了一个函数swipe函数，我们看官方api：&lt;/p&gt;
&lt;p&gt;swipe(self, start_x, start_y, end_x, end_y, duration=None) ，这句话我相信大家能够看懂，如果看不是很理解，没事，我们看官方给出的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
Swipe from one point to another point, for an optional duration.
    从A点滑动至B点，滑动时间为毫秒
    :Args:
     - start_x - x-coordinate at which to start
     - start_y - y-coordinate at which to start
     - end_x - x-coordinate at which to stop
     - end_y - y-coordinate at which to stop
     - duration - (optional) time to take the swipe, in ms.
      
    :Usage:
        driver.swipe(100, 100, 100, 400)
用法 driver.swipe(x1,y1,x2,y2,500)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从官方的例子中我相信大家能够明白了吧。说得通俗易懂就是，我们整个屏幕是一个坐标系，x轴加上y轴的各一个标志就形成了一个坐标点，那么你要滑动屏幕，你总得告诉appium从哪个点（start_x，start_y）到哪个点（end_x，end_y），那么剩下的是不是就是要告诉appium你整个滑动操作要持续的时间呢（毫秒计算）？到这里是不是so easy！&lt;/p&gt;
&lt;h3&gt;10.3 滑动函数的封装实战&lt;/h3&gt;
&lt;h4&gt;10.3.1 如何设计滑动封装&lt;/h4&gt;
&lt;p&gt;　　看到这里可能有人说我啰嗦，当然你有一定基础，然后有这个思想了那么你可以跳过，其实我每次看书的时候无论该知识点我是否掌握，我都会看一遍，毕竟每个人的思考不一样，说不定会有一些不一样的收获，事实也是如此。&lt;/p&gt;
&lt;p&gt;　　整个app操作中的滑动无非就是上下左右的滑动，那么变化的也就是x，y的值不一样，水平滑动就是x轴变化，y轴不变化，垂直滑动就是y轴变化，x轴不变化，那么我们回头来看一下我们第六章的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def getSize(self):
    x = self.driver.get_window_size()['width']
    y = self.driver.get_window_size()['height']
    return (x,y)
      
      
  #向左滑动
  def swipeLeft(self,t):
    l=self.getSize()
    x1=int(l[0]*0.9)
    y1=int(l[1]*0.5)
    x2=int(l[0]*0.1)
    self.driver.swipe(x1,y1,x2,y1,t)
              
  #向右滑动
  def swipeRight(self,t):
    l=self.getSize()
    x1=int(l[0]*0.25)
    y1=int(l[1]*0.5)
    x2=int(l[0]*0.75)
    self.driver.swipe(x1,y1,x2,y1,t)
              
  #向上滑动
  def swipeUp(self,t):
    l=self.getSize()
    x1=int(l[0]*0.5)
    y1=int(l[1]*0.8)
    y2=int(l[1]*0.4)
    self.driver.swipe(x1,y1,x1,y2,t)
    time.sleep(5)
      
  #向下滑动
  def swipeDown(self,t):
    l=self.getSize()
    x1=int(l[0]*0.5)
    y1=int(l[1]*0.25)
    y2=int(l[1]*0.75)
    self.driver.swipe(x1,y1,x1,y2,t)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再次回来看的时候收获不太一样呢？看到这里你是不是该思考一个问题了呢？这个滑动能够实现我一些app里面的验证码功能吗？&lt;/p&gt;
&lt;p&gt;这个知识点我在这里面就不仔细讲了，能否实现下来去实践一下，即使不行那么最后的解决方案也是类似的。哈哈，答案又说漏了。实践去，不然你真的只会纸上谈兵了。&lt;/p&gt;
&lt;h3&gt;10.4 解锁九宫格&lt;/h3&gt;
&lt;h4&gt;10.4.1 解锁思想&lt;/h4&gt;
&lt;p&gt;在这个课程之前讲一个题外话，其实自动化的目的是为了提高工作效率，不是为了显示咱会写代码，所以能减少工作的时候就减少，好比这个解锁九宫格如果在你工作中遇见app中有，那么不去设置就好。哈哈，题外话。&lt;/p&gt;
&lt;p&gt;首先讲解锁这个之前需要了解一个问题，我们这个解锁解的是app里面的密码锁，不是你设置手机的密码，切记切记。手机的密码暂时appium还不提供方法去解决，so，等待你去努力。&lt;/p&gt;
&lt;p&gt;首先我们看一下下面一张图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/bookeditor/interface/imageview?book_id=ee049f357275a417866fb84ae45c3b3567ecdd1b&amp;amp;file=88adc462c1ffb4e1e8d171d7c0ac77ad.png&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;903&quot;/&gt;你看到图片中的定位你能找到方法去操作吗？我们的9个点就在一个view里面，他们是一个整体，分不开。怎么去实现？思考一下。&lt;/p&gt;
&lt;h4&gt;10.4.2 九宫格解锁语法&lt;/h4&gt;
&lt;p&gt;不知道看见上面的那幅图的思考结果是什么，首先我们来看一下我们经常用到的解锁方式以及语法。&lt;/p&gt;
&lt;p&gt;首先我们第一个需要了解的是TouchAction。其实TouchAction的原理是将一系列的动作放在一个链条中，好比我们解锁九宫格的时候一样，我们是在这个链条中执行了很多不操作，然后将这个链条传递给服务器，然后服务器再去挨个解析这一些动作，最后挨个执行。&lt;/p&gt;
&lt;p&gt;知道了TouchAction之后那么我们在解锁之前是不是需要做第一个动作呢？就是去点（用到press），只有点了开始点之后我们再将我们的动作移动到下一个点(move_to)，然后依次类推，当我们将所有的点都执行完毕之后就需要松开我们的点(release)，然后进行提交(perform)，这是不是就是一个完整的解锁流程呢？那我们如何将上面的流程转换成代码呢？看下面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
TouchAction(self.driver).press().move_to().move_to().release().perfrom()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是我们整个流程的代码，但是如果你这样去执行肯定回报错，为什么呢？因为我都不知道你要点啥，从哪里移动到哪里，能不报错么？&lt;/p&gt;
&lt;p&gt;首先press()时需要指定一个对象，对吧。那么这里看press()的语法：&lt;/p&gt;
&lt;p&gt;press(WebElement e):这里你需要传入一个WebElement元素，但是像我们上面的图片无法获取到WebElement元素怎么办，那么我们就需要通过下面这种坐标的方式来进行。&lt;/p&gt;
&lt;p&gt;press(int x,int y):这里你需要传入需要点击元素的坐标位置。&lt;/p&gt;
&lt;p&gt;move_to(WebElement e):同样的传入一个WebElement元素，当无法获取WebElement元素时，同样用坐标去操作&lt;/p&gt;
&lt;p&gt;move_to(int x,int y).&lt;/p&gt;
&lt;p&gt;那么最后我们上面的解锁代码就成了下面这个样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
TouchAction(self.driver).press(x=228,y=647).move_to(x=228,y=647).wait(100).move_to(x=812,y=647).wait(100).move_to(x=812,y=940).wait(100).mov
e_to(x=812,y=1241).release().perform()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;​10.4.3 九宫格解锁实战&lt;/h4&gt;
&lt;p&gt;通过上面的学习我相信大家一定觉得能够完全搞定上面的问题了，但是去动手了的人都知道结果了，上面执行后肯定回报错，知道为什么吗？往上照了资料但是一样却实际要报错，为什么呢？首先来看我的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from appium.webdriver.common.touch_action import TouchAction
TouchAction(self.driver).press(x=217,y=600).move_to(x=0,y=150).wait(1000).move_to(x=0,y=150).wait(1000).move_to(x=113,y=0).move_to(x=113,y=0).release().perform()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;是不是发现有不一样的地方呢？这里一定要记住的是move_to()函数里面的坐标位置是在上一个目标位置的基础上进行坐标位置的变化。初始坐标位置为：press(x=217,y=600),第一个move_to(x=0 ,y=150)，表示在（x=217，y=600）这个位置上向下移动150分辨率，也就是连接第二个点。而第二个move_to(x=0,y=150)，意思也差不多，因为，这个时候我还没有release（）也就是没有松开手，所以第三个点还是以（x=217，y=900）为起点，依次类推那么最后的结果就是我们上面的代码。哈哈，是不是顿时有被网上一些资料忽悠呢？但是你也不要觉得很厉害，你思考过一个问题没？每个手机的分辨率不一样，那么这样的操作在测试兼容性的时候是不是就有问题了呢？那思考一下该怎么解决吧。&lt;/p&gt;
&lt;p&gt;备注：可能看到这里的小伙伴会疑惑，为什么不用开始讲的定位直接使用element来进行定位操作呢？因为我们选择操作的对象是qq，在qq中整个九宫格页面他是一个view，他没有将每一个空格都拆分成一个element，所以那种方法不行，但是相对而言那会简单，只需要将我们的坐标更换成element的元素信息即可。提醒一下，最好是开始定位整个九宫格view，这个时候是一个数组，那么每一个元素只需通过index去访问就好，那样操作最快，下去动手操作一下吧。&lt;/p&gt;

</description>
<pubDate>Tue, 31 Oct 2017 15:14:00 +0000</pubDate>
<dc:creator>Mushishi_xu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mushishi_xu/p/7764381.html</dc:identifier>
</item>
<item>
<title>SQL基本查询_单表查询（实验二） - yjl博客</title>
<link>http://www.cnblogs.com/yjlblog/p/7764355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjlblog/p/7764355.html</guid>
<description>&lt;p&gt;查询部门编号为02的雇员信息，显示其编号、姓名、薪水，并按姓名降序排序显示。&lt;/p&gt;
&lt;h3 id=&quot;sql-查询命令&quot;&gt;SQl 查询命令&lt;/h3&gt;
&lt;p&gt;1、 使用 * 查询所有员工的信息；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from emp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、 查询员工的编号、姓名、工资信息，显示列标题为雇员编号、姓名、雇员工资；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select empno 雇员编号,ename 姓名,sal 雇员工资 from emp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、 查询单位共设置了那些岗位？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select distinct job from emp;//distinct 是把重复的去掉&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、查询所有员工的信息，显示其编号、姓名、日薪水；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select empno 编号,ename 姓名，sal/30 日薪水  from emp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、使用联合查询，分别查询雇员姓名和部门名称，并使用一列显示；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select ename from emp
union
select job from emp;//union 是联合查询一般用在两个表的中间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、查询马姓雇员信息,显示其编号、姓名、薪水；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select empno 编号,ename 姓名，sal 薪水 from emp where ename like '马%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、查询姓名中包含“小”字的雇员信息,显示其编号、姓名、薪水；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select empno 编号,ename 姓名，sal 薪水 from emp where ename like '%小%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、查询日薪在这200-300的雇员信息，显示其编号、姓名、日薪；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select empno 编号,ename 姓名，sal/30 日薪水  from emp
where sal/30 &amp;gt; 200 and sal/30 &amp;lt; 300//注意此处的写法，不要忘记and&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;9、查询没有分配单位的雇员信息，显示其编号、姓名、薪水；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select empno 编号,ename 姓名，sal 薪水 
from emp 
where deptno is null //此处的null一定要要注意，前面是is&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;10、查询部门编号为02的雇员信息，显示其编号、姓名、薪水，并按姓名降序排序显示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select empno 编号,ename 姓名，sal 薪水 
from emp 
where deptno= '02'
order by ename desc
//降序排列的话要用到 order by 降序是用desc  升序的话是用 ASC
//注意：若省略ASC和DESC，则默认为ASC，即升序排序&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好弱啊，好多命令还没有记清楚，而且伤心的是，课本竟然落在机房里，然后、、、、、找了很长一段的时间，找了很多地方，终于还是在机房里找到了。还有一个问题是自己的本子上按住了PLSQL 也完破解激活了，但是没有配置好。。。emnnnn.这真的很伤 --!&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 15:06:00 +0000</pubDate>
<dc:creator>yjl博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjlblog/p/7764355.html</dc:identifier>
</item>
</channel>
</rss>