<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>webpack4.0各个击破（10）—— Integration篇 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9572754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9572754.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;作为前端最火的构建工具，是前端自动化工具链&lt;strong&gt;最重要的部分&lt;/strong&gt;，使用门槛较高。本系列是笔者自己的学习记录，比较基础，希望通过&lt;strong&gt;问题 + 解决方式&lt;/strong&gt;的模式，以前端构建中遇到的具体需求为出发点，学习&lt;code&gt;webpack&lt;/code&gt;工具中相应的处理办法。（本篇中的参数配置及使用方式均基于&lt;code&gt;webpack4.0版本&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/31/820cb1497b62aa9abd23aab35315f010.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/31/6cecca7277e994f361afe096b3c860fc.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-integration&quot;&gt;一. Integration&lt;/h2&gt;
&lt;p&gt;下文摘自&lt;code&gt;webpack&lt;/code&gt;中文网：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;首先我们要消除一个常见的误解，&lt;code&gt;webpack&lt;/code&gt;是一个模块打包工具(module bundler)，它不是一个任务执行工具，任务执行器是用来自动化处理开发中常见任务的，例如检查(lint)，构建(build)，测试(test)等。相对于打包器，任务执行器所面对的逻辑问题更为上层，你可以使用上层的工具来管理整个持续集成（CI），而把打包的部分交给&lt;code&gt;webpack&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;在工具链中的角色定位是非常清晰的，那么为了与其他流程进行合作，就需要使用任务管理工具来启动&lt;code&gt;webpack&lt;/code&gt;，本文介绍两种常见的方法。&lt;/p&gt;
&lt;h3 id=&quot;使用node-api&quot;&gt;1. 使用Node-API&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;webpak&lt;/code&gt;暴露了一些方法，使得开发者可以通过调用他们而在脚本中启动&lt;code&gt;webpack&lt;/code&gt;，使用的方法较为简单:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//webpack-node.js
const webpack = require('webpack');
const webpackConfig = require('./webpack.config.html.js');
const cowsay = require('cowsay');

const compiler = webpack(webpackConfig);

compiler.run((err, stats)=&amp;gt;{
   if (!err) {
        console.log(stats.toJson().assets);
        console.log(cowsay.say({text:'Congratulations!'}));
   }

});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/31/ee68d8a6d79d2cdd6b8c0b02fcd18c4c.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里解释一下上面代码的基本逻辑，引入了&lt;code&gt;webpack&lt;/code&gt;模块以及&lt;code&gt;webpack.config.html.js&lt;/code&gt;的配置文件(从这里就很容易理解为什么&lt;code&gt;webpack&lt;/code&gt;的配置文件可以导出为一个函数或多个配置，它实际上也是作为一个模块参与到整个运行过程的)，通过调用&lt;code&gt;webpack([Object config])&lt;/code&gt;方法得到一个&lt;code&gt;compiler&lt;/code&gt;实例，调用&lt;code&gt;compiler.run&lt;/code&gt;方法就启动了&lt;code&gt;webpack&lt;/code&gt;的构建功能，run方法的回调函数中如果有运行错误，可以通过&lt;code&gt;err&lt;/code&gt;来获取，与构建过程有关的信息都挂载在&lt;code&gt;stats&lt;/code&gt;对象（例如&lt;code&gt;stats。toJson().assets&lt;/code&gt;)。这样便实现了以非命令行的方式启动&lt;code&gt;webpack&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;使用gulp&quot;&gt;2.使用gulp&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;gulp&lt;/code&gt;是基于流的任务管理工具，实际上&lt;code&gt;webpack&lt;/code&gt;的细分功能使用&lt;code&gt;gulp&lt;/code&gt;也可以做到，而且很多功能型插件都会提供针对&lt;code&gt;grunt&lt;/code&gt;,&lt;code&gt;gulp&lt;/code&gt;和&lt;code&gt;webpack&lt;/code&gt;等不同工具的集成方式。&lt;code&gt;gulp&lt;/code&gt;的确更适合做宏观意义上的任务流管理，还是那句老话，工具是提供便利的，而不是提供束缚的。官方文档也提供了如下代码示例：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//gulpfile.js
var gulp = require('gulp');
var webpack = require('webpack-stream');
gulp.task('default',function(){
    return gulp.src('src/entry.js')
        .pipe(webpack({
        //...configs
    })).pipe(gulp.dest('dist/'));
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二.-after-webpack&quot;&gt;二. after webpack&lt;/h2&gt;
&lt;p&gt;至此，&lt;code&gt;webpack&lt;/code&gt;已经被集成进了自动化工具链，开发者可以按自己的需求来定制构建以后需要执行的任务，但&lt;code&gt;webpack&lt;/code&gt;的使命还没有结束，构建的结束距离用户能够访问站点和使用功能还需要非常多的工作要做，有很多问题并不是在构建中出现的，但是却需要在构建时加以处理，这个时候开发者又需要回过头来为&lt;code&gt;webpack&lt;/code&gt;增加配置。&lt;/p&gt;
&lt;p&gt;例如很多开发者最初不理解构建过程中为什么要使用&lt;code&gt;hash&lt;/code&gt;,&lt;code&gt;chunkhash&lt;/code&gt;等占位符来把文件名变得丑陋无比，直到不同版本的产品上线时出现不强制刷新页面就无法访问新资源的问题时，才会开始关注版本更新和缓存策略的问题，然后才会理解为了标记版本而启用&lt;code&gt;hash&lt;/code&gt;，为了避免重复构建而使用&lt;code&gt;chunkhash&lt;/code&gt;,为了减小体积而使用&lt;code&gt;tree-shaking&lt;/code&gt;等等。&lt;/p&gt;
&lt;h2 id=&quot;三.-商务吹捧走一波&quot;&gt;三. 商务吹捧走一波&lt;/h2&gt;
&lt;p&gt;《&lt;code&gt;webpack&lt;/code&gt;4.0各个击破》全系列文章就连载结束了，感谢您的关注，希望对你有所帮助，你也可以通过以下方式查看我的其他博文。&lt;/p&gt;
&lt;p&gt;博客园地址:&lt;a href=&quot;https://www.cnblogs.com/dashnowords&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/dashnowords&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Sep 2018 22:31:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>作为前端最火的构建工具，是前端自动化工具链 最重要的部分 ，使用门槛较高。本系列是笔者自己的学习记录，比较基础，希望通过 问题 + 解决方式 的模式，以前端构建中遇到的具体需求为出发点，学习 工具中相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9572754.html</dc:identifier>
</item>
<item>
<title>String常用操作 - J.FengS</title>
<link>http://www.cnblogs.com/fjfsu/p/9582189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fjfsu/p/9582189.html</guid>
<description>&lt;h2&gt;常量池：&lt;/h2&gt;
&lt;p&gt;字符串一旦被初始化就不会被改变&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        String s=&quot;123&quot;&lt;span&gt;;
        s&lt;/span&gt;=&quot;abc&quot;&lt;span&gt;;
        System.out.print(s);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码看上去s的值是被改变了的，实际上123就是一个对象，他存在于常量池中，abc也是一个对象，s的值实际上是指向123或者abc的地址。&lt;/p&gt;
&lt;p&gt;所以当我们使用String s=&quot;123&quot;;来定义字符串的时候，会先查看常量池中是否有123，有就直接赋值123的地址，如果没有就创建123。&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   1     String s=&quot;123&quot;&lt;span&gt;;
   2     String s1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;&lt;span&gt;);
   3     System.out.println(s&lt;/span&gt;==&lt;span&gt;s1);
   4     System.out.print(s.equals(s1));&lt;br/&gt;结果：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　false&lt;/p&gt;
&lt;p&gt;　　　　true&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2中，实际上是创建了两个对象，一个new,一个堆内存中。equals本来和==一样是比较地址值得，但是String类重写了equals方法，比较的是内容。 &lt;/p&gt;
&lt;h2&gt;获取&lt;/h2&gt;
&lt;p&gt;1.1获取字符串中字符的长度（个数）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; length()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.2根据位置获取字符 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; charAt(&lt;span&gt;int&lt;/span&gt; index)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.3根据字符（子串）获取其在字符串中第一次出现的位置　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; indexOf(&lt;span&gt;int&lt;/span&gt; ch)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; indexOf (&lt;span&gt;int&lt;/span&gt; ch,&lt;span&gt;int&lt;/span&gt; fromIndex)从指定位置进行查找
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; indexOf(&lt;span&gt;String&lt;/span&gt; str)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; indexOf (String str,&lt;span&gt;int&lt;/span&gt; fromIndex)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上面的是从前向后找，下面的是从后向前找&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
char lastIndexOf(int ch)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
char lastIndexOf (int ch,int fromIndex)从指定位置进行查找
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
char lastIndexOf(String str)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
char lastIndexOf (String str,int fromIndex)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 1.4获取字符串中的子串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
String substring(&lt;span&gt;int&lt;/span&gt; beginIndex,&lt;span&gt;int&lt;/span&gt; endInedx)包含befin不包含end
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
String substring(int beginIndex)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;转换&lt;/h2&gt;
&lt;p&gt;1.1将字符串变成字符串数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;String[] split(String regex) 这里的切割点有时会涉及到正则表达式，所以要用\将特殊字符转化成普通字符。注意\.也是正则规则中的一部分&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        String s&lt;/span&gt;=&quot;张三.李四.王五&quot;&lt;span&gt;;
        String[] arr&lt;/span&gt;=s.split(&quot;\\.&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;arr.length;i++&lt;span&gt;)
        System.out.println(arr[i]);    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.2将字符串变成字符数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt;[] toCharArray();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.3将字符串变成字节数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;byte&lt;/span&gt;[] getBytes();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.4将字符串中的字母转换大小写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;String toUpperCase();
String toLowerCase();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.5将字符串中的内容进行互换&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;String replace(String oldst,String newst)
String replace(&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; oldch,&lt;span&gt;char&lt;/span&gt; newch)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.6将字符串两端的空格去掉&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
String trim();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.7将字符串进行连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
String concat(String);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;判断&lt;/h2&gt;
&lt;p&gt;1.1比较两个字符串是否相同&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;boolean&lt;/span&gt; equals(anObject)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;boolean&lt;/span&gt; equalsIgnoreCase(anotherString)不区分大小写
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.2判断字符串中是否包含指定字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;boolean&lt;/span&gt; contains(String str)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.3字符串是否以指定字符串开头（结尾）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;boolean&lt;/span&gt; startsWith(String)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;boolean&lt;/span&gt; endsWith(String)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.4比较两个字符串的字典顺序大小&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; compareTo(anotherString);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; compareToIgnoreCase(anotherString)不区分大小写
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; intern&lt;/h2&gt;
&lt;ul class=&quot;blockListLast&quot;&gt;&lt;li class=&quot;blockList&quot; readability=&quot;0.48811544991511&quot;&gt;
&lt;div class=&quot;block&quot; readability=&quot;13.667232597623&quot;&gt;
&lt;p&gt;当调用intern方法时，如果池已经包含与&lt;a&gt;&lt;code&gt;equals(Object)&lt;/code&gt;&lt;/a&gt;方法确定的相当于此&lt;code&gt;String&lt;/code&gt;对象的字符串，则返回来自池的字符串。 否则，此&lt;code&gt;String&lt;/code&gt;对象将添加到池中，并返回对此&lt;code&gt;String&lt;/code&gt;对象的引用。&lt;/p&gt;
&lt;p&gt;（实际上就是看对象的值123在池当中有没有，如果没有那我就在池中创建一个，如果有那我就直接拿来用）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        String s&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;&lt;span&gt;);
        String s1&lt;/span&gt;=&lt;span&gt;s.intern();
        String s2&lt;/span&gt;=&lt;span&gt;s1.intern();
        System.out.println(s&lt;/span&gt;==&lt;span&gt;s1);    
        System.out.println(s1&lt;/span&gt;==&lt;span&gt;s2);    
    }
}
结果
&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;StringBuffer&lt;/h2&gt;
&lt;p&gt;就是字符串缓冲区，用于存储数据的容器&lt;/p&gt;
&lt;p&gt;特点：1长度是可变的&lt;/p&gt;
&lt;p&gt;           2可以存储不同数据类型&lt;/p&gt;
&lt;p&gt;　　　3最终要转成字符串进行使用&lt;/p&gt;
&lt;p&gt;　　　4可对字符串进行修改&lt;/p&gt;

&lt;p&gt;既然是个容器那么它具备什么功能呢？&lt;/p&gt;
&lt;p&gt;1添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;StringBuffer append(data)在结尾进行添加
StringBuffer insert(index,data)在指定位置插入&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        StringBuffer s&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
        s.append(&lt;/span&gt;&quot;1&quot;).append(&quot;2&quot;).append(&quot;b&quot;&lt;span&gt;);
        s.insert(&lt;/span&gt;1, &quot;a&quot;&lt;span&gt;);
        System.out.println(s);        
    }
}&lt;br/&gt;结果:1a2b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2删除&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;StringBuffer delete(start,end);包含头不包含为尾
StringBuffer deleteCharAt(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index);删除指定位置的元素
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3查找&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; charAt(index)返回指定位置字符
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; indexOf(str);返回子串第一次出现的位置
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; kastIndexOf(str)从字符串末尾开始查询
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
StringBuffer replace(start, end, str);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; setCharAt(index, ch);只修改一个字符。注意它没有返回值类型
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
StringBuffer reverse();将字符串头尾进行对调
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; new StringBuffer()初始化的默认长度为16 &lt;/p&gt;
&lt;p&gt; new StringBuffer(index)可以指定其初始化的长度（如果可以确定数据的大小，最好使用这个，可以避免开辟空间和进行运算）&lt;/p&gt;
&lt;h2 class=&quot;title&quot; title=&quot;Class StringBuilder&quot;&gt; StringBuilder&lt;/h2&gt;
&lt;p&gt;jdk1.5以后出现了功能和StringBuffer一模一样的对象，即Stringbuilder&lt;/p&gt;
&lt;p&gt;不同的是：&lt;/p&gt;
&lt;p&gt;Stringbuilder是线程不同步的，通常用于单线程，效率高，因为不用每次都判断锁。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;StringBuffer&lt;/em&gt;线程同步，通常用于多线程，安全。（如果删除和添加同时进行了，那么就会造成安全隐患）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    Object lock;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; StringBuffer append(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(lock){
                
            }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; StringBuffer delete(&lt;span&gt;int&lt;/span&gt; start,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; end){
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(lock){
                
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JDK升级的目的：&lt;/p&gt;
&lt;p&gt;1简化书写&lt;/p&gt;
&lt;p&gt;2提高效率&lt;/p&gt;
&lt;p&gt;3增加安全性&lt;/p&gt;
</description>
<pubDate>Mon, 03 Sep 2018 17:51:00 +0000</pubDate>
<dc:creator>J.FengS</dc:creator>
<og:description>常量池： 字符串一旦被初始化就不会被改变 这段代码看上去s的值是被改变了的，实际上123就是一个对象，他存在于常量池中，abc也是一个对象，s的值实际上是指向123或者abc的地址。 所以当我们使用S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fjfsu/p/9582189.html</dc:identifier>
</item>
<item>
<title>聊聊IOCP，聊聊异步编程 - 坦荡</title>
<link>http://www.cnblogs.com/tdws/p/9582155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tdws/p/9582155.html</guid>
<description>&lt;div readability=&quot;39&quot;&gt;

&lt;p data-source-line=&quot;4&quot;&gt;&lt;span&gt;IO完成端口（IO completion ports）在多核计算机的并行异步IO请求方面提供了一种高效的线程模型。当进程创建一个IO完成端口时，系统创建一个相关联的队列，其唯一目的是服务与那些请求。IO完成端口通常和预先分配的线程池配合，相比于一个一个创建线程，这使其更快更高效。IOCP在进程之间并不共享，一个IOCP及其句柄只和创建它的进程关联，但是一个进程中的多个线程可共享。IOCP最关键的地方就是，IOCP在IO请求和接收动作完成之后，激活线程池中的任意线程继续操作，而不是在IO请求和接受完成之后，激活原等待中的线程。这样的好处是防止等待线程闲置，和必须激活／切换到原等待线程的开销。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;4&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;大多应用存在的问题&quot; data-source-line=&quot;5&quot;&gt;大多应用存在的问题&lt;/h2&gt;
&lt;p data-source-line=&quot;7&quot;&gt;&lt;span&gt;曾见过很多服务，几台，几十台，几百台服务器的，它们cpu大多数时间处于空闲状态，也许需要大量计算的应用并没有那么多，我们常见的应用大多主要读写关系数据库，读写内存数据库／缓存，RPC调用接口。IO耗时过多，CPU大量闲置，导致没看到服务器资源大量消耗，便已不能承受日益增加的访问量，再加服务器，依然大量浪费了资源。 CPU资源昂贵，每一个核心，同一时刻只能有一个线程在运行，超线程cpu同一时刻可以有两个逻辑线程运行，所以说线程不是创建的越多越好，过多的线程只会增加线程切换带来的成本。试想一下，如果应用线程池的线程，都在同步等待IO操作的结束，线程池中也就没有空闲线程继续处理请求，所以线程池会继续创建线程以提供服务。恶性循环，则会带来线程过多的成本，好在线程池不会让这样的事发生。那么到达服务器无法处理更多请求的程度时，http 503便出现了。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;7&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;windows下使用iocp&quot; data-source-line=&quot;10&quot;&gt;windows下使用IOCP&lt;/h2&gt;
&lt;p data-source-line=&quot;11&quot;&gt;&lt;span&gt;异步IO在于线程非阻塞，提高CPU利用率，增加服务器吞吐量，助我们承受更大的并发。在windows下使用IOCP，可以直接使用C#异步编程await／async。虽然C#可以直接操作win32API，但.NET平台已提供好异步IO的操作封装，只需要简单的语法，即可完成异步磁盘IO，异步HTTP请求，异步SOCKET，基于.NET框架现有的条件，也很容易做关系数据库，redis，ElasticSearch，mongodb的异步读写。所以推荐在windows下的IO尽可能使用IOCP。IOCP本质上解决的问题就是CPU和IO速度极大的不对等。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;11&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;基于iocp的异步编程线程行为证明&quot; data-source-line=&quot;13&quot;&gt;基于IOCP的异步编程线程行为证明&lt;/h2&gt;
&lt;p data-source-line=&quot;14&quot;&gt;&lt;span&gt;简单写了个API接口，用于证明在异步IO操作的时候，线程并不阻塞等待IO结束，而是将请求交给驱动后返回线程池，继续工作。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;16&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686162/201809/686162-20180904004350688-1319169321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;16&quot;&gt;&lt;span&gt;图中代码操作是先记录当前请求处理中的线程ID，然后请求一个10s返回的网络接口。用http客户端并发请求图中该接口后，我们稍后给出线程行为的结论。 我们都知道，如果说服务端线程是IO阻塞的，第一次请求，如果记录了线程ID为1，那么在10s内，该线程一直在阻塞等待，所以10s内不会再出现该线程ID被记录到日志中。 事实上结论是：&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;21&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686162/201809/686162-20180904004400840-2106634595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;23&quot;&gt;&lt;span&gt;可以看到在同一秒甚至同一毫秒内，一个线程同时处理了多次http请求。另外可以确定的一个事实是，IO前和IO后，线程可能是不一样的，也可能是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;23&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;23&quot;&gt;&lt;span&gt;&lt;strong&gt;感谢志同道合的你的阅读&lt;/strong&gt;，如果你希望长期学习到 .Net , Java , Kotlin ,Python 等原理知识，互联网实践干货，技术感悟等，&lt;strong&gt;不妨 &lt;/strong&gt;关注博客，或者闲暇时在微信&lt;strong&gt;公众号&lt;/strong&gt;上阅读。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;23&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686162/201809/686162-20180904004902135-1607224268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p data-source-line=&quot;23&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;23&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 03 Sep 2018 16:51:00 +0000</pubDate>
<dc:creator>坦荡</dc:creator>
<og:description>前言 IO完成端口（IO completion ports）在多核计算机的并行异步IO请求方面提供了一种高效的线程模型。当进程创建一个IO完成端口时，系统创建一个相关联的队列，其唯一目的是服务与那些请</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tdws/p/9582155.html</dc:identifier>
</item>
<item>
<title>在JS中统计函数执行次数与执行时间 - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/9582150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/9582150.html</guid>
<description>&lt;p&gt;假如想统计JS中的函数执行次数最多的是哪个，执行时间最长的是哪个，该怎么做呢？&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9582150.html#s0&quot; target=&quot;_parent&quot;&gt;1. 统计函数执行次数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9582150.html#s1&quot; target=&quot;_parent&quot;&gt;2. 统计函数执行时间&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9582150.html#s2&quot; target=&quot;_parent&quot;&gt;3. 如何控制函数的调用次数&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9582150.html#s3&quot; target=&quot;_parent&quot;&gt;4. 如何控制函数的执行时间&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span/&gt;&lt;span&gt;一、统计函数执行次数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;常规的方法可以使用 console.log 输出来肉眼计算有多少个输出&lt;/p&gt;
&lt;p&gt;不过在Chrome中内置了一个 console.count 方法，可以统计一个字符串输出的次数。我们可以利用这个来间接地统计函数的执行次数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; someFunction() {
    console.count(&lt;/span&gt;'some 已经执行'&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; otherFunction() {
    console.count(&lt;/span&gt;'other 已经执行'&lt;span&gt;);
}

someFunction(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; some 已经执行: 1&lt;/span&gt;
someFunction(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; some 已经执行: 2&lt;/span&gt;
otherFunction(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; other 已经执行: 1&lt;/span&gt;
&lt;span&gt;
console.count(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; default: 1&lt;/span&gt;
console.count(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; default: 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不带参数则为 default 值，否则将会输出该字符串的执行次数，观测起来还是挺方便的&lt;/p&gt;

&lt;p&gt;当然，除了输出次数之外，还想获取一个纯粹的次数值，可以用装饰器将函数包装一下，内部使用对象存储调用次数即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getFunCallTimes = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 装饰器，在当前函数执行前先执行另一个函数&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; decoratorBefore(fn, beforeFn) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = beforeFn.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在前一个函数中判断，不需要执行当前函数&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (ret !== &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
                fn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
            }
        };
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行次数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; funTimes =&lt;span&gt; {};
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给fun添加装饰器，fun执行前将进行计数累加&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(fun, funName) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储的key值&lt;/span&gt;
        funName = funName ||&lt;span&gt; fun;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不重复绑定，有则返回&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (funTimes[funName]) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; funTimes[funName];
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绑定&lt;/span&gt;
        funTimes[funName] = decoratorBefore(fun, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计数累加&lt;/span&gt;
            funTimes[funName].callTimes++&lt;span&gt;;

            console.log(&lt;/span&gt;'count'&lt;span&gt;, funTimes[funName].callTimes);
        });
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义函数的值为计数值（初始化）&lt;/span&gt;
        funTimes[funName].callTimes = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; funTimes[funName];
    }
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; someFunction() {
    
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; otherFunction() {
    
}


someFunction &lt;/span&gt;= getFunCallTimes(someFunction, 'someFunction'&lt;span&gt;);

someFunction(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; count 1&lt;/span&gt;
someFunction(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; count 2&lt;/span&gt;
someFunction(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; count 3&lt;/span&gt;
someFunction(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; count 4&lt;/span&gt;
&lt;span&gt;
console.log(someFunction.callTimes); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;span&gt;


otherFunction &lt;/span&gt;=&lt;span&gt; getFunCallTimes(otherFunction);
otherFunction(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; count 1&lt;/span&gt;
console.log(otherFunction.callTimes); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;
otherFunction(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; count 2&lt;/span&gt;
console.log(otherFunction.callTimes); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;二、统计函数执行时间&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Chrome中内置了 console.time 和 console.timeEnd 来打点计算时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.time();

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 100000; ++&lt;span&gt;i) {

}

console.timeEnd(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; default: 1.77197265625ms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不传入参数的话，将以default输出毫秒值&lt;/p&gt;
&lt;p&gt;我们可以封装一下，传入函数名称，类似上面的做法，使用装饰器在函数执行前后进行处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getFunExecTime = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 装饰器，在当前函数执行前先执行另一个函数&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; decoratorBefore(fn, beforeFn) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = beforeFn.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在前一个函数中判断，不需要执行当前函数&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (ret !== &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
                fn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
            }
        };
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 装饰器，在当前函数执行后执行另一个函数&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; decoratorAfter(fn, afterFn) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            fn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
            afterFn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
        };
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行次数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; funTimes =&lt;span&gt; {};
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给fun添加装饰器，fun执行前后计时&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(fun, funName) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decoratorAfter(decoratorBefore(fun, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行前&lt;/span&gt;
&lt;span&gt;            console.time(funName);
        }), &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行后&lt;/span&gt;
&lt;span&gt;            console.timeEnd(funName);
        });
    }
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么调用的时候，就不需要理会如何计时了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; someFunction() {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 100000; ++&lt;span&gt;i) {

    }
}


&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; otherFunction() {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 10000000; ++&lt;span&gt;i) {

    }
}

someFunction &lt;/span&gt;= getFunExecTime(someFunction, 'someFunction'&lt;span&gt;);
someFunction(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; someFunction: 1.616943359375ms&lt;/span&gt;
&lt;span&gt;
otherFunction &lt;/span&gt;= getFunExecTime(otherFunction, 'otherFunction'&lt;span&gt;);
otherFunction(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; otherFunction: 18.157958984375ms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Chrome的Console API毕竟不是标准的，除了使用它之外，还可以选择日期插件 Date 中的 getTime now 相关方法&lt;/p&gt;
&lt;p&gt;然而使用Date对象来计算耗时并不正统，推荐使用标准的 performance.now&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; start =&lt;span&gt; performance.now();

console.time();

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 10000000; ++&lt;span&gt;i) {

}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; end =&lt;span&gt; performance.now();

console.timeEnd(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; default: 23.598876953125ms&lt;/span&gt;
&lt;span&gt;
console.log(end &lt;/span&gt;- start); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 23.600000015459955&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，它们是相差不大的&lt;/p&gt;
&lt;p&gt;使用类似的方法，将它包装起来以便方便调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getFunExecTime = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 装饰器，在当前函数执行前先执行另一个函数&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; decoratorBefore(fn, beforeFn) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = beforeFn.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在前一个函数中判断，不需要执行当前函数&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (ret !== &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
                fn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
            }
        };
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 装饰器，在当前函数执行后执行另一个函数&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; decoratorAfter(fn, afterFn) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            fn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
            afterFn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
        };
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行次数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; funTimes =&lt;span&gt; {};
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给fun添加装饰器，fun执行前后计时&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(fun, funName) {
        funName &lt;/span&gt;= funName ||&lt;span&gt; fun;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (funTimes[funName]) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; funTimes[funName];
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绑定&lt;/span&gt;
        funTimes[funName] = decoratorAfter(decoratorBefore(fun, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行前&lt;/span&gt;
            funTimes[funName].timestampStart =&lt;span&gt; performance.now();
        }), &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行后&lt;/span&gt;
            funTimes[funName].timestampEnd =&lt;span&gt; performance.now();
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将执行耗时存入&lt;/span&gt;
            funTimes[funName].valueOf = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.timestampEnd - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.timestampStart;
            };
        });

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; funTimes[funName];
    }
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; someFunction() {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 100000; ++&lt;span&gt;i) {

    }
}


&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; otherFunction() {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 10000000; ++&lt;span&gt;i) {

    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 包装&lt;/span&gt;
someFunction =&lt;span&gt; getFunExecTime(someFunction);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行&lt;/span&gt;
&lt;span&gt;someFunction();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取耗时，可直接使用函数的 valueOf&lt;/span&gt;
console.log(+someFunction); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.0999999847263098&lt;/span&gt;
&lt;span&gt;
otherFunction &lt;/span&gt;= getFunExecTime(otherFunction, 'otherFunction'&lt;span&gt;);
otherFunction(); 
console.log(&lt;/span&gt;+otherFunction); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 21.00000000745058&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;三、如何控制函数的调用次数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;也可以通过闭包来控制函数的执行次数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; someFunction() {
    console.log(&lt;/span&gt;1&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; otherFunction() {
    console.log(&lt;/span&gt;2&lt;span&gt;);
}


&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setFunCallMaxTimes(fun, times, nextFun) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (times-- &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行函数&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; fun.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (nextFun &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; nextFun === 'function'&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行下一个函数&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; nextFun.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
        }
    };
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fun = setFunCallMaxTimes(someFunction, 3&lt;span&gt;, otherFunction);

fun(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
fun(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
fun(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
fun(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
fun(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;四、如何控制函数的执行时间&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;因为JS是单线程的，控制函数的执行时间相对来说挺麻烦&lt;/p&gt;
&lt;p&gt;通过 async await yield 等异步特性，也许还是能办到的&lt;/p&gt;
&lt;p&gt;在React 16中的 &lt;a href=&quot;http://zxc0328.github.io/2017/09/28/react-16-source/&quot; target=&quot;_blank&quot;&gt;Fiber 机制&lt;/a&gt;，在某种意义上是能控制函数的执行时机，得空再去看看它是怎么实现的吧&lt;/p&gt;
</description>
<pubDate>Mon, 03 Sep 2018 16:45:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<og:description>假如想统计JS中的函数执行次数最多的是哪个，执行时间最长的是哪个，该怎么做呢？ 1. 统计函数执行次数 2. 统计函数执行时间 3. 如何控制函数的调用次数 4. 如何控制函数的执行时间 一、统计函数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/9582150.html</dc:identifier>
</item>
<item>
<title>【深度学习篇】---CNN和RNN结合与对比，实例讲解 - LHBlog</title>
<link>http://www.cnblogs.com/LHWorldBlog/p/9581918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LHWorldBlog/p/9581918.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、前述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CNN和RNN几乎占据着深度学习的半壁江山，所以本文将着重讲解CNN+RNN的各种组合方式，以及CNN和RNN的对比。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、CNN与RNN对比&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、CNN卷积神经网络与RNN递归神经网络直观图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180903224645542-1067912595.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、相同点：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;    2.1. 传统神经网络的扩展。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    2.2. 前向计算产生结果，反向计算模型更新。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    2.3. 每层神经网络横向可以多个神经元共存,纵向可以有多层神经网络连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、不同点&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;    3.1. CNN空间扩展，神经元与特征卷积；RNN时间扩展，神经元与多个时间输出计算&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    3.2. RNN可以用于描述时间上连续状态的输出，有记忆功能，CNN用于静态输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   3. 3. CNN高级100+深度，RNN深度有限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、CNN+RNN组合方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. CNN 特征提取，用于RNN语句生成图片标注。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180903225951565-1601866098.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. RNN特征提取用于CNN内容分类视频分类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180903230039626-1748342640.png&quot; alt=&quot;&quot; width=&quot;945&quot; height=&quot;138&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. CNN特征提取用于对话问答图片问答。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180903230115422-1853322771.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、具体应用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、图片标注&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基本思路&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       目标是产生标注的语句，是一个语句生成的任务，LSTM？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       描述的对象大量图像信息，图像信息表达，CNN？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       CNN网络中全连接层特征描述图片，特征与LSTM输入结合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1 模型设计－特征提取&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;全连接层特征用来描述原图片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LSTM输入：word＋图片特征；输出下一word。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180903231917977-595036855.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2 模型设计－数据准备&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 图片CNN特征提取&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 图片标注生成Word2Vect 向量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 生成训练数据：图片特征＋第n单词向量：第n＋1单词向量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180903232059504-2079228025.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.3 模型训练：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 运用迁移学习，CNN特征，语句特征应用已有模型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 最终的输出模型是LSTM，训练过程的参数设定：梯度上限(gradient clipping), 学习率调整(adaptivelearning)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 训练时间很长。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4 模型运行：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. CNN特征提取&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. CNN 特征＋语句开头，单词逐个预测&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、视频行为识别 ：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;视频中在发 生什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180903233344892-645792819.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1常用方法总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RNN用于CNN特征融合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. CNN 特征提取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. LSTM判断&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 多次识别结果分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不同的特征不同输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180903233449320-1092650414.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者：所有特征作为一个输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180903235513546-1145017325.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 RNN用于CNN特征筛选＋融合：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 并不是所有的视频 图像包含确定分类信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. RNN用于确定哪些frame 是有用的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 对有用的图像特征 融合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 RNN用于，目标检测：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. CNN直接产生目标候选区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. LSTM对产生候选区融合（相邻时刻位置近 似）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 确定最终的精确位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180903233826401-2134523942.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.4 多种模型综合：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;竞赛／应用中，为了产生最好结果，多采用 多模型ensemble形式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180903233903661-1602281200.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3、图片／视频问答&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1 问题种类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201809/1250469-20180904000623041-1391134340.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 图片问答意义&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 是对纯文本语言问答系统的扩展&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 图片理解和语言处理的深度融合&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 提高人工智能应用范围－观察，思考，表达&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Sep 2018 16:16:00 +0000</pubDate>
<dc:creator>LHBlog</dc:creator>
<og:description>一、前述 CNN和RNN几乎占据着深度学习的半壁江山，所以本文将着重讲解CNN+RNN的各种组合方式，以及CNN和RNN的对比。 二、CNN与RNN对比 1、CNN卷积神经网络与RNN递归神经网络直观</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LHWorldBlog/p/9581918.html</dc:identifier>
</item>
<item>
<title>表单数据验证方法（一）—— 使用validate.js实现表单数据验证 - CherishTheYouth</title>
<link>http://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_903.html</guid>
<description>&lt;h3&gt;&lt;span&gt;摘要：使用validate.js在前端实现表单数据提交前的验证&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 　&lt;span&gt;　好久没写博客了，真的是罪过，以后不能这样了，只学习不思考，学的都是白搭，希望在博客园能记录下自己学习的点滴，虽然记录的都是些浅显的技术，但能起到巩固自己和稍微帮助一下和我一样的菜鸡也是不错的，哈哈，不好意思，闲话扯多了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今天想把之前学的表单验证的方法复习一遍，因为明天的工作中要用到，而且好久没复习了，都快忘记了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在是学的ASP.NET，关于表单验证，目前知道的，除了以前那种傻瓜式的每个表单选项都用一个函数去验证之外，有两种方法是比较方便的，今天先介绍一下第一种，在前端实现表单验证的方法——基于validate.js的表单验证方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;注意哟，以下我都用截图的方式挂出代码，然后最后会把完整代码贴出来，提供复制粘贴，小伙伴不要急着敲哦！&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.下载和引入validate.js&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们需要下载一份validate.js文件，这个文件可以去JQuery官网或者csdn等网站下载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903225617417-291726500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下载好之后，新建一个html文件，然后先后将jquery.js文件和validate.js引入html代码，我这里新建一个名为formCheck.html的文件，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903230237804-467797902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;这里为了待会的表单表现的好看一些，我引入了layui.css的样式文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.建立表单&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903232754699-352383217.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903233022205-533468087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt; 3.使用validate.js实现表单数据的验证&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 同样，我们直接看代码截图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903233434669-708133478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;除了这些检验方式，validate.js里还封装了包括&lt;strong&gt;邮箱格式验证，电话号码格式验证&lt;/strong&gt;等验证犯法，使用方法和上图中的&lt;strong&gt;number&lt;/strong&gt;一致，想进一步了解的同学可以自行查看具体的js内容哦。&lt;/span&gt;&lt;span&gt;上图中的代码，rules部分限定了输入数据的规范，message则设定了错误提示信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;4.查看结果&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903234018954-2057798329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903234049872-938667503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　 这种验证方法还是非常简单和方便的，借助一个js插件，轻松搞定数据验证，希望这个简单的demo能帮到何我一样的菜鸡哦，先写到这里啦，要睡了，晚安哦！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对了，差点忘了奉上完整代码了，请笑纳：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;title&amp;gt;前端表单验证&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;         &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-v2.3.0/layui/css/layui.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;span&gt; 7&lt;/span&gt;         &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt; 8&lt;/span&gt;         &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;js/jquery.validate.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt; 9&lt;/span&gt;         &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-v2.3.0/layui/layui.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt;10&lt;/span&gt;         &amp;lt;style type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;11&lt;/span&gt;             #form-&lt;span&gt;box{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                width: 700px;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                height: 300px;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                margin: auto;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                position: relative;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                top: 100px;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &amp;lt;/style&amp;gt;
&lt;span&gt;19&lt;/span&gt;     &amp;lt;/head&amp;gt;
&lt;span&gt;20&lt;/span&gt;     &amp;lt;body&amp;gt;
&lt;span&gt;21&lt;/span&gt;         &amp;lt;form action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;formCheck.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;22&lt;/span&gt;             &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-box&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form layui-form-pane&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;23&lt;/span&gt;                 &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;24&lt;/span&gt;                     &amp;lt;label &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;用户名&amp;lt;/label&amp;gt;
&lt;span&gt;25&lt;/span&gt;                     &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-input-inline&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;26&lt;/span&gt;                        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;27&lt;/span&gt;                     &amp;lt;/div&amp;gt;       
&lt;span&gt;28&lt;/span&gt;                  &amp;lt;/div&amp;gt;
&lt;span&gt;29&lt;/span&gt;                  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;30&lt;/span&gt;                     &amp;lt;label &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;密码&amp;lt;/label&amp;gt;
&lt;span&gt;31&lt;/span&gt;                     &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-input-inline&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;32&lt;/span&gt;                        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passWord&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;33&lt;/span&gt;                     &amp;lt;/div&amp;gt;   
&lt;span&gt;34&lt;/span&gt;                  &amp;lt;/div&amp;gt;
&lt;span&gt;35&lt;/span&gt;                  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;                   
&lt;span&gt;36&lt;/span&gt;                        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;frmSubmit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-btn layui-btn-primary layui-btn-normal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;span&gt;37&lt;/span&gt;                  &amp;lt;/div&amp;gt;
&lt;span&gt;38&lt;/span&gt;             &amp;lt;/div&amp;gt;
&lt;span&gt;39&lt;/span&gt;         &amp;lt;/form&amp;gt;
&lt;span&gt;40&lt;/span&gt;     &amp;lt;/body&amp;gt;
&lt;span&gt;41&lt;/span&gt;     &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        $(function(){
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).validate({
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                    rules: {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                        userName: {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                             required: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该项表示该字段为必填项&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                             maxlength: &lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示该字段的最大长度为5&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                        },
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                        passWord: {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                             required: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                             number: &lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示该字段必须为数字&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                    },
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                    messages: {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                        userName: {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                             required: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*必填&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                             maxlength: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*最多5个字符&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                        },
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                        passWord: {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                             required: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*必填&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                             number: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*必须是合法的数字&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                    }                    
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;                })        
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;67&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt; 希望能帮到你哦！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的eMail:3074596466@qq.com&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Mon, 03 Sep 2018 15:48:00 +0000</pubDate>
<dc:creator>CherishTheYouth</dc:creator>
<og:description>使用validate.js在前端实现表单数据提交前的验证</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_903.html</dc:identifier>
</item>
<item>
<title>北京周末去哪儿 —— 天安门广场 - 一 定 会 去 旅 行</title>
<link>http://www.cnblogs.com/jying/p/9415523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jying/p/9415523.html</guid>
<description>&lt;p&gt;对于第一次来北京的游客，天安门都是必去的一站，毕竟那是祖国首都最中心的地方，心脏。&lt;/p&gt;
&lt;p&gt;对于来北京工作的奋斗者，早晚你会去看看它。&lt;/p&gt;
&lt;p&gt;本文主要针对周末逛北京的群体，对于外来游客，改天我会单独开贴。&lt;/p&gt;
&lt;p&gt;不同于外来游客，作为本地“居住民”而游览这座城市，应该怀着一种慢悠悠的休闲，只有这样你才能体味观察到那种京味，假如你像个外来游客一样匆匆而过，拍张照证明到此一游，那我奉劝你看完本文再去重游一遍吧~~&lt;/p&gt;
&lt;p&gt;天安门广场适合上午游览，如果你能在6点后8点前赶到的话，那时候在我看来是一天中最好的时候，看升国旗的刚刚散去，旅游团还没赶到，阳光打在天安门城楼上也刚刚好的和煦，其实没有必要去看升国旗，因为真的是太早了，作为本地“居住民”恐怕只有紧挨在附近的才能赶到，其他的要么是外来旅游住在酒店的，要么还听说过通宵一晚等待的，也听说过半夜往那骑行或步行的。&lt;/p&gt;

&lt;p&gt;如下图，游览整个天安门广场的路线图建议为：天安门广场——毛主席纪念堂——天安门城楼——端门左出口——王府井大街。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/362679/201809/362679-20180901121456729-1890800791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;希望大家在游览时听从服务人员指挥，爱护环境，小声言语，文明游览，成年人请随身携带身份证。&lt;/p&gt;
&lt;p&gt;1、到达天安门广场最近的地铁出口是1号线天安门东站和天安门西站，2号线的前门站，因为进入天安门广场需要安检，所以我推荐的到达时间是6点-8点游客较少，当然11点之前到达都是可以的，但如果要去看毛爷爷的话就必须11点前了，因为12点后闭馆。&lt;/p&gt;
&lt;p&gt;　  天安门广场虽然只是个广场，但因为它是中国人们心中的首都广场，又有每天的升国旗，新闻联播中每天出境的人民英雄纪念碑，所以置身其中感觉很神圣。&lt;/p&gt;
&lt;p&gt;2、毛爷爷纪念堂（免票），严格安检，禁止携带打火机/火柴/刀具等危险品，门口会全部没收，而且是&lt;span&gt;单行道进出&lt;/span&gt;，所以没收后无法再取回，吸烟者提前注意，钥匙/硬币等铁器需要拿出口袋检查，大包需要寄存，所以最好的方式是有一个人学做雷锋放弃进去参观在外面背包。毛爷爷纪念堂&lt;span&gt;开馆时间8:00—12:00（下午闭馆）&lt;/span&gt;，其中暑假7月1日至8月31日7:00—11:00点（下午闭馆），另外&lt;span&gt;每周一全天闭馆&lt;/span&gt;。入馆不准开口说话，请大家怀着缅怀的心情入馆瞻仰，不要嬉皮笑脸的。&lt;br/&gt;&lt;span&gt;　　a．瞻仰、参观须凭有效证件（可能是身份证也可能不需要）&lt;span&gt;免费&lt;/span&gt;排队入场。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　b．自觉接受安全检查。严禁携带危险物品入场。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　c．&lt;span&gt;严禁携带手提包、背包、照相机、摄像机、水杯、饮料&lt;/span&gt;等物品入场。带有上述物品者请先到存包处寄存。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　d．注意衣着整洁、得体，脱帽瞻仰。&lt;span&gt;穿背心、拖鞋者谢绝入场。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　e．注意保持安静。&lt;span&gt;请关闭手机或将手机调至静音状态，不要大声喧哗、嬉笑打闹。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 　　f．注意保持环境整洁。严禁吸烟，严禁随地吐痰、&lt;span&gt;严禁嚼吐口香糖&lt;/span&gt;，严禁乱扔烟头、果皮、纸屑等废弃物，严禁翻越栏杆、踩踏花坛和草坪。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、大家可以在广场拍拍照，以天安门为背景，以人民大会堂为背景，以人民英雄纪念碑为背景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/362679/201809/362679-20180901121510640-1118485384.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、天安门广场与天安门城楼中间是长安街，所以可以走地下走廊穿过，天安门城楼前斜侧其实也是拍照的好地点，在天安门广场拍摄时距离有点远背景人还巨多，但是在天安门城楼前正面拍摄又太近显示不下整个城楼，所以斜侧60-80度是最好的角度位置，去晚了背景都是人需要抢占拍照位置哦~~&lt;/p&gt;
&lt;p&gt;5、天安门城楼那个门是可以免费进入的，不收费的~~但是&lt;span&gt;下午3点关门&lt;/span&gt;，所以这也是推荐上午去的原因之一。另外这个门是&lt;span&gt;单行道，进去后不能原路退回&lt;/span&gt;。小时候学课文，什么华表，金水桥都专门赞美一段，等你到了看一眼根本不吸引人……天安门城楼可以上去（收费，需寄存包裹），所以空手的有兴趣的可以上去看看，但是我没上去过~~&lt;/p&gt;
&lt;p&gt;6、穿过天安门城楼一直往前走，到端门往里属于故宫就收费啦，可以选择左门出，顺路往前走，路旁有卖老冰棍的，1块一根~~一直走就能到王府井大街，这时候差不多就是正午啦，这么有名的地方当然没啥便宜吃饭地方，景点那些快餐量少又贵还不好吃，所以不如直接王府井找有吃饭一条街的商场，便宜的话比如庆丰包子，比如吉野家，带妹子的话建议呷哺，相对便宜还不丢面。吃完饭有兴趣的还可以在王府井逛逛，男生可以转转王府井的apply实体店。&lt;/p&gt;
&lt;p&gt;7、打道回府，大约下午3，4点的时候就可以打道回府啦~~干嘛要回家那么晚呢，轻轻松松日常闲逛才是享受生活嘛~~&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;天安门广场线路就介绍到这里啦，以下为个人指数感受，满分都是10星：&lt;/p&gt;
&lt;p&gt;推荐指数：8星（毕竟是首都的中心的中心）&lt;br/&gt;交通指数：8星（主要安检什么的排队耗时）&lt;br/&gt;团体指数：8星（互拍照片必不可少）&lt;br/&gt;家庭指数：8星（我真的觉得这是一个家庭一起活动一起步行的很好路线，前提是家庭成员体力上能走完）&lt;br/&gt;情侣指数：7星（只要体力好，走一走很美好~~前提是妹子愿意跟你走这么远）&lt;br/&gt;食物指数：4星（主要吃饭贵远，富人自动屏蔽）&lt;br/&gt;休闲指数：5星（要走很多路，要看很多人）&lt;/p&gt;
&lt;p&gt;最佳游览季节：3月1号-5月10号，8月15号-10月30&lt;/p&gt;



</description>
<pubDate>Mon, 03 Sep 2018 15:44:00 +0000</pubDate>
<dc:creator>一 定 会 去 旅 行</dc:creator>
<og:description>对于第一次来北京的游客，天安门都是必去的一站，毕竟那是祖国首都最中心的地方，心脏。 对于来北京工作的奋斗者，早晚你会去看看它。 本文主要针对周末逛北京的群体，对于外来游客，改天我会单独开贴。 不同于外</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jying/p/9415523.html</dc:identifier>
</item>
<item>
<title>详解JS中DOM 元素的 attribute 和 property 属性 - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9581851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9581851.html</guid>
<description>&lt;h4 id=&quot;一表亲戚attribute和property&quot;&gt;一、'表亲戚':attribute和property&lt;/h4&gt;
&lt;p&gt;为什么称attribute和property为'表亲戚'呢?因为他们既有共同处,也有不同点.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;attribute&lt;/code&gt; 是 dom 元素在文档中作为 html 标签拥有的属性；&lt;br/&gt;&lt;code&gt;property&lt;/code&gt; 是 dom 元素在 js 中作为对象拥有的属性。&lt;/p&gt;
&lt;p&gt;从定义上可以看出:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的&lt;/li&gt;
&lt;li&gt;但是对于自定义的属性来说，他们是不同步的.(自定义属性不会自动添加到property)&lt;/li&gt;
&lt;li&gt;property 的值可以改变；attribute 的值不能改变&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;二&quot;&gt;二、&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;分别打印两个值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;打印attribute属性&lt;/strong&gt;&lt;br/&gt;直接把div标签当作对象,用'.'输出即是property属性&lt;br/&gt;但是注意!&lt;span&gt;property是不能输出自定义属性的&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//html
&amp;lt;div class=&quot;divClass&quot; id=&quot;divId&quot; &amp;gt;&amp;lt;/div&amp;gt;

//js
window.onload = function(){
    var divId = document.getElementById('divId');
    console.log(divId.id);
    console.log(divId.add)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201809/1414709-20180903222314862-922982860.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看见attributes对应的值,我们打印一下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(divId.attributes[0]);       //打印 class=&quot;divClass&quot;
console.log(divId.attributes.class)     //打印 class=&quot;divClass&quot;

console.log(divId.getAttribute('class'))    //打印divClass
console.log(divId.getAttribute('id'))    //打印divId&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现上面两组值是相等的.&lt;/p&gt;
&lt;p&gt;虽然都可以取值,但《js高级程序设计》中提到，为了方便操作，建议大家用setAttribute()和getAttribute()来操作即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打印property&lt;/strong&gt;&lt;br/&gt;html自带的dom属性会自动转换成property,但是自定义的属性没有这个'权利'&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;divClass&quot; id=&quot;divId&quot; addUserDefine=&quot;zidingyi&quot;&amp;gt;&amp;lt;/div&amp;gt;

console.log(divId.class);           //打印 divClass
console.log(divId.addUserDefine)    //打印 undefined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201809/1414709-20180903223422977-698780892.png&quot;/&gt;&lt;br/&gt;打开Elements的properties可以看到,dom存在的属性,property同样继承了,而&lt;code&gt;addUserDefine&lt;/code&gt;却没有出现在&lt;span&gt;property&lt;/span&gt;中&lt;/p&gt;
&lt;p&gt;property:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var obj = {};
Object.defineProperty(obj,'name',{
    value:'Property'
})

console.log(obj.name)   //打印 Property&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三用例子解析两者赋值&quot;&gt;三、用例子解析两者赋值&lt;/h4&gt;
&lt;p&gt;如果我们修改了property的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//html
&amp;lt;input value=&quot;initValue&quot; id=&quot;ipt&quot;/&amp;gt;

//js
window.onload = function(){
    var ipt = document.getElementById('ipt');

    ipt.value = 'changeValue'
    console.log(ipt.value);
    console.log(ipt.getAttribute('value'));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;猜一下结果??&lt;br/&gt;答案是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(ipt.value);         //changeValue
console.log(ipt.getAttribute('value'));     //initValue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再来看看input的值&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201809/1414709-20180903230918526-1680293703.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;难以置信?&lt;br/&gt;我们再来看看从修改attribute入手&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//html
&amp;lt;input value=&quot;initValue&quot; id=&quot;ipt&quot;/&amp;gt;

//js
window.onload = function(){
    var ipt = document.getElementById('ipt');

    ipt.setAttribute('value','changeValue')
    console.log(ipt.value);
    console.log(ipt.getAttribute('value'));

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(ipt.value);         //changeValue
console.log(ipt.getAttribute('value'));     //changeValue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;property比attribute'霸道',估计是'表哥'&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;property和attribute两者是属于单方面通信,即:&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;1.property能够从attribute中得到同步；
2.attribute不会同步property上的值；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再啰嗦一句:&lt;br/&gt;对属性Property可以赋任何类型的值，而对特性Attribute只能赋值字符串！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
//js
var obj = {
    value : false,
}

var ipt = document.getElementById('ipt');

obj.value = true;       //property更改
ipt.setAttribute('value',true)  //attribute更改

console.log(typeof obj.value);  //boolean
console.log(obj.value)          //true

console.log(typeof ipt.value)   //string
console.log(ipt.value);         //true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大吉大利,感谢阅读,欢迎纠正！&lt;/p&gt;
</description>
<pubDate>Mon, 03 Sep 2018 15:24:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、'表亲戚':attribute和property 为什么称attribute和property为'表亲戚'呢?因为他们既有共同处,也有不同点. 是 dom 元素在文档中作为 html 标签拥有的属</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9581851.html</dc:identifier>
</item>
<item>
<title>跟厂长学PHP7内核（六）：生命周期之请求初始化阶段 - 了不起的厂长</title>
<link>http://www.cnblogs.com/enochzzg/p/9581544.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enochzzg/p/9581544.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上篇文章我们分析了生命周期的模块初始化阶段，大部分是初始化全局变量和各种宏的定义，今天我们来学习一下五大生命周期的第二阶段--请求初始化阶段（php_request_startup）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们先对请求初始化阶段内的函数做个概览。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;php_output_activate()&lt;/td&gt;
&lt;td&gt;重置输出全局变量，初始化输出相关堆栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;zend_activate()&lt;/td&gt;
&lt;td&gt;初始化Zend引擎&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;sapi_activate()&lt;/td&gt;
&lt;td&gt;初始化SG宏，调各sapi钩子函数activate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;zend_signal_activate()&lt;/td&gt;
&lt;td&gt;信号处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;zend_set_timeout()&lt;/td&gt;
&lt;td&gt;设置超时时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;php_hash_environment()&lt;/td&gt;
&lt;td&gt;初始化PHP请求的全局变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;zend_activate_modules()&lt;/td&gt;
&lt;td&gt;调用各扩展定义的request_startup钩子函数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;php_output_activate&quot;&gt;2.1、php_output_activate&lt;/h2&gt;
&lt;p&gt;重新为output_globals分配内存，初始化与输出处理程序相关的堆栈，并将OG宏的flags设置为激活状态。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/output.c
PHPAPI int php_output_activate(void)
{
#ifdef ZTS
    memset((*((void ***) ZEND_TSRMLS_CACHE))[TSRM_UNSHUFFLE_RSRC_ID(output_globals_id)], 0, sizeof(zend_output_globals));
#else
    memset(&amp;amp;output_globals, 0, sizeof(zend_output_globals));
#endif

    zend_stack_init(&amp;amp;OG(handlers), sizeof(php_output_handler *));
    OG(flags) |= PHP_OUTPUT_ACTIVATED;

    return SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;zend_activate&quot;&gt;2.2、zend_activate&lt;/h2&gt;
&lt;p&gt;zend引擎的初始化，主要作用为重置垃圾回收、初始化编译器、初始化执行器、初始化扫描器。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;gc_reset()&lt;/td&gt;
&lt;td&gt;重置垃圾回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;init_compiler()&lt;/td&gt;
&lt;td&gt;初始化编译器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;init_executor()&lt;/td&gt;
&lt;td&gt;初始化执行器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;startup_scanner()&lt;/td&gt;
&lt;td&gt;初始化扫描器&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;sapi_activate&quot;&gt;2.3、sapi_activate&lt;/h2&gt;
&lt;p&gt;对SG宏内的一些变量进行初始化，并调用当前sapi_module_struct中定义的钩子函数activate()以及input_filter_init()，但是在cli模式下，这两个钩子函数都没有实现，返回了null。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/SAPI.c
SAPI_API void sapi_activate(void)
{
    zend_llist_init(&amp;amp;SG(sapi_headers).headers, sizeof(sapi_header_struct), (void (*)(void *)) sapi_free_header, 0);
    SG(sapi_headers).send_default_content_type = 1;

    /*
    SG(sapi_headers).http_response_code = 200;
    */
    SG(sapi_headers).http_status_line = NULL;
    SG(sapi_headers).mimetype = NULL;
    SG(headers_sent) = 0;
    ZVAL_UNDEF(&amp;amp;SG(callback_func));
    SG(read_post_bytes) = 0;
    SG(request_info).request_body = NULL;
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;php_hash_environment&quot;&gt;2.4、php_hash_environment&lt;/h2&gt;
&lt;p&gt;为http_globals分配内存，初始化auto_globals，解析请求参数并存放到全局变量中。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;PHPAPI int php_hash_environment(void)
{
    memset(PG(http_globals), 0, sizeof(PG(http_globals)));
    zend_activate_auto_globals();
    if (PG(register_argc_argv)) {
        php_build_argv(SG(request_info).query_string, &amp;amp;PG(http_globals)[TRACK_VARS_SERVER]);
    }
    return SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;zend_activate_modules&quot;&gt;2.5、zend_activate_modules&lt;/h2&gt;
&lt;p&gt;该函数通过遍历注册在module_registry的所有模块，调用每个模块的钩子函数request_startup()进行初始化。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;ZEND_API void zend_activate_modules(void) /* {{{ */
{
    zend_module_entry **p = module_request_startup_handlers;

    while (*p) {
        zend_module_entry *module = *p;

        if (module-&amp;gt;request_startup_func(module-&amp;gt;type, module-&amp;gt;module_number)==FAILURE) {
            zend_error(E_WARNING, &quot;request_startup() for %s module failed&quot;, module-&amp;gt;name);
            exit(1);
        }
        p++;
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 03 Sep 2018 14:23:00 +0000</pubDate>
<dc:creator>了不起的厂长</dc:creator>
<og:description>上篇文章我们分析了生命周期的模块初始化阶段，大部分是初始化全局变量和各种宏的定义，今天我们来学习一下五大生命周期的第二阶段 请求初始化阶段（php_request_startup）。 一、概览 我们先</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enochzzg/p/9581544.html</dc:identifier>
</item>
<item>
<title>Python抽象类（abc模块） - rongz</title>
<link>http://www.cnblogs.com/Rongze-blog/p/9581521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rongze-blog/p/9581521.html</guid>
<description>&lt;p&gt;1.抽象类概念&lt;/p&gt;
&lt;p&gt;抽象类是一个特殊的类，只能被继承，不能实例化&lt;/p&gt;
&lt;p&gt;2.为什么要有抽象类&lt;/p&gt;
&lt;p&gt;其实在未接触抽象类概念时，我们可以构造香蕉、苹果、梨之类的类，然后让它们继承水果这个的基类，水果的基类包含一个eat函数。&lt;/p&gt;
&lt;p&gt;但是你有没有想过，我们可以将香蕉、苹果、梨实例化，去吃香蕉、苹果、梨。但是我们却不能将水果实例化，因为我们无法吃到叫水果的这个东西。&lt;/p&gt;
&lt;p&gt;所以抽象类中只能有抽象方法（没有实现功能），该类不能被实例化，只能被继承，且子类必须实现抽象方法。&lt;/p&gt;
&lt;p&gt;3.抽象类的作用&lt;/p&gt;
&lt;p&gt;在不同的模块中通过抽象基类来调用，可以用最精简的方式展示出代码之间的逻辑关系，让模块之间的依赖清晰简单。&lt;/p&gt;
&lt;p&gt;抽象类的编程，让每个人可以关注当前抽象类的方法和描述，而不需要考虑过多的实现细节，这对协同开发有很大意义，也让代码可读性更高。&lt;/p&gt;
&lt;p&gt;4.抽象类的使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; abc  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用abc模块实现抽象类&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt; File(metaclass=abc.ABCMeta):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; abc.ABCMeta是实现抽象类的一个基础类&lt;/span&gt;
    @abc.abstractmethod  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义抽象方法，无需实现功能&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt; Txt(File):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 子类继承抽象类，但是必须定义read方法将抽象类中的read方法覆盖&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;文本数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


txt1 &lt;/span&gt;=&lt;span&gt; Txt()
txt1.read()  &lt;/span&gt;
&lt;span&gt;
txt2 &lt;/span&gt;=&lt;span&gt; File()
txt2.read()
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;文本数据的读取方法
Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:/python/ftp_work/test.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 20, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;span&gt;
    txt2 &lt;/span&gt;=&lt;span&gt; File()
TypeError: Can&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t instantiate abstract class File with abstract methods read&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然将抽象类实例化报错了，得到了我们想要的结果&lt;/p&gt;
&lt;p&gt;5.abc模块在Python2&amp;amp;3的兼容问题&lt;/p&gt;
&lt;p&gt;为解决兼容性问题，我们需要引入six模块&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;通用做法。&lt;/p&gt;
&lt;p&gt;@six.add_metaclass(MetaClass) 的作用是在不同版本的Python之间提供一个优雅的声明类的metaclass的手段，事实上不用它也可以，只是使用了它代码更为整洁明了。&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;import six&lt;/p&gt;

&lt;p&gt;@six.add_metaclass(Meta)&lt;/p&gt;
&lt;p&gt;class MyClass(object):&lt;/p&gt;
&lt;p&gt;    pass&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;在Python 3 等价于&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;import six&lt;/p&gt;

&lt;p&gt;class MyClass(object, metaclass = Meta):&lt;/p&gt;
&lt;p&gt;    pass&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;在Python 2.x (x &amp;gt;= 6)中等价于&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;import six&lt;/p&gt;

&lt;p&gt;class MyClass(object):&lt;/p&gt;
&lt;p&gt;    __metaclass__ = Meta&lt;/p&gt;
&lt;p&gt;    pass&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;或者直接调用装饰器，&lt;/p&gt;
&lt;p&gt;这里也能看出来装饰器就是个方法包装而已。&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;import six&lt;/p&gt;

&lt;p&gt;class MyClass(object):&lt;/p&gt;
&lt;p&gt;    pass&lt;/p&gt;
&lt;p&gt;MyClass  = six.add_metaclass(Meta)(MyClass)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 03 Sep 2018 14:20:00 +0000</pubDate>
<dc:creator>rongz</dc:creator>
<og:description>1.抽象类概念 抽象类是一个特殊的类，只能被继承，不能实例化 2.为什么要有抽象类 其实在未接触抽象类概念时，我们可以构造香蕉、苹果、梨之类的类，然后让它们继承水果这个的基类，水果的基类包含一个eat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Rongze-blog/p/9581521.html</dc:identifier>
</item>
</channel>
</rss>