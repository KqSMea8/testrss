<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>js面向对象之继承那点事儿根本就不是事 - 决起而飞</title>
<link>http://www.cnblogs.com/iDouble/p/8406975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iDouble/p/8406975.html</guid>
<description>&lt;p&gt;说道这个继承，了解object-oriented的朋友都知道，大多oo语言都有两种，一种是接口继承（只继承方法签名）；一种是实现继承（继承实际的方法）&lt;/p&gt;
&lt;p&gt;奈何js中没有签名，因而只有实现继承，而且靠的是原型链实现的。下面正式的说一说js中继承那点事儿&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt; 1、原型链&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;关于原型链在上一节&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/iDouble/p/8401058.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;面向对象之原型&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;提了一些，这节好好说一说。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原型链：实现继承的主要方法，利用原型让一个引用类型继承另一个引用类型的属性和方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;回顾：构造函数，原型，实例三者的关系&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一个构造函数都有一个原型对象(Person.prototype)；原型对象都包含指向构造函数的指针(constructor)；每个实例都包含指向原型对象的指针(看不见的_proto_指针)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;原型链是怎么来的呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;某个构造函数的原型对象是另一个构造函数的实例；这个构造函数的原型对象就会有个(看不见的_proto_指针)指向另一个构造函数的原型对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么另一个原型对象又是其他的构造函数实例又会怎么样，就这样层层递进，形成原型链；来具体看一下吧&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个构造函数;有一个属性和一个原型方法&lt;/span&gt;
       &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperType(){
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.property=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
       } 
       
       SuperType.prototype.getSuperValue&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.property
       }


       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个构造函数;目前有一个属性&lt;/span&gt;
       &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubType(){
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subproperty=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
       }
       
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承了SuperType;SubType原型成了SuperType的实例;实际就是重写SubType的原型对象;给SuperType原型对象继承了&lt;/span&gt;
       SubType.prototype=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SuperType()
       
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;现在这个构造函数有两个属性(一个本身的subproperty,一个继承的存在原型对象的property);两个方法(一个原型对象的getSubValue,一个原型对象的原型对象的getSuperValue)&lt;/span&gt;
       SubType.prototype.getSubValue=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subproperty
       }
       
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance=&lt;span&gt;new&lt;/span&gt; SubType()    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第二个构造函数的实例&lt;/span&gt;
&lt;span&gt;
       console.log(instance.getSuperValue())   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true  先查找instance这个实例有没有此方法;显然没有，再查找SubType原型对象有没有此方法;也没有，再查找SubType原型对象的原型对象;显然是存在的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：instance的constructor现在指向的是SuperType这个构造函数；因为原来的SubType.prototype被重写了，其内部的constructor也就随着SubType.prototype的原型对象的constructor指向构造函数SuperType；至于原型搜索机制是怎么样运行的，请仔细看上面的代码，相信你是可以的&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.1完整的原型&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在原型那节已经提了些，还是再说一下。完整的原型包括Object。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有函数的默认原型都是Object的实例；每个默认原型都有个_proto_指针指向Object.prototype；因此自定义类型都继承如toString，valueOf的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而Object.prototype的_proto_指针指向null来结束原型链。以Person构造函数为例，看看完整的原型链图&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318627/201802/1318627-20180202211524906-57514661.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2原型和实例的关系判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种使用instanceof操作符：  测试实例和原型链中出现的构造函数，结果为true&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种使用isPrototypeOf()方法： 只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
       console.log(instance &lt;span&gt;instanceof&lt;/span&gt; Object)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;都为true&lt;/span&gt;
       console.log(instance &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; SuperType)
       console.log(instance &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; SubType)

      
       console.log(Object.prototype.isPrototypeOf(instance))  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;都为true&lt;/span&gt;
&lt;span&gt;       console.log(SuperType.prototype.isPrototypeOf(instance))
       console.log(SubType.prototype.isPrototypeOf(instance))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1.3谨慎定义方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：给原型对象添加方法，一定放在替换原型的后面，因为放在替换原型之前是找不到了，原型会被重写的；&lt;/p&gt;
&lt;p&gt;注意：在通过原型链继承时，不能使用对象字面量创建原型方法，因为也会重写原型链；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperType(){
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.property=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
       } 
       
       SuperType.prototype.getSuperValue&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.property
       }
       
       &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubType(){
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subproperty=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
       }
       
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承SuperType&lt;/span&gt;
       SubType.prototype=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SuperType()
       
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用字面量添加新方法,导致上一行无效     因为现在的原型替换了Object实例而非SuperType的实例,关系中断&lt;/span&gt;
       SubType.prototype=&lt;span&gt;{
              getSubValue:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subproperty;
              },
              somOtherMethod:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
              }
       };

       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubType()
       console.log(instance.getSuperValue())    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1.4原型链的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、包含引用类型值的原型：当实例是另一函数的原型时，引用类型值就会变成原型上的属性，就会被另一函数的实例所共享。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperType(){
              &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.colors=[&quot;yellow&quot;,&quot;red&quot;,&quot;olive&quot;&lt;span&gt;]
       }

       &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubType(){
       }

       SubType.prototype&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; SuperType()    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;color实际上就是原型上的了&lt;/span&gt;

       &lt;span&gt;var&lt;/span&gt; instance1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubType()
       instance1.colors.push(&lt;/span&gt;&quot;purple&quot;&lt;span&gt;)
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubType()

       console.log(instance1.colors&lt;/span&gt;==instance2.colors)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、创建子类型实例时，不能向超类型的构造函数传递参数（没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数）&lt;/p&gt;
&lt;h2&gt;2、借助构造函数&lt;/h2&gt;
&lt;p&gt;为了解决原型中包含引用类型值带来的问题，利用构造函数来解决&lt;/p&gt;
&lt;p&gt;在子类型构造函数的内部调用超类型构造函数（函数是特定环境中执行代码的对象，可以通过apply或call调用）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperType(){
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color=[&quot;yellow&quot;,&quot;red&quot;,&quot;olive&quot;&lt;span&gt;]
       }

       &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubType(){
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承了SuperType&lt;/span&gt;
               SuperType.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
       }

       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubType()
       instance1.color.push(&lt;/span&gt;&quot;purple&quot;&lt;span&gt;)
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubType()

       console.log(instance1.color)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;yellow&quot;,&quot;red&quot;,&quot;olive&quot;,&quot;purple&quot;]&lt;/span&gt;
       console.log(instance2.color)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;yellow&quot;,&quot;red&quot;,&quot;olive&quot;]&lt;/span&gt;


       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递参数&lt;/span&gt;
       &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperType(name){
              &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name
       }
       &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubType(){
                SuperType.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;double&quot;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age=12&lt;span&gt;
       }

       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubType()
       console.log(instance1.name)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;
       console.log(instance1.age)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题：仅仅借鉴构造函数，&lt;strong&gt;那么避免不了构造函数的问题，方法都在构造函数定义了，函数无法复用&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;3、组合继承（常用的还是组合，和原型与构造结合一样）&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperType(name){
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color=[&quot;yellow&quot;,&quot;red&quot;,&quot;olive&quot;&lt;span&gt;];
       }

       SuperType.prototype.sayName&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
               console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
       }
  
       &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubType(name,age){
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承属性,创建属性副本&lt;/span&gt;
               SuperType.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,name);
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age=&lt;span&gt;age;
       }
       
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承属性和方法,只是原型中属性被后来的函数调用生成的属性副本遮盖&lt;/span&gt;
       SubType.prototype=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SuperType();

       alert(SubType.prototype.constructor)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向的是SuperType&lt;/span&gt;
&lt;span&gt;
       SubType.prototype.constructor&lt;/span&gt;=&lt;span&gt;SubType; //将constructor回归到SubType构造函数身上
       SubType.prototype.sayAge&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age)
       }
       
       
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance1=&lt;span&gt;new&lt;/span&gt; SubType(&quot;double&quot;,23&lt;span&gt;)
       instance1.color.push(&lt;/span&gt;&quot;pink&quot;&lt;span&gt;)
       console.log(instance1.color)         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;yellow&quot;,&quot;red&quot;,&quot;olive&quot;,&quot;pink&quot;]&lt;/span&gt;
       instance1.sayName()                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;
       instance1.sayAge()                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;

       &lt;span&gt;var&lt;/span&gt; instance2=&lt;span&gt;new&lt;/span&gt; SubType(&quot;single&quot;,34&lt;span&gt;)
       console.log(instance2.color)         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;yellow&quot;,&quot;red&quot;,&quot;olive&quot;]&lt;/span&gt;
       instance2.sayName()                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;single&lt;/span&gt;
       instance2.sayAge()                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有其他的继承，花点时间写一下&lt;/p&gt;
&lt;h3&gt;1、原型式继承&lt;/h3&gt;
&lt;p&gt;克罗克福德写的；借助原型可以基于已有的对象创建新对象，同时不必创建自定义类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;function&lt;/span&gt; object(o){           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本质上object()函数对其中对象的浅复制&lt;/span&gt;
               &lt;span&gt;function&lt;/span&gt; F(){}           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个新的构造函数&lt;/span&gt;
               F.prototype=o            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数原型为传入的对象&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; F()           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回构造函数的实例&lt;/span&gt;
&lt;span&gt;       }

       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person=&lt;span&gt;{
               name:&lt;/span&gt;&quot;double&quot;&lt;span&gt;,
               friends:[&lt;/span&gt;&quot;tom&quot;,&quot;jack&quot;,&quot;mike&quot;&lt;span&gt;]
       }

       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1=object(person)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;事实上为原型共享&lt;/span&gt;
       person1.name=&quot;grey&quot;&lt;span&gt;
       person1.friends.push(&lt;/span&gt;&quot;single&quot;&lt;span&gt;)
       
       console.log(person1.friends)    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;tom&quot;, &quot;jack&quot;, &quot;mike&quot;, &quot;single&quot;]&lt;/span&gt;

       &lt;span&gt;var&lt;/span&gt; person2=&lt;span&gt;object(person)
       person2.name&lt;/span&gt;=&quot;red&quot;&lt;span&gt;
       console.log(person2.friends)     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;tom&quot;, &quot;jack&quot;, &quot;mike&quot;, &quot;single&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ES5为了规范原型式的继承，有个Object.create()来方便，IE9以上可以；只是想一个对象和另一个对象保持类似的情况，完全可以这种方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;var&lt;/span&gt; person=&lt;span&gt;{
               name:&lt;/span&gt;&quot;double&quot;&lt;span&gt;,
               friends:[&lt;/span&gt;&quot;tom&quot;,&quot;jack&quot;,&quot;mike&quot;&lt;span&gt;]
       }

       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1=&lt;span&gt;Object.create(person)
       person1.name&lt;/span&gt;=&quot;single&quot;&lt;span&gt;
       person1.friends.push(&lt;/span&gt;&quot;singles&quot;&lt;span&gt;)

       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2=&lt;span&gt;Object.create(person)

       console.log(person1.friends&lt;/span&gt;==person2.friends)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;

       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object.create()接受两个参数，一个为作为新对象原型的对象，一个为新对象定义额外属性对象&lt;/span&gt;
       &lt;span&gt;var&lt;/span&gt; person=&lt;span&gt;{
               name:&lt;/span&gt;&quot;double&quot;&lt;span&gt;,
               friends:[&lt;/span&gt;&quot;tom&quot;,&quot;jack&quot;,&quot;mike&quot;&lt;span&gt;]
       }

       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1=&lt;span&gt;Object.create(person,{
                 name:{ 
                       value:&lt;/span&gt;&quot;single&quot;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个属性都是通过自己描述符定义的&lt;/span&gt;
&lt;span&gt;                 }
       })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、寄生式继承&lt;/h3&gt;
&lt;p&gt;思路和原型式继承一脉相承，创建一个用于封装继承过程的函数，内部通过方式增强对象，返回对象；主要考虑对象时使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; object(o){
              &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; F(){}
              F.prototype&lt;/span&gt;=&lt;span&gt;o
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F()
       }

       &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createPerson(original){
              &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; clone=&lt;span&gt;object(original)     //继承原型
              clone.sayName&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){ 
                      alert(&lt;/span&gt;&quot;name&quot;&lt;span&gt;)
              }
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clone
       }

       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person=&lt;span&gt;{
              name:&lt;/span&gt;&quot;double&quot;&lt;span&gt;,
              friends:[&lt;/span&gt;&quot;single&quot;,&quot;tom&quot;,&quot;jack&quot;&lt;span&gt;]
       }

       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1=&lt;span&gt;createPerson(person)
       person1.sayName()    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;name     引用类型值还是共享的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、寄生组合继承&lt;/h3&gt;
&lt;p&gt;组合继承是继承中常常用到的，但是会调用两次超类型构造函数；寄生组合继承就是为了解决这个问题的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; object(o){
          &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; F(){}
          F.prototype&lt;/span&gt;=&lt;span&gt;o
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F()
    }


    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; inheritPrototype(subType,superType){
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prototype=object(superType)       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建对象   (superType实例)&lt;/span&gt;
          prototype.constructor=subType         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;增强对象&lt;/span&gt;
          subType.prototype=prototype           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定对象   (原型赋予实例)&lt;/span&gt;
&lt;span&gt;    }
    

     &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperType(name,sex){
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex=&lt;span&gt;sex
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.colors=[&quot;red&quot;&lt;span&gt;]
     }

     SuperType.prototype.sayName&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          alert(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name)
     }

     &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubType(name,sex,age){
           SuperType.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,name,sex)
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age=&lt;span&gt;age
     }


     inheritPrototype(SubType,SuperType)       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目前subType.prototype什么都没有&lt;/span&gt;
     SubType.prototype.sayAge=&lt;span&gt;function&lt;/span&gt;(){      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为subType.prototype添加个方法&lt;/span&gt;
           alert(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age)
     }

     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1=&lt;span&gt;new&lt;/span&gt; SubType(&quot;double&quot;,&quot;man&quot;,34&lt;span&gt;)
     console.log(person1.name)    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SuperType  这是个Bug&lt;/span&gt;
     console.log(person1.sex)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;man&lt;/span&gt;
     console.log(person1.colors)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;red&quot;]&lt;/span&gt;
     person1.sayAge()             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，差不多结束啦。&lt;/p&gt;
&lt;p&gt;各位客官们，关注一波呗&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 07:29:00 +0000</pubDate>
<dc:creator>决起而飞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iDouble/p/8406975.html</dc:identifier>
</item>
<item>
<title>.Net Core部署到CentOS - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/8409563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/8409563.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　1、本地使用Visual Studio 2017开发，使用的.NetCore SDK版本为2.1.4；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　2、数据库使用的MSSQLServer，部署在阿里云服务器上，WindowServer；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　3、Demo部署在腾讯云服务器上，&lt;strong&gt;CentOS系统;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;　　4、CentOS中安装了.net CoreSDK 2.1.4（开发和部署的环境最好一致，我在这里掉过坑）&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;　　5、代码管理通过Git来进行，在本地安装了Git，在CentOS中也安装了Git；&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;　　6、利用jexus进行反向代理；&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;建立一个Asp.Net Core项目，这个建立过程就不贴图了，步骤简单。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;此处还没有使用到Docker,&lt;strong&gt;建立项目时,&lt;/strong&gt;没有勾选Docker支持&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1133736/201802/1133736-20180203110927390-1575508179.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;整个项目从搭建到运行的简略过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1133736/201802/1133736-20180203115236734-787153141.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、建立实体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　只加了一个User类，里面就是基本的用户名、密码、地址和创建日期。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CreateDate =&lt;span&gt; DateTime.Now;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Password { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime CreateDate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、&lt;/span&gt;&lt;span&gt;&lt;span&gt;接下来是建立DbContext&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HDShopDbContext:DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HDShopDbContext(DbContextOptions&amp;lt;HDShopDbContext&amp;gt;&lt;span&gt; options)
            :&lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options)
        {

        }
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;modelBuilder.Entity&amp;lt;User&amp;gt;().ToTable(&quot;xxxx&quot;);&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;  DbSet&amp;lt;User&amp;gt; User { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3、&lt;/strong&gt;&lt;strong&gt;配置服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　在项目中已经默认的将EFCore相关的Nuget包加入进来了&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　在StartUp.cs文件中进行服务配置，使用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;services.AddDbContext&amp;lt;HDShopDbContext&amp;gt;(d =&amp;gt; d.UseSqlServer(Configuration.GetConnectionString(&quot;Default&quot;)));&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddDbContext&lt;/span&gt;&amp;lt;HDShopDbContext&amp;gt;(d =&amp;gt; d.UseSqlServer(Configuration.GetConnectionString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
            services.AddMvc();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseBrowserLink();
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseExceptionHandler(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            app.UseStaticFiles();

            app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                routes.MapRoute(
                    name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
        }
    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;此处，解释下Configure和ConfigureService的区别：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　Configure配置的是中间件，整个服务运行过程中，是以中间件形式进行跳转，从第一个中间件到第二个中间件，完成最后一个中间件要求后返回到上一个中间件，而中间件数量的多少是我们可以去控制的，如果有什么功能需要加入，我们也可以以中间件的形式控制运行，Configure方法即时控制中间件的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　ConfigureService配置的是整个运行中所用到的各种框架，注入等等，在Configure方法前先被调用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　具体可看@&lt;/strong&gt;&lt;a href=&quot;https://home.cnblogs.com/u/vipyoumay/&quot;&gt;行动派Xdpie&lt;/a&gt; &lt;a href=&quot;https://www.cnblogs.com/vipyoumay/p/5640645.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/vipyoumay/p/5640645.html&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;https://home.cnblogs.com/u/vipyoumay/&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1133736/201802/1133736-20180203134617312-754509626.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在appsetting.json中配置连接字符串，由于Linux中不能安装SQLServer除2017以外的其他版本我便将另一台WindowServer服务器数据库弄过来用了，SQLServer2017对于Linux服务器配置要求很高，我等小平民伤不起，哈哈。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1133736/201802/1133736-20180203135151859-708620472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记得连接字符串名字不要弄错了  ! ! !&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、为了方便让EFCore的CodeFirst在我们部署完，启动后就自动创建数据库，我们准备点种子数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DbInitializer
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Initialize(HDShopDbContext context)
        {
            context.Database.EnsureCreated();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (context.User.Any())
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; users = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; User(){Address=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,UserName =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1测试1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Password=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; User(){Address=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,UserName =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2测试2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Password=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; User(){Address=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,UserName =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3测试3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Password=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; User(){Address=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,UserName =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4测试4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Password=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; User(){Address=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,UserName =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5测试5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Password=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; User(){Address=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,UserName =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6测试6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Password=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            };
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; user &lt;span&gt;in&lt;/span&gt;&lt;span&gt; users)
            {
                context.Add(user);
            }
            context.SaveChanges();
        }
    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、编译运行，测试下本地运行是否成功。我这就不将我的测试结果展示出来了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、进入Linux服务器，下载好Git，通过配置好SSH公钥，在GitHub或是码云上做个记录。（我还是习惯用码云，毕竟汉字多 哈哈）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　Linux服务器上配置Gti的教程：&lt;a href=&quot;https://www.cnblogs.com/yolo-bean/p/7808767.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/yolo-bean/p/7808767.html&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、Linux服务器安装jexus，通过如下命令安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
curl https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jexus.org/release/x64/install.sh|sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　安装成功后会提示：OK, Jexus has been installed in /usr/jexus.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　至此，作为反向代理的jexus安装完毕，以前需要安装jexus+mono，现在最新版本的jexus已经将mono合并进去了，形成了现在的jexus独立版.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、安装.Net Core环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　我的建议是先查看开发环境的.Net Core SDK版本，不然如果服务器上的环境和开发环境存在版本差异的话会出现一些坑，比如我遇到的一个坑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Error:
  An assembly specified &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; the application dependencies manifest ({projectName}.deps.json) was not found:
    package: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Microsoft.AspNetCore.Antiforgery&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, version: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2.0.2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lib/netstandard2.0/Microsoft.AspNetCore.Antiforgery.dll&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  This assembly was expected to be &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the local runtime store &lt;span&gt;as&lt;/span&gt; the application was published &lt;span&gt;using&lt;/span&gt;&lt;span&gt; the following target manifest files:
    aspnetcore&lt;/span&gt;-store-&lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt;.xml
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;在我安装服务器的SDK的时候选择的是2.1.3版本,而我的开发环境是2.1.4版本,结果就出错了，弄了一阵子没搞好这个原因，同样就是这个原因，使得我从Git上pull下来的项目，虽然发布成功了，但是部署的话是不能够正常访问的，同时通过dotnet /xxx/xxx/xx.dll进行测试会一直出现这个错误。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最后通过干掉已有的版本，获得最新的版本，同样，我也在这里有个问题，貌似没得更新SDK版本的指令吧？我没有找到，抱歉，如有，请联系我，谢谢。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;通过命令，干掉旧版的CLI，同时下载新版的SDK搞定，成功运行起来了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rm -rf /usr/share/dotnet​ 删除旧版cli
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面是我的安装.Net Core的指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
1&lt;span&gt;、配置dotnet产品Feed&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo rpm &lt;/span&gt;--import https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/keys/microsoft.asc&lt;/span&gt;
sudo sh -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;echo -e &quot;[packages-microsoft-com-prod]&lt;/span&gt;
name=packages-microsoft-com-&lt;span&gt;prod 
baseurl&lt;/span&gt;= https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/yumrepos/microsoft-rhel7.3-prod&lt;/span&gt;
enabled=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgcheck&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgkey&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/keys/microsoft.asc&quot; &amp;gt; /etc/yum.repos.d/dotnetdev.repo'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、安装SDK，注意版本！！！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo yum update
sudo yum &lt;/span&gt;-&lt;span&gt;y install libunwind libicu
sudo yum install dotnet&lt;/span&gt;-sdk-&lt;span&gt;2.1&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;至此环境便已经搭建好了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过Git将码云或是Github上的项目Pull下来，最好现在服务器上指定好Git路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比如我的建立一个专门放置项目的文件夹，其中对每一个需要Clone到本地的项目建立一个文件夹，可以让我思路比较清晰。或许，你有更好的方式，也可以使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1133736/201802/1133736-20180203143516359-1059709779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过建立完毕运行指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone 你项目的SSH地址
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们可以利用其他dotnet的指令进行一些操作了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体需要什么指令可以通过dotnet --help进行获得&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看下文件夹中的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1133736/201802/1133736-20180203143926453-620427558.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以通过指令 &lt;strong&gt;dotnet run&lt;/strong&gt; 将项目进行启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1133736/201802/1133736-20180203144430359-10331707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此处会发现,我们不能干什么事情了，&lt;/p&gt;
&lt;p&gt;只能按&lt;strong&gt;Ctrl + C&lt;/strong&gt;让服务停下来，我们可以将当前这个程序作为后台程序运行，具体的操作就是&lt;strong&gt;Ctrl +Z&lt;/strong&gt;将服务暂停&lt;/p&gt;
&lt;p&gt;然后通过指令 &lt;strong&gt;bg &lt;/strong&gt;将其设为后台进程,如果想要进入已有的后台进程通过指令 &lt;strong&gt;fg&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们是只在命令行里操作的话，又看不到页面，又不能通过外网访问，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;又想要确保网站是否真的运行成功了，我们可以通过指令来查看网站的首页信息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 curl localhost:&lt;span&gt;65758&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将返回网站的html信息&lt;/p&gt;
&lt;p&gt;具体更多的linux下http指令请参照&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/wh211212/article/details/54285921&quot;&gt;http://blog.csdn.net/wh211212/article/details/54285921&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们可以发布了，通过指令 &lt;strong&gt;dotnet build&lt;/strong&gt;将项目再次编译一下&lt;/p&gt;
&lt;p&gt;然后通过 &lt;strong&gt;dotnet publish -o /xxxx/xxxx 将项目发布到指定文件夹&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接下来，可以开始配置jexus了.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 1、切换到Jexus配置文件目录&lt;/span&gt;
cd /usr/jexus/&lt;span&gt;siteconf
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 2、复制默认的配置文件为HDShop&lt;/span&gt;
cp &lt;span&gt;default&lt;/span&gt;&lt;span&gt; HDShop
vi HDShop

######################
# Web Site: HDShop
########################################
port&lt;/span&gt;=9527&lt;span&gt;
root&lt;/span&gt;=/ /&lt;span&gt;var&lt;/span&gt;/www/&lt;span&gt;HDShop
hosts&lt;/span&gt;= *    #OR your.com,*&lt;span&gt;.your.com

AppHost&lt;/span&gt;={CmdLine=dotnet /&lt;span&gt;var&lt;/span&gt;/www/HDShop/HDShop.dll;AppRoot=/&lt;span&gt;var&lt;/span&gt;/www/HDShop/;Port=&lt;span&gt;0&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;至此，需要的所有准备工作已经做好，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;通过jexus的命令来启动服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 如果已启动 Jexus：&lt;/span&gt;
sh /usr/jexus/&lt;span&gt;jws restart

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 如果未启动 Jexus：&lt;/span&gt;
sh /usr/jexus/jws start
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;jexus的命令大全可以参照：&lt;a href=&quot;http://blog.csdn.net/yang1982_0907/article/details/45155765&quot;&gt;http://blog.csdn.net/yang1982_0907/article/details/45155765&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;此时通过外网输入ip地址或域名(如果有的话)+端口(我写的不是默认80端口而是9527端口)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1133736/201802/1133736-20180203145607531-217791517.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网站正常启动，成功读到阿里云上那台数据库服务器的数据，同时也进行增删改成功了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此，尝试结束，其中还有许多的其他部分没有说明进来，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比如说Docker，我是使用了Docker的，但在写的部分中并没涉及Docker，因为我自己发现一些逻辑绕不过去，具体问题见下一章。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有也尝试了想要用图形界面操控Linux服务器并且远程操控，专门下了GNOME和TigerVNC,发现很卡，卡到心累，便不再使用，直接在命令行中进行所有工作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同时，对于Window下的项目怎么移动到Linux上，其实还有很多种方式，比如FTP等等，这个可以从度娘获知。我比较喜欢Git这种方式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;此次没有配合Docker容器一起使用，下一次将会带来Docker容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、引入Docker容器，实现服务部署于容器中，通过外网访问可以访问到Docker容器中的网站。&lt;/p&gt;
&lt;p&gt;2、项目还没有加入Dockerfile文件,此次都是通过手工去部署的，下一次将使用Dockerfile进行服务部署。&lt;/p&gt;
&lt;p&gt;3、域名绑定还没有尝试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是还有一些问题没有解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、jexus配合Docker使用使用，但是遇到点问题还需解决。&lt;/p&gt;
&lt;p&gt;　　比如：目前来讲，我将网站直接发布好了，那么我就不需要指令 &lt;strong&gt;dotnet run&lt;/strong&gt; 让其自运行自侦听了，那么全是依靠的jexus的代理。&lt;/p&gt;
&lt;p&gt;　　这么一来，Docker容器中运行服务那是什么意思呢？我暂时还不能理解。同时如果说Docker容器中运行网站，那么是由网站本身自侦听还是由容器中的jexus进行代理呢？&lt;/p&gt;
&lt;p&gt;2、端口映射问题，主机端口和Docker容器中端口映射问题。&lt;/p&gt;
&lt;p&gt;3、Docker容器间访问设置&lt;/p&gt;

&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;2018-2-3,望技术有成后能回来看见自己的脚步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Sat, 03 Feb 2018 07:18:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/8409563.html</dc:identifier>
</item>
<item>
<title>AM调制的FPGA实现 - HOOKNET</title>
<link>http://www.cnblogs.com/HOOKNET/p/8407749.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HOOKNET/p/8407749.html</guid>
<description>&lt;h2 id=&quot;一说明&quot;&gt;一、说明：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;功能：AM调制&lt;/li&gt;
&lt;li&gt;平台：Vivado 2016.4 和 Matlab R2017a&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二原理&quot;&gt;二、原理：&lt;/h2&gt;
&lt;h3 id=&quot;am调制原理&quot;&gt;1. AM调制原理&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;AM已调信号的时域表达式：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/29295862/35344947-5391bf16-0169-11e8-97c9-d8eedace8214.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;已调信号的频域表达式：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/29295862/35344965-5af1843a-0169-11e8-8404-a27227df6875.png&quot;/&gt;&lt;br/&gt;本质上AM调制就是频谱的搬移。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;AM调制的系统框图&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/29295862/35344973-5f419bc4-0169-11e8-9397-0813d525fd8b.png&quot;/&gt;&lt;br/&gt;将调制信号加上一个直流分量，保证信号的最小值大于零，然后再和载波相乘，得到已调信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三am调制的fpga实现&quot;&gt;三、AM调制的FPGA实现&lt;/h2&gt;
&lt;h3 id=&quot;产生调制信号和载波信号&quot;&gt;1.产生调制信号和载波信号&lt;/h3&gt;
&lt;p&gt;调用ROM IP核在FPGA内部产生两路余弦信号，其中一路信号用于模拟外部输入的调制信号，另一路用作载波信号。&lt;br/&gt;在配置ROM IP核之前，需要用Matlab生.coe文件，存放在ROM核里。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Matlab生成.coe文件：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;%---------------------------------%
width=8;       %设置rom的位宽
depth=1024;     %设置rom的深度
%---------------------------------%

x=linspace(0,2*pi,depth);       %在一个周期内产生depth个采样点
y_cos=cos(x);                   %生成余弦函数
%y_cos=sin(x);                   %生成正弦函数
%y_cos=round(y_cos*(2^(width-1)-1))+2^(width-1)-1;       %将数据转化成整数,生成无符号数
y_cos=round(y_cos*(2^(width-1)-1));       %将数据转化成整数,生成有符号数

plot(x,y_cos);                  %绘图

fid = fopen('E:\Workspace\DDS\Design\IP_Core\cos.coe','wt');

fprintf(fid,'memory_initialization_radix = 10;\nmemory_initialization_vector = ');
for i = 1 : depth
    if mod(i-1,8) == 0 
        fprintf(fid,'\n');
    end
    fprintf(fid,'%6d,',y_cos(i));
end

fclose(fid);                    %关闭文件
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成.coe文件后就可以进行IP核的配置了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ROM核具体配置：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/29295862/35349621-6e1186ac-0176-11e8-98e5-a1475ff60d50.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/29295862/35349629-739fdf24-0176-11e8-800e-aea80c15a60d.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/29295862/35349637-77da1834-0176-11e8-8b3a-e1ce6b8441a5.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/29295862/35349644-7c3bb8ec-0176-11e8-9acc-f9033ad57396.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置完IP核后，编写控制模块，产生两路信号。其中，调制信号上叠加的直流分量的大小为调制信号的峰值，这样将得到调制度为100%的已调信号。如果要得到不同的调制度，则需要叠加不同大小的直流分量，同时需要注意定义的数据位宽，防止数据溢出。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;产生载波和带有直流分量的调制信号：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;module cos_make(
    input   clk,
    input   rst_n,
    output  reg [7:0]   cos_s,
    output  reg signed  [7:0]   cos_c
);

//------------------------------------//
parameter freq_s = 32'd429497;          //调制信号频率10k
parameter freq_c = 32'd42949673;        //载波频率1M
parameter cnt_width = 8'd32;
//------------------------------------//

//------------------------------------//
reg     [cnt_width-1:0] cnt_s = 0;
reg     [cnt_width-1:0] cnt_c = 0;
wire    [9:0]   addr_s;
wire    [9:0]   addr_c;
always @(posedge clk or negedge rst_n) begin
    if(!rst_n)  begin
        cnt_s &amp;lt;= 0;
        cnt_c &amp;lt;= 0;
    end
    else    begin
        cnt_s &amp;lt;= cnt_s + freq_s;
        cnt_c &amp;lt;= cnt_c + freq_c;
    end
end

assign  addr_s = cnt_s[cnt_width-1:cnt_width-10];
assign  addr_c = cnt_c[cnt_width-1:cnt_width-10];
//------------------------------------//

//------------调用ROM核----------------//
wire    signed  [7:0]   cos_s_r;
wire    signed  [7:0]   cos_c_r;

ROM         ROM_inst(
    .clka   (clk),
    .addra  (addr_s),
    .douta  (cos_s_r),
    .clkb   (clk),
    .addrb  (addr_c),
    .doutb  (cos_c_r)
);

always @(posedge clk or negedge rst_n) begin
    if(!rst_n)  begin
        cos_s &amp;lt;= 0;
        cos_c &amp;lt;= 0;
    end
    else    begin
        cos_s &amp;lt;= cos_s_r + 8 'd128;     //加上大小为峰值的直流分量
        cos_c &amp;lt;= cos_c_r;
    end
end

endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生成am调制信号&quot;&gt;2.生成AM调制信号&lt;/h3&gt;
&lt;p&gt;得到两路信号后就可以用乘法器将两路信号相乘，得到已调信号。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module modulate(
    input       clk,
    input       rst_n,
    output  signed  [15:0]  AM_mod
);

wire    [7:0]   cos_s;
wire    signed  [7:0]   cos_c;

//------------调用出波模块------------//
cos_make        cos_make_inst0(
    .clk            (clk),
    .rst_n      (rst_n),
    .cos_s      (cos_s),
    .cos_c      (cos_c)
);
//-----------------------------------//

//------------调用乘法器--------------//
MULT        MULT_inst1(     
  .CLK  (clk),
  .A        (cos_s),
  .B        (cos_c),
  .P        (AM_mod)
);

endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;仿真调制结果&quot;&gt;3.仿真调制结果&lt;/h3&gt;
&lt;p&gt;以上AM调制过程基本完成，但是正确与否还需要通过仿真来确定，接下来编写仿真用的测试模块。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TestBeach的编写：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;`timescale 1ns/1ps

module tb_AM();

//---------接口设置----------//
reg     sclk;
reg     rst_n;
wire    signed  [15:0]  AM_mod;
//--------------------------//
initial     sclk = 1;
always  #5  sclk = ~sclk;       //100M时钟

initial begin
    rst_n = 0;
    #500
    rst_n = 1;
end
//--------------------------//
modulate        modulate_inst0(
    .clk        (sclk),
    .rst_n      (rst_n),
    .AM_mod     (AM_mod)
);

endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Vivado中将各个文件添加进工程后，运行仿真。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;仿真结果如下：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/29295862/35352112-d7de9514-017d-11e8-8bfc-bb974be7840c.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/29295862/35352115-da652410-017d-11e8-8d84-881a1c2af51f.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;已调信号能明显看到包络，并且包络的频率同调制信号一致，表明AM调制正确。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 07:14:00 +0000</pubDate>
<dc:creator>HOOKNET</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HOOKNET/p/8407749.html</dc:identifier>
</item>
<item>
<title>区块链简单研读笔记 - 叶小钗</title>
<link>http://www.cnblogs.com/yexiaochai/p/8409452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yexiaochai/p/8409452.html</guid>
<description>&lt;p&gt;有日子没发博客了，主要是现在离前端稍微有点远了，而其他方面都不是很深入，一时之间竟然发现自己没什么可以写的了&lt;/p&gt;
&lt;p&gt;现在个人角色有些改变，常常需要在技术层面给老板介绍一些时下比较火的事物，于是就需要对AI或者区块链做出一些研究，而到底用不用或者怎么用都不一定，这里将一些区块链的研究结果放出来，希望自己也逐渐开始重新写博客&lt;/p&gt;
&lt;p&gt;个人对区块链了解有限，知识基本来自网络（此文基本就是整理各种材料再加上自己一些理解产生），虽然此文产生的原因是因为要向老板汇报，还是想以此逐渐激励自己重新开始写博客，无论是什么吧......不写博客的日子感觉好虚&lt;/p&gt;
&lt;p&gt;PS：强调个人对区块链认识有限，文章带有个人倾向，如果有什么问题，请各位提出&lt;/p&gt;

&lt;p&gt;关于区块链相关的消息一点一点的进入我们眼前，其势大有之前AI之感，更有人称：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;区块链革命已经到来。这是一场顺之者昌，逆之者亡的伟大技术革命。它对传统的颠覆，将会比互联网、移动互联网来得更加迅猛、彻底。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——徐小平&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我这边对AI以及区块链皆保持了一定的关注。私以为不论区块链或者AI皆有可能成为下一个“互联网”技术，而互联网乃至后面的移动互联网技术带给我们的改变，如支付宝之与金融，如天猫之于商务、如微信之于社交，已经完全的改变了我们的生活方式，而与之来临的信息爆炸，相信足以让各位惊异，可以毫不夸张的说，互联网是颠覆性技术。&lt;/p&gt;
&lt;p&gt;为什么会有这样的说法呢？我们这里先为大家介绍一下令人癫狂，尤其令程序员癫狂的区块链技术的重要应用——比特币&lt;/p&gt;
&lt;div readability=&quot;38.43766864544&quot;&gt;
&lt;div readability=&quot;75.377765785213&quot;&gt;
&lt;div readability=&quot;8.4905660377358&quot;&gt;比特币诞生于2008年的一篇&lt;a title=&quot;https://bitcoin.org/en/bitcoin-paper&quot; href=&quot;https://bitcoin.org/en/bitcoin-paper&quot;&gt;文章&lt;/a&gt;，一个署名为中本聪的人，提出了革命性的构想：&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;让我们创造一种不受政府或其他任何人控制的货币！这个想法堪称疯狂：一串数字，背后没有任何资产支持，也没有任何人负责，你把它当作钱付给对方，怎么会有人愿意接受？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如今疯狂变成了现实，在全世界无数爱好者的支持下，比特币网络运行起来了，越来越多的资本参与，星星之火已成燎原。&lt;/p&gt;
&lt;p&gt;在17年我错过了最后一个一夜暴富的机会，比特币从年初的1000美元最高涨到了2万美元，全世界为之震惊，不管你我承认与否，比特币可能要开始改变世界了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS：我一同事10月在群里连续发了三次大红包，我收入600，原因是他套现了XXXX，这个钱拿得心头莫名&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;一个解释&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这里考虑到大家的接受程度，我们这里将技术一块抛开，这里尝试简单解释一下比特币：&lt;/p&gt;
&lt;p&gt;我们都知道，人民币是钱，美元是钱，金银财宝是钱。&lt;/p&gt;
&lt;p&gt;因为人们普遍相信（认同）它们的价值，其他东西的价值难以得到普通认同，无法成为钱。比如，邮票的价值就没有普遍的认同，除了集邮爱好者，其他地方都不能当钱用。一般来说，认同的人越多，这种钱的通用性就越高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;钱的本质，或者说货币的本质，就是它的可信性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;一样东西能否成为钱，只取决于人们是否相信它的价值，至于它是不是真的有价值，根本不重要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比特币要解决的核心问题，就是创造一种可信的数字凭证，而这个基础就是&lt;strong&gt;区块链技术，&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;区块链就是一个数据库，记载了所有的交易，用作中央记账系统。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;这里是一个详细的例子&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对于比特币来说，钱不是支付给个人的，而是支付给了某一把私钥，这个就是交易匿名的根本原因，因为没人知道私钥背后的主人是谁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以比特币交易第一件事就是拥有自己的公钥和私钥，我们去网上开户，就会为我们创建一个比特币钱包，这个钱包不会存放比特币，而是存放公钥与私钥，这个时候你向别人收钱的时候只需要告诉别人公钥即可（会生成一个链接）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS：公钥定义了钱包在哪，私钥定义了这个钱包是谁的，私钥绝不能丢，虽然区块链体系是安全的，但是你的电脑不是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而整个这些记录会像历史时间线一样保存下来，不能更改，这个也是其最具特色的地方，换个方式说，一个比特币现在在哪个钱包，经过了什么样的流程到达的这个钱包，全网所有人都是知道的，只不过大家不知道这个钱包是谁的&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;强调：区块链的作用就是把这些记录永久保存下来了，让任何人都可以查看，并且任何人都无法再修改。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;===陷阱===&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;另一方面，我们说区块链火爆，其实也只是我们这一类型人知道，更多的人是不知道的；&lt;/p&gt;
&lt;p&gt;区块链技术这里的火有点类似于2000年左右的互联网，看似火热其实泡沫不少，就现在而言，区块链项目层出不穷，但是真正有价值或者说有潜力的应用并没有几家&lt;/p&gt;
&lt;p&gt;比特币更多是击中了很多妄想一夜暴富（包括我）群众的心理，而这个疯狂还将持续下去，到后面是收割韭菜满地鸡毛，还是脱颖而出屹立不倒，我是无法判断的。&lt;/p&gt;
&lt;p&gt;最后，有可能竞争对手都希望我们去做区块链相关研究是因为：&lt;/p&gt;
&lt;p&gt;① 区块链&lt;strong&gt;&lt;span&gt;很贵&lt;/span&gt;&lt;/strong&gt;，可能我们就做跨了&lt;/p&gt;
&lt;p&gt;② 区块链应用得当，我们就不只是医疗界的巨头了&lt;/p&gt;
&lt;p&gt;对于他们而言，无论如何他们都将减少一个竞争对手&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们这里尝试来解释一下第二个问题：&lt;strong&gt;那些场景以前的解决方案是什么，有什么问题&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;为什么是区块链&lt;/h2&gt;
&lt;p&gt;第一，现在区块链成功的应用场景也只有比特币（也有其他号称成功的场景，但是不被市场认可），所以我们这里也只能以比特币为例说明问题，而这种代币本身就有一些特点，不能全部代表区块链。&lt;/p&gt;
&lt;p&gt;这里有一个核心的概念叫“&lt;strong&gt;去中心化&lt;/strong&gt;”，这个概念似乎很玄妙，我们这里先尝试解释这个去中心化&lt;/p&gt;
&lt;p&gt;我们熟悉的第一个去中心化的产品是BT下载，中心化下载是用户直接从网站下片，能不能下载都由网站控制，比如百度网盘就会刻意控制下载速度，逼迫我们去充会员；&lt;/p&gt;
&lt;p&gt;去中心化产品的下载方式是用户直接去其他用户那里下载，并且也上传给别人，在人多的时候速度快，就算第一个提供资源的人不在了，也不会影响整个事件进行，其他人依旧可以下片。这是一个互联网人对自由的追求表现。&lt;/p&gt;
&lt;p&gt;这里&lt;span&gt;第一个问题的答案&lt;/span&gt;就即将出现了：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比特币的出现是为了创造一种不受中心（政府）控制的货币&lt;/strong&gt;，而这个里面利益是及其庞大的，所以在我看来是：&lt;strong&gt;有了比特币这个需求，才出现的区块链这个技术&lt;/strong&gt;，就如我们有微信交流的需求，才出现了移动互联网的技术&lt;/p&gt;
&lt;p&gt;第一个问题的答案是：&lt;strong&gt;之前的技术是没有办法解决比特币的场景&lt;/strong&gt;。也可以说，在涌现“去中心化”、“自由世界货币”前，是没有人想到该这样做，正是因为比特币带来了&lt;strong&gt;&lt;span&gt;巨大的利益&lt;/span&gt;&lt;/strong&gt;后，各种各样的新奇场景（需求）就出现了&lt;/p&gt;
&lt;p&gt;这里各位可能觉得我在说废话，我这里赘述一句，没有微信的时候我们也有社交，也能获取各种信息，只不过我们需要更好的获取各种信息，所以产生了整个互联网，而当互联网成熟后，各种本来就具有的需求，会得到更好的实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以区块链（比特币）看似创新，其实是资源重组，实现原来已经有的需求的变形，再low一点，其实就是信息化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里再扩展一下，比特币的出现其实是具有一点“反社会”的特点的，正因为无法监管可能会出现混乱，我们知道自由是好的，但是完全不加控制的自由，未必就不会被有心人操弄，我们以为的自由只不过是假象，所以比特币要成为世界货币是很难很难，几乎不可能的。&lt;/p&gt;
&lt;div readability=&quot;45&quot;&gt;
&lt;p&gt;以美国为例，之前货币由美帝国中央银行统一管理，就会造成通货膨胀等后果，通货膨胀不可怕，可怕的是发行过程的不公平和不透明，而越是接近权利中心，越能最先拿到新的货币，埋单的往往是群众。由于利益的纠葛，如果中央银行控制的话，这种信息是不可能透明的。&lt;/p&gt;
&lt;h3&gt;一个例子&lt;/h3&gt;
&lt;p&gt;但是，比特币到底能不能解决这一问题呢，这里举一个&lt;strong&gt;&lt;span&gt;去中心化的&lt;/span&gt;&lt;/strong&gt;小故事说明问题：&lt;/p&gt;
&lt;p&gt;之前我们上班的时候会托同事帮忙照顾小孩，但是没人老是愿意“免费”帮人照顾，于是聪明人就想了个点子，在成员内部发行一种保姆券，每张对应一小时照看孩子服务，保姆券最开始数量是一定的，有成员会在闲暇时赚取保姆券，以备不时之需。&lt;/p&gt;
&lt;p&gt;这个制度看起来万无一失，但是马上就会有很多问题发生，会存在有人拼命照顾小孩&lt;span&gt;囤积保姆券&lt;/span&gt;的行为，但是保姆券数量却是一定的，没有保姆券的人就开始慌了，于是大家都开始囤积，这种囤积行为，不是因为我需要，而是因为我可能会需要，这个引起的后果是，大家都开始努力照看别人的小孩。&lt;/p&gt;
&lt;p&gt;但是同事的数量（小孩的数量）是固定的，保姆券只会越来越少，这个如果被当做一个简单经济体的话，保姆服务就是产出（GDP），那么这个就表示，经济开始衰退了，衰退的主要原因是在经济体内部的通货紧缩，保姆券数量不够！！！&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;现在我们再来看比特币，&lt;span&gt;比特币由于其设计特性，总量是固定的，在2140年达到2100w极限后，货币供给会停止&lt;/span&gt;（&lt;span&gt;所有程序都是人写的，这里存在调整空间&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;保姆券的特指是鼓励大家存钱，故事中的出现的问题，恐怕比特币都不能解决。&lt;/p&gt;
&lt;p&gt;克鲁格曼：“至少目前来说，买入比特币还是一笔好的投资。但是这并不说明这次实验成功了。我们建立一个货币制度的初衷不是使得那些持有货币的人变得富有，而是让交易变得便利，让整个经济体获益。而这些比特币都没能带给我们。”&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这里比特币的结论是：比特币的所谓交易便利、秘密、去中心化和防通胀，对于大部分人来说，基于现有法币系统的支付手段一直在提高便利性，如果不洗个钱的话秘密性好像也不是那么重要。&lt;/p&gt;
&lt;p&gt;所以比特币的意义可能是：&lt;strong&gt;&lt;span&gt;比特币已经成长为一个不怎么好的货币。纵使不好，但已经完全能履行货币的所有功能，比特币目前能非常方便地在世界各地兑换成当地货币。这在本质上就形成了比特币和政府发行的货币的一种竞争关系。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二个问题，为什么区块链技术可以解决信任问题 &lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;信任问题的解决&lt;/h3&gt;
&lt;p&gt;比特币的发展，不能评价其背后的区块链技术，区块链技术还是为了解决一个世界难题“信任”的问题&lt;/p&gt;
&lt;p&gt;区块链维护了一个共享的、公开的账本，这个账本不受任何组织控制，由分布式网络维护&lt;/p&gt;
&lt;p&gt;在区块链中所有的交易都有记录，网络中每个节点都拥有完整的副本，区块链还使用了一些机制（程序制度），调动了所有用户竞争性的记账（方法很暴力，就是给最快的人钱）&lt;/p&gt;
&lt;p&gt;全民记账的方式，使得系统没有第三方记账人，由于很多节点，也不会有记录丢失的问题，如果有欺诈，他的节点是无法跟众人同步的（除非他能篡改全网51%的记录）&lt;/p&gt;
&lt;p&gt;因此，区块链在技术层面解决了信任的问题&lt;/p&gt;
&lt;div readability=&quot;6.4761904761905&quot;&gt;这里如果要阐述技术层面的实现方式，我想大家是没有兴趣的，如果有兴趣，&lt;a title=&quot;http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html&quot; href=&quot;http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html&quot;&gt;这里有个科普文章&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;区块链公司的融资现状&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;区块链技术被普遍看好，相关公司皆已获得了大量的风险投资，资本的涌入无疑大大促进区块链产业的落地。数据显示，2013年各种区块链项目的融资金额总计超9000万美元，2014年3.6亿美元，2015年4.9亿美元。截至2016年9月中旬，2016年区块链行业的融资总额已达到4.2亿美元（&lt;/span&gt;&lt;strong&gt;&lt;span&gt;17年估计会是之前的总和还多&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然而，从企业发展周期来看，当前大部分的投融资还停留在天使轮和A轮、B轮融资阶段，预示着区块链相关公司还处于早期萌芽和摸索阶段，区块链从理论走向实践尚需较长一段时间，短期内很难有系统性成果出现。据高盛预计，在接下来的2年内可见到早期技术原型，2-5年后有机会见到有限度的市场应用，而5-10年内将会有更大范围的市场普及。&lt;/p&gt;
&lt;p&gt;就当前而言，大量区块链公司已相继涌现，区块链应用已初见端倪，主要集中于支付转账、交易所流程优化、资产确权、慈善等领域。&lt;/p&gt;
&lt;p&gt;引用材料：&lt;/p&gt;
&lt;p&gt;http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/37290469/answer/107612456&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/27687960/answer/84583016&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 06:45:00 +0000</pubDate>
<dc:creator>叶小钗</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yexiaochai/p/8409452.html</dc:identifier>
</item>
<item>
<title>jdk源码-&gt;多线程-&gt;Thread - unbelievableme</title>
<link>http://www.cnblogs.com/kundeg/p/8409199.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kundeg/p/8409199.html</guid>
<description>&lt;h2 id=&quot;线程的创建&quot;&gt;线程的创建&lt;/h2&gt;
&lt;p&gt;java提供了三种创建线程的方法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过继承 Thread 类本身；&lt;/li&gt;
&lt;li&gt;通过实现 Runnable 接口；&lt;/li&gt;
&lt;li&gt;通过 Callable 和 Future 创建线程。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;继承thread类&quot;&gt;继承Thread类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;继承Thread类&lt;/li&gt;
&lt;li&gt;重写run方法&lt;/li&gt;
&lt;li&gt;实例化该类，调用start方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;演示:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TestThread1{
    public static void main(String args[]){
        //3.实例化该类，调用start方法
        Thread1 t1 = new Thread1();
        t1.start();
        for(int i=0;i&amp;lt;=10;i++){
            System.out.println(&quot;cpu:MainThread&quot;);
        }
    }
}
//1.继承Thread类
class Thread1 extends Thread{
    //2.重写run()方法
    public void run(){
        for(int i=0;i&amp;lt;=10;i++){
            System.out.println(&quot;cpu:Thread1&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果不唯一，通过输出情况，说明确实新建了Thread1线程，因为出现了MainThread和Thread1抢占cpu的现象
cpu:Thread1
cpu:Thread1
cpu:Thread1
cpu:Thread1
cpu:Thread1
cpu:Thread1
cpu:Thread1
cpu:Thread1
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:Thread1
cpu:Thread1
cpu:Thread1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现runnable接口&quot;&gt;实现Runnable接口&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实现Runnable接口&lt;/li&gt;
&lt;li&gt;重写run方法&lt;/li&gt;
&lt;li&gt;将该类的实例作为参数实例化Thread类，调用调用start方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;演示：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TestThread2{
    public static void main(String args[]){
        Runnable1 r1 = new Runnable1();
        //3. 将该类的实例作为参数实例化Thread类，调用调用start方法
        Thread t = new Thread(r1);
        t.start();
        for(int i=0;i&amp;lt;10;i++){
            System.out.println(&quot;cpu:MainThread&quot;);
        }
    }
}
//1. 实现Runnable接口
class Runnable1 implements Runnable{
    //2. 重写run方法
    public void run(){
        for(int i=0;i&amp;lt;10;i++){
            System.out.println(&quot;cpu:Thread2&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cpu:Thread2
cpu:Thread2
cpu:Thread2
cpu:Thread2
cpu:Thread2
cpu:Thread2
cpu:Thread2
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:Thread2
cpu:Thread2
cpu:Thread2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;callable和future&quot;&gt;Callable和Future&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实现Callable接口&lt;/li&gt;
&lt;li&gt;重写call方法&lt;/li&gt;
&lt;li&gt;将该类的实例作为参数实例化FutureTask类&lt;/li&gt;
&lt;li&gt;将FutureTask对象作为参数实例化Thread，调用start方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;演示：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
//1. 实现Callable接口
class Callable1 implements Callable&amp;lt;String&amp;gt; {
    //2. 重写call方法
    public String call() throws Exception {
        for (int i = 0; i &amp;lt; 10; i++) {
            System.out.println(&quot;cpu:Thread3&quot;);
        }
        return &quot;hello world&quot;;
    }
}

public class TestThread3 { 
    public static void main(String[] args) {
        Callable1 c1 = new Callable1();
        //3. 将该类的实例作为参数实例化FutureTask类
        FutureTask&amp;lt;String&amp;gt; ft = new FutureTask&amp;lt;String&amp;gt;(c1);
        //4. 将FutureTask对象作为参数实例化Thread，调用start方法
        new Thread(ft, &quot;Callable1&quot;).start();
        for (int i = 0; i &amp;lt; 10; i++) {
            System.out.println(&quot;cpu:MainThread&quot;);
        }

        try {
            System.out.println(&quot;子线程返回值：&quot; + ft.get());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cpu:Thread3
cpu:Thread3
cpu:Thread3
cpu:Thread3
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:Thread3
cpu:Thread3
cpu:Thread3
cpu:Thread3
cpu:Thread3
cpu:Thread3
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
cpu:MainThread
子线程返回值：hello world&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;　三种创建线程的方法,都需要自定义线程的执行内容,并且线程启动执行的时候也是执行我们自定义的这段代码,为了实现这种功能，第一种创建线程的方法应用了java多态，后面两种应用了静态代理。&lt;br/&gt;　对于实现Runnable或者Callable接口和继承Thread类这三种开辟新线程的方法的选择应该优先选择实现Runnable或者Callable接口这种方式去开辟一个新的线程。因为接口的实现可以实现多个，而类的继承只能是单继承。因此在开辟新线程时能够使用Runnable或者Callable接口就尽量不要使用从Thread类继承的方式来开辟新的线程，而Runnable和Callable的区别在于后者有返回值。&lt;/p&gt;
&lt;h2 id=&quot;thread属性&quot;&gt;Thread属性&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;   private static native void registerNatives();
    static {
        registerNatives();
    }

    private volatile String name;  //线程的名称
    private int            priority; //线程的优先级
    private Thread         threadQ;  
    private long           eetop;  

    /* Whether or not to single_step this thread. */
    private boolean     single_step;

    //该线程是否是个守护线程
    private boolean     daemon = false;

    /* JVM state */
    private boolean     stillborn = false;

    /* What will be run. */
    private Runnable target;

    //该线程所在的线程组
    private ThreadGroup group;

    /* The context ClassLoader for this thread */
    private ClassLoader contextClassLoader;

    /* The inherited AccessControlContext of this thread */
    private AccessControlContext inheritedAccessControlContext;

    /* For autonumbering anonymous threads. */
    private static int threadInitNumber;
    private static synchronized int nextThreadNum() {
        return threadInitNumber++;
    }

    //ThreadLocal类中对应该线程的一个map
    ThreadLocal.ThreadLocalMap threadLocals = null;

    /*
     * InheritableThreadLocal values pertaining to this thread. This map is
     * maintained by the InheritableThreadLocal class.
     */
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;

    //线程栈的深度，默认是0
    private long stackSize;

    /*
     * JVM-private state that persists after native thread termination.
     */
    private long nativeParkEventPointer;

    //线程id
    private long tid;

    //静态全局变量，用来产生线程id
    private static long threadSeqNumber;

 
    //线程的状态
    private volatile int threadStatus = 0;


    private static synchronized long nextThreadID() {
        return ++threadSeqNumber;
    }

    /**
     * The argument supplied to the current call to
     * java.util.concurrent.locks.LockSupport.park.
     * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
     * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
     */
    volatile Object parkBlocker;

    /* The object in which this thread is blocked in an interruptible I/O
     * operation, if any.  The blocker's interrupt method should be invoked
     * after setting this thread's interrupt status.
     */
    private volatile Interruptible blocker;
    private final Object blockerLock = new Object();

    /* Set the blocker field; invoked via sun.misc.SharedSecrets from java.nio code
     */
    void blockedOn(Interruptible b) {
        synchronized (blockerLock) {
            blocker = b;
        }
    }

    //下面三个是不同优先级指定
    public final static int MIN_PRIORITY = 1;
    public final static int NORM_PRIORITY = 5;
    public final static int MAX_PRIORITY = 10;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;thread类常用方法&quot;&gt;Thread类常用方法&lt;/h2&gt;
&lt;h3 id=&quot;init&quot;&gt;init()&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //new Thread()本质是调用该方法
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc,
                      boolean inheritThreadLocals) {
        if (name == null) {
            throw new NullPointerException(&quot;name cannot be null&quot;);
        }
        this.name = name;//线程名
        Thread parent = currentThread();//parent是创建该线程的线程引用
        //？？
        SecurityManager security = System.getSecurityManager();
        if (g == null) {//没有指定线程组
            //？？
            if (security != null) {
                g = security.getThreadGroup();
            }
            //继承其parent的线程组
            if (g == null) {
                g = parent.getThreadGroup();
            }
        }
        //？？
        g.checkAccess();

        //？？
        if (security != null) {
            if (isCCLOverridden(getClass())) {
                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
            }
        }
        //线程组中未启动线程count+1
        g.addUnstarted();
        this.group = g; //初始化线程组
        this.daemon = parent.isDaemon(); //继承parent的daemon属性
        this.priority = parent.getPriority(); //继承parent的优先级
        //？？
        if (security == null || isCCLOverridden(parent.getClass()))
            this.contextClassLoader = parent.getContextClassLoader();
        else
            this.contextClassLoader = parent.contextClassLoader;
        this.inheritedAccessControlContext =
                acc != null ? acc : AccessController.getContext();
        this.target = target;//初始化Runnable target
        setPriority(priority);//设置线程优先级
        //？？
        if (inheritThreadLocals &amp;amp;&amp;amp; parent.inheritableThreadLocals != null)
            this.inheritableThreadLocals =
                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
        this.stackSize = stackSize; //初始化栈的深度
        tid = nextThreadID(); //初始化线程Id
    }

//currentThread是一个本地方法
        public static native Thread currentThread();
//nextThreadID()方法，是线程安全的
        private static synchronized long nextThreadID() {
        return ++threadSeqNumber;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;start&quot;&gt;start()&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//vm在创建main线程和系统线程的时候不会调用start方法
public synchronized void start() {
        //threadStatus!=0说明该线程已经start过了，不允许两次start，抛出异常
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
        //将该线程添加到线程组中表示该线程将要被启动
        group.add(this);
        boolean started = false;
        try {
            //核心方法
            start0();
            started = true;
        } finally {
            try {
                //如果线程启动失败，线程组中删除该线程
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
            }
        }
    }
//start0是本地方法
    private native void start0();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;run&quot;&gt;run()&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //run函数是线程执行的主体
    public void run() {
        //Runnable target
        if (target != null) {
            target.run();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过前面分析的创建线程的不同方法，run函数的执行过程分为两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;继承Thread，重写run函数，利用java多态，线程执行Thread子类的run函数&lt;/li&gt;
&lt;li&gt;实现Runnable接口,重写run函数,初始化Thread对象的target属性,执行Thread类里的run函数&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;sleeplong&quot;&gt;sleep(long)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //当前的线程休眠millis时长，在此期间依然拥有锁(monitor)
    public static native void sleep(long millis) throws InterruptedException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    &lt;strong&gt;举例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Main extends Thread {
    static int number = 10;

    public void firstMethod() throws Exception {
        synchronized (this) {
            number += 100;
            System.out.println(number);
        }
    }

    public synchronized void secondMethod() throws Exception {
        Thread.sleep(2000);//主线程休眠两秒，但仍然拥有m对象的锁
        number *= 200;
    }

    public void run() {
        try {
            firstMethod();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception {
        Main m = new Main();
        m.secondMethod();
        m.start();
    }
}

结果：
两秒之后输出：2100&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;yield&quot;&gt;yield()&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //当前线程放弃cpu使用权，进入就绪状态，重新与优先级的线程共同竞争cpu
    public static native void yield();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    &lt;strong&gt;举例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Main extends Thread {

    @Override
    public void run() {
        long beginTime = System.currentTimeMillis();
        int count = 0;
        for (int i = 0; i &amp;lt; 50000; i++) {
            Thread.yield();         // 注释该语句，执行变得很快
            ++count;
        }
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;用时：&quot; + (endTime - beginTime) + &quot;毫秒！&quot;);
    }

    public static void main(String[] args) {
        Main thread = new Main();
        thread.start();
    }
}
//结果时间差间接表明:线程执行期间放弃cpu再重新获取cpu的过程
结果：
没有注释：用时：41毫秒！
添加注释：用时：1毫秒！&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;joinlong&quot;&gt;join(long)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //synchronized关键字:执行到join方法的线程要拥有内置锁,这也是该方法中可以调用wait的原因
    public final synchronized void join(long millis)
    throws InterruptedException {
        //记住当前时间
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis &amp;lt; 0) {
            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
        }
        //即join()的执行情况
        if (millis == 0) {
            //isAlive()是判断调用join方法的对象线程是否存活，例如:m.join(),是判断m是否存活
            while (isAlive()) {
                //进入内置锁的wait队列
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                //等待millis时长之后退出
                if (delay &amp;lt;= 0) {
                    break;
                }
                //等待delay时长
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    &lt;strong&gt;举例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Thread1 extends Thread {
    public static void main(String[] args)  {
        System.out.println(&quot;进入线程&quot; + Thread.currentThread().getName());
        Thread1 t1 = new Thread1();
        t1.start();
        try {
            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;等待&quot;);
            t1.join(1000);//Main线程进入t1内置锁的wait队列等待1000ms,在此期间执行t1线程
            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void run() {
        System.out.println(&quot;进入线程&quot; + Thread.currentThread().getName());
        try {
            Thread.currentThread().sleep(2000);//t1线程休眠2000ms
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;);
    }
}

结果(稳定)：
进入线程main
线程main等待
进入线程Thread-0
线程main执行完毕       
线程Thread-0执行完毕&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：线程A执行过程中调用线程B的join(long mills)方法，线程A获得线程B的内置锁之后进入线程B的wait队列中等待mills时长(期间释放锁)，线程B执行，如果在线程A等待期间，线程B执行完毕会notify线程A(在代码中没有体现，但是在底层结束线程的时候会有这个操作)，因此线程的等待时间有可能小于mills&lt;br/&gt;如果理解了join方法,下面一道面试题就迎刃而解了:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //题目:三个线程t1,t2,t3，如何保证执行顺序为ti，t2，t3
       public class Thread1 {
            public static void main(String[] args) {
                method01();
            }

            private static void method01() {
               final Thread t1 = new Thread(new Runnable() {
                    @Override
                    public void run() {
                        System.out.println(&quot;t1 is finished&quot;);
                    }
                });
                final Thread t2 = new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            t1.join();//如果t2先于t1执行,t2进入t1内置锁的wait队列，等待t1执行完毕
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(&quot;t2 is finished&quot;);
                    }
                });
                Thread t3 = new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            t2.join();//如果t3先于t2执行,t3进入t2内置锁的wait队列，等待t2执行完毕
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(&quot;t3 is finished&quot;);
                    }
                });

                t3.start();
                t2.start();
                t1.start();
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考资料：&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/xdp-gacl/p/3633936.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xdp-gacl/p/3633936.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/81a56497e073&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/81a56497e073&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/justloveyou_/article/details/54347954&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/justloveyou_/article/details/54347954&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/ll666634/article/details/78615505&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/ll666634/article/details/78615505&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://wangchangchung.github.io/2016/12/05/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/&quot;&gt;https://wangchangchung.github.io/2016/12/05/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94Thread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 06:21:00 +0000</pubDate>
<dc:creator>unbelievableme</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kundeg/p/8409199.html</dc:identifier>
</item>
<item>
<title>Tomcat(三)：tomcat处理连接的详细过程 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8408670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8408670.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8408670.html#blog1&quot;&gt;&lt;span&gt;1. Tomcat组件体系结构&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8408670.html#blog2&quot;&gt;&lt;span&gt;2. Tomcat和httpd/nginx在监听和处理请求上的区别&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8408670.html#blog2.1&quot;&gt;&lt;span&gt;2.1 Tomcat如何处理并发请求&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8408670.html#blog3&quot;&gt;&lt;span&gt;3. Tomcat处理jsp动态资源的过程&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8408670.html#blog4&quot;&gt;&lt;span&gt;4. Tomcat处理静态资源的过程&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;tomcat可以处理静态资源的请求，也可以通过servlet处理动态资源的请求。处理jsp动态资源时，先通过jasper组件(具体的是JspServlet)将jsp翻译成java源代码并编译成class后运行。需要知道的是，静态资源也一样是通过servlet处理的，只不过它使用的servlet是定义在$catalina_home/conf/web.xml中默认的servlet。本文将详细分析tomcat如何处理客户端请求(并发)以及如何处理动、静态资源。&lt;/p&gt;

&lt;h2 id=&quot;1-tomcat-&quot;&gt;1.Tomcat组件体系结构&lt;/h2&gt;
&lt;p&gt;如下两图：上面的图是tomcat组件体系的简图，下面的图是Service组件细化后的图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201801/733013-20180124210257803-102897279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180203101937937-1936575013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;server&lt;/code&gt;组件是管理tomcat实例的组件，可以监听一个端口，从此端口上可以远程向该实例发送shutdown关闭命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;service&lt;/code&gt;组件是一个逻辑组件，用于绑定connector和container，有了service表示可以向外提供服务，就像是一般的daemon类服务的service。可以认为一个service就启动一个JVM，更严格地说，一个engine组件才对应一个JVM(定义负载均衡时，jvmRoute就定义在Engine组件上用来标识这个JVM)，只不过connector也工作在JVM中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connector&lt;/code&gt;组件是&lt;strong&gt;监听&lt;/strong&gt;组件，它有四个作用：
&lt;ul&gt;&lt;li&gt;(1).&lt;span&gt;&lt;strong&gt;开启监听套接字，监听外界请求，并建立TCP连接;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;(2).使用protocolHandler解析请求中的协议和端口等信息，如http协议、AJP协议;&lt;/li&gt;
&lt;li&gt;(3).根据解析到的信息，使用processer将请求数据转发给绑定的Engine;&lt;/li&gt;
&lt;li&gt;(4).接收响应数据并返回给客户端。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;container&lt;/code&gt;是容器，它是一类组件，在配置文件(如server.xml)中没有体现出来。它包含4个容器类组件：engine容器、host容器、context容器和wrapper容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;engine&lt;/code&gt;容器用于从connector组件处接收转发过来的请求，然后按照分析的结果将相关参数传递给匹配出的虚拟主机。engine还用于指定默认的虚拟主机。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;host&lt;/code&gt;容器定义虚拟主机，由于tomcat主要是作为servlet容器的，所以为每个webapp指定了它们的根目录appBase。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;context&lt;/code&gt;容器主要是根据path和docBase获取一些信息，将结果交给其内的wrapper组件进行处理(它提供wrapper运行的环境，所以它叫上下文context)。一般来说，都采用默认的标准wrapper类，因此在context容器中几乎不会出现wrapper组件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wrapper&lt;/code&gt;容器对应servlet的处理过程。它开启servlet的生命周期，根据context给出的信息以及解析web.xml中的映射关系，负责装载相关的类，初始化servlet对象init()、执行servlet代码service()以及服务结束时servlet对象的销毁destory()。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;executor&lt;/code&gt;组件为每个Service组件提供线程池，使得Engine可以从线程池中获取线程处理请求，从而实现tomcat的并发处理能力。&lt;span&gt;&lt;strong&gt;一定要注意，Executor的线程池大小是为Engine组件设置，而不是为Connector设置的，Connector的线程数量由Connector组件的acceptorThreadCount属性来设置&lt;/strong&gt;&lt;/span&gt;。如果要在配置文件中设置该组件，则必须设置在Connector组件的前面，以便在Connector组件中使用&lt;code&gt;executor&lt;/code&gt;属性来引用配置好的Executor组件。如果不显式设置，则采用Connector组件上的默认配置，默认配置如下：
&lt;ul&gt;&lt;li&gt;(1).maxThreads：最大线程数，默认值200。&lt;/li&gt;
&lt;li&gt;(2).minSpareThreads：最小空闲线程数，默认值25。&lt;/li&gt;
&lt;li&gt;(3).maxIdleTime：空闲线程的线程空闲多长时间才会销毁，默认值60000即1分钟。&lt;/li&gt;
&lt;li&gt;(4).prestartminSpareThreads：是否启动executor时就直接创建等于最小空闲线程数的线程，默认值为false，即只在有连接请求进入时才会创建。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;根据上面描述的tomcat组件体系结构，处理请求的大致过程其实很容易推导出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;Client(request)--&amp;gt;Connector--&amp;gt;Engine--&amp;gt;Host--&amp;gt;Context--&amp;gt;Wrapper(response data)--&amp;gt;Connector(response header)--&amp;gt;Client
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;2-tomcat-httpd-nginx-&quot;&gt;2.Tomcat和httpd/nginx在监听和处理请求上的区别&lt;/h2&gt;
&lt;p&gt;在监听和处理请求上，tomcat和httpd/nginx等服务程序不一样，而且是巨大的区别。因此，在理解处理请求时，万万不可将httpd/nginx的处理模式套在tomcat上。&lt;/p&gt;
&lt;p&gt;关于httpd/nginx等服务程序处理连接时的过程，此处仅简单说明以体现它们和tomcat的不同之处，详细内容可参见我另一篇文章：&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7623252.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;不可不知的socket和TCP连接过程&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;(1).httpd/nginx等都是监听进程/线程负责监听，当监听到连接请求时，将生成一个新的&lt;code&gt;已连接套接字&lt;/code&gt;放进一个称为已连接队列中，然后监听进程/线程继续回去监听。而负责处理请求的共作进程/线程则从该队列中获取&lt;code&gt;已连接套接字&lt;/code&gt;并与客户端建立TCP连接，然后与客户端进行通信，包括接收客户端的资源请求数据、构建和响应数据给客户端。&lt;/p&gt;
&lt;p&gt;(2).tomcat虽然也将监听和处理请求的工作分别使用不同的组件进行处理，但connector线程监听到请求就直接建立TCP连接，并一直与客户端保持该连接。connector线程会分析请求并将结果转发给与之绑定的Engine组件，Engine线程负责处理请求以及构建响应数据，但Engine组件不会和客户端建立任何连接。&lt;span&gt;&lt;strong&gt;Engine的一切数据来源都是Connector，客户端任何一次资源请求都会发送到connector上，并从connector转发给Engine&lt;/strong&gt;&lt;/span&gt;。Engine构建响应后，再次将响应数据转发给Connector，并由Connector做一些处理(如加上首部字段)回复给客户端。&lt;/p&gt;
&lt;p&gt;只要明确一点即可推导出tomcat的连接和请求处理机制：&lt;span&gt;&lt;strong&gt;任何一次从外界流入的请求都必将经过connector，任何一次从本地流出的响应数据也都必将经过connector&lt;/strong&gt;&lt;/span&gt;。这正是连接器的意义所在──连接客户端和服务端servlet。&lt;/p&gt;

&lt;h2 id=&quot;2-1-tomcat-&quot;&gt;2.1 tomcat如何处理并发请求&lt;/h2&gt;
&lt;p&gt;connector组件支持4种IO协议类型：同步阻塞BIO、同步非阻塞NIO、异步非阻塞NIO2、apache基金会提供的IO模型APR(IO模型只是APR类库的其中一种功能模块)。它们的区别如下图所示，除了BIO，其他IO模型在接受新请求上都是非阻塞的，因此这里不考虑BIO，而且现在也不会有人将connector设置成BIO模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201801/733013-20180125093335428-860416836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该表中，最需要关注的是&quot;Wait for next Request&quot;行，NIO/NIO2/APR都是Non Blocking，这表示正在处理某个请求时不会被阻塞，可以接收额外的请求，这是tomcat实现并发处理请求的关键。&lt;/p&gt;
&lt;p&gt;再来看connector组件和并发数量有关的设置选项：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;acceptorThreadCount&lt;/code&gt;：用于&lt;span&gt;&lt;strong&gt;接收连接请求的线程数&lt;/strong&gt;&lt;/span&gt;。默认值为1。多核CPU系统应该增大该值，另外由于长连接的存在，也应该考虑增大该值。&lt;br/&gt;&lt;code&gt;maxThreads&lt;/code&gt;：线程池中最多允许存在多少线程用于&lt;span&gt;&lt;strong&gt;处理请求&lt;/strong&gt;&lt;/span&gt;。默认值为200。它是最大并发处理的数量，但不影响接收线程接收更多的连接。&lt;br/&gt;&lt;code&gt;maxConnections&lt;/code&gt;：服务端允许接收和处理的最大连接数。当达到该值后，操作系统还能继续接收额外acceptCount个的连接请求，但这些连接暂时不会被处理。当Connector类型为BIO模型时的默认值等于maxThread的值，当为NIO/NIO2模型时的默认值为10000，当APR时默认长度为8192。&lt;br/&gt;&lt;code&gt;acceptCount&lt;/code&gt;：当所有请求处理线程都处于忙碌状态时，连接请求将进入等待队列，该值设置等待队列的长度。当达到队列最大值后，如果还有新连接请求进入，则会被拒绝。默认队列长度为100。&lt;/p&gt;
&lt;p&gt;从上面几个属性的意义来分析并发机制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1).connector中最多有acceptorThreadCount个专门负责监听、接收连接请求并建立TCP连接的线程，这些线程是非阻塞的(不考虑BIO)。当和某客户端建立TCP连接后，可以继续去监听或者将Engine返回的数据发送给客户端或者处理其它事情。&lt;/li&gt;
&lt;li&gt;(2).线程池中的最大线程数maxThreads决定了某一刻允许处理的最大并发请求数，这是专门负责处理connector转发过来的请求的线程，可以认为这些线程专门是为Engine组件服务的(因此我将其称之为Engine线程)。注意，maxThreads决定的是&lt;strong&gt;某一刻&lt;/strong&gt;的最大并发处理能力，但不意味着maxThreads数量的线程只能处理maxThreads数量的请求，因为这些Engine线程也是非阻塞的，当处理某个请求时出现IO等待时，它不会阻塞，而是继续处理其它请求。也就是说，每个请求都占用一个Engine线程直到该客户端的所有请求处理完毕，但每个Engine线程可以处理多个请求。同时还能推测出，每个connector线程可以和多个Engine线程绑定(connector线程的数量远少于Engine线程的数量)。&lt;/li&gt;
&lt;li&gt;(3).当并发请求数量逐渐增多，tomcat处理能力的极限由maxConnector决定，这个值是由maxThreads和acceptorThreadCount以及非阻塞特性同时决定的。由于非阻塞特性，无论是connector线程还是Engine线程，都能不断接收、处理新请求。它的默认值看上去很大(10000或8192)，但分配到每个线程上的数量并不大。假设不考虑监听线程对数量的影响，仅从处理线程上来看，10000个连接分配给200个处理线程，每个处理线程可以轮询处理50个请求。和nginx默认的一个worker线程允许1024个连接相比，已经很少了，当然，因为架构模型不一样，它们没有可比性。&lt;/li&gt;
&lt;li&gt;(4).当并发请求数量继续增大，tomcat还能继续接收acceptCount个请求，但不会去建立连接，所以也不会去处理。实际上，这些请求不是tomcat接收的，而是操作系统接收的，接收后放入到由Connector创建的队列中，当tomcat有线程可以处理新的请求了再去队列中取出并处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再来细分一下tomcat和httpd/nginx的不同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1).&lt;span&gt;&lt;strong&gt;httpd/nginx的监听者只负责监听和产生&lt;code&gt;已连接套接字&lt;/code&gt;，不会和客户端直接建立TCP连接。而tomcat的监听者connector线程不仅会监听，还会直接建立TCP连接，且一直处于ESTABLISHED状态直到close&lt;/strong&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;(2).&lt;span&gt;&lt;strong&gt;httpd/nginx的工作进程/线程首先从已连接套接字队列中获取已连接套接字，并与客户端建立TCP连接，然后和客户端通信兵处理请求、响应数据。而tomcat的工作线程(Engine线程)只接受来自connector转发过来的请求，处理完毕后还会将响应数据转发回connector线程，由connector将响应数据传输给客户端(和客户端的所有通信数据都必须经过连接器connector来传输)&lt;/strong&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;(3).不难推断出，一个Connector线程可以和多个客户端建立TCP连接，也可以和多个Engine线程建立绑定关系，而一个Engine线程可以处理多个请求。如果不理解并发处理机制，这一点很容易被&quot;Connector组件和Engine组件绑定在一起组成Service组件&quot;这句话误导。这句话的意思并不是要求它们1:1对应，就像httpd/nginx也一样，一个监听者可能对应多个工作者。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，tomcat处理连接的过程如下图所示，其中我把Engine线程处理请求的过程用&quot;Engine+N&quot;来表示，例如Engine线程1下的Engine1表示该Engine线程处理的某个请求，Engine2表示该线程处理的另一个请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180202193226031-1822875245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-tomcat-jsp-&quot;&gt;3.Tomcat处理jsp动态资源的过程&lt;/h2&gt;
&lt;p&gt;假设tomcat的配置如下，其中项目名称为&quot;xiaofang&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Connector&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;connectionTimeout&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;20000&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;port&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;8080&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;protocol&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;HTTP/1.1&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;redirectPort&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;8443&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Engine&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;Catalina&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;defaultHost&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;localhost&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Host&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;www.xiaofang.com&quot;&lt;/span&gt;  &lt;span class=&quot;hljs-attribute&quot;&gt;appBase&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;webapps/xiaofang&quot;&lt;/span&gt;
          &lt;span class=&quot;hljs-attribute&quot;&gt;unpackWARs&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;autoDeploy&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;path&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;docBase&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;reloadable&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;path&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;/xuexi&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;docBase&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;xuexi&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;reloadable&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Host&lt;/span&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Host&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;localhost&quot;&lt;/span&gt;  &lt;span class=&quot;hljs-attribute&quot;&gt;appBase&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;webapps&quot;&lt;/span&gt;
          &lt;span class=&quot;hljs-attribute&quot;&gt;unpackWARs&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;autoDeploy&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Host&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Engine&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当客户端访问&lt;code&gt;http://www.xiaofang.com:8080/xuexi/abc.jsp&lt;/code&gt;时，其请求的是$CATALINA_HOME/webapps/xiaofang/xuexi/abc.jsp文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1).Connector组件扮演的角色。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Connector组件首先监听到该请求，于是建立TCP连接，并分析该请求。Connector分析请求的内容包括请求的协议、端口、参数等。因为这里没考虑集群问题，因此只可能是http协议而不可能是ajp协议的请求。分析后，将请求和相关参数转发给关联的Engine组件进行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2).Engine组件扮演的角色。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Engine组件主要用于将请求分配到匹配成功的虚拟主机上，如果没有能匹配成功的，则分配到默认虚拟主机上。对于上面的请求，很显然将分配到虚拟主机&lt;code&gt;www.xiaofang.com&lt;/code&gt;上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3).Host组件扮演的角色。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Host组件收到Engine传递过来的请求参数后，将对请求中的uri与Context中的path进行匹配，如果和某个Context匹配成功，则将请求交给该Context处理。如果匹配失败，则交给&lt;code&gt;path=&quot;&quot;&lt;/code&gt;对应的Context来处理。所以，根据匹配结果，上面的请求将交给&lt;code&gt;&amp;lt;Context path=&quot;/xuexi&quot; docBase=&quot;xuexi&quot; /&amp;gt;&lt;/code&gt;进行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意，这次的uri匹配是根据path进行的匹配，它是目录匹配，不是文件匹配&lt;/span&gt;。&lt;/strong&gt;也就是说，只匹配到uri中的xuexi就结束匹配。之所以要明确说明这一点，是因为后面还有一次文件匹配，用于决定交给哪个Servlet来处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4).Context和Wrapper组件扮演的角色。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到了这里，就算真正到了Servlet程序运行的地方了，相比于前面几个组件，这里的过程也更复杂一些。&lt;/p&gt;
&lt;p&gt;请求&lt;code&gt;http://www.xiaofang.com:8080/xuexi/abc.jsp&lt;/code&gt;经过Host的uri匹配后，分配给&lt;code&gt;&amp;lt;Context path=&quot;/xuexi&quot; docBase=&quot;xuexi&quot; /&amp;gt;&lt;/code&gt;进行处理，此时已经匹配了url中的目录，剩下的是abc.jsp。abc.jsp也需要匹配，但这个匹配是根据web.xml中的配置进行匹配的。&lt;/p&gt;
&lt;p&gt;首先，从项目名为xiaofang的私有web.xml中进行查找，即webapps/xiaofang/WEB-INF/web.xml。由于此处仅为简单测试，因此并没有该文件。&lt;/p&gt;
&lt;p&gt;于是从全局web.xml即$CATALINA_HOME/conf/web.xml中匹配abc.jsp。以下是web.xml中能匹配到该文件名的配置部分。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;jsp&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;*.jsp&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;*.jspx&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;jsp&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.jasper.servlet.JspServlet&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先根据&lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/code&gt;中的url-pattern进行&lt;span&gt;&lt;strong&gt;文件匹配&lt;/strong&gt;&lt;/span&gt;，发现该url匹配的是servlet-name为&quot;jsp&quot;的servlet，然后再找到与该名称对应的&lt;code&gt;&amp;lt;servlet&amp;gt;&lt;/code&gt;标签段，发现处理该动态资源的类为&lt;code&gt;org.apache.jasper.servlet.JspServlet&lt;/code&gt;，于是找到该类对应的class文件，该class文件归档在$catalina_home/lib/jasper.jar中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180203001602437-1383432706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JspServlet程序的作用是将jsp文件翻译成java源代码文件，并放在$catalina_home/work目录下。然后将该java源文件进行编译，编译后的class文件也放在work目录下。这个class文件就是abc.jsp最终要执行的servlet小程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; ~]
index_jsp.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;  index_jsp.java  new&lt;span class=&quot;hljs-number&quot;&gt;_&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在翻译后的servlet小程序中，不仅会输出业务逻辑所需的数据，还会输出html/css代码，这样一来，客户端接收到的数据都将是排版好的。&lt;/p&gt;

&lt;h2 id=&quot;4-tomcat-&quot;&gt;4.Tomcat处理静态资源的过程&lt;/h2&gt;
&lt;p&gt;对于tomcat来说，无论是动态还是静态资源，都是经过servlet处理的。只不过处理静态资源的servlet是默认的servlet而已。&lt;/p&gt;
&lt;p&gt;在$catalina_home/conf/web.xml中关于静态资源处理的配置如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;default&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;/&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;default&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.catalina.servlets.DefaultServlet&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要记住的是，&lt;span&gt;&lt;strong&gt;web.xml中的url-pattern是文件匹配，而server.xml中的&lt;code&gt;&amp;lt;Context path=&quot;URL-PATTERN&quot; /&amp;gt;&lt;/code&gt;是目录匹配。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面web.xml中的&lt;code&gt;&amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;&lt;/code&gt;表示的是默认servlet。这意味着，当web.xml中没有servlet-mapping能匹配请求url中的路径时，将匹配servlet-name，即名为default的servlet。然后找到处理default的类为&lt;code&gt;org.apache.catalina.servlets.DefaultServlet&lt;/code&gt;，该类的class文件归档在$catalina_home/lib/catalina.jar中。该servlet不像JspServlet会翻译jsp文件，它只有最基本的作用：原样输出请求文件中的内容给客户端。&lt;/p&gt;
&lt;p&gt;例如，根据前面的配置，下面几个请求都将采用默认servlet进行处理，即当作静态资源处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http:
http:
http:
http:
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但&lt;code&gt;http://www.xiaofang.com:8080/xuexi&lt;/code&gt;则不一定，因为tomcat中默认的index文件包含index.jsp和index.html，而index.jsp排在index.html的前面，只有不存在index.jsp时才请求index.html。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8408670.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8408670.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 01:51:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8408670.html</dc:identifier>
</item>
<item>
<title>Storm Topology Parallelism - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/8407078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/8407078.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;what-makes-a-running-topology-worker-processes-executors-and-tasks&quot;&gt;What makes a running topology: worker processes, executors and tasks&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在一个Strom集群中，实际运行一个topology有三个主要的实体&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Worker processes&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Executors (threads)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Tasks&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面是一张草图简单说明他们之间的关系：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180202200207593-1592191189.png&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;260&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A &lt;em&gt;worker process&lt;/em&gt; executes a subset of a topology.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个worker进程属于一个特定的topology并且可能运行一个或者多个executors&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个运行中的topology由运行在集群中的许多机器上的这样的进程组成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个executor是被一个worker进程启动的一个线程。它可能运行一个或多个任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个task执行实际的数据处理——在你的代码中实现的每一个spout或bolt执行许多任务。一个组件的任务数量总是不变的，这是自始至终贯穿整个topology的，但是一个组件的executors(threads)的数量是可以随时改变的。也就是说，下面这个表达式总是true：&lt;strong&gt;&lt;span&gt;#threads ≤ #tasks。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;默认情况下，task的数量和executor的数量是相等的，也就是说每个线程运行一个任务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;configuring-the-parallelism-of-a-topology&quot;&gt;Configuring the parallelism of a topology&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;注意，Storm中的术语&quot;parallelism&quot;也被叫做parallelism hint，表示一个组件初始的executor(threads)数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这篇文档中我们将用&quot;parallelism&quot;来描述怎样配置executor的数量，怎样配置worker进程的数量，以及task的数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置的方式有多种，它们之间的优先级顺序为：&lt;code&gt;defaults.yaml&lt;/code&gt; &amp;lt; &lt;code&gt;storm.yaml&lt;/code&gt; &amp;lt; topology-specific configuration &amp;lt; internal component-specific configuration &amp;lt; external component-specific configuration&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180202202834187-1416605895.png&quot; alt=&quot;&quot; width=&quot;690&quot; height=&quot;398&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是一个例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180202202956281-1005522146.png&quot; alt=&quot;&quot; width=&quot;391&quot; height=&quot;60&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面这段代码片段配置了一个叫green-bolt的Bolt，初始数量为2个executors并且关联4个task。也就是说，每个executor量运行2个task。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你没有明确配置task的数量，那么Strom将用默认的配置来运行，即：每个executor运行一个task。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;example-of-a-running-topology&quot;&gt;Example of a running topology&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下面这幅插图显示了一个简单的topology。这个topology由三个组件组成：一个叫&quot;BlueSpout&quot;的spout和两个bolt，分别叫&quot;GreenBolt&quot;和&quot;YellowBolt&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180202203852703-1482344519.png&quot; alt=&quot;&quot; width=&quot;765&quot; height=&quot;680&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180202204500828-1555025968.png&quot; alt=&quot;&quot; width=&quot;594&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;how-to-change-the-parallelism-of-a-running-topology&quot;&gt;How to change the parallelism of a running topology&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180202204743796-717107318.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;补充一个Java API&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180202205048890-1978382939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考  http://storm.apache.org/releases/1.1.1/Understanding-the-parallelism-of-a-Storm-topology.html&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 03 Feb 2018 01:49:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/8407078.html</dc:identifier>
</item>
<item>
<title>Part 2：模型与后台管理admin站点--Django从入门到精通系列教程 - 刘江liujiangblog.com</title>
<link>http://www.cnblogs.com/feixuelove1009/p/8404011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixuelove1009/p/8404011.html</guid>
<description>&lt;hr/&gt;&lt;h3 id=&quot;该系列教程系个人原创并完整发布在个人官网刘江的博客和教程&quot;&gt;该系列教程系个人原创，并完整发布在个人官网&lt;a href=&quot;http://www.liujiangblog.com&quot;&gt;刘江的博客和教程&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;所有转载本文者需在顶部显著位置注明原作者及www.liujiangblog.com官网地址&quot;&gt;所有转载本文者，需在顶部显著位置注明原作者及www.liujiangblog.com官网地址。&lt;/h3&gt;
&lt;h3 id=&quot;python及django学习qq群453131687&quot;&gt;Python及Django学习QQ群：453131687&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;接着第一部分，本节将讲述如何安装数据库，编写第一个模型以及简要的介绍下Django自动生成的后台管理admin站点。&lt;/p&gt;
&lt;h2 id=&quot;一数据库安装&quot;&gt;一、数据库安装&lt;/h2&gt;
&lt;p&gt;打开&lt;code&gt;mysite/settings.py&lt;/code&gt;配置文件，这是整个Django项目的设置中心。Django默认使用SQLite数据库，因为Python源生支持SQLite数据库，所以你无须安装任何程序，就可以直接使用它。当然，如果你是在创建一个实际的项目，可以使用类似PostgreSQL的数据库，避免以后数据库迁移的相关问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# mysite/settings.py

# Database
# https://docs.djangoproject.com/en/1.11/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你想使用其他的数据库，请先安装相应的数据库操作模块，并将settings文件中DATABASES位置的&lt;code&gt;’default’&lt;/code&gt;的键值进行相应的修改，用于连接你的数据库。其中：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ENGINE（引擎）：可以是&lt;code&gt;django.db.backends.sqlite3&lt;/code&gt;、&lt;code&gt;django.db.backends.postgresql&lt;/code&gt;、&lt;code&gt;django.db.backends.mysql&lt;/code&gt;、&lt;code&gt;django.db.backends.oracle&lt;/code&gt;，当然其它的也行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;NAME（名称）：类似Mysql数据库管理系统中用于保存项目内容的数据库的名字。如果你使用的是默认的SQLite，那么数据库将作为一个文件将存放在你的本地机器内，此时的NAME应该是这个文件的完整绝对路径包括文件名，默认值&lt;code&gt;os.path.join(BASE_DIR, ’db.sqlite3’)&lt;/code&gt;，将把该文件储存在你的项目目录下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你不是使用默认的SQLite数据库，那么一些诸如USER，PASSWORD和HOST的参数必须手动指定！下面给出一个基于pymysql操作Mysql数据库的例子，更多细节参考后续的数据库章节。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# mysite/settings.py

# Database
# https://docs.djangoproject.com/en/1.11/ref/settings/#databases

import pymysql         # 一定要添加这两行！通过pip install pymysql！
pymysql.install_as_MySQLdb()

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mysite',
        'HOST': '192.168.1.1',
        'USER': 'root',
        'PASSWORD': 'pwd',
        'PORT': '3306',
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在使用非SQLite的数据库时，请务必预先在数据库管理系统的提示符交互模式下创建数据库，你可以使用命令：“CREATE DATABASE database_name;”。Django不会自动帮你做这一步工作。&lt;/li&gt;
&lt;li&gt;确保你在settings文件中提供的数据库用户具有创建数据库表的权限，因为在接下来的教程中，我们需要自动创建一个test数据表。（在实际项目中也需要确认这一条要求。）&lt;/li&gt;
&lt;li&gt;如果你使用的是SQLite，那么你无需做任何预先配置，直接使用就可以了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在修改settings文件时，请顺便将&lt;code&gt;TIME_ZONE&lt;/code&gt;设置为国内所在的时区&lt;code&gt;Asia/Shanghai&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同时，请注意settings文件中顶部的&lt;code&gt;INSTALLED_APPS&lt;/code&gt;设置项。它列出了所有的项目中被激活的Django应用（app）。你必须将你自定义的app注册在这里。每个应用可以被多个项目使用，并且可以打包和分发给其他人在他们的项目中使用。&lt;/p&gt;
&lt;p&gt;默认情况，&lt;code&gt;INSTALLED_APPS&lt;/code&gt;中会自动包含下列条目，它们都是Django自动生成的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;django.contrib.admin：admin管理后台站点&lt;/li&gt;
&lt;li&gt;django.contrib.auth：身份认证系统&lt;/li&gt;
&lt;li&gt;django.contrib.contenttypes：内容类型框架&lt;/li&gt;
&lt;li&gt;django.contrib.sessions：会话框架&lt;/li&gt;
&lt;li&gt;django.contrib.messages：消息框架&lt;/li&gt;
&lt;li&gt;django.contrib.staticfiles：静态文件管理框架&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的一些应用也需要建立一些数据库表，所以在使用它们之前我们要在数据库中创建这些表。使用下面的命令创建数据表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python manage.py migrate。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;migrate命令将遍历&lt;code&gt;INSTALLED_APPS&lt;/code&gt;设置中的所有项目，在数据库中创建对应的表，并打印出每一条动作信息。如果你感兴趣，可以在你的数据库命令行下输入：&lt;code&gt;\dt&lt;/code&gt; (PostgreSQL)、 &lt;code&gt;SHOW TABLES;&lt;/code&gt;(MySQL)或 &lt;code&gt;.schema&lt;/code&gt;(SQLite) 来列出 Django 所创建的表。&lt;/p&gt;
&lt;p&gt;提示：对于极简主义者，你完全可以在INSTALLED_APPS内注释掉任何或者全部的Django提供的通用应用。这样，migrate也不会再创建对应的数据表。&lt;/p&gt;
&lt;h2 id=&quot;二创建模型&quot;&gt;二、创建模型&lt;/h2&gt;
&lt;p&gt;现在，我们来定义模型model，模型本质上就是数据库表的布局，再附加一些元数据。&lt;/p&gt;
&lt;p&gt;Django通过自定义Python类的形式来定义具体的模型，每个模型的物理存在方式就是一个Python的类Class，每个模型代表数据库中的一张表，每个类的实例代表数据表中的一行数据，类中的每个变量代表数据表中的一列字段。Django通过模型，将Python代码和数据库操作结合起来，实现对SQL查询语言的封装。也就是说，你可以不会管理数据库，可以不会SQL语言，你同样能通过Python的代码进行数据库的操作。Django通过ORM对数据库进行操作，奉行代码优先的理念，将Python程序员和数据库管理员进行分工解耦。&lt;/p&gt;
&lt;p&gt;在这个简单的投票应用中，我们将创建两个模型：&lt;code&gt;Question&lt;/code&gt;和&lt;code&gt;Choice&lt;/code&gt;。Question包含一个问题和一个发布日期。Choice包含两个字段：该选项的文本描述和该选项的投票数。每一条Choice都关联到一个Question。这些都是由Python的类来体现，编写的全是Python的代码，不接触任何SQL语句。现在，编辑&lt;code&gt;polls/models.py&lt;/code&gt;文件，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# polls/models.py&lt;/span&gt;

&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Question(models.Model):
    question_text &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;)
    pub_date &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.DateTimeField(&lt;span class=&quot;st&quot;&gt;'date published'&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Choice(models.Model):
    question &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ForeignKey(Question, on_delete&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;models.CASCADE)
    choice_text &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;)
    votes &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.IntegerField(default&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码非常简单明了。每一个类都是&lt;code&gt;django.db.models.Model&lt;/code&gt;的子类。每一个字段都是&lt;code&gt;Field&lt;/code&gt;类的一个实例，例如用于保存字符数据的CharField和用于保存时间类型的DateTimeField，它们告诉Django每一个字段保存的数据类型。&lt;/p&gt;
&lt;p&gt;每一个Field实例的名字就是字段的名字（如： question_text 或者 pub_date ）。在你的Python代码中会使用这个值，你的数据库也会将这个值作为表的列名。&lt;/p&gt;
&lt;p&gt;你也可以在每个Field中使用一个可选的第一位置参数用于提供一个人类可读的字段名，让你的模型更友好，更易读，并且将被作为文档的一部分来增强代码的可读性。&lt;/p&gt;
&lt;p&gt;一些Field类必须提供某些特定的参数。例如CharField需要你指定max_length。这不仅是数据库结构的需要，同样也用于数据验证功能。&lt;/p&gt;
&lt;p&gt;有必填参数，当然就会有可选参数，比如在votes里我们将其默认值设为0.&lt;/p&gt;
&lt;p&gt;最后请注意，我们使用&lt;code&gt;ForeignKey&lt;/code&gt;定义了一个外键关系。它告诉Django，每一个Choice关联到一个对应的Question（注意要将外键写在‘多’的一方）。Django支持通用的数据关系：一对一，多对一和多对多。&lt;/p&gt;
&lt;h2 id=&quot;三启用模型&quot;&gt;三、启用模型&lt;/h2&gt;
&lt;p&gt;上面的代码看着有点少，其实包含了大量的信息，据此，Django会做下面两件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建该app对应的数据库表结构&lt;/li&gt;
&lt;li&gt;为Question和Choice对象创建基于Python的数据库访问API&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，首先我们得先告诉Django项目，我们要使用投票app。&lt;/p&gt;
&lt;p&gt;要将应用添加到项目中，需要在&lt;code&gt;INSTALLED_APPS&lt;/code&gt;设置中增加指向该应用的配置文件的链接。对于本例的投票应用，它的配置类文件是&lt;code&gt;polls/apps.py&lt;/code&gt;，路径格式为&lt;code&gt;polls.apps.PollsConfig&lt;/code&gt;。我们需要在&lt;code&gt;INSTALLED_APPS&lt;/code&gt;中，将该路径添加进去：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# mysite/settings.py

INSTALLED_APPS = [
'polls.apps.PollsConfig',
'django.contrib.admin',
'django.contrib.auth',
'django.contrib.contenttypes',
'django.contrib.sessions',
'django.contrib.messages',
'django.contrib.staticfiles',
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，在多数情况下，我们简写成‘polls’就可以了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# mysite/settings.py

INSTALLED_APPS = [
'polls',
'django.contrib.admin',
'django.contrib.auth',
'django.contrib.contenttypes',
'django.contrib.sessions',
'django.contrib.messages',
'django.contrib.staticfiles',
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在Django已经知道你的投票应用的存在了，并把它加入了项目大家庭。&lt;/p&gt;
&lt;p&gt;我们需要再运行下一个命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python manage.py makemigrations polls&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会看到类似下面的提示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Migrations for 'polls':
  polls/migrations/0001_initial.py:
    - Create model Choice
    - Create model Question
    - Add field question to choice&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过运行&lt;code&gt;makemigrations&lt;/code&gt;命令，相当于告诉Django你对模型有改动，并且你想把这些改动保存为一个“迁移(migration)”。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;migrations&lt;/code&gt;是Django保存模型修改记录的文件，这些文件保存在磁盘上。在例子中，它就是&lt;code&gt;polls/migrations/0001_initial.py&lt;/code&gt;，你可以打开它看看，里面保存的都是人类可读并且可编辑的内容，方便你随时手动修改。&lt;/p&gt;
&lt;p&gt;接下来有一个叫做&lt;code&gt;migrate&lt;/code&gt;的命令将对数据库执行真正的迁移动作。但是在此之前，让我们先看看在migration的时候实际执行的SQL语句是什么。有一个叫做&lt;code&gt;sqlmigrate&lt;/code&gt;的命令可以展示SQL语句，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python manage.py sqlmigrate polls 0001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你将会看到如下类似的文本（经过适当的格式调整，方便阅读）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BEGIN;
--
-- Create model Choice
--
CREATE TABLE &quot;polls_choice&quot; (
    &quot;id&quot; serial NOT NULL PRIMARY KEY,
    &quot;choice_text&quot; varchar(200) NOT NULL,
    &quot;votes&quot; integer NOT NULL
);
--
-- Create model Question
--
CREATE TABLE &quot;polls_question&quot; (
    &quot;id&quot; serial NOT NULL PRIMARY KEY,
    &quot;question_text&quot; varchar(200) NOT NULL,
    &quot;pub_date&quot; timestamp with time zone NOT NULL
);
--
-- Add field question to choice
--
ALTER TABLE &quot;polls_choice&quot; ADD COLUMN &quot;question_id&quot; integer NOT NULL;
ALTER TABLE &quot;polls_choice&quot; ALTER COLUMN &quot;question_id&quot; DROP DEFAULT;
CREATE INDEX &quot;polls_choice_7aa0f6ee&quot; ON &quot;polls_choice&quot; (&quot;question_id&quot;);
ALTER TABLE &quot;polls_choice&quot;
    ADD CONSTRAINT &quot;polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id&quot;
    FOREIGN KEY (&quot;question_id&quot;)
    REFERENCES &quot;polls_question&quot; (&quot;id&quot;)
    DEFERRABLE INITIALLY DEFERRED;
COMMIT;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;请注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实际的输出内容将取决于您使用的数据库会有所不同。上面的是PostgreSQL的输出。&lt;/li&gt;
&lt;li&gt;表名是自动生成的，通过组合应用名 (polls) 和小写的模型名&lt;code&gt;question&lt;/code&gt;和&lt;code&gt;choice&lt;/code&gt; 。 ( 你可以重写此行为。)&lt;/li&gt;
&lt;li&gt;主键 (IDs) 是自动添加的。( 你也可以重写此行为。)&lt;/li&gt;
&lt;li&gt;按照惯例，Django 会在外键字段名上附加 &quot;_id&quot; 。 (你仍然可以重写此行为。)&lt;/li&gt;
&lt;li&gt;生成SQL语句时针对你所使用的数据库，会为你自动处理特定于数据库的字段，例如 auto_increment (MySQL), serial (PostgreSQL), 或integer primary key (SQLite) 。 在引用字段名时也是如此 – 比如使用双引号或单引号。&lt;/li&gt;
&lt;li&gt;这些SQL命令并没有在你的数据库中实际运行，它只是在屏幕上显示出来，以便让你了解Django真正执行的是什么。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你感兴趣，也可以运行&lt;code&gt;python manage.py check&lt;/code&gt;命令，它将检查项目中的错误，并不实际进行迁移或者链接数据库的操作。&lt;/p&gt;
&lt;p&gt;现在，我们可以运行migrate命令，在数据库中进行真正的表操作了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python manage.py migrate
Operations to perform:
    Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
    Rendering model states... DONE
    Applying polls.0001_initial... OK
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;migrate命令对所有还未实施的迁移记录进行操作，本质上就是将你对模型的修改体现到数据库中具体的表上面。Django通过一张叫做django_migrations的表，记录并跟踪已经实施的migrate动作，通过对比获得哪些migrations尚未提交。&lt;/p&gt;
&lt;p&gt;migrations的功能非常强大，允许你随时修改你的模型，而不需要删除或者新建你的数据库或数据表，在不丢失数据的同时，实时动态更新数据库。我们将在后面的章节对此进行深入的阐述，但是现在，只需要记住&lt;strong&gt;修改模型时的操作分三步&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在models.py中修改模型；&lt;/li&gt;
&lt;li&gt;运行&lt;code&gt;python manage.py makemigrations&lt;/code&gt;为改动创建迁移记录；&lt;/li&gt;
&lt;li&gt;运行&lt;code&gt;python manage.py migrate&lt;/code&gt;，将操作同步到数据库。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;之所以要将创建和实施迁移的动作分成两个命令两步走是因为你也许要通过版本控制系统（例如github，svn）提交你的项目代码，如果没有一个中间过程的保存文件（migrations），那么github如何知道以及记录、同步、实施你所进行过的模型修改动作呢？毕竟，github不和数据库直接打交道，也没法和你本地的数据库通信。但是分开之后，你只需要将你的migration文件（例如上面的0001）上传到github，它就会知道一切。&lt;/p&gt;
&lt;h2 id=&quot;四使用模型的api&quot;&gt;四、使用模型的API&lt;/h2&gt;
&lt;p&gt;下面，让我们进入Python交互环境，尝试使用Django提供的数据库访问API。要进入Python的shell，请输入命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python manage.py shell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比较直接输入“python”命令的方式进入Python环境，调用&lt;code&gt;manage.py&lt;/code&gt;参数能将&lt;code&gt;DJANGO_SETTINGS_MODULE&lt;/code&gt;环境变量导入，它将自动按照&lt;code&gt;mysite/settings.py&lt;/code&gt;中的设置，配置好你的python shell环境，这样，你就可以导入和调用任何你项目内的模块了。&lt;/p&gt;
&lt;p&gt;或者你也可以这样，先进入一个纯净的python shell环境，然后启动Django，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import django
&amp;gt;&amp;gt;&amp;gt; django.setup()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你进入shell后，尝试一下下面的API吧：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; polls.models &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Question, Choice &lt;span class=&quot;co&quot;&gt;# 导入我们写的模型类&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 现在系统内还没有questions对象&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Question.objects.&lt;span class=&quot;bu&quot;&gt;all&lt;/span&gt;()
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;QuerySet []&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;# 创建一个新的question对象&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# Django推荐使用timezone.now()代替python内置的datetime.datetime.now()&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 这个timezone就来自于Django唯一的依赖库pytz&lt;/span&gt;
    &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.utils &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; timezone
    &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; q &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Question(question_text&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;What's new?&quot;&lt;/span&gt;, pub_date&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;timezone.now())
    
    &lt;span class=&quot;co&quot;&gt;# 你必须显式的调用save()方法，才能将对象保存到数据库内&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; q.save()
    
    &lt;span class=&quot;co&quot;&gt;# 默认情况，你会自动获得一个自增的名为id的主键&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; q.&lt;span class=&quot;bu&quot;&gt;id&lt;/span&gt;
    &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;# 通过python的属性调用方式，访问模型字段的值&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; q.question_text
    &lt;span class=&quot;co&quot;&gt;&quot;What's new?&quot;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; q.pub_date
    datetime.datetime(&lt;span class=&quot;dv&quot;&gt;2012&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;26&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;775217&lt;/span&gt;, tzinfo&lt;span class=&quot;op&quot;&gt;=&amp;lt;&lt;/span&gt;UTC&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;)
    
    &lt;span class=&quot;co&quot;&gt;# 通过修改属性来修改字段的值，然后显式的调用save方法进行保存。&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; q.question_text &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;What's up?&quot;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; q.save()
    
    &lt;span class=&quot;co&quot;&gt;# objects.all() 用于查询数据库内的所有questions&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Question.objects.&lt;span class=&quot;bu&quot;&gt;all&lt;/span&gt;()
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;QuerySet [&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Question: Question &lt;span class=&quot;bu&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里等一下：上面的&lt;code&gt;&amp;lt;Question: Question object&amp;gt;&lt;/code&gt;是一个不可读的内容展示，你无法从中获得任何直观的信息，为此我们需要一点小技巧，让Django在打印对象时显示一些我们指定的信息。&lt;/p&gt;
&lt;p&gt;返回&lt;code&gt;polls/models.py&lt;/code&gt;文件，修改一下question和Choice这两个类，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.utils.encoding &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; python_2_unicode_compatible

&lt;span class=&quot;at&quot;&gt;@python_2_unicode_compatible&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;# 当你想支持python2版本的时候才需要这个装饰器&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Question(models.Model):
    &lt;span class=&quot;co&quot;&gt;# ...&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__str__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):   &lt;span class=&quot;co&quot;&gt;# 在python2版本中使用的是__unique__&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.question_text
        
&lt;span class=&quot;at&quot;&gt;@python_2_unicode_compatible&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Choice(models.Model):
    &lt;span class=&quot;co&quot;&gt;# ...&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__str__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.choice_text&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个技巧不但对你打印对象时很有帮助，在你使用Django的admin站点时也同样有帮助。&lt;/p&gt;
&lt;p&gt;另外，这里我们自定义一个模型的方法，用于判断问卷是否最近时间段内发布度的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; datetime
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.utils &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; timezone

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Question(models.Model):
    &lt;span class=&quot;co&quot;&gt;# ...&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; was_published_recently(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.pub_date &lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt; timezone.now() &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; datetime.timedelta(days&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意上面分别导入了两个关于时间的模块，一个是python内置的datetime一个是Django工具包提供的timezone。&lt;/p&gt;
&lt;p&gt;保存修改后，我们重新启动一个新的python shell，再来看看其他的API：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; polls.models &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Question, Choice

&lt;span class=&quot;co&quot;&gt;# 先看看__str__()的效果，直观多了吧？&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Question.objects.&lt;span class=&quot;bu&quot;&gt;all&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;QuerySet [&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Question: What&lt;span class=&quot;st&quot;&gt;'s up?&amp;gt;]&amp;gt;&lt;/span&gt;

&lt;span class=&quot;st&quot;&gt;# Django提供了大量的关键字参数查询API&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; Question.objects.filter(id=1)&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;lt;QuerySet [&amp;lt;Question: What'&lt;/span&gt;s up?&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Question.objects.&lt;span class=&quot;bu&quot;&gt;filter&lt;/span&gt;(question_text__startswith&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'What'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;QuerySet [&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Question: What&lt;span class=&quot;st&quot;&gt;'s up?&amp;gt;]&amp;gt;&lt;/span&gt;

&lt;span class=&quot;st&quot;&gt;# 获取今年发布的问卷&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from django.utils import timezone&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; current_year = timezone.now().year&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; Question.objects.get(pub_date__year=current_year)&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;lt;Question: What'&lt;/span&gt;s up?&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 查询一个不存在的ID，会弹出异常&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Question.objects.get(&lt;span class=&quot;bu&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
Traceback (most recent call last):
...
DoesNotExist: Question matching query does &lt;span class=&quot;op&quot;&gt;not&lt;/span&gt; exist.

&lt;span class=&quot;co&quot;&gt;# Django为主键查询提供了一个缩写：pk。下面的语句和Question.objects.get(id=1)效果一样.&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Question.objects.get(pk&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Question: What&lt;span class=&quot;st&quot;&gt;'s up?&amp;gt;&lt;/span&gt;

&lt;span class=&quot;st&quot;&gt;# 看看我们自定义的方法用起来怎么样&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; q = Question.objects.get(pk=1)&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; q.was_published_recently()&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;True&lt;/span&gt;

&lt;span class=&quot;st&quot;&gt;# 让我们试试主键查询&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; q = Question.objects.get(pk=1)&lt;/span&gt;

&lt;span class=&quot;st&quot;&gt;# 显示所有与q对象有关系的choice集合，目前是空的，还没有任何关联对象。&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; q.choice_set.all()&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;lt;QuerySet []&amp;gt;&lt;/span&gt;

&lt;span class=&quot;st&quot;&gt;# 创建3个choices.&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; q.choice_set.create(choice_text='&lt;/span&gt;Not much&lt;span class=&quot;st&quot;&gt;', votes=0)&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;lt;Choice: Not much&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; q.choice_set.create(choice_text='&lt;/span&gt;The sky&lt;span class=&quot;st&quot;&gt;', votes=0)&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;lt;Choice: The sky&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; c = q.choice_set.create(choice_text='&lt;/span&gt;Just hacking again&lt;span class=&quot;st&quot;&gt;', votes=0)&lt;/span&gt;

&lt;span class=&quot;st&quot;&gt;# Choice对象可通过API访问和他们关联的Question对象&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;gt;&amp;gt;&amp;gt; c.question&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;lt;Question: What'&lt;/span&gt;s up?&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 同样的，Question对象也可通过API访问关联的Choice对象&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; q.choice_set.&lt;span class=&quot;bu&quot;&gt;all&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;QuerySet [&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Choice: Not much&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;, &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Choice: The sky&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;, &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Choice: Just hacking again&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; q.choice_set.count()
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# API会自动进行连表操作，通过双下划线分割关系对象。连表操作可以无限多级，一层一层的连接。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 下面是查询所有的Choices，它所对应的Question的发布日期是今年。（重用了上面的current_year结果）&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; Choice.objects.&lt;span class=&quot;bu&quot;&gt;filter&lt;/span&gt;(question__pub_date__year&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;current_year)
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;QuerySet [&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Choice: Not much&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;, &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Choice: The sky&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;, &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Choice: Just hacking again&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 使用delete方法删除对象&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; q.choice_set.&lt;span class=&quot;bu&quot;&gt;filter&lt;/span&gt;(choice_text__startswith&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'Just hacking'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; c.delete()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于模型的使用就暂时先介绍这么多。这部分内容是Django项目的核心，也是动态网站与数据库交互的核心，对于初学者，再难理解也要理解。&lt;/p&gt;
&lt;h2 id=&quot;五admin后台管理站点&quot;&gt;五、admin后台管理站点&lt;/h2&gt;
&lt;p&gt;很多时候，我们不光要开发针对客户使用的前端页面，还要给后台管理人员提供相应的管理界面。但是大多数时候为你的团队或客户编写用于增加、修改和删除内容的后台管理站点是一件非常乏味的工作并且没有多少创造性，而且也需要花不少的时间和精力。Django最大的优点之一，就是体贴的为你提供了一个基于项目model创建的一个后台管理站点admin。这个界面只给站点管理员使用，并不对大众开放。虽然admin的界面可能不是那么美观，功能不是那么强大，内容不一定符合你的要求，但是它是免费的、现成的，并且还是可定制的，有完善的帮助文档，那么，你还要什么自行车？&lt;/p&gt;
&lt;h3 id=&quot;创建管理员用户&quot;&gt;1. &lt;strong&gt;创建管理员用户&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;首先，我们需要通过下面的命令，创建一个可以登录admin站点的用户：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python manage.py createsuperuser&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入用户名：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Username: admin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入邮箱地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Email address: xxx@xxx.xxx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入密码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Password: **********
Password (again): *********
Superuser created successfully.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：Django1.10版本后，超级用户的密码强制要求具备一定的复杂性，不能再偷懒了。&lt;/p&gt;
&lt;h3 id=&quot;启动开发服务器&quot;&gt;2. &lt;strong&gt;启动开发服务器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;服务器启动后，在浏览器访问&lt;code&gt;http://127.0.0.1:8000/admin/&lt;/code&gt;。你就能看到admin的登陆界面了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/gooji341rw0c46mtjqjva6jo/image.png&quot; alt=&quot;image.png-13.9kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实际环境中，为了站点的安全性，我们不能将管理后台的url随便暴露给他人，不能用&lt;code&gt;/admin/&lt;/code&gt;这么简单的路径。&lt;/p&gt;
&lt;p&gt;打开根url路由文件&lt;code&gt;mysite/urls.py&lt;/code&gt;，修改其中admin.site.urls对应的正则表达式，换成你想要的，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf.urls import url
from django.contrib import admin

urlpatterns = [
    url(r'^my/set/', admin.site.urls),
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们必须访问&lt;code&gt;http://127.0.0.1:8000/my/set/&lt;/code&gt;才能进入admin界面。&lt;/p&gt;
&lt;h3 id=&quot;进入admin站点&quot;&gt;3. &lt;strong&gt;进入admin站点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;利用刚才建立的admin账户，登陆admin，你将看到如下的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/71xzz5ftkvd92ex3eo8jv8ie/image.png&quot; alt=&quot;image.png-49.8kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前只有两个可编辑的内容：groups和users。它们是&lt;code&gt;django.contrib.auth&lt;/code&gt;模块提供的身份认证框架。&lt;/p&gt;
&lt;h3 id=&quot;在admin中注册投票应用&quot;&gt;4. &lt;strong&gt;在admin中注册投票应用&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;现在还无法看到投票应用，必须先在admin中进行注册，告诉admin站点，请将polls的模型加入站点内，接受站点的管理。&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;polls/admin.py&lt;/code&gt;文件，加入下面的内容：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.contrib &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; admin
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; .models &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Question

admin.site.register(Question)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;admin站点的主要功能&quot;&gt;4. &lt;strong&gt;admin站点的主要功能&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;注册question模型后，刷新admin页面就能看到Question栏目了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/cc9weiavx8dvpuusfk513skl/image.png&quot; alt=&quot;image.png-37.9kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击“Questions”，进入questions的修改列表页面。这个页面会显示所有的数据库内的questions对象，你可以在这里对它们进行修改。看到下面的&lt;code&gt;“What’s up?”&lt;/code&gt;了么？它就是我们先前创建的一个question对象，并且通过&lt;code&gt;__str__&lt;/code&gt;方法的帮助，显示了较为直观的信息，而不是一个冷冰冰的对象类型名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/9g6wo9cfa5fipgmvo335dp2w/image.png&quot; alt=&quot;image.png-31.8kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面，点击&lt;code&gt;What’s up?&lt;/code&gt;进入编辑界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/wzeve3hf28vyow8bj8ow1iwl/image.png&quot; alt=&quot;image.png-47.6kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;页面中的表单是由Question模型自动生成的。&lt;/li&gt;
&lt;li&gt;不同的模型字段类型(DateTimeField, CharField)会表现为不同的&lt;code&gt;HTML input&lt;/code&gt;框类型。&lt;/li&gt;
&lt;li&gt;每一个&lt;code&gt;DateTimeField&lt;/code&gt;都会自动生成一个可点击链接。日期是Today，并有一个日历弹出框；时间是Now，并有一个通用的时间输入列表框。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在页面的底部，则是一些可选项按钮：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;delete&lt;/code&gt;：弹出一个删除确认页面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;save and add another&lt;/code&gt;：保存当前修改，并加载一个新的空白的当前类型对象的表单。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;save and continue editing&lt;/code&gt;：保存当前修改，并重新加载该对象的编辑页面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;save&lt;/code&gt;：保存修改，返回当前对象类型的列表页面。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果&lt;code&gt;Date published&lt;/code&gt;字段的值和你在前面教程创建它的时候不一致，可能是你没有正确的配置&lt;code&gt;TIME_ZONE&lt;/code&gt;，在国内，通常是8个小时的时间差别。修改TIME_ZONE配置并重新加载页面，就能显示正确的时间了。&lt;/p&gt;
&lt;p&gt;在页面的右上角，点击&lt;code&gt;History&lt;/code&gt;按钮，你会看到你对当前对象的所有修改操作都在这里有记录，包括修改时间和操作人员，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/k1ofn93wzepcpemniygcc3tw/image.png&quot; alt=&quot;image.png-29.6kB&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 01:25:00 +0000</pubDate>
<dc:creator>刘江liujiangblog.com</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixuelove1009/p/8404011.html</dc:identifier>
</item>
<item>
<title>Java并发系列[2]----AbstractQueuedSynchronizer源码分析之独占模式 - 劳夫子</title>
<link>http://www.cnblogs.com/liuyun1995/p/8400724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyun1995/p/8400724.html</guid>
<description>&lt;p&gt;在上一篇《&lt;a href=&quot;http://www.cnblogs.com/liuyun1995/p/8400663.html&quot; target=&quot;_blank&quot;&gt;Java并发系列[1]----AbstractQueuedSynchronizer源码分析之概要分析&lt;/a&gt;》中我们介绍了AbstractQueuedSynchronizer基本的一些概念，主要讲了AQS的排队区是怎样实现的，什么是独占模式和共享模式以及如何理解结点的等待状态。理解并掌握这些内容是后续阅读AQS源码的关键，所以建议读者先看完我的上一篇文章再回过头来看这篇就比较容易理解。在本篇中会介绍在独占模式下结点是怎样进入同步队列排队的，以及离开同步队列之前会进行哪些操作。AQS为在独占模式和共享模式下获取锁分别提供三种获取方式：不响应线程中断获取，响应线程中断获取，设置超时时间获取。这三种方式整体步骤大致是相同的，只有少部分不同的地方，所以理解了一种方式再看其他方式的实现都是大同小异。在本篇中我会着重讲不响应线程中断的获取方式，其他两种方式也会顺带讲一下不一致的地方。&lt;/p&gt;
&lt;p&gt;1. 怎样以不响应线程中断获取锁？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不响应中断方式获取(独占模式)&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;span&gt; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        selfInterrupt();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中虽然看起来简单，但是它按照顺序执行了下图所示的4个步骤。下面我们会逐个步骤进行演示分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201370/201802/1201370-20180201191957640-354605007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一步：!tryAcquire(arg)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;尝试去获取锁(独占模式)&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候来了一个人，他首先尝试着去敲了敲门，如果发现门没锁(tryAcquire(arg)=true)，那就直接进去了。如果发现门锁了(tryAcquire(arg)=false)，就执行下一步。这个tryAcquire方法决定了什么时候锁是开着的，什么时候锁是关闭的。这个方法必须要让子类去覆盖，重写里面的判断逻辑。&lt;/p&gt;
&lt;p&gt;第二步：addWaiter(Node.EXCLUSIVE)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前线程包装成结点并添加到同步队列尾部&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node addWaiter(Node mode) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定持有锁的模式&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     Node node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(Thread.currentThread(), mode);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取同步队列尾结点引用&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     Node pred =&lt;span&gt; tail;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果尾结点不为空, 表明同步队列已存在结点&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.指向当前尾结点&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         node.prev =&lt;span&gt; pred;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.设置当前结点为尾结点&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(pred, node)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.将旧的尾结点的后继指向新的尾结点&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             pred.next =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则表明同步队列还没有进行初始化&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    enq(node);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结点入队操作&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Node enq(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Node node) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取同步队列尾结点引用&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         Node t =&lt;span&gt; tail;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果尾结点为空说明同步队列还没有初始化&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化同步队列&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node())) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 tail =&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.指向当前尾结点&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             node.prev =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.设置当前结点为尾结点&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(t, node)) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.将旧的尾结点的后继指向新的尾结点&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                 t.next =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行到这一步表明第一次获取锁失败，那么这个人就给自己领了块号码牌进入排队区去排队了，在领号码牌的时候会声明自己想要以什么样的方式来占用房间(独占模式or共享模式)。注意，这时候他并没有坐下来休息(将自己挂起)哦。&lt;/p&gt;
&lt;p&gt;第三步：acquireQueued(addWaiter(Node.EXCLUSIVE), arg)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以不可中断方式获取锁(独占模式)&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; acquireQueued(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取给定结点的前继结点的引用&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前结点是同步队列的第一个结点, 就尝试去获取锁&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp;&lt;span&gt; tryAcquire(arg)) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将给定结点设置为head结点&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                setHead(node);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了帮助垃圾收集, 将上一个head结点的后继清空&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 p.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置获取成功状态&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回中断的状态, 整个循环执行到这里才是出口&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; interrupted;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则说明锁的状态还是不可获取, 这时判断是否可以挂起当前线程
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果判断结果为真则挂起当前线程, 否则继续循环, 在这期间线程不响应中断&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt; parkAndCheckInterrupt()) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 interrupted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在最后确保如果获取失败就取消获取&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            cancelAcquire(node);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否可以将当前结点挂起&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shouldParkAfterFailedAcquire(Node pred, Node node) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取前继结点的等待状态&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; pred.waitStatus;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前继结点状态为SIGNAL, 表明前继结点会唤醒当前结点, 所以当前结点可以安心的挂起了&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ws &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的操作是清理同步队列中所有已取消的前继结点&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             node.prev = pred =&lt;span&gt; pred.prev;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         } &lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         pred.next =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;到这里表示前继结点状态不是SIGNAL, 很可能还是等于0, 这样的话前继结点就不会去唤醒当前结点了
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所以当前结点必须要确保前继结点的状态为SIGNAL才能安心的挂起自己&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;挂起当前线程&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; parkAndCheckInterrupt() {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     LockSupport.park(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Thread.interrupted();
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;领完号码牌进入排队区后就会立马执行这个方法，当一个结点首次进入排队区后有两种情况，一种是发现他前面的那个人已经离开座位进入房间了，那他就不坐下来休息了，会再次去敲一敲门看看那小子有没有完事。如果里面的人刚好完事出来了，都不用他叫自己就直接冲进去了。否则，就要考虑坐下来休息一会儿了，但是他还是不放心，如果他坐下来睡着后没人提醒他怎么办？他就在前面那人的座位上留一个小纸条，好让从里面出来的人看到纸条后能够唤醒他。还有一种情况是，当他进入排队区后发现前面还有好几个人在座位上排队呢，那他就可以安心的坐下来咪一会儿了，但在此之前他还是会在前面那人(此时已经睡着了)的座位上留一个纸条，好让这个人在走之前能够去唤醒自己。当一切事情办妥了之后，他就安安心心的睡觉了，注意，我们看到整个for循环就只有一个出口，那就是等线程成功的获取到锁之后才能出去，在没有获取到锁之前就一直是挂在for循环的parkAndCheckInterrupt()方法里头。线程被唤醒后也是从这个地方继续执行for循环。&lt;/p&gt;
&lt;p&gt;第四步：selfInterrupt()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程将自己中断&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; selfInterrupt() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    Thread.currentThread().interrupt();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于上面整个线程一直是挂在for循环的parkAndCheckInterrupt()方法里头，没有成功获取到锁之前不响应任何形式的线程中断，只有当线程成功获取到锁并从for循环出来后，他才会查看在这期间是否有人要求中断线程，如果是的话再去调用selfInterrupt()方法将自己挂起。&lt;/p&gt;
&lt;p&gt;2. 怎样以响应线程中断获取锁？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以可中断模式获取锁(独占模式)&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doAcquireInterruptibly(&lt;span&gt;int&lt;/span&gt; arg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前线程包装成结点添加到同步队列中&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node node =&lt;span&gt; addWaiter(Node.EXCLUSIVE);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前结点的前继结点&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果p是head结点, 那么当前线程就再次尝试获取锁&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp;&lt;span&gt; tryAcquire(arg)) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                setHead(node);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁成功后返回&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果满足条件就挂起当前线程, 此时响应中断并抛出异常&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt; parkAndCheckInterrupt()) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程被唤醒后如果发现中断请求就抛出异常&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            cancelAcquire(node);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;响应线程中断方式和不响应线程中断方式获取锁流程上大致上是相同的。唯一的一点区别就是线程从parkAndCheckInterrupt方法中醒来后会检查线程是否中断，如果是的话就抛出InterruptedException异常，而不响应线程中断获取锁是在收到中断请求后只是设置一下中断状态，并不会立马结束当前获取锁的方法，一直到结点成功获取到锁之后才会根据中断状态决定是否将自己挂起。&lt;/p&gt;
&lt;p&gt;3. 怎样设置超时时间获取锁？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以限定超时时间获取锁(独占模式)&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; doAcquireNanos(&lt;span&gt;int&lt;/span&gt; arg, &lt;span&gt;long&lt;/span&gt; nanosTimeout) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取系统当前时间&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; lastTime =&lt;span&gt; System.nanoTime();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前线程包装成结点添加到同步队列中&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node node =&lt;span&gt; addWaiter(Node.EXCLUSIVE);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前结点的前继结点&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前继是head结点, 那么当前线程就再次尝试获取锁&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp;&lt;span&gt; tryAcquire(arg)) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新head结点&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                setHead(node);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 p.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时时间用完了就直接退出循环&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (nanosTimeout &amp;lt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果超时时间大于自旋时间, 那么等判断可以挂起线程之后就会将线程挂起一段时间&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp; nanosTimeout &amp;gt;&lt;span&gt; spinForTimeoutThreshold) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前线程挂起一段时间, 之后再自己醒来&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 LockSupport.parkNanos(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, nanosTimeout);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取系统当前时间&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; now =&lt;span&gt; System.nanoTime();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时时间每次都减去获取锁的时间间隔&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             nanosTimeout -= now -&lt;span&gt; lastTime;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次更新lastTime&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             lastTime =&lt;span&gt; now;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在获取锁的期间收到中断请求就抛出异常&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted()) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            cancelAcquire(node);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置超时时间获取首先会去获取一下锁，第一次获取锁失败后会根据情况，如果传入的超时时间大于自旋时间那么就会将线程挂起一段时间，否则的话就会进行自旋，每次获取锁之后都会将超时时间减去获取一次锁所用的时间。一直到超时时间小于0也就说明超时时间用完了，那么这时就会结束获取锁的操作然后返回获取失败标志。注意在以超时时间获取锁的过程中是可以响应线程中断请求的。&lt;/p&gt;
&lt;p&gt;4. 线程释放锁并离开同步队列是怎样进行的？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放锁的操作(独占模式)&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; release(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拨动密码锁, 看看是否能够开锁&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryRelease(arg)) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取head结点&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         Node h =&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果head结点不为空并且等待状态不等于0就去唤醒后继结点&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒后继结点&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            unparkSuccessor(h);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒后继结点&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unparkSuccessor(Node node) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取给定结点的等待状态&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; node.waitStatus;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将等待状态更新为0&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ws &amp;lt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         compareAndSetWaitStatus(node, ws, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取给定结点的后继结点&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     Node s =&lt;span&gt; node.next;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;后继结点为空或者等待状态为取消状态&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         s = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从后向前遍历队列找到第一个不是取消状态的结点&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t =&lt;span&gt; t.prev) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 s =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒给定结点后面首个不是取消状态的结点&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        LockSupport.unpark(s.thread);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;线程持有锁进入房间后就会去办自己的事情，等事情办完后它就会释放锁并离开房间。通过tryRelease方法可以拨动密码锁进行解锁，我们知道tryRelease方法是需要让子类去覆盖的，不同的子类实现的规则不一样，也就是说不同的子类设置的密码不一样。像在ReentrantLock当中，房间里面的人每调用tryRelease方法一次，state就减1，直到state减到0的时候密码锁就开了。大家想想这个过程像不像我们在不停的转动密码锁的转轮，而每次转动转轮数字只是减少1。CountDownLatch和这个也有点类似，只不过它不是一个人在转，而是多个人每人都去转一下，集中大家的力量把锁给开了。线程出了房间后它会找到自己原先的座位，也就是找到head结点。看看座位上有没有人给它留了小纸条，如果有的话它就知道有人睡着了需要让它帮忙唤醒，那么它就会去唤醒那个线程。如果没有的话就表明同步队列中暂时还没有人在等待，也没有人需要它唤醒，所以它就可以安心的离去了。以上过程就是在独占模式下释放锁的过程。&lt;/p&gt;
&lt;p&gt;注：以上全部分析基于JDK1.7，不同版本间会有差异，读者需要注意&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 00:59:00 +0000</pubDate>
<dc:creator>劳夫子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyun1995/p/8400724.html</dc:identifier>
</item>
<item>
<title>6、系统用户指南 - 软件项目角色指南系列文章 - lzhdim</title>
<link>http://www.cnblogs.com/lzhdim/p/8405649.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lzhdim/p/8405649.html</guid>
<description>

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;系统用户这个角色在项目管理过程中也是重要的一员。在实际的项目管理过程中，项目经理除了与客户负责人进行沟通之外，还需要与系统实际的用户进行沟通，让客户负责人与系统用户等进行协调，为项目组争取利益，让系统实际开发出来的功能是满足及更好的符合系统用户的工作内容以及业务需求，还有就是用户体验及界面上的功能确认等等。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、工作职责&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统用户在实际的工作过程中，需要对自身工作的内容进行不断的总结，给客户负责人提出更多更好更能提高效率的业务需求流程，这样才能够让自己及同事的工作轻松一些，以及让自己的工作平台更加完善更加便捷更好。&lt;/p&gt;
&lt;p&gt;l  在实际工作过程中总结业务经验，提出行业内的新业务需求；&lt;/p&gt;
&lt;p&gt;l  与客户负责人沟通，提出更好的业务需求及流程；&lt;/p&gt;
&lt;p&gt;l  配合客户负责人对系统进行需求变更及确认；&lt;/p&gt;
&lt;p&gt;l  配合项目建设方对系统进行测试；&lt;/p&gt;
&lt;p&gt;l  配合项目建设方对系统验收的评审等做确认；&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、应具备的知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统用户在工作过程中需要不断的积累和总结工作业务经验及流程，所以实际工作过程中要对自己的工作业务进行了解。首先需要先了解工作内容、工作业务流程、工作所需要的技能和工作所使用的工具软件等等。&lt;/p&gt;
&lt;p&gt;l  工作所需要的技术、业务；&lt;/p&gt;
&lt;p&gt;l  工作实际的业务操作流程；&lt;/p&gt;
&lt;p&gt;l  工作所使用的工具软件；&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、日常工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统用户实际的日常工作其实也比较单一，就是在工作过程中重复操作自己所具备的技能、经验及实际工作中需要的业务经验流程等内容。系统用户的工作相对简单，等熟悉了自己岗位的工作流程等内容后，系统用户的工作内容就简单多了，很多都是重复性的工作。&lt;/p&gt;
&lt;p&gt;l  对实际工作业务内容进行操作；&lt;/p&gt;
&lt;p&gt;l  对工作业务操作内容进行总结；&lt;/p&gt;
&lt;p&gt;l  对工作领域的业务进行不断学习；&lt;/p&gt;
&lt;p&gt;l  配合客户负责人提出更多更好的系统软件功能；&lt;/p&gt;
&lt;p&gt;l  配合客户负责人及系统建设方项目经理对系统软件进行测试；&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;、经验提升的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统用户的工作比较单一，所以实际的经验提升方法也比较单一。无外乎就是不断的去学习和在实际的工作过程中去操作自己所学到的知识内容，这样才能够更快更好的对自己的工作内容进行学习和总结经验，更加熟练的进行自己的本职工作。&lt;/p&gt;
&lt;p&gt;l  在实际工作过程中不断学习和总结经验；&lt;/p&gt;
&lt;p&gt;l  参加相关的系统操作培训；&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;、与其他角色的沟通&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统用户因为实际工作比较简单，所以在工作过程中与其他角色的沟通也不是那么频繁。一般来说，系统用户在工作过程中使用系统功能的时候，会自己总结新的业务操作功能，这样才能让客户负责人与系统建设方进行沟通，更好的将系统做好，更好的服务于自己的工作。&lt;/p&gt;
&lt;p&gt;l  与客户负责人沟通实际工作中碰到的业务操作流程功能；&lt;/p&gt;
&lt;p&gt;l  配合客户负责人将新的业务操作流程提交给系统建设方项目经理；&lt;/p&gt;
&lt;p&gt;l  配合客户负责人及领导对自己业务领域的内容进行积累经验及总结；&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;strong&gt;、应阅读的书籍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统用户在工作过程中基本上除了开始的时候学习工作业务操作流程外，还需要不断的补充新的业务流程内容，更好的在工作中进行学习及实践。所以，系统用户一般都是先对自己的工作内容的业务操作流程进行了解，先解决工作过程中的问题，然后再不断学习提高，并将自己在实际工作中遇到的问题提交给客户负责人，更好的将系统做好，更好的提高自己的工作效率。&lt;/p&gt;
&lt;p&gt;l  学习自己工作中的业务操作知识；&lt;/p&gt;
&lt;p&gt;l  学习工作中使用到的软件工具知识；&lt;/p&gt;
&lt;p&gt;l  学习及提高自己的业务水平，以及如何提升自己的价值，得到成长；&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;、应铭记的话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;l  不断的在工作中进行学习；&lt;/p&gt;
&lt;p&gt;l  不断的在工作中积累和总结实际工作经验；&lt;/p&gt;
&lt;p&gt;l  不断的与领导沟通，提出工作中碰到的业务流程内容，提高自己的价值和水平；&lt;/p&gt;
&lt;p&gt;l  不断的与客户负责人进行沟通，对工作中的软件系统功能提出自己的看法，更好的提高自己的工作能力和效率；&lt;/p&gt;

</description>
<pubDate>Sat, 03 Feb 2018 00:07:00 +0000</pubDate>
<dc:creator>lzhdim</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lzhdim/p/8405649.html</dc:identifier>
</item>
</channel>
</rss>