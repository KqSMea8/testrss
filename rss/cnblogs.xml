<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>还记得八皇后的解法吗 - sherrywasp</title>
<link>http://www.cnblogs.com/sherrywasp/p/9765921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sherrywasp/p/9765921.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010150744859-59417190.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;“还记得八皇后的解法吗？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“上个世纪的事情，不记得了。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“…… 现在回忆一下？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“开会，回头说。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“ fuck u ”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“ u shit ”&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我有一个C++基友，这么称呼是因为他入行时用的是C++。虽然在游走于腾讯、金山之后，如今已经十八般武艺略懂了，但说起来还是C++的标签最刺眼。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当你有一个C++基友时，QQ里的日常，难免就会碰到上面那种聊天记录了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　八皇后是一个古老的经典问题：&lt;strong&gt;如何在一张国际象棋的棋盘上，摆放8个皇后，使其任意两个皇后互相不受攻击。&lt;/strong&gt;该问题由一位德国&lt;strong&gt;国际象棋排局家&lt;/strong&gt; &lt;strong&gt;Max Bezzel&lt;/strong&gt; 于 1848年提出。严格来说，那个年代，还没有“德国”这个国家，彼时称作“普鲁士”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010133316912-1707009972.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;em&gt;Max Bezzel&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1850年，&lt;strong&gt;Franz Nauck&lt;/strong&gt; 给出了第一个解，并将其扩展成了“ &lt;strong&gt;n皇后&lt;/strong&gt; ”问题，即&lt;strong&gt;在一张 n 维棋盘上，如何摆放 n 个皇后，使其两两互不攻击&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　历史上，八皇后问题曾惊动过“数学王子”高斯(Gauss)，而且正是上面这个 Franz Nauck 写信找高斯请教的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010133609867-775587768.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;高斯和八皇后问题&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在那天被基友问到时，我并非真的不记得了，而是我压根就没有做过。但我第一次遇见这个问题时，确实是在上个世纪，那是在小学微机教室里，参加市级计算机奥林匹克小学组竞赛的培训课上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我还记得初次看到这个问题的第一反应——&lt;strong&gt;怎么可能摆8个！&lt;/strong&gt;要知道我初学国际象棋时，经常为了简化局面，早早地就伺机兑掉皇后，因为皇后的威力实在是溢出了我童年的脑袋。&lt;strong&gt;一个皇后感觉就可以 hold 住全场了&lt;/strong&gt;，怎么还可以摆8个互不干扰的呢？这肯定无解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以说，童言无忌这个说法，是有必要的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　一晃好多年。如今基友问过来了，我琢磨着是该补上这份作业了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　给老爸拨了个电话——&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“喂，爸，家里的国际象棋放哪了？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“…… 压箱底了吧，得找找。怎么突然问这，你要研究西西里防御？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“我现在都不走 &lt;strong&gt;e4&lt;/strong&gt; 了，要研究也是后翼弃兵。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“别特么瞎扯，给你根杆子你就爬啊，快说，有什么屁事？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“我要研究八皇后问题。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“讲中文！”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“我有个问题想研究一下，要在国际象棋棋盘上摆放八个皇后，并且互相不受攻击，求摆法。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“哦，这样啊…… 那你要国际象棋干嘛？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“我想在国际象棋上试着摆摆啊。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“国际象棋没有八个皇后，你要国际象棋干嘛？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“呃…… 那我可以拿八个兵当皇后做试验。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“那你直接画个棋盘摆八个硬币不是一回事？非要用国际象棋？脱裤子放屁，多此一举！”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“…… ……”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“老子懒得翻箱子跟你找了，你干脆去买四副国际象棋，然后就有八个皇后了。还有事吗？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“没…… 没了，爸。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“早点休息，多喝水，别熬夜。天气冷了，注意加衣服……”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“好，好好。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　—— 对方挂断，通话结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我默默地打开了淘宝，搜索“国际象棋”，准备买 4 副…… &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　转念一想，还是算了，自己画吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　转念二想，懒得画了，就在脑子里摆摆看吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，做点分析工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　虽然还不知道最终的答案长什么样，有多少个，但利用国际象棋的规则，可以知道的是，最终8个皇后的分布必定是&lt;strong&gt;每行有且只有1个，每列有且只有1个&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因为如果有某一行（或列）空置的话，则必然导致另有一行（或列）存在2个皇后。这显而易见的结果背后，有一个数学概念叫做“&lt;strong&gt;抽屉原则&lt;/strong&gt;”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　借助这个“抽屉”，接下来要做的就是一行一行地找出8个位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然，按一列一列来做也可以，但在&lt;strong&gt;处理图形图像等信息时，优先水平方向似乎更符合人的思维惯性，据说这是因为人的两只眼睛是水平的&lt;/strong&gt;。（跑题了……）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　心算8皇后感觉有点累，我打算&lt;strong&gt;简化&lt;/strong&gt;问题。从2皇后开始，不过2皇后无解得太昭然若揭了，换成3皇后，无解得也是一目了然，进而思考4皇后的情况（在4X4的棋盘上放4个皇后），于是，有点思考的空间了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一开始，棋盘是空的，第1个皇后可以任意放置，但为了思考方便，最好是按照秩序来尝试，于是先将第1个皇后放置在棋盘第1行第1列格子里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141118061-2138969677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你觉得图中的皇后图标长得很像&lt;strong&gt;ROLEX&lt;/strong&gt;的Logo，是因为我用的就是ROLEX的Logo。毕竟，他们长得实在是太像了。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第1行已经有了皇后，下一步是寻找第2行皇后的位置。在这之前，需要计算出第2行此时未被第1个皇后攻击的棋格分布。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141123715-462534597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上图中呈现的是整个棋盘的状态，但此时关注的重点在第2行。接下来，将第2个皇后放置于第2行第3列棋格中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141129329-1819005651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在，第1行和第2行都有皇后了，重新计算棋盘状态，以寻找第3行的皇后位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141136690-939125521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　经过计算，第3行的所有棋格已经全部处于第1个和第2个皇后的联合攻击范围内了，虽然第4行还有空位，但已经无关紧要，当前尝试可以宣告 Game Over 了。换句话说，刚才的第2个皇后位置不对。调整一下，将第2个皇后从第3列挪到第4列再试试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141154508-144871311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　调整之后，继续更新棋盘状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141201541-1647987062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;　　此时，第&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;行有一个可用的空位，于是将第&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;个皇后放在这个棋格中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141207355-1395343982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后再次更新棋盘状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141213027-1165082141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;strong&gt;Oops&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，又遇到了类似的情况，第&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;行已经没有棋格可以用了，所以，刚才的第&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;个皇后位置不对。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但第&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;行只有一个空位可以用，而这唯一的一个空位又是错误的，这说明，问题还是出在第&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;个皇后的位置上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　再进一步&lt;strong&gt;回溯&lt;/strong&gt;分析，可以发现，第&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;行可用的棋格已经都尝试过了，然而都不对。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以，问题其实出在第&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;个皇后的位置上。也就是说，第一步将皇后放置于第&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;行第&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;列的摆法就错了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　知错就改，善莫大焉。将第&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;个皇后挪到第&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;行第&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;列，重头再来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141219766-903627072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，更新棋盘状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141225975-1509347726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　根据上图，将第&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;个皇后置于第&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;行第&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;列。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141231699-162747494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　继续，更新棋盘状态。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141243686-1703340858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　看上去不错，接着，将第3个皇后置于第3行第1列。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141249004-1694265991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　继续，更新棋盘状态。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141255041-1945395374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　咦，似乎成了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010141301437-179430395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;　　BINGO！&lt;/strong&gt;4皇后的第一个解，找到了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　现在，回顾上面的整个过程，做点抽象，引入一点计算机的思维，就可以得出解题流程了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010134828347-476071542.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　步骤清楚了，现在需要思考的就是过程中很关键的一步——&lt;strong&gt;根据已放置的皇后计算下一行棋格状态&lt;/strong&gt;的逻辑实现。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　这里需要回到国际象棋的规则本身了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　一个皇后在棋盘上的攻击范围如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010134852375-1343026224.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　对这个图做点数学上的抽象分析：棋盘本身是一个标准的坐标平面，每个棋格都有着很明细的坐标位置。所以，上图可以转换成下面的模型：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010134914647-603225123.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　受皇后攻击的点，按照和皇后（Q点）的相对位置，可以分成&lt;strong&gt;4类&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;横向（A1）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;纵向（A2）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;正斜（A3）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;反斜（A4）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　横向攻击其实不用考虑，因为解题的思路本身就是按行来推进的，先天就过滤掉横向攻击点了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　纵向攻击很容易判断，Q点 和 A2点 的 &lt;strong&gt;x&lt;/strong&gt;坐标 相等，就处于攻击范围内。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　不那么直观的是两条斜线的情况，需要算一下。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　将正斜线攻击（A3类点）和反斜线攻击（A4类点）的坐标&lt;strong&gt;转换&lt;/strong&gt;一下，表示成基于Q点的偏移——&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;　　Q：（ x0, y0 ）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;　　正斜线 A3：（ x0 + m, y0 + m ）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;　　反斜线 A4：（ x0 - m, y0 + m ）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　通过观察不难得出规律——&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;　　正斜线上的点：&lt;/strong&gt; (x0 + m) – x0 = (y0 + m) – y0&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　即：&lt;strong&gt;A3点的横坐标值 - Q点的横坐标值 = A3点的纵坐标值 – Q点的纵坐标值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;　　反斜线上的点：&lt;/strong&gt; x0 + y0 = (x0 – m) + (y0 + m)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　即：&lt;strong&gt;Q点横坐标值 + Q点纵坐标值 = A4点横坐标值 + A4点纵坐标值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　自此，&lt;strong&gt;通过皇后所在的棋格判断棋盘上另一处方格是否处于被攻击状态&lt;/strong&gt;的逻辑就全部搞清楚了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　流程和方法都有了，是时候写代码实现具体程序了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　用什么语言来做这事呢？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　QBasic，C，C#，Java，Python，Lua，JavaScript，PHP， ……&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　我在脑袋里慢慢遍历着我所精通的20门语言，俗话说艺不压身，但俗话却没说选择困难症，哎……&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　（以上这段纯属虚构）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　最终，我决定用最近的新欢—— &lt;strong&gt;Go &lt;/strong&gt;语言来写这个程序。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　延续之前的思路，依然将重心放到4皇后的情况，直译上面的分析过程，然后代码差不多长这样：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4皇后&lt;/span&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

func main() {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义4个皇后，初始化坐标为[-1,-1]，即未放置于棋格中。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; (
        queen1 &lt;/span&gt;= [&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;{-&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
        queen2 &lt;/span&gt;= [&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;{-&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
        queen3 &lt;/span&gt;= [&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;{-&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
        queen4 &lt;/span&gt;= [&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;{-&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
    )

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放置第1个皇后&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++ { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历棋盘上的第一行方格(rank1)&lt;/span&gt;
        queen1[&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; i
        queen1[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新第2行棋格状态(此时已放置1个皇后)&lt;/span&gt;
        rank2 :=&lt;span&gt; render(queen1)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放置第2个皇后&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;rank2[i] {
                queen2[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; i
                queen2[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新第3行棋格状态(此时已放置2个皇后)&lt;/span&gt;
                rank3 :=&lt;span&gt; render(queen1, queen2)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放置第3个皇后&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;rank3[i] {
                        queen3[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; i
                        queen3[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;2&lt;/span&gt;
                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新第4行棋格状态(此时已放置3个皇后)&lt;/span&gt;
                        rank4 :=&lt;span&gt; render(queen1, queen2, queen3)
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放置第4个皇后&lt;/span&gt;
                        &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;rank4[i] {
                                queen4[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; i
                                queen4[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;3&lt;/span&gt;
                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 到此，4个皇后均成功置于棋盘中&lt;/span&gt;
                                fmt.Println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;solution:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, queen1, queen2, queen3, queen4)
                            }
                        }
                    }
                }
            }
        }
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据已放置的皇后，更新下一行棋格的状态
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个含4个bool类型元素的数组，true表示受攻击的，false表示未受攻击。&lt;/span&gt;
func render(queens ...[&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;) [&lt;span&gt;4&lt;/span&gt;]&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 国际象棋棋盘中的一行，在英文中叫做：rank&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; rank [&lt;span&gt;4&lt;/span&gt;]&lt;span&gt;bool&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取已放置的皇后的数量，可以得到下一行的索引&lt;/span&gt;
    y :=&lt;span&gt; len(queens)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历下一行的棋格&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; x := &lt;span&gt;0&lt;/span&gt;; x &amp;lt; &lt;span&gt;4&lt;/span&gt;; x++&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _, queen :=&lt;span&gt; range queens {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过已放置的皇后的棋格坐标来判断攻击范围&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; x-queen[&lt;span&gt;0&lt;/span&gt;] == y-queen[&lt;span&gt;1&lt;/span&gt;] ||  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正斜攻击&lt;/span&gt;
                x == queen[&lt;span&gt;0&lt;/span&gt;] ||    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 纵向攻击&lt;/span&gt;
                x+y == queen[&lt;span&gt;0&lt;/span&gt;]+queen[&lt;span&gt;1&lt;/span&gt;] {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反斜攻击&lt;/span&gt;
                rank[x] = &lt;span&gt;true&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一旦判断出该棋格受到攻击，则不用再计算后面的皇后对其影响&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rank
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　运行后结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010135441775-810216337.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;/span&gt;&lt;span&gt;共&lt;strong&gt;2种解&lt;/strong&gt;，并分别给出了每种解法的4皇后的坐标分布。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　说明一下：这里我用到一个包含两整型元素的数组来表示皇后的坐标，每一个中括号里面的第1个数字表示 &lt;strong&gt;x&lt;/strong&gt;轴 坐标（对应棋盘上的列），第2个数字表示 &lt;strong&gt;y&lt;/strong&gt;轴 坐标（对应棋盘上的行）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　现在，4皇后已经解决了，那8皇后呢？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　很简单，我只需要将 &lt;strong&gt;main &lt;/strong&gt;函数里面的 for 循环再写4套，把循环次数改成8，就搞定了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　(开个玩笑~)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　虽然照着上面的代码，写8套循环也确实可以得到正确的结果，但应该没有人有勇气公开地这么干吧。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　所以，上面的代码充其量只能算是个草稿，接下来需要把它改成像样的程序。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　通过前面的分析以及上面的代码，可以很明显地看出4层循环体里的代码逻辑是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　当循环遇上重复时…… &lt;strong&gt;递归&lt;/strong&gt;，就要来了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　但在递归之前，先做点小调整。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　增加一个&lt;strong&gt;const  n&lt;/strong&gt;，用于定义棋盘的维度，避免直接使用字面量“4”；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　将用于存储皇后坐标的4个 &lt;strong&gt;array&lt;/strong&gt; 合成1个 &lt;strong&gt;slice&lt;/strong&gt;，这样就不用做固定次数的初始化了，而且对 &lt;strong&gt;slice&lt;/strong&gt; 的操作也使得代码看上去更讨巧一点。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后，将之前代码中，&lt;strong&gt;main&lt;/strong&gt; 函数里的多重循环部分，精简成一个递归的形式函数调用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放置下一个皇后
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数的参数为已放置的皇后的坐标集&lt;/span&gt;
func place(queens [][&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取已放置的皇后数量&lt;/span&gt;
    y :=&lt;span&gt; len(queens)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当已放置的皇后数量未达到n个之前，继续求解动作&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; y &amp;lt;&lt;span&gt; n {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算下一行的棋格状态&lt;/span&gt;
        nextRank :=&lt;span&gt; render(queens)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x := &lt;span&gt;0&lt;/span&gt;; x &amp;lt; n; x++&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当遍历到下一行的可用棋格时&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; !&lt;span&gt;nextRank[x] {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放置一个皇后&lt;/span&gt;
                queens = append(queens, [&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;span&gt;{x, y})
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后继续尝试下一个皇后的放置&lt;/span&gt;
&lt;span&gt;                place(queens)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当上一句的递归调用结束时，表示本次求解过程的结束
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时，无论求解是否成功，均需要还原本次的状态（即拿起皇后，准备尝试下一次放置）&lt;/span&gt;
                queens =&lt;span&gt; queens[:y]
            }
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当n个皇后均已放置时，表示一次求解的完成
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　之前代码中，用于“根据已放置的皇后计算下一行棋格状态”的 &lt;strong&gt;render&lt;/strong&gt; 函数，无须调整。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　最后，我觉得应该增加一点&lt;strong&gt;可视化&lt;/strong&gt;的工作，将结果直观的打印出来，虽然这不是解题的必要，但数据可视化绝对是一种人文关怀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　加个打印结果的函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印结果
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数说明 - index：当前解法的序号；solution：皇后分布的坐标&lt;/span&gt;
func visualize(index &lt;span&gt;int&lt;/span&gt;, solution [][&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) {
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Solution &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, index)
    fmt.Println(strings.Repeat(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;*n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; y := &lt;span&gt;0&lt;/span&gt;; y &amp;lt; n; y++&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x := &lt;span&gt;0&lt;/span&gt;; x &amp;lt; n; x++&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x == solution[y][&lt;span&gt;0&lt;/span&gt;] &amp;amp;&amp;amp; y == solution[y][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] {
                fmt.Print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Q &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                fmt.Print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;* &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            }
        }
        println()
    }
    fmt.Println(strings.Repeat(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;*n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　函数 &lt;strong&gt;visualize&lt;/strong&gt; 的调用，自然应该发生在 &lt;strong&gt;place&lt;/strong&gt; 函数体的 &lt;strong&gt;else&lt;/strong&gt; 部分，并且顺便记录一下解法的数量（加一个统计变量 &lt;strong&gt;total&lt;/strong&gt;，统计解法总数）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {   
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当n个皇后均已放置时，表示一次求解的完成&lt;/span&gt;
        total++&lt;span&gt;
        visualize(total, queens)
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　最终&lt;/strong&gt;的代码长这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 8 QUEENS PUZZLE&lt;/span&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 棋盘维度&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; n &lt;span&gt;int&lt;/span&gt; = &lt;span&gt;4&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 统计解法总数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; total &lt;span&gt;int&lt;/span&gt;&lt;span&gt;

func main() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于记录已放置的皇后&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; queens [][&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递归求解&lt;/span&gt;
&lt;span&gt;    place(queens)
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放置下一个皇后
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数的参数为已放置的皇后的坐标集&lt;/span&gt;
func place(queens [][&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取已放置的皇后数量&lt;/span&gt;
    y :=&lt;span&gt; len(queens)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当已放置的皇后数量未达到n个之前，继续求解动作&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; y &amp;lt;&lt;span&gt; n {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算下一行的棋格状态&lt;/span&gt;
        nextRank :=&lt;span&gt; render(queens)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x := &lt;span&gt;0&lt;/span&gt;; x &amp;lt; n; x++&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当遍历到下一行的可用棋格时&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; !&lt;span&gt;nextRank[x] {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放置一个皇后&lt;/span&gt;
                queens = append(queens, [&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;span&gt;{x, y})
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后继续尝试下一个皇后的放置&lt;/span&gt;
&lt;span&gt;                place(queens)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当上一句的递归调用结束时，表示本次求解过程的结束
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时，无论求解是否成功，均需要还原本次的状态（即拿起皇后，准备尝试下一次放置）&lt;/span&gt;
                queens =&lt;span&gt; queens[:y]
            }
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当n个皇后均已放置时，表示一次求解的完成&lt;/span&gt;
        total++&lt;span&gt;
        visualize(total, queens)
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据已放置的皇后，更新下一行棋格的状态
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个含4个bool类型元素的数组，true表示受攻击的，false表示未受攻击。&lt;/span&gt;
func render(queens [][&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;) [n]&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rank [n]&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;
    y :&lt;/span&gt;=&lt;span&gt; len(queens)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x := &lt;span&gt;0&lt;/span&gt;; x &amp;lt; n; x++&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _, queen :=&lt;span&gt; range queens {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x-queen[&lt;span&gt;0&lt;/span&gt;] == y-queen[&lt;span&gt;1&lt;/span&gt;] ||&lt;span&gt;
                x &lt;/span&gt;== queen[&lt;span&gt;0&lt;/span&gt;] ||&lt;span&gt;
                x&lt;/span&gt;+y == queen[&lt;span&gt;0&lt;/span&gt;]+queen[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] {
                rank[x] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rank
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印结果
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数说明 - index：当前解法的序号；solution：皇后分布的坐标&lt;/span&gt;
func visualize(index &lt;span&gt;int&lt;/span&gt;, solution [][&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) {
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Solution &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, index)
    fmt.Println(strings.Repeat(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;*n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; y := &lt;span&gt;0&lt;/span&gt;; y &amp;lt; n; y++&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x := &lt;span&gt;0&lt;/span&gt;; x &amp;lt; n; x++&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x == solution[y][&lt;span&gt;0&lt;/span&gt;] &amp;amp;&amp;amp; y == solution[y][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] {
                fmt.Print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Q &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                fmt.Print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;* &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            }
        }
        println()
    }
    fmt.Println(strings.Repeat(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;*n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　运行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010140013666-1803739785.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　将 const n int = 4 改成 const n int = 8 .&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;　　终于，&lt;/strong&gt;得到八皇后的答案了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010140028400-4275619.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　共&lt;strong&gt;92&lt;/strong&gt;种&lt;strong&gt;互不相同&lt;/strong&gt;的解。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　拿到结果了，可以再研究研究过程了。去掉可视化工作，只计算解法数量，然后看看程序的性能。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　注释掉 &lt;strong&gt;visualize&lt;/strong&gt; 函数的调用，并将 &lt;strong&gt;main&lt;/strong&gt; 函数改造一下，统计程序运行的时间：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;func main() {

    start :&lt;/span&gt;=&lt;span&gt; time.Now()

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于记录已放置的皇后&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; queens [][&lt;span&gt;2&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递归求解&lt;/span&gt;
&lt;span&gt;    place(queens)

    end :&lt;/span&gt;=&lt;span&gt; time.Now()
    elapsed :&lt;/span&gt;=&lt;span&gt; end.Sub(start)
    
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Total:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, total)
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Elapsed:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, elapsed)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　在我老旧的一款ThinkPad E系列笔记本上&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010140118528-2114401551.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　运行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010140225278-1659317960.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;　　998微秒，不到1毫秒&lt;/strong&gt;，看上去不错。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　至此，八皇后的问题彻底完结。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　事实上，&lt;strong&gt;n&lt;/strong&gt;皇后的问题也顺便完结了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　将常量&lt;strong&gt;n&lt;/strong&gt;改成9，试试看：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010140246432-377490042.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　共&lt;strong&gt;352&lt;/strong&gt;种互不相同的解，耗时&lt;strong&gt;1.99毫秒&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;　　n = 10 &lt;/strong&gt;时：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010140259788-1447888491.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;　　8.99毫秒&lt;/strong&gt;算出&lt;strong&gt;724&lt;/strong&gt;种互不相同的解。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　就这样吧……&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;后 记&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;本来以为这个问题就算研究完了，直到有一天和老爸的另一次通话——&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;“你上次找老子要国际象棋的那个问题，后来想出来没有？”&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;“爸，那小儿科我当天挂完电话，分分钟就解出来了。”&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;“滚远点，怕不是买了4副象棋吧？”&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;“怎么可能，我可以心算8盘棋。”&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;“滚远点，你那个问题我后来也想了的，很简单的问题啊。”&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;“啊？”（What？？？ 老爸也解八皇后？）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;“你题目只说了摆八个皇后，没说不让摆其它的棋子，对吧？你用其它的兵啊、马啊等棋子把八个皇后隔开，就可以做到互不攻击了。”&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;“@#￥%&amp;amp;*……”&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;“还有事吗？”&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;“没没，没了，爸。”（持续晕眩中）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;“早点休息，多喝水，天气冷了注意加衣服，少熬夜。就这。”&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;——对方挂断通话&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;附：老爸的解法&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/788453/201810/788453-20181010140324632-1118286923.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Oct 2018 07:19:00 +0000</pubDate>
<dc:creator>sherrywasp</dc:creator>
<og:description>“还记得八皇后的解法吗？” “上个世纪的事情，不记得了。” “…… 现在回忆一下？” “开会，回头说。” “ fuck u ” “ u shit ” 我有一个C++基友，这么称呼是因为他入行时用的是C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sherrywasp/p/9765921.html</dc:identifier>
</item>
<item>
<title>读研or工作？对计算机类专业学习的看法 - iTryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/9764002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/9764002.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;先来介绍一下自己&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;　中南大学（不知名985双一流A类）大二计算机专业本科生，才学编程1年多一点。大一的时候搞了大半年ACM，现在慢慢转向项目开发（在学习JAVA开发，U3D和C#），同时在学习机器学习、大数据等内容，混进了学校的图灵班。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面进入正题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;以后是读研还是直接工作？&lt;/strong&gt;这个问题可能困扰了很多读计算机类的本科生。大一刚入学的时候，我的想法是不读研，之后直接去工作，为什么呢？我当时报计算机专业的时候想的是以后要做游戏开发，那读不读研完全是不重要了，搞好技术，自然就行。今年暑假的时候，去表哥的公司呆了一暑假，当时放弃了ACM暑假集训（相当于退队了，寒假开始可能会回去接着搞），虽然还是有些后悔，但是也有了蛮多收获，一个是见识稍微广了些，想的更远了，二是敢于去接触一些看起来很高大上的领域（如人工智能等）。开学后，写了些关于机器学习方面的程序，去听了一些学术研讨会，慢慢开始有了读研的想法，所以纠结了好一阵子，我觉的我纠结的更大一部分原因就是认识面小，不知道在BAT这些大公司里工作是什么一种感受，感觉只有出去实习几次，才能更好做出抉择。但这段时间跟一些大神级的前辈交流之后，想的是技术方面接着搞（下大功夫搞），学业方面还是稍微抓一抓。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面一段话讲的还是我这一年来的一些经历，下面就讲讲我的看法。一般来说，对于&lt;span&gt;刚进入大一&lt;/span&gt;的同学来说，你们可能还没考虑过自己以后的发展路线，那么这时候可以边走边看，先把成绩搞起来（简单地说就是刷绩点），边学习边思考、规划未来，而不是想着以后是读研还是直接工作，这个问题&lt;strong&gt;等你们到了真正需要选择的那天再考虑&lt;/strong&gt;，什么是真正需要选择的时候呢？就是你们既有保研名额，又有BAT的offer的时候，到这时候再考虑也不迟，这时候你们可以&lt;strong&gt;根据自己的兴趣&lt;/strong&gt;来选，如果是对科研方面更感兴趣，当然是保研无疑了，但对开发更有兴趣，那直接工作可能会更好，毕竟读研是搞研究去了，开发方面的东西研究生学不到什么。表示有些后悔大一的时候直接把绩点丢了。对于大二大三的同学来说，目前成绩能拿到保研名额或是争取一下还是有希望拿到的，最好要拿到，多一个选择总没错。而对于保研大体上没戏的，如果你决定要考研，那自然没什么话讲，当然是去考了。那不准备考研的，自然就是选择直接工作了（除了那些现在还是成天浑浑噩噩的同学），那该怎么做？我没经历过，自然不太懂该怎么做，但我也听了许多在BAT等大公司工作的学长学姐的分享，我还是谈谈自己的看法吧。（以下看法对读研的同学来说也会适用）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;毫无疑问，有一份好的简历，更容易取得面试资格（好像有时候想去某实验室学习也是需要投简历的），并且，需要从现在就开始准备简历，好的简历不是一时半刻就能写出来的，都是经过长时间的修改加工才能做出来的。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;2.平时敲代码！多敲代码！！&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;　　为什么这么说呢？现在放眼望去，学习编程的人不在少数，你要如何与他们竞争呢？一是学历，这点我们不能否认，二是自身的硬实力，而这硬实力是怎么练出来的？就是平时的积累，多敲代码，但我们要做的不应该是所谓的码农，因此我们还需要多思考，多学习。我始终相信一句话，积少成多，方能成大器。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;3.敢于去接触一些&lt;span&gt;看起来&lt;/span&gt;挺高深的东西&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;　　我现在是准备去学校的一个实验室学习有关机器学习、大数据这些方面的内容。对要准备读研的同学来说这点是肯定的了，而对于本科毕业就准备出去工作的同学，想想几年后，自己相比于读研的同学，优势在哪里?绝大部分只是经验，而这经验等他们工作几年后也算不上是优势了，时代在发展，我们要学的东西越来越多，不想被淘汰，就需要去接触这些，撸起袖子就是干，不管会不会，不学肯定不会。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;4.多关注关注外面&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　&lt;span&gt;平时多参加些比赛，拿不拿奖不重要，关键是要出去见识见识，见的多了就会有更好的想法。还多与一些厉害的学长学姐交流，有时他们的一些经历或是想法是能让自己更清楚地知道接下来该怎么走的。还有就是，关注前沿的技术，不断学习才能更加强大。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;5.精一门，懂多门&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;　　就是编程涉及的各方面都涉及了解一下，见识的多对自己未来的发展没有坏处，但得要有自己一个专精的地方，得靠这个吃饭。读研的自然也一样，你们研究的方向自然就是精的那门，那只满足与这一门就够了吗？要知道，每一门技术都不是孤立存在的，一定是与其他的技术有关联，涉猎的范围广了，对于一个问题的分析会更加透彻，想的也会更远。像我去年的时候，想的就是做个游戏开发，但接触了一段时间机器学习之后，我想法就稍微变了，现在想的是以后做的是游戏中AI的开发（个人认为，一个优秀的游戏少不了好的AI）。总结一下就是学归学，总的方向肯定不变，学了只是为了更好地实现自己地目标。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;最后我想说直接工作并不代表以后你就比不上读研的同学，说实话，我们得承认读三年研究生能学到不少东西，但是工作三年期间，不代表你不能学他们学的，不代表几年后你就比不过他们&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上就是我目前的一些看法，如有说的不好的地方，请多多包涵，同时希望各位大神、前辈们能给些学习上的建议。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Oct 2018 06:01:00 +0000</pubDate>
<dc:creator>iTryagain</dc:creator>
<og:description>先来介绍一下自己 中南大学（不知名985双一流A类）大二计算机专业本科生，才学编程1年多一点。大一的时候搞了大半年ACM，现在慢慢转向项目开发（在学习JAVA开发，U3D和C#），同时在学习机器学习、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/csu-lmw/p/9764002.html</dc:identifier>
</item>
<item>
<title>MyBatis（8）延迟加载&amp;缓存 - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/9763867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/9763867.html</guid>
<description>&lt;p&gt;&lt;span&gt;什么是延迟加载？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;resultMap可以实现高级映射，association，collection具有延迟加载的功能。&lt;/p&gt;

&lt;p&gt;当我们需要查询某个信息的时候，再去查询，达到按需查询，就是延迟加载&lt;/p&gt;

&lt;p&gt;可以大大提高数据库的性能&lt;/p&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;那么我们代码撸起来把：&lt;/p&gt;
&lt;p&gt;延迟加载我们首先要在全局配置文件中开启：&lt;/p&gt;
&lt;p&gt;SQlMapConfig.xml:&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
     &amp;lt;!-- 延迟加载 --&amp;gt;
     &amp;lt;settings&amp;gt;
           &amp;lt;setting name=&quot;&lt;span&gt;lazyLoadingEnabled&lt;/span&gt;&quot; value=&quot;&lt;span&gt;true&lt;/span&gt;&quot;/&amp;gt;
           &amp;lt;setting name=&quot;&lt;span&gt;aggressiveLazyLoading&lt;/span&gt;&quot; value=&quot;&lt;span&gt;false&lt;/span&gt;&quot;/&amp;gt;
     &amp;lt;/settings&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;lazyLoadingEnabled&lt;/span&gt;:全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;aggressiveLazyLoading&lt;/span&gt;:当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;其次是OrderMapperCustomer.xml映射文件：&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
     &amp;lt;!-- 延迟加载 --&amp;gt;
           &amp;lt;resultMap type=&quot;com.MrChengs.po.Orders&quot; id=&quot;slow&quot;&amp;gt;
                &amp;lt;id column=&quot;id&quot; property=&quot;id&quot;/&amp;gt;
                &amp;lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&amp;gt;
                &amp;lt;result column=&quot;number&quot; property=&quot;number&quot;/&amp;gt;
                &amp;lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&amp;gt;
                &amp;lt;result column=&quot;note&quot; property=&quot;note&quot;/&amp;gt;
                
                     &amp;lt;!--&lt;span&gt; 实现对用户信息进行延迟加载
                     select：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement）
                     要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询，如果findUserById不在本mapper中需要前边加namespace
                     column：订单信息中关联用户信息查询的列，是user_id
                     关联查询的sql理解为：
                     SELECT orders.&lt;/span&gt;*&lt;span&gt;,
                     (SELECT username FROM USER WHERE orders.user_id &lt;/span&gt;=&lt;span&gt; user.id)username,
                     (SELECT sex FROM USER WHERE orders.user_id &lt;/span&gt;=&lt;span&gt; user.id)sex
                            FROM orders
                      &lt;/span&gt;--&amp;gt;
                &lt;span&gt;&amp;lt;association property=&quot;user&quot; javaType=&quot;com.MrChengs.po.User&quot;
                select=&quot;com.MrChengs.mapper.UserMapper.findUserById&quot; column=&quot;user_id&quot;&amp;gt;&amp;lt;/association&amp;gt;
               &lt;/span&gt; 
           &amp;lt;/resultMap&amp;gt;
           &amp;lt;select id=&quot;findSlowing&quot; resultMap=&quot;slow&quot;&amp;gt;&lt;span&gt;
                SELECT &lt;/span&gt;*&lt;span&gt; from orders
           &lt;/span&gt;&amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试文件：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延迟加载&lt;/span&gt;
&lt;span&gt;           @Test
           &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testfindSlowing() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                SqlSession sqlSession &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory().openSession();
                
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理对象&lt;/span&gt;
                OrderMapperCustomer mapper = sqlSession.getMapper(OrderMapperCustomer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试findOrderUsers&lt;/span&gt;
                List&amp;lt;Orders&amp;gt; orders =&lt;span&gt; mapper.findSlowing();
                
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Orders order : orders){
                  &lt;span&gt;   User user &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; order.getUser();&lt;/span&gt;
                     System.out.println(user);
                }
                
                sqlSession.close();
           }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;13.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
DEBUG [main] - Setting autocommit to &lt;span&gt;false&lt;/span&gt;&lt;span&gt; on JDBC Connection [com.mysql.jdbc.JDBC4Connection@8e24743]
DEBUG [main] &lt;/span&gt;- ==&amp;gt;  Preparing: SELECT *&lt;span&gt; from orders
DEBUG [main] &lt;/span&gt;- ==&amp;gt;&lt;span&gt; Parameters:
DEBUG [main] &lt;/span&gt;- &amp;lt;==      Total: 3&lt;span&gt;
DEBUG [main] - ==&amp;gt;  Preparing: select * from user where id=?&lt;/span&gt;&lt;span&gt;
DEBUG [main] &lt;/span&gt;- ==&amp;gt; Parameters: 1&lt;span&gt;(Integer)
DEBUG [main] &lt;/span&gt;- &amp;lt;==      Total: 1&lt;span&gt;
User [id&lt;/span&gt;=1, username=王五, birthday=&lt;span&gt;null&lt;/span&gt;, sex=2, address=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;]
User [id&lt;/span&gt;=1, username=王五, birthday=&lt;span&gt;null&lt;/span&gt;, sex=2, address=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;]
&lt;span&gt;DEBUG [main] &lt;/span&gt;&lt;/span&gt;&lt;span&gt;- ==&amp;gt;  Preparing: select * from user where id=?&lt;/span&gt;&lt;span&gt;
DEBUG [main] &lt;/span&gt;- ==&amp;gt; Parameters: 10&lt;span&gt;(Integer)
DEBUG [main] &lt;/span&gt;- &amp;lt;==      Total: 1&lt;span&gt;
User [id&lt;/span&gt;=10, username=张三, birthday=Thu Jul 10 00:00:00 CST 2014, sex=1, address=&lt;span&gt;北京市]
DEBUG [main] &lt;/span&gt;- Resetting autocommit to &lt;span&gt;true&lt;/span&gt; on JDBC Connection [com.mysql.jdbc.JDBC4Connection@8e24743]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;


&lt;p&gt;&lt;span&gt;缓存：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;用于减轻数据库压力，提高数据库的性能&lt;/p&gt;
&lt;p&gt;mybatis提供一级缓存&amp;amp;二级缓存&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;17&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201810/1488757-20181009232832626-340140666.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;在操作数据库时需构造sqlsession对象，在对象中有一个数据结构（HashMap）用于存储数据&lt;/p&gt;
&lt;p&gt;不同的sqlsession之间的缓存数据区域时互不影响的&lt;/p&gt;

&lt;p&gt;一级缓存：是sqlsession级别的缓存&lt;/p&gt;

&lt;p&gt;二级缓存：是mapper级别的缓存多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。&lt;/p&gt;


&lt;p&gt;为什么需要缓存：&lt;/p&gt;
&lt;p&gt;如果缓存中有数据就不需要从数据库中获取，提高系统性能。&lt;/p&gt;
&lt;/div&gt;



&lt;p&gt;&lt;span&gt; 一级缓存：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 工作原理：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201810/1488757-20181009232931573-355437722.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;第一次查询先去缓存中查询，若没有则取数据库中查询&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;如果sqlsession去执行commit操作（插入，删除，更新），清空sqlsession中的一级缓存，使存储区域得到最新的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;信息，避免脏读。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;8&quot;&gt; 
&lt;p&gt;第二次在查询第一次数据，首先在缓存中查找，找到了则不再去数据库想查询&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 默认支持一级缓存，不需要手动去开启。&lt;/span&gt;&lt;/p&gt;


&lt;div&gt; 
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;p&gt;在testUserMapper.java&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一级缓存&lt;/span&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testCahseFiret() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
           SqlSession sqlSession &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory().openSession();
           UserMapper mapper &lt;/span&gt;= sqlSession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次查询&lt;/span&gt;
&lt;span&gt;           
           User user &lt;/span&gt;= mapper.findUserById(1&lt;span&gt;);
           System.out.println(user);
           
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二次查询&lt;/span&gt;
           User user1 = mapper.findUserById(1&lt;span&gt;);
           System.out.println(user1);

            sqlsession.close();
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;由此可见，查询时，只查询了一次&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
DEBUG [main] - Setting autocommit to &lt;span&gt;false&lt;/span&gt;&lt;span&gt; on JDBC Connection [com.mysql.jdbc.JDBC4Connection@8e24743]
&lt;span&gt;DEBUG [main] &lt;/span&gt;&lt;/span&gt;&lt;span&gt;- ==&amp;gt;  Preparing: select * from user where id=?&lt;/span&gt;&lt;span&gt;
DEBUG [main] &lt;/span&gt;- ==&amp;gt; Parameters: 1&lt;span&gt;(Integer)
DEBUG [main] &lt;/span&gt;- &amp;lt;==      Total: 1&lt;span&gt;
User [id&lt;/span&gt;=1, username=王五, birthday=&lt;span&gt;null&lt;/span&gt;, sex=2, address=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;]
User [id&lt;/span&gt;=1, username=王五, birthday=&lt;span&gt;null&lt;/span&gt;, sex=2, address=&lt;span&gt;null&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; 有清空操作：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testCahseFiret() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
           SqlSession sqlSession &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory().openSession();
           UserMapper mapper &lt;/span&gt;= sqlSession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次查询&lt;/span&gt;
&lt;span&gt;           
           User user &lt;/span&gt;= mapper.findUserById(1&lt;span&gt;);
           System.out.println(user);
           
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;
           User adduser = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
           adduser.setUsername(&lt;/span&gt;&quot;Mr&quot;&lt;span&gt;);
           adduser.setSex(&lt;/span&gt;1&lt;span&gt;);
           mapper.addUser(user);
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空缓存&lt;/span&gt;
&lt;span&gt;           sqlSession.commit();
           
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二次查询&lt;/span&gt;
           User user1 = mapper.findUserById(1&lt;span&gt;);
           System.out.println(user1);
           
           sqlSession.close();
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果： &lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;19.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
DEBUG [main] -&lt;span&gt; Opening JDBC Connection
DEBUG [main] &lt;/span&gt;- Created connection 149047107&lt;span&gt;.
DEBUG [main] &lt;/span&gt;- Setting autocommit to &lt;span&gt;false&lt;/span&gt;&lt;span&gt; on JDBC Connection [com.mysql.jdbc.JDBC4Connection@8e24743]
DEBUG [main] &lt;/span&gt;- ==&amp;gt;  Preparing: select * from user where id=?&lt;span&gt;
DEBUG [main] &lt;/span&gt;- ==&amp;gt; Parameters: 1&lt;span&gt;(Integer)
DEBUG [main] &lt;/span&gt;- &amp;lt;==      Total: 1&lt;span&gt;
User [id&lt;/span&gt;=1, username=王五, birthday=&lt;span&gt;null&lt;/span&gt;, sex=2, address=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;]
DEBUG [main] &lt;/span&gt;- ==&amp;gt;  Preparing: insert into user(id,username,birthday,sex,address) value(?,?,?,?,?&lt;span&gt;)
DEBUG [main] &lt;/span&gt;- ==&amp;gt; Parameters: 1(Integer), 王五(String), &lt;span&gt;null&lt;/span&gt;, 2(Integer), &lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一级缓存的应用：&lt;/p&gt;
&lt;p&gt;正式开发，是将mybatis和spring进行整合，事物控制在service中&lt;/p&gt;
&lt;p&gt;一个servic包括很多mapper方法调用&lt;/p&gt;
&lt;/div&gt;





&lt;p&gt;&lt;span&gt; 二级缓存：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;25&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201810/1488757-20181009233234284-414708067.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;span&gt;首先开启mybatis的二级缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果SqlSession3去执行相同 mapper下sql，执行commit提交，清空该 mapper下的二级缓存区域的数据。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;sqlSession2去查询用户id为1的用户信息，去缓存中找是否存在数据，如果存在直接从缓存中取出数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二级缓存与一级缓存区别，二级缓存的范围更大，多个sqlSession可以共享一个UserMapper的二级缓存区域。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;UserMapper有一个二级缓存区域（按namespace分） ，其它mapper也有自己的二级缓存区域（按namespace分）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;每一个namespace的mapper都有一个二缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同 的二级缓存区域中。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;



&lt;div&gt; 

&lt;p&gt;&lt;span&gt;开启二级缓存：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &amp;lt;settings&amp;gt;
           &amp;lt;!-- 开启二级缓存 --&amp;gt;
           &amp;lt;setting name=&quot;&lt;span&gt;cacheEnabled&lt;/span&gt;&quot; value=&quot;true&quot;/&amp;gt;
     &amp;lt;/settings&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;cacheEnabled&lt;/span&gt;：&lt;span data-en-paragraph=&quot;true&quot; data-en-has-metadata=&quot;true&quot;&gt;对在此配置文件下的所有&lt;span data-en-paragraph=&quot;true&quot; data-en-has-metadata=&quot;true&quot;&gt;cache 进行全局性开/关设置。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;开启mapper下的二级缓存：&lt;/p&gt;
&lt;p&gt;UserMapper.xml&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &amp;lt;!-- 开启本mapper的namespace下的二级缓存 --&amp;gt;
     &amp;lt;&lt;span&gt;cache&lt;/span&gt;&amp;gt;
     
     &amp;lt;/&lt;span&gt;cache&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 实现pojo类实现里序列化接口：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User  &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{
......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;为了将存储数据取出执行反序列化的操作，以内二级缓存存储介质多种多种杨，不一定在内存&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt; 测试类 ：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二级缓存&lt;/span&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testCahseSecond() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
           SqlSession sqlSession &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory().openSession();
           SqlSession sqlSession1 &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory().openSession();
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次查询&lt;/span&gt;
           UserMapper mapper = sqlSession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
           User user &lt;/span&gt;= mapper.findUserById(1&lt;span&gt;);
           System.out.println(user);
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将执行关闭操作，将sqlsession写道二级缓存&lt;/span&gt;
&lt;span&gt;           sqlSession.close();
           
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二次查询&lt;/span&gt;
           UserMapper mapper2 = sqlSession1.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
           User user1 &lt;/span&gt;= mapper2.findUserById(1&lt;span&gt;);
           System.out.println(user1);
           sqlSession1.close();
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;11.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
DEBUG [main] - Setting autocommit to &lt;span&gt;false&lt;/span&gt;&lt;span&gt; on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1990a65e]
&lt;span&gt;DEBUG [main] &lt;/span&gt;&lt;/span&gt;&lt;span&gt;- ==&amp;gt;  Preparing: select * from user where id=?&lt;/span&gt;&lt;span&gt;
DEBUG [main] &lt;/span&gt;- ==&amp;gt; Parameters: 1&lt;span&gt;(Integer)
DEBUG [main] &lt;/span&gt;- &amp;lt;==      Total: 1&lt;span&gt;
User [id&lt;/span&gt;=1, username=王五, birthday=&lt;span&gt;null&lt;/span&gt;, sex=2, address=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;]
DEBUG [main] &lt;/span&gt;- Resetting autocommit to &lt;span&gt;true&lt;/span&gt;&lt;span&gt; on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1990a65e]
DEBUG [main] &lt;/span&gt;-&lt;span&gt; Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@1990a65e]
DEBUG [main] &lt;/span&gt;- Returned connection 428910174&lt;span&gt; to pool.
DEBUG [main] &lt;/span&gt;- Cache Hit Ratio [com.MrChengs.mapper.UserMapper]: 0.0&lt;span&gt;
DEBUG [main] &lt;/span&gt;-&lt;span&gt; Opening JDBC Connection
&lt;span&gt;DEBUG [main] &lt;/span&gt;&lt;/span&gt;&lt;span&gt;- Created connection 1873859565.
DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@6fb0d3ed]
DEBUG [main] - ==&amp;gt;  Preparing: select * from user where id=?&lt;/span&gt;&lt;span&gt;
DEBUG [main] &lt;/span&gt;- ==&amp;gt; Parameters: 1&lt;span&gt;(Integer)
DEBUG [main] &lt;/span&gt;- &amp;lt;==      Total: 1&lt;span&gt;
User [id&lt;/span&gt;=1, username=王五, birthday=&lt;span&gt;null&lt;/span&gt;, sex=2, address=&lt;span&gt;null&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div readability=&quot;21&quot;&gt; 
&lt;p&gt;一些简单的参数配置：&lt;/p&gt;

&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;useCache：为fasle时，禁用缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;select id=&quot;&quot; &lt;span&gt;useCache&lt;/span&gt;=&quot;true&quot;&amp;gt;&amp;lt;/select&amp;gt;&lt;/p&gt;
&lt;p&gt;针对每次查询都需要最新数据的sql&lt;/p&gt;

&lt;p&gt;2.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flushCache：刷新缓存，实质就是清空缓存，刷寻缓存可以避免数据的脏读&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;select id=&quot;&quot; flushCache=&quot;true&quot;&amp;gt;&amp;lt;/select&amp;gt;&lt;/p&gt;

&lt;p&gt;3.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flushInterval：刷新间隔，可以设置任意的毫秒数，代表一个何况i的时间段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;cache flushInterval=&quot;&quot; /&amp;gt;&lt;/p&gt;
&lt;/div&gt;




&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;mybatis整合ehcache&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;ehcache分布式的缓存&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201810/1488757-20181009233758767-1681263352.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统 开发。所以要使用分布式缓存对缓存数据进行集中管理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;7&quot;&gt; 
&lt;p&gt;整和方法：&lt;/p&gt;
&lt;p&gt;mybatis提供了cache接口，如果要实现自己的缓存逻辑，实现cache接口即可&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt; 在mybatis包里的cache类里面&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201810/1488757-20181009233827196-350904123.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;



&lt;div readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;span&gt;二级缓存应用场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。&lt;/p&gt;
&lt;p&gt;实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;二级缓存的局限性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。&lt;/p&gt;
&lt;/div&gt;




</description>
<pubDate>Wed, 10 Oct 2018 04:41:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>什么是延迟加载？ resultMap可以实现高级映射，association，collection具有延迟加载的功能。 当我们需要查询某个信息的时候，再去查询，达到按需查询，就是延迟加载 可以大大提高</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/9763867.html</dc:identifier>
</item>
<item>
<title>Mybatis入门（一） - Miya。</title>
<link>http://www.cnblogs.com/SimpleWu/p/9765552.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/9765552.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;Editor：SimpleWu&lt;/p&gt;
&lt;h2 id=&quot;mybatis简介&quot;&gt;MyBatis简介&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。&lt;/li&gt;
&lt;li&gt;MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;MyBatis参考资料官网&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;http://www.mybatis.org/mybatis-3/zh/index.html&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MyBatis下载地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;https://github.com/mybatis/mybatis-3&lt;/p&gt;
&lt;h2 id=&quot;mybatis的优势&quot;&gt;MyBatis的优势&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;开源的优秀的持久层框架&lt;/li&gt;
&lt;li&gt;SQL语句与代码分离&lt;/li&gt;
&lt;li&gt;面向配置的编程&lt;/li&gt;
&lt;li&gt;良好支持复杂数据映射&lt;/li&gt;
&lt;li&gt;动态SQL&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mybatis开发步骤&quot;&gt;MyBatis开发步骤&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;添加需要的jar包&quot;&gt;1.添加需要的jar包&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;p&gt;1）mybatis-3.3.0 核心包（如果需要日志操作，可以导入依赖包）&lt;/p&gt;
&lt;p&gt;2）数据库驱动（mysql-connector-java-5.1.22-bin）&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;创建数据库添加测试数据&quot;&gt;2.创建数据库，添加测试数据&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;create table `tal_employee` (
    `id` int (11),
    `last_name` varchar (360),
    `email` varchar (300),
    `gender` char (9)
); &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;INSERT INTO `tal_employee` (`id`, `last_name`, `email`, `gender`) VALUES('1','韩信','hanxin@gemail.com','男');
INSERT INTO `tal_employee` (`id`, `last_name`, `email`, `gender`) VALUES('2','LiBaihH','libai@gemail.com','男');
INSERT INTO `tal_employee` (`id`, `last_name`, `email`, `gender`) VALUES('3','孙尚香','sunshangxiang@gemail.com','女');
INSERT INTO `tal_employee` (`id`, `last_name`, `email`, `gender`) VALUES('4','安琪拉','anqila@gemail.com','女');
INSERT INTO `tal_employee` (`id`, `last_name`, `email`, `gender`) VALUES('5','Hello','Hello@gemail.com','男');
INSERT INTO `tal_employee` (`id`, `last_name`, `email`, `gender`) VALUES('6','Miya','Miya@gemail.com','男');&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;创建实体类&quot;&gt;3.创建实体类&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Employee {
    private Integer id;
    private String lastName;
    private String email;
    private String gender;
    //此处省略get set toString。。。
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;创建实体类映射配置文件&quot;&gt;4.创建实体类映射配置文件&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;!-- 该配置命名空间 --&amp;gt;
&amp;lt;mapper namespace=&quot;EmployeeMapper&quot;&amp;gt;
    &amp;lt;!-- 定义一个查询方法  resultType 返回值类型--&amp;gt;
    &amp;lt;select id=&quot;findAll&quot; resultType=&quot;com.simple.mybatis.entitys.Employee&quot;&amp;gt;
        select * from tal_employee
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;创建mybatis主配置文件&quot;&gt;5.创建mybatis主配置文件&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; 
&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!-- 配置环境  default默认使用环境名字--&amp;gt;
    &amp;lt;environments default=&quot;development&quot;&amp;gt;
        &amp;lt;!-- 配置一个环境 --&amp;gt;
        &amp;lt;environment id=&quot;development&quot;&amp;gt;
            &amp;lt;!-- 使用事务JDBC事务管理器 --&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot; /&amp;gt;
            &amp;lt;!-- 配置数据库连接 --&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;root&quot; /&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;root&quot; /&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;!-- 加载映射 --&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&quot;com/simple/mybatis/entitys/EmployeeMapper.xml&quot; /&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;编写代码见下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;获取sqlsessionfactory对象&quot;&gt;获取SqlSessionFactory对象&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private SqlSessionFactory sqlSessionFactory;
    @Before
    public void init() throws IOException{
        //读取mybatis主配置文件
        InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
        /**
         * 实例化SqlSessionFactory
         * 如果没有指定默认环境，可以在这里指定使用的环境ID，比如我先在有个DEV环境
         * sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream,&quot;DEV&quot;);
         * 我这里已经使用了默认环境所以我就不用这种方式创建了
         */
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;访问数据库&quot;&gt;访问数据库&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;获取SqlSession对象，作用于与数据库的一次回话作用于与数据库的一次回话&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SqlSession session = sqlSessionFactory.openSession();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;获取所有员工记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;EmployeeMapper就是我们实体类映射文件的命名空间，findAll就是我们select标签的ID&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;Employee&amp;gt; employees = session.selectList(&quot;EmployeeMapper.findAll&quot;);
        for (Employee employee : employees) {
            System.out.println(employee);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Employee [id=1, lastName=null, email=hanxin@gemail.com, gender=男]
Employee [id=2, lastName=null, email=libai@gemail.com, gender=男]
Employee [id=3, lastName=null, email=sunshangxiang@gemail.com, gender=女]
Employee [id=4, lastName=null, email=anqila@gemail.com, gender=女]
Employee [id=5, lastName=null, email=Hello@gemail.com, gender=男]
Employee [id=6, lastName=null, email=Miya@gemail.com, gender=男]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里我们访问数据库是正常的，为什么lastName为空呢？&lt;/p&gt;
&lt;h2 id=&quot;解决表字段与类属性名不对应&quot;&gt;解决表字段与类属性名不对应&lt;/h2&gt;
&lt;p&gt;原因：应为我们这里实体类上的属性叫做lastName与数据库列last_name名字不对应所以获取的值为空&lt;/p&gt;
&lt;p&gt;解决方案1：将实体类映射文件的中select标签中的取别名&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;findAll&quot; resultType=&quot;com.simple.mybatis.entitys.Employee&quot;&amp;gt;
        select id,last_name AS lastName,email,gender from tal_employee
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方案2：在mybatis主配置文件中配置驼峰式命名，需要将配置排在前面否则XML报错&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;settings&amp;gt;
    &amp;lt;!-- 开启驼峰式命名规则 --&amp;gt;
    &amp;lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&amp;gt;
&amp;lt;/settings&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方案2我们类中属性lastName会匹配数据库字段last_name&lt;/p&gt;
&lt;h2 id=&quot;使用日志查看sql语句等&quot;&gt;使用日志查看SQL语句等&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首先我们需要添加mybatis依赖包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;添加log4j.properties&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;#设置输出级别和输出位置
log4j.rootLogger=debug,Console
#设置控制台相关的参数
log4j.appender.Console=org.apache.log4j.ConsoleAppender  
log4j.appender.Console.layout=org.apache.log4j.PatternLayout  
log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n  
#设置MyBatis的输出内容
log4j.logger.java.sql.ResultSet=INFO  
log4j.logger.org.apache=INFO  
log4j.logger.java.sql.Connection=DEBUG  
log4j.logger.java.sql.Statement=DEBUG  
log4j.logger.java.sql.PreparedStatement=DEBUG&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就可以使用log4j来查看我们的sql语句啊，传入的参数啊。。等等&lt;/p&gt;
&lt;h2 id=&quot;mybatis的配置文件&quot;&gt;MyBatis的配置文件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通过前面简单的MyBatis案例，大家应该了解到了MyBatis框架的基本结构，和Hibernate一样，MyBatis包含了一个核心配置文件和映射文件。&lt;/li&gt;
&lt;li&gt;核心配置文件(mybatis-config.xml)：包含了对Mybatis的核心配置，包含连接池信息，事务，加载映射文件，参数设置等配置。&lt;/li&gt;
&lt;li&gt;映射文件(EmployeeMapper.xml）：主要实现实体对象对数据库的映射，关联关系，Sql语句等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;核心配置文件&quot;&gt;核心配置文件&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td/&gt;
&lt;td&gt;配置环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;一些外部属性，这些属性可以被替换&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;Mybatis中极为重要的调整设置，会改变Mybatis的默认行为。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;为Java类型设置一个别名，它只和xml配置有关。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;映射器，加载MyBatis的映射文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;插件，Mybatis允许用户在映射的某一点进行拦截。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;环境配置&quot;&gt;环境配置&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Mybatis可以通过配置多种环境，比如开发环境、测试环境和生产环境等。&lt;/li&gt;
&lt;li&gt;不过要记住，尽管可以配置多个环境，但是SqlSessionFactory对象只能加载一个。如果你需要同时连接多个数据库，需要创建多个SqlSessionFactory实例。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;事务管理&quot;&gt;事务管理&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在 MyBatis 来进行事务的设置，其中有两种类型的事务管理器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;JDBC：这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务范围。&lt;/li&gt;
&lt;li&gt;MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;transactionManager type=&quot;MANAGED&quot;&amp;gt;
    &amp;lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&amp;gt;
&amp;lt;/transactionManager&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数据源&quot;&gt;数据源&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。有三种数据源类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。&lt;/li&gt;
&lt;li&gt;POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来， 避免了创建新的连接实例时所必需的初始化和认证时间。&lt;/li&gt;
&lt;li&gt;JNDI：使用JNDI在外部配置数据源。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;properties标签&quot;&gt;properties标签&lt;/h3&gt;
&lt;p&gt;properties为外部属性，比如数据库连接信息可以配置到一个单独的properties文件中，然后在xml中进行引入。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;添加一个db.properties文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/test
username=root
password=root&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在mybatis主配置文件中引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;properties resource=&quot;db.properties&quot; /&amp;gt;
&amp;lt;environments default=&quot;development&quot;&amp;gt;
    &amp;lt;environment id=&quot;development&quot;&amp;gt;
        &amp;lt;transactionManager type=&quot;JDBC&quot; /&amp;gt;
        &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
            &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot; /&amp;gt;
            &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&amp;gt;
            &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&amp;gt;
            &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&amp;gt;
        &amp;lt;/dataSource&amp;gt;
    &amp;lt;/environment&amp;gt;
&amp;lt;/environments&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;映射器&quot;&gt;映射器&lt;/h3&gt;
&lt;p&gt;通常MyBatis中将映射关系（非必须）和SQL语句写入到映射文件中，在配置文件中需要手动进行加载映射文件。加载映射文件使用进行加载。Mybatis中有4种加载方式。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1.使用resource，加载classpath路径进行加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper resource=&quot;com/simple/mybatis/entitys/EmployeeMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2.使用url路径进行加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3.使用calss进行加载，注解方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!– 加载class类--&amp;gt;
&amp;lt;mappers&amp;gt;
    &amp;lt;mapper class=&quot;使用注解的全类名&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4.使用package进行加载，注解方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!– 加载某个包下的所有class文件--&amp;gt;
&amp;lt;mappers&amp;gt;
    &amp;lt;package name=&quot;com.simple.mybatis.entitys&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;别名的使用&quot;&gt;别名的使用&lt;/h3&gt;
&lt;p&gt;之前，我们在sql映射xml文件中的引用实体类时，resultType需要写上实体类的全类名(包名+类名)，如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;findAll&quot; resultType=&quot;com.simple.mybatis.entitys.Employee&quot;&amp;gt;
        select id,last_name AS lastName,email,gender from tal_employee
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在mybatis主配置文件中加入&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;typeAliases&amp;gt;
    &amp;lt;typeAlias type=“com.simple.mybatis.entitys.Employee&quot; alias=&quot;Employee&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在resultType中就可以直接使用Employee类型了。这个别名是不区分大小写的。&lt;/p&gt;
</description>
<pubDate>Wed, 10 Oct 2018 03:50:00 +0000</pubDate>
<dc:creator>Miya。</dc:creator>
<og:description>[TOC] MyBatis入门 Editor：SimpleWu MyBatis简介 MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software f</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/9765552.html</dc:identifier>
</item>
<item>
<title>码农晋升为技术管理者后，痛并快乐着的纠结内心 - IVAN-jsjwk</title>
<link>http://www.cnblogs.com/jsjwk/p/9765326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jsjwk/p/9765326.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jgOJKOvxkeMKZWZ2U61JD6rRLH3KafQbTHIHlYgElGxXibG5RyrHJTO82nVOl1rxZQc3yFDJvLPsoLAiaibjdRMuw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.8576642335766423&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jgOJKOvxkeMKZWZ2U61JD6rRLH3KafQbTHIHlYgElGxXibG5RyrHJTO82nVOl1rxZQc3yFDJvLPsoLAiaibjdRMuw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;822&quot; data-fail=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有一个非常有趣的现象：据说大部分的技术管理者，在其从程序员转为管理岗位的时候，都是在领导或公司的要求下，被动的推到管理岗位上的，并非是自己当初有强烈意愿、主动去选择管理岗的。这种被动的比例还不低，高达80%以上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个现象从我自己身边的同事中也可以感受到，最近两年我接触到的四五位新晋的技术管理者，全是因为技术/项目做得好，被上级提拔到管理岗的，几乎没有人是因为具备了管理技能后主动去选择的。其实包括曾经的我自己也是这样走过来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里，我们不讨论这种普遍现象是否合理，我们先来看看这种晋升方式会带来什么样的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然有这么多人是「被动」的成为技术管理者的，那可以想象，在这些人刚步入管理岗位的时候，对管理知识的了解会是多么的薄弱，对即将要开展的管理工作会多么的心虚和纠结。甚至有些人，因为刚开始进行管理工作的不顺利，导致对自己能力的质疑，对技术管理岗位的排斥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以这也说明了很多程序员刚晋升为管理后，内心其实是痛并快乐着的。针对这个现象，那应该怎么办呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里，我就以「过来人」的工作经验，结合近期读到的「刘建国老师」的一些的管理理念，计划从一名新晋的技术管理者角度出发，来聊一聊我们应该怎么走好初入管理岗的这段路，希望能给管理新人们一些启发。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;一、我适不适合去做一名技术管理者呢?&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;很多初入管理岗的同学，可能会有这样一些内心的纠结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「我没有做过管理，不知道自己能不能做得好？有点胆怯」&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「是公司领导安排我做技术管理的，我也不知道自己适不适合？更不知道对自己职业是好还是坏？有点焦虑」&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「晋升管理岗会给我带来工资福利和职位的提高，这是我很想要的。但我不知道管理这条路自己是否真的喜欢？有点迷茫」&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实对于一名新晋管理者，或者想要步入管理岗的同学来说，有这些纠结和不安也是正常现象。要解决这些问题，首先你得问问自己的内心：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你为什么要去做一名技术管理者，你对管理工作所需的 投入要求/意愿 以及 带来的回报 都清楚了吗？&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;认可管理工作的价值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;我们都知道，在日常的管理中会有很多的「繁琐的」「协调性」「打杂的」的工作需要做。例如：协调资源、跟进项目、管理进度、员工面谈、绩效考评、开会沟通、邮件汇报、研发流程、关注项目和人员问题等等。这些工作在有的人看来就是打杂，觉得很没有价值，没有写牛逼的代码来得高大上。而在有的人眼中却非常认可这些工作，觉得能给自己带来多方位的素质提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，在你眼中，你是怎么看待这些工作的呢？&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对管理工作发自内心的兴趣&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;很多管理工作并非一定要你到达管理岗位后才能做的。在你还是一名普通程序员的时候，在你还是团队技术骨干的时候，如果你真的对技术管理有兴趣，那么这些「管理」工作已经在你的日常工作中无形的开始了。例如：关注项目整体进度、了解项目目标、推进项目流程、关心身边的同事成长、优化研发与协作方式等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，你是否发自内心的对这些无形中的「管理」工作感兴趣呢？&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;3&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;愿意去提升管理能力&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;一旦从纯粹的技术岗转到管理岗，你可能需要面临很多管理技巧上的挑战，甚至还有很多在思维和认知上的颠覆。例如：首先，管理工作已经不再像敲代码一样非0即1了，管理工作中有很多中间态，不确定的因素，这些往往是对程序员之前习惯性思维的一个很大的冲击。其次，之前敲代码是与计算机打交道，转为管理之后，会花更多的时间与人打交道，与上司、与平级、与下属、与跨部门协作等等。另外，管理者会承担更多更大的责任，需带领团队穿山越岭实现公司的最终目标，这些压力也是作为程序员时候所没有的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你愿意为此方向重构自己，提升自己的管理思维和能力吗？你做好这个准备好吗？&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;你拥有了一个团队&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;步入管理岗之后，你就不是一个人在战斗，你拥有了一个团队，基于团队，你可以做出更大的成就。以前你的成绩可能就是技术做的好，代码写的好，而转入管理开始带团队之后，你可以和团队一起搞定更复杂的任务，做出更大的成绩。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;能力、视野、影响力 都会得到显著提升&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;除了技术能力，你还获得了管理能力、领导力，你看待问题的视角不再是程序员思维了，会有更高的视野。由于团队间的协作，你还能获得更大的个人影响力。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;物质的回报&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这是非常现实的，看得见摸得着的回报。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，上面已经将一名技术管理者所需的要求和回报都简单捋了捋。作为程序员的你，可以对照一下，然后问问内心的自己是否真的合适。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你觉得没有问题，那咱们就继续来看看，一般有那些机会可以帮助我们成长为技术管理者。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;二、有哪些机会能使我成为一名技术管理者？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;首先，「管理比技术更需要机会」，我们做程序员的，都非常勤奋，挑灯熬夜的干活学习都是平常事，而且技术这东西也确实很公平，你不断的努力去研究去学习，迟早会提高一个层次，无非是不同人不同时间的问题。但是做管理呢，并不是这样。要想成为一名技术管理者，勤奋必不可少，然而其中的机会也很重要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在职场上，经常有遇到这样的现象：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「你的能力非常不错了，可是团队中没有管理的空缺了」&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「你是团队中技术最好的一个，可是管理岗的却安排给了别人」&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实可以发现，这里面除了你个人的条件以外，外部的「机会」因素相当重要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想成为技术管理者，那我们应该抓住那些潜在的机会呢？&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;快速发展的公司最有机会，这类公司经常会建立新的项目新的团队，需要很多技术管理者&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;耐心积攒能力，掌握核心技术的人会更有机会，厚积薄发的道理人人都懂&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;手上负责的项目属于基础性、全局性、跨部门协作工作多的业务相对来说机会会多一些&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;在平时的工作中，经常得到上级认可、甚至上级能支持你转管理，这类人等待的就是以一个契机&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;身边有管理能力较好的导师朋友来解惑帮助的人也会更容易把握机会&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;最后就是，当你还不是管理岗，但你却已经在团队中做着技术管理者应该做的事情的时候，你最有机会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在互联网公司中，很多管理岗的晋升不是给予的，更多是对既定事实的追认。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;三、技术和管理应该怎么去平衡？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;从一名程序员晋级为技术管理者之后，很多人的内心多多少少都存在这样一些顾虑：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「每天管理的工作越来越多，留给自己研究技术的时间却越来越少，时间一长，我会不会慢慢脱离技术了」&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「写代码的时间变少了，对很多技术细节也没有以前敏感了，感觉自己离技术老本行越来越远，内心越来越发虚」&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「脱离了一线编码，心里空落落的，很担心自己的职业发展」&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实有这些顾虑也无妨，这也是大多数新晋技术管理者都会遇到的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，我们来想想，为什么这些问题在新管理者面前这么普遍呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要原因还是因为新晋的技术管理者大多都是程序员出身，一直以来都是靠一线的编码技术能力去打江山混名声的。突然之间转为管理了，既担心把「技术」丢了没了退路，又对「管理」应该要做哪些事情、如何把「管理」做好，如何重新依靠「管理」这项能力去打江山混江湖还不熟练，正处于青黄不接的时期，自然而然就会觉得焦虑不安了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那这些顾虑有解吗？有的。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;要明白「放弃编码，不代表放弃技术」&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;转做技术管理之后，我们只是减少了编码的时间，并不是放弃了技术，事实上，作为一名技术人，我们永远永远也不能放弃技术。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但也千万不要把「编码能力」与「技术能力」之间划上等号。技术能力是可以更多的关注应用，但并不一定需要时时关注实现细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就像部队打仗一样，作战指挥官需要了解陆军、空军、海军等不同军种的优劣势，需要了解军舰、坦克、导弹等不同作战武器的最佳特性，才能部署出最佳的作战方针，统筹全局打胜仗，但是他并不需要了解军舰具体怎么开、坦克具体怎么驾驶。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，当你还是一名程序员的时候，编码可能就是你的全部实现，而当你成为一名技术管理者的时候，技术就应该是你的工具，你应该站在更高的视野去看待技术的价值，技术是为最终的目标而服务。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;要保持对技术的评估能力&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;上面提到了「技术能力」并不等于「编码能力」，抛开一些非核心能力的话，可以简单点理解为「技术能力」=「编码能力」+「技术评估能力」。当我们还是程序员的时候编码能力是我们最为注重的，但当我们转技术管理之后，技术评估能力就应该成为我们的重点，编码能力在精力有限的情况下是可以放弃的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;技术评估能力主要是指我们通过自己的技术认知，去评估一个项目/开发任务 要不要做、值不得值得做、做到什么程度，技术方案边界在哪儿、技术选型用什么、可用性/拓展性方案是什么等等，甚至是对团队人员技术水平的边界评估。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎样才能保持技术评估能力，以及怎样能不断增长自己的技术评估水平呢？作为技术管理者而言，很明显，已经不能通过大量编码的方式去提高技术能力了，只能依赖于：自己以往技术经验的积累、团队的技术分享、技术调研、与同行专家交流、培训学习等方式。这些方式有的时候会比编码的方式更快更有效率。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;3&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;技术管理是多样性的，你总会找到一条你自己的路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;我们要明白，技术管理并没有固定的模式，有的技术老大做着做着就往商业方向靠了，比如雷军这类。有的技术老大无论做到多高的级别，带几百上千人的团队，却依旧非常关注技术日常。每个人的技术管理风格不同，但最后都会找到一条自己风格的管理之路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即使最后你发现自己不喜欢做管理了，想转回做技术架构师或创业，你通过管理获得这些经验能力和视野，对你的其它道路依旧会有莫大的帮助。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;4&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;技术管理能力是每一个程序员都需要的技能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;技术管理是一项能力，并不是一个职业。它是每一个技术同学在成长过程中，都应该去学习和具备的能力。无论你以后是走管理道路，还是做职业经理人、技术专家、架构师、创业，你都需要具备技术管理者应具备的团队管理能力、技术视野、技术规划能力、项目管理能力、沟通协调能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，你还需要有顾虑吗？反正无论如何你都得会一点嘛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上，就是对新晋的技术管理者如何解决初入管理岗时纠结心路的学习与分享，希望能给新步入管理岗的同学们一些启发。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流Java、Web、架构、大数据、职业发展、技术管理。  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1453917/201810/1453917-20181010111801382-128859962.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 10 Oct 2018 03:18:00 +0000</pubDate>
<dc:creator>IVAN-jsjwk</dc:creator>
<og:description>有一个非常有趣的现象：据说大部分的技术管理者，在其从程序员转为管理岗位的时候，都是在领导或公司的要求下，被动的推到管理岗位上的，并非是自己当初有强烈意愿、主动去选择管理岗的。这种被动的比例还不低，高达</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jsjwk/p/9765326.html</dc:identifier>
</item>
<item>
<title>Android P的APP适配总结，让你快人一步 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/9765229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/9765229.html</guid>
<description>&lt;p&gt;&lt;strong&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer/?fromSource=waitui&quot;&gt;腾讯云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;本文由&lt;a href=&quot;https://cloud.tencent.com/developer/user/1027752?fromSource=waitui&quot;&gt;QQ音乐技术团队&lt;/a&gt;发表于&lt;a href=&quot;https://cloud.tencent.com/developer/column/1443?fromSource=waitui&quot;&gt;云+社区专栏&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Android P 这次有很多行为变更，其中不乏一些需要亟需适配的变更。&lt;/p&gt;
&lt;h2 id=&quot;一全面屏检测&quot;&gt;&lt;strong&gt;一、全面屏检测&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在 Android 8.0 时代各个手机厂商就开始发布自己的全面屏手机，但是此时 Android 官方并未支持到该功能，所以各个厂商都各自实现了一套全面屏判断逻辑，对于开发者来说甚是麻烦。终于在 Android P 里官方收归了该功能的判断逻辑，Android P 和之后的版本完全可以使用官方 API 来判断全面屏，当然前提是第三方厂商按照 google 官方接口去实现。Android P 版本判断全面屏代码很简单，但是在适配过程中你可能会在网上发现如下判断代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.P) {
    decorView.setOnApplyWindowInsetsListener(new View.OnApplyWindowInsetsListener() {
        @RequiresApi(api = 28)
        @Override
        public WindowInsets onApplyWindowInsets(View view, WindowInsets windowInsets) {
            if (windowInsets != null) {
                DisplayCutout cutout = windowInsets.getDisplayCutout();
                if (cutout != null) {
                    List&amp;lt;Rect&amp;gt; rects = cutout.getBoundingRects();
                    //通过判断是否存在rects来确定是否全面屏手机
                    if (rects != null &amp;amp;&amp;amp; rects.size() &amp;gt; 0) {
                        isNotchScreen = true;
                    }
                }
            }
            return windowInsets;
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码确实可以判断出全面屏与否，但是会造成一个很严重的后果，就是在某些手机（pixel 和 vivo x21 均出现该情况）上底部导航栏会透明，导致应用内容会透到导航栏从而被遮挡，大大影响内容展示。最后经过仔细排查发现仅仅因为在上面那段代码中调用了 &lt;code&gt;setOnApplyWindowInsetsListener&lt;/code&gt; 函数，该函数在 Android 官网有详细介绍，是用来在 Android 21 版本之后代替 &lt;code&gt;fitSystemWindows&lt;/code&gt; 函数，目的是让 View 根据 Window 的缩进进行相应处理，调用后会影响系统状态栏和导航栏对应用内容的展示，对此的介绍资料网上有很多，就不赘述了。真正完美判断全面屏的代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.P) {
    WindowInsets windowInsets = decorView.getRootWindowInsets();
    if (windowInsets != null) {
        DisplayCutout displayCutout = windowInsets.getDisplayCutout();
        if (displayCutout != null) {
            List&amp;lt;Rect&amp;gt; rects = displayCutout.getBoundingRects();
            //通过判断是否存在rects来确定是否刘海屏手机
            if (rects != null &amp;amp;&amp;amp; rects.size() &amp;gt; 0) {
                isNotchScreen = true;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二非-sdk-api-适配详解&quot;&gt;&lt;strong&gt;二、非 SDK API 适配详解&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;非-sdk-api-名单介绍&quot;&gt;&lt;strong&gt;2.1 非 SDK API 名单介绍&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Android P 版本最大最严格的特性变更应该非 SDK 接口限制莫属了。对于非 SDK API 里面的部分名单来说，就算在不修改 targetSdkVersion 的前提下，不管是直接、反射还是通过 JNI 调用都会造成调用失败、抛出 &lt;code&gt;NoSuchFieldException&lt;/code&gt;或 &lt;code&gt;NoSuchMethodException&lt;/code&gt; 等严重后果，该行为影响范围波及所有调用此接口的应用。&lt;/p&gt;
&lt;p&gt;非 SDK API 名单总共分为三类：light grey list （浅灰名单）、dark grey list （深灰名单）、dark list（黑名单），详情：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1027752/4qyh789fit.jpeg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 非 SDK API 名单扫描&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以对于我们应用开发者来说，当前首要任务是适配深灰名单和黑名单。目前 google 官方提供了一个可以实时查询三个名单里面 API 列表的网站：https://android.googlesource.com/platform/frameworks/base/+/master/config/。在之前 DP 版本时开发者如果遇到了不得不使用的黑名单或者深灰名单 API，需要向 google 官方及时提出反馈（反馈url：https://issuetracker.google.com/issues/new?component=328403&amp;amp;template=1027267），申请将其移动到浅灰名单中，但是目前正式版本已经发布，未得知该申请通道是否仍有效。&lt;/p&gt;
&lt;p&gt;详细了解了非 SDK API 之后，下一步当然是将应用代码里面的深灰名单和黑名单 API 调用找出来一一修改。目前官方提供了一个非常实用的扫描工具，该工具可以把应用里面三个类型名单的 API 调用都扫描出来（但是可能会有遗漏），使用方法也很简单：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打包一个应用 APK，建议使用 release 包，排除一些未使用到的单元测试类或者其他因素的影响，将 APK 放到工具指定目录下；&lt;/li&gt;
&lt;li&gt;执行命令 &lt;code&gt;./appcompat.sh --dex-file=test.apk&lt;/code&gt;，在终端上会输出三个名单每个 API 的详细调用处: #1: Linking dark greylist Landroid/os/SystemProperties;-&amp;gt;get(Ljava/lang/String;)Ljava/lang/String; use(s): Ltmsdkobf/gv;-&amp;gt;a(Ljava/lang/String;)Ljava/lang/String; #2: Linking dark greylist Landroid/os/SystemProperties;-&amp;gt;get(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; use(s): Ltmsdkobf/gp;-&amp;gt;b(Landroid/content/Context;)Ljava/lang/String; ....&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;非-sdk-api-适配&quot;&gt;&lt;strong&gt;2.3 非 SDK API 适配&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;经过上一步扫描出应用内非 SDK API 调用之后，接下来就可以直接开始适配。适配的原则是优先黑名单和深灰名单，浅灰名单在官方未有替代 API 之前可以暂时不适配，在 Android P 上运行也不会有任何问题。扫描完成之后，不出意外大家应该会有三类需要适配的 API 调用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;应用代码本身调用到了非 SDK API 接口； 针对应用代码本身调用到了非 SDK API 接口，用的比较频繁的例如 &lt;code&gt;SystemProperties.get&lt;/code&gt;，就需要去寻找另外一个可以替代的合法 API，如果找不到就只能认为该 API 调用失败从而走失败逻辑，如果实在必须要用到该 API 就尽早去向 google 申请移动到浅灰名单中。&lt;/li&gt;
&lt;li&gt;第三方库调用到了非 SDK API 接口； 针对第三方库调用到了非 SDK API 接口，解决办法当然是直接查询相关资料或者联系库提供方，确认是否有适配 Android P 新版本的 SDK。还有需要提到的一点，就算更换适配完成的第三方 SDK 后，仍然可能会在同一地方扫描出非 SDK API 的调用，这是因为适配工程师只是在调用处加了一个 try-catch 保护逻辑，虽然这样也勉强叫做适配完成，但是还是强烈建议大家使用如下的适配方式： if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.P) { // Android P or above } else { // below Android P } 严格按照上面的适配方案，扫描工具就不会再扫描出此处的非 SDK API 调用，我们也无需每次都去确认所有非 SDK API 调用处都加了保护逻辑。 当然如果第三方库没有适配也没有近期适配的意向，目前有两种方法：第一种是屏蔽入口；第二种是反编译 SDK，在关键地方加上适配代码；&lt;/li&gt;
&lt;li&gt;Android 官方库调用到了非 SDK API 接口； 没错！Android 官方库也会被扫描出非 SDK API 调用，针对这种情况，需要分情况讨论：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1027752/bzgzsbbmp6.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该 API 调用查看 v7 support 包源码可以发现已经被 try-catch 住了，测试了相关类也可以正常运行，而且在适配过程中升级 rc 版本的 support-v7 包会导致应用编译不过，所以目前 QQ 音乐暂时认定无需升级到最新版本的 support-v7。除上面介绍的特殊情况之外还是建议更换最新版本的官方 SDK。&lt;/p&gt;
&lt;h2 id=&quot;三电源管理改进&quot;&gt;&lt;strong&gt;三、电源管理改进&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;应用待机群组&quot;&gt;&lt;strong&gt;3.1 应用待机群组&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Android P 上对电源管理又做了一系列的改进措施，不管应用 targetApi 版本是否已经升级到 P，系统都会依据应用最近的使用时间和频率来给应用进行待机分组，然后根据应用所属群组限制应用可以访问的资源，目前总共有五类分组：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;活跃： 一般为正在使用或者在前台运行的应用，例如：
&lt;ul&gt;&lt;li&gt;应用启动一个 Activity；&lt;/li&gt;
&lt;li&gt;应用正在运行前台 Service；&lt;/li&gt;
&lt;li&gt;应用的同步适配器关联上了一个前台应用；&lt;/li&gt;
&lt;li&gt;用户点击了应用的一个通知； 系统不会对该类应用有任何的限制；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;工作集： 应用经常运行，但是当前未属于活跃状态就会被归属于工作集，该群组的应用在运行作业和触发闹钟方面会被施加轻度的限制；&lt;/li&gt;
&lt;li&gt;常用： 应用如果被定期使用，但不是每天的话就会被归到该工作群组。该群组的应用在运行作业和触发闹钟方面会被施加较强的限制，FCM 消息数量也会有相关限制；&lt;/li&gt;
&lt;li&gt;极少使用： 应用如果不经常使用就会被归到该工作群组，系统会对该群组应用运行作业、触发闹钟和接收高优先级别 FCM 的消息能力方面有严格的限制；&lt;/li&gt;
&lt;li&gt;从未使用： 安装但从未被使用过的应用会被归到该工作群组，该工作群组的应用会被施加极其严格的限制；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;更加详细的表述可以参考官网：App Standby Buckets(https://developer.android.com/about/versions/pie/power)，不同群组的限制的详细表现见：Power management restrictions（链接：https://developer.android.com/topic/performance/power/power-details）。系统会动态的将手机里面的应用分配到这五类群组里面，也会根据需要变化应用群组，同时借助了机器学习来将一个应用放到更合适的群组里。目前应用可以通过 &lt;code&gt;UsageStatsManager.getAppStandbyBucket()&lt;/code&gt; 函数来获取当前所属的应用群组，借助这个结果来更好的提升自己的打开频率，同时可以借助此来模拟处于不同群组能否正常工作。另外，位于低电耗模式白名单中的应用不适用基于应用待机群组的限制。&lt;/p&gt;
&lt;h3 id=&quot;省电模式改进&quot;&gt;&lt;strong&gt;3.2 省电模式改进&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Android 9 对省电模式又做了很多改进，开启省电模式之后会有如下限制：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;系统会更加积极的将应用置于待机模式，不管应用是否空闲；&lt;/li&gt;
&lt;li&gt;后台执行限制将适用于所有应用，无论他们的 targetApi 是多少；&lt;/li&gt;
&lt;li&gt;屏幕关闭时，位置服务可能被停用；&lt;/li&gt;
&lt;li&gt;后台应用没有网络访问权限；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里需要重点介绍一下后台执行限制，该限制于 Android O 版本引入，主要是为了优化 Android 在多应用多服务运行时，系统负载过大会杀死后台音乐播放等服务导致用户体验下降的问题，它默认只对 targetApi 大于等于 26 的应用生效。目前用户可以通过设置页面对任意应用施加后台执行限制，后台执行限制会对应用有两方面的影响：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;后台服务限制： 处于前台（可见、具有前台服务或者关联到前台应用）或临时白名单（处理高优先级 FCM、接收短信等广播或者执行通知的 &lt;code&gt;PendingIntent&lt;/code&gt;）时，应用可以自由创建和运行前台与后台服务。 进入后台时，在一个持续数分钟的时间窗内，应用仍可以创建和使用服务，但是超过该时间之后再通过 startService 去启动一个服务就会抛出 &lt;code&gt;java.lang.IllegalStateException: Not allowed to start service Intent&lt;/code&gt; 的错误，解决办法是使用 &lt;code&gt;startForegroundService&lt;/code&gt; 或者 &lt;code&gt;JobIntentService&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;广播限制: 针对 Android O 和之上的应用无法继续在其清单中为隐式广播注册广播接收器。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四apache-http-client-相关类找不到&quot;&gt;&lt;strong&gt;四、Apache HTTP client 相关类找不到&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;将 compileSdkVersion 升级到 28 之后，如果在项目中用到了 Apache HTTP client 的相关类，就会抛出找不到这些类的错误。这是因为官方已经在 Android P 的启动类加载器中将其移除，如果仍然需要使用 Apache HTTP client，可以在 Manifest 文件中加入：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;uses-library android:name=&quot;org.apache.http.legacy&quot; android:required=&quot;false&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者也可以直接将 Apache HTTP client 的相关类打包进 APK 中。&lt;/p&gt;
&lt;p&gt;除上面两种适配方式外，QQ 音乐目前采用了另外一种方式。在音乐项目中，我们已经将使用 Apache HTTP client 的模块单独抽离到了一个 module 中，所以暂时只需要保持 module 中的 compileSdkVersion 在 28 以下即可正常编译运行。&lt;/p&gt;
&lt;h2 id=&quot;五其余适配&quot;&gt;&lt;strong&gt;五、其余适配&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;前台-service&quot;&gt;&lt;strong&gt;4.1 前台 Service&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在 Android P 中，如果 targeSdkVersion 升级到 28，使用前台 Service 必须要申请 &lt;code&gt;FOREGROUND_SERVICE&lt;/code&gt; 权限，如果没有申请该权限，系统会抛出 &lt;code&gt;SecurityException&lt;/code&gt;，该权限为普通权限，申请自动授予应用。&lt;/p&gt;
&lt;h3 id=&quot;隐私安全保护&quot;&gt;&lt;strong&gt;4.2 隐私安全保护&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Build.SERIAL 标识修改：在 Android P 中，对隐私保护又做了更加严格的要求。在某些应用中为了识别手机的唯一性可能会用到 Build.SERIAL 这个标识，但这个标识在 Android P 中已经被设置成了 &lt;code&gt;UNKNOWN&lt;/code&gt;，所以会直接导致该功能出现异常。&lt;/li&gt;
&lt;li&gt;多进程 webview 信息访问限制：在 Android P 中为了提升系统的安全性，用户无法在多进程的 webview 中共享数据目录，该目录下存储的是一些 cookies、Http 缓存和其他一些永久、临时的缓存。当下不少应用会把 webview 放在另一个进程中打开以避免内存泄漏，但是他们 cookies 的设置往往还是在主进程中，所以开发者需要仔细排查自己的应用是否有这么使用，webview 相关运行是否正常等。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;com.android.internal-包下某些类找不到&quot;&gt;&lt;strong&gt;4.3 com.android.internal 包下某些类找不到&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;升级到 28 之后，应用编译后抛出 &lt;code&gt;com.android.internal&lt;/code&gt; 包下面有些类找不到的异常，经过查找发现这些类已经从 SDK 中移除。针对这种情况目前有两种处理办法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;移除该类的调用逻辑；&lt;/li&gt;
&lt;li&gt;在应用中新建一个同名类，将被移除类的所有代码逻辑复制到新建类中（必要时可能需要将被移除类相关类同时拷贝一份到应用中），然后将应用中所有相关 import 引用直接修改成新建类的包名引用即可；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Android P 这次当然也有很多丰富的特性，总结了两个对于第三方应用开发者比较实用的特性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud.tencent.com/developer/article/1200331&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一heif-图片格式支持&quot;&gt;&lt;strong&gt;一、HEIF 图片格式支持&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;HEIF（High Efficiency Image Format），高帧率图片格式，采用的是 HEVC 编码格式。苹果于 iOS11 版本开始支持该图片格式，而 Android 则是在 Android O MR1 版本开始支持 HEIF 静态图的软解码，在 P 版本上完全支持该格式的软编解码。HEIF 格式的压缩率是 JPEG 的 2.39 倍，同等大小质量的图片可节省 50% 的空间和网络传输流量，而且支持动图。HEIF 格式比起 GIF 格式来说有着更好的图片展示效果，所以 HEIF 格式图片的目标是用来代替 JPEG 成为主流的图片压缩格式。HEIF 格式图片的扩展名为 .heif 或者 .heic：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;最大尺寸&lt;/td&gt;
&lt;td&gt;无上限&lt;/td&gt;
&lt;td&gt;16383x16383&lt;/td&gt;
&lt;td&gt;65535x65535&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;编码&lt;/td&gt;
&lt;td&gt;HEVC&lt;/td&gt;
&lt;td&gt;VP8&lt;/td&gt;
&lt;td&gt;JPEG&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;是否支持其他编码&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;支持音频/文字&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;支持多图片&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;支持裁剪&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;支持透明&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;支持缩略图&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;分块加载&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;看上去很美好，但是目前还不是所有的 Android P 机型都会支持 HEIF 格式硬编解码，因为这需要特殊的硬件支持同时还需要缴纳一定的专利费，所以在编解码效率上就会有机型差异，同时 Android P 软编解码也只能支持静态 HEIF 格式图片。目前开发者可以通过版本来判断是否支持 HEIF 编解码，判断逻辑如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;fun supportHEIF() = Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.P&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解码代码也很简单，支持将 HEIF 格式图片解码成 Bitmap 和 Drawable：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@TargetApi(28)
fun decodeHEIFDrawable(filePath: String): Drawable? {
    if (!supportHEIF()) {
        return null
    }
    var source: ImageDecoder.Source = ImageDecoder.createSource(File(filePath))
    return ImageDecoder.decodeDrawable(source)
}

@RequiresApi(28)
fun decodeHEIFBitmap(filePath: String): Bitmap? {
    if (!supportHEIF()) {
        return null
    }
    var source: ImageDecoder.Source = ImageDecoder.createSource(File(filePath))
    return ImageDecoder.decodeBitmap(source)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外扫描本地图片则继续使用 ContentResolver 即可，如果设备支持 HEIF 格式，系统会自动扫描上 HEIF 格式的图片：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var cursor : Cursor = getContext().getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, null, null, null, null)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样还远远没有适配完成，第三方应用适配 HEIF 格式图片有一个很困难的地方是本地虽然可以识别解码 HEIF 格式的图片，但是如果某个用户将其设置为头像上传到后台，后台将其下发给其他不支持 HEIF 图片格式解码的手机，这些手机就肯定有展示问题。解决这个问题目前有两种思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;终端在上传之前将其转码成 JPEG 格式的图片，但是这样就根本没有充分利用到 HEIF 图片的高压缩率的优势；&lt;/li&gt;
&lt;li&gt;在到达后端之后，后端将其转码成 JPEG 图片，同时保存一份 HEIF 和 JEPG，到时候根据用户是否可以解码 HEIF 下发不同格式图片。该方案可以充分利用 HEIF 的优点，但是大大增加了后端存储空间和开发工作量。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二imagedecoder&quot;&gt;&lt;strong&gt;二、ImageDecoder&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;上面已经介绍到了 &lt;code&gt;ImageDecoder&lt;/code&gt; 在解码 HEIF 图片中的应用，但是实际它的功能完全不仅于此，在 Android P 中它可以完全替代 &lt;code&gt;BitmapFactory&lt;/code&gt; 和 &lt;code&gt;BitmapFactory.Options&lt;/code&gt; 相关类。&lt;code&gt;ImageDocoder&lt;/code&gt; 类可以通过字节数据、文件和 URI 来解码一张图片。用法和之前一样，首先通过 &lt;code&gt;createSource&lt;/code&gt; 方法创建一个图片文件的 &lt;code&gt;ImageDecoder.Source&lt;/code&gt; 对象，然后调用 &lt;code&gt;decodeDrawable&lt;/code&gt; 或者 &lt;code&gt;decodeBitmap&lt;/code&gt; 方法传入之前的 &lt;code&gt;ImageDecoder.Source&lt;/code&gt; 对象就能生成图片的 Drawable 或者 Bitmap 对象引用。&lt;code&gt;ImageDecoder&lt;/code&gt; 支持 PNG、JPEG、WEBP、GIF 和 HEIF 多种格式图片的解码，另外解码 GIF 或者 WEBP 格式图片得到的是一个 &lt;code&gt;AnimatedImageDrawable&lt;/code&gt; 对象，&lt;code&gt;AnimatedImageDrawable&lt;/code&gt; 类的工作原理和 &lt;code&gt;AnimatedVectorDrawable&lt;/code&gt; 类似，都是使用一个工作线程来解码，所以解码线程和显示线程互不干扰。&lt;code&gt;AnimatedImageDrawable&lt;/code&gt; 用法也很简单：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var drawable: Drawable = ImageDecoder.decodeDrawable(source);
if (drawable is AnimatedImageDrawable){
    image.setImageDrawable(drawable)
    drawable.start()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ImageDecoder&lt;/code&gt; 除了基础的解码功能之外，还有很多非常实用的方法，比如通过设置 &lt;code&gt;OnHeaderDecodedListener&lt;/code&gt; 就可以在解析图片之前获取到图片的宽高等信息，同时还可以根据需要设置采样率：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;val listener = object : OnHeaderDecodedListener {
    fun onHeaderDecoded(decoder: ImageDecoder, info: ImageInfo, source: Source) {
        decoder.setTargetSampleSize(2)
    }
}
val drawable = ImageDecoder.decodeDrawable(source, listener)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外还可以通过 &lt;code&gt;setPostProcessor&lt;/code&gt; 方法来添加一些自定义的效果，比如最常用的切圆角：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var drawable = ImageDecoder.decodeDrawable(source) { decoder, info, src -&amp;gt;
    decoder.setPostProcessor { canvas -&amp;gt;
        val path = Path()
        path.setFillType(Path.FillType.INVERSE_EVEN_ODD)
        val width = canvas.getWidth()
        val height = canvas.getHeight()
        path.addRoundRect(0, 0, width, height, 20, 20, Path.Direction.CW)
        val paint = Paint()
        paint.setAntiAlias(true)
        paint.setColor(Color.TRANSPARENT)
        paint.setXfermode(PorterDuffXfermode(PorterDuff.Mode.SRC))
        canvas.drawPath(path, paint)
        PixelFormat.TRANSLUCENT
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非常便捷。用法远不仅于此，有了 Canvas 对象，开发者完全可以发挥想象去实现自己想要的炫酷效果。另外如果解码的图片不完整或者包含错误，一般情况下会抛出 &lt;code&gt;DecodeException&lt;/code&gt;，但是如果这个时候通过 &lt;code&gt;setOnPartialImageListener&lt;/code&gt; 函数传递一个 &lt;code&gt;OnPartialImageListener&lt;/code&gt; 对象，并且在 &lt;code&gt;onPartialImage&lt;/code&gt; 函数中返回 true，则图片就会只展示解析成功的一部分而不会抛出 &lt;code&gt;DecodeException&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var drawable = ImageDecoder.decodeDrawable(source) { decoder, info, src -&amp;gt;
    decoder.setOnPartialImageListener { e: ImageDecoder.DecodeException -&amp;gt;
        true
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;5.7435897435897&quot;&gt;
&lt;p&gt;https://developer.android.google.cn/about/versions/pie/android-9.0 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MjgxMjU0Mg==&amp;amp;mid=2247486857&amp;amp;idx=1&amp;amp;sn=bb7777b6f69cba31ce9d68ffee9c8f47&amp;amp;scene=21#wechat_redirect&quot;&gt;https://mp.weixin.qq.com/s/03ospQEdY5HLdYqxEiDX1g&lt;/a&gt; https://blog.csdn.net/GenlanFeng/article/details/79496359 https://developer.android.com/about/versions/pie/power https://segmentfault.com/a/1190000015947004&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.59433962264151&quot;&gt;
&lt;p&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/173726?fromSource=waitui&quot;&gt;Android - 如何修复权限异常？&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1351968?fromSource=waitui&quot;&gt;Android音频系统&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1335158?fromSource=waitui&quot;&gt;Android 基本常识&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1334964?fromSource=waitui&quot;&gt;Android全局异常处理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/edu/course-1128?fromSource=waitui&quot;&gt;【每日课程推荐】机器学习实战！快速入门在线广告业务及CTR相应知识&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，更多原文请&lt;a href=&quot;https://cloud.tencent.com/developer/article/1200331?fromSource=waitui&quot;&gt;点击&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搜索关注公众号「云加社区」，第一时间获取技术干货，关注后回复1024 送你一份技术课程大礼包！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;海量技术实践经验，尽在&lt;a href=&quot;https://cloud.tencent.com/developer?fromSource=waitui&quot;&gt;云加社区&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Wed, 10 Oct 2018 03:05:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>欢迎大家前往</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/9765229.html</dc:identifier>
</item>
<item>
<title>Python基础（下） - Jonins</title>
<link>http://www.cnblogs.com/jonins/p/9746507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jonins/p/9746507.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.join([&lt;span&gt;''&lt;/span&gt;.join([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;*((x-y)%3) &lt;span&gt;if&lt;/span&gt;((x*0.05)**2+(y*0.1)**2 -1)**3-(x*0.05)**2*(y*0.1)**3&amp;lt;=0 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(-30,30)]) &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt; range(15,-15,-1)]))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181010101001593-1213467134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;函数基础（function）&lt;/h2&gt;
&lt;h3&gt;1.定义函数&lt;/h3&gt;
&lt;p&gt;定义函数需要用到&lt;span&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;/span&gt;关键词，格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; 函数名():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    此函数做的事情1
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    此函数做的事情3
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    此函数做的事情2
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     ...省略...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义了函数后，相当于有了一个具有某功能的代码块，想要调用函数，通过&lt;strong&gt;函数名()&lt;/strong&gt;即可。详细示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; addition():&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     a = 2
&lt;span&gt;3&lt;/span&gt;     b = 3
&lt;span&gt;4&lt;/span&gt;     c = a + &lt;span&gt;b
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; addition()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006220845191-1853973282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.函数注释说明&lt;/h3&gt;
&lt;p&gt;若想给函数添加注释说明，让外部调用者知道函数的大体功能，可以通过如下格式进行函数文档说明的添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; addition():&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;两个数字求和&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     a = 2
&lt;span&gt;4&lt;/span&gt;     b = 3
&lt;span&gt;5&lt;/span&gt;     c = a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; addition()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006221241330-1418437958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.函数参数&lt;/h3&gt;
&lt;p&gt;定义带有参数的函数的方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; addition(a,b):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义带入参数的函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;两个数字求和&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     c = a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; addition(2,3)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用带入参数的函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.函数返回值&lt;/h3&gt;
&lt;p&gt;想要函数中把结果返回给调用者，需要在函数中使用&lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;。示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; addition(a,b):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;两个数字求和&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     c = a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; c
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; result = addition(2,3)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用函数&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.函数类型&lt;/h3&gt;
&lt;p&gt;定义函数时小括号内的参数，用来接收参数所用，称为&lt;strong&gt;“形参”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;调用函数时小括号内的参数，用来传递给函数所用，称为&lt;strong&gt;”实参“&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;函数一共有4种类型：&lt;/p&gt;
&lt;p&gt;1.无参数，无返回值。&lt;/p&gt;
&lt;p&gt;2.有参数，无返回值。&lt;/p&gt;
&lt;p&gt;3.无参数，有返回值。&lt;/p&gt;
&lt;p&gt;4.有参数，有返回值。&lt;/p&gt;

&lt;h2&gt;函数高级&lt;/h2&gt;
&lt;h3&gt;1.函数返回多个值&lt;/h3&gt;
&lt;p&gt; python允许&lt;strong&gt;函数有多个返回值&lt;/strong&gt;，本质时利用了&lt;span&gt;&lt;strong&gt;元组&lt;/strong&gt;&lt;/span&gt;，示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; addition(a,b):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a+1,b+1
&lt;span&gt;3&lt;/span&gt; result = addition(2,3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006222857561-947959904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.缺省参数&lt;/h3&gt;
&lt;p&gt;调用函数时，&lt;strong&gt;缺省参数的值如果没有传入，则被认为时默认值&lt;/strong&gt;，我们给参数赋值默认值的方式如下示例所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; addition(a,b=3&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a+1,b+1
&lt;span&gt;3&lt;/span&gt; result = addition(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006222857561-947959904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;缺省参数一定要位于参数列表的最后面。&lt;/p&gt;
&lt;h3&gt;3.不定长参数&lt;/h3&gt;
&lt;p&gt;有时需要函数处理比当初声明时更多的参数，这些参数叫做不定长参数，声明时不会命名。实现不定长参数的方式有两种，&lt;/p&gt;
&lt;p&gt;1.使用&lt;strong&gt;*参数名&lt;/strong&gt;的方式，本质是一个&lt;strong&gt;元组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2.使用&lt;strong&gt;**参数名&lt;/strong&gt;的方式，本质是一个&lt;strong&gt;字典&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用&lt;span&gt;&lt;strong&gt;*变量名&lt;/strong&gt;&lt;/span&gt;方式的示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; addition(a,b,*&lt;span&gt;arg):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(arg)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; addition(1,2,3,4,5,6)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006230701822-1882733134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;span&gt;&lt;strong&gt;**变量名&lt;/strong&gt;&lt;/span&gt;方式的示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; addition(a,b,**&lt;span&gt;kwargs):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; addition(1,2,name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jonins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,age=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006230934210-56233812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个复杂例子说明：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; addition(a,b,c=3,*args,**&lt;span&gt;kwargs):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--------2个必填参数---------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; addition(1,2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-------2个必填1个缺省其它为不定长*args----------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; addition(1,2,3,4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-------2个必填1个缺省其它为不定长**kwargs----------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; addition(1,2,name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;jonins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,age = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-------2个必填1个缺省有不定长*args和**kwargs----------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; addition(1,2,3,4,5,6,name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;jonins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,age = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006231931187-452413431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量先赋值普通参数，省却参数，最后为不定长变量。参数的声明顺序也要遵循如下顺序声明。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传递多余的参数，如果前面&lt;strong&gt;不带变量名&lt;/strong&gt;，统统传值给&lt;strong&gt;&lt;span&gt;*变量名&lt;/span&gt;以元组形式保存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;传递多余的参数，如果前面&lt;strong&gt;带有变量名&lt;/strong&gt;，统统传值给&lt;strong&gt;&lt;span&gt;**变量名&lt;/span&gt;以字典形式保存&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;拆包&lt;/h2&gt;
&lt;p&gt;我们先看一个示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; addition(a,b,*args,**&lt;span&gt;kwargs):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; A = {1,2,3,4&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; B = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jonins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:18&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; addition(1,2,A,B)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006233150771-1132160505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为值的前面不存在变量名，所以统统放进了元组中，若想将元组变量和字典变量，直接替换不定长参数中的变量，则需要&lt;strong&gt;拆包（元组前加1个*，字典前加2个*）&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; addition(a,b,*args,**&lt;span&gt;kwargs):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; A = {1,2,3,4&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; B = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jonins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:18&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; addition(1,2,*A,**B)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006233256329-1969558246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;全局变量&amp;amp;局部变量 &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;局部变量&lt;/strong&gt;，就时在函数内部定义的变量。不同函数，可以i当以相同名字的局部变量，但是各用各的不会产生影响。局部变量的作用是为了临时保存数据需要在函数中定义变量来进行存储。&lt;/p&gt;
&lt;p&gt;如果一个变量，既能在一个函数中使用，也能在其它的函数中使用，这样的变量就是&lt;strong&gt;全局变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; a = 100
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test1,%i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; a)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2():
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test2,%i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; a)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test3():
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     a = 200
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test3,%i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; a)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test4():
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; a
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     a = 200
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test4,%i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; a)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;test1()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;test2()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;test3()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;未使用global时，全局变量外部为:%i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;a)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;test4()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;使用global时，全局变量外部为:%i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181007003040661-330687591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.函数外边定义的变量叫做全局变量。&lt;/p&gt;
&lt;p&gt;2.全局变量能够在所有函数中进行访问&lt;/p&gt;
&lt;p&gt;3.如果在函数中&lt;strong&gt;修改全局变量&lt;/strong&gt;，需要使用&lt;strong&gt;&lt;span&gt;global&lt;/span&gt;&lt;/strong&gt;进行声明。&lt;/p&gt;
&lt;p&gt;4.如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的值（若名称相同情况出现，默认是&lt;strong&gt;定义一个局部变量&lt;/strong&gt;，&lt;strong&gt;&lt;span&gt;global&lt;/span&gt;&lt;/strong&gt;时是修改）。&lt;/p&gt;

&lt;h2&gt;引用&lt;/h2&gt;
&lt;h3&gt;1.变量赋值本质&lt;/h3&gt;
&lt;p&gt;python中变量的赋值并非单纯的将值复制过去一份保存起来，而是将变量值的引用复制过去保存一份。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;python&lt;/span&gt;中变量赋值过程大致描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006235150781-1477263562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;C&lt;/span&gt;或&lt;span&gt;C++&lt;/span&gt;中变量赋值过程大致描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006235357337-944890956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以通过&lt;span&gt;&lt;strong&gt;id()&lt;/strong&gt;&lt;/span&gt;方法验证，&lt;span&gt;&lt;strong&gt;id()&lt;/strong&gt; &lt;/span&gt;函数用于&lt;strong&gt;获取对象的内存地址&lt;/strong&gt;,示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a=100
&lt;span&gt;2&lt;/span&gt; b=&lt;span&gt;a
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; c=&lt;span&gt;b
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(a))
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(b))
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(id(c))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181006235635960-892406425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.可变类型&amp;amp;不可变类型&lt;/h3&gt;
&lt;p&gt;python值靠引用的传递，那么一个变量的值改变了，同样引用的其它变量的值是否会变呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; A = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; B =&lt;span&gt; A
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; A.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(B)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; a = 100
&lt;span&gt;6&lt;/span&gt; b =&lt;span&gt; a
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; a = 200
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181007001133246-1148965124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到列表的变量的值随其它同引用变量对值的修改而发生了变化，但数值类型的变量却没有发生变化，这是因为python中类型分为可变类型与不可变类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可变类型，值可以改变：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;列表（list）、字典（dict）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可变类型，值不可以改变：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数值类型（int、long、bool、float）、字符串（str）、元组（tuple）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;本质上&lt;strong&gt;不可变量类型&lt;/strong&gt;在原值发生变化时，重新开辟空间生成了一个值的存储区域并引用了新的地址，验证示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a = 100
&lt;span&gt;2&lt;/span&gt; b =&lt;span&gt; a
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(a))
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(b))
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; a = 200
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--修改值后--&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(a))
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(id(b))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181007001753811-1539857169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;类基础（class）&lt;/h2&gt;
&lt;p&gt;python是&lt;strong&gt;面向对象的&lt;/strong&gt;，而面向对象编程的2个非常重要的概念就是：&lt;strong&gt;类和对象&lt;/strong&gt;（如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在这里不做过多描述）。&lt;/p&gt;
&lt;p&gt;对象是面向对象编程的核心，在使用对象的过程中，为了&lt;strong&gt;将具有共同特征和行为&lt;/strong&gt;的一组对象抽象定义，提出了一个新的概念：类。而类的具体”实现“就是：对象。&lt;/p&gt;
&lt;h3&gt;1.定义类&amp;amp;实现类&lt;/h3&gt;
&lt;p&gt;类的定义和对象的实现的基本语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CSharpCoder(): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义类、经典类方式定义&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C#程序员&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;CSharpCoder类的描述信息&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PythonCoder(object): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义类、新式类方式定义&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;'P&lt;/span&gt;&lt;span&gt;ython程序员&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;PythonCoder类的描述信息&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; cp_cder = CSharpCoder() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;实现CSharpCoder类的对象&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; py_cder = PythonCoder() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;实现PythonCoder类的对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.python中定义类有两种方式：&lt;strong&gt;新式类&lt;/strong&gt;和&lt;strong&gt;经典类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2.规范要求&lt;strong&gt;类的命名&lt;/strong&gt;方式采用：大驼峰。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;&lt;span&gt;pass&lt;/span&gt;&lt;/strong&gt;：&lt;strong&gt;空语句&lt;/strong&gt;，是为了保持程序结构的完整性，不做任何事情，一般用做占位语句。&lt;/p&gt;
&lt;p&gt;4.类的注释和函数的注释作用及语法是一样的。&lt;/p&gt;
&lt;h3&gt;2.定义属性&lt;/h3&gt;
&lt;p&gt;类中定义属性的示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CSharpCoder():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     name = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; cp_cder =&lt;span&gt; CSharpCoder()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; cp_cder.name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jonins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(cp_cder.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181009111127364-652358619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.定义方法&lt;/h3&gt;
&lt;p&gt;类中定义方法的示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CSharpCoder():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_name(self):
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.name)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; cp_cder =&lt;span&gt; CSharpCoder()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; cp_cder.name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jonins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; cp_cder.get_name()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181009112956706-1499704379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;python编写类的内置函数时，第一个参数都是&lt;span&gt;&lt;strong&gt;self&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因为当类初始化时会得到实例，&lt;span&gt;&lt;strong&gt;self&lt;/strong&gt;&lt;/span&gt;就是用于代表初始化得到的实例。在python设计之初，完全可以考虑似于Javascript中的&lt;span&gt;this&lt;/span&gt;或C#隐藏掉实例让人无感知（除非需要用到&lt;span&gt;this&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;但是python的哲学是“Explicit is better than implicit”因此python类中的方法需要一个&lt;span&gt;&lt;strong&gt;self&lt;/strong&gt;&lt;/span&gt;参数代表实例。&lt;/p&gt;
&lt;h3&gt;4.构造函数（init）&lt;/h3&gt;
&lt;p&gt;python中&lt;strong&gt;类&lt;/strong&gt;的的&lt;strong&gt;构造函数&lt;/strong&gt;需要用到：&lt;span&gt;&lt;strong&gt;__init__&lt;/strong&gt;&lt;/span&gt;，使用示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CSharpCoder():
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;  &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;实例化对象中...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self.age = 18
&lt;span&gt; 6&lt;/span&gt;         self.name =&lt;span&gt; name
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.age)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.name)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; cp_cder = CSharpCoder(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jonins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; cp_cder.get()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181009154834460-123556640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;&lt;strong&gt;.__init__()&lt;/strong&gt;&lt;/span&gt;方法，在实例化一个对象时默认被调用的初始化方法，不需要手动调用。&lt;br/&gt;2.&lt;span&gt;&lt;strong&gt;__init__(self)&lt;/strong&gt;&lt;/span&gt;中的&lt;span&gt;&lt;strong&gt;self&lt;/strong&gt;&lt;/span&gt;参数，不需要开发者传递，python解释器会自动把当前的对象引用传递进去。&lt;br/&gt;3.构造函数即实例化对象的一个标准，当&lt;strong&gt;&lt;span&gt;__init__()&lt;/span&gt;&lt;/strong&gt;方法指定&lt;strong&gt;&lt;span&gt;self&lt;/span&gt;&lt;/strong&gt;参数以外的参数时，外部实例化对象时必须传递所需的参数，否则报错。&lt;/p&gt;
&lt;h3&gt;5.析构函数（del）&lt;/h3&gt;
&lt;p&gt;析构函数，在释放对象时使用，需要用到&lt;span&gt;&lt;strong&gt;__del()__&lt;/strong&gt;&lt;/span&gt;，示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CSharpCoder():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;  &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;实例化对象中...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__del__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;释放对象中...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; cp_cder =&lt;span&gt; CSharpCoder()
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;del&lt;/span&gt; cp_cder &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440910/201810/1440910-20181010101753902-133448341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;析构函数在对象被删除时会自动调用。&lt;/p&gt;
&lt;h3&gt;6.类专有函数&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;__init__&lt;/strong&gt; ：构造函数，在生成对象时调用&lt;br/&gt;&lt;strong&gt;__del__&lt;/strong&gt; ：析构函数，释放对象时使用&lt;br/&gt;&lt;strong&gt;__repr__&lt;/strong&gt; ：打印，转换&lt;br/&gt;&lt;strong&gt;__setitem__&lt;/strong&gt; ：按照索引赋值&lt;br/&gt;&lt;strong&gt;__getitem__&lt;/strong&gt;：按照索引获取值&lt;br/&gt;&lt;strong&gt;__len__&lt;/strong&gt;：获得长度&lt;br/&gt;&lt;strong&gt;__cmp__&lt;/strong&gt;：比较运算&lt;br/&gt;&lt;strong&gt;__call__&lt;/strong&gt;：函数调用&lt;br/&gt;&lt;strong&gt;__add__&lt;/strong&gt;：加运算&lt;br/&gt;&lt;strong&gt;__sub__&lt;/strong&gt;：减运算&lt;br/&gt;&lt;strong&gt;__mul__&lt;/strong&gt;：乘运算&lt;br/&gt;&lt;strong&gt;__div__&lt;/strong&gt;：除运算&lt;br/&gt;&lt;strong&gt;__mod__&lt;/strong&gt;：求余运算&lt;br/&gt;&lt;strong&gt;__pow__&lt;/strong&gt;：乘方&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;self&amp;amp;__xxx__&lt;/h2&gt;
&lt;h3&gt;1.self（自身）&lt;/h3&gt;
&lt;p&gt;所谓的&lt;strong&gt;&lt;span&gt;self&lt;/span&gt;&lt;/strong&gt;，可以理解为”自己“，类似于C++中类里面的&lt;span&gt;this&lt;/span&gt;指针一样理解，就是对象自身的意思。&lt;br/&gt;某个对象调用其方法时，python解释器会把这个对象自身当作第一个参数传递给&lt;span&gt;&lt;strong&gt;self&lt;/strong&gt;&lt;/span&gt;，所以开发者只需要传递后面的参数即可。&lt;/p&gt;
&lt;h3&gt;2.__xxx__（魔法方法）&lt;/h3&gt;
&lt;p&gt;在python中，方法如果是：&lt;strong&gt;__xxx__()&lt;/strong&gt;形式的（&lt;strong&gt;双下划线所包围&lt;/strong&gt;），就表示具有一些特殊的功能，&lt;strong&gt;统称为“Magic Method”，即魔法方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这些特殊方法不需要直接调用，在特殊的情况下这些特殊方法会自动被python调用。下面是python魔法方法的整理列表（整理自网络）：&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;114&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;魔法方法&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;含义&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;基本的魔法方法&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;__new__(cls[, ...])&lt;/td&gt;
&lt;td&gt;1. __new__ 是在一个对象实例化的时候所调用的第一个方法&lt;br/&gt;2. 它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法&lt;br/&gt;3. __new__ 决定是否要使用该 __init__ 方法，因为 __new__ 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__ 没有返回实例对象，则 __init__ 不会被调用&lt;br/&gt;4. __new__ 主要是用于继承一个不可变的类型比如一个 tuple 或者 string&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__init__(self[, ...])&lt;/td&gt;
&lt;td&gt;构造器，当一个实例被创建的时候调用的初始化方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__del__(self)&lt;/td&gt;
&lt;td&gt;析构器，当一个实例被销毁的时候调用的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;__call__(self[, args...])&lt;/td&gt;
&lt;td&gt;允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__len__(self)&lt;/td&gt;
&lt;td&gt;定义当被 len() 调用时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__repr__(self)&lt;/td&gt;
&lt;td&gt;定义当被 repr() 调用时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__str__(self)&lt;/td&gt;
&lt;td&gt;定义当被 str() 调用时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__bytes__(self)&lt;/td&gt;
&lt;td&gt;定义当被 bytes() 调用时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__hash__(self)&lt;/td&gt;
&lt;td&gt;定义当被 hash() 调用时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__bool__(self)&lt;/td&gt;
&lt;td&gt;定义当被 bool() 调用时的行为，应该返回 True 或 False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;__format__(self, format_spec)&lt;/td&gt;
&lt;td&gt;定义当被 format() 调用时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;有关属性&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__getattr__(self, name)&lt;/td&gt;
&lt;td&gt;定义当用户试图获取一个不存在的属性时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;__getattribute__(self, name)&lt;/td&gt;
&lt;td&gt;定义当该类的属性被访问时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;__setattr__(self, name, value)&lt;/td&gt;
&lt;td&gt;定义当一个属性被设置时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__delattr__(self, name)&lt;/td&gt;
&lt;td&gt;定义当一个属性被删除时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__dir__(self)&lt;/td&gt;
&lt;td&gt;定义当 dir() 被调用时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;__get__(self, instance, owner)&lt;/td&gt;
&lt;td&gt;定义当描述符的值被取得时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;__set__(self, instance, value)&lt;/td&gt;
&lt;td&gt;定义当描述符的值被改变时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;__delete__(self, instance)&lt;/td&gt;
&lt;td&gt;定义当描述符的值被删除时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;比较操作符&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__lt__(self, other)&lt;/td&gt;
&lt;td&gt;定义小于号的行为：x &amp;lt; y 调用 x.__lt__(y)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__le__(self, other)&lt;/td&gt;
&lt;td&gt;定义小于等于号的行为：x &amp;lt;= y 调用 x.__le__(y)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__eq__(self, other)&lt;/td&gt;
&lt;td&gt;定义等于号的行为：x == y 调用 x.__eq__(y)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__ne__(self, other)&lt;/td&gt;
&lt;td&gt;定义不等号的行为：x != y 调用 x.__ne__(y)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__gt__(self, other)&lt;/td&gt;
&lt;td&gt;定义大于号的行为：x &amp;gt; y 调用 x.__gt__(y)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__ge__(self, other)&lt;/td&gt;
&lt;td&gt;定义大于等于号的行为：x &amp;gt;= y 调用 x.__ge__(y)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;算数运算符&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__add__(self, other)&lt;/td&gt;
&lt;td&gt;定义加法的行为：+&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__sub__(self, other)&lt;/td&gt;
&lt;td&gt;定义减法的行为：-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__mul__(self, other)&lt;/td&gt;
&lt;td&gt;定义乘法的行为：*&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__truediv__(self, other)&lt;/td&gt;
&lt;td&gt;定义真除法的行为：/&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;__floordiv__(self, other)&lt;/td&gt;
&lt;td&gt;定义整数除法的行为：//&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__mod__(self, other)&lt;/td&gt;
&lt;td&gt;定义取模算法的行为：%&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__divmod__(self, other)&lt;/td&gt;
&lt;td&gt;定义当被 divmod() 调用时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;__pow__(self, other[, modulo])&lt;/td&gt;
&lt;td&gt;定义当被 power() 调用或 ** 运算时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__lshift__(self, other)&lt;/td&gt;
&lt;td&gt;定义按位左移位的行为：&amp;lt;&amp;lt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__rshift__(self, other)&lt;/td&gt;
&lt;td&gt;定义按位右移位的行为：&amp;gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__and__(self, other)&lt;/td&gt;
&lt;td&gt;定义按位与操作的行为：&amp;amp;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__xor__(self, other)&lt;/td&gt;
&lt;td&gt;定义按位异或操作的行为：^&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__or__(self, other)&lt;/td&gt;
&lt;td&gt;定义按位或操作的行为：|&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;反运算&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__radd__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__rsub__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__rmul__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;__rtruediv__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;__rfloordiv__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__rmod__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__rdivmod__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__rpow__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__rlshift__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__rrshift__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__rxor__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__ror__(self, other)&lt;/td&gt;
&lt;td&gt;（与上方相同，当左操作数不支持相应的操作时被调用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;span&gt;&lt;strong&gt;增量赋值运算&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__iadd__(self, other)&lt;/td&gt;
&lt;td&gt;定义赋值加法的行为：+=&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__isub__(self, other)&lt;/td&gt;
&lt;td&gt;定义赋值减法的行为：-=&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__imul__(self, other)&lt;/td&gt;
&lt;td&gt;定义赋值乘法的行为：*=&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;__itruediv__(self, other)&lt;/td&gt;
&lt;td&gt;定义赋值真除法的行为：/=&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;__ifloordiv__(self, other)&lt;/td&gt;
&lt;td&gt;定义赋值整数除法的行为：//=&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__imod__(self, other)&lt;/td&gt;
&lt;td&gt;定义赋值取模算法的行为：%=&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;__ipow__(self, other[, modulo])&lt;/td&gt;
&lt;td&gt;定义赋值幂运算的行为：**=&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__ilshift__(self, other)&lt;/td&gt;
&lt;td&gt;定义赋值按位左移位的行为：&amp;lt;&amp;lt;=&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__irshift__(self, other)&lt;/td&gt;
&lt;td&gt;定义赋值按位右移位的行为：&amp;gt;&amp;gt;=&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__iand__(self, other)&lt;/td&gt;
&lt;td&gt;定义赋值按位与操作的行为：&amp;amp;=&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__ixor__(self, other)&lt;/td&gt;
&lt;td&gt;定义赋值按位异或操作的行为：^=&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__ior__(self, other)&lt;/td&gt;
&lt;td&gt;定义赋值按位或操作的行为：|=&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;一元操作符&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__neg__(self)&lt;/td&gt;
&lt;td&gt;定义正号的行为：+x&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__pos__(self)&lt;/td&gt;
&lt;td&gt;定义负号的行为：-x&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__abs__(self)&lt;/td&gt;
&lt;td&gt;定义当被 abs() 调用时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__invert__(self)&lt;/td&gt;
&lt;td&gt;定义按位求反的行为：~x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;类型转换&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__complex__(self)&lt;/td&gt;
&lt;td&gt;定义当被 complex() 调用时的行为（需要返回恰当的值）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__int__(self)&lt;/td&gt;
&lt;td&gt;定义当被 int() 调用时的行为（需要返回恰当的值）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__float__(self)&lt;/td&gt;
&lt;td&gt;定义当被 float() 调用时的行为（需要返回恰当的值）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__round__(self[, n])&lt;/td&gt;
&lt;td&gt;定义当被 round() 调用时的行为（需要返回恰当的值）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;__index__(self)&lt;/td&gt;
&lt;td&gt;1. 当对象是被应用在切片表达式中时，实现整形强制转换&lt;br/&gt;2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 __index__&lt;br/&gt;3. 如果 __index__ 被定义，则 __int__ 也需要被定义，且返回相同的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;上下文管理（with 语句）&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;__enter__(self)&lt;/td&gt;
&lt;td&gt;1. 定义当使用 with 语句时的初始化行为&lt;br/&gt;2. __enter__ 的返回值被 with 语句的目标或者 as 后的名字绑定&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;__exit__(self, exc_type, exc_value, traceback)&lt;/td&gt;
&lt;td&gt;1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么&lt;br/&gt;2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;容器类型&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__len__(self)&lt;/td&gt;
&lt;td&gt;定义当被 len() 调用时的行为（返回容器中元素的个数）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__getitem__(self, key)&lt;/td&gt;
&lt;td&gt;定义获取容器中指定元素的行为，相当于 self[key]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;__setitem__(self, key, value)&lt;/td&gt;
&lt;td&gt;定义设置容器中指定元素的行为，相当于 self[key] = value&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__delitem__(self, key)&lt;/td&gt;
&lt;td&gt;定义删除容器中指定元素的行为，相当于 del self[key]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__iter__(self)&lt;/td&gt;
&lt;td&gt;定义当迭代容器中的元素的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__reversed__(self)&lt;/td&gt;
&lt;td&gt;定义当被 reversed() 调用时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;__contains__(self, item)&lt;/td&gt;
&lt;td&gt;定义当使用成员测试运算符（in 或 not in）时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 若需要示例请戳：&lt;a href=&quot;http://blog.51cto.com/leejia/2132061?source=dra&quot; target=&quot;_blank&quot;&gt;Python魔法方法指南&lt;/a&gt;&lt;a href=&quot;http://blog.51cto.com/leejia/2132061?source=dra&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;关于继承，重写，静态类，异常捕获和处理、面向对象等其它内容因篇幅过长后续再补（到这里储备的基础知识应该够用了，后续若用到一些科学计算的库在现学吧）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来一段时间专注在&lt;span&gt;算法&amp;amp;数据结构&lt;/span&gt;，准备沉淀几个月迈过这道坎。当中&lt;/strong&gt;代码为加深了解尽可能写两套（C#和Python），感兴趣的朋友可以关注。&lt;/p&gt;
&lt;p&gt;谢谢大家。&lt;/p&gt;

</description>
<pubDate>Wed, 10 Oct 2018 02:48:00 +0000</pubDate>
<dc:creator>Jonins</dc:creator>
<og:description>前言 函数基础（function） 1.定义函数 定义函数需要用到def关键词，格式如下： 定义了函数后，相当于有了一个具有某功能的代码块，想要调用函数，通过函数名()即可。详细示例如下： 2.函数注</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jonins/p/9746507.html</dc:identifier>
</item>
<item>
<title>京东云，100倍故障时长赔付，呵呵 - 影子卓卓</title>
<link>http://www.cnblogs.com/zwjzone/p/9765036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwjzone/p/9765036.html</guid>
<description>&lt;p&gt;现在大厂都在玩云计算服务，但是售后服务就是见真章的时候了。前段时间的新闻，阿里，腾讯等故障，新闻里都说工程师如何秒定位问题，赔钱多积极等。可惜我瞎了。当初选择了京东云这种杀马特非主流的云。故事就此开始了。就是一个950块钱10万次的数据接口，突然消失了，然后喊天不应喊地地不灵，人工智能客服问题。详细的见我上一篇《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zwjzone/p/9729834.html&quot;&gt;京东万象数据接口，钱没花完，接口404，客服是白痴，无法维权&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;》。本贴来说说后续吧。在 快意恩仇的一句&quot;草尼玛&quot;之后。我被京东后台风控了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010095820904-980092468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9月30日还能好好登录骂客服的，现在狠了。绑定手机号吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010095948897-2070783853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题在于我在买电脑的那个京东账号和这个账号用户不是一个，显然是不行的，于是，老哥我就连登后台的资格都没有了。这就是京东。我在三线城市3000一个月的工资做的用户体系，也不至于此吧，况且9月30号以前为啥不风控我呢，我提了问题，就这么被风控。这就是京东云的售后。没办法，叔能忍婶不能忍啊。那就注册一个账号，找京东云。先回顾一下京东云高级工程师们做的大气的网站：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010100805944-1284205422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确实比咱3000一个月的增删查改程序员做的xxx管理系统要好看一些。重点看这个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010100932174-1091455757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;”数据 API 平台京东云万象大数据开放平台是京东云在已有的云计算平台基础上围绕数据提供方、数据需求方、数据服务方等多方，构建了以数据开放、数据共享、数据分析为核心的综合性数据开放平台，为全行业提供权威数据支持，打造全行业数据开放的优质生态圈。“ 这是首页的原话。&lt;/p&gt;
&lt;p&gt;还有下面这个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010101047164-1294338850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我安心无忧的100倍赔偿。（后来想这句话是有问题的，100倍故障时长，也就是说赔的是使用时间，呵呵呵，这文字游戏）。&lt;/p&gt;
&lt;p&gt;老哥我弄了个新号，登录了京东云，提交个工单：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010101415765-1521099323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;工单相应确实快。5分钟邮件告诉我有结果了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010101526698-2082264400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;呵呵呵，意思就是说，万象跟京东云没关系。100倍找他们去。首页说的很牛叉的数据api，就是这样的解释的 &quot;万象相关业务是和京东云业务是分开运营的，需要您咨询万象相关&quot;。WRNMMP。收老子钱的时候你龟儿子咋不分开收。&lt;/p&gt;
&lt;p&gt;打了010电话，终于不是人工智能了，让我回产品经理的邮件。终于加上了微信。首先是账号倍风控的问题，我故意先试探一下，结果这样回我：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010104935685-476769601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;考虑到这个老哥是真头像，我就打个码。毕竟咱的苦主是不要脸的京东，不是程序老哥。&lt;/p&gt;
&lt;p&gt;”是不应该注册成功的。“咱们忽悠政府单位的用户，也不能这样解释吧。我忍不住把接口事说出来了。这位技术老哥算负责，让妹子查了可以退款，但是就算退950，也是不容易的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010102840198-1538558012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;必须要发票。17年12月20号的发票。还强调”商家没发票不给退“。后来咨询公司财务，正规退发票，必须，让京东给开红字冲销发票。很显然京东是不会响应的。（后来想京东肯定是知道这种财税流程，故意的。）且不说赔偿了，连散买卖都没法。&lt;/p&gt;
&lt;p&gt;继续和两个老哥老姐一顿撕扯后，算是知道了点事情真相：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010103449729-200167981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010103523043-704249602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总的说，就是数据提供方跑了。就和在商城买电脑，出了问题，你找商户去，一个套路，也许这就是京东的文化。什么京东云，京东万象，收钱的时候是一家亲。等到有问题了，不是咱兄弟了。呵呵。估计哪天京东的云服务数据丢失了，也能扯一个第三方公司进来，然后问题和风险就转嫁了。每次看新闻，说东哥起家，就是非典时候，有人在论坛上说，”京东我知道，卖光盘的，xxxxx....“。天真的我居然信了。呵呵。MMP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/346277/201810/346277-20181010104250433-1560051726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; @贤达  呵呵。&lt;/p&gt;
</description>
<pubDate>Wed, 10 Oct 2018 02:43:00 +0000</pubDate>
<dc:creator>影子卓卓</dc:creator>
<og:description>现在大厂都在玩云计算服务，但是售后服务就是见真章的时候了。前段时间的新闻，阿里，腾讯等故障，新闻里都说工程师如何秒定位问题，赔钱多积极等。可惜我瞎了。当初选择了京东云这种杀马特非主流的云。故事就此开始</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zwjzone/p/9765036.html</dc:identifier>
</item>
<item>
<title>创建对象学习 —— 《高级教程》 - 一万分懵逼</title>
<link>http://www.cnblogs.com/lwl0812/p/9764936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwl0812/p/9764936.html</guid>
<description>&lt;p&gt;创建单个对象的缺点：用同一个接口创建很多对象，会产生大量的重复代码。&lt;/p&gt;
&lt;p&gt;工厂模式就是为了解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;621-工厂模式&quot; data-source-line=&quot;11&quot;&gt;工厂模式&lt;/h2&gt;
&lt;p&gt;解决了创建多个相似对象的问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createPerson(name, age, job) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    o.name &lt;/span&gt;=&lt;span&gt; name;
    o.age &lt;/span&gt;=&lt;span&gt; age;
    o.job &lt;/span&gt;=&lt;span&gt; job;
    o.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name)
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = createPerson('Mike', 28, 'xxx'&lt;span&gt;);
console.log(person1);
person1.sayName();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = createPerson('Mike', 24, 'aaa'&lt;span&gt;);
console.log(person2);
person2.sayName();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;缺点：无法解决对象识别的问题——怎样知道一个对象的类型&lt;/p&gt;
&lt;h2 id=&quot;622-构造函数模式&quot; data-source-line=&quot;37&quot;&gt;构造函数模式&lt;/h2&gt;
&lt;p&gt;ECMAScript中的构造函数可以用来创建特定类型的对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age , job) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.job =&lt;span&gt; job;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sayName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person('Mike', 28, 'teacher'&lt;span&gt;);
console.log(person1);
person1.sayName();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt; Person('Danie', 24, 'doctor'&lt;span&gt;);
console.log(person2);
person2.sayName();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与工厂模式的区别：&lt;/p&gt;
&lt;ul data-source-line=&quot;61&quot;&gt;&lt;li&gt;没有显示的创建对象&lt;/li&gt;
&lt;li&gt;将属性和方法赋值给了this对象&lt;/li&gt;
&lt;li&gt;没有return语句&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;构造函数本身也是函数，只不过可以用来创建对象&lt;/p&gt;
&lt;p&gt;用new操作符新建构造函数的实例，经历4个步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/804467/201810/804467-20181010101956819-734265226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;person1 和 person2 分别保存着 Person 的两个不同实例，都有一个 constructor (构造函数) 属性，指向 Person&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/804467/201810/804467-20181010102022319-2102915421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(person1.constructor == Person); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
console.log(person2.constructor == Person); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(person1.constructor == Object); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
console.log(person2.constructor == Object); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;person1 和 person2 都是 Person 的实例，也是 Object 的实例，可以通过&lt;span&gt; instanceof &lt;/span&gt;操作符来检验。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(person1 &lt;span&gt;instanceof&lt;/span&gt; Person); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
console.log(person2 &lt;span&gt;instanceof&lt;/span&gt; Person); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
console.log(person1 &lt;span&gt;instanceof&lt;/span&gt; Object); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
console.log(person2 &lt;span&gt;instanceof&lt;/span&gt; Object); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缺点：每个构造函数中的方法都要在新的实例上创建一遍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log(person1.sayName == person2.sayName); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将相同的方法移到外部：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; sayName() { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将相同的方法移到构造函数的外部&lt;/span&gt;
    console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age , job) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.job =&lt;span&gt; job;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sayName =&lt;span&gt; sayName;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person('Mike', 28, 'teacher'&lt;span&gt;);
console.log(person1);
person1.sayName();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt; Person('Danie', 24, 'doctor'&lt;span&gt;);
console.log(person2);
person2.sayName();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时不同实例上的方法就相等了&lt;/span&gt;
console.log(person1.sayName == person2.sayName); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缺点：需要在全局作用域定义很多函数，没有封装性可言&lt;/p&gt;
&lt;h2 id=&quot;623-原型模式&quot; data-source-line=&quot;140&quot;&gt;原型模式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/804467/201810/804467-20181010102226547-436871002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好处: 所有对象实例可共享它所包含的属性和方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {

}

Person.prototype.name &lt;/span&gt;= 'Mike'&lt;span&gt;;
Person.prototype.age &lt;/span&gt;= 28&lt;span&gt;;
Person.prototype.job &lt;/span&gt;= 'teacher'&lt;span&gt;;
Person.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person1.sayName();
person2.sayName();

console.log(person1.sayName &lt;/span&gt;== person2.sayName); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下图以上面代码为例，展示了Person构造函数、Person的原型属性，及两个实例之间的关系。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/804467/201810/804467-20181010102308824-412369887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实现中，无法访问 [[Prototype]]，可以用&lt;span&gt; isPrototypeOf() &lt;/span&gt;方法来确定对象之间是否有这种关系。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(Person.prototype.isPrototypeOf(person1)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
console.log(Person.prototype.isPrototypeOf(person2)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 &lt;span&gt;Object.getPrototypeOf()&lt;/span&gt; 方法，访问原型对象上的属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(Object.getPrototypeOf(person1) == Person.prototype); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
console.log(Object.getPrototypeOf(person1).name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mike&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改实例属性 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原型模式 修改实例属性&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {

}

Person.prototype.name &lt;/span&gt;= 'Mike'&lt;span&gt;;
Person.prototype.age &lt;/span&gt;= 28&lt;span&gt;;
Person.prototype.job &lt;/span&gt;= 'teacher'&lt;span&gt;;
Person.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person1.name &lt;/span&gt;= 'Gray'&lt;span&gt;;
person1.job &lt;/span&gt;= 'doctor'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person1.sayName(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Gray&lt;/span&gt;
person2.sayName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mike&lt;/span&gt;
&lt;span&gt;
console.log(person1); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Person {name: &quot;Gray&quot;, job: &quot;doctor&quot;, __proto__: Object}&lt;/span&gt;
console.log(person2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Person {__proto__: Object}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改实例属性为 null, 不会恢复指向原型的链接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {

}

Person.prototype.name &lt;/span&gt;= 'Mike'&lt;span&gt;;
Person.prototype.age &lt;/span&gt;= 28&lt;span&gt;;
Person.prototype.job &lt;/span&gt;= 'teacher'&lt;span&gt;;
Person.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person1.name &lt;/span&gt;= 'Gray'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person1.sayName(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Gray&lt;/span&gt;
person2.sayName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mike&lt;/span&gt;
person1.name = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不会恢复指向原型的链接&lt;/span&gt;
person1.sayName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除实例属性 会重新恢复指向原型对象的链接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原型模式 删除实例属性 会重新恢复指向原型对象的链接&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {

}

Person.prototype.name &lt;/span&gt;= 'Mike'&lt;span&gt;;
Person.prototype.age &lt;/span&gt;= 28&lt;span&gt;;
Person.prototype.job &lt;/span&gt;= 'teacher'&lt;span&gt;;
Person.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person1.name &lt;/span&gt;= 'Gray'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person1.sayName(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Gray&lt;/span&gt;
person2.sayName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mike&lt;/span&gt;
&lt;span&gt;delete&lt;/span&gt; person1.name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 会重新恢复指向原型对象的链接&lt;/span&gt;
person1.sayName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mike&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hasOwnProperty() 检测一个属性存在于实例中还是存在于原型中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原型模式 hasOwnProperty()&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {

}

Person.prototype.name &lt;/span&gt;= 'Mike'&lt;span&gt;;
Person.prototype.age &lt;/span&gt;= 28&lt;span&gt;;
Person.prototype.job &lt;/span&gt;= 'teacher'&lt;span&gt;;
Person.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
console.log(person1.hasOwnProperty(&lt;/span&gt;'name')); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
person1.name = 'Gray'&lt;span&gt;;
console.log(person1.hasOwnProperty(&lt;/span&gt;'name')); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
console.log(person2.hasOwnProperty(&lt;/span&gt;'name')); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; person1.name;
console.log(person1.hasOwnProperty(&lt;/span&gt;'name')); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Object.keys()&lt;/span&gt; 获得对象上所有可枚举的实例属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Object.keys()&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {

}

Person.prototype.name &lt;/span&gt;= 'Mike'&lt;span&gt;;
Person.prototype.age &lt;/span&gt;= 28&lt;span&gt;;
Person.prototype.job &lt;/span&gt;= 'teacher'&lt;span&gt;;
Person.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}
console.log(Object.keys(Person.prototype)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
console.log(Object.keys(person1)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; []&lt;/span&gt;
person1.name = 'Gray'&lt;span&gt;;
console.log(Object.keys(person1)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;name&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更简单的原型语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {

}

Person.prototype &lt;/span&gt;= { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; prototype 的 constructor 属性不再指向 Person&lt;/span&gt;
    name: 'Mike'&lt;span&gt;,
    age: &lt;/span&gt;28&lt;span&gt;,
    job: &lt;/span&gt;'Teacher'&lt;span&gt;,
    sayName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();

console.log(person1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;332&quot;&gt;以上方式，Person.prototype 的 constructor 属性将不再指向 Person。&lt;/p&gt;
&lt;p data-source-line=&quot;334&quot;&gt;对比下面两张图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Person.prototype.name = 'Mike'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方式创建的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;constructor 会指向 Person&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/804467/201810/804467-20181010102640530-201494785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Person.prototype = {}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对象字面量方式创建的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;constructor 不会指向 Person&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/804467/201810/804467-20181010102716641-314228403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过 instanceof 还能返回正确的结果，但是 constructor 已经不能确定对象的类型了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
console.log(person1 &lt;span&gt;instanceof&lt;/span&gt; Object); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
console.log(person1 &lt;span&gt;instanceof&lt;/span&gt; Person); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
console.log(person1.constructor == Object); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
console.log(person1.constructor == Person); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果 constructor 很重要，可以显示指定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 显示指定 constructor&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {

}

Person.prototype &lt;/span&gt;= { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过指定 constructor属性，指向 Person&lt;/span&gt;
    constructor: Person, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以这种方式重设，会使它的[[Enumerable]]特性被设置为true&lt;/span&gt;
    name: 'Mike'&lt;span&gt;,
    age: &lt;/span&gt;28&lt;span&gt;,
    job: &lt;/span&gt;'Teacher'&lt;span&gt;,
    sayName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
console.log(person1); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印出的结果见下图&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/804467/201810/804467-20181010102758728-1952090763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;383&quot;&gt;兼容 ECMAScript5的浏览器引擎&lt;/p&gt;
&lt;p data-source-line=&quot;385&quot;&gt;&lt;span&gt;Object.defineProperty()&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {

}

Person.prototype &lt;/span&gt;=&lt;span&gt; {
    name: &lt;/span&gt;'Mike'&lt;span&gt;,
    age: &lt;/span&gt;28&lt;span&gt;,
    job: &lt;/span&gt;'Teacher'&lt;span&gt;,
    sayName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}

Object.defineProperty(Person.prototype, &lt;/span&gt;'constructor'&lt;span&gt;, {
    enumerable: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    value: Person
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;原型的动态性&quot; data-source-line=&quot;407&quot;&gt;原型的动态性&lt;/h3&gt;
&lt;p&gt;先创建实例，再在Person的原型对象上加方法，实例也可以调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原型的动态性&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {

}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();

Person.prototype.sayHi &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'Hi'&lt;span&gt;);
}

person1.sayHi(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Hi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重写原型对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {

}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();

Person.prototype &lt;/span&gt;= { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过指定 constructor属性，指向 Person&lt;/span&gt;
&lt;span&gt;    constructor: Person,
    name: &lt;/span&gt;'Mike'&lt;span&gt;,
    age: &lt;/span&gt;28&lt;span&gt;,
    job: &lt;/span&gt;'Teacher'&lt;span&gt;,
    sayName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}
console.log(person1);
person1.sayName(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; person1.sayName is not a function&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，person1的原型对象上没有Person的新原型对象上的属性，因为他们是两个不同的对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/804467/201810/804467-20181010102921159-473718890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图展示了重写原型之前和重写原型之后各个对象之间的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/804467/201810/804467-20181010102938753-1149520977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/804467/201810/804467-20181010103002554-1495724103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 未完待续...&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注：以上所有的文字、代码都是本人一个字一个字敲上去的，图片也是一张一张画出来的，转载请注明出处，谢谢！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Oct 2018 02:32:00 +0000</pubDate>
<dc:creator>一万分懵逼</dc:creator>
<og:description>创建单个对象的缺点：用同一个接口创建很多对象，会产生大量的重复代码。 工厂模式就是为了解决这个问题。 工厂模式 解决了创建多个相似对象的问题 缺点：无法解决对象识别的问题——怎样知道一个对象的类型 构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwl0812/p/9764936.html</dc:identifier>
</item>
<item>
<title>《React Native 精解与实战》书籍连载「React Native 源码学习方法及其他资源」 - Parry</title>
<link>http://www.cnblogs.com/parry/p/react_native_resources.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/parry/p/react_native_resources.html</guid>
<description>&lt;p&gt;此系列文章将整合我的 React 视频教程与 React Native 书籍中的精华部分，给大家介绍 React Native 源码学习方法及其他资源。&lt;/p&gt;
&lt;p&gt;最后的章节给大家介绍 React Native 源码的查阅方法，以便你进行更加高阶的开发与研究时参阅，并分享了开发过程中可能遇到的众多问题的解决方案，以及与 React Native 开发相关、本书相关的一些线上资源。&lt;/p&gt;

&lt;p&gt;我们在学习了 React Native 开发的方方面面之后，我们再次回到 React Native 的本质，给大家简要介绍 React Native 源码的学习方法，对 React Native 源码的整体框架做一个简单介绍，后续如果大家想深入阅读 React Native 框架的源码，希望这部分对你有所帮助，并且能从源码中学习到复杂框架的设计思想，希望大家也能“造出复杂的轮子”。&lt;/p&gt;
&lt;p&gt;React Native 项目的 GitHub 地址为：&lt;a href=&quot;https://github.com/facebook/react-native&quot; class=&quot;uri&quot;&gt;https://github.com/facebook/react-native&lt;/a&gt;，源码的基本结构如图 A-1 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oindk07nf.qnssl.com/b_cd2c9907d7c2c7abf1e52dfd9dfb2723.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 A-1 React Native 源码结构&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根目录中主要包含了项目的一些配置文件和一些描述性文档；&lt;/li&gt;
&lt;li&gt;初始化项目的 React Native CLI 定义在 react-native-cli 文件夹下；&lt;/li&gt;
&lt;li&gt;RNTester 文件夹包含了 React Native 项目的单元测试用例以及组件、API 的使用示例代码，是一个学习 React Native 组件与 API 使用方法的宝库，这个在之前的章节有过介绍；&lt;/li&gt;
&lt;li&gt;React 文件夹是 iOS 原生平台的项目文件夹，用于与 React Native 的 JavaScript 代码通信；&lt;/li&gt;
&lt;li&gt;ReactAndroid 文件夹是 Android 原生平台的项目文件夹，用于与 React Native 的 JavaScript 代码通信；&lt;/li&gt;
&lt;li&gt;babel-preset 文件夹是 React Native 项目的 Babel 预配置；&lt;/li&gt;
&lt;li&gt;Libraries 文件夹是 React Native 源码的核心，所有的 React Native 组件与 API 的实现都在此文件夹中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来我们就随便找一个组件来看看 React Native 是如何进行实现的，假设我们就来看看 Alert 组件的实现，其实通过我们在 React Native 与原生平台混合开发章节的学习，我们已经大概知道了 React Native 是如何来实现的。&lt;/p&gt;
&lt;p&gt;我们先来看 Alert 组件 JavaScript 端的实现，Alert 组件包含的文件如图 A-2 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oindk07nf.qnssl.com/b_3cf11ecd89f2e78fc1a8ff128f4a06e1.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 A-2 Alert 组件源码结构&lt;/p&gt;
&lt;p&gt;源码在 &lt;a href=&quot;https://github.com/facebook/react-native/blob/master/Libraries/Alert/Alert.js&quot; class=&quot;uri&quot;&gt;https://github.com/facebook/react-native/blob/master/Libraries/Alert/Alert.js&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;jsx&quot;&gt;
&lt;code&gt;1.  ......  
2.  class Alert {  
3.    
4.    /** 
5.     * Launches an alert dialog with the specified title and message. 
6.     * 
7.     * See http://facebook.github.io/react-native/docs/alert.html#alert 
8.     */  
9.    static alert(  
10.     title: ?string,  
11.     message?: ?string,  
12.     buttons?: Buttons,  
13.     options?: Options,  
14.     type?: AlertType,  
15.   ): void {  
16.     if (Platform.OS === 'ios') {  
17.       if (typeof type !== 'undefined') {  
18.         console.warn('Alert.alert() with a 5th &quot;type&quot; parameter is deprecated and will be removed. Use AlertIOS.prompt() instead.');  
19.         AlertIOS.alert(title, message, buttons, type);  
20.         return;  
21.       }  
22.       AlertIOS.alert(title, message, buttons);  
23.     } else if (Platform.OS === 'android') {  
24.       AlertAndroid.alert(title, message, buttons, options);  
25.     }  
26.   }  
27. }  
28.   
29. /** 
30.  * Wrapper around the Android native module. 
31.  */  
32. class AlertAndroid {  
33.   
34.   static alert(  
35.     title: ?string,  
36.     message?: ?string,  
37.     buttons?: Buttons,  
38.     options?: Options,  
39.   ): void {  
40.     var config = {  
41.       title: title || '',  
42.       message: message || '',  
43.     };  
44.   
45.     if (options) {  
46.       config = {...config, cancelable: options.cancelable};  
47.     }  
48.     // At most three buttons (neutral, negative, positive). Ignore rest.  
49.     // The text 'OK' should be probably localized. iOS Alert does that in native.  
50.     var validButtons: Buttons = buttons ? buttons.slice(0, 3) : [{text: 'OK'}];  
51.     var buttonPositive = validButtons.pop();  
52.     var buttonNegative = validButtons.pop();  
53.     var buttonNeutral = validButtons.pop();  
54.     if (buttonNeutral) {  
55.       config = {...config, buttonNeutral: buttonNeutral.text || '' };  
56.     }  
57.     if (buttonNegative) {  
58.       config = {...config, buttonNegative: buttonNegative.text || '' };  
59.     }  
60.     if (buttonPositive) {  
61.       config = {...config, buttonPositive: buttonPositive.text || '' };  
62.     }  
63.     NativeModules.DialogManagerAndroid.showAlert(  
64.       config,  
65.       (errorMessage) =&amp;gt; console.warn(errorMessage),  
66.       (action, buttonKey) =&amp;gt; {  
67.         if (action === NativeModules.DialogManagerAndroid.buttonClicked) {  
68.           if (buttonKey === NativeModules.DialogManagerAndroid.buttonNeutral) {  
69.             buttonNeutral.onPress &amp;amp;&amp;amp; buttonNeutral.onPress();  
70.           } else if (buttonKey === NativeModules.DialogManagerAndroid.buttonNegative) {  
71.             buttonNegative.onPress &amp;amp;&amp;amp; buttonNegative.onPress();  
72.           } else if (buttonKey === NativeModules.DialogManagerAndroid.buttonPositive) {  
73.             buttonPositive.onPress &amp;amp;&amp;amp; buttonPositive.onPress();  
74.           }  
75.         } else if (action === NativeModules.DialogManagerAndroid.dismissed) {  
76.           options &amp;amp;&amp;amp; options.onDismiss &amp;amp;&amp;amp; options.onDismiss();  
77.         }  
78.       }  
79.     );  
80.   }  
81. }  
82.   
83. module.exports = Alert;  
84. ......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此段代码省略了头部的相关内容，在代码的第 16 行通过 Platform 变量判断当前所运行的平台，如果是 iOS 平台，那么就调用 AlertIOS 文件中定义的代码，如果是 Android 平台就调用代码第 32 行定义的 AlertAndroid 用于实现对 Android 原生平台 Alert 的调用，注意代码的第 63 行，是不是和我们实战 React Native 与 Android 平台混合开发的实现一样？所以 React Native 的所有组件与 API 基本都是通过此种方法进行了封装后提供给了开发者，所以我们可以说 iOS 原生平台与 Android 原生平台具备的功能都可以通过封装后在 React Native 框架中使用。&lt;/p&gt;
&lt;p&gt;对应的 Android 原生端的实现代码在：&lt;a href=&quot;https://github.com/facebook/react-native/blob/26684cf3adf4094eb6c405d345a75bf8c7c0bf88/ReactAndroid/src/main/java/com/facebook/react/modules/dialog/DialogModule.java&quot; class=&quot;uri&quot;&gt;https://github.com/facebook/react-native/blob/26684cf3adf4094eb6c405d345a75bf8c7c0bf88/ReactAndroid/src/main/java/com/facebook/react/modules/dialog/DialogModule.java&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;jsx&quot;&gt;
&lt;code&gt;86. ......  
87.  @ReactMethod  
88.   public void showAlert(  
89.       ReadableMap options,  
90.       Callback errorCallback,  
91.       final Callback actionCallback) {  
92.     final FragmentManagerHelper fragmentManagerHelper = getFragmentManagerHelper();  
93.     if (fragmentManagerHelper == null) {  
94.       errorCallback.invoke(&quot;Tried to show an alert while not attached to an Activity&quot;);  
95.       return;  
96.     }  
97.   
98.     final Bundle args = new Bundle();  
99.     if (options.hasKey(KEY_TITLE)) {  
100.          args.putString(AlertFragment.ARG_TITLE, options.getString(KEY_TITLE));  
101.        }  
102.        if (options.hasKey(KEY_MESSAGE)) {  
103.          args.putString(AlertFragment.ARG_MESSAGE, options.getString(KEY_MESSAGE));  
104.        }  
105.        if (options.hasKey(KEY_BUTTON_POSITIVE)) {  
106.          args.putString(AlertFragment.ARG_BUTTON_POSITIVE, options.getString(KEY_BUTTON_POSITIVE));  
107.        }  
108.        if (options.hasKey(KEY_BUTTON_NEGATIVE)) {  
109.          args.putString(AlertFragment.ARG_BUTTON_NEGATIVE, options.getString(KEY_BUTTON_NEGATIVE));  
110.        }  
111.        if (options.hasKey(KEY_BUTTON_NEUTRAL)) {  
112.          args.putString(AlertFragment.ARG_BUTTON_NEUTRAL, options.getString(KEY_BUTTON_NEUTRAL));  
113.        }  
114.        if (options.hasKey(KEY_ITEMS)) {  
115.          ReadableArray items = options.getArray(KEY_ITEMS);  
116.          CharSequence[] itemsArray = new CharSequence[items.size()];  
117.          for (int i = 0; i &amp;lt; items.size(); i ++) {  
118.            itemsArray[i] = items.getString(i);  
119.          }  
120.          args.putCharSequenceArray(AlertFragment.ARG_ITEMS, itemsArray);  
121.        }  
122.        if (options.hasKey(KEY_CANCELABLE)) {  
123.          args.putBoolean(KEY_CANCELABLE, options.getBoolean(KEY_CANCELABLE));  
124.        }  
125.      
126.        UiThreadUtil.runOnUiThread(new Runnable() {  
127.          @Override  
128.          public void run() {  
129.            fragmentManagerHelper.showNewAlert(mIsInForeground, args, actionCallback);  
130.          }  
131.        });  
132.      
133.      }  
134.    ......  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过如上代码看到整个 Android 端的 showAlert 实现完全就是我们平时进行 Android 原生开发的代码实现，而通过 React Native 的封装之后，可以轻松让开发者在前端通过 JavaScript 的代码调用原生平台的方法，还可以直接适配两个平台，这样的框架设计的确有魅力，源码也值得好好阅读。&lt;/p&gt;
&lt;p&gt;以上主要是给大家把 React Native 源码的基本结构告诉大家，空闲时间大家可以多去阅读 React Native 的实现源码，希望能对你 React Native 的学习再多一些帮助。&lt;/p&gt;
&lt;p&gt;关于源码学习过程中的任何问题都可以在本书的线上资源站点找到我的联系方式和我交流。&lt;/p&gt;

&lt;p&gt;任何开发语言的学习，即使相关的书籍讲解得再详细，也不能完全覆盖你在开发过程中遇到的种种问题，所以我们需要掌握一些查找疑难问题的基本方案。&lt;/p&gt;
&lt;p&gt;关于大家在学习本书进行 React Native 开发的过程中，有几个建议遵循的原则与查找问题的方案供大家参考。&lt;/p&gt;
&lt;h2 id=&quot;不要纠结于-react-native-的版本问题&quot;&gt;1. 不要纠结于 React Native 的版本问题&lt;/h2&gt;
&lt;p&gt;很多时候我们在学习时纠结于 React Native 版本更新后，自己已学习的知识是否会落后，从而频繁地在安装最新版本的 React Native 框架、以及解决新版本与老的学习代码冲突上浪费太多的时间。其实很多的前端框架的更新都比较激进，React 基本实现了两周版本一更新，而每次的版本升级肯定会导致和你既有的项目代码有稍许冲突的地方，而如果你花大量地时间去解决这些冲突没有太大的意义。&lt;/p&gt;
&lt;p&gt;所以一般的建议是你固定一个版本的 React Native 进行学习，因为版本的更新一般都很小，你只需要专注于框架的使用学习，尽快通过代码实战掌握框架的基本使用，后期可以认真研究框架的底层实现原理，而后期的版本更新基本都不会离开你已掌握的框架知识，更不会与你理解的实现原理有太大出入。&lt;/p&gt;
&lt;h2 id=&quot;单个平台进行问题定位&quot;&gt;2. 单个平台进行问题定位&lt;/h2&gt;
&lt;p&gt;React Native 的开发因为涉及到 iOS 平台与 Android 平台的适配，有时一个问题可能影响到了两个平台的表现，这时应该逐个平台突破，而不是两个平台来一起调试，反而会造成代码的逻辑混乱，如果需要在代码上强制分离逻辑调试，可以通过 Platform 变量判断当前是运行在哪个平台，进而编写特定的平台代码进行分离调试。&lt;/p&gt;
&lt;h2 id=&quot;善用官方的-issues&quot;&gt;3. 善用官方的 Issues&lt;/h2&gt;
&lt;p&gt;React Native 因为源码就发布在 GitHub 上，所以你可以直接在 GitHub 项目页面上查找开发过程中遇到的问题，在 Issues 页面中已包含了近万个问题，基本上你使用过程中遇到的问题肯定有别人遇到过，所以要学会直接在 Issues 中查找问题的原因以及解决方案，实在找不到解决方案你还可以向 React Native 项目提交 Issue，并可以获得 React Native 开发团队的回复，我想应该没有人比 React Native 开发团队的人更了解 React Native 了吧，不过在提问前最好自己多动手查阅一遍所有的 Issues 是否已包含了你遇到的问题了。&lt;/p&gt;
&lt;p&gt;React Native 的官方 Issues 地址为：&lt;a href=&quot;https://github.com/facebook/react-native/issues&quot; class=&quot;uri&quot;&gt;https://github.com/facebook/react-native/issues&lt;/a&gt;，截图如图 A-3 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oindk07nf.qnssl.com/b_2be708bc16260e8573ceb5ff9944b629.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 A-3 React Native 官方 Issues 页面&lt;/p&gt;

&lt;ol readability=&quot;42.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;本书配套源码的 GitHub 地址&lt;br/&gt;包含书籍中所有标注的完整代码、代码片段等，所有的章节代码都进行了单独文件夹存放，方便查阅，后续关于本书的相关更新也在此 GitHub 中更新。&lt;br/&gt;地址：https://github.com/ParryQiu/ReactNative-Book-Demo&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;React GitHub&lt;br/&gt;地址：https://github.com/facebook/react/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;React Native 官网&lt;br/&gt;地址：https://facebook.github.io/react-native/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;React Native GitHub&lt;br/&gt;地址：https://github.com/facebook/react-native&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;awesome-react-native GitHub&lt;br/&gt;地址：https://github.com/jondot/awesome-react-native&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;深入理解 React JS 中的 setState&lt;br/&gt;地址：http://blog.parryqiu.com/2017/12/19/react_set_state_asynchronously/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;从源码的角度再看 React JS 中的 setState&lt;br/&gt;地址：http://blog.parryqiu.com/2017/12/29/react-state-in-sourcecode/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;从源码的角度看 React JS 中批量更新 State 的策略（上）&lt;br/&gt;地址：http://blog.parryqiu.com/2018/01/04/2018-01-04/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;从源码的角度看 React JS 中批量更新 State 的策略（下）&lt;br/&gt;地址：http://blog.parryqiu.com/2018/01/08/2018-01-08/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Node.js 官网&lt;br/&gt;地址：https://nodejs.org&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;npm 官网&lt;br/&gt;地址：https://www.npmjs.com/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Node.js 下载页面&lt;br/&gt;地址：https://nodejs.org/en/download/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Homebrew 官网&lt;br/&gt;地址：https://brew.sh/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;官方 UI 示例 App&lt;br/&gt;地址：https://github.com/facebook/react-native/tree/master/RNTester&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;react-native-elements&lt;br/&gt;地址：https://github.com/react-native-training/react-native-elements&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;react-native-tab-navigator&lt;br/&gt;地址：https://github.com/happypancake/react-native-tab-navigator&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;react-native-navigation&lt;br/&gt;地址：https://github.com/wix/react-native-navigation&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;react-native-keychain&lt;br/&gt;地址：https://github.com/oblador/react-native-keychain&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;react-native-sensitive-info&lt;br/&gt;地址：https://github.com/mCodex/react-native-sensitive-info&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;react-native-image-picker&lt;br/&gt;地址：https://github.com/react-community/react-native-image-picker&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Fetch API 文档&lt;br/&gt;地址：https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Awesome React Native&lt;br/&gt;地址：https://github.com/jondot/awesome-react-native&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;react-native-open-share&lt;br/&gt;地址：https://github.com/ParryQiu/react-native-open-share&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新浪微博开放平台&lt;br/&gt;地址：http://open.weibo.com/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;微信开放平台&lt;br/&gt;地址：https://open.weixin.qq.com/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;QQ 开放平台&lt;br/&gt;地址：http://open.qq.com/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;React-Virgin&lt;br/&gt;地址：https://github.com/Trixieapp/react-virgin&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;react-native-pathjs-charts&lt;br/&gt;地址：https://github.com/capitalone/react-native-pathjs-charts&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;react-native-gifted-listview&lt;br/&gt;地址：https://github.com/FaridSafi/react-native-gifted-listview&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;react-native-vector-icons&lt;br/&gt;地址：https://github.com/oblador/react-native-vector-icons&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;React Native metro&lt;br/&gt;地址：https://github.com/facebook/metro&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Genymotion&lt;br/&gt;地址：https://www.genymotion.com/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;极光推送官网&lt;br/&gt;地址：https://www.jiguang.cn/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;jpush-react-native&lt;br/&gt;地址：https://github.com/jpush/jpush-react-native&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;极光推送 iOS 证书设置向导&lt;br/&gt;地址：https://docs.jiguang.cn/jpush/client/iOS/ios_cer_guide/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Ape Tools&lt;br/&gt;地址：http://apetools.webprofusion.com/tools/imagegorilla&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;App 图标生成工具&lt;br/&gt;https://makeappicon.com/&lt;br/&gt;http://ios.hvims.com/&lt;br/&gt;https://romannurik.github.io/AndroidAssetStudio/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;react-native-code-push&lt;br/&gt;地址：https://github.com/Microsoft/react-native-code-push&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;React Native Issues&lt;br/&gt;地址：https://github.com/facebook/react-native/issues&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;以上的所有链接汇总页面&lt;br/&gt;如果你觉得需要查阅以上的链接，手动在浏览器中输入太麻烦，你可以直接访问本书的线上所有链接汇总站点，在此站点中你可以看到以上的所有链接以及链接说明，直接点击即可访问、查阅，希望能帮助大家提高学习效率。&lt;br/&gt;地址：http://rn.parryqiu.com&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 10 Oct 2018 02:00:00 +0000</pubDate>
<dc:creator>Parry</dc:creator>
<og:description>此文是我的出版书籍[《React Native 精解与实战》](http://rn.parryqiu.com/)连载分享，此书由机械工业出版社出版，书中详解了 React Native 框架底层原理、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/parry/p/react_native_resources.html</dc:identifier>
</item>
</channel>
</rss>