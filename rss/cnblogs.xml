<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>div元素宽度不定的情况下如何居中显示 - 弹钢琴的小男孩</title>
<link>http://www.cnblogs.com/sunsonghao/p/8120902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunsonghao/p/8120902.html</guid>
<description>&lt;p&gt;最近由于工作的原因碰到一个问题，就是在一个弹窗宽度不定的情况下还能是该弹窗居中显示，思考许久未找到合适办法，于是在网上找到一些办法在此总结记录下来方便以后的学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;兼容IE67，但是当元素宽度大于50%时，会出现滚动条。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;father&quot;&amp;gt;
    &amp;lt;div class=&quot;child&quot;&amp;gt;这个是需要剧中的元素，宽度不确定&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

.father {
    display: inlien-block; //使.father得宽度适应.child的宽度
    background-color: grey; // 方便看到.father元素
    position: relative;
    left: 50%;
}
.child {
    position: relative;
    left: -50%;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/878086/201712/878086-20171227005453838-792034498.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;思路如下：&lt;br/&gt;外层设置为float:left或者display:inline-block,然后设置相对定位，left:50%，这样左边位置就偏移到了中间的位置;然后内层设置相对定位，left:-50%，这样正好向左偏移自身宽度的一半，实现了居中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;兼容ie67&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;father&quot;&amp;gt;
    &amp;lt;div class=&quot;child&quot;&amp;gt;这个是需要剧中的元素，宽度不确定&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

.father {
    text-align: center; //设置该属性是为了让.father里面的 **内联** 元素居中。
}
.child {
    display: inlne-block;
    border:1px solid red;
    *display: inline; /*主要用于激活IE中的hasLayout属性，兼容IE67*/
    /*zoom:1;*/ /*主要用于激活IE中的hasLayout属性，兼容IE67*/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/878086/201712/878086-20171227005342932-1850711813.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;思路如下：&lt;br/&gt;外层使用text-align为center是为了让里面的内联元素居中，很显然在外层设置text-align:center后，我们让里面的元素变成内联元素即可，则可以对里面元素使用display:inline-block;*display:inline(兼容IE6-7)。&lt;/p&gt;
&lt;p&gt;IE浏览器的hasLayout属性，参考：&lt;a href=&quot;https://baike.so.com/doc/6747002-6961548.html&quot; class=&quot;uri&quot;&gt;https://baike.so.com/doc/6747002-6961548.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Dec 2017 16:45:00 +0000</pubDate>
<dc:creator>弹钢琴的小男孩</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunsonghao/p/8120902.html</dc:identifier>
</item>
<item>
<title>MyBatis_查询缓存01 - hoje</title>
<link>http://www.cnblogs.com/hoje/p/8117575.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hoje/p/8117575.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、查询缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简单化，不在每次均从数据库中查询获取结果数据，从而提高访问速度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1212417/201712/1212417-20171226133047901-2010140884.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1212417/201712/1212417-20171226133428229-449397571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   MyBatis的查询缓存机制，根据缓存区的作用域与生命周期，可划分为两种：一级缓存和二级缓存。&lt;/p&gt;
&lt;p&gt;   MyBatis查询缓存的作用域是根据映射文件mapper的namespace划分的，相同namespace的mapper查询数据存放在同一个缓存区域。不同的namespace下的数据互不干扰。无论是一级缓存还是二级缓存，都是按照namespace进行分别存放的。&lt;/p&gt;
&lt;p&gt;   但一、二级缓存的不同之处在于，SqlSession一旦关闭，则SQLSession中的数据将不存在，即一级缓存就不存在，而二级缓存的生命周期会与整个应用同步，与SQLSession是否关闭无关。&lt;/p&gt;
&lt;p&gt;  简单的说，一级缓存是在同一线程（同一SQLSession）间共享数据，而二级缓存是在不同线程间共享数据。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;二、一级缓存的证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1212417/201712/1212417-20171226165145776-2043006111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1212417/201712/1212417-20171226165158260-1969799786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、从缓存中查找数据的依据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1212417/201712/1212417-20171226170218495-1639122156.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1212417/201712/1212417-20171226170231807-956085457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MyBatis的查询依据是：Sql的id+SQL语句。&lt;/p&gt;
&lt;p&gt;Hibernate的查依据是：查询结果对象的id。&lt;/p&gt;
&lt;p&gt;缓存的底层实现是一个Map,Map的value是查询结果。Map的key，即查询依据，使用的ORM架构不同，查询依据就不不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ORM&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;lemma-summary&quot; readability=&quot;38.5&quot;&gt;
&lt;p&gt;ORM（Object Relational Mapping）框架采用元数据来描述对象一关系映射细节，元数据一般采用XML格式，并且存放在专门的对象一映射文件中。&lt;/p&gt;
&lt;p&gt;只要提供了持久化类与表的映射关系，ORM框架在运行时就能参照映射文件的信息，把对象持久化到数据库中。&lt;/p&gt;
&lt;p&gt;当前ORM框架主要有五种：Hibernate(Nhibernate)，iBATIS，mybatis，EclipseLink，JFinal。&lt;/p&gt;
&lt;p&gt;元数据：是描述其它数据的数据 （data about other data）&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;四、增删改对一级缓存的影响&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test03() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Student student = dao.selectStudentById(197&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        System.out.println(student);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;增删改操作都会清空一级缓存&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         dao.insertStudent(&lt;span&gt;new&lt;/span&gt; Student(&quot;阿古斯&quot;,26,96.5&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         Student student1 = dao.selectStudentById(197&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        System.out.println(student1);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
0 [main] DEBUG com.jmu.dao.IStudentDao.selectStudentById  - ==&amp;gt;  Preparing: select id,name,age,score from student where id=? 
75 [main] DEBUG com.jmu.dao.IStudentDao.selectStudentById  - ==&amp;gt; Parameters: 197&lt;span&gt;(Integer)
&lt;/span&gt;116 [main] TRACE com.jmu.dao.IStudentDao.selectStudentById  - &amp;lt;==&lt;span&gt;    Columns: id, name, age, score
&lt;/span&gt;116 [main] TRACE com.jmu.dao.IStudentDao.selectStudentById  - &amp;lt;==        Row: 197, 明明, 19, 87.9
120 [main] DEBUG com.jmu.dao.IStudentDao.selectStudentById  - &amp;lt;==      Total: 1&lt;span&gt;
Student [id&lt;/span&gt;=197, name=明明, score=87.9, age=19&lt;span&gt;]
&lt;/span&gt;121 [main] DEBUG com.jmu.dao.IStudentDao.insertStudent  - ==&amp;gt;  Preparing: insert into student(name,age,score) values(?,?,?&lt;span&gt;) 
&lt;/span&gt;122 [main] DEBUG com.jmu.dao.IStudentDao.insertStudent  - ==&amp;gt; Parameters: 阿古斯(String), 26(Integer), 96.5&lt;span&gt;(Double)
&lt;/span&gt;123 [main] DEBUG com.jmu.dao.IStudentDao.insertStudent  - &amp;lt;==    Updates: 1
124 [main] DEBUG com.jmu.dao.IStudentDao.selectStudentById  - ==&amp;gt;  Preparing: select id,name,age,score from student where id=? 
124 [main] DEBUG com.jmu.dao.IStudentDao.selectStudentById  - ==&amp;gt; Parameters: 197&lt;span&gt;(Integer)
&lt;/span&gt;124 [main] TRACE com.jmu.dao.IStudentDao.selectStudentById  - &amp;lt;==&lt;span&gt;    Columns: id, name, age, score
&lt;/span&gt;125 [main] TRACE com.jmu.dao.IStudentDao.selectStudentById  - &amp;lt;==        Row: 197, 明明, 19, 87.9
125 [main] DEBUG com.jmu.dao.IStudentDao.selectStudentById  - &amp;lt;==      Total: 1&lt;span&gt;
Student [id&lt;/span&gt;=197, name=明明, score=87.9, age=19]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
结论：增删改操作都会清空一级缓存，无论是否提交
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;五、内置二级缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）二级缓存的开启&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MyBatis的使用二级缓存的目的是为了防止同一查询（相同Sql id、相同的Sql语句）的反复执行。&lt;/p&gt;
&lt;p&gt;Hibernate中的缓存就是为了在多个查询间共享查询结果（所有查询中只要查询结果中存在改对象的，就直接从缓存中读取）&lt;/p&gt;
&lt;p&gt;MyBatis内置的二级缓存为org.apache.ibatis.cache.Impl.PerpetualCache.&lt;/p&gt;
&lt;p&gt; 首先，证明二级缓存的存在。&lt;/p&gt;
&lt;p&gt;因为SqlSession一旦关闭，一级缓存就不存在，而二级缓存的生命周期会与整个应用同步，与SQLSession是否关闭无关。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
sqlSession.close();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开启内置的二级缓存步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对实体进行序列化&lt;img src=&quot;https://images2017.cnblogs.com/blog/1212417/201712/1212417-20171226233357120-685647911.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在映射文件中添加&amp;lt;cache/&amp;gt;标签；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缓存命中率：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
【DEBUG】 Cache Hit Ratio：0.5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（2）增删改对二级缓存的影响&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test01() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         sqlSession =&lt;span&gt; MybatisUtils.getSqlSession();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         dao = sqlSession.getMapper(IStudentDao.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Student student = dao.selectStudentById(197&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        System.out.println(student);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        sqlSession.close();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;         sqlSession =&lt;span&gt; MybatisUtils.getSqlSession();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         dao = sqlSession.getMapper(IStudentDao.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         
&lt;span&gt;12&lt;/span&gt;         dao.insertStudent(&lt;span&gt;new&lt;/span&gt; Student(&quot;&quot;,0,0&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt;         Student student1 = dao.selectStudentById(197&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        System.out.println(student1);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1212417/201712/1212417-20171226235429432-1604162498.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面的例子说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;增删改同样会清空二级缓存；&lt;/li&gt;
&lt;li&gt;对于二级缓存的清空，实际上是对所查找key对应的value置为null，而非将&amp;lt;key,value&amp;gt;对，即Entry对象删除&lt;/li&gt;
&lt;li&gt;从DB中重新进行select查询的条件是：A、缓存中根本不存在这个key；B、缓存中存在改key所对应的Entry对象，但其value为null&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;（3）二级缓存的配置&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;size：二级缓存中可以存放的最多对象个数，默认为1024个。（实际上就是HashMap的长度，可以放多少Entry对象）&lt;/li&gt;
&lt;li&gt;eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为LRU。常用的策略有：FIFO（First in First out）先进先出、LRU（Least Recently Used）未被使用时间最长的。&lt;/li&gt;
&lt;li&gt;flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不知道，即当执行增删改时刷新缓存。&lt;/li&gt;
&lt;li&gt;readOnly:设置缓存中数据是否只读。默认false。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（4）二级缓存的关闭&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）全局关闭&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;settings&amp;gt;
        &amp;lt;!-- 关闭二级缓存 --&amp;gt;
        &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot; /&amp;gt;
    &amp;lt;/settings&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）局部关闭&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1212417/201712/1212417-20171227002840588-1739407946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）二级缓存的使用原则&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;多个namespace不要操作同一张表&lt;/li&gt;
&lt;li&gt;不要在关联关系表上执行增删改操作（一个namespace一般对同一个表，若表间存在关联关系，也就意味着同一个表可能会出现多个namespace。若其中一个namespace对表进行增删改操作而影响到了其关联表数据，而这个关联表的数据修改之后刷新当前namespace下的二级缓存，而对另一个namespace下的二级缓存数据没有影响）&lt;/li&gt;
&lt;li&gt;查询多于修改时使用二级缓存&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 26 Dec 2017 16:39:00 +0000</pubDate>
<dc:creator>hoje</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hoje/p/8117575.html</dc:identifier>
</item>
<item>
<title>关于redis的使用 - 尼古拉斯凯光</title>
<link>http://www.cnblogs.com/guangye/p/8120683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guangye/p/8120683.html</guid>
<description>&lt;p&gt;　　距离上次写博客有两三个月了，这段时间去了新公司上班，忙了很多。接手了一个项目，刚好用到redis，先总结下遇到的问题（跟redis相关的问题）：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、列表问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　举例：展示商品列表，但是要先展示运营置顶的数据，如果排序的序号一样，则按照id降序排序，就是需要按照sort asc, id desc 来排序；用redis怎么处理？&lt;/p&gt;
&lt;p&gt;　　【分析】&lt;/p&gt;
&lt;p&gt;　　首先这个问题可能本身有点问题，因为如果限定了redis，那么处理的方法就给限定死了，当时由于一股劲想着用redis处理，而忘了去想下redis是否适合处理这种问题；&lt;/p&gt;
&lt;p&gt;　　第二，讲下一开始是怎么用redis处理的：&lt;/p&gt;
&lt;p&gt;　　1）商品列表存储起来在有序集合，按照sort字段排序比如有序集合goods-by-sort中数据：&lt;/p&gt;
&lt;p&gt;　　商品id （member） ， value（score）&lt;/p&gt;
&lt;p&gt;　　1　　　　　　　　　　1&lt;/p&gt;
&lt;p&gt;　　2　　　　　　　　　　1　　&lt;/p&gt;
&lt;p&gt;　　3　　　　　　　　　　3&lt;/p&gt;
&lt;p&gt;　　4　　　　　　　　　　2&lt;/p&gt;
&lt;p&gt;　　2）每当创建新商品，加入此队列，sort值是默认值；&lt;/p&gt;
&lt;p&gt;　　3）每当运营在管理后台修改sort值，则修改此有序集合中对应商品的score值；&lt;/p&gt;
&lt;p&gt;　　4）删除商品，或者设置不可见，则从这个有序集合中删掉该商品id的数据；&lt;/p&gt;
&lt;p&gt;　　5）用户获取商品列表时，因为需要按照sort和id排序，所以我当时再新增一个有序集合： goods_list_data，首先从goods_by_sort取出数据，在程序里面重新排序，然后写到goods_temp有序集合，然后rename为goods_list_data有序集合，然后给这个集合设置一个过期时间，比如2分钟。&lt;/p&gt;
&lt;p&gt;　　6）针对上面第2）到第4）步可能会对goods_by_sort有序集合的数据进行调整，比如修改、新增和删除，那么goods_list_data数据也需要更新，否则用户会一直看到被删除的商品。所以上面这三种情况，我会去更新一个string类型的refresh_goods_data 的key，每次去incr。用一个定时任务，每分钟一次去检查这个值，如果不为0，那么就去更新goods_list_data，然后设置refresh_goods_data的值为0,。否则则不处理，因为goods_list_data有序集合没改动。&lt;/p&gt;
&lt;p&gt;　　【上面这么做的问题】&lt;/p&gt;
&lt;p&gt;　　1）耦合很深，不好维护；搞了2个有序集合，还有定时任务；&lt;/p&gt;
&lt;p&gt;　　2）会有无底洞问题：有序集合存储的数据会越来越多，当然这个可以根据业务处理，比如裁剪，但是维护这个有序集合也是个问题，增删改都要做相应维护。&lt;/p&gt;
&lt;p&gt;　　【比较好的处理方法】&lt;/p&gt;
&lt;p&gt;　　1）还是回归到查询数据库，根据sort asc,id desc 排序来分页获取，但是基础数据就从redis中获取；这个要根据数据量，还有sql语句复杂度来评估，如果联表，或者是已经被告知数据库出现这个慢查询sql，那就肯定不能用这个方法。&lt;/p&gt;
&lt;p&gt;　　2）同事建议这种用sphinx来处理，有道理，不过还没尝试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　2、redis防雪崩、防穿透、无底洞问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　【分析和解决方法】&lt;/p&gt;
&lt;p&gt;　　防止雪崩问题的有效方法：&lt;/p&gt;
&lt;p&gt;　　1）不设置过期时间，只要数据实时更新到redis，那么给用户的数据就是实时的，不影响后端数据库；&lt;/p&gt;
&lt;p&gt;　　2）热数据和冷数据的区分，每天定时刷新热数据；&lt;/p&gt;
&lt;p&gt;　　防穿透问题：&lt;/p&gt;
&lt;p&gt;　　1）由于在redis中找不到数据，所以会去数据库读取，但是数据库也没有，所以不会写回缓存，导致并发访问时每次兜圈数据库读取；&lt;/p&gt;
&lt;p&gt;　　2）可以给这类数据写一个null或false到redis，设置一个过期时间，比如2分钟；&lt;/p&gt;
&lt;p&gt;　　3）要注意的是，这种key不能存储太长时间，key的量多起来，内存占用也会多的。&lt;/p&gt;
&lt;p&gt;　　无底洞问题：&lt;/p&gt;
&lt;p&gt;　　1）key如果不过期，那么会一直保存在内存，内存会越来越不够用；&lt;/p&gt;
&lt;p&gt;　　2）key如果过期，那么过期后，怎么处理，高并发访问数据，数据库会不会挂掉？网上有不少代码用setnx加锁方式，获取到锁的就去db查询然后写回redis，而其他的请求没有获取到锁，则等待一段时间（比如10毫秒）然后再去redis读取，取到就返回，取不到数据的话可以根据业务看要不要直接返回空结果，还是再去获取锁，直到读取到数据或者尝试的次数到达指定次数。&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;　3、刷缓存问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　举例：由于是在一个老项目上做优化，之前是没有做redis缓存（严格来说还是有缓存，但是仅仅是把api接口的结果缓存起来设置个过期时间），所以新的优化上线后，如果访问旧的数据，缓存中没有，那么如果不刷数据，就会所有请求到缓存都是空命中，此时要么直接返回说没数据（用户体验非常差），或者去数据库查询，此时是类似雪崩的情况，并发访问数据库，数据库可能会挂掉，那么比较好的处理方式就是先把数据刷到缓存。这里该如何处理？&lt;/p&gt;
&lt;p&gt;　　【分析】&lt;/p&gt;
&lt;p&gt;　　1）根据业务，分析哪些数据需要提前刷新到缓存；&lt;/p&gt;
&lt;p&gt;　　2）增加锁机制，如果获取不到数据，则先去获取锁，获取到锁的则去db查询然后写回redis，db无数据则写null或false到redis并设置过期时间；&lt;/p&gt;
&lt;p&gt;　　3）根据数据库表中数据量和业务，分析是否可以先刷一部分数据。比如商品有1000万条数据，用户在网站首页可以分页慢慢地看1000万条数据，但是大部分用户可能只会看前面的几十页数据，比如一页20条数据，那么准备2000条最新数据或者热门数据即可。其他的商品，等待用户访问的时候，从redis获取，读取不到从db获取写回redis即可。 &lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;4、商品之间根据标签进行关联&lt;/strong&gt;，比如：&lt;/p&gt;
&lt;p&gt;　　商品A： tag1， tag2 ，tag3&lt;/p&gt;
&lt;p&gt;　　商品B： tag2， tag4&lt;/p&gt;
&lt;p&gt;　　商品C： tag1， tag5&lt;/p&gt;
&lt;p&gt;　　商品D： tag4&lt;/p&gt;
&lt;p&gt;　　所以，商品A和商品B、商品C关联；商品B和商品D关联；商品C和商品A关联；商品D和商品B关联。&lt;/p&gt;
&lt;p&gt;　　每当要获取商品A关联的商品时，当然可以从db去获取A的标签，然后计算出管理的商品，那么如何用redis处理？&lt;/p&gt;
&lt;p&gt;　　【分析】&lt;/p&gt;
&lt;p&gt;　　如果非要用redis处理，那么就是需要提前把关系计算好，存放到集合/有序集合，那么一旦需要获取数据的时候，不需要再去计算，而是直接从缓存读出这些关联的id。&lt;/p&gt;
&lt;p&gt;　　1）新增商品时，会附带标签。计算关联的商品，是比较耗时的操作，可以放在队列，由后台脚本定时处理；&lt;/p&gt;
&lt;p&gt;　　2）删除商品时，也是需要放入队列，由后台脚本去处理；&lt;/p&gt;
&lt;p&gt;　　3）修改标签（给商品新增一个或多个标签、删除一个或多个标签和修改某些标签），也是需要放入队列，由后台脚本去处理；&lt;/p&gt;
&lt;p&gt;　　【上面这么做的问题】&lt;/p&gt;
&lt;p&gt;　　1）不好维护；增删改，都需要去维护这个有序集合。好处就是需要获取关联数据时直接从集合/有序集合获取id，基础信息也从redis获取；&lt;/p&gt;
&lt;p&gt;　　2）请教了同事，说用sphinx也可以处理，还没尝试。&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;　5、用redis能否解决mysql like 的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　答案自然是解决不了，只能用sphinx或es这些全文搜索系统。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;6、商品列表&lt;/strong&gt;有个逻辑是，允许展示用户自己发布的商品（不论审核状态）+其他用户发布的商品（只能审核通过状态）的这些数据。当时用redis处理，搞了两个有序集合，一个是存储网站上所有审核通过的商品；第二个有序集合是存储用户自己发布的商品（不论审核状态）。当需要获取商品列表时，合并两个集合，然后分页取数据。&lt;/p&gt;
&lt;p&gt;　　【问题】&lt;/p&gt;
&lt;p&gt;　　并发情况下，合并有序集合的代价是很高的，可能造成阻塞；&lt;/p&gt;
&lt;p&gt;　　【解决方法】&lt;/p&gt;
&lt;p&gt;　　1）可以的话直接mysql查询。&lt;/p&gt;
&lt;p&gt;　　2）使用sphinx：又是同事的建议。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、redis不是万能的，也有自己的优势和劣势；redis不适合处理sql这种关系型的业务；&lt;/p&gt;
&lt;p&gt;　　2、redis的性能是很好的，但是人为的操作，使用不当，可能造成阻塞；&lt;/p&gt;
&lt;p&gt;　　3、除了redis，还有其他的方法可以处理，不能限定死了。处理问题的时候，不仅要考虑能不能处理，还要考虑是否合理。&lt;/p&gt;

</description>
<pubDate>Tue, 26 Dec 2017 16:06:00 +0000</pubDate>
<dc:creator>尼古拉斯凯光</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guangye/p/8120683.html</dc:identifier>
</item>
<item>
<title>CS:APP3e 深入理解计算机系统_3e ShellLab(tsh)实验 - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/8120617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/8120617.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;详细的题目要求和资源可以到 &lt;a href=&quot;http://csapp.cs.cmu.edu/3e/labs.html&quot; class=&quot;uri&quot;&gt;http://csapp.cs.cmu.edu/3e/labs.html&lt;/a&gt; 或者 &lt;a href=&quot;http://www.cs.cmu.edu/&quot; class=&quot;uri&quot;&gt;http://www.cs.cmu.edu/&lt;/a&gt;~./213/schedule.html 获取。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;完整代码：&lt;a href=&quot;https://paste.ubuntu.com/26257776/&quot; class=&quot;uri&quot;&gt;https://paste.ubuntu.com/26257776/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;前期准备&quot;&gt;&lt;span&gt;前期准备&lt;/span&gt;&lt;/h3&gt;

&lt;h3 id=&quot;注意事项&quot;&gt;&lt;span&gt;注意事项&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;tsh的提示符为“tsh&amp;gt; ”&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用户的输入分为第一个的&lt;code&gt;name&lt;/code&gt;和后面的参数，之间以一个或多个空格隔开。如果&lt;code&gt;name&lt;/code&gt;是一个tsh内置的命令，那么tsh应该马上处理这个命令然后等待下一个输入。否则，tsh应该假设&lt;code&gt;name&lt;/code&gt;是一个路径上的可执行文件，并在一个子进程中运行这个文件（这也称为一个工作、job）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;tsh不需要支持管道和重定向&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果用户输入&lt;code&gt;ctrl-c&lt;/code&gt; (&lt;code&gt;ctrl-z&lt;/code&gt;)，那么&lt;code&gt;SIGINT&lt;/code&gt; (&lt;code&gt;SIGTSTP&lt;/code&gt;)信号应该被送给每一个在前台进程组中的进程，如果没有进程，那么这两个信号应该不起作用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果一个命令以“&amp;amp;”结尾，那么tsh应该将它们放在后台运行，否则就放在前台运行（并等待它的结束）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每一个工作（job）都有一个正整数PID或者job ID（JID）。JID通过&quot;%&quot;前缀标识符表示，例如，“%5”表示JID为5的工作，而“5”代笔PID为5的进程。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;tsh应该有如下内置命令：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;span&gt;&lt;code&gt;quit: 退出当前shell

jobs: 列出所有后台运行的工作

bg &amp;lt;job&amp;gt;: 这个命令将会向&amp;lt;job&amp;gt;代表的工作发送SIGCONT信号并放在后台运行，&amp;lt;job&amp;gt;可以是一个PID也可以是一个JID。

fg &amp;lt;job&amp;gt;: 这个命令会向&amp;lt;job&amp;gt;代表的工作发送SIGCONT信号并放在前台运行，&amp;lt;job&amp;gt;可以是一个PID也可以是一个JID。&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;tsh应该回收（reap）所有僵尸孩子，如果一个工作是因为收到了一个它没有捕获的（没有按照信号处理函数）而终止的，那么tsh应该输出这个工作的PID和这个信号的相关描述。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;提示&quot;&gt;&lt;span&gt;提示&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;利用测试文件逐步构建tsh，例如先从trace01.txt开始。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;setpgid&lt;/code&gt;中的WUNTRACED and WNOHANG选项有用（参看前期准备）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当解析命令并产生子进程的时候（&lt;code&gt;fork&lt;/code&gt; ）的时候，必须先调用&lt;code&gt;sigprocmask&lt;/code&gt; block &lt;code&gt;SIGCHLD&lt;/code&gt;信号，调用&lt;code&gt;addjob&lt;/code&gt;将刚刚创建的工作加入到工作列表里，然后unblock该信号（课件里有讲这个竞争产生的问题）。另外，由于子进程会继承block的特性，所以子进程要记得unblock。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一些具有终端环境的进程会尝试从父进程读写数据，例如/bin/sh，还有一些程序例如&lt;code&gt;more&lt;/code&gt; &lt;code&gt;less&lt;/code&gt; &lt;code&gt;vi&lt;/code&gt; &lt;code&gt;emacs&lt;/code&gt; 会对终端做一些“奇怪的设置”。本次实验用&lt;code&gt;/bin/ls&lt;/code&gt; &lt;code&gt;/bin/echo&lt;/code&gt;这样的文字模式的程序测试即可。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当我们在真正的shell（例如bash）中执行tsh时，tsh本身也是被放在前台进程组中的，它的子进程也会在前台进程组中，例如下图所示：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;span&gt;&lt;code&gt;               +----------+
               |   Bash   |
               +----+-----+
                    |
+-----------------------------------------+
|                   v                     |
|              +----+-----+   foreground  |
|              |   tsh    |   group       |
|              +----+-----+               |
|                   |                     |
|         +--------------------+          |
|         |         |          |          |
|         v         v          v          |
|       /bin/ls    /bin/sleep  xxxxx      |
|                                         |
|                                         |
+-----------------------------------------+&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;所以当我们在终端输入&lt;code&gt;ctrl-c&lt;/code&gt; (&lt;code&gt;ctrl-z&lt;/code&gt;)的时候，&lt;code&gt;SIGINT&lt;/code&gt; (&lt;code&gt;SIGTSTP&lt;/code&gt;)信号应该被送给每一个在前台进程组中的&lt;strong&gt;所有进程&lt;/strong&gt;，包括我们在tsh中认为是后台进程的程序。一个决绝的方法就是在&lt;code&gt;fork&lt;/code&gt;之后&lt;code&gt;execve&lt;/code&gt;之前，子进程应该调用&lt;code&gt;setpgid(0, 0)&lt;/code&gt;使得它进入一个新的进程组（其pgid等于该进程的pid）。tsh接收到&lt;code&gt;SIGINT&lt;/code&gt; &lt;code&gt;SIGTSTP&lt;/code&gt;信号后应该将它们发送给tsh眼中正确的“前台进程组”（包括其中的所有进程）。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;思路及其实现&quot;&gt;&lt;span&gt;思路及其实现&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我首先将书上（8.5.5节）说的6个关于&lt;strong&gt;信号处理函数安全性&lt;/strong&gt;的要求列出（详细的解释请参考书），在编程的时候要注意：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;尽量保持信号处理函数的简单性，例如只改变一个flag&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在信号处理函数内部只调用&lt;code&gt;async-signal-safe&lt;/code&gt;的函数（&lt;code&gt;man 7 signal&lt;/code&gt;里面有完全的列出）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在进入和退出信号处理函数的时候保存和还原&lt;code&gt;errno&lt;/code&gt;变量（参考：&lt;a href=&quot;https://en.wikipedia.org/wiki/Thread-local_storage&quot;&gt;Thread-local storage&lt;/a&gt; ）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当试图访问全局结构变量的时候暂时block所有的信号，然后还原&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;全局变量的声明为&lt;code&gt;volatile&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将flag（标志）声明为&lt;code&gt;sig_atomic_t&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;下面我就实验要求完成的7个函数说几个注意的地方，代码中的注释也解释了一些：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* Here are the functions that you will implement */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; eval(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *cmdline);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; builtin_cmd(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; **argv, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *cmdline);
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; do_bgfg(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; **argv, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *cmdline);
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; waitfg(pid_t pid);

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; sigchld_handler(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sig);
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; sigtstp_handler(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sig);
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; sigint_handler(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sig);&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;void-evalchar-cmdline&quot;&gt;&lt;span&gt;1.void eval(char *cmdline)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在调用&lt;code&gt;parseline&lt;/code&gt;解析输出后，我们首先判断这是一个内置命令（shell实现）还是一个程序（本地文件）。如果是内置命令，进入&lt;code&gt;builtin_cmd(argv, cmdline)&lt;/code&gt; ，否则创建子进程并在job列表里完成添加。这里要注意在&lt;code&gt;fork&lt;/code&gt;前用&lt;code&gt;access&lt;/code&gt;判断是否存在这个文件，不然fork以后无法回收，另外要注意一个线程并行竞争（race）的问题：&lt;code&gt;fork&lt;/code&gt;以后会在job列表里添加job，信号处理函数&lt;code&gt;sigchld_handler&lt;/code&gt;回收进程后会在job列表中删除，如果信号来的比较早，那么就可能会发生先删除后添加的情况。这样这个job永远不会在列表中消失了（内存泄露），所以我们要先block&lt;code&gt;SIGCHLD&lt;/code&gt; ，添加以后再还原。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * eval - Evaluate the command line that the user has just typed in&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * If the user has requested a built-in command (quit, jobs, bg or fg)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * then execute it immediately. Otherwise, fork a child process and&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * run the job in the context of the child. If the job is running in&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * the foreground, wait for it to terminate and then return.  Note:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * each child process must have a unique process group ID so that our&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * background children don't receive SIGINT (SIGTSTP) from the kernel&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * when we type ctrl-c (ctrl-z) at the keyboard.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; eval(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *cmdline)
{
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *argv[MAXARGS];
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; bg_flag;

    bg_flag = parseline(cmdline, argv); &lt;span class=&quot;co&quot;&gt;/* true if the user has requested a BG job, false if the user has requested a FG job. */&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (builtin_cmd(argv, cmdline)) &lt;span class=&quot;co&quot;&gt;/* built-in command */&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/* program (file) */&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (access(argv[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;], F_OK)) &lt;span class=&quot;co&quot;&gt;/* do not fork and addset! */&lt;/span&gt;
        {
            fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;%s: Command not found&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, argv[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
        }

        pid_t pid;
        sigset_t mask, prev;
        sigemptyset(&amp;amp;mask);
        sigaddset(&amp;amp;mask, SIGCHLD);
        sigprocmask(SIG_BLOCK, &amp;amp;mask, &amp;amp;prev); &lt;span class=&quot;co&quot;&gt;/* block SIG_CHLD */&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((pid=fork()) == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;/* child */&lt;/span&gt;
        {
            sigprocmask(SIG_SETMASK, &amp;amp;prev, NULL); &lt;span class=&quot;co&quot;&gt;/* unblock SIG_CHLD */&lt;/span&gt;

            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!setpgid(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;))
            {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (execve(argv[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;], argv, environ))
                {
                    fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;%s: Failed to execve&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, argv[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
                }
                &lt;span class=&quot;co&quot;&gt;/* context changed */&lt;/span&gt;
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            {
                unix_error(&lt;span class=&quot;st&quot;&gt;&quot;Failed to invoke setpgid(0, 0)&quot;&lt;/span&gt;);
            }
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (pid &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;co&quot;&gt;/* tsh */&lt;/span&gt;
        {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!bg_flag) &lt;span class=&quot;co&quot;&gt;/* exec foreground */&lt;/span&gt;
            {
                fg_pid = pid;
                fg_pid_reap = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
                addjob(jobs, pid, FG, cmdline);
                sigprocmask(SIG_SETMASK, &amp;amp;prev, NULL); &lt;span class=&quot;co&quot;&gt;/* unblock SIG_CHLD */&lt;/span&gt;
                waitfg(pid);
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/* exec background */&lt;/span&gt;
            {
                addjob(jobs, pid, BG, cmdline);
                sigprocmask(SIG_SETMASK, &amp;amp;prev, NULL); &lt;span class=&quot;co&quot;&gt;/* unblock SIG_CHLD */&lt;/span&gt;
                printf(&lt;span class=&quot;st&quot;&gt;&quot;[%d] (%d) %s&quot;&lt;/span&gt;, maxjid(jobs), pid, cmdline);
            }
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
        {
            unix_error(&lt;span class=&quot;st&quot;&gt;&quot;Failed to fork child&quot;&lt;/span&gt;);
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;int-builtin_cmdchar-argv-char-cmdline&quot;&gt;&lt;span&gt;2.int builtin_cmd(char **argv, char *cmdline)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;这个函数分情况判断是哪一个内置命令，要注意如果用户仅仅按下回车键，那么在解析后&lt;code&gt;argv&lt;/code&gt;的第一个变量将是一个空指针。如果用这个空指针去调用&lt;code&gt;strcmp&lt;/code&gt;函数会引发segment fault。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * builtin_cmd - If the user has typed a built-in command then execute&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *    it immediately.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; builtin_cmd(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; **argv, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *cmdline)
{
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *first_arg = argv[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;];

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (first_arg == NULL) &lt;span class=&quot;co&quot;&gt;/* if input nothing('\n') in function main, then the&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;                              first_arg here will be NULL, which will cause SEG fault when invoke strcmp(read) */&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!strcmp(first_arg, &lt;span class=&quot;st&quot;&gt;&quot;quit&quot;&lt;/span&gt;))
    {
        exit(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
    }
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!strcmp(first_arg, &lt;span class=&quot;st&quot;&gt;&quot;jobs&quot;&lt;/span&gt;))
    {
        listjobs(jobs);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!strcmp(first_arg, &lt;span class=&quot;st&quot;&gt;&quot;bg&quot;&lt;/span&gt;) || !strcmp(first_arg, &lt;span class=&quot;st&quot;&gt;&quot;fg&quot;&lt;/span&gt;))
    {
        do_bgfg(argv, cmdline);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;void-do_bgfgchar-argv-char-cmdline&quot;&gt;&lt;span&gt;3.void do_bgfg(char **argv, char *cmdline)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;这个函数单独处理了&lt;code&gt;bg&lt;/code&gt;和&lt;code&gt;fg&lt;/code&gt;这两个内置命令。要注意&lt;code&gt;fg&lt;/code&gt;有两个对应的情况：1.后台程序是stopped的状态，这时我们需要设置相关变量，然后发送继续的信号。2.如果这个进程本身就在运行，我们就只需要改变job的状态，设置相关变量，然后进入&lt;code&gt;waitfg&lt;/code&gt;等待这个新的前台进程执行完毕。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;写这个也出现了一个让我debug 几个小时的兼容性问题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;code&gt;man 7 signal&lt;/code&gt;中，&lt;code&gt;SIGCHLD&lt;/code&gt;描述如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;SIGCHLD   20,17,18    Ign     Child stopped or terminated&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;也就是说，子进程终止或者停止的时候会向父进程发送这个信号，然后父进程进入&lt;code&gt;sigchld_handler&lt;/code&gt;信号处理函数进行回收或者提示。但是在我的机器上却发现在子进程从stopped变到running（收到&lt;code&gt;SIGCONT&lt;/code&gt; ）的时候也会向父进程发送这个信号。这样就会出现一个问题：我们要使后台一个stopped的进程重新运行，但是它会向父进程（shell）发送一个&lt;code&gt;SIGCONT&lt;/code&gt; ，这样父进程就会进入信号处理函数&lt;code&gt;sigchld_handler&lt;/code&gt;试图回收它（不是stop），而它有没有结束，所以信号处理函数会一直等待它执行完毕，在shell中显示的情况就是卡住了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过长时间调试确认后发现在POSIX某个标准中&lt;code&gt;SIGCHLD&lt;/code&gt;信号的定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9.4704049844237&quot;&gt;
&lt;p&gt;&lt;span&gt;SIGCHLD&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/SIGCHLD&quot;&gt;SIGCHLD&lt;/a&gt; signal is sent to a process when a &lt;strong&gt;child process&lt;/strong&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Exit_(operating_system)&quot;&gt;terminates&lt;/a&gt;, is interrupted, or resumes after being interrupted. One common usage of the signal is to instruct the operating system to clean up the resources used by a child process after its termination without an explicit call to the &lt;code&gt;wait&lt;/code&gt; system call.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;or resumes after being interrupted.&lt;/code&gt; ，看到这句的时候我就要吐血了。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了进一步证实我的想法，我在FreeBSD11.1上面查了一下手册：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1072319/201712/1072319-20171226234149182-581652645.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他说的是“changed”，看来我的机器是按照POSIX的某个标准实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的解决方案是设置一个&lt;code&gt;pid_t&lt;/code&gt;的全局变量stopped_resume_child记录我们要fg的stopped进程，在进入信号处理函数后首先检查这个变量是否大于零，如果是就直接退出不做处理。（这里其实有一个和其他进程竞争的问题，时间有限就不去做更改了）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * do_bgfg - Execute the builtin bg and fg commands&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; do_bgfg(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; **argv, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *cmdline)
{
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *first_arg = argv[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;];
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!strcmp(first_arg, &lt;span class=&quot;st&quot;&gt;&quot;bg&quot;&lt;/span&gt;))
    {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] == NULL)
        {
            fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;bg command requires PID or %%jobid argument&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
        }

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] == '%') &lt;span class=&quot;co&quot;&gt;/* JID */&lt;/span&gt;
        {
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; jid = atoi(argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (jid)
            {
                &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; job_t *job_tmp = getjobjid(jobs, jid);
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (job_tmp != NULL)
                {
                    job_tmp-&amp;gt;state = BG;
                    printf(&lt;span class=&quot;st&quot;&gt;&quot;[%d] (%d) %s&quot;&lt;/span&gt;, jid, job_tmp-&amp;gt;pid, job_tmp-&amp;gt;cmdline);
                    stopped_resume_child = job_tmp-&amp;gt;pid;
                    killpg(job_tmp-&amp;gt;pid, SIGCONT);
                   
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                {
                    fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;%%%s: No such job&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
                }
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            {
                fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;%%%s: No such job&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            }
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/* PID */&lt;/span&gt;
        {
            pid_t pid = atoi(argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(pid)
            {
                &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; job_t *job_tmp = getjobpid(jobs, pid);
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (job_tmp != NULL)
                {
                    job_tmp-&amp;gt;state = BG;
                    printf(&lt;span class=&quot;st&quot;&gt;&quot;[%d] (%d) %s&quot;&lt;/span&gt;, job_tmp-&amp;gt;jid, pid, job_tmp-&amp;gt;cmdline);
                    stopped_resume_child = job_tmp-&amp;gt;pid;
                    killpg(pid, SIGCONT);
                   
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                {
                    fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;(%s): No such process&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]);
                }
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            {
                fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;bg: argument must be a PID or %%jobid&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
            }
        }
    }
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
    {
        &lt;span class=&quot;co&quot;&gt;/* there are two case when using fg:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        1. the job stopped &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        2. the job is running&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        */&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] == NULL)
        {
            fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;fg command requires PID or %%jobid argument&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] == '%') &lt;span class=&quot;co&quot;&gt;/* JID */&lt;/span&gt;
        {
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; jid = atoi(argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (jid)
            {
                &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; job_t *job_tmp = getjobjid(jobs, jid);
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (job_tmp != NULL)
                {
                    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; state = job_tmp-&amp;gt;state;
                    fg_pid = job_tmp-&amp;gt;pid; &lt;span class=&quot;co&quot;&gt;/* this is the new foreground process */&lt;/span&gt;
                    fg_pid_reap = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

                    job_tmp-&amp;gt;state = FG;

                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (state == ST)
                    {
                        stopped_resume_child = job_tmp-&amp;gt;pid; &lt;span class=&quot;co&quot;&gt;/* set the global var in case of wait in SIGCHLD handler */&lt;/span&gt;
                        killpg(job_tmp-&amp;gt;pid, SIGCONT);
                    }
                    
                    waitfg(job_tmp-&amp;gt;pid); &lt;span class=&quot;co&quot;&gt;/* wait until the foreground terminate/stop */&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                {
                    fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;%%%s: No such job&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
                }
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            {
                fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;%%%s: No such job&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            }
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/* PID */&lt;/span&gt;
        {
            pid_t pid = atoi(argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(pid)
            {
                &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; job_t *job_tmp = getjobpid(jobs, pid);
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (job_tmp != NULL)
                {
                    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; state = job_tmp-&amp;gt;state;
                    fg_pid = job_tmp-&amp;gt;pid; &lt;span class=&quot;co&quot;&gt;/* this is the new foreground process */&lt;/span&gt;
                    fg_pid_reap = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

                    job_tmp-&amp;gt;state = FG;

                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (state == ST)
                    {
                        stopped_resume_child = job_tmp-&amp;gt;pid; &lt;span class=&quot;co&quot;&gt;/* set the global var in case of wait in SIGCHLD handler */&lt;/span&gt;
                        killpg(pid, SIGCONT);
                    }
                    
                    waitfg(job_tmp-&amp;gt;pid); &lt;span class=&quot;co&quot;&gt;/* wait until the foreground terminate/stop */&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                {
                    fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;(%s): No such process&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]);
                }
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            {
                fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;fg: argument must be a PID or %%jobid&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
            }
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;void-waitfgpid_t-pid&quot;&gt;&lt;span&gt;4.void waitfg(pid_t pid)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;我之前声明了一个&lt;code&gt;volatile sig_atomic_t&lt;/code&gt;的全局变量&lt;code&gt;fg_pid_reap&lt;/code&gt; ，只要信号处理函数回收了前台进程，它就会将&lt;code&gt;fg_pid_reap&lt;/code&gt; 置1，这样我们的&lt;code&gt;waitfg&lt;/code&gt;函数就会退出，接着读取用户的下一个输入。使用busy&lt;code&gt;sleep&lt;/code&gt;会有一些延迟，实验报告上要求这么实现我也没办法; )&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * waitfg - Block until process pid is no longer the foreground process&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; waitfg(pid_t pid)
{
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (!fg_pid_reap)
    {
        sleep(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    }
    fg_pid_reap = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;void-sigchld_handlerint-sig&quot;&gt;&lt;span&gt;5.void sigchld_handler(int sig)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;注意保存&lt;code&gt;errno&lt;/code&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意到这里不能使用while来回收进程，因为我们的后台还可能有正在运行的进程，这样做的话会使得&lt;code&gt;waitpid&lt;/code&gt;一直等待这个进程结束。当然使用if只回收一次也可能会导致信号累加的问题，例如多个后台程序同时结束，实验报告上要求这么实现我也没办法 ; )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意如果程序是被stop的话&lt;code&gt;SIGTSTP ctrl-z&lt;/code&gt; ，我们不用回收、删除job列表中的节点。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     a child job terminates (becomes a zombie), or stops because it&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     received a SIGSTOP or SIGTSTP signal. The handler reaps all&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     available zombie children, but doesn't wait for any other&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     currently running children to terminate.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; sigchld_handler(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sig) &lt;span class=&quot;co&quot;&gt;/* When a child process stops or terminates, SIGCHLD is sent to the parent process. */&lt;/span&gt;
{
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; olderrno = errno;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (stopped_resume_child)
    {
        stopped_resume_child = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
    }
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; status;
    pid_t pid;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((pid = waitpid(-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &amp;amp;status, WUNTRACED)) &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;/* don't use while! */&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (pid == fg_pid)
        {
            fg_pid_reap = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        }

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (WIFEXITED(status)) &lt;span class=&quot;co&quot;&gt;/* returns true if the child terminated normally */&lt;/span&gt;
        {
        
        
            deletejob(jobs, pid);
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (WIFSIGNALED(status)) &lt;span class=&quot;co&quot;&gt;/* returns true if the child process was terminated by a signal. */&lt;/span&gt;
                                      &lt;span class=&quot;co&quot;&gt;/* since job start from zero, we add it one */&lt;/span&gt;
        {
        
        
            printf(&lt;span class=&quot;st&quot;&gt;&quot;Job [%d] (%d) terminated by signal %d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, pid2jid(pid), pid, WTERMSIG(status));
            deletejob(jobs, pid);
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/* SIGTSTP */&lt;/span&gt;
        {
            &lt;span class=&quot;co&quot;&gt;/* don't delete job */&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; job_t *p = getjobpid(jobs, pid);
            p-&amp;gt;state = ST; &lt;span class=&quot;co&quot;&gt;/* Stopped */&lt;/span&gt;
            printf(&lt;span class=&quot;st&quot;&gt;&quot;Job [%d] (%d) stopped by signal 20&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, pid2jid(pid), pid);
        }
    }

    errno = olderrno;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;void-sigtstp_handlerint-sig&quot;&gt;&lt;span&gt;6.void sigtstp_handler(int sig)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;注意是群发，即&lt;code&gt;killpg&lt;/code&gt;，不能只发一个。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * sigint_handler - The kernel sends a SIGINT to the shell whenver the&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *    user types ctrl-c at the keyboard.  Catch it and send it along&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *    to the foreground job.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; sigint_handler(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sig)
{
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; olderrno = errno;

    pid_t pgid = fgpid(jobs);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (pgid)
    {
        killpg(pgid, SIGINT);
    }

    errno = olderrno;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;void-sigint_handlerint-sig&quot;&gt;&lt;span&gt;7.void sigint_handler(int sig)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;不解释。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     the user types ctrl-z at the keyboard. Catch it and suspend the&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     foreground job by sending it a SIGTSTP.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; sigtstp_handler(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sig)
{
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; olderrno = errno;

    pid_t pgid = fgpid(jobs);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (pgid)
    {
        killpg(pgid, SIGTSTP);
    }
    
    errno = olderrno;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;运行结果&quot;&gt;&lt;span&gt;运行结果&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了方便检查结果，我写了一个bash脚本，用来比较我的&lt;code&gt;tsh&lt;/code&gt;和实验给的正确参考程序&lt;code&gt;tshref&lt;/code&gt;的输出结果（测试用例为trace01.txt~trace16.txt）：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;span&gt;&lt;code&gt;frank@under:~/tmp/shlab-handout$ cat test.sh 
#! /bin/bash

for file in $(ls trace*)
do
    ./sdriver.pl -t $file -s ./tshref &amp;gt; tshref_$file
    ./sdriver.pl -t $file -s ./tsh &amp;gt; tsh_$file
done 

for file in $(ls trace*)
do
    diff tsh_$file tshref_$file &amp;gt; diff_$file
done

for file in $(ls diff_trace*)
do
    echo $file &quot; :&quot;
    cat $file
    echo -e &quot;-------------------------------------\n&quot;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;全部打印出来太长，这里列出最后几个：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;span&gt;&lt;code&gt;frank@under:~/tmp/shlab-handout$ ./test.sh 

#.............................
#.............................
#.............................

diff_trace13.txt  :
5c5
&amp;lt; tsh&amp;gt; Job [1] (6173) stopped by signal 20
---
&amp;gt; tsh&amp;gt; Job [1] (6162) stopped by signal 20
7c7
&amp;lt; tsh&amp;gt; [1] (6173) Stopped ./mysplit 4 
---
&amp;gt; tsh&amp;gt; [1] (6162) Stopped ./mysplit 4 
20,24c20,24
&amp;lt;  6170 pts/5    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace13.txt -s ./tsh
&amp;lt;  6171 pts/5    S+     0:00 ./tsh
&amp;lt;  6173 pts/5    T      0:00 ./mysplit 4
&amp;lt;  6174 pts/5    T      0:00 ./mysplit 4
&amp;lt;  6177 pts/5    R      0:00 /bin/ps a
---
&amp;gt;  6159 pts/5    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace13.txt -s ./tshref
&amp;gt;  6160 pts/5    S+     0:00 ./tshref
&amp;gt;  6162 pts/5    T      0:00 ./mysplit 4
&amp;gt;  6163 pts/5    T      0:00 ./mysplit 4
&amp;gt;  6166 pts/5    R      0:00 /bin/ps a
41c41
&amp;lt;  1303 tty7     Ssl+  21:49 /usr/lib/xorg/Xorg -core :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch
---
&amp;gt;  1303 tty7     Ssl+  21:48 /usr/lib/xorg/Xorg -core :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch
51,53c51,53
&amp;lt;  6170 pts/5    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace13.txt -s ./tsh
&amp;lt;  6171 pts/5    S+     0:00 ./tsh
&amp;lt;  6182 pts/5    R      0:00 /bin/ps a
---
&amp;gt;  6159 pts/5    S+     0:00 /usr/bin/perl ./sdriver.pl -t trace13.txt -s ./tshref
&amp;gt;  6160 pts/5    S+     0:00 ./tshref
&amp;gt;  6169 pts/5    R      0:00 /bin/ps a
-------------------------------------

diff_trace14.txt  :
7c7
&amp;lt; tsh&amp;gt; [1] (6207) ./myspin 4 &amp;amp;
---
&amp;gt; tsh&amp;gt; [1] (6188) ./myspin 4 &amp;amp;
23c23
&amp;lt; tsh&amp;gt; Job [1] (6207) stopped by signal 20
---
&amp;gt; tsh&amp;gt; Job [1] (6188) stopped by signal 20
27c27
&amp;lt; tsh&amp;gt; [1] (6207) ./myspin 4 &amp;amp;
---
&amp;gt; tsh&amp;gt; [1] (6188) ./myspin 4 &amp;amp;
29c29
&amp;lt; tsh&amp;gt; [1] (6207) Running ./myspin 4 &amp;amp;
---
&amp;gt; tsh&amp;gt; [1] (6188) Running ./myspin 4 &amp;amp;
-------------------------------------

diff_trace15.txt  :
7c7
&amp;lt; tsh&amp;gt; Job [1] (6241) terminated by signal 2
---
&amp;gt; tsh&amp;gt; Job [1] (6224) terminated by signal 2
9c9
&amp;lt; tsh&amp;gt; [1] (6244) ./myspin 3 &amp;amp;
---
&amp;gt; tsh&amp;gt; [1] (6226) ./myspin 3 &amp;amp;
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;可以发现除了PID不同以外其余都相同，说明&lt;code&gt;tsh&lt;/code&gt;实现正确。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h3 id=&quot;感悟&quot;&gt;&lt;span&gt;感悟&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这次实验给我最大的教训就是不要完全相信文档，自己去实现和求证也很重要。另外，并行产生的竞争问题也有了一些了解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，有意思的是，我在做实验之前看到实验指导里说：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;– In waitfg, use a busy loop around the sleep function.&lt;br/&gt;– In sigchld handler, use exactly one call to waitpid.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;当时我还想说用&lt;code&gt;sleep&lt;/code&gt; 和在&lt;code&gt;waitpid&lt;/code&gt;里面只用一个回收是不是不安全或者太傻了，结果我上github一看不仅都是这样，而且他们的代码非常不安全（上面提到的六个安全注意点完全不遵守，各种调用也没有检查返回值和异常（例如只有if没有else）），于是觉得自己写的肯定比他们好多了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果。。。如果注意这些安全问题会有很多麻烦，时间也有限，我就把几个容易实现的实现了，还有两个“访问全局结构变量前block”和“在信号处理函数中仅使用&lt;code&gt;async-signal-safe&lt;/code&gt;没有实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，改编一下&lt;a href=&quot;http://www.mutt.org/&quot;&gt;Mutt E-Mail Client&lt;/a&gt;作者的一句话总结一下这次实验：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;All code about this ShellLab on github suck. This one just sucks less ;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 26 Dec 2017 15:44:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/8120617.html</dc:identifier>
</item>
<item>
<title>django的CMS系统（内容管理系统） - 左手十字</title>
<link>http://www.cnblogs.com/zuoshoushizi/p/8120576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuoshoushizi/p/8120576.html</guid>
<description>&lt;h2&gt;一、什么是CMS系统&lt;/h2&gt;
&lt;p&gt;CMS具有许多基于模板的优秀设计，可以减少开发的成本。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;8.2265625&quot;&gt;CMS的功能并不只限于文本处理，它也可以处理图片、&lt;a href=&quot;https://baike.baidu.com/item/Flash%E5%8A%A8%E7%94%BB&quot; target=&quot;_blank&quot;&gt;Flash动画&lt;/a&gt;、声像流、图像甚至电子邮件档案。&lt;/div&gt;
&lt;p&gt;CMS还分各个平台脚本种类的。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;6.4477611940299&quot;&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&quot; target=&quot;_blank&quot;&gt;内容管理系统&lt;/a&gt;是&lt;a href=&quot;https://baike.baidu.com/item/%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E5%8C%96%E5%BB%BA%E8%AE%BE&quot; target=&quot;_blank&quot;&gt;企业信息化建设&lt;/a&gt;和电子政务的新宠，也是一个相对较新的市场，对于内容管理，业界还没有一个统一的定义，不同的机构有不同的理解：&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;10.592375366569&quot;&gt;Gartner Group 认为内容管理从内涵上应该包括企业内部内容管理、Web内容管理、电子商务交易内容管理和企业外部网(Extranet)信息共享内容管理（如&lt;a href=&quot;https://baike.baidu.com/item/CRM&quot; target=&quot;_blank&quot;&gt;CRM&lt;/a&gt;和 SCM等），Web内容管理是当前的重点，&lt;a href=&quot;https://baike.baidu.com/item/e-business&quot; target=&quot;_blank&quot;&gt;e-business&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/XML&quot; target=&quot;_blank&quot;&gt;XML&lt;/a&gt;（&lt;a href=&quot;https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80&quot; target=&quot;_blank&quot;&gt;标准通用标记语言&lt;/a&gt;的子集）是推动内容管理发展的源动力。&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;12.5125&quot;&gt;Merrill Lynch的分析师认为内容管理侧重于企业员工、企业用户、合作伙伴和供应商方便获得&lt;a href=&quot;https://baike.baidu.com/item/%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E4%BF%A1%E6%81%AF&quot; target=&quot;_blank&quot;&gt;非结构化信息&lt;/a&gt;的处理过程。内容管理的目的是把非结构化信息出版到intranets， extranets和ITE(Internet Trading Exchanges)， 从而使用户可以检索、使用、分析和共享。商业智能系统 (BI)侧重于结构化数据的价值提取，而内容管理则侧重于企业内部和外部非结构化资源的战略价值提取。&lt;/div&gt;
&lt;p&gt;Giga Group 认为作为电子商务引擎，内容管理解决方案必须和电子商务服务器紧密集成，从而形成内容生产(Production)、传递(Delivery)以及电子商务端到端系统。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;9.7260273972603&quot;&gt;我们认为&lt;a href=&quot;https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&quot; target=&quot;_blank&quot;&gt;内容管理系统&lt;/a&gt;是一种位于WEB前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。内容管理解决方案重点解决各种非结构化或半结构化的数字资源的采集、管理、利用、传递和增值，并能有机集成到结构化数据的商业智能环境中，如OA，CRM等。内容的创作人员、编辑人员、发布人员使用内容管理系统来提交、修改、审批、发布内容。这里指的&quot;内容&quot;可能包括文件、表格、图片、数据库中的数据甚至视频等一切你想要发布到 Internet、Intranet以及Extranet网站的信息。&lt;/div&gt;
&lt;h2 class=&quot;para&quot;&gt; &lt;/h2&gt;
&lt;h2 class=&quot;para&quot;&gt;二、Django自带的CMS---faltpages&lt;/h2&gt;

&lt;p&gt;优点：   1、不需要自己动手写代码&lt;/p&gt;
&lt;p&gt;　　　　2、不需要维护代码&lt;/p&gt;
&lt;p&gt;　　　　3、url在admin中维护，不需要专门去编写URLconf&lt;/p&gt;
&lt;p&gt;缺点：　1、所有拥有flatpages应用的管理员都可以修改flatpages的任何界面，用户不能拥有单独的界面&lt;/p&gt;
&lt;p&gt;　　　　2、flatpages的功能有限，除了title和content，以及url外，几乎没有其他的功能。例如创建时间等。&lt;/p&gt;
&lt;p&gt;　　　　3、由于石油django的contrib提供的，没办法轻易对其进行属性和方法的修改&lt;/p&gt;

&lt;p&gt;激活flatpages&lt;/p&gt;
&lt;p&gt;　　步骤：&lt;/p&gt;
&lt;p&gt;　　1、创建一个django的project ，fuck这不是废话吗，不会的请自行百度。&lt;/p&gt;
&lt;p&gt;　　2、添加中间件&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;12&quot;&gt;　　　
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
MIDDLEWARE =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.flatpages.middleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,　　&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　'django.contrib.sites.middleware.CurrentSiteMiddleware',
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、注册app&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
INSTALLED_APPS =&lt;span&gt; [
    'django.contrib.admin'&lt;span&gt;,
     #
    'django.contrib.flatpages'&lt;span&gt;,&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　'django.contrib.sitemaps',&lt;br/&gt;　　'django.contrib.sites',
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、更新数据库&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　 　　python  manage.py　makemigrations&lt;/p&gt;
&lt;p&gt;　　　python  manage.py　migrate&lt;/p&gt;
&lt;p&gt;4、创建一个admin账户&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;14.5&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1224905/201712/1224905-20171226225614166-1436204311.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;5、在admin中编辑platpages&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1224905/201712/1224905-20171226225825963-1339548893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 6、创建HTML模板&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;{{ flatpage.title }}&amp;lt;/h1&amp;gt;
    &amp;lt;hr&amp;gt;    
    &amp;lt;p&amp;gt;{{ flatpage.content }}&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;访问你刚才添加的flatpage对象的url：http://127.0.0.1:8000/about/&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1224905/201712/1224905-20171226230802526-2004138203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; oh了，是不是很简单！！！&lt;/p&gt;
&lt;p&gt;今天很晚了，有时间的话，给大家整理一自定义cms吧&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Tue, 26 Dec 2017 15:27:00 +0000</pubDate>
<dc:creator>左手十字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuoshoushizi/p/8120576.html</dc:identifier>
</item>
<item>
<title>用keras做SQL注入攻击的判断 - McKay</title>
<link>http://www.cnblogs.com/aarond/p/sql_inject.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aarond/p/sql_inject.html</guid>
<description>&lt;p&gt;本文是通过深度学习框架keras来做SQL注入特征识别， 不过虽然用了keras，但是大部分还是普通的神经网络，只是外加了一些规则化、dropout层（随着深度学习出现的层）。&lt;/p&gt;
&lt;p&gt;基本思路就是喂入一堆数据（INT型）、通过神经网络计算（正向、反向）、SOFTMAX多分类概率计算得出各个类的概率，注意：这里只要2个类别：0-正常的文本；1-包含SQL注入的文本&lt;/p&gt;
&lt;p&gt;文件分割上，做成了4个python文件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;util类，用来将char转换成int（NN要的都是数字类型的，其他任何类型都要转换成int/float这些才能喂入，又称为feed） &lt;/li&gt;
&lt;li&gt;data类，用来获取训练数据，验证数据的类，由于这里的训练是有监督训练，因此此时需要返回的是个元组(x, y)&lt;/li&gt;
&lt;li&gt;trainer类，keras的网络模型建模在这里，包括损失函数、训练epoch次数等&lt;/li&gt;
&lt;li&gt;predict类，获取几个测试数据，看看效果的预测类&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先放trainer类代码，网络定义在这里，最重要的一个，和数据格式一样重要（呵呵，数据格式可是非常重要的，在这种程序中）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import SQL注入Data
import numpy as np
import keras
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation
from keras.layers.normalization import BatchNormalization
from keras.optimizers import SGD

x, y=SQL注入Data.loadSQLInjectData()
availableVectorSize=15
x=keras.preprocessing.sequence.pad_sequences(x, padding='post', maxlen=availableVectorSize)
y=keras.utils.to_categorical(y, num_classes=2)


model = Sequential()
model.add(Dense(64, activation='relu', input_dim=availableVectorSize))
model.add(BatchNormalization())
model.add(Dropout(0.3))
model.add(Dense(64, activation='relu'))
model.add(Dropout(0.3))
model.add(Dense(2, activation='softmax'))

sgd = SGD(lr=0.001, momentum=0.9)
model.compile(loss='mse',
              optimizer=sgd,
              metrics=['accuracy'])

history=model.fit(x, y,epochs=500,batch_size=16)

model.save('E:\\sql_checker\\models\\trained_models.h5')
print(&quot;DONE, model saved in path--&amp;gt;E:\\sql_checker\\models\\trained_models.h5&quot;)

import matplotlib.pyplot as plt
plt.plot(history.history['loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先来解释上面这段plt的代码，因为最容易解释，这段代码是用来把每次epoch的训练的损失loss value用折线图表示出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/68230/201712/68230-20171226230957166-468943907.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;何为训练？何为损失loss value？&lt;/p&gt;
&lt;p&gt;训练的目的是为了想让网络最终计算出来的分类数据和我们给出的y一致，那不一致怎么算？不一致就是有损失，也就是说训练的目的是要一致，也就是要损失最小化&lt;/p&gt;
&lt;p&gt;怎么让损失最小化？梯度下降，这里用的是SGD优化算法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from keras.optimizers import SGD

sgd = SGD(lr=0.001, momentum=0.9)
model.compile(loss='mse',
              optimizer=sgd,
              metrics=['accuracy'])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这段代码的loss='mse'就是定义了用那种损失函数，还有好几种损失函数，大家自己参考啊。&lt;/p&gt;
&lt;p&gt;optimizer=sgd就是优化算法用哪个了，不同的optimizer有不同的参数&lt;/p&gt;
&lt;p&gt;由于此处用的是全连接NN，因此是需要固定的输入size的，这个函数就是用来固定（不够会补0） 特征向量size的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
x=keras.preprocessing.sequence.pad_sequences(x, padding='post', maxlen=availableVectorSize)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看看最终的分类输出，是one hot的，这个one hot大家自己查查，很容易的定义，就是比较浪费空间，分类间没有关联性，不过用在这里很方便&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
y=keras.utils.to_categorical(y, num_classes=2)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后再说说预测部分代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import SQL注入Data
import Converter


import numpy as np
import keras
from keras.models import load_model

print(&quot;predict....&quot;)

x=SQL注入Data.loadTestSQLInjectData()
x=keras.preprocessing.sequence.pad_sequences(x, padding='post', maxlen=15)

model=load_model('E:\\sql_checker\\models\\trained_models.h5')
result=model.predict_classes(x, batch_size=len(x))
result=Converter.convert2label(result)
print(result)


print(&quot;DONE&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这部分代码很容易理解，并且连y都没有　　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/68230/201712/68230-20171226232145682-1240806914.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt; 好了，似乎有那么点意思了吧。&lt;/p&gt;
&lt;p&gt;下面把另外几个工具类、数据类代码放出来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def toints(sentence):
    base=ord('0')
    ary=[]
    for c in sentence:
        ary.append(ord(c)-base)
    return ary


def convert2label(vector):
    string_array=[]
    for v in vector:
        if v==1:
            string_array.append('SQL注入')
        else:
            string_array.append('正常文本')
    return string_array
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import Converter
import numpy as np

def loadSQLInjectData():
    x=[]
    x.append(Converter.toints(&quot;100&quot;))
    x.append(Converter.toints(&quot;150&quot;))
    x.append(Converter.toints(&quot;1&quot;))
    x.append(Converter.toints(&quot;3&quot;))
    x.append(Converter.toints(&quot;19&quot;))
    x.append(Converter.toints(&quot;37&quot;))
    x.append(Converter.toints(&quot;1'--&quot;))
    x.append(Converter.toints(&quot;1' or 1=1;--&quot;))
    x.append(Converter.toints(&quot;updatable&quot;))
    x.append(Converter.toints(&quot;update tbl&quot;))
    x.append(Converter.toints(&quot;update someb&quot;))
    x.append(Converter.toints(&quot;update&quot;))
    x.append(Converter.toints(&quot;updat&quot;))
    x.append(Converter.toints(&quot;update a&quot;))
    x.append(Converter.toints(&quot;'--&quot;))
    x.append(Converter.toints(&quot;' or 1=1;--&quot;))
    x.append(Converter.toints(&quot;aupdatable&quot;))
    x.append(Converter.toints(&quot;hello world&quot;))

    y=[[0],[0],[0],[0],[0],[0],[1],[1],[0],[1],[1],[0],[0],[1],[1],[1],[0],[0]]

    x=np.asarray(x)
    y=np.asarray(y)

    return x, y


def loadTestSQLInjectData():    
    x=[]
    x.append(Converter.toints(&quot;some value&quot;))
    x.append(Converter.toints(&quot;-1&quot;))
    x.append(Converter.toints(&quot;' or 1=1;--&quot;))
    x.append(Converter.toints(&quot;noupdate&quot;))
    x.append(Converter.toints(&quot;update &quot;))
    x.append(Converter.toints(&quot;update&quot;))
    x.append(Converter.toints(&quot;update z&quot;))
    x=np.asarray(x)
    return x
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，祝大家元旦快乐。&lt;/p&gt;

</description>
<pubDate>Tue, 26 Dec 2017 15:25:00 +0000</pubDate>
<dc:creator>McKay</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aarond/p/sql_inject.html</dc:identifier>
</item>
<item>
<title>项目实战12.2—企业级监控工具应用实战-zabbix操作进阶 - 阿龙along</title>
<link>http://www.cnblogs.com/along21/p/8119088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/along21/p/8119088.html</guid>
<description>&lt;p&gt;&lt;span&gt;无监控，不运维。好了，废话不多说，下面都是干货。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;流量党勿入，图片太多！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　项目实战系列，总架构图&lt;/strong&gt; &lt;a href=&quot;http://www.cnblogs.com/along21/p/8000812.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/along21/p/8000812.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、User parameters 用户参数&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、介绍和用法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;① 介绍&lt;/p&gt;
&lt;p&gt;自定义用户参数，也就是自定义key&lt;/p&gt;
&lt;p&gt;有时，你可能想要运行一个代理检查，而不是Zabbix的预定义&lt;/p&gt;
&lt;p&gt;你可以&lt;strong&gt;编写一个命令&lt;/strong&gt;来&lt;strong&gt;检索需要的数据&lt;/strong&gt;，并将其包含在代理配置文件(&quot;UserParameter&quot;配置参数)的&lt;strong&gt;用户参数&lt;/strong&gt;中&lt;/p&gt;
&lt;p&gt;② 用法格式 syntax&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;UserParameter&lt;/span&gt;=&lt;span&gt;&amp;lt;key&amp;gt;,&amp;lt;command&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　A user parameter also contains a key　　一个用户参数也包含一个键&lt;/p&gt;
&lt;p&gt;　　The key will be necessary when configuring an item 　　在配置监控项时，key是必需的&lt;/p&gt;
&lt;p&gt;　　Note: Need to restart the agent 　　注意:需要重新启动agent 服务&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、用法展示&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）修改agent 端的配置，设置用户参数&lt;/p&gt;
&lt;p&gt;① free | awk '/^Mem/{print $3}' 自己需要查找的参数的命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226171855010-665295523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 修改配置文件，把查找参数的命令设为用户参数&lt;/p&gt;
&lt;p&gt;cd /etc/zabbix/zabbix_agentd.d/&lt;/p&gt;
&lt;p&gt;vim &lt;strong&gt;memory_usage.conf&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UserParameter=memory.used,free | awk '/^Mem/{print $3}'&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;③ systemctl restart zabbix-agent.service 重启agent 服务&lt;/p&gt;

&lt;p&gt;（2）在zabbix-server 端，查询&lt;/p&gt;
&lt;p&gt;zabbix_get -s 192.168.30.7 -p 10050 -k &quot;memory.used&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172647557-2133137319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）在监控上，设置一个item监控项，使用这个用户参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172026041-1695073569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）查询graph 图形&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172026463-839175044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、用法升级&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）修改agent 端的配置，设置用户参数&lt;/p&gt;
&lt;p&gt;① 命令行查询参数的命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172026698-1464978164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 修改配置文件，把查找参数的命令设为用户参数&lt;/p&gt;
&lt;p&gt;UserParameter=&lt;span&gt;&lt;strong&gt;memory.stats[*]&lt;/strong&gt;&lt;/span&gt;,cat /proc/meminfo | awk &lt;span&gt;&lt;strong&gt;'/^$1/{print $$2}&lt;/strong&gt;&lt;/span&gt;'&lt;/p&gt;
&lt;p&gt;分析：$$2：表示不是前边调位置参数的$2 ，而是awk 的参数$2&lt;/p&gt;
&lt;p&gt;注意：$1是调用前边的[*]，位置参数，第一个参数&lt;/p&gt;

&lt;p&gt;（2）在zabbix-server 端，查询使用这个用户参数的key&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172026932-1905881550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）在监控上，设置一个item监控项，使用这个用户参数&lt;/p&gt;
&lt;p&gt;① 添加Memory Total 的item监控项，使用&lt;strong&gt;memory.stats[MemTotal]&lt;/strong&gt; 的用户参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172027260-1446706159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在进程中定义倍数，规定单位&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172027729-143163327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;② clone 克隆Memory Total 创建Memory Free 的监控项&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;memory.stats[MemFree]&lt;/strong&gt; 用户参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172028120-539441659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ 创建Memory Buffers 的item 监控项，使用 &lt;strong&gt;memory.stats[Buffers]&lt;/strong&gt; 的key&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172028448-41169528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（4）上面3个监控项的graph 图形&lt;/p&gt;
&lt;p&gt;① memory total&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172028745-1274821835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② memory free&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172029088-1142382464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ buffers&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172029338-158312847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;4、使用用户参数监控php-fpm 服务的状态&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在agent 端：&lt;/p&gt;
&lt;p&gt;（1）下载，设置php-fpm&lt;/p&gt;
&lt;p&gt;① yum -y install php-fpm&lt;/p&gt;
&lt;p&gt;② vim /etc/php-fpm.d/www.conf 打开php-fpm的状态页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
user =&lt;span&gt; nginx
group &lt;/span&gt;=&lt;span&gt; nginx
pm.status_path &lt;/span&gt;= /php-fpm-status    #php-&lt;span&gt;fpm 的状态监测页面
&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;.path = /&lt;span&gt;ping&lt;/span&gt;      #&lt;span&gt;ping&lt;/span&gt;&lt;span&gt; 接口，存活状态是否ok
&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;.response = pong    #响应内容pong
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ systemctl start php-fpm 开启服务&lt;/p&gt;

&lt;p&gt;（2）设置nginx ，设置代理php，和php-fpm的状态页面匹配&lt;/p&gt;
&lt;p&gt;① vim /etc/nginx/nginx.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
location ~&lt;span&gt; \.php$ {
            fastcgi_pass   &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi_params;
}
location &lt;/span&gt;~* /(php-fpm-status|&lt;span&gt;ping&lt;/span&gt;&lt;span&gt;) {
            fastcgi_pass   &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  $fastcgi_script_name;
            include        fastcgi_params;

            allow &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;;   #因为这个页面很重要，所有需加访问控制
            deny all;

            access_log off;   #访问这个页面就不用记录日志了
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172029791-156116121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② systemctl start nginx 开启nginx服务&lt;/p&gt;

&lt;p&gt;（3）在agent 端，设置用户参数&lt;/p&gt;
&lt;p&gt;① 查询 curl 192.168.30.7/php-fpm-status&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172030088-1020205629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 设置&lt;/p&gt;
&lt;p&gt;cd /etc/&lt;strong&gt;zabbix/zabbix_agentd.d/&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vim php_status.conf&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UserParameter=php-fpm.stats[*]&lt;/strong&gt;,&lt;span&gt;&lt;strong&gt;curl -s http://127.0.0.1/php-fpm-status | awk '/^$1/{print $$NF}'&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分析：设置用户参数为php-fpm.stats[*]，$1为第一个参数；$$NF为awk中的参数，倒数第一列&lt;/p&gt;

&lt;p&gt;③ 重启服务&lt;/p&gt;
&lt;p&gt;systemctl restart zabbix-agent&lt;/p&gt;

&lt;p&gt;（4）在zabbix-server 端，查询使用这个用户参数的key&lt;/p&gt;
&lt;p&gt;zabbix_get -s 192.168.30.7 -p 10050 -k &quot;php-fpm.stats[idle]&quot;&lt;/p&gt;
&lt;p&gt;zabbix_get -s 192.168.30.7 -p 10050 -k &quot;php-fpm.stats[active]&quot;&lt;/p&gt;
&lt;p&gt;zabbix_get -s 192.168.30.7 -p 10050 -k &quot;php-fpm.stats[max active]&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172030323-150229024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（5）创建一个模板，在模板上创建4个item监控项，使用定义的用户参数&lt;/p&gt;
&lt;p&gt;① 创建一个模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172030682-152674187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 在模板上配置items 监控项，使用刚定义的用户参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fpm.stats[total processes]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172031120-396201427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ 再clone克隆几个items监控项&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fpm.stats[active processes]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172031495-1001452204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;④ &lt;strong&gt;fpm.stats[max active processes]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172031807-398956119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑤ &lt;strong&gt;fpm.stats[idle processes]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172032120-165244744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（6）host主机链接模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172032495-2030001112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（7）查看graph 图形&lt;/p&gt;
&lt;p&gt;① php-fpm total processes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172032760-1387400769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② php-fpm active processes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172033276-1849464959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ php-fpm max active processes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172033573-911796042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;④ php-fpm idle processes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172034198-1450005062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（8）把模板导出，可以给别人使用&lt;/p&gt;
&lt;p&gt;① 导出模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172034682-1229092767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最下面有导出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172035088-116185645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 自己定义用户参数的文件，也不要忘记导出&lt;/p&gt;
&lt;p&gt;/etc/zabbix/zabbix_agentd.d/php_status.conf&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、Network discovery 网络发现&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;网络发现：zabbix server&lt;strong&gt;扫描指定网络范围内的主机&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;网络发现是zabbix 最具特色的功能之一，它能够根据用户&lt;strong&gt;事先定义的规则自动添加监控的主机或服务&lt;/strong&gt;等&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;　　加快Zabbix部署&lt;/p&gt;
&lt;p&gt;　　简化管理&lt;/p&gt;
&lt;p&gt;在快速变化的环境中使用Zabbix，而不需要过度管理&lt;/p&gt;

&lt;p&gt;（2）发现方式：&lt;/p&gt;
&lt;p&gt;ip地址范围；&lt;/p&gt;
&lt;p&gt;　　可用服务（ftp, ssh, http, ...）&lt;/p&gt;
&lt;p&gt;　　zabbix_agent的响应；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　snmp&lt;/strong&gt;_agent的响应；&lt;/p&gt;

&lt;p&gt;（3）网络发现通常包含两个阶段：discovery发现 和actions动作&lt;/p&gt;
&lt;p&gt;① discovery：&lt;/p&gt;
&lt;p&gt;Zabbix定期扫描网络发现规则中定义的IP范围；检查的频率对于每个规则都是可配置的&lt;/p&gt;
&lt;p&gt;每个规则都有一组用于为IP范围执行的服务检查&lt;/p&gt;
&lt;p&gt;由网络发现模块执行的服务和主机(IP)的每个检查都会生成一个发现事件&lt;/p&gt;
&lt;p&gt;8种响应事件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172035479-1598541190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② actions：网络发现中的事件可以触发action，从而自动执行指定的操作，把discvery events当作前提条件；&lt;/p&gt;
&lt;p&gt;　　Sending notifications 发送通知&lt;/p&gt;
&lt;p&gt;　　Adding/removing hosts 添加/删除主机&lt;/p&gt;
&lt;p&gt;　　Enabling/disabling hosts 启用/禁用host&lt;/p&gt;
&lt;p&gt;　　Adding hosts to a group 向组中添加主机&lt;/p&gt;
&lt;p&gt;　　Removing hosts from a group 移除组中的主机&lt;/p&gt;
&lt;p&gt;　　Linking hosts to/unlinking from a template 从模板链接主机或取消链接&lt;/p&gt;
&lt;p&gt;　　Executing remote scripts 执行远程脚本&lt;/p&gt;
&lt;p&gt;这些事件的配置还可以基于设备的类型、IP 、状态、上线/ 离线等进行配置&lt;/p&gt;

&lt;p&gt;（4）网络发现：接口添加&lt;/p&gt;
&lt;p&gt;网络发现中添加主机时会自动创建interface 接口&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;　　如果基于SNMP 检测成功，则会创建SNMP 接口&lt;/p&gt;
&lt;p&gt;　　如果某服务同时响应给了agent 和SNMP ，则&lt;strong&gt;两种接口都会创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果同一种发现机制( 如agent) 返回了非惟一数据，则&lt;strong&gt;第一个接口被识别为默认，其它的为额外接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　即便是某主机开始时只有agent 接口，后来又通过snmp 发现了它，同样会为其添加额外的snmp 接口&lt;/p&gt;
&lt;p&gt;　　不同的主机如果返回了相同的数据，则第一个主机将被添加，余下的主机会被当作第一个主机的额外接口&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、配置网络发现Network discovery&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）准备一台可被扫描发现的主机&lt;/p&gt;
&lt;p&gt;① 安装agent 段的包&lt;/p&gt;
&lt;p&gt;yum -y install zabbix-agent zabbix-sender&lt;/p&gt;
&lt;p&gt;② 设置agent 配置，可以把之前设置好的node1的配置传过来&lt;/p&gt;
&lt;p&gt;vim /etc/zabbix/zabbix_agentd.conf&lt;/p&gt;
&lt;p&gt;Hostname=node2.along.com #只需修改hostname&lt;/p&gt;
&lt;p&gt;③ visudo 修改sudo的配置&lt;/p&gt;
&lt;p&gt;#Defaults !visiblepw&lt;/p&gt;
&lt;p&gt;zabbix ALL=(ALL) NOPASSWD: ALL&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172036745-511117378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;④ 开启服务&lt;/p&gt;
&lt;p&gt;systemctl start zabbix-agent&lt;/p&gt;

&lt;p&gt;（2）设置自动发现规则discovery&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172037370-800415726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注释：&lt;/p&gt;
&lt;p&gt;① key：zabbix_get -s 192.168.30.2 -p 10050 -k &quot;system.hostname&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172037635-349059993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 更新间隔：1h就好，不要扫描太过频繁，扫描整个网段，太废资源；这里为了实验，设为1m&lt;/p&gt;

&lt;p&gt;（3）自动发现成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172037948-2146168679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（4）设置自动发现discovery 的动作action&lt;/p&gt;
&lt;p&gt;a) 创建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172038182-11402625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b) 设置action动作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172038541-1323988067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;① 设置A条件，自动发现规则=test.net&lt;/p&gt;
&lt;p&gt;② 设置B条件，自动发现状态=up&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172038823-1466028368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ 要做什么操作&lt;/p&gt;
&lt;p&gt;添加主机到监控&lt;/p&gt;
&lt;p&gt;自动链接Template OS Linux 到此host&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172039213-1479221797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;c) 配置action 完成，默认是disabled 停用的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172039526-1399823520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;d) 启用动作，查看效果&lt;/p&gt;
&lt;p&gt;确实已经生效，添加主机成功，模板链接成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172039979-1033265636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（5）如果自己需要添加的主机已经扫描添加完成，就可以关闭网络扫描了，因为太耗资源&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、web监控&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;① Web监控：监控指定的站点的&lt;strong&gt;资源下载速度&lt;/strong&gt;，及&lt;strong&gt;页面响应时间&lt;/strong&gt;，还有&lt;strong&gt;响应代码&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;② 术语：&lt;/p&gt;
&lt;p&gt;　　web Scenario： web场景（站点）&lt;/p&gt;
&lt;p&gt;　　web page ：web页面，一个场景有多个页面&lt;/p&gt;
&lt;p&gt;　　內建key：要测一个页面，要测三个步骤（下边3个內建key）&lt;/p&gt;
&lt;p&gt;③ 内建key：&lt;/p&gt;
&lt;p&gt;　　 web.test.in[Scenario,Step,bps]：传输速率&lt;/p&gt;
&lt;p&gt;　　 web.test.time[Scenario,Step]： 响应时长&lt;/p&gt;
&lt;p&gt;　　 web.test.rspcode[Scenario,Step]：响应码&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、创建设置web场景&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）创建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172040229-465393880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）配置web 监测&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172040588-1557305887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;① 点击步骤，设置web page web页面&lt;/p&gt;
&lt;p&gt;a) 设置名为home page，URL为&lt;span&gt;http://192.168.30.7/index.html 的web页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172040885-1526168288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b) 设置名为fpm status，URL为&lt;span&gt;http://192.168.30.7/fpm-status 的web页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172041291-925383434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;c) 设置2个web页面成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172041870-962857372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 如果有特殊认证，也可以添加&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172042166-1660206125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、查看测试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172042510-1962638311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;四、主动/被动 监控&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）主动/被动介绍&lt;/p&gt;
&lt;p&gt;　　被动检测：相对于agent而言；agent, &lt;strong&gt;server向agent请求获取配置的各监控项相关的数据&lt;/strong&gt;，agent接收请求、获取数据并响应给server；&lt;/p&gt;
&lt;p&gt;　　主动检测：相对于agent而言；agent(active),&lt;strong&gt;agent向server请求与自己相关监控项配置&lt;/strong&gt;，主动地将server配置的监控项相关的数据发送给server；&lt;/p&gt;
&lt;p&gt;　　主动监控能极大节约监控server 的资源。&lt;/p&gt;
&lt;p&gt;（2）zabbix_sender发送数据：实现人工生成数据，发给server端&lt;/p&gt;
&lt;p&gt;① zabbix server上的某主机上，直接定义Item时随便定义一个不与其它已有key冲突的key即可，即item type为&quot;zabbix trapper&quot;；&lt;/p&gt;
&lt;p&gt;② 用法选项：&lt;/p&gt;
&lt;p&gt;zabbix_sender&lt;/p&gt;
&lt;p&gt;　　-z zabbix_server_ip&lt;/p&gt;
&lt;p&gt;　　-p zabbix_server_port&lt;/p&gt;
&lt;p&gt;　　-s zabbix_agent_hostname&lt;/p&gt;
&lt;p&gt;　　-k key&lt;/p&gt;
&lt;p&gt;　　-o value 值&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、设置一个通过內建key发送数据的主动监控&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）agent端所需要基本配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ServerActive=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;&lt;span&gt;   给哪个监控server 发送数据
Hostname&lt;/span&gt;=&lt;span&gt;node1.along.com   自己的主机名，假设主机定死了，不设置下一项
#HostnameItem&lt;/span&gt;=   如果自己的主机名易变动，这一项相当于key一样去匹配
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：若后两项同时启用，下边一个选择生效&lt;/p&gt;

&lt;p&gt;（2）设置一个主动监测&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172042870-1427172290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;① 选择进程，每秒更改，&lt;/p&gt;
&lt;p&gt;因为key：system.cpu.switches ：上下文的数量进行切换，它返回一个整数值。为了监控效果，选择下一秒减上一秒的值作为监控&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172043120-1810882608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）已经有啦graph图形&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172043526-25418384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、设置一个通过命令zabbix_sender发送数据的主动监控&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）配置一个zabbix traper(采集器) 的item 监控项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172043838-1551635865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）agent 端手动发送数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172044120-1117751325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）监控到数据的变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172044682-2050320416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;五、基于SNMP监控（了解）&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;SNMP：&lt;strong&gt;简单&lt;/strong&gt;网络管理协议；（非常古老的协议）&lt;/p&gt;
&lt;p&gt;三种通信方式：读（get, getnext）、写（set）、trap（陷阱）；&lt;/p&gt;
&lt;p&gt;端口：&lt;/p&gt;
&lt;p&gt;　　161/udp&lt;/p&gt;
&lt;p&gt;　　162/udp&lt;/p&gt;
&lt;p&gt;SNMP协议：年代久远&lt;/p&gt;
&lt;p&gt;　　v1: 1989&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　v2c&lt;/strong&gt;: 1993&lt;/p&gt;
&lt;p&gt;　　v3: 1998&lt;/p&gt;
&lt;p&gt;监控网络设备：交换机、路由器&lt;/p&gt;
&lt;p&gt;MIB：Management Information Base 信息管理基础&lt;/p&gt;
&lt;p&gt;OID：Object ID 对象ID&lt;/p&gt;

&lt;p&gt;（2）Linux启用snmp的方法：&lt;/p&gt;
&lt;p&gt;yum install net-snmp net-snmp-utils&lt;/p&gt;
&lt;p&gt;配置文件：定义ACL&lt;/p&gt;
&lt;p&gt;　　/etc/snmp/snmpd.conf&lt;/p&gt;
&lt;p&gt;启动服务：&lt;/p&gt;
&lt;p&gt;　　systemctl start snmpd 被监控端开启的服务&lt;/p&gt;
&lt;p&gt;　　 systemctl start snmptrapd    监控端开启的服务（如果允许被监控端启动主动监控时启用）&lt;/p&gt;

&lt;p&gt;（3）配置文件的介绍&lt;/p&gt;
&lt;p&gt;开放数据：4步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172045276-679726746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;① 定义认证符，将社区名称&quot;public&quot;映射为&quot;安全名称&quot;&lt;/p&gt;
&lt;p&gt;② 将安全名称映射到一个组名&lt;/p&gt;
&lt;p&gt;③ 为我们创建一个视图，让我们的团队有权利&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;掩码：&lt;/strong&gt;我列出一些注释，有很多，可以再网上查询&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;.1.3.6.1.2.&lt;/span&gt;1.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 1.1.0：系统描述信息，SysDesc&lt;/p&gt;
&lt;p&gt;　　 1.3.0：监控时间， SysUptime&lt;/p&gt;
&lt;p&gt;　　 1.5.0：主机名，SysName&lt;/p&gt;
&lt;p&gt;　　 1.7.0：主机提供的服务，SysService&lt;/p&gt;
&lt;p&gt;.1.3.6.1.2.2.&lt;/p&gt;
&lt;p&gt;　　 2.1.0：网络接口数目&lt;/p&gt;
&lt;p&gt;　　 2.2.1.2:网络接口的描述信息&lt;/p&gt;
&lt;p&gt;　　 2.2.1.3:网络接口类型&lt;/p&gt;
&lt;p&gt;　　 ……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172045604-1497693285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;④ 授予对systemview视图的只读访问权&lt;/p&gt;

&lt;p&gt;（4）测试工具：&lt;/p&gt;
&lt;p&gt;    # &lt;strong&gt;snmpget&lt;/strong&gt; -v 2c -c public HOST OID&lt;/p&gt;
&lt;p&gt;    # &lt;strong&gt;snmpwalk&lt;/strong&gt; -v 2c -c public HOST OID 通过这个端口查询到的数据，全列出了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172045948-698976544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、配置SNMP监控&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）下载，修改配置文件&lt;/p&gt;
&lt;p&gt;vim /etc&lt;strong&gt;/snmp/snmpd.conf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
view    systemview    included   .&lt;span&gt;1.3&lt;/span&gt;.&lt;span&gt;6.1&lt;/span&gt;.&lt;span&gt;2.1&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
view    systemview    included   .&lt;/span&gt;&lt;span&gt;1.3&lt;/span&gt;.&lt;span&gt;6.1&lt;/span&gt;.&lt;span&gt;2.1&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;   # 网络接口的相关数据
view    systemview    included   .&lt;/span&gt;&lt;span&gt;1.3&lt;/span&gt;.&lt;span&gt;6.1&lt;/span&gt;.&lt;span&gt;4.1&lt;/span&gt;.&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;   # 系统资源负载，memory, disk io, cpu load 
view    systemview    included   .&lt;/span&gt;&lt;span&gt;1.3&lt;/span&gt;.&lt;span&gt;6.1&lt;/span&gt;.&lt;span&gt;2.1&lt;/span&gt;.&lt;span&gt;25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）在agent 上测试&lt;/p&gt;
&lt;p&gt;snmpget -v 2c -c public 192.168.30.2 .1.3.6.1.2.1.1.3.0&lt;/p&gt;
&lt;p&gt;snmpget -v 2c -c public 192.168.30.2 .1.3.6.1.2.1.1.5.0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172046245-1946753487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）在监控页面，给node2加一个snmp的接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172046541-990434657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）在node2上加一个 &lt;span&gt;Template OS Linux SNMPv2 模板&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172046854-1430722762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板添加成功，生成一系列东西&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172047151-639977143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点开一个item 看一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172047463-1455547608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（5）生成一些最新数据的图形graph了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172047729-481410869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、设置入站出站packets 的SNMP监控&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）监控网络设备：交换机、路由器的步骤：&lt;/p&gt;
&lt;p&gt;① 把交换机、路由器的SNMP 把对应的OID的分支启用起来&lt;/p&gt;
&lt;p&gt;② 了解这些分支下有哪些OID，他们分别表示什么意义&lt;/p&gt;
&lt;p&gt;③ 我们要监控的某一数据：如交换机的某一个接口流量、报文，发送、传入传出的报文数有多少个；传入传出的字节数有多少个，把OID取出来，保存&lt;/p&gt;

&lt;p&gt;（2）定义入站出站的item监控项&lt;/p&gt;
&lt;p&gt;interface traffic packets(in)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172048182-394941521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;interface traffic packets(out)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172048510-973935048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;六、JMX接口&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172048698-2048639928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;Java虚拟机(JVM)具有内置的插装，使您能够使用JMX监视和管理它。您还可以使用JMX监视工具化的应用程序。&lt;/p&gt;
&lt;p&gt;（2）配置设置介绍&lt;/p&gt;
&lt;p&gt;① zabbix-java-gateway主机设置：&lt;/p&gt;
&lt;p&gt;　　安装 zabbix-java-gateway程序包，启动服务；&lt;/p&gt;
&lt;p&gt;　　yum -y install zabbix-java-gateway&lt;/p&gt;
&lt;p&gt;② zabbix-server端设置（需要重启服务）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　JavaGateway=&lt;/strong&gt;172.16.0.70&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　JavaGatewayPort=&lt;/strong&gt;10052&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　StartJavaPollers=&lt;/strong&gt;5 #监控项&lt;/p&gt;
&lt;p&gt;③ tomcat主机设置：&lt;/p&gt;
&lt;p&gt;　　 监控tomcat：&lt;/p&gt;
&lt;p&gt;　　　　 /etc/sysconfig/tomcat，添加&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　CATALINA_OPTS&lt;/strong&gt;=&quot;-Djava.rmi.server.hostname=TOMCAT_SERVER_IP -Djavax.management.builder.initial= -Dcom.sun.management.jmxremote=true -Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&quot;   #启用JVM接口，默认没有启用&lt;/p&gt;

&lt;p&gt;　　添加监控项：&lt;/p&gt;
&lt;p&gt;　　　　jmx[object_name,attribute_name]&lt;/p&gt;
&lt;p&gt;　　　　　　object name - 它代表MBean的对象名称&lt;/p&gt;
&lt;p&gt;　　　　　　attribute name - 一个MBean属性名称，可选的复合数据字段名称以点分隔&lt;/p&gt;
&lt;p&gt;　　　　示例：&lt;/p&gt;
&lt;p&gt;　　　　　　 jmx[&quot;java.lang:type=Memory&quot;,&quot;HeapMemoryUsage.used&quot;]&lt;/p&gt;

&lt;p&gt;④ jmx的详细文档：https://docs.oracle.com/javase/1.5.0/docs/guide/management/agent.html&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、配置JVM接口监控&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）安装配置tomcat&lt;/p&gt;
&lt;p&gt;① 下载安装tomcat，主要是用JVM&lt;/p&gt;
&lt;p&gt;yum -y install &lt;strong&gt;java-1.8.0-openjdk-devel tomcat-admin-webapps tomcat-docs-webapp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;② 加CATALINA_OPTS= #启用JVM接口，默认没有启用&lt;/p&gt;
&lt;p&gt;vim /etc/sysconfig/tomcat&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
CATALINA_OPTS=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Djava.rmi.server.hostname=192.168.30.2 -Djavax.management.builder.initial= -Dcom.sun.management.jmxremote=true   -Dcom.sun.management.jmxremote.port=12345  -Dcom.sun.management.jmxremote.ssl=false  -Dcom.sun.management.jmxremote.authenticate=false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 开启服务&lt;/p&gt;
&lt;p&gt;systemctl start tomcat&lt;/p&gt;

&lt;p&gt;（2）在&lt;strong&gt;zabbix-server 端&lt;/strong&gt;，安装配置java-gateway&lt;/p&gt;
&lt;p&gt;① 安装配置java-gateway&lt;/p&gt;
&lt;p&gt;yum -y install zabbix-java-gateway&lt;/p&gt;
&lt;p&gt;/etc/zabbix/zabbix_java_gateway.conf 安装完后，会生成一个java_gateway 的配置文件&lt;/p&gt;
&lt;p&gt;systemctl start zabbix-java-gateway.service 不用修改，直接开启服务&lt;/p&gt;

&lt;p&gt;② 修改server 配置，开启java-gateway的配置&lt;/p&gt;
&lt;p&gt;vim /etc/zabbix/&lt;strong&gt;zabbix_server.conf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
JavaGateway=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;&lt;span&gt;  
JavaGatewayPort&lt;/span&gt;=&lt;span&gt;10052&lt;/span&gt;&lt;span&gt;
StartJavaPollers&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;    #打开5个监控项
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ systemctl restart zabbix-server 重启zabbix-server 服务&lt;/p&gt;

&lt;p&gt;（3）在node2 主机上添加JMX接口，实验模板&lt;/p&gt;
&lt;p&gt;① 添加JMX接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172049182-664693382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 在node2 上连接tomcat JMX 模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172049541-701630088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ 随便查看一个监控项item&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172050010-1062166097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（4）自己定义一个堆内存使用的监控项，基于JVM接口（没必要，使用模板就好）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172050479-619246539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;七、分布式监控&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172050995-2135249770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;分布式监控概述&lt;/p&gt;
&lt;p&gt;　　proxy and node&lt;/p&gt;
&lt;p&gt;Zabbix 的三种架构&lt;/p&gt;
&lt;p&gt;　　Server-agent&lt;/p&gt;
&lt;p&gt;　　Server-Node-agent&lt;/p&gt;
&lt;p&gt;　　Server-Proxy-agent&lt;/p&gt;
&lt;p&gt;监控Zabbix&lt;/p&gt;

&lt;p&gt;（2）配置介绍&lt;/p&gt;
&lt;p&gt;Zabbix Proxy的配置：&lt;/p&gt;
&lt;p&gt;　　server-node-agent&lt;/p&gt;
&lt;p&gt;　　server-proxy-agent&lt;/p&gt;
&lt;p&gt;a) 配置proxy主机：&lt;/p&gt;
&lt;p&gt;(1) 安装程序包&lt;/p&gt;
&lt;p&gt;    zabbix-proxy-mysql zabbix-get&lt;/p&gt;
&lt;p&gt;    zabbix-agent zabbix-sender&lt;/p&gt;
&lt;p&gt;(2) 准备数据库&lt;/p&gt;
&lt;p&gt;　　创建、授权用户、导入schema.sql；&lt;/p&gt;
&lt;p&gt;(3) 修改配置文件&lt;/p&gt;
&lt;p&gt;　　Server=&lt;/p&gt;
&lt;p&gt;　　　　zabbix server主机地址；&lt;/p&gt;
&lt;p&gt;　　Hostname=&lt;/p&gt;
&lt;p&gt;　　　　当前代理服务器的名称；在server添加proxy时，必须使用此处指定的名称；&lt;/p&gt;
&lt;p&gt;　　　　=需要事先确保server能解析此名称；&lt;/p&gt;
&lt;p&gt;　　DBHost=&lt;/p&gt;
&lt;p&gt;　　DBName=&lt;/p&gt;
&lt;p&gt;　　DBUser=&lt;/p&gt;
&lt;p&gt;　　DBPassword=&lt;/p&gt;

&lt;p&gt;　　ConfigFrequency=10&lt;/p&gt;
&lt;p&gt;　　DataSenderFrequency=1&lt;/p&gt;

&lt;p&gt;b) 在server端添加此Porxy&lt;/p&gt;
&lt;p&gt;    Administration --&amp;gt; Proxies&lt;/p&gt;

&lt;p&gt;c) 在Server端配置通过此Proxy监控的主机；&lt;/p&gt;
&lt;p&gt;注意：zabbix agent端要允许zabbix proxy主机执行数据采集操作：&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、实现分布式zabbix proxy监控&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;实验前准备：&lt;/p&gt;
&lt;p&gt;① ntpdate 172.168.30.1 同步时间&lt;/p&gt;
&lt;p&gt;② 关闭防火墙，selinux&lt;/p&gt;
&lt;p&gt;③ 设置主机名 hostnamectl set-hostname zbproxy.along.com&lt;/p&gt;
&lt;p&gt;④ vim /etc/hosts 每个机器都设置hosts，以解析主机名；DNS也行&lt;/p&gt;
&lt;p&gt;192.168.30.107 server.along.com&lt;/p&gt;
&lt;p&gt;192.168.30.7 node1.along.com&lt;/p&gt;
&lt;p&gt;192.168.30.2 node2.along.com&lt;/p&gt;
&lt;p&gt;192.168.30.3 node3.along.com zbproxy.along.com&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172051276-274670232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）环境配置（4台主机）&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;113&quot;&gt;
&lt;p&gt;机器名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;120&quot;&gt;
&lt;p&gt;IP配置&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p&gt;服务角色&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;113&quot;&gt;
&lt;p&gt;zabbix-server&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;120&quot;&gt;
&lt;p&gt;192.168.30.107&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p&gt;监控&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;113&quot;&gt;
&lt;p&gt;agent-node1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;120&quot;&gt;
&lt;p&gt;192.168.30.7&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p&gt;被监控端&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;113&quot;&gt;
&lt;p&gt;agent-node2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;120&quot;&gt;
&lt;p&gt;192.168.30.2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p&gt;被监控端&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;113&quot;&gt;
&lt;p&gt;node3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;120&quot;&gt;
&lt;p&gt;192.168.30.3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p&gt;代理proxy&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;zabbix-server 直接监控一台主机node1&lt;/p&gt;
&lt;p&gt;zabbix-server 通过代理node3 监控node2&lt;/p&gt;

&lt;p&gt;（2）在node3 上配置mysql&lt;/p&gt;
&lt;p&gt;① 创建配置mysql&lt;/p&gt;
&lt;p&gt;vim /etc/my.cnf.d/server.cnf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[server]
skip_name_resolve &lt;/span&gt;=&lt;span&gt; on
innodb_file_per_table &lt;/span&gt;=&lt;span&gt; on
innodb_buffer_pool_size &lt;/span&gt;=&lt;span&gt; 256M
max_connections &lt;/span&gt;= &lt;span&gt;2000&lt;/span&gt;&lt;span&gt;
log&lt;/span&gt;-bin = master-log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② systemctl start mariadb 开启服务&lt;/p&gt;
&lt;p&gt;③ 创建数据库 和 授权用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
MariaDB [(none)]&amp;gt; create database zbxproxydb character set &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
MariaDB [(none)]&lt;/span&gt;&amp;gt; grant all on zbxproxydb.* to &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zbxproxyuser&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.30.%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; identified by &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zbxproxypass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
MariaDB [(none)]&lt;/span&gt;&amp;gt; flush privileges;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）在node3 上下载zabbix 相关的包，主要是代理proxy的包&lt;/p&gt;
&lt;p&gt;yum -y install &lt;strong&gt;zabbix-proxy-mysql&lt;/strong&gt; zabbix-get zabbix-agent zabbix-sender&lt;/p&gt;

&lt;p&gt;a) &lt;strong&gt;初始化数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;zabbix-proxy-mysql 包里带有，导入数据的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172052791-1016956277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;cp /usr/share/doc/zabbix-proxy-mysql-3.4.4/schema.sql.gz ./ 复制&lt;/p&gt;
&lt;p&gt;gzip -d schema.sql.gz 解包&lt;/p&gt;
&lt;p&gt;mysql -root -p zbxproxydb &amp;lt; schema.sql 导入数据&lt;/p&gt;

&lt;p&gt;b) 查看数据已经生成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172053276-1712858671.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（4）配置proxy端&lt;/p&gt;
&lt;p&gt;① vim /etc/zabbix/zabbix_proxy.conf&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172053682-47495044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Server=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;&lt;span&gt;   #server 的IP
ServerPort&lt;/span&gt;=&lt;span&gt;10051&lt;/span&gt;&lt;span&gt;   #server 的端口

Hostname&lt;/span&gt;=&lt;span&gt;zbxproxy.along.com   #主机名
ListenPort&lt;/span&gt;=&lt;span&gt;10051&lt;/span&gt;&lt;span&gt;    #proxy自己的监听端口
EnableRemoteCommands&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;    #允许远程命令
LogRemoteCommands&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;    #记录远程命令的日志

数据的配置
DBHost&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.3&lt;/span&gt;&lt;span&gt;
DBName&lt;/span&gt;=&lt;span&gt;zbxproxydb  
DBUser&lt;/span&gt;=&lt;span&gt;zbxproxyuser
DBPassword&lt;/span&gt;=&lt;span&gt;zbxproxypass

ConfigFrequency&lt;/span&gt;=&lt;span&gt;30&lt;/span&gt;&lt;span&gt;    #多长时间，去服务端拖一次有自己监控的操作配置；为了实验更快的生效，这里设置30秒，默认3600s
DataSenderFrequency&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;   #每一秒向server 端发一次数据，发送频度
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② systemctl start zabbix-proxy 开启服务&lt;/p&gt;

&lt;p&gt;（5）配置node2端，允许proxy代理监控&lt;/p&gt;
&lt;p&gt;vim /etc/zabbix/zabbix_agentd.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Server=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;,&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.3&lt;/span&gt;&lt;span&gt;
ServerActive&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;,&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;systemctl restart zabbix-agent 启动服务&lt;/p&gt;

&lt;p&gt;（6）把代理加入监控server，创建配置agent 代理&lt;/p&gt;
&lt;p&gt;① 创建agent 代理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172053932-978486530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172054213-335809349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（7）创建node2 主机，并采用代理监控&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172054682-1009619727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置代理成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172055307-1060200173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（8）创建item监控项&lt;/p&gt;
&lt;p&gt;① 为了实验，随便创一个监控项 CPU Switches&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172055698-1128474710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 进程里设置每秒更改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172055932-1067681793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ 成功，graph 图形生成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172056416-1575771036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;八、查询使用网上模板监控&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、找官方的share 分享网站&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.bing.com/&quot;&gt;&lt;span&gt;https://cn.bing.com/&lt;/span&gt;&lt;/a&gt; 搜索 zabbix share&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172057120-1262251161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如：我们要实现监控Nginx ，我们查找一个模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172057635-1089716709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就以这个模板为例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172058182-128310444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、在node1 上使用此模板&lt;/h3&gt;
&lt;p&gt;（1）安装配置 nginx&lt;/p&gt;
&lt;p&gt;① yum -y install nginx&lt;/p&gt;
&lt;p&gt;vim /etc/nginx/nginx.conf 按照网页的操作指示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
location /&lt;span&gt;stub_status {
        stub_status on;
        access_log off;
    #    allow &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;;   #为了操作方便，我取消的访问控制
    #    deny all;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172058510-1149178016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 启动服务&lt;/p&gt;
&lt;p&gt;systemctl restart nginx&lt;/p&gt;

&lt;p&gt;（2）下载模板所依赖的脚本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172058823-57198051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;mkdir -p /srv/zabbix/libexec/&lt;/p&gt;
&lt;p&gt;cd /srv/zabbix/libexec/&lt;/p&gt;
&lt;p&gt;wget https://raw.githubusercontent.com/oscm/zabbix/master/nginx/nginx.sh 从网页上获取脚本&lt;/p&gt;
&lt;p&gt;chmod +x nginx.sh 加执行权限&lt;/p&gt;

&lt;p&gt;（3）配置agent 的用户参数UserParameter&lt;/p&gt;
&lt;p&gt;cd /etc/zabbix/zabbix_agentd.d/&lt;/p&gt;
&lt;p&gt;wget &lt;span&gt;https://raw.githubusercontent.com/oscm/zabbix/master/nginx/userparameter_nginx.conf 很短，自己写也行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172059073-397108138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）在windows 上下载模板，并导入这server 的模板中&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wget https://raw.githubusercontent.com/oscm/zabbix/master/nginx/zbx_export_templates.xml 可以现在linux上下载，再sz 导出到windows上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172059291-1133694346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;① 导入下载的模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172059635-1317185355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 主机node1 链接这个模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172100041-1015144646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ 模板生效&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172100323-635966866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;九、zabbix-server 监控自己，数据库，nginx&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1、下载安装，配置agent&lt;/h3&gt;
&lt;p&gt;vim /etc/zabbix/zabbix_agentd.conf 配置agent&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
EnableRemoteCommands=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;    允许远程命令
LogRemoteCommands&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;    记录远程命令
Server&lt;/span&gt;=&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
ServerActive&lt;/span&gt;=&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
Hostname&lt;/span&gt;=server.along.com
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、自动生成Zabbix server 的主机&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172101526-749330259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、在主机中添加模板&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172101885-2112581492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4、启用Zabbix server&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172102370-823261452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5、监控到数据&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201712/1216496-20171226172102698-926445046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;十、调优&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、调优&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;① Database：&lt;/p&gt;
&lt;p&gt;　　历史数据不要保存太长时长；&lt;/p&gt;
&lt;p&gt;　　尽量让数据缓存在数据库服务器的内存中；&lt;/p&gt;
&lt;p&gt;② 触发器表达式：&lt;strong&gt;减少使用聚合函数&lt;/strong&gt; min(), max(), avg()；尽量使用last()，nodata()；&lt;/p&gt;
&lt;p&gt;　　因为聚合函数，要运算&lt;/p&gt;
&lt;p&gt;③ 数据收集：polling较慢(减少使用SNMP/agentless/agent）；&lt;strong&gt;尽量使用trapping（agent(active）主动监控）；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;④ 数据类型：文本型数据处理速度较慢；&lt;strong&gt;尽量少&lt;/strong&gt;收集类型为&lt;strong&gt;文本&lt;/strong&gt; text或string类型的数据；&lt;strong&gt;多使用&lt;/strong&gt;类型为numeric &lt;strong&gt;数值型数据&lt;/strong&gt; 的；&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、zabbix服务器的进程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;(1) 服务器组件的数量；&lt;/p&gt;
&lt;p&gt;　　alerter, discoverer, escalator, http poller, hourekeeper, icmp pinger, ipmi polller, poller, trapper, configration syncer, ...&lt;/p&gt;

&lt;p&gt;　　StartPollers=60&lt;/p&gt;
&lt;p&gt;　　StartPingers=10&lt;/p&gt;
&lt;p&gt;　　...&lt;/p&gt;
&lt;p&gt;　　StartDBSyncer=5&lt;/p&gt;
&lt;p&gt;　　...&lt;/p&gt;

&lt;p&gt;(2) 设定合理的缓存大小&lt;/p&gt;
&lt;p&gt;　　 CacheSize=8M&lt;/p&gt;
&lt;p&gt;　　 HistoryCacheSize=16M&lt;/p&gt;
&lt;p&gt;　　 HistoryIndexCacheSize=4M&lt;/p&gt;
&lt;p&gt;　　 TrendCacheSize=4M&lt;/p&gt;
&lt;p&gt;　　 ValueCacheSize=4M&lt;/p&gt;

&lt;p&gt;(3) 数据库优化&lt;/p&gt;
&lt;p&gt;　　分表：&lt;/p&gt;
&lt;p&gt;　　　　history_*&lt;/p&gt;
&lt;p&gt;　　　　trends*&lt;/p&gt;
&lt;p&gt;　　　　events*&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、其它解决方案&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; grafana：展示&lt;/p&gt;
&lt;p&gt; collectd：收集&lt;/p&gt;
&lt;p&gt; influxdb：存储&lt;/p&gt;

&lt;p&gt; grafana+collectd+influxdb&lt;/p&gt;

&lt;p&gt; prometheus：&lt;/p&gt;
&lt;p&gt;　　 exporter：收集&lt;/p&gt;
&lt;p&gt;　　 alertmanager:&lt;/p&gt;
&lt;p&gt; grafana：展示&lt;/p&gt;

&lt;p&gt;openfalcon&lt;/p&gt;
</description>
<pubDate>Tue, 26 Dec 2017 15:00:00 +0000</pubDate>
<dc:creator>阿龙along</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/along21/p/8119088.html</dc:identifier>
</item>
<item>
<title>代码重构的必要性分析及实施建议 - 飞鸿踏雪2018</title>
<link>http://www.cnblogs.com/toothlou/p/8120466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toothlou/p/8120466.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;代码重构在软件开发过程中，是一项重要非紧急的工作。但大多数情况下，人们都会因为其非紧急，而忽略其重要性。等到代码重构演变成重要且紧急的工作时，一般就只有放弃了，因为由于长期的技术欠债，此时代码已经变得无法扩展，成为一堆僵死的代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码重构是为了使代码具有很好的可读性、可维护性、可扩展性、可重用性。&lt;/p&gt;

&lt;p&gt;代码在演化过程中，会由于各种不同的原因，不断产生bad smell。如果不及时清理，bad smell会不断积累，代码逐渐腐化，最终导致代码不可用。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;为了赶进度，开发人员牺牲了质量。&lt;/li&gt;
&lt;li&gt;业务分析不透彻、技术设计不深入。&lt;/li&gt;
&lt;li&gt;开发人员经验和意识欠缺。&lt;/li&gt;
&lt;li&gt;对设计方案的评审和代码走查重视不够，或者根本就没有这个环节。&lt;/li&gt;
&lt;li&gt;没有专人从业务、技术、人员等各方面拉通全盘考虑。&lt;/li&gt;
&lt;li&gt;前期无法预测后面所有的变化。&lt;/li&gt;
&lt;li&gt;技术团队对使用的相关技术掌握得不够，无法最优化地使用。&lt;/li&gt;
&lt;li&gt;由于软件开发本身的客观规律，代码腐化本身就不可避免。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;开发人员应该具有随时重构的意识，只要发现bad smell，就应该尝试重构。如果因为有其它原因，暂时无法重构的，我的建议是不超过两个月进行一次系统的重构。&lt;/p&gt;

&lt;h2 id=&quot;开发人员&quot;&gt;开发人员&lt;/h2&gt;
&lt;p&gt;开发人员是重构的具体执行者，需要具备很高的素质，才能做好重构工作。个人认为，比较重要的素质包括以下几方面：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.技能&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包括技术敏感度、重构的套路方法、系统思考的能力等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.责任心&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要有很好的质量意识，随时保持对代码出现bad smell的警惕。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.稳定的情绪&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这应该是属于管理层面的问题。如果开发人员的情绪出现的波动，就不会就主动将工作做得更好。&lt;/p&gt;
&lt;h2 id=&quot;测试人员&quot;&gt;测试人员&lt;/h2&gt;
&lt;p&gt;测试人员要与开发人员配合，通过各种测试手段和测试用例，降低或避免因重构而引入新的bug。&lt;/p&gt;
&lt;h2 id=&quot;需求分析人员&quot;&gt;需求分析人员&lt;/h2&gt;
&lt;p&gt;需求分析人员除了理清基本的业务逻辑之外，还要能够将各业务进行拆分，理清业务的本质和各业务之间的相互关系。&lt;br/&gt;当有新的需求引入，而导致之前的业务关系有变化时，尤其要重视。此时需求分析人员要与设计、开发、测试人员共同讨论，理清可能会对之前的代码产生哪些冲击，可能会带来哪方面的问题。&lt;/p&gt;
&lt;h2 id=&quot;系统设计人员&quot;&gt;系统设计人员&lt;/h2&gt;
&lt;p&gt;系统设计人员要有非常强的系统思维，同时对业务和技术都能够掌控，这样才能将各功能划分的更清晰、更合理。&lt;/p&gt;
&lt;h2 id=&quot;上级主管&quot;&gt;上级主管&lt;/h2&gt;
&lt;p&gt;上级主管不会直接参与重构，但如果上级主管不能够理解重构的重要性，则重构的工作开展到什么程度，完全由开发人员自己的经验、责任心来决定。&lt;br/&gt;虽然重构是非常重要的，但由于重构的效果是偏隐性和长期的，如果重构工作得不到上级主管的认同，则开发人员的重构积极性会被严重挫伤。&lt;br/&gt;等到代码不断腐化以至僵死，开发人员可能就会选择拍屁股走人，这时上级主管也会受到伤害。&lt;/p&gt;

&lt;p&gt;这是我个人的感受，不代表所有情况。就我个人的经验，有以下原因：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.人的惰性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然很多时候，开发人员都已经知道了该怎么重构，才能让代码具有更好的扩展性和重用性，但不重构而直接拷贝之前的代码再作简单的修改这样更省事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.能力的限制&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重构这个概念大家都知道，但真正要能够及时识别出代码中的重构点，并采用最优的方法进行重构，则对能力的要求非常高。不同水平的人，体现在重构上的差别非常大。&lt;br/&gt;这种能力的提升，主要是需要开发人员对自己的代码质量有很高的要求，并不断修炼。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.没有合适的主导人员&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;合适的主导人员，在技术上要能够识别出重构点和重构时机，并能自己或者指导开发人员进行有效的重构。在沟通协调上，要能够争取到上级主管的支持和其它业务部门的谅解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;4.缺乏制度的保证&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果能够在制度上，将重构工作常态化，并配以合理的考核机制和主导人员，则我们开发出的软件产品将具有更高的质量、更长的生命周期、带来更大的价值。&lt;/p&gt;
</description>
<pubDate>Tue, 26 Dec 2017 14:59:00 +0000</pubDate>
<dc:creator>飞鸿踏雪2018</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toothlou/p/8120466.html</dc:identifier>
</item>
<item>
<title>Python爬虫Scrapy(二)_入门案例 - 小破孩92</title>
<link>http://www.cnblogs.com/miqi1992/p/8120215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miqi1992/p/8120215.html</guid>
<description>&lt;blockquote readability=&quot;4.0217391304348&quot;&gt;
&lt;p&gt;本章将从案例开始介绍python scrapy框架，更多内容请参考:&lt;a href=&quot;http://www.cnblogs.com/miqi1992/p/8120215.html&quot;&gt;python学习指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;学习目标&quot;&gt;学习目标&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;创建一个Scrapy项目&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;定义提取的结构化数据(Item)&lt;/li&gt;
&lt;li&gt;编写爬取网站的Spider并提取出结构化数据(Item)&lt;/li&gt;
&lt;li&gt;编写Item Pipelines来存储提取到的Item(即结构化数据)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一新建项目scrapy-startproject&quot;&gt;一、新建项目(scrapy startproject)&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在开始爬取之前，必须创建一个新的Scrapy项目。进入自定义的项目目录中，运行下列命令：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;scrapy startproject cnblogSpider&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;其中，cnblogSpider为项目名称，可以看到将会创建一个cnblogSpider文件夹，目录结构大致如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oyl9rg5dr.bkt.clouddn.com/image/Spider_tree.png&quot; alt=&quot;scrapy目录结构&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;scrapy.cfg:项目部署文件&lt;br/&gt;cnblogSpider/: 该项目的python模块，之后可以在此加入代码&lt;br/&gt;cnblogSpider/items.py: 项目中的item文件。&lt;br/&gt;cnblogSpider/pipelines.py: 项目中的Pipelines文件。&lt;br/&gt;cnblogSpider/settings.py: 项目的配置文件。&lt;br/&gt;cnblogSpider/spiders/: 放置Spider代码的目录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二明确目标myspideritems.py&quot;&gt;二、明确目标(mySpider/items.py)&lt;/h2&gt;
&lt;p&gt;我们打算抓取：&quot;&lt;a href=&quot;http://www.cnblogs.com/miqi1992/default.html?page=2&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/miqi1992/default.html?page=2&lt;/a&gt;&quot; 网站里博客地址、标题、创建时间、文本。&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;打开cnblogSpider目录下的items.py&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;item定义结构化数据字段，用来保存爬取到的数据，有点像Python中的dict,但是提供了一些额外的保护减少错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以通过创建一个scrapy.item类，并且定义类型为scrapy.Field的类属性来定义一个Item(可以理解成类似于ORM的映射关系)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接下来，创建一个CnblogspiderItem类，和模型item模型(model)。&lt;br/&gt;```python&lt;br/&gt;import scrapy&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;class CnblogspiderItem(scrapy.Item):&lt;br/&gt;# define the fields for your item here like:&lt;br/&gt;url = scrapy.Field()&lt;br/&gt;time = scrapy.Field()&lt;br/&gt;title = scrapy.Field()&lt;br/&gt;content = scrapy.Field()&lt;br/&gt;```&lt;/p&gt;
&lt;h2 id=&quot;三制作爬虫spiderscnblogsspider.py&quot;&gt;三、制作爬虫(spiders/cnblogsSpider.py)&lt;/h2&gt;
&lt;p&gt;爬虫功能主要分两步：&lt;/p&gt;
&lt;h4 id=&quot;爬数据&quot;&gt;1. 爬数据&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在当前目录下输入命令，将在&lt;code&gt;cnblogSpider/spiders&lt;/code&gt;目录下创建一个名为&lt;code&gt;cnblog&lt;/code&gt;的爬虫，并制定爬取域的范围：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;scrapy genspider cnblog &lt;span class=&quot;st&quot;&gt;&quot;cnblogs.com&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;打开&lt;code&gt;cnblogSpider/spiders&lt;/code&gt;目录下的&lt;code&gt;cnblog&lt;/code&gt;，默认增加了下列代码：&lt;br/&gt;```python&lt;/p&gt;

&lt;p&gt;import scrapy&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;class CnblogSpider(scrapy.Spider):&lt;br/&gt;name = 'cnblog'&lt;br/&gt;allowed_domains = ['cnblogs.com']&lt;br/&gt;start_urls = ['&lt;a href=&quot;http://cnblogs.com/&quot; class=&quot;uri&quot;&gt;http://cnblogs.com/&lt;/a&gt;']&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def parse(self, response):
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实也可以由我们自行创建cnblog.py并编写上面的代码，只不过使用命令可以免去编写固定代码的麻烦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要建立一个Spider,你必须用scrapy.Spider类创建一个子类，并确定了三个强制的属性和一个方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;name = &quot;&quot;&lt;/code&gt;: 这个爬虫的识别名称，必须是唯一的，在不同的爬虫必须定义不同的名字。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allow_domains=[]&lt;/code&gt;: 是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页，不存在的URL会被忽略。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_urls=()&lt;/code&gt;:爬取的URL元祖/列表。爬虫从这里开始爬取数据，所以，第一次下载的数据将会从这些urls开始。其他子URL将会从这些起始URL中继承性生成。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parse(self, response)&lt;/code&gt;:解析的方法，每个初始URL完成下载后将被调用，调用的时候传入从每一个URL传回的Response对象来作为唯一参数，主要作用如下：
&lt;ol&gt;&lt;li&gt;负责解析返回的网页数据(respose.body),提取结构化数据(生成item)&lt;/li&gt;
&lt;li&gt;生成需要下一页的URL请求&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;将start_urls的值改为需要爬取的第一个url&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;start_urls&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;http://www.cnblogs.com/miqi1992/default.html?page=2&quot;&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;修改parse()方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; parse(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;, response):
    filename &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;cnblog.html&quot;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(filename, &lt;span class=&quot;st&quot;&gt;'w'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; f:
        f.write(response.body)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行一下看看，在cnblogSpider目录下运行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;scrapy crawl cnblog&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的，就是cnblog,看上面代码，它是CnblogSpider类的name属性，也就是&lt;code&gt;scrapy genspider&lt;/code&gt;命令的唯一爬虫名。&lt;/p&gt;
&lt;p&gt;运行之后，如果打印的日志出现&lt;code&gt;[scrapy]INFO: Spider closed(finished)&lt;/code&gt;，代表执行完成。之后当前文件夹中就出现了一个cnblog.html文件，里面就是我们刚刚要爬取的网页的全部源代码信息。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;#注意，Python2.x默认编码环境是ASCII，当和取回的数据编码格式不一致时，可能会造成乱码;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#我们可以指定保存内容的编码格式，一般情况下，我们可以在代码最上方添加：&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; os
&lt;span class=&quot;bu&quot;&gt;reload&lt;/span&gt;(sys)
sys.setdefaultencoding(&lt;span class=&quot;st&quot;&gt;'utf-8'&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;#这三行代码是Python2.x里面解决中文编码的万能钥匙，警告这么多年的吐槽后Python3学乖了，默认编码是Unicode了&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;爬数据-1&quot;&gt;2.爬数据&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;爬取整个网页完毕，接下来就是取过程了，首先观察页面源码：&lt;br/&gt;&lt;img src=&quot;http://oyl9rg5dr.bkt.clouddn.com/image/beautiful_yuanma.png&quot; alt=&quot;页面结构&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;day&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dayTitle&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;...&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;postTitle&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;...&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;postCon&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;...&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;XPath表达式如下：
&lt;ul&gt;&lt;li&gt;所有文章：.//*[@class='day']&lt;/li&gt;
&lt;li&gt;文章发表时间：.//*[@class='dayTitle']/a/text()&lt;/li&gt;
&lt;li&gt;文章标题内容：.//*[@class='postTitle']/a/text()&lt;/li&gt;
&lt;li&gt;文章摘要内容：.//*[@class='postCon']/div/text()&lt;/li&gt;
&lt;li&gt;文章链接：.//*[@class='postTitle']&lt;a href=&quot;mailto:/a/@href&quot;&gt;/a/@href&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;是不是一目了然？直接上XPath开始提取数据吧。&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们之前在cnblogSpider/items.py里定义了一个CnblogItem类。这里引入进来&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; cnblogSpider.items &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; CnblogspiderItem&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;然后将我们得到的数据封装到一个&lt;code&gt;CnblogspiderItem&lt;/code&gt;对象中，可以保存每个博客的属性：&lt;br/&gt;```python&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;form cnblogSpider.items import CnblogspiderItem&lt;/p&gt;
&lt;p&gt;def parse(self, response):&lt;br/&gt;# print(response.body)&lt;br/&gt;# filename = &quot;cnblog.html&quot;&lt;br/&gt;# with open(filename, 'w') as f:&lt;br/&gt;# f.write(response.body)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    #存放博客的集合
    items = []

    for each in response.xpath(&quot;.//*[@class='day']&quot;):
        item = CnblogspiderItem()
        url = each.xpath('.//*[@class=&quot;postTitle&quot;]/a/@href').extract()[0]
        title = each.xpath('.//*[@class=&quot;postTitle&quot;]/a/text()').extract()[0]
        time = each.xpath('.//*[@class=&quot;dayTitle&quot;]/a/text()').extract()[0]
        content = each.xpath('.//*[@class=&quot;postCon&quot;]/div/text()').extract()[0]

        item['url'] = url
        item['title'] = title
        item['time'] = time
        item['content'] = content 
        
        items.append(item)

    #直接返回最后数据
    return items&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们暂时先不处理管道，后面会详细介绍。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;保存数据&quot;&gt;保存数据&lt;/h3&gt;
&lt;p&gt;scrapy保存信息的最简单的方法主要有四种， -o 输出指定格式的文件，命令如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;#json格式，默认为Unicode编码&lt;/span&gt;
scrapy crawl cnblog &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;o cnblog.json

&lt;span class=&quot;co&quot;&gt;#json lines格式，默认为Unicode编码&lt;/span&gt;
scrapy crawl cnblog &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;o cnblog.jsonl

&lt;span class=&quot;co&quot;&gt;#csv逗号表达式，可用excel打开&lt;/span&gt;
scrapy crawl cnblog &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;o cnblog.csv

&lt;span class=&quot;co&quot;&gt;#xml格式&lt;/span&gt;
scrapy crawl cnblog &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;o cnblog.xml&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;
&lt;h4 id=&quot;如果将代码改成下面形式结果完全一样&quot;&gt;如果将代码改成下面形式，结果完全一样&lt;/h4&gt;
&lt;h4 id=&quot;请思考yield在这里的作用&quot;&gt;请思考yield在这里的作用：&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;form cnblogSpider.items &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; CnblogspiderItem

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; parse(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;, response):
        &lt;span class=&quot;co&quot;&gt;# print(response.body)&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;# filename = &quot;cnblog.html&quot;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;# with open(filename, 'w') as f:&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;#     f.write(response.body)&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;#存放博客的集合&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;# items = []&lt;/span&gt;

        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; each &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; response.xpath(&lt;span class=&quot;st&quot;&gt;&quot;.//*[@class='day']&quot;&lt;/span&gt;):
            item &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; CnblogspiderItem()
            url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; each.xpath(&lt;span class=&quot;st&quot;&gt;'.//*[@class=&quot;postTitle&quot;]/a/@href'&lt;/span&gt;).extract()[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
            title &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; each.xpath(&lt;span class=&quot;st&quot;&gt;'.//*[@class=&quot;postTitle&quot;]/a/text()'&lt;/span&gt;).extract()[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
            time &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; each.xpath(&lt;span class=&quot;st&quot;&gt;'.//*[@class=&quot;dayTitle&quot;]/a/text()'&lt;/span&gt;).extract()[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
            content &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; each.xpath(&lt;span class=&quot;st&quot;&gt;'.//*[@class=&quot;postCon&quot;]/div/text()'&lt;/span&gt;).extract()[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]

            item[&lt;span class=&quot;st&quot;&gt;'url'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; url
            item[&lt;span class=&quot;st&quot;&gt;'title'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; title
            item[&lt;span class=&quot;st&quot;&gt;'time'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time
            item[&lt;span class=&quot;st&quot;&gt;'content'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; content 
            
            &lt;span class=&quot;co&quot;&gt;# items.append(item)&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;#将获取到的数据交给pipelines&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;yield&lt;/span&gt; item

        &lt;span class=&quot;co&quot;&gt;#直接返回最后数据,不经过pipelines&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;#return items&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.html&quot;&gt;Python参考手册&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 26 Dec 2017 13:54:00 +0000</pubDate>
<dc:creator>小破孩92</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/miqi1992/p/8120215.html</dc:identifier>
</item>
<item>
<title>IdentityServer（12）- 使用 ASP.NET Core Identity - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/8120129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/8120129.html</guid>
<description>&lt;p&gt;IdentityServer具有非常好的扩展性，其中用户及其数据（包括密码）部分你可以使用任何想要的数据库进行持久化。 如果需要一个新的用户数据库，那么ASP.NET Core Identity是你的一个选择。 本快速入门介绍了如何将ASP.NET Core Identity 和 IdentityServer4一起使用。&lt;/p&gt;
&lt;p&gt;在阅读这篇文章是，希望你能把前面的文章全部看一遍，了解基本使用和相关的理论。 这个快速入门使用ASP.NET Core Identity的方法是从Visual Studio中的ASP.NET Core Identity模板创建一个新项目。 这个新的项目将取代之前在之前的快速入门中从头开始构建的IdentityServer项目。 此解决方案中的所有其他项目（对于客户端和API）将保持不变。&lt;/p&gt;

&lt;p&gt;第一步是为您的解决方案添加一个ASP.NET Core Identity的新项目。 鉴于ASP.NET Core Identity需要大量代码，因此使用Visual Studio中的模板是最好的。 你最终将删除IdentityServer的旧项目，但有几个项目需要迁移（或按照之前的快速入门所述从头开始重新编写）。&lt;/p&gt;
&lt;p&gt;创建一个ASP.NET Core Web应用程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201712/668104-20171226205953088-1433623312.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择Web应用程序（MVC）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201712/668104-20171226210100995-162278411.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击“更改身份验证”按钮，选择“个人用户账户”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201712/668104-20171226210144338-1217407085.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，你的设置应该是和下图一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201712/668104-20171226210240010-431521790.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;不要忘记修改hosting以在端口5000上运行。这非常重要，这将关系到继续使用现有的客户端和API项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201712/668104-20171226210734885-688139973.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;添加&lt;code&gt;IdentityServer4.AspNetIdentity&lt;/code&gt; NuGet包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201712/668104-20171226211033385-277601723.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;尽管这是IdentityServer的一个新项目，但我们仍然需要与之前的快速入门一样的配置Scopes 和 Clients。 将之前快速入门的配置类（在Config.cs中）复制到此新项目中。&lt;/p&gt;
&lt;p&gt;对于现在的配置需要改变的是禁用MVC客户端的许可。 我们还没有复制之前的IdentityServer项目的许可代码，所以现在对MVC客户端进行一次修改，并设置&lt;code&gt;RequireConsent = false&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;new Client
{
    ClientId = &quot;mvc&quot;,
    ClientName = &quot;MVC Client&quot;,
    AllowedGrantTypes = GrantTypes.HybridAndClientCredentials,

    RequireConsent = false,

    ClientSecrets =
    {
        new Secret(&quot;secret&quot;.Sha256())
    },

    RedirectUris           = { &quot;http://localhost:5002/signin-oidc&quot; },
    PostLogoutRedirectUris = { &quot;http://localhost:5002/signout-callback-oidc&quot; },

    AllowedScopes =
    {
        IdentityServerConstants.StandardScopes.OpenId,
        IdentityServerConstants.StandardScopes.Profile,
        &quot;api1&quot;
    },
    AllowOfflineAccess = true
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;和以前一样，IdentityServer需要在Startup.cs的ConfigureServices和Configure中进行配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConfigureServices&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;以前我们使用&lt;code&gt;AddTestUsers&lt;/code&gt;扩展方法用于注册用户，但在这种现在的解决方案下，我们用&lt;code&gt;AddAspNetIdentity&lt;/code&gt;替换该扩展方法来使用ASP.NET Identity用户。&lt;code&gt;AddAspNetIdentity&lt;/code&gt;扩展方法需要一个通用参数，它是你的ASP.NET Ientity用户类型（与模板中的AddIdentity方法一样）&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;
        options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));

    services.AddIdentity&amp;lt;ApplicationUser, IdentityRole&amp;gt;()
        .AddEntityFrameworkStores&amp;lt;ApplicationDbContext&amp;gt;()
        .AddDefaultTokenProviders();

    // Add application services.
    services.AddTransient&amp;lt;IEmailSender, EmailSender&amp;gt;();

    services.AddMvc();

    // configure identity server with in-memory stores, keys, clients and scopes
    services.AddIdentityServer()
        .AddDeveloperSigningCredential()
        .AddInMemoryPersistedGrants()
        .AddInMemoryIdentityResources(Config.GetIdentityResources())
        .AddInMemoryApiResources(Config.GetApiResources())
        .AddInMemoryClients(Config.GetClients())
        .AddAspNetIdentity&amp;lt;ApplicationUser&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们在将Asp.Net Identity添加到DI容器中时，一定要把注册IdentityServer放在Asp.Net Identity之后，因为注册IdentityServer会覆盖Asp.Net Identity的一些配置，这个非常重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Configure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用UseIdentityServer代替了对UseIdentity的调用&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
        app.UseBrowserLink();
        app.UseDatabaseErrorPage();
    }
    else
    {
        app.UseExceptionHandler(&quot;/Home/Error&quot;);
    }

    app.UseStaticFiles();

    // app.UseAuthentication(); // not needed, since UseIdentityServer adds the authentication middleware
    app.UseIdentityServer();

    app.UseMvc(routes =&amp;gt;
    {
        routes.MapRoute(
            name: &quot;default&quot;,
            template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;鉴于这是一个新的ASP.NET Identity项目，您将需要创建数据库。 您可以通过从项目目录运行命令提示符并运行&lt;code&gt;dotnet ef database update -c ApplicationDbContext&lt;/code&gt;来完成此操作:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171226213405010-370800566.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在VS程序包控制台使用命令也是一样的&lt;code&gt;Update-Database&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此时，您应该能够运行项目并在数据库中创建/注册用户。 启动应用程序，并从主页点击“Register”链接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171226213702807-2007565345.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并在注册页面上创建一个新的用户帐户：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171226213725604-1924127843.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在你有一个用户帐户，你应该可以登录，使用客户端，并调用API。&lt;/p&gt;

&lt;p&gt;启动MVC客户端应用程序，你应该能够点击“Secure”链接登录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171226213849713-558450627.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;您应该被重定向到ASP.NET Identity登录页面。 用新创建的用户登录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171226213920120-1485123099.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录后，您应该跳过同意页面（给出我们上面所做的更改），并立即重定向到MVC客户端应用程序，会显示你的用户信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171226214107323-1298549854.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;您还应该能够单击“Call API using application identity”来调用API：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171226214203916-1254810901.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，您已经从ASP.NET Ientity的用户登录。&lt;/p&gt;
&lt;p&gt;本文代码：&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4.Samples/tree/release/Quickstarts/6_AspNetIdentity&quot; class=&quot;uri&quot;&gt;https://github.com/IdentityServer/IdentityServer4.Samples/tree/release/Quickstarts/6_AspNetIdentity&lt;/a&gt;&lt;br/&gt;原文：&lt;a href=&quot;https://identityserver4.readthedocs.io/en/release/quickstarts/6_aspnet_identity.html&quot; class=&quot;uri&quot;&gt;https://identityserver4.readthedocs.io/en/release/quickstarts/6_aspnet_identity.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Dec 2017 13:43:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stulzq/p/8120129.html</dc:identifier>
</item>
</channel>
</rss>