<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>算法总结之动态规划（DP） - Sure_Cheun</title>
<link>http://www.cnblogs.com/surecheun/p/9973932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surecheun/p/9973932.html</guid>
<description>&lt;h3 id=&quot;适用动态规划的特点&quot;&gt;适用动态规划的特点&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;所解决的问题是最优化问题。&lt;/li&gt;
&lt;li&gt;所解决的问题具有“最优子结构”。可以建立一个递推关系，使得n阶段的问题，可以通过几个k&amp;lt;n阶段的低阶子问题的最优解来求解。&lt;/li&gt;
&lt;li&gt;具有“重叠子结构”的特点。即，求解低阶子问题时存在重复计算。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;词典法&quot;&gt;词典法&lt;/h3&gt;
&lt;p&gt;大家都知道，递归算法一般都存在大量的重复计算，这会造成不必要的时间浪费。词典法，它可以使递归函数避免重复计算。词典法的具体做法是，设计一个数据结构D（多为数组）来保存以前的计算结果。在计算过程中，如果发现要用到的计算结果是之前已经算过了的结果时，就可以直接从数据结构D中获取，避免重复计算，用空间换取时间。&lt;/p&gt;
&lt;p&gt;动态规划同样使用了类似“词典法”的措施，也设计了一个数据结构来保存计算结果，但不再使用递归函数来求解，而是通过循环迭代的方式来填写数据结构。&lt;/p&gt;
&lt;h3 id=&quot;动态规划常见问题&quot;&gt;动态规划常见问题&lt;/h3&gt;
&lt;h4 id=&quot;最长公共子序列&quot;&gt;最长公共子序列&lt;/h4&gt;
&lt;p&gt;如果序列 { s1, s2, ……, sk } 是序列 { a1, a2, ……, an } 的子序列，又是序列 { b1, b2, ……, bm } 的子序列，则称序列 s 为序列 a 和 序列 b 的公共子序列。在 a 和 b 的所有公共子序列中，长度最长者称为最长公共子序列。 求a,b的最长公共子序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析：&lt;/strong&gt; 一个长度为n的序列，有2的n次方个子序列；如果用穷举的方法来比的话，那么时间复杂度将会非常高。很明显这是一个最优化的问题，我们不妨看看这期间存不存在递推关系，尝试寻找一下“最优子结构”。&lt;br/&gt;假设S={s1,s2,...sk}是序列A={a1,a2,...an}和B={b1,b2...bm}的最长子序列，那么有以下发现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果an=bm，则{s1,s2...s(k-1)}是{a1,a2,...a(n-1)}和{b1,b2,...b(m-1)}的最长子序列；&lt;/li&gt;
&lt;li&gt;如果an！=bm，则S要么是A(n-1）和B的最长公共子序列，要么是A和B（m-1）的最长公共子序列。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;根据上面的分析，此问题存在着递推关系（“最优子结构”）。为方便，先计算最长公共子序列的长度，然后再寻找最长公共子序列。考虑用一个 &lt;strong&gt;&lt;em&gt;二维数组D[i][j]&lt;/em&gt;&lt;/strong&gt; 来记录A(i),B(j)的最长公共子序列的长度。由上面的分析，很容易得到以下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;D[i][j]=0,如果i或j为0；&lt;/li&gt;
&lt;li&gt;D[i][j]=D[i-1][j-1]+1,如果ai=bj;&lt;/li&gt;
&lt;li&gt;D[i][j]=max(D[i-1][j],D[i][j-1]),如果ai！=bj&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由上面的递推公式可知，D[i][j]的计算有可能要用到i,j位置上一行的数以及i，j位置所在行左边的数，所以填写D[i][j]是应该是由上往下、由左往右填写，最后的D[n][m]就是A和B的最长公共子序列的长度。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;C++实现如下：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define MAX 100
#define max(a,b) a&amp;gt;b? a:b

int D[MAX][MAX];//记录最长公共子序列的长度

int S[MAX];//记录其中一个公共最长子序列

void countLen(int A[], int n, int B[], int m) {//根据公式填写D[i][j]
    int i, j;
    for (i = 1; i &amp;lt;= n; i++)//i=0,j=0不用
        for (j = 1; j &amp;lt;= m; j++)
            if (A[i] == B[j])
                D[i][j] = D[i - 1][j - 1] + 1;
            else
                D[i][j] = max(D[i - 1][j], D[i][j - 1]);
}

int searchS(int A[], int n, int B[], int m) {//如果D[i]j]==D[i-1][j-1]+1，则A[i]可写进S;
    int i, j, k;
    i = n;
    j = m;
    k = D[n][m];
    while (i != 0 &amp;amp;&amp;amp; j != 0) {
        if (D[i][j] == D[i - 1][j - 1])
            i--;
        else if (D[i][j] == D[i][j - 1])//也可沿着D[i][j]==d[i-1][j]回溯
            j--;
        else
        {
            S[k--] = A[i];
            i--;
            j--;
        }
    }
    //返回最长长度
    return D[m][n];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;其他问题&quot;&gt;其他问题&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;最大字段和问题&lt;/li&gt;
&lt;li&gt;矩阵连乘问题&lt;/li&gt;
&lt;li&gt;数据压缩问题&lt;/li&gt;
&lt;li&gt;0-1背包问题&lt;/li&gt;
&lt;li&gt;最优二叉树搜索问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;【原创声明。转载请标注原文地址：&lt;a href=&quot;https://blog.csdn.net/yunyunyx/article/details/84140780&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/yunyunyx/article/details/84140780&lt;/a&gt;】&lt;/p&gt;
</description>
<pubDate>Sat, 17 Nov 2018 07:01:00 +0000</pubDate>
<dc:creator>Sure_Cheun</dc:creator>
<og:description>适用动态规划的特点 1. 所解决的问题是最优化问题。 2. 所解决的问题具有“最优子结构”。可以建立一个递推关系，使得n阶段的问题，可以通过几个kb? a:b int D[MAX][MAX];//记录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surecheun/p/9973932.html</dc:identifier>
</item>
<item>
<title>dropwizard-core模块解析 - pinezhang</title>
<link>http://www.cnblogs.com/ilovena/p/9864836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ilovena/p/9864836.html</guid>
<description>&lt;p&gt;Dropwizard是一款开发运维友好、高效、RESTful web服务的框架。Dropwizard将稳定、成熟的java生态系统中的库整合为一个简单的、轻量级的包，即跨越了库和框架之间的界限，使得我们可以更关注于业务本身。&lt;br/&gt;Dropwizard 集成的三方包：Jersey，Jetty，Jackson，metrics，其他&lt;/p&gt;

&lt;p&gt;学习程序的常规操作，&lt;a href=&quot;https://www.dropwizard.io/1.1.0/docs/getting-started.html&quot;&gt;helloworld&lt;/a&gt;。了解大致的应用启动流程。&lt;/p&gt;

&lt;p&gt;该模块是dropwizard的核心模块，掌握了这个模块，对dw的基本运行机制等大部分的常用功能基本就了解了。&lt;br/&gt;&lt;a href=&quot;https://www.dropwizard.io/1.3.5/docs/manual/core.html&quot;&gt;core官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;application&quot;&gt;Application&lt;/h2&gt;
&lt;p&gt;Application类是dw的核心类，使用dw的应用必须需要继承该类，比如helloworld.&lt;br/&gt;Application的核心函数为run，在该部分会完成应用初始化和启动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void run(String... arguments) throws Exception {
        //注意创建bootstrap对象时赋的其他对象，比如默认使用的ConfigurationSourceProvider为FileConfigurationSourceProvider
        final Bootstrap&amp;lt;T&amp;gt; bootstrap = new Bootstrap&amp;lt;&amp;gt;(this);
        //添加默认的command，只有check和server。
        addDefaultCommands(bootstrap);
        //调用app的init方法，在这里可以addBundle，addCommand，设置configuration的替换方法，由应用自身实现
        initialize(bootstrap);
        //注册metrics，为监控服务器做准备
        bootstrap.registerMetrics();

        //创建命令执行器，Cli类解析命令行输入参数并执行命令
        final Cli cli = new Cli(new JarLocation(getClass()), bootstrap, System.out, System.err);
        //根据输入参数执行command，比如利用server Command为应用启动HTTP 服务器
        if (!cli.run(arguments)) {
            // only exit if there's an error running the command
            onFatalError();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;configuration类&quot;&gt;Configuration类&lt;/h2&gt;
&lt;p&gt;Configuration类是core的核心类之一，YAML配置文件的对象表示&lt;br/&gt;&lt;em&gt;Configuration主要功能实现在dropwizard-confiugration模块实现&lt;/em&gt;&lt;br/&gt;dropwizard-confiugration模块的主要功能是加载、解析、绑定和验证配置文件。核心接口ConfigurationFactory&lt;/p&gt;
&lt;h2 id=&quot;bootstrap类&quot;&gt;Bootstrap类&lt;/h2&gt;
&lt;p&gt;Bootstrap类是core模块的核心类之一，官方定位为application的预启动环境。我个人将其作用理解为完成application启动前的环境准备和初始化，比如添加Bundles、Commands或者注册Jackson modules，这样就能允许我们把一些自定义的类型加载到配置中。&lt;br/&gt;其实，根据Bootstrap的构造器我们能大致看出类的功能，Bootstrap主要负责构造器里的对象的管理（get和set），然后提供addBundle和addCommand功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public Bootstrap(Application&amp;lt;T&amp;gt; application) {
        this.application = application;
        //Jackson的主要类，用于Java对象和Json对象相互转换
        this.objectMapper = Jackson.newObjectMapper();
        //维护bundle的列表
        this.configuredBundles = new ArrayList&amp;lt;&amp;gt;();
        //维护command的列表
        this.commands = new ArrayList&amp;lt;&amp;gt;();
        //Validator负责配置文件解析后的验证功能
        this.validatorFactory = Validators.newValidatorFactory();
        //度量对象，用于@Timed等
        this.metricRegistry = new MetricRegistry();
        //配置文件的读取方式，具体见dropwizard-configuration模块
        this.configurationSourceProvider = new FileConfigurationSourceProvider();
        this.classLoader = Thread.currentThread().getContextClassLoader();
        this.configurationFactoryFactory = new DefaultConfigurationFactoryFactory&amp;lt;&amp;gt;();
        //HealCheck，负责应用状态检查，可以查看应用是否正在工作
        this.healthCheckRegistry = new HealthCheckRegistry();
    }
.........
    public void addCommand(ConfiguredCommand&amp;lt;T&amp;gt; command) {
        commands.add(command);
    }
.........
//注意，init()添加bundle时进行了初始化
    public void addBundle(ConfiguredBundle&amp;lt;? super T&amp;gt; bundle) {
        bundle.initialize(this);
        configuredBundles.add(bundle);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;environment类&quot;&gt;Environment类&lt;/h2&gt;
&lt;p&gt;Environment类是dropwizard的应用环境。包含应用提供的所有的的 Resources, servlets, filters, Health Checks, Jersey providers, Managed Objects, Tasks, and Jersey properties。&lt;br/&gt;Environment类的属性如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private final String name;
    private final MetricRegistry metricRegistry;
    private final HealthCheckRegistry healthCheckRegistry;

    private final ObjectMapper objectMapper;
    private Validator validator;

    private final JerseyContainerHolder jerseyServletContainer;
    private final JerseyEnvironment jerseyEnvironment;

    private final MutableServletContextHandler servletContext;
    private final ServletEnvironment servletEnvironment;

    private final LifecycleEnvironment lifecycleEnvironment;

    private final MutableServletContextHandler adminContext;
    private final AdminEnvironment adminEnvironment;

    private final ExecutorService healthCheckExecutorService;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性基本全部为final修饰，主要方法几乎全部为get方法，只有唯一一个set方法。所有，你可以直接把Environment理解为提供各种服务环境或者对象的一个容器，并且维护的对象只有Validator 可变。&lt;/p&gt;

&lt;p&gt;dropwizard-core的cli包负责执行传入的命令，入口为Cli.run(String... arguments)&lt;br/&gt;&lt;em&gt;Cli.run-&amp;gt;ConfiguredCommand.run-&amp;gt;EnvironmentCommand.run&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected void run(Bootstrap&amp;lt;T&amp;gt; bootstrap, Namespace namespace, T configuration) throws Exception {
        final Environment environment = new Environment(bootstrap.getApplication().getName(),
                                                        bootstrap.getObjectMapper(),
                                                        bootstrap.getValidatorFactory(),
                                                        bootstrap.getMetricRegistry(),
                                                        bootstrap.getClassLoader(),
                                                        bootstrap.getHealthCheckRegistry());
        //为注册器registry配置生命周期，同app生命周期
        //@Timed @Metered 产生的报告和生命周期关联
        configuration.getMetricsFactory().configure(environment.lifecycle(),
                                                    bootstrap.getMetricRegistry());
        //配置Envrionment.
        //调用DefaultServerFactory.configure
        // 的Registering jersey handler，Registering admin handler。jetty sevrer 必备属性
        configuration.getServerFactory().configure(environment);
        // 运行bundles，Bundle实现ConfiguredBundle，实现run方法和init方法
        bootstrap.run(configuration, environment);
        //应用自定义的run方法。用于向environment注册Resource,设置鉴权等
        application.run(configuration, environment);
        //Runs the command with the given {@link Environment} and {@link Configuration}
        //一般为server command--产生并启动app的服务器
        run(environment, namespace, configuration);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完run(environment, namespace, configuration)，Jetty服务器就启动成功了。&lt;/p&gt;
&lt;p&gt;dropwizard-core模块Server的核心接口为ServerFactory，实现类为DefaultServerFactory。&lt;br/&gt;启动Jetty Server为命令为server command，启动类为ServerCommand&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected void run(Environment environment, Namespace namespace, T configuration) throws Exception {
        final Server server = configuration.getServerFactory().build(environment);
        try {
            server.addLifeCycleListener(new LifeCycleListener());
            cleanupAsynchronously();
            server.start();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了更好的理解应用启动过程，需要对Jetty做一些了解。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Nov 2018 06:25:00 +0000</pubDate>
<dc:creator>pinezhang</dc:creator>
<og:description>简介 Dropwizard是一款开发运维友好、高效、RESTful web服务的框架。Dropwizard将稳定、成熟的java生态系统中的库整合为一个简单的、轻量级的包，即跨越了库和框架之间的界限，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ilovena/p/9864836.html</dc:identifier>
</item>
<item>
<title>强化学习七 - Policy Gradient Methods - SongHL</title>
<link>http://www.cnblogs.com/songorz/p/9973792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songorz/p/9973792.html</guid>
<description>&lt;p&gt;　　之前我们讨论的所有问题都是先学习action value,再根据action value 来选择action(无论是根据greedy policy选择使得action value 最大的action,还是根据ε-greedy policy以1-ε的概率选择使得action value 最大的action,action 的选择都离不开action value 的计算)。即&lt;strong&gt;没有action value的估计值就无法进行action选择，也就没有Policy,这类方法被称为 value-based methods.&lt;/strong&gt;其实我们可以直接产生不依赖于action value 的polcy ,这类直接生成action的方法就叫policy-based methods.他们关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117123720017-1384801095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　value-based方法，需要计算价值函数（value function），根据自己认为的高价值选择行（action）的方法，如Q Learning。&lt;br/&gt;　　policy-based方法，不需要根据value function选择action，可以直接得出policy的方法。&lt;br/&gt;　　图中第三类方法(Actor critic)结合了上述两者，&lt;strong&gt;即计算value function，但不直接根据value function选择action，action 由policy-based方法得到。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二. Advantages of Policy-Based RL&lt;/strong&gt;　　&lt;/h2&gt;
&lt;p&gt;Policy-Based RL 的优势：&lt;/p&gt;
&lt;p&gt;　　1）有着更好的收敛性质。Value_Based 方法需要对值函数进行更新，然后才能反映到策略中，而值函数中的一些小小改变可能会使得策略发生较大改变，从而收敛性较差。当然，我们在模型无关的控制(model free)当中说过，如果将探索因子epsilon设定位1/k,则得到的Monte-carlo Contorl是符合GLIE条件的，此时该方法对应的致函苏将收敛于最优致函数。&lt;strong&gt;Value-Based方法收敛性较差只得是较容易震荡而难以收敛，而后面说的将收敛于最优值函数是指“最终”将收敛于最优致函数。&lt;/strong&gt;我们并不知道“最终”是多久，所以，Policy-Based在这个问题上更具有优势。&lt;/p&gt;
&lt;p&gt;　　2）在高纬度和连续动作空间上有着逢高的效率。毕竟Value-Based 方法需要计算&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117132056260-1522215954.png&quot; alt=&quot;&quot; width=&quot;80&quot; height=&quot;19&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果动作集很大，那么这个max操作的计算量就很大，而Policy-Based RL方法就不存在这种问题。&lt;/p&gt;
&lt;p&gt;　　3）可以学习随机性策略。Value-Based 方法是隐式地对策略进行表示，需要用greedy 方法得到策略，所以学习单的是确定性策略。&lt;/p&gt;
&lt;p&gt;　　Policy-Based 的缺点：&lt;/p&gt;
&lt;p&gt;　　1）通常是收敛到极限；&lt;/p&gt;
&lt;p&gt;　　2）评估策略是低效，高差异的；&lt;/p&gt;
&lt;p&gt;　　举个例子1，在我们所熟知的“石头剪刀布”游戏中，需要寻求纳什均衡，所以并不能弄一个确定性策略，这种情况下，一个均匀的随机策略就是最优的。&lt;/p&gt;
&lt;p&gt;　　举例2：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117132851908-372307625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的这个格子世界中，两个灰色方格对于智能体而言并没有什么区别。如果使用一个确定性策略，那么在灰色方格处的决策要么都向左，要么都向右，不管是向左还是向右，都有可能卡住，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117132904603-1702753518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，Value-Based方法也可以学习一个near-deterministic策略，比如说epsilon-greedy，这样的方法虽然不会一直卡住，但是一般需要较长时间才能结束这一episode。课程中有这么一句话：Whenever stochastic policy occurs, a stochastic policy can do better than a deterministic policy。也就是说，&lt;strong&gt;一般而言，只要出现随机性策略的时候，一般都会比确定性策略要好&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面来看一下常用的几个目标函数：&lt;/p&gt;
&lt;p&gt;        1）episodic环境中，我们使用start value：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117133101127-2044620436.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;45&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）continuing环境中，我们使用average value：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117133128054-18532693.png&quot; alt=&quot;&quot; width=&quot;275&quot; height=&quot;38&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3）continuing环境中，也可以使用average reward per time-step：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117133158059-310883945.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;strong&gt;d为利用对应策略生成的马尔可夫链的稳态分布&lt;/strong&gt;。1）中为从某个状态&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224085359674&quot; alt=&quot;&quot; width=&quot;15&quot;/&gt;开始，后面将得到的奖励；2）中为continuing环境，所以并没有一个所谓的初始状态&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224085359674&quot; alt=&quot;&quot; width=&quot;15&quot;/&gt;，也没有一个结束状态；3）中表示平稳状态分布下单步的奖励。&lt;/p&gt;
&lt;h2&gt; 三. Score Function&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117134150548-1792744806.png&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;106&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也即策略梯度可以等价地表示为策略乘以一个似然函数的倒数，这个与极大似然操作形式一致的式子叫做Score Function ,表示为：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117134542180-570105145.png&quot; alt=&quot;&quot; width=&quot;516&quot; height=&quot;26&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面通过两个例子说明score function:&lt;/p&gt;
&lt;p&gt;　　1)softmax policy&lt;/p&gt;
&lt;p&gt;首先假设使用线性特征组合&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117134753898-1427460405.png&quot; alt=&quot;&quot; width=&quot;126&quot; height=&quot;25&quot;/&gt;对动作进行加权：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117134825438-925753091.png&quot; alt=&quot;&quot; width=&quot;231&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，score function为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117134857179-1720824257.png&quot; alt=&quot;&quot; width=&quot;496&quot; height=&quot;362&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理，我们可以得到服从&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224200348922&quot; alt=&quot;&quot; width=&quot;60&quot;/&gt;的高斯分布的score function：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117134938656-393942132.png&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;34&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四.one-step MDP&lt;/h2&gt;
&lt;p&gt;考虑完策略的导数之后，接着我们讨论奖励函数的导数。首先考虑一个简单的one-step MDP：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135020214-2032156810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 推导奖励函数的梯度：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224201928409&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们通过这个简单的one-step MDP可知，奖励函数的导数等于socre function乘以reward在策略下的期望，也即：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224202935214&quot; alt=&quot;&quot; width=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        策略梯度定理正是这一简单情形的拓展：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224203053722&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与上面的one-step MDP的情形相比，这里将其拓展到了multi-step MDP，并且将即时奖励r替换为了long-term值函数，这一定理非常重要。我们知道，我们对于策略参数的更新都是沿着极大化奖励函数的方向进行的，所以由上式我们可以对参数进行更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来将将该定理结合model-free情形进行使用，得到REINFORCE算法：&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;五.Monte-Carlo Policy Gradient (REINFORCE)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135116974-608502356.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;433&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其想法非常简单，就是将奖励函数的梯度中的期望换为采样，在一个episode结束之后，利用该episode中的每一个step对参数进行更新。不过这个算法中对于的估计使用的是回报（return），这是一个无偏估计，但是却有着较大的方差，所以，我们考虑换成其他方法对值函数进行逼近，比如说利用神经网络或其他参数化方法，记参数为w（此处可回想DDPG算法形式）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135208733-894260325.png&quot; alt=&quot;&quot; width=&quot;258&quot; height=&quot;25&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们称之为Critic，并将上面的参数化策略称为Actor，将这二者结合起来，叫做&lt;strong&gt;Actor-Critic&lt;/strong&gt;算法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135230704-438697666.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;53&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于参数w的更新，我们可以将回报（return）或者TD target作为目标，最小化当前值函数与目标的平方。此外，在Actor-Critic算法中，我们可以在每个step对策略进行更新，而不用像REINFORCE一样，只能在每个episode运行完成之后进行更新。因为这里每个step我们可以使用对奖励进行估计，然后代入上面的式子，对策略进行更新，而REINFORCE使用回报（return）决定了它不能实时更新。当然，在这里使用的是单样本更新，我们也可以将其换为least-squares方法，也即replay buffer方法。&lt;/p&gt;
&lt;p&gt;        Actor-Critic算法虽然降低了方差，但是一般来说是有偏的，因为在approximating(逼近)的时候引入了bias。那是否能够通过恰当地选择值函数估计器来避免引入bias呢？这是可以的。由此我们引出兼容函数估计（Compatible Function Approximation）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135436756-32445318.png&quot; alt=&quot;&quot; width=&quot;449&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 考虑条件1中提到的式子，用语言表述为：“score function = the gradient of Critic”，将其代入到&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224212819644&quot; alt=&quot;&quot; width=&quot;20&quot;/&gt;中，可得：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135512454-2040714718.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;39&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 比方说，在某个状态s和动作a下，假设&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224210701819&quot; alt=&quot;&quot; width=&quot;50&quot;/&gt;为正，则&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224212819644&quot; alt=&quot;&quot; width=&quot;20&quot;/&gt;沿着&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224210701819&quot; alt=&quot;&quot; width=&quot;50&quot;/&gt;的梯度方向进行更新，且&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224210701819&quot; alt=&quot;&quot; width=&quot;50&quot;/&gt;越大，&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224212819644&quot; alt=&quot;&quot; width=&quot;20&quot;/&gt;越大，如果&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224210701819&quot; alt=&quot;&quot; width=&quot;50&quot;/&gt;为负，则朝着与&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224210701819&quot; alt=&quot;&quot; width=&quot;50&quot;/&gt;的梯度相反的方向更新。换句话说，我们这里的&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224232948685&quot; alt=&quot;&quot; width=&quot;20&quot;/&gt;朝着&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224210701819&quot; alt=&quot;&quot; width=&quot;50&quot;/&gt;大的方向更新，&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135629871-1503174765.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中最左边一幅图表示score function向量，其实就是朝着使p(x)增大的方向；中间的图则是表示一个加权函数f，比方说我们的 等（值得注意的是，图中标示的score function并不是我们这里的score function，只是因为f作为一个加权，所以这样叫罢了），这个函数在除了三个小圆圈范围内的其他区域的值均为-1，小圆圈内的值为+1；最右边的图则是表明，除了在小圆圈中的区域外，其他区域对于参数的更新是与score function相反的，所以分布p(x)进行了相应更新。&lt;/p&gt;
&lt;p&gt;        前面我们说过，为了降低REINFORCE算法的方差，我们引入了Critic，现在，我们进一步使用Baseline来降低RL中的方差。首先我们可以推导出如下式子：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135708122-1477541729.png&quot; alt=&quot;&quot; width=&quot;247&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135717450-1305676646.png&quot; alt=&quot;&quot; width=&quot;236&quot; height=&quot;124&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该式表明，对于某一个与动作a无关的基准函数B(s)，它乘以score function之后，计算在策略下的期望，结果为0。换句话说，我们可以在奖励函数的梯度的基础上任意的增减一个这样的式子，而保持梯度不变。&lt;/strong&gt;一个不错的Baseline函数就是值函数是，在原奖励函数梯度的计算式上减去该值，得到：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135816506-16212600.png&quot; alt=&quot;&quot; width=&quot;299&quot; height=&quot;21&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们称&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224234635524&quot; alt=&quot;&quot; width=&quot;60&quot;/&gt;为优势函数，用其表示奖励函数的梯度为：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180224234809488&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  优势函数的意义是，在动作值函数的基础上减去了对应状态拥有的基准值，使之变为动作带来的增益，因而降低了方差（降低了由于状态基准值的抖动引起的方差）。当然，这样做也有缺点（笔者观点），那就是相当于将不同状态下的动作带来的奖励放在同一水平考虑，实质上是应该结合状态进行考虑的，关于奖励函数，我们可以结合Dueling Network进行理解与深思（提示：Dueling Network中使用双流结构，考虑了优势函数以及状态值函数，从二者的作用来看，状态值函数那一项也是有意义的）。&lt;/p&gt;
&lt;p&gt;        现在我们给出的计算优势函数的公式是理论上的，或者说是策略对应的真实优势函数，但实际上，我们并不知道该函数，因而只能对其进行估计，就像我们前面估计状态值函数和动作值函数一样：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135853663-2360441.png&quot; alt=&quot;&quot; width=&quot;273&quot; height=&quot;136&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以不断地更新&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180225000343715&quot; alt=&quot;&quot; width=&quot;40&quot;/&gt;以及&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180225000415772&quot; alt=&quot;&quot; width=&quot;60&quot;/&gt;，比方说利用TD方法进行更新，然后通过计算得到&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdn.net/20180225000525028&quot; alt=&quot;&quot; width=&quot;60&quot;/&gt;。不过令人感到不开心的是，这里我们需要维持两个逼近器，有没有方法能够让我们用一个逼近器就能够给出优势函数的估计呢？有的，具体见下面的PPT：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117135942921-21480554.png&quot; alt=&quot;&quot; width=&quot;398&quot; height=&quot;261&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中最为重要的结论是：“&lt;strong&gt;如果我们使用真实的状态值函数来计算TD error，则TD error为优势函数的一个无偏估计”&lt;/strong&gt;。并且，在这种方法中，我们仅需一组参数就能够对优势函数进行估计。&lt;/p&gt;
&lt;p&gt;        关于不同Time-Scales下的Critics、Actors以及考虑资格迹的策略梯度，鉴于其重要性，因而直接给出课程PPT如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117140048540-936854975.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;314&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117140118266-1043199580.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;315&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117140143976-1958031678.png&quot; alt=&quot;&quot; width=&quot;425&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117140211141-1993954742.png&quot; alt=&quot;&quot; width=&quot;424&quot; height=&quot;286&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自然策略梯度也即直接对原始策略梯度进行修正，乘以一个Fisher信息阵的逆。这样做有什么用处呢？它使得策略梯度变成parametrisation无关的了。举个例子，对于一个softmax策略，我们增大其中所有动作的score，此时各个动作的概率并不会发生改变，这可以通过其score function来考虑：&lt;/p&gt;

&lt;p&gt;        比方说，我们反过来想，成比例的增大策略中各个动作对应的分子，也即，因为softmax策略中的分母也会成比例的增大，所以最终各个动作的概率并没有发生改变。如果这里我们是通过增加来增加分子的值的，所以上面的score function也可能会随之增大，这样的话，虽然该策略各个动作对应的概率没有变，但是下一步对于策略的改进却发生了改变（想想对于策略参数的更新公式），这并不是我们想看到的。而自然策略梯度可以很好地解决这一问题，对于刚刚提及的这种情形，Fisher信息阵也将增大，从而使得下一步对于策略的改进与reparametrisation无关，就很开心了。&lt;br/&gt; 将自然策略梯度与Actor-Critic结合，得到Natural Actor-Critic如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181117140344318-84631845.png&quot; alt=&quot;&quot; width=&quot;505&quot; height=&quot;339&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的推导中，我们可以将compatible function approximation积分代入对于奖励函数的求导中，得到最终的奖励函数的自然梯度，发现它就等于Critic的参数w，这并不是巧合，&lt;strong&gt;当我们结合natural policy gradient + compatible function approximation之后，就可以推到得到这一结论：对Actor参数的更新就等于Critic的参数。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;总结：　&lt;/h2&gt;
&lt;p&gt;本章阐述了value-based methods和policy-based methods的优缺点，引入了性能函数J(θ) J(\mathbf \theta)J(θ)，介绍了PG定理，并详细介绍了episode case下的PG方法：REINFORCE 、REINFORCE-with-baseline(减小偏差，但方差较大)。介绍了结合PG 和value-based methods的Actor{Critic Methods，以及 continuing case下的PG。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Nov 2018 06:16:00 +0000</pubDate>
<dc:creator>SongHL</dc:creator>
<og:description>一.前言 之前我们讨论的所有问题都是先学习action value,再根据action value 来选择action(无论是根据greedy policy选择使得action value 最大的ac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songorz/p/9973792.html</dc:identifier>
</item>
<item>
<title>【.NET Core项目实战-统一认证平台】第六章 网关篇-自定义客户端授权 - 金焰的世界</title>
<link>http://www.cnblogs.com/jackcao/p/9973765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackcao/p/9973765.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;上篇文章我们介绍了网关使用&lt;code&gt;Redis&lt;/code&gt;进行缓存，并介绍了如何进行缓存实现，缓存信息清理接口的使用。本篇我们将介绍如何实现网关自定义客户端授权，实现可以为不同的接入客户端设置不同的访问权限。&lt;/p&gt;
&lt;p&gt;.netcore项目实战交流群（637326624），有兴趣的朋友可以在群里交流讨论。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;网关重点功能之一鉴权，需要实现对不同的客户端进行授权访问，禁止访问未经授权的路由地址，且需要对无权访问的请求，返回通用的格式。&lt;br/&gt;比如网关有1-10个可用路由，客户端A只能访问1-5，客户端B只能访问6-10，这时我们就无法通过&lt;code&gt;Ocelot&lt;/code&gt;配置授权来进行自定义认证，这块就需要我们增加自定义的认证管道来实现功能，尽量不影响网关已有的功能。&lt;/p&gt;
&lt;p&gt;下面我们就该功能如何实现展开讲解，希望大家先理解下功能需求，然后在延伸到具体实现。&lt;/p&gt;

&lt;p&gt;我在&lt;a href=&quot;https://www.cnblogs.com/jackcao/p/9942561.html&quot;&gt;第三章 网关篇-数据库存储配置（1）&lt;/a&gt;中讲解了我们网关配置信息设计，本篇将在那个基础上增加客户端认证需要用到的表的相关设计，设计客户端授权结构如下。其中客户端使用的&lt;code&gt;IdentityServer4&lt;/code&gt;客户端表结构。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201811/1529926-20181117140503083-1609617502.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设计好概念模型后，我们生成物理模型，然后生成数据库脚本。&lt;/p&gt;
&lt;p&gt;设计思想为可以添加自定义的授权组，为每一个授权分配能够访问的路由，然后为网关授权的客户端分配一个或多个授权组，每次客户端请求时，如果路由设置了授权访问，就校验客户端是否存在路由访问权限，如果无访问权限，直接返回401未授权提醒。&lt;/p&gt;
&lt;p&gt;感觉是不是很简单呢？有了这个自定义的客户端认证，那么我们后端服务可以专注于自己的业务逻辑而无需再过多了进行权限处理了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、功能开启配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网关应该支持自定义客户端授权中间件是否启用，因为一些小型项目是不需要对每个客户端进行单独授权的，中型和大型项目才有可能遇到自定义配置情况，所以我们需要在配置文件增加配置选项。在&lt;code&gt;AhphOcelotConfiguration.cs&lt;/code&gt;配置类中增加属性，默认不开启,而且需要知道客户端标识名称。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-11-15
/// 是否启用客户端授权,默认不开启
/// &amp;lt;/summary&amp;gt;
public bool ClientAuthorization { get; set; } = false;

/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-11-15
/// 客户端授权缓存时间，默认30分钟
/// &amp;lt;/summary&amp;gt;
public int ClientAuthorizationCacheTime { get; set; } = 1800;
/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-11-15
/// 客户端标识，默认 client_id
/// &amp;lt;/summary&amp;gt;
public string ClientKey { get; set; } = &quot;client_id&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那我们如何把自定义的授权增加到网关流程里呢？这块我们就需要订制自己的授权中间件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、实现客户端授权中间件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们定义一个自定义授权中间件&lt;code&gt;AhphAuthenticationMiddleware&lt;/code&gt;，需要继承&lt;code&gt;OcelotMiddleware&lt;/code&gt;，然后我们要实现&lt;code&gt;Invoke&lt;/code&gt;方法，详细代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Ctr.AhphOcelot.Configuration;
using Microsoft.AspNetCore.Http;
using Ocelot.Configuration;
using Ocelot.Logging;
using Ocelot.Middleware;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;

namespace Ctr.AhphOcelot.Authentication.Middleware
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-11-15
    /// 自定义授权中间件
    /// &amp;lt;/summary&amp;gt;
    public class AhphAuthenticationMiddleware : OcelotMiddleware
    {
        private readonly OcelotRequestDelegate _next;
        private readonly AhphOcelotConfiguration _options;
        private readonly IAhphAuthenticationProcessor _ahphAuthenticationProcessor;
        public AhphAuthenticationMiddleware(OcelotRequestDelegate next,
            IOcelotLoggerFactory loggerFactory,
            IAhphAuthenticationProcessor ahphAuthenticationProcessor,
            AhphOcelotConfiguration options)
            : base(loggerFactory.CreateLogger&amp;lt;AhphAuthenticationMiddleware&amp;gt;())
        {
            _next = next;
            _ahphAuthenticationProcessor = ahphAuthenticationProcessor;
            _options = options;
        }

        public async Task Invoke(DownstreamContext context)
        {
            if (!context.IsError &amp;amp;&amp;amp; context.HttpContext.Request.Method.ToUpper() != &quot;OPTIONS&quot; &amp;amp;&amp;amp; IsAuthenticatedRoute(context.DownstreamReRoute))
            {
                if (!_options.ClientAuthorization)
                {
                    Logger.LogInformation($&quot;未启用客户端授权管道&quot;);
                    await _next.Invoke(context);
                }
                else
                {
                    Logger.LogInformation($&quot;{context.HttpContext.Request.Path} 是认证路由. {MiddlewareName} 开始校验授权信息&quot;);
                    #region 提取客户端ID
                    var clientId = &quot;client_cjy&quot;;
                    var path = context.DownstreamReRoute.UpstreamPathTemplate.OriginalValue; //路由地址
                    var clientClaim = context.HttpContext.User.Claims.FirstOrDefault(p =&amp;gt; p.Type == _options.ClientKey);
                    if (!string.IsNullOrEmpty(clientClaim?.Value))
                    {//从Claims中提取客户端id
                        clientId = clientClaim?.Value;
                    }
                    #endregion
                    if (await _ahphAuthenticationProcessor.CheckClientAuthenticationAsync(clientId, path))
                    {
                        await _next.Invoke(context);
                    }
                    else
                    {//未授权直接返回错误
                        var errResult = new ErrorResult() { errcode=401, errmsg= &quot;请求地址未授权&quot; };
                        var message = errResult.ToJson();
                        context.HttpContext.Response.StatusCode = (int)HttpStatusCode.OK;
                        await context.HttpContext.Response.WriteAsync(message);
                        return;
                    }
                }
            }
            else
            {
                await _next.Invoke(context);
            }

        }
        private static bool IsAuthenticatedRoute(DownstreamReRoute reRoute)
        {
            return reRoute.IsAuthenticated;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这个中间件，那么如何添加到Ocelot的管道里呢？这里就需要查看Ocelot源代码了，看是如何实现管道调用的，&lt;code&gt;OcelotMiddlewareExtensions&lt;/code&gt;实现管道部分如下,&lt;code&gt;BuildOcelotPipeline&lt;/code&gt;里具体的流程。其实我在之前的Ocelot源码解读里也讲解过原理了，奈斯，既然找到了，那么我们就加入我们自定义的授权中间件即可。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static async Task&amp;lt;IApplicationBuilder&amp;gt; UseOcelot(this IApplicationBuilder builder, OcelotPipelineConfiguration pipelineConfiguration)
{
    var configuration = await CreateConfiguration(builder);

    ConfigureDiagnosticListener(builder);

    return CreateOcelotPipeline(builder, pipelineConfiguration);
}

private static IApplicationBuilder CreateOcelotPipeline(IApplicationBuilder builder, OcelotPipelineConfiguration pipelineConfiguration)
{
    var pipelineBuilder = new OcelotPipelineBuilder(builder.ApplicationServices);

    pipelineBuilder.BuildOcelotPipeline(pipelineConfiguration);

    var firstDelegate = pipelineBuilder.Build();

    /*
            inject first delegate into first piece of asp.net middleware..maybe not like this
            then because we are updating the http context in ocelot it comes out correct for
            rest of asp.net..
            */

    builder.Properties[&quot;analysis.NextMiddlewareName&quot;] = &quot;TransitionToOcelotMiddleware&quot;;

    builder.Use(async (context, task) =&amp;gt;
                {
                    var downstreamContext = new DownstreamContext(context);
                    await firstDelegate.Invoke(downstreamContext);
                });

    return builder;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加使用自定义授权中间件扩展&lt;code&gt;AhphAuthenticationMiddlewareExtensions&lt;/code&gt;，代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Ocelot.Middleware.Pipeline;
using System;
using System.Collections.Generic;
using System.Text;

namespace Ctr.AhphOcelot.Authentication.Middleware
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-11-15
    /// 使用自定义授权中间件
    /// &amp;lt;/summary&amp;gt;
    public static class AhphAuthenticationMiddlewareExtensions
    {
        public static IOcelotPipelineBuilder UseAhphAuthenticationMiddleware(this IOcelotPipelineBuilder builder)
        {
            return builder.UseMiddleware&amp;lt;AhphAuthenticationMiddleware&amp;gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这个中间件扩展后，我们就在管道的合适地方加入我们自定义的中间件。我们添加我们自定义的管道扩展&lt;code&gt;OcelotPipelineExtensions&lt;/code&gt;，然后把自定义授权中间件加入到认证之后。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
using System.Threading.Tasks;
using Ctr.AhphOcelot.Authentication.Middleware;
using Ocelot.Authentication.Middleware;
using Ocelot.Authorisation.Middleware;
using Ocelot.Cache.Middleware;
using Ocelot.Claims.Middleware;
using Ocelot.DownstreamRouteFinder.Middleware;
using Ocelot.DownstreamUrlCreator.Middleware;
using Ocelot.Errors.Middleware;
using Ocelot.Headers.Middleware;
using Ocelot.LoadBalancer.Middleware;
using Ocelot.Middleware;
using Ocelot.Middleware.Pipeline;
using Ocelot.QueryStrings.Middleware;
using Ocelot.RateLimit.Middleware;
using Ocelot.Request.Middleware;
using Ocelot.Requester.Middleware;
using Ocelot.RequestId.Middleware;
using Ocelot.Responder.Middleware;
using Ocelot.WebSockets.Middleware;

namespace Ctr.AhphOcelot.Middleware
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-11-15
    /// 网关管道扩展
    /// &amp;lt;/summary&amp;gt;
    public static class OcelotPipelineExtensions
    {
        public static OcelotRequestDelegate BuildAhphOcelotPipeline(this IOcelotPipelineBuilder builder,
            OcelotPipelineConfiguration pipelineConfiguration)
        {
            // This is registered to catch any global exceptions that are not handled
            // It also sets the Request Id if anything is set globally
            builder.UseExceptionHandlerMiddleware();

            // If the request is for websockets upgrade we fork into a different pipeline
            builder.MapWhen(context =&amp;gt; context.HttpContext.WebSockets.IsWebSocketRequest,
                app =&amp;gt;
                {
                    app.UseDownstreamRouteFinderMiddleware();
                    app.UseDownstreamRequestInitialiser();
                    app.UseLoadBalancingMiddleware();
                    app.UseDownstreamUrlCreatorMiddleware();
                    app.UseWebSocketsProxyMiddleware();
                });

            // Allow the user to respond with absolutely anything they want.
            builder.UseIfNotNull(pipelineConfiguration.PreErrorResponderMiddleware);

            // This is registered first so it can catch any errors and issue an appropriate response
            builder.UseResponderMiddleware();

            // Then we get the downstream route information
            builder.UseDownstreamRouteFinderMiddleware();

            //Expand other branch pipes
            if (pipelineConfiguration.MapWhenOcelotPipeline != null)
            {
                foreach (var pipeline in pipelineConfiguration.MapWhenOcelotPipeline)
                {
                    builder.MapWhen(pipeline);
                }
            }

            // Now we have the ds route we can transform headers and stuff?
            builder.UseHttpHeadersTransformationMiddleware();

            // Initialises downstream request
            builder.UseDownstreamRequestInitialiser();

            // We check whether the request is ratelimit, and if there is no continue processing
            builder.UseRateLimiting();

            // This adds or updates the request id (initally we try and set this based on global config in the error handling middleware)
            // If anything was set at global level and we have a different setting at re route level the global stuff will be overwritten
            // This means you can get a scenario where you have a different request id from the first piece of middleware to the request id middleware.
            builder.UseRequestIdMiddleware();

            // Allow pre authentication logic. The idea being people might want to run something custom before what is built in.
            builder.UseIfNotNull(pipelineConfiguration.PreAuthenticationMiddleware);

            // Now we know where the client is going to go we can authenticate them.
            // We allow the ocelot middleware to be overriden by whatever the
            // user wants
            if (pipelineConfiguration.AuthenticationMiddleware == null)
            {
                builder.UseAuthenticationMiddleware();
            }
            else
            {
                builder.Use(pipelineConfiguration.AuthenticationMiddleware);
            }

            //添加自定义授权中间 2018-11-15 金焰的世界
            builder.UseAhphAuthenticationMiddleware();

            // Allow pre authorisation logic. The idea being people might want to run something custom before what is built in.
            builder.UseIfNotNull(pipelineConfiguration.PreAuthorisationMiddleware);

            // Now we have authenticated and done any claims transformation we 
            // can authorise the request
            // We allow the ocelot middleware to be overriden by whatever the
            // user wants
            if (pipelineConfiguration.AuthorisationMiddleware == null)
            {
                builder.UseAuthorisationMiddleware();
            }
            else
            {
                builder.Use(pipelineConfiguration.AuthorisationMiddleware);
            }

            // Allow the user to implement their own query string manipulation logic
            builder.UseIfNotNull(pipelineConfiguration.PreQueryStringBuilderMiddleware);

            // Get the load balancer for this request
            builder.UseLoadBalancingMiddleware();

            // This takes the downstream route we retrieved earlier and replaces any placeholders with the variables that should be used
            builder.UseDownstreamUrlCreatorMiddleware();

            // Not sure if this is the best place for this but we use the downstream url 
            // as the basis for our cache key.
            builder.UseOutputCacheMiddleware();

            //We fire off the request and set the response on the scoped data repo
            builder.UseHttpRequesterMiddleware();

            return builder.Build();
        }

        private static void UseIfNotNull(this IOcelotPipelineBuilder builder,
            Func&amp;lt;DownstreamContext, Func&amp;lt;Task&amp;gt;, Task&amp;gt; middleware)
        {
            if (middleware != null)
            {
                builder.Use(middleware);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这个自定义的管道扩展后，我们需要应用到网关启动里，修改我们创建管道的方法如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private static IApplicationBuilder CreateOcelotPipeline(IApplicationBuilder builder, OcelotPipelineConfiguration pipelineConfiguration)
{
    var pipelineBuilder = new OcelotPipelineBuilder(builder.ApplicationServices);

    //pipelineBuilder.BuildOcelotPipeline(pipelineConfiguration);
    //使用自定义管道扩展 2018-11-15 金焰的世界
    pipelineBuilder.BuildAhphOcelotPipeline(pipelineConfiguration);

    var firstDelegate = pipelineBuilder.Build();

    /*
            inject first delegate into first piece of asp.net middleware..maybe not like this
            then because we are updating the http context in ocelot it comes out correct for
            rest of asp.net..
            */

    builder.Properties[&quot;analysis.NextMiddlewareName&quot;] = &quot;TransitionToOcelotMiddleware&quot;;

    builder.Use(async (context, task) =&amp;gt;
                {
                    var downstreamContext = new DownstreamContext(context);
                    await firstDelegate.Invoke(downstreamContext);
                });

    return builder;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们完成了网关的扩展和应用，但是是否注意到了，我们的网关接口还未实现呢？什么接口呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IAhphAuthenticationProcessor&lt;/code&gt;这个接口虽然定义了，但是一直未实现，现在开始我们要实现下这个接口，我们回看下我们使用这个接口的什么方法，就是检查客户端是否有访问路由的权限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、结合数据库实现校验及缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次请求都需要校验客户端是否授权，如果不缓存此热点数据，那么对网关开销很大，所以我们需要增加缓存。&lt;/p&gt;
&lt;p&gt;新建&lt;code&gt;AhphAuthenticationProcessor&lt;/code&gt;类来实现认证接口，代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Ctr.AhphOcelot.Configuration;
using Ocelot.Cache;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;

namespace Ctr.AhphOcelot.Authentication
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-11-15
    /// 实现自定义授权处理器逻辑
    /// &amp;lt;/summary&amp;gt;
    public class AhphAuthenticationProcessor : IAhphAuthenticationProcessor
    {
        private readonly IClientAuthenticationRepository _clientAuthenticationRepository;
        private readonly AhphOcelotConfiguration _options;
        private readonly IOcelotCache&amp;lt;ClientRoleModel&amp;gt; _ocelotCache;
        public AhphAuthenticationProcessor(IClientAuthenticationRepository clientAuthenticationRepository, AhphOcelotConfiguration options, IOcelotCache&amp;lt;ClientRoleModel&amp;gt; ocelotCache)
        {
            _clientAuthenticationRepository = clientAuthenticationRepository;
            _options = options;
            _ocelotCache = ocelotCache;
        }
        /// &amp;lt;summary&amp;gt;
        /// 校验当前的请求地址客户端是否有权限访问
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;clientid&quot;&amp;gt;客户端ID&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;path&quot;&amp;gt;请求地址&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;bool&amp;gt; CheckClientAuthenticationAsync(string clientid, string path)
        {
            var enablePrefix = _options.RedisKeyPrefix + &quot;ClientAuthentication&quot;;
            var key = AhphOcelotHelper.ComputeCounterKey(enablePrefix, clientid, &quot;&quot;, path);
            var cacheResult = _ocelotCache.Get(key, enablePrefix);
            if (cacheResult!=null)
            {//提取缓存数据
                return cacheResult.Role;
            }
            else
            {//重新获取认证信息
                var result = await _clientAuthenticationRepository.ClientAuthenticationAsync(clientid, path);
                  //添加到缓存里
                  _ocelotCache.Add(key, new ClientRoleModel() { CacheTime = DateTime.Now,Role=result }, TimeSpan.FromMinutes(_options.ClientAuthorizationCacheTime), enablePrefix);
                return result;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码很简单，就是从缓存中查找看是否有数据，如果存在直接返回，如果不存在，就从仓储中提取访问权限，然后写入缓存，写入缓存的时间可由配置文件写入，默认为30分钟，可自行根据业务需要修改。&lt;/p&gt;
&lt;p&gt;现在我们还需要解决2个问题，这个中间件才能正常运行，第一&lt;code&gt;IClientAuthenticationRepository&lt;/code&gt;接口未实现和注入；第二&lt;code&gt;IOcelotCache&amp;lt;ClientRoleModel&amp;gt;&lt;/code&gt;未注入，那我们接下来实现这两块，然后就可以测试我们第一个中间件啦。&lt;/p&gt;
&lt;p&gt;新建&lt;code&gt;SqlServerClientAuthenticationRepository&lt;/code&gt;类，来实现&lt;code&gt;IClientAuthenticationRepository&lt;/code&gt;接口，实现代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Ctr.AhphOcelot.Authentication;
using Ctr.AhphOcelot.Configuration;
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Text;
using System.Threading.Tasks;
using Dapper;
namespace Ctr.AhphOcelot.DataBase.SqlServer
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-11-16
    /// 使用sqlserver实现客户端授权仓储
    /// &amp;lt;/summary&amp;gt;
    public class SqlServerClientAuthenticationRepository : IClientAuthenticationRepository
    {
        private readonly AhphOcelotConfiguration _option;
        public SqlServerClientAuthenticationRepository(AhphOcelotConfiguration option)
        {
            _option = option;
        }
        /// &amp;lt;summary&amp;gt;
        /// 校验获取客户端是否有访问权限
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;clientid&quot;&amp;gt;客户端ID&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;path&quot;&amp;gt;请求路由&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;bool&amp;gt; ClientAuthenticationAsync(string clientid, string path)
        {
            using (var connection = new SqlConnection(_option.DbConnectionStrings))
            {
                string sql = @&quot;SELECT COUNT(1) FROM  AhphClients T1 INNER JOIN AhphClientGroup T2 ON T1.Id=T2.Id INNER JOIN AhphAuthGroup T3 ON T2.GroupId = T3.GroupId INNER JOIN AhphReRouteGroupAuth T4 ON T3.GroupId = T4.GroupId INNER JOIN AhphReRoute T5 ON T4.ReRouteId = T5.ReRouteId WHERE Enabled = 1 AND ClientId = @ClientId AND T5.InfoStatus = 1 AND UpstreamPathTemplate = @Path&quot;;
                var result= await connection.QueryFirstOrDefaultAsync&amp;lt;int&amp;gt;(sql, new { ClientId = clientid, Path = path });
                return result &amp;gt; 0 ? true : false;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在需要注入下实现，这块应该都知道在哪里加入了吧？没错&lt;code&gt;ServiceCollectionExtensions&lt;/code&gt;扩展又用到啦，现在梳理下流程感觉是不是很清晰呢？&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;builder.Services.AddSingleton&amp;lt;IClientAuthenticationRepository, SqlServerClientAuthenticationRepository&amp;gt;();

builder.Services.AddSingleton&amp;lt;IAhphAuthenticationProcessor, AhphAuthenticationProcessor&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再添加缓存的注入实现，到此我们的第一个中间件全部添加完毕了，现在可以开始测试我们的中间件啦。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;builder.Services.AddSingleton&amp;lt;IOcelotCache&amp;lt;ClientRoleModel&amp;gt;, InRedisCache&amp;lt;ClientRoleModel&amp;gt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4、测试授权中间件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先在数据库插入客户端授权脚本，脚本如下。&lt;/p&gt;
&lt;pre class=&quot;mssql&quot;&gt;
&lt;code&gt;--插入测试客户端
INSERT INTO AhphClients(ClientId,ClientName) VALUES('client1','测试客户端1')
INSERT INTO AhphClients(ClientId,ClientName) VALUES('client2','测试客户端2')
--插入测试授权组
INSERT INTO AhphAuthGroup VALUES('授权组1','只能访问/cjy/values路由',1);
INSERT INTO AhphAuthGroup VALUES('授权组2','能访问所有路由',1);

--插入测试组权限
INSERT INTO AhphReRouteGroupAuth VALUES(1,1);

INSERT INTO AhphReRouteGroupAuth VALUES(2,1);
INSERT INTO AhphReRouteGroupAuth VALUES(2,2);

--插入客户端授权
INSERT INTO AhphClientGroup VALUES(1,1);
INSERT INTO AhphClientGroup VALUES(2,2);

--设置测试路由只有授权才能访问
UPDATE AhphReRoute SET AuthenticationOptions='{&quot;AuthenticationProviderKey&quot;: &quot;TestKey&quot;}' WHERE ReRouteId IN(1,2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这块设置了客户端2可以访问路由&lt;code&gt;/cjy/values&lt;/code&gt;,客户端1可以访问路由&lt;code&gt;/cjy/values 和 /ctr/values/{id}&lt;/code&gt;，开始使用&lt;code&gt;PostMan&lt;/code&gt;来测试这个中间件看是否跟我设置的一毛一样，各种&lt;code&gt;dotnet run&lt;/code&gt;启动吧。启动前别忘了在我们网关配置文件里，设置启动客户端授权 &lt;code&gt;option.ClientAuthorization = true;&lt;/code&gt;，是不是很简单呢？&lt;/p&gt;
&lt;p&gt;为了测试授权效果，我们需要把网关项目增加认证，详细看代码，里面就是定义了授权认证，启动我们默认的认证地址。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var authenticationProviderKey = &quot;TestKey&quot;;
Action&amp;lt;IdentityServerAuthenticationOptions&amp;gt; gatewayoptions = o =&amp;gt;
{
o.Authority = &quot;http://localhost:6611&quot;;
o.ApiName = &quot;gateway&quot;;
o.RequireHttpsMetadata = false;
};

services.AddAuthentication()
.AddIdentityServerAuthentication(authenticationProviderKey, gatewayoptions);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下，达到我们预期目的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201811/1529926-20181117140544634-369963760.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201811/1529926-20181117140552435-624040497.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201811/1529926-20181117140558058-155428586.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;终于完成了我们的自定义客户端授权啦，此处应该掌声不断。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;5、增加mysql支持&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看过我前面的文章应该知道，支持&lt;code&gt;mysql&lt;/code&gt;太简单啦，直接重写&lt;code&gt;IClientAuthenticationRepository&lt;/code&gt;实现，然后注入到&lt;code&gt;UseMySql&lt;/code&gt;里，问题就解决啦。感觉是不是不可思议，这就是&lt;code&gt;.netcore&lt;/code&gt;的魅力，简单到我感觉到我再贴代码就是侮辱智商一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、重构认证失败输出，保持与Ocelot一致风格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面我们定义了未授权使用自定义的&lt;code&gt;ClientRoleModel&lt;/code&gt;输出，最后发现这样太不优雅啦，我们需要简单重构下，来保持与&lt;code&gt;Ocelot&lt;/code&gt;默认管道一致风格，修改代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//var errResult = new ErrorResult() { errcode=401, errmsg= &quot;请求地址未授权&quot; };
//var message = errResult.ToJson();
//context.HttpContext.Response.StatusCode = (int)HttpStatusCode.OK;
//await context.HttpContext.Response.WriteAsync(message);
//return;
var error = new UnauthenticatedError($&quot;请求认证路由 {context.HttpContext.Request.Path}客户端未授权&quot;);
Logger.LogWarning($&quot;路由地址 {context.HttpContext.Request.Path} 自定义认证管道校验失败. {error}&quot;);
SetPipelineError(context, error);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再测试下未授权，返回状态为401，强迫症患者表示舒服多了。&lt;/p&gt;

&lt;p&gt;本篇我们讲解的是网关如何实现自定义客户端授权功能，从设计到实现一步一步详细讲解，虽然只用一篇就写完了，但是涉及的知识点还是非常多的，希望大家认真理解实现的思想，看我是如何从规划到实现的，为了更好的帮助大家理解，从本篇开始，我的源代码都是一个星期以后再开源，大家可以根据博客内容自己手动实现下，有利于消化，如果在操作中遇到什么问题，可以加&lt;code&gt;.NET Core项目实战交流群（QQ群号：637326624）&lt;/code&gt;咨询作者。&lt;/p&gt;
&lt;p&gt;下一篇开始讲解自定义客户端限流，在学习下篇前可以自己先了解下限流相关内容，然后自己试着实现看看，带着问题学习可能事半功倍哦。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Nov 2018 06:06:00 +0000</pubDate>
<dc:creator>金焰的世界</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackcao/p/9973765.html</dc:identifier>
</item>
<item>
<title>一文读懂拥塞控制 - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/9973757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/9973757.html</guid>
<description>&lt;p&gt;大家可能都听说过拥塞控制和流量控制，想必也有一些人可能还分不清拥塞控制和流量控制，进而把他们当作一回事。拥塞控制和流量控制虽然采取的动作很相似，但拥塞控制与网络的拥堵情况相关联，而流量控制与接收方的缓存状态相关联。&lt;/p&gt;

&lt;p&gt;也就是说，拥塞控制和流量控制是针对完全不同的问题而采取的措施。今天这篇文章，我们先来讲讲拥塞控制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、为何要进行拥塞控制？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了方便，我们假设主机A给主机B传输数据。&lt;/p&gt;

&lt;p&gt;我们知道，两台主机在传输数据包的时候，如果发送方迟迟没有收到接收方反馈的ACK，那么发送方就会认为它发送的数据包丢失了，进而会重新传输这个丢失的数据包。&lt;/p&gt;

&lt;p&gt;然而实际情况有可能此时有太多主机正在使用信道资源，导致网络拥塞了，而A发送的数据包被堵在了半路，迟迟没有到达B。这个时候A误认为是发生了丢包情况，会重新传输这个数据包。&lt;/p&gt;

&lt;p&gt;结果就是不仅浪费了信道资源，还会使网络更加拥塞。因此，我们需要进行拥塞控制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、如何知道网络的拥塞情况？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A与B建立连接之后，就可以向B发送数据了，然而这个时候A并不知道此时的网络拥塞情况如何，也就是说，A不知道一次性连续发送多少个数据包好，我们也把A一次性连续发送多少个数据包称之为拥塞窗口，用N代表此时拥塞窗口的大小吧。&lt;/p&gt;

&lt;p&gt;为了探测网络的拥塞情况，我们可以采取以下两种策略：&lt;/p&gt;

&lt;p&gt;1、先发送一个数据包试探下，如果该数据包没有发生超时事件(也就是没有丢包)。那么下次发送时就发送2个，如果还是没有发生超时事件，下次就发送3个，以此类推，即N = 1, 2, 3, 4, 5.....&lt;/p&gt;
&lt;p&gt; (如果图片失效了，请到我的公众号阅读：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNzg0MDc1Mg==&amp;amp;mid=2247484586&amp;amp;idx=1&amp;amp;sn=dd2e533f0d9c248726f71be3604b2a18&amp;amp;chksm=f9934eb5cee4c7a35e56c13e62ea2fd0c661f2f9977d1170c6c661ad6fcc3af8c94367232ebb&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;5分钟读懂拥塞控制&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCt8lO9cYZz8Qx0F63LpIoSDA0G4zbXAwYyFjHVod86BGibAIBFfNmufGw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.8081023454157783&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCt8lO9cYZz8Qx0F63LpIoSDA0G4zbXAwYyFjHVod86BGibAIBFfNmufGw/640&quot; data-type=&quot;png&quot; data-w=&quot;938&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;                (图可能画的不大形象，，，，)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;2、一个一个增加实在是太慢了，所以可以刚开始发送1个，如果没有发生超时时间，就发送2个，如果还是没有发送超时事件就发送4个，接着8个...，用翻倍的速度类推,即 N = 1, 2, 4, 8, 16...&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCtvNlQB05tKiaTcmLKe8WJNNvqsZrtZwy3LTLVhtgcBJ86KDe8AmqlaDw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.8508891928864569&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCtvNlQB05tKiaTcmLKe8WJNNvqsZrtZwy3LTLVhtgcBJ86KDe8AmqlaDw/640&quot; data-type=&quot;png&quot; data-w=&quot;731&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;


&lt;p&gt;无论是第一种方法还是第二种方法，最后都会出现瓶颈值。不过这里值得注意的是，第一种情况的增长速率确实有点慢，但是第二种情况以指数增长，增长速度有点太快了，可能一下子就到瓶颈值了。&lt;/p&gt;

&lt;p&gt;为了解决这个过慢或过快的问题，我们可以把第一种方法和第二种方法结合起来。也就是说，我们刚开始可以以指数的速度增长，增长到某一个值，我们把这个值称之为阈值吧，用变量ssthresh代替。当增长到阈值时，我们就不在以指数增长了，而是一个一个线性增长。&lt;/p&gt;

&lt;p&gt;所以最终的策略是：前期指数增长，到达阈值之后，就以一个一个线性的速度来增长。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCtda8gvTBT83203IrJnaG5o2HiaF9msMFeoGF0juglpjbp7aqeGLDEZlA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.727164887307236&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCtda8gvTBT83203IrJnaG5o2HiaF9msMFeoGF0juglpjbp7aqeGLDEZlA/640&quot; data-type=&quot;png&quot; data-w=&quot;843&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(注：8之后其实是直线的，那里只是弯曲了一下)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们也把指数增长阶段称之为慢启动，线性增长阶段称之为拥塞避免&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;三、到了瓶颈值之后怎么办？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;无论是指数增长还是一个一个增长，最终肯定会出现超时事件，总不可能无限增长吧。当出现超时事件时，我们就认为此时网络出现了拥塞了，不能再继续增长了。我们就把这个时候的N的值称之为瓶颈值吧，用MAX这个字母来代替吧，即最大值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCt9LuGClICpGibcGicOjGIksLLdGj8Wt9HbcYRPPrClGITFUlPugytW8sQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.7420537897310513&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCt9LuGClICpGibcGicOjGIksLLdGj8Wt9HbcYRPPrClGITFUlPugytW8sQ/640&quot; data-type=&quot;png&quot; data-w=&quot;818&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：这里再次提醒阈值过后是一个一个线性增长，图中之所以弯曲是因为我画图原因导致的。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;当达到最大值MAX之后，我们该怎么办呢？&lt;/p&gt;

&lt;p&gt;当到达最大值之后我们采取的策略是这样的：&lt;/p&gt;

&lt;p&gt;我们就回到最初的最初的状态，也就是说从1，2，4，8.....开始,不过这个时候我们还会把ssthresh调小，调为MAX值的一半，即ssthresh = MAX / 2。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCt9jiadVaGgCep8YSFSXXnl8IVVvDjVMwWCNfZQYibEGXZOOrzf6vibmaaA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.783989834815756&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCt9jiadVaGgCep8YSFSXXnl8IVVvDjVMwWCNfZQYibEGXZOOrzf6vibmaaA/640&quot; data-type=&quot;png&quot; data-w=&quot;787&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中阈值为8，瓶颈值是14；超时事件发生后，阈值为14 / 2 = 7。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、超时事件就一定是网络拥塞？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;超时事件发送就一定是网络出现了拥堵吗？其实也有可能不是出现了网络拥堵，有可能是因为某个数据包出现了丢失或者损害了，导致了这个数据包超时事件发生了&lt;/p&gt;

&lt;p&gt;为了防止这种情况，我们是通过冗余ACK来处理的。我们都知道，数据包是有序号的，如果A给B发送M1, M2, M3, M4, M5...N个数据包，如果B收到了M1, M2, M4....却始终没有收到M3，这个时候就会重复确认M2，意在告诉A,M3还没收到，可能是丢失了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCtukuqbPb3U4namqva9qjgVhU7qfXOP2ZpGZSJzxgaZHKVbwCUic1UODQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.7637362637362637&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCtukuqbPb3U4namqva9qjgVhU7qfXOP2ZpGZSJzxgaZHKVbwCUic1UODQ/640&quot; data-type=&quot;png&quot; data-w=&quot;728&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;


&lt;p&gt;当A连续收到了三个确认M2的ACK，且M3超时事件还没发生。A就知道M3可能丢失了，这个时候A就不必等待M3设置的计时器到期了，而是快速重传M3。并且把ssthresh设置为MAX的一半，即ssthresh = MAX/2，但是这个时候并非把控制窗口N设置为1，而是让N = ssthresh，N在一个一个增长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCtMdCzqZ7HnmbFwA5EZ8h6vMrQsqxVWxsWmy70TZkjlvm8B82cDEQ17w/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.745742092457421&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINfuKCKn8IwibwelDSLQibRCtMdCzqZ7HnmbFwA5EZ8h6vMrQsqxVWxsWmy70TZkjlvm8B82cDEQ17w/640&quot; data-type=&quot;png&quot; data-w=&quot;822&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们也把这种情况称之为快速恢复。而这种具有快速恢复的TCP版本称之为TCP Reno。&lt;/p&gt;

&lt;p&gt;还有另外一种TCP版本，无论是收到三个相同的ACK还是发生超时事件，都把拥塞窗口的大小设为1，从最初状态开始，这种版本的TCP我们称之为TCP Tahoe。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;偷偷透露一下，由于第一次画这种图，这几个图画了差不多两个小时，也是醉了。&lt;/p&gt;

&lt;p&gt;下一次可能会将流量控制，敬请期待，如何有什么建议可以后台留言提哈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNzg0MDc1Mg==&amp;amp;mid=2247484563&amp;amp;idx=1&amp;amp;sn=830702b545d2fc01f39aab33e3e2c766&amp;amp;chksm=f9934e8ccee4c79a950ddb868654b2b5ff5b17e3dce5e802eb80bd9cb77aae376994b4f5bdb0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;4个月文章汇总，赶紧来收藏一波&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNzg0MDc1Mg==&amp;amp;mid=2247484556&amp;amp;idx=1&amp;amp;sn=c1de2e3dceb78ee85fa83914422a90d4&amp;amp;chksm=f9934e93cee4c78518caa8bd9defa714cbf8b9281ebb5e50bde2763cd0545a3e369732d026b0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;一些常用的算法技巧总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNzg0MDc1Mg==&amp;amp;mid=2247484538&amp;amp;idx=1&amp;amp;sn=9e2c6bad1a4958c5c717aa5857176981&amp;amp;chksm=f9934e65cee4c773f32d3d6ffe559d8620260765efb7f9e6cecd6f3661fe113657fb2d281f18&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;【漫画】两台陌生的主机是如何保证数据正确交付的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNzg0MDc1Mg==&amp;amp;mid=2247484456&amp;amp;idx=1&amp;amp;sn=13eda1297e0006bdbe6e4efcb605061f&amp;amp;chksm=f9934e37cee4c721cb0513546df0140e710db0f5fbe63350473c021a3836fc8cfacdbcc97fc5&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;【漫画】https 加密那点事&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNzg0MDc1Mg==&amp;amp;mid=2247484395&amp;amp;idx=1&amp;amp;sn=11262d022b66b3891c6dc4691c128c85&amp;amp;chksm=f99349f4cee4c0e2cfcc5aa7763b23b0a3771e6edb549906339bfd52575f081ed7da6b3dc180&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;【漫画】以后在有面试官问你AVL树，你就把这篇文章扔给他&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多原创文章可以关注我的公众号：&lt;strong&gt;苦逼的码农&lt;/strong&gt;(ID:201805)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1122091/201811/1122091-20181117140153323-1442839228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 17 Nov 2018 06:05:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>大家可能都听说过拥塞控制和流量控制，想必也有一些人可能还分不清拥塞控制和流量控制，进而把他们当作一回事。拥塞控制和流量控制虽然采取的动作很相似，但拥塞控制与网络的拥堵情况相关联，而流量控制与接收方的缓</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/9973757.html</dc:identifier>
</item>
<item>
<title>知识小罐头02 - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/9972591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/9972591.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;萌新科普文&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这次来简单说说mysql驱动，不要用了这么久的框架，突然被人问起什么叫做mysql驱动、内部怎么工作的啊，你却突然的不知道了，那就尴尬了。&lt;/p&gt;
&lt;p&gt;　　注：最好用jdk1.6（这个看DriverManager源码一目了然），mysql驱动嘛，不要用太高版本了，版本越高封装的越彻底，不利于萌新看底层原理。&lt;/p&gt;
&lt;p&gt;　　然而我并没有装1.6，于是我就到处找了一些材料加上我自己找的一些代码凑数啊！（继续偷懒。。。。）&lt;/p&gt;
&lt;p&gt;　　大家是不是对于mysql，oracle，SQL Server，DB2等数据库的其中一种或者几种用法很是熟悉了，很多的框架都会用到。&lt;/p&gt;
&lt;p&gt;　　以mysql为例，在java中连接数据库，最开始是用jdbc，想必大家对下面这几句代码很是熟悉了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181116235906120-1029338394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　首先是加载mysql驱动，然后是获取连接，很初级的代码。&lt;/p&gt;
&lt;p&gt;　　我最开始学jdbc的时候，我就纳闷了！为什么要加载驱动，驱动又是什么鬼啊？反正就只知道要想连接数据库就要下载个驱动。&lt;/p&gt;
&lt;p&gt;　　那个DriverManager是哪里来的啊？还有，这样就获取连接了，为什么这个方法就能获取连接啊？&lt;/p&gt;
&lt;p&gt;　　这种问题最是让初学者困惑不已（我就是这样的，嘿嘿）。&lt;/p&gt;
&lt;p&gt;　　其实吧，用大白话说一下，就是java里面提供了一个接口（java.sql.Driver）用于和任意的数据库连接，而mysql数据库开发商此时看到java这么火就要默默的写个实现类（就是所谓的数据库驱动），去实现这个接口，不然java语言用不了你这个数据库（那数据库的推广就会受到限制，赚的钱就少了嘛！）。&lt;/p&gt;
&lt;p&gt;　　而java中还会有一个类DriverManager，顾名思义，就是来管理别人传过来的Driver类（里面肯定有个属性是一个容器，通过类似set作用的方法把Driver的实例存起来，供其他的方法使用），这就是口述版mysql驱动的原理。&lt;/p&gt;
&lt;p&gt;　　下面来看看源码，分析分析。&lt;/p&gt;
&lt;p&gt;　　打开上图的第一个标记&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181117003001581-2014894555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　现在打开registerDriver方法，看看是怎么包装Driver实例的（jdk1.6）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181117115027483-1571829417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　也可以看看jdk1.8的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181117115823575-1677450405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们来看看DriverInfo里面有哪些属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181117120317091-428508089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　（jdk1.6）是不是发现还有一个initialize方法啊，其实这个方法简单说一下，就是遍历所有的数据库驱动（实现了java.sql.Driver的实现类），并用系统类加载器去加载。还有，在，图上还有一个writeDrivers（就是负责注册驱动）和readDrivers（注册成功的驱动复制到这里，后面要我们要用就直接来这里取）；&lt;/p&gt;
&lt;p&gt;　　因为其中涉及的东西太细了，就粗略说一下，感兴趣的小伙伴可以自己进去仔细研究啊！&lt;/p&gt;
&lt;p&gt;　　jdk1.8就不去看了，里面变化了很多算法什么的，但是大概的逻辑还是这样的。&lt;/p&gt;
&lt;p&gt;　　接下来，看看怎么通过DriverManager的静态方法去获得connection（这里我把很多判断性的代码删除了，留下一些基本逻辑）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181117132011596-2122738515.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;p&gt;　　到达这里，就差不多了，本质就是去实现类里面看实现类的connect方法，是怎么通过传递过去的过去的url、用户名、密码，最后返回给我们connection对象。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181117133010502-1487251106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　打开这个父类，看connect方法里面大概的做法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181117133343393-718283445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181117133546723-436975300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　emmmm....后面的太多了，要分析太涉及底层了，我把大概的逻辑说一下吧！就是通过socket（内部封装了io流）去链接mysql 服务端(进行三次握手)，并进行用户名和密码的校验，以及一些数据加密的工作等等， 想仔细了解的小伙伴可以自己翻看源码。&lt;/p&gt;
&lt;p&gt;　　其实，还有很多的东西，比如后面的预编译啊什么原理啊，还没说呢，咳咳，毕竟是一个给萌新科普的随笔，就不说多了，哈哈，偷个懒！&lt;/p&gt;
&lt;p&gt;　　到这里，萌新们是不是对mysql驱动了解了一点啦！&lt;/p&gt;
&lt;p&gt;　　继续说废话（嘿嘿~）：学东西要学本质才能印象深刻啊，不然睡一觉之后就忘了！比如学mysql驱动，本质就是io流+socket+类+一些基本逻辑的处理；就比如学javase的容器（list，set.,map）,本质就是Object数组和类的组合嘛！再加一些扩容等条件的判断以及一些算法，最后就叫做容器；&lt;/p&gt;

</description>
<pubDate>Sat, 17 Nov 2018 06:03:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>萌新科普文 这次来简单说说mysql驱动，不要用了这么久的框架，突然被人问起什么叫做mysql驱动、内部怎么工作的啊，你却突然的不知道了，那就尴尬了。 注：最好用jdk1.6（这个看DriverMan</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/9972591.html</dc:identifier>
</item>
<item>
<title>leetcode刷题--两数之和（简单） - DJDU</title>
<link>http://www.cnblogs.com/DJDU/p/9973267.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DJDU/p/9973267.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、序言&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　第一次刷leetcode的题，之前从来没有刷题然后去面试的概念，直到临近秋招，或许是秋招结束的时候才有这个意识，原来面试是需要刷题的，面试问的问题都是千篇一律的，只要刷够了题就差不多了，当然你的基础也要扎实，毕竟在技术面的时候很容易露馅的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以奉劝各位还未毕业，在大三或大二的师弟师妹早点刷题，心里也有底气进入求职大军，毕竟大四开始刷题的话时间上有些太紧了，推荐刷题的话就是牛客和leetcode。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　回归正题，这次记录的是leetcode刷的第一题--&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;两数之和&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二、审题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　审题真的很重要，这道题我因为审题和惯性思维的原因导致前两次都编写程序的运行结果不正确。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h4&gt;&lt;span&gt;1、整数数组和一个目标值&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　　　题目中的整数数组是可以有&lt;span&gt;负数&lt;span&gt;、&lt;/span&gt;正数&lt;/span&gt;和&lt;span&gt;零&lt;/span&gt;的，例：{-10，-15，-18,0,9,55}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　目标值可能为整数数组两数之和，意味着可以为&lt;span&gt;正数&lt;/span&gt;、&lt;span&gt;负数&lt;/span&gt;和&lt;span&gt;零&lt;/span&gt;，例：-9 、0 、10&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、同样的元素不能被重复利用&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　　　例：target=6，nums={3,2,4}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　所以&lt;/span&gt;&lt;span&gt;返回[1,2],而不是[0,0]，&lt;span&gt;3不可以重复利用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;三、解题&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、暴力法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;直接上代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] twoSum(&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] down={-1,-1&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;nums.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             down[0]=&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=i+1;j&amp;lt;nums.length;j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(nums[j]==(target-&lt;span&gt;nums[i])){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     down[1]=&lt;span&gt;j;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; down;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; down;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图分析思路：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1507988/201811/1507988-20181117130643734-1293865864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;时间复杂度：&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;O(&lt;span class=&quot;mord mathit&quot;&gt;n&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span class=&quot;pstrut&quot;&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span class=&quot;pstrut&quot;&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mclose&quot;&gt;)， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;O(n)&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mclose&quot;&gt; 的时间。因此时间复杂度为 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;O(&lt;span class=&quot;mord mathit&quot;&gt;n&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span class=&quot;pstrut&quot;&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot;&gt;&lt;span class=&quot;pstrut&quot;&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mclose&quot;&gt;)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;空间复杂度：&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;O(&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;span class=&quot;mclose&quot;&gt;)。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、两遍哈希表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　这个方法我是没有想到的，这需要记录下来，而且我数据结构不太扎实，哈希表也不是很清楚，自己分析总结一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;target - nums[i]&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;t&lt;span class=&quot;mord mathit&quot;&gt;a&lt;span class=&quot;mord mathit&quot;&gt;r&lt;span class=&quot;mord mathit&quot;&gt;g&lt;span class=&quot;mord mathit&quot;&gt;e&lt;span class=&quot;mord mathit&quot;&gt;t&lt;span class=&quot;mspace&quot;&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;span class=&quot;mspace&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;n&lt;span class=&quot;mord mathit&quot;&gt;u&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;s&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mclose&quot;&gt;]）是否存在于表中。注意，该目标元素不能是 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;nums[i]&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;n&lt;span class=&quot;mord mathit&quot;&gt;u&lt;span class=&quot;mord mathit&quot;&gt;m&lt;span class=&quot;mord mathit&quot;&gt;s&lt;span class=&quot;mopen&quot;&gt;[&lt;span class=&quot;mord mathit&quot;&gt;i&lt;span class=&quot;mclose&quot;&gt;] 本身！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;直接上代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] twoSum(&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Map&amp;lt;Integer, Integer&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nums.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        map.put(nums[i], i);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nums.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; complement = target -&lt;span&gt; nums[i];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (map.containsKey(complement) &amp;amp;&amp;amp; map.get(complement) !=&lt;span&gt; i) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] { i, map.get(complement) };
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;No two sum solution&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图分析思路：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1507988/201811/1507988-20181117134145573-647936588.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;复杂度分析：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;时间复杂度：&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;O(n)&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mclose&quot;&gt;， 我们把包含有 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;n &lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;个元素的列表遍历两次。由于哈希表将查找时间缩短到 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;O(1)&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mclose&quot;&gt; ，所以时间复杂度为 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;O(n)&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mclose&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;空间复杂度：&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;O(n)&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mclose&quot;&gt;， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;n&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt; 个元素。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、一遍哈希表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mclose&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;哈哈哈哈哈哈哈哈哈，这个方法我也搞不太懂，贴上来参考一下吧！！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;直接上代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] twoSum(&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Map&amp;lt;Integer, Integer&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nums.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; complement = target -&lt;span&gt; nums[i];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (map.containsKey(complement)) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] { map.get(complement), i };
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        map.put(nums[i], i);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;No two sum solution&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;时间复杂度：&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;O(n)&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mclose&quot;&gt;， 我们只遍历了包含有 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;n&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;n 个元素的列表一次。在表中进行的每次查找只花费 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;O(1)&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mclose&quot;&gt; 的时间。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;空间复杂度：&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;O(n)&lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;&lt;span class=&quot;mclose&quot;&gt;， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;n &lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;个元素。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sat, 17 Nov 2018 06:03:00 +0000</pubDate>
<dc:creator>DJDU</dc:creator>
<og:description>记录的是leetcode刷的第一题--两数之和，学习笔记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DJDU/p/9973267.html</dc:identifier>
</item>
<item>
<title>java调用Linux执行Python爬虫，并将数据存储到elasticsearch--（环境脚本搭建） - 陈远波</title>
<link>http://www.cnblogs.com/chenyuanbo/p/9973685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyuanbo/p/9973685.html</guid>
<description>&lt;p&gt;java调用Linux执行Python爬虫，并将数据存储到elasticsearch中&lt;/p&gt;
&lt;p&gt;一、以下博客代码使用的开发工具及环境如下：&lt;/p&gt;
&lt;p&gt;1、idea：&lt;/p&gt;
&lt;p&gt;2、jdk：1.8&lt;/p&gt;
&lt;p&gt;3、elasticsearch：5.2.0&lt;/p&gt;
&lt;p&gt;4、Linux&lt;/p&gt;
&lt;p&gt;5、Python&lt;/p&gt;
&lt;p&gt;6、maven&lt;/p&gt;
&lt;p&gt;二、maven坐标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;!--java连接ulinix脚本架包--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;ch.ethz.ganymed&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;ganymed-ssh2&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;build209&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;jar&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;commons-lang&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-lang&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.6&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;jar&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!--es相关坐标--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;pre&quot;&gt;&amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;org.elasticsearch.plugin&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;transport-netty4-client&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;5.2.0&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;br/&gt;&amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;br/&gt;&amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;org.elasticsearch&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;elasticsearch&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;5.2.0&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;br/&gt;&amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;br/&gt;&amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;org.nlpcn&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;elasticsearch-sql&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;6.3.0.0&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;br/&gt;&amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;br/&gt;&amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;com.alibaba&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;druid&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;1.1.9&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;br/&gt;&amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;br/&gt;&amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;org.elasticsearch.client&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;transport&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;5.2.0&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;br/&gt;&amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 二、Linux脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /usr/local/python3/lib/python3.6/site-&lt;span&gt;packages
python linux_sina.py &lt;/span&gt;&amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、Python爬虫脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
Created on Mon Aug 13 10:12:56 2018

@author: Administrator
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; public_python as p
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BeautifulSoup
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;存储到ES&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; elasticsearch &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Elasticsearch

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; flask
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; request
server &lt;/span&gt;= flask.Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver


@server.route(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/news&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_html2():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;异常处理机制：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;声明全局变量&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;global title,time,strcon,cos&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        url&lt;/span&gt;=request.values.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;存储的新闻类型----用于数据库表中的字段&lt;/span&gt;
        theme_id=request.values.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;theme_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;----guonei--新闻类型 &lt;/span&gt;
        
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;无界面启动&lt;/span&gt;
        firefox_options =&lt;span&gt; webdriver.FirefoxOptions()
        firefox_options.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--headless&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        browser &lt;/span&gt;= webdriver.Firefox(firefox_options=&lt;span&gt;firefox_options)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;超时设置&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;timeout=request.values.get(&quot;timeout&quot;)&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;设置加载时间&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        browser.set_page_load_timeout(&lt;/span&gt;30000&lt;span&gt;)
        browser.set_script_timeout(&lt;/span&gt;30000)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这两种设置都进行才有效&lt;/span&gt;
&lt;span&gt;        browser.get(url)
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        判断url是否包含多个链接，如果包含--即URL值不会是以.shtml结尾的字符串
        那么就去获取链接里面所有的以.shtml结尾的链接url值。
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存放页面中具体的url链接&lt;/span&gt;
        data_urls=&lt;span&gt;[]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.shtml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; url:

            list_father&lt;/span&gt;=browser.find_element_by_tag_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;先定位大的标签&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存放所有&amp;lt;a&amp;gt;链接&lt;/span&gt;
            ahref=list_father.find_elements_by_tag_name(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在打标签下寻找确定的小标签的集合-需要：elements。&lt;/span&gt;
              
            &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
            对标签&amp;lt;a&amp;gt;进行遍历，获取其中的属性为：href的值，
            然后过滤判断，如果包含.shtml，那么将href的值保存到数组，并且对数组进行set去重。
            如果没包含.shtml，那么跳过本次循环。
            最后调用获取数据的方法进行爬取数据
            &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; ah &lt;span&gt;in&lt;/span&gt; ahref:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;具体小标签中包含内容较多，所以还需要遍历 &lt;/span&gt;
&lt;span&gt;                         
                hr&lt;/span&gt;=ah.get_attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取连接的值&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.shtml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; hr: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对链接进行遍历过滤&lt;/span&gt;
&lt;span&gt;                      data_urls.append(hr)
                      links&lt;/span&gt;=set(data_urls)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;去重&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                      &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
                      &lt;span&gt;continue&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;getcontent(links)#调用获取内容的方法：&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
         判断url是否包含多个链接，如果url包含。shtml，那么代表此url是单页的。
         那么直接将url存入数组，然后调用获取数据的方法
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.shtml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;in&lt;/span&gt;&lt;span&gt; url:
            data_urls.append(url)
            links&lt;/span&gt;=set(data_urls)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;去重&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;getcontent(links)&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        #最后均去调用获取内容的方法：
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        getcontent(links)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;测试 &lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;data_urls中包含网页中所有.shtml的链接。 &lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        for i in range(len(data_urls)):
              print(data_urls[i])
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

        browser.quit()&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;完成后退出关闭浏览器&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt; urllib.error.URLError as e :
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e.code)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.code
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reason&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e.reason)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.reason
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exception:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;str(e))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; getcontent(data_urls):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;异常处理机制：&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; title,time,strcon,cos
        &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;存储的新闻类型----用于数据库表中的字段&lt;/span&gt;
        theme_id=request.values.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;theme_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;----guonei--新闻类型         &lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;图片的前缀链接域名&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;domain_name=request.values.get(&quot;domain_name&quot;)&lt;/span&gt;
        
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;无界面启动&lt;/span&gt;
        firefox_options =&lt;span&gt; webdriver.FirefoxOptions()
        firefox_options.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--headless&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        browser &lt;/span&gt;= webdriver.Firefox(firefox_options=&lt;span&gt;firefox_options)
        
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        连接ES集群，获取es
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        es&lt;/span&gt;=Elasticsearch(hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.200.211:9201&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], maxsize=25&lt;span&gt;)
       
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        对传递过来的url数组进行遍历，获取每一个具体链接url（以.shtml结尾的url）
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data_urls:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(url) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;具体每个标题链接,后缀是.shtml&lt;/span&gt;
&lt;span&gt;
            browser.get(url)

            conlist&lt;/span&gt;=[] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存储文章内容，先以数组进行保存&lt;/span&gt;
            
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断源代码中id的值：artibodyTitle是否存在，存在的话将值内容赋值给标题变量&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;artibodyTitle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; browser.page_source:
                title&lt;/span&gt;=browser.find_element_by_id(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;artibodyTitle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断class的值：main-title是否存在，存在的话将值内容赋值给标题变量&lt;/span&gt;
            &lt;span&gt;elif&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main-title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; browser.page_source:
                title&lt;/span&gt;=browser.find_element_by_class_name(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main-title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text
                &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                以上是对新浪网新闻中标题存在的不同形式的判断。
                &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;跳过异常错误 继续执行&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
                title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无法爬取标题&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(title)
    
            &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
            以下是获取时间的方式。
            &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
            
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pub_date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; browser.page_source:
                  time&lt;/span&gt;=browser.find_element_by_id(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pub_date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text
            &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; browser.page_source:
                  time&lt;/span&gt;=browser.find_element_by_class_name(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
                 time=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无法爬取时间&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(time)&lt;/span&gt;

            &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
            以下是去获取正文内容。
            先：打开url，并读取内容
            &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
            
            file&lt;/span&gt;=urllib.request.urlopen(url=url,timeout=30000&lt;span&gt;)
            data&lt;/span&gt;=file.read().decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ignore&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            soup&lt;/span&gt;=BeautifulSoup(data,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            
            &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;#存实际的所有正文的内容--不以数组形式存储&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
            strcon&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;
            
            &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
            #内容有2中情况，一种在class=article的div下(class以“.”表示)，
                          一种在id=artibody的div下（id以“#”表示）
            &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.article &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) :
                 cos&lt;/span&gt;=soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.article &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt;  soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#artibody &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
                 cos&lt;/span&gt;=soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#artibody &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
            判断包含内容的标签是否存在，以下代码均是在内容存在的情况下进行
            &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;                    
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; cos:
                 &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cos:
                      &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                      遍历内容标签，查找包含图片和段落的标签（img和p）,
                      结果是bs4.element.ResultSet集合。
                      集合中每一个元素是一个tag标签
                      &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                      alls&lt;/span&gt;=i.find_all([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;])&lt;span&gt;#&lt;/span&gt;&lt;span&gt;传入一个字符串的列表，将匹配列表中标签的Tag全部返回&lt;/span&gt;
                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(type(alls))       #&amp;lt;class 'bs4.element.ResultSet'&amp;gt;&lt;/span&gt;
                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;(type(alls[0]))         #&amp;lt;class 'bs4.element.Tag'&amp;gt;&lt;/span&gt;
                
                 &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                 对过滤后的标签结合进行遍历。
                 &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
                 &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; alls:
                      &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(j)   #---div-article标签下所以内容。包含标签在内&lt;/span&gt;
                      &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                      #接下来需要将图片进行替换成本地图片:
                      #第一步：将本页的图片按原名下载下来
                      #第二步，替换标签&amp;lt;img&amp;gt;中src的来源路径即可
                      &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
                      &lt;span&gt;if&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; soup.findAll(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
                          
                           &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取图片的连接url&lt;/span&gt;
                           imgAllName=str(j.attrs[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
                           &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;图片名称&lt;/span&gt;
                           imgName=imgAllName.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[-1].split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[0]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;aaa.jpg格式--aaa&lt;/span&gt;
                           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;图片后缀&lt;/span&gt;
                           imgName_suffix=imgAllName.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[-1].split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[-1]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;类似jpg&lt;/span&gt;
                           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将图片存入本地文件-由于网址中src缺少&quot;http:&quot;，所以需要添加形成完整url路径&lt;/span&gt;
                           urllib.request.urlretrieve(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+imgAllName,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//opt//zc//img//&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+imgName+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;imgName_suffix)
                           &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                           #设置新的图片（目的：将本地图片地址去替换原来的链接地址）-本地图片的位置和图片名称链接
                           &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                           imglink&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http:/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/zc/img/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+imgName+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;imgName_suffix
                           
                           &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                           #修改：图片位置存放链接,将本地图片地址去替换原来的链接地址
                           #j.attrs[&quot;src&quot;]通过标签的attrs属性获取里面的属性值
                           &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                           j.attrs[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]=&lt;span&gt;imglink 
                           
                      
                      &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;此添加的就是仅仅修改图片链接地址后全部的内容。&lt;/span&gt;
&lt;span&gt;                      conlist.append((j))
                 &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                 遍历保存内容的数组，将其保存为一个整体
                 &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
                 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(conlist)):
                     strcon&lt;/span&gt;+=str(conlist[i]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;str:将标签内容转换成string类型&lt;/span&gt;
                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(strcon)#内容&lt;/span&gt;
                 &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;   
                 #以下是ES存储的时候的表字段
                 &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存储的新闻类型----用于数据库表中的字段&lt;/span&gt;
                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;theme_id=request.values.get(&quot;theme_id&quot;)#----guonei--新闻类型 &lt;/span&gt;
                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;autoid 主键&lt;/span&gt;
                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;company_id=&quot;&quot; # 公司ID&lt;/span&gt;
                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;title:标题-title&lt;/span&gt;
                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;content:内容-strcon&lt;/span&gt;
                
                 
                 &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                 对es中的索引进行判断，查看是否存在
                 如果不存在，那么就创建，将id的值赋值为1，然后添加数据
                 &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
                 &lt;span&gt;if&lt;/span&gt; es.indices.exists(index=theme_id) &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; True:
                     
                     autoid&lt;/span&gt;=1 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置es中id的值&lt;/span&gt;
                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将结果写入ES&lt;/span&gt;
                     data={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:autoid,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:title,
                           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:strcon
                           }&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;str(conlist)转换成str类型 否则序列化失败&lt;/span&gt;
                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建新索引---注意位置在此！&lt;/span&gt;
                     es.indices.create(index=&lt;span&gt;theme_id)
                     p.insert_result(theme_id,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sina&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,data)

                     
                                   
                     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                     如果索引存在的话，先查询出索引中所有内容，然后将数据进行转换成dataframe
                     然后去获取其中关于标题：title和主键:id的值。
                 
                     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                     
                     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                          #去重，先去查询ES,如果title不相同的，那么继续执行，否则跳出此循环，pass,continue
                          继续执行的前提下，查询ES中的id的最大值，然后每次存储，id+1
            
                     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;  
                     
                     res0&lt;/span&gt;=p.search(theme_id,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sina&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查询方法&lt;/span&gt;
&lt;span&gt;                     
                     res1&lt;/span&gt;=p.clean_data(res0)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对数据进行转换成：dataFrame&lt;/span&gt;
&lt;span&gt;                     
                     res_title&lt;/span&gt;=res1[[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取需要的部分数据dataframe--&lt;/span&gt;
                     res_id=res1[[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取需要的部分数据dataframe&lt;/span&gt;
                     
                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(res_title.values)#---[[],[]]:二维数组&lt;/span&gt;
&lt;span&gt;                     
                     titles&lt;/span&gt;=[]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;存储es中已经存在的title的集合&lt;/span&gt;
                     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; res_title.values:
                         &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(i)#[] [] []&lt;/span&gt;
                         &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; i:
                             titles.append(j)
                     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                     以上，标题titles保存的就是一维数组
                     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

                     ids&lt;/span&gt;=[]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;存储es中已经存在的id的集合&lt;/span&gt;
                     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; res_id.values:
                                 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(i)#[] [] []&lt;/span&gt;
                                 &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; i:
                                     ids.append(j)
                     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                     以上，主键ids:保存的就是一维数组
                     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
                   
                     &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                     由于每次插入数据id自动增加，所以先要去查看es中（ids）的最大值，然后每加一条记录+1。
                     #对ids数组进行遍历，获取最大值，#max(ids)是：&amp;lt;class 'numpy.int64'&amp;gt;，要转换成int类型
                     #print(type(ids))#list类型
                     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;                  
                     autoid_max&lt;/span&gt;=&lt;span&gt;int(max(ids)) 
                     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置es中id的值，自动增加1&lt;/span&gt;
                     
                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(type(autoid_max))#int 类型&lt;/span&gt;
                     autoid=int(autoid_max+1&lt;span&gt;)
                 
                     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
                     去重处理。
                     #print(titles)#titles:['','','']
                     #对title的值进行判断是否存在。--去重！！！！！，如果存在那么跳出本次循环
                     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
                     &lt;span&gt;if&lt;/span&gt; title &lt;span&gt;in&lt;/span&gt;&lt;span&gt; titles:
                            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
                            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经存在此标题&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                            
                     &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                             
                             data&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:autoid,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:title,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:strcon
                                   }
                             &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用方法，往es中插入数据&lt;/span&gt;
&lt;span&gt;                             
                             p.insert_result(theme_id,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sina&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,data)
    

                 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;seach获取---本地打印&lt;/span&gt;
                 res00=p.search(theme_id,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sina&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查询方法&lt;/span&gt;
                 &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(res00)
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
              
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt; urllib.error.URLError as e :
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;e.code)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.code
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reason&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;e.reason)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.reason
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exception:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;str(e))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e
server.run(host&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,port=8000,debug=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上Linux脚本及Python爬虫脚本，作者在此感谢我的同事张超提供。下一篇博客作者将为大家提供后台java代码。此篇博客主要为Python爬虫都是自己书写的小伙伴参考&lt;/p&gt;

</description>
<pubDate>Sat, 17 Nov 2018 05:45:00 +0000</pubDate>
<dc:creator>陈远波</dc:creator>
<og:description>java调用Linux执行Python爬虫，并将数据存储到elasticsearch中 一、以下博客代码使用的开发工具及环境如下： 1、idea： 2、jdk：1.8 3、elasticsearch：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenyuanbo/p/9973685.html</dc:identifier>
</item>
<item>
<title>并发编程(三) - Eurekaa</title>
<link>http://www.cnblogs.com/zuanzuan/p/9973640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuanzuan/p/9973640.html</guid>
<description>&lt;p&gt;经过前一篇博客的学习了解了 Unix 和 Windows 系统创建进程的方式了,对于 Unix系统来说,会把父进程的数据直接拷贝一份到子进程的内存空间;而 Windows 系统会重新加载一遍父进程的代码.&lt;/p&gt;
&lt;p&gt;那么在 python 中怎么创建进程呢?其实也是调用了操作系统提供的接口,像 Unix 是 fork 接口, Windows 是 CreateProcess 接口.&lt;/p&gt;

&lt;h3 id=&quot;process-源码探析&quot;&gt;Process 源码探析&lt;/h3&gt;
&lt;p&gt;首先不管怎么创建进程都是调用了一个multiprocessing模块里面的 Process 类,学习一个模块第一件事就是查看源码.(ps: 对我来说看源码很爽😋)因为 python3看不到源码,所以用 python2可以看到:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fxa6rs7loog30dc064npg.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;翻译 Process 类的注释:进程对象表示在隔开的进程中运行的活动,这个类和 threading.Thread 同义.(因为最开始的计算机都是单核,多进程是后面才出来的)&lt;/p&gt;
&lt;p&gt;那么很显然,因为 Process 是个类,那么想要创建一个进程就是实例化一个 Process 类的对象.查看__ init__方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fxb1y1zgtbj30yu0g0wi7.jpg&quot; alt=&quot;image-20181116211024312&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哇,参数好多啊,不过大部分都可以使用默认值,第一个参数是 group, 看后面有一句注释: group 参数当前必须为 None, 好了可以不用理会了;第二个参数很重要,表示创建的进程将要进行的任务,必须要传参数(函数名);第三个是名字,可以自定义进程名;第四个是可变长参数,参数会在创建进程的时候传进 target 中;第五个为关键词参数,也是给 target 传的.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;assert group is None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;断言,只有该表达式值为 True 才会运行下面的代码.很显然不用管就行.&lt;/p&gt;
&lt;p&gt;然后下面的都是一些类属性,需要关注的是 self._target,sekf._popen.&lt;/p&gt;
&lt;p&gt;查看 process 模块的注释:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fxauq74fldg30dc064qv5.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;翻译可知:&lt;/p&gt;
&lt;p&gt;模块提供 Process 类是模拟于'threading.Thread'&lt;/p&gt;
&lt;p&gt;再分配和使用的源代码和二进制形式，无论有无修改,但必须符合下列的情况:&lt;/p&gt;
&lt;p&gt;1.源代码的再分发必须保留上述版权声明，此条件列表和以下免责声明。&lt;/p&gt;
&lt;p&gt;2.二进制形式的再分发必须在随分发提供的文档和/或其他材料中复制上述版权声明，此条件列表和以下免责声明。&lt;/p&gt;
&lt;p&gt;3.未经事先书面许可，不得使用作者姓名或任何贡献者的姓名来认可或宣传本软件衍生的产品。(ps: 这注释怎么和 process 一点关系没有😲)&lt;/p&gt;
&lt;h3 id=&quot;开启进程的两种方式&quot;&gt;开启进程的两种方式&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;实例化 Process 类&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;创建一个子进程的 demo 如下:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from multiprocessing import Process,current_process

def task():
    print('子', current_process)
    
if __name__ == '__main__':
    p = Process(target=task)
    p.start() # 启动一个进程
    print('主', current_process)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:创建进程的代码为什么要放在 mian 下面?&lt;/p&gt;
&lt;p&gt;这是因为在 windows 系统下创建进程会重新加载一遍父进程的代码,如果不放在 main 判断下面的话会重复执行创建进程的代码.在 类linux 系统下就不用了.创建进程后执行start方法其实就是运行传入的 task 函数:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwly1fxatnjxgd8j30wa06y74y.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个类方法的注释含义为:运行在子进程中的方法,可以在子类中重写.&lt;/p&gt;
&lt;p&gt;看看创建的子进程的运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwly1fxav9ty4mkj314w04yjsn.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果会打印出主进程和子进程.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建一个继承自 Process 类的子类并改写 run 方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;demo 如下:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from multiprocessing import Process,current_process

class MyProcess(Process):
    def run(self):
        print('子', current_process())


if __name__ == '__main__':
    p = MyProcess()
    p.start()
    print('主', current_process())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fxav6zykv4j315a05675l.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;进程之间内存空间互相隔离&quot;&gt;进程之间内存空间互相隔离&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from multiprocessing import Process

x = 100
def task():
    global x
    x = 1
    print('子', x)
    
if __name__ == '__main__':
    p = Process(target=task)
    p.start()
    print('主', x)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fxavk7l036j315804wdgm.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以得出即使在子进程中global x了,修改的也是子进程内存空间里面的名称,这和之前讲的子进程将父进程的代码重新加载了一遍,所以这里面的 x 是两个不同的 x.&lt;/p&gt;
&lt;p&gt;[image-20181117110113666](&lt;a href=&quot;https://ws1.sinaimg.cn/large/006tNbRwly1fxb1zr8r3ij315e04o3z8.jpg&quot; class=&quot;uri&quot;&gt;https://ws1.sinaimg.cn/large/006tNbRwly1fxb1zr8r3ij315e04o3z8.jpg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为什么进程的内存空间需要切必须要互相隔离呢?&lt;/p&gt;
&lt;p&gt;进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术.这个技术是为了避免A 进程写入 B 进程的情况发生.进程的隔离实现,使用了虚拟地址空间.进程 A 的虚拟地址和进程 B 的虚拟地址不同,这样就防止进程 A 将数据信息写入进程 B,总的来说就是为了数据安全,但也有办法可以实现进程间通信,稍后再谈.&lt;/p&gt;
&lt;h3 id=&quot;父子进程执行顺序与-join-方法&quot;&gt;父子进程执行顺序与 join 方法&lt;/h3&gt;
&lt;p&gt;在上面的代码中实例一个进程对象然后执行 start 方法,会创建出一个子进程然后去执行任务,其实 python 只是调用了操作系统提供的接口,在上一篇博客说到,类 Unix 是调用了操作系统的 fork 函数, windows 是 CreateProcess 函数,所以是通过操作系统来调用并创建一个进程的,而创建进程需要一些必要的资源,那么在操作系统分配这些资源的过程中,主进程代码的执行应该进行完成了,所以运行结果会先出现主进程代码执行完,后子进程的代码执行完.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建进程的具体时间&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from multiprocessing import Process
import time


def task():
    start_time = time.time()
    print('子进程运行时间')
    print(time.time() - start_time)


if __name__ == '__main__':
    start_time = time.time()

    p = Process(target=task)
    p.start()
    print('创建子进程', time.time() - start_time)

    print('主', time.time() - start_time)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwly1fxax05vxqyj315i06kabk.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以得出创建子进程几乎花了总程序运行时间的90%以上,所以主进程先运行结束就很正常了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;join 方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么如何可以让主进程等待子进程运行结束主进程才结束呢?&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from multiprocessing import Process
import time


def task():
    start_time = time.time()
    print('子进程运行时间')
    print(time.time() - start_time)


if __name__ == '__main__':
    start_time = time.time()

    p = Process(target=task)
    p.start()
    print('创建子进程', time.time() - start_time)
    p.join()

    print('主', time.time() - start_time)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fxax8s8o5aj315a06i402.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样主进程就会等待子进程运行结束才会结束.&lt;/p&gt;
&lt;p&gt;join 方法:主进程等待子进程运行完毕,即主进程在原地阻塞而不影响子进程的运行.&lt;/p&gt;
&lt;h3 id=&quot;进程对象相关属性和方法&quot;&gt;进程对象相关属性和方法&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from multiprocessing import Process
import os,time

def task(name):
    print('start', name)
    time.sleep(5)
    print('stop', name)
    
if __name__ == '__main__':
    p = Process(target=task, args=('musibii',), name='musibii_Process')
    p.start()
    
    print(p.name) # 获取进程名,可以自定义
    print(p.pid) # 获取进程 pid
    p.terminate() # 结束子进程
    print(p.is_alive()) # 判断进程是否存活,布尔值
    
    print(os.getpid()) # 当前主进程 pid
    print(os.getppid()) # 执行 py 文件的进程,当前为 pycharm 进程pid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwly1fxaxox6dqtj315i07mmyc.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么在 terminate 之后判断子进程是否存活,结果为 True 呢?&lt;/p&gt;
&lt;p&gt;因为在执行终结子进程命令后需要操作系统来结束子进程,而完全终结子进程需要一定的时间,而代码执行速度很快,所以会是 True.&lt;/p&gt;
&lt;h3 id=&quot;僵尸进程与孤儿进程以及守护进程&quot;&gt;僵尸进程与孤儿进程以及守护进程&lt;/h3&gt;
&lt;h4 id=&quot;僵尸进程&quot;&gt;僵尸进程&lt;/h4&gt;
&lt;p&gt;在类 Unix 系统中,僵尸进程是指完成执行(通过 exit 系统调用,或运行时发生致命错误或收到终止信号所致)但在操作系统的进程表中仍然有一个表项(进程控制块 PCB),处于'终止状态'的进程.&lt;/p&gt;
&lt;h4 id=&quot;孤儿进程&quot;&gt;孤儿进程&lt;/h4&gt;
&lt;p&gt;在操作系统中,孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程,这类进程由操作系统进行管理和回收.&lt;/p&gt;
&lt;h4 id=&quot;守护进程&quot;&gt;守护进程&lt;/h4&gt;
&lt;p&gt;在一个多工的电脑作业系统中,守护进程是一种在后台执行的电脑程序.此类程序会被以进程的形式初始化.守护进程程序的名称通常以' d'结尾:例如 syslogd 就是指管理系统日志的守护进程.&lt;/p&gt;
&lt;p&gt;详解:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一般情况下,子进程是由父进程创建的,而子进程和父进程的退出是无顺序的,两者之间都不知道谁先退出.正常情况下父进程先结束则会调用 wait 或者 waitpid 函数等待子进程完成再退出,而一旦父进程不等待直接退出,则剩下的子进程会被 init(pid=1)进程接收,成被孤儿进程.(进程树种除了 init 都会有父进程)&lt;/li&gt;
&lt;li&gt;如果子进程先退出,父进程还未结束并且没有调用 wait 或者 waitpid 函数获取子进程的状态信息,则子进程残留的状态信息(task_struct 结构和少量系统资源信息)会变成僵尸进程.&lt;/li&gt;
&lt;li&gt;守护进程是指在后台运行,没有控制终端与之相连的进程.它独立于控制终端,通常周期性的执行某种任务.(特别的,守护进程不能有子进程)守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;产生的危害&lt;/p&gt;
&lt;p&gt;孤儿进程结束后会被 init 进程管理并处理后事,并没有危害,而僵尸进程则会一直占着进程号,操作系统的进程数量有限则会受影响.&lt;/p&gt;
&lt;p&gt;解决办法:&lt;/p&gt;
&lt;p&gt;一般僵尸进程的产生都是因为父进程的原因,则可以通过kill 父进程解决,这时候僵尸进程就变成了孤儿进程,被 init 进程管理.&lt;/p&gt;
</description>
<pubDate>Sat, 17 Nov 2018 05:30:00 +0000</pubDate>
<dc:creator>Eurekaa</dc:creator>
<og:description>前言 经过前一篇博客的学习了解了 Unix 和 Windows 系统创建进程的方式了,对于 Unix系统来说,会把父进程的数据直接拷贝一份到子进程的内存空间;而 Windows 系统会重新加载一遍父进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuanzuan/p/9973640.html</dc:identifier>
</item>
<item>
<title>muduo网络库学习笔记(五) 链接器Connector与监听器Acceptor - 艾露米婭娜</title>
<link>http://www.cnblogs.com/ailumiyana/p/9973611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ailumiyana/p/9973611.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;标签： muduo Connector Acceptor&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本篇继续为前面封装的EventLoop添加事件，到现在共给EventLoop添加了两个fd,Timerfd，EventFd分别用于处理定时任务和通知事件.&lt;br/&gt;今天添加的Acceptor会增加另一个fd,此fd是是一个socket，用于监听套接字连接.同时封装非组赛网络编程中的connect(2)的使用Connector.&lt;/p&gt;
&lt;h2 id=&quot;connector&quot;&gt;Connector&lt;/h2&gt;
&lt;p&gt;在非阻塞网络编程中，发起连接的基本方式是调用connect(2)，当socket变得可写时表明连接建立完毕，其中要处理各种类型的错误，我们把它封装为Connector class.&lt;br/&gt;Connector 和 Acceptor 设计思路基本一致，只是Acceptor通过判断套接字是否可读来执行回调，而Connector是判断套接字是否可写来执行回调.&lt;br/&gt;还有一点就是错误处理，socket可写不一定就是连接建立好了 ， 当连接建立出错时，套接口描述符变成既可读又可写,这时我们可以通过调用getsockopt来得到套接口上待处理的错误(SO_ERROR).&lt;/p&gt;
&lt;p&gt;其次非阻塞网络编程中connect(2)的sockfd是一次性的，一旦出错（比如对方拒绝连接），就无法恢复，只能关闭重来。但Connector是可以反复使用的， 因此每次尝试连接都要使用新的socket文件描述符和新的Channel对象。要注意的就是Channel的生命期管理了.&lt;/p&gt;
&lt;h3 id=&quot;系统函数connect&quot;&gt;系统函数connect&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;   #include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
   #include &amp;lt;sys/socket.h&amp;gt;
   
   int connect(int sockfd, const struct sockaddr *addr,
               socklen_t addrlen);
               &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sockfd&lt;/code&gt; 试图制作的一个连接到被绑定到addr指定地址的套接字。&lt;br/&gt;&lt;code&gt;addr&lt;/code&gt;和&lt;code&gt;addrlen&lt;/code&gt; 服务端地址和长度.&lt;/p&gt;
&lt;p&gt;retrun:&lt;br/&gt;成功 返回0 ， 失败 返回 -1.&lt;/p&gt;
&lt;h3 id=&quot;处理非阻塞connect的步骤&quot;&gt;处理非阻塞connect的步骤:&lt;/h3&gt;
&lt;p&gt;第一步:创建非阻塞socket,返回套接口描述符;&lt;br/&gt;第二步:connect(2)开始建立连接;&lt;br/&gt;第三步:判断连接是否成功建立：&lt;/p&gt;
&lt;p&gt;A:如果connect返回0,表示连接建立成功, 如果错误为EINPROGRESS 表示连接正在进行，可以等待select()变的可写，通过getsockopt()来来得到套接口上待处理的错误(SO_ERROR),连接是否建立成功.如果连接建立成功,这个错误值将是0,如果建立连接时遇到错误,则这个值是连接错误所对应的errno值(比如:ECONNREFUSED,ETIMEDOUT等).&lt;br/&gt;B: EAGAIN、EADDRINUSE、EADDRNOTAVAIL、ECONNREFUSED、ENETUNREACH 像EAGAIN 这类表明本机临时端口暂时用完的错误、可以尝试重连。&lt;br/&gt;C: EACCES、EPERM、EAFNOSUPPORT、EALREADY、EBADF、EFAULT、ENOTSOCK 其他真错误像无权限，协议错误，等直接关闭套接字.&lt;/p&gt;
&lt;p&gt;Connector正是按这个步骤处理的连接.&lt;br/&gt;暴露的接口只有start()和stop()&lt;br/&gt;start()执行上述connect的步骤.&lt;br/&gt;stop()关闭套接字，删除注册的通道，停止进行连接.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Connector
{
public:
  typedef std::function&amp;lt;void (int sockfd)&amp;gt; NewConnectionCallback;

  Connector(EventLoop* loop, const InetAddress&amp;amp; serverAddr);
  ~Connector();

  void setNewConnectionCallback(const NewConnectionCallback&amp;amp; cb)
  { m_newConnectionCallBack = cb; }

  void start();// can be called in any thread
  void stop(); // can be called in any thread

private:

  enum States { kDisconnected, kConnecting, kConnected };
  static const int kMaxRetryDelayMs = 30*1000;
  static const int kInitRetryDelayMs = 500;

  void connect();
  void connecting(int sockfd);

  void handleWrite();
  void handleError();

  void retry(int sockfd);
  int removeAndResetChannel();
  void resetChannel();

  void setState(States s) { m_state = s; }
  void startInLoop();
  void stopInLoop();

  EventLoop* p_loop;
  int m_retryDelayMs;
  InetAddress m_serverAddr;

  States m_state;

  std::unique_ptr&amp;lt;Channel&amp;gt; p_channel;
  NewConnectionCallback m_newConnectionCallBack;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;connetor时序图&quot;&gt;Connetor时序图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1384555/201811/1384555-20181117131602784-1295155853.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;Connector::Connector(EventLoop* loop, const InetAddress&amp;amp; serverAddr)
  :p_loop(loop),
  m_serverAddr(serverAddr),
  m_state(kDisconnected),
  m_retryDelayMs(kInitRetryDelayMs)
{
  LOG_DEBUG &amp;lt;&amp;lt; &quot;ctor[&quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &quot;]&quot;;
}

Connector::~Connector()
{
  LOG_DEBUG &amp;lt;&amp;lt; &quot;dtor[&quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &quot;]&quot;;
  assert(!p_channel);
}

void Connector::start()
{

  p_loop-&amp;gt;runInLoop(std::bind(&amp;amp;Connector::startInLoop, this));
}

void Connector::startInLoop()
{
  p_loop-&amp;gt;assertInLoopThread();
  assert(m_state == kDisconnected);

  connect();
}

void Connector::stop()
{
  p_loop-&amp;gt;queueInLoop(std::bind(&amp;amp;Connector::stopInLoop, this));
}

void Connector::stopInLoop()
{
  p_loop-&amp;gt;assertInLoopThread();

  if(m_state == kConnecting)
  {
    int sockfd = removeAndResetChannel();
    sockets::close(sockfd);
    setState(kDisconnected);
  }
}

void Connector::connect()
{
  int sockfd = sockets::createNonblockingOrDie(m_serverAddr.family());
  int ret = sockets::connect(sockfd, m_serverAddr.getSockAddr());
  int savedErrno = (ret == 0) ? 0 : errno;

  if(ret != 0) LOG_TRACE &amp;lt;&amp;lt; &quot;connect error (&quot;&amp;lt;&amp;lt; savedErrno &amp;lt;&amp;lt; &quot;) : &quot; &amp;lt;&amp;lt; strerror_tl(savedErrno);

  switch(savedErrno)
  {
    case 0:
    case EINPROGRESS:      //Operation now in progress
    case EINTR:            //Interrupted system call
    case EISCONN:          //Transport endpoint is already connected
      connecting(sockfd);
      break;

    case EAGAIN:
    case EADDRINUSE:
    case EADDRNOTAVAIL:
    case ECONNREFUSED:
    case ENETUNREACH:
      retry(sockfd);
      LOG_SYSERR &amp;lt;&amp;lt; &quot;reSave Error. &quot; &amp;lt;&amp;lt; savedErrno;
      break;

    case EACCES:
    case EPERM:
    case EAFNOSUPPORT:
    case EALREADY:
    case EBADF:
    case EFAULT:
    case ENOTSOCK:
      LOG_SYSERR &amp;lt;&amp;lt; &quot;connect error in Connector::startInLoop &quot; &amp;lt;&amp;lt; savedErrno;
      sockets::close(sockfd);
      break;

    default:
      LOG_SYSERR &amp;lt;&amp;lt; &quot;Unexpected error in Connector::startInLoop &quot; &amp;lt;&amp;lt; savedErrno;
      sockets::close(sockfd);
      // connectErrorCallback_();
      break;
  }

}

void Connector::connecting(int sockfd)
{
  LOG_TRACE &amp;lt;&amp;lt; &quot;Connector::connecting] sockfd : &quot; &amp;lt;&amp;lt; sockfd;
  setState(kConnecting);
  assert(!p_channel);
  p_channel.reset(new Channel(p_loop, sockfd));
  p_channel-&amp;gt;setWriteCallBack(std::bind(&amp;amp;Connector::handleWrite, this));
  //p_channel-&amp;gt;setErrorCallback()

  //enableWriting if Channel Writeable ,Connect Success.
  p_channel-&amp;gt;enableWriting();
}

void Connector::retry(int sockfd)
{
  sockets::close(sockfd);
  setState(kDisconnected);

  LOG_INFO &amp;lt;&amp;lt; &quot;Connector::retry - Retry connecting to &quot; &amp;lt;&amp;lt; m_serverAddr.toIpPort()
           &amp;lt;&amp;lt; &quot; in &quot; &amp;lt;&amp;lt; m_retryDelayMs &amp;lt;&amp;lt; &quot; milliseconds. &quot;;

  p_loop-&amp;gt;runAfter(m_retryDelayMs/1000.0, std::bind(&amp;amp;Connector::startInLoop, this));
  m_retryDelayMs = std::min(m_retryDelayMs * 2, kMaxRetryDelayMs);
}

int Connector::removeAndResetChannel()
{
  p_channel-&amp;gt;disableAll();
  p_channel-&amp;gt;remove();

  int sockfd = p_channel-&amp;gt;fd();

  p_loop-&amp;gt;queueInLoop(std::bind(&amp;amp;Connector::resetChannel, this));

  return sockfd;
}

void Connector::resetChannel()
{
  LOG_TRACE &amp;lt;&amp;lt; &quot;Connector::resetChannel()&quot;;
  p_channel.reset();
}

void Connector::handleWrite()
{
  LOG_TRACE &amp;lt;&amp;lt; &quot;Connector::handleWrite &quot;;

  if(m_state == kConnecting)
  {
    int sockfd = removeAndResetChannel();
    int err = sockets::getSocketError(sockfd);

    if(err)
    {
      LOG_WARN &amp;lt;&amp;lt; &quot;Connector::handleWrite - SO_ERROR = &quot;
               &amp;lt;&amp;lt; err &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; strerror_tl(err);
      retry(sockfd);
    }
    /*else if (sockets::isSelfConnect(sockfd))
    {

    }*/
    else
    {
      setState(kConnected);
      m_newConnectionCallBack(sockfd);
    }

  }
  else
  {
    assert(m_state == kDisconnected);
  }

}

void Connector::handleError()
{
  LOG_ERROR &amp;lt;&amp;lt; &quot;Connector::handleError States &quot; &amp;lt;&amp;lt; m_state;

  if(m_state == kConnecting)
  {
    int sockfd = removeAndResetChannel();
    int err = sockets::getSocketError(sockfd);
    LOG_TRACE &amp;lt;&amp;lt; &quot;SOCK_ERROR = &quot; &amp;lt;&amp;lt; err &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; strerror_tl(err);
    retry(sockfd);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;acceptor&quot;&gt;Acceptor&lt;/h2&gt;
&lt;p&gt;相较于Connector更简单，只要有socket可读，即可确认连接建立.&lt;/p&gt;
&lt;h3 id=&quot;系统函数accept&quot;&gt;系统函数accept&lt;/h3&gt;
&lt;p&gt; #include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */&lt;br/&gt;#include &amp;lt;sys/socket.h&amp;gt;&lt;/p&gt;
&lt;p&gt;       int &lt;code&gt;accept&lt;/code&gt;(int sockfd, struct sockaddr &lt;em&gt;addr, socklen_t&lt;/em&gt; addrlen);&lt;/p&gt;
&lt;p&gt;       #define _GNU_SOURCE             /* See feature_test_macros(7) */&lt;br/&gt;       #include &amp;lt;sys/socket.h&amp;gt;&lt;/p&gt;
&lt;p&gt;       int &lt;code&gt;accept4&lt;/code&gt;(int sockfd, struct sockaddr &lt;em&gt;addr,&lt;br/&gt;                   socklen_t&lt;/em&gt; addrlen, int flags);&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sockfd&lt;/code&gt; socket(2)创建的文件描述符, 且已被bind(2)绑定本地地址,listen(2)使能监听.&lt;br/&gt;&lt;code&gt;addr&lt;/code&gt; 用于填充远端套接字地址, 如果不需要知道远端地址,可以添NULL.&lt;br/&gt;&lt;code&gt;addrlen&lt;/code&gt; 用于填充远端地址大小.&lt;br/&gt;&lt;code&gt;flags&lt;/code&gt;&lt;br/&gt;如果flags为0  等同于 accept.&lt;/p&gt;
&lt;p&gt;       SOCK_NONBLOCK  在新打开的文件描述符设置 O_NONBLOCK 标记。在 fcntl(2) 中保存这个标记可以得到相同的效果。&lt;/p&gt;
&lt;p&gt;       SOCK_CLOEXEC  在新打开的文件描述符里设置 close-on-exec (FD_CLOEXEC) 标记。参看在open(2)里关于 O_CLOEXEC标记的描述来了解这为什么有用。&lt;/p&gt;
&lt;p&gt;  int connfd = ::accept4(sockfd, (struct sockaddr *)(addr),&lt;br/&gt;                         &amp;amp;addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC);&lt;br/&gt; &lt;br/&gt;flags 会对返回的fd  connfd  设置SOCK_NONBLOCK | SOCK_CLOEXEC 标记.&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;如果用于监听的文件描述符没有设置nonblocking标志，且监听队列上没有挂起的连接, accept()会阻塞直到有新的连接到来. 如果此socket设置了nonblocking标记,accept() 会立即返回失败并设置 error 为 EAGAIN or EWOULDBLOCK.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;socket的封装&quot;&gt;Socket的封装&lt;/h3&gt;
&lt;p&gt;Socket类封装一个套接字 fd 析构的时候close 管理套接字的生命期.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Socket{
public:
  explicit Socket(int sockfd) : m_sockfd(sockfd) { }
  ~Socket();

  int fd() const { return m_sockfd; }
 
  void bindAddress(const InetAddress&amp;amp; localaddr);
  void listen();
  int accept(int sockfd, struct sockaddr_in6* addr);

  int accept(InetAddress* peeraddr);

private:
  const int m_sockfd;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;acceptor的封装&quot;&gt;Acceptor的封装&lt;/h3&gt;
&lt;p&gt;Acceptor的数据成员包含Socket和Channel，Acceptor的Socket是服务端的监听socket，Channel用于观察此socket上的readable事件.并回调Acceptor:: handleRead()，handleRead()会调用accept(2)来接受新连接， 并回调用户callback。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;class Acceptor{
public:
  typedef std::function&amp;lt;void (int sockfd, const InetAddress&amp;amp;)&amp;gt; NewConnectionCallBack;

  Acceptor(EventLoop* loop, const InetAddress&amp;amp; listenAddr, bool reuseport = true);
  ~Acceptor();

  void listen();
  bool listenning() const { return m_listenning; } // get listen status.

  void setNewConnectionCallBack(const NewConnectionCallBack&amp;amp; cb) { m_newConnectionCallBack = cb; }

private:
  void handleRead(); //处理新到的连接.

  EventLoop* p_loop;
  Socket m_acceptSocket;
  Channel m_acceptChannel;
  NewConnectionCallBack m_newConnectionCallBack;
  bool m_listenning;
  int m_idleFd;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;acceptor时序图.&quot;&gt;Acceptor时序图.&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1384555/201811/1384555-20181117131641418-622102026.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;Acceptor::Acceptor(EventLoop* loop, const InetAddress&amp;amp; listenAddr, bool reuseport)
  :p_loop(loop),
  m_acceptSocket(sockets::createNonblockingOrDie(listenAddr.family())),
  m_acceptChannel(loop, m_acceptSocket.fd()),
  m_listenning(false),
  m_idleFd(::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC))
{
  assert(m_idleFd &amp;gt;= 0);
  m_acceptSocket.setReuseAddr(true);
  m_acceptSocket.setReuseAddr(reuseport);
  m_acceptSocket.bindAddress(listenAddr);
  m_acceptChannel.setReadCallBack(
    std::bind(&amp;amp;Acceptor::handleRead, this));
}

Acceptor::~Acceptor()
{
  m_acceptChannel.disableAll();
  m_acceptChannel.remove();
  ::close(m_idleFd);
}

void Acceptor::listen()
{
  p_loop-&amp;gt;assertInLoopThread();
  m_listenning = true;
  m_acceptSocket.listen();
  m_acceptChannel.enableReading();
}

void Acceptor::handleRead()
{
  p_loop-&amp;gt;assertInLoopThread();
  InetAddress peerAddr;
  int connfd = m_acceptSocket.accept(&amp;amp;peerAddr);
  if(connfd &amp;gt;= 0)
  {
    if(m_newConnectionCallBack)
    {
      m_newConnectionCallBack(connfd, peerAddr);
    }
    else
    {
      sockets::close(connfd);
    }
  }
  else
  {
    LOG_SYSERR &amp;lt;&amp;lt; &quot;in Acceptor::handleRead&quot;;
    if(errno == EMFILE)
    {
      ::close(m_idleFd);
      m_idleFd = ::accept(m_acceptSocket.fd(), NULL, NULL);
      ::close(m_idleFd);
      m_idleFd = ::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;简单测试程序&quot;&gt;简单测试程序&lt;/h2&gt;
&lt;h3 id=&quot;acceptor-1&quot;&gt;Acceptor&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void newConnetion(int sockfd, const InetAddress&amp;amp; peeraddr)
{
  LOG_DEBUG &amp;lt;&amp;lt; &quot;newConnetion() : accepted a new connection from&quot;;
  ::sockets::close(sockfd);
}

int main()
{
  InetAddress listenAddr(8888);
  EventLoop loop;
  Acceptor acceptor(&amp;amp;loop, listenAddr);
  acceptor.setNewConnectionCallBack(newConnetion);
  acceptor.listen();

  loop.loop();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;connctor&quot;&gt;Connctor&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;EventLoop* g_loop;

void newConnetion(int sockfd)
{
  LOG_DEBUG &amp;lt;&amp;lt; &quot;newConnetion() : Connected a new connection.&quot;;
  sockets::close(sockfd);
  g_loop-&amp;gt;quit();
}

int main()
{
  EventLoop loop;
  g_loop = &amp;amp;loop;

  InetAddress serverAddr(&quot;127.0.0.1&quot;, 8888);
  Connector client(&amp;amp;loop, serverAddr);
  client.setNewConnectionCallback(newConnetion);
  client.start();

  loop.loop();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行日志&quot;&gt;运行日志&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1384555/201811/1384555-20181117131747775-2057786360.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Nov 2018 05:19:00 +0000</pubDate>
<dc:creator>艾露米婭娜</dc:creator>
<og:description>muduo网络库学习笔记(五) 链接器Connector与监听器Acceptor 标签： muduo Connector Acceptor [TOC] 本篇继续为前面封装的EventLoop添加事件，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ailumiyana/p/9973611.html</dc:identifier>
</item>
</channel>
</rss>