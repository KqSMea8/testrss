<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MySQL中间件之ProxySQL(6)：管理后端节点 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9286922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9286922.html</guid>
<description>&lt;p&gt;为了让ProxySQL能够找到后端的MySQL节点，需要将后端的MySQL Server加入到ProxySQL中。ProxySQL的一切配置行为都是在修改main库中的对应的表，所以添加节点到ProxySQL中实际上也是通过修改相关表来实现的。&lt;/p&gt;
&lt;p&gt;管理后端节点有几个过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将后端MySQL Server的主从复制结构配置好。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;将后端MySQL Server节点加入到ProxySQL中。相关的表为&lt;code&gt;mysql_servers&lt;/code&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;监控后端节点。相关的表是全局变量表&lt;code&gt;global_vairbles&lt;/code&gt;，相关的变量为&lt;code&gt;mysql-monitor_&lt;/code&gt;开头的变量。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;配置读、写组。相关的表为&lt;code&gt;mysql_replication_hostgroups&lt;/code&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;配置MySQL用户，用于发送SQL语句。相关的表为&lt;code&gt;mysql_users&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;几个注意点：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;(1).ProxySQL是通过监控后端节点的&lt;code&gt;read_only&lt;/code&gt;值来自动调整节点所属组的，例如&lt;code&gt;read_only=1&lt;/code&gt;的节点会移动到读组，&lt;code&gt;read_only=0&lt;/code&gt;的节点会移动到写组。所以，在配置读、写组之前，需要先监控后端节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;(2).对于传统的主从复制，默认的&lt;code&gt;read_only=0&lt;/code&gt;，所以在第一步中，各slave节点的配置文件中需要加上&lt;code&gt;read_only=1&lt;/code&gt;。对于组复制、Galera，因为会自动强制设置非写节点的&lt;code&gt;read_only=1&lt;/code&gt;，所以无需额外配置该属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;(3).ProxySQL支持传统主从复制结构(即异步、半同步、gtid复制)的后端，读、写组相关的表是&lt;code&gt;mysql_replication_hostgroups&lt;/code&gt;。还支持MySQL组复制结构的后端，相关的表是&lt;code&gt;mysql_group_replication_hostgroups&lt;/code&gt;，还支持Galera(如percona XtraDB cluster)结构的后端，不过ProxySQL是通过scheduler调度&lt;code&gt;proxysql_galera_checker.sh&lt;/code&gt;脚本来支持Galera的，而且目前还没有&lt;code&gt;mysql_galera_hostgroups&lt;/code&gt;(ProxySQL 2.0才新增该表)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文暂时只解释&lt;code&gt;mysql_servers&lt;/code&gt;和&lt;code&gt;mysql_replication_hostgroups&lt;/code&gt;，组复制相关的表在在后面介绍&quot;ProxySQL+组复制&quot;的文章中再介绍。&lt;/p&gt;
&lt;p&gt;完成了上面的过程后，节点就一切正常了，然后就可以去配置ProxySQL的路由规则、查询缓存、SQL语句重写等功能。这些在后面的文章会详细介绍。&lt;/p&gt;
&lt;p&gt;在开始本文下面的配置之前，请确保已经明白如何使用&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9281199.html&quot; title=&quot;MySQL中间件之ProxySQL(3)：Admin管理接口&quot;&gt;Admin管理接口&lt;/a&gt;，以及&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9280793.html&quot; title=&quot;MySQL中间件之ProxySQL(4)：多层配置系统&quot;&gt;ProxySQL的多层配置系统&lt;/a&gt;。&lt;/p&gt;


&lt;p&gt;假如后端有3个节点，使用的是传统的异步复制(1 master, 2 slave)。这3个节点的IP地址为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;192.168.100.22
192.168.100.23
192.168.100.24&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要加入3个后端MySQL节点，只需向mysql_servers表插入3行对应的记录即可。以下是使用了一大堆默认值的insert语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert into mysql_servers(hostgroup_id,hostname,port) 
values(10,'192.168.100.22',3306);

insert into mysql_servers(hostgroup_id,hostname,port) 
values(10,'192.168.100.23',3306);

insert into mysql_servers(hostgroup_id,hostname,port) 
values(10,'192.168.100.24',3306);

load mysql servers to runtime;
save mysql servers to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的insert语句表示将后端MySQL节点&lt;code&gt;192.168.100.xx:3306&lt;/code&gt;加入到&lt;code&gt;hostgroup_id=10&lt;/code&gt;的组中。&lt;/p&gt;
&lt;p&gt;其实mysql_servers表有很多字段，很多字段都有默认值，正如上面的insert语句，除了3个字段，其它使用的全是字段的默认值。&lt;/p&gt;
&lt;p&gt;以下是mysql_servers表的字段属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;|       字段          | 数据类型  | 允许null  | 默认值 |
|---------------------|----------|-----------|--------|
| hostgroup_id  (pk)  | int      | not null  | 0      |
| hostname      (pk)  | varchar  | not null  | 无     |
| port          (pk)  | int      | not null  | 3306   |
| status              | varchar  | not null  | online |
| weight              | int      | not null  | 1      |
| compression         | int      | not null  | 0      |
| max_connections     | int      | not null  | 1000   |
| max_replication_lag | int      | not null  | 0      |
| use_ssl             | int      | not null  | 0      |
| max_latency_ms      | int      | not null  | 0      |
| comment             | varchar  | not null  | ''     |&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，新添加一个节点时，唯一必须指定的字段就是hostname值。如果不指定&lt;code&gt;hostgroup_id&lt;/code&gt;，那么节点将自动加入到&lt;code&gt;hostgroup_id=0&lt;/code&gt;的组中。&lt;/p&gt;
&lt;p&gt;各字段的意义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;hostgroup_id&lt;/strong&gt;：该后端MySQL实例所在的主机组。注意，同一MySQL节点可属于多个主机组。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hostname,port&lt;/strong&gt;：后端MySQL监听的地址和端口。就是默认3306端口的意义&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;status&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ONLINE&lt;/strong&gt;：该后端MySQL节点完全正常。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SHUNNED&lt;/strong&gt;：该后端MySQL节点将暂时被ProxySQL自动避开(忽略)，原因可能是一个较短时间内发生了大量连接错误，也可能是该slave与master的数据延迟太大(replication lag)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OFFLINE_SOFT&lt;/strong&gt;：当某后端MySQL被设置为 OFFLINE_SOFT 时，ProxySQL将不会向它发送新的请求，但该节点正在执行的事务会继续执行，直到所有事务执行完毕后会进入非激活状态。也就是说，和该后端的连接会保持到事务执行完毕。这可以实现后端节点的graceful停止、重启。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OFFLINE_HARD&lt;/strong&gt;：当某后端MySQL被设置为 OFFLINE_HARD 时，ProxySQL将不会向它发送新的请求，该节点正在执行的事务也会立即中断。也就是直接将该后端杀掉。等价于删除该节点，或临时将其移除出组(例如出于维护的目的)。&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;weight&lt;/strong&gt;：节点在组中的权重值越高，ProxySQL会发送越多请求给它们。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;compression&lt;/strong&gt;：如果该字段的值设置为大于0，ProxySQL和该后端新建的连接中，ProxySQL将会先压缩数据再传输。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_connections&lt;/strong&gt;：和该后端允许建立的最大连接数。当达到最大数量时，即使该后端的权重很大，也不会和它新建连接。默认值为1000，表示每个后端最多能同时接受1000个连接。请确保该后端的&lt;code&gt;max_connections&lt;/code&gt;值是合理的，以避免MySQL超负荷时ProxySQL继续向其发送请求。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_replication_lag&lt;/strong&gt;：如果值大于0，ProxySQL的Monitor模块将会定期检查该&lt;strong&gt;slave&lt;/strong&gt;的复制是否延后于master，如果延迟的值大于该字段的值，ProxySQL将会暂时避开该节点，直到该slave赶上master。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;use_ssl&lt;/strong&gt;：如果设置为1，则和该后端MySQL建立SSL连接。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_latency_ms&lt;/strong&gt;：Monitory模块定期向该后端发起ping检查，如果该节点的ping时间大于该字段的值，则将其排除在连接池之外(尽管该节点仍处于ONLINE状态)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;comment&lt;/strong&gt;：该表的说明信息，可随便定义。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于该表各字段的用法，请参见&lt;a href=&quot;https://github.com/malongshuai/proxysql/wiki/MySQL-Server-Configuration&quot; title=&quot;在ProxySQL中配置后端MySQL Server&quot;&gt;官方手册&lt;/a&gt;(我已翻译)。&lt;/p&gt;
&lt;p&gt;以下是上面插入数据成功后的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select * from mysql_servers\G
*************************** 1. row ***************************
       hostgroup_id: 10
           hostname: 192.168.100.22
               port: 3306
             status: ONLINE
             weight: 1
        compression: 0
    max_connections: 1000
max_replication_lag: 0
            use_ssl: 0
     max_latency_ms: 0
            comment: 
*************************** 2. row ***************************
       hostgroup_id: 10
           hostname: 192.168.100.23
               port: 3306
             status: ONLINE
             weight: 1
        compression: 0
    max_connections: 1000
max_replication_lag: 0
            use_ssl: 0
     max_latency_ms: 0
            comment: 
*************************** 3. row ***************************
       hostgroup_id: 10
           hostname: 192.168.100.24
               port: 3306
             status: ONLINE
             weight: 1
        compression: 0
    max_connections: 1000
max_replication_lag: 0
            use_ssl: 0
     max_latency_ms: 0
            comment: &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，同一个节点是可以同时存在于多个组中的。最典型的情形是master既充当写节点，也充当读节点，这时它就同时存在于写组和读组。&lt;/p&gt;


&lt;p&gt;ProxySQL通过Monitor模块监控后端MySQL Server的&lt;code&gt;read_only&lt;/code&gt;值来自动调整节点所属的组。所以，在配置读、写组之前，必须先配置好监控。&lt;/p&gt;
&lt;p&gt;本文只简单介绍该模块的监控类型，以及如何配置监控。对于Monitor模块理论的详细介绍，请参见以下两篇文章：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/malongshuai/proxysql/wiki/Monitor-Module&quot; title=&quot;Monitor模块官方手册翻译&quot;&gt;Monitor模块官方手册翻译&lt;/a&gt;：关于Monitor模块和相关变量。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9281909.html&quot; title=&quot;Monitor模块线程池、连接池&quot;&gt;Monitor模块使用的线程池、连接池&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;monitor模块可以监控什么东西&quot;&gt;3.1 Monitor模块可以监控什么东西&lt;/h2&gt;
&lt;p&gt;首先看下Monitor库中的表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; show tables from monitor;
+------------------------------------+
| tables                             |
+------------------------------------+
| mysql_server_connect_log           |
| mysql_server_group_replication_log |
| mysql_server_ping_log              |
| mysql_server_read_only_log         |
| mysql_server_replication_lag_log   |
+------------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Monitor监控4种指标：connect、ping、read_only和replication lag。下面稍作介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.connect监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ProxySQL连接到各后端是否成功，成功/失败的连接将记录到表&lt;code&gt;mysql_server_connect_log&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.ping监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一种心跳检测。Monitor模块向所有后端MySQL节点发起ping检查，ping成功/失败的情况将记录到表&lt;code&gt;mysql_server_ping_log&lt;/code&gt;中。当ping某后端的失败次数达到了&lt;code&gt;mysql-monitor_ping_max_failures&lt;/code&gt;时表示失去心跳，将发送一个信号给MySQL的主机组管理器来杀掉和该后端节点的所有连接。&lt;/p&gt;
&lt;p&gt;请和connect监控区分开，connect监控是通过建立连接来检测和后端节点连接的连通性。ping监控是心跳检测，ProxySQL通过MySQL的一个ping API发送给后端MySQL服务上，然后等待ping回复，虽然是ping检测，但也是需要建立连接的。&lt;/p&gt;
&lt;p&gt;所以，有两个确定连接不可用公式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mysql-monitor_ping_max_failures * mysql-monitor_connect_timeout&lt;/li&gt;
&lt;li&gt;mysql-monitor_ping_max_failures * mysql-monitor_ping_timeout&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3.read_only监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;检查&lt;code&gt;mysql_replication_hostgroups&lt;/code&gt;表中所有节点的&lt;code&gt;read_only&lt;/code&gt;值，并记录到&lt;code&gt;mysql_server_read_only_log&lt;/code&gt;。如果&lt;code&gt;read_only=1&lt;/code&gt;，表示只读，是一个slave，这样的节点将会&lt;strong&gt;自动移入&lt;/strong&gt;&lt;code&gt;reader_hostgroup&lt;/code&gt;中，如果&lt;code&gt;read_only=0&lt;/code&gt;，表示可写，可能是master，这样的节点将会&lt;strong&gt;自动移入&lt;/strong&gt;&lt;code&gt;writer_hostgroup&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.replication lag监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;mysql_servers&lt;/code&gt;表中所有配置了&lt;code&gt;max_replication_lag&lt;/code&gt;的后端slave节点都检查复制延迟，通过&lt;code&gt;show slave status&lt;/code&gt;返回结果中的&lt;code&gt;Seconds_Behind_Master&lt;/code&gt;字段，判断slave和master之间的延迟程度，并记录到&lt;code&gt;mysql_server_replication_lag_log&lt;/code&gt;表中。&lt;/p&gt;
&lt;p&gt;如果Seconds_Behind_Master &amp;gt; max_replication_lag，表示该slave延迟很严重，ProxySQL会&lt;strong&gt;自动避开&lt;/strong&gt;这种slave节点，直到Seconds_Behind_Master &amp;lt; max_replication_lag。&lt;/p&gt;
&lt;p&gt;Monitor监控上述指标时，会使用MySQL节点上的用户连接到后端节点，所以，需要先在后端节点上创建负责监控的用户。监控connect、ping和read_only这3项指标时，该用户只需具有&lt;code&gt;USAGE&lt;/code&gt;权限，如果要监控replication lag指标，则需要&lt;code&gt;replication client&lt;/code&gt;权限。&lt;/p&gt;

&lt;h2 id=&quot;配置connect和ping监控&quot;&gt;3.2 配置connect和ping监控&lt;/h2&gt;
&lt;p&gt;首先，在后端节点上创建用于监控的用户，顺便为其授予&lt;code&gt;replication client&lt;/code&gt;权限。只需在一个写节点(例如master)上创建即可，它会复制到其它节点上。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create user monitor@'192.168.100.%' identified by 'P@ssword1!';
grant replication client on *.* to monitor@'192.168.100.%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，在ProxySQL上配置这个监控用户，配置方式是修改全局变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set mysql-monitor_username='monitor';
set mysql-monitor_password='P@ssword1!';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于ProxySQL上所有的配置修改都是在修改main库中对应的表，上面的变量在&lt;code&gt;main.global_variables&lt;/code&gt;中，所以上面两个set语句和下面两个update语句是等价的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;update global_variables set variable_value='monitor'
 where variable_name='mysql-monitor_username';

update global_variables set variable_value='P@ssword1!'
 where variable_name='mysql-monitor_password';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在将配置load到runtime之前，可以先查看下connect和ping对应的log表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select * from mysql_server_connect_log;
+----------------+------+------------------+-------------------------+---------------+
| hostname       | port | time_start_us    | connect_success_time_us | connect_error |
+----------------+------+------------------+-------------------------+---------------+
| 192.168.100.22 | 3306 | 1530968712977867 | 4174                    | NULL          |
| 192.168.100.23 | 3306 | 1530968712988986 | 4908                    | NULL          |
| 192.168.100.24 | 3306 | 1530968713000074 | 3044                    | NULL          |
| 192.168.100.22 | 3306 | 1530968772978982 | 3407                    | NULL          |
| 192.168.100.23 | 3306 | 1530968772989627 | 3404                    | NULL          |
| 192.168.100.24 | 3306 | 1530968773000778 | 3444                    | NULL          |
+----------------+------+------------------+-------------------------+---------------+

admin&amp;gt; select * from mysql_server_ping_log;
+----------------+------+------------------+----------------------+-------------+
| hostname       | port | time_start_us    | ping_success_time_us | ping_error  |
+----------------+------+------------------+----------------------+-------------+
| 192.168.100.22 | 3306 | 1530968712666540 | 452                  | NULL        |
| 192.168.100.23 | 3306 | 1530968712668779 | 458                  | NULL        |
| 192.168.100.24 | 3306 | 1530968712671541 | 324                  | NULL        |
| 192.168.100.22 | 3306 | 1530968722667071 | 1190                 | NULL        |
| 192.168.100.23 | 3306 | 1530968722669574 | 1162                 | NULL        |
| 192.168.100.24 | 3306 | 1530968722673162 | 1380                 | NULL        |
+----------------+------+------------------+----------------------+-------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难发现，监控操作在load到runtime之前就已经生效了。这是有意为之的：通过这种方式，可以在节点添加到生产环境之前执行一些基本的健康检查。&lt;/p&gt;
&lt;p&gt;监控的节点一切正常后(error=NULL)，将配置load到runtime。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;load mysql variables to runtime;
save mysql variables to disk;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;配置read_only监控和读写组&quot;&gt;3.3 配置read_only监控和读/写组&lt;/h2&gt;
&lt;p&gt;目前read_only和replication_lag的监控日志还是空。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select * from mysql_server_read_only_log;
Empty set (0.00 sec)

admin&amp;gt; select * from mysql_server_replication_lag_log;
Empty set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为还没有对ProxySQL中的节点分组：writer_hostgroup、reader_hostgroup。&lt;/p&gt;
&lt;p&gt;设置分组信息，需要修改的是main库中的&lt;code&gt;mysql_replication_hostgroups&lt;/code&gt;表(组复制则是&lt;code&gt;mysql_group_replication_hostgroups&lt;/code&gt;)，该表只有3个字段：第一个字段名为writer_hostgroup，第二个字段为reader_hostgroup，第三个字段为注释字段，可随意写。&lt;/p&gt;
&lt;p&gt;例如，指定写组的id为10，读组的id为20。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert into mysql_replication_hostgroups values(10,20);

admin&amp;gt; select * from mysql_replication_hostgroups;
+------------------+------------------+----------+
| writer_hostgroup | reader_hostgroup | comment  |
+------------------+------------------+----------+
| 10               | 20               | cluster1 |
+------------------+------------------+----------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该配置加载到RUNTIME生效之前，先查看下各mysql server所在的组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select hostgroup_id,hostname,port,status,weight from mysql_servers; 
+--------------+----------------+------+--------+--------+
| hostgroup_id | hostname       | port | status | weight |
+--------------+----------------+------+--------+--------+
| 10           | 192.168.100.22 | 3306 | ONLINE | 1      |
| 10           | 192.168.100.23 | 3306 | ONLINE | 1      |
| 10           | 192.168.100.24 | 3306 | ONLINE | 1      |
+--------------+----------------+------+--------+--------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3个节点都在&lt;code&gt;hostgroup_id=10&lt;/code&gt;的组中。&lt;/p&gt;
&lt;p&gt;现在，将刚才&lt;code&gt;mysql_replication_hostgroups&lt;/code&gt;表的修改加载到RUNTIME生效。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;load mysql servers to runtime;
save mysql servers to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;一加载，Monitor模块就会开始监控后端的read_only值，当监控到read_only值后，就会按照read_only的值将某些节点自动移动到读/写组。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，此处所有节点都在&lt;code&gt;id=10&lt;/code&gt;的写组，slave1和slave2都是slave，它们的&lt;code&gt;read_only=1&lt;/code&gt;，这两个节点将会移动到&lt;code&gt;id=20&lt;/code&gt;的组。如果一开始这3节点都在&lt;code&gt;id=20&lt;/code&gt;的读组，那么移动的将是Master节点，会移动到&lt;code&gt;id=10&lt;/code&gt;的写组。&lt;/p&gt;
&lt;p&gt;看结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select hostgroup_id,hostname,port,status,weight from mysql_servers;
+--------------+----------------+------+--------+--------+
| hostgroup_id | hostname       | port | status | weight |
+--------------+----------------+------+--------+--------+
| 10           | 192.168.100.22 | 3306 | ONLINE | 1      |
| 20           | 192.168.100.23 | 3306 | ONLINE | 1      |
| 20           | 192.168.100.24 | 3306 | ONLINE | 1      |
+--------------+----------------+------+--------+--------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置好read_only的监控后，Monitor模块会每隔一段时间监控一次read_only值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select * from mysql_server_read_only_log;
+----------------+------+------------------+-----------------+-----------+--------+
| hostname       | port | time_start_us    | success_time_us | read_only | error  |
+----------------+------+------------------+-----------------+-----------+--------+
| 192.168.100.22 | 3306 | 1530970372197917 | 8487            | 0         | NULL   |
| 192.168.100.23 | 3306 | 1530970372198992 | 7907            | 1         | NULL   |
| 192.168.100.24 | 3306 | 1530970372199835 | 8064            | 1         | NULL   |
| 192.168.100.22 | 3306 | 1530970373698824 | 10078           | 0         | NULL   |
| 192.168.100.23 | 3306 | 1530970373699825 | 9845            | 1         | NULL   |
| 192.168.100.24 | 3306 | 1530970373700786 | 10745           | 1         | NULL   |
+----------------+------+------------------+-----------------+-----------+--------+&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;配置replication-lag监控&quot;&gt;3.4 配置replication lag监控&lt;/h2&gt;
&lt;p&gt;Monitor模块会监控后端主机组中各slave的数据是否延迟于master，这个延迟行为称为&lt;code&gt;replication lag&lt;/code&gt;，俗称拖后腿。&lt;/p&gt;
&lt;p&gt;如果某个slave节点上的数据比master落后很多(临界值见下文)，表示这个slave节点处理速度慢，数据较旧。ProxySQL采用一种称为&lt;strong&gt;自动避开&lt;/strong&gt;(automatic shunned)的方式，&lt;strong&gt;临时避开&lt;/strong&gt;这个落后的节点。当ProxySQL避开某节点后，ProxySQL不会把SQL语句路由给这个节点。&lt;/p&gt;
&lt;p&gt;ProxySQL有几种情况可能会触发自动避开节点的行为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;和后端的连接断开。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;slave落后于master过多。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;和后端建立连接时，错误次数过多。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;second_behind_master=null时，即slave的SQL线程未运行，或者slave未连接到master。(不过这种自动避开的情况是可控的，见全局变量&lt;a href=&quot;https://github.com/malongshuai/proxysql/wiki/Global-variables#mysql-monitor_slave_lag_when_null&quot;&gt;mysql-monitor_slave_lag_when_null&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文介绍关于replication lag的内容。&lt;/p&gt;
&lt;p&gt;Monitor模块会每隔一段时间(&lt;code&gt;mysql-monitor_replication_lag_interval&lt;/code&gt;)去检查一次拖后腿情况，检测的方式是获取&lt;code&gt;show slave status&lt;/code&gt;中的&lt;code&gt;Seconds_Behind_Master&lt;/code&gt;字段值，然后和&lt;code&gt;mysql_servers&lt;/code&gt;表中&lt;code&gt;max_replication_lag&lt;/code&gt;字段的值比较：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Seconds_Behind_Master &amp;lt; max_replication_lag：表示落后程度尚在允许范围内。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Seconds_Behind_Master &amp;gt; max_replication_lag：表示落后太多，这样的节点应该避开。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有&lt;strong&gt;传统复制结构的slave节点才需要设置&lt;/strong&gt;&lt;code&gt;max_replication_lag&lt;/code&gt;字段，master无需设置，组复制和galera也无需设置，因为这两种复制结构中&lt;code&gt;show slave status&lt;/code&gt;的结果为空。例如，将读组中的所有节点都设置最多落后于master 10秒钟。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;update mysql_servers set max_replication_lag=10 where hostgroup_id=20;
load mysql servers to runtime;
save mysql servers to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，Seconds_Behind_Master的值并不总是可靠的，见 https://dev.mysql.com/doc/refman/5.7/en/show-slave-status.html 。&lt;/p&gt;


&lt;p&gt;配置好后端MySQL节点、监控、分组后，接下来要配置的是MySQL的用户。&lt;/p&gt;
&lt;p&gt;需要注意，ProxySQL中有3套用户：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;连接Admin管理接口(默认6032端口)使用一套用户名/密码。&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;分为管理员和普通用户，管理员用户具有写权限，能配置ProxySQL，普通用户只有几个库的读权限。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;管理员用户/密码通过变量&lt;code&gt;admin-admin_credentials&lt;/code&gt;设置，普通用户/密码通过变量&lt;code&gt;admin-stats_credentials&lt;/code&gt;设置。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;这部分用户名不能出现在mysql_users表中。&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;Monitor模块监控后端时，需要使用一个MySQL用户连接后端进行监控。&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;需要先在后端MySQL组中创建好这个用户监控的用户。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;监控connect、ping和read_only时，只需&lt;code&gt;USAGE&lt;/code&gt;权限，监控replication lag时需要&lt;code&gt;replication client&lt;/code&gt;权限。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;通过变量&lt;code&gt;mysql-monitor_username&lt;/code&gt;和&lt;code&gt;mysql-monitor_password&lt;/code&gt;将监控用户加入到ProxySQL中。&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;前端连接ProxySQL(默认6033端口)、ProxySQL连接后端MySQL时使用一套用户名/密码。&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;当前端app发送SQL请求时，需要使用这套用户。然后ProxySQL将SQL语句路由给某后端节点，需要使用同一个用户和后端建立连接并将SQL语句发送出去。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;需要现在后端MySQL组中创建好这套用户，因为ProxySQL需要连接后端，所以一般授权所有权限，例如root。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;通过mysql_users表将这些用户加入到ProxySQL中，每一行对应一个用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;添加mysql-users到proxysql&quot;&gt;4.1 添加MySQL users到ProxySQL&lt;/h2&gt;
&lt;p&gt;例如，使用root用户来处理SQL请求。先在后端的写节点(如master节点)上授权root，该操作会复制给其它节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grant all on *.* to root@'192.168.100.%' identified by 'P@ssword1!';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，向ProxySQL的&lt;code&gt;mysql_users&lt;/code&gt;插入这个用户即可。这个表的字段很多，大多数字段都有默认值，以下是大部分使用默认值的插入语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert into mysql_users(username,password,default_hostgroup) 
values ('root','P@ssword1!',10);

load mysql users to runtime;
save mysql users to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面指定了root用户的用户名、密码以及该用户默认的路由目标组。&lt;/p&gt;
&lt;p&gt;ProxySQL有多种粒度的路由规则，每个用户都有默认的路由目标组，当使用该用户发送的SQL语句没有能够匹配的语句级路由规则，则会将该SQL语句路由给该用户默认的路由目标组。&lt;/p&gt;
&lt;p&gt;例如，navicat工具使用root用户连接到了ProxySQL，发送了一个select语句，如果没有配置select语句的路由规则，那么这个select语句将默认路由给root用户的默认组。&lt;/p&gt;
&lt;p&gt;下面先介绍一下&lt;code&gt;mysql_users&lt;/code&gt;表中的密码相关内容，然后再详细介绍&lt;code&gt;mysql_users&lt;/code&gt;表。&lt;/p&gt;

&lt;h2 id=&quot;mysql_users表中用户的密码管理&quot;&gt;4.2 mysql_users表中用户的密码管理&lt;/h2&gt;
&lt;p&gt;ProxySQL向&lt;code&gt;mysql_users&lt;/code&gt;表添加用户时，支持明文密码和hash加密密码。这个hash密码和mysql的&lt;code&gt;password()&lt;/code&gt;的算法是一样的。&lt;/p&gt;
&lt;p&gt;但是，ProxySQL内部使用的是SQLite3引擎，不支持&lt;code&gt;password()&lt;/code&gt;。所以，想要向ProxySQL中使用hash加密密码，可以先通过mysql的&lt;code&gt;password()&lt;/code&gt;函数创建一个hash密码，然后copy到mysql_users表中。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@s4 ~]#  mysql -uroot -pP@ssword1! -e 'select password(&quot;P@ssword1!&quot;);' 
mysql: [Warning] Using a password on the command line interface can be insecure.
+-------------------------------------------+
| password(&quot;P@ssword1!&quot;)                    |
+-------------------------------------------+
| *50572A5FABC7DA9CEE5EB5977EDDE59E38967422 |
+-------------------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后插入到ProxySQL的mysql_users表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert into mysql_users(username,password,default_hostgroup) 
values ('root','*50572A5FABC7DA9CEE5EB5977EDDE59E38967422',10);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ProxySQL和MySQL对密码的处理方式都是：以&quot;*&quot;开头的密码，表示是hash加密密码。&lt;/p&gt;
&lt;p&gt;在MySQL和ProxySQL中，使用&lt;code&gt;SHA1(SHA1('clear_password'))&lt;/code&gt;对clear_password进行加密。无法根据加密的hash密码推导回原始的明文密码。&lt;/p&gt;
&lt;p&gt;当客户端连接到ProxySQL时，ProxySQL将使用该加密的密码对用户进行认证。如果该客户端是第一次认证，则ProxySQL会推导出一部分的hash密码&lt;code&gt;SHA1('clear_password')&lt;/code&gt;。推导出的信息会存储到runtime的内部数据结构中，以便ProxySQL连接后端MySQL时使用。&lt;/p&gt;
&lt;p&gt;从1.2.3版本开始，引入了一个布尔类型的全局变量&lt;code&gt;admin-hash_passwords&lt;/code&gt;，默认为true。该变量表示，内存数据库的&lt;code&gt;mysql_users&lt;/code&gt;表中的明文密码，在&lt;code&gt;load mysql users to runtime&lt;/code&gt;时，对明文密码进行hash加密，并保存到runtime数据结构中。有了这个特性，可以以另一种方式保存加密密码：只需将其刷回内存数据库即可。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Admin&amp;gt; SELECT username,password FROM mysql_users;
+----------+-----------+
| username | password  |
+----------+-----------+
| user1    | password1 |     # 明文密码
| user2    | password2 |
+----------+-----------+

Admin&amp;gt; LOAD MYSQL USERS TO RUNTIME;    # 加载到runtime数据结构

Admin&amp;gt; SELECT username,password FROM mysql_users;
+----------+-----------+
| username | password  |
+----------+-----------+
| user1    | password1 |    # 还是明文密码
| user2    | password2 |
+----------+-----------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候，runtime数据结构中的密码是加密密码，而内存数据库中的密码是明文密码。&lt;/p&gt;
&lt;p&gt;将runtime数据结构数据刷回内存数据库，即可将加密密码保存到内存数据库中，然后还可以将加密的密码持久化到disk。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Admin&amp;gt; save mysql users to memory;

Admin&amp;gt; SELECT username,password FROM mysql_users;
+----------+-------------------------------------------+
| username | password                                  |
+----------+-------------------------------------------+
| user1    | *668425423DB5193AF921380129F465A6425216D0 |
| user2    | *DC52755F3C09F5923046BD42AFA76BD1D80DF2E9 |
+----------+-------------------------------------------+

Admin&amp;gt; save mysql users to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;唯一需要注意的是，&lt;code&gt;admin-hash-passwords&lt;/code&gt;变量是&lt;code&gt;admin-&lt;/code&gt;变量而非&lt;code&gt;mysql-&lt;/code&gt;变量，这意味着修改了这个变量后(虽然基本不会去修改)，load/save操作的目标是&quot;admin variables&quot;，而非&quot;mysql variables&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;load admin variables to runtime;
save admin variables to disk;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;mysql_users表详细解释&quot;&gt;4.3 mysql_users表详细解释&lt;/h2&gt;
&lt;p&gt;以下是&lt;code&gt;mysql_users&lt;/code&gt;表的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;|     字段名             | 数据类型 | 可为空?  | 默认值 |
|-----------------------|---------|----------|-------|
|username    (pk,uk)    | VARCHAR | NOT NULL |       |
|password               | VARCHAR | NULL     |       |
|active                 | INT     | NOT NULL | 1     |
|use_ssl                | INT     | NOT NULL | 0     |
|default_hostgroup      | INT     | NOT NULL | 0     |
|default_schema         | VARCHAR | NULL     |       |
|schema_locked          | INT     | NOT NULL | 0     |
|transaction_persistent | INT     | NOT NULL | 1     |
|fast_forward           | INT     | NOT NULL | 0     |
|backend      (pk)      | INT     | NOT NULL | 1     |
|frontend     (uk)      | INT     | NOT NULL | 1     |
|max_connections        | INT     | NOT NULL | 10000 |&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各字段的意义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;username, password&lt;/strong&gt;：前端连接到ProxySQL以及ProxySQL连接到后端时使用的用户凭据。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;active&lt;/strong&gt;：&lt;code&gt;active=0&lt;/code&gt;的用户会保留在库中，但不会加载到runtime数据结构中，只有&lt;code&gt;active=1&lt;/code&gt;用户才是有效用户。该字段默认值为1。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;default_hostgroup&lt;/strong&gt;：如果该用户发送的查询语句无法匹配任何规则，则该查询会路由到该字段指定的默认组中。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;default_schema&lt;/strong&gt;：建立连接时默认将切换到该schema。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;schema_locked&lt;/strong&gt;：目前还不支持该功能。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;transaction_persistent&lt;/strong&gt;：如果正在和ProxySQL建立连接的客户端使用的用户设置了该字段，那么当该用户开启一个事务后，该客户端后续的请求都将路由到同一主机组中(无视查询规则)，使得事务在这个组中是持久的，避免同一事务分散到其它组，直到事务结束才可能会路由到其它主机组。注意，&lt;strong&gt;有些老版本中，这个字段默认值为0，强烈建议修改为1&lt;/strong&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fast_forward&lt;/strong&gt;：如果设置了该字段，ProxySQL将绕过查询处理层(重写语句、缓存)，直接将原请求语句转发给后端节点。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;frontend&lt;/strong&gt;：如果设置为1，前端将可以使用该用户(username,password)连接到ProxySQL。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;backend&lt;/strong&gt;：如果设置为1，ProxySQL将可以使用该用户(username,password)连接到后端节点。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max_connections&lt;/strong&gt;：使用该用户&quot;建立到ProxySQL的连接&quot;的最大数量。默认值为10000，所以每个用户最多和ProxySQL建立10000个连接。注意，这是前端到ProxySQL的连接限制，ProxySQL和某个后端节点的最大连接数量是通过&lt;code&gt;mysql_servers&lt;/code&gt;中的&lt;code&gt;max_connections&lt;/code&gt;字段控制的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，当前版本的ProxySQL要求所有的用户均设置frontend和backend为1(即所有用户都可以进行&lt;code&gt;frontend --&amp;gt; ProxySQL&lt;/code&gt;以及&lt;code&gt;ProxySQL --&amp;gt; backend&lt;/code&gt;的连接认证)。将来版本中，ProxySQL将分离这两部分连接的用户凭据。这样前端将永远不知道后端的用户凭据，它们只能通过中间的ProxySQL发送请求，无法直接和后端节点建立连接，从而提高安全性。&lt;/p&gt;
&lt;p&gt;关于快速转发fast_forward：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要求用一个不同的端口：正常的ProxySQL逻辑和&quot;fast forward&quot;的逻辑使用的是完全相同的代码/模块。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;fast forward是基于每用户的：根据连接到ProxySQL用户的设置，决定该用户是否启用、禁用fast forward功能。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;fast forward算法的启用是在用户认证之后：ProxySQL仍然需要先对客户端使用的用户进行认证，尽管客户端的请求会直接原样转发给后端，但ProxySQL仍然会和前端先建立好连接。这意味着，如果前端和ProxySQL的连接发生错误，也会被处理。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;fast forward不支持SSL连接。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果使用压缩功能，必须在两端都启用压缩。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;事务持久化transaction_persistent&quot;&gt;4.4 事务持久化：transaction_persistent&lt;/h2&gt;
&lt;p&gt;mysql_users表中的&lt;code&gt;transaction_persistent&lt;/code&gt;字段，当它的值为1时，表示事务持久化：当某连接使用该用户开启了一个事务后，那么在事务提交/回滚之前，所有的语句都路由到同一个组中，避免语句分散到不同组。在以前的版本中，默认值为0，不知道从哪个版本开始，它的默认值为1。我们期望的值为1，所以&lt;strong&gt;强烈建议插入用户后先检查下这个字段的值是否为1&lt;/strong&gt;，如果为0，则执行下面的语句修改为1。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;update mysql_users set transaction_persistent=1 where username='root';
update mysql_users set transaction_persistent=1 where username='sqlsender';
load mysql users to runtime;
save mysql users to disk;&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;添加后端节点、监控后端节点、添加MySQL用户是使用ProxySQL所必须完成的步骤。这3个步骤虽然需要操作的过程不多，但是涉及的内容还是比较多的。&lt;/p&gt;
&lt;p&gt;强烈建议将mysql_servers、mysql_users、mysql_replication_hostgroups这3个表的所有字段都了解一遍。不仅如此，要熟练使用ProxySQL，还应该对main库中的表的各个字段都比较熟悉，至少要知道它们什么意思。&lt;/p&gt;
&lt;p&gt;下面，将添加后端节点、监控后端节点、添加MySQL用户的操作过程抽取出来，算是个步骤总结：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;######### 1.添加后端节点
#
#
insert into mysql_servers(hostgroup_id,hostname,port) values
    (10,'192.168.100.22',3306),
    (10,'192.168.100.23',3306),
    (10,'192.168.100.24',3306);

load mysql servers to runtime;
save mysql servers to disk;

# 查看下各节点是否都是 ONLINE 
select * from mysql_servers\G


######### 2.在后端MySQL上创建监控用户和处理SQL语句的用户
#
# 在后端master节点上执行以下语句
#
create user monitor@'192.168.100.%' identified by 'P@ssword1!';
grant replication client on *.* to monitor@'192.168.100.%';
grant all on *.* to root@'192.168.100.%' identified by 'P@ssword1!';


######### 3.在ProxySQL中配置监控用户
#
#
set mysql-monitor_username='monitor';
set mysql-monitor_password='P@ssword1!';

# 以上两个set语句等价于下面两个update：
update global_variables set variable_value='monitor'
 where variable_name='mysql-monitor_username';

update global_variables set variable_value='P@ssword1!'
 where variable_name='mysql-monitor_password';

load mysql variables to runtime;
save mysql variables to disk;

# 查看下connect和ping的监控是否正常
select * from mysql_server_connect_log order by time_start_us desc limit 6;
select * from mysql_server_ping_log order by time_start_us desc limit 6;


######### 4.配置读、写组
#
#
insert into mysql_replication_hostgroups values(10,20);
load mysql servers to runtime;
save mysql servers to disk;


######### 5.在ProxySQL中配置MySQL用户
#
#
insert into mysql_users(username,password,default_hostgroup) 
values ('root','P@ssword1!',10);
load mysql users to runtime;
save mysql users to memory;
save mysql users to disk;

update mysql_users set transaction_persistent=1 where username='root';
load mysql users to runtime;
save mysql users to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在后面的文章中，我会介绍以下percona版本的ProxySQL，percona ProxySQL提供了一个管理工具，它能通过额外的配置文件自动化配置上面一大堆的操作，大大简化了初始搭建使用ProxySQL的过程。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Jul 2018 19:34:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9286922.html</dc:identifier>
</item>
<item>
<title>Mybatis学习系列（六）延迟加载 - 仍是少年</title>
<link>http://www.cnblogs.com/ashleyboy/p/9286814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashleyboy/p/9286814.html</guid>
<description>&lt;p&gt;延迟加载其实就是将数据加载时机推迟，比如推迟嵌套查询的执行时机。在Mybatis中经常用到关联查询，但是并不是任何时候都需要立即返回关联查询结果。比如查询订单信息，并不一定需要及时返回订单对应的产品信息，查询商品分类信息并不一定要及时返回该类别下有哪些产品，这种情况一下需要一种机制，当需要查看时，再执行查询，返回需要的结果集，这种需求在Mybatis中可以使用延迟加载机制来实现。延迟加载可以实现先查询主表，按需实时做关联查询，返回关联表结果集，一定程度上提高了效率。&lt;/p&gt;
&lt;h2&gt;Mapper.xml映射文件&lt;/h2&gt;
&lt;p&gt;以商品类别category和商品product为例，一个类别下可以有多个商品，一个商品属于一种类别。&lt;/p&gt;
&lt;p&gt;编写lazyLoadMapper.xml映射文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper 
    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; 
    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.sl.mapper.LazyLoadMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 分类信息查询 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;lazyLoadTest&quot;&lt;/span&gt;&lt;span&gt;  resultMap&lt;/span&gt;&lt;span&gt;=&quot;lazyLoadProductsByCategoryTest&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            select * from category where id=#{id}
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;lazyLoadProductsByCategoryTest&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.sl.po.Category&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;Id&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;Name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;remark&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;Remark&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 一个分类对应多个产品，此处使用collection &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;collection &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;productList&quot;&lt;/span&gt;&lt;span&gt; ofType&lt;/span&gt;&lt;span&gt;=&quot;com.sl.po.Product&quot;&lt;/span&gt;&lt;span&gt;  column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; select&lt;/span&gt;&lt;span&gt;=&quot;selectProductsByCategoryId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;collection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 嵌套查询返回商品信息，延迟加载将要执行的sql &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectProductsByCategoryId&quot;&lt;/span&gt;&lt;span&gt;  resultType&lt;/span&gt;&lt;span&gt;=&quot;com.sl.po.Product&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            select * from products where categoryid=#{id} 
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;启用延迟加载和按需加载&lt;/h2&gt;
&lt;p&gt;Mybatis配置文件中通过两个属性lazyLoadingEnabled和aggressiveLazyLoading来控制延迟加载和按需加载。&lt;/p&gt;
&lt;p&gt;lazyLoadingEnabled：是否启用延迟加载，mybatis默认为false，不启用延迟加载。lazyLoadingEnabled属性控制全局是否使用延迟加载，特殊关联关系也可以通过嵌套查询中fetchType属性单独配置（fetchType属性值lazy或者eager）。&lt;/p&gt;
&lt;p&gt;aggressiveLazyLoading：是否按需加载属性，默认值false，lazyLoadingEnabled属性启用时只要加载对象，就会加载该对象的所有属性；关闭该属性则会按需加载，即使用到某关联属性时，实时执行嵌套查询加载该属性。&lt;/p&gt;
&lt;p&gt;SqlMapConfig.xml中修改配置，注册lazyLoadMapper.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 启用延迟加载特性，不配置默认关闭该特性&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;setting &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;lazyLoadingEnabled&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;setting&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 按需加载: false:使用关联属性，及时加载;    true,加载对象，则加载所有属性， &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;setting &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;aggressiveLazyLoading&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注册Mapper.xml文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;mapper/lazyLoadMapper.xml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;运行测试&lt;/h2&gt;
&lt;p&gt;添加mapper接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('be67b46e-400a-4fa3-8787-f3bb3443dc86')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_be67b46e-400a-4fa3-8787-f3bb3443dc86&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_be67b46e-400a-4fa3-8787-f3bb3443dc86&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('be67b46e-400a-4fa3-8787-f3bb3443dc86',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_be67b46e-400a-4fa3-8787-f3bb3443dc86&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.mapper;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.po.Category;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.po.Product;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; LazyLoadMapper {
    
    
    Category lazyLoadTest(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;嵌套查询&lt;/span&gt;
    List&amp;lt;Product&amp;gt; selectProductsByCategoryId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cId);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d54aa678-16c7-4781-a2f3-c7946e6c5e7f')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d54aa678-16c7-4781-a2f3-c7946e6c5e7f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d54aa678-16c7-4781-a2f3-c7946e6c5e7f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d54aa678-16c7-4781-a2f3-c7946e6c5e7f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d54aa678-16c7-4781-a2f3-c7946e6c5e7f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.math.BigDecimal;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.DateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.ParseException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.io.Resources;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactoryBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.mapper.LazyLoadMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.mapper.ProductMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.mapper.UnitMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.po.Category;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.po.Product;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.po.ProductDetailInfo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.po.ProductInfo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.po.ProductVo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.po.User;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLazyLoadMapperClient {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义会话SqlSession&lt;/span&gt;
    SqlSession session = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    @Before
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义mabatis全局配置文件&lt;/span&gt;
        String resource = &quot;SqlMapConfig.xml&quot;&lt;span&gt;;
        InputStream inputStream &lt;/span&gt;=&lt;span&gt; Resources.getResourceAsStream(resource);
        SqlSessionFactoryBuilder builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder();
        SqlSessionFactory factory &lt;/span&gt;=&lt;span&gt; builder.build(inputStream);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据sqlSessionFactory产生会话sqlsession&lt;/span&gt;
        session =&lt;span&gt; factory.openSession();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 延迟加载&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testoneToManyTestCollectionSelect() {

        LazyLoadMapper mapper &lt;/span&gt;= session.getMapper(LazyLoadMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        Category category &lt;/span&gt;= mapper.lazyLoadTest(1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(category);&lt;/span&gt;
&lt;span&gt;        System.out.println(category.getName());

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (category.getProductList().size() &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Product pro : category.getProductList()) {
                System.out.println(pro);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭会话&lt;/span&gt;
&lt;span&gt;        session.close();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;运行程序查看sql执行记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201807/577318-20180710012931297-820214672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前配置：启用延迟加载lazyLoadingEnabled=true和按需加载aggressiveLazyLoading=false&lt;/p&gt;
&lt;p&gt;Step1: 执行Mapper方法lazyLoadTest，实际只执行了select * from category where id=#{id}&lt;/p&gt;
&lt;p&gt;Step2: 执行System.out.println(category.getName())，加载属性，由于启用按需加载aggressiveLazyLoading=false，name属性此前已加载好，所以此处无数据库交互&lt;/p&gt;
&lt;p&gt;Step3: 执行category.getProductList().size()，加载属性productList，按需加载需要执行延迟加载sql脚本select * from products where categoryid=#{id}，与数据库交互&lt;/p&gt;

&lt;p&gt;将aggressiveLazyLoading属性设为为true，即：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;setting &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;aggressiveLazyLoading&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再一下执行过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201807/577318-20180710013036922-736316620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时的配置：启用延迟加载lazyLoadingEnabled=true和关闭按需加载aggressiveLazyLoading=true（即加载对象则加载所有属性）&lt;/p&gt;
&lt;p&gt;Step1: 执行Mapper方法lazyLoadTest，实际只执行了select * from category where id=#{id}&lt;/p&gt;
&lt;p&gt;Step2: 执行System.out.println(category.getName())，访问name属性，由于启用按需加载aggressiveLazyLoading=true，关闭按需加载，则加载category对象时加载该对象的所有属性，执行延迟加载sql脚本select * from products where categoryid=#{id}，与数据库交互&lt;/p&gt;
&lt;p&gt;Step3: 执行category.getProductList().size()，访问productList属性，该 性step2已加载好，此处无需数据库交互&lt;/p&gt;
&lt;p&gt;对比上下两个step2可以发现 aggressiveLazyLoading=true /false的区别。&lt;/p&gt;

</description>
<pubDate>Mon, 09 Jul 2018 17:32:00 +0000</pubDate>
<dc:creator>仍是少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashleyboy/p/9286814.html</dc:identifier>
</item>
<item>
<title>二叉树(前序，中序，后序，层序)遍历递归与循环的python实现 - Byron_Wu</title>
<link>http://www.cnblogs.com/bjwu/p/9284534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bjwu/p/9284534.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://iclykofte.com/wp-content/uploads/2017/01/binary-tree.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二叉树的遍历是在面试使比较常见的项目了。对于二叉树的前中后层序遍历，每种遍历都可以递归和循环两种实现方法，且每种遍历的递归实现都比循环实现要简洁。下面做一个小结。&lt;/p&gt;
&lt;h2 id=&quot;一中序遍历&quot;&gt;一、中序遍历&lt;/h2&gt;
&lt;p&gt;前中后序三种遍历方法对于左右结点的遍历顺序都是一样的（先左后右），唯一不同的就是根节点的出现位置。对于中序遍历来说，根结点的遍历位置在中间。&lt;/p&gt;
&lt;p&gt;所以中序遍历的顺序：&lt;strong&gt;左中右&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;递归实现&quot;&gt;1.1 递归实现&lt;/h4&gt;
&lt;p&gt;每次递归，只需要判断结点是不是None，否则按照左中右的顺序打印出结点value值。&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;class Solution:
    def inorderTraversal(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        if not root:
            return [] 
        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;循环实现&quot;&gt;1.2 循环实现&lt;/h4&gt;
&lt;p&gt;循环比递归要复杂得多，因为你得在一个函数中遍历到所有结点。但是有句话很重要：&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;对于树的遍历，循环操作基本上要用到栈(stack)这个结构&lt;/strong&gt;&lt;/center&gt;
&lt;p&gt;对于中序遍历的循环实现，每次将当前结点(curr)的左子结点push到栈中，直到当前结点(curr)为None。这时，pop出栈顶的第一个元素，设其为当前结点，并输出该结点的value值，且开始遍历该结点的右子树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obiwong.is-programmer.com/user_files/obiwong/Image/thisfile.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，对于上图的一个二叉树，其循环遍历过程如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;[1]&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;[1,2]&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;[1,2,4]&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;[4]&lt;/td&gt;
&lt;td&gt;[1,2]&lt;/td&gt;
&lt;td&gt;4 -&amp;gt; None(4的右结点)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;[4,2]&lt;/td&gt;
&lt;td&gt;[1]&lt;/td&gt;
&lt;td&gt;2 -&amp;gt; 5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;[4,2]&lt;/td&gt;
&lt;td&gt;[1,5]&lt;/td&gt;
&lt;td&gt;None(5的左结点)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;[4,2,5]&lt;/td&gt;
&lt;td&gt;[1]&lt;/td&gt;
&lt;td&gt;5 -&amp;gt; None(5的右结点)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;[4,2,5,1]&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;[4,2,5,1]&lt;/td&gt;
&lt;td&gt;[3]&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;[4,2,5,1,3]&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可见，规律为：当前结点curr不为None时，每一次循环将当前结点curr入栈；当前结点curr为None时，则出栈一个结点，且打印出栈结点的value值。整个循环在stack和curr皆为None的时候结束。&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;class Solution:
    def inorderTraversal(self, root):
        stack = []
        sol = []
        curr = root
        while stack or curr:
            if curr:
                stack.append(curr)
                curr = curr.left
            else:
                curr = stack.pop()
                sol.append(curr.val)
                curr = curr.right
        return sol&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二前序遍历和后序遍历&quot;&gt;二、前序遍历和后序遍历&lt;/h2&gt;
&lt;p&gt;按照上面的说法，前序遍历指根结点在最前面输出，所以前序遍历的顺序是：&lt;strong&gt;中左右&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后序遍历指根结点在最后面输出，所以后序遍历的顺序是：&lt;strong&gt;左右中&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;递归实现-1&quot;&gt;2.1 递归实现&lt;/h4&gt;
&lt;p&gt;递归实现与中序遍历几乎完全一样，改变一下打印的顺序即可：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;class Solution:
    def preorderTraversal(self, root):  ##前序遍历
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        if not root:
            return [] 
        return  [root.val] + self.inorderTraversal(root.left) + self.inorderTraversal(root.right)
        
    def postorderTraversal(self, root):  ##后序遍历
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        if not root:
            return [] 
        return  self.inorderTraversal(root.left) + self.inorderTraversal(root.right) + [root.val]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改动的地方只有return时函数的打印顺序。&lt;/p&gt;
&lt;h4 id=&quot;循环实现-1&quot;&gt;2.2 循环实现&lt;/h4&gt;
&lt;p&gt;为什么把前序遍历和后序遍历放在一起呢？Leetcode上前序遍历是medium难度，后序遍历可是hard难度呢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际上，后序遍历不就是前序遍历的“反过程”嘛！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看前序遍历。我们仍然使用栈stack，由于前序遍历的顺序是&lt;strong&gt;中左右&lt;/strong&gt;，所以我们每次先打印当前结点curr，并将右子结点push到栈中，然后将左子结点设为当前结点。入栈和出栈条件（当前结点curr不为None时，每一次循环将当前结点curr入栈；当前结点curr为None时，则出栈一个结点）以及循环结束条件（整个循环在stack和curr皆为None的时候结束）与中序遍历一模一样。&lt;/p&gt;
&lt;p&gt;再看后序遍历。由于后序遍历的顺序是&lt;strong&gt;左右中&lt;/strong&gt;，我们把它反过来，则遍历顺序变成&lt;strong&gt;中左右&lt;/strong&gt;，是不是跟前序遍历只有左右结点的差异了呢？然而左右的差异仅仅就是.left和.right的差异，在代码上只有机械的差别。&lt;/p&gt;
&lt;p&gt;我们来看代码：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;class Solution:
    def preorderTraversal(self, root):  ## 前序遍历
        stack = []
        sol = []
        curr = root
        while stack or curr:
            if curr:
                sol.append(curr.val)
                stack.append(curr.right)
                curr = curr.left
            else:
                curr = stack.pop()
        return sol
        
    def postorderTraversal(self, root): ## 后序遍历
        stack = []
        sol = []
        curr = root
        while stack or curr:
            if curr:
                sol.append(curr.val)
                stack.append(curr.left)
                curr = curr.right
            else:
                curr = stack.pop()
        return sol[::-1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码的主体部分基本就是.right和.left交换了顺序，且后序遍历在最后输出的时候进行了反向（因为要从&lt;strong&gt;中右左&lt;/strong&gt;变为&lt;strong&gt;左右中&lt;/strong&gt;）&lt;/p&gt;
&lt;h2 id=&quot;三层序遍历&quot;&gt;三、层序遍历&lt;/h2&gt;
&lt;p&gt;层序遍历也可以叫做宽度优先遍历：先访问树的第一层结点，再访问树的第二层结点...然后一直访问到最下面一层结点。在同一层结点中，以从左到右的顺序依次访问。&lt;/p&gt;
&lt;h4 id=&quot;递归实现-2&quot;&gt;3.1 递归实现&lt;/h4&gt;
&lt;p&gt;递归函数需要有一个参数level，该参数表示当前结点的层数。遍历的结果返回到一个二维列表sol=[[]]中，sol中的每一个子列表保存了对应index层的从左到右的所有结点value值。&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;class Solution:
    def levelOrder(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        def helper(node, level):
            if not node:
                return
            else:
                sol[level-1].append(node.val)
                if len(sol) == level:  # 遍历到新层时，只有最左边的结点使得等式成立
                    sol.append([])
                helper(node.left, level+1)
                helper(node.right, level+1)
        sol = [[]]
        helper(root, 1)
        return sol[:-1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Q：如果仍然按层遍历，但是每层从右往左遍历怎么办呢？&lt;/p&gt;
&lt;p&gt;A：将上面的代码left和right互换即可&lt;/p&gt;
&lt;p&gt;Q：如果仍然按层遍历，但是我要第一层从左往右，第二层从右往左，第三从左往右...这种zigzag遍历方式如何实现？&lt;/p&gt;
&lt;p&gt;A：将&lt;code&gt;sol[level-1].append(node.val)&lt;/code&gt;进行一个层数奇偶的判断，一个用&lt;code&gt;append()&lt;/code&gt;，一个用&lt;code&gt;insert(0,)&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;    if level%2==1:
        sol[level-1].append(node.val)
    else:
        sol[level-1].insert(0, node.val)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;循环实现-2&quot;&gt;3.2 循环实现&lt;/h4&gt;
&lt;p&gt;这里的循环实现不能用栈了，得用队列queue。因为每一层都需要从左往右打印，而每打印一个结点都会在队列中依次添加其左右两个子结点，每一层的顺序都是一样的，故必须采用先进先出的数据结构。&lt;/p&gt;
&lt;p&gt;以下代码的打印结果为一个一维列表，没有采用二维列表的形式。&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;class Solution:
    def levelOrder(self, root):
        if not root:
            return []
        sol = []
        curr = root
        queue = [curr]
        while queue:
            curr = queue.pop(0)
            sol.append(curr.val)
            if curr.left:
                queue.append(curr.left)
            if curr.right:
                queue.append(curr.right)
        return sol&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实，如果需要打印成zigzag形式（相邻层打印顺序相反），则可以采用栈stack数据结构，正好符合先进后出的形式。不过在代码上还要进行其他改动。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Jul 2018 17:24:00 +0000</pubDate>
<dc:creator>Byron_Wu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bjwu/p/9284534.html</dc:identifier>
</item>
<item>
<title>golang基础--map字典 - failymao</title>
<link>http://www.cnblogs.com/failymao/p/9286858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/failymao/p/9286858.html</guid>
<description>&lt;p&gt;&lt;strong&gt;map 类似python语言中的dict（字典类型），以key-value形式存储数据&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;Key必须是支持&lt;code&gt;==&lt;/code&gt;或&lt;code&gt;！=&lt;/code&gt;比较运算的类型，不可以是函数，map或slice&lt;/li&gt;
&lt;li&gt;map查找比线性搜素快很多，但比使用索引访问数据的类型慢100倍&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;map使用make()函数创建，支持 &lt;code&gt;:=&lt;/code&gt;赋值的简单写法&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;//基本操作
func main() {
    //var m map[int]string //定义一个map变量
    //m = map[int]string{}      //第一种方式
    //m = make(map[int]string)  //第二种方式：使用make
    m := make(map[int]string) //第三种方式make直接初始化
    m[1] = &quot;ok&quot;               //赋值一对key-value
    a := m[1]                 //获取一个key对应的value值
    delete(m, 1)              //删除map中的某一个kefmt.Println(m)y
    fmt.Println(m)
    fmt.Println(a)
    fmt.Println(m)
}

/*output
map_init----&amp;gt;   map[]
map_add----&amp;gt;    map[1:ok]
map_get----&amp;gt;    ok
map_del----&amp;gt;    map[]
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;嵌套map: 类似python中的嵌套字典，取值，赋值时需要层层递进 ，且每次赋值时需要对内层map执行make初始化。&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;示例代码&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;fmt&quot;

func main() {
    var m map[int]map[int]string     //嵌套字典
    m = make(map[int]map[int]string) //初始化map--最外层
    m[1] = make(map[int]string)      //make初始化嵌套字典，第一个键对应的map类型
    m[1][1] = &quot;ok&quot;                   //key1_value1赋值
    b, ok := m[1][1]                 //使用多返回值，第二值返回值时bool类型，如果前一个有返回值，返回true,反之返回false
    fmt.Println(b, ok)
    fmt.Println(m)
    a, ok := m[2][1] //由于key2，对应的value2赋值前没有make初始化，所以，
    fmt.Println(a, ok)
    if !ok {
        m[2] = make(map[int]string)
    }
    m[2][1] = &quot;Good&quot;
    a, ok = m[2][1]
    fmt.Println(a, ok)
    fmt.Println(m)
}

/*输出
a, ok---&amp;gt;   ok true
m ---&amp;gt;      map[1:map[1:ok]]
a, ok---&amp;gt;        false
a, ok---&amp;gt;   Good true           //初始化后
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;for 迭代操作，类似python，dict操作，for k,v in dic.&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;示例代码&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;//for 迭代操作slice
package main
import &quot;fmt&quot;

func main() {
    sum := make([]map[int]string, 5) //初始化一个slice,元素是map类型
    for i := range sum {
        sum[i] = make(map[int]string, 1)
        sum[i][1] = &quot;ok&quot;
        fmt.Println(sum[i])
    }
    fmt.Println(sum)
}

/*输出
i=0---&amp;gt;     map[1:ok]
i=1---&amp;gt;     map[1:ok]
i=2---&amp;gt;     map[1:ok]
i=3---&amp;gt;     map[1:ok]
i=4---&amp;gt;     map[1:ok]
sum---&amp;gt;     [map[1:ok] map[1:ok] map[1:ok] map[1:ok] map[1:ok]]
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;map，间接排序，通过slice，对key进行排序。&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;示例代码&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;//间接排序,对key进行排序
package main

import &quot;fmt&quot;
import &quot;sort&quot; //排序包

func main() {
    m := map[int]string{1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot;, 4: &quot;d&quot;}
    s := make([]int, len(m))
    i := 0
    for k := range m {
        s[i] = k
        i++
    }
    sort.Ints(s)
    fmt.Println(s)
}
/*输出
[1 2 3 4]
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 09 Jul 2018 16:59:00 +0000</pubDate>
<dc:creator>failymao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/failymao/p/9286858.html</dc:identifier>
</item>
<item>
<title>Python类的内置方法 - zzzzou</title>
<link>http://www.cnblogs.com/zzzlw/p/9286828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzzlw/p/9286828.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;**（为了方便和美观，省略了各内置方法前后的__双下划线）**&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;newinit&quot;&gt;1、new、init&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;__new__&lt;/code&gt;方法是真正的类构造方法，用于产生实例化对象（空属性）。重写&lt;code&gt;__new__&lt;/code&gt;方法可以控制对象的产生过程。&lt;br/&gt;&lt;code&gt;__init__&lt;/code&gt;方法是初始化方法，负责对实例化对象进行属性值初始化，此方法必须返回None，&lt;code&gt;__new__&lt;/code&gt;方法必须返回一个对象。重写&lt;code&gt;__init__&lt;/code&gt;方法可以控制对象的初始化过程。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 使用new来处理单例模式

class Student:
    __instance = None

    def __new__(cls, *args, **kwargs):
        if not cls.__instance:
            cls.__instance = object.__new__(cls)
        return cls.__instance

    def sleep(self):
        print('sleeping...')

stu1 = Student()
stu2 = Student()

print(id(stu1), id(stu2))  # 两者输出相同
print(stu1 is stu2)  # True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;个人感觉，&lt;code&gt;__new__&lt;/code&gt;一般很少用于普通的业务场景，更多的用于元类之中，因为可以更底层的处理对象的产生过程。而&lt;code&gt;__init__&lt;/code&gt;的使用场景更多。&lt;/p&gt;
&lt;h3 id=&quot;strrepr&quot;&gt;2、str、repr&lt;/h3&gt;
&lt;p&gt;两者的目的都是为了显式的显示对象的一些必要信息，方便查看和调试。&lt;code&gt;__str__&lt;/code&gt;被&lt;code&gt;print&lt;/code&gt;默认调用，&lt;code&gt;__repr__&lt;/code&gt;被控制台输出时默认调用。即，使用&lt;code&gt;__str__&lt;/code&gt;控制用户展示，使用&lt;code&gt;__repr__&lt;/code&gt;控制调试展示。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 默认所有类继承object类，object类应该有一个默认的str和repr方法，打印的是对象的来源以及对应的内存地址

class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

stu = Student('zlw', 26)
print(stu)  # &amp;lt;__main__.Student object at 0x0000016ED4BABA90&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 自定义str来控制print的显示内容，str函数必须return一个字符串对象
# 使用repr = str来偷懒控制台和print的显示一致

class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f'{self.__class__}, {self.name}, {self.age}'
    
    __repr__ = __str__

stu = Student('zlw', 26)
print(stu)  # &amp;lt;class '__main__.Student'&amp;gt;, zlw, 26

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;call&quot;&gt;3、call&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;__call__&lt;/code&gt;方法提供给对象可以被执行的能力，就像函数那样，而本质上，函数就是对象，函数就是一个拥有&lt;code&gt;__call__&lt;/code&gt;方法的对象。拥有&lt;code&gt;__call__&lt;/code&gt;方法的对象，使用&lt;code&gt;callable&lt;/code&gt;可以得到&lt;code&gt;True&lt;/code&gt;的结果，可以使用&lt;code&gt;（）&lt;/code&gt;执行，执行时，可以传入参数，也可以返回值。所以我们可以使用&lt;code&gt;__call__&lt;/code&gt;方法来实现实例化对象作为装饰器：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
# 检查一个函数的输入参数个数, 如果调用此函数时提供的参数个数不符合预定义，则无法调用。

# 单纯函数版本装饰器
def args_num_require(require_num):
    def outer(func):
        def inner(*args, **kw):
            if len(args) != require_num:
                print('函数参数个数不符合预定义，无法执行函数')
                return None

            return func(*args, **kw)
        return inner
    return outer

@args_num_require(2)
def show(*args):
    print('show函数成功执行!')

show(1)  # 函数参数个数不符合预定义，无法执行函数
show(1,2) # show函数成功执行!
show(1,2,3)  # 函数参数个数不符合预定义，无法执行函数&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
# 检查一个函数的输入参数个数,
# 如果调用此函数时提供的参数个数不符合预定义，则无法调用。

# 实例对象版本装饰器
class Checker:
    def __init__(self, require_num):
        self.require_num = require_num

    def __call__(self, func):
        self.func = func

        def inner(*args, **kw):
            if len(args) != self.require_num:
                print('函数参数个数不符合预定义，无法执行函数')
                return None

            return self.func(*args, **kw)
        return inner

@Checker(2)
def show(*args):
    print('show函数成功执行!')

show(1)  # 函数参数个数不符合预定义，无法执行函数
show(1,2) # show函数成功执行!
show(1,2,3)  # 函数参数个数不符合预定义，无法执行函数&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;del&quot;&gt;4、del&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;__del__&lt;/code&gt;用于当对象的引用计数为0时自动调用。&lt;br/&gt;&lt;code&gt;__del__&lt;/code&gt;一般出现在两个地方：1、手工使用del减少对象引用计数至0，被垃圾回收处理时调用。2、程序结束时调用。&lt;br/&gt;&lt;code&gt;__del__&lt;/code&gt;一般用于需要声明在对象被删除前需要处理的资源回收操作&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 手工调用del 可以将对象引用计数减一，如果减到0，将会触发垃圾回收

class Student:

    def __del__(self):
        print('调用对象的del方法，此方法将会回收此对象内存地址')

stu = Student()  # 调用对象的__del__方法回收此对象内存地址

del stu

print('下面还有程序其他代码')&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student:

    def __del__(self):
        print('调用对象的del方法，此方法将会回收此对象内存地址')

stu = Student()  # 程序直接结束，也会调用对象的__del__方法回收地址&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;iternext&quot;&gt;5、iter、next&lt;/h3&gt;
&lt;p&gt;这2个方法用于将一个对象模拟成&lt;strong&gt;序列&lt;/strong&gt;。内置类型如列表、元组都可以被迭代，文件对象也可以被迭代获取每一行内容。重写这两个方法就可以实现自定义的迭代对象。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 定义一个指定范围的自然数类，并可以提供迭代

class Num:
    def __init__(self, max_num):
        self.max_num = max_num
        self.count = 0
        
    def __iter__(self):
        return self

    def __next__(self):
        if self.count &amp;lt; self.max_num:
            self.count += 1
            return self.count
        else:
            raise StopIteration('已经到达临界')
        
num = Num(10)
for i in num:
    print(i)  # 循环打印1---10&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;getitemsetitemdelitem&quot;&gt;6、getitem、setitem、delitem&lt;/h3&gt;
&lt;p&gt;重写此系列方法可以模拟对象成列表或者是字典，即可以使用&lt;code&gt;key-value&lt;/code&gt;的类型。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class StudentManager:
    li = []
    dic = {}

    def add(self, obj):
        self.li.append(obj)
        self.dic[obj.name] = obj

    def __getitem__(self, item):
        if isinstance(item, int):
            # 通过下标得到对象
            return self.li[item]
        elif isinstance(item, slice):
            # 通过切片得到一串对象
            start = item.start
            stop = item.stop
            return [student for student in self.li[start:stop]]
        elif isinstance(item, str):
            # 通过名字得到对象
            return self.dic.get(item, None)
        else:
            # 给定的key类型错误
            raise TypeError('你输入的key类型错误!')

class Student:
    manager = StudentManager()

    def __init__(self, name):
        self.name = name

        self.manager.add(self)

    def __str__(self):
        return f'学生: {self.name}'

    __repr__ = __str__


stu1 = Student('小明')
stu2 = Student('大白')
stu3 = Student('小红')
stu4 = Student('胖虎')

# 当做列表使用
print(Student.manager[0])  # 学生: 小明
print(Student.manager[-1])  # 学生: 胖虎
print(Student.manager[1:3])  # [学生: 大白, 学生: 小红]

# 当做字典使用
print(Student.manager['胖虎'])  # 学生: 胖虎&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;getattrsetattrdelattr&quot;&gt;7、getattr、setattr、delattr&lt;/h3&gt;
&lt;p&gt;当使用&lt;code&gt;obj.x = y&lt;/code&gt;的时候触发对象的&lt;code&gt;setattr&lt;/code&gt;方法，当&lt;code&gt;del obj.x&lt;/code&gt;的时候触发对象的&lt;code&gt;delattr&lt;/code&gt;方法。&lt;br/&gt;当尝试访问对象的一个不存在的属性时 &lt;code&gt;obj.noexist&lt;/code&gt; 会触发&lt;code&gt;getattr&lt;/code&gt;方法，&lt;code&gt;getattr&lt;/code&gt;方法是属性查找中优先级最低的。&lt;br/&gt;可以重写这3个方法来控制对象属性的访问、设置和删除。&lt;br/&gt;**特别注意：如果定义了getattr，而没有任何代码（即只有pass），则所有不存在的属性值都是None而不会报错,可以使用super().__getattr__()方法来处理**&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student:
    def __getattr__(self, item):
        print('访问一个不存在的属性时候触发')
        return '不存在'

    def __setattr__(self, key, value):
        print('设置一个属性值的时候触发')
        # self.key = value  # 这样会无限循环
        self.__dict__[key] = value

    def __delattr__(self, item):
        print('删除一个属性的时候触发')
        if self.__dict__.get(item, None):
            del self.__dict__[item]

stu = Student()
stu.name = 'zlw'  # 设置一个属性值的时候触发
print(stu.noexit)  # 访问一个不存在的属性时候触发 , 返回'不存在'
del stu.name  # 删除一个属性的时候触发&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;getatrribute&quot;&gt;8、getatrribute&lt;/h3&gt;
&lt;p&gt;这是一个&lt;strong&gt;属性访问截断器&lt;/strong&gt;，即，在你访问属性时，这个方法会把你的访问行为截断，并优先执行此方法中的代码，此方法应该是属性查找顺序中优先级最高的。&lt;br/&gt;&lt;strong&gt;属性查找顺序：&lt;br/&gt;实例的getattribute--&amp;gt;实例对象字典--&amp;gt;实例所在类字典--&amp;gt;实例所在类的父类(MRO顺序）字典--&amp;gt;实例所在类的getattr--&amp;gt;报错&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class People:
    a = 200

class Student(People):
    a = 100

    def __init__(self, a):
        self.a = a

    def __getattr__(self, item):
        print('没有找到:', item)

    def __getattribute__(self, item):
        print('属性访问截断器')
        if item == 'a':
            return 1
        return super().__getattribute__(item)

stu = Student(1)
print(stu.a)  # 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;enterexit&quot;&gt;9、enter、exit&lt;/h3&gt;
&lt;p&gt;这两个方法的重写可以让我们对一个对象使用&lt;code&gt;with&lt;/code&gt;方法来处理工作前的准备，以及工作之后的清扫行为。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
class MySQL:
    def connect(self):
        print('启动数据库连接，申请系统资源')

    def execute(self):
        print('执行sql命令，操作数据')

    def finish(self):
        print('数据库连接关闭，清理系统资源')

    def __enter__(self):  # with的时候触发，并赋给as变量
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):  # 离开with语句块时触发
        self.finish()

with MySQL() as mysql:
    mysql.execute()
    
# 结果:
# 启动数据库连接，申请系统资源
# 执行sql命令，操作数据
# 数据库连接关闭，清理系统资源&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;getsetdelete描述符研究中待补充&quot;&gt;10、get、set、delete、描述符(研究中，待补充）&lt;/h3&gt;
</description>
<pubDate>Mon, 09 Jul 2018 16:34:00 +0000</pubDate>
<dc:creator>zzzzou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzzlw/p/9286828.html</dc:identifier>
</item>
<item>
<title>单元测试-002UI自动化测试 - 胡锦涛_Steven</title>
<link>http://www.cnblogs.com/StevenHuSir/p/UnitTest_AutoTest.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StevenHuSir/p/UnitTest_AutoTest.html</guid>
<description>&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;一般来说，测试是发布之前的最后一道关卡。如果代码不能在测试中发现，那么BUG就会抵达用户，所以测试的完整性和可靠想十分重要。目前，大多数App 还停留在人工测试的阶段，但测试人员不会写代码，在很多测试场景下，人工测试的效率太低，容易出错。例如：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;1&amp;gt;一个App的核心功能，在每一次发布版本前的测试必定会跑一边所有到测试用例，不管对应的版本在当前版本有没有变化，如果这次测出新的BUG，测试人员在下一次发版本测试的时候，又不得不做这些重复的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;2&amp;gt;开发在写API请求相关代码的时候没有做数据容错，测试在人工测试的时候都是正常的数据，所以测试通过。上线了之后，后台配置数据的时候出了点小问题，导致大面积崩溃，Crash&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自动化测试&lt;/span&gt;&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;自动化测试就是写一些测试代码，&lt;strong&gt;&lt;span&gt;用代码代替人工去完成模块和业务的测试&lt;/span&gt;&lt;/strong&gt;。(&lt;span&gt;自动编译代码&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;TDD测试驱动代码&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;自动化测试有很多优点:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;     测试速度快，避免重复性的工作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;     &lt;span&gt;避免regression(回归)，让开发更有信心去修改和重构代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;     有了自动化测试，持续集成（CI）会变得更可可靠&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;     迫使开发人员写出更高质量的代码。（自动化测试不通过，代码不允许合并）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;自动化测试也有一些缺点:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;      &lt;span&gt;开发和维护成本高;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;      不能完全替代人工测试;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;      无法完全保证测试的准确性 - 让代码去判断一段逻辑是否正确很容易，但是，让代码判断一个控件显示是否正确却没那么容易。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
在做自动化测试之前，首先要问自己几个问题？
这个测试业务的变动是否频繁？
这个测试业务是否属于核心功能？
编写测试代码的成本有多少？
自动化测试能保证测试结果的准确么？
通常，我们会选择那些业务稳定，需要频繁测试的部分来编写自动化测试脚本，其余的采用人工测试，人工测试仍然是iOS App开发中不可缺少的一部分。
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;UI测试：&lt;span class=&quot;s2&quot;&gt;UI测试是模拟用户操作，进而从业务处层面测试。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;关于UI测试，有几个核心类需要掌握&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;strong&gt;&lt;span&gt;XCUIApplication&lt;/span&gt;&lt;/strong&gt; :测试应用代理  https://developer.apple.com/documentation/xctest/xcuiapplication&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;strong&gt;&lt;span&gt;XCUIElement&lt;/span&gt;&lt;/strong&gt; :一个UI上课件的视图对象 https://developer.apple.com/documentation/xctest/xcuielement&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;strong&gt;&lt;span&gt;XCUIElementQuery&lt;/span&gt;&lt;/strong&gt;:查找XCUIElement https://developer.apple.com/documentation/xctest/xcuielementquery&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;UI测试还有一个核心功能是&lt;strong&gt;&lt;span&gt;UI Recording&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;选中一个UI测试用例，然后点击图中的小红点既可以开始UI Recoding。你会发现&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;随着点击模拟器，自动合成了测试代码。（通常自动合成代码后，还需要手动的去调整）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180709234746836-1781558495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;&lt;span&gt;点击小红点即可自动编译-生成代码&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;在写UI测试用例的时候要注意：测试行为而不是测试代码.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;对应测试代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)setUp {
    [super setUp];
    self.continueAfterFailure &lt;/span&gt;=&lt;span&gt; NO;
    [[[XCUIApplication alloc] init] launch];
}
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)tearDown {
    [super tearDown];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)testLogin{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;XCUIApplication --&amp;gt; application&lt;/span&gt;
    XCUIApplication *app =&lt;span&gt; [[XCUIApplication alloc] init];
    [[[XCUIApplication alloc] init].buttons[&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] tap];
    XCUIElement &lt;/span&gt;*selfElement = [[[[app.otherElements containingType:XCUIElementTypeNavigationBar identifier:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] childrenMatchingType:XCUIElementTypeOther].element childrenMatchingType:XCUIElementTypeOther].element childrenMatchingType:XCUIElementTypeOther].element;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;XCUIElementTypeTextField&lt;/span&gt;
    XCUIElementQuery *textFiledQ =&lt;span&gt; [selfElement childrenMatchingType:XCUIElementTypeTextField];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;UI 元素&lt;/span&gt;
    XCUIElement *accountE = [textFiledQ elementBoundByIndex:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    XCUIElement &lt;/span&gt;*passwordE = [textFiledQ elementBoundByIndex:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Query -&amp;gt; 元素
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;XCUIElementTypeButton&lt;/span&gt;
    XCUIElementQuery *buttonQ =&lt;span&gt; [selfElement childrenMatchingType:XCUIElementTypeButton];
    XCUIElement &lt;/span&gt;*loginE = [buttonQ elementBoundByIndex:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入账号&lt;/span&gt;
&lt;span&gt;    [accountE tap];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; value attribute&lt;/span&gt;
    [accountE typeText:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入密码&lt;/span&gt;
&lt;span&gt;    [passwordE tap];
    [passwordE typeText:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;12345&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
    XCUIElement *key_delete = app.keys[&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    [key_delete doubleTap];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击登录&lt;/span&gt;
&lt;span&gt;    [loginE tap];
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180710000748144-1743803497.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;补充&lt;/span&gt;：&lt;span&gt;&lt;span&gt;列举一些&lt;/span&gt;常用的断言&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;XCTFail(format…) 生成一个失败的测试；

XCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过；

XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；

XCTAssert(expression, format...)当expression求值为TRUE时通过；

XCTAssertTrue(expression, format...)当expression求值为TRUE时通过；

XCTAssertFalse(expression, format...)当expression求值为False时通过；

XCTAssertEqualObjects(a1, a2, format...)判断相等，&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;a1 isEqual:a2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;值为TRUE时通过，其中一个不为空时，不通过；

XCTAssertNotEqualObjects(a1, a2, format...)判断不等，&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;a1 isEqual:a2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;值为False时通过，

XCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；

XCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；

XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（double或float类型）提供一个误差范围，当在误差范围（&lt;/span&gt;&lt;span&gt;+/-&lt;/span&gt;&lt;span&gt;accuracy）以内相等时通过测试；

XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；

XCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态）

XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；

XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；

XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；

XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；

XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Mon, 09 Jul 2018 16:16:00 +0000</pubDate>
<dc:creator>胡锦涛_Steven</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/StevenHuSir/p/UnitTest_AutoTest.html</dc:identifier>
</item>
<item>
<title>ParisGabriel：Python全栈工程师（0基础到精通）教程 第十一课 - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9286805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9286805.html</guid>
<description>
&lt;div align=&quot;left&quot;&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　ParisGabriel&lt;/span&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 　　　　　　　　　　　　　　感谢 大家的支持  你们的阅读评价就是我最好的更新动力  我会坚持吧排版做的越来越好 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div align=&quot;left&quot; readability=&quot;7&quot;&gt; 　　　　　　　　　　　　　　　　　　　　&lt;img id=&quot;aimg_Gc8tb&quot; class=&quot;zoom&quot; src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180708123626547-869442520.png&quot; alt=&quot;&quot; width=&quot;413&quot; height=&quot;136&quot; border=&quot;0&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　每天坚持 一天一篇 点个订阅吧  灰常感谢    当个死粉也阔以&lt;/span&gt;&lt;span&gt;&lt;img src=&quot;https://static.52pojie.cn/static/image/smiley/default/mad.gif&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;img src=&quot;https://static.52pojie.cn/static/image/smiley/default/mad.gif&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　&lt;span&gt;　　　　　　　&lt;span&gt;Python人工智能从入门到精通&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;列表创建函数：&lt;/strong&gt;&lt;br/&gt;　　list（可迭代对象）&lt;br/&gt;&lt;strong&gt;序列有5种：&lt;/strong&gt;&lt;br/&gt;　　star 字符串&lt;br/&gt;　　list 列表&lt;br/&gt;　　tuple 元组&lt;br/&gt;　　bytes   后面讲 &lt;br/&gt;　　bytearray  后面讲 &lt;br/&gt;　　序列运算符：&lt;br/&gt;　　in 、 not in&lt;br/&gt;　　&amp;gt;&lt;br/&gt;　　&amp;gt;=&lt;br/&gt;　　&amp;lt;&lt;br/&gt;　　&amp;lt;=&lt;br/&gt;　　+&lt;br/&gt;　　*&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列表的索引可以增加、删除、修改、列表的元素值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;切片赋值：&lt;/strong&gt;&lt;br/&gt;　　步长不等于1时切片赋值，赋值运算符的右侧的可迭代对象提供的元素&lt;br/&gt;　　的个数&lt;strong&gt;一定要等于切片切出的片数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;del语句：&lt;/strong&gt;&lt;br/&gt;　　用于删除列表的元素&lt;br/&gt;　&lt;strong&gt;　del&lt;/strong&gt; 列表 [索引]&lt;br/&gt;　&lt;strong&gt;　del&lt;/strong&gt; 列表 [切片]&lt;br/&gt;Python3中常用的序列相关函数：&lt;br/&gt;　　&lt;strong&gt;len（x）&lt;/strong&gt; 返回序列的长度&lt;br/&gt;　　&lt;strong&gt;max （x）&lt;/strong&gt; 返回最大元素&lt;br/&gt;　　&lt;strong&gt;min（x）&lt;/strong&gt; 返回序列最小元素&lt;br/&gt;　　&lt;strong&gt;sum（x）&lt;/strong&gt; 返回序列中所有原素的和&lt;br/&gt;　　&lt;strong&gt;any（x）&lt;/strong&gt; 真值测试，如果列表中有一个值为真返回true&lt;br/&gt;　　&lt;strong&gt;all（x）&lt;/strong&gt; 真值测试，如果列表中所有值为真返回true&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;列表的方法（method）&lt;/strong&gt;：&lt;br/&gt;&lt;strong&gt;help（list）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;[ ]内的参数代表可以省略&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　　　&lt;span&gt;方法&lt;/span&gt; 　　　　　　　　　　　　　　　　　　　　　　 &lt;span&gt;意义&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;L.index&lt;/strong&gt;(v [, begin[, end]])　　　　   　 返回对应元素的索引下标, &lt;strong&gt;begin：&lt;/strong&gt;为开始索引，&lt;strong&gt;end&lt;/strong&gt;：为结束索引,当 value 不存在时触发ValueError错误&lt;br/&gt;&lt;strong&gt;L.insert&lt;/strong&gt;(index, obj) 　　　　　　　　 将某个元素插放到列表中指定的位置 &lt;strong&gt;index&lt;/strong&gt;：索引 &lt;strong&gt;obj&lt;/strong&gt;：要插入的元素&lt;br/&gt;&lt;strong&gt;L.count&lt;/strong&gt;(x) 　　　　　　　　　　　　 返回列表中元素的个数 &lt;strong&gt;x&lt;/strong&gt;：元素&lt;br/&gt;&lt;strong&gt;L.remove&lt;/strong&gt;(x) 　　　　　　　　　　　从列表中删除第一次出现在列表中的值 &lt;strong&gt;x：&lt;/strong&gt;元素（例如列表内有2个3 删除第一个 依次进行）&lt;br/&gt;&lt;strong&gt;L.copy&lt;/strong&gt;() 　　　　　　　　　　　　   复制此列表（只复制一层，不会复制深层对象)&lt;br/&gt;&lt;strong&gt;L.append&lt;/strong&gt;(x) 　　　　　　　　　　    向列表中追加单个元素 可以追加可迭代对象元素&lt;br/&gt;&lt;strong&gt;L.extend&lt;/strong&gt;(list)　　　　　　　　　　    向列表追加另一个列表&lt;br/&gt;&lt;strong&gt;L.clear&lt;/strong&gt;() 　　　　　　　　　　　　   清空列表,等同于 &lt;strong&gt;L[:] = []&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;L.sort&lt;/strong&gt;(reverse=False) 　　  　　　　 将列表中的元素进行排序，默认顺序按值的&lt;strong&gt;小到大的顺序排列&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;L.reverse&lt;/strong&gt;() 　　　　　　　　　　    列表的&lt;strong&gt;反转&lt;/strong&gt;，用来改变原列表的&lt;strong&gt;先后顺序&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;L.pop&lt;/strong&gt;([index])　　　　　　　　　　 删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系（相当于取出元素不归还，可以用变量来接受）&lt;br/&gt;&lt;strong&gt;字符串的文本解析方法：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;S.split&lt;/strong&gt;（sep=None）　　　  将字符串使用sep作为分隔符分割字符串，返回分隔后的字符串列表，当不给定参数时，用空白字符作为分隔符分隔&lt;br/&gt;&lt;strong&gt;S.join&lt;/strong&gt;（iterable） 　　　　　用可迭代对象中的字符串，返回一个中间用S分隔组合的字符串 S=esp 要插入分割链接的字符 iterable：可迭代对象&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;潜拷贝和深拷贝：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;潜拷贝&lt;/strong&gt;shallow copy：&lt;br/&gt;　　help（list.copy）&lt;br/&gt;　　拷贝指在复制过程中，只复制&lt;span&gt;一层&lt;/span&gt;变量，不会复制&lt;span&gt;深成变量绑定的对象&lt;/span&gt;的复制过程&lt;br/&gt;　　例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; L = [3.1,3.2&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; L1 = [1, 2&lt;span&gt;, L]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; L2 =&lt;span&gt; L1.copy()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; L1
[&lt;/span&gt;1, 2, [3.1, 3.2&lt;span&gt;]]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; L2
[&lt;/span&gt;1, 2, [3.1, 3.2&lt;span&gt;]]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; L2[2][0] = 3.14
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; L1
[&lt;/span&gt;1, 2, [3.14, 3.2&lt;span&gt;]]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; L2
[&lt;/span&gt;1, 2, [3.14, 3.2]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225117760-1338462601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;深拷贝&lt;/strong&gt; deep copy：&lt;br/&gt;　　import copy # 导入copy 模块&lt;br/&gt;　　例如：&lt;br/&gt;　　L = [3.1, 3.2]&lt;br/&gt;　　L1 = [1, 2, L]&lt;br/&gt;　　L2 = L1.deep copy()&lt;br/&gt;　　L2[2][0] = 3.14&lt;br/&gt;　　print(L1) #[1, 2, [3.1, 3.2]]&lt;br/&gt;　　print(L2) #1, 2, [3.14, 3.2]]&lt;/p&gt;
&lt;p&gt;　　深拷贝&lt;span&gt;通常只对可变对象&lt;/span&gt;进行复制 ，不可变对象通常不会复制（这里深拷贝需要 import copy中的deepcopy  后面讲）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;br/&gt;　　L1 = [1, 2, [3.1, 3.2]]&lt;/p&gt;
&lt;p&gt;这里只是纯粹的调用关系  可以通过内存地址查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225537941-1231206426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　L2 = L1 　　　　　　　　 # 不拷贝 同时绑定一个对象&lt;br/&gt;　　L3 = L1.copy（）　　　　# 潜拷贝等同于 L3 = L1[:]&lt;br/&gt;　　import copy&lt;br/&gt;　　L4 = copy.deepcopy（L1） #深拷贝&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;列表推导式&lt;/strong&gt; list comprehension：&lt;br/&gt;　　列表推导式是用可迭代对象生成列表的表达式&lt;br/&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;br/&gt;　　[表达式 for 变量 in 可迭代对象]&lt;br/&gt;　　或&lt;br/&gt;　　[表达式 for 变量 in 可迭代对象 if 真值表达式]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　for in 表达式的 if 子句可以省略，省略后将对所有生成的对象进行求值处理&lt;br/&gt;　　如：生成1~9的平方的列表&lt;br/&gt;　　L= [x ** 2 for x in range(1,10)]&lt;br/&gt;&lt;span&gt;列表推到式的嵌套：&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;语法:&lt;/strong&gt;&lt;br/&gt;L=[表达式&lt;br/&gt;    for 变量1 in 可迭代对象1 if 真值表达式1&lt;br/&gt;        for 变量2 in 可迭代对象2 if 真值表达式2 ]&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;OK 今天的练习比较多 但是都很简单  争取把每个题都要理解他的原理 不懂得对照上面的参数进行核对一下就可以&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;想要入门IT就必须多写多练 写的代码也多 你就越熟练  越熟练经验越多  尝试不同的思路去分析  &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么时候写的想吐 什么时候才算会了  我们一起加油  &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709223236979-1710354272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;练习:&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;已知有列表:&lt;br/&gt;L = [3, 5]&lt;/p&gt;
&lt;p&gt;1) 用索引和切片等操作，将原列表改变为:&lt;br/&gt;L = [1, 2, 3, 4, 5, 6]&lt;br/&gt;2) 将列表反转,删除最后一个元素后打印此列表&lt;br/&gt;...&lt;br/&gt;print(L) # [6, 5, 4, 3, 2]&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
L = [3, 5&lt;span&gt;]
L[:] &lt;/span&gt;= range(1, 7&lt;span&gt;)
L[::&lt;/span&gt;-1] = range(1, 7)&lt;span&gt;#&lt;/span&gt;&lt;span&gt; L[:] = [range(6, 0, -1)]&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; L[-1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709230442731-841777932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;br/&gt;1. 写程序，让用户输入一些整数，当输入-1时结束输入，将这些数存于列表L中&lt;br/&gt;1) 打印用户共输入了几个数？&lt;br/&gt;2) 打印您输入的数的最大数是多少&lt;br/&gt;3) 打印您输入的数的最小数是多少&lt;br/&gt;4) 打印您输入的这些数的平均值是多少？&lt;/p&gt;
&lt;p&gt; 答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
L =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    a &lt;/span&gt;= int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please input at will integer (input '-1' over):&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; a &amp;lt;&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
    L.append(a)
L.sort()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;you input line number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, len(L))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top1:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, L[-1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lower1:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, L[0])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; average number :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sum(L) / len(L))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709232955277-1792381487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;/p&gt;
&lt;p&gt;1.已知有一个字符串&lt;br/&gt;s = “100， 200， 300， 500， 800”&lt;br/&gt;将其转换为整数的列表存于L列表中&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100,200,300,500,800&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
L &lt;/span&gt;= s.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709234143250-1815666216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.生成前40个婓波那契数（fibonacci）&lt;br/&gt;1 1 2 3 5 8 13 .....&lt;br/&gt;要求将这些数字保存在列表中&lt;br/&gt;打印这些数&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
L = [1, 1&lt;span&gt;]
a &lt;/span&gt;= 1&lt;span&gt;
b &lt;/span&gt;= 1
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    a &lt;/span&gt;+=&lt;span&gt; b
    b &lt;/span&gt;+=&lt;span&gt; a
    L &lt;/span&gt;+=&lt;span&gt; [a, b]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(L) &amp;gt; 38&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(L)
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;方法二
L &lt;/span&gt;= [1, 1&lt;span&gt;]
a &lt;/span&gt;= 1&lt;span&gt;
b &lt;/span&gt;=&lt;span&gt; 0
i &lt;/span&gt;=&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; i &amp;lt; 40&lt;span&gt;:
    a &lt;/span&gt;= a +&lt;span&gt; b
    b &lt;/span&gt;= a -&lt;span&gt; b
    L.append(b)
    i &lt;/span&gt;+= 1
&lt;span&gt;print&lt;/span&gt;(L)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709235109959-1607347331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;/p&gt;
&lt;p&gt;L= [1, 3, 2, 1, 6, 4, 2, ......98, 82]&lt;br/&gt;将列表中出现的重复数字存入另一个列表L2中&lt;br/&gt;要求：重复出现多次的数字在L2中只保留一份 （去重）&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
L =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    a &lt;/span&gt;= int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please input at will integer (input '-1' over):&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; a &amp;lt;&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
    L.append(a)
L2 &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L2:
        L2.append(x)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(L)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L2)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709235756918-2075091502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5.&lt;br/&gt;输入多行文字，存入列表中,&lt;br/&gt;每次输入回车后算一行&lt;br/&gt;任意输入多行，当输入回车(即输入空行时结束输入)&lt;br/&gt;1) 按原输入内容在屏幕上输出内容&lt;br/&gt;2) 打印出您共输入了多少行文字&lt;br/&gt;3) 打印出您共输入了多少个字符&lt;/p&gt;
&lt;p&gt;答案;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
L =&lt;span&gt; []
i &lt;/span&gt;=&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    a &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please input at will string direct Enter over:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; a == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
    i &lt;/span&gt;+=&lt;span&gt; len(a)
    L.append(a)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您共输入的行数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, len(L))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您共输入的字符：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180710000245930-1035966277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;6.&lt;br/&gt;1. 有字符串&quot;hello&quot;&lt;br/&gt;请用此字符串生成:&lt;br/&gt;'h e l l o' 和 'h-e-l-l-o'&lt;br/&gt;2. 写一个程序，让用户输入很多正整数，当输入小于零的数时结束输入,&lt;br/&gt;1) 打印这些数中最大的一个数&lt;br/&gt;2) 打印这些数中第二大的一个数&lt;br/&gt;3) 删除最小的一个数&lt;br/&gt;4) 打印剩余数的和&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;heool&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
L &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.join(s)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(L)
L &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.join(s)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180710000539435-706426041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.&lt;br/&gt;用列表推导式生成1~100内奇数的列表&lt;br/&gt;结果是: [1, 3, 5, 7, ..... 99]&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
L = [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(1, 100, 2&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
L = [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(1, 100) &lt;span&gt;if&lt;/span&gt; x % 2 !=&lt;span&gt; 0]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180710001000241-419798429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8.&lt;br/&gt;生成一个数值为 1 ~ 9的平方的列表，去掉所有的奇数的平方&lt;br/&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
L = [x**2 &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(2, 10, 2&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
L = [x**2 &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(2, 10) &lt;span&gt;if&lt;/span&gt; x % 2 ==&lt;span&gt; 0]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　　　　Python人工智能从入门到精通&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180710001145549-179776999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;加油！&lt;/p&gt;

</description>
<pubDate>Mon, 09 Jul 2018 16:14:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9286805.html</dc:identifier>
</item>
<item>
<title>Apollo 5 教你怎么把自己的配置放到 Spring 环境中 - 莫那-鲁道</title>
<link>http://www.cnblogs.com/stateis0/p/9286772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stateis0/p/9286772.html</guid>
<description>&lt;p&gt;目录：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;处理方案&lt;/li&gt;
&lt;li&gt;简单例子&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;有的时候，你可能需要在 Spring 环境中放入一些配置，但这些配置无法写死在配置文件中，只能运行时放入。那么，这个时候该怎么办呢？&lt;/p&gt;
&lt;p&gt;Apollo 就是搞配置的，那么自然会遇到这个问题，他是如何处理的呢？&lt;/p&gt;
&lt;h2 id=&quot;处理方案&quot;&gt;处理方案&lt;/h2&gt;
&lt;p&gt;首先要知道 Spring 环境中，一个配置的数据结构是什么？&lt;/p&gt;
&lt;p&gt;是抽象类 &lt;code&gt;PropertySource&amp;lt;T&amp;gt;&lt;/code&gt;， 内部是个 key value 结构。这个 T 可以是任意类型，取决于子类的设计。&lt;/p&gt;
&lt;p&gt;子类可以通过重写 getProperty 抽象方法获取配置。&lt;/p&gt;
&lt;p&gt;Spring 自身的 org.springframework.core.env.MapPropertySource 就重写了这个方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MapPropertySource extends EnumerablePropertySource&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; {

    public MapPropertySource(String name, Map&amp;lt;String, Object&amp;gt; source) {
        super(name, source);
    }


    @Override
    public Object getProperty(String name) {
        return this.source.get(name);
    }

    @Override
    public boolean containsProperty(String name) {
        return this.source.containsKey(name);
    }

    @Override
    public String[] getPropertyNames() {
        return StringUtils.toStringArray(this.source.keySet());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，他的泛型是 Map，getProperty 方法则是从 Map 中获取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apollo 就直接利用了这个类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-e67471ed5a73e2b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个不同的子类，不同的刷新逻辑。我们暂时不关心他们的不同。&lt;/p&gt;
&lt;p&gt;这两个类都会被 RefreshableConfig 组合，添加到 Spring 的环境中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.core.env.ConfigurableEnvironment;

public abstract class RefreshableConfig {

  @Autowired
  private ConfigurableEnvironment environment; // Spring 环境

  @PostConstruct
  public void setup() {
  // 省略代码
    for (RefreshablePropertySource propertySource : propertySources) {
      propertySource.refresh();
      // 注意：成功刷新后，放到 Spring 的环境中
      environment.getPropertySources().addLast(propertySource);
    }
  // 省略代码&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当从 Spring 的环境中获取配置的时候，具体代码是下面这样的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected &amp;lt;T&amp;gt; T getProperty(String key, Class&amp;lt;T&amp;gt; targetValueType, boolean resolveNestedPlaceholders) {
        for (PropertySource&amp;lt;?&amp;gt; propertySource : this.propertySources) {
            // 注意：这里调用的就是 propertySource.getProperty 方法，子类刚刚重写的方法
            Object value = propertySource.getProperty(key);
             // 省略无关代码........
            return convertValueIfNecessary(value, targetValueType);
        }
        return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring 维护了一个 PropertySource 的集合，这个结合是有顺序的，也就是说，排在最前面的优先级最高（遍历从下标 0 开始）。&lt;/p&gt;
&lt;p&gt;而用户可以在 PropertySource 里，维护一个配置字典（Map），这样，就类似 2 维数组的这样一个数据结构。&lt;/p&gt;
&lt;p&gt;所以，配置是可以重名的，重名时，以最前面的 PropertySource 中的配置为准。所以，Spring 留给了几个 API：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;addFirst(PropertySource&amp;lt;?&amp;gt; propertySource)&lt;/li&gt;
&lt;li&gt;addLast(PropertySource&amp;lt;?&amp;gt; propertySource)&lt;/li&gt;
&lt;li&gt;addBefore(String relativePropertySourceName, PropertySource&amp;lt;?&amp;gt; propertySource)&lt;/li&gt;
&lt;li&gt;addAfter(String relativePropertySourceName, PropertySource&amp;lt;?&amp;gt; propertySource)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从名字可以看出，通过这些 API，我们可以将 propertySource 插入到我们指定的地方。从而可以手动控制配置的优先级。&lt;/p&gt;
&lt;p&gt;Spring 中有个现成的 CompositePropertySource 类，内部聚合了一个 PropertySource Set 集合，当 getProperty(String name) 的时候，就会遍历这个集合，然后调用这个 propertySource 的 getProperty(name) 方法。相当于 3 维数组。&lt;/p&gt;
&lt;p&gt;大概的设计是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-bf02da7a86e22149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个环境中，有多个 PS（PropertySource 简称），每个 PS 可以直接包含配置，也可以再包装一层 PS。&lt;/p&gt;
&lt;h2 id=&quot;简单例子&quot;&gt;简单例子&lt;/h2&gt;
&lt;p&gt;我们这里有个简单的例子，需求：&lt;br/&gt;程序里有个配置，但不能写死在配置文件中，只能在程序启动过程中进行配置，然后注入到 Spring 环境中，让 Spring 在之后的 IOC 中，可以正常的使用这些配置。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class DemoApplication {

  @Value(&quot;${timeout:1}&quot;)
  String timeout;


  public static void main(String[] args) throws InterruptedException {
    ApplicationContext c = SpringApplication.run(DemoApplication.class, args);
    for (; ; ) {
      Thread.sleep(1000);
      System.out.println(c.getBean(DemoApplication.class).timeout);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;application.properties 配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;timeout=100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，我们在 bean 中定义了一个属性 timeout， 并在本地配置文件中写入了一个 100 的值，也在表达式中给了一个默认值 1。&lt;/p&gt;
&lt;p&gt;那么现在打印出来的就是配置文件中的值：100.&lt;/p&gt;
&lt;p&gt;但是，这不是我们想要的结果，所以需要修改代码。&lt;/p&gt;
&lt;p&gt;我们加入一个类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
class Test implements EnvironmentAware, BeanFactoryPostProcessor {

  @Override
  public void setEnvironment(Environment environment) {
    ((ConfigurableEnvironment) environment).getPropertySources()
        // 这里是 addFirst,优先级高于 application.properties 配置
        .addFirst(new PropertySource&amp;lt;String&amp;gt;(&quot;timeoutConfig&quot;, &quot;12345&quot;) {
          // 重点
          @Override
          public Object getProperty(String s) {
            if (s.equals(&quot;timeout&quot;)) {//
              return source;// 返回构造方法中的 source :12345
            }
            return null;
          }
        });
  }

  @Override
  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
      throws BeansException {
    // NOP
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后，结果：12345&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;2018-07-02 15:26:54.315  INFO 43393 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2018-07-02 15:26:54.327  INFO 43393 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 0.991 seconds (JVM running for 1.49)
12345
12345&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么加入了这个类，就能够代替配置文件中的属性呢？解释一下这个类的作用。&lt;/p&gt;
&lt;p&gt;我们要做的事情就是在 Spring 的环境中，插入自定义的 PS 对象，以便容器获取的时候，能够通过 getProperty 方法获取对应的配置。&lt;/p&gt;
&lt;p&gt;所以，我们要拿到 Spring 环境对象，还需要创建一个 PS 对象，并重写 getProperty 方法，同时，注意：自己的 PS 配置优先级需要高于容器配置文件的优先级，保险起见，放在第一位。&lt;/p&gt;
&lt;p&gt;PS 构造方法的第一个参数没什么用，就是一个标识符，第二个参数就是 source，可以定义为任何类型，String，Map，都可以，我们这里简单期间，就是一个 String，直接返回这个值，如果是 Map，就调用 Map 的 get 方法。&lt;/p&gt;
&lt;p&gt;为什么要实现 BeanFactoryPostProcessor 接口呢？ 实现 BeanFactoryPostProcessor 接口的目的是让该 Bean 的加载时机提前，高于目标 Bean 的初始化。否则，目标 Bean 中的 timeout 属性都注入结束了，后面的操作就没有意义了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;说白了，就是不想写配置文件！！！&lt;/p&gt;
&lt;p&gt;而且也不想改老项目的代码，老项目即使在删除配置文件的情况下，依然能够使用配置中心！&lt;/p&gt;
&lt;p&gt;这就需要熟悉 Spring 的配置加载逻辑和属性获取逻辑。&lt;/p&gt;
&lt;p&gt;现在，我们知道，只需要拿到 Spirng 的环境对象，并向环境中添加自定义的 PS 对象，重写 PS 的 getProperty 方法，即可获取配置（注意优先级）。&lt;/p&gt;
&lt;p&gt;还需要注意加载这个配置的 bean 的优先级也要很高，通常实现 BeanFactoryPostProcessor 接口就足够了，如果还不够，就需要做一些特殊操作。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Jul 2018 15:52:00 +0000</pubDate>
<dc:creator>莫那-鲁道</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stateis0/p/9286772.html</dc:identifier>
</item>
<item>
<title>JS ES6的变量的结构赋值 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/9286745.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/9286745.html</guid>
<description>&lt;p&gt;变量的结构赋值用户很多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、交换变量的值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let x = 1&lt;span&gt;;
let y &lt;/span&gt;= 2&lt;span&gt;;
[x,y] &lt;/span&gt;= [y,x]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码交换变量x和变量y的值，这样的写法不仅简洁，易读，语义非常清晰&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、从函数返回多个值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数只能返回一个值，如果要返回多个值，只能讲他们放在数组或者对象里返回。了解&lt;strong&gt;解构赋值&lt;/strong&gt;，取值这些值非常方便&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个数组&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; example(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [1,2,3&lt;span&gt;];
}
let [a,b,c] &lt;/span&gt;= example();&lt;br/&gt;[a,b,c];   //[1,2,3]
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个对象&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; example(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        foo:&lt;/span&gt;1&lt;span&gt;,
        bar:&lt;/span&gt;2&lt;span&gt;
    };
}
let {foo,bar} &lt;/span&gt;= example();&lt;br/&gt;foo;   //1&lt;br/&gt;bar;   //2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3、函数参数的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解构赋值可以方便的讲一组参数与变量名对应起来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数是一组有次序的值&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f([x,y,z]){
    console.log(x,y,z);
}
f([&lt;/span&gt;1,2,3]);  //1,2,3
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数是一组无次序的值&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func({x,y,z}){
    console.log(x,y,z);
}
func({z:&lt;/span&gt;3,y:2,x:1}); //1,2,3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4、提取JSON数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解构赋值对提取JSON对象中的数据尤其有用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
let jsonData =&lt;span&gt; {
    id:&lt;/span&gt;42&lt;span&gt;,
    status:&lt;/span&gt;&quot;OK&quot;&lt;span&gt;,
    data:[&lt;/span&gt;123,456&lt;span&gt;]             
} ;
let {id,status,data:number} &lt;/span&gt;=&lt;span&gt; jsonData;
console.log(id,status,number);   //42 &quot;OK&quot; (2) [123, 456]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5、函数参数的默认值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;、、、&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、遍历Map结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何部署了Iterator接口的对象都可以使用for... of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值获取名和键值就非常方便。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
map.set(&lt;/span&gt;'first','hello'&lt;span&gt;);
map.set(&lt;/span&gt;'second','world'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [key,value] of map){
    console.log(key,value);
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;//first hello&lt;br/&gt;//second world&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果只想获取键名，或者只想获取键值，可以这样写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取键名&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [key] of map){
    console.log(key);
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;//first&lt;br/&gt;//second&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取键值&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [,value] of map){
    console.log(value);
}&lt;br/&gt;//hello&lt;br/&gt;//world&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;7、输入模块的指定方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加载模块时，往往需要指定输入的方法。解构赋值使得输入语句非常清晰。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const {a,b} = require('source-map');
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 09 Jul 2018 15:41:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/9286745.html</dc:identifier>
</item>
<item>
<title>Python学习：14.Python面向对象（一） - BD-ld-2017</title>
<link>http://www.cnblogs.com/liudi2017/p/9286742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudi2017/p/9286742.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、面向对象简介&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Python设计之初，就是一门面向对象的语言，在Python中一切皆对象，而且在Python中创建一个对象也很简单，今天我们就来学习一下Python的面向对象的知识。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、两种编程方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在C#、Java中，只能使用面向对象编程，在Ruby、Python中可以使用函数编程以及面向对象进行编程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数式编程&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fetch(backend):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_record(backend,record):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;
fetch(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;www.oldboy.org&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
add_record(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;www.oldboy.org&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,xxxxx)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;面向对象编程&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Oldboy:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;类，用来封装几个函数&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; fetch(self,backend):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;self是python内部传的，用户我们传值时&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;        &lt;span&gt;#传的&lt;/span&gt;&lt;span&gt;第一个参数直接给backend&lt;/span&gt;
     
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_record(self,backend,record):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;

obj &lt;/span&gt;=&lt;span&gt; Oldboy()
obj.fetch()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1205099/201807/1205099-20180709200514517-283087359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　函数在类的外面就叫做函数，在类的里面就叫做方法，面向对象的情况下想要执行函数时需要根据这个类创建一个对象,通过对象访问函数。&lt;/p&gt;
&lt;p&gt;　　一般函数式编程的函数为模块的成员，而面向对象编程，类是模块的成员，函数是类的成员。&lt;/p&gt;
&lt;p&gt;　　面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。对象是特征和技能的结合，其中特征和技能分别对应对象的数据属性和方法属性。 &lt;br/&gt;优点是：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。 &lt;br/&gt;缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。于是我们经常看到一个游戏人某一参数的修改极有可能导致阴霸的技能出现，一刀砍死3个人，这个游戏就失去平衡。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、面向对象深度解析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.关于self的解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1205099/201807/1205099-20180709201156848-1228144941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.封装&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Oldboy:

　　&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fetch(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self.backend)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;因为参数self传的值为对象obj1，所以可以用self代替obj1&lt;/span&gt;
 
　　&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_record(self,record):
    　　&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;
obj1 &lt;/span&gt;=&lt;span&gt; Oldboy()
obj1.backend &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个参数，和obj1一起被存入内存&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;封装的非主流的方式&lt;/span&gt;
obj1.fetch()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;由于backend和obj1一起存入内存，所以不用再吧backend传过去，直接&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在函数里用self.backend使用&lt;/span&gt;
&lt;span&gt;
obj2 &lt;/span&gt;=&lt;span&gt; Oldboy()
obj2.backend &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ALEXSEL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
obj2.fetch()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里也显示出了self的作用，self可以标识对象，由于给两个对象传入的参数输不同，调用类的方法的时候，输出的内容就不同，这就是self的功能。&lt;/p&gt;
&lt;p&gt;应用：&lt;br/&gt;当有几个函数要传的参数相同时，封装比较简便&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.构造方法__init__&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当使用类创建对象的时候（obj = Foo()），默认执行__init__方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, bk):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#这个self为创建的对象，创建对象时默认执行__init__&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#所以可把需要多次传的参数在这里创建，代替上面那个&lt;/span&gt;
        self.name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#非主流的方法&lt;/span&gt;
        self.favor =&lt;span&gt; bk
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.favor)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建对象，实例，并将“xxx”封装到对象里&lt;/span&gt;
obj1 = Foo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建对象时，类里就会执行__init__方法（函数），这个xxx就传入到__init__的bk参数中&lt;/span&gt;
obj2 = Foo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


输出结果：
init
xxx
init
sss&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用场景：当同一类型的的方法具有相同的参数时，直接封装到对象即可。&lt;br/&gt;使用场景：把类当成模板，创建多个对象（对象内封装的数据可以不一样）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;四、上手练习&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;针对刚才了解的知识，我们进行一个简单的练习，输出同样的结果下，不同的两种写法，熟悉类中方法和属性的使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写法一：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; activity:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,age,gender):
        self.FlyAnAeroplane &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{:s},{:s},{:s},去开飞机&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(name,age,gender)
        self.GoToSchool &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{:s},{:s},{:s},去学校&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(name,age,gender)
        self.Farm &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{:s},{:s},{:s},去种田&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(name,age,gender)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; FlyAnAeroplane_one(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.FlyAnAeroplane)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; GoToSchool_one(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.GoToSchool)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; Farm_one(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.Farm)


obj &lt;/span&gt;= activity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
obj.FlyAnAeroplane_one()
obj.GoToSchool_one()
obj.Farm_one()
obj2 &lt;/span&gt;= activity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eric&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
obj2.FlyAnAeroplane_one()
obj2.GoToSchool_one()
obj2.Farm_one()


输出结果：
alexsel,&lt;/span&gt;10&lt;span&gt;,男,去开飞机
alexsel,&lt;/span&gt;10&lt;span&gt;,男,去学校
alexsel,&lt;/span&gt;10&lt;span&gt;,男,去种田
eric,&lt;/span&gt;60&lt;span&gt;,男,去开飞机
eric,&lt;/span&gt;60&lt;span&gt;,男,去学校
eric,&lt;/span&gt;60,男,去种田
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;写法二：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.age &lt;/span&gt;=&lt;span&gt; age
        self.gender &lt;/span&gt;=&lt;span&gt; gender

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; kaifeiji(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s,%s岁,%s,去开飞机&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (self.name, self.age, self.gender))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; quxuexiao(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s,%s岁,%s,去学校&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (self.name, self.age, self.gender))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; quzhongtian(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s,%s岁,%s,去种田&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (self.name, self.age, self.gender))


alexsel &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 10, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
alexsel.kaifeiji()
alexsel.quxuexiao()
alexsel.quzhongtian()

eric &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eric&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 90, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
eric.kaifeiji()
eric.quxuexiao()
eric.quzhongtian()


输出结果：
alexsel,10岁,男,去开飞机
alexsel,10岁,男,去学校
alexsel,10岁,男,去种田
eric,90岁,男,去开飞机
eric,90岁,男,去学校
eric,90岁,男,去种田&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;五、项目练习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在写这个项目之前，我们首先学习一下pickel模块。&lt;/p&gt;
&lt;p&gt;pickle可以将任何数据类型序列化，pickle只能在python中使用，pickle模块用于将内存中的python对象序列化成字节流，并可以写入任何类似文件对象中；它也可以根据序列化的字节流进行反序列化，将字节流还原为内存中的对象。&lt;/p&gt;
&lt;p&gt;pickle使用dump方法将内存对象序列化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt; pickle

li &lt;/span&gt;= list(range(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;))
dbfile &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pickle_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)    #必须以2进制打开文件，否则pickle无法将对象序列化只文件
pickle.dump(li, dbfile)
dbfile.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码即将list对象li序列化至文件“pickle_list&quot;中，下次再次运行时，可以通过pickle的load方法恢复list对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pickle

dbfile &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pickle_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
li &lt;/span&gt;=&lt;span&gt; pickle.load(dbfile)
dbfile.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开始项目练习&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pickle

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,age,weight):
        self.Name &lt;/span&gt;=&lt;span&gt; name
        self.Age &lt;/span&gt;=&lt;span&gt; age
        self.Weight &lt;/span&gt;=&lt;span&gt; weight

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
        self.Weight &lt;/span&gt;= self.Weight + 2   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每次吃饭，体重加1&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fitness(self):
        self.Weight &lt;/span&gt;= self.Weight - 1   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每次健身，体重减1&lt;/span&gt;
&lt;span&gt;


xiaoming &lt;/span&gt;= pickle.load(open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fitnessgame.obb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; xiaoming:            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断是否有小明这个对象，没有创建小明对象&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(xiaoming.Weight)
    xiaoming.fitness()
    xiaoming.fitness()
    xiaoming.fitness()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(xiaoming.Weight)
    pickle.dump(xiaoming,open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fitnessgame.obb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    xiaoming  &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10岁&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,200&lt;span&gt;)
    xiaoming.fitness()
    xiaoming.eat()
    xiaoming.eat()
    xiaoming.eat()
    xiaoming.eat()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(xiaoming.Weight)
    pickle.dump(xiaoming,open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fitnessgame.obb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;明天我们接着讲面向对象，明天继续讲面向对象中的继承。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Jul 2018 15:39:00 +0000</pubDate>
<dc:creator>BD-ld-2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudi2017/p/9286742.html</dc:identifier>
</item>
</channel>
</rss>