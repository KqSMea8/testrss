<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>我所参加的最贵的培训 - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8420654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8420654.html</guid>
<description>&lt;p&gt;上一篇《IT人士如何避免中年危机？》得到了很多关注，留言赞赏也创了本公众号（cloudman6）的记录。&lt;/p&gt;
&lt;p&gt;这个结果既在意料之中，也在意料之外。&lt;/p&gt;
&lt;p&gt;意料之中是因为这确实是个能够引发共鸣的话题。每个人的职业生涯有40多年，总会有低谷，总会遭遇风雨，只有未雨绸缪，提前做准备才能从容应对。&lt;/p&gt;
&lt;p&gt;意料之外是因为作为一个 IT 工程师，我没学过专业的投资理论，也没有傲人的投资成就，只是喜欢多了解世界，求知欲稍强，多些好奇心而已。&lt;/p&gt;
&lt;p&gt;写这篇文章，源于前段时间 IT 圈子发生了几件不幸的事情，自己也有了些危机感，不免也开始重新思考和规划人生。再加上最近参加了一个培训（待会儿细说），有感而发，也算是这段时间思考和行动的总结。&lt;/p&gt;
&lt;p&gt;投资本来是一个非常私人的事，但如果能给大家一点点启发，我认为也是有意义的。&lt;/p&gt;
&lt;p&gt;还是先简单总结一下上篇文章我们推理出的几个结论：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1. 投资对每个人都很重要。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2. 股票是很好的价值投资标的。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3. 中国股市适合价值投资。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4. 价值投资方法论：&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;找到优质的公司&lt;br/&gt;在它股价合理或低估的时候买入&lt;br/&gt;耐心等待其升值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们就来详细讨论如何实践这个方法论。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;最贵的培训&lt;/h2&gt;
&lt;p&gt;上周末，我参加了一个培训，&lt;em&gt;超级数字力&lt;/em&gt;，学费 13998，课程内容是教你：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过上市公司的财务报表判断企业的经营状况。&lt;br/&gt;根据财务数据推算上市公司股价的合理区间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看，这是不是正好可以用来实践价值投资方法论？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;先找出好公司，在合理的价位买入，在适当的时候卖出。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;不过先别激动，这个课程我其实一年前就知道了，等到一年后才报名参加是有原因的。&lt;/p&gt;
&lt;p&gt;课程价格不是重点，虽然 13998 很贵，但如果真的是干货，有效果，这个价格可以接受。&lt;/p&gt;
&lt;p&gt;关键是如何判断课程的价值。我采取的策略是 &lt;em&gt;多维度考察&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;首先这个课程是在我经常关注的一个知识型社群发布的，社群中的人大部分素质都很高，属于终身学习者，经常原创一些高质量的文章，也都是 &lt;em&gt;得到&lt;/em&gt; 的付费用户。我购买过社群的几个收费课程，都还不错，从这点看，课程质量应该有保证。（如果想知道是哪个社群，可公众号回复 &lt;em&gt;社群&lt;/em&gt; ）&lt;/p&gt;
&lt;p&gt;但毕竟 13998 不是小数，我还需要再等等。等什么呢？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;等吃过螃蟹的人的反馈。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;课程从 2017 年开始，每个月开一次，每次结束后都有人发文章分享，都是收获满满，物有所值，极力推荐。每多看到一篇分享，就增加了我对这门课的一分信心。毕竟我也希望真的有一门价值投资的实操课程。最终让我下定决心的是12月3号我信任的一个人参加培训后也推荐了这门课。&lt;/p&gt;
&lt;p&gt;接下来就是马上报名，不过12月份的课程已经报满，只好报了今年1月底的。&lt;/p&gt;
&lt;p&gt;等待了将近两个月，上周末终于参加了这个为期两天的特训。&lt;br/&gt;感受只有一个字：&lt;strong&gt;超值！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我给大家介绍一下课程的具体内容。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;如何找到优质的公司？&lt;/h2&gt;
&lt;p&gt;财务报表是上市公司经营的成绩单，通过财报可以判断出公司的基本面。&lt;/p&gt;
&lt;p&gt;等一下，你可能会问：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;财务报表可信吗？&lt;br/&gt;那不是会计做出来的吗？&lt;br/&gt;能反应企业的真实情况吗？&lt;br/&gt;财报不是可以作假吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很好，能提出这些问题说明你是个能独立思考的人。&lt;br/&gt;刚一上课老师就做出了解答。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;年报必须经过正规会计师事务所审计，考虑到会计师事务所违规成本太高，所以 &lt;em&gt;年报的可信度很高&lt;/em&gt; 。而月报、季报和半年报不要求审计，所以仅供参考。&lt;/p&gt;
&lt;p&gt;财报有三张：利润表、资产负债表和现金流量表。&lt;br/&gt;其中利润表最容易作假，即使有审计也很难发现。&lt;br/&gt;但现金流量表很难作假，而且这张表最重要，巴菲特也最看重这张表。&lt;/p&gt;
&lt;p&gt;一定要 &lt;em&gt;三张表一起看&lt;/em&gt;，通过交叉验证，能够分析出企业的真实情况。&lt;/p&gt;
&lt;p&gt;巴菲特会看 &lt;em&gt;连续5年&lt;/em&gt; 的财报，从中找出能够稳定获利的优秀企业。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以：&lt;strong&gt;通过财报能够挑选出优质企业&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那具体要如何做呢？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从现金流量、营运能力、盈利能力、财务结构、偿债能力五个关键维度综合衡量一家企业&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/CloudMan6/p/images/5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201802/775365-20180206065705638-373282222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;衡量有一套具体的操作方法，比如现金流量要看现金流量比率、现金流量允当比率、现金再投资比率是否满足 &amp;gt;100/100/10，如果不满足也不能立即判断现金流不好，需要再考察现金占总资产的比率是否 &amp;gt;10%，以及企业是否天天收现金（应收款项周转天数&amp;lt;15)。&lt;/p&gt;
&lt;p&gt;因为涉及到具体的会计科目，细节就不在这里展开了，大家只需要知道根据财报数据从五个维度对企业进行打分，最后综合得分高的就是好企业。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;通过这个方法真的能找到好企业吗？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;课程中有个实战环节，老师给我们每个小组发了100多份财报，让我们用学到的方法从中筛选出自己认为最好的公司。由于财报上没有标注企业的名称，我们唯一能做的就是通过财报数据做判断。我们每人分别看10份财报，然后挑选出最好的一份，然后将这一份与别人挑出的两两PK，最终选出本组最好的一份。&lt;br/&gt;&lt;img src=&quot;http://www.cnblogs.com/CloudMan6/p/images/5.5.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201802/775365-20180206065748920-1401885526.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后老师汇总了各组挑出的财报并揭晓答案，一共六家来自不同行业的上市公司入围：生物股份、承德露露、五粮液、恒瑞医药、老板电器和海天味业。&lt;/p&gt;
&lt;p&gt;老师发的财报都是截止到2016的年报。如果在2017年初我们通过这些财报挑出了这么一个投资组合并买入，到2017年底一年收益能有多少？下面是我算出的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/CloudMan6/p/images/6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201802/775365-20180206065809029-355017191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，除了承德露露表现不佳，其余股票都远远跑赢大盘，五粮液的收益甚至达到了 137.8%&lt;/p&gt;
&lt;p&gt;要知道，这些股票只是我们在半个小时内完全通过看财报从100多家公司中 &lt;em&gt;盲选&lt;/em&gt; 出来的。当时所有人都有一个想法：&lt;em&gt;要是在2017年初就参加了这个培训该有多好！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;不过更重要的是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们已经掌握了挑选优质企业的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照价值投资方法论，现在可以进入第二步了：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在股价合理或低估的时候买入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;-&quot;&gt;如何判断股价的合理区间？&lt;/h2&gt;
&lt;p&gt;老师给大家看了一张财报，五个维度都堪称完美，可以说是极品中的极品，这家公司就是 — &lt;em&gt;贵州茅台&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;作为中国的股王，贵州茅台的股价已经 700 多了，能买吗？&lt;br/&gt;公司无疑是极好的，但是不是好股票呢？&lt;br/&gt;请记住好股票的定义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好股票是股价合理或被低估的好公司的股票。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;能不能买还得计算一下股价的合理区间。&lt;br/&gt;公式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/CloudMan6/p/images/7.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201802/775365-20180206065846966-792919696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（如果想查看A股其他股票的估值区间，可公众号回复 &lt;em&gt;估值区间&lt;/em&gt; ）&lt;/p&gt;
&lt;p&gt;这个公式是推导出来的，具体过程就不展开了。可以看到，茅台股价的合理区间在【179.89 - 539.66】，这个价格是通过2016年的财报计算出来的，2017年初只有327块，当时的价格是不贵的，不过现在看已经很高了。再次感慨，如果是2017年初参加的培训……&lt;/p&gt;
&lt;p&gt;当然，不是说茅台就不能再涨了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这只是一个参考的区间，股价还会受到市场热度的影响。&lt;/li&gt;
&lt;li&gt;2017年的年报出来后，公式中的数字会有调整。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是，作为一名合格的价值投资者，我们追求的是长期的、稳定的投资回报，一定要选择价格合理的股票。也就是巴菲特常说的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要有足够的安全边际。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;什么时候卖？&lt;/h2&gt;
&lt;p&gt;买什么和什么时候买我们现在都知道了，那么接下来的问题是：什么时候卖？&lt;/p&gt;
&lt;p&gt;其实也不难。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果这家公司的财报显示公司经营很稳健，数据没有明显变坏，则可继续持有。&lt;/li&gt;
&lt;li&gt;反过来，当数据变坏了，已经不是一家好公司了，当然就该下车了。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里回答两个常见问题。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Q：在持股过程中，股价跌了怎么办？&lt;br/&gt;A：股价的短期走势是无法预测的。&lt;br/&gt;请记住，我们进行的是价值投资，投资逻辑是好公司的价值最终会反映到股价上。我们投资的周期都是以年为单位。价值投资策略不适合炒短线。&lt;/p&gt;
&lt;p&gt;Q：如果遇到股灾怎么办？死扛吗？&lt;br/&gt;A：股灾之前大概率都已经获利丰厚，在股票大幅升值的时候我们会降低持仓成本，锁定利润（具体方法下回分解）。而且当大势企稳后，价值最先回归的都是优质企业。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;-&quot;&gt;下一步做什么？&lt;/h2&gt;
&lt;p&gt;好了，到这里，我觉得已经把价值投资的具体实操方法讨论清楚了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;找到优质的公司&lt;br/&gt;在它股价合理或低估的时候买入&lt;br/&gt;耐心等待其升值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于我，接下来要做的是下面这几件事情：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;目前上市公司2017年财报还没出来（要到4月份），可以先通过2016年的财报筛选出优质企业，并计算合理股价区间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;等2017年财报出来后，进行二次筛选，挑选出好股票（请重温前面好股票的定义）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分批进行买入。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;专注本行和个人成长，做时间的朋友。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果你也希望实践价值投资，可以做下面这几件事情：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;报名参加 &lt;em&gt;超级数字力&lt;/em&gt; 培训。不过听老师说，由于年龄大了，可能再在大陆（老师来自宝岛）开一到两期班就不办了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;买本老师的《五大关键数字力》，与培训内容一样，不过很遗憾，目前亚马逊上缺货。希望你有渠道自己搞到。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果上面两个办法都不行，那你只能看我现学现卖了。&lt;br/&gt;2017年的财报出来后我会陆续在公众号里公布自己挑选出来的好公司和好股票，并给出理由。同时，我还会公开自己的投资过程。&lt;br/&gt;这样做的目的并不是要你跟我一起投资，因为这套方法我也是第一次用。这样做只是为了践行下面这个理念：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;知道了一个道理，理解了，认可了，就要用行动去实践。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;-&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;这次培训让我学会了如何看财务报表。&lt;br/&gt;有了这些财务知识，就能判断一家公司的基本面，从而挑选出绩优股。&lt;/p&gt;
&lt;p&gt;即便是不买股票，看懂财报也有很多好处。&lt;/p&gt;
&lt;p&gt;比如你有一家公司，上游有买你产品的公司A，下游有给你供货的公司B。经营过程中，你一定会担心A公司能否及时支付货款；你也会关注B公司的运营能力是否能够及时给你供货。而这些，都可以从财报中看出端倪。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;看懂财报能帮你挑选业务伙伴。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再举一个例子，现在处于风口浪尖上的乐视。&lt;br/&gt;2017年4月20号乐视CEO在致股东的信中有这么一段话：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;六年前，乐视网初登创业板，依靠版权内容和会员付费的创新模式，年营业收入达2.3亿元。如今，公司构建了互联网及云、内容、大屏三大子生态，实现&lt;em&gt;年营收超200亿元&lt;/em&gt;，市值超过600亿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;年营收&lt;/em&gt; 对应利润表中 &lt;em&gt;营业收入&lt;/em&gt; 这个会计科目。下面是乐视历年利润表的对比数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/CloudMan6/p/images/8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201802/775365-20180206065937748-2043216065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确实有220亿，而且相比上一年提升了69%！&lt;br/&gt;按照正常逻辑，大部分人都应该觉得乐视2016年挣了不少钱啊，是好公司！&lt;/p&gt;
&lt;p&gt;但是，还记得吗？我们前面说过：&lt;em&gt;利润表是最容易造价的！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;到底有没有挣到钱，要看&lt;strong&gt;现金流量表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/CloudMan6/p/images/9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201802/775365-20180206070003185-478286233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;营业活动现金流量是 &lt;em&gt;-10.68亿！&lt;/em&gt;&lt;br/&gt;什么意思？在营业额相比上一年增加了90个亿的情况下，现金流却是负的!而且比上年还少了19个亿(10.68+8.76)。用一个词形容就是 &lt;em&gt;入不敷出&lt;/em&gt;。如果不能获得持续融资，随时可能会因现金枯竭而破产。&lt;/p&gt;
&lt;p&gt;虽然我们不能确定乐视是否在报表上动了手脚，​但至少可以判断出乐视的经营状况其实并不乐观，并不像它的CEO说的那么好。&lt;br/&gt;如果看得懂财报，就不会对乐视目前的情况感到惊讶了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;懂财报能提高看待事物的洞察力。&lt;br/&gt;正如在上一篇文章谈到的，投资分两种：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;投资股票、期货、现货、黄金这类常见投资品种。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;投资自己&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这次培训完美地兼顾了这两种投资，所以才会觉得 &lt;strong&gt;超值！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下一篇我想跟大家谈另一个很重要的问题：&lt;em&gt;如何做资产配置？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201802/775365-20180206070023420-1032494110.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 22:37:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8420654.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 Canvas 绘制的电信网络拓扑图 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/8377854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/8377854.html</guid>
<description>&lt;p&gt;电信网结构（telecommunication network structure）是指电信网各种网路单元按技术要求和经济原则进行组合配置的组合逻辑和配置形式。组合逻辑描述网路功能的体系结构，配置形式描述网路单元的邻接关系，即以交换中心（或节点）和传输链路所组成的拓扑结构。常见的网络拓扑结构有星型结构、总线结构、环形结构、树形结构、网状结构、混合型拓扑以及蜂窝拓扑结构等，本文的例子主要描绘的是总线型拓扑，在显示上相对其他的结构类型来说更清晰明了，绘制起来也非常容易。&lt;/p&gt;
&lt;p&gt;虽然题目起的名字是电信网络拓扑图，几乎所有的拓扑图都能涵盖，例如基本网络图，网络拓扑图，机架图，网络通信图，3D网络图等等。&lt;/p&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/591709/201801/591709-20180129182919390-1438018385.gif&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个图看起来挺简单的，代码也少，但是内容不少。&lt;/p&gt;
&lt;p&gt;首先，机柜01、机柜02、机柜03 都是 ht.Group “组”类型，ht.Group 类型用于作为父容器包含孩子图元，在 GraphView 拓扑图（&lt;a href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com&lt;/a&gt;）上可通过双击进行展开合并，合并时会自定隐藏子孙图元节点， 如果有子节点有连线连接到外部时，合并的 Group 将代理进行连接。Group 的移动会带动孩子节点跟随， 孩子的位置和大小变化也会影响 Group 的展开图形和 position 位置。&lt;/p&gt;
&lt;p&gt;这边提到一个代理连线的问题，“代理”两个字可以很好地表明代理连线意义。实际上就是如果组内部的节点与组外部的节点有连线，那么在组合并的时候，会在这个组会“代理”与外部节点之间的连线，这个就是代理连线。我们拿机柜02来说吧，机柜02内部有一个“电脑”与“内部网络交换机”之间有两条连线，那么当我们双击机柜02合并时，实际上就相当于机柜02与“内部网络交换机”之间有两条连线了。&lt;/p&gt;
&lt;p&gt;那么，我们来看看如何绘制这个组以及组内部的节点吧，先创建“机柜02”的 Group 节点，因为整个例子我创建了三个 Group 节点，而且创建的方式都类似，因此把创建组的代码封装起来复用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createGroup(name, x, y) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; group = &lt;span&gt;new&lt;/span&gt; ht.Group();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组类型 实际上也是一个节点&lt;/span&gt;
    group.setExpanded(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置展开组&lt;/span&gt;
    group.setName(name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置组的名字&lt;/span&gt;
    group.s({&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置组的样式style&lt;/span&gt;
        'group.title.background': 'rgba(14,36,117,0.80)',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组展开后的title背景颜色，仅对group.type为空的类型起作用&lt;/span&gt;
        'group.background': 'rgba(14,36,117,0.40)',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组展开后的背景颜色&lt;/span&gt;
        'group.title.align': 'center'&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组展开后的title文字水平对齐方式，默认值为'left'，可设置为center和right&lt;/span&gt;
&lt;span&gt;    });
    group.setPosition(x, y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置组的位置&lt;/span&gt;
    group.setImage('images/服务器.json');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置拓扑上展现的图片信息，在GraphView拓扑图中图片一般以position为中心绘制&lt;/span&gt;
    dataModel.add(group);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将创建的组节点添加进数据容器中&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; group;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;组是可以通过双击展开合并的，展开的时候显示的是一个有标题栏的框（当然这些都是可以自定义的），合并的时候就显示上面代码中设置的 group.setImage 中的图片。&lt;/p&gt;
&lt;p&gt;所有机柜内部的节点都是 ht.Node 类型的节点，所以我也封装了一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createNode(image, parent, x, y) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt; ht.Node();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个 Node 节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (image) node.setImage(image);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的显示图片&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (parent) node.setParent(parent);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的父亲&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (x &amp;amp;&amp;amp; y) node.setPosition(x, y);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的位置&lt;/span&gt;
    dataModel.add(node);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将节点添加进数据容器中&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成机柜02：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/591709/201801/591709-20180129155544515-300721048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
cabinet = createGroup('机柜02', 146, 445);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建机柜02&lt;/span&gt;
createNode('images/正常.json', cabinet, 78, 440).s('label', '数据监控分析系统');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建带有“正常”图片的节点，并设置这个节点的文字为“数据监控分析系统”&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为连线需要的是“源节点”以及“终节点”，这边源节点是中间的“内部网络交换机”，我们再创建这个节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; line = createNode();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个节点&lt;/span&gt;
line.setSize(725, 20);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点大小&lt;/span&gt;
line.setPosition(310, 325);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点位置&lt;/span&gt;
line.s({&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的style属性&lt;/span&gt;
    'shape': 'roundRect',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;决定shape的形状，默认值为空，代表用image绘制。roundRect四周圆角矩形&lt;/span&gt;
    'shape.background': 'rgba(14,36,117,0.80)',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;背景填充颜色，为null代表不填充背景&lt;/span&gt;
    'shape.border.color': '#979797',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;边框颜色&lt;/span&gt;
    'shape.corner.radius': 10,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该参数指定roundRect类型的圆角半径，默认为空系统自动调节，可设置正数值&lt;/span&gt;
    'label': '内部网络交换机', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字内容，默认为空&lt;/span&gt;
    'label.position': 45,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字内容，默认为空&lt;/span&gt;
    'label.offset.x': 50,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字水平偏移，对于Edge意味着沿着连线方向水平偏移&lt;/span&gt;
    'label2': '内部网络交换机',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HT默认除了label.*的属性外，还提供了label2.*的属性，用于满足一个图元需要显示双文字的情况&lt;/span&gt;
    'label2.position': 48&lt;span&gt;,
    &lt;/span&gt;'label2.offset.x': 50&lt;span&gt;,
    &lt;/span&gt;'label2.offset.y': 2&lt;span&gt;,
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不知道你们有没有注意到，有一个 label2 的样式属性，这个是 HT 为了能在一个节点上添加两个 label 文本而增加的功能，label 属性和 label2 的属性是完全相同的，只要在设置属性的时候用 label 和 label2 区分开来就可以。&lt;/p&gt;
&lt;p&gt;源节点和终节点都具备了，可以制作连线了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
createEdge(line, createNode('images/电脑.json', cabinet, 185, 450), 'rgb(30,232,178)', -100, &lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数1 源节点，参数2 终节点，参数3 连线颜色，参数4 连线起始点的水平偏移，参数5 是否创建两条连线&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一点有趣的，“交换机”的部分，最左侧蓝色方形的节点和中间长条的节点并不是一体的，而是分离的，但是我通过 setHost 进行节点与节点间的吸附，然后反吸附回来，这样操作上就相当于这两个节点是一体的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; exchange = createNode('images/交换机.json', &lt;span&gt;null&lt;/span&gt;, -53, 313&lt;span&gt;);
exchange.setHost(line);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置吸附&lt;/span&gt;
line.setHost(exchange);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反吸附 又设置line的吸附为exchange&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 HT 会按照节点添加进数据容器中的顺序来进行层次的排列，我的交换机是在 line 的添加之后的，所以默认交换机的节点会显示在 line 之下，我们将默认的层级显示关闭，并设置交换机 exchange 显示在数据容器的顶部：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
dataModel.setAutoAdjustIndex(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将自动调整data在容器中索引顺序的开关关闭&lt;/span&gt;
dataModel.sendToTop(exchange);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将data在拓扑上置顶&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 代码就是这些，还有不懂的可以留言或者私信我也可以，大家一起探讨。&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 22:31:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/8377854.html</dc:identifier>
</item>
<item>
<title>ASP.NET没有魔法——ASP.NET MVC 模型验证 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/8424735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/8424735.html</guid>
<description>&lt;p&gt;　　在前面的文章中介绍了用户的注册及登录功能，在注册用户时可以通过代码的形式限制用户名及密码的格式，如果不符合要求那么就无法完成操作，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206230458045-153626949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　该功能的原理是Identity基于的Entity Framework组件在添加用户之前对用户提交数据进行校验后给出的错误信息。&lt;br/&gt;　　数据校验功能在每一个软件系统中都是非常必要的，为了避免用户输入无效或非法数据导致的系统错误，需要在数据进行处理或持久化之前对其进行验证确保数据的正确、有效性。&lt;/p&gt;
&lt;p&gt;　　本文将从以下几点来介绍ASP.NET MVC中的模型验证机制：&lt;br/&gt;　　● 输入验证&lt;br/&gt;　　● .NET 的验证简介&lt;br/&gt;　　● ASP.NET MVC的后端模型验证&lt;br/&gt;　　● ASP.NET MVC的客户端模型验证&lt;br/&gt;　　● 关于ASP.NET MVC的客户端验证&lt;br/&gt;　　● 自定义ASP.NET MVC中的模型验证&lt;/p&gt;
&lt;h2&gt;输入验证&lt;/h2&gt;
&lt;p&gt;　　输入验证的目的就是用来判断一个变量是否能够满足规定的要求，这里既然提到了“&lt;strong&gt;判断&lt;/strong&gt;”那么使用程序来实现时最直接的方式就是通过判断语句来完成，如：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206230606654-534827570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　但是在.Net中是否有一种统一的方式来实现数据的验证呢？否则每次通过判断语句来写验证代码既不能重用又影响阅读。&lt;/p&gt;
&lt;h2&gt;.NET 的验证简介&lt;/h2&gt;
&lt;p&gt;　　在.Net中提供了一种基于特性的数据类型标记(DataAnnotations)、验证机制。&lt;/p&gt;
&lt;p&gt;　　1、数据类型的标记：&lt;/p&gt;
&lt;p&gt;　　.Net中有一个名为system.componentmodel.dataannotations的类库，里面包含了很多特性(Attribute)。这些特性用于标记.Net类型中的属性的数据类型信息。比如数据长度、格式、能否为空等等。&lt;br/&gt;　　下图为该类库中的部分类型，从中可以看到如信用卡、邮件地址、最大/最小长度等特性类型：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206230719045-435067188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　数据标记特性(Data Annotation attributes)有三种类型，分别是：&lt;br/&gt;　　● 验证特性：用于执行验证规则，如邮箱地址、数据类型、数据长度、数字区间、正则表达式等验证特性。&lt;br/&gt;　　● 展示特性：用于指定被标记的类型或属性如何在UI上展示。&lt;br/&gt;　　● 模型关系特性：用于指定类成员与其它类型的关系，如外键特性等。&lt;br/&gt;　　下图是通过特性对一个实体类型的name属性进行标记的结果，从标记的名称可以轻易看出该name属性是必填的并且最大长度为30，展示的名称为“名称”。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206230848498-658101320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　但需要注意的是system.componentmodel.dataannotations所提供的&lt;span&gt;特性仅仅是一种描述&lt;/span&gt;，它不会因为你限制了一个字符串的长度就无法给它赋值超出限制的字符串，它&lt;span&gt;必须手动调用验证方法或者在ASP.NET MVC、EF中使用&lt;/span&gt;。(可参考：&lt;a href=&quot;https://stackoverflow.com/questions/6496705/how-do-data-annotations-wor&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/6496705/how-do-data-annotations-wor&lt;/a&gt;k)&lt;br/&gt;　　关于dataannotations提供的特性类型可参考：&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.aspx&quot; target=&quot;_blank&quot;&gt;https://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　2、数据类型的验证&lt;/p&gt;
&lt;p&gt;　　当使用数据特性标记对类型完成标记后，还需要通过专门的验证类型才可以完成验证，该类型同样存在于system.componentmodel.dataannotations程序集中名为Validator，下图是Validator的定义，从其描述来看该类用于对使用ValidationAttribute特性标记的类型、属性、方法进行验证：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206230936966-466512247.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　3、类型验证示例&lt;/p&gt;
&lt;p&gt;　　通过一个Console程序来演示如何使用.Net中的数据验证：&lt;br/&gt;　　首先创建一个Console程序，并添加System.ComponentModel.DataAnnotations程序集的引用，然后编写以下代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231017201-621347822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　运行后将输出以下错误信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231049810-1550695127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加显示特性后：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231117966-722398266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　优化了验证提示信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231153107-1458047447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4、自定义验证方式：&lt;/p&gt;
&lt;p&gt;　　系统内置的数据验证特性均是继承至ValidationAttribute类型，下面就通过继承该类型来实现一个自己的数据验证方式：&lt;br/&gt;　　首先添加一个继承ValidationAttribute的类型，并重写其IsValid方法，该方法中包含数据验证的逻辑，并设置相应的错误信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231238857-1117028905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后在相应的类属性上应用该特性：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231316451-1952285495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　验证结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231336685-1655924529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　关于自定义验证特性可参考：&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/cc668224.aspx&quot; target=&quot;_blank&quot;&gt;https://msdn.microsoft.com/en-us/library/cc668224.aspx&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC的模型验证&lt;/h2&gt;
&lt;p&gt;　　ASP.NET MVC中提供了基于特性标记的模型验证的功能，既只要在用做action参数的类型属性上添加对应的数据验证特性，那么ASP.NET MVC在进行模型绑定时就会&lt;span&gt;自动对被标记的属性进行验证&lt;/span&gt;。验证的结果通过Controller中的ModelState的IsValid属性体现。&lt;br/&gt;　　下面就介绍如何在ASP.NET MVC中为Model添加数据验证：&lt;/p&gt;
&lt;p&gt;　　1.使用特性为Model的属性进行标记，如必填、密码类型及属性间的比较等：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231456513-1246954498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.在Action代码中添加ModelState.IsValid判断，当出现错误时，将错误信息通过ModelState对象的AddModelError方法携带至View中：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231530716-604439026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180207003603435-779508725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3、在View中使用Html.ValidationSummary方法输出验证信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231612857-1746912201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注：如果View中有用于客户端验证的代码需要先注释掉@Scripts.Render(&quot;~/bundles/jqueryval&quot;)，该文件用于客户端验证，客户端验证在后面介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231653185-344233946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4、在页面上使用Html对象根据模型生成对应的html标签&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206232338701-2121391439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5、运行程序&lt;/p&gt;
&lt;p&gt;　　输入空的用户名和不匹配的两个密码，点击提交后：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231749263-163326357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　显示验证未通过：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231814873-1061998005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　页面上输出的内容：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231858982-1804275670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　6、使用display特性来优化属性名称的输出：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231926107-557558759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206231958732-1744112848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;ASP.NET MVC的客户端模型验证&lt;/h2&gt;
&lt;p&gt;　　前面介绍的是ASP.NET MVC服务端的模型验证，当数据提交到服务器时进行验证的方式，虽然能够在业务逻辑之前过滤数据无效的请求，但是仍然需要将请求发送到服务器，当请求过多时这些无效的请求会占用大量的服务器资源，所以如果能够在客户端完成相应的验证，那么对于客户来说提升了响应速度，而对于服务器来说减少了压力，ASP.NET MVC就结合Jquery Validation插件提供了浏览器端的数据验证功能。&lt;br/&gt;　　接下来就在上面代码的基础上，通过在页面中引入验证相关javascript实现在客户端验证：&lt;br/&gt;　　1、添加以下代码，引入验证相关Js代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206232435513-228378279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、使用Html对象的ForXXX方法在View上生成Model对应标记的Html代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206232536545-1525973210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、运行效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206232611810-920648795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果与服务端验证一致，但是点击注册按钮时不再去发送Post请求到服务器，而是通过js代码在浏览器完成的数据验证。&lt;/p&gt;
&lt;h2&gt;关于ASP.NET MVC的客户端验证&lt;/h2&gt;
&lt;h3&gt;Jquery Validation&lt;/h3&gt;
&lt;p&gt;　　Jquery Validation是一个Jquery的插件，它提供了强大的表单数据验证功能，可以简单快速的为Web应用添加一些常用的数据验证，如必填、数字、邮箱、电话号码、正则表达式等常用格式验证。&lt;br/&gt;　　它的验证功能是通过在表单的标签中添加一些属性或设置其类型来完成的，如下图所示，该代码来自官方文档，它提供了长度限制、必填、Email格式、Url格式的验证：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206232841138-338704356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更多关于Jquery Validation的内容可参考文档：&lt;a href=&quot;https://jqueryvalidation.org/documentation/&quot; target=&quot;_blank&quot;&gt;https://jqueryvalidation.org/documentation/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Unobtrusive Javascript&lt;/h3&gt;
&lt;p&gt;　　Unobtrusive Javascript可以译为非侵入式的Javascript，其目的就是为了分离HTML和Javascript，换句话说HTML中没有JavaScript代码，它们只有引用关系。这样做既可以避免代码混乱，又可以避免不同浏览器之间的兼容问题。&lt;br/&gt;　　而ASP.NET MVC是通过在HTML中的标签上插入data-val*等属性，对相应的标签进行标记，然后引入的js通过读取这些特殊标记来完成特定的功能，以下是通过Html.TextBoxFor方法生成HTML：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206232951763-318348380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从代码中可以看到除了input标签正常的属性外还生成了data-val为前缀的相关属性，这些属性将用于辅助js代码完成数据验证。&lt;/p&gt;
&lt;h3&gt;关于@Scripts.Render(&quot;~/bundles/jqueryval&quot;)：&lt;/h3&gt;
&lt;p&gt;　　首先Scripts对象的Render方法是用于将指定的脚本文件路径添加到页面中，而它的参数是一个字符串数组代表脚本文件的路径。&lt;br/&gt;　　那么~/bundles/jqueryval指向的是哪个文件呢？&lt;br/&gt;　　在ASP.NET MVC中提供了一个bundle的技术，它可以用来合并和压缩JavaScript和css文件，bundle的配置一般在App_Start目录下的BundleConfig.cs文件下，从下图的代码中就可以看出，~/bundles/jqueryval代表了能够被jquery.validate*匹配的所有文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206233124732-1305695212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后向注册路由一样将其注册到一个全局静态Bundle列表中：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206233222529-1831811622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样在UI上就可以使用~/bundles/jqueryval来获取到与验证相关的js文件，更多关于UI的内容将在后续文章中介绍。&lt;/p&gt;
&lt;h2&gt;自定义ASP.NET MVC中的模型验证&lt;/h2&gt;
&lt;p&gt;　　上面介绍了ASP.NET MVC中的模型验证，其内置了一些常用的验证方式，但是在实际开发中仍然会出现无法满足需求的情况，所以在这些情况下就需要根据实际需求来自定义验证，包括后端验证与前端验证。&lt;br/&gt;　　1、添加自定义验证特性：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206233608279-874165846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面代码需要注意以下几点：&lt;br/&gt;　　● 实现了ValidationAttribute类型并&lt;span&gt;重写了&lt;/span&gt;用于获取错误信息的&lt;span&gt;FormatErrorMessage方法&lt;/span&gt;以及用于验证数据的&lt;span&gt;IsValid方法&lt;/span&gt;。&lt;br/&gt;　　● &lt;span&gt;实现了&lt;/span&gt;System.Web.Mvc命名空间下的&lt;span&gt;IClientValidatable接口&lt;/span&gt;，该接口是ASP.NET MVC拓展的用于实现客户端验证的接口，该接口用于创建并返回一个验证规则列表，该验证规则主要包含了错误信息、验证类型、验证参数三个属性，其中错误信息在默认的信息中添加了“来自客户端验证”用于区分服务端验证。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206233740951-662913557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：由于客户端验证仅仅是ASP.NET MVC中的特性，所以IClientValidatable接口存在与System.Web.Mvc程序集中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2、拓展Jquery Validation插件，添加一个名为myblog.validate.extension.js的验证拓展文件，并对Jquery validation添加新的验证方法(&lt;span&gt;注：方法第一个参数与GetClientValidationRules方法中设置的ValidationType属性一致&lt;/span&gt;)，最后通过jQuery.validator.unobtrusive.adapters添加MVC与Jquery Validation的关联：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206233823029-1623839794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：添加关联代码时需要添加名称与ValidationType属性一致的messages及rules。&lt;/span&gt;&lt;br/&gt;　　3、将拓展的js文件引入页面中：&lt;br/&gt;　　bundleConfig.cs：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206233900779-1956173765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　页面代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206233914482-918608169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4、将新添加的特性应用到相应的类型属性上：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180207005247013-403144038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5、执行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/640251/201802/640251-20180206233931576-527110940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　数据验证对于应用程序来说是一个非常重要的功能，从本文的分析中可以看出，一个数据可能会在客户端录入时、服务器接收时以及业务逻辑处理时对其进行验证，那么可能会有疑问这些代码是否是重复的没必要的，答案是否定的，首先对于服务器来说所有来自客户端的数据都是不可信的，所以无论数据在浏览器中是否被验证过，都需要在服务端进行验证，而对于业务逻辑来说，它是一个整体，它自己本身就规定了什么数据是合法的什么是非法的，所以其本身就必须包含验证逻辑，否则该业务逻辑的单元测试都无法通过，而最后对于服务端的Model验证来说，它做为请求的接收者，决定了是否执行相应的业务逻辑，它们即独立又存在联系。&lt;/p&gt;
&lt;p&gt;　　另外文中还对涉及到的Unobtrusive Javascript进行了简要介绍，非侵入式JavaScript是一种思想，除了这里的数据验证外还可以将其用于其它地方。接下来的文章将对ASP.NET MVC如何将HTTP请求的数据绑定到Model进一步说明。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;　　&lt;a href=&quot;https://www.codeproject.com/articles/826304/basic-introduction-to-data-annotation-in-net-frame&quot; target=&quot;_blank&quot;&gt;https://www.codeproject.com/articles/826304/basic-introduction-to-data-annotation-in-net-frame&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.codeproject.com/Articles/1184173/DataAnnotations-in-Depth&quot; target=&quot;_blank&quot;&gt;https://www.codeproject.com/Articles/1184173/DataAnnotations-in-Depth&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.codeproject.com/Articles/287278/Unobtrusive-Validation-with-ASP-NET&quot; target=&quot;_blank&quot;&gt;https://www.codeproject.com/Articles/287278/Unobtrusive-Validation-with-ASP-NET&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;http://blog.darkthread.net/post-2011-07-27-unobtrusive-jquery-validation.aspx&quot; target=&quot;_blank&quot;&gt;http://blog.darkthread.net/post-2011-07-27-unobtrusive-jquery-validation.aspx&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;http://bradwilson.typepad.com/blog/2010/10/mvc3-unobtrusive-validation.html&quot; target=&quot;_blank&quot;&gt;http://bradwilson.typepad.com/blog/2010/10/mvc3-unobtrusive-validation.html&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.cnblogs.com/Leo_wl/p/4886622.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/Leo_wl/p/4886622.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ASP.NET没有魔法——ASP.NET MVC 模型验证&quot; href=&quot;http://www.cnblogs.com/selimsong/p/8424735.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/selimsong/p/8424735.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt; &lt;a id=&quot;post_title_link_7641799&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7641799.html&quot;&gt;ASP.NET没有魔法——目录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 17:14:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/8424735.html</dc:identifier>
</item>
<item>
<title>JavaScript中的类继承 - Jaxu</title>
<link>http://www.cnblogs.com/jaxu/p/8424720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaxu/p/8424720.html</guid>
<description>&lt;p&gt;　　&lt;a href=&quot;http://www.crockford.com/javascript/&quot; target=&quot;_blank&quot;&gt;JavaScript&lt;/a&gt;是一个&lt;em&gt;无class&lt;/em&gt;的面向对象语言，它使用原型继承而非类继承。这会让那些使用传统面向对象语言如C++和Java的程序员们感到困惑。正如我们所看到的，JavaScript的原型继承比类继承具有更强的表现力。&lt;/p&gt;
&lt;p&gt;　　但首先，要搞清楚我们为什么如此关注继承？主要有两个原因。首先是方便类型的转换。我们希望语言系统能够对那些相似类的引用进行自动转换。而对于一个要求对引用对象进行显示转换的类型系统来说只能获得很少的类型安全性。这对于强类型语言来说很重要，但是在像JavaScript这样的松散型语言中，永远不需要对对象引用进行强制转换。&lt;/p&gt;
&lt;p&gt;　　第二个原因是代码的复用。代码中存在大量拥有相同方法的对象是十分常见的。类可以通过一组定义来创建它们。另外存在很多相似的对象也很普遍，这些对象中只有少数有关添加和修改的方法存在区别。类的继承可以很有效地解决这些问题，但原型继承更有效。&lt;/p&gt;
&lt;p&gt;　　为了说明这一点，我们将介绍一点语法糖，它允许我们以类似于传统的class的语言来编写代码。然后我们将介绍一些有用的模式，这些模式不适用于传统的class语言。最后，我们将对语法糖进行解释。&lt;/p&gt;

&lt;p&gt;　　首先，我们添加了一个&lt;strong&gt;Parenizor&lt;/strong&gt;类，包含set和get两个方法，分别用来设置和获取&lt;strong&gt;value&lt;/strong&gt;，以及一个&lt;strong&gt;toString&lt;/strong&gt;方法，用来对parens中的&lt;strong&gt;value&lt;/strong&gt;进行包装。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Parenizor(value) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setValue(value);
}

Parenizor.method(&lt;/span&gt;'setValue', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
});

Parenizor.method(&lt;/span&gt;'getValue', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
});

Parenizor.method(&lt;/span&gt;'toString', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '(' + &lt;span&gt;this&lt;/span&gt;.getValue() + ')'&lt;span&gt;;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　语法看起来有点不太一样，但是应该很好懂。方法&lt;strong&gt;method&lt;/strong&gt;接受方法的名称和一个function，并将这个function作为公共方法添加到类中。&lt;/p&gt;
&lt;p&gt;　　然后我们可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
myParenizor = &lt;span&gt;new&lt;/span&gt; Parenizor(0&lt;span&gt;);
myString &lt;/span&gt;= myParenizor.toString();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　正如你所期望的，&lt;strong&gt;myString&lt;/strong&gt;的值为&quot;(0)&quot;.&lt;/p&gt;
&lt;p&gt;　　现在我们创建另一个类继承&lt;strong&gt;Parenizor&lt;/strong&gt;，除了&lt;strong&gt;toString&lt;/strong&gt;方法中对于&lt;strong&gt;value&lt;/strong&gt;为空或0的情况会输出&quot;&lt;strong&gt;-0-&lt;/strong&gt;&quot;外其余都和&lt;strong&gt;Parenizor&lt;/strong&gt;相同。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ZParenizor(value) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setValue(value);
}

ZParenizor.inherits(Parenizor);

ZParenizor.method(&lt;/span&gt;'toString', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getValue()) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.uber('toString'&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;-0-&quot;&lt;span&gt;;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的&lt;strong&gt;inherits&lt;/strong&gt;方法与Java中的&lt;strong&gt;extends&lt;/strong&gt;方法类似，&lt;strong&gt;uber&lt;/strong&gt;方法也与Java中的&lt;strong&gt;super&lt;/strong&gt;方法类似。它允许一个方法调用父类中的方法（只是改了名称以避开保留字的限制）。&lt;/p&gt;
&lt;p&gt;　　然后我们可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
myZParenizor = &lt;span&gt;new&lt;/span&gt; ZParenizor(0&lt;span&gt;);
myString &lt;/span&gt;= myZParenizor.toString();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这一次，&lt;strong&gt;myString&lt;/strong&gt;的值为&quot;-0-&quot;.&lt;/p&gt;
&lt;p&gt;　　JavaScript没有类，但是我们可以通过编程来实现它。&lt;/p&gt;

&lt;p&gt;　　通过操作一个函数的&lt;strong&gt;原型&lt;/strong&gt;对象，我们可以实现多重继承，从而使我们可以用多个类的方法来构建一个类。混合多重继承可能难以实现，并可能存在方法名称的冲突。我们可以在JavaScript中实现混合多重继承，但是在本例中我们将使用一个更严格的被称之为&lt;a href=&quot;https://www.cosmik.com/aa-october99/stan_freberg.html&quot; target=&quot;_blank&quot;&gt;Swiss继承&lt;/a&gt;的形式。&lt;/p&gt;
&lt;p&gt;　　假设有一个&lt;strong&gt;NumberValue&lt;/strong&gt;类，包含一个方法&lt;strong&gt;setValue&lt;/strong&gt;，该方法检查&lt;strong&gt;value&lt;/strong&gt;是否为某个特定范围内的数字，必要的时候会抛出异常。我们只需要&lt;strong&gt;ZParenizor&lt;/strong&gt;的&lt;strong&gt;setValue&lt;/strong&gt;和&lt;strong&gt;setRange&lt;/strong&gt;方法，而不需要&lt;strong&gt;toString&lt;/strong&gt;方法。那么我们可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ZParenizor.swiss(NumberValue, 'setValue', 'setRange');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样只会将我们需要的方法添加到类中。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;ZParenizor&lt;/strong&gt;还有另外一种写法。除了从&lt;strong&gt;Parenizor&lt;/strong&gt;类继承，我们还可以在构造函数中调用&lt;strong&gt;Parenizor&lt;/strong&gt;的构造函数，并传递返回的结果。通过这种方式，我们给构造函数添加&lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot; target=&quot;_blank&quot;&gt;特权方法&lt;/a&gt;，而不用再去为其添加公共方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ZParenizor2(value) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; that = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Parenizor(value);
    that.toString &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getValue()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.uber('toString'&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;-0-&quot;&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; that;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　类的继承是&lt;strong&gt;is-a&lt;/strong&gt;关系（公有继承），而寄生继承是&lt;strong&gt;was-a-but-now's-a&lt;/strong&gt;关系（私有继承与公有继承）。构造函数在对象的构造中发挥了很大的作用。注意&lt;strong&gt;uber&lt;/strong&gt;和&lt;strong&gt;super&lt;/strong&gt;方法仍然可用于特权方法。&lt;/p&gt;

&lt;p&gt;　　JavaScript的动态性允许我们添加或替换现有类的方法，&lt;strong&gt;method&lt;/strong&gt;方法可以随时被调用，这样类的所有实例在现在和将来都会有这个方法。我们可以在任何时候对一个类进行扩展。继承具有追溯性，我们把这个叫做&lt;em&gt;类的扩充&lt;/em&gt;（Class Augmentation），以避免与Java的&lt;strong&gt;extends&lt;/strong&gt;产生混淆。&lt;/p&gt;

&lt;p&gt;　　在静态面向对象语言中，如果你想要一个对象与另一个对象略微不同，就需要定义一个新的类。在JavaScript中，你可以将方法添加到单个的对象中，而不需要在定义额外的类。这个非常强大，因为你只需要写很少的类，并且类都可以很简单。回想一下，JavaScript对象就像哈希表，你可以随时添加新的值，如果值是function，那么它就成了一个方法。&lt;/p&gt;
&lt;p&gt;　　因此在上面的示例中，我根本不需要&lt;strong&gt;ZParenizor&lt;/strong&gt;类。我可以简单地修改我的实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
myParenizor = &lt;span&gt;new&lt;/span&gt; Parenizor(0&lt;span&gt;);
myParenizor.toString &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getValue()) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.uber('toString'&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;-0-&quot;&lt;span&gt;;
};
myString &lt;/span&gt;= myParenizor.toString();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我将&lt;strong&gt;toString&lt;/strong&gt;方法添加到我的&lt;strong&gt;myParenizor&lt;/strong&gt;实例中，而没有使用任何形式的继承。我们可以修改单个的实例，因为语言是无class的。&lt;/p&gt;

&lt;p&gt;　　为了使上面的示例能正常工作，我写了四个&lt;a href=&quot;http://en.wikipedia.org/wiki/Syntactic_sugar&quot; target=&quot;_blank&quot;&gt;sugar&lt;/a&gt;方法。首先是&lt;strong&gt;method&lt;/strong&gt;方法，它将一个实例方法添加到类中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Function.prototype.method = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (name, func) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prototype[name] =&lt;span&gt; func;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　它在&lt;strong&gt;Function.prototype&lt;/strong&gt;上添加了一个公共方法，因此所有的函数都通过Class Augmentation（类的扩充）获得了该方法。它接受一个名称和一个函数，并将它们添加到函数的&lt;strong&gt;原型&lt;/strong&gt;对象中。&lt;/p&gt;
&lt;p&gt;　　它返回&lt;strong&gt;this&lt;/strong&gt;. 当我编写一个不需要返回值的方法时，我通常都会返回&lt;strong&gt;this&lt;/strong&gt;，这样就具有了一个级联式的编程风格。&lt;/p&gt;
&lt;p&gt;　　接下来是&lt;strong&gt;inherits&lt;/strong&gt;方法，它用来表示一个类从另一个类继承。应该在两个类都被定义之后再调用这个方法，并且在继承类的方法之前添加该方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
Function.method('inherits', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (parent) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prototype = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; parent();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; d =&lt;span&gt; {}, 
        p &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.prototype;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prototype.constructor =&lt;span&gt; parent; 
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.method('uber', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; uber(name) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; d)) {
            d[name] &lt;/span&gt;= 0&lt;span&gt;;
        }        
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; f, r, t = d[name], v =&lt;span&gt; parent.prototype;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (t) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (t) {
                v &lt;/span&gt;=&lt;span&gt; v.constructor.prototype;
                t &lt;/span&gt;-= 1&lt;span&gt;;
            }
            f &lt;/span&gt;=&lt;span&gt; v[name];
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            f &lt;/span&gt;=&lt;span&gt; p[name];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;[name]) {
                f &lt;/span&gt;=&lt;span&gt; v[name];
            }
        }
        d[name] &lt;/span&gt;+= 1&lt;span&gt;;
        r &lt;/span&gt;= f.apply(&lt;span&gt;this&lt;/span&gt;, Array.prototype.slice.apply(arguments, [1&lt;span&gt;]));
        d[name] &lt;/span&gt;-= 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们继续对&lt;strong&gt;Function&lt;/strong&gt;进行扩充。我们创建了一个&lt;strong&gt;父类&lt;/strong&gt;的实例，并将其作为新的&lt;strong&gt;原型&lt;/strong&gt;。我们还修改了&lt;strong&gt;构造函数&lt;/strong&gt;的字段，并将&lt;strong&gt;uber&lt;/strong&gt;方法添加到&lt;strong&gt;原型&lt;/strong&gt;中。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Uber&lt;/strong&gt;方法在自己的&lt;strong&gt;原型&lt;/strong&gt;中查找指定的方法。这是在寄生继承或对象扩充的情况下调用的函数。如果我们进行类的继承，那么我们就需要在&lt;strong&gt;父类的原型&lt;/strong&gt;中找到这个函数。&lt;strong&gt;Return&lt;/strong&gt;语句使用函数的&lt;strong&gt;apply&lt;/strong&gt;方法来调用function，显示地设置&lt;strong&gt;this&lt;/strong&gt;并传递一个数组参数。参数（如果有的话）从&lt;strong&gt;arguments&lt;/strong&gt;数组中获取。可惜&lt;strong&gt;arguments&lt;/strong&gt;数组不是一个真正的数组，所以我们不得不再次使用&lt;strong&gt;apply&lt;/strong&gt;来调用的&lt;strong&gt;slice&lt;/strong&gt;方法。&lt;/p&gt;
&lt;p&gt;　　最后，是swiss方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Function.method('swiss', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (parent) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 1; i &amp;lt; arguments.length; i += 1&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name =&lt;span&gt; arguments[i];
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prototype[name] =&lt;span&gt; parent.prototype[name];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;Swiss&lt;/strong&gt;方法对&lt;strong&gt;arguments&lt;/strong&gt;进行遍历。对每一个&lt;strong&gt;name&lt;/strong&gt;，它都从&lt;strong&gt;父类的原型&lt;/strong&gt;中复制一个成员到新类的&lt;strong&gt;原型&lt;/strong&gt;中。&lt;/p&gt;

&lt;p&gt;　　JavaScript可以像class语言一样来使用，但它也具有相当独特的表现力。我们研究了类的继承，Swiss继承，寄生继承，类的扩充以及对象的扩充。这种大量代码的复用模式来自于一种被认为比Java更小，更简单的语言。&lt;/p&gt;
&lt;p&gt;　　类的对象非常严格，要将一个新成员添加到对象中，唯一的方法就是创建一个新类。而在JavaScript中，对象是松散的，可以通过简单的赋值操作将一个新成员添加到对象中。&lt;/p&gt;
&lt;p&gt;　　由于JavaScript中的对象非常灵活，所以你需要对类的层次结构进行不同的考虑。深层次的结构并不太适用，相反，浅层次的结构更高效，更具有表现力。&lt;/p&gt;

&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;我从事编写JavaScript代码已经有14年了，而且我从来没有发现需要使用uber函数。Super在class模式中十分重要，但是在原型和函数式模式中不是必须的。现在看来我早期尝试在JavaScript中支持class模式是一个错误。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://crockford.com/javascript/inheritance.html&quot; target=&quot;_blank&quot;&gt;Classical Inheritance in JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关链接：&lt;a href=&quot;http://www.cnblogs.com/sanshi/archive/2009/07/08/1519036.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/sanshi/archive/2009/07/08/1519036.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 15:26:00 +0000</pubDate>
<dc:creator>Jaxu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jaxu/p/8424720.html</dc:identifier>
</item>
<item>
<title>WTF小程序之wxs - nobody-junior</title>
<link>http://www.cnblogs.com/imgss/p/8424656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imgss/p/8424656.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;对于从VUE过来的前端同学来说，见到小程序的第一眼一定是熟悉—感觉就像是把vue的单文件拆成了3个文件。但是，随着慢慢入坑。马上会发现，这样怎么不行？wxs文件又是什么鬼？template和vue的template一样吗？下面我们来一起探索一下。&lt;/p&gt;
&lt;h2 id=&quot;wxs文件的写法&quot;&gt;wxs文件的写法&lt;/h2&gt;
&lt;p&gt;根据&lt;a href=&quot;https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxs/&quot;&gt;官方文档&lt;/a&gt;的说法，wxs是小程序的一套脚本语言，用于和wxml一起构成页面结构。就像js一样，你可以在wxml中借助&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;在 HTML中的内联js
&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'hello world'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;在WXML中的内联wxs&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;wxs module=&quot;m1&quot;&amp;gt;console.log&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'hello world'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&amp;lt;/wxs&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;单独在文件中：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//hello.js&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world&quot;&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;//引入js&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;script src&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;./hello.js&quot;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;//hello.wxs&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;console.log&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;function foo&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;module.exports = {foo:foo}&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;//引入wxs&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;wxs src=&quot;./hello&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;wxs&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot; module=&quot;&lt;/span&gt;m1&lt;span class=&quot;st&quot;&gt;&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是别觉得wxs跟js就是一样的了。wxs实现了CommonJS规范，也就是说，你写在wxs文件或者标签中的函数需要导出后才能使用，而不是像js那样一个全局作用域。注意wxs标签多出的module属性，相当于 &lt;code&gt;const m1 = require('./hello.wxs')&lt;/code&gt;；然后你就可以在WXML中通过&lt;code&gt;m1.foo&lt;/code&gt;来调用函数。另外，你可以在wxs中通过require引用别的wxs代码。&lt;/p&gt;
&lt;h2 id=&quot;wxs的作用&quot;&gt;wxs的作用&lt;/h2&gt;
&lt;p&gt;如果不是因为&lt;code&gt;{{}}&lt;/code&gt;中不能执行我写在&lt;code&gt;Page({})&lt;/code&gt;参数对象中的函数，我可能都懒得去看wxs究竟是干什么用的😰。好在wxs解决了这个问题，wxs中的函数可以导出然后在WXML的{{}}中进行调用。这对于从vue或者react中过来又刚接触小程序的同学一定是 ？？？。&lt;/p&gt;
&lt;p&gt;我们来分别看看它们各自的文档是怎么说的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;vue: 对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。{{ message.split('').reverse().join('') }}是支持的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;react: You can embed any JavaScript expression in JSX by wrapping it in curly braces.For example, 2 + 2, user.firstName, and formatName(user) are all valid expressions:(一句话，JSX的{}中支持函数调用)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小程序: 简单绑定可作用于 字面量/数字运算/字符运算/.[]的索引运算/条件运算/逻辑运算，&lt;strong&gt;不支持js文件中的函数调用以及方法调用&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，我们需要把逻辑写到wxs中，从而实现在WXML中借助函数处理复杂的逻辑。以实现&lt;code&gt;message.split('').reverse().join('')&lt;/code&gt;这个逻辑为例，你可以这么写:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;wxs&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; module=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;mdl&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
function convert(str){return str.split('').reverse().join('')}
module.exports = {convert}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/wxs&amp;gt;&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;&amp;lt;view&amp;gt;&lt;/span&gt;{{mdl.convert(message)}}&lt;span class=&quot;kw&quot;&gt;&amp;lt;/view&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时如果js中的data的message =&quot;123&quot;,显示出来的就是“321”了。本文完&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 15:13:00 +0000</pubDate>
<dc:creator>nobody-junior</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imgss/p/8424656.html</dc:identifier>
</item>
<item>
<title>查询集API  -- Django从入门到精通系列教程 - 刘江liujiangblog.com</title>
<link>http://www.cnblogs.com/feixuelove1009/p/8424607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixuelove1009/p/8424607.html</guid>
<description>&lt;h3 id=&quot;该系列教程系个人原创并完整发布在个人官网刘江的博客和教程&quot;&gt;该系列教程系个人原创，并完整发布在个人官网&lt;a href=&quot;http://www.liujiangblog.com&quot;&gt;刘江的博客和教程&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;所有转载本文者需在顶部显著位置注明原作者及www.liujiangblog.com官网地址&quot;&gt;所有转载本文者，需在顶部显著位置注明原作者及www.liujiangblog.com官网地址。&lt;/h3&gt;
&lt;h3 id=&quot;python及django学习qq群453131687&quot;&gt;Python及Django学习QQ群：453131687&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;本节将详细介绍查询集的API，它建立在下面的模型基础上，与上一节的模型相同：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Blog(models.Model):
    name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)
    tagline &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.TextField()

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__str__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):              &lt;span class=&quot;co&quot;&gt;# __unicode__ on Python 2&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.name

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Author(models.Model):
    name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;)
    email &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.EmailField()

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__str__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):              &lt;span class=&quot;co&quot;&gt;# __unicode__ on Python 2&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.name

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Entry(models.Model):
    blog &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ForeignKey(Blog, on_delete&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;models.CASCADE)
    headline &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;)
    body_text &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.TextField()
    pub_date &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.DateField()
    mod_date &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.DateField()
    authors &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ManyToManyField(Author)
    n_comments &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.IntegerField()
    n_pingbacks &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.IntegerField()
    rating &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.IntegerField()

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__str__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):              &lt;span class=&quot;co&quot;&gt;# __unicode__ on Python 2&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.headline&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在内部，创建、过滤、切片和传递一个QuerySet不会真实操作数据库，在你对查询集提交之前，不会发生任何实际的数据库操作。&lt;/p&gt;
&lt;p&gt;可以使用下列方法对QuerySet提交查询操作：&lt;/p&gt;
&lt;p&gt;QuerySet是可迭代的，在首次迭代查询集时执行实际的数据库查询。 例如， 下面的语句会将数据库中所有Entry的headline打印出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for e in Entry.objects.all():
    print(e.headline)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;切片&lt;/strong&gt;：如果使用切片的”step“参数，Django 将执行数据库查询并返回一个列表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Pickling/缓存&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;repr()&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;len()&lt;/strong&gt;：当你对QuerySet调用len()时， 将提交数据库操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;list()&lt;/strong&gt;：对QuerySet调用list()将强制提交操作&lt;code&gt;entry_list = list(Entry.objects.all())&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;bool()&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试布尔值，像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if Entry.objects.filter(headline=&quot;Test&quot;):
   print(&quot;There is at least one Entry with the headline Test&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：如果你需要知道是否存在至少一条记录（而不需要真实的对象），使用exists() 将更加高效。&lt;/p&gt;

&lt;p&gt;下面是对于QuerySet的正式定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class QuerySet(model=None, query=None, using=None)[source]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;QuerySet类具有两个公有属性用于内省：&lt;/p&gt;
&lt;p&gt;ordered：如果QuerySet是排好序的则为True，否则为False。&lt;/p&gt;
&lt;p&gt;db：如果现在执行，则返回使用的数据库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以下的方法都将返回一个新的QuerySets。&lt;/strong&gt;重点是加粗的几个API，其它的使用场景很少。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;strong&gt;filter()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;过滤查询对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;exclude()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;排除满足条件的对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;strong&gt;annotate()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;使用聚合函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;strong&gt;order_by()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;对查询集进行排序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;strong&gt;reverse()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;反向排序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;strong&gt;distinct()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;对查询集去重&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;values()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;返回包含对象具体值的字典的QuerySet&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;values_list()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;与values()类似，只是返回的是元组而不是字典。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dates()&lt;/td&gt;
&lt;td&gt;根据日期获取查询集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;datetimes()&lt;/td&gt;
&lt;td&gt;根据时间获取查询集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;strong&gt;none()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;创建空的查询集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;strong&gt;all()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;获取所有的对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;union()&lt;/td&gt;
&lt;td&gt;并集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;intersection()&lt;/td&gt;
&lt;td&gt;交集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;difference()&lt;/td&gt;
&lt;td&gt;差集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;strong&gt;select_related()&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;附带查询关联对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;prefetch_related()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;预先查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;extra()&lt;/td&gt;
&lt;td&gt;附加SQL查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;defer()&lt;/td&gt;
&lt;td&gt;不加载指定字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;only()&lt;/td&gt;
&lt;td&gt;只加载指定的字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;using()&lt;/td&gt;
&lt;td&gt;选择数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;select_for_update()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;锁住选择的对象，直到事务结束。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;raw()&lt;/td&gt;
&lt;td&gt;接收一个原始的SQL查询&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;filter&quot;&gt;1. filter()&lt;/h2&gt;
&lt;p&gt;filter(**kwargs)&lt;/p&gt;
&lt;p&gt;返回满足查询参数的对象集合。&lt;/p&gt;
&lt;p&gt;查找的参数（**kwargs）应该满足下文字段查找中的格式。多个参数之间是和AND的关系。&lt;/p&gt;
&lt;h2 id=&quot;exclude&quot;&gt;2. exclude()&lt;/h2&gt;
&lt;p&gt;exclude(**kwargs)&lt;/p&gt;
&lt;p&gt;返回一个新的QuerySet，它包含&lt;strong&gt;不&lt;/strong&gt;满足给定的查找参数的对象。&lt;/p&gt;
&lt;p&gt;查找的参数（**kwargs）应该满足下文字段查找中的格式。多个参数通过AND连接，然后所有的内容放入NOT() 中。&lt;/p&gt;
&lt;p&gt;下面的示例&lt;strong&gt;排除&lt;/strong&gt;所有&lt;code&gt;pub_date&lt;/code&gt;晚于2005-1-3&lt;strong&gt;且&lt;/strong&gt;headline为“Hello” 的记录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3), headline='Hello')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的示例&lt;strong&gt;排除&lt;/strong&gt;所有&lt;code&gt;pub_date&lt;/code&gt;晚于2005-1-3&lt;strong&gt;或者&lt;/strong&gt;headline 为“Hello” 的记录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3)).exclude(headline='Hello')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;annotate&quot;&gt;3. annotate()&lt;/h2&gt;
&lt;p&gt;annotate(*args, **kwargs)&lt;/p&gt;
&lt;p&gt;使用提供的聚合表达式查询对象。&lt;/p&gt;
&lt;p&gt;表达式可以是简单的值、对模型（或任何关联模型）上的字段的引用或者聚合表达式（平均值、总和等）。&lt;/p&gt;
&lt;p&gt;annotate()的每个参数都是一个annotation，它将添加到返回的QuerySet每个对象中。&lt;/p&gt;
&lt;p&gt;关键字参数指定的Annotation将使用关键字作为Annotation 的别名。 匿名参数的别名将基于聚合函数的名称和模型的字段生成。 只有引用单个字段的聚合表达式才可以使用匿名参数。 其它所有形式都必须用关键字参数。&lt;/p&gt;
&lt;p&gt;例如，如果正在操作一个Blog列表，你可能想知道每个Blog有多少Entry：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models import Count
&amp;gt;&amp;gt;&amp;gt; q = Blog.objects.annotate(Count('entry'))
# The name of the first blog
&amp;gt;&amp;gt;&amp;gt; q[0].name
'Blogasaurus'
# The number of entries on the first blog
&amp;gt;&amp;gt;&amp;gt; q[0].entry__count
42&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Blog模型本身没有定义&lt;code&gt;entry__count&lt;/code&gt;属性，但是通过使用一个关键字参数来指定聚合函数，可以控制Annotation的名称：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; q = Blog.objects.annotate(number_of_entries=Count('entry'))
# The number of entries on the first blog, using the name provided
&amp;gt;&amp;gt;&amp;gt; q[0].number_of_entries
42&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;order_by&quot;&gt;4. order_by()&lt;/h2&gt;
&lt;p&gt;order_by(*fields)&lt;/p&gt;
&lt;p&gt;默认情况下，根据模型的Meta类中的ordering属性对QuerySet中的对象进行排序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的结果将按照&lt;code&gt;pub_date&lt;/code&gt;降序排序，然后再按照headline升序排序。&quot;-pub_date&quot;前面的负号表示降序顺序。 升序是默认的。 要随机排序，使用&quot;?&quot;，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.order_by('?')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：&lt;code&gt;order_by('?')&lt;/code&gt;可能耗费资源且很慢，这取决于使用的数据库。&lt;/p&gt;
&lt;p&gt;若要按照另外一个模型中的字段排序，可以使用查询关联模型的语法。即通过字段的名称后面跟两个下划线（&lt;code&gt;__&lt;/code&gt;），再加上新模型中的字段的名称，直到希望连接的模型。 像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.order_by('blog__name', 'headline')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果排序的字段与另外一个模型关联，Django将使用关联的模型的默认排序，或者如果没有指定Meta.ordering将通过关联的模型的主键排序。 例如，因为Blog模型没有指定默认的排序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.order_by('blog')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与以下相同：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.order_by('blog__id')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果Blog设置了&lt;code&gt;ordering = ['name']&lt;/code&gt;，那么第一个QuerySet将等同于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.order_by('blog__name')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以通过调用表达式的desc()或者asc()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.order_by(Coalesce('summary', 'headline').desc())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;考虑下面的情况，指定一个多值字段来排序（例如，一个ManyToManyField 字段或者ForeignKey 字段的反向关联）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Event(Model):
   parent &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ForeignKey(
       &lt;span class=&quot;st&quot;&gt;'self'&lt;/span&gt;,
       on_delete&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;models.CASCADE,
       related_name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'children'&lt;/span&gt;,
   )
   date &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.DateField()

Event.objects.order_by(&lt;span class=&quot;st&quot;&gt;'children__date'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，每个Event可能有多个排序数据；具有多个children的每个Event将被多次返回到&lt;code&gt;order_by()&lt;/code&gt;创建的新的QuerySet中。 换句话说，用&lt;code&gt;order_by()&lt;/code&gt;方法对QuerySet对象进行操作会返回一个扩大版的新QuerySet对象。因此，使用多值字段对结果进行排序时要格外小心。&lt;/p&gt;
&lt;p&gt;没有方法指定排序是否考虑大小写。 对于大小写的敏感性，Django将根据数据库中的排序方式排序结果。&lt;/p&gt;
&lt;p&gt;可以通过Lower将一个字段转换为小写来排序，它将达到大小写一致的排序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.order_by(Lower('headline').desc())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过检查&lt;code&gt;QuerySet.ordered&lt;/code&gt;属性来知道查询是否是排序的。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;order_by()&lt;/code&gt;都将清除前面的任何排序。 例如下面的查询将按照&lt;code&gt;pub_date&lt;/code&gt;排序，而不是headline：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.order_by('headline').order_by('pub_date')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;reverse&quot;&gt;5. reverse()&lt;/h2&gt;
&lt;p&gt;reverse()&lt;/p&gt;
&lt;p&gt;反向排序QuerySet中返回的元素。 第二次调用reverse()将恢复到原有的排序。&lt;/p&gt;
&lt;p&gt;如要获取QuerySet中最后五个元素，可以这样做：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;my_queryset.reverse()[:5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这与Python直接使用负索引有点不一样。 Django不支持负索引，只能曲线救国。&lt;/p&gt;
&lt;h2 id=&quot;distinct&quot;&gt;6. distinct()&lt;/h2&gt;
&lt;p&gt;distinct(*fields)&lt;/p&gt;
&lt;p&gt;去除查询结果中重复的行。&lt;/p&gt;
&lt;p&gt;默认情况下，QuerySet不会去除重复的行。当查询跨越多张表的数据时，QuerySet可能得到重复的结果，这时候可以使用distinct()进行去重。&lt;/p&gt;
&lt;h2 id=&quot;values&quot;&gt;7. values()&lt;/h2&gt;
&lt;p&gt;values(*fields, **expressions)&lt;/p&gt;
&lt;p&gt;返回一个包含数据的字典的queryset，而不是模型实例。&lt;/p&gt;
&lt;p&gt;每个字典表示一个对象，键对应于模型对象的属性名称。&lt;/p&gt;
&lt;p&gt;下面的例子将values() 与普通的模型对象进行比较：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 列表中包含的是Blog对象
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(name__startswith='Beatles')
&amp;lt;QuerySet [&amp;lt;Blog: Beatles Blog&amp;gt;]&amp;gt;
# 列表中包含的是数据字典
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(name__startswith='Beatles').values()
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法接收可选的位置参数&lt;code&gt;*fields&lt;/code&gt;，它指定values()应该限制哪些字段。如果指定字段，每个字典将只包含指定的字段的键/值。如果没有指定字段，每个字典将包含数据库表中所有字段的键和值。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.values()
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values('id', 'name')
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog'}]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;values()方法还有关键字参数&lt;code&gt;**expressions&lt;/code&gt;，这些参数将传递给&lt;code&gt;annotate()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models.functions import Lower
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values(lower_name=Lower('name'))
&amp;lt;QuerySet [{'lower_name': 'beatles blog'}]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在values()子句中的聚合应用于相同values()子句中的其他参数之前。 如果需要按另一个值分组，请将其添加到较早的values()子句中。 像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models import Count
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values('author', entries=Count('entry'))
&amp;lt;QuerySet [{'author': 1, 'entries': 20}, {'author': 1, 'entries': 13}]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values('author').annotate(entries=Count('entry'))
&amp;lt;QuerySet [{'author': 1, 'entries': 33}]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;如果你有一个字段foo是一个ForeignKey，默认的&lt;code&gt;foo_id&lt;/code&gt;参数返回的字典中将有一个叫做foo 的键，因为这是保存实际值的那个隐藏的模型属性的名称。 当调用&lt;code&gt;foo_id&lt;/code&gt;并传递字段的名称，传递foo 或values()都可以，得到的结果是相同的。像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values()
&amp;lt;QuerySet [{'blog_id': 1, 'headline': 'First Entry', ...}, ...]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Entry.objects.values('blog')
&amp;lt;QuerySet [{'blog': 1}, ...]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Entry.objects.values('blog_id')
&amp;lt;QuerySet [{'blog_id': 1}, ...]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当values()与distinct()一起使用时，注意排序可能影响最终的结果。&lt;/p&gt;
&lt;p&gt;如果values()子句位于extra()调用之后，extra()中的select参数定义的字段必须显式包含在values()调用中。 values( 调用后面的extra( 调用将忽略选择的额外的字段。&lt;/p&gt;
&lt;p&gt;在values()之后调用only()和defer()不太合理，所以将引发一个NotImplementedError。&lt;/p&gt;
&lt;p&gt;可以通过ManyToManyField、ForeignKey 和 OneToOneFiel 属性反向引用关联的模型的字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.values('name', 'entry__headline')
&amp;lt;QuerySet [{'name': 'My blog', 'entry__headline': 'An entry'},
     {'name': 'My blog', 'entry__headline': 'Another entry'}, ...]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;values_list&quot;&gt;8. values_list()&lt;/h2&gt;
&lt;p&gt;values_list(*fields, flat=False)&lt;/p&gt;
&lt;p&gt;与values()类似，只是在迭代时返回的是元组而不是字典。每个元组包含传递给&lt;code&gt;values_list()&lt;/code&gt;调用的相应字段或表达式的值，因此第一个项目是第一个字段等。 像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', 'headline')
&amp;lt;QuerySet [(1, 'First entry'), ...]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; from django.db.models.functions import Lower
&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', Lower('headline'))
&amp;lt;QuerySet [(1, 'first entry'), ...]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果只传递一个字段，还可以传递flat参数。 如果为True，它表示返回的结果为单个值而不是元组。 如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id').order_by('id')
&amp;lt;QuerySet[(1,), (2,), (3,), ...]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', flat=True).order_by('id')
&amp;lt;QuerySet [1, 2, 3, ...]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果有多个字段，传递flat将发生错误。&lt;/p&gt;
&lt;p&gt;如果不传递任何值给&lt;code&gt;values_list()&lt;/code&gt;，它将返回模型中的所有字段，以在模型中定义的顺序。&lt;/p&gt;
&lt;p&gt;常见的情况是获取某个模型实例的特定字段值。可以使用&lt;code&gt;values_list()&lt;/code&gt;，然后调用get()：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('headline', flat=True).get(pk=1)
'First entry'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;values()&lt;/code&gt;和&lt;code&gt;values_list()&lt;/code&gt;都用于特定情况下的优化：检索数据子集，而无需创建模型实例。&lt;/p&gt;
&lt;p&gt;注意通过ManyToManyField进行查询时的行为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Author.objects.values_list('name', 'entry__headline')
&amp;lt;QuerySet [('Noam Chomsky', 'Impressions of Gaza'),
 ('George Orwell', 'Why Socialists Do Not Believe in Fun'),
 ('George Orwell', 'In Defence of English Cooking'),
 ('Don Quixote', None)]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似地，当查询反向外键时，对于没有任何作者的条目，返回None。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('authors')
&amp;lt;QuerySet [('Noam Chomsky',), ('George Orwell',), (None,)]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dates&quot;&gt;9. dates()&lt;/h2&gt;
&lt;p&gt;dates(field, kind, order='ASC')&lt;/p&gt;
&lt;p&gt;返回一个QuerySet，表示QuerySet内容中特定类型的所有可用日期的&lt;code&gt;datetime.date&lt;/code&gt;对象列表。&lt;/p&gt;
&lt;p&gt;field参数是模型的DateField的名称。 kind参数应为&quot;year&quot;，&quot;month&quot;或&quot;day&quot;。 结果列表中的每个datetime.date对象被截取为给定的类型。&lt;/p&gt;
&lt;p&gt;&quot;year&quot; 返回对应该field的所有不同年份值的列表。&lt;/p&gt;
&lt;p&gt;&quot;month&quot;返回字段的所有不同年/月值的列表。&lt;/p&gt;
&lt;p&gt;&quot;day&quot;返回字段的所有不同年/月/日值的列表。&lt;/p&gt;
&lt;p&gt;order参数默认为'ASC'，或者'DESC'。 它指定如何排序结果。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'year')
[datetime.date(2005, 1, 1)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'month')
[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'day')
[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'day', order='DESC')
[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
[datetime.date(2005, 3, 20)]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;datetimes&quot;&gt;10. datetimes()&lt;/h2&gt;
&lt;p&gt;datetimes(field_name, kind, order='ASC', tzinfo=None)&lt;/p&gt;
&lt;p&gt;返回QuerySet，为datetime.datetime对象的列表，表示QuerySet内容中特定种类的所有可用日期。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;field_name&lt;/code&gt;应为模型的DateTimeField的名称。&lt;/p&gt;
&lt;p&gt;kind参数应为&quot;hour&quot;，&quot;minute&quot;，&quot;month&quot;，&quot;year&quot;，&quot;second&quot;或&quot;day&quot;。&lt;/p&gt;
&lt;p&gt;结果列表中的每个datetime.datetime对象被截取到给定的类型。&lt;/p&gt;
&lt;p&gt;order参数默认为'ASC'，或者'DESC'。 它指定如何排序结果。&lt;/p&gt;
&lt;p&gt;tzinfo参数定义在截取之前将数据时间转换到的时区。&lt;/p&gt;
&lt;h2 id=&quot;none&quot;&gt;11. none()&lt;/h2&gt;
&lt;p&gt;none()&lt;/p&gt;
&lt;p&gt;调用none()将创建一个不返回任何对象的查询集，并且在访问结果时不会执行任何查询。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.none()
&amp;lt;QuerySet []&amp;gt;
&amp;gt;&amp;gt;&amp;gt; from django.db.models.query import EmptyQuerySet
&amp;gt;&amp;gt;&amp;gt; isinstance(Entry.objects.none(), EmptyQuerySet)
True&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;all&quot;&gt;12. all()&lt;/h2&gt;
&lt;p&gt;all()&lt;/p&gt;
&lt;p&gt;返回当前QuerySet（或QuerySet子类）的副本。通常用于获取全部QuerySet对象。&lt;/p&gt;
&lt;h2 id=&quot;union&quot;&gt;13. union()&lt;/h2&gt;
&lt;p&gt;union(*other_qs, all=False)&lt;/p&gt;
&lt;p&gt;Django中的新功能1.11。也就是集合中并集的概念！&lt;/p&gt;
&lt;p&gt;使用SQL的UNION运算符组合两个或更多个QuerySet的结果。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs1.union(qs2, qs3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，UNION操作符仅选择不同的值。 要允许重复值，请使用all=True参数。&lt;/p&gt;
&lt;h2 id=&quot;intersection&quot;&gt;14. intersection()&lt;/h2&gt;
&lt;p&gt;intersection(*other_qs)&lt;/p&gt;
&lt;p&gt;Django中的新功能1.11。也就是集合中交集的概念！&lt;/p&gt;
&lt;p&gt;使用SQL的INTERSECT运算符返回两个或更多个QuerySet的共有元素。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs1.intersection(qs2, qs3)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;difference&quot;&gt;15. difference()&lt;/h2&gt;
&lt;p&gt;difference(*other_qs)&lt;/p&gt;
&lt;p&gt;Django中的新功能1.11。也就是集合中差集的概念！&lt;/p&gt;
&lt;p&gt;使用SQL的EXCEPT运算符只保留QuerySet中的元素，但不保留其他QuerySet中的元素。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs1.difference(qs2, qs3)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;select_related(*fields)&lt;/p&gt;
&lt;p&gt;沿着外键关系查询关联的对象的数据。这会生成一个复杂的查询并引起性能的损耗，但是在以后使用外键关系时将不需要再次数据库查询。&lt;/p&gt;
&lt;p&gt;下面的例子解释了普通查询和&lt;code&gt;select_related()&lt;/code&gt;查询的区别。 下面是一个标准的查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 访问数据库。
e = Entry.objects.get(id=5)
# 再次访问数据库以得到关联的Blog对象。
b = e.blog&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个&lt;code&gt;select_related&lt;/code&gt;查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 访问数据库。
e = Entry.objects.select_related('blog').get(id=5)
# 不会访问数据库，因为e.blog已经在前面的查询中获得了。
b = e.blog&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;select_related()&lt;/code&gt;可用于objects任何的查询集：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.utils &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; timezone

&lt;span class=&quot;co&quot;&gt;# Find all the blogs with entries scheduled to be published in the future.&lt;/span&gt;
blogs &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;set&lt;/span&gt;()

&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; e &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; Entry.objects.&lt;span class=&quot;bu&quot;&gt;filter&lt;/span&gt;(pub_date__gt&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;timezone.now()).select_related(&lt;span class=&quot;st&quot;&gt;'blog'&lt;/span&gt;):
    &lt;span class=&quot;co&quot;&gt;# 没有select_related()，下面的语句将为每次循环迭代生成一个数据库查询,以获得每个entry关联的blog。&lt;/span&gt;
    blogs.add(e.blog)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;filter()&lt;/code&gt;和&lt;code&gt;select_related()&lt;/code&gt;的顺序不重要。 下面的查询集是等同的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog')
Entry.objects.select_related('blog').filter(pub_date__gt=timezone.now())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以沿着外键查询。 如果有以下模型：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; City(models.Model):
    &lt;span class=&quot;co&quot;&gt;# ...&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Person(models.Model):
    &lt;span class=&quot;co&quot;&gt;# ...&lt;/span&gt;
    hometown &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ForeignKey(
        City,
        on_delete&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;models.SET_NULL,
        blank&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;,
        null&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;,
    )

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Book(models.Model):
    &lt;span class=&quot;co&quot;&gt;# ...&lt;/span&gt;
    author &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ForeignKey(Person, on_delete&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;models.CASCADE)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用&lt;code&gt;Book.objects.select_related('author__hometown').get(id=4)&lt;/code&gt;将缓存相关的Person 和相关的City：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b = Book.objects.select_related('author__hometown').get(id=4)
p = b.author         # Doesn't hit the database.
c = p.hometown       # Doesn't hit the database.
b = Book.objects.get(id=4) # No select_related() in this example.
p = b.author         # Hits the database.
c = p.hometown       # Hits the database.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在传递给&lt;code&gt;select_related()&lt;/code&gt;的字段中，可以使用任何ForeignKey和OneToOneField。&lt;/p&gt;
&lt;p&gt;在传递给&lt;code&gt;select_related&lt;/code&gt;的字段中，还可以反向引用OneToOneField。也就是说，可以回溯到定义OneToOneField 的字段。 此时，可以使用关联对象字段的&lt;code&gt;related_name&lt;/code&gt;，而不要指定字段的名称。&lt;/p&gt;

&lt;p&gt;prefetch_related(*lookups)&lt;/p&gt;
&lt;p&gt;在单个批处理中自动检索每个指定查找的相关对象。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;select_related&lt;/code&gt;类似，但是策略是完全不同的。&lt;/p&gt;
&lt;p&gt;假设有这些模型：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Topping(models.Model):
    name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Pizza(models.Model):
    name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;)
    toppings &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ManyToManyField(Topping)

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__str__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):              &lt;span class=&quot;co&quot;&gt;# __unicode__ on Python 2&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;)&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; (
            &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.name,
            &lt;span class=&quot;st&quot;&gt;&quot;, &quot;&lt;/span&gt;.join(topping.name &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; topping &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.toppings.&lt;span class=&quot;bu&quot;&gt;all&lt;/span&gt;()),
        )&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Pizza.objects.all()
[&quot;Hawaiian (ham, pineapple)&quot;, &quot;Seafood (prawns, smoked salmon)&quot;...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题是每次QuerySet要求&lt;code&gt;Pizza.objects.all()&lt;/code&gt;查询数据库，因此&lt;code&gt;self.toppings.all()&lt;/code&gt;将在&lt;code&gt;Pizza Pizza.__str__()&lt;/code&gt;中的每个项目的Toppings表上运行查询。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;prefetch_related&lt;/code&gt;减少为只有两个查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Pizza.objects.all().prefetch_related('toppings')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这意味着现在每次&lt;code&gt;self.toppings.all()&lt;/code&gt;被调用，不会再去数据库查找，而是在一个预取的QuerySet缓存中查找。&lt;/p&gt;
&lt;p&gt;还可以使用正常连接语法来执行相关字段的相关字段。 假设在上面的例子中增加一个额外的模型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Restaurant(models.Model):
    pizzas = models.ManyToManyField(Pizza, related_name='restaurants')
    best_pizza = models.ForeignKey(Pizza, related_name='championed_by')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是合法的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Restaurant.objects.prefetch_related('pizzas__toppings')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这将预取所有属于餐厅的比萨饼，和所有属于那些比萨饼的配料。 这将导致总共3个查询 - 一个用于餐馆，一个用于比萨饼，一个用于配料。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Restaurant.objects.prefetch_related('best_pizza__toppings')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这将获取最好的比萨饼和每个餐厅最好的披萨的所有配料。 这将在3个表中查询 - 一个为餐厅，一个为“最佳比萨饼”，一个为一个为配料。&lt;/p&gt;
&lt;p&gt;当然，也可以使用&lt;code&gt;best_pizza&lt;/code&gt;来获取&lt;code&gt;select_related&lt;/code&gt;关系，以将查询数减少为2：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Restaurant.objects.select_related('best_pizza').prefetch_related('best_pizza__toppings')&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None)&lt;/p&gt;
&lt;p&gt;有些情况下，Django的查询语法难以简单的表达复杂的WHERE子句，对于这种情况,可以在extra()生成的SQL从句中注入新子句。使用这种方法作为最后的手段，这是一个旧的API，在将来的某个时候可能被弃用。仅当无法使用其他查询方法表达查询时才使用它。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs.extra(
...     select={'val': &quot;select col from sometable where othercol = %s&quot;},
...     select_params=(someparam,),
... )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相当于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs.annotate(val=RawSQL(&quot;select col from sometable where othercol = %s&quot;, (someparam,)))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;defer&quot;&gt;19. defer()&lt;/h2&gt;
&lt;p&gt;defer(*fields)&lt;/p&gt;
&lt;p&gt;在一些复杂的数据建模情况下，模型可能包含大量字段，其中一些可能包含大尺寸数据（例如文本字段），将它们转换为Python对象需要花费很大的代价。&lt;/p&gt;
&lt;p&gt;当最初获取数据时不知道是否需要这些特定字段的情况下，如果正在使用查询集的结果，可以告诉Django不要从数据库中检索它们。&lt;/p&gt;
&lt;p&gt;通过传递字段名称到defer()实现不加载：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Entry.objects.defer(&quot;headline&quot;, &quot;body&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具有延迟加载字段的查询集仍将返回模型实例。&lt;/p&gt;
&lt;p&gt;每个延迟字段将在你访问该字段时从数据库中检索（每次只检索一个，而不是一次检索所有的延迟字段）。&lt;/p&gt;
&lt;p&gt;可以多次调用defer()。 每个调用都向延迟集添加新字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 延迟body和headline两个字段。
Entry.objects.defer(&quot;body&quot;).filter(rating=5).defer(&quot;headline&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字段添加到延迟集的顺序无关紧要。对已经延迟的字段名称再次defer()没有问题（该字段仍将被延迟）。&lt;/p&gt;
&lt;p&gt;可以使用标准的双下划线符号来分隔关联的字段，从而加载关联模型中的字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Blog.objects.select_related().defer(&quot;entry__headline&quot;, &quot;entry__body&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要清除延迟字段集，将None作为参数传递到defer()：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 立即加载所有的字段。
my_queryset.defer(None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;defer()方法（及其兄弟，only()）仅适用于高级用例，它们提供了数据加载的优化方法。&lt;/p&gt;
&lt;h2 id=&quot;only&quot;&gt;20. only()&lt;/h2&gt;
&lt;p&gt;only(*fields)&lt;/p&gt;
&lt;p&gt;only()方法与defer()相反。&lt;/p&gt;
&lt;p&gt;如果有一个模型几乎所有的字段需要延迟，使用only()指定补充的字段集可以使代码更简单。&lt;/p&gt;
&lt;p&gt;假设有一个包含字段biography、age和name的模型。 以下两个查询集是相同的，就延迟字段而言：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Person.objects.defer(&quot;age&quot;, &quot;biography&quot;)
Person.objects.only(&quot;name&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每当你调用only()时，它将替换立即加载的字段集。因此，对only()的连续调用的结果是只有最后一次调用的字段被考虑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# This will defer all fields except the headline.
Entry.objects.only(&quot;body&quot;, &quot;rating&quot;).only(&quot;headline&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于defer()以递增方式动作（向延迟列表中添加字段），因此你可以结合only()和defer()调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Final result is that everything except &quot;headline&quot; is deferred.
Entry.objects.only(&quot;headline&quot;, &quot;body&quot;).defer(&quot;body&quot;)
# Final result loads headline and body immediately (only() replaces any
# existing set of fields).
Entry.objects.defer(&quot;body&quot;).only(&quot;headline&quot;, &quot;body&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当对具有延迟字段的实例调用save()时，仅保存加载的字段。&lt;/p&gt;
&lt;h2 id=&quot;using&quot;&gt;21. using()&lt;/h2&gt;
&lt;p&gt;using(alias)&lt;/p&gt;
&lt;p&gt;如果正在使用多个数据库，这个方法用于指定在哪个数据库上查询QuerySet。方法的唯一参数是数据库的别名，定义在DATABASES。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# queries the database with the 'default' alias.
&amp;gt;&amp;gt;&amp;gt; Entry.objects.all()
# queries the database with the 'backup' alias
&amp;gt;&amp;gt;&amp;gt; Entry.objects.using('backup')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;select_for_update&quot;&gt;22. select_for_update()&lt;/h2&gt;
&lt;p&gt;select_for_update(nowait=False, skip_locked=False)&lt;/p&gt;
&lt;p&gt;返回一个锁住行直到事务结束的查询集，如果数据库支持，它将生成一个&lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;语句。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;entries = Entry.objects.select_for_update().filter(author=request.user)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有匹配的行将被锁定，直到事务结束。这意味着可以通过锁防止数据被其它事务修改。&lt;/p&gt;
&lt;p&gt;一般情况下如果其他事务锁定了相关行，那么本查询将被阻塞，直到锁被释放。使用&lt;code&gt;select_for_update(nowait=True)&lt;/code&gt;将使查询不阻塞。如果其它事务持有冲突的锁,那么查询将引发&lt;code&gt;DatabaseError&lt;/code&gt;异常。也可以使用&lt;code&gt;select_for_update(skip_locked=True)&lt;/code&gt;忽略锁定的行。nowait和&lt;code&gt;skip_locked&lt;/code&gt;是互斥的。&lt;/p&gt;
&lt;p&gt;目前，postgresql，oracle和mysql数据库后端支持&lt;code&gt;select_for_update()&lt;/code&gt;。但是，MySQL不支持nowait和&lt;code&gt;skip_locked&lt;/code&gt;参数。&lt;/p&gt;
&lt;h2 id=&quot;raw&quot;&gt;23. raw()&lt;/h2&gt;
&lt;p&gt;raw(raw_query, params=None, translations=None)&lt;/p&gt;
&lt;p&gt;接收一个原始的SQL查询，执行它并返回一个&lt;code&gt;django.db.models.query.RawQuerySet&lt;/code&gt;实例。&lt;/p&gt;
&lt;p&gt;这个RawQuerySet实例可以迭代，就像普通的QuerySet一样。&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 14:47:00 +0000</pubDate>
<dc:creator>刘江liujiangblog.com</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixuelove1009/p/8424607.html</dc:identifier>
</item>
<item>
<title>hexo 博客支持PWA和压缩博文 - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/hexp-pwa-compress.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/hexp-pwa-compress.html</guid>
<description>&lt;h2 id=&quot;目标网站&quot;&gt;目标网站&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.rmiao.top/&quot; class=&quot;uri&quot;&gt;https://blog.rmiao.top/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;pwa&quot;&gt;PWA&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;yarn add hexo&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;offline&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在root config.yml里新增&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;# offline config passed to sw&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;precache&lt;/span&gt;.
service_worker&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  maximumFileSizeToCacheInBytes&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5242880&lt;/span&gt;
  staticFileGlobs&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/**/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;.&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;js&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;html&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;css&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;png&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;jpg&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;gif&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;svg&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;eot&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;ttf&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;woff&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;woff2&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/lib/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/*.js&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;  - /lib/**/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;css&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/images/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/js/src&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/**/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;js&lt;/span&gt;
  stripPrefix&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;
  verbose&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;
  runtimeCaching&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; urlPattern&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      handler: cacheFirst&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      options:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        origin: cdn.bootcss.com&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后添加manifest.json, 比如我使用了 &lt;code&gt;hexo-theme-next&lt;/code&gt;的主题，在&lt;code&gt;layout/_custom/header.swig&lt;/code&gt; 中引用了&lt;code&gt;manifest.json&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;manifest生成地址： &lt;a href=&quot;https://app-manifest.firebaseapp.com/&quot; class=&quot;uri&quot;&gt;https://app-manifest.firebaseapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如，我的为&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;风 - Ryan Miao&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;short_name&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;风&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;theme_color&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;#2196f3&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;background_color&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;#2196f3&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;display&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;browser&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;scope&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;start_url&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体缓存策略还是看下官方文档，这里不求甚解缓存。重启博客，打开控制台，查看网络，会发现，所有的文件都是&lt;code&gt;(from ServiceWorker)&lt;/code&gt; 或者&lt;code&gt;(from disk cache)&lt;/code&gt;或者&lt;code&gt;(from memory cache)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当hexo g之后，会多出一个&lt;code&gt;service-worker.js&lt;/code&gt;里面则是会缓存的内容。&lt;/p&gt;
&lt;h2 id=&quot;压缩&quot;&gt;压缩&lt;/h2&gt;
&lt;p&gt;看了下计算，压缩大概可以节省一半空间。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;$ npm install gulp &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;g
$ npm install gulp&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;minify&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;css gulp&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;uglify gulp&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;htmlmin gulp&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;htmlclean gulp &lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;save

或者使用yarn 

yarn global add gulp
yarn add gulp&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;minify&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;css gulp&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;uglify gulp&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;htmlmin gulp&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;htmlclean gulp&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，在根目录新增 &lt;code&gt;gulpfile.js&lt;/code&gt; :&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; gulp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'gulp'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; minifycss &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'gulp-minify-css'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; uglify &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'gulp-uglify'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; htmlmin &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'gulp-htmlmin'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; htmlclean &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'gulp-htmlclean'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 压缩 public 目录 css&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;gulp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;task&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'minify-css'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;gulp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;src&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./public/**/*.css'&lt;/span&gt;)
        .&lt;span class=&quot;at&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;minifycss&lt;/span&gt;())
        .&lt;span class=&quot;at&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;gulp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;dest&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./public'&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 压缩 public 目录 html&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;gulp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;task&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'minify-html'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;gulp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;src&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./public/**/*.html'&lt;/span&gt;)
    .&lt;span class=&quot;at&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;htmlclean&lt;/span&gt;())
    .&lt;span class=&quot;at&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;htmlmin&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;dt&quot;&gt;removeComments&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;dt&quot;&gt;minifyJS&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;dt&quot;&gt;minifyCSS&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;dt&quot;&gt;minifyURLs&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;))
    .&lt;span class=&quot;at&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;gulp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;dest&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./public'&lt;/span&gt;))
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 压缩 public/js 目录 js&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;gulp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;task&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'minify-js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;gulp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;src&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./public/**/*.js'&lt;/span&gt;)
        .&lt;span class=&quot;at&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;uglify&lt;/span&gt;())
        .&lt;span class=&quot;at&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;gulp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;dest&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./public'&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 执行 gulp 命令时执行的任务&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;gulp&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;task&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'default'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; [
    &lt;span class=&quot;st&quot;&gt;'minify-html'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'minify-css'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'minify-js'&lt;/span&gt;
])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;hexo clean &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; hexo g &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; gulp &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;  hexo s&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.naaln.com/2017/09/hexo-with-pwa/&quot; class=&quot;uri&quot;&gt;https://blog.naaln.com/2017/09/hexo-with-pwa/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Feb 2018 14:43:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woshimrf/p/hexp-pwa-compress.html</dc:identifier>
</item>
<item>
<title>将excel文件内容存储到数据库，并可以实时在前端查看（不必生成文件） - 且聆听风</title>
<link>http://www.cnblogs.com/listenfwind/p/8424162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/listenfwind/p/8424162.html</guid>
<description>&lt;p&gt;&lt;span&gt;版权声明：本文为博主原创文章，未经博主允许不得转载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文主要讲前端内容，后端涉及较少，可以认为是使用Java。&lt;/p&gt;
&lt;p&gt;首先是excel文件上传，这个较为简单，可以html5的数据接口FormData()进行操作。具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;_file&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;或点此选择文件&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    &lt;br/&gt;　　　　　&amp;lt;button id = &quot;file_button&quot; &amp;gt;按钮&amp;lt;/button&amp;gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是对应的javascript&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$(&quot;#button&quot;).click(function(){
&lt;span&gt;&lt;span&gt;  var files = $('#_file').prop('files');&lt;/span&gt;
  var data = new FormData();
  data.append(&quot;upload&quot;,files[0]); //因为是只选择一个文件，故而只取file[0]&lt;/span&gt;
  $.ajax({
    url: yourPath,
    type: 'POST',
    data: data, 
    cache: false,
    dataType:'text',
    processData: false,
    contentType: false,
    success: function(result) {
                // Do something with the result
        alert(&quot;成功&quot;);
    },
    error : function(result){
        alert(&quot;失败&quot;+result.toString());
    }
  });

});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后端接收到文件之后，将其存储成二进制数组，在数据库中，比如postgresql，使用blob数据类型，然后在java中使用byte数组映射就可以了。&lt;/p&gt;
&lt;p&gt;那么怎么从后端存储的文件内容直接在页面上excel呢？这里需要用到sheetJs，官网：http://sheetjs.com/，可以直接取其demo来用，&lt;/p&gt;
&lt;p&gt;demo下载地址放在github上了：https://github.com/SheetJS/SheetJS.github.io。 &lt;/p&gt;
&lt;p&gt;在这里是直接使用它的一些代码，主要说说思路。&lt;/p&gt;
&lt;p&gt;下载后解压是SheetJS.github.io-master文件夹，在而显示生成excel的Js代码主要在SheetJS.github.io-master\assets\js\dropsheet.js中。其中发下其最后是通过调用该文件中以下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; handleDrop(e) {
        e.stopPropagation();
        e.preventDefault();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pending) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; opts.errors.pending();
        &lt;/span&gt;&lt;span&gt;var files = e.dataTransfer.files;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i,f;
        &lt;/span&gt;&lt;span&gt;for (i = 0, f = files[i]; i != files.length; ++i) {
            var reader = new FileReader();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name =&lt;span&gt; f.name;
            reader.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; e.target.result;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; wb, arr;
                &lt;/span&gt;&lt;span&gt;var readtype = {type: rABS ? 'binary' : 'base64' };
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;rABS) {
                    arr &lt;/span&gt;=&lt;span&gt; fixdata(data);
                    data &lt;/span&gt;=&lt;span&gt; btoa(arr);
                }
                &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; doit() {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(useworker) { sheetjsw(data, process_wb, readtype); &lt;span&gt;return&lt;/span&gt;&lt;span&gt;; }
                        wb &lt;/span&gt;=&lt;span&gt; XLSX.read(data, readtype);
                        process_wb(wb);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e) { console.log(e); opts.errors.failed(e); }
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e.target.result.length &amp;gt; 1e6) opts.errors.large(e.target.result.length, &lt;span&gt;function&lt;/span&gt;(e) { &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(e) doit(); });
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; { doit(); }
            };
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(rABS) reader.readAsBinaryString(f);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; reader.readAsArrayBuffer(f);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：SheetJs这个demo中，解析excel使用的是js-xlsx这个库，这个库对excel的操作很多，解析只是一个方面，具体可以上github上看。而根据解析在html上绘制excel表格的是canvas-datagrid.js这个表格控件。&lt;/p&gt;
&lt;p&gt;可以看到它是通过FileReader的readAsBinaryString方法读取每个选中的文件，根据文件内容在html中绘制出excel表格，那么我们只要在这里自己从后端接收那个二进制数据，生成一个File对象，再跑同样这段代码就OK。&lt;/p&gt;
&lt;p&gt;这个过程中碰到两个问题：&lt;/p&gt;
&lt;p&gt;一个就是后端的byte数组传递到前端很不方便，而且我在用ajax传递的时候，二进制数组参数会变成string型。&lt;/p&gt;
&lt;p&gt;另一个就是javascript中无法直接新建一个File对象。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先第一个问题&lt;/strong&gt;，二进制数组不能传递，那么就只能传递字符串了，但是不能直接转字符串，那么有什么办法呢？再上面的代码看到，里面有一句&lt;/p&gt;
&lt;pre&gt;
var readtype = {type: rABS ? 'binary' : 'base64' };
&lt;/pre&gt;
&lt;p&gt;说明这个操作可以操作base64编码的字符串，那就是转成base64，这个需要引入apache的一个包，包名为&lt;span&gt;commons-codec&lt;/span&gt;，再Maven中引用如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mvnrepository.com/artifact/commons-codec/commons-codec --&amp;gt;&lt;/span&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-codec&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-codec&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再调用其一个方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Base64.encodeBase64String(byteArray);   //将byteArray转为base64字符串
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以传输到前端了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;再说第二个问题&lt;/strong&gt;，通过百度发现，javascript有一种数据类型Blob，而File正是基于这种Blob的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个Blob对象就是一个包含有只读原始数据的类文件对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是Blob是可以初始化来生成的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;var blob = new Blob([base64Data], { type: &quot;mime&quot; })&lt;/p&gt;
&lt;p&gt;然后就可以通过FileReader读取了，再接下来只需要按照demo的代码调用就可以了。。。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;reader.readAsBinaryString(blob);&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 06 Feb 2018 14:34:00 +0000</pubDate>
<dc:creator>且聆听风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/listenfwind/p/8424162.html</dc:identifier>
</item>
<item>
<title>经典游戏还原之：松鼠大作战2 - 优梦创客</title>
<link>http://www.cnblogs.com/raymondking123/p/8380117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/raymondking123/p/8380117.html</guid>
<description>&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;游戏介绍&lt;/strong&gt; 1990年，经迪士尼授权，由日本卡普空（Capcom）电视游戏公司制作的基于任天堂FC主机的电视游戏《松鼠大作战》出版发行。游戏延用迪士尼动画片《松鼠大作战》里的两只可爱花栗鼠Chip and Dale（奇奇和蒂蒂），从寻找小猫咪的委托任务开始，到摆脱肥猫陷阱与其一决高下为故事内容。可单人玩又可双人对战，可互助又可互攻，流畅度，创造力与可玩性均为同类游戏中的领军者。&lt;br/&gt;1993年，卡普空制作发行了《松鼠大作战2》再一次将经典搬到屏幕。除了制作更加精良外，故事也更加惊险刺激。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/27/pXQxk6.jpg&quot; alt=&quot;pXQxk6.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;场景搭建&lt;/strong&gt; 将场景中的图片首尾拼接，在合适的位置设置碰撞器与平台控制器&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/pXlknA&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/27/pXlknA.md.png&quot; alt=&quot;pXlknA.md.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;主角Chip登场&lt;/strong&gt; 将主角图片拖入层级面板上，命名为“player”,添加刚体2D组件和合适的碰撞器组件。为player设置子节点hand,添加碰撞器组件设置为触发，用于触碰箱子的判断；设置子节点foot,调整恰当的位置，用于跳跃，以及主角跳跃动画的条件判定；再设置两个节点用于主角投掷物品发射的位置。&lt;a href=&quot;https://imgchr.com/i/pXlIHI&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/27/pXlIHI.md.png&quot; alt=&quot;pXlIHI.md.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主角Chip动画制作&lt;/strong&gt; 打开动画控制器，创建主角的Idel动画，在合适的时间轴拖上相应的主角图片，重复操作将主角的动画设置好。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/pXGvWV&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/27/pXGvWV.md.png&quot; alt=&quot;pXGvWV.md.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;主角Chip基本动作实现&lt;/strong&gt; 为player添加脚本组件，命名为PlayerController，主角的移动需要通过输入设备为其提供指令，并进行相应的操作，Unity中Input可以获得这些操作。horizontal与vertical均是浮点数范围为-1至1，方向与卡迪尔坐标相同，isPressjump与isPressFire均为Bool类型。通过射线的方式我们可以判断处人物是否在跳跃状态下。Chip的移动与跳跃我们通过物理运动进行操作，在FixedUpdate()下进行代码操作；&lt;/p&gt;
&lt;pre&gt;

&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;isJump = !(Physics2D.Linecast(transform.position, foot.position, 1 &amp;lt;&amp;lt; LayerMask.NameToLayer(&quot;Map&quot;)) || Physics2D.Linecast(transform.position, foot.position, 1 &amp;lt;&amp;lt; LayerMask.NameToLayer(&quot;Box&quot;)));
horizontal = Input.GetAxis(&quot;Horizontal&quot;);//上下
vertical = Input.GetAxis(&quot;Vertical&quot;);//左右
isPressjump = Input.GetButtonDown(&quot;Jump&quot;);//跳跃
isPressFire = Input.GetButtonDown(&quot;Fire1&quot;);//攻击
void FixedUpdate()
{
    if (isControl)
    {
        if (!isDown &amp;amp;&amp;amp; isPressjump &amp;amp;&amp;amp; !isJump)
        {
            if (rig.velocity.y &amp;lt; 1F)
            {
                rig.AddForce(Vector3.up * force);
            }
            isJump = true;
        }
        if (isDown)
        {
            rig.velocity = new Vector3(0, rig.velocity.y);
        }
        else
        {
           rig.velocity = new Vector3(speed * horizontal, rig.velocity.y);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;主角Chip攻击实现&lt;/strong&gt; 与射击游戏的区别，在本作中，CHip是通过搬物品再投掷出去进行攻击的。这里的设想是将场景的箱子与投掷的箱子区别开来，方便判断。player下的节点hand添加脚本，在OnTriggerStay2D下调用MoveBox方法,isHandBox判断手中是否有箱子，isThrow则判断有没有进行投掷操作。这里贴出主要代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void MoveBox(Collider2D collision)
{
    //搬箱子
    if (!isDown &amp;amp;&amp;amp; collision.tag.StartsWith(&quot;Box&quot;) &amp;amp;&amp;amp; isPressFire &amp;amp;&amp;amp; !isHandBox &amp;amp;&amp;amp; !isThrow)
    {
        Destroy(collision.gameObject);//场景中的箱子被销毁了，游戏中松鼠头顶上的箱子仅仅是外观的区别
        isHandBox = true;
        animator.SetTrigger(&quot;moveBox&quot;);
        Instantiate(movebox);
    }
}
private void ThrowBox()
{
    if (isHandBox &amp;amp;&amp;amp; isPressFire)
    {
        isHandBox = false;
        isThrow = true;
        GameObject o = Instantiate(throwingbox);//投掷箱子时实例化一个投掷的箱子（与场景的箱子功能不同）
        if (!isDown)
        {
            o.transform.position = transform.Find(&quot;fireposition&quot;).position;
        }
        else
        {
            o.transform.position = transform.Find(&quot;downfireposition&quot;).position;
        }
        o.GetComponent&amp;lt;ThrowingBox&amp;gt;().Throw(transform.localScale.x, vertical);
        StartCoroutine(ResetIsThrow());
        animator.SetTrigger(&quot;throwbox&quot;);
        Instantiate(throwbox);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;主角Chip动画控制器动画控制&lt;/strong&gt; 给出合适的条件进行动画转换，本作动作丰富，通过多次尝试，本作动作才比较连贯。&lt;a href=&quot;https://imgchr.com/i/pXriiF&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/27/pXriiF.md.png&quot; alt=&quot;pXriiF.md.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;场景箱子的制作&lt;/strong&gt; 将箱子图片拖进层级面板中，为它设置合适的碰撞器，做成预制体备用。&lt;img src=&quot;https://s1.ax1x.com/2018/01/27/pXsn6s.png&quot; alt=&quot;pXsn6s.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;投掷箱子的制作&lt;/strong&gt; 与场景箱子类似，设置触发器，另外需要增加刚体2D组件与脚本，脚本主要用于处理与怪物接触的交互，同样也制成预制体。&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvrYe1.png&quot; alt=&quot;pvrYe1.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;其他道具的制作&lt;/strong&gt; 其他道具有花（吃了一定的数量可以奖励生命）；蜂蜜（蜜蜂怪物攻击的道具，玩家触碰会造成伤害）；坚果（若主角受伤，吃到该道具会增加1点Hp值）；叉子（投掷小鼠投掷的道具，玩家触碰会造成1点Hp伤害）。&lt;a href=&quot;https://imgchr.com/i/pvr6eI&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvr6eI.png&quot; alt=&quot;pvr6eI.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;一些其他的制定&lt;/strong&gt; 在本场景的末尾添加添加合适的触发器，绑上脚本可以通过下一个场景；在悬崖处也添加一个长条的触发器，用于触发主角死亡判定并重新加载本场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;蜜蜂怪物的制作&lt;/strong&gt; 在层级面板中，拖进一张蜜蜂怪物的图片，添加刚体组件，和合适的碰撞器，设置为触发。为这个对象设置两个动画，一个为停止动画，一个为飞行动画。摄像机还没有看到蜜蜂时，蜜蜂处于静止状态，当蜜蜂被摄像机照到时，蜜蜂处于飞行状态。蜜蜂飞到玩家的X位置时，投掷蜂蜜道具。附上蜜蜂的物理运动时脚本代码：&lt;a href=&quot;https://imgchr.com/i/pvs9mR&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvs9mR.md.png&quot; alt=&quot;pvs9mR.md.png&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://imgchr.com/i/pvyGUx&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvyGUx.md.png&quot; alt=&quot;pvyGUx.md.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void FixedUpdate()
{
    if (isHit)
    {
        rig.velocity = new Vector2(masterFlyX, masterFlyY);
    }
    else if (isRest)
    {
        rig.velocity = Vector2.zero;
    }
    else if (!isStop &amp;amp;&amp;amp; !isHit)
    {
        rig.velocity = new Vector2(flyspeedx, flyspeedy);
        if (this.transform.position.x &amp;lt; PlayerController.instance.transform.position.x &amp;amp;&amp;amp; honeyNum &amp;gt; 0)
        {
            Attack();
            honeyNum--;
            isRest = true;
            StartCoroutine(ResetIsRest());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;投叉小鼠的制作&lt;/strong&gt; 与蜜蜂怪物类似，添加刚体组件和合适的碰撞器。为这个对象设置四个动画，停止动画，巡逻动画，攻击动画，跳跃动画。给这个对象加一个点进行射线是不是发现玩家，发现时，执行攻击逻辑播放攻击动画。这里附上部分代码：&lt;a href=&quot;https://imgchr.com/i/pvHJIO&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvHJIO.md.png&quot; alt=&quot;pvHJIO.md.png&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://imgchr.com/i/pvHazd&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvHazd.md.png&quot; alt=&quot;pvHazd.md.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Update()
{
    if (state == State.Stop &amp;amp;&amp;amp; this.transform.position.x &amp;lt; cam.position.x + xoffset)
    {
        //怪物行为被激活
        state = State.Walk;
        animator.SetTrigger(&quot;Walk&quot;);
    }
    else if (this.transform.position.x &amp;lt; cam.position.x - xoffset || this.transform.position.y &amp;gt; cam.position.y + yoffset)
    {
        Destroy(this.gameObject);
    }
    Walk();
    Throw();
    Escape();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;Boss制作&lt;/strong&gt; 在层级面包板中拖入Boss的图片，组件与合适的触发器，Boss主要两种状态，添加刚体，走动状态与停下攻击状态。这里附上Boss的代码：&lt;a href=&quot;https://imgchr.com/i/pvqdbt&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvqdbt.md.png&quot; alt=&quot;pvqdbt.md.png&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://imgchr.com/i/pvq55T&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvq55T.md.png&quot; alt=&quot;pvq55T.md.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Boss : MonoBehaviour {

    public float range;
    public float speed;
    public float stopTime;
    public float walkTime;
    private float dir = 1;//方向正1表示坐标向右
    private float leftrange;
    private float rightrange;
    private Rigidbody2D rig;
    private Animator ani;
    private SpriteRenderer spriterender;
    private State state = State.Stop;
    private float currentTime;
    public GameObject puke;
    public float pukeSpeed;
    public int hp;
    public int totalHp;
    private bool isFlash = false;
    public float flashTime;
    public Color flashColor;
    public Color normalColor;
    public Color dangerColor;
    public float destoryTime;

    public GameObject bosspuke;
    public GameObject kill;


    public enum State
    {
        Stop,
        Walk,
        Attack,
        Die
    }
    // Use this for initialization
    void Start () {
        rig = this.GetComponent&amp;lt;Rigidbody2D&amp;gt;();
        ani = this.GetComponent&amp;lt;Animator&amp;gt;();
        spriterender = this.GetComponent&amp;lt;SpriteRenderer&amp;gt;();
        leftrange = this.transform.position.x - range;
        rightrange = this.transform.position.x + range;
    }

    void Update () {

        ChangeColor();
        ani.SetInteger(&quot;state&quot;, (int)state);
        if (state == State.Stop)
        {
            StartCoroutine(CancelStop());
        }
        else if (state == State.Walk)
        {
            currentTime += Time.deltaTime;
            if (currentTime &amp;gt; walkTime)
            {
                currentTime = 0f;
                state = State.Attack;
            }
            else
            {
                if (this.transform.position.x &amp;gt; rightrange)
                {
                    transform.localScale = new Vector3(-1F, 1F, 1F);
                    dir = -1F;
                }
                if (this.transform.position.x &amp;lt; leftrange)
                {
                    transform.localScale = new Vector3(1F, 1F, 1F);
                    dir = 1F;
                }
            }
        }
        else if (state == State.Die)
        {
            ani.enabled = false;
            this.GetComponent&amp;lt;Collider2D&amp;gt;().enabled = false;
            Destroy(this.gameObject, destoryTime);
        }
    }

    public void ChangeColor()
    {
        if (isFlash)
            spriterender.color = flashColor;
        else
            spriterender.color = normalColor;
        if (hp &amp;lt;= 1)
        {
            spriterender.color = dangerColor;
            if (hp &amp;lt;= 0)
            {
                state = State.Die;
            }
        }
    }

    public void FixedUpdate()
    {
        if (state == State.Stop || state == State.Attack)
        {
            rig.velocity = Vector2.zero;
        }
        else if (state == State.Walk)
        {
              rig.velocity = new Vector2(dir * speed, 0);
        }
        else if (state == State.Die)
        {
            rig.velocity = new Vector2(-3F,-1F);
        }
    }

    IEnumerator CancelStop()
    {
        yield return new WaitForSeconds(stopTime);
        state = State.Walk;
    }


    public void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.gameObject.tag == &quot;Player&quot; &amp;amp;&amp;amp;
          !PlayerController.instance.isFlash)
        {
            PlayerController.instance.Hurt();
            PlayerInfo.instance.SubHp();
        }
    }

    public void ChangeWalkState()
    {
        state = State.Walk;
    }


    public void Attack()
    {
        GameObject o = Instantiate(puke);
        Vector2 start = this.transform.Find(&quot;firePos&quot;).position;
        Vector2 end = GameObject.Find(&quot;player&quot;).transform.position;
        o.transform.position = start;
        Vector2 dir = end - start;
        dir = dir.normalized;
        o.GetComponent&amp;lt;Rigidbody2D&amp;gt;().velocity = dir*pukeSpeed;
        Instantiate(bosspuke);
    }

    public void Hit()
    {
        hp--;
        isFlash = true;
        StartCoroutine(ResetFlash());
        if (hp&amp;lt;=0)
        {
            Instantiate(kill);
        }
    }

    IEnumerator ResetFlash()
    {
        yield return new WaitForSeconds(flashTime);
        isFlash = false;
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;游戏的大体思路就是这样，让我们看看成品的图片&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/pvLuRg&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvLuRg.png&quot; alt=&quot;pvLuRg.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/pvLQMj&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvLQMj.png&quot; alt=&quot;pvLQMj.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/pvLKzQ&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvLKzQ.png&quot; alt=&quot;pvLKzQ.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/pvLnJS&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvLnJS.png&quot; alt=&quot;pvLnJS.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/pvLlss&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvLlss.png&quot; alt=&quot;pvLlss.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/pvLmi8&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/01/28/pvLmi8.png&quot; alt=&quot;pvLmi8.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
</description>
<pubDate>Tue, 06 Feb 2018 14:01:00 +0000</pubDate>
<dc:creator>优梦创客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/raymondking123/p/8380117.html</dc:identifier>
</item>
<item>
<title>JSP第六篇【自定义标签之传统标签】 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8424276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8424276.html</guid>
<description>&lt;p&gt;&lt;strong&gt;JSTL标签库只提供了简单的输出等功能，没有实现任何的HTML代码封装，并且某些复杂类型转换，或者逻辑处理的时候，JSTL标签库完成不了，需要自定义标签!&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;strong&gt;编写一个实现Tag接口的Java类【标签处理器类】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在WEB-INF目录下创建tld(Tag Library Descriptor)文件，在tld文件中对标签处理类（实现Tag接口的Java类）进行描述&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; showIp &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Tag {
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setPageContext&lt;/span&gt;(PageContext pageContext) {
    
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setParent&lt;/span&gt;(Tag tag) {
    
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Tag &lt;span class=&quot;fu&quot;&gt;getParent&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doStartTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doEndTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;() {
    
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;既然要获取到客户机的IP地址，那么request对象是必不可少的&lt;/strong&gt;。现在问题来了，&lt;strong&gt;在Tag重写的方法好像不能直接获取到request对象啊&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;经过我一番仔细的观察，发现了下面这个方法：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setPageContext&lt;/span&gt;(PageContext pageContext) {
    
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;既然能获取到pageContext对象，那么其他8大内置对象还不是随随便便？&lt;/strong&gt;于是乎，我就&lt;strong&gt;定义一个成员变量pageContext，在setPageContext()方法中传递过来的pageContext赋值给我定义的成员变量即可&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; PageContext pageContext = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setPageContext&lt;/span&gt;(PageContext pageContext) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;pageContext&lt;/span&gt; = pageContext;
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;好的，看回我们的需求：使用标签输出客户机的IP地址。&lt;strong&gt;在上面剩余5个方法中，最有可能就是在doStartTag()方法中编写代码&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doStartTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {

        &lt;span class=&quot;co&quot;&gt;//获取到request对象&lt;/span&gt;
        HttpServletRequest httpServletRequest = (HttpServletRequest) pageContext.&lt;span class=&quot;fu&quot;&gt;getRequest&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;//获取到客户机的ip地址&lt;/span&gt;
        String ip = httpServletRequest.&lt;span class=&quot;fu&quot;&gt;getRemoteAddr&lt;/span&gt;();
        
        &lt;span class=&quot;co&quot;&gt;//获取输出到浏览器的对象&lt;/span&gt;
        JspWriter jspWriter = pageContext.&lt;span class=&quot;fu&quot;&gt;getOut&lt;/span&gt;();
        
        &lt;span class=&quot;co&quot;&gt;//下面的异常只能捕获，因为子类的异常不能比父类多&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            jspWriter.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(ip);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;接着，&lt;strong&gt;编写tld文件，描述实现Tag接口的Java类【标签处理类】&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;taglib&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://java.sun.com/xml/ns/javaee&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;            xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;            xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;            version=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;2.1&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;tlib-version&amp;gt;&lt;/span&gt;1.0&lt;span class=&quot;kw&quot;&gt;&amp;lt;/tlib-version&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;short-name&amp;gt;&lt;/span&gt;zhongfucheng&lt;span class=&quot;kw&quot;&gt;&amp;lt;/short-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;uri&amp;gt;&lt;/span&gt;/zhongfucheng&lt;span class=&quot;kw&quot;&gt;&amp;lt;/uri&amp;gt;&lt;/span&gt;
    
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- Invoke 'Generate' action to add tags or functions --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;viewIp&lt;span class=&quot;kw&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag-class&amp;gt;&lt;/span&gt;tag.showIp&lt;span class=&quot;kw&quot;&gt;&amp;lt;/tag-class&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;body-content&amp;gt;&lt;/span&gt;empty&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body-content&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tag&amp;gt;&lt;/span&gt;
    
    
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/taglib&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;下面我们&lt;strong&gt;来测试一下看能不能用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/5OTwHUl.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;标签处理类详细说明&quot;&gt;标签处理类详细说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;看完上面的程序，大部分人都是懵逼的。因为还不知道它具体是怎么用的，调用顺序是什么&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;首先我们来看一下Tag接口的源码&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; Tag &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; JspTag {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SKIP_BODY = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; EVAL_BODY_INCLUDE = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SKIP_PAGE = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; EVAL_PAGE = &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;;
    
        &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setPageContext&lt;/span&gt;(PageContext var1);
    
        &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setParent&lt;/span&gt;(Tag var1);
    
        Tag &lt;span class=&quot;fu&quot;&gt;getParent&lt;/span&gt;();
    
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doStartTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException;
    
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doEndTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException;
    
        &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;();
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;上面程序的执行流程：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;JSP引擎遇到自定义标签，首先创建标签处理器类的实例对象&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;JSP引擎实例化完标签处理器类后，&lt;strong&gt;调用setPageContext()方法，将pageContext对象传递给标签处理器类，使得标签处理器类可以通过pageContext对象与JSP页面进行通信！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;setPageContext()方法执行完后，&lt;strong&gt;调用setParent()方法，将当前标签的父标签传递给当前处理器类，如果当前标签没有父标签，则传入null&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当WEB容器执行到自定义标签的开始标记时，调用doStartTag()方法。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当WEB容器执行到自定义标签的结束标记时，调用doEndTag()方法。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一般来说，&lt;strong&gt;当WEB容器执行完自定义标签后，标签处理器类会驻留在内存中，直至停止WEB应用时，WEB容器才会调用release()方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170208140937722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;我们现在已经清楚了方法的执行顺序了，&lt;strong&gt;可Tag接口的源码还有4个变量阿，它们是用来做什么的呢？我们在编写JSP页面时，经常需要在页面中引入一些逻辑，例如：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;控制JSP页面某一部分（标签体）是否执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制整个JSP页面是否执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制JSP页面内容重复执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修改JSP页面内容输出&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;再看回4个变量的名字，我们可以发现，这4个变量就是用来做逻辑判断的&lt;/strong&gt;！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们来测试一下吧，&lt;strong&gt;在doEndTag()方法中，返回的是SKIP_PAGE变量，看下会怎么样&lt;/strong&gt;！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doEndTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; SKIP_PAGE;
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;我们再来看一看效果：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/ViNg91X.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;好像是没什么区别！我们再查看一下源代码，&lt;strong&gt;发现执行完标签后，后面的代码全都没有执行！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/A1cvpAU.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;doStartTag()方法使用的是SKIP_BODY和EVAL_BODY_INCLUDE这两个变量，判断是否执行标签体的内容。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;doEndTag()方法使用的是SKIP_PAGE和EVAL_PAGE这两个变量，判断是否执行剩下页面的内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制JSP页面内容重复执行和修改JSP页面内容输出后面会有！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;tld文件详细说明&quot;&gt;tld文件详细说明&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170208142210947?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170208142230738?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先我们来&lt;strong&gt;看一下tld文件当前用到的内容吧&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;tlib-version&amp;gt;&lt;/span&gt;1.0&lt;span class=&quot;kw&quot;&gt;&amp;lt;/tlib-version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;short-name&amp;gt;&lt;/span&gt;myshortname&lt;span class=&quot;kw&quot;&gt;&amp;lt;/short-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;uri&amp;gt;&lt;/span&gt;http://mycompany.com&lt;span class=&quot;kw&quot;&gt;&amp;lt;/uri&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;name&amp;gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag-class&amp;gt;&amp;lt;/tag-class&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;body-content&amp;gt;&amp;lt;/body-content&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tag&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;我们一个一个来看：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;shortname推荐使用prefix&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;uri就是引入这个标签库使用的uri&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;name为标签名&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tagclass为实现类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bodycontent为标签体的限制&lt;/strong&gt;，它有4个值： &lt;strong&gt;EMPTY【不允许有标签体】，JSP【允许有JSP代码】 ，scriptless【不允许有脚本代码（也就是&amp;lt;%%&amp;gt;），允许有EL表达式，文本，JSP行为】 ， tagdepentend【标签体内的JSP代码不会被解析，直接输出文本】&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;大部分时候我们都不需要实现Tag接口来编写自定义标签，TagSupport是Tag的一个模板类，实现了pageContext，parent的getter、setter方法以及一些其他的功能。我们要做的就是重写doStartTag()和doEndTag()方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Demo1 &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; TagSupport {
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doStartTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
    
            &lt;span class=&quot;co&quot;&gt;//获取到request对象&lt;/span&gt;
            HttpServletRequest httpServletRequest = (HttpServletRequest) pageContext.&lt;span class=&quot;fu&quot;&gt;getRequest&lt;/span&gt;();
    
            String method = httpServletRequest.&lt;span class=&quot;fu&quot;&gt;getMethod&lt;/span&gt;();
    
            JspWriter jspWriter = pageContext.&lt;span class=&quot;fu&quot;&gt;getOut&lt;/span&gt;();
    
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                jspWriter.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(method);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
    
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在tld文件中描述一把&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;showMethod&lt;span class=&quot;kw&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag-class&amp;gt;&lt;/span&gt;tag.Demo1&lt;span class=&quot;kw&quot;&gt;&amp;lt;/tag-class&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;body-content&amp;gt;&lt;/span&gt;empty&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body-content&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tag&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/oIFCZ3v.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;带属性的标签&quot;&gt;带属性的标签&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;上面我们编写的自定义标签都没有附带属性的，我们在使用core标签库的时候，标签一般都带有属性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其实&lt;strong&gt;JSTL标签库的原理就是自定义标签，把自定义标签搞明白了，对JSTL标签库的使用就有更好的理解了&lt;/strong&gt;！&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;想要自定义标签带有属性也非常简单，只要在标签处理器类上加一个成员变量和setter、getter()，再在tld文件中描述下该属性即可！它的原理是这样的：当标签使用到属性的时候，引擎就会调用它的setter()方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;下面我想要完成的功能是：&lt;strong&gt;使用标签的人，传入一个字符串格式就可以显示想要的格式日期&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;编写标签处理器类，增加一个成员变量以及对应的setter、getter方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Demo1 &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; TagSupport {
    
    
        &lt;span class=&quot;co&quot;&gt;//创建成员对象，对应的setter、getter方法&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String format = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doStartTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
    
            &lt;span class=&quot;co&quot;&gt;//创建日期格式化对象&lt;/span&gt;
            SimpleDateFormat simpleDateFormat = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(format);
    
            &lt;span class=&quot;co&quot;&gt;//格式化日期并向浏览器输出&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                pageContext.&lt;span class=&quot;fu&quot;&gt;getOut&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(simpleDateFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date()));
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
    
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getFormat&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; format;
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setFormat&lt;/span&gt;(String format) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt; = format;
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在tld文件中描述标签和属性，name代表的是属性的名字，required代表的是是否为必须，rtexprvalue代表能否使用EL表达式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;formatDate&lt;span class=&quot;kw&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag-class&amp;gt;&lt;/span&gt;tag.Demo1&lt;span class=&quot;kw&quot;&gt;&amp;lt;/tag-class&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;body-content&amp;gt;&lt;/span&gt;empty&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body-content&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;attribute&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;format&lt;span class=&quot;kw&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;required&amp;gt;&lt;/span&gt;true&lt;span class=&quot;kw&quot;&gt;&amp;lt;/required&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;rtexprvalue&amp;gt;&lt;/span&gt;true&lt;span class=&quot;kw&quot;&gt;&amp;lt;/rtexprvalue&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/attribute&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tag&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;我们来看一下效果：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/MNYQ0kK.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/OLL4Pwo.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在深入讲解之前，我们先来看一下各种Tag接口、类之间的关系，这样学习下去才不会晕&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/uqf1Ndn.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;iterationtag说明&quot;&gt;IterationTag说明&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;我们已经使用过了Tag接口和TagSupport类了&lt;/strong&gt;。接下来我们看一下IterationTag是什么玩意。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; IterationTag &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Tag {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; EVAL_BODY_AGAIN = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
    
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doAfterBody&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;从关系图我们也可以看出，&lt;strong&gt;IterationTag接口实现了Tag接口，InterationTag接口和Tag接口最主要的区别就是多了个doAfterBody()方法和EVAL_BODY_AGAIN变量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;理解起来也很简单：&lt;strong&gt;当doAfterBody()返回的是EVAL_BODY_AGAIN变量，那么标签体的内容就一直循环&lt;/strong&gt;！当然了，&lt;strong&gt;TagSupport也实现了Iteration接口，也就是说TagSupport类也能完成Iteration接口的事情&lt;/strong&gt;！&lt;/li&gt;
&lt;li&gt;我们来使用一下吧：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Demo1 &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; TagSupport {
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doStartTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
    
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                pageContext.&lt;span class=&quot;fu&quot;&gt;getOut&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
    
            &lt;span class=&quot;co&quot;&gt;//执行标签体&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; EVAL_BODY_INCLUDE;
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doAfterBody&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
    
            &lt;span class=&quot;co&quot;&gt;//标签体不断循环，直到doAfterBody()返回的是SKIP_BODY&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; EVAL_BODY_AGAIN;
        
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;tld文件中描述，&lt;strong&gt;既然标签体有内容，就不能用empty了&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;foreverEval&lt;span class=&quot;kw&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag-class&amp;gt;&lt;/span&gt;tag.Demo1&lt;span class=&quot;kw&quot;&gt;&amp;lt;/tag-class&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;body-content&amp;gt;&lt;/span&gt;tagdependent&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body-content&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tag&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;注意看横向的滑轮，已经死循环输出了：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/wu4iNkk.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;doAfterBody()中只要返回的是SKPI_BODY就退出循环，执行doEndTag()方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;//定义一个变量，规定标签体循环的次数&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doStartTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
    
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                pageContext.&lt;span class=&quot;fu&quot;&gt;getOut&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
    
            &lt;span class=&quot;co&quot;&gt;//执行标签体&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; EVAL_BODY_INCLUDE;
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doAfterBody&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
            
            x++;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (x &amp;gt;= &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; SKIP_BODY;
            }
    
            &lt;span class=&quot;co&quot;&gt;//标签体不断循环，直到doAfterBody()返回的是SKIP_BODY&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; EVAL_BODY_AGAIN;
    
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;现在我们已经能控制循环的次数了&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/bvb2N5q.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;bodytag说明&quot;&gt;BodyTag说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;前面我们已经使用到了带标签体的自定义标签了，前面的都是只能直接输出而得不到标签体的内容，既然得不到标签体的内容，就更别说修改标签体了&lt;/strong&gt;！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;此时，我们就需要BodyTag接口的支持了！&lt;strong&gt;它专门用来处理带标签体的标签&lt;/strong&gt;，下面我们来&lt;strong&gt;看一下BodyTag的源码&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; BodyTag &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; IterationTag {
        &lt;span class=&quot;co&quot;&gt;/** @deprecated */&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; EVAL_BODY_TAG = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;

        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; EVAL_BODY_BUFFERED = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
    
        &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setBodyContent&lt;/span&gt;(BodyContent var1);
    
        &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doInitBody&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;BodyTag多了EVAL_BODY_BUFFERED变量【一个已经标识过时了】，多了setBodyContent和doInitBody()两个方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;其实&lt;strong&gt;使用BodyTag十分简单&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;如果doStartTag()方法返回的是EVAL_BODY_BUFFERED，把标签体的内容缓存起来&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接着调用setBodyContent()方法和doInitBody()方法，封装标签体的内容到BodyContent对象中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接着调用doEndTag()方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于标签体的内容，我们可以通过getBodyContenet()来获取！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再看回上面的关系图，BodyTag实现了IterationTag和Tag接口，如果直接实现BodyTag接口做开发，要实现的方法就太多了。一般我们使用继承BodyTag的BodyTagSupport来做开发&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;bodytagsupport说明&quot;&gt;BodyTagSupport说明&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先来看一下源代码吧：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BodyTagSupport &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; TagSupport &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; BodyTag {
        &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; BodyContent bodyContent;
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BodyTagSupport&lt;/span&gt;() {
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doStartTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doEndTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;doEndTag&lt;/span&gt;();
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setBodyContent&lt;/span&gt;(BodyContent b) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;bodyContent&lt;/span&gt; = b;
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doInitBody&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doAfterBody&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;bodyContent&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;();
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; BodyContent &lt;span class=&quot;fu&quot;&gt;getBodyContent&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;bodyContent&lt;/span&gt;;
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; JspWriter &lt;span class=&quot;fu&quot;&gt;getPreviousOut&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;bodyContent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getEnclosingWriter&lt;/span&gt;();
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;可以发现:&lt;strong&gt;BodyTagSupport主要扩充了以下的内容:&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;把BodyContent直接定义为成员变量，在获取标签体内容的时候就不需要通过getBodyContent()获取了&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供获取JspWriter的方法，不需要从pageConext中获取了&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以上的两个扩充都简化了我们的代码书写&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

        &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; BodyContent bodyContent;

        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; JspWriter &lt;span class=&quot;fu&quot;&gt;getPreviousOut&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;bodyContent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getEnclosingWriter&lt;/span&gt;();
        }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;从BodyTag接口中，我就说到了：&lt;strong&gt;标签体的内容封装到了BodyContent类中，那么BodyContent类究竟是什么？我们来看一下源码&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BodyContent &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; JspWriter {
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; JspWriter enclosingWriter;
    
        &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BodyContent&lt;/span&gt;(JspWriter e) {
            &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(-&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;enclosingWriter&lt;/span&gt; = e;
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;flush&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IOException(&lt;span class=&quot;st&quot;&gt;&quot;Illegal to flush within a custom tag&quot;&lt;/span&gt;);
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;clearBody&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;clear&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException var2) {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;st&quot;&gt;&quot;internal error!;&quot;&lt;/span&gt;);
            }
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; Reader &lt;span class=&quot;fu&quot;&gt;getReader&lt;/span&gt;();
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;();
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;writeOut&lt;/span&gt;(Writer var1) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException;
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; JspWriter &lt;span class=&quot;fu&quot;&gt;getEnclosingWriter&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;enclosingWriter&lt;/span&gt;;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;原来BodyContent继承着JspWriter，它与JspWriter最大的区别是：BodyContent类的任何写入的内容并不自动地向页面输出！&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我们一般使用BodyContent都使用两个方法：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;//将数据转变成Reader对象&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; Reader &lt;span class=&quot;fu&quot;&gt;getReader&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;//将数据转变成String对象&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;再从关系图我们可以看初，&lt;strong&gt;BodyTagSupport继承了TagSupport类实现了BodyTag接口，可以说：BodyTagSupport有着前面讲的接口和类的所有功能！&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;下面我们来&lt;strong&gt;使用下BodyTagSupport将标签体的内容转成是小写的&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标签处理器类&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Demo1 &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; BodyTagSupport {
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doStartTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
    
    
            &lt;span class=&quot;co&quot;&gt;//想要获取到标签体的内容，就要返回EVAL_BODY_BUFFERED变量&lt;/span&gt;
    
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; EVAL_BODY_BUFFERED;
    
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doEndTag&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; JspException {
    
            &lt;span class=&quot;co&quot;&gt;//获取到标签体的内容&lt;/span&gt;
            String value = bodyContent.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;();
    
            &lt;span class=&quot;co&quot;&gt;//将标签体的内容转成小写并输出&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getPreviousOut&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(value.&lt;span class=&quot;fu&quot;&gt;toLowerCase&lt;/span&gt;());
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
    
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;doEndTag&lt;/span&gt;();
        }
    
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;tld文件：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;BodyContentToLowerCase&lt;span class=&quot;kw&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;tag-class&amp;gt;&lt;/span&gt;tag.Demo1&lt;span class=&quot;kw&quot;&gt;&amp;lt;/tag-class&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;body-content&amp;gt;&lt;/span&gt;tagdependent&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body-content&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tag&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/tpxuWP3.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章的同学，可以关注微信公众号:Java3y.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 06 Feb 2018 13:15:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8424276.html</dc:identifier>
</item>
</channel>
</rss>