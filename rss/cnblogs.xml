<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>CSS属性：定位属性（图文详解） - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8296748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8296748.html</guid>
<description>&lt;blockquote readability=&quot;5.375&quot;&gt;
&lt;p&gt;本文最初发表于&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8296748.html&quot;&gt;博客园&lt;/a&gt;，并在&lt;a href=&quot;https://github.com/smyhvae/Web&quot;&gt;GitHub&lt;/a&gt;上持续更新&lt;strong&gt;前端的系列文章&lt;/strong&gt;。欢迎在GitHub上关注我，一起入门和进阶前端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CSS的定位属性有三种，分别是绝对定位、相对定位、固定定位。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    position: absolute;  &amp;lt;!-- 绝对定位 --&amp;gt;

    position: relative;  &amp;lt;!-- 相对定位 --&amp;gt;

    position: fixed;     &amp;lt;!-- 固定定位 --&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面逐一介绍。&lt;/p&gt;
&lt;h2 id=&quot;相对定位&quot;&gt;相对定位&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;相对定位&lt;/strong&gt;：让元素相对于自己原来的位置，进行位置调整（可用于盒子的位置微调）。&lt;/p&gt;
&lt;p&gt;我们之前学习的背景属性中，是通过如下格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-position:向右偏移量 向下偏移量;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这回的定位属性，是通过如下格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    position: relative;
    left: 50px;
    top: 50px;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相对定位的举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;er&quot;&gt;&amp;lt;&lt;/span&gt;!doctype html&amp;gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Generator&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;EditPlus®&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Author&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Keywords&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Description&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Document&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/css&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

        body&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;fl&quot;&gt;.div1&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;fl&quot;&gt;.div2&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/*相对定位：相对于自己原来的位置*/&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/*横坐标：正值表示向右偏移，负值表示向左偏移*/&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/*纵坐标：正值表示向下偏移，负值表示向上偏移*/&lt;/span&gt;

            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;

 &lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;div1&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;有生之年&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;div2&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;狭路相逢&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

 &lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-28.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;相对定位不脱标&quot;&gt;相对定位不脱标&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;相对定位&lt;/strong&gt;：不脱标，老家留坑，&lt;strong&gt;别人不会把它的位置挤走&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也就是说，相对定位的真实位置还在老家，只不过影子出去了，可以到处飘。&lt;/p&gt;
&lt;h3 id=&quot;相对定位的用途&quot;&gt;相对定位的用途&lt;/h3&gt;
&lt;p&gt;相对定位有坑，所以如果需要做一般不用于做“压盖”效果（把一个div放到另一个div之上）。页面中，效果极小。就两个作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（1）微调元素&lt;/li&gt;
&lt;li&gt;（2）做绝对定位的参考，子绝父相&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;相对定位的定位值&quot;&gt;相对定位的定位值&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;left：盒子右移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right：盒子左移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;top：盒子下移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bottom：盒子上移&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：负数表示相反的方向。&lt;/p&gt;
&lt;p&gt;↘：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    position: relative;
    left: 40px;
    top: 10px;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;↙：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    position: relative;
    right: 100px;
    top: 100px;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;↖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    position: relative;
    right: 100px;
    bottom: 100px;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;↗：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    position: relative;
    left: 200px;
    bottom: 200px;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180115_1716.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果要描述上面这张图的方向，我们可以首先可以这样描述：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    position: relative;
    left: 200px;
    top: 100px;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;left: 200px&lt;/code&gt;等价于&lt;code&gt;right: -200px&lt;/code&gt;，所以这张图其实有四种写法。&lt;/p&gt;
&lt;h2 id=&quot;绝对定位&quot;&gt;绝对定位&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;绝对定位&lt;/strong&gt;：定义横纵坐标，原点在父容器的左上角或左下角。横坐标用left表示，纵坐标用top或者bottom表示。&lt;/p&gt;
&lt;p&gt;格式举例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    position: absolute;  /*绝对定位*/
    left: 10px;  /*横坐标*/
    top/bottom: 20px;  /*纵坐标*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;绝对定位脱标&quot;&gt;绝对定位脱标&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;绝对定位的盒子脱离了标准文档流。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，所有的标准文档流的性质，绝对定位之后都不遵守了。&lt;/p&gt;
&lt;p&gt;绝对定位之后，标签就不区分所谓的行内元素、块级元素了，不需要&lt;code&gt;display:block&lt;/code&gt;就可以设置宽、高了。&lt;/p&gt;
&lt;h3 id=&quot;绝对定位的参考点重要&quot;&gt;绝对定位的参考点（重要）&lt;/h3&gt;
&lt;p&gt;（1）如果用&lt;strong&gt;top描述&lt;/strong&gt;，那么参考点就是&lt;strong&gt;页面的左上角&lt;/strong&gt;，而不是浏览器的左上角：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180115_2120.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）如果用&lt;strong&gt;bottom描述&lt;/strong&gt;，那么参考点就是&lt;strong&gt;浏览器首屏窗口尺寸&lt;/strong&gt;（好好理解“首屏”二字），对应的页面的左下角：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180115_2121.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了理解“&lt;strong&gt;首屏&lt;/strong&gt;”二字的含义，我们来看一下动态图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180115_2200.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180115_2131.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;p&gt;用bottom的定位的时候，参考的是浏览器首屏大小对应的页面左下角。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180115_2132.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;以盒子为参考点&quot;&gt;以盒子为参考点&lt;/h3&gt;
&lt;p&gt;一个绝对定位的元素，如果父辈元素中也出现了已定位（无论是绝对定位、相对定位，还是固定定位）的元素，那么将以父辈这个元素，为参考点。&lt;/p&gt;
&lt;p&gt;如下：（子绝父相）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180115_2210.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下几点需要注意。&lt;/p&gt;
&lt;p&gt;（1） 要听最近的已经定位的祖先元素的，不一定是父亲，可能是爷爷：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        &amp;lt;div class=&quot;box1&quot;&amp;gt;        相对定位
            &amp;lt;div class=&quot;box2&quot;&amp;gt;    没有定位
                &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;           绝对定位，将以box1为参考，因为box2没有定位，box1就是最近的父辈元素
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        &amp;lt;div class=&quot;box1&quot;&amp;gt;        相对定位
            &amp;lt;div class=&quot;box2&quot;&amp;gt;    相对定位
                &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;           绝对定位，将以box2为参考，因为box2是自己最近的父辈元素
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）不一定是相对定位，任何定位，都可以作为儿子的参考点：&lt;/p&gt;
&lt;p&gt;子绝父绝、&lt;strong&gt;子绝父相&lt;/strong&gt;、子绝父固，都是可以给儿子定位的。但是在工程上，如果子绝、父绝，没有一个盒子在标准流里面了，所以页面就不稳固，没有任何实战用途。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工程应用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“&lt;strong&gt;子绝父相&lt;/strong&gt;”有意义：这样可以保证父亲没有脱标，儿子脱标在父亲的范围里面移动。于是，工程上经常这样做：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;父亲浮动，设置相对定位（零偏移），然后让儿子绝对定位一定的距离。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（3）绝对定位的儿子，无视参考的那个盒子的padding：&lt;/p&gt;
&lt;p&gt;下图中，绿色部分是父亲div的padding，蓝色部分p是div的内容区域。此时，如果div相对定位，p绝对定位，那么，&lt;br/&gt;p将无视父亲的padding，在border内侧为参考点，进行定位：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180116_0812.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工程应用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;绝对定位非常适合用来做“压盖”效果。我们来举个lagou.com上的例子。&lt;/p&gt;
&lt;p&gt;现在有如下两张图片素材：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180116_1115.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180116_1116.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要求作出如下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180116_1117.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Document&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/css&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.box&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;308px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;307px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#FF7E00&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;/*子绝父相*/&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.box&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;.image&lt;/span&gt; img&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;308px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;196px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.box&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;.dtc&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;/*转为块级元素，才能设置span的宽高*/&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;52px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;28px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-image:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;url(&lt;/span&gt;http://img&lt;span class=&quot;dt&quot;&gt;.&lt;/span&gt;smyhvae&lt;span class=&quot;dt&quot;&gt;.&lt;/span&gt;com/&lt;span class=&quot;dt&quot;&gt;20180116&lt;/span&gt;_1115&lt;span class=&quot;dt&quot;&gt;.&lt;/span&gt;png&lt;span class=&quot;dt&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-108px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/*这里用到了精灵图*/&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;absolute&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;/*采用绝对定位的方式，将精灵图盖在最上层*/&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-9px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;13px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.box&lt;/span&gt; h4&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;308px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;40px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;line-height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;40px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;absolute&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;156px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;box&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;span&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dtc&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://img.smyhvae.com/20180116_1116.jpg&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; alt=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;h4&amp;gt;&lt;/span&gt;广东深圳宝安区建安一路海雅缤纷城4楼&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h3&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码解释如下：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为了显示“多套餐”那个小图，我们需要用到精灵图。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;“多套餐”下方黑色背景的文字都是通过“子绝父相”的方式的盖在大海报image的上方的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180116_1335.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;让绝对定位中的盒子居中&quot;&gt;让绝对定位中的盒子居中&lt;/h3&gt;
&lt;p&gt;我们知道，如果想让一个&lt;strong&gt;标准流中的盒子居中&lt;/strong&gt;（水平方向看），可以将其设置&lt;code&gt;margin: 0 auto&lt;/code&gt;属性。&lt;/p&gt;
&lt;p&gt;可如果盒子是绝对定位的，此时已经脱标了，如果还想让其居中，可以这样做：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div&amp;gt;
    width: 600px;
    height: 60px;
    position: absolute;  绝对定位的盒子
    left: 50%;           首先，让左边线居中
    top: 0;
    margin-left: -300px;  然后，向左移动宽度（600px）的一半
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上方代码所示，我们先让这个宽度为600px的盒子，左边线居中，然后向左移动宽度（600px）的一半，就达到效果了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180116_1356.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以总结成一个公式：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;left:50%; margin-left:负的宽度的一半&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;固定定位&quot;&gt;固定定位&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;固定定位&lt;/strong&gt;：就是相对浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变。&lt;/p&gt;
&lt;p&gt;备注：IE6不兼容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用途1&lt;/strong&gt;：网页右下角的“返回到顶部”&lt;/p&gt;
&lt;p&gt;比如我们经常看到的网页右下角显示的“返回到顶部”，就可以固定定位。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/css&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.backtop&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;fixed&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;bottom:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;right:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;30px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;60px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;60px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;gray&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;text-align:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;line-height:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;30px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;text-decoration:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;/*去掉超链接的下划线*/&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;用途2：&lt;/strong&gt;顶部导航条&lt;/p&gt;
&lt;p&gt;我们经常能看到固定在网页顶端的导航条，可以用固定定位来做。&lt;/p&gt;
&lt;p&gt;需要注意的是，假设顶部导航条的高度是60px，那么，为了防止其他的内容被导航条覆盖，我们要给body标签设置60px的padding-top。&lt;/p&gt;
&lt;p&gt;顶部导航条的实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xml:lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; http-equiv=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Document&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/css&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        *&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;padding:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
body&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;/*为什么要写这个？*/&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;/*不希望我们的页面被nav挡住*/&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;padding-top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;60px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;/*IE6不兼容固定定位，所以这个padding没有什么用，就去掉就行了*/&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;_padding-top:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;fixed&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;60px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#333&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;z-index:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;99999999&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.inner_c&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1000px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;60px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.inner_c&lt;/span&gt; ul&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;list-style:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.inner_c&lt;/span&gt; ul li&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;float:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;60px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;text-align:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;line-height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;60px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.inner_c&lt;/span&gt; ul li a&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;60px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;text-decoration:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.inner_c&lt;/span&gt; ul li a&lt;span class=&quot;dv&quot;&gt;:hover&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; gold&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        p&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;font-size:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;30px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.btn&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;30px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; orange&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;2px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;nav&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;inner_c&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网页栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网页栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网页栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网页栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网页栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网页栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网页栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网页栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网页栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网页栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;z-index属性&quot;&gt;5、z-index属性：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;z-index&lt;/strong&gt;属性：表示谁压着谁。数值大的压盖住数值小的。&lt;/p&gt;
&lt;p&gt;有如下特性：&lt;/p&gt;
&lt;p&gt;（1）属性值大的位于上层，属性值小的位于下层。&lt;/p&gt;
&lt;p&gt;（2）z-index值没有单位，就是一个正整数。默认的z-index值是0。&lt;/p&gt;
&lt;p&gt;（3）如果大家都没有z-index值，或者z-index值一样，那么在HTML代码里写在后面，谁就在上面能压住别人。定位了的元素，永远能够压住没有定位的元素。&lt;/p&gt;
&lt;p&gt;（4）只有定位了的元素，才能有z-index值。也就是说，不管相对定位、绝对定位、固定定位，都可以使用z-index值。&lt;strong&gt;而浮动的元素不能用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（5）从父现象：父亲怂了，儿子再牛逼也没用。意思是，如果父亲1比父亲2大，那么，即使儿子1比儿子2小，儿子1也能在最上层。&lt;/p&gt;
&lt;p&gt;针对（1）（2）（3）条，举例如下：&lt;/p&gt;
&lt;p&gt;这是默认情况下的例子：（div2在上层，div1在下层）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-32.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在加一个&lt;code&gt;z-index&lt;/code&gt;属性，要求效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-33.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第五条分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180116_1445.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;z-index属性的应用还是很广泛的。当好几个已定位的标签出现覆盖的现象时，我们可以用这个z-index属性决定，谁处于最上方。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 07:08:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8296748.html</dc:identifier>
</item>
<item>
<title>Spring 事务管理 - _wave</title>
<link>http://www.cnblogs.com/wave-gbt/p/spring-transaction.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wave-gbt/p/spring-transaction.html</guid>
<description>[unable to retrieve full-text content]事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。</description>
<pubDate>Tue, 16 Jan 2018 07:04:00 +0000</pubDate>
<dc:creator>_wave</dc:creator>
<dc:identifier>http://www.cnblogs.com/wave-gbt/p/spring-transaction.html</dc:identifier>
</item>
<item>
<title>LevelDB的源码阅读（三） Put操作 - 雪球球</title>
<link>http://www.cnblogs.com/xueqiuqiu/p/8296324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueqiuqiu/p/8296324.html</guid>
<description>[unable to retrieve full-text content]在Linux上leveldb的安装和使用中我们写了这么一段测试代码，内容以及输出结果如下： Leveldb的写数据流程入口为db文件夹下db_impl.cc文件中的DBImpl::Put和DBImpl::Delete,这两个文件是DBImpl::Write接口的封装，将写操作封装成WriteBatc</description>
<pubDate>Tue, 16 Jan 2018 06:48:00 +0000</pubDate>
<dc:creator>雪球球</dc:creator>
<dc:identifier>http://www.cnblogs.com/xueqiuqiu/p/8296324.html</dc:identifier>
</item>
<item>
<title>看JQ时代过来的前端，如何转换思路用Vue打造选项卡组件 - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/8277007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/8277007.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在Vue还未流行的时候，我们都是用JQuery来封装一个选项卡插件，如今Vue当道，让我们一起来看看从JQ时代过来的前端是如何转换思路，用数据驱动DOM的思想打造一个Vue选项卡组件。&lt;/p&gt;
&lt;p&gt;接下来，正文从这开始~&lt;/p&gt;
&lt;p&gt; 先来看一下用Vue写的选项卡组件在浏览器上的展示效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201801/701424-20180112175449676-1668438400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实，你在浏览器上看到的UI界面效果也就是那么回事，中规中矩。当点开Chrome的Devtools下面的Elements选项，你看到的dom节点其实和jQuery的dom节点如出一辙，不同的是，现在你看到的dom树是在Vue组件生命周期mounted之后渲染得到的真实DOM&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201801/701424-20180112175641504-970477155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们来聊一聊关于选项卡组件的业务需求，每个标签页的主体内容是由使用组件的父级控制，所以这部分应该是一个slot。slot的数量决定了标签切换按钮的数量。假设我们有3个标签页，点击每个标签按钮时，另外的两个标签对应的slot将被隐藏掉。&lt;/p&gt;
&lt;p&gt;先来贴出html结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt; v-cloak&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tabs&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pane  &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;标签一&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;标签一的内容&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pane&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pane  &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;标签二&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;标签二的内容&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pane&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pane  &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;标签三&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;标签三的内容&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pane&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tabs&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由html结构可知，我们需要定义两个组件tabs和子组件pane，pane嵌套在标签组件tabs里面。由于tabs和pane两个组件是分离的，但是tabs的组件上的标题应该由pane组件来定义，因为slot是写在pane里，因此在组件初始化（以及标签标题动态改变）时，tabs要从pane里获取标题，并保存起来，自己使用。&lt;/p&gt;
&lt;p&gt;接下来，先初始化各个组件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Vue.component('tabs'&lt;span&gt;,{
    template:`
        &lt;/span&gt;&amp;lt;div class=&quot;tabs&quot;&amp;gt;
            &amp;lt;div class=&quot;tabs-bar&quot;&amp;gt;
                &amp;lt;!-- 标签页标题，这里要用v-&lt;span&gt;for&lt;/span&gt; --&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;tabs-content&quot;&amp;gt;
                &amp;lt;!-- 这里的slot就是嵌套的pane --&amp;gt;
                &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
&lt;span&gt;    `
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Vue.component('pane'&lt;span&gt;,{
    name:&lt;/span&gt;'pane'&lt;span&gt;,
    template:`
        &lt;/span&gt;&amp;lt;div class=&quot;pane&quot; v-show=&quot;show&quot;&amp;gt;
            &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
        &amp;lt;/div&amp;gt;
&lt;span&gt;    `,
    data:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            show:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pane组件中需要控制标签页内容的显示与隐藏，所以设置一个data：show，并且用v-show指令来控制元素。&lt;/p&gt;
&lt;p&gt;如果你是用jQuery写过选项卡，应该知道，在写完控制tabs标题显示与隐藏后，接下来该控制tabs内容的显示与隐藏了。那么如果要点击对应的标签页标题显示对应的标签页内容，此时应该有一个唯一的值来标识这个pane，我们可以设置一个prop：name让用户来设置，其实这个name也就是索引index。除了name，还需要设置标签页的标题prop：label。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;props:{
     name:{
        type:String
     },
        label:{
            type:String,
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;:''&lt;span&gt;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的标题prop：label 用户是可以动态调整的，所以在pane初始化及label更新时，都要通知父组件也更新，因为是独立独立组件，我们可以直接通过this.$parent访问tabs组件的实例来调用它的方法更新标题，这个方法名暂定为updateNav：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;methods:{
    updateNav(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$parent.updateNav();
    }
},
watch:{
    label(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.updateNav();
    }
},
mounted(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.updateNav();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过以上代码可以看到，在生命周期mounted，也就是pane初始化时，调用一遍tabs的updateNav方法，同时监听了prop：label，在label更新时，同样调用。&lt;/p&gt;
&lt;p&gt;说完了pane组件，剩下的任务就是完成tabs组件。&lt;/p&gt;
&lt;p&gt;首先就是需要把pane组件设置的标题动态渲染出来，也就是当pane触发tabs的updateNav方法时，更新标题内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
        Vue.component('tabs'&lt;span&gt;,{
            template:`
                &lt;/span&gt;&amp;lt;div class=&quot;tabs&quot;&amp;gt;
                    &amp;lt;div class=&quot;tabs-bar&quot;&amp;gt;
                        &amp;lt;&lt;span&gt;div
                            :class&lt;/span&gt;=&quot;tabCls(item)&quot;&lt;span&gt;
                            v&lt;/span&gt;-&lt;span&gt;for&lt;/span&gt;=&quot;(item,index) in navList&quot;&lt;span&gt;
                            @click&lt;/span&gt;=&quot;handleChange(index)&quot;&amp;gt;&lt;span&gt;
                            {{item.label}}
                        &lt;/span&gt;&amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;tabs-content&quot;&amp;gt;
                        &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
&lt;span&gt;            `,
            props:{&lt;br/&gt;　　　　　　　　　　// 这里的value是为了可以使用v-model
                value:{
                    type:[String, Number]
                }
            },
            data:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　　　　　　// 因为不能修改value，所以复制一份自己维护
                    currentValue:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value,
                    navList:[]  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于渲染tabs的标题&lt;/span&gt;
&lt;span&gt;                }
            },
            methods:{
                tabCls:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [
                        &lt;/span&gt;'tabs-tab'&lt;span&gt;,
                        {&lt;br/&gt;　　　　　　　　　　　　　　　　　// 给当前选中的tab加一个class
                            &lt;/span&gt;'tabs-tab-active': item.name === &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentValue
                        }
                    ]
                },
                getTabs(){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过遍历子组件，得到所有的pane组件&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.$children.filter(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item.$options.name === 'pane'&lt;span&gt;;
                    });
                },
                updateNav(){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.navList=&lt;span&gt;[];
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置对this的引用，在function回调里，this指向的并不是vue实例&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getTabs().forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(pane,index){
                        _this.navList.push({
                            label:pane.label,
                            name:pane.name &lt;/span&gt;||&lt;span&gt; index
                        });
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有给pane设置那么，默认设置它的索引&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt;(!pane.name) pane.name =&lt;span&gt; index;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置当前选中的tab的索引&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt;(index === 0&lt;span&gt;){
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;_this.currentValue){
                                _this.currentValue &lt;/span&gt;= pane.name ||&lt;span&gt; index;
                            }
                        }
                    });
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(this.navList);&lt;/span&gt;

                    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.updateStatus();
                },
                updateStatus(){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tabs = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getTabs();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(tabs);&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 显示当前选中的tab对应的pane组件，隐藏没有选中的&lt;/span&gt;
                    tabs.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(tab){
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(tab.name === _this.currentValue);&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; tab.show = tab.name ===&lt;span&gt; _this.currentValue;
                    })
                },&lt;br/&gt;　　　　　　　　　 // 点击tab标题时触发
                handleChange:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(index){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nav = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.navList[index];
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name =&lt;span&gt; nav.name;
                    console.log(name);&lt;br/&gt;　　　　　　　　　　　　// 改变当前选中的tab，并触发下面的watch
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentValue =&lt;span&gt; name;&lt;/span&gt;
&lt;span&gt;                }
            },
            watch:{
                value:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentValue =&lt;span&gt; val;
                },
                currentValue:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.updateStatus();
                }
            }
        })    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;getTabs是一个公用的方法，使用this.$children来拿到所有的pane组件实例。在遍历了每一个pane组件后，把他的label和name提取出来，构建成一个Object并添加到数据navList数组里。拿到navList后，就可以用v-for把tab的标题渲染出来，并且判断每个tab当前的状态。&lt;/p&gt;
&lt;p&gt;通过以上代码，大家可以看到，在使用v-for指令循环显示tab标题时，使用v-bind:class指向了一个名为tabCls的methods来动态设置class名称。&lt;/p&gt;
&lt;p&gt;点击每个tab标题时，会触发handleChange方法来改变当前选中的tab的索引，也就是pane组件的name。在watch选项里，我们监听了currentValue，当其发生变化时，触发了updateStatus方法来更新了pane组件的显示状态。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;总结一下：该选项卡组件，使用了组件嵌套的方式，将一系列pane组件作为tabs组件的slot；tabs组件和pane组件通信上，使用了$parent 和 $children 的方法访问父链和子链；定义了prop：value  和 data： currentValue。&lt;/p&gt;
&lt;p&gt;以上就是Vue标签页组件的所有实现过程。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 06:48:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/8277007.html</dc:identifier>
</item>
<item>
<title>让 MyBatis Generator 变的更简单 - 风的姿态</title>
<link>http://www.cnblogs.com/fengzheng/p/8296538.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengzheng/p/8296538.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;MyBatis 是一个 Java 的 ORM 框架，ORM 的出现就是为了简化开发。最初的开发方式是业务逻辑和数据库查询逻辑是分开的，或者在程序中编写 sql 语句，或者调用 sql 存储过程。这样导致思维需要在语言逻辑和 sql 逻辑之间切换，导致开发效率低下。所以出现了一系列的 ORM 框架，ORM 框架将数据库表和 Java 对象对应起来，当操作数据库时，只需要操作对象的 Java 对象即可，例如设置几个 and 条件，只需要设置几个属性即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么要有用-mybatis-generator&quot;&gt;为什么要有用 MyBatis Generator&lt;/h2&gt;
&lt;p&gt;虽然说有了 mybatis 框架，但是学习 mybatis 也需要学习成本，尤其是配置它需要的 XML 文件，那也是相当繁琐，而且配置中出现错误，不容易定位。当出现莫名其妙的错误或者有大批量需要生成的对象时，时常会有种生无可恋的感觉在脑中徘徊。故此， MyBatis Generator 应运而生了。&lt;/p&gt;
&lt;p&gt;它只需要简单配置，即可完成大量的表到 MyBatis Java 对象的生成工作，不仅速度快，而且不会出错，可让开发人员真正的专注于业务逻辑的开发。&lt;/p&gt;
&lt;p&gt;官方提供的 MyBatis Generator 功能比较简单，对于稍微复杂但是开发中必然用到的分页功能、批量插入功能等没有实现，但已经有成熟的插件功能支持。&lt;/p&gt;
&lt;p&gt;MyBatis Generator 生成的文件结构&lt;/p&gt;
&lt;p&gt;生成的文件包含三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Model 实体文件，一个数据库表生成一个 Model 实体；&lt;/li&gt;
&lt;li&gt;ModelExample 文件，此文件和实体文件在同一目录下，主要用于查询条件构造；&lt;/li&gt;
&lt;li&gt;Mapper 接口文件，数据数操作方法都在此接口中定义；&lt;/li&gt;
&lt;li&gt;Mapper XML 配置文件；&lt;br/&gt;在配置文件中配置好文件的生成路径，并设置好对应的包名，即可生成对应的目录结构和文件。我将生成目录设置为 test 目录，实体包名设置为 com.fengzheng.dao.entity ，接口包名设置为 com.fengzheng.dao.mapper ，然后生成的文件目录结构如下图所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/273364/201609/273364-20160921181308824-1997763174.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mybatis&lt;/code&gt; 官方提供了 MyBatis Generator ，可以通过 xml 配置文件的方式使用，例如自己写调用脚本，或者使用 mvn 插件的方式，其实实现起来还是很简单的。&lt;/p&gt;
&lt;h2 id=&quot;毕竟我们懒嘛&quot;&gt;毕竟我们懒嘛&lt;/h2&gt;
&lt;p&gt;虽然简单，但还是不够简单，懒嘛，这不就实现了一个更简单的生成方式，通过 web 页面的方式，填写几个关键的配置参数，选好要生成的数据库表即可。&lt;/p&gt;
&lt;h2 id=&quot;可配置的参数有如下几个&quot;&gt;可配置的参数有如下几个&lt;/h2&gt;
&lt;p&gt;targetRuntime ：MyBatis3、MyBatis3Simple、Ibatis2Java2、Ibatis2Java5，默认为 MyBatis3&lt;/p&gt;
&lt;p&gt;是否取消注释：生成的文件中默认会有注释内容，可以选择是否取消。&lt;/p&gt;
&lt;p&gt;targetProject（文件生成目录）：文件最后保存的目录，选择一个本地磁盘上的目录位置。&lt;/p&gt;
&lt;p&gt;实体类包名：实体对象的包名。&lt;/p&gt;
&lt;p&gt;mapper.xml文件所在目录：xml 文件所在的目录&lt;/p&gt;
&lt;p&gt;mapper接口类包名：mapper 接口类的包名&lt;/p&gt;
&lt;p&gt;数据库驱动：目前只支持 mysql&lt;/p&gt;
&lt;p&gt;数据库连接字符串、数据库用户、数据库用户密码：数据库相关配置&lt;/p&gt;
&lt;h2 id=&quot;启动方式&quot;&gt;启动方式&lt;/h2&gt;
&lt;h4 id=&quot;方式1&quot;&gt;方式1：&lt;/h4&gt;
&lt;p&gt;直接下载源码，然后运行 &lt;code&gt;BuilderApplication&lt;/code&gt; 文件，或者使用 mvn 的 &lt;code&gt;spring-boot:run&lt;/code&gt; 方式运行&lt;/p&gt;
&lt;h4 id=&quot;方式2&quot;&gt;方式2：&lt;/h4&gt;
&lt;p&gt;下载 &lt;a href=&quot;https://github.com/huzhicheng/kite-mybatis-builder/releases/download/v1.0/kite-mybats-builder.jar&quot;&gt;kite-mybatis-builder.jar&lt;/a&gt;, 运行命令 &lt;code&gt;java -jar -Dserver.port=[port] kite-mybatis-builder.jar&lt;/code&gt; 或者 &lt;code&gt;java -jar kite-mybatis-builder.jar&lt;/code&gt; 默认在 9090 端口运行&lt;/p&gt;
&lt;h2 id=&quot;使用方式&quot;&gt;使用方式&lt;/h2&gt;
&lt;p&gt;如果运行在默认的 9090 端口，打开浏览器访问 &lt;a href=&quot;http://localhost:9090&quot; class=&quot;uri&quot;&gt;http://localhost:9090&lt;/a&gt; 。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;默认打开之后，点击“新建项目”。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://hexo.moonkite.cn/mybatis/mybatis-1.png&quot; alt=&quot;mybatis-1&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在弹出的项目配置界面，填写上面提到的配置参数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://hexo.moonkite.cn/mybatis/mybatis-2.png&quot; alt=&quot;mybatis-2&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选择要生成的表，并可在后面配置实体名称，默认规则是各单词首字母大写。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://hexo.moonkite.cn/mybatis/mybatis-3.png&quot; alt=&quot;mybatis-3&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;点击生成按钮，会根据生成结果提示成功或失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;生成过的项目会在首页列出来，下次如果还需要生成此数据库的表，可以在之前的项目中重新配置选择即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://hexo.moonkite.cn/mybatis/mybatis-4.png&quot; alt=&quot;mybatis-4&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;默认已集成了分页&quot;&gt;默认已集成了分页&lt;/h2&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;支持分页查询&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        UserExample userExample = new UserExample();
        userExample.setLimit(5);
        userExample.setOffset(5);
        userExample.setOrderByClause(&quot; id desc &quot;);
        List&amp;lt;User&amp;gt; users = userMapper.selectByExample(userExample);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​**欢迎关注我的微信公众号&lt;br/&gt;&lt;img src=&quot;http://hexo.moonkite.cn/WeChat/wechat-qr.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;a href=&quot;https://github.com/huzhicheng/kite-mybatis-builder&quot;&gt;点此进入 github&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 06:39:00 +0000</pubDate>
<dc:creator>风的姿态</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengzheng/p/8296538.html</dc:identifier>
</item>
<item>
<title>开启 TLS 1.3 加密协议，极速 HTTPS 体验 - 又拍云</title>
<link>http://www.cnblogs.com/upyun/p/8296404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upyun/p/8296404.html</guid>
<description>&lt;p&gt;随着互联网的发展，用户对网络速度的要求也越来越高，尤其是目前在大力发展 HTTPS 的情况下，TLS 加密协议变得至关重要。又拍云在 HTTPS 的普及和性能优化上，始终做着自己的努力和贡献。2018年初，又拍云 CDN 网络部署了 TLS 1.3，进一步提升了用户的访问速度与安全。&lt;/p&gt;
&lt;h2&gt;什么是 TLS 1.3？&lt;/h2&gt;
&lt;p&gt;TLS 1.3 加密协议是在 TLS 1.0 、TLS 1.1 、TLS 1.2 之前版本基础上进行的升级和改造，也是迄今为止改动最大的一次，IETF 正在制定 TLS 1.3 的新标准，目前尚在草案阶段 ，可以参考&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//tools.ietf.org/html/draft-ietf-tls-tls13-23&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;最新草案&lt;/a&gt;。相比 TLS 1.2 ，TLS 1.3 的主要区别在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新的加密套件只能在 TLS 1.3 中使用，旧的加密套件不能用于 TLS 1.3 连接；&lt;/li&gt;
&lt;li&gt;添加了0-RTT 模式，在建立连接时节省了往返时间（以某些安全性为代价）；&lt;/li&gt;
&lt;li&gt;废除了静态的 RSA（ 不提供前向保密 ）密钥交换，基于公钥的密钥交换机制现在可提供前向保密；&lt;/li&gt;
&lt;li&gt;ServerHello 之后的所有握手消息采取了加密操作；&lt;/li&gt;
&lt;li&gt;TLS 1.2 版本的重协商握手机制已被弃用，TLS 1.3 中重新协商变为不可行了；&lt;/li&gt;
&lt;li&gt;相比过去的的版本，会话恢复在服务端是无状态的，使用了新的 PSK 交换；&lt;/li&gt;
&lt;li&gt;DSA 证书不再允许在 TLS 1.3 中使用；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上的这些改动，可以避免之前版本出现的缺陷，不仅如此，还可以减少 TLS 握手的时间。总结一下，TLS 1.3 与以前的版本相比具有如下两个大的优势，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更快的访问速度&lt;/li&gt;
&lt;li&gt;增强安全性&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;TLS 1.3 作用&lt;/h2&gt;
&lt;h2&gt;1. 更快的访问速度&lt;/h2&gt;
&lt;p&gt;为了对比 TLS 1.3 在 TLS 握手阶段的变化， 这里将 TLS 1.2 和 TLS 1.3 在 TLS 握手阶段进行对比。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/585973/201801/585973-20180116142036256-1419236820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;△ TLS 1.2 完整握手框架（ 来自&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc5246&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt; RFC 5246&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;从上图可以看出，使用 TLS 1.2 需要两次往返（ 2-RTT ）才能完成握手，然后才能发送请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/585973/201801/585973-20180116142055599-527635566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;△ TLS 1.3 完整握手框架（来自 TLS 1.3 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//tools.ietf.org/html/draft-ietf-tls-tls13-23&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;最新草案&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;TLS 1.3 的握手不再支持静态的 RSA 密钥交换，这意味着可以使用带有前向安全的 Diffie-Hellman 进行全面握手。从上图可以看出，使用 TLS 1.3 协议只需要一次往返（ 1-RTT ）就可以完成握手。&lt;/p&gt;
&lt;p&gt;相比 TLS 1.2 ，TLS 1.3 的握手时间会减半。这意味着访问一个移动端网站，使用 TLS1.3 协议，可能会减少将近 100ms 的时间。关于 1-RTT 最大的变化是消除了 ServerKeyExchange 和 ClientKeyExchange 消息，DH 参数和公钥现在以特殊的 key_share 扩展发送，这是一种新的扩展类型，将被包含在 Client Hello 和 Server Hello 消息中。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/50/v2-32f736b494a381dcf8237cb6628c08d2_hd.jpg&quot; alt=&quot;&quot; width=&quot;567&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;567&quot; data-rawheight=&quot;305&quot; data-original=&quot;https://pic3.zhimg.com/v2-32f736b494a381dcf8237cb6628c08d2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-32f736b494a381dcf8237cb6628c08d2_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;△ TLS 1.3 0-RTT 模式握手框架（ 来自 TLS 1.3 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//tools.ietf.org/html/draft-ietf-tls-tls13-23&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;最新草案&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;值得关注的是，TLS 1.3 草案中新增了&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=http%3A//swg.github.io/tls13-spec/%23zero-rtt-exchange&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;零 RTT （ 0-RTT ）模式&lt;/a&gt;，也即在上一次连接中，握手完成之后，服务端会发送一条 ServerConfiguration 消息，在随后的客户端发起第一个 TLS 记录 ClientHello 过程中，直接附加加密的应用程序数据，该模式将会导致更加快速的访问体验。&lt;/p&gt;
&lt;h2&gt;2. 增强的安全性&lt;/h2&gt;
&lt;p&gt;TLS 的发展有 20 多年的历史，在之前的版本中，TLS 1.2 是高度可配置的，为了更好的兼容旧版本的浏览器，这意味着那些易受攻击的站点始终在运行着不安全的加密算法，这让互联网黑客有可乘之机。TLS 1.3 在 之前版本的基础上删除了那些不安全的加密算法，这些加密算法包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RSA 密钥传输 —— 不支持前向安全性&lt;/li&gt;
&lt;li&gt;CBC 模式密码 —— 易受 BEAST 和 Lucky 13 攻击&lt;/li&gt;
&lt;li&gt;RC4 流密码 —— 在 HTTPS 中使用并不安全&lt;/li&gt;
&lt;li&gt;SHA-1 哈希函数 —— 建议以 SHA-2 取而代之&lt;/li&gt;
&lt;li&gt;任意 Diffie-Hellman 组—— CVE-2016-0701 漏洞&lt;/li&gt;
&lt;li&gt;输出密码 —— 易受 FREAK 和 LogJam 攻击&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TLS 1.3 目前支持以下加密套件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
TLS13-AES128-GCM-&lt;span&gt;SHA256
TLS13&lt;/span&gt;-AES256-GCM-&lt;span&gt;SHA384
TLS13&lt;/span&gt;-CHACHA20-POLY1305-&lt;span&gt;SHA256
TLS13&lt;/span&gt;-AES128-CCM-&lt;span&gt;SHA256
TLS13&lt;/span&gt;-AES128-CCM-&lt;span&gt;8&lt;/span&gt;-SHA256 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新的加密套件只能在 TLS 1.3 中使用，旧的套件不能用于 TLS 1.3 连接。总之，TLS 1.3 相比老版本的 TLS 协议将会更加安全，这也代表着互联网安全的一大进步。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;2018 年初，又拍云在 CDN 部分节点中部署了 TLS 1.3，作为国内较早支持 TLS 1.3 的 CDN 厂商，又拍云始终跟随时代的步伐，为互联网世界的安全与加速贡献着自己的一份力量。在互联网世界这个生态系统中，进行 TLS 安全协议的升级并不简单，这个需要客户端和服务端同时进行升级，并确保客户端和服务端的所有通信都是正常的。&lt;/p&gt;
&lt;h2&gt;一键开启 TLS 1.3&lt;/h2&gt;
&lt;h2&gt;1）在又拍云 CDN 平台启用 TLS 1.3&lt;/h2&gt;
&lt;p&gt;在 又拍云 CDN 控制台，针对 TLS 1.3 开放了切换开关，TLS 1.3 默认为关闭状态，您可以手动开启，如下图所示：&lt;/p&gt;

&lt;p&gt;值得声明的是， CDN 是否启用 TLS 1.3 ，这个取决于客户端浏览器是否支持，如果客户端并不支持 TLS 1.3 ，则会进行协议降级，仍会使用较低的 TLS 1.2 协议进行通信。&lt;/p&gt;
&lt;h2&gt;2）在浏览器中启用 TLS 1.3&lt;/h2&gt;
&lt;p&gt;目前最新版本的 Chrome 和 Firefox 都支持 TLS 1.3，但是都需要手动开启。&lt;/p&gt;
&lt;p&gt;在 Firefox 中手动启用 TLS 1.3&lt;/p&gt;
&lt;p&gt;Mozilla Firefox 用户可以通过以下方式在 Firefox 中启用 TLS 1.3 支持（ 请注意，Firfox &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.mozilla.org/zh-CN/firefox/channel/desktop/%23nightly&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Nightly&lt;/a&gt;版本默认支持 TLS 1.3，而 Firefox 稳定版（截至日前是 Firfox 57）需要专门配置以支持 TLS 1.3 ）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 Firefox 地址栏中输入 about:config。如果显示警告屏幕，请确认您要小心，可忽略安全提示；&lt;/li&gt;
&lt;li&gt;在搜索区域搜索 security.tls.version.max；&lt;/li&gt;
&lt;li&gt;通过双击它将首选项的值更改为 4（ 默认为 3 ）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Chrome 中手动启动 TLS 1.3&lt;/p&gt;
&lt;p&gt;Google Chrome 用户可以通过以下方式在 Chrome 中启用 TLS 1.3 支持（ 请注意，Chrome &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.google.com/chrome/browser/canary.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Canary&lt;/a&gt; 版本默认支持 TLS 1.3，而 Chrome 稳定版（截至日前是Chrome 64） 需要专门配置以支持 TLS 1.3 ）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在浏览器的地址栏中加载 chrome://flags/，这将打开 Web 浏览器的实验页面。&lt;/li&gt;
&lt;li&gt;在搜索区域搜索 TLS 或者 tls ，找到 TLS 1.3 选项，默认为 Default&lt;/li&gt;
&lt;li&gt;需要将 TLS 1.3 改为 Enabled (Draft)；&lt;/li&gt;
&lt;li&gt;重新启动 Web 浏览器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：Chrome 62 之前的版本需要将 Maximum TLS version enabled 改为 TLS 1.3。&lt;/p&gt;
&lt;h2&gt;验证服务端是否支持了 TLS 1.3&lt;/h2&gt;
&lt;p&gt;使用 Google Chrome 开发者工具，选择 Security 模块，如下图所示，当安全链接为 TLS 1.3 时，说明此次连接是使用 TLS 1.3 进行通信的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/585973/201801/585973-20180116142218787-379085907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上可以得知，浏览器以及服务端都支持 TLS 1.3 才可以使用 TLS 1.3 进行通信。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;TLS 1.3 是 Web 安全与性能的一大进步，虽然主流浏览器还未默认开启，但是这一天的到来不会太久，又拍云紧紧跟随时代的步伐，希望为互联网用户提供更安全、更快的加速体验，为推进互联网的发展贡献自己的力量。与此同时，我们也很高兴成为国内较早支持 TLS 1.3 功能的 CDN 厂商。&lt;/p&gt;

&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://tech.upyun.com/article/192/HTTPS%E7%B3%BB%E5%88%97%E5%B9%B2%E8%B4%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHTTPS%20%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3.html&quot; target=&quot;_blank&quot;&gt;HTTPS系列干货（一）：HTTPS 原理详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tech.upyun.com/article/242/%E4%BB%8E%20HTTP%20%E5%88%B0%20HTTPS%20%E5%86%8D%E5%88%B0%20HSTS.html&quot; target=&quot;_blank&quot;&gt;从 HTTP 到 HTTPS 再到 HSTS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Transport_Layer_Security&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;en.wikipedia.org/wiki/T&lt;span class=&quot;invisible&quot;&gt;ransport_Layer_Security&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.mitls.org/downloads/transcript-collisions.pdf&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;span class=&quot;visible&quot;&gt;mitls.org/downloads/tra&lt;span class=&quot;invisible&quot;&gt;nscript-collisions.pdf&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=http%3A//www.freebuf.com/vuls/95560.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;span class=&quot;visible&quot;&gt;freebuf.com/vuls/95560.&lt;span class=&quot;invisible&quot;&gt;html&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//tools.ietf.org/html/draft-ietf-tls-tls13-23&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;tools.ietf.org/html/dra&lt;span class=&quot;invisible&quot;&gt;ft-ietf-tls-tls13-23&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//tlswg.github.io/tls13-spec/%23zero-rtt-exchange&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;tlswg.github.io/tls13-s&lt;span class=&quot;invisible&quot;&gt;pec/#zero-rtt-exchange&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//blog.cloudflare.com/introducing-tls-1-3/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;blog.cloudflare.com/int&lt;span class=&quot;invisible&quot;&gt;roducing-tls-1-3/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.openssl.org/blog/blog/2017/05/04/tlsv1.3/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;span class=&quot;visible&quot;&gt;openssl.org/blog/blog/2&lt;span class=&quot;invisible&quot;&gt;017/05/04/tlsv1.3/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 06:21:00 +0000</pubDate>
<dc:creator>又拍云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upyun/p/8296404.html</dc:identifier>
</item>
<item>
<title>【vue系列之三】从一个vue-pdf-shower，说说vue组件和npm包 - TJYoung</title>
<link>http://www.cnblogs.com/tjyoung/p/8289141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tjyoung/p/8289141.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;从去年年初开始，自己便下决心要写一个vue系列的博客，但时至今日，才写系列的第三篇博客，想来甚是惭愧。&lt;/p&gt;
&lt;p&gt;但是慢归慢，每一篇都要保证质量，以及要写出自己的心路历程，防止自己工作中填的坑再让读者走一遍。&lt;/p&gt;
&lt;p&gt;vue上手相对react来说是比较简单的，对于vue的基本指令以及语法，应该没有什么能比官网更详细，更生动的了。仔细想来，vue值得一说的，在项目中会让新手感到困惑的，是vue的组件，今天就最近工作中用到的一个pdf查看组件，和大家聊聊vue的组件。最后会讲如何将自己的代码封装成一个npm包，发布到npm官网。&lt;/p&gt;
&lt;p&gt;去年5月份的，写了vue系列的第一篇&lt;a id=&quot;post_title_link_6832234&quot; href=&quot;http://www.cnblogs.com/tjyoung/p/6832234.html&quot;&gt;使用vue-cli脚手架工具搭建vue-webpack项目&lt;/a&gt;，今天再次使用vue-cli初始化项目时，发现vue-cli已经升级到2.9.2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/908144/201801/908144-20180116103913912-979620659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多说一句，因为vue-cli的命令为vue，所以查看vue-cli的版本时，需要使用vue -V，而且是大写的V。仔细看下vue-cli 2.9的官方模板，惊喜的发现多了一个pwa模板。&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/908144/201801/908144-20180116105833553-1623626205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;前一阵子，谷歌开发者大会在上海举办，会上主推pwa，在这在简单说下PWA，大神可直接忽略。&lt;/p&gt;
&lt;h3&gt;简述PWA&lt;/h3&gt;
&lt;p&gt; PWA是Progressive Web App的缩写，字面意思理解为渐进增强的网页应用。一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能。&lt;/p&gt;
&lt;p&gt;在一个正常的HTML中，添加一个link标签，href为manifest.json，即可将你的网页应用添加到主屏幕。&lt;/p&gt;
&lt;p&gt;manifest.json中会包含你的图标、名称。背景色等信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;name&quot;: &quot;你的web app名称&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;short_name&quot;: &quot;简称&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;display&quot;: &quot;standalone&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;start_url&quot;: &quot;/&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;theme_color&quot;: &quot;主体色（#ffffff）&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;background_color&quot;: &quot;背景色(#333333)&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;icons&quot;&lt;span&gt;: [
    {
      &lt;/span&gt;&quot;src&quot;: &quot;icon.png&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;sizes&quot;: &quot;256x256&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;type&quot;: &quot;image/png&quot;&lt;span&gt;
    }
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
引入manifest.json&lt;br/&gt;&amp;lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PWA应用能实现离线访问的核心是Service Worker，Service Worker 在网页已经关闭的情况下还可以运行, 用来实现页面的缓存和离线, 后台通知等等功能。&lt;/p&gt;
&lt;p&gt;为了让应用离线工作，需要注册一个 service worker，一段允许在后台运行的脚本，不需要 用户打开 web 页面，也不需要其他交互。在应用根目录放置serviceworker.js，然后在浏览器注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
if('serviceWorker' in navigator) { &lt;br/&gt;　　navigator.serviceWorker .register('/service-worker.js') &lt;br/&gt;　　.then(function() { console.log('Service Worker Registered'); &lt;br/&gt;}); }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在serviceworker注册后，浏览器首次访问该应用时，会执行install方法，这个方法的callback中我们能够缓存所有需要缓存的数据。具体过程为：&lt;br/&gt;首先定义需要缓存的文件类型，以及缓存存放路径；然后在网页相应所有请求之前，会将请求统一处理，可以控制一部分请求从缓存里拿数据。缓存会通过字符串名称，动态的更新。篇幅有限，这里大概简述下。具体可以移步&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25459319&quot; target=&quot;_blank&quot;&gt;饿了么团队知乎&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;vue组件vue-pdf-shower&lt;/h3&gt;
&lt;p&gt;下面言归正传，说说vue组件。&lt;/p&gt;
&lt;p&gt;最近笔者在项目中遇到一个pdf预览的需求，经过调研，最终决定用火狐的pdf.js封装一个vue组件。&lt;/p&gt;
&lt;p&gt;其实需求还是比较简单的，就是后台给一个URL，前端将pdf加载到网页中即可。chrome和Firefox是自带pdf查看器的，简单的做法是使用iframe嵌入，但该方案兼容性太差，而且不受我们控制，所以pass了。&lt;/p&gt;
&lt;h4&gt;总体思路如下：&lt;/h4&gt;
&lt;p&gt;1.通过pdf.js提供的api，我们传入pdf的URL，在callback中会拿到所需的pdf对象。&lt;/p&gt;
&lt;p&gt;2.通过传入不同的页码，可以拿到指定页面的page对象。&lt;/p&gt;
&lt;p&gt;3.通过canvas，将page对象渲染到页面中。&lt;/p&gt;
&lt;p&gt;4.遍历所有page，循环生成多个canvas对象，插入dom。&lt;/p&gt;
&lt;p&gt;把思路缕清楚之后，开发就比较简单了。&lt;/p&gt;
&lt;p&gt;首先，确定dom结构。由于我们的canvas是动态插入dom的，所以只提供一个wraper即可。&lt;/p&gt;
&lt;h4&gt;dom结构如下&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;pdf-wraper&quot;&amp;gt;
        &amp;lt;div id=&quot;cvsWraper&quot;&amp;gt;
            &amp;lt;div class=&quot;loading-pdf&quot; v-if=&quot;isloading&quot;&amp;gt;{{loadingTxt}}&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　&lt;/h4&gt;
&lt;h4&gt;vue-pdf-viewer组件js&lt;/h4&gt;
&lt;p&gt;该组件需要传两个参数，一个是URL，一个是缩放值scale。&lt;/p&gt;
&lt;p&gt;vue组件需要显式说明自身期望传入哪些属性，并且可以赋予默认值。调用组件时，传入不同的属性，可以实现父组件向子组件传值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
props: {
        pdfurl: {
            default: ''
        },
        scale: {
            default: 1
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;子组件向父组件传值&lt;/h4&gt;
&lt;p&gt;子组件向父组件通信时，需要使用vue.$emit事件。&lt;/p&gt;
&lt;p&gt;$emit事件接受两个参数，第一个为所要抛出的方法名，第二个为所抛出方法带的参数。&lt;/p&gt;
&lt;p&gt;在这个组件中，只暴露出一个onErr事件，即当pdf加载失败时的回调函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
PDFJS.getDocument(me.pdfurl).then(function (pafObj) {
            me.isloading = true;
            me.pdfDoc = pafObj;
            let totalNum = me.pdfDoc.numPages;

            // 循环渲染所有canvas
            for (let i = 1; i &amp;lt;= totalNum; i++) {
                let id = `canvas${i}`;
                let cvsNode = document.createElement('canvas');
                cvsNode.setAttribute('id', id);
                cvsNode.setAttribute('class', 'canvas-item');
                cvsWraper.appendChild(cvsNode);
                me.renderPage(i);

                if (totalNum === i) {
                    me.isloading = false;
                }
            }
        }).catch(function (err) {
            me.loadingTxt = '加载失败，请稍后重试';
           &lt;span&gt; me.$emit('onErr', err);&lt;/span&gt;
        });
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;调用组件&lt;/h3&gt;
&lt;p&gt;在调用组件时，需要传入所需的属性和方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
         &amp;lt;pdfshower 
            &lt;span&gt;:pdfurl=&quot;pdfurls&quot; 
            :scale=&quot;scale&quot; 
            @onErr=&quot;onErr&quot;&lt;/span&gt;
        &amp;gt;&amp;lt;/pdfshower&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;非父子组件通信&lt;/h3&gt;
&lt;p&gt;兄弟组件通信也是比较常见的，比如说在一个页面中，导航是一个组件，内容区域是一个组件；当导航切换时，需要通知内容组件发生变化，并告诉他导航的id。&lt;/p&gt;
&lt;p&gt;处理兄弟组件通信的问题，一般有两种方式：&lt;/p&gt;
&lt;p&gt;1.兄弟组件都引入一个公共vue组件hub，通过hub抛出事件，和监听事件，以达到兄弟组件通信。&lt;/p&gt;
&lt;p&gt;2.使用vuex。&lt;/p&gt;
&lt;p&gt;项目中比较常见的是第一种做法，我做的vue项目中只有一次使用到了vuex；我对vuex的理解是：&lt;/p&gt;
&lt;p&gt;vuex类似于一个全局的存储空间，你可以把他理解为将需要传递的东西绑在了window下，所以在任何地方都可以拿到，并做修改。&lt;/p&gt;
&lt;p&gt;在项目中用到的hub.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * @file 事件总线
 * @author yangtianjiao
/
import Vue from 'vue';
export default new Vue({});
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;假设是上面说的那种情况，在导航组件切换时，通过hub发射信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
hub.$emit('changeTableData', {
       dateKey: this.curDateTab
});
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;内容区域监听hub发射的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
hub.$on('changeTableData', item =&amp;gt; {
                this.pageNum = 1;
                this.total = 0;
                this.dataList = [];
                this.orderFieldId = 1;
                this.orderType = 1;
                this.contenctDesc = '';
                this.emptyText = '数据加载中...';
                this.isLoading = false;
            });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在内容组件销毁时，取消对hub事件的监听&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
beforeDestroy() {
        hub.$off('changeTableData');
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;兄弟组件通信并不复杂，但要深刻理解，必须在项目中多运用、实践。这块应该是vue最难的部分了，这块掌握了，vue项目做起来就会得心应手。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;发布npm包&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;大家平时工作中，最常用的是npm，很多包、类库都从npm安装。其实我们很容易就会发布属于自己的npm包，下面我会一步步讲讲如何将上述的vue-pdf-viewer组件发布到npm官网的。&lt;/p&gt;
&lt;h4&gt;1.执行npm init&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/908144/201801/908144-20180116132358568-887473833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行npm init后，根据命令行提示，依次输入&lt;/p&gt;
&lt;p&gt;包名称&lt;/p&gt;
&lt;p&gt;版本&lt;/p&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;入口文件&lt;/p&gt;
&lt;p&gt;测试脚本&lt;/p&gt;
&lt;p&gt;关键词&lt;/p&gt;
&lt;p&gt;作者&lt;/p&gt;
&lt;p&gt;版权信息（协议）&lt;/p&gt;
&lt;p&gt;等等，最后OK，生成一个package.json文件。&lt;/p&gt;
&lt;h4&gt;2.确定包的目录结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/908144/201801/908144-20180116132742881-1157781587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;package.json是npm帮我们生成的，根目录下有入口文件index.js，和readme.md。&lt;/p&gt;
&lt;p&gt;index.js中其实就是一句话，将真正的index.vue暴露出去&lt;/p&gt;
&lt;p&gt;&lt;span&gt;index.js&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * @file vue-pdf-shower
 * @author v_yangtianjiao(v_yangtianjiao@baidu.com)
 * @time 18/01/15
 */
module.exports = require('./lib/index.vue');
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;readme中放有对包的简述，以及包的基本用法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;readme.md&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
# vue-pdf-shower

## 介绍
&amp;gt; 基于pdf.js的pdf简易查看组件。
&amp;gt; 该组件加载全部pdf页面，不提供翻页查看功能。

## github
[vue-pdf-shower](https://github.com/TJ666/vue-pdf-shower)

## install
```
npm i vue-pdf-shower --save
```
## example
```
&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
         &amp;lt;pdfshower 
            :pdfurl=&quot;pdfurls&quot; 
            :scale=&quot;scale&quot; 
            @onErr=&quot;onErr&quot;
        &amp;gt;&amp;lt;/pdfshower&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import pdfshower from 'vue-pdf-shower';
export default {
    name: 'pdfshower',
    components: {
        pdfshower
    },
    data() {
        return {
            // 所查看的pdf url
            pdfurls: '//cdn.mozilla.net/pdfjs/tracemonkey.pdf',
            // 缩放 默认为1
            scale: 1.2
        };
    },
    methods: {
        // 加载失败的callback
        onErr(err) {
            console.log('pdf加载失败，请重试');
            console.log('错误信息：', err);
        }
    }
};
&amp;lt;/script&amp;gt;
```
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;至于为啥有个lib文件夹，还有目录结构为啥长这样？我的回答是：&lt;/p&gt;
&lt;p&gt;看了一遍所有的npm包都是这样，咱就按人家的来吧 - -&lt;/p&gt;
&lt;p&gt;好了，咱们的包已经准备就绪了，就差发布！！！&lt;/p&gt;
&lt;h3&gt;3.注册npm账号&amp;amp;发包&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/908144/201801/908144-20180116133618990-925162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开冰箱，将大象放进冰箱，关上冰箱门。&lt;/p&gt;
&lt;p&gt;注册很简单的，只需要一个邮箱就行，连网站都打不开的同学就好好写写jquery去吧。&lt;/p&gt;
&lt;h3&gt;4.npm login&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/908144/201801/908144-20180116134121834-1923769349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在命令行输入npm login，&lt;/p&gt;
&lt;p&gt;然后依次输入用户名和密码，以及注册的邮箱。&lt;/p&gt;
&lt;p&gt;注意：输入密码时，密码是不会显示出来的，不要方！&lt;/p&gt;
&lt;p&gt;登录后只要没有错误提示即登录成功。&lt;/p&gt;
&lt;h3&gt;5.npm publish发包&lt;/h3&gt;
&lt;p&gt;离成功只差一步。&lt;/p&gt;
&lt;p&gt;一切准备妥当，cd 到我们的vue-pdf-shower目录，先检查下npm有没有重名的包。&lt;/p&gt;
&lt;p&gt;可以去npm官网搜索，也可以直接npm install 包名，如果报错，那么恭喜你包名没有重复的。&lt;/p&gt;
&lt;p&gt;执行npm publish&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/908144/201801/908144-20180116134825240-780840861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定睛一看，报了个错。原来是package.json 的版本号没有改。将版本号升一个级，在执行publish。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/908144/201801/908144-20180116135113959-160684499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功！&lt;/p&gt;
&lt;h3&gt; 6.去npm官网检验发包情况&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/908144/201801/908144-20180116135301599-1076926711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现已经可以搜到，因为我是昨天发的包，一天时间内已有116次下载。嗯，还不赖。&lt;/p&gt;
&lt;p&gt;最后附上本组件github地址，欢迎大家拍砖。&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/TJ666/vue-pdf-shower&quot; target=&quot;_blank&quot;&gt;https://github.com/TJ666/vue-pdf-shower&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;PostIndex-title av-paddingSide av-titleFont&quot;&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25459319&quot; target=&quot;_blank&quot;&gt;PWA 入门: 写个非常简单的 PWA 页面&lt;/a&gt;&lt;/h4&gt;
&lt;h4 class=&quot;title&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/36d3e0e00157&quot; target=&quot;_blank&quot;&gt;手把手教你用npm发布一个包&lt;/a&gt;&lt;/h4&gt;

</description>
<pubDate>Tue, 16 Jan 2018 06:04:00 +0000</pubDate>
<dc:creator>TJYoung</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tjyoung/p/8289141.html</dc:identifier>
</item>
<item>
<title>AdaBoost入门 - ScorpioLu</title>
<link>http://www.cnblogs.com/ScorpioLu/p/8295990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ScorpioLu/p/8295990.html</guid>
<description>&lt;p&gt;&lt;span&gt;写一点自己理解的AdaBoost，然后再贴上面试过程中被问到的相关问题。按照以下目录展开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，也可以去&lt;a href=&quot;https://louisscorpio.github.io/2017/11/28/AdaBoost%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/&quot; target=&quot;_blank&quot;&gt;我的博客&lt;/a&gt;上看&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Boosting提升算法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AdaBoost&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;原理理解&lt;/li&gt;
&lt;li&gt;实例&lt;/li&gt;
&lt;li&gt;算法流程&lt;/li&gt;
&lt;li&gt;公式推导&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;面经&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span&gt;Boosting提升算法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;AdaBoost是典型的Boosting算法，属于Boosting家族的一员。在说AdaBoost之前，先说说Boosting提升算法。Boosting算法是将“弱学习算法“提升为“强学习算法”的过程，主要思想是“三个臭皮匠顶个诸葛亮”。一般来说，找到弱学习算法要相对容易一些，然后通过反复学习得到一系列弱分类器，组合这些弱分类器得到一个强分类器。Boosting算法要涉及到两个部分，加法模型和前向分步算法。加法模型就是说强分类器由一系列弱分类器线性相加而成。一般组合形式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$F_M(x;P)=\sum_{m=1}^nβ_mh(x;a_m)$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，$h(x;a_m)$ 就是一个个的弱分类器，$a_m$是弱分类器学习到的最优参数，$β_m$就是弱学习在强分类器中所占比重，$P$是所有$a_m$和$β_m$的组合。这些弱分类器线性相加组成强分类器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;前向分步就是说在训练过程中，下一轮迭代产生的分类器是在上一轮的基础上训练得来的。也就是可以写成这样的形式：&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;$$F_m (x)=F_{m-1}(x)+ β_mh_m (x;a_m)$$&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;由于采用的损失函数不同，Boosting算法也因此有了不同的类型，AdaBoost就是损失函数为指数损失的Boosting算法。&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;AdaBoost&quot;&gt;&lt;span&gt;AdaBoost&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;原理理解&quot;&gt;&lt;span&gt;原理理解&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;基于Boosting的理解，对于AdaBoost，我们要搞清楚两点：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot; has-jax&quot;&gt;&lt;span&gt;每一次迭代的弱学习$h(x;a_m)$有何不一样，如何学习？&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot; has-jax&quot;&gt;&lt;span&gt;弱分类器权值$β_m$如何确定？&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot; has-jax&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;对于第一个问题，AdaBoost改变了训练数据的权值，也就是样本的概率分布，其思想是将关注点放在被错误分类的样本上，减小上一轮被正确分类的样本权值，提高那些被错误分类的样本权值。然后，再根据所采用的一些基本机器学习算法进行学习，比如逻辑回归。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;对于第二个问题，AdaBoost采用加权多数表决的方法，加大分类误差率小的弱分类器的权重，减小分类误差率大的弱分类器的权重。这个很好理解，正确率高分得好的弱分类器在强分类器中当然应该有较大的发言权。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;实例&quot;&gt;&lt;span&gt;实例&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了加深理解，我们来举一个例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;有如下的训练样本，我们需要构建强分类器对其进行分类。x是特征，y是标签。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;序号&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;1&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;2&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;3&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;4&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;5&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;6&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;7&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;8&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;9&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;10&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;x&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;5&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;6&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;7&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;8&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;9&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;y&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p class=&quot; has-jax has-jax has-jax has-jax has-jax&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;令权值分布$D_1=(w_{1,1},w_{1,2},…,w_{1,10} )$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并假设一开始的权值分布是均匀分布：$w_{1,i}=0.1，i=1,2,…,10$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在开始训练第一个弱分类器。我们发现阈值取2.5时分类误差率最低，得到弱分类器为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1312719/201801/1312719-20180116131724287-765372178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，也可以用别的弱分类器，只要误差率最低即可。这里为了方便，用了分段函数。得到了分类误差率$e_1=0.3$。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步计算$(G_1 (x)$在强分类器中的系数$α_1=\frac{1}{2} log\frac{ 1-e_1}{e_1}=0.4236$，这个公式先放在这里，下面再做推导。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步更新样本的权值分布，用于下一轮迭代训练。由公式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$w_{2,i}=\frac{w_{1,i}}{z_1}exp⁡(-α_1 y_i G_1 (x_i ))，i=1,2,…,10$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得到新的权值分布，从各0.1变成了:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$D_2=(0.0715,0.0715,0.0715,0.0715,0.0715,0.0715,0.1666,0.1666,0.1666,0.0715)$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看出，被分类正确的样本权值减小了，被错误分类的样本权值提高了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步得到第一轮迭代的强分类器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$sign(F_1 (x))=sign(0.4236G_1 (x))$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以此类推，经过第二轮……第N轮，迭代多次直至得到最终的强分类器。迭代范围可以自己定义，比如限定收敛阈值，分类误差率小于某一个值就停止迭代，比如限定迭代次数，迭代1000次停止。这里数据简单，在第3轮迭代时，得到强分类器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$sign(F_3 (x))=sign(0.4236G_1 (x)+0.6496G_2 (x)+0.7514G_3 (x))$$&lt;/span&gt;&lt;br/&gt;&lt;span&gt;的分类误差率为0，结束迭代。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$F(x)=sign(F_3 (x))$就是最终的强分类器。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;算法流程&quot;&gt;&lt;span&gt;算法流程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;总结一下，得到AdaBoost的算法流程：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot; has-jax has-jax has-jax has-jax&quot;&gt;&lt;span&gt;输入：训练数据集$T=\{(x_1,y_1),(x_2,y_2),(x_N,y_N)\}$，其中，$x_i∈X⊆R^n$，$y_i∈Y={-1,1}$，迭代次数$M$&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot; has-jax&quot;&gt;&lt;span&gt;1.　初始化训练样本的权值分布：$D_1=(w_{1,1},w_{1,2},…,w_{1,i}),w_{1,i}=\frac{1}{N},i=1,2,…,N$。&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot; has-jax&quot;&gt;&lt;span&gt;2.　对于$m=1,2,…,M$&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot; has-jax has-jax&quot;&gt;&lt;span&gt;　　(a)　使用具有权值分布$D_m$的训练数据集进行学习，得到弱分类器$G_m (x)$&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot; has-jax has-jax&quot;&gt;&lt;span&gt;　　(b)　计算$G_m(x)$在训练数据集上的分类误差率：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot; has-jax has-jax&quot;&gt;&lt;span&gt;$$e_m=\sum_{i=1}^Nw_{m,i}  I(G_m (x_i )≠y_i )$$&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot; has-jax has-jax&quot;&gt;&lt;span&gt;　　(c)　计算$G_m (x)$在强分类器中所占的权重：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot; has-jax has-jax&quot;&gt;&lt;span&gt;$$α_m=\frac{1}{2}log \frac{1-e_m}{e_m} $$&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot; has-jax has-jax has-jax&quot;&gt;&lt;span&gt;　　(d)　更新训练数据集的权值分布（这里，$z_m$是归一化因子，为了使样本的概率分布和为1）：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot; has-jax has-jax has-jax&quot;&gt;&lt;span&gt;$$w_{m+1,i}=\frac{w_{m,i}}{z_m}exp⁡(-α_m y_i G_m (x_i ))，i=1,2,…,10$$&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot; has-jax has-jax has-jax&quot;&gt;&lt;span&gt;$$z_m=\sum_{i=1}^Nw_{m,i}exp⁡(-α_m y_i G_m (x_i ))$$&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot; has-jax&quot;&gt;&lt;span&gt;3.    得到最终分类器：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot; has-jax&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;$$F(x)=sign(\sum_{i=1}^Nα_m G_m (x))$$&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;公式推导&quot;&gt;&lt;span&gt;公式推导&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;现在我们来搞清楚上述公式是怎么来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设已经经过$m-1$轮迭代，得到$F_{m-1} (x)$，根据前向分步，我们可以得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$F_m (x)=F_{m-1} (x)+α_m G_m (x)$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们已经知道AdaBoost是采用指数损失，由此可以得到损失函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$Loss=\sum_{i=1}^Nexp⁡(-y_i F_m (x_i ))=\sum_{i=1}^Nexp⁡(-y_i (F_{m-1} (x_i )+α_m G_m (x_i )))$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时候，$F_{m-1}(x)$是已知的，可以作为常量移到前面去:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$Loss=\sum_{i=1}^N\widetilde{w_{m,i}} exp⁡(-y_i α_m G_m (x_i ))$$&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其中，$\widetilde{w_{m,i}}=exp⁡(-y_i (F_{m-1} (x)))$ ，敲黑板！这个就是每轮迭代的样本权重！依赖于前一轮的迭代重分配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是不是觉得还不够像？那就再化简一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\widetilde{w_{m,i}}=exp⁡(-y_i (F_{m-1} (x_i )+α_{m-1} G_{m-1} (x_i )))=\widetilde{w_{m-1,i}} exp⁡(-y_i α_{m-1} G_{m-1} (x_i ))$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在够像了吧？ok，我们继续化简Loss：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$Loss=\sum_{y_i=G_m(x_i)}\widetilde{w_{m,i}} exp(-α_m)+\sum_{y_i≠G_m(x_i)}\widetilde{w_{m,i}} exp⁡(α_m)$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$=\sum_{i=1}^N\widetilde{w_{m,i}}(\frac{\sum_{y_i=G_m(x_i)}\widetilde{w_{m,i}}}{\sum_{i=1}^N\widetilde{w_{m,i}}}exp(-α_m)+\frac{\sum_{y_i≠G_m(x_i)}\widetilde{w_{m,i}}}{\sum_{i=1}^N\widetilde{w_{m,i}}}exp(α_m))$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;公式变形之后，炒鸡激动！$\frac{\sum_{y_i≠G_m(x_i)}\widetilde{w_{m,i}}}{\sum_{i=1}^N\widetilde{w_{m,i}}}$这个不就是分类误差率$e_m$吗？？？！重写一下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$Loss=\sum_{i=1}^N\widetilde{w_{m,i}}exp⁡(-α_m)+e_m exp⁡(α_m))$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ok，这样我们就得到了化简之后的损失函数。接下来就是求导了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对$α_m$求偏导，令$\frac{∂Loss}{∂α_m }=0$得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$α_m=\frac{1}{2}log\frac{1-e_m}{e_m} $$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;真漂亮！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，AdaBoost的代码实战与详解请戳&lt;a href=&quot;https://louisscorpio.github.io/2017/11/28/%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98%E4%B9%8BAdaBoost/&quot; target=&quot;_blank&quot;&gt;代码实战之AdaBoost&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;

&lt;h2 id=&quot;面经&quot;&gt;&lt;span&gt;面经&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;今年8月开始找工作，参加大厂面试问到的相关问题有如下几点：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;手推AdaBoost&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;与GBDT比较&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AdaBoost几种基本机器学习算法哪个抗噪能力最强，哪个对重采样不敏感？&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;作者 &lt;a href=&quot;https://louisscorpio.github.io/&quot; target=&quot;_blank&quot;&gt;Scorpio.Lu&lt;/a&gt;&lt;br/&gt;转载请注明出处！&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 05:54:00 +0000</pubDate>
<dc:creator>ScorpioLu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ScorpioLu/p/8295990.html</dc:identifier>
</item>
<item>
<title>Core Animation 文档翻译 （第二篇） - 开机按钮</title>
<link>http://www.cnblogs.com/zhouyubo/p/8287613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouyubo/p/8287613.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Co&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;re Animation&lt;/strong&gt; 文档翻译 （第二篇）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;核心动画基础要素&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;核心动画为我们APP内Views动画和其他可视化元素动画提供了综合性的实现体系。核心动画不是我们APP内Views的替代品，相反，它是一种结合Views来提供更好性能和支持Content动画的技术。它通过将Views的Content缓存进可以被绘图软件直接操作处理的Bitmaps来达到这种高性能。在某些情况下，这种缓存技术可能需要我们重新思考我们将要如何呈现和管理我们的APP的Content,但是大多数情况我们可以在不去考虑这种缓存带来的影响而直接使用核心动画。除了缓存View 的Content之外,核心动画也定义了一种制定任意可视化Content,使我们的Views与可视化Content结合起来，并使该可视化Content和其他事物一起动画。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;我们使用核心动画让我们APP内Views和可视化对象特性的变更以动画的形式过渡。许多可视化对象的变更和修改可视化对象的属性有关联，例如，我们可能使用核心动画来为View的position、size、opacity的改变制作动画。当我们调整了类似的属性，核心动画将会制作在当前属性值和我们指定的新值之间过渡的动画。我们尤其不应该使用核心动画以60次每秒的频率替换View的Content，例如不应该使用核心动画以这种方式制作卡通片。相反，我们使用核心动画从屏幕上移除View的Content,渐隐渐出Content,任意调整Views的图形transformation，或者改变View的其他可视化属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Layers 提供绘画和动画的主要部分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;Layer 对象是2D平面，并被组织到3D空间；核心动画能做的所有事情的核心也是Layer。和Views一样，Layers管理他们各自的几何、Content和其他可视化属性。和Views不一样的是，Layers没有定义显示表面。一个Layer仅仅管理一个bitmap相关的状态信息；这个bitmap他本身可能是一个View的绘制结果或者我们制定的固定的图片，因为Layers主要管理data，因此APP中我们使用的大部分Layers被视为模型对象。这个概念很重要，需要记住，因为它影响动画的行为&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基于 Layer的绘制模型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;APP中许多Layers没有做任何实际绘制。相反，一个Layer捕获我们APP提供的Content并将他们缓存进一个bitmap中，这个bitmap有时候被称作辅助存储。当我们接着改变Layer的属性，所有我们做的便是改变Layer对象相关联的状态信息。当一个改变出发一个动画，核心动画将Layer的bitmap和状态信息传递给绘图硬件，绘图硬件使用这些新的信息渲染bitmap，Figure 1-1图显示的流程。在硬件中操作处理bitmap将会产生更快的动画，相较于使用软件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;                                                                     &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;&lt;span&gt; &lt;span&gt;Figure 1-1  How Core Animation draws content&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180116134453490-1371498421.png&quot; alt=&quot;&quot; width=&quot;653&quot; height=&quot;203&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为他操作处理一个静态bitmap，基于Layer的绘制明显不同于传统的基于View的绘制技术。在基于View的绘制中，View的变化通常会调用该View的drawRect:方法 来使用新的参数绘制Content；但是这种方式的绘制的消耗是很高的，因为他是使用CPU在主线程上完成的。核心动画通过一种流程避免这种高昂的消耗--当能够通过操作处理硬件内缓存的bitmap达到相同或相似的效应时候。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽管核心动画尽可能的使用缓存的Content，我们的APP仍旧提供这个初始化的Content和不时的更新Content。APP中有几个方法为通过Content提供Layer对象，在&lt;span class=&quot;content_text&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/SettingUpLayerObjects/SettingUpLayerObjects.html#//apple_ref/doc/uid/TP40004514-CH13-SW4&quot; data-renderer-version=&quot;1&quot;&gt;Providing a Layer’s Contents&lt;/a&gt;（后续有翻译）中有详细描述。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;span class=&quot;content_text&quot;&gt;基于Layer的动画&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Layer对象的数据和状态信息与屏幕上Layer的Content的可视化展现之间是解耦的。这种解耦使得核心动画处于Layer对象与屏幕上可视化的展现之间，并能够使这个从旧状态值到新状态值的过渡显示为动画。例如，改变一个Layer的position属性会引起Layer从它当前position移动到新指定的position。其他属性的相似变更也会引起相应的动画。Figure 1-2展现了几个我们能够在Layers上执行的动画种类。Layer可以触发动画的属性，可以参见&lt;span class=&quot;content_text&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/AnimatableProperties/AnimatableProperties.html#//apple_ref/doc/uid/TP40004514-CH11-SW1&quot; data-renderer-version=&quot;1&quot;&gt;Animatable Properties&lt;/a&gt;。（后续会有翻译）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content_text&quot;&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;                                                             &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;content_text&quot;&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;  &lt;span&gt;Figure 1-2  Examples of animations you can perform on layers&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180116134707084-869348826.png&quot; alt=&quot;&quot; width=&quot;519&quot; height=&quot;351&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在动画的过程期间，核心动画在硬件中做了所有的逐帧绘制。所有我们应该做的仅仅是制定动画的开始和结束点，并开启核心动画，核心动画将会做剩下的工作。我们也能制定自定义的必要的timing信息和动画参数；然而，如果我们没有设定相应的默认值，核心动画将会提供适当的默认值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多信息关于如何去开启动画和配置动画参数参见&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/CreatingBasicAnimations/CreatingBasicAnimations.html#//apple_ref/doc/uid/TP40004514-CH3-SW1&quot; data-renderer-version=&quot;1&quot;&gt;Animating Layer Content&lt;/a&gt;。（后续会有翻译）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Layer 对象定义他们的几何形状&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Layer的功能之一就为Layer自身的Content管理可视化几何形状。可视化几何形状所包含的信息：Content在屏幕上的bounds和position和该Layer是否通过任何途径被旋转、缩放、transformed。就像一个View，一个Layer也有frame和bounds属性以用于调整该Layer和Content的位置。Layers也有其他和View也有的属性，例如anchor point（锚点），可以围绕锚点制作动画的点。我们指定一些Layer的几何方面值与指定View相应的值是有区别的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Layers 使用两种坐标系统&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Layers 利用基于点的坐标系统和单元坐标系统指定Content的位置。具体使用哪种坐标系统取决于被传递的信息类型。当指定映射到屏幕坐标值和被关联到另外的Layer时候，这两种情况将会使用基于点的坐标，例如Layer的position 属性。当某些值不应该被绑定到屏幕坐标系统时候（因为它是关联一些其他值的）会使用到单元坐标系统。例如，Layer的anchorPoint属性是指定和Layer本身的bounds相关联的点，bounds会变，就会影响单元坐标系统内anchorPoint。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于点坐标系统最普遍的用途就是指定Layer的size 和position，其实就是指我们使用Layer的bounds和position属性。bounds 定义Layer本身内部坐标系统并包含Layer在屏幕上的size。position属性定义了Layer在它父坐标系统上的位置。尽管Layers有frame属性，frame属性实际上是从bounds和position属性得到的，Layer的frame不常用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Layer的bounds和frame的方向总是和所在的平台默认方向匹配的。Figure 1-3展示了iOS和OS X两个平台的默认方向。在iOS里面，原点的位置默认是左上角，在OS X平台默认是左下角。如果我们在两个平台之间分享核心动画的代码，我们必须考虑两者的不同之处。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;                                                       &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;  &lt;span&gt;Figure 1-3  The default layer geometries for iOS and OS X&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180116134819865-698252674.png&quot; alt=&quot;&quot; width=&quot;486&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在图1-3中有件事情需要注意：position属性是Layer的中心点。有几个属性的值是基于Layer的anchorPoint属性，position就是其中之一。anchor point 代表了特定坐标系统的起点，锚点被描述的更详细在文档&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/CoreAnimationBasics/CoreAnimationBasics.html#//apple_ref/doc/uid/TP40004514-CH2-SW17&quot; data-renderer-version=&quot;1&quot;&gt;Anchor Points Affect Geometric Manipulations&lt;/a&gt;。（后续会有翻译）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有几个属性的值是我们使用单元坐标系统指定的，anchor point 就是其中之一。核心动画使用单元坐标系统代表属性值，这些属性值可能会发生变化当Layer的size改变的时候。我们可以把单元坐标视为一个整体值的百分比（例如宽度被设定为为100，锚点是50%）。在单元坐标内，每个坐标值的变化范围是0.0到1.0。例如沿着X轴，左边缘是0.0，右边缘是1.0。沿着Y轴单元坐标的值的变化和所在平台有关，如图1-4所展示。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;Figure 1-4  The default unit coordinate systems for iOS and OS X&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;caption_number&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180115220328537-1463590754.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;204&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;直到OS X 10.8，当有需要时，geometryFlipped属性能够调整一个Layer的Y轴方向。当涉及到反转transforms调整时，通过使用这个属性来矫正Layer的方向是很有必要的。例如如果父View使用一个反转transform调整时，子Views的contents（和他们相应的Layers）将会被反转。在这些情况下，设置子Layers的geometryFlipped属性为YES是能够改正问题的一个简单的方式。在OS X 10.8和之后，AppKit 管理这些属性并且我们不应该修改他。对于iOS APPs,完全不建议使用geometryFlipped属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有的坐标值，无论点坐标还是单元坐标，它们都是浮点型数值，使用浮点型使我们能够指定精细的位置，这些位置可能在标准坐标值之间。浮点值的使用很便利，尤其在印刷或者当会知道Retina屏幕时候，Retina屏幕的一个点可能代表多个像素。浮点值允许我们忽略基于设备的分辨率，可直接调整到某个我们想要的精确值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Anchor Point 影响几何图形操作处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Layer的几何相关操作都受到Layer的anchor point的影响，即Layer的anchorPoint属性。当调整position或transform属性的时候，anchor point的影响会很明显。position 属性总是和Layer的anchor point关联在一起的；对Layer做的transformations调整也总是和anchor point 关联着的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1-5所描述了——Layer的anchor point 从默认值到一个新值的调整是如何影响position属性的。anchor point从Layer的中心点移动到Layer的origin，改变了Layer的position属性，但是Layer在他父Layer的bounds内坐标没有发生变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;span&gt;　&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;Figure 1-5  How the anchor point affects the layer’s position property&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180115223214709-529890600.png&quot; alt=&quot;&quot; width=&quot;580&quot; height=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;图1-6展现了anchor point的改变是如何影响Layer的transforms变换的。当我们对Layer做旋转transform调整时候，旋转将会绕着anchor point发生。由于anchor point默认在Layer的中心位置，正常的旋转调整将会是围绕Layer的中心发生；如果我们改变anchor point，旋转的结果将会发生变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;Figure 1-6  How the anchor point affects layer transformations&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;caption_number&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180115224236756-298396499.png&quot; alt=&quot;&quot; width=&quot;591&quot; height=&quot;576&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Layer 的三维空间操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;每一个Layer有两个transform 矩阵，我们可以使用这两个矩阵来操作处理Layer的contents。Layer的transform属性指定的变换将会被应用到Layer本身和内嵌的sublayers。通常我们想使用这个属性来调整Layer本身，例如，我们可能使用transform属性来缩放或旋转某个Layer，或者临时调整Layer的position。sublayerTransform属性定义的变换仅仅用来调整Layer的sublayers，在某些场景中它也通常备用来添加人眼视角效应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Transforms 通过矩阵变换改变当前坐标值得到新的坐标值(coordinate)，新的坐标值代表着转换后的坐标值。由于核心动画可以指定三维空间变换，在矩阵变换中，每一个点对应着一个4x4的矩阵。如图1-7.在核心动画中transform代表着CATransform3D类型。幸运的是，我们不需要直接修改这个4x4的矩阵来执行标准的转换；核心动画提供一个全面的函数集合，包含操作有scale,translation,rotation矩阵以及矩阵的比较。除了使用函数操作矩阵之外，核心动画也扩展了KVC，以便于支持我们使用key paths修改transform。可以通过key paths修改的列表参见&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW1&quot; data-renderer-version=&quot;1&quot;&gt;CATransform3D Key Paths&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;Figure 1-7  Converting a coordinate using matrix math&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;caption_number&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180115231340271-150943548.png&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;144&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;caption_number&quot;&gt;图1-8展现了常见的transformations的矩阵配置。任何乘以identity矩阵的coordinate将不会变化，当乘以其他矩阵时，coordinate的变化和矩阵每个分量都有关。例如，沿着X轴平移，我们需要提供非零的 tx 分量并让 ty 和 tz 为0。对于旋转操作，我们应该提供合适的 sine 和 cosine 值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;Figure 1-8  Matrix configurations for common transformations&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;caption_number&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180115232817803-672310015.png&quot; alt=&quot;&quot; width=&quot;316&quot; height=&quot;346&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;关于可用的函数信息和矩阵操作，可以参见&lt;em&gt;Core Animation Function Reference。&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;图层（layer）树反应动画状态的不同方面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用核心动画的APP有三种Layer对象集合；在将content显示到屏幕上的任务中，每个Layer对象集合扮演者不同的角色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·模型树（model layer tree 也被简称为图层树）是和APP交互最多的。模型树上面的模型对象保存着动画的目标值。无论何时我们要改变一个Layer的属性时，我们应该使用model对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·呈现树（presentation tree）包含着正在动画过程中的值。无论在哪里模型树总包含动画的目标值（最终值），而渲染树反映屏幕上显示的当前值。我们永远都不要修改呈现树上的对象，而可以借助呈现对象来读取当前动画的值，还可以将该值作为一个新的动画的起点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·渲染树（render tree）内包含的对象执行真正的动画，并且它是核心动画私有的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一个集合内的Layer对象都想APP内的Views一样是以层级结构组织起来的。事实上，一个为所有Views内嵌Layers的APP中，每个（图层）树的结构和View的层级结构是一直的。然而，APP可以添加单独的Layer对象（单独的Layer对象是指的没有被关联到view的层次中的），通过这么做我们可以优化APP的content方面的性能，因为某些content的显示是不需要使用Views的其他功能的。图1-9展示了Layer层次的分解图。在这个例子中window包含一个content View，这个View包含了一个button View和两个单独的Layer对象。每一个View包含一个对应的Layer对象，这个Layer对象用于形成Layer层结构的一部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;Figure 1-9  Layers associated with a window&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180116001920162-167171225.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如图1-10所示，每一个图层树上的对象都有一个对应的对象在渲染树和呈现树上。和之前提到的一样，APP开发中主要使用图层树中的对象，但是有时可以需要获取渲染树上的对象。尤其是，通过图层树内Layer对象的presentationLayer属性可以获取对应的呈现树上的对象，我们可以通过获取这个对象读取当前动画过程中某个属性的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;caption_number&quot;&gt;                          &lt;span&gt;Figure 1-10  The layer trees for a window&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180116002756646-1274774456.png&quot; alt=&quot;&quot; width=&quot;575&quot; height=&quot;389&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;重要提醒：&lt;/strong&gt;&lt;/span&gt;我们应该仅仅在动画执行过程中获取呈现树上的对象。当一个动画还在执行过程中，渲染树包含Layer在屏幕上那一瞬间显示的值。这个值是不同于模型树的，模型树只会反映动画终点状态的值。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;strong&gt;&lt;span&gt;Layers和Views 之间的关系&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Layers不是APP中Views的替代品，也就是说我们不能创建一个仅仅基于Layer对象的可视化界面。Layers为View提供关键基础。尤其是，Layers让它绘制Views的Content和给Views的ContentView更高效以及更方便，并且能够维持高帧率。然而，有许多事情是Layer是无法做到的，Layers无法处理事件、绘制content、参与响应者链条以及好多其他事情。出于这些原因，每个APP必须有一个或更多Views去处理这些交互。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在iOS中，每个Views默认被嵌入一个对应的Layer对象，但是在OS X中我们必须自己指定哪些Views应该内建Layer。在OS X v10.8和之后，给所有Views添加Layer才有意义，然而我们我们没必要这么做，当不是必须及指定layer这种消耗没有保证的时候我们仍旧可以禁止为Views的Layers添加。Layers确实增加APP的内存，但是Layers带来的优点多余缺点，因此在禁止Layer的支持前最好先测试下APP的性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们开启某个View的Layer支持时，就创建了一个被置为layer-backed view。在layer-backed view中，系统是有责任创建该View附属的Layer并同时将创建的Layer与View对应保存。所有的iOS中的Views都是layer-backed ，大部分OS X中的View也是一样的。然而，OS X中，我们也创建Layer-hosting view,这种View需要我们自己创建一个Layer，对于这中View,AppKit具有管理他的方式并且在View改变时候不调整它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提示：对于layer-backed views而言，无论何时，都推荐操作View而不是操作他的Layer。在iOS中View仅仅是一个Layer对象的简单包装，因此操作处理Layer通常更好。但是,有些时候在iOS和OS X中直接操作Layer可能不会产生预期的效果。此核心动画编程指南将会指出这些陷阱并提供避免他们的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了和Views关联的Layers外，我们也可以创建一个没有对应View的Layer对象。我们将的Layer对象嵌入到其他Layer对象里，例如嵌入到和View关联的Layer里。我们尤其可以使用单独的Layer作为特殊优化的一部分，例如，如果我们想要使用同样的图片在许多地方，我们可以加载这个图片一次，并使它和许多单独的Layer对象关联，并将这些Layer对象添加到图层树上，每一个Layer于是就引用这个图片资源而不是尝试去再次创建该图片并拷贝到内存中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于如何开启Layer的支持，参见&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/SettingUpLayerObjects/SettingUpLayerObjects.html#//apple_ref/doc/uid/TP40004514-CH13-SW5&quot; data-renderer-version=&quot;1&quot;&gt;Enabling Core Animation Support in Your App&lt;/a&gt;。关于如何创建一个Layer对象层次和合适应该创建一个对象层次的建议参见&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/BuildingaLayerHierarchy/BuildingaLayerHierarchy.html#//apple_ref/doc/uid/TP40004514-CH6-SW2&quot; data-renderer-version=&quot;1&quot;&gt;Building a Layer Hierarchy&lt;/a&gt;（后续会有译文）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：后续我将会有新的翻译更新，觉得不错的朋友可以暂等下&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 16 Jan 2018 05:42:00 +0000</pubDate>
<dc:creator>开机按钮</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouyubo/p/8287613.html</dc:identifier>
</item>
<item>
<title>微信小程序——获取openid - 任心飞翔</title>
<link>http://www.cnblogs.com/Chenzhifeng/p/8296132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Chenzhifeng/p/8296132.html</guid>
<description>&lt;p&gt;1.在微信小程序后台得到appid、AppSecret&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1229959/201801/1229959-20180116132727256-87464383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.在任意小程序界面的【onLoad】中取得code（建议将代码写在index.js中）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1229959/201801/1229959-20180116135849271-591699662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.用取得code换取openid&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1229959/201801/1229959-20180116140528474-1799990752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如后台无法将openid换取给你，可找我拿php方法进行换取。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如有其他不懂可加扣扣  &lt;span&gt;654405510  &lt;/span&gt;进行交流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/Chenzhifeng/p/8296007.html&quot; target=&quot;_blank&quot;&gt;获取微信小程序openGid方法&lt;/a&gt;已加密，付费阅读&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/Chenzhifeng/p/8296399.html&quot; target=&quot;_blank&quot;&gt;获取微信小程序formid方法&lt;/a&gt;已加密，付费阅读&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jan 2018 05:38:00 +0000</pubDate>
<dc:creator>任心飞翔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Chenzhifeng/p/8296132.html</dc:identifier>
</item>
</channel>
</rss>