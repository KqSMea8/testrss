<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JavaScript对象的valueOf()方法 - weiqinl</title>
<link>http://www.cnblogs.com/weiqinl/p/8380060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiqinl/p/8380060.html</guid>
<description>&lt;p&gt;js对象中的&lt;code&gt;valueOf()&lt;/code&gt;方法和&lt;code&gt;toString()&lt;/code&gt;方法非常类似，但是，当需要返回对象的原始值而非字符串的时候才调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript就会自动调用&lt;code&gt;valueOf()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;valueOf()&lt;/code&gt;方法是&lt;code&gt;Object&lt;/code&gt;的原型方法，每个对象都具有该方法，但是各对象返回的值有一定的区别。我们一起来看看。&lt;/p&gt;
&lt;h2 id=&quot;object.prototype.valueof&quot;&gt;Object.prototype.valueOf()&lt;/h2&gt;
&lt;p&gt;JavaScript调用&lt;code&gt;valueOf()&lt;/code&gt;方法将对象转换为原始值。你很少需要自己调用&lt;code&gt;valueOf()&lt;/code&gt;方法；&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;valueOf()&lt;/code&gt;方法由Object后面的每个对象继承。每个内置的核心对象都会覆盖此方法以放回适当的值。&lt;br/&gt;如果对象没有原始值，则&lt;code&gt;valueOf()&lt;/code&gt;将返回对象本身。&lt;/p&gt;
&lt;p&gt;你可以在自己的代码中使用&lt;code&gt;valueOf()&lt;/code&gt;将内置对象转换为原始值。创建自定义对象时，可以覆盖&lt;code&gt;Object.prototype.valueOf()&lt;/code&gt;来调用自定义方法，而不是默认&lt;code&gt;Object&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3 id=&quot;覆盖自定义对象的valueof方法&quot;&gt;覆盖自定义对象的&lt;code&gt;valueOf()&lt;/code&gt;方法&lt;/h3&gt;
&lt;p&gt;你可以创建一个取代&lt;code&gt;valueOf()&lt;/code&gt;方法的函数，你的方法必须不能传入参数。&lt;br/&gt;假设你有个对象叫&lt;code&gt;MyNumberType&lt;/code&gt;而你想为它创建一个&lt;code&gt;valueOf()&lt;/code&gt;方法。下面的代码为&lt;code&gt;valueOf()&lt;/code&gt;方法赋予了一个自定义函数:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MyNumberType.prototype.valueOf = function() { return customPrimitiveValue; };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这样的一个方法，下一次每当&lt;code&gt;MyNumberType&lt;/code&gt;要被转换为原始类型值时，JavaScript在此之前会自动调用自定义的&lt;code&gt;valueOf()&lt;/code&gt;方法。&lt;br/&gt;&lt;code&gt;valueOf()&lt;/code&gt;方法一般都会被JavaScript自动调用，但你也可以像下面代码那样自己调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;myNumberType.valueOf()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;string.prototype.valueof&quot;&gt;String.prototype.valueOf()&lt;/h2&gt;
&lt;p&gt;语法：&lt;code&gt;strObj.valueOf()&lt;/code&gt;&lt;br/&gt;返回值：表示给定&lt;code&gt;String&lt;/code&gt;对象的原始值&lt;br/&gt;说明：&lt;code&gt;valueOf()&lt;/code&gt;方法返回一个&lt;code&gt;String&lt;/code&gt;对象的原始值，该值等同于&lt;code&gt;String.prototype.toString()&lt;/code&gt;。&lt;br/&gt;该方法通常在JavaScript内部被调用，而不是在代码里显示调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let x = new String('Hello world')
console.log(x.valueOf())   // Hello world&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/564792/201801/564792-20180129235451546-2056772811.png&quot; alt=&quot;String.prototype.valueOf()&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;date.prototype.valueof&quot;&gt;Date.prototype.valueOf()&lt;/h2&gt;
&lt;p&gt;语法：&lt;code&gt;dataObj.valueOf()&lt;/code&gt;&lt;br/&gt;返回值：表示给定&lt;code&gt;Date&lt;/code&gt;对象的原始值&lt;br/&gt;说明：&lt;code&gt;valueOf()&lt;/code&gt;方法返回以数值格式表示的一个&lt;code&gt;Date&lt;/code&gt;对象的原始值。该值从1970年1月1日0时0分0秒（UTC，即协调世界时）到该日期对象所代表时间的毫秒数。&lt;br/&gt;该方法的功能和&lt;code&gt;Date.prototype.getTime()&lt;/code&gt;方法一样。&lt;br/&gt;该方法通常在JavaScript内部调用，而不是在代码中显示调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var x = new Date(2018, 1, 12)
var myVar = x.valueOf()
console.log(myVar) // 1518364800000&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;number.prototype.valueof&quot;&gt;Number.prototype.valueOf()&lt;/h2&gt;
&lt;p&gt;语法： &lt;code&gt;numObj.valueOf()&lt;/code&gt;&lt;br/&gt;返回值：表示给定&lt;code&gt;Number&lt;/code&gt;对象的原始值。&lt;br/&gt;说明：该方法通常在JavaScript内部调用，而不是在代码中显示调用。覆盖&lt;code&gt;Object.prototype.valueOf()&lt;/code&gt;方法&lt;br/&gt;案例：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/564792/201801/564792-20180129235430343-552143799.png&quot; alt=&quot;Number.prototype.valueOf()&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;boolean.prototype.valueof&quot;&gt;Boolean.prototype.valueOf()&lt;/h2&gt;
&lt;p&gt;语法：&lt;code&gt;bool.valueOf()&lt;/code&gt;&lt;br/&gt;返回值： 返回给定&lt;code&gt;Boolean&lt;/code&gt;对象的原始值&lt;br/&gt;说明： &lt;code&gt;Boolean&lt;/code&gt;的&lt;code&gt;valueOf()&lt;/code&gt;方法返回一个&lt;code&gt;Boolean&lt;/code&gt;字面量的原始值作为布尔数据类型。该方法通常在JavaScript内部调用，而不是在代码中显示调用。&lt;br/&gt;案例：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/564792/201801/564792-20180129235413140-100092005.png&quot; alt=&quot;Boolean.prototype.valueOf()&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;symbol.prototype.valueof&quot;&gt;Symbol.prototype.valueOf()&lt;/h2&gt;
&lt;p&gt;语法： &lt;code&gt;Symbol().valueOf()&lt;/code&gt;&lt;br/&gt;返回值：返回给定&lt;code&gt;Symbol&lt;/code&gt;对象的原始值&lt;br/&gt;说明：&lt;code&gt;Symbol&lt;/code&gt;的&lt;code&gt;valueOf()&lt;/code&gt;方法返回&lt;code&gt;Symbol&lt;/code&gt;对象的原始值作为&lt;code&gt;Symbol&lt;/code&gt;数据类型。JavaScript调用&lt;code&gt;valueOf()&lt;/code&gt;方法将对象转换为原始值。你很少需要自己调用&lt;code&gt;valueOf()&lt;/code&gt;方法。当遇到期望有原始值的对象时，JavaScript会自动调用它。&lt;br/&gt;案例：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/564792/201801/564792-20180129235355750-1139685875.png&quot; alt=&quot;Symbol.prototype.valueOf()&quot;/&gt;&lt;br/&gt;[完]&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jan 2018 15:57:00 +0000</pubDate>
<dc:creator>weiqinl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weiqinl/p/8380060.html</dc:identifier>
</item>
<item>
<title>dubbo源码—service reply - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/8379902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/8379902.html</guid>
<description>&lt;p&gt;dubbo通过netty将请求发送到provider的时候，provider之前已经启动好的NettyServer监听指定端口的时候会收到来自consumer的请求，将通过网络发送来的二进制编码成Request交给上层处理。dubbo从Request中取出调用信息，找到之前的Invoker，然后经过filter，最后通过代理调用到提供服务的方法。&lt;/p&gt;
&lt;p&gt;provider处理请求的调用堆栈如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;sayHe110:&lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;TestDubb0Servicelmpl&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;test&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;service&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;impl&lt;/span&gt;) 
invokeMethod:-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;Wrapper1&lt;/span&gt; (com. alibabadubbo. common.&lt;span class=&quot;fu&quot;&gt;bytecode&lt;/span&gt;) 
dolnvoke:&lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt;, JavassistProxyFactory$&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;proxy&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;javassist&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;72&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;AbstractProxylnvoker&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;proxy&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;53&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;InvokerWrapper&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt;, ExceptionFilter .&lt;span class=&quot;fu&quot;&gt;com&lt;/span&gt; alibaba.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt; filter) 
invoke:&lt;span class=&quot;dv&quot;&gt;91&lt;/span&gt;, ProtocolFilterWrapper$&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt;, MonitorFilter .&lt;span class=&quot;fu&quot;&gt;com&lt;/span&gt; alibaba.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;. monitor.&lt;span class=&quot;fu&quot;&gt;support&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;91&lt;/span&gt;, ProtocolFilterWrapper$&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;42&lt;/span&gt;, TimeoutFilter .&lt;span class=&quot;fu&quot;&gt;com&lt;/span&gt; alibaba.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;. rpc.&lt;span class=&quot;fu&quot;&gt;filter&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;91&lt;/span&gt;, ProtocolFilterWrapper$&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;49&lt;/span&gt;, TokenFilter .&lt;span class=&quot;fu&quot;&gt;com&lt;/span&gt; alibaba.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;. roc. filter) 
invoke:&lt;span class=&quot;dv&quot;&gt;91&lt;/span&gt;, ProtocolFilterWrapper$&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;78&lt;/span&gt;, TraceFilter .&lt;span class=&quot;fu&quot;&gt;com&lt;/span&gt; alibaba dubbo. roc. protocol.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;filter&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;91&lt;/span&gt;, ProtocolFilterWrapper$&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;, ContextFilter .&lt;span class=&quot;fu&quot;&gt;com&lt;/span&gt; alibaba.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;. roc. filter) 
invoke:&lt;span class=&quot;dv&quot;&gt;91&lt;/span&gt;, ProtocolFilterWrapper$&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;132&lt;/span&gt;, GenericFilter .&lt;span class=&quot;fu&quot;&gt;com&lt;/span&gt; alibaba.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;. roc. filter) 
invoke:&lt;span class=&quot;dv&quot;&gt;91&lt;/span&gt;, ProtocolFilterWrapper$&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;38&lt;/span&gt;, ClassLoaderFilter .&lt;span class=&quot;fu&quot;&gt;com&lt;/span&gt; alibaba dubbo.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;filter&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;91&lt;/span&gt;, ProtocolFilterWrapper$&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt;) 
invoke:&lt;span class=&quot;dv&quot;&gt;38&lt;/span&gt;, EchoFilter .&lt;span class=&quot;fu&quot;&gt;com&lt;/span&gt; alibaba dubbo. rpc filter) 
invoke:&lt;span class=&quot;dv&quot;&gt;91&lt;/span&gt;, ProtocolFilterWrapper$&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt;) 
reply:&lt;span class=&quot;dv&quot;&gt;108&lt;/span&gt;, DubboProtocol$&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; .&lt;span class=&quot;fu&quot;&gt;com&lt;/span&gt; alibaba dubbo.&lt;span class=&quot;fu&quot;&gt;rpcprotocol&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;) 
handleRequest:&lt;span class=&quot;dv&quot;&gt;86&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;HeaderExchangeHandler&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;remoting&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;exchange&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;support&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;header&lt;/span&gt;) 
received:&lt;span class=&quot;dv&quot;&gt;172&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;HeaderExchangeHandler&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt; dubbo. remoting. exchange.&lt;span class=&quot;fu&quot;&gt;support&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;header&lt;/span&gt;) 
received:&lt;span class=&quot;dv&quot;&gt;52&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;DecodeHandler&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt; dubbo.&lt;span class=&quot;fu&quot;&gt;remoting&lt;/span&gt;. transport) 
run:&lt;span class=&quot;dv&quot;&gt;82&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;ChannelEventRunnable&lt;/span&gt; (com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;remoting&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;transport&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dispatcher&lt;/span&gt;) 
runWorker:&lt;span class=&quot;dv&quot;&gt;1142&lt;/span&gt;, ThreadPoolExecutor (java.&lt;span class=&quot;fu&quot;&gt;util&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;concurrent&lt;/span&gt;) 
run:&lt;span class=&quot;dv&quot;&gt;617&lt;/span&gt;, ThreadPoolExecutor$&lt;span class=&quot;fu&quot;&gt;Worker&lt;/span&gt; (java.&lt;span class=&quot;fu&quot;&gt;util&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;concurrent&lt;/span&gt;) 
run:&lt;span class=&quot;dv&quot;&gt;745&lt;/span&gt;, Thread (java.&lt;span class=&quot;fu&quot;&gt;lang&lt;/span&gt;) &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从调用堆栈基本可以看出provider整个处理请求的过程，比较简单，但是需要知道为什么调用过程是这样的？其中关键类是什么时候在初始化的？怎么初始化的？&lt;/p&gt;
&lt;p&gt;接下来解决一下问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为什么是从ChannelEventRunnable开始的？谁初始化的ChannelEventRunnable？ChannelEventRunnable作用是什么？&lt;/li&gt;
&lt;li&gt;为什么会调用到上面堆栈中的几个handler（也就是handler是怎么初始化的）?&lt;/li&gt;
&lt;li&gt;filter链怎么初始化的？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本来这些问题在export的时候如果仔细查看源码已经可以解决了，但是真正用到的时候是处理请求的时候，所以这里算是补上之前export过程的一些关键步骤。&lt;/p&gt;
&lt;h3 id=&quot;channeleventrunnable初始化&quot;&gt;ChannelEventRunnable初始化&lt;/h3&gt;
&lt;p&gt;上面的调用堆栈中，是在线程池中一个单独的线程来处理请求，所以先从线程池中调用的线程开始，ChannelEventRunnable的构造过程。&lt;/p&gt;
&lt;p&gt;接着前面provider export的时候会启动NettyServer，所以ChannelEventRunnable的创建也从NettyServer的启动说起，ChannelEventRunnable被初始化的过程会涉及到netty的部分内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;NettyServer#doOpen，NettyServer启动的时候会创建NioServerSocketChannelFactory，该factory负责创建netty放入所有channel&lt;/li&gt;
&lt;li&gt;在NioServerSocketChannelFactory构造方法中会初始化NioWorkerPool，在该类的构造方法中创建NioWorker&lt;/li&gt;
&lt;li&gt;在创建NioWorker的过程中，调用超类AbstractNioSelector的构造方法&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// NioWorker构造方法中会调用超类AbstractNioSelector的构造方法&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;AbstractNioSelector&lt;/span&gt;(Executor executor, ThreadNameDeterminer determiner) {
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;executor&lt;/span&gt; = executor;
  &lt;span class=&quot;fu&quot;&gt;openSelector&lt;/span&gt;(determiner);
}

&lt;span class=&quot;co&quot;&gt;// org.jboss.netty.channel.socket.nio.AbstractNioSelector#openSelector&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;openSelector&lt;/span&gt;(ThreadNameDeterminer determiner) {
  &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;co&quot;&gt;// open selector&lt;/span&gt;
    selector = SelectorUtil.&lt;span class=&quot;fu&quot;&gt;open&lt;/span&gt;();
  } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable t) {
    &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ChannelException&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Failed to create a selector.&quot;&lt;/span&gt;, t);
  }

  &lt;span class=&quot;co&quot;&gt;// Start the worker thread with the new Selector.&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; success = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
  &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;co&quot;&gt;// new一个thread，将当前初始化的NioWorker作为入参，也就是说最终要运行的是NioWorker.run&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 这个start方法里面会将新建的这个线程放到线程池中运行&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 这里的executor就是new NioServerSocketChannelFactory时候的入参worker，也就是worker线程池&lt;/span&gt;
    DeadLockProofWorker.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;(executor, &lt;span class=&quot;fu&quot;&gt;newThreadRenamingRunnable&lt;/span&gt;(id, determiner));
    success = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
  } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
    &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
  }
  assert selector != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; selector.&lt;span class=&quot;fu&quot;&gt;isOpen&lt;/span&gt;();
}

&lt;span class=&quot;co&quot;&gt;// org.jboss.netty.channel.socket.nio.AbstractNioWorker#newThreadRenamingRunnable&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; ThreadRenamingRunnable &lt;span class=&quot;fu&quot;&gt;newThreadRenamingRunnable&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; id, ThreadNameDeterminer determiner) {
  &lt;span class=&quot;co&quot;&gt;// 这里的this就是初始化的NioWorker&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ThreadRenamingRunnable&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;New I/O worker #&quot;&lt;/span&gt; + id, determiner);
}

&lt;span class=&quot;co&quot;&gt;// org.jboss.netty.channel.socket.nio.NioWorker#run&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
  &lt;span class=&quot;co&quot;&gt;// 上面DeadLockProofWorker.start里面启动的线程会调用这个run方法&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 这里调用了超类的run方法，最终会调用到org.jboss.netty.channel.socket.nio.AbstractNioSelector#run&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// AbstractNioSelector#run&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;();
  recvBufferPool.&lt;span class=&quot;fu&quot;&gt;releaseExternalResources&lt;/span&gt;();
}

&lt;span class=&quot;co&quot;&gt;// AbstractNioSelector#run&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 这个方法是NioWorker真正处理逻辑的地方，死循环调用select接受IO事件，然后处理&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
  thread = Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;();

  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; selectReturnsImmediately = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
  Selector selector = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;selector&lt;/span&gt;;

  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (selector == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
  }
  &lt;span class=&quot;co&quot;&gt;// use 80% of the timeout for measure&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; minSelectTimeout = SelectorUtil.&lt;span class=&quot;fu&quot;&gt;SELECT_TIMEOUT_NANOS&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;;
  &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; wakenupFromLoop = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (;;) {
    wakenUp.&lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);

    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; beforeSelect = System.&lt;span class=&quot;fu&quot;&gt;nanoTime&lt;/span&gt;();
      &lt;span class=&quot;co&quot;&gt;// 监听I/O事件发生&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; selected = &lt;span class=&quot;fu&quot;&gt;select&lt;/span&gt;(selector);
   
      &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
      
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (shutdown) {
        &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
      } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;// 处理I/O事件&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;process&lt;/span&gt;(selector);
      }
    } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable t) {
      &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来到初始化ChannelEventRunnable的调用堆栈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/846961/201801/846961-20180129230056843-996543725.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;终于到了ChannelEventRunnable开始初始化的地方，所有的ChannelEventRunnable都是在AllChannelHandler中完成初始化，并加入到线程池中执行，下面以收到connect事件为例&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;connected&lt;/span&gt;(Channel channel) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; RemotingException {
  ExecutorService cexecutor = &lt;span class=&quot;fu&quot;&gt;getExecutorService&lt;/span&gt;(); 
  &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;{
    &lt;span class=&quot;co&quot;&gt;// 初始化ChannelEventRunnable并将其加入线程池&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 这里的线程池是com.alibaba.dubbo.common.threadpool.ThreadPool这个扩展，默认配置的是&quot;fixed&quot;，也就是FixedThreadPool&lt;/span&gt;
    cexecutor.&lt;span class=&quot;fu&quot;&gt;execute&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ChannelEventRunnable&lt;/span&gt;(channel, handler ,ChannelState.&lt;span class=&quot;fu&quot;&gt;CONNECTED&lt;/span&gt;));
  }&lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable t) {
    &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ExecutionException(&lt;span class=&quot;st&quot;&gt;&quot;connect event&quot;&lt;/span&gt;, channel, &lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;()+&lt;span class=&quot;st&quot;&gt;&quot; error when process connected event .&quot;&lt;/span&gt; , t);
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;处理请求&quot;&gt;处理请求&lt;/h3&gt;
&lt;p&gt;上面最终启动了ChannelEventRunnable线程，在这个线程中会最终调用到我们的SayHello方法中，这个类负责分类处理各种接收到的I/O事件&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;28&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// com.alibaba.dubbo.remoting.transport.dispatcher.ChannelEventRunnable#run&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
  &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; (state) {
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; CONNECTED:
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;{
        &lt;span class=&quot;co&quot;&gt;// 接收到连接&lt;/span&gt;
        handler.&lt;span class=&quot;fu&quot;&gt;connected&lt;/span&gt;(channel);
      }&lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
        logger.&lt;span class=&quot;fu&quot;&gt;warn&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ChannelEventRunnable handle &quot;&lt;/span&gt; + state + &lt;span class=&quot;st&quot;&gt;&quot; operation error, channel is &quot;&lt;/span&gt; + channel, e);
      }
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; DISCONNECTED:
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;{
        &lt;span class=&quot;co&quot;&gt;// 连接断开&lt;/span&gt;
        handler.&lt;span class=&quot;fu&quot;&gt;disconnected&lt;/span&gt;(channel);
      }&lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
        logger.&lt;span class=&quot;fu&quot;&gt;warn&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ChannelEventRunnable handle &quot;&lt;/span&gt; + state + &lt;span class=&quot;st&quot;&gt;&quot; operation error, channel is &quot;&lt;/span&gt; + channel, e);
      }
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; SENT:
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;{
        &lt;span class=&quot;co&quot;&gt;// 发送数据&lt;/span&gt;
        handler.&lt;span class=&quot;fu&quot;&gt;sent&lt;/span&gt;(channel,message);
      }&lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
        logger.&lt;span class=&quot;fu&quot;&gt;warn&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ChannelEventRunnable handle &quot;&lt;/span&gt; + state + &lt;span class=&quot;st&quot;&gt;&quot; operation error, channel is &quot;&lt;/span&gt; + channel
                    + &lt;span class=&quot;st&quot;&gt;&quot;, message is &quot;&lt;/span&gt;+ message,e);
      }
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; RECEIVED:
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;{
        &lt;span class=&quot;co&quot;&gt;// 收到数据&lt;/span&gt;
        handler.&lt;span class=&quot;fu&quot;&gt;received&lt;/span&gt;(channel, message);
      }&lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
        logger.&lt;span class=&quot;fu&quot;&gt;warn&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ChannelEventRunnable handle &quot;&lt;/span&gt; + state + &lt;span class=&quot;st&quot;&gt;&quot; operation error, channel is &quot;&lt;/span&gt; + channel
                    + &lt;span class=&quot;st&quot;&gt;&quot;, message is &quot;&lt;/span&gt;+ message,e);
      }
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; CAUGHT:
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;{
        &lt;span class=&quot;co&quot;&gt;// 处理异常&lt;/span&gt;
        handler.&lt;span class=&quot;fu&quot;&gt;caught&lt;/span&gt;(channel, exception);
      }&lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
        logger.&lt;span class=&quot;fu&quot;&gt;warn&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ChannelEventRunnable handle &quot;&lt;/span&gt; + state + &lt;span class=&quot;st&quot;&gt;&quot; operation error, channel is &quot;&lt;/span&gt;+ channel
                    + &lt;span class=&quot;st&quot;&gt;&quot;, message is: &quot;&lt;/span&gt; + message + &lt;span class=&quot;st&quot;&gt;&quot;, exception is &quot;&lt;/span&gt; + exception,e);
      }
      &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:
      logger.&lt;span class=&quot;fu&quot;&gt;warn&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;unknown state: &quot;&lt;/span&gt; + state + &lt;span class=&quot;st&quot;&gt;&quot;, message is &quot;&lt;/span&gt; + message);
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面通过调用handler的相关方法来处理的，接下来看看handler是什么？&lt;/p&gt;
&lt;h3 id=&quot;handler初始化&quot;&gt;handler初始化&lt;/h3&gt;
&lt;p&gt;从最上面的调用堆栈里面有这些handler&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;remoting&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;transport&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DecodeHandler&lt;/span&gt;#DecodeHandler
com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;remoting&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;exchange&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;support&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;header&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;HeaderExchangeHandler&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 最上面调用堆栈中com alibaba dubbo.rpcprotocol.dubbo.DubboProtocol$1.reply其实就是线面这个接口的实现类&lt;/span&gt;
com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;remoting&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;exchange&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ExchangeHandler&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之前在dubbo export中说过启动NettyServer的调用堆栈，但是并没有详细看每一个调用方法，这里把相关重要的方法拿出来&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol#requestHandler&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ExchangeHandler requestHandler = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ExchangeHandlerAdapter&lt;/span&gt;() {
  &lt;span class=&quot;co&quot;&gt;// 这些请求received、connected、disconnected最终都会调用下面这个方法处理&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;reply&lt;/span&gt;(ExchangeChannel channel, Object message) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; RemotingException {
    &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
  }
  &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
}

&lt;span class=&quot;co&quot;&gt;// com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol#createServer&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ExchangeServer &lt;span class=&quot;fu&quot;&gt;createServer&lt;/span&gt;(URL url) {
  &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 这里的handler就是上面初始化的，是一个匿名内部类，也就是com.alibaba.dubbo.remoting.exchange.ExchangeHandler的实现类&lt;/span&gt;
  server = Exchangers.&lt;span class=&quot;fu&quot;&gt;bind&lt;/span&gt;(url, requestHandler);
  &lt;span class=&quot;co&quot;&gt;// 省略中间代码...&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; server;
}

&lt;span class=&quot;co&quot;&gt;// com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchanger#bind&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ExchangeServer &lt;span class=&quot;fu&quot;&gt;bind&lt;/span&gt;(URL url, ExchangeHandler handler) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; RemotingException {
  &lt;span class=&quot;co&quot;&gt;// 这里的handler就是上面bind方法传入的requestHandler&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 所以这里就是初始化DecodeHandler和HeaderExchangeHandler的地方，也就说传入Transporters.bind方法的是DecodeHandler类型&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;HeaderExchangeServer&lt;/span&gt;(Transporters.&lt;span class=&quot;fu&quot;&gt;bind&lt;/span&gt;(url, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DecodeHandler&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;HeaderExchangeHandler&lt;/span&gt;(handler))));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;channeleventrunnable中的handler是什么类型&quot;&gt;ChannelEventRunnable中的handler是什么类型？&lt;/h3&gt;
&lt;p&gt;从最上面的堆栈已经知道这个handler其实就是DecodeHandler，也就是初始化ChannelEventRunnable的时候传入的handler，接下来需要弄清楚的是为什么是DecodeHandler。&lt;/p&gt;
&lt;p&gt;上面刚说过ChannelEventRunnable的初始化是由AllChannelHandler中的某一个方法初始化的，那么作为构造参数传入ChannelEventRunnable的handler也就是WrappedChannelHandler#handler（这个类是AllChannelHandler的超类），现在要找到AllChannelHandler是怎么初始化的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// com.alibaba.dubbo.remoting.transport.netty.NettyServer#NettyServer&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 上面说handler的初始化的时候，Transporters.bind方法会最终调用NettyServer的构造方法&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;NettyServer&lt;/span&gt;(URL url, ChannelHandler handler) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; RemotingException{
  &lt;span class=&quot;co&quot;&gt;// 这里的handler就是DecodeHandler&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(url, ChannelHandlers.&lt;span class=&quot;fu&quot;&gt;wrap&lt;/span&gt;(handler, ExecutorUtil.&lt;span class=&quot;fu&quot;&gt;setThreadName&lt;/span&gt;(url, SERVER_THREAD_POOL_NAME)));
}

&lt;span class=&quot;co&quot;&gt;// com.alibaba.dubbo.remoting.transport.dispatcher.ChannelHandlers#wrap&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ChannelHandler &lt;span class=&quot;fu&quot;&gt;wrap&lt;/span&gt;(ChannelHandler handler, URL url){
  &lt;span class=&quot;co&quot;&gt;// 这里的handler是DecodeHandler&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ChannelHandlers.&lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;wrapInternal&lt;/span&gt;(handler, url);
}

&lt;span class=&quot;co&quot;&gt;// com.alibaba.dubbo.remoting.transport.dispatcher.ChannelHandlers#wrapInternal&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; ChannelHandler &lt;span class=&quot;fu&quot;&gt;wrapInternal&lt;/span&gt;(ChannelHandler handler, URL url) {
  &lt;span class=&quot;co&quot;&gt;// 这里的handler是DecodeHandler&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 先获取Dispatcher的扩展类，默认是com.alibaba.dubbo.remoting.transport.dispatcher.all.AllDispatcher&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 然后调用AllDispatcher.dispatch方法&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MultiMessageHandler&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;HeartbeatHandler&lt;/span&gt;(ExtensionLoader.&lt;span class=&quot;fu&quot;&gt;getExtensionLoader&lt;/span&gt;(Dispatcher.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;)
                                                      .&lt;span class=&quot;fu&quot;&gt;getAdaptiveExtension&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;dispatch&lt;/span&gt;(handler, url)));
}

&lt;span class=&quot;co&quot;&gt;// com.alibaba.dubbo.remoting.transport.dispatcher.all.AllDispatcher#dispatch&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ChannelHandler &lt;span class=&quot;fu&quot;&gt;dispatch&lt;/span&gt;(ChannelHandler handler, URL url) {
  &lt;span class=&quot;co&quot;&gt;// 这里的handler是DecodeHandler，所以AllChannelHandler的超类WrappedChannelHandler#handler就是DecodeHandler&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;AllChannelHandler&lt;/span&gt;(handler, url);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是ChannelEventRunnable中的handler就是HeaderExchanger#bind方法中new出来的DecodeHandler类型的对象&lt;/p&gt;
&lt;h3 id=&quot;filter链构造&quot;&gt;filter链构造&lt;/h3&gt;
&lt;p&gt;filter链的构造本来也是在provider export服务的时候完成的，同理consumer端是在refer服务的时候完成filter链的构造。&lt;/p&gt;
&lt;p&gt;consumer和provider的filter链都是在下面的类中构造的，查看前面的service_export和service_reference的调用堆栈就可以看到对该类的调用。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProtocolFilterWrapper &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Protocol {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Protocol protocol;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProtocolFilterWrapper&lt;/span&gt;(Protocol protocol){
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (protocol == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;protocol == null&quot;&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt; = protocol;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getDefaultPort&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; protocol.&lt;span class=&quot;fu&quot;&gt;getDefaultPort&lt;/span&gt;();
    }

    &lt;span class=&quot;co&quot;&gt;// service export的时候调用 &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; Exporter&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;export&lt;/span&gt;(Invoker&amp;lt;T&amp;gt; invoker) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; RpcException {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (Constants.&lt;span class=&quot;fu&quot;&gt;REGISTRY_PROTOCOL&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(invoker.&lt;span class=&quot;fu&quot;&gt;getUrl&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getProtocol&lt;/span&gt;())) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; protocol.&lt;span class=&quot;fu&quot;&gt;export&lt;/span&gt;(invoker);
        }
        &lt;span class=&quot;co&quot;&gt;// 先构造filter链再继续后面的export&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; protocol.&lt;span class=&quot;fu&quot;&gt;export&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;buildInvokerChain&lt;/span&gt;(invoker, Constants.&lt;span class=&quot;fu&quot;&gt;SERVICE_FILTER_KEY&lt;/span&gt;, Constants.&lt;span class=&quot;fu&quot;&gt;PROVIDER&lt;/span&gt;));
    }

    &lt;span class=&quot;co&quot;&gt;// consumer refer的还是调用&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;refer&lt;/span&gt;(Class&amp;lt;T&amp;gt; type, URL url) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; RpcException {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (Constants.&lt;span class=&quot;fu&quot;&gt;REGISTRY_PROTOCOL&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(url.&lt;span class=&quot;fu&quot;&gt;getProtocol&lt;/span&gt;())) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; protocol.&lt;span class=&quot;fu&quot;&gt;refer&lt;/span&gt;(type, url);
        }
        &lt;span class=&quot;co&quot;&gt;// 这里是先refer调用创建DubboInvoker，然后才构造filter链，因为consumer是先经过filter链，再经过DubboInvoker处理，而provider是先经过DubboProtocol处理，然后调用filter链&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;buildInvokerChain&lt;/span&gt;(protocol.&lt;span class=&quot;fu&quot;&gt;refer&lt;/span&gt;(type, url), Constants.&lt;span class=&quot;fu&quot;&gt;REFERENCE_FILTER_KEY&lt;/span&gt;, Constants.&lt;span class=&quot;fu&quot;&gt;CONSUMER&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;destroy&lt;/span&gt;() {
        protocol.&lt;span class=&quot;fu&quot;&gt;destroy&lt;/span&gt;();
    }

    &lt;span class=&quot;co&quot;&gt;// &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;buildInvokerChain&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Invoker&amp;lt;T&amp;gt; invoker, String key, String group) {
        Invoker&amp;lt;T&amp;gt; last = invoker;
        &lt;span class=&quot;co&quot;&gt;// 获取所有符合条件的filter扩展，条件包括&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 1. filter扩展类上面group对应的值和要求的group(入参)一致&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 2. url中也可以指定加载的filter或者剔除的filter，url配置的key就是入参的key&lt;/span&gt;
        List&amp;lt;Filter&amp;gt; filters = ExtensionLoader.&lt;span class=&quot;fu&quot;&gt;getExtensionLoader&lt;/span&gt;(Filter.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;getActivateExtension&lt;/span&gt;(invoker.&lt;span class=&quot;fu&quot;&gt;getUrl&lt;/span&gt;(), key, group);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (filters.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = filters.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i --) {
                &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Filter filter = filters.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(i);
                &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Invoker&amp;lt;T&amp;gt; next = last;
                &lt;span class=&quot;co&quot;&gt;// 每个filter使用一个Invoker包裹&lt;/span&gt;
                last = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Invoker&amp;lt;T&amp;gt;() {

                    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Class&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;getInterface&lt;/span&gt;() {
                        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; invoker.&lt;span class=&quot;fu&quot;&gt;getInterface&lt;/span&gt;();
                    }

                    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; URL &lt;span class=&quot;fu&quot;&gt;getUrl&lt;/span&gt;() {
                        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; invoker.&lt;span class=&quot;fu&quot;&gt;getUrl&lt;/span&gt;();
                    }

                    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isAvailable&lt;/span&gt;() {
                        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; invoker.&lt;span class=&quot;fu&quot;&gt;isAvailable&lt;/span&gt;();
                    }

                    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Result &lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(Invocation invocation) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; RpcException {
                        &lt;span class=&quot;co&quot;&gt;// 将next传入，在filter负责调用，由此构成链&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; filter.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(next, invocation);
                    }

                    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;destroy&lt;/span&gt;() {
                        invoker.&lt;span class=&quot;fu&quot;&gt;destroy&lt;/span&gt;();
                    }

                    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;() {
                        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; invoker.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
                    }
                };
            }
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; last;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以现在返回看最前面的调用堆栈一切应该是顺理成章了，netty接收到I/O请求后，通知到NioWorker，在NioWorker线程中经过pipeline的处理后启动了ChannelEventRunnable线程；在ChannelEventRunnable线程线程中根据接收到的不同事件调用handler的不同方法来处理，经过多个handler处理之后，经过的是filter链，最后会调用到我们编写的service方法。执行完我们的方法之后，dubo会将结果通过netty发送给consumer。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;上面通过提问题的方式，解读了一些阅读源码中的关键代码，现在将service export和service reply结合起来，再去阅读源代码就就本能读懂所有主流程了，就能明白源代码为什么这么写。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jan 2018 15:00:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/8379902.html</dc:identifier>
</item>
<item>
<title>谈谈领域驱动设计的理解 - 道法自然</title>
<link>http://www.cnblogs.com/baihmpgy/p/8379886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baihmpgy/p/8379886.html</guid>
<description>&lt;p&gt;领域驱动设计有感 最近3年一直在供应链信息化领域的管理和架构，一方面惊讶于该领域业务知识的复杂，另一方面也惊讶于管理的复杂，特别是今年在做一个系统的架构时，学习了很多的东西。这几年，几乎每年都要花2000+元在买书上。目前负责一个架构的团队有几十号人，一直在思考如何更好的做好的一个复杂的软件产品，因此，也有意识的学习一些知识。最近在看的有两本书《领域驱动设计》、《架构及未来》，本文简单的描述读《领域驱动设计》前面两部分的一些体验。&lt;/p&gt;
&lt;p&gt;强烈推荐有志于架构师、CTO，走技术流的兄弟们也好好看一下这两本书。对于一个大型的团队，你不可能再亲力亲为，因而，这时候需要考虑的是如何为团队构建成熟的组织、流程、制度，确保团队可扩展性。阅读《领域驱动设计》的目的，是为系统分析团队探索一条比较有效的系统分析设计方法，希望将其变成团队可以遵循的标准规范，使团队形成更为高效的详细设计方法。 设计的目的是为了建模，通过模型实现更有效的沟通，确保领域专家、技术团队能够为需求达成一致的理解，并且，通过模型可以理解代码，保证代码的可理解性、可扩展性、可维护性。&lt;/p&gt;
&lt;p&gt;领域驱动设计的一个重点就是领域建模。谈到领域建模，我们先谈谈领域。领域知识一般是用于描述有哪些角色使用系统完成什么任务。领域知识的描述语句就是“主谓宾”，比如关于订单领域知识的描述，大致是“用户通过商城可以搜索商品，将商品添加到购物车，然后下单付款等待收货。每一个订单由若干商品构成，在下单的时候，商品价格是确定的、优惠也是确定的。供货商会在不同的时期去更改商品的价格和优惠方式……”。这段领域知识的描述的每一个“主谓宾”句子，本质就是由名词（主语和宾语）和动词构成。因此，对领域知识的建模会有以下元素构成：&lt;/p&gt;
&lt;p&gt;（1）关联：谓语一般用于关联主语和宾语，比如订单由若干商品（确切的讲，应该成为订单商品，订单商品与商品不同）构成。关联由：组合、聚合、关联、依赖四种类型，这里“订单由若干订单商品构成”，表明订单和订单商品是组合关系，即订单是订单商品组成并且订单商品不能单独存在。聚合是组合的弱化，聚合是弱化的整体和部分的关系，这里的部分可以单独存在。关联相对于组合与聚合会更弱一些，比如这里“用户下单付款等待收货”。用户和订单就是一种关联关系，订单属于用户，用户与订单的关系就是“下单”。依赖是在业务代码中，一个类使用到另一个类的功能，比如付款时，我们会依赖第三方接口来实现具体的付款。付款有不同的方式，我们会抽取为不同的支付接口，仅依赖于接口而不是实现。&lt;/p&gt;
&lt;p&gt;（2）实体/值对象：领域知识的名称，会由实体（或称为领域实体）或者值对象来表示，动词则可能是领域实体的一个操作。实体与值对象的差别在于实体具有标识，值对象则没有。&lt;/p&gt;
&lt;p&gt;（3）模块/系统：模块和系统用于组织领域知识的边界，确保软件系统的高内聚、低耦合。&lt;/p&gt;
&lt;p&gt;（4）Service：一般表示一些可复用的功能，领域实体一般会依赖于服务。&lt;/p&gt;
&lt;p&gt;我们通过以上元素，将领域知识，使用大家都能看懂的图形来构建出来，这就是建模。模型必须真实反映了领域知识，并且与代码相对应。对于复杂系统，领域模型会非常庞大，这样的模型图我相信没有任何人有兴趣细看，我们会陷入到细节中，然后不知所措。因此，更有效的建模，会使用分层、模块化、服务化，甚至按照子系统设计，传统的SOA架构也是解决软件复杂性的一种有效的方法。同理，在数据库设计时，一张庞大的ER图也是很恐怖的，模型必须进行分层，由顶向下，由High Level到Details Level。&lt;/p&gt;
&lt;p&gt;￼这里，我们使用图形对“客户下单”领域知识进行了建模（模型图仅示例，不精确）。这个模型反应了客户、订单、商品、优惠折扣及历史价格的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/21322/201801/21322-20180129225348171-1939796497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有的领域实体，具有生命周期，我们通过以下模式来管理领域实体。&lt;/p&gt;
&lt;p&gt;（1）聚合（Aggregate）：在这里订单、订单商品（订单商品与商品折扣）、订单折扣是聚合关系，订单是这些部分的聚合根。我们使用聚合模式来将这些实体作为整体统一管理。聚合涉及的实体将一起存在、一起消亡，需要满足固定的商业规则。领域驱动设计只允许我们通过聚合根来访问，二不允许直接访问内部实体。这确保整个业务规则的完整性，具备更好的可维护性、可扩展性。&lt;/p&gt;
&lt;p&gt;（2）Factory和Repository：Factory用于创建复杂的聚合根，Repository用于加载和保存聚合根到持久存储。 领域驱动设计提倡将系统分成UI层、应用层、领域层和基础设施层。通过这几个元素，我们整个设计就初步具备一定的标准规范了。在后续，我会进一步分享关于聚合、Factory、Repository模式的知识。 这本书可以让我们对设计有一种从朦胧到清晰的感觉，提供了更好的方法论，有助于解决软件的复杂性难题。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jan 2018 14:55:00 +0000</pubDate>
<dc:creator>道法自然</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baihmpgy/p/8379886.html</dc:identifier>
</item>
<item>
<title>salesforce零基础学习（八十五）streaming api 简单使用（接近实时获取你需要跟踪的数据的更新消息状态） - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/7955469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/7955469.html</guid>
<description>&lt;p&gt;Streaming API参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://trailhead.salesforce.com/en/modules/api_basics/units/api_basics_streaming&quot; target=&quot;_blank&quot;&gt;https://trailhead.salesforce.com/en/modules/api_basics/units/api_basics_streaming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://resources.docs.salesforce.com/210/latest/en-us/sfdc/pdf/api_streaming.pdf&quot; target=&quot;_blank&quot;&gt; https://resources.docs.salesforce.com/210/latest/en-us/sfdc/pdf/api_streaming.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;背景：工作中我们有可能会有这样相关的需求：某些数据很重要，需要实时监控是否有变化,或者某些数据在其他的平台有集成。如果有变化，不刷新页面或者做其他trigger等操作便可以收到相关更改的推送通知（不管是salesforce平台还是其他外部服务，比如java端等，可以通过此种方式进行实时同步），告诉当前的需要监控的记录已经发生了变化。这种场景往往更会出现在数据不止存储在salesforce端，还有其他平台有数据的存储或者访问。这种情况下可以使用Streaming API。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.Stream API简单介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Streaming API提供了两种功能，一种为基于Salesforce数据改变，对订阅的客户端进行通知推送，另一种是不基于Salesforce数据改变，对订阅的客户端进行通知推送，接下来大部分内容基于Salesforce数据改变后，对订阅的客户端进行推送，另外一种感兴趣的可以自行查看。通知推送不止可以应用于salesforce系统，其他系统等也可以通过oauth等连接后接收到通知推送，感兴趣的可以查看API提供的内容。&lt;/p&gt;
&lt;p&gt;Streaming API用于制定一套你想要接收的数据的条件，并且指定哪些事件（create/update/delete/undelete）情况下符合的数据推送一条通知到客户端，一条通知就是事件触发的结果发送到渠道的消息。通知的格式为JSON的格式。使用Streaming API可以减少不必要的API请求。&lt;/p&gt;
&lt;p&gt;Streaming API使用的推送技术，即服务器端会主动给订阅的客户端发送通知信息，而不是客户端去调用服务器端返回消息，使用Bayeux协议和CometD用于长轮询。&lt;/p&gt;
&lt;p&gt;cometd 参考链接： &lt;a href=&quot;https://docs.cometd.org/&quot; target=&quot;_blank&quot;&gt;https://docs.cometd.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果想使用Streaming API，需要enable api的权限以及streaming api的权限&lt;/p&gt;
&lt;p&gt;想要接受通知(notifications),当前登录的user必须针对StreamingChannel表拥有read权限&lt;/p&gt;
&lt;p&gt;想要创建和管理通知，当前登录的user必须对StreamingChannel拥有Create权限&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/910966/201712/910966-20171227171427925-634647540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 二.Streaming API 使用步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对开发者来说，更关注的是这个东西如何使用。使用Streaming API实现订阅者接收符合条件的推送消息可以三步走：&lt;/p&gt;
&lt;p&gt;1.创建PushTopic&lt;/p&gt;
&lt;p&gt;去除一下PushTopic神奇的面纱，简单的来说，PushTopic是一个标准的sObject，封装了以下的字段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ApiVersion：用于指定查询的SQL的版本，37以后系统可以存储24小时以内的事件，必填字段；&lt;/li&gt;
&lt;li&gt;Description：PushTopic的描述信息，限定在400个字符以内；&lt;/li&gt;
&lt;li&gt;ID：指定一条记录的全局唯一的标识；&lt;/li&gt;
&lt;li&gt;isActive：是否可用，关系到PushTopic的限制计数（系统对PushTopic有limitation size）；&lt;/li&gt;
&lt;li&gt;IsDeleted：指定此PushTopic是否移动到回收站；&lt;/li&gt;
&lt;li&gt;Name：PushTopic的名字，定义了渠道的名字，并且此名称必须是唯一的，后期订阅者订阅时，使用的就是这个名字；&lt;/li&gt;
&lt;li&gt;NotifyForFields：指定哪些字段被评估生成通知；&lt;/li&gt;
&lt;li&gt;NotifyForOperations：指定数据哪种事件操作会生成通知，在api version 29以后，此字段为只读字段；&lt;/li&gt;
&lt;li&gt;NotifyForOperationCreate：Create操作是否会生成通知，api29以后可用；&lt;/li&gt;
&lt;li&gt;NotifyForOperationDelete：Delete操作是否会生成通知，api29以后可用；&lt;/li&gt;
&lt;li&gt;NotifyForOperationUndelete：UnDelete操作是否会生成通知，api29以后可用；&lt;/li&gt;
&lt;li&gt;NotifyForOperationUpdate：Update操作是否会生成通知，api29以后可用；&lt;/li&gt;
&lt;li&gt;Query：SOQL语句决定了哪些数据符合触发的事件后会发送到渠道。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;恩，新建一个PushTopic，设置了必填字段的值insert以后，一个PushTopic就创建完了。这些字段有几个需要详细的描述一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;：Query在PushTopic的作用不言而喻，定义了哪些数据可以满足条件进行推送。Query语法和SOQL基本相同，但是有一些情况不支持。限制如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;select字段无ID；&lt;/li&gt;
&lt;li&gt;子连接查询Semi-joins and anti-joins；&lt;/li&gt;
&lt;li&gt;聚合类的查询，比如SUM，AVG等；&lt;/li&gt;
&lt;li&gt;COUNT；&lt;/li&gt;
&lt;li&gt;LIMIT；&lt;/li&gt;
&lt;li&gt;关系型查询不支持，只可以查询到ID，不能通过“.”的方式查询到父的其他信息；&lt;/li&gt;
&lt;li&gt;查询中包括Text Area字段；&lt;/li&gt;
&lt;li&gt;ORDER BY；&lt;/li&gt;
&lt;li&gt;GROUP BY；&lt;/li&gt;
&lt;li&gt;WHERE部分使用了formula类型字段；&lt;/li&gt;
&lt;li&gt;NOT   Example : SELECT Id FROM Account WHERE NOT Name = 'Salesforce.com'&lt;/li&gt;
&lt;li&gt;OFFSET&lt;/li&gt;
&lt;li&gt;TYPEOF&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;NotifyForFields：&lt;/strong&gt;推送的message包含一项sObject字段值的信息，会推送哪些字段值取决于NotifyForFields的赋值，NotifyForFields赋值及作用如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;All ：推送所有的字段&lt;/li&gt;
&lt;li&gt;Referenced (default) : 推送select以及where部分字段的并集集合，如果不指定此字段值，默认值为Referenced&lt;/li&gt;
&lt;li&gt;Select ：只推送select部分的字段；&lt;/li&gt;
&lt;li&gt;Where；只推送where部分的字段。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; NotifyForOperationCreate：&lt;/strong&gt;指定此字段值为true情况下，当操作的sObject进行insert操作，并且满足query的查询条件，则server端会推送一条通知给所有的订阅者们，此字段当且仅当ApiVersion大于29情况下才允许使用；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NotifyForOperationDelete：&lt;/strong&gt;指定此字段值为true情况下，当操作的sObject进行delete操作，并且满足query的查询条件，则server端会推送一条通知给所有的订阅者们，此字段当且仅当ApiVersion大于29情况下才允许使用；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NotifyForOperationUndelete：&lt;/strong&gt;指定此字段值为true情况下，当操作的sObject进行undelete操作，并且满足query的查询条件，则server端会推送一条通知给所有的订阅者们，此字段当且仅当ApiVersion大于29情况下才允许使用；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NotifyForOperationUpdate：&lt;/strong&gt;指定此字段值为true情况下，当操作的sObject进行update操作，并且满足query的查询条件，则server端会推送一条通知给所有的订阅者们，此字段当且仅当ApiVersion大于29情况下才允许使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ApiVersion:&lt;/strong&gt;此字段声明Streaming版本。在36.0及以前，他不包含客户端的状态,也没法跟踪已经过去的事件信息。简单来说，如果声明的版本为36及以前情况下，客户端订阅了渠道后，只能收到订阅后的满足条件的数据事件发生的数据，订阅以前的相关满足事件的数据便没法接收到。如果将此字段设置值为37.0及以上，Streaming API支持存储24小时内满足条件的数据通知信息，即使客户端订阅渠道后，也可以重播24小时内的以前的数据。一条记录有可能出现增删改等很多的事件，每一个广播事件通过replayId作为编号，replayId在org和渠道中是唯一的，即使事件被删除后，此事件对应的replayId也不会被重用，订阅者可以通过赋值ReplayId接收不同的事件消息进行重播，主要有三种ReplayId 赋值&lt;/p&gt;
&lt;p&gt;-2：订阅者连接渠道后，接收所有的事件，包括订阅时前24小时的事件消息；&lt;/p&gt;
&lt;p&gt;-1：订阅者连接渠道后，接收订阅以后的事件消息；&lt;/p&gt;
&lt;p&gt;replayId：订阅者连接渠道后，接受指定replayId以及以后的事件消息，比如replayId为5，订阅者将会受到5以后的事件消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201712/910966-20171225163048072-477992817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(注：每个Query语句中只能搜索一个sObject.)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;当新建PushTopic想要查看是否创建成功以及是否生效，或者模拟PushTopic的订阅，可以使用workbench查看相关的状态，这里以Account为例，监听Account增删改事件，有以上事件则会发送通知。&lt;/p&gt;

&lt;p&gt;1）登录workbench,网址&lt;a href=&quot;https://workbench.developerforce.com/login.php&quot; target=&quot;_blank&quot;&gt;https://workbench.developerforce.com/login.php&lt;/a&gt;，选择登录的版本为36.0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/910966/201712/910966-20171228150431788-1685194010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2）Jump To选择Streaming Push Topics&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/910966/201712/910966-20171228150604741-1434588679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3)Push Topics 选择刚刚创建的TestAccountStreaming，点击Subscribe,则目前已经模拟订阅了此PushTopic&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/910966/201712/910966-20171228150724709-893447544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 4）修改了一条Account信息，则会在Streaming Push Topic 显示具体的修改信息推送消息了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/910966/201712/910966-20171228151008397-681974470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;PushTopic按照上面的字段描述可以很轻松的创建了，下一步应该是让客户端来订阅。如何让订阅呢，这时，我们需要定义一个渠道，保证客户端可以顺利订阅此渠道（Channel），当有满足条件事件的数据进行触发后，由渠道server主动推送给订阅此渠道的客户端。渠道在salesforce端也封装成了一个对象 StreamingChannel，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;StreamingChannel表结构如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Description ： Streaming Channel的描述&lt;/li&gt;
&lt;li&gt;ID ： Streaming Channel的ID&lt;/li&gt;
&lt;li&gt;IsDeleted ： 指定Streaming Channel是否被移动到回收站&lt;/li&gt;
&lt;li&gt;IsDynamic ： 如果为true则在订阅时动态创建channel&lt;/li&gt;
&lt;li&gt;LastReferencedDate ： 存储当前用户最近一次查看的这条记录的时间戳&lt;/li&gt;
&lt;li&gt;Name：绑定的PushTopic，以/u/开始，命名为/u/pushtopic Name&lt;/li&gt;
&lt;li&gt;OwnerId : Streaming Channel的owner&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里主要需要说明的一个字段就是Name，Name字段要求必须为/u/PushTopicName，并且PushTopicName只能包含标准的字符以及‘_’或者‘/’，其他的字符不支持，比如上面创建的PushTopic的名称为TestAccountPushTopic，则创建StreamingChannel时，Name必须为/u/TestAccountPushTopic,并且区分大小写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 2.客户端订阅渠道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端订阅渠道可以简单的分成三部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送一个握手请求&lt;/li&gt;
&lt;li&gt;向渠道发送一个订阅的请求&lt;/li&gt;
&lt;li&gt;使用长响应（轮询）进行连接。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果订阅是在页面或者组件中使用，可以使用Cometd进行操作，Cometd提供了基本方法用来实现客户端订阅操作，详见Cometd API。当渠道成功后，PushTopic定义的query的数据执行的操作事件（create/update/delete/undelete）满足了PushTopic定义的操作条件，渠道将会向所有订阅的客户端发送通知。上面说道，通知是一个JSON的字符串，大概格式如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;clientId&quot;: &quot;lxdl9o32njygi1gj47kgfaga4k&quot;, 
  &quot;data&quot;: {
    &quot;event&quot;: {
      &quot;createdDate&quot;: &quot;2016-09-16T19:45:27.454Z&quot;, 
      &quot;replayId&quot;: 1, 
      &quot;type&quot;: &quot;created&quot;
    }, 
    &quot;sobject&quot;: {
      &quot;Phone&quot;: &quot;(415) 555-1212&quot;, 
      &quot;Id&quot;: &quot;001D000000KneakIAB&quot;, 
      &quot;Name&quot;: &quot;Blackbeard&quot;
    }
  }, 
  &quot;channel&quot;: &quot;/topic/AccountUpdates&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;订阅者订阅接收消息需要有以下的权限：&lt;/p&gt;
&lt;p&gt;where条件部分的字段的FLS&lt;/p&gt;
&lt;p&gt;query对象的读的权限&lt;/p&gt;
&lt;p&gt;PushTopic对象的读的权限&lt;/p&gt;
&lt;p&gt;基于Sharing Rule的新建和编辑记录的权限&lt;/p&gt;
&lt;p&gt;Salesforce存储了基于PushTopic时间24小时，并且允许你去重新检索已经存储的以及新的事件。订阅者可以通过重播的选项来选择哪些事件接收。&lt;/p&gt;
&lt;p&gt;当你订阅一个渠道后，你并不想接收所有的数据，比如对于客户信息，不同的人员更关注自己的客户的变化信息，这是你可以在订阅的URL后添加filter对事件通知进行过滤，推送你需要的通知信息。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;eg：&lt;/em&gt;/topic/ChannelName?&amp;lt;expression&amp;gt;&lt;/p&gt;
&lt;p&gt;其中ChannelName为上面定义的渠道的名称，&amp;lt;expression&amp;gt;包含一个或者多个条件，多个条件使用'&amp;amp;'分割，比如&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;/topic/TestAccountPushTopic?country=China&amp;amp;isActive=true&lt;br/&gt;&lt;/em&gt;如果使用ID作为过滤条件，需要使用18位的ID格式，15位的不支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三.代码举例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方提供了两个demo，一个是基于数据进行DML操作发送给订阅者消息，一个是主动广播发送给订阅者消息。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/developerforce/SalesforceDurableStreamingDemo/archive/master.zip&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/developerforce/SalesforceDurableStreamingDemo/archive/master.zip&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以下载下来看一下代码，代码里面详尽的讲解了客户端握手，订阅以及接受信息的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;本篇主要简单讲解Streaming API的使用方式以及什么情况下会使用到此API，如果使用到查看上面的文档即可。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jan 2018 14:31:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/7955469.html</dc:identifier>
</item>
<item>
<title>引用类型之数组array最全的详解 - 决起而飞</title>
<link>http://www.cnblogs.com/iDouble/p/8377426.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iDouble/p/8377426.html</guid>
<description>&lt;p&gt;今天总结一下array类型。 js中的数组是有着非常强大的功能。具有很大的灵活性，有两个方面的特点&lt;/p&gt;
&lt;p&gt;1、数组的每一项可以保存任何的数据类型；2、数组大小可以动态的调整；看下面的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;var&lt;/span&gt; one=&lt;span&gt;new&lt;/span&gt; Array();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;空数组&lt;/span&gt;
           &lt;span&gt;var&lt;/span&gt; two=&lt;span&gt;new&lt;/span&gt; Array(5)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;length为5的数组&lt;/span&gt;
           &lt;span&gt;var&lt;/span&gt; three=&lt;span&gt;new&lt;/span&gt; Array(&quot;double&quot;,3)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;包含double和3的数组&lt;/span&gt;

           &lt;span&gt;var&lt;/span&gt; four=[]               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用[]表示&lt;/span&gt;
           &lt;span&gt;var&lt;/span&gt; five=[1,2,3,4&lt;span&gt;]
           console.log(five[&lt;/span&gt;0])      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 数组的索引从0开始，length-1&lt;/span&gt;
           console.log(five.length)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4 数组大小length为4&lt;/span&gt;
           five.length=10&lt;span&gt;
           console.log(five[&lt;/span&gt;4])      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引从4到9都是undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;检测类型&lt;/h2&gt;
&lt;p&gt;前面谈过，对于引用类型，可以用instanceof来检测，可以得到对象是不是数组，这只适合于只有一个全局环境。对于具有几个全局环境，可以用ES5新增的Array.isArray()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; one=&lt;span&gt;[]
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(one &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Array){
                  console.log(&lt;/span&gt;&quot;true&quot;&lt;span&gt;)
          }

          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(Array.isArray(one)){
                  console.log(&lt;/span&gt;&quot;true&quot;&lt;span&gt;)    IE9支持
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;转换方法&lt;/h2&gt;
&lt;p&gt;我们所知道的，所有对象都有toString()、toLocaleString()、valueOf()的方法&lt;/p&gt;
&lt;p&gt;对于数组而言：valueOf()返回的是数组本身；toString()返回数组中每个值得字符串形式拼接而成的一个有逗号分隔开的字符串（数组的每一项都会调用toString()方法）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; one=[1,&quot;2&quot;,&quot;great&quot;&lt;span&gt;];
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; two=one.toString();         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组每一项都调用toString()方法，组成的字符串&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; three=one.valueOf();        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回数组本身&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; four=one.toLocaleString()   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组的每一项都调用toLocaleString()方法，组成字符串&lt;/span&gt;
&lt;span&gt;          
          console.log(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; two)         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;
          console.log(&lt;span&gt;typeof&lt;/span&gt; two[0])      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;
          console.log(Array.isArray(three))    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
          console.log(&lt;span&gt;typeof&lt;/span&gt; four)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;
          console.log(&lt;span&gt;typeof&lt;/span&gt; four[0])     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;

          &lt;span&gt;var&lt;/span&gt; first=[1,2,3,4&lt;span&gt;]
          console.log(first.join(&lt;/span&gt;&quot;||&quot;))   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;join()方法主要是连接，默认还是逗号的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;补充一下关于toString()和toLocaleString()之间的区别，主要体现在日期和数字上&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
         1&lt;span&gt;、日期上的区别，locale代表的是国际化和本土化中的概念
         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; date=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
         console.log(date.toString())        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认的日期 Mon Jan 29 2018 16:01:34 GMT+0800 (中国标准时间)&lt;/span&gt;
         console.log(date.toLocaleString())  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地化日期 2018/1/29 下午4:01:34&lt;/span&gt;

         2&lt;span&gt;、数字超过3位数的区别
         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; num1=100&lt;span&gt;;
         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; num2=1000000&lt;span&gt;;
         console.log(num1.toString())        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;
         console.log(num1.toLocaleString())  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;
         console.log(num2.toString())        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1000000&lt;/span&gt;
         console.log(num2.toLocaleString())  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,000,000 每3个0都会有逗号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;操作数组的方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;栈方法（后进先出）&lt;/strong&gt;：push()，推入和pop()，弹出两种&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;var&lt;/span&gt; one=[1,2&lt;span&gt;]
         one.push(&lt;/span&gt;3,4)       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在末尾添加3,4&lt;/span&gt;
         console.log(one)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,2,3,4   &lt;/span&gt;
         &lt;span&gt;var&lt;/span&gt; two=one.pop()   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除并返回末尾数&lt;/span&gt;
         console.log(one)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,2,3&lt;/span&gt;
         console.log(two)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;队列方法（先进后出）&lt;/strong&gt;：shift()，移除和unshift()，增加两种&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;var&lt;/span&gt; one=[1,2&lt;span&gt;]
         one.unshift(&lt;/span&gt;3,4)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在开头添加3,4&lt;/span&gt;
         console.log(one)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3,4,1,2   &lt;/span&gt;
         &lt;span&gt;var&lt;/span&gt; two=one.shift()   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除并返回第一数&lt;/span&gt;
         console.log(one)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2,3,4&lt;/span&gt;
         console.log(two)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;重新排序方法&lt;/strong&gt;：reverse()和sort()方法，他们的返回值是排序后的数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;reverse()方法&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; one=[1,2,3,4&lt;span&gt;]
        console.log(one.reverse())   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4,3,2,1 翻转数组项的顺序&lt;/span&gt;
        
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sort()方法&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; two=[0,5,10,15&lt;span&gt;]
        console.log(two.sort())      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0,10,15,5  sort方法默认是升序排列,先回把每一项调用toString()方法，按照string的规则进行排序&lt;/span&gt;
        
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sort接受比较函数&lt;br/&gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通的比较&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; three=[0,5,10,15&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; threes=three.sort(rank1)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用比较函数&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; rank1(num1,num2){
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(num1&amp;lt;&lt;span&gt;num2){
                      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;
               }
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(num1&amp;gt;&lt;span&gt;num2){
                      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;
               }
               &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;
               }
        }
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; rank2(num1,num2){      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者这样&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; num1-num2        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;num1-num2为升序;num2-num1为降序&lt;/span&gt;
&lt;span&gt;               }
        console.log(threes)             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0,5,10,15     &lt;/span&gt;
         
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象的比较&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; objectList=&lt;span&gt;[]
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; person(name,age){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age=&lt;span&gt;age;
        }
        objectList.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; person(&quot;double&quot;,5&lt;span&gt;))
        objectList.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; person(&quot;single&quot;,15&lt;span&gt;))
        objectList.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; person(&quot;another&quot;,10&lt;span&gt;))

        objectList.sort(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; rank(a,b){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较函数进行排序&lt;/span&gt;
               &lt;span&gt;return&lt;/span&gt; a.age-&lt;span&gt;b.age
        })

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;objectList.length;i++){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历一遍&lt;/span&gt;
             console.log(&quot;name&quot;+objectList[i].name+&quot; age&quot;+&lt;span&gt;objectList[i].age)
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;concat()方法：基于当前数组中的所有项创建一个新数组（&lt;strong&gt;先创建当前数组的一个副本，将接受到的参数添加到该数组的末尾&lt;/strong&gt;），&lt;strong&gt;对原数组没有影响&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;slice()方法：&lt;strong&gt;基于当前数组中的一项或多项创建一个新的数组&lt;/strong&gt;，规则比较多，&lt;strong&gt;对原数组没有影响&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这两种方法值得注意，&lt;strong&gt;对原数组没有影响；而其他方法是基于原数组的操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;var&lt;/span&gt; one=[1,2,3&lt;span&gt;]
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; two=one.concat(4,5,[6,7&lt;span&gt;])&lt;br/&gt;console.log(one)      //[1,2,3]    创建了副本
       console.log(two)      //[1,2,3,4,5,6,7]

       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; one=[1,2,3,4,5&lt;span&gt;]

       console.log(one.slice())        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;截取整个数组&lt;/span&gt;
       console.log(one.slice(3))       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4,5   索引3开始到结束&lt;/span&gt;
       console.log(one.slice(0,3))     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,2,3 不包括索引3&lt;/span&gt;
       console.log(one.slice(1,-1))    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;出现负数，-1为倒数第一,-2为倒数第二&lt;/span&gt;
       console.log(one.slice(-4,-1))   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;都加上length再说,2,3,4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;修改数组项的万能大法：splice()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除：指定2个参数，要删除的第一项位置和删除的项数&lt;/p&gt;
&lt;p&gt;插入：指定3个参数，起始位置，0（要删除的项数），要插入的项&lt;/p&gt;
&lt;p&gt;替换：指定3个参数，起始位置，要删除的项，要插入的任意数量的项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;var&lt;/span&gt; one=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;&lt;span&gt;]
       one.splice(&lt;/span&gt;3,1)           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;
       console.log(one)          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a,b,c&lt;/span&gt;
       one.splice(2,0,&quot;e&quot;,&quot;f&quot;&lt;span&gt;)
       console.log(one)          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a,b,e,f,c    添加是在前面添加&lt;/span&gt;
       one.splice(2,1,&quot;g&quot;,&quot;h&quot;&lt;span&gt;)
       console.log(one)          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a,b,g,h,f,c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;位置方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;indexOf()和lastIndexOf()方法，要查找的项和（可选的）表示查找起点位置的索引；indexOf从数组的开头开始向后查找，lastIndexOf从数组前面查找&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;都返回要查找项在数组中的位置，找不到就返回-1，会使用全等操作符&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;var&lt;/span&gt; one=[1,2,3,2,4&lt;span&gt;]
      console.log(one.indexOf(&lt;/span&gt;1))     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0 返回的是要查找项的索引值&lt;/span&gt;
      console.log(one.indexOf(&quot;1&quot;))   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;-1 因为比较使用的是全等操作符，所以找不到直接返回-1&lt;/span&gt;
      console.log(one.indexOf(4,2))   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5 从索引为2开始查找&lt;/span&gt;
      console.log(one.lastIndexOf(2)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;迭代方法&lt;/h3&gt;
&lt;p&gt;es5规定的5种迭代方法，接受两个参数：每一项上运行的函数和（可选）运行该函数的作用域对象——影响this值&lt;/p&gt;
&lt;p&gt;函数接受三个参数：item数组中的每个元素；index数组中每个元素的索引；array数组本身；item为必选，其他为可选&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      every和some是数组的逻辑判定，对数组应用指定的函数判断，返回布尔值
      every传入的函数每一项都返回true才返回true，相当于&lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
      而some传入的函数的任意一项返回true就会返回true，相当于&lt;/span&gt;||&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; one=[1,2,3,4,5&lt;span&gt;]
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; everyResult=one.every(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item,index,array){
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item&amp;gt;4&lt;span&gt;
      })
      console.log(everyResult)      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;flase 不是每一项都大于4&lt;/span&gt;

      &lt;span&gt;var&lt;/span&gt; someResult=one.some(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item,index,array){
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item&amp;gt;4&lt;span&gt;
      })
      console.log(someResult)       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true  存在大于4的项&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      filter返回一个数组，该数组的元素为指定检查数组中满足函数条件的所有元素&lt;br/&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; one=[1,2,3,4,5,6&lt;span&gt;]
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; filterResult=one.filter(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item,index,array){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item&amp;gt;4&lt;span&gt;
      })
      console.log(filterResult)    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5,6  返回满足条件的数组&lt;/span&gt;
&lt;span&gt;
      map返回一个数组，该数组的元素为传入函数的结果的集合&lt;br/&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; one=[1,2,3,4&lt;span&gt;]
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mapResult=one.map(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item,index,array){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item*4&lt;span&gt;
      })
      console.log(mapResult)       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4,8,12,16 返回经过函数的结果的数组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;     forEach用于调用数组中每一个元素，将元素返回给回调函数，没有返回值;本质上和使用for循环迭代数组是一样的

     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; one=[1,2,3,4,5,6&lt;span&gt;]
     one.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item,index,array){
                  console.log(item)         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1——6的迭代  &lt;/span&gt;
&lt;span&gt;     })

     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; two=[1,2,3,4&lt;span&gt;]
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sum=0&lt;span&gt;
     two.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item,index,array){
             sum&lt;/span&gt;+=item                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;累加&lt;/span&gt;
&lt;span&gt;     })
     console.log(sum)                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;
     two.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item,index,array){
             two[index]&lt;/span&gt;=item+1       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;元素自加&lt;/span&gt;
&lt;span&gt;     })
     console.log(two)               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2,3,4,5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并归方法&lt;/p&gt;
&lt;p&gt;reduce()和reduceRight()这两个方法都会迭代数组的所有项，然后构建一个最终返回的值，reduce从数组第一项开始遍历，reduceRight从数组最后一个遍历；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
    基本语法为array.reduce(function&lt;span&gt;,initialValue)
    函数接受四个参数：pre,cur,index,array
    如果有初始值，pre就是初始值，没有则pre为数组第一项，cur为数组第二项

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; one=[1,2,3,4&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sum=one.reduce(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(pre,cur,index,array){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; pre+&lt;span&gt;cur
    },&lt;/span&gt;0&lt;span readability=&quot;5&quot;&gt;)                          
    console.log(sum)  //10&lt;p&gt;pre为0，cur为1   pre为pre和cur之和1，cur为2  ……一直遍历结束&lt;/p&gt;&lt;p&gt;对于reduceRight来说，没有初始值，pre就是最后一项，cur为倒数第二项；有初始值则cur为最后一项&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后：ES5中的新方法具有极强功能，代替原来用for循环遍历的种种，下次再用实际项目总结&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jan 2018 14:18:00 +0000</pubDate>
<dc:creator>决起而飞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iDouble/p/8377426.html</dc:identifier>
</item>
<item>
<title>开源纯C#工控网关+组态软件(八)表达式编译器 - 老坏猫</title>
<link>http://www.cnblogs.com/evilcat/p/8379640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evilcat/p/8379640.html</guid>
<description>&lt;div&gt;
&lt;p class=&quot;PublishStatus&quot;&gt;&lt;span&gt;&lt;strong&gt;一、  &lt;/strong&gt; &lt;strong&gt;引子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; &lt;span&gt;监控画面的主要功能之一就是跟踪下位机变量变化，并将这些变化展现为动画。大部分时候，界面上一个图元组件的某个状态，与单一变量Tag绑定，比如电机的运行态，绑定一个MotorRunning信号；但有些时候不会这么简单，比如温度计在温度高于50℃显示红色;某设备报警，可能是多个条件其中之一触发的结果；变量变化触发一系列连锁反应…如此种种。考虑到工控行业大部分技术人员并非计算机专业出身，如何能够用最少的编码解决各种复杂的变量-动画绑定问题，无疑要费一番心思。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/43917/201801/43917-20180129220113906-709178120.png&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、  &lt;/strong&gt; &lt;strong&gt;方案选型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对变量动画绑定问题，可以选择的方案包括如下几种：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;脚本编译器&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;不少大型组态软件包含强大的脚本编辑器，支持诸如VBS、Python甚至C脚本语言。脚本自带语法编辑器、调试器和编译器，调用的API包罗万象，如数据库API，通讯API，画面组态API…可以用脚本实现非常复杂的逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但基于下面几种考虑，我没有实现这类的脚本编译器：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;不同于大部分组态软件包含一个独立的界面设计器，我用Visual Studio来肩挑语法编辑、调试、编译和界面设计的重任，没必要多此一举的搞一个独立的脚本编译器。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;C#结合Visual Studio来调用通讯、数据库链接的各类函数，C#包含强大的语法功能，配合.NET 类库几乎无所不能，同时C#也支持脚本化，没有必要在使用其他脚本语言。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;对于复杂的逻辑，就让C#配合VS神器来完成吧。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;运算符重载。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;曾经研究过一个C#写的脚本编译系统，它可以实现两个特定集合间的四则运算和逻辑运算，如List1.A+List2.A;List1.A&amp;gt;List2.B。看上去集合就像一个普通的数值那样参与运算和操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运算符重载是C#一个强大的语法功能，可以重载的操作符如下：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;运算符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可重载性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;+、-、!、~、++、--、true、false&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;可以重载这些一元运算符。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  true和false运算符必须成对重载。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;+、-、*、/、%、&amp;amp;、|、^、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;可以重载这些二元运算符。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;==、!=、&amp;lt;、&amp;gt;、&amp;lt;=、&amp;gt;=&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;可以重载比较运算符。必须成对重载。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;&amp;amp;&amp;amp;、||&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;不能重载条件逻辑运算符。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  但可以使用能够重载的&amp;amp;和|进行计算。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;[]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;不能重载数组索引运算符，但可以定义索引器。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;不能重载转换运算符，但可以定义新的转换运算符。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;+=、-=、*=、/=、%=、&amp;amp;=、|=、^=、&amp;lt;&amp;lt;=、&amp;gt;&amp;gt;=&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;不能显式重载赋值运算符。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  在重写单个运算符如+、-、%时，它们会被隐式重写。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;=、.、?:、-&amp;gt;、new、is、sizeof、typeof&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;无疑运算符重载用的好可以写出语义更清晰、更简洁的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如有一种复数类型&lt;span&gt;Complex&lt;/span&gt;，有两个坐标x和y；定义ComplexA大于ComplexB为： A的x，y中至少有一个大于B的x，y。我只需要重载&amp;gt;操作符（相应的最好重载&amp;gt;=,&amp;lt;,&amp;lt;=），以后只需要A&amp;gt;B就能代替重复啰嗦的A.x&amp;gt;B.x||A.y&amp;gt;B.y。更可喜的是，重载后的&amp;gt;,&amp;lt;这些运算符，在.Net表达式树(&lt;span&gt;ExpressionTree&lt;/span&gt;)中已经替换了它原来的语义。因此运算符重载在我这个编译器也有它用武之地。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但出于下面两个原因，它只适合作为编译引擎的辅助，而不适合单独使用：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;首先运算符重载只针对特定的类型；对于不熟悉C#语法特性的编程者，理解并正确的使用运算符重载不是件容易的事。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;运算符重载可以减少重复的代码，让语法更简洁；但依然要写C#代码，不适合大部分工控人员。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt; 订阅事件&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果想省事，最简单的办法是直接写代码，例如：如果一台电机的运行需要A,B,C三个前提条件均满足，我就分别订阅A、B、C的变量变化事件，如果A由fasle变为true，再看看其他两个变量触发没有。也就是写这样几行代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            var&lt;/span&gt; tag1 = App.Server[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tag2 = App.Server[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tag3 = App.Server[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tag1 != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; tag2 != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; tag3 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
            {
                tag1.ValueChanged &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
                  {
                      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tag1.Value.Boolean &amp;amp;&amp;amp; tag2.Value.Boolean &amp;amp;&amp;amp;&lt;span&gt; tag3.Value.Boolean)
                      {
                          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;&lt;span&gt;
                      }
                  };
                tag2.ValueChanged &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tag1.Value.Boolean &amp;amp;&amp;amp; tag2.Value.Boolean &amp;amp;&amp;amp;&lt;span&gt; tag3.Value.Boolean)
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;&lt;span&gt;
                    }
                };
                tag3.ValueChanged &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tag1.Value.Boolean &amp;amp;&amp;amp; tag2.Value.Boolean &amp;amp;&amp;amp;&lt;span&gt; tag3.Value.Boolean)
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;&lt;span&gt;
                    }
                };
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看上去不算复杂吧？如果界面上有50个动画，这样的代码就要写50次。不但浪费时间，改起来麻烦，查起来也麻烦。更糟糕的是，不懂编程的人还用不了。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; &lt;strong&gt;表达式编译器&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对于大部分零编程基础的上位机设计人员，他们需要的是一种没有学习和理解成本的、简单直观的变量绑定方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如温度计在温度高于50℃显示红色，就一句话【&lt;span&gt;temperature&amp;gt;50&lt;/span&gt;】;某设备显示报警，可能是多个报警变量其中之一触发的结果，只需写【&lt;span&gt;Alarm1||Alarm2||Alarm3&lt;/span&gt;】…借助微软强大的表达式引擎，如果能解析这类变量表达式，设计者只需要知道图元与变量的逻辑关系；而极少数表达式也难以企及的功能，略微懂一点C#就可以实现。这样就可以做到使用简单，上手容易，同时又可以满足复杂的需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时还有下面几个额外的好处：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最少的编码量：在一个界面的cs文件里，几乎没有代码。绑定逻辑在XAML内用直观的方式嵌入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/43917/201801/43917-20180129215330453-936794228.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;可以用复制、粘贴和文本替换等功能减少重复编码；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以充分利用WPF的设计器扩展，实现一个简单的语法编辑器，实现语法高亮、自动完成并执行语法检查；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;查找变量逻辑和修改很方便。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这个编译器的主要代码在Eval类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、  &lt;/strong&gt; &lt;strong&gt;自己实现一个编译器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;编译原理&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;大学计算机都有一门编译原理课程。当年我也捧着一本教材，被“波兰表达式”、“逆波兰表达式”绕的云里雾里，然而逆波兰表达式是实现编译器的关键。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逆波兰表达式的优势在于只用两种简单操作，入栈和&lt;a href=&quot;https://baike.baidu.com/item/%E5%87%BA%E6%A0%88&quot; target=&quot;_blank&quot;&gt;出栈&lt;/a&gt;就可以搞定任何普通表达式的运算。其运算方式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何实现自己的编译器，微软已经给大家现成的轮子了。微软的&lt;span&gt;Expression&lt;/span&gt;类提供了一套拼接、编译Lambda表达式的完整方法，可以用它轻松定义你自己的语法。相关知识可以参考博客园 装配脑袋的&lt;a href=&quot;http://www.cnblogs.com/Ninputer/archive/2011/06/18/2084383.html&quot;&gt;自己动手开发编译器&lt;/a&gt;系列文章：&lt;a href=&quot;http://www.cnblogs.com/Ninputer/archive/2011/06/18/2084383.html&quot;&gt;http://www.cnblogs.com/Ninputer/archive/2011/06/18/2084383.html&lt;/a&gt;。下面就以这个SCADA项目为例：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;定义语法&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在这一版，我只实现了最基本最常用的一些操作，如四则运算（+-*/）、逻辑运算(&amp;amp;|!)、取反取模、三目条件等运算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;GetOperatorLevel&lt;/span&gt;函数按照C#的运算符优先级定义运算优先级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义了@开头的自定义函数如@Date取当前日期、@App取当前路径等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;IsConstant&lt;/span&gt;方法定义系统常数，其中True/False表示逻辑常量，字符串常量用’’。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;编译过程&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;编译过程就是将一个字符串转换为一个带返回值的函数；函数的参数就是表达式相关的Tag的值。依次为：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;RpnExpression&lt;/span&gt;方法：将中缀表达式转换为逆波兰表达式。用关键字将表达式字符串分割为一个数组；按照优先级出栈入栈；返回一个逆波兰表达式顺序的字符串列表。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;ComplieRpnExp&lt;/span&gt;方法：根据逆波兰表达式顺序，依次弹出运算符转换为Expression的各子类如二元表达式&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.linq.expressions.binaryexpression.aspx&quot;&gt;BinaryExpression&lt;/a&gt;、条件表达式&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.linq.expressions.conditionalexpression.aspx&quot;&gt;ConditionalExpression&lt;/a&gt;、常数表达式&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.linq.expressions.constantexpression.aspx&quot;&gt;ConstantExpression&lt;/a&gt;等；参数首先判断是否常数，如果不是，则调用GetTagExpression方法，将字符串转换为方法调用&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.linq.expressions.methodcallexpression.aspx&quot;&gt;MethodCallExpression&lt;/a&gt;，最终会将该参数编译为一个Tag。经过处理最终返回一个&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.linq.expressions.lambdaexpression.aspx&quot;&gt;LambdaExpression&lt;/a&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;Eval&lt;/span&gt;方法将&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.linq.expressions.lambdaexpression.aspx&quot;&gt;LambdaExpression&lt;/a&gt;编译为一个委托；相关的Tag加入列表TagList。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、  &lt;/strong&gt; &lt;strong&gt;应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;  表达式与动画绑定&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在每一个界面窗体都有几乎一样的几行代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
       List&amp;lt;TagNodeHandle&amp;gt;&lt;span&gt; _valueChangedList;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HMI_Loaded(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
            {
                _valueChangedList &lt;/span&gt;=&lt;span&gt; cvs1.BindingToServer(App.Server);
            }
        }
 
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HMI_Unloaded(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
            {
               App.Server.RemoveHandles(_valueChangedList);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;其中, &lt;span&gt;BindingToServer&lt;/span&gt;就是对当前界面所有图元进行地毯式扫描，搜索出各控件相关的TagReadText表达式并用Eval类编译之；编译的结果转换为带返回值的函数和一个相关Tag的列表；遍历这个Tag列表，将其值变化事件ValueChanged与这个函数链接起来。这样，在加载界面的时候已经完成了编译过程，相关变量的值一旦改变，就会根据表达式返回一个值，如果这个值是布尔量，同时与电机的运行动画绑定，就完成了从表达式到动画的触发过程。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;  复杂报警条件&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;报警一般包括超限报警、变量触发报警、差值报警等。但也可能有复杂的报警条件，不能用超限、超差等简单方式表述的，就可以归结为复杂报警，其条件可以用类似动画绑定的表达式来描述，在系统初始化时刻加载、编译为报警条件。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt; 未来改进&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;编辑器改进：支持命令自动完成、语法高亮、更完善的语法检查。可考虑Sharpdevelop的编辑控件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持复杂语法：目前的语法仅仅是简单的四则运算和逻辑表达式。未来考虑支持多段表达式、函数（如正余弦）、属性引用等复杂语法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、  &lt;/strong&gt; &lt;strong&gt;下面的计划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写一系列帖子，把架构、原理讲清楚。大致如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;github地址：&lt;a href=&quot;https://github.com/GavinYellow/SharpSCADA&quot; target=&quot;_blank&quot;&gt;https://github.com/GavinYellow/SharpSCADA&lt;/a&gt;。QQ群：102486275&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jan 2018 14:13:00 +0000</pubDate>
<dc:creator>老坏猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evilcat/p/8379640.html</dc:identifier>
</item>
<item>
<title>我的2017——求职篇（二） - codingHeart</title>
<link>http://www.cnblogs.com/codingHeart/p/8370229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingHeart/p/8370229.html</guid>
<description>&lt;p&gt;　　既然主观上已经不考虑7k的offer了，那就也没什么好留恋的了（其实人有时候还是会犯贱 去想....），又开始了app刷招聘信息投简历了（不禁想起了以前暑假的时候，找个洗碗端菜之类的简兼职要满城市的走着一家家的问，找了几天，腿都要走断了，人快热晕了 也找不到的情景，现在是真的幸福）。因为前一个offer来得顺风顺水，这次再刷的时候心情要好不少，几乎没什么压力，所以投简历的时候一度头脑发热投了不少10K+的，当时没怎么意识到，就我的简历写的，根本不可能的好么，这直接导致后面连续接近一个星期，没有任何音讯。&lt;/p&gt;
&lt;p&gt;　　然而那时候的我，前几天人依旧活在梦里，饿了就吃、醒着就玩、困了就睡，从不耽搁，自己说好的要复习，倒是也会偶尔看两眼前端面试的东西 -- 来减轻负罪感（以便玩得更high，哎，无可救药了），丝毫没有紧迫感。等到了第二周的周一，距离上次收到面试邀请已经五天了，一个消息都没有！这下淡定不了了，我朋友都有点替我急了，让我多下两个app投。没办法，只能这样咯，于是又注册两个，再填两次个人简历（填的人都毛躁了，特别是项目经验什么的，一栏一栏的，复制都很烦心），于是又开始了熬夜求职之旅。人都是在看招聘信息时候睡着的。&lt;/p&gt;
&lt;p&gt;　　第二天醒来，依旧没有消息，只有接着刷了，其实大部分都已经投过了。终于，下午来了个电话，问我什么时间方便过去面试的，于是定在了后天也就是周四的上午。这一口气松的，真是及时雨啊，感觉人都快崩溃了，玩游戏都能分心的。。后面翻app记录的时候，好像自己并没有投过这家的，怎么就被通知面试了呢，查了下公司地址，还有点偏。朋友下班回来知道后也跟我说多留点心，然后晚上又看到一条 某男子找工作被拐的新闻...，心里有点怕怕的。&lt;/p&gt;
&lt;p&gt;　　周三，天气不错，在外边晃悠的时候，手机又来了条推送，幸福来的有点突然啊，嗯，面试又来了，又是约周四10点，我只能回消息说，明天上午有点事儿，看能不能换个时间咯，商量了几个时间后，我很自然的选了第二天下午，毕竟早上早起坐两个小时的车对我来说太折磨人了。于是，周四就有两场面试等着我了，这次人总算 知道静下心来 花点时间 温习下 一些基础的知识。&lt;/p&gt;
&lt;p&gt;　　周四一大早，仓促吃了碗路边两块钱的米粉（之后再也没见过这么便宜的早餐了）便开始朝第一家奔去了，这次知道带笔和到路边店里打印份简历了，哈哈。等到了那边，很意想不到，这么偏的地方居然还有这么漂亮的高楼，可能是旁边的楼都太破旧、低矮了吧，这写字楼显得格外别致。所以一开始，印象还不错。进去之后，感觉一二层像是商场，不像个办公的地方。人在里面绕半天不知道从哪上去，只好找人问路，应该是有点绕了，他也说不清楚，最后还是得靠自己找。还好找到的时候不算太晚。进去后，前台妹子很冰冷。。。。但长得有点肉肉，看着也还算亲切，先让我填了份表格，直接拿一套题 带我去了一个小办公间，让我把题先做下，到里面的时候 发现那里已经坐了一个了，正在答题，好像跟我做的还是同一套题，两个人就默默的各自笔试了 。大致浏览了下全部的题，第一时间 我有点震惊了，这特么和我前一家公司校招我的时候的题是真的像啊。然而，我已经不是那时的我了，大学刚毕业的我 对接口，抽象类，继承原理这些东西还算是比较熟的，毕竟那时候离大二学C++的隔着不是很久，很多东西都是有印象的，可现在，在前一家公司根本不沾边啊，基本没复习过，sql什么的还好写了点，不然估计也gg。没办法，那就硬着头皮做吧，做完选择题后，尴尬的事情又来了，笔试是带笔了，等要写代码的时候，发现没有带草稿纸...，我只好在试卷的顶部空白处打草稿了，这时候对面那哥们居然很体贴的把他的草稿纸给我用（看样子是时刻关注着的我呀还）。。。他没过一会儿，就拨号喊客服交答案了。于是，接下来就是，他看着我做题。我这个人真是有人盯着 我一句代码写不出来，然后，在他看我的几分钟里，我的冒泡算法是一行代码都没写完，这哥们真的是服务到位啊，看了眼外边，开始口头教我实现了，我感觉如果草稿纸在他那里，他应该会把答案写出来给我（这世界这么有爱的么）。其实那时候我 正想冒泡 在后面已经开始有序的情况下 怎么提前结束。看他这么热心，我也不好意思辜负，于是按他的思路把最原始的代码写了出来。&lt;/p&gt;
&lt;p&gt;　　他不久也被喊出去面试了，面完试后，居然还记得回来找我要草稿纸的（是我估计翻篇，早忘了）。&lt;/p&gt;
&lt;p&gt;　　我一会儿也勉强做完了，很折磨人，因为考的东西都是曾经很用心学过的，放在三年前，这种大学试卷类型的笔试题，分分钟解决，然而现在...哎，不禁感慨啊。&lt;/p&gt;
&lt;p&gt;　　我也懒得检查什么的了，感觉早点解放也好，一做完就交了。&lt;/p&gt;
&lt;p&gt;　　于是，我人生中最疯狂的一次面试悄然开启，为什么用疯狂来形容，等会就知道了，我真没有碰到比这还疯狂的事儿了。&lt;/p&gt;
&lt;p&gt;　　被带到了另一间会议室，会议室里有一台大屏，看样子是要机试啊，对我这个实战大菜逼来说，心里难以控制的心慌。我坐下后不一会儿就来了个很接地气的面试管，比较年轻，很程序员（拖鞋眼镜油头）。第一句话好像是说我笔试题做的还可以。。。（其实我还真不知道可不可以，好些题是真的靠蒙，既然你说可以那就可以好了）。于是翻起我的简历，问我 “会前端是吧”，我第一时间还没去接话，这没法接啊，心里还在想 会前端是个什么概念呢，我了解但也没用过mvvm，webpack之类的东西啊，算会么。他见我没回答，眼光由简历专向了我，我半点不点的上下动了下头。。。于是&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;前方高能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   “这样吧，你帮我把这个弄到上面去”，说着把鼠标指向了一个悬浮在页面底部的按钮，然后鼠标和键盘都移到我面前。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好吧，可能这只是循序渐进，我心里当时还觉得这个面试官挺有心的，知道由简到难，一步步引导我们这些新手。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　于是，一两分钟吧，f12找到了css，去掉了bottom：*px 样式。至于为什么用了这么久，这里得解释下，前端在我的脑子里可能js偏多，刚刚心里还在叨念js 前端的mvvm框架呢，于是有半分钟是在想找id之类的通过js实现。后面马上反应过来了，就直接改css了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后，我说我弄好了的时候他还在看我简历，抬头说“好了？”，看样子，他是准备给10分钟 让我我搞定的....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　检查之后，表示很满意，于是鼠标指着一个有颜色的文字块  “你帮我把这个颜色的弄掉”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我。。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好吧，可能是想让我热热身。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接过键盘，找到颜色块，去掉background-color，这次一分钟解决。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“这么快？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我。。。。。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“哦，我的意思是把这个文字块都去掉”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我知道我可能理解错他意思了，立马接过鼠标加了个display none，半分钟吧（后面想想，其实有更快的方法~）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&quot;嗯，很好&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我。。。。。。。。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“你js怎么样的”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“还可以。”这个我还是有点底气的，毕竟js高程基础部分之前翻了几遍（其实是因为前面的问题简单地让我有自信了。。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“那我找段代码，你给我说说吧”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我这时候心理活动又来了了：不应该问js 的原型，闭包，对象，继承，this这些么，找段代码是个什么情况。。。我特么实战经验不行啊，完了完了~~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　于是，随便在页面里找了段代码让我说说在干什么。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　运气不错，代码里的单词基本都认识，Navigator，firefox，dialog，再加一点js基础和浏览器兼容的概念，于是，很顺畅的说完了这个代码段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&quot;很好很好，你前端很不错啊&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;我。。。。。。。。。。。。。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好吧，我还是笑一下吧，毕竟在夸我，不笑显得气氛有点尴尬。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后面再问了一下我关于 多人操作资源不同步的问题，我只记得读书学java的时候有说过种情况下得加锁，于是耿直的说了两个字 “加锁”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“怎么加呢”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后面我也不知道怎么混过去的，他直接改问我 有没有其他的方法了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个我是真的没做过啊，想了半天，突然意识到好像之前的老项目里有一种我当时很鄙视的方法，可以解决这个问题。当时是为了防止多个用户同时操作一个记录，每当用户进入一个记录编辑页面，就专门有个表来记住这个记录当前被哪个用户编辑的信息，从而防止多用户同时编辑。于是，我抱着试一试的心态，说了下思路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“嗯嗯，确实，这个方法用得多点”他看着我，点了几下头，看得出来，他对我应该时相当满意了。于时起身去喊经理了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来，就是闲聊了，经理最后的时候 问了我一下存储过程。。。好郁闷，我特么又没怎么用过，曾经花了一个晚上学习过，然而几乎忘光了。。勉强能接接话那种，比小白要好那么一丢丢吧（起码我知道有这个东西，是干嘛的，大概有什么好处和不好的，当然都是理论派。。。。），幸运的是，好像这个不是太重要，经理也没太在意。后半段聊的时候不知道怎么聊到了前面那个一起笔试的仁兄，结果经理说他技术不行。。我，，有些事儿真奇妙哈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于人事上午不在，下午有点晚才回得来，所以我就说先回去了，对了，之前有填一个基本情况表，我填了期望薪资8.5k，这个经理应该是有看到的，也就是说他对我的薪资要求是接受了的，于是乎，我就确认性的试探了下：“那个，薪资方面的情况..”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“那个到时候你跟人事谈吧，我觉得是没问题的”我话没说完，经理直接给了我答案 ，当然也是我想要的答案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　于是很愉快的就离开了，准备奔赴下一个面试，一个让我有重回校园感觉的地方。&lt;/p&gt;
&lt;p&gt;　　待续。。。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jan 2018 14:07:00 +0000</pubDate>
<dc:creator>codingHeart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingHeart/p/8370229.html</dc:identifier>
</item>
<item>
<title>发送邮件那些事 - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/8379669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/8379669.html</guid>
<description>&lt;h2 id=&quot;邮件历史&quot;&gt;邮件历史&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;世界的第一封电子邮件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1969年10月世界上的第一封电子邮件是由计算机科学家Leonard K.教授发给他的同事的一条简短消息。&lt;/p&gt;
&lt;p&gt;据《互联网周刊》报道世界上的第一封电子邮件是由计算机科学家Leonard K.教授发给他的同事的一条简短消息(时间应该是1969年10月)，这条消息只有两个字母：&quot;LO&quot;。Leonard K.教授因此被称为电子邮件之父。所以第一条网上信息就是‘LO’，意思是‘你好！’”&lt;/p&gt;
&lt;p&gt;当然这个说法也有一点争议，另外一种说法是麻省理工学院博士Ray Tomlinson发送的第一封邮件，这里不再展开讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中国的第一封电子邮件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1987年9月14日中国第一封电子邮件是由“德国互联网之父”维纳·措恩与王运丰在当时的兵器工业部下属单位—计算机应用技术研究所(简称ICA)发往德国卡尔斯鲁厄大学的，其内容为德文和英文双语，第一段大意如下：&lt;/p&gt;
&lt;p&gt;原文：&lt;em&gt;“ Across the Great Wall we can reach every corner in the world. ”&lt;/em&gt;&lt;br/&gt;中文大意：&lt;em&gt;“ 越过长城，我们可以到达世界的每一个角落。 ”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这是中国通过北京与德国卡尔斯鲁厄大学之间的网络连接，发出的第一封电子邮件。&lt;strong&gt;现在看这封邮件内容，颇具深意呀！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电子邮件的发展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然电子邮件是在70年代发明的，它却是在80年才开始有人用，70年代的沉寂主要是由于当时使用Arpanet网络的人太少，网络的速度也仅为目前56Kbps标准速度的二十分之一。受网络速度的限制，那时的用户只能发送些简短的信息，根本别想象现在那样发送大量照片。&lt;/p&gt;
&lt;p&gt;到80年代中期，个人电脑兴起，电子邮件开始在电脑迷以及大学生中广泛传播开来；到90年代中期，互联网浏览器诞生，全球网民人数激增，电子邮件被广为使用。2000零几年的时候，那时候没有网盘，上大学的时候常常使用邮箱存储东西，那时候的邮箱也主要以网易为主；到了现在，几乎每个人都有好几个邮箱，QQ邮箱、126邮箱、公司邮箱。&lt;/p&gt;
&lt;h2 id=&quot;邮件协议&quot;&gt;邮件协议&lt;/h2&gt;
&lt;p&gt;发送邮件的本质是将一个人的信息传输给另外一个人，那么如何传输就需要商量好标准，这些标准就是协议。最初只有两个协议：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SMTP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。它的一个重要特点是它能够在传送中接力传送邮件，即邮件可以通过不同网络上的主机接力式传送。&lt;/p&gt;
&lt;p&gt;SMTP 认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SMTP主要负责底层的邮件系统如何将邮件从一台机器传至另外一台机器。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;POP3协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件。&lt;/p&gt;
&lt;p&gt;POP 协议支持“离线”邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是 PC机或 MAC。一旦邮件发送到 PC 机或 MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SMTP和POP3是最初的俩个协议，随着邮件的不断发展后来又增加了两个协议：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IMAP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全称 Internet Mail Access Protocol（交互式邮件存取协议），IMAP是斯坦福大学在1986年开发的研发的一种邮件获取协议，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。&lt;/p&gt;
&lt;p&gt;IMAP的一个与POP3的区别是：IMAP它只下载邮件的主题，并不是把所有的邮件内容都下载下来，而是你邮箱当中还保留着邮件的副本，没有把你原邮箱中的邮件删除，你用邮件客户软件阅读邮件时才下载邮件的内容。较好支持这两种协议的邮件客户端有：ThunderMail,Foxmail,outlook等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mime协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于SMTP这个协议开始是基于纯ASCⅡ文本的，在二进制文件上处理得并不好。后来开发了用来编码二进制文件的标准，如MIME，以使其通过SMTP来传输。今天，大多数SMTP服务器都支持8位MIME扩展，它使二进制文件的传输变得几乎和纯文本一样简单。&lt;/p&gt;
&lt;h2 id=&quot;邮件发送流程&quot;&gt;邮件发送流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2018/springboot/mail-process.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发信人在用户代理上编辑邮件，并写清楚收件人的邮箱地址；&lt;/li&gt;
&lt;li&gt;用户代理根据发信人编辑的信息，生成一封符合邮件格式的邮件；&lt;/li&gt;
&lt;li&gt;用户代理把邮件发送到发信人的的邮件服务器上，邮件服务器上面有一个缓冲队列，发送到邮件服务器上面的邮件都会加入到缓冲队列中，等待邮件服务器上的SMTP客户端进行发送；&lt;/li&gt;
&lt;li&gt;发信人的邮件服务器使用SMTP协议把这封邮件发送到收件人的邮件服务器上&lt;/li&gt;
&lt;li&gt;收件人的邮件服务器收到邮件后，把这封邮件放到收件人在这个服务器上的信箱中；&lt;/li&gt;
&lt;li&gt;收件人使用用户代理来收取邮件。首先用户代理使用POP3协议来连接收件人所在的邮件服务器，身份验证成功后，用户代理就可以把邮件服务器上面的收件人邮箱里面的邮件读取出来，并展示给收件人。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java和邮件&quot;&gt;Java和邮件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;JavaMail&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最早期使用Java Mail进行发送邮件&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.util.*;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import javax.mail.*;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import javax.mail.internet.*;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import javax.activation.*;&lt;/span&gt;
 
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SendEmail{
   &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String [] args){   
      &lt;span class=&quot;co&quot;&gt;// 收件人电子邮箱&lt;/span&gt;
      String to = &lt;span class=&quot;st&quot;&gt;&quot;ityouknow@gmail.com&quot;&lt;/span&gt;;
      &lt;span class=&quot;co&quot;&gt;// 发件人电子邮箱&lt;/span&gt;
      String from = &lt;span class=&quot;st&quot;&gt;&quot;webMail@gmail.com&quot;&lt;/span&gt;;
      &lt;span class=&quot;co&quot;&gt;// 指定发送邮件的主机为 localhost&lt;/span&gt;
      String host = &lt;span class=&quot;st&quot;&gt;&quot;localhost&quot;&lt;/span&gt;;
      &lt;span class=&quot;co&quot;&gt;// 获取系统属性&lt;/span&gt;
      Properties properties = System.&lt;span class=&quot;fu&quot;&gt;getProperties&lt;/span&gt;();
      &lt;span class=&quot;co&quot;&gt;// 设置邮件服务器&lt;/span&gt;
      properties.&lt;span class=&quot;fu&quot;&gt;setProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;mail.smtp.host&quot;&lt;/span&gt;, host);
      &lt;span class=&quot;co&quot;&gt;// 获取默认session对象&lt;/span&gt;
      Session session = Session.&lt;span class=&quot;fu&quot;&gt;getDefaultInstance&lt;/span&gt;(properties);
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;{
         &lt;span class=&quot;co&quot;&gt;// 创建默认的 MimeMessage 对象&lt;/span&gt;
         MimeMessage message = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MimeMessage&lt;/span&gt;(session);
         &lt;span class=&quot;co&quot;&gt;// Set From: 头部头字段&lt;/span&gt;
         message.&lt;span class=&quot;fu&quot;&gt;setFrom&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;InternetAddress&lt;/span&gt;(from));
         &lt;span class=&quot;co&quot;&gt;// Set To: 头部头字段&lt;/span&gt;
         message.&lt;span class=&quot;fu&quot;&gt;addRecipient&lt;/span&gt;(Message.&lt;span class=&quot;fu&quot;&gt;RecipientType&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;TO&lt;/span&gt;,&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;InternetAddress&lt;/span&gt;(to));
         &lt;span class=&quot;co&quot;&gt;// Set Subject: 头部头字段&lt;/span&gt;
         message.&lt;span class=&quot;fu&quot;&gt;setSubject&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;This is the Subject Line!&quot;&lt;/span&gt;);
         &lt;span class=&quot;co&quot;&gt;// 设置消息体&lt;/span&gt;
         message.&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;This is actual message&quot;&lt;/span&gt;);
         &lt;span class=&quot;co&quot;&gt;// 发送消息&lt;/span&gt;
         Transport.&lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(message);
         System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Sent message successfully....&quot;&lt;/span&gt;);
      }&lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (MessagingException mex) {
         mex.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在后来有了Spring，一切变的更简单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Mail&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;simpleSend&lt;/span&gt;() {
    &lt;span class=&quot;co&quot;&gt;// 构建简单邮件对象，见名知意&lt;/span&gt;
    SimpleMailMessage smm = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SimpleMailMessage&lt;/span&gt;();
    &lt;span class=&quot;co&quot;&gt;// 设定邮件参数&lt;/span&gt;
    smm.&lt;span class=&quot;fu&quot;&gt;setFrom&lt;/span&gt;(mailSender.&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;());
    smm.&lt;span class=&quot;fu&quot;&gt;setTo&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ityouknow@126.com&quot;&lt;/span&gt;);
    smm.&lt;span class=&quot;fu&quot;&gt;setSubject&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;);
    smm.&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Hello world via spring mail sender&quot;&lt;/span&gt;);
    &lt;span class=&quot;co&quot;&gt;// 发送邮件&lt;/span&gt;
    mailSender.&lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(smm);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;貌似几句就搞定了，可以看出Spring的力量还是很强大的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot And Mail&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再到了后来，Spring Boot就出现了，更加简单了邮件发送的步骤，想了解如何使用Spring Boot发送邮件看这里：&lt;a href=&quot;http://www.ityouknow.com/springboot/2017/05/06/springboot-mail.html&quot;&gt;springboot(十)：邮件服务&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/xiaoxiangfeizi/archive/2012/04/17/2453026.html&quot;&gt;邮件发送的原理&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jan 2018 13:56:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ityouknow/p/8379669.html</dc:identifier>
</item>
<item>
<title>统计信息自动收集任务失效原因排查 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/8379315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/8379315.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;Oracle 11.2.0.3 RAC&lt;br/&gt;&lt;strong&gt;问题：&lt;/strong&gt;统计信息自动收集任务失效原因排查&lt;/p&gt;

&lt;p&gt;查看自动任务的状态，确认是enabled状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; select client_name,status from dba_autotask_client;

CLIENT_NAME                                                      STATUS
---------------------------------------------------------------- --------
auto optimizer stats collection                                  ENABLED
auto space advisor                                               ENABLED
sql tuning advisor                                               ENABLED

Elapsed: 00:01:03.88&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说，这样的结果，就意味着统计信息自动收集是打开的，如今却是没有自动收集。说明确实是有故障，需要进一步深入排查。&lt;br/&gt;若对这些自动任务的状态不理解可以参考之前文章：&lt;/p&gt;

&lt;p&gt;根据 Why Auto Optimizer Statistics Collection May Appear to be &quot;Stuck&quot; and Not Running? (文档 ID 1320246.1)&lt;/p&gt;
&lt;p&gt;排查以下项：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;The 'auto optimizer stats collection' task is enabled in auto task&lt;br/&gt;STATISTICS_LEVEL has already been set to TYPICAL or FULL&lt;br/&gt;dba_autotask_client_history is empty&lt;br/&gt;Statistics on tables are stale.&lt;br/&gt;Some scheduler window is active and LAST_START_DATE is several days ago.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体操作记录如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--STATISTICS_LEVEL：
SQL&amp;gt; show parameter STATISTICS_LEVEL 

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
statistics_level                     string      TYPICAL

--dba_autotask_client_history is empty：
SQL&amp;gt; select * from dba_autotask_client_history;

no rows selected

Elapsed: 00:01:04.79

--Some scheduler window is active and LAST_START_DATE 是20-SEP-12 10.00.00.010777 PM
SELECT window_name, last_start_date, enabled, active FROM dba_scheduler_windows;
SQL&amp;gt; SELECT window_name ,
  2  last_start_date,
  3  enabled ,
  4  active
  5  FROM dba_scheduler_windows;

WINDOW_NAME                    LAST_START_DATE                                                             ENABL ACTIV
------------------------------ --------------------------------------------------------------------------- ----- -----
MONDAY_WINDOW                  22-JAN-18 10.00.00.014299 PM PRC                                            TRUE  FALSE
TUESDAY_WINDOW                 23-JAN-18 10.00.01.076798 PM PRC                                            TRUE  FALSE
WEDNESDAY_WINDOW               24-JAN-18 10.00.00.055066 PM PRC                                            TRUE  FALSE
THURSDAY_WINDOW                20-SEP-12 10.00.00.010777 PM PRC                                            TRUE  TRUE
FRIDAY_WINDOW                  26-JAN-18 10.00.00.725176 PM PRC                                            TRUE  FALSE
SATURDAY_WINDOW                27-JAN-18 06.00.00.010751 AM PRC                                            TRUE  FALSE
SUNDAY_WINDOW                  28-JAN-18 06.00.00.593207 AM PRC                                            TRUE  FALSE
WEEKNIGHT_WINDOW                                                                                           FALSE FALSE
WEEKEND_WINDOW                                                                                             FALSE FALSE

9 rows selected.

Elapsed: 00:00:00.01&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，如今的环境确实完全匹配文档列出的这些特征项。&lt;br/&gt;另外，看下统计信息自动收集任务的WINDOW_GROUP以及对应的MEMBER_NAME：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; select client_name,window_group
  2  from DBA_AUTOTASK_CLIENT
  3  where client_name = 'auto optimizer stats collection';

CLIENT_NAME                                                      WINDOW_GROUP
---------------------------------------------------------------- ----------------------------------------------------------------
auto optimizer stats collection                                  ORA$AT_WGRP_OS

Elapsed: 00:01:05.39
SQL&amp;gt; SELECT * FROM dba_scheduler_group_members
  2  where group_name='ORA$AT_WGRP_OS';

OWNER                          GROUP_NAME                     MEMBER_NAME
------------------------------ ------------------------------ -----------------------------------------------------------------------------------------------------------------------------------
SYS                            ORA$AT_WGRP_OS                 &quot;SYS&quot;.&quot;MONDAY_WINDOW&quot;
SYS                            ORA$AT_WGRP_OS                 &quot;SYS&quot;.&quot;TUESDAY_WINDOW&quot;
SYS                            ORA$AT_WGRP_OS                 &quot;SYS&quot;.&quot;WEDNESDAY_WINDOW&quot;
SYS                            ORA$AT_WGRP_OS                 &quot;SYS&quot;.&quot;THURSDAY_WINDOW&quot;
SYS                            ORA$AT_WGRP_OS                 &quot;SYS&quot;.&quot;FRIDAY_WINDOW&quot;
SYS                            ORA$AT_WGRP_OS                 &quot;SYS&quot;.&quot;SATURDAY_WINDOW&quot;
SYS                            ORA$AT_WGRP_OS                 &quot;SYS&quot;.&quot;SUNDAY_WINDOW&quot;

7 rows selected.

Elapsed: 00:00:00.04&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，正常应该是一周7天都有的，但是由于THURSDAY_WINDOW 的窗口ACTIVE是TRUE，导致2012年9月27号（周四）统计信息收集失败。根据MOS描述，会影响其后的窗口都打开失败，进而导致之后所有自动任务的执行都失败。&lt;br/&gt;我实际在我的测试环境验证也是如此，现象如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; SELECT window_name, last_start_date, enabled, active FROM dba_scheduler_windows;

WINDOW_NAME                                                  LAST_START_DATE                                                             ENABLED    ACTIVE
------------------------------------------------------------ --------------------------------------------------------------------------- ---------- ----------
MONDAY_WINDOW                                                22-JAN-18 10.00.00.011111 PM EST5EDT                                        TRUE       FALSE
TUESDAY_WINDOW                                               23-JAN-18 10.22.54.068776 PM EST5EDT                                        TRUE       FALSE
WEDNESDAY_WINDOW                                             24-JAN-18 10.00.00.005654 PM EST5EDT                                        TRUE       FALSE
THURSDAY_WINDOW                                              25-JAN-18 10.00.00.009885 PM EST5EDT                                        TRUE       FALSE
FRIDAY_WINDOW                                                26-JAN-18 10.00.00.010077 PM EST5EDT                                        TRUE       FALSE
SATURDAY_WINDOW                                              27-JAN-18 05.00.00.004156 PM EST5EDT                                        TRUE       FALSE
SUNDAY_WINDOW                                                28-JAN-18 01.00.00.010044 PM EST5EDT                                        TRUE       TRUE
WEEKNIGHT_WINDOW                                                                                                                         FALSE      FALSE
WEEKEND_WINDOW                                                                                                                           FALSE      FALSE

9 rows selected.

SQL&amp;gt; EXECUTE DBMS_SCHEDULER.OPEN_WINDOW ('MONDAY_WINDOW','');
BEGIN DBMS_SCHEDULER.OPEN_WINDOW ('MONDAY_WINDOW',''); END;

*
ERROR at line 1:
ORA-27480: window &quot;SUNDAY_WINDOW&quot; is currently open
ORA-06512: at &quot;SYS.DBMS_ISCHED&quot;, line 493
ORA-06512: at &quot;SYS.DBMS_SCHEDULER&quot;, line 1220
ORA-06512: at line 1


SQL&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我测试环境，因为周日的窗口已经是ACTIVE，再尝试打开周一的窗口就会报错，看起来同时就只能有一个窗口ACTIVE，这与MOS的描述也完全一致。&lt;/p&gt;

&lt;p&gt;根据MOS解决建议手工关闭活动的窗口，我这里就是关闭THURSDAY_WINDOW窗口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; EXECUTE DBMS_SCHEDULER.CLOSE_WINDOW ('THURSDAY_WINDOW');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.14&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次查询状态，确认窗口状态已关闭：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; SELECT window_name ,
  2  last_start_date,
  3  enabled ,
  4  active
  5  FROM dba_scheduler_windows;

WINDOW_NAME                    LAST_START_DATE                                                             ENABL ACTIV
------------------------------ --------------------------------------------------------------------------- ----- -----
MONDAY_WINDOW                  22-JAN-18 10.00.00.014299 PM PRC                                            TRUE  FALSE
TUESDAY_WINDOW                 23-JAN-18 10.00.01.076798 PM PRC                                            TRUE  FALSE
WEDNESDAY_WINDOW               24-JAN-18 10.00.00.055066 PM PRC                                            TRUE  FALSE
THURSDAY_WINDOW                20-SEP-12 10.00.00.010777 PM PRC                                            TRUE  FALSE
FRIDAY_WINDOW                  26-JAN-18 10.00.00.725176 PM PRC                                            TRUE  FALSE
SATURDAY_WINDOW                27-JAN-18 06.00.00.010751 AM PRC                                            TRUE  FALSE
SUNDAY_WINDOW                  28-JAN-18 06.00.00.593207 AM PRC                                            TRUE  FALSE
WEEKNIGHT_WINDOW                                                                                           FALSE FALSE
WEEKEND_WINDOW                                                                                             FALSE FALSE

9 rows selected.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就找到了问题，另外因为离统计信息信息自动收集关闭已有多年，目前生产环境运行平稳，所以最终决定保守处理，即：先将生产环境的自动任务都关闭，等在备库测试验证后再考虑生产环境开启自动任务。&lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Why Auto Optimizer Statistics Collection May Appear to be &quot;Stuck&quot; and Not Running? (文档 ID 1320246.1)&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 29 Jan 2018 12:26:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/8379315.html</dc:identifier>
</item>
<item>
<title>-------- ROOTKIT 核心技术——系统服务调度表挂钩调试（PART III） -------- - f1yin9_0x5hark</title>
<link>http://www.cnblogs.com/flying-shark/p/8379345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-shark/p/8379345.html</guid>
<description>&lt;p&gt;————————————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇开始进行真枪实弹的调试，本文的最后会附上完整的源码包，方便各位在自己的机器上演练。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果安装了 Windows Driver Kits，在“开始”-&amp;gt;“所有程序”中选择类似“WDK 7600.16385.1”的项目。具体的数字取决于你&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装的 WDK 开发环境版本而定。然后选择“Build Environments”下面的操作系统版本，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;亦即你编译出来的驱动要运行其上的 OS 版本，接着选择&lt;span&gt;硬件平台体系结构&lt;/span&gt;与&lt;span&gt;构建类型&lt;/span&gt;，比如“x86 Checked Build&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Environment”是用于 32 位平台，且附带生成包含调试符号文件的构建环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调试符号文件有助于调试器显示驱动二进制文件中的函数，变量，常量名称等信息，生成人性化的输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样会创建一个特殊的 cmd.exe 进程，它的环境变量预配置好了各种构建相关的参数，比如头文件，库文件的位置；编译器，汇编&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;器，链接器程序所在路径。。。等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在该 cmd 窗口中切换到源码包的解压目录，然后执行如下命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;build /D /g /b /B /e /F /S /s /$ /why /v /w /y&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些指定的参数让你能查看详细的构建过程，比如预处理器解析头文件的嵌套包含过程，给出可能的警告或错误提示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是一个样例输出，对于排除过程中出现的问题很有用：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
D:\kmdsource_use_mdl_mapping_ssdt&amp;gt;build  /D /g /b /B /e /F /S /s /$ /why /v /&lt;span&gt;w&lt;/span&gt; /&lt;span&gt;y
BUILD: Compile and Link &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; x86
BUILD: Loading d:\winddk\&lt;/span&gt;&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\build.dat...
BUILD: Computing Include &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; dependencies:
    Scanning d:\winddk\&lt;/span&gt;&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
    Scanning d:\winddk\&lt;/span&gt;&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\ddk
BUILD: Start &lt;/span&gt;&lt;span&gt;time&lt;/span&gt;: Mon Jan &lt;span&gt;29&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;
    Scanning d:\kmdsource_use_mdl_mapping_ssdt
    Scanning d:\winddk\&lt;/span&gt;&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt
BUILD: Examining d:\kmdsource_use_mdl_mapping_ssdt directory &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; files to compile.
    d:\kmdsource_use_mdl_mapping_ssdt
Invalidating OACR warning log &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root:x86chk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;0x00000001&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c  ntddk.h                d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\ddk
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    wdm.h                d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\ddk
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      excpt.h            d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt
&lt;/span&gt;&lt;span&gt;0x00000004&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c        crtdefs.h        d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt
&lt;/span&gt;&lt;span&gt;0x00000005&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c          specstrings.h     d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c            sal_supp.h   d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c            specstrings_supp.h   d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000007&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c              sal_supp.h d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c            sal.h        d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c            specstrings_strict.h   d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000007&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c              specstrings_undef.h d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c            driverspecs.h   d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000007&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c              specstrings.h d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c            sal_supp.h   d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c            specstrings_supp.h   d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c            sal.h        d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c            specstrings_strict.h   d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c            sdv_driverspecs.h   d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      ntdef.h            d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000004&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c        ctype.h          d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt
&lt;/span&gt;&lt;span&gt;0x00000005&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c          crtdefs.h      d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt
&lt;/span&gt;&lt;span&gt;0x00000004&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c        specstrings.h       d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000004&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c        kernelspecs.h       d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000005&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c          driverspecs.h     d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000004&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c        basetsd.h        d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000004&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c        guiddef.h        d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000005&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c          &lt;span&gt;string&lt;/span&gt;.h       d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt
&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c            crtdefs.h    d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt
&lt;/span&gt;&lt;span&gt;0x00000004&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c        excpt.h          d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt
&lt;/span&gt;&lt;span&gt;0x00000004&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c        sdkddkver.h       d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      ntstatus.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      bugcodes.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      ntiologc.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      mce.h              d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\ddk
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      pshpack4.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      poppack.h          d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      guiddef.h          d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      pshpack1.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      &lt;span&gt;string&lt;/span&gt;.h           d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      dpfilter.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      ktmtypes.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      dsfhrmports.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\ddk
Compiling &lt;/span&gt;-&lt;span&gt; d:\kmdsource_use_mdl_mapping_ssdt\usemdlmappingssdt.c
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      evntrace.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
Linking Executable &lt;/span&gt;-&lt;span&gt; d:\kmdsource_use_mdl_mapping_ssdt\objchk_win7_x86\i386\UseMdlMappingSSDT.sys
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      stdarg.h           d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt
 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;% &lt;span&gt;done&lt;/span&gt;.    &lt;span&gt;0&lt;/span&gt; TLPS  Time Left: &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;  Files: &lt;span&gt;0&lt;/span&gt;  Total LLines: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;0x00000004&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c        vadefs.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt

&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      evntprov.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      devpropdef.h         d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000003&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c      clfslsn.h          d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\ddk
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    excpt.h              d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\crt
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    ntdef.h              d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    ntstatus.h           d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    bugcodes.h           d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    ntiologc.h           d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    mce.h                d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\ddk
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    pshpack4.h           d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    poppack.h            d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    guiddef.h            d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    pshpack1.h           d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\api
&lt;/span&gt;&lt;span&gt;0x00000001&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt;&lt;span&gt; usemdlmappingssdt.c  datatype.h             d:\kmdsource_use_mdl_mapping_ssdt
&lt;/span&gt;&lt;span&gt;0x00000001&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt;&lt;span&gt; usemdlmappingssdt.c  dbgmsg.h               d:\kmdsource_use_mdl_mapping_ssdt
&lt;/span&gt;&lt;span&gt;0x00000001&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt;&lt;span&gt; usemdlmappingssdt.c  ctrlcode.h             d:\kmdsource_use_mdl_mapping_ssdt
&lt;/span&gt;&lt;span&gt;0x00000001&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt;&lt;span&gt; usemdlmappingssdt.c  device.h               d:\kmdsource_use_mdl_mapping_ssdt
&lt;/span&gt;&lt;span&gt;0x00000002&lt;/span&gt;-&lt;span&gt;0x00000001&lt;/span&gt;/&lt;span&gt;0x00000001&lt;/span&gt; usemdlmappingssdt.c    ntddk.h              d:\winddk\&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\inc\ddk

Compiling usemdlmappingssdt.c because .. (&lt;/span&gt;&lt;span&gt;0x00000006&lt;/span&gt;&lt;span&gt;)
BUILD: Saving d:\winddk\&lt;/span&gt;&lt;span&gt;7600.16385&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;\build.dat...
BUILD: Compiling and Linking d:\kmdsource_use_mdl_mapping_ssdt directory
Configuring OACR &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root:x86chk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; - &amp;lt;OACR on&amp;gt;
&lt;span&gt;1&lt;/span&gt;&amp;gt;warnings &lt;span&gt;in&lt;/span&gt;&lt;span&gt; directory d:\kmdsource_use_mdl_mapping_ssdt
alSystemServicePtr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; differs in levels of indirection from &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;DWORD&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&amp;gt;d:\kmdsource_use_mdl_mapping_ssdt\usemdlmappingssdt.c(157) : warning&lt;/span&gt;
BUILD: Finish &lt;span&gt;time&lt;/span&gt;: Mon Jan &lt;span&gt;29&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;35&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;
BUILD: Done

    &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; files compiled - &lt;span&gt;2&lt;/span&gt;&lt;span&gt; Warnings
    &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; executable built

D:\kmdsource_use_mdl_mapping_ssdt&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我在前一篇文章中说过，可以忽略源码中 157 行造成的警告——rootkit 的实际效果不受该警告影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把编译出来的 UseMdlMappingSSDT.sys 拷贝到虚拟机或另一台真实机器上（&lt;span&gt;交叉编译的目标平台&lt;/span&gt;假设是 widnows 7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或  &lt;/span&gt;&lt;span&gt;Windows Server 2008），使用 &lt;/span&gt;&lt;span&gt;sc.exe 加载该驱动进入内核空间，如果一切正常，宿主机上应该会触发首个断点，位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于 &lt;/span&gt;&lt;span&gt;MapMdl() 中，如下图，注意，DbgPrint() &lt;/span&gt;&lt;span&gt;与 DBG_TRACE 宏的输出&lt;/span&gt;&lt;span&gt;信息除了可以在目标机器上用 DbgView.exe 查看外，也&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;会&lt;/span&gt;&lt;span&gt;直接输出到宿主机上调试器的控制台。我们只关心获取到的 &lt;/span&gt;&lt;span&gt;KiServiceTable 地址： 83CABF7C ；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分配出来的一个 nt!_MDL &lt;/span&gt;&lt;span&gt;结构地址：86A838A8 ；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于之前选择了“Checked Build”构建环境，现在调试器能够根据“UseMdlMappingSSDT.pdb”符号文件显示诸如 MapMdl()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之类&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;函数名称：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129194729796-2087767715.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;结合源码可知，首个断点位于 IoAllocateMdl() 调用后不远处，我们的意图是检查该调用后的一个 nt!_MDL 对象内容，前面通&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;过 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;mdl_pointer 保存的地址派上用场：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129194927046-1737532118.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如你所见，IoAllocateMdl() 分配出来的一个 MDL 总大小（头部加上其后的 PFN 数组）为 36 字节；当前的标志取值 10 进制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的 &lt;/span&gt;&lt;span&gt;8，参见前一篇博文可知，它&lt;/span&gt;&lt;span&gt;只对应 MDL_ALLOCATED_FIXED_SIZE；还记得吗，我在前一篇博文指出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;仅当 _MDL 的 MdlFlags 字段内设置了 MDL_MAPPED_TO_SYSTEM_VA 或 MDL_SOURCE_IS_NONPAGED_POOL 比特位，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MappedSystemVa 字段才是&lt;/span&gt;&lt;span&gt;有效的，因此上图中的 MappedSystemVa 字段值 0x8059d950 没有意义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你还看到， StartVa 字段值为 0x83cab000，这就是 KiServiceTable（从 0x83CABF7C 开始）所在的虚拟页起始地址，&lt;/span&gt;&lt;span&gt;注意这个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;地址是对齐在 4 KB 边界上&lt;/span&gt;&lt;span&gt;&lt;span&gt;的，因为虚拟页和物理页大小正情况下均为 4 KB&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ByteOffset 字段值为 0xf7c，亦即 KiServiceTable 的页内偏移量—— 0x83CABF7C - 0x83cab000 = 0xf7c&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ByteCount 字段值为 0x644，亦即整张 KiServiceTable 调用表（一片缓冲区）的大小—— 1064 字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在犹如醍醐灌顶的状态下，按“g”继续执行目标系统至第二个软件断点处，再次转储这个 nt!_MDL 对象内容：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129195217531-1218757426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;MdlFlags 字段值变成了 138（0x8A），对照相关的宏定义可知，这是 MDL_WRITE_OPERATION（0x80）加&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上 &lt;/span&gt;&lt;span&gt;MDL_PAGES_LOCKED（0x02）加上 &lt;/span&gt;&lt;span&gt;MDL_ALLOCATED_FIXED_SIZE（0x08）的组合，表明 MmProbeAndLockPages() 例程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把该 MDL &lt;/span&gt;&lt;span&gt;锁在物理内存中，且具有了写访问权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;继续按“g”执行目标系统至第三个软件断点处，再次转储这个 nt!_MDL 对象内容，谨记在心，此刻代表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MmGetSystemAddressForMdlSafe() &lt;/span&gt;&lt;span&gt;例程执行后的状态：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129195434578-1259349966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先，MdlFlags 字段值变成了 139（0x8B），&lt;span&gt;这表明追加了一个 MDL_MAPPED_TO_SYSTEM_VA 标志，从而使得&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;MappedSystemVa 字段值：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;0x805fbf7c 为有效，它代表把 KiServiceTable 映射到的新内核缓冲区起始地址&lt;/span&gt;，这与 eax 寄存器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（普遍用来存放函数调用的&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;&lt;span&gt;值，在此场景中由 &lt;/span&gt;&lt;span&gt;MmGetSystemAddressForMdlSafe() 返回 ）的值相符！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;细心的你可能已经发现了，“旧”缓冲与新缓冲地址的后 12 位都是“f7c”，这当然不是巧合，事实上，虚拟地址的后 12 位&lt;/span&gt;&lt;span&gt;（页&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内偏移）在地址转译阶段被&lt;/span&gt;&lt;span&gt;原封不动地与高 20 位的物理页框号结合产生物理地址！这暗示它们都映射到相同的物理地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么通过它们应该访问到同一个 KiServiceTable，如下所示，记住，当前断点是尚未 hook KiServiceTable，因此 0x39 号系统&lt;/span&gt;&lt;span&gt;服&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;务还是原来的那一个—— &lt;/span&gt;&lt;span&gt;nt!NtCompleteConnectPort() ：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129195617171-151439745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前面我说过，新映射到的内核地址通常位于驱动被载入的内核空间中，&lt;span&gt;下图否决了这一点（尽信博文不如无博文！）&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129195746984-1259040874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;你可以看到，我们的 rootkit“&lt;strong&gt;UseMdlMappingSSDT&lt;/strong&gt;”被加载到 9ff55000——9ff5c000 这片内核空间，占用 28 KB 左右的&lt;/span&gt;&lt;span&gt;内&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;核内存！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而 KiServiceTable 被映射到的 805fbf7c 内核地址显然不在其内。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上，&lt;span&gt;KiServiceTable 被映射到的 805fbf7c 内核地址属于“SystemPte 型（即系统页表条目）”内核空间&lt;/span&gt;，此类内核空间有多&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;种用途，&lt;/span&gt;&lt;span&gt;包括提供给 MDL &lt;/span&gt;&lt;span&gt;来把 SSDT/KiServiceTable 映射到此处。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;系统页表条目（PTEs）内核空间，用于动态地映射系统页面，例如 I/O 空间，内核栈，以及映射内存描述符列表（MDLs）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统 PTE 的分配者除了各种执行体/内核组件外，多数是一些加载到内核空间的设备驱动程序，其中有系统自带的，也有第三方软&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;硬件供应商开发的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它们请求在系统 PTE 区域中分配内存的目的都是与映射视图，MDLs（内存描述符列表），适配器内存映射，驱动程序映像，&lt;/span&gt;&lt;span&gt;内核&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;栈， I/O 映射等相关的，如&lt;/span&gt;&lt;span&gt;下图所示：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129200004000-1241141130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;内核空间中有多处被划分为 SystemPte 类型，我们把 KiServiceTable 映射到第一个 SystemPte 型内核空间，该区域大小为 &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;MB。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按下“g”继续执行，这会导致 MapMdl() 返回新映射的地址到 DriverEntry()，后者挂钩 nt!NtCompleteConnectPort()，&lt;/span&gt;&lt;span&gt;另一方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面，我们还可以通过计算出&lt;/span&gt;&lt;span&gt;来的 nt!_MDL 头部大小访问到其后的 PFN 数组，检查其内保存的物理页框号是否就是&lt;/span&gt;&lt;span&gt;虚拟地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;0x83CABF7C 和 0x805fbf7c 两&lt;/span&gt;&lt;span&gt;者执行地址转译后所在的物&lt;/span&gt;&lt;span&gt;理页框号，&lt;strong&gt;&lt;span&gt;它们都被转译到物理地址 0x3cabf7c&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，页框号为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;0x03cab，虚拟地址的后 12 位偏移量（0xf7c）直接拷贝到物理地址&lt;/span&gt;&lt;span&gt;的后 12 位偏移量；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;页框号&lt;/span&gt;&lt;span&gt;还&lt;/span&gt;&lt;span&gt;可以通过&lt;/span&gt;&lt;span&gt;对 pfn_array_follow_mdl 执行指针运算并解引地址处的内容得出，也是 0x03cab；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两者的区别在于，&lt;span&gt;描述虚拟地址 0x83CABF7C 的 PTE 内容设置了&lt;strong&gt;只读&lt;/strong&gt;标记；而描述虚拟地址 0x805fbf7c 的 PTE 内容&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;设置了&lt;strong&gt;可读&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;写&lt;/strong&gt;标记&lt;/span&gt;，因此通过虚拟地址 &lt;/span&gt;&lt;span&gt;0x83CABF7C 向实际的物理页写入就会蓝屏；而通过虚拟地址 0x805fbf7c &lt;/span&gt;&lt;span&gt;则可以安全写入！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129200356156-1325304595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129200411296-2021035916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;strong&gt;&lt;span&gt;访问 KiServiceTable 中的 0x39 号系统服务，已经被替换为我们的钩子例程：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129200446968-1157997645.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我提供了一个 UnMapMdl() 例程，把它注册为该 rootkit 的卸载回调，大致逻辑是，在驱动卸载时，取消映射新的&lt;/span&gt;&lt;span&gt;内核虚拟地址，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并释放 MDL 指针 ，如此&lt;/span&gt;&lt;span&gt;一来，卸载 UseMdlMappingSSDT.sys 后，既不能通过新映射的地址访问 &lt;/span&gt;&lt;span&gt;KiServiceTable，也不能通过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指针访问 nt!_MDL 结构（&lt;span&gt;但该结构确实尚未释&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;放&lt;/span&gt;）：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129200653812-1061112748.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129200545812-1731013676.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后，让我们填充前一篇博文中那张 MDL 架构图中的占位符，以便让各位能够洞察整个来龙去脉。&lt;/span&gt;&lt;span&gt;祝愿你没有被那些红红绿绿的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;箭头搞晕！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180129200834703-1787664460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;附上源码包的下载地址，欢迎反馈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://files.cnblogs.com/files/flying-shark/kmdsource_use_mdl_mapping_ssdt.rar&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 29 Jan 2018 12:20:00 +0000</pubDate>
<dc:creator>f1yin9_0x5hark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-shark/p/8379345.html</dc:identifier>
</item>
</channel>
</rss>