<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ArrayList源码阅读 - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/arraylist.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/arraylist.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;数组是我们最常用最简单的数据结构，Java里对数组做了一个简单的包装，就是ArrayList，提供自动扩容的功能。&lt;/p&gt;
&lt;h2 id=&quot;最常用法&quot;&gt;最常用法&lt;/h2&gt;
&lt;p&gt;list在我们日常代码中最为常用的做法是创建一个list，放入数据，取出数据。如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;testList&lt;/span&gt;(){
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; List&amp;lt;String&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
    list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;);
    list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt;);
    list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;);
    list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;);

    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String one = list.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; size = list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;();

    Assert.&lt;span class=&quot;fu&quot;&gt;assertEquals&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;, one);
    Assert.&lt;span class=&quot;fu&quot;&gt;assertEquals&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, size);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面，将从构造函数开始读取源码。&lt;/p&gt;
&lt;h3 id=&quot;构造器&quot;&gt;构造器&lt;/h3&gt;
&lt;p&gt;第一步，构造一个list对象&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Constructs an empty list with an initial capacity of ten.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ArrayList() {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt; = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注释写的很清楚，构造一个空list，初始化容量为10. 我们来看看这个初始值。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Shared empty array instance used for default sized empty instances. We&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * first element is added.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认大小的共享的空array实例。可以注意到这是一个static变量，也就是说所有的ArrayList对象共享这个变量。由此可以猜测，这是一个临时值。&lt;/p&gt;
&lt;p&gt;然后看我们的数据存储对象elementData.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * The array buffer into which the elements of the ArrayList are stored.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * The capacity of the ArrayList is the length of this array buffer. Any&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * will be expanded to DEFAULT_CAPACITY when the first element is added.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; Object[] elementData; &lt;span class=&quot;co&quot;&gt;// non-private to simplify nested class access&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ArrayList的容量(capacity)就是这个数组的长度。&lt;br/&gt;另外，注意修饰关键字&lt;code&gt;transient&lt;/code&gt;， 这个不常用，用来表示这个字段不可以被序列化。我们知道，ArrayList实现了&lt;code&gt;Serializable&lt;/code&gt;接口，为什么不允许序列化data呢？具体原因参加 &lt;a href=&quot;http://www.cnblogs.com/woshimrf/p/java-serialize.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/woshimrf/p/java-serialize.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;add&quot;&gt;add&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(E e) {
    &lt;span class=&quot;fu&quot;&gt;ensureCapacityInternal&lt;/span&gt;(size + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;// Increments modCount!!&lt;/span&gt;
    elementData[size++] = e;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先保证容量，然后插入数据，size数量+1.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ensureCapacityInternal&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;(DEFAULT_CAPACITY, minCapacity);
    }

    &lt;span class=&quot;fu&quot;&gt;ensureExplicitCapacity&lt;/span&gt;(minCapacity);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对空list第一次add，判断elementData是不是默认的空对象，若是空对象，计算容量。容量的计算也很有意思。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; DEFAULT_CAPACITY = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一次添加后容量就是10了，当超过10之后就肯定要扩容了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ensureExplicitCapacity&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
    modCount++;

    &lt;span class=&quot;co&quot;&gt;// overflow-conscious code&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (minCapacity - elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        &lt;span class=&quot;fu&quot;&gt;grow&lt;/span&gt;(minCapacity);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再一次看到modCount这个变量名，和HashMap一样，记载容量发生变化的次数。而扩容的阈值也相当简单，只要保证当前数量+1能够容纳就好。当数组长度不够的时候，扩容。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;grow&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
    &lt;span class=&quot;co&quot;&gt;// overflow-conscious code&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldCapacity = elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        newCapacity = minCapacity;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        newCapacity = &lt;span class=&quot;fu&quot;&gt;hugeCapacity&lt;/span&gt;(minCapacity);
    &lt;span class=&quot;co&quot;&gt;// minCapacity is usually close to size, so this is a win:&lt;/span&gt;
    elementData = Arrays.&lt;span class=&quot;fu&quot;&gt;copyOf&lt;/span&gt;(elementData, newCapacity);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扩容也同HashMap一样，扩大为2倍。然后新建数组，长度为新的容量，复制旧数据。由于过程中没有加锁，ArrayList也不是线程安全的。&lt;/p&gt;
&lt;h2 id=&quot;get&quot;&gt;Get&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index) {
    &lt;span class=&quot;fu&quot;&gt;rangeCheck&lt;/span&gt;(index);

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt;(index);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现相当简单，就是通过数组下标读取元素。但值得学习的是编程结构。比如，这个的范围检测，通过一个有意义的方法名封装了一段代码。清晰易懂。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;rangeCheck&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (index &amp;gt;= size)
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IndexOutOfBoundsException(&lt;span class=&quot;fu&quot;&gt;outOfBoundsMsg&lt;/span&gt;(index));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;如何使用线程安全的list&quot;&gt;如何使用线程安全的List&lt;/h2&gt;
&lt;p&gt;自己对变化过程加锁，或者使用&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;List list = Collection.&lt;span class=&quot;fu&quot;&gt;synchronizedList&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList());&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CopyOnWriteArrayList是一个有趣的例子，它规避了只读操作（如get/contains）并发的瓶颈，但是它为了做到这点，在修改操作中做了很多工作和修改可见性规则。 此外，修改操作还会锁住整个List，因此这也是一个并发瓶颈。所以从理论上来说，CopyOnWriteArrayList并不算是一个通用的并发List。(并发编程网)&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Wed, 28 Feb 2018 23:19:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woshimrf/p/arraylist.html</dc:identifier>
</item>
<item>
<title>深入java虚拟机学习 -- 类的加载机制 - blueskyli</title>
<link>http://www.cnblogs.com/blueskyli/p/8486565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blueskyli/p/8486565.html</guid>
<description>&lt;p&gt;当看到“类的加载机制”，肯定很多人都在想我平时也不接触啊，工作中无非就是写代码，不会了可以百度，至于类，jvm是怎么加载的我一点也不需要关心。在我刚开始工作的时候也觉得这些底层的内容距离我还很遥远，根本不用关系，可是随着做开发的时间越来越长，慢慢的已经意识到虚拟机相关要领的重要性。一直想写篇和虚拟机相关的文章，无奈之前由于各种原因一直没写，年初工作还不是很忙，抽时间来慢慢完善jvm的内容。&lt;/p&gt;
&lt;p&gt;好了，不说废话了，大家一起来看下代码吧，都来猜猜下面的两份代码的执行结果是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton singleton = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; counter1;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; counter2=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         counter1++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         counter2++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getInstance(){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;        Singleton singleton=&lt;span&gt;Singleton.getInstance();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;        System.out.println(&quot;counter1:&quot;+&lt;span&gt;singleton.counter1);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;        System.out.println(&quot;counter2:&quot;+&lt;span&gt;singleton.counter2);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/354604/201803/354604-20180301001159871-1622864790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; counter1;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; counter2=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton singleton = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         counter1++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         counter2++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getInstance(){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;        Singleton singleton=&lt;span&gt;Singleton.getInstance();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;        System.out.println(&quot;counter1:&quot;+&lt;span&gt;singleton.counter1);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;        System.out.println(&quot;counter2:&quot;+&lt;span&gt;singleton.counter2);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/354604/201803/354604-20180301001259421-120321815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这样的结果，不知道你有没有意外呢？看完我的这几篇文章后聪明的你一看就明白是怎么回事了。&lt;/p&gt;
&lt;h2&gt;java虚拟机与程序的生命周期&lt;/h2&gt;
&lt;p&gt;　　- 执行了System.exit()方法&lt;/p&gt;
&lt;p&gt;　　- 程序正常执行结束&lt;/p&gt;
&lt;p&gt;　　- 程序在执行过程中遇到了异常或错误而终止&lt;/p&gt;
&lt;p&gt;　　- 由于操作系统出现错误导致java虚拟机进程终止&lt;/p&gt;
&lt;p&gt;在如上几种情况下，java虚拟机将结束自己的生命周期&lt;/p&gt;
&lt;h2&gt;类的生命周期&lt;/h2&gt;
&lt;p&gt;类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/354604/201803/354604-20180301004615630-249763067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。&lt;/p&gt;
&lt;h2&gt;加载&lt;/h2&gt;
&lt;p&gt;查找并加载类的二进制数据，加载是类加载过程中的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类的加载指的是将类的.class文件中的二进制数据读取到内存中&lt;/li&gt;
&lt;li&gt;将其放在运行时数据区的方法区内，&lt;/li&gt;
&lt;li&gt;然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/354604/201803/354604-20180301003923658-140749250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;类加载的最终产品书位于堆区中的Class对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Class对象封装了类在方法区内的数据结构，并像java程序员提供了访问方法去内的数据结构的接口。&lt;/p&gt;
&lt;p&gt;Java程序对类的使用方式可以分为两种：&lt;/p&gt;
&lt;p&gt;-主动使用（&lt;span&gt;六种&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;1，创建类的实例&lt;/p&gt;
&lt;p&gt;2，访问某个类活接口的静态变量，或者对该静态变量赋值&lt;/p&gt;
&lt;p&gt;3，调用类的静态方法&lt;/p&gt;
&lt;p&gt;4，反射（Class.forName（“com.jack.test”））&lt;/p&gt;
&lt;p&gt;5，初始化一个类的子类&lt;/p&gt;
&lt;p&gt;6，Java虚拟机启动时被标明为启动类的类&lt;/p&gt;
&lt;p&gt;-被动使用（&lt;span&gt;除以上6种情况外，其他情况均为被动使用&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误），如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加载.class文件的方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从本地系统中直接加载&lt;/li&gt;
&lt;li&gt;通过网络下载.class文件&lt;/li&gt;
&lt;li&gt;从zip，jar等归档文件中加载.class文件&lt;/li&gt;
&lt;li&gt;从专有数据库中提取.class文件&lt;/li&gt;
&lt;li&gt;将Java源文件动态编译为.class文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;类加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同的类加载器负责的组件不同，可分为2种类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自定义类加载器（java.lang.classLoader的自来）&lt;/li&gt;
&lt;li&gt;java虚拟机自带类加载器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;java虚拟机自带类加载器按类型又可分为三种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动类加载器：Bootstrap ClassLoader    &lt;strong&gt;C/C++实现的  负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;扩展类加载器：Extension ClassLoader    &lt;strong&gt;使用java代码实现 该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;应用程序类加载器：Application ClassLoader    &lt;strong&gt;使用java代码实现 该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;双亲委派模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。&lt;/p&gt;
&lt;p&gt;双亲委派机制:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。&lt;/li&gt;
&lt;li&gt;当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。&lt;/li&gt;
&lt;li&gt;如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；&lt;/li&gt;
&lt;li&gt;若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;双亲委派模型意义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统类防止内存中出现多份同样的字节码&lt;/li&gt;
&lt;li&gt;保证Java程序安全稳定运行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;层次关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/354604/201803/354604-20180301012950212-1742999977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;验证&lt;/h2&gt;
&lt;p&gt;类被加在后，就进入连接阶段。连接就是将已经读取到内存的类的二进制数据合并到虚拟机的运行时环境中去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/354604/201803/354604-20180301010234582-1380115148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;准备&lt;/h2&gt;
&lt;p&gt;在准备阶段，Java虚拟机为类的静态变量分配内存，并设置默认的初始值，这些内存都将在方法区中分配。&lt;/p&gt;
&lt;p&gt;对于该阶段有以下几点需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。&lt;/li&gt;
&lt;li&gt;这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如对一下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存控件，并赋予默认值0，为long类型的静态变量b分配8个字节的内存控件，并赋予默认值0；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sample{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a=1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b;

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
       b&lt;/span&gt;=2&lt;span&gt;；
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;解析&lt;/h2&gt;
&lt;p&gt;在解析阶段，Java虚拟机会把类的二进制数据中的符号引用替换为直接引用。例如在Worker类的gotoWork()方法中会引用Car类的run()方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; gotoWork(){
   car.run(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这段代码在Worker类的二进制数据中表示为符号引用&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Worker类的二进制数据中，包含了一个对Car类的run()方法的符号引用，它由run()方法的全名和相关描述符组成。在解析阶段，Java虚拟机会把这个符号引用替换为一个指针，该指针指向Car类的run()方法区内的内存位置，这个指针就是直接引用。&lt;/p&gt;
&lt;h2&gt;初始化&lt;/h2&gt;
&lt;p&gt;类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量 赋予正确的初始值。在程序中，静态变量的初始化有两种途径：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在静态变量的声明处进行初始化&lt;/li&gt;
&lt;li&gt;在静态代码库中进行初始化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在如下代码中，静态变量a和b都被显示初始化，而静态变量c没有被显示初始化，它将保持默认值0；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sample{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a=1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; c;

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
       b&lt;/span&gt;=2&lt;span&gt;；
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JVM初始化步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;假如这个类还没有被加载和连接，则程序先加载并连接该类&lt;/li&gt;
&lt;li&gt;假如该类的直接父类还没有被初始化，则先初始化其直接父类&lt;/li&gt;
&lt;li&gt;假如类中有初始化语句，则系统依次执行这些初始化语句&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 28 Feb 2018 17:32:00 +0000</pubDate>
<dc:creator>blueskyli</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blueskyli/p/8486565.html</dc:identifier>
</item>
<item>
<title>麻省理工18年春软件构造课程阅读01“静态检查” - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/8486545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/8486545.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;本文内容来自&lt;a href=&quot;http://web.mit.edu/6.031/www/sp18/&quot;&gt;MIT_6.031_sp18: Software Construction&lt;/a&gt;课程的Readings部分，采用&lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;CC BY-SA 4.0&lt;/a&gt;协议。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于我们学校（哈工大）大二软件构造课程的大部分素材取自此，也是推荐的阅读材料之一，于是打算做一些翻译工作，自己学习的同时也能帮到一些懒得看英文的朋友。另外，该课程的阅读资料中有许多练习题，但是没有标准答案，所给出的答案均为译者所写，有错误的地方还请指出。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;译者：&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/&quot;&gt;李秋豪&lt;/a&gt; &lt;a href=&quot;https://github.com/wangyihang&quot;&gt;王一航&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;审校：&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/&quot;&gt;李秋豪&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V1.0 Thu Mar 1 00:49:04 CST 2018&lt;/span&gt;&lt;/p&gt;


&lt;h4 id=&quot;今天课程的目标&quot;&gt;&lt;span&gt;今天课程的目标：&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;学习静态类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;了解好的软件应该具有的三个属性&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;冰雹序列&quot;&gt;&lt;span&gt;冰雹序列&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;作为一个运行示例，我们先来了解一下“冰雹序列”，它是这样定义的：从正整数n开始，如果n是偶数，则下一个数是n/2，否则下一个数是3n+1，直到n等于1。这里有几个例子：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;2, 1
3, 10, 5, 16, 8, 4, 2, 1
4, 2, 1
2n, 2n-1 , … , 4, 2, 1
5, 16, 8, 4, 2, 1
7, 22, 11, 34, 17, 52, 26, 13, 40, …? (会停止吗？)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;由于存在3n+1这种变化，所以序列元素的大小可能会忽高忽低——这也是“冰雹序列”名称的来历，冰雹在落地前会在云层中忽上忽下。那么所有的序列都会最终“落地”变到1吗？（这个猜想称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Collatz_conjecture&quot;&gt;考拉兹猜想&lt;/a&gt; ，现在还没有一个好的解决方法。）&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;计算冰雹序列&quot;&gt;&lt;span&gt;计算冰雹序列&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;为了计算冰雹序列里的元素，我们可以在java和python中分别这样写：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// Java&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (n != &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(n);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (n % &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        n = n / &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        n = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; * n + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    }
}
System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(n);&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# Python&lt;/span&gt;
n &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt; n &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(n)
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; n &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:
        n &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; n &lt;span class=&quot;op&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        n &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; n &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(n)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;有些东西值得一提（译者注：MIT大一学的是python，所以这里谈了一下java和python语法上的区别，懂的读者可以略过）：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Java和Python的基本语法很相似，例如&lt;code&gt;while&lt;/code&gt; 和 &lt;code&gt;if&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Java在每一个句子结束时要求以分号作为结尾。这看起来有些麻烦，但也给了你很多自由以便安排代码——例如你可以将一行代码写成两行然后以分号结束。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Java在使用 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;while&lt;/code&gt;的时候，其中的条件判断需要用括号括起来。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Java使用花括号将一个语句块分割开来——python是以缩进作为区分，所以你写一些别的空格符也是可以的。但是编程也是一种交流，你不仅要和编译器交流，还要和别的程序员交流，所以缩进也是必要的，我们在后面的课中会专门讲这个。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;类型&quot;&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在上面的代码中，Python和Java最大的不同就是Java需要指定变量&lt;code&gt;n&lt;/code&gt;的类型：&lt;code&gt;int&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类型&lt;/strong&gt;是一些值的集合，以及这些值对应的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Java中有5种&lt;strong&gt;原始类型&lt;/strong&gt; ：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;int&lt;/code&gt; 例如5和-200这样的整数，但是其范围有限制，大概在±20亿）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;long&lt;/code&gt; （比int更大范围的整数）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;boolean&lt;/code&gt;对或错这两个值）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;double&lt;/code&gt; （浮点数，其表示的是实数的子集）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;char&lt;/code&gt; （单个字符例如 &lt;code&gt;'A'&lt;/code&gt; 和 &lt;code&gt;'$'&lt;/code&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Java也有&lt;strong&gt;对象类型&lt;/strong&gt; ，例如：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;String&lt;/code&gt; 表示一串连续的字符。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;BigInteger&lt;/code&gt; 表示任意大小的整数。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;从Java的传统来说，原始类型用小写字母，对象类型的起始字母用大写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;操作符&lt;/strong&gt;是一些能接受输入并输出结果的功能。他们的语法各有区别，Java中常见的有下面这三种：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;em&gt;前缀、中缀、后缀操作符.&lt;/em&gt; 例如， &lt;code&gt;a + b&lt;/code&gt; 调用这样一种操作（映射） &lt;code&gt;+ : int × int → int&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;( &lt;code&gt;+&lt;/code&gt; 是这个操作符的名字, &lt;code&gt;int × int&lt;/code&gt; 描述了这两个输入, 最后的 &lt;code&gt;int&lt;/code&gt; 描述的了输出)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;em&gt;一个对象的方法.&lt;/em&gt; 例如， &lt;code&gt;bigint1.add(bigint2)&lt;/code&gt; 调用这样一种操作（映射） &lt;code&gt;add: BigInteger × BigInteger → BigInteger&lt;/code&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;em&gt;一个函数.&lt;/em&gt; 例如： &lt;code&gt;Math.sin(theta)&lt;/code&gt; 调用这样一种操作（映射） &lt;code&gt;sin: double → double&lt;/code&gt;. 注意， &lt;code&gt;Math&lt;/code&gt; 不是一个对象，它是一个包含&lt;code&gt;sin&lt;/code&gt;函数的类。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;有一些操作符可以对不同类型的对象进行操作，这时我们就称之为&lt;strong&gt;可重载&lt;/strong&gt; （&lt;strong&gt;overloaded&lt;/strong&gt;），例如Java中的算术运算符 &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; 都是可重载的。一些函数也是可重载的。大多数编程语言都有不容程度的重载性。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;静态类型&quot;&gt;&lt;span&gt;静态类型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Java是一种&lt;strong&gt;静态类型&lt;/strong&gt;的语言。所有变量的类型在编译的时候就已经知道了（程序还没有运行），所以编译器也可以推测出每一个表达式的类型。例如，如果&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;是&lt;code&gt;int&lt;/code&gt;类型的，那么编译器就可以知道&lt;code&gt;a+b&lt;/code&gt;的结果也是&lt;code&gt;int&lt;/code&gt;类型的。事实上，Eclipse在你写代码的时候就在做这些检查，所以你就能够在编辑的同时发现这些问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;strong&gt;动态类型&lt;/strong&gt;语言中（例如Python），这种类型检查是&lt;strong&gt;发生在程序运行的时候&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;静态类型是&lt;strong&gt;静态检查&lt;/strong&gt;的一种——检查发生在编译的时候。本课程的一个重要目标就是教会你避免bug的产生，静态检查就是我们知道的第一种方法。其中静态类型就阻止了一大部分和类型相关的bug——确切点说，就是将操作符用到了不对应的类型对象上。例如，如果你进行下面这个操作，试图将两个字符串进行算术乘法：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;    &quot;5&quot; * &quot;6&quot;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;那么静态类型检查就会在你编辑代码的时候发现这个bug，而不是等到你编译后运行程序的时候（编译也不通过）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;译者注：这里注意不要和强类型和弱类型弄混了，知乎上有一个问答可以参考一下：&lt;a href=&quot;https://www.zhihu.com/question/19918532&quot;&gt;弱类型、强类型、动态类型、静态类型语言的区别是什么？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180301005654847-415972342.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（图片来自知乎）&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;静态检查动态检查无检查&quot;&gt;&lt;span&gt;静态检查、动态检查、无检查&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;编程语言通常能提供以下三种自动检查的方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;静态检查&lt;/strong&gt;: bug在程序运行前发现&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;动态检查&lt;/strong&gt;: bug在程序运行中发现&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;无检查&lt;/strong&gt;: 编程语言本身不帮助你发现错误，你必须通过特定的条件（例如输出的结果）检查代码的正确性。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;很明显，静态检查好于动态检查好于不检查。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里有一些“经验法则”，告诉你这静态和动态检查通常会发现什么bug：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;静态检查&lt;/strong&gt; :&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;语法错误，例如多余的标点符号或者错误的关键词。即使在动态类型的语言例如Python中也会做这种检查：如果你有一个多余的缩进，在运行之前就能发现它。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;错误的名字，例如&lt;code&gt;Math.sine(2)&lt;/code&gt;. (应该是 &lt;code&gt;sin&lt;/code&gt;.)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;参数的个数不对，例如 &lt;code&gt;Math.sin(30, 20)&lt;/code&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;参数的类型不对 &lt;code&gt;Math.sin(&quot;30&quot;)&lt;/code&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;错误的返回类型 ，例如一个声明返回&lt;code&gt;int&lt;/code&gt;类型函数&lt;code&gt;return &quot;30&quot;;&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;动态检查&lt;/strong&gt; :&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;非法的变量值。例如整型变量x、y，表达式&lt;code&gt;x/y&lt;/code&gt; 只有在&lt;strong&gt;运行后y为0才会报错&lt;/strong&gt;，否则就是正确的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;无法表示的返回值。例如最后得到的返回值无法用声明的类型来表示。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;越界访问。例如在一个字符串中使用一个负数索引。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用一个&lt;code&gt;null&lt;/code&gt;对象解引用。（&lt;code&gt;null&lt;/code&gt;相当于Python中的&lt;code&gt;None&lt;/code&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;静态检查倾向于&lt;em&gt;类型错误&lt;/em&gt; ，&lt;strong&gt;即与特定的值无关的错误&lt;/strong&gt;。正如上面提到过的，一个类型是一系列值的集合，而静态类型就是保证变量的值在这个集合中，但是在运行前我们可能不会知道这个值的结果到底是多少。所以如果一个错误必须要特定的值来“触发”（例如除零错误和越界访问），编译器是不会在编译的时候报错的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与此相对的，动态类型检查倾向于特定值才会触发的错误。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;原始类型并不是真正的数字&quot;&gt;&lt;span&gt;原始类型并不是真正的数字！&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在Java和许多其他语言中存在一个“陷阱”——原始数据类型的对象在有些时候并不像真正的数字那样得到应有的输出。结果就是本来应该被动态检查发现的错误没有报错。例如：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;整数的除法&lt;/strong&gt;：&lt;code&gt;5/2&lt;/code&gt;并不会返回一个小数，而是一个去掉小数部分的整数对象，因为除法操作符对两个整数对象运算后的结果还是整数，而整数对象是无法表示&lt;code&gt;5/2&lt;/code&gt;的精确值的（而我们期望它会是一个动态检查能发现的错误）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;整形溢出：&lt;/strong&gt; &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;long&lt;/code&gt;类型的值的&lt;strong&gt;集合是一个有限集合——它们有最大的值和最小的值&lt;/strong&gt;，当运算的结果过大或者过小的时候我们就很可能得到&lt;strong&gt;一个在合法范围内的错误值。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;浮点类型中的特殊值：&lt;/strong&gt;在浮点类型例如&lt;code&gt;double&lt;/code&gt;中有一些不是数的特殊值：&lt;code&gt;NaN&lt;/code&gt; ( “Not a Number”), &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; （正无穷）, and &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; （负无穷）.当你对浮点数进行运算的时候可能就会得到这些特殊值（例如除零或者对一个负数开更号），如果你拿着这些特殊值继续做运算，那你可能就会得到一个意想不到结果（译者注：例如拿NaN和别的数进行比较操作永远是False） 。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;阅读小练习&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;下面这些代码都有各自的bug，请你判断它们是静态错误还是动态错误还是无报错，但是得到错误的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (n) {
  n = n + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; big = &lt;span class=&quot;dv&quot;&gt;200000&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 200,000&lt;/span&gt;
big = big * big;  &lt;span class=&quot;co&quot;&gt;// big should be 40 billion now&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; probability = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sum = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; average = sum/n;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; sum = &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; n = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; average = sum/n;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;译者注：下面的四小节讲的是Java语言本身的一些性质，对Java很熟悉的同学可以跳过或略读。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;数组和聚集类型&quot;&gt;&lt;span&gt;数组和聚集类型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;现在让我们把“冰雹序列”的结果存储在数据结构中而不仅仅是输出。在Java中有两种常用的线性存储结构：数组和列表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组是一连串类型相同的元素组成的结构，&lt;strong&gt;而且它的长度是固定的（元素个数固定）&lt;/strong&gt;。例如，我们声明一个&lt;code&gt;int&lt;/code&gt;类型的数组：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;];&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于数组，常用的操作符有下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;索引其中的一个元素： &lt;code&gt;a[2]&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;赋予一个元素特定的值： &lt;code&gt;a[2]=0&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;求这个数组的长度： &lt;code&gt;a.length&lt;/code&gt; (注意和 &lt;code&gt;String.length()&lt;/code&gt; 的区别—— &lt;code&gt;a.length&lt;/code&gt; 不是一个类内方法调用，你不能在它后面写上括号和参数)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面是我们利用数组写的第一个求“冰雹序列”的代码，它存在一些bug：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;];  &lt;span class=&quot;co&quot;&gt;// &amp;lt;==== DANGER WILL ROBINSON&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (n != &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
    a[i] = n;
    i++;  &lt;span class=&quot;co&quot;&gt;// very common shorthand for i=i+1&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (n % &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        n = n / &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        n = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; * n + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    }
}
a[i] = n;
i++;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;相信很快你就能发现错误：幻数100？（译者注：幻数是指那些硬编码的数值）那如果n产生的“冰雹序列”非常长呢？像这样的bug称为越界访问，在Java中能够被动态检查检测出来，但是在C和C++这样的语言中则会造成 &lt;a href=&quot;https://en.wikipedia.org/wiki/Buffer_overflow&quot;&gt;缓冲区溢出&lt;/a&gt; （能通过编译），这也是很多漏洞的来源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方法是使用&lt;code&gt;List&lt;/code&gt;类型。列表类型是一个长度可变的序列结构。我们可以这样声明列表：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;常用的操作符有下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;索引一个元素： &lt;code&gt;list.get(2)&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;赋予一个元素特定的值： &lt;code&gt;list.set(2, 0)&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;求列表的长度： &lt;code&gt;list.size()&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这里要注意&lt;code&gt;List&lt;/code&gt;是一个接口，这种类型的对象无法直接用&lt;code&gt;new&lt;/code&gt;来构造，必须用能够实现&lt;code&gt;List&lt;/code&gt;要求满足的操作符的方法来构造。我们会在后来讲抽象数据类型的时候具体将价格这个。&lt;code&gt;ArrayList&lt;/code&gt;是一个实类型的类（concrete type），它提供了&lt;code&gt;List&lt;/code&gt;操作符的具体实现。当然，&lt;code&gt;ArrayList&lt;/code&gt;不是唯一的实现方法（还有&lt;code&gt;LinkedList&lt;/code&gt; 等），但是是最常用的一个）。你可以在Java API的文档里找到很多这方面的信息（Google Java 8 API，这里的API指“应用程序接口”，它会告诉你Java里面实现的很多有用的类和方法）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外要注意的是，我们要写&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt; 而不是 &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt;.因为&lt;code&gt;List&lt;/code&gt;只会处理对象类型而不是原始类型。&lt;strong&gt;在Java中，每一个原始类型都有其对应的对象类型&lt;/strong&gt;（原始类型使用小写字母名字，例如&lt;code&gt;int&lt;/code&gt;，而对象类型的开头字母大写，例如&lt;code&gt;Integer&lt;/code&gt;）。&lt;strong&gt;当我们使用尖括号参量化一个类型时，Java要求我们使用对象类型而非原始类型&lt;/strong&gt;。在其他的一些情况中，Java会自动在原始类型和对等的对象类型之间相转换。例如在上面的代码中我们可以使用&lt;code&gt;Integer i = 0&lt;/code&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是用列表写的“冰雹序列”的实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (n != &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
    list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(n);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (n % &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        n = n / &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        n = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; * n + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    }
}
list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(n);&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样实现不仅看起来简洁，更重要的是安全，因为列表会自动扩充它自己以满足新添加的元素（当然，直到你的内存不够用为止）&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;迭代&quot;&gt;&lt;span&gt;迭代&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对于在一个序列结构（例如列表和数组）遍历元素，Java和Python的写法差不多：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// find the maximum point of a hailstone sequence stored in list&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; max = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; x : list) {
    max = Math.&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;(x, max);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Math.max()&lt;/code&gt; 是一个Java API提供的方便的函数。你可以在Google中搜索“java 8 Math”获得关于Math这个库的一些详细信息。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;方法&quot;&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在Java中，声明通常必须在一个方法中，而每个方法都要在一个类型中，所以写“冰雹序列”程序最简单可以这么写：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Hailstone {
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Compute a hailstone sequence.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param n &lt;/span&gt;&lt;span class=&quot;co&quot;&gt; Starting number for sequence.  Assumes n &amp;gt; 0.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;hailstone sequence starting with n and ending with 1.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span class=&quot;fu&quot;&gt;hailstoneSequence&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n) {
        List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (n != &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
            list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(n);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (n % &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                n = n / &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                n = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; * n + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
            }
        }
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(n);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; list;
    }
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面介绍一些新的东西。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;public&lt;/code&gt;意味着任何在你程序中的代码都可以访问这个类或者方法。其他的&lt;strong&gt;类型修饰符&lt;/strong&gt;，例如&lt;code&gt;private&lt;/code&gt; ，是用来确保程序的安全性的——它保证了可变类型不会被别处的代码所修改。我们会在后面的课程中详细提到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;static&lt;/code&gt;意味这这个方法没有&lt;code&gt;self&lt;/code&gt;这个参数——Java会隐含的实现它，所以你不会看到这个参数。静态的方法不能通过对象来调用，例如&lt;code&gt;List&lt;/code&gt; &lt;code&gt;add()&lt;/code&gt; 方法 或者 &lt;code&gt;String&lt;/code&gt; &lt;code&gt;length()&lt;/code&gt;方法，它们要求先有一个对象。静态方法的正确调用应该使用类来索引，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;Hailstone.&lt;span class=&quot;fu&quot;&gt;hailstoneSequence&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;83&lt;/span&gt;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;另外，记得在定义的方法前面写上注释。这些注释应该描述了这个方法的功能，输入输出/返回，以及注意事项。记住注释不要写的啰嗦，而是应该直切要点，简洁明了。例如在上面的代码中，n是一个整型的变量，这个在声明的时候&lt;code&gt;int&lt;/code&gt;已经体现出来了，就不需要进行注释。但是如果我们设想的本意是n不能为负数，而这个编译器（声明）是不能检查和体现出来的，我们就应该注释出来，方便阅读理解和修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些东西我们会在后面的课程中详细介绍，但是你现在就要开始试着正确使用他们。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;变化的值-vs.-可被赋值的改变&quot;&gt;&lt;span&gt;变化的值 vs. 可被赋值的改变&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在下一篇阅读资料中我们会介绍“快照图”（&lt;em&gt;snapshot diagrams&lt;/em&gt;），以此来辨别修改一个变量和修改一个值的区别。当你给一个变量赋值的时候，你实际上是在改变这个变量指向的对象（值也不一样）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而当你对一个可变的值进行赋值操作的时候——例如数组或者列表——你实际上是在改变对象本身的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变化是“邪恶”的，好的程序员会避免可改变的东西，因为这些改变可能是意料之外的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不变性（Immutability）是我们这门课程的一个重要设计原则。不变类型是指那些这种类型的对象一旦创建其内容就不能被更改的类型（至少外部看起来是这样，我们在后面的的课程中会说一些替代方案）。思考一下在上面的代码中哪一些类型是可更改类型，哪一些不是？（译者注：例如&lt;code&gt;int&lt;/code&gt;就是不变的，&lt;code&gt;List&lt;/code&gt;就是可变的，给&lt;code&gt;int&lt;/code&gt;类型的对象赋值就会让它指向一个新的对象）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java也给我们提供了不变的索引：只要变量被初始化后就不能再次被赋值了——只要在声明的时候加上&lt;code&gt;final&lt;/code&gt; ：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果编译器发现你的&lt;code&gt;final&lt;/code&gt;变量不仅仅是在初始化的时候被“赋值”，那么它就会报错。换句话说，&lt;code&gt;final&lt;/code&gt;会提供不变索引的静态检查。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正确的使用&lt;code&gt;final&lt;/code&gt;是一个好习惯，就好像类型声明一样，这不仅会让编译器帮助你做静态检查，同时别人读起来也会更顺利一些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;code&gt;hailstoneSequence&lt;/code&gt;方法中有两个变量n和list，我们可以将它们声明为&lt;code&gt;final&lt;/code&gt;吗？请说明理由。（译者注：n不行，list可以。因为我们需要改变n指向的对象，而&lt;code&gt;List&lt;/code&gt;对象本身是可以更改的，我们也不需要改变list对应的对象）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span class=&quot;fu&quot;&gt;hailstoneSequence&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n) { 
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;记录你的设想&quot;&gt;&lt;span&gt;记录你的设想&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在文档中写下变量的类型记录了一个关于它的设想, 例如这个变量总是指向一个整型. 在编译的时候 Java 就会检查这个设想, 并且保证在你的代码中没有任何一处违背这个设想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而使用 &lt;code&gt;final&lt;/code&gt; 关键字去定义一个变量也是一种记录设想, 要求这个变量在其被赋值之后就永远不会再被修改, Java 也会对其进行静态地检查。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不幸的是 Java 并不会自动检查所有设想，例如:n 必须为正数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么我们需要写下我们的设想呢? 因为编程就是不断的设想, 如果我们不写下他们, 就可能会遗忘掉他们, 而且如果以后别人想要阅读或者修改我们的软件, 他们就会很难理解代码, 不得不去猜测(译者注: 变量的含义/函数的描述/返回值描述等等)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以在编程的时候我们必须朝着如下两个目标努力：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;与计算机交流. 首先说服编译器你的程序语法正确并且类型正确, 然后保证逻辑正确, 这样就可以让它在运行的时候给我们正确的结果。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;与其他人交流. 尽可能使你的程序易于理解, 所以当有人想要在将来某些时候修正它, 改进它或者对其进行适配的时候, 他们可以很方便地实现自己的想法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;黑客派hacking-vs.-工程派engineering&quot;&gt;&lt;span&gt;黑客派（Hacking） vs. 工程派（Engineering）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们已经在本门课程中编写了一些黑客风格的代码, 黑客派的编程风格可以理解为“放飞自我并且乐观的”（译者注：贬义）：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;缺点: 在已经编写大量代码以后才测试它们&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;缺点: 将所有的细节都放在脑子里, 以为自己可以永远记住所有的代码, 而不是将它们编写在代码中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;缺点: 认为 BUG 都不存在或者它们都非常容易发现和被修复.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;而工程派对应的做法是（译者注：褒义）：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;优点: 一次只写一点点, 一边写一边测试. 在将来的课程中, 我们将会探讨&quot;测试优先编程&quot; (test-first programming)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;优点: 记录代码的设想、意图 (document the assumptions that your code depends on)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;优点: 静态代码检查将会保护你的代码不沦为“愚蠢的代码”&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;阅读小练习-1&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;思考下面这个Python片段：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; math &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; sqrt
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; funFactAbout(person):
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; sqrt(person.age) &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt;(sqrt(person.age)):
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;The age of &quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; person.name &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot; is a perfect square: &quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(person.age))&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这块代码做了哪些设想（能够正常运行不报错）？&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;person&lt;/code&gt; 一定有 &lt;code&gt;age&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; 这两个实例化变量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;person&lt;/code&gt; 不是 &lt;code&gt;None&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;person.age&lt;/code&gt; 不是负数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;person.age&lt;/code&gt; 是整数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;person.name&lt;/code&gt; 一定是字符串&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果这串代码用Java来写，下面的哪些设想可以用类型声明来限制，或者能够被编译器静态检查出来？&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;person&lt;/code&gt; 一定有 &lt;code&gt;age&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; 这两个实例化变量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;person&lt;/code&gt; 不是 &lt;code&gt;None&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;person.age&lt;/code&gt; 不是负数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;person.age&lt;/code&gt; 是整数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;person.name&lt;/code&gt; 一定是字符串&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;本门课程6.031的目标&quot;&gt;&lt;span&gt;本门课程（6.031）的目标&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本门课程的主要目标为学习如何生产具有如下属性的软件:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;安全健壮性&lt;/strong&gt;. 正确性 (现在看起来是正确的), 防御性 (将来也是正确的)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可读性&lt;/strong&gt;. 我们不得不和以后有可能需要理解和修改代码的程序员进行交流 (修改 BUG 或者添加新的功能), 那个将来的程序员或许会是几个月或者几年以后的你, 如果你不进行交流, 那么到了那个时候, 你将会惊讶于你居然忘记了这么多, 并且这将会极大地帮助未来的你有一个良好的设计。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可改动性&lt;/strong&gt;. 软件总是在更新迭代的, 一些好的设计可以让这个过程变得非常容易, 但是也有一些设计将会需要让开发者扔掉或者重构大量的代码。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;译者注：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;safe from bugs (SFB),&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;easy to understand (ETU),&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ready for change (RFC).&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;当然也有其他的非常重要的关于软件的性质(例如: 性能, 实用性以及安全性), 并且他们可能会和上述三种性质是互相矛盾的。但是在 6.031 这门课程中, 我们重点关注上述三个重要性质, 并且软件开发者一般情况下会将这三种性质列于软件开发过程中的最重要的性质。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这门课的学习中, 思考每一种编程语言的特性, 每一次编程练习, 每一个设计模式是非常值得的, 试着理解它们如何和上述三种特性关联起来。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习-2&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;上文中那些知识点能够帮助你&lt;strong&gt;远离bug&lt;/strong&gt; SFB ？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] 动态检查&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] 常量（final）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 整型溢出&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] 静态类型&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;上文中那些知识点能够帮助你&lt;strong&gt;的代码易于理解和阅读&lt;/strong&gt; ETU ？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上文中那些知识点能够帮助你&lt;strong&gt;的代码能够被方便的更改&lt;/strong&gt; RFC ？&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;我们为什么选择java作为本课程的编程语言&quot;&gt;&lt;span&gt;我们为什么选择Java作为本课程的编程语言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果你已经学过了课程 6.009, 我们假设你已经对 Python 语言轻车熟路了, 那么为什么在这门课程中, 我们没有使用 Python 语言而是使用了 Java 呢?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;安全性&lt;/strong&gt;是首要原因, Java 有静态检查机制 (主要检查变量类型, 同时也会检查函数的返回值和函数定义时的返回值类型是否匹配). 我们在这门课中学习软件开发, 而在软件开发中一个主要原则就是远离 BUG, Java 拨号安全性达到了 11 (Java dials safety up to 11), 这让 Java 成为一个非常好的用来进行软件工程实践的语言. 当然, 在其他的动态语言中也可以写出安全的代码, 例如 Python, 但是如果你学习过如何在一个安全的, 具有静态代码检查机制的语言, 你就可以更加容易地理解这一过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;普遍性&lt;/strong&gt;是另一个原因, Java 在科学研究/教育/工业界广泛被使用. Java 可以在许多平台运行, 不仅仅是 Windows/Mac/Linux. Java 也可以用来进行 web 开发 (不仅可以在服务端使用, 也可以在客户端使用), 而且原生安卓系统也是基于 Java 开发. 尽管其他的编程语言也有更加适合用来进行编程教学 (Scheme 和 ML 浮现在脑海中), 但是令人是让的是这些语言并没有在现实世界中被广泛使用. 你的简历上的 Java 经验将会被认为是一个非常有利的技能. 但是注意请不要理解错了, 你从本门课程中学到的并不是仅限定于 Java 语言, 这些知识是可以被套用在任何编程语言中的. 本门课程中最重要内容: 安全性, 清晰性, 抽象, 工程化的本能, 这些知识将会让你游刃有余地应对各种编程语言的新潮流。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;任何情况下, 一个好的程序员必须能&lt;strong&gt;熟练使用多种编程语言&lt;/strong&gt;, 编程语言是一种工具, 而你必须使用正确的工具来完成你的工作. 在你完成你在 MIT 的学习生涯之前你肯定会学到其他的编程语言技能 (例如: JavaScript, C/C++, Scheme, Ruby, ML 或者 Haskell) 所以我们正在通过学习第二门语言来入门。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作为普遍性的一个结果, Java 有大量的有趣而且有用的&lt;strong&gt;库&lt;/strong&gt; (包括 Java 本身自带的库, 以及在网络上的库), 也有非常多的免费并且完美的&lt;strong&gt;工具&lt;/strong&gt; (IDE 例如 Eclipse; 编辑器, 编译器, 测试框架, 性能分析工具, 代码覆盖率检测工具, 代码风格检查工具). 即使是 Python , 它的生态系统也没有 Java 的更加丰富。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后悔使用 Java 的几个原因.&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;它很啰嗦, 这个特性使得在黑板上写出代码样例是非常麻烦的.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;它很臃肿, 在这些年中已经积累了非常多的不同的功能和特性.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;它存在一些内部矛盾, 例如: &lt;code&gt;final&lt;/code&gt; 关键字在不同的上下文中会有不同的含义, &lt;code&gt;static&lt;/code&gt; 关键字在 Java 中和静态代码检查并没有任何关系&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;它受到C / C ++等老式语言的影响, 原始数据类型和 &lt;code&gt;switch&lt;/code&gt; 语句就是很好的例子&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;它并没有一个像 Python 一样的解释器, 可以允许你在解释器中编写一些短小的测试代码来学习这门语言&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;但是总体来说, Java 对现在来说还是一款比较适合用来学习如何编写安全的, 易于理解的, 对改变友好的代码的编程语言, 以上就是我们课程的目标；）&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们今天主要介绍的思想为&lt;strong&gt;静态代码检查&lt;/strong&gt;, 下面是该思想如何和我们的目标进行关联&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;安全健壮性&lt;/strong&gt;. 静态代码检查可以通过捕捉类型错误等其他BUG帮助我们在运行代码之前就发现它们&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可读性&lt;/strong&gt;. 它可以帮助我们理解, 因为所有的类型在代码中被明确定义 (译者注: 相比于 Python/PHP 这类动态变量类型的语言)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可改动性&lt;/strong&gt;. 静态代码检查可以在你在修改你的代码的时候定位出也需要被修改的地方, 例如: 当你改变一个变量的类型或者名称的时候, 编译器立即就会在所有使用到这个变量的地方显示错误, 提示你也需要更新它们。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 28 Feb 2018 17:05:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/8486545.html</dc:identifier>
</item>
<item>
<title>Java集合中的AbstractMap抽象类 - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/8486539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/8486539.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;jdk1.8.0_144&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;AbstractMap抽象类实现了一些简单且通用的方法，本身并不难。但在这个抽象类中有两个方法非常值得关注，keySet和values方法源码的实现可以说是教科书式的典范。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　抽象类通常作为一种骨架实现，为各自子类实现公共的方法。上一篇我们讲解了Map接口，此篇对AbstractMap抽象类进行剖析研究。&lt;/p&gt;
&lt;p&gt;　　Java中Map类型的数据结构有相当多，AbstractMap作为它们的骨架实现实现了Map接口部分方法，也就是说为它的子类各种Map提供了公共的方法，没有实现的方法各种Map可能有所不同。&lt;/p&gt;
&lt;p&gt;　　抽象类不能通过new关键字直接创建抽象类的实例，但它可以有构造方法。AbstractMap提供了一个protected修饰的无参构造方法，意味着只有它的子类才能访问（当然它本身就是一个抽象类，其他类也不能直接对其实例化），也就是说只有它的子类才能调用这个无参的构造方法。&lt;/p&gt;
&lt;p&gt;　　在Map接口中其内部定义了一个Entry接口，这个接口是Map映射的内部实现用于维护一个key-value键值对，key-value存储在这个Map.Entry中。AbstractMap对这个内部接口进行了实现，一共有两个：一个是可变的SimpleEntry和一个是不可变的SimpleImmutableEntry。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static class SimpleEntry&amp;lt;K,V&amp;gt; implements Entry&amp;lt;K,V&amp;gt;, java.io.Serializable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　实现了Map.Entry&amp;lt;K, V&amp;gt;接口，并且实现了Serializable（可被序列化）。&lt;/p&gt;
&lt;p&gt;　　它的方法比较简单都是取值存值的操作，对于key值的定义是一个final修饰意味着是一个不可变的引用。另外其setValue方法稍微特殊，存入value值返回的并不是存入的值，而是返回的以前的旧值。需要重点学习的是它重写的equals和hashCode方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object o) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt; Map.Entry))        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断参数是否是Map.Entry类型，要equals相等首先得是同一个类型&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Object类型强转为Map.Entry类型，这里参数使用“?”而不是“K, V”是因为泛型在运行时类型会被擦除，编译器不知道具体的K,V是什么类型&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; eq(key, e.getKey()) &amp;amp;&amp;amp; eq(value, e.getValue());        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key和value分别调用eq方法进行判断，都返回ture时equals才相等。&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; eq(Object o1, Object o2) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; o1 == &lt;span&gt;null&lt;/span&gt; ? o2 == &lt;span&gt;null&lt;/span&gt; : o1.equals(o2);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个三目运算符也很简单，只不过需要注意的是尽管这里o1、o2是Object类型，Object类型的equals方法是通过“==”比较的引用，所以不要认为这里有问题，因为在实际中，o1类型有可能是String，尽管被转为了Object，所以此时在调用equals方法时还是调用的String#equals方法。&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　要想正确重写equals方法并能正确使用，通常还需要重写hashCode方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt; ? 0 : key.hashCode()) ^ (value == &lt;span&gt;null&lt;/span&gt; ? 0 : value.hashCode());    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key和value的值不为null时，将它们的hashCode进行异或运算。&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;public static class SimpleImmutableEntry&amp;lt;K,V&amp;gt; implements Entry&amp;lt;K,V&amp;gt;, java.io.Serializable SimpleImmutableEntry&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　定义为不可变的Entry，其实是事实不可变，因为它不提供setValue方法，在多个线程同时访问时自然不能通过setValue方法进行修改。它相比于SimpleEntry其key和value成员变量都被定义为了final类型。调用setValue方法将会抛出UnsupportedOperationException异常。&lt;/p&gt;
&lt;p&gt; 　　它的equals和hashCode方法和SimpleEntry一致。&lt;/p&gt;
&lt;p&gt;　　接下来查看AbstractMap抽象类实现了哪些Map接口中的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public int size()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Map中定义了一个entrySet方法，返回的是Map.Entry的Set集合，直接调用Set集合的size方法即是Map的大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public boolean isEmpty()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　调用上面的size方法，等于0即为空。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public boolean containsKey(Object key)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法的实现较为简单，通过调用entrySet方法获取Set集合的迭代器遍历Map.Entry，与参数key比较。Map可以存储为null的key值，由于key=null在Map中存储比较特殊（不能计算hashCode值），所以在这里也做了判断参数key是否为空。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public boolean containsValue(Object value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法实现和containsKey一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public V get(Object key)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法实现和上面两个也类似，不同的是上面相等返回boolean，这个方法返回value值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public V put(K key, V value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　向Map中存入key-value键值对的方法并没有具体实现，会直接抛出一个UnsupportedOperationException异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public V remove(Object key)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过参数key删除Map中指定的key-value键值对。这个方法也很简单，也是通过迭代器遍历Map.Entry的Set集合，找到对应key值，通过调用Iterator#remove方法删除Map.Entry。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public void putAll(Map&amp;lt;? extends K, ? extends V&amp;gt; m)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法也很简单遍历传入的Map，调用put方法存入就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public void clear()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　调用entrySet方法获取Set集合再调用Set#clear()方法清空。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public Set&amp;lt;K&amp;gt; keySet()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回Map key值的Set集合。AbstractMap中定义了一个成员变量“transient Set&amp;lt;K&amp;gt; keySet”，在JDK7中keySet变量是由volatile修饰的，但在JDK8中并没有使用volatile修饰。在对keySet变量的注释中解释道，访问这些字段的方法本身就没有同步，加上volatile也不能保证线程安全。关于keySet方法的实现就有点意思了。&lt;/p&gt;
&lt;p&gt;　　首先思考该方法是返回key值的Set集合，很自然的能想到一个简单的实现方式，遍历Entry数组取出key值放到Set集合中，类似下面代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Set&amp;lt;K&amp;gt;&lt;span&gt; keySet() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     Set&amp;lt;K&amp;gt; ks = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;K, V&amp;gt;&lt;span&gt; entry : entrySet()) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        ks.add(entry.getKey());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ks;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这就意味着每次调用keySet方法都会遍历Entry数组，数据量大时效率会大大降低。不得不说JDK源码是写得非常好，它并没有采取遍历的方式。如果不遍历Entry，那又如何知道此时Map新增了一个key-value键值对呢？&lt;/p&gt;
&lt;p&gt;　　答案就是在keySet方法内部重新实现了一个新的自定义Set集合，在这个自定义Set集合中又重写了iterator方法，这里是关键，iterator方法返回Iterator接口，而在这里又重新实现了Iterator迭代器，通过调用entrySet方法再调用它的iterator方法。下面结合代码来分析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Set&amp;lt;K&amp;gt;&lt;span&gt; keySet() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Set&amp;lt;K&amp;gt; ks = keySet;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义的transient Set&amp;lt;K&amp;gt; keySet&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ks == &lt;span&gt;null&lt;/span&gt;) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次调用肯定为null，则通过下面代码创建一个Set示例&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         ks = &lt;span&gt;new&lt;/span&gt; AbstractSet&amp;lt;K&amp;gt;() {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个自定义Set&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;K&amp;gt; iterator() {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写Set集合的iterator方法&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Iterator&amp;lt;K&amp;gt;() {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新实现Iterator接口&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; Iterator&amp;lt;Entry&amp;lt;K,V&amp;gt;&amp;gt; i = entrySet().iterator();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用Entry的Set集合Iterator迭代器&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; i.hasNext();        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对key值的判断，就是对entry的判断&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; K next() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; i.next().getKey();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取下一个key值，就是取entry#getKey&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         i.remove();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除key值，就是删除entry&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                };
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size() {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写的Set#size方法&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; AbstractMap.&lt;span&gt;this&lt;/span&gt;.size();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key值有多少就是整个Map有多大，所以调用本类的size方法即可。这个是内部类，直接使用this关键字代表这个类，应该指明是调用AbstractMap中的size方法，没有this则表示是static静态方法&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isEmpty() {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写的Set#isEmpty方法&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; AbstractMap.&lt;span&gt;this&lt;/span&gt;.isEmpty();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对是否有key值，就是判断Map是否为空，，所以调用本类的isEmpty方法即可&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clear() {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写的Set#clear方法&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                 AbstractMap.&lt;span&gt;this&lt;/span&gt;.clear();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空key值，就是清空Map，，所以调用本类的clear方法即可&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; contains(Object k) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写Set#contains方法&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; AbstractMap.&lt;span&gt;this&lt;/span&gt;.containsKey(k);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断Set是否包含数据k，就是判断Map中是否包含key值，所以调用本类的containsKey方法即可&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         keySet = ks;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将这个自定义Set集合赋值给变量keySet，在以后再次调用keySet方法时，因为keySet不为null，只需直接返回。&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; ks;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我认为这是一种很巧妙的实现，尽管这个方法是围绕key值，但实际上可以结合Entry来实现，而不用遍历Entry，同时上面提到了调用entrySet# iterator方法，这里则又是模板方法模式的最佳实践。因为entrySet在AbstractMap中并未实现，而是交给了它的子类去完成，但是对于keySet方法却可以对它进行一个“算法骨架” 实现，这就是模板方法模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public Collection&amp;lt;V&amp;gt; values()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　对于values方法则完全可以参考keySet，两者有着异曲同工之妙，这里为节省篇幅不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public abstract Set&amp;lt;Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一个抽象方法，交给它的子类去完成，说明这个方法并不是特别“通用”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public boolean equals(Object o)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Map中规定只有在Map中的每对key-value键值对的key和value都一一对应时他们的equals比较才返回true。在方法中先判断简单的条件，如果引用相等，直接返回true，如果参数o不是Map类型直接返回false，如果两个Map的数量不同也直接返回false。后面才再遍历Entry数组比较Entry中的key和value是否一一对应。方法简单，但这给了我们一个启示，在条件判断中，先判断简单的基本的，再判断复杂的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public int hashCode()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　重写了Object类的equals方法，重写hashCode也是必须的。AbstractMap对hashCode的实现是将所有Map.Entry（这里就是SimpleEntry或SimpleImmutableEntry）的hashCode值向加，最后得出的总和作为Map的hashCode值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public String toString()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法没什么好说的，就是取出所有键值对使用StringBuilder对其进行拼接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;protected Object clone() throws CloneNotSupportedException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　实现一个浅拷贝，由于是浅拷贝对于变量keySet和values不进行拷贝，防止两个浅拷贝引发的问题，关于Object中的clone方法在&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/8445910.html&quot; target=&quot;_blank&quot;&gt;《万类之父——Object》&lt;/a&gt;已有解析。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 28 Feb 2018 16:48:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/8486539.html</dc:identifier>
</item>
<item>
<title>redux middleware 源码分析 - 牧云云</title>
<link>http://www.cnblogs.com/MuYunyun/p/8486533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MuYunyun/p/8486533.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/1/161dd3870015d2a9?w=640&amp;amp;h=280&amp;amp;f=jpeg&amp;amp;s=12875&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MuYunyun/blog/issues/15&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;middleware-的由来&quot;&gt;middleware 的由来&lt;/h3&gt;
&lt;p&gt;在业务中需要打印每一个 action 信息来调试，又或者希望 dispatch 或 reducer 拥有异步请求的功能。面对这些场景时，一个个修改 dispatch 或 reducer 代码有些乏力，我们需要一个可组合的、自由增减的插件机制，Redux 借鉴了 Koa 中 middleware 的思想，利用它我们可以在前端应用中便捷地实现如日志打印、异步请求等功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/1/161dd387003424f6?w=718&amp;amp;h=200&amp;amp;f=jpeg&amp;amp;s=14678&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如在&lt;a href=&quot;https://github.com/MuYunyun/reactSPA/blob/274c00870853638fb0f77df8497f911eb560b617/src/client/store/configureStore.dev.js#L14&quot;&gt;项目&lt;/a&gt;中，进行了如下调用后，redux 就集成了 thunk 函数调用以及打印日志的功能。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; thunk &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'redux-thunk'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; logger &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'../middleware/logger'&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; enhancer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;applyMiddleware&lt;/span&gt;(thunk&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; logger)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;// 以 redux-thunk、logger 中间件为例介绍中间件的使用&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; store &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;createStore&lt;/span&gt;(rootReducer&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; enhancer)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面追本溯源，来分析下源码。&lt;/p&gt;
&lt;h3 id=&quot;applymiddleware-调用入口&quot;&gt;applyMiddleware 调用入口&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;createStore&lt;/span&gt;(reducer&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; preloadedState&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; enhancer) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 通过下面代码可以发现，如果 createStore 传入 2 个参数，第二个参数相当于就是 enhancer&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; preloadedState &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'function'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; enhancer &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'undefined'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    enhancer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; preloadedState
    preloadedState &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;undefined&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; enhancer &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'undefined'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;enhancer&lt;/span&gt;(createStore)(reducer&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; preloadedState)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  ...
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由上述 &lt;a href=&quot;https://github.com/reactjs/redux/blob/55e77e88c98723f1883929458bb0144430108143/src/createStore.js#L33&quot;&gt;createStore 源码&lt;/a&gt;发现，applyMiddleware 会进行 &lt;code&gt;applyMiddleware(thunk, logger)(createStore)(reducer, preloadedState)&lt;/code&gt; 的调用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/redux/blob/55e77e88c98723f1883929458bb0144430108143/src/applyMiddleware.js#L20&quot;&gt;applyMiddleware 源码&lt;/a&gt;如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;applyMiddleware&lt;/span&gt;(...&lt;span class=&quot;at&quot;&gt;middlewares&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; createStore &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (...&lt;span class=&quot;at&quot;&gt;args&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; store &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;createStore&lt;/span&gt;(...&lt;span class=&quot;at&quot;&gt;args&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; dispatch &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; chain &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []

    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; middlewareAPI &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;                &lt;span class=&quot;co&quot;&gt;// 调用 redux 原生方法，获取状态&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (...&lt;span class=&quot;at&quot;&gt;args&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;(...&lt;span class=&quot;at&quot;&gt;args&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// 调用 redux 原生 dispatch 方法&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 串行 middleware&lt;/span&gt;
    chain &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;middlewares&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(middleware &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;middleware&lt;/span&gt;(middlewareAPI))
    dispatch &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;compose&lt;/span&gt;(...&lt;span class=&quot;at&quot;&gt;chain&lt;/span&gt;)(&lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;)

    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      ...&lt;span class=&quot;at&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      dispatch &lt;span class=&quot;co&quot;&gt;// 返回加工过的 dispatch&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以发现 applyMiddleware 的作用其实就是返回加工过的 dispatch，下面会着重分析 middlewares 是如何串行起来的以及 dispatch 是如何被加工的。&lt;/p&gt;
&lt;h3 id=&quot;串行-middleware&quot;&gt;串行 middleware&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; middlewareAPI &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (...&lt;span class=&quot;at&quot;&gt;args&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;(...&lt;span class=&quot;at&quot;&gt;args&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
chain &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;middlewares&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(middleware &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;middleware&lt;/span&gt;(middlewareAPI))
dispatch &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;compose&lt;/span&gt;(...&lt;span class=&quot;at&quot;&gt;chain&lt;/span&gt;)(&lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;观察上述代码后发现每个 middleware 都会传入参数 middlewareAPI，来看下中间件 &lt;a href=&quot;https://github.com/MuYunyun/reactSPA/blob/274c00870853638fb0f77df8497f911eb560b617/src/client/middleware/logger.js#L1&quot;&gt;logger 的源码&lt;/a&gt; 以及 &lt;a href=&quot;https://github.com/gaearon/redux-thunk/blob/master/src/index.js&quot;&gt;redux-thunk 的源码&lt;/a&gt;, 发现中间件接受的第一个参数正是 ({ dispatch, getState })&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// logger 源码&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; dispatch&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; getState &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; next &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; action &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(action)
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;next&lt;/span&gt;(action) &lt;span class=&quot;co&quot;&gt;// 经 compose 源码分析，此处 next 为 Store.dispatch&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// redux-thunk 源码&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; dispatch&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; getState &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; next &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; action &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; action &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'function'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;action&lt;/span&gt;(dispatch)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;next&lt;/span&gt;(action) &lt;span class=&quot;co&quot;&gt;// 此处 next 为 logger 中间件返回的 (action） =&amp;gt; {} 函数&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;dispatch-是如何被加工的&quot;&gt;dispatch 是如何被加工的&lt;/h3&gt;
&lt;p&gt;接着上个小节，在 &lt;code&gt;dispatch = compose(...chain)(store.dispatch)&lt;/code&gt; 中发现了 compose 函数，来看下 &lt;a href=&quot;https://github.com/reactjs/redux/blob/55e77e88c98723f1883929458bb0144430108143/src/compose.js#L12&quot;&gt;compose 的源码&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;compose&lt;/span&gt;(...&lt;span class=&quot;at&quot;&gt;funcs&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;funcs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;reduce&lt;/span&gt;((a&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; b) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (...&lt;span class=&quot;at&quot;&gt;args&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;a&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;b&lt;/span&gt;(...&lt;span class=&quot;at&quot;&gt;args&lt;/span&gt;)))
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;compose 源码中的 &lt;code&gt;funcs.reduce((a, b) =&amp;gt; (...args) =&amp;gt; a(b(...args)))&lt;/code&gt; 算是比较重要的一句，它的作用是返回组合参数后的函数，比如 compose(f, g, h) 等价于 (...args) =&amp;gt; f(g(h(...args)))，效果图如下所示，调用 this.props.dispatch() 后，会调用相应的中间件，最终会调用 redux 原生的 store.dispatch()，并且可以看到中间件调用的形式类似数据结构中的栈(先进后出)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/1/161dd3870009f6b7?w=360&amp;amp;h=300&amp;amp;f=jpeg&amp;amp;s=15622&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拿上个小节提到的 logger、redux-thunk 中间件为例，其 middleware 的内部串行调用方式如下，从而完成了 dispatch 功能的增强(支持如 &lt;code&gt;this.props.dispatch(func)&lt;/code&gt; 的调用以及日志功能)。具体可以看 &lt;a href=&quot;https://github.com/MuYunyun/reactSPA/blob/274c00870853638fb0f77df8497f911eb560b617/src/common/pages/music/index.js#L35&quot;&gt;项目中的运用&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;action &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; action &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'function'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;action&lt;/span&gt;(dispatch)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (action &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(action)
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;(action)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)(action)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;p&gt;深入React技术栈&lt;/p&gt;
</description>
<pubDate>Wed, 28 Feb 2018 16:43:00 +0000</pubDate>
<dc:creator>牧云云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MuYunyun/p/8486533.html</dc:identifier>
</item>
<item>
<title>Redis Sentinel 高可用服务架构搭建 - 田园里的蟋蟀</title>
<link>http://www.cnblogs.com/xishuai/p/redis-sentinel.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xishuai/p/redis-sentinel.html</guid>
<description>&lt;p&gt;阅读目录：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;关于 Redis 的概念&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关于 Redis Sentinel 的概念&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;搭建 Redis Server（master）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;搭建 Redis Server（slave）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;搭建 Redis Sentinel&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis Sentinel 故障转移测试&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;前几天，看到了一篇文章：&lt;a href=&quot;https://www.cnblogs.com/xuning/p/8464625.html&quot;&gt;高可用 Redis 服务架构分析与搭建&lt;/a&gt;，思路讲的非常好，但是没有搭建的过程，这篇文章就记录下 Redis Sentinel 高可用服务架构搭建的过程。&lt;/p&gt;
&lt;p&gt;搭建方案，就按照作者的第四种方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/435188/201802/435188-20180227155808044-1131790670.png&quot; width=&quot;800px&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;关于-redis-的概念&quot;&gt;1. 关于 Redis 的概念&lt;/h2&gt;
&lt;p&gt;Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。&lt;/p&gt;
&lt;p&gt;Redis 与其他 key-value 缓存产品有以下三个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
&lt;li&gt;Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis 支持数据的备份，即 master-slave 模式的数据备份。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Redis 的优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;性能极高&lt;/strong&gt; – Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丰富的数据类型&lt;/strong&gt; – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原子&lt;/strong&gt; – Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丰富的特性&lt;/strong&gt; – Redis 还支持 publish/subscribe, 通知, key 过期等等特性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上内容摘自：&lt;a href=&quot;http://www.runoob.com/redis/redis-intro.html&quot; class=&quot;uri&quot;&gt;http://www.runoob.com/redis/redis-intro.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于-redis-sentinel-的概念&quot;&gt;2. 关于 Redis Sentinel 的概念&lt;/h2&gt;
&lt;p&gt;Redis Sentinel（译为“哨兵”）是 Redis 官方推荐的高可用性(HA)解决方案，当用 Redis 做 Master-slave 的高可用方案时，假如 master 宕机了，Redis 本身（包括它的很多客户端）都没有实现自动进行主备切换，而 Redis-sentinel 本身也是一个独立运行的进程，它能监控多个 master-slave 集群，发现 master 宕机后能进行自懂切换。&lt;/p&gt;
&lt;p&gt;Redis Sentinel 系统用于管理多个 Redis 服务器（instance），该系统执行以下三个任务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;监控（Monitoring）&lt;/strong&gt;：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提醒（Notification）&lt;/strong&gt;：当被监控的某个 Redis 服务器出现问题时，Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动故障迁移（Automatic failover）&lt;/strong&gt;：当一个主服务器不能正常工作时，Sentinel 会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Redis Sentinel 是一个分布式系统，你可以在一个架构中运行多个 Sentinel 进程（progress），这些进程使用流言协议（gossip protocols）来接收关于主服务器是否下线的信息，并使用投票协议（agreement protocols）来决定是否执行自动故障迁移，以及选择哪个从服务器作为新的主服务器。&lt;/p&gt;
&lt;p&gt;一个 Sentinel 进程可以与其他多个 Sentinel 进程进行连接，每个 Sentinel 进程之间可以互相检查对方的可用性，并进行信息交换。&lt;/p&gt;
&lt;p&gt;以上内容摘自：&lt;a href=&quot;http://redisdoc.com/topic/sentinel.html&quot; class=&quot;uri&quot;&gt;http://redisdoc.com/topic/sentinel.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;搭建-redis-servermaster&quot;&gt;3. 搭建 Redis Server（master）&lt;/h2&gt;
&lt;p&gt;我们就按照上面的架构图进行搭建，大概&lt;strong&gt;三台服务器&lt;/strong&gt;（防火墙关闭）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;10.9.10.154&lt;/span&gt; master   redis-server redis-sentinel
&lt;span class=&quot;kw&quot;&gt;10.9.10.152&lt;/span&gt; slave    redis-server redis-sentinel
&lt;span class=&quot;kw&quot;&gt;10.9.10.215&lt;/span&gt; redis-sentinel&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先从 &lt;a href=&quot;http://download.redis.io/releases/&quot;&gt;redis.io/releases&lt;/a&gt;，下载最新版本的 Redis（需要进行编译）。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;wget&lt;/span&gt; http://download.redis.io/releases/redis-4.0.8.tar.gz
$ &lt;span class=&quot;kw&quot;&gt;tar&lt;/span&gt; xzf redis-4.0.8.tar.gz
$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; redis-4.0.8
$ &lt;span class=&quot;kw&quot;&gt;ls&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;00-RELEASENOTES&lt;/span&gt;  COPYING    Makefile   redis.conf       runtest-sentinel  tests
&lt;span class=&quot;kw&quot;&gt;BUGS&lt;/span&gt;             INSTALL    README.md  runtest          sentinel.conf     utils
&lt;span class=&quot;kw&quot;&gt;CONTRIBUTING&lt;/span&gt;     MANIFESTO  deps       runtest-cluster  src
$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; src
$ &lt;span class=&quot;kw&quot;&gt;make&lt;/span&gt; install

    &lt;span class=&quot;kw&quot;&gt;CC&lt;/span&gt; Makefile.dep
    &lt;span class=&quot;kw&quot;&gt;INSTALL&lt;/span&gt; redis-sentinel
    &lt;span class=&quot;kw&quot;&gt;CC&lt;/span&gt; redis-cli.o
    &lt;span class=&quot;kw&quot;&gt;LINK&lt;/span&gt; redis-cli
    &lt;span class=&quot;kw&quot;&gt;CC&lt;/span&gt; redis-benchmark.o
    &lt;span class=&quot;kw&quot;&gt;LINK&lt;/span&gt; redis-benchmark
    &lt;span class=&quot;kw&quot;&gt;INSTALL&lt;/span&gt; redis-check-rdb

&lt;span class=&quot;kw&quot;&gt;Hint&lt;/span&gt;: It&lt;span class=&quot;st&quot;&gt;'s a good idea to run '&lt;/span&gt;make test&lt;span class=&quot;st&quot;&gt;' ;)&lt;/span&gt;

&lt;span class=&quot;st&quot;&gt;    INSTALL install&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    INSTALL install&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    INSTALL install&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    INSTALL install&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    INSTALL install&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译成功后，会在&lt;code&gt;redis-4.0.8/src&lt;/code&gt;目录下，生成&lt;code&gt;redis-server&lt;/code&gt;和&lt;code&gt;redis-sentinel&lt;/code&gt;可执行文件。&lt;/p&gt;
&lt;p&gt;然后，我们在 master 节点（&lt;code&gt;10.9.10.154&lt;/code&gt;）上，创建&lt;code&gt;redis-4.0.8/redis-master.conf&lt;/code&gt;配置文件，示例配置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 使用守护进程模式&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;daemonize&lt;/span&gt; yes
&lt;span class=&quot;co&quot;&gt;# 非保护模式，可以外网访问&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected-mode&lt;/span&gt; no
&lt;span class=&quot;co&quot;&gt;# 端口号&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;port&lt;/span&gt; 6379
&lt;span class=&quot;co&quot;&gt;# 绑定ip，本机的ip&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;bind&lt;/span&gt; 10.9.10.154
&lt;span class=&quot;co&quot;&gt;# 学习开发，使用最大日志级别，能够看到最多的日志信息&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;loglevel&lt;/span&gt; debug
&lt;span class=&quot;co&quot;&gt;# 指定日志文件路径，没有文件的话，先创建&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;logfile&lt;/span&gt; /home/ubuntu/redis/redis-4.0.8/redis-server.log
&lt;span class=&quot;co&quot;&gt;# 客户端访问，需要密码连接&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;requirepass&lt;/span&gt; 123456&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后启动 master：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;src/redis-server&lt;/span&gt; redis-master.config
$ &lt;span class=&quot;kw&quot;&gt;cat&lt;/span&gt; redis-server.log
&lt;span class=&quot;kw&quot;&gt;8517&lt;/span&gt;:C 28 Feb 06:10:38.345 &lt;span class=&quot;co&quot;&gt;# oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;8517&lt;/span&gt;:C 28 Feb 06:10:38.345 &lt;span class=&quot;co&quot;&gt;# Redis version=4.0.8, bits=64, commit=00000000, modified=0, pid=8517, just started&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;8517&lt;/span&gt;:C 28 Feb 06:10:38.345 &lt;span class=&quot;co&quot;&gt;# Configuration loaded&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;8518&lt;/span&gt;:M 28 Feb 06:10:38.349 * Increased maximum number of open files to 10032 (it was originally set to 1024)&lt;span class=&quot;kw&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;8518&lt;/span&gt;:M 28 Feb 06:10:38.352 * Running mode=standalone, port=6379.
&lt;span class=&quot;kw&quot;&gt;8518&lt;/span&gt;:M 28 Feb 06:10:38.352 &lt;span class=&quot;co&quot;&gt;# WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;8518&lt;/span&gt;:M 28 Feb 06:10:38.352 &lt;span class=&quot;co&quot;&gt;# Server initialized&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;8518&lt;/span&gt;:M 28 Feb 06:10:38.352 &lt;span class=&quot;co&quot;&gt;# WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;8518&lt;/span&gt;:M 28 Feb 06:10:38.352 * Ready to accept connections
&lt;span class=&quot;kw&quot;&gt;8518&lt;/span&gt;:M 28 Feb 06:10:38.352 - 0 clients connected (0 slaves), &lt;span class=&quot;kw&quot;&gt;765776&lt;/span&gt; bytes in use&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看 Redis 的状态：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;redis-cli&lt;/span&gt; -h 10.9.10.154 -p 6379 -a 123456
&lt;span class=&quot;kw&quot;&gt;10.9.10.154&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; INFO replication
&lt;span class=&quot;co&quot;&gt;# Replication&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;role&lt;/span&gt;:master
&lt;span class=&quot;kw&quot;&gt;connected_slaves&lt;/span&gt;:0
&lt;span class=&quot;kw&quot;&gt;master_replid&lt;/span&gt;:7f90fb4ba0c2c450b184a348f23f31d9c40b010d
&lt;span class=&quot;kw&quot;&gt;master_replid2&lt;/span&gt;:0000000000000000000000000000000000000000
&lt;span class=&quot;kw&quot;&gt;master_repl_offset&lt;/span&gt;:0
&lt;span class=&quot;kw&quot;&gt;second_repl_offset&lt;/span&gt;:-1
&lt;span class=&quot;kw&quot;&gt;repl_backlog_active&lt;/span&gt;:0
&lt;span class=&quot;kw&quot;&gt;repl_backlog_size&lt;/span&gt;:1048576
&lt;span class=&quot;kw&quot;&gt;repl_backlog_first_byte_offset&lt;/span&gt;:0
&lt;span class=&quot;kw&quot;&gt;repl_backlog_histlen&lt;/span&gt;:0
&lt;span class=&quot;kw&quot;&gt;10.9.10.154&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; ping
&lt;span class=&quot;kw&quot;&gt;PONG&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加和获取键值测试：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;10.9.10.154&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; set test hello
&lt;span class=&quot;kw&quot;&gt;OK&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;10.9.10.154&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; get test
&lt;span class=&quot;st&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Redis 常用命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动服务：&lt;code&gt;service redis start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;停止服务：&lt;code&gt;service redis stop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启服务：&lt;code&gt;service ngredisnx restart&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果没有配置为 Service 服务，可以用下面命令关闭 Redis：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ src/redis-cli shutdown
或者
$ ps aux | grep redis
$ kill 111&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;搭建-redis-serverslave&quot;&gt;4. 搭建 Redis Server（slave）&lt;/h2&gt;
&lt;p&gt;slave 节点和 master 节点搭建差不多，只不过&lt;code&gt;redis-slave.conf&lt;/code&gt;配置文件，有些不同：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 使用守护进程模式&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;daemonize&lt;/span&gt; yes
&lt;span class=&quot;co&quot;&gt;# 非保护模式，可以外网访问&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected-mode&lt;/span&gt; no 
&lt;span class=&quot;co&quot;&gt;# 端口号&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;port&lt;/span&gt; 6379
&lt;span class=&quot;co&quot;&gt;# 绑定ip，本机的ip&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;bind&lt;/span&gt; 10.9.10.152
&lt;span class=&quot;co&quot;&gt;# 指定 master 的 ip 地址和端口&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;slaveof&lt;/span&gt; 10.9.10.154 6379
&lt;span class=&quot;co&quot;&gt;# 学习开发，使用最大日志级别，能够看到最多的日志信息&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;loglevel&lt;/span&gt; debug
&lt;span class=&quot;co&quot;&gt;# 指定日志文件路径，没有文件的话，先创建&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;logfile&lt;/span&gt; /home/ubuntu/redis/redis-4.0.8/redis-server.log
&lt;span class=&quot;co&quot;&gt;# 设置访问 master 的密码&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;masterauth&lt;/span&gt; 123456&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后启动 slave：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;src/redis-server&lt;/span&gt; redis-slave.conf
$ &lt;span class=&quot;kw&quot;&gt;cat&lt;/span&gt; redis-server.log
&lt;span class=&quot;kw&quot;&gt;7307&lt;/span&gt;:C 28 Feb 06:11:00.987 &lt;span class=&quot;co&quot;&gt;# oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;7307&lt;/span&gt;:C 28 Feb 06:11:00.987 &lt;span class=&quot;co&quot;&gt;# Redis version=4.0.8, bits=64, commit=00000000, modified=0, pid=7307, just started&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;7307&lt;/span&gt;:C 28 Feb 06:11:00.987 &lt;span class=&quot;co&quot;&gt;# Configuration loaded&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.989 * Increased maximum number of open files to 10032 (it was originally set to 1024)&lt;span class=&quot;kw&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.989 * Running mode=standalone, port=6379.
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.990 &lt;span class=&quot;co&quot;&gt;# WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.990 &lt;span class=&quot;co&quot;&gt;# Server initialized&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.990 &lt;span class=&quot;co&quot;&gt;# WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.990 * Ready to accept connections
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.990 - 0 clients connected (0 slaves), &lt;span class=&quot;kw&quot;&gt;765736&lt;/span&gt; bytes in use
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.990 * Connecting to MASTER 10.9.10.154:6379
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.990 * MASTER &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;-&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; SLAVE sync started
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.990 * Non blocking connect for SYNC fired the event.
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.991 * Master replied to PING, replication can continue...
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.993 * Partial resynchronization not possible (no cached master)
&lt;span class=&quot;kw&quot;&gt;7308&lt;/span&gt;:S 28 Feb 06:11:00.995 * Full resync from master: 55b29a9f06ffb89f96106287ce95ddfbdeccb986:0&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看 Redis 的状态：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;redis-cli&lt;/span&gt; -h 10.9.10.152 -p 6379 -a 123456
&lt;span class=&quot;kw&quot;&gt;10.9.10.154&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; INFO replication
&lt;span class=&quot;co&quot;&gt;# Replication&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;role&lt;/span&gt;:slave
&lt;span class=&quot;kw&quot;&gt;master_host&lt;/span&gt;:10.9.10.154
&lt;span class=&quot;kw&quot;&gt;master_port&lt;/span&gt;:6379
&lt;span class=&quot;kw&quot;&gt;master_link_status&lt;/span&gt;:up
&lt;span class=&quot;kw&quot;&gt;master_last_io_seconds_ago&lt;/span&gt;:10
&lt;span class=&quot;kw&quot;&gt;master_sync_in_progress&lt;/span&gt;:0
&lt;span class=&quot;kw&quot;&gt;slave_repl_offset&lt;/span&gt;:280
&lt;span class=&quot;kw&quot;&gt;slave_priority&lt;/span&gt;:100
&lt;span class=&quot;kw&quot;&gt;slave_read_only&lt;/span&gt;:1
&lt;span class=&quot;kw&quot;&gt;connected_slaves&lt;/span&gt;:0
&lt;span class=&quot;kw&quot;&gt;master_replid&lt;/span&gt;:55b29a9f06ffb89f96106287ce95ddfbdeccb986
&lt;span class=&quot;kw&quot;&gt;master_replid2&lt;/span&gt;:0000000000000000000000000000000000000000
&lt;span class=&quot;kw&quot;&gt;master_repl_offset&lt;/span&gt;:280
&lt;span class=&quot;kw&quot;&gt;second_repl_offset&lt;/span&gt;:-1
&lt;span class=&quot;kw&quot;&gt;repl_backlog_active&lt;/span&gt;:1
&lt;span class=&quot;kw&quot;&gt;repl_backlog_size&lt;/span&gt;:1048576
&lt;span class=&quot;kw&quot;&gt;repl_backlog_first_byte_offset&lt;/span&gt;:1
&lt;span class=&quot;kw&quot;&gt;repl_backlog_histlen&lt;/span&gt;:280
&lt;span class=&quot;kw&quot;&gt;10.9.10.152&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; ping
&lt;span class=&quot;kw&quot;&gt;PONG&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们再查看下 master 的状态（更新了&lt;code&gt;connected_slaves&lt;/code&gt;的信息）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;redis-cli&lt;/span&gt; -h 10.9.10.154 -p 6379 -a 123456
&lt;span class=&quot;kw&quot;&gt;10.9.10.154&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; INFO replication
&lt;span class=&quot;co&quot;&gt;# Replication&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;role&lt;/span&gt;:master
&lt;span class=&quot;kw&quot;&gt;connected_slaves&lt;/span&gt;:1
&lt;span class=&quot;kw&quot;&gt;slave0&lt;/span&gt;:ip=10.9.10.152,port=6379,state=online,offset=28,lag=1
&lt;span class=&quot;kw&quot;&gt;master_replid&lt;/span&gt;:55b29a9f06ffb89f96106287ce95ddfbdeccb986
&lt;span class=&quot;kw&quot;&gt;master_replid2&lt;/span&gt;:0000000000000000000000000000000000000000
&lt;span class=&quot;kw&quot;&gt;master_repl_offset&lt;/span&gt;:28
&lt;span class=&quot;kw&quot;&gt;second_repl_offset&lt;/span&gt;:-1
&lt;span class=&quot;kw&quot;&gt;repl_backlog_active&lt;/span&gt;:1
&lt;span class=&quot;kw&quot;&gt;repl_backlog_size&lt;/span&gt;:1048576
&lt;span class=&quot;kw&quot;&gt;repl_backlog_first_byte_offset&lt;/span&gt;:1
&lt;span class=&quot;kw&quot;&gt;repl_backlog_histlen&lt;/span&gt;:28&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，你可以测试下，在 master 上添加一个 key 和 value，然后就可以在 salve 上获取这个对应的 key 的 value。&lt;/p&gt;
&lt;h2 id=&quot;搭建-redis-sentinel&quot;&gt;5. 搭建 Redis Sentinel&lt;/h2&gt;
&lt;p&gt;接着，我们分别在三台服务器上，配置 Redis Sentinel，创建&lt;code&gt;redis-4.0.8/sentinel-my.conf&lt;/code&gt;配置文件，示例配置（记得更改不同的&lt;code&gt;bind ip&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;port&lt;/span&gt; 26379
&lt;span class=&quot;kw&quot;&gt;bind&lt;/span&gt; 10.9.10.154
&lt;span class=&quot;kw&quot;&gt;daemonize&lt;/span&gt; yes
&lt;span class=&quot;kw&quot;&gt;logfile&lt;/span&gt; /home/ubuntu/redis/redis-4.0.8/redis-sentinel.log

&lt;span class=&quot;kw&quot;&gt;sentinel&lt;/span&gt; monitor manager1 10.9.10.154 6379 2
&lt;span class=&quot;kw&quot;&gt;sentinel&lt;/span&gt; auth-pass manager1 123456
&lt;span class=&quot;kw&quot;&gt;sentinel&lt;/span&gt; down-after-milliseconds manager1 60000
&lt;span class=&quot;kw&quot;&gt;sentinel&lt;/span&gt; failover-timeout manager1 180000
&lt;span class=&quot;kw&quot;&gt;sentinel&lt;/span&gt; parallel-syncs manager1 1&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这四行配置为一组，因为我们只有一个 master 节点，所以只配置了一个 master，可以配置多个 master，不用配置 slave 的信息，因为 slave 能够被自动检测到（master 节点会有关于 slave 的消息）&lt;/p&gt;
&lt;p&gt;第一行配置指示 Sentinel 去监视一个名为&lt;code&gt;manager1&lt;/code&gt;的主服务器，这个主服务器的 IP 地址为&lt;code&gt;10.9.10.154&lt;/code&gt;，端口号为 6379，而将这个主服务器判断为失效至少需要 2 个 Sentinel 同意（只要同意 Sentinel 的数量不达标，自动故障迁移就不会执行）。&lt;/p&gt;
&lt;p&gt;其他选项的基本格式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sentinel&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;选项的名字&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;主服务器的名字&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;选项的值&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选项说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;auth-pass&lt;/code&gt;：选项指定了 master 的连接密码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;down-after-milliseconds&lt;/code&gt;：选项指定了 Sentinel 认为服务器已经断线所需的毫秒数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;failover-timeout&lt;/code&gt;：如果在该时间（ms）内未能完成 failover 操作，则认为该 failover 失败。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parallel-syncs&lt;/code&gt;：选项指定了在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步，这个数字越小，完成故障转移所需的时间就越长。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着，我们启动 Redis Sentinel（默认端口 26379）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;src/redis-server&lt;/span&gt; sentinel-my.conf --sentinel
或者
$ &lt;span class=&quot;kw&quot;&gt;src/redis-sentinel&lt;/span&gt; sentinel-my.conf

$ &lt;span class=&quot;kw&quot;&gt;cat&lt;/span&gt; redis-sentinel.log
&lt;span class=&quot;kw&quot;&gt;5716&lt;/span&gt;:X 28 Feb 03:04:17.407 &lt;span class=&quot;co&quot;&gt;# oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;5716&lt;/span&gt;:X 28 Feb 03:04:17.407 &lt;span class=&quot;co&quot;&gt;# Redis version=4.0.8, bits=64, commit=00000000, modified=0, pid=5716, just started&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;5716&lt;/span&gt;:X 28 Feb 03:04:17.407 &lt;span class=&quot;co&quot;&gt;# Configuration loaded&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;5716&lt;/span&gt;:X 28 Feb 03:04:17.408 * Increased maximum number of open files to 10032 (it was originally set to 1024)&lt;span class=&quot;kw&quot;&gt;.&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;_._&lt;/span&gt;
           &lt;span class=&quot;kw&quot;&gt;_.-``&lt;/span&gt;__ &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;-._
      &lt;span class=&quot;kw&quot;&gt;_.-``&lt;/span&gt;    &lt;span class=&quot;kw&quot;&gt;`.&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;`&lt;/span&gt;_.  &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;-._           Redis 4.0.8 (00000000/0) &lt;span class=&quot;kw&quot;&gt;64&lt;/span&gt; bit
  &lt;span class=&quot;kw&quot;&gt;.-``&lt;/span&gt; .-&lt;span class=&quot;kw&quot;&gt;```.&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;```&lt;/span&gt;\/    _.,_ &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;-._
 &lt;span class=&quot;kw&quot;&gt;(&lt;/span&gt;    &lt;span class=&quot;st&quot;&gt;'      ,       .-`  | `,    )     Running in sentinel mode&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt; |`-._`-...-` __...-.``-._|'&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;_.-&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'|     Port: 26379&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt; |    `-._   `._    /     _.-'&lt;/span&gt;    &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt;     &lt;span class=&quot;kw&quot;&gt;PID&lt;/span&gt;: 5716
  &lt;span class=&quot;kw&quot;&gt;`-._&lt;/span&gt;    &lt;span class=&quot;kw&quot;&gt;`-._&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;`&lt;/span&gt;-./  _.-&lt;span class=&quot;st&quot;&gt;'    _.-'&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;|`-._`-._&lt;/span&gt;    &lt;span class=&quot;kw&quot;&gt;`-.__.-&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'    _.-'&lt;/span&gt;_.-&lt;span class=&quot;st&quot;&gt;'|&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt; |    `-._`-._        _.-'&lt;/span&gt;_.-&lt;span class=&quot;st&quot;&gt;'    |           http://redis.io&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  `-._    `-._`-.__.-'&lt;/span&gt;_.-&lt;span class=&quot;st&quot;&gt;'    _.-'&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;|`&lt;/span&gt;-._&lt;span class=&quot;kw&quot;&gt;`-._&lt;/span&gt;    &lt;span class=&quot;kw&quot;&gt;`&lt;/span&gt;-.__.-&lt;span class=&quot;st&quot;&gt;'    _.-'&lt;/span&gt;_.-&lt;span class=&quot;st&quot;&gt;'|&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt; |    `-._`-._        _.-'&lt;/span&gt;_.-&lt;span class=&quot;st&quot;&gt;'    |&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  `-._    `-._`-.__.-'&lt;/span&gt;_.-&lt;span class=&quot;st&quot;&gt;'    _.-'&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;`-._&lt;/span&gt;    &lt;span class=&quot;kw&quot;&gt;`-.__.-&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'    _.-'&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;`-._&lt;/span&gt;        _.-&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;              `-.__.-'&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;5716&lt;/span&gt;:X 28 Feb 03:04:17.410 &lt;span class=&quot;co&quot;&gt;# WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;5716&lt;/span&gt;:X 28 Feb 03:04:17.412 &lt;span class=&quot;co&quot;&gt;# Sentinel ID is 493852dd16017dccdf7b169a256ce7eea2719aff&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;5716&lt;/span&gt;:X 28 Feb 03:04:17.412 &lt;span class=&quot;co&quot;&gt;# +monitor master manager1 10.9.10.154 6379 quorum 2&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当有其他服务器启动 Redis Sentinel 的时候，会有这样的日志（Redis Sentinel 是会相互通信的）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;5716:X 28 Feb 03:18:46.404 # -tilt #tilt mode exited
5716:X 28 Feb 03:19:43.959 * +sentinel sentinel 55ebce153ac69c908800bc14beff24725fc5a721 10.9.10.152 26379 @ manager1 10.9.10.154 6379&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连接测试（测试三台服务器）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;redis-cli&lt;/span&gt; -h 10.9.10.154 -p 26379
&lt;span class=&quot;kw&quot;&gt;10.9.10.154&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; ping
&lt;span class=&quot;kw&quot;&gt;PONG&lt;/span&gt;

$ &lt;span class=&quot;kw&quot;&gt;redis-cli&lt;/span&gt; -h 10.9.10.152 -p 26379
&lt;span class=&quot;kw&quot;&gt;10.9.10.152&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; ping
&lt;span class=&quot;kw&quot;&gt;PONG&lt;/span&gt;

$ &lt;span class=&quot;kw&quot;&gt;redis-cli&lt;/span&gt; -h 10.9.10.155 -p 26379
&lt;span class=&quot;kw&quot;&gt;10.9.10.155&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; ping
&lt;span class=&quot;kw&quot;&gt;PONG&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他常用命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;PING&lt;/code&gt; - 这个命令简单的返回 PONE。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SENTINEL masters&lt;/code&gt; - 展示监控的 master 清单和它们的状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SENTINEL master [master name]&lt;/code&gt; - 展示指定 master 的状态和信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SENTINEL slaves [master name]&lt;/code&gt; - 展示 master 的 slave 清单和它们的状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SENTINEL sentinels [master name]&lt;/code&gt; - 展示 master 的 sentinel 实例的清单和它们的状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SENTINEL get-master-addr-by-name [master name]&lt;/code&gt; - 返回 master 的 IP 和端口。如果故障转移在处理中或成功终止，返回晋升的 slave 的 IP 和端口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SENTINEL reset [pattern]&lt;/code&gt; - 这个命令将重置所有匹配名字的 masters。参数是 blog 风格的。重置的过程清空 master 的所有状态，并移除已经发现和关联 master 的所有 slave 和 sentinel。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SENTINEL failover [master name]&lt;/code&gt; - 如果 master 不可到达，强制执行一个故障转移，而不征求其他 Sentinel 的同意。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SENTINEL ckquorum [master name]&lt;/code&gt; - 检查当前的 Sentinel 配置是否能够到达故障转移需要的法定人数，并且需要授权故障转移的多数。这个命令应该用于监控系统检查部署是否正确。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SENTINEL flushconfig&lt;/code&gt; - 强制 Sentinel 在磁盘上重写它的配置，包括当前的 Sentinel 状态。通常 Sentinel 每次重写配置改变它的状态。然而有时由于操作错误、硬盘故障、包升级脚本或配置管理器可能导致配置文件丢失。在这种情况下收到强制 Sentinel 重写配置文件。这个命令即使上面的配置文件完全不见了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;redis-sentinel-故障转移测试&quot;&gt;6. Redis Sentinel 故障转移测试&lt;/h2&gt;
&lt;p&gt;我们的计划是，将 master 的 Redis 服务停掉，看看 Redis Sentinel 是如何操作的。&lt;/p&gt;
&lt;p&gt;首先，我们先查看下目前 master 节点的信息（记住 IP）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;redis-cli&lt;/span&gt; -h 10.9.10.154 -p 6379
&lt;span class=&quot;kw&quot;&gt;10.9.10.154&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;26379&amp;gt;&lt;/span&gt; SENTINEL get-master-addr-by-name manager1
&lt;span class=&quot;kw&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;st&quot;&gt;&quot;10.9.10.154&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;st&quot;&gt;&quot;6379&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后执行下面命令（强制 Redis Server 休眠 120 秒）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;redis-cli&lt;/span&gt; -h 10.9.10.154 -p 6379 -a 123456 DEBUG sleep 120&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们再查看下 master 节点的信息：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;redis-cli&lt;/span&gt; -h 10.9.10.154 -p 6379
&lt;span class=&quot;kw&quot;&gt;10.9.10.154&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;26379&amp;gt;&lt;/span&gt; SENTINEL get-master-addr-by-name manager1
&lt;span class=&quot;kw&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;st&quot;&gt;&quot;10.9.10.152&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;st&quot;&gt;&quot;6379&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现 IP 已经变成了此前 salve 节点的，也就是说&lt;code&gt;10.9.10.152&lt;/code&gt;变成了 master，然后我们查看下当前 master 的信息：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;redis-cli&lt;/span&gt; -h 10.9.10.152 -p 6379 -a 123456
&lt;span class=&quot;kw&quot;&gt;10.9.10.152&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;6379&amp;gt;&lt;/span&gt; INFO replication
&lt;span class=&quot;co&quot;&gt;# Replication&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;role&lt;/span&gt;:master
&lt;span class=&quot;kw&quot;&gt;connected_slaves&lt;/span&gt;:1
&lt;span class=&quot;kw&quot;&gt;slave0&lt;/span&gt;:ip=10.9.10.154,port=6379,state=online,offset=1270535,lag=0
&lt;span class=&quot;kw&quot;&gt;master_replid&lt;/span&gt;:8b033de60b4be410a1706ff6b27b52b97bcc2981
&lt;span class=&quot;kw&quot;&gt;master_replid2&lt;/span&gt;:e56e893b96e7df8fda00ebcacf1d4b24c9499c4a
&lt;span class=&quot;kw&quot;&gt;master_repl_offset&lt;/span&gt;:1270535
&lt;span class=&quot;kw&quot;&gt;second_repl_offset&lt;/span&gt;:1208143
&lt;span class=&quot;kw&quot;&gt;repl_backlog_active&lt;/span&gt;:1
&lt;span class=&quot;kw&quot;&gt;repl_backlog_size&lt;/span&gt;:1048576
&lt;span class=&quot;kw&quot;&gt;repl_backlog_first_byte_offset&lt;/span&gt;:221960
&lt;span class=&quot;kw&quot;&gt;repl_backlog_histlen&lt;/span&gt;:1048576&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;slave0:ip=10.9.10.154,port=6379&lt;/code&gt;表示此前的 master，已变为现在的 salve。&lt;/p&gt;
&lt;p&gt;整个过程，我们可以查看 Redis Sentinel 的日志：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;20153&lt;/span&gt;:X 28 Feb 09:13:51.023 &lt;span class=&quot;co&quot;&gt;# +sdown master manager1 10.9.10.154 6379&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;20153&lt;/span&gt;:X 28 Feb 09:13:51.243 &lt;span class=&quot;co&quot;&gt;# +new-epoch 1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;20153&lt;/span&gt;:X 28 Feb 09:13:51.244 &lt;span class=&quot;co&quot;&gt;# +vote-for-leader c14ac16f2a43c311c663677b7e056e744e2e2852 1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;20153&lt;/span&gt;:X 28 Feb 09:13:52.102 &lt;span class=&quot;co&quot;&gt;# +odown master manager1 10.9.10.154 6379 #quorum 2/2&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;20153&lt;/span&gt;:X 28 Feb 09:13:52.102 &lt;span class=&quot;co&quot;&gt;# Next failover delay: I will not start a failover before Wed Feb 28 09:19:51 2018&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;20153&lt;/span&gt;:X 28 Feb 09:13:52.365 &lt;span class=&quot;co&quot;&gt;# +config-update-from sentinel c14ac16f2a43c311c663677b7e056e744e2e2852 10.9.10.152 26379 @ manager1 10.9.10.154 6379&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;20153&lt;/span&gt;:X 28 Feb 09:13:52.365 &lt;span class=&quot;co&quot;&gt;# +switch-master manager1 10.9.10.154 6379 10.9.10.152 6379&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;20153&lt;/span&gt;:X 28 Feb 09:13:52.365 * +slave slave 10.9.10.154:6379 10.9.10.154 6379 @ manager1 10.9.10.152 6379
&lt;span class=&quot;kw&quot;&gt;20153&lt;/span&gt;:X 28 Feb 09:15:00.797 * +convert-to-slave slave 10.9.10.154:6379 10.9.10.154 6379 @ manager1 10.9.10.152 6379&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;翻译一下就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个 Sentinel 发现了主节点挂掉了并有一个 +sdown 事件&lt;/li&gt;
&lt;li&gt;这个事件稍候升级到 +odown，意味着大多数 Sentinel 已经同意了主节点是不可达的。&lt;/li&gt;
&lt;li&gt;Sentinels 开始投票一个 Sentinel 开始并尝试故障转移&lt;/li&gt;
&lt;li&gt;故障转移开始&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;另外，需要注意的是，Redis Sentinel 并不是提供对外服务的地址，它只是管理 Redis 主备切换的监测工具，所以，对外 Client 提供的地址，仍是 Redis Server 的地址（包含 salve），当然，也可以像提供负载均衡（SLB）或者虚拟IP（Virtual IP，VIP），进行统一地址的访问。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
</description>
<pubDate>Wed, 28 Feb 2018 16:32:00 +0000</pubDate>
<dc:creator>田园里的蟋蟀</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xishuai/p/redis-sentinel.html</dc:identifier>
</item>
<item>
<title>Spring框架系列之AOP思想 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8486478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8486478.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;微信公众号：compassblog&lt;/p&gt;
&lt;p&gt;欢迎关注、转发，互相学习，共同进步！&lt;/p&gt;
&lt;p&gt;有任何问题，请后台留言联系！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1、AOP概述&lt;/h3&gt;
&lt;p&gt;（1）、什么是 AOP&lt;/p&gt;
&lt;p&gt;AOP 为 Aspect Oriented Programming 的缩写，意为“面向切面编程”。AOP 是 OOP （面向对象）的延续，可以对业务的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性和开发效率。&lt;/p&gt;
&lt;p&gt;（2）、AOP 思想图解：横向重复，纵向切取&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3R4VBiavfDxtNRdwxEAvpgcibhibtkDPcGfAvFAcDjs5UicR6oeicdFHEAsS1nGazlfzXtIIXDXY9kVbZfnqL8c1q5w/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5707154742096506&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3R4VBiavfDxtNRdwxEAvpgcibhibtkDPcGfaicbrjH0nFteAOjQQLDSvlpHgFLZscdUAibxMmbs47ic5jFDO5mhFhWpA/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.575075075075075&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;666&quot;/&gt;&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;事务管理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3R4VBiavfDxtNRdwxEAvpgcibhibtkDPcGfmfpgkzHGl7SaCficsKicTr5ia9Nv2Sia1ibEPxY6chlqk6iaOAvgWJyD07Iw/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6260296540362438&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）、AOP 可以实现的功能&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;权限验证&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志记录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务控制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（4）、AOP 底层实现的两种代理机制&lt;/p&gt;

&lt;h3&gt;2、Spring底层AOP实现原理&lt;/h3&gt;
&lt;p&gt;（1）、 JDK 动态代理增强一个类中方法：被代理对象必须要实现接口，才能产生代理对象。如果没有接口将不能使用动态代理技术。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MyJDKProxy &lt;span class=&quot;hljs-keyword&quot; readability=&quot;7&quot;&gt;implements &lt;span class=&quot;hljs-title&quot; readability=&quot;14&quot;&gt;InvocationHandler { &lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private UserDao userDao; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;MyJDKProxy&lt;span class=&quot;hljs-params&quot;&gt;(UserDao userDao) {   &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.userDao = userDao; &lt;br/&gt;} &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public UserDao &lt;span class=&quot;hljs-title&quot;&gt;createProxy&lt;span class=&quot;hljs-params&quot;&gt;(){&lt;br/&gt;UserDao  userDaoProxy  =  (UserDao)Proxy.newProxyInstance(userDao.getClass().getClassLoader(),userDao.getClass().getInterfaces(), &lt;span class=&quot;hljs-keyword&quot;&gt;this);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return userDaoProxy;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Object &lt;span class=&quot;hljs-title&quot;&gt;invoke&lt;span class=&quot;hljs-params&quot;&gt;(Object proxy, Method method, Object[] args) &lt;span class=&quot;hljs-keyword&quot;&gt;throws Throwable&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if(&lt;span class=&quot;hljs-string&quot;&gt;&quot;save&quot;.equals(method.getName())){&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;权限校验=============&lt;br/&gt;} &lt;br/&gt;return method.invoke(userDao, args); &lt;br/&gt;} &lt;br/&gt;} &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）、Cglib  动态代理增强一个类中的方法：可以对任何类生成代理，代理的原理是对目标对象进行继承代理。如果目标对象被final修饰，那么该类无法被cglib代理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MyCglibProxy &lt;span class=&quot;hljs-keyword&quot; readability=&quot;7&quot;&gt;implements &lt;span class=&quot;hljs-title&quot; readability=&quot;14&quot;&gt;MethodInterceptor{ &lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private CustomerDao customerDao; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;MyCglibProxy&lt;span class=&quot;hljs-params&quot;&gt;(CustomerDao customerDao){   &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.customerDao = customerDao; &lt;br/&gt;} &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Object &lt;span class=&quot;hljs-title&quot;&gt;intercept&lt;span class=&quot;hljs-params&quot;&gt;(Object proxy, Method method, Object[] args, MethodProxy methodProxy) &lt;span class=&quot;hljs-keyword&quot;&gt;throws Throwable {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if(&lt;span class=&quot;hljs-string&quot;&gt;&quot;delete&quot;.equals(method.getName())){&lt;br/&gt;Object obj = methodProxy.invokeSuper(proxy, args);&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;日志记录================&quot;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return obj;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return methodProxy.invokeSuper(proxy, args);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;3、Spring 基于 AspectJ AOP 开发的相关术语&lt;/h3&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Joinpoint(连接点)：所谓连接点是指那些被拦截到的点。在 spring 中，这些点指的是方法，因为 spring 只支持方法类型的连接点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Pointcut(切入点)：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Advice(通知/增强)：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知，通知分为前置通知，后置通知，异常通知，最终通知，环绕通知(切面要完成的功能)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Introduction(引介)：引介是一种特殊的通知，在不修改类代码的前提下， Introduction 可以在运行期为类动态地添加一些方法或 Field&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Target(目标对象)：代理的目标对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Weaving(织入)：是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装在期织入&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Proxy（代理）：一个类被 AOP 织入增强后，就产生一个结果代理类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Aspect(切面)：是切入点和通知（引介）的结合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;您可能还喜欢：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本系列后期仍会持续更新，欢迎关注！&lt;/p&gt;

&lt;p&gt;如果你认为这篇文章有用，欢迎转发分享给你的好友！&lt;/p&gt;
&lt;p&gt;本号文章可以任意转载，转载请注明出处！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;扫码关注微信公众号，了解更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3R4VBiavfDxtNRdwxEAvpgcibhibtkDPcGfvKjdkFbiavV1niaHhT90BSCR7qm7ZdosFfBdFLMsh3MAvtZIeut4fT8Q/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 28 Feb 2018 16:17:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8486478.html</dc:identifier>
</item>
<item>
<title>PHP常见面试题总结 - 郁冬</title>
<link>http://www.cnblogs.com/lamp01/p/8486451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lamp01/p/8486451.html</guid>
<description>&lt;p&gt;&lt;span&gt;1、include 和 require 都能把另外一个文件包含到当前文件中 他们有什么区别?include 和 include_once 又有什么区别?&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 21&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;二者区别只有一个，那就是对包含文件的需求程度&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;include 就是包含，如果被包含的文件不存在的话， 那么则会提示一个错误，但是程序会继续执行下去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;require 意思是需要，如果被包含文件不存在或者 无法打开的时候，则会提示错误，并且会终止程序的执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这两种结构除了在如何处理失败之外完全一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;once 的意思是一次，那么 include_once 和 require_once 表示只包含一次，避免重复包含。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、用最少的代码写一个求 3 值最大的函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot; readability=&quot;45&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;52&quot;&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot; readability=&quot;36&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1128628/201802/1128628-20180228223717197-491717760.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;3、&lt;/em&gt;表单中 get 与 post 提交方法的区别?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1、GET 请求能够被 cache，GET 请求能够被保存在浏览器的浏览历史 里面(密码等重要数据 GET 提交，别人查看历史记录，就可以直接看 到这些私密数据)POST 不进行缓存。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 25&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;3.2、GET 参数是带在 URL 后面，传统 IE 中 URL 的最大可用长度为 2053 字符，其他浏览器对 URL 长度限制实现上有所不同。POST 请求无长 度限制(目前理论上是这样的)。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 26&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;13&quot;&gt;&lt;span&gt;3.3、GET 提交的数据大小，不同浏览器的限制不同，一般在 2k-8K 之间， POST 提交数据比较大，大小靠服务器的设定值限制，而且某些数据 只能用 POST 方法「携带」，比如 file。&lt;/span&gt;
&lt;p&gt;&lt;span&gt;3.4、全部用 POST 不是十分合理，最好先把请求按功能和场景分下类， 对数据请求频繁，数据不敏感且数据量在普通浏览器最小限定的 2k 范围内，这样的情况使用 GET。其他地方使用 POST。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.5、GET 的本质是「得」，而 POST 的本质是「给」。而且，GET 是「幂 等」的，在这一点上，GET 被认为是「安全的」。但实际上 server 端 也可以用作资源更新，但是这种用法违反了约定，容易造成 CSRF(跨 站请求伪造)。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、用 PHP 打印出前一天的时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;格式是 2005-5-10 22:21:21&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot;&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 27&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;date&lt;/span&gt;('Y-m-d H:i:s',&lt;span&gt;time&lt;/span&gt;()-24*3600&lt;span&gt;);
或
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;date&lt;/span&gt;('Y-m-d H:i:s',&lt;span&gt;strtotime&lt;/span&gt;('-1 day'));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、假设现在有一个字符串 ww.baidu.com 如何使用 PHP 对他进行操作使字符串以 moc.udiab.输出?&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;$str='www.baidu.com';
//先替换，再反转
echo strrev('www','',$str);
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot;&gt;&lt;span&gt;6、用 php 写出显示客户端 IP 与服务器 IP 的代码&lt;/span&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 31&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;客户端 IP:&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;   $SERVER[“REMOTE_ADDR”]
&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;或者&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;   getenv('REMOTE_ADDR');
&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;服务器 IP: $_SERVER[“SERVER_ADDR”]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot;&gt;&lt;span&gt;7、写个函数用来对二维数组排序&lt;/span&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 38&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1128628/201802/1128628-20180228225755008-178722459.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 8、&lt;code&gt;'01' == '1';&lt;/code&gt; 结果是 TRUE&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;hljs php&quot;&gt;
&lt;span&gt;&lt;code&gt;in_array(&lt;span class=&quot;hljs-string&quot;&gt;'01',&lt;span class=&quot;hljs-keyword&quot;&gt;array(&lt;span class=&quot;hljs-string&quot;&gt;'1'))；结果是1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot; readability=&quot;32&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1128628/201802/1128628-20180228230702385-1004483674.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9、简述单引号和双引号的用法 双引号串中的内容可以被解释而且替换，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 48&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;单引号串中的内容总被认为是普通字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;10、&lt;/em&gt;&lt;/em&gt;计算某段字符串中某个字符出现的次数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 49&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;12.5&quot;&gt;
&lt;p&gt;&lt;span&gt; (例如:gdfgfdgd59gmkblg 中 g 的次数) $text = 'gdfgfdgd59gmkblg';&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;substr_count&lt;/span&gt; ( &lt;span&gt;$text&lt;/span&gt;,'g'&lt;span&gt;);
 &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11、有一个楼梯n级台阶,每次可以上一级或两级台阶,有几种不同上法?&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 这是一个经典的递归问题.也就是费波纳西级数.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(n) = f(n-1) + f(n-2).&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果我们第一部选1个台阶,那么后面就会剩下n-1个台阶,也就是会有f(n-1)种走法.如果我们第一部选2个台阶,后面会有f(n-2)个台阶.因此,对于n个台阶来说,就会有f(n-1) + f(n-2)种走法.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因此,1个台阶f(1) = 1.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(2) = 2,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(3) = 3 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(4) = 5 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(5) = 8 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(6) = 13 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(7) = 21 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(8) = 34 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(9) = 55 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(10) = 89 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(11) = 89+55 = 144 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(12) = 144 + 89 = 233&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这类题可这样理解 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;假设走到第n阶有f(n)种走法,走到第n+1阶有f(n+1)种走法; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;则走到第n+2阶,则可分成两种情况:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一,最后一步是从第n阶直接登两级到第n+2阶 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;二,最后一步是从第n+1阶直接登一级到第n+2阶 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;由于从地面到第n阶,和到第n+1阶的走法已经知道 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;故从地面到第n+2阶的走法:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;f(n+2)=f(n)+f(n+1) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;n=1时,1种走法 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;n=2时,2种走法 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;n=3时,1+2=3种走法 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;n=4时,2+3=5种走法 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot; readability=&quot;57&quot;&gt;&lt;span&gt;12、普通传值与引用传值及unset&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通传值&lt;/span&gt;
&lt;span&gt;$param1&lt;/span&gt;=1&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;$param2&lt;/span&gt;=2&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;$param2&lt;/span&gt; = &lt;span&gt;$param1&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;$param1&lt;/span&gt; = 5; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量1和变量2是两块内存,互不影响;&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$param2&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所以此处还是显示为1

//引用传值 ↓↓&lt;/span&gt;
&lt;span&gt;$param1&lt;/span&gt;=1&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;$param2&lt;/span&gt;=2&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;$param2&lt;/span&gt; = &amp;amp;&lt;span&gt;$param1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把变量1的内存地址赋给变量2;此时的变量2和变量1全等;&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$param2&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;$param1&lt;/span&gt; = 5; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量1和变量2是一处内存,改变其中一个,另外一个也被改变;&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$param2&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示为5&lt;/span&gt;
?&amp;gt;


&lt;span&gt;$a&lt;/span&gt; = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt; = &amp;amp;&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;unset&lt;/span&gt;(&lt;span&gt;$a&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$b&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;首先,要理解变量名存储在内存栈中,它是指向堆中具体内存的地址,通过变量名查找堆中的内存;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;普通传值,传值以后,是不同的地址名称,指向不同的内存实体;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;引用传值,传引用后,是不同的地址名称,但都指向同一个内存实体;改变其中一个,另外一个就也被改变;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;unset并没有真正销毁变量的作用...仅仅是切断了变量与内存之间的关系，内存只要还被引用着就不会被释放; $b和$a同时指向1,切断其中$a的关系,$b还是指向1,所以上题不报错,照样输出1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot; readability=&quot;33&quot;&gt;&lt;span&gt;13、&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------如何理解static静态变量-----------&lt;/span&gt;
 
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 普通局部变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; local() {
    &lt;/span&gt;&lt;span&gt;$loc&lt;/span&gt; = 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样，如果直接不给初值0是错误的。&lt;/span&gt;
    ++&lt;span&gt;$loc&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$loc&lt;/span&gt; . '&amp;lt;br&amp;gt;'&lt;span&gt;;
}
local(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
local(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
local(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; '===================================&amp;lt;br/&amp;gt;'&lt;span&gt;;
 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* static静态局部变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; static_local() {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;$local&lt;/span&gt; = 0 ; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处可以不赋0值&lt;/span&gt;
    &lt;span&gt;$local&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$local&lt;/span&gt; . '&amp;lt;br&amp;gt;'&lt;span&gt;;
}
static_local(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
static_local(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
static_local(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3
//echo $local; 注意虽然静态变量，但是它仍然是局部的，在外不能直接访问的。&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; '=======================================&amp;lt;br&amp;gt;'&lt;span&gt;;
 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* static静态全局变量(实际上:全局变量本身就是静态存储方式,所有的全局变量都是静态变量) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; static_global() {
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt; &lt;span&gt;$glo&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处，可以不赋值0，当然赋值0，后每次调用时其值都为0，每次调用函数得到的值都会是1，但是不能想当然的写上&quot;static&quot;加以修饰，那样是错误的.&lt;/span&gt;
    &lt;span&gt;$glo&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$glo&lt;/span&gt; . '&amp;lt;br&amp;gt;'&lt;span&gt;;
}
static_global(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
static_global(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
static_global(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
?&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 52&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;8&quot;&gt;&lt;span&gt;在 PHP 中，作用域是不重叠的，函数之外的是全局变量，&lt;/span&gt;
&lt;p&gt;&lt;span&gt;函数内部定义的则是局部变量，二者是两个不同的变量，除非 在函数内使用 global 显式声明使用全局变量或直接用 $_GLOBALS 来引用。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;span&gt; &lt;/span&gt;&lt;/div&gt;
&lt;div title=&quot;Page 22&quot; readability=&quot;14&quot;&gt;&lt;span&gt; 14、$arr = array(‘james’, ‘tom’, ‘symfony’); 请将$arr 数组的值用’ , ’分割并合并成字符串输出&lt;/span&gt;
&lt;div title=&quot;Page 53&quot; readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;echo implode(‘ , ’ , $arr);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$str = ‘jack, james, tom, symfony’;请将$str 用’ , ’分割,并把分割后的值放到$arr 数组中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$arr = explode(‘ , ’ , $str);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;15、说出数组涉及到的常用函数&lt;/span&gt;&lt;/p&gt;
&lt;div title=&quot;Page 56&quot; readability=&quot;9&quot;&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;array-- 声明一个数组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;count -- 计算数组中的单元数目或对象中的属性个数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;foreach-- 遍历数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;list -- 遍历数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;explode-- 将字符串转成数组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;implode-- 将数组转成一个新字符串&lt;/span&gt;&lt;br/&gt;&lt;span&gt;array_merge-- 合并一个或多个数组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;is_array-- 检查是否是数组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;print_r -- 输出数组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sort -- 数组排序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;array_keys-- 返回数组中所有的键名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;array_values-- 返回数组中所有的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;key-- 从关联数组中取得键名&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot; readability=&quot;39&quot;&gt;&lt;span&gt; 16、字符串的常用函数&lt;/span&gt;
&lt;div title=&quot;Page 57&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;trim()-- 去除字符串首尾处的空白字符(或者其他字符)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;strlen()-- 字符串长度&lt;/span&gt;&lt;br/&gt;&lt;span&gt;substr()-- 截取字符串&lt;/span&gt;&lt;br/&gt;&lt;span&gt;str_replace()-- 替换字符串函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;substr_replace()-- 对指定字符串中的部分字符串进行替换 &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;strstr()-- 检索字符串函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;explode()-- 分割字符串函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;implode()-- 将数组合并成字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;str_repeat()-- 重复一个字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;addslashes()-- 转义字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;htmlspecialchars()--THML 实体转义&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;span&gt; &lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;17、写一个函数,能够遍历一个文件夹下的所有文件和子文件夹&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1128628/201802/1128628-20180228235340027-165321536.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;18、&lt;/em&gt;&lt;/em&gt;以下代码的执行后是,$result 值为: &lt;img src=&quot;https://images2018.cnblogs.com/blog/1128628/201802/1128628-20180228235719042-883650288.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 59&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 60&quot; readability=&quot;31.5&quot;&gt;
&lt;p&gt;&lt;span&gt;答案：false&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;section&quot; readability=&quot;8&quot;&gt;&lt;span&gt;is_null-- 检测变量是否为NULL，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果变量是 null 则返回 TRUE，否则返回 FALSE。&lt;/span&gt;
&lt;p&gt;&lt;span&gt;在下列情况下一个变量被认为是 NULL: 1) 被赋值为 NULL&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2) 尚未被赋值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3) 被 unset()&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot;&gt;&lt;span&gt;19、请列举出你所知道的全局环境变量&lt;/span&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 60&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;p&gt;&lt;span&gt; $_ENV;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$_SERVER;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$_REQUEST&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$_FILES&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$_SESSION;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$_COOKIE;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$_GET;&lt;/span&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 22&quot;&gt;&lt;span&gt;20、session 与 cookie 的区别?&lt;/span&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 62&quot;&gt;
&lt;div class=&quot;section&quot;&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 62&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;10&quot;&gt;&lt;span&gt;session:储存用户访问的全局唯一变量,存储在服务器上的 php 指 定的目录中的(session_dir)的位置进行的存放&lt;/span&gt;
&lt;p&gt;&lt;span&gt;cookie:用来存储连续访问一个页面时所使用，是存储在客户端， 对于 Cookie 来说是存储在用户 WIN 的 Temp 目录中的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两者都可通过时间来设置时间长短&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 28 Feb 2018 16:04:00 +0000</pubDate>
<dc:creator>郁冬</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lamp01/p/8486451.html</dc:identifier>
</item>
<item>
<title>makefile讲解 - Mingle_CHB</title>
<link>http://www.cnblogs.com/MINGLE-CHB/p/8486423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MINGLE-CHB/p/8486423.html</guid>
<description>&lt;p&gt;&lt;span&gt;仅供自己学习使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、Makefile介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　Makefile 或 makefile: 告诉make维护一个大型程序， 该做什么。Makefile说明了组成程序的各模块间的相互 关系及更新模块时必须进行的动作， make按照这些说明自动地维护这些模块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　执行make命令时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。 Makefile是一个文本形式的数据库文件，其中包含一些规则来告诉make处理哪些文件以及如何处理这些文件。这些规则主要是描述哪些文件（称为target目标文件，不要和编译时产生的目标文件相混淆）是从哪些别的文件（称为dependency依赖文件）中产生的，以及用什么命令（command）来执行这个过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、Makefile里包含什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Makefile里主要包含了五个部分内容：显式规则、隐式规则、变量定义、文件指示和注释。　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1、显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、隐晦规则。由于make有自动推导的功能，所以隐式规则可以让我们比较粗糙地简略地书写Makefile，这是由make支持的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5、注释。和UNIX的Shell脚本一样Makefile中只有行注释， 其注释是用“#”字符，这个就像C/C++中的“//”或者“ /*”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;在Makefile中的命令，必须要以[Tab]键开始！！！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Makefile的默认文件名为GNUmakefile、makefile或Makefile，多数Linux程序员使用第三种。 执行make命令时，会对磁盘上的文件进行检查，如果目标文件的生成或被改动时的时间至少比它的一个依赖文件还旧的话，make就执行相应的命令，以更新目标文件。目标文件不一定是最后的可执行文件，可以是任何一个中间文件并可以作为其他目标文件的依赖文件。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　引用其它的Makefile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;　Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　include的语法是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　include &amp;lt;filename&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　Make支持三种通配符： “*”、“？”、“[…]” 　　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　include foo.make *.mk $(bar)等价于： include foo.make a.mk b.mk c.mk e.mk f.mk&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、Makefile的规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Makefile文件主要含有一系列的规则，每条规则包含以下内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一个目标（target），即make最终需要创建的文件，如可执行文件和目标文件；目标也可以是要执行的动作，如“clean”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一个或多个依赖文件（dependency）列表，通常是编译目标文件所需要的其他文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 一系列命今(command)，是make执行的动作，通常是把指定的相关文件编译成目标文件的编译命令，每个命令占一行，且每个命令行的起始字符必须为TAB字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如，有以下的Makefile文件：&lt;/p&gt;
&lt;p&gt;# 一个简单的Makefile的例子&lt;/p&gt;
&lt;p&gt;# 以#开头的为注释行&lt;/p&gt;
&lt;p&gt;test：prog.o code.o&lt;/p&gt;
&lt;p&gt;　　   gcc –o test prog.o code.o  &lt;/p&gt;
&lt;p&gt;prog.o：prog.c prog.h code.h&lt;/p&gt;
&lt;p&gt;　　gcc –c prog.c –o prog.o  &lt;/p&gt;
&lt;p&gt;code.o：code.c code.h&lt;/p&gt;
&lt;p&gt;　　gcc –c code.c –o code.o  &lt;/p&gt;
&lt;p&gt;clean：&lt;/p&gt;
&lt;p&gt;　　　rm –f *.o&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　上面的Makefile文件中共定义了四个目标：test、prog.o、code.o和clean。目标从每行的最左边开始写，后面跟一个冒号（：），如果有与这个目标有依赖性的其他目标或文件，把它们列在冒号后面，并以空格隔开。然后另起一行开始写实现这个目标的一组命令。在Makefile中，可使用续行号（\）将一个单独的命令行延续成几行。但要注意在续行号（\）后面不能跟任何字符（包括空格和键）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般情况下，调用make命令可输入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;# make target&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;target是Makefile文件中定义的目标之一，如果省略target，make就将生成Makefile文件中定义的第一个目标。对于上面Makefile的例子，单独的一个“make”命令等价于：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;# make test&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为test是Makefile文件中定义的第一个目标，，所有make首先将其读入，然后从第一行开始执行，把第一个目标test作为它的最终目标后面的目标的更新都会影响到test的更新。第一条规则说明只要文件test的时间戳比文件prog.o或code.o中的任何一个旧，下一行的编译命令将会被执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，在检查文件prog.o和code.o的时间戳之前，make会在下面的行中寻找以prog.o和code.o为目标的规则，在第三行中找到了关于prog.o的规则，该文件的依赖文件是prog.c、prog.h和code.h。同样，make会在后面的规则行中继续查找这些依赖文件的规则，如果找不到，则开始检查这些依赖文件的时间戳，如果这些文件中任何一个的时间戳比prog.o的新，make将执行“gcc –c prog.c –o prog.o”命令，更新prog.o文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以同样的方法，接下来对文件code.o做类似 的检查，依赖文件是code.c和code.h。当make执行完所有这些套嵌的规则后，make将处理最顶层的test规则。如果关于prog.o和code.o的两个规则中的任何一个被执行，至少其中一个.o目标文件就会比test新，那么就要执行test规则中的命令，因此make去执行gcc命令将prog.o和code.o连接成目标文件test。 在上面Makefile的例子中，还定义了一个目标clean，它是Makefile中常用的一种专用目标，即删除所有的目标模块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在来看一下make做的工作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 首先make按顺序读取makefile中的规则，然后检查该规则中的依赖文件与目标文件的时间戳哪个更新，如果目标文件的时问戳比依赖文件还早，就按规则中定义的命令更新目标文件。如果该规则中的依赖文件又是其他规则中的目标文件，那么依照规则链不断执行这个过程，直到Makefile文件的结束，至少可以找到一个不是规则生成的最终依赖文件，获得此文件的时间戳，然后从下到上依照规则链执行目标文件的时间戳比此文件时间戳旧的规则，直到最顶层的规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四、Makefile中的变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;Makefile里的变量就像一个环境变量。事实上，环境变量在make中也被解释成make的变量。这些变量对大小写敏感，一般使用大写宇母。几乎可以从任何地方引用定义的变量，变量的主要作用如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;保存文件名列表。在前面的例子里，作为依赖文件的一些目标文件名出现在可执行文件的规则中，而在这个规则的命令行里同样包含这些文件并传递给gcc做为命令参数。如果使用一个变量来保存所有的目标文件名，则可以方便地加入新的目标文件而且不易出错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;保存可执行命令名，如编译器。在不同的Linux系统中存在着很多相似的编译器系统，这些系统在某些地方会有细微的差别，如果项目被用在一个非gcc的系统里，则必须将所有出现编译器名的地方改成用新的编译器名，比如编译器的版本不同，arm-linux 3.4.1、4.3.2等。如果使用一个变量来代替编译器名，那么只需要改变该变量的值。其他所有地方的命令名就都改变了。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;保存编译器的参数。在很多源代码编译时，gcc需要很长的参数选项，在很多情况下，所有的编译命令使用一组相同的选项，如果把这组选项使用一个变量代表，那么可以把这个变量放在所有引用编译器的地方。当要改变选项的时候，只需改变一次这个变量的内容即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;五、定义变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Makefile中的变量是用一个文本串在Makefile中定义的，这个文本串就是变量的值。只要在一行的开始写下这个变量的名字，后面跟一个“＝”号，以及要设定这个变量的值即可定义变量，下面是定义变量的语法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　VARNAME=string&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用时，把变量用括号括起来，并在前面加上$符号，就可以引用变量的值： ${VARNAME}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　make解释规则时，VARNAME在等式右端展开为定义它的字符串。变量一般都在Makefile的头部定义。按照惯例，所有的Makefile变量都应该是大写。如果变量的值发生变化，就只需要在一个地方修改，从而简化了Makefile的维护。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在利用变量把前面的Makefile重写一遍：&lt;/p&gt;
&lt;p&gt;OBJS=prog.o code.o&lt;/p&gt;
&lt;p&gt;CC=gcc  &lt;/p&gt;
&lt;p&gt;test：${ OBJS }&lt;/p&gt;
&lt;p&gt;　　${ CC } –o test ${ OBJS }&lt;/p&gt;
&lt;p&gt;prog.o：prog.c prog.h code.h&lt;/p&gt;
&lt;p&gt;　　${ CC } –c prog.c –o prog.o&lt;/p&gt;
&lt;p&gt;code.o：code.c code.h&lt;/p&gt;
&lt;p&gt;${ CC } –c code.c –o code.o  &lt;/p&gt;
&lt;p&gt;clean： rm –f *.o&lt;/p&gt;
&lt;p&gt;如：源程序为&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1266551/201802/1266551-20180228234700892-1885847335.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;经过变量替换过后的makefile文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1266551/201802/1266551-20180228234824282-1019510400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;六、Makefile的隐含规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在上面的例子中，几个产生目标文件的命令都是从“.c”的C语言源文件和相关文件通过编译产生“.o”目标文件，这也是一般的步骤。实际上，make可以使工作更加自动化，也就是说，make知道一些默认的动作，它有一些称作隐含规则的内置的规则，这些规则告诉make当用户没有完整地给出某些命令的时候，应该怎样执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如，把生成prog.o和code.o的命令从规则中删除，make将会查找隐含规则，然后会找到并执行一个适当的命令。由于这些命令会使用一些变量，因此可以通过改变这些变量来定制make。象在前面的例子中所定义的那样，make使用变量CC来定义编译器，并且传递变量CFLAGS（编译器参数）、CPPFLAGS（C语言预处理器参数）、TARGET_ARCH（目标机器的结构定义）给编译器，然后加上参数-c，后面跟变量$&amp;lt;（第一个依赖文件名），然后是参数-o加变量$@（目标文件名）。综上所述，一个C编译的具体命令将会是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$ {CC} $ {CFLAGS} $ {CPPFLAGS} $ {TARGET_ARCH} –c $&amp;lt; -o $@&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1266551/201802/1266551-20180228234929728-490474825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在上面的例子中，利用隐含规则，可以简化为：&lt;/p&gt;
&lt;p&gt;OBJS=prog.o code.o&lt;/p&gt;
&lt;p&gt;CC=gcc&lt;/p&gt;
&lt;p&gt;test：${ OBJS }&lt;/p&gt;
&lt;p&gt;　　${ CC } –o $@ $^  &lt;/p&gt;
&lt;p&gt;prog.o：prog.c prog.h code.h&lt;/p&gt;
&lt;p&gt;code.o：code.c code.h  &lt;/p&gt;
&lt;p&gt;clean： rm –f *.o&lt;/p&gt;

</description>
<pubDate>Wed, 28 Feb 2018 15:53:00 +0000</pubDate>
<dc:creator>Mingle_CHB</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MINGLE-CHB/p/8486423.html</dc:identifier>
</item>
<item>
<title>战狼项目：美团点评金融核心交易系统可用性7个9是这样炼成的 - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/8486390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/8486390.html</guid>
<description>&lt;p&gt;　　本文是我原创，首发于美团点评技术团队博客。原文地址是：https://mp.weixin.qq.com/s/fx6XfBpuzozsJCvllMcCqw。欢迎大家转载，转载请注明出处，谢谢~~。&lt;/p&gt;

&lt;p&gt;背景&lt;/p&gt;

&lt;p&gt;2017年8月25日，我怀着“再也不要在下班时间收到报警”的美好期待，加入美团金融智能支付负责核心交易，结果入职后收到的报警一天紧似一天。核心交易是整个智能支付的核心链路，承担着智能支付百分之百的流量，不敢有丝毫的懈怠。&lt;/p&gt;
&lt;p&gt;　　从17年下半年开始，我们的日单量增长迅速，而且压力和流量在午、晚高峰时段非常集中。在这种情况下，报警和小事故日益频繁，交易的稳定性面临着严峻的考验。下面是早期的可用性趋势图，仔细看的话，可以看到可用性有下降的趋势，旁边的总可用性显示只有4个9（99.998765%），美团点评排在第一的价值观是“以客户为中心”，显然对交易这种稳定性要求非常高的系统，低于5个9是不可容忍的。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.42543171114599687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GPwOP9GOk5e4ZaicOR8MK1S60xDib4VsXQYShUfHOO3HaqNKuJxRibvc6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动排查&lt;/p&gt;

&lt;p&gt;在很长时间里，我们做的只是在原有系统上增加功能，架构上没有大调整。但是随着业务增长，就算我们系统没有任何发版升级，也会突然出现一些事故。事故出现的频率越来越高，我们自身的升级，也经常是困难重重。基础设施升级、上下游升级，经常会发生“蝴蝶效应”，毫无征兆的受到影响。以下是这些现象的鱼骨图分析：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5818181818181818&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GENslxuH9eJb6s4A50Y2tZBsWX1sl0mcaa7ArKseyOgMLgCFc9Dl1LQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了保证交易的高可用，智能支付技术团队快速整合平台和集团技术资源，成立了专题项目组——“战狼”，聚焦支付技术底层基础，排查系统风险点和系统问题，全力为智能支付商户与客户提供一个良好、安全、顺畅的支付体验。使命必达，为核心交易系统保驾护航！&lt;/p&gt;

&lt;p&gt;发现问题&lt;/p&gt;

&lt;p&gt;通过排查，我们发现了系统的主要问题，从大方面说就是：外部的问题和自身的问题，当然症结在于架构的问题。问题分类如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.44692737430167595&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GDIRqjyyuUMe1PqYLxS1iaibzYwzDR3ZaT2Af0ZPhB5OiaetwIHFZyZ6vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1432&quot;/&gt;&lt;/p&gt;

&lt;p&gt;值得一提的是：如果我们业务量没有上来，这些问题其实本不是问题。系统刚搭建完成好比建造了一个“土房子”，考虑自己能在里面住就可以了，而发展到四合院，就要考虑东厢、西厢等一些布局的问题，再发展到一个小区，就涉及内部道路、配套等等，再大一点发展成一个城市，就要涉及要各种保障工作，比如下雨了怎么排水，进城要设置哪些关卡，哪些道路要放置监控等。&lt;/p&gt;

&lt;p&gt;系统建设也是这样，一个用户基数小、日活少的系统，要考虑的主要是完成功能，随着业务量增大，就要开始涉及系统间的问题，接着去发展一些基础设施、共通组件等，而我们目前的局面是，系统已经扩大到了“城市”的规模，我们要解决更繁重的问题。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.8227699530516432&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1G3gXw0EulWkRM0NyjRjJWqYtibxFrGu15Vuaml1UqhQ9m6WVwGB3eUbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1704&quot;/&gt;&lt;/p&gt;

&lt;p&gt;分析问题&lt;/p&gt;

&lt;p&gt;首先我们要对目前所面临的问题进行分析。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;事务中包含外部调用&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;外部调用包括对外部系统的调用和基础组件的调用。它具有返回时间不确定性的特征，必然会造成大事务。大的数据库事务会造成其它对数据库连接的请求获取不到，那么和这个数据库相关的所有服务都很可能处于等待状态，造成连接池被打满，多个服务直接宕掉。如果这个没做好，危险指数五颗星。下面的图显示出外部调用时间的不可控：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5392&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GF80RtWOc93ia77e3faw5UqyqB8CNiaY1ZlkTNKHllXGTSAM1qRrAIGVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;超时时间和重试次数不合理&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;对外部系统和缓存、消息队列等基础组件的依赖，如果超时时间设置过长、重试过多，系统长时间不返回，可能会导致连接池被打满，系统死掉；如果超时时间设置过短，499错误会增多，系统的可用性会降低。如果超时时间设置得短，重试次数设置得多，会增加系统的整体耗时；如果超时时间设置得短，重试次数设置得也少，那么这次请求的返回结果会不准确。波士顿矩阵分析图如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;295&quot; data-ratio=&quot;0.5463576158940397&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1G1b1V0jI81ZGmWzCFeq2tqxSa5copPsgvru6AH6mFiaARicgsk8ImJP7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1208&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;举个例子：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1G36j3AtGVkpA3LCM3pfPHtzX1v5jWYhXmQicZTMWvTrhrkT8PHetdt2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;326&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务A依赖于两个服务的数据完成此次操作。平时没有问题，假如服务B在你不知道的情况下，响应时间变长，甚至停止服务，而你的客户端超时时间设置过长，则你完成此次请求的响应时间就会变长，此时如果发生意外，后果会很严重。&lt;/p&gt;

&lt;p&gt;Java的Servlet容器，无论是Tomcat还是Jetty都是多线程模型，都用worker线程来处理请求。这个可配置有上限，当你的请求打满worker线程的最大值之后，剩余请求会被放到等待队列。等待队列也有上限，一旦等待队列都满了，那这台Web Server就会拒绝服务，对应到Nginx上返回就是502。如果你的服务是QPS较高的服务，那基本上这种场景下，你的服务也会跟着被拖垮。如果你的上游也没有合理的设置超时时间，那故障会继续向上扩散。这种故障逐级放大的过程，就是服务雪崩效应。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;外部依赖的地方没有熔断&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在依赖的服务不可用时，服务调用方应该通过一些技术手段，向上提供有损服务，保证业务柔性可用。而系统没有熔断，如果由于代码逻辑问题上线引起故障、网络问题、调用超时、业务促销调用量激增、服务容量不足等原因，服务调用链路上有一个下游服务出现故障，就可能导致接入层其它的业务不可用。下图是对无熔断影响的鱼骨图分析：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4183082271147161&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GOxIpffrsj4MCibDZouxMJYcCBTxushI9eHWSFufvmIHrR4QC84aXYvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1726&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;对于依赖我们的上游没有限流&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在开放式的网络环境下，对外系统往往会收到很多有意无意的恶意攻击，如DDoS攻击、用户失败重刷。虽然我们的队友各个是精英，但还是要做好保障，不被上游的疏忽影响，毕竟，谁也无法保证其他同学哪天会写一个如果下游返回不符合预期就无限次重试的代码。这些内部和外部的巨量调用，如果不加以保护，往往会扩散到后台服务，最终可能引起后台基础服务宕机。下图是对无限流影响的问题树分析：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.508301404853129&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GKiaF3tqB6ibVdTq8BphG8ybicHiaUQTVMyfIGRDyZ41Quc0FLKMkvQ9sng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1566&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;慢查询问题&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;慢查询会降低应用的响应性能和并发性能。在业务量增加的情况下造成数据库所在的服务器CPU利用率急剧攀升，严重的会导致数据库不响应，只能重启解决。关于慢查询，可以参考我们技术博客之前的文章《&lt;a href=&quot;https://tech.meituan.com/mysql-index.html&quot;&gt;MySQL索引原理及慢查询优化&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6646216768916156&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GrkiazAuVXZKHm8qn0g5PV2mJRAxJFxiaYTxKjltYich2JvOhpWsczXZOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;978&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;依赖不合理&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;每多一个依赖方，风险就会累加。特别是强依赖，它本身意味着一荣俱荣、一损俱损。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.439312567132116&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1Gj9djrUiavXGE5YFlibzniaicsETgACWMe5exLHjNpmWATewpxClzZXVD7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1862&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;废弃逻辑和临时代码&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;过期的代码会对正常逻辑有干扰，让代码不清晰。特别是对新加入的同事，他们对明白干什么用的代码可以处理。但是已经废弃的和临时的，因为不知道干什么用的，所以改起来更忐忑。如果知道是废弃的，其它功能改了这一块没改，也有可能这块不兼容，引发问题。下图是William Pietri（曾任Code for America的研发总监）定义的代码类别，不持续维护的代码从长期成本来说是很高的：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.38246041412911086&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GpxIEGHWnR5hEyEVzkT1TMG7iaV9jia9uTSibusyxDsAqwc3kHKvW8wo6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1642&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;没有有效的资源隔离&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;容易造成级联多米诺骨牌效应。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.2664609053497942&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GjmWvM3dDgj5RNaUqL8lZ8xMYa2Ft7C4kuWCZTLJ2WziaV7icpEaTY2gQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1944&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对上述问题，我们提出了解决方案。&lt;/p&gt;


&lt;p&gt;解决问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 事务中不包含外部调用&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;排查各个系统的代码，检查在事务中是否存在RPC调用、HTTP调用、消息队列操作、缓存、循环查询等耗时的操作，这个操作应该移到事务之外，理想的情况是事务内只处理数据库操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对大事务添加监控报警。大事务发生时，会收到邮件和短信提醒，一般的报警标准是1s。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;建议不要用XML配置事务，而采用注解的方式。原因是XML配置事务，第一可读性不强，第二切面通常配置的比较泛滥，容易造成事务过大，第三对于嵌套情况的规则不好处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;strong&gt;2. 超时时间设置合理和重试次数&lt;/strong&gt;&lt;/h2&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先要调研被依赖服务自己调用下游的超时时间是多少。调用方的超时时间要大于被依赖方调用下游的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;统计这个接口99%的超时时间是多少，设置的超时时间在这个基础上加50%。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;重试次数如果系统服务重要性高，则按照默认，一般是重试三次。否则，可以不重试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;3. 外部依赖的地方都要做熔断&lt;/strong&gt;&lt;/h2&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;自动熔断：可以使用Netflix的Hystrix或者美团点评自己研发的Rhino来做快速失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;手动熔断：确认下游支付通道抖动或不可用，可以手动关闭通道。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;strong&gt;4. 对于依赖我们的上游要限流&lt;/strong&gt;&lt;/h2&gt;


&lt;h2&gt;&lt;strong&gt;5. 解决慢查询问题&lt;/strong&gt;&lt;/h2&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将查询分成实时查询、近实时查询和离线查询。实时查询可穿透数据库，其它的不走数据库，可以用Elasticsearch来实现一个查询中心，处理近实时查询和离线查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;读写分离。写走主库，读走从库。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;索引优化。索引过多会影响数据库写性能。索引不够查询会慢。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像核心交易这种数据库读写TPS差不多的，一般建议索引不超过4个。如果这还不能解决问题，那很可能需要调整表结构设计了。&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;6. 能去依赖就去依赖，否则尽量同步强依赖改成异步弱依赖&lt;/strong&gt;&lt;/h2&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;划清业务边界，只做该做的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果依赖一个系统提供的数据，上游可以作为参数传入或者下游可以作为返回值返回，则可以下线专门去取数据的逻辑，尽量让上下游给我们数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们写入基础组件，数据提供给其它端，如果其它端有兜底策略，则我们可以异步写入，不用保证数据100%不丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;7. 精简代码逻辑&lt;/strong&gt;&lt;/h2&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;梳理每个接口的调用情况，对于没有调用量的接口，确认不再使用后及时下线。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;code review保证每段逻辑都明白其含义，弄清楚是否是历史逻辑或者临时逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;8. 核心路径进行资源隔离&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;服务器物理隔离原则&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;① 内外有别：内部系统与对外开放平台区分对待。&lt;br/&gt;② 内部隔离：从上游到下游按通道从物理服务器上进行隔离，低流量服务合并。&lt;br/&gt;③ 外部隔离：按渠道隔离，渠道之间互不影响。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线程池资源隔离&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;注意：尽管线程池提供了线程隔离，客户端底层代码也必须要有超时设置，不能无限制的阻塞以致于线程池一直饱和。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信号量资源隔离&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;除了上面的措施之外，战狼项目还进行了很有成效的两地三中心机房互备、组件安全漏洞修复和服务健康验证，限于篇幅，本文就不详述了。《Clean Code》一书里说沟通是专业开发者的头等大事，我个人也认为它可以说是项目过程中最重要的环节。没有很好的沟通，就好像是越走越远的两个人，我在等着你回心转意，你却在等着自己死心，你发现心死不了，我却已经放弃了等待。永远在平行线上没有交集，只是徒增苦痛，没有意义。&lt;/p&gt;

&lt;p&gt;实施后的效果&lt;/p&gt;

&lt;p&gt;通过这场“飞行中换引擎”的战狼项目，线上事故急剧减少，基本上维持在零事故。监控报警从常态变成偶尔发生。为了系统性地检验效果。我们进行了多次故障演练。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.45052631578947366&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1Gib5EfoL5gw54npc11Y57TsGcibiaL0gurzDDSvN8PQkBE2iadftUrYibgpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1900&quot;/&gt;&lt;/p&gt;
&lt;p&gt;演练效果符合预期，系统稳定性符合标准。这过程中有很多收获和乐趣，比如第一次演练的时候，把缓存挂掉，系统竟然跟着挂了。所以以后的每次演练都觉得这是很重要的事情。&lt;/p&gt;

&lt;p&gt;就好像我3年前从一家公司离职，当时因为是冬天好多人感冒了，咳嗽。我就开玩笑跟我搭档说：“去了新公司听不到咳嗽声了会不会不适应。”搭档跟我说：“到了新公司肯定还会出现专门咳嗽给你听的人。”所以从此，我在办公室里听到咳嗽声，都会朝自己笑一笑。一件不经意的小事，让本来很多不是好事的事情变得有意义。“战狼”项目，开始是由于故障和报警引起的，肯定算不上是好事。但是这也催生出了“战狼”这样意义重大，影响深远的项目。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;近期我们的可用性除了因为一次下游通道抖动引起的可用性6个9之外，其它时间可用性均为100%。下面为可用性趋势图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;182&quot; data-ratio=&quot;0.4580941446613088&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GfHCaZj9iaqFQwhpVpPR7l0gUzF50S0WBnXdsPFFXWzInuwXrSlTmsyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1742&quot;/&gt;&lt;/p&gt;
&lt;p&gt;持续跟进&lt;/p&gt;

&lt;p&gt;我们优化了业务大盘、故障大盘。加强了监控报警机制，持续监控和保障着系统的稳定性。故障演练也作为了定时的日常工作来做。稳定性需要建立长期规范，维护组内的checklist，定期检查是否达到标准。checklist举例如下：　　&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.8583535108958837&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1Gsc6NIZvt1Q9CxloyL27NCjP4T1pjvSxC4PJ7BxUiassfpmnZFpiamRcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1652&quot;/&gt;&lt;/p&gt;


&lt;p&gt;项目总结&lt;/p&gt;

&lt;p&gt;我们家老大是像星星一样散发着智慧的人，他给我们总结系统稳定性的三个要素：&lt;strong&gt;第一是别人死我们不死，第二是不自己作死，第三是不被猪队友搞死。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;稳定性具体的实施方法总结一下就是：能不依赖就去依赖，尽可能将强依赖转成弱依赖，实在不能降低依赖就保护依赖，做好自保，出了问题只能收敛不能扩大，对危险要能监控。&lt;/p&gt;

&lt;p&gt;线上支付平台总结的稳定性“四板斧”：&lt;strong&gt;研发规范、自身稳定、容错下游、防御上游。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经过为期4周的战狼项目，多个小组紧密合作，日夜兼程，高效地完成了一个又一个攻坚任务，保证了交易系统的稳定。整个项目收获的不仅是一套稳定的系统，更重要的是通过一次次的激烈探讨，一场场集体推进会，总结出了一套通用的系统稳定提升方法，同时也锻炼出一只充满战斗力的队伍，为整个支付业务快速稳定发展奠定了基础。&lt;/p&gt;

&lt;p&gt;所谓生于忧患，死于安乐。历史上，重大危机总是发生在承平日久之后。战狼项目虽然已经结束，但是战狼精神永存。我们要时时刻刻居安思危，保持稳定第一。&lt;/p&gt;


&lt;p&gt;工具介绍&lt;/p&gt;

&lt;p&gt;项目中多次提到使用Hystrix和Rhino。所以这里对它们做一个简单的介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hystrix&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hystrix实现了断路器模式来对故障进行监控，当断路器发现调用接口发生了长时间等待，就使用快速失败策略，向上返回一个错误响应，这样达到防止阻塞的目的。这里重点介绍一下Hystrix的线程池资源隔离和信号量资源隔离。&lt;/p&gt;
&lt;p&gt;线程池资源隔离&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用线程可以完全隔离第三方代码，请求线程可以快速放回。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当一个失败的依赖再次变成可用时，线程池将清理，并立即恢复可用，而不是一个长时间的恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以完全模拟异步调用，方便异步编程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;线程池的主要缺点是它增加了CPU，因为每个命令的执行涉及到排队（默认使用SynchronousQueue避免排队），调度和上下文切换。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对使用ThreadLocal等依赖线程状态的代码增加复杂性，需要手动传递和清理线程状态（Netflix公司内部认为线程隔离开销足够小，不会造成重大的成本或性能的影响）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;信号量资源隔离&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开发者可以使用Hystrix限制系统对某一个依赖的最高并发数。这个基本上就是一个限流策略，每次调用依赖时都会检查一下是否到达信号量的限制值，如达到，则拒绝。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;比较一下线程池资源隔离和信号量资源隔离&lt;/strong&gt;&lt;/p&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;线程隔离是和主线程无关的其他线程来运行的；而信号量隔离是和主线程在同一个线程上做的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;信号量隔离也可以用于限制并发访问，防止阻塞扩散，与线程隔离的最大不同在于执行依赖代码的线程依然是请求线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;线程池隔离适用于第三方应用或者接口、并发量大的隔离；信号量隔离适用于内部应用或者中间件；并发需求不是很大的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.3742953776775648&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GQ3zPxcItCvCliaZQe0wn5Zg7gKzRic9aeltgSGcbaiakQUseKNLxicpyoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1774&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rhino&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Rhino是美团点评基础架构团队研发并维护的一个稳定性保障组件，提供故障模拟、降级演练、服务熔断、服务限流等功能。和Hystrix对比：&lt;/p&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.91818181818182&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Hystrix组件在熔断之后，并在试探线程成功之后，就直接关闭熔断开关，全部流量走正常逻辑。而Rhino会对流量进行恢复灰度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;内部通过CAT（美团点评开源的监控系统，参见之前的博客“&lt;a href=&quot;https://tech.meituan.com/CAT_in_Depth_Java_Application_Monitoring.html&quot;&gt;深度剖析开源分布式监控CAT&lt;/a&gt;”）进行了一系列埋点，方便进行服务异常报警。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接入配置中心，能提供动态参数修改，比如强制熔断、修改失败率等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于作者&lt;/p&gt;

&lt;p&gt;晓静，20岁时毕业于东北大学计算机系。在毕业后的第一家公司由于出众的语言天赋，在1年的时间里从零开始学日语并以超高分通过了国际日语一级考试，担当两年日语翻译的工作。后就职于人人网，转型做互联网开发。中国科学院心理学研究生。有近百个技术发明专利，创业公司合伙人。有日本东京，美国硅谷技术支持经验。目前任美团点评技术专家，负责核心交易。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GBc57Zsbm0aHu1MU4YTNIHvqBXw4VxCh5wlowVGnvm00au1iahllfy8g/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU7rbbCviaPU1aM3yUIOFQ1GBc57Zsbm0aHu1MU4YTNIHvqBXw4VxCh5wlowVGnvm00au1iahllfy8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注静儿的个人技术公众号：编程一生&lt;/p&gt;

&lt;p&gt;招贤纳士&lt;/p&gt;

&lt;p&gt;美团金融核心交易大量招收Java高级工程师、技术专家。高速发展的业务需要高速发展的团队，作为核心部门，我们急需相信技术改变世界的你！有意者请关注我的个人技术公众号并留言:-)&lt;/p&gt;

&lt;p&gt;我们的老大很有想法，团队氛围一级棒，欢迎加入我们的大家庭哦~~&lt;/p&gt;

</description>
<pubDate>Wed, 28 Feb 2018 15:41:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/8486390.html</dc:identifier>
</item>
</channel>
</rss>