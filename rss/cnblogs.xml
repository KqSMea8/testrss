<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Skyline桌面二次开发之路径漫游（C#） - MaxFish</title>
<link>http://www.cnblogs.com/huangwei1992/p/9487843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangwei1992/p/9487843.html</guid>
<description>&lt;p&gt;所谓路径漫游：即创建一个动态对象和一条由多点组成的线，然后让动态对象沿着线飞行&lt;/p&gt;
&lt;p&gt;首先绘制一条线，实际上路径漫游是不需要绘制线的，我这里只是为了确认动态对象是否沿着线路在飞行，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//绘制路径
            double[] cVerticesArray = null;
            cVerticesArray = new double[] {
                        116.35,  27.98,  0,
                        116.45,  28.98,  0,
                        116.45,  28.11,  0,
                        116.65,  28.45,  0,
                     };

            ILineString pILineString = sgWorld.Creator.GeometryCreator.CreateLineStringGeometry(cVerticesArray);
            IColor66 color = sgWorld.Creator.CreateColor(255, 0, 0, 125);
            var polyline = sgWorld.Creator.CreatePolyline(pILineString, color);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来创建动态对象，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var dynamicObject = this.sgWorld.Creator.CreateDynamicObject(0, DynamicMotionStyle.MOTION_GROUND_VEHICLE, DynamicObjectType.DYNAMIC_IMAGE_LABEL, @&quot;F:\项目管理\智慧抚州\使用的Fly\data11\汽车图标\整车.png&quot;, 50, AltitudeTypeCode.ATC_TERRAIN_RELATIVE, &quot;&quot;, &quot;动态对象&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;第一个参数0&lt;span&gt;：一组 IRouteWaypoint66对象，后续向动态对象中添加&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个参数&lt;/span&gt;DynamicMotionStyle&lt;span&gt;：移动方式，是一个枚举类型，具体的效果大家可以去试一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三个参数&lt;/span&gt;DynamicObjectType&lt;span&gt;：动态对象类型，是一个枚举类型，该参数也决定了你第四个参数的文件类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四个参数：由于第三个参数选择的Image_label，这里我选择了一张图片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五个参数50：文件缩放大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第六个参数&lt;/span&gt;AltitudeTypeCode：高度模式&lt;/p&gt;
&lt;p&gt;动态对象创建完成之后就是创建路径的拐点，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var wayPoint1 = this.sgWorld.Creator.CreateRouteWaypoint(116.35, 27.98, 0, 2000);
            var wayPoint2 = this.sgWorld.Creator.CreateRouteWaypoint(116.45, 28.98, 0, 2000);
            var wayPoint3 = this.sgWorld.Creator.CreateRouteWaypoint(116.55, 28.11, 0, 800);
            var wayPoint4 = this.sgWorld.Creator.CreateRouteWaypoint(116.65, 28.45, 0, 800);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后将拐点添加到动态对象中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
            dynamicObject.Waypoints.AddWaypoint(wayPoint1);
            dynamicObject.Waypoints.AddWaypoint(wayPoint2);
            dynamicObject.Waypoints.AddWaypoint(wayPoint3);
            dynamicObject.Waypoints.AddWaypoint(wayPoint4);
            dynamicObject.CircularRoute = false;
            dynamicObject.RestartRoute(0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后调用飞行到对象，就可以实现路径漫游效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sgWorld.Navigate.FlyTo(dynamicObject.ID, ActionCode.AC_JUMP);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; &lt;/h2&gt;
</description>
<pubDate>Thu, 16 Aug 2018 07:58:00 +0000</pubDate>
<dc:creator>MaxFish</dc:creator>
<og:description>所谓路径漫游：即创建一个动态对象和一条由多点组成的线，然后让动态对象沿着线飞行 首先绘制一条线，实际上路径漫游是不需要绘制线的，我这里只是为了确认动态对象是否沿着线路在飞行，代码如下： 接下来创建动态</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangwei1992/p/9487843.html</dc:identifier>
</item>
<item>
<title>闭包和一部电影的关系 - 大众美男典范</title>
<link>http://www.cnblogs.com/best-xiaoqiang/p/9487792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/best-xiaoqiang/p/9487792.html</guid>
<description>&lt;h2&gt;闭包的定义&lt;/h2&gt;
&lt;p&gt;在网上，关于闭包的文章众多。&lt;/p&gt;
&lt;p&gt;MDN文档中说：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;闭包是函数和声明该函数的词法环境的组合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很多文章中说：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;闭包是指有权访问另一个函数作用域中的变量的函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有一篇文章，总结了闭包的四种定义。&lt;/p&gt;
&lt;p&gt;最后，我决定去请教我的一个经验丰富的同事。&lt;/p&gt;
&lt;p&gt;他说：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;闭包就是闭着的包子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;我发现闭包的最大难点，就是没有一个明确的定义。&lt;/p&gt;
&lt;p&gt;于是，我去其精华、取其糟粕，写下这篇关于闭包但完全不去定义闭包的文章。&lt;/p&gt;
&lt;h2&gt;作用域和变量对象&lt;/h2&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function outter(){
    var name = '小强'
    function inner(){
        console.log(name)
    }
    return inner
}
var foo = outter()
foo()   // '小强'
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面这段代码，就是一个闭包。&lt;/p&gt;
&lt;p&gt;（&lt;em&gt;无论闭包的定义是什么，这段代码基本上是通行的&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;首先，如果套用这个定义：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;闭包是指有权访问另一个函数作用域中的变量的函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，函数&lt;code&gt;inner&lt;/code&gt;就是闭包，因为我们知道：&lt;/p&gt;
&lt;p&gt;定义在函数内部的函数，是可以访问外部函数的作用域的。&lt;/p&gt;
&lt;p&gt;简写一下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function outter(){
    var name = '小强'
    function inner(){
        console.log(name)
    }
    inner()
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这种结构下，&lt;code&gt;inner&lt;/code&gt;函数还是有权访问&lt;code&gt;outter&lt;/code&gt;函数作用域中的变量的，所以这是不是闭包？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（欢迎讨论）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上面代码，是一种最常见的函数嵌套。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;outter&lt;/code&gt;函数执行时，会创建一个属于&lt;code&gt;outter&lt;/code&gt;的执行环境及变量对象。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;inner&lt;/code&gt;函数执行时，又会创建一个&lt;code&gt;inner&lt;/code&gt;的执行环境及变量对象。&lt;/p&gt;
&lt;p&gt;它们的相同点是：&lt;/p&gt;
&lt;p&gt;执行完毕之后，各自的执行环境及变量对象都会被销毁。&lt;/p&gt;
&lt;p&gt;尽管函数是一等公民，但是它们执行完毕后、变得“没用”，JS很快将它们“灭门”，这就是JS垃圾回收机制。&lt;/p&gt;
&lt;p&gt;它们的联系是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inner&lt;/code&gt;函数可以访问到&lt;code&gt;outter&lt;/code&gt;函数的变量对象。&lt;/p&gt;
&lt;p&gt;变量对象，顾名思义，就是保存该函数自身变量的一个对象。&lt;/p&gt;
&lt;p&gt;内部函数保存所有外层函数的变量对象，形成了自己的作用域。&lt;/p&gt;
&lt;p&gt;即&lt;code&gt;inner&lt;/code&gt;函数的作用域，包括自身的变量对象、&lt;code&gt;outter&lt;/code&gt;的变量对象和window的变量对象。&lt;/p&gt;
&lt;p&gt;为什么要保存别人的变量对象？&lt;/p&gt;
&lt;p&gt;因为对自己有用，自身没有的话就可以去用外层的。&lt;/p&gt;
&lt;p&gt;可以说，外层函数的变量服务于内部函数。&lt;/p&gt;
&lt;h2&gt;闭包中的变量对象&lt;/h2&gt;
&lt;p&gt;再回到这种形式：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function outter(){
    var name = '小强'
    function inner(){
        console.log(name)
    }
    return inner
}
var foo = outter()
foo()   // '小强'
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;不同于普通嵌套，&lt;/p&gt;
&lt;p&gt;这里当&lt;code&gt;outter&lt;/code&gt;函数执行到最后时，将&lt;code&gt;inner&lt;/code&gt;函数&lt;code&gt;return&lt;/code&gt;了出去。&lt;/p&gt;
&lt;p&gt;显然，&lt;code&gt;outter&lt;/code&gt;已经执行完毕了，但是它的执行环境及变量对象都被销毁了吗？&lt;/p&gt;
&lt;p&gt;并不是。&lt;/p&gt;
&lt;p&gt;有一个幸存者，就是&lt;strong&gt;&lt;code&gt;outter&lt;/code&gt;函数的变量对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;虽然&lt;code&gt;outter&lt;/code&gt;函数在&lt;code&gt;return&lt;/code&gt;之后，自身已经执行完毕。&lt;/p&gt;
&lt;p&gt;但是，因为它&lt;code&gt;return&lt;/code&gt;的是嵌套在自己内部的函数&lt;code&gt;inner&lt;/code&gt;，并赋值给全局变量&lt;code&gt;foo&lt;/code&gt;，这就导致：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一方面，&lt;code&gt;outter&lt;/code&gt;函数执行完毕，&lt;code&gt;outter&lt;/code&gt;的变量对象理应被销毁&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;另一方面，&lt;code&gt;inner&lt;/code&gt;函数被赋值给全局变量，随时有可能被调用，那它的作用域不应该被破坏，其中的&lt;code&gt;outter&lt;/code&gt;变量对象也就不该被销毁&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面已经说过：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;内部函数保存所有外层函数的变量对象，形成了自己的作用域&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，就是因为还有用，所以&lt;code&gt;outter&lt;/code&gt;函数的变量对象并没有在&lt;code&gt;outter&lt;/code&gt;执行后被销毁，成为幸存者。&lt;/p&gt;
&lt;p&gt;最终，当我执行&lt;code&gt;foo()&lt;/code&gt;的时候，&lt;/p&gt;
&lt;p&gt;尽管&lt;code&gt;outter&lt;/code&gt;函数早已执行完毕，但依然可以打印出其变量&lt;code&gt;name&lt;/code&gt;的值'帅哥小强'。&lt;/p&gt;
&lt;h3&gt;闭包和一部电影的关系&lt;/h3&gt;
&lt;p&gt;而我想到的，是《辛德勒名单》这部电影。&lt;/p&gt;
&lt;p&gt;1939年，波兰在纳粹德国的统治下，党卫军对犹太人进行了&lt;strong&gt;隔离统治&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这时，德国商人奥斯卡·辛德勒和德军建立了良好的关系，他的工厂雇用犹太人工作，大发战争财。&lt;/p&gt;
&lt;p&gt;犹太人遭到了德军的大屠杀，辛德勒目睹了这一切之后十分震撼。&lt;/p&gt;
&lt;p&gt;辛德勒让自己的工厂成为集中营的附属劳役营，在那些疯狂屠杀的日子里，他的工厂也成为了犹太人的避难所。&lt;/p&gt;
&lt;p&gt;德国战败前夕，屠杀犹太人的行动越发疯狂，辛德勒向德军军官开出了1200人的名单，倾家荡产买下了这些犹太人的生命。&lt;/p&gt;
&lt;p&gt;这个电影很有名，如果没看过建议看一下。&lt;/p&gt;
&lt;p&gt;同样，在我们的JS世界中：&lt;/p&gt;
&lt;p&gt;当一个函数执行完毕，它的执行环境及变量对象也会遭到一场屠杀，即垃圾回收机制。&lt;/p&gt;
&lt;p&gt;在这场屠杀中，辛德勒用一份自己工厂员工的名单，使自己的工厂成为集中营的附属劳役营，更成为犹太人的避难所。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;inner&lt;/code&gt;函数，也有一份自己员工的名单，那就是作用域。&lt;/p&gt;
&lt;p&gt;这份名单上，就包含了&lt;code&gt;outter&lt;/code&gt;函数的变量对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inner&lt;/code&gt;函数被赋值给全局变量，就好比辛德勒和德军建立了良好关系，&lt;/p&gt;
&lt;p&gt;它的作用域就成为变量对象的避难所，&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;outter&lt;/code&gt;函数的变量对象被写在&lt;code&gt;inner&lt;/code&gt;函数的员工名单（即作用域）中，所以才免遭杀害。&lt;/p&gt;
&lt;p&gt;这就是JS版的《辛德勒名单》。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;那么在这个过程中，你认为哪部分属于闭包呢？&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Aug 2018 07:53:00 +0000</pubDate>
<dc:creator>大众美男典范</dc:creator>
<og:description>闭包的定义 在网上，关于闭包的文章众多。 MDN文档中说： 闭包是函数和声明该函数的词法环境的组合 很多文章中说： 闭包是指有权访问另一个函数作用域中的变量的函数 还有一篇文章，总结了闭包的四种定义。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/best-xiaoqiang/p/9487792.html</dc:identifier>
</item>
<item>
<title>Qt动态库静态库的创建、使用、多级库依赖等详细说明 - 苦涩的茶</title>
<link>http://www.cnblogs.com/liushui-sky/p/9487583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liushui-sky/p/9487583.html</guid>
<description>&lt;p&gt;本文描述的是windows系统下，通过qtcreator在pro文件中添加动态库与静态库的方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、添加动态库（直接添加动态库文件.dll，非子项目）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过qtcreator创建动态库的方法就不在此处赘述了。&lt;/p&gt;
&lt;p&gt;唯一值得强调的是动态库与静态库的创建在pro文件中配置的区别在于静态库多了&lt;/p&gt;
&lt;pre&gt;
CONFIG += staticlib ，如下图所示（稍安勿躁，以下示例的工程代码最后会统一打包上传）
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816142149566-940770762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：mingw32编译器生成的动态库文件包括一个***.dll和一个***.a文件，vc编译器生成的动态库文件包含一个***.dll和一个***.lib文件&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816142311162-2018676433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来言归正传，如何添加动态库，右击工程名，选择“添加库”，由于是添加外部的库，就选择“外部库”，如果是子项目的生成的动态库，则选择“内部库”，系统库就不在此介绍了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816142425923-199100410.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816143050455-1204605020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要吐槽下，貌似qtcreator添加外部库的步骤在windows下只能添加.lib文件，也就是说主要用于添加vc编译器生成的动态库文件，这个比较坑，linux下到是没有这个问题。&lt;/p&gt;
&lt;p&gt;那么qtcreator mingw32编译器生成的库如何添加呢，在看上面两幅图的第一幅，添加库的最终目的是“请将库和它的include路径添加到.pro文件中”，所以我们直接把库文件和include路径直接写到pro文件中即可。添加方法主要有以下几种，不赘述，直接看图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816143815655-1103285009.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样动态库就添加好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、添加静态库（直接添加静态库文件.a，非子项目）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与添加动态库类似，不详细说明，直接看图，相信聪明的你一看就明白&lt;/p&gt;
&lt;p&gt;pro文件：　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　编译生成文件（静态库***.a文件）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816144155802-1930596793.png&quot; alt=&quot;&quot;/&gt;      　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816144306319-1311076906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，如何添加静态库，右击工程名，选择“添加库”，由于是添加外部的库，就选择“外部库”，如果是子项目的生成的动态库，则选择“内部库”，系统库就不在此介绍了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816142425923-199100410.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816144659825-339281569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是得说声抱歉，貌似qtcreator添加外部库的步骤在windows下不管是动态库和静态库都只能添加.lib文件，也就是说主要用于添加vc编译器生成的动态库（库文件.dll和其引导文件.lib）和静态库文件（.lib文件），这个比较坑，linux下到是没有这个问题。&lt;/p&gt;
&lt;p&gt;那么上面qtcreator mingw32编译器生成的静态库如何添加呢，其实跟添加动态库是一样的，指定库文件和include路径，具体看第一节的图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、添加动态库或静态库子项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个工程包含多个子项目时，往往一个带main主文件的项目作为主项目（即最后运行的程序），其它子项目以生成库（动态库或者静态库）的方式让主项目进行包含。&lt;/p&gt;
&lt;p&gt;未来调试方便，我们通过添加”内部库”的方式建立依赖关系，达到动态关联的目的。添加方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816145629807-358657224.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816145937550-522283215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816150042653-1328342916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终在test_lib.pro的文件中添加了以上代码，但是由于mingw32生成的静态库不带lib文件，所以以上最后3行要删除，即下图中的注释部分不需要&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816150243571-1333588468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加内部动态库更加简单，都不用删除，见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816150439011-8629591.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816150505354-1421326561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;4、多级库依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下图中项目为例介绍，test_lib依赖test_lib.2，而test依赖test_lib，所以也要依赖test_lib2，记住不管动态库还是静态库子项目都要把多级依赖的库都添加上，而且还要注意顺利（具体如图中红线所示），否则哪怕编译未出错，也无法正常实现功能。也许有人先在test项目pro中加上了test_lib2的依赖，然后编译通过了，然后再注释掉重新编译还是可以正常运行，但是我想告诉你的是----这都是假象，不相信你把编译的文件都删掉再编译就不行了，这只不过是qtcreator重新构建的功能没有把一些编译文件清除干净而已，所以还是要求把依赖项都加上。这个依赖关系的学习可以具体看这篇文章https://www.cnblogs.com/liushui-sky/articles/9487600.html&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816153523764-657221607.png&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;&lt;span&gt;注意：这里包含的顺序与库依赖的顺序刚好相反，最底层的子项目在上面，最顶层的项目在下面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816151024475-55879637.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816151151518-1433556001.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816151354418-129768509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816151325216-1767874370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、动态库、静态库混合使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个是否可以混合使用呢，答案当然是可以的了，为什么这么说呢，一个很简单的道理——动态编译的qt库本身都是dll的，而静态编译的子项目生成的库为静态库，既然这样可以 &lt;/p&gt;
&lt;p&gt;使用说明就可以一起混合使用。具体还是以上述项目为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816151024475-55879637.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816153126677-2063839659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816151354418-129768509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/350840/201808/350840-20180816151325216-1767874370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里把test_lib2配置为生成静态库，test_lib不变，仍为动态库，test依次包含，运行结果OK，说明可行。&lt;/p&gt;
&lt;p&gt; 项目示例代码位置：https://files.cnblogs.com/files/liushui-sky/TEST123.rar&lt;/p&gt;

</description>
<pubDate>Thu, 16 Aug 2018 07:40:00 +0000</pubDate>
<dc:creator>苦涩的茶</dc:creator>
<og:description>本文描述的是windows系统下，通过qtcreator在pro文件中添加动态库与静态库的方法： 1、添加动态库（直接添加动态库文件.dll，非子项目） 通过qtcreator创建动态库的方法就不在此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liushui-sky/p/9487583.html</dc:identifier>
</item>
<item>
<title>使用浏览器访问或调试微信公众号（跳过微信认证） - lulianqi15</title>
<link>http://www.cnblogs.com/lulianqi/p/9482259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lulianqi/p/9482259.html</guid>
<description>
&lt;p&gt;因为大部分公众号web应用实际登录都是使用用户微信认证登录，下文主要是提供一种方法使在PC端使用任意浏览器绕过微信认证完成登录，后面就可以在浏览器中使用或调试web应用。&lt;/p&gt;


&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;应用服务器(我们自己的第三方应用程序)需要知道是谁在访问服务（登录），而在微信公众号应用中登录一般都是使用静默的oauth2，由微信认证用户的真实性，并通知应用服务器当前用户是哪位（openid）&lt;/p&gt;

&lt;p&gt;那能不能跳过微信应用程序由第三方来模拟（模拟微信应用程序，骗过微信oauth2服务器）完成oauth2授权？&lt;/p&gt;
&lt;/div&gt;


&lt;div&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/209007/201808/209007-20180816153318068-1645350977.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;请求1&lt;/strong&gt;：一般就是一个对公众号网页的范围，一旦我们自己的应用服务器发现这个用户授权失效（没有相应cookie，或cookie对不上），那服务器返回302，要求用户（微信APP内置 浏览器）跳转至微信授权服务器 『https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;amp;redirect_uri=REDIRECT_URI&amp;amp;response_type=code&amp;amp;scope=SCOPE&amp;amp;state=STATE#wechat_redirect』 这里有个关键信息appid，应用服务器会把appid带上，以便微信授权服务器识别是那个公众号来授权了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;请求2，3&lt;/strong&gt;：用户按302的指示向微信服务器进行授权，在2，3中微信用户不仅把之前的appid带上，还带上了uni（user information 正常也只在微信跟微信服务通讯中用），跟一个关键的key。（这个key值每次授权不不一样，所以保存下来重放也无效），猜测key是由微信应用程序根据用户信息，公众号信息加密合成的，外部应用程序也是很难仿照。第2步 的 appid与uin向微信服务器换取了uuid，第3步，微信返回了关键的code参数，并通知微信应用程序301到 我们的应用服务的地址。 （实际上一旦应用服务器拿到code，后面的步骤就可以不一定一定需要微信APP参与了）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;请求4&lt;/strong&gt;：用户带着微信返回的code请求我们的应用服务器，我们自己的应用服务器拿到code后向微信授权服务器换取网页授权access_token 『https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;amp;secret=SECRET&amp;amp;code=CODE&amp;amp;grant_type=authorization_code』 注意这个请求需要带上secret，即表示这个请求只能由我们的应用服务器来完成（secret不能公开）&lt;/p&gt;
&lt;p&gt;完成请求5后我们的应用服务器已经拿到openid，access_token ，简单的应用取得openid后即已经能确定用户的身份了。如果需要用户的详细信息可以使openid，access_token用进一步向微信服务器请求&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结束&lt;/strong&gt;：一般应用服务器使用用户的openid标识用户，所以得到通过用户请求中的code获取到openid后即表示用户已经被认证，应用服务器此时通常在这个请求的response中加入Set-Cookie将登录信息写入微信浏览器（或者对之前的cookie的认证信息标记为有效）&lt;/p&gt;


&lt;p&gt;通过上面简单的步骤可以看出来无论是客户端（微信）还是应用服务器都有私有的类似secret的数据，来保证各自的不可伪造性。所以无论是想要伪造谁都不是那么简单&lt;/p&gt;

&lt;p&gt;但是一旦微信oauth2完成后的安全性就会变成一般浏览器的一样，应用服务器验证用户基本上都凭借请求中带的含有十分信息的cookie。也就是说我们只要能在微信公众号（服务号）应用完成认证后将相应的cookie取出并写入浏览器（或者其他调试工具），那浏览器就可以通过后面应用服务器的身份验证（无论当前网页使用怎样的域名甚至是前端人员的本地页面）&lt;/p&gt;

&lt;p&gt;那现在就是2个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取网站授权完成后的cookie（cookie可能会有很多，而我们其实不用关注哪个是认证用户信息用的，全部拿过来就行了）。对于cookie的获取其实还是比较方便的，如果被设置为微信公众号的开发者可以直接使用微信web开发者工具，调试信息包括cookies也都会有，如果不是开发者无法进入调试模式也没有关系，任何针对http协议及更底层协议的抓包工具都可以查看request所携带的cookie信息。&lt;/li&gt;
&lt;li&gt;然后就是将cookies信息写入浏览器，如果是浏览器可以在Console中修改cookies，不过要求必须必须带有js执行能力的控制台的浏览器。还是一个就是通过response的head头 Set-Cookie来完成cookie的写入及修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面接受一种更简单的步骤完上面2个步骤&lt;/p&gt;


&lt;p&gt;直接在手机微信上打开公众号（订阅号）页面，使用fiddler抓取指定网站任意页面请求（也可以使用PC版微信打开公众号页面）&lt;/p&gt;
&lt;p&gt;进入free cookies 标签页（free cookies 插件下载地址 使用说明）&lt;/p&gt;
&lt;p&gt;选择目标域名网址的任意页面请求（注意图片及js资源可能不含有cookies信息）点击Get Cookies获取cookie （如下图）&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/209007/201808/209007-20180816153514230-1064864698.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;打开本地调试页面（也可以是其他域名或是同一域名）&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/209007/201808/209007-20180816153626475-1256615582.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;填写目标地址到UrlFilter，勾选Injeck Cookies，在浏览器中对该站点任意请求进行刷新操作（cookie 写入完成后建议取消勾选，或者不要勾选Inject Always）&lt;/p&gt;
&lt;p&gt;写入cookies后就可以看到页面再与服务器的交互就已经完成了“登录”&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/209007/201808/209007-20180816153542785-1733333585.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;最后下图展示一张京东到家公众号应用直接在chrome，并完成了微信的认证登录。（实际是手机微信的登录后将cookie再写到Chrome里，这里jd需要在浏览器中修改UA，chrome本身就可以直接修改UA）&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/209007/201808/209007-20180816153757148-1258051055.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;以上使用到的 Fiddler插件freeCookies 说明见 &lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/9481203.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lulianqi/p/9481203.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码见github： &lt;a href=&quot;https://github.com/lulianqi/FreeCookies&quot; target=&quot;_blank&quot;&gt;https://github.com/lulianqi/FreeCookies&lt;/a&gt;&lt;/p&gt;





</description>
<pubDate>Thu, 16 Aug 2018 07:21:00 +0000</pubDate>
<dc:creator>lulianqi15</dc:creator>
<og:description>因为大部分公众号web应用实际登录都是使用用户微信认证登录，下文主要是提供一种方法使在PC端使用任意浏览器绕过微信认证完成登录，后面就可以在浏览器中使用或调试web应用。 应用服务器(我们自己的第三方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lulianqi/p/9482259.html</dc:identifier>
</item>
<item>
<title>基于docker的spark-hadoop分布式集群之二： 环境测试 - Fordestiny</title>
<link>http://www.cnblogs.com/Fordestiny/p/9487303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Fordestiny/p/9487303.html</guid>
<description>&lt;p&gt;在上一节搭建的集群环境基础上，本节对各个模块做个测试&lt;/p&gt;
&lt;h2 id=&quot;mysql-测试&quot;&gt;Mysql 测试&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、Mysql节点准备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为方便测试，在mysql节点中，增加点数据&lt;/p&gt;
&lt;p&gt;进入主节点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker exec -it hadoop-maste /bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入数据库节点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh hadoop-mysql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create database zeppelin_test;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建数据表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table user_info(id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,name VARCHAR(16),age INT);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加几条数据，主键让其自增：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert into user_info(name,age) values(&quot;aaa&quot;,10);
insert into user_info(name,age) values(&quot;bbb&quot;,20);
insert into user_info(name,age) values(&quot;ccc&quot;,30);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、Zeppelin配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置驱动及URL地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;default.driver  ====&amp;gt;   com.mysql.jdbc.Driver
default.url     ====&amp;gt;   jdbc:mysql://hadoop-mysql:3306/zeppelin_test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使zeppelin导入mysql-connector-java库（maven仓库中获取）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql:mysql-connector-java:8.0.12&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、测试mysql查询&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%jdbc
select * from user_info;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应能打印出先前插入的几条数据。&lt;/p&gt;
&lt;h2 id=&quot;hive测试&quot;&gt;Hive测试&lt;/h2&gt;
&lt;p&gt;本次使用JDBC测试连接Hive，注意上一节中，hive-site.xml的一个关键配置，若要使用JDBC连接（即TCP模式），hive.server2.transport.mode应设置为binary。&lt;/p&gt;
&lt;p&gt;1、Zeppelin配置&lt;/p&gt;
&lt;p&gt;（1）增加hive解释器，在JDBC模式修改如下配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;default.driver  ====&amp;gt;   org.apache.hive.jdbc.HiveDriver

default.url     ====&amp;gt;   jdbc:hive2://hadoop-hive:10000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）添加依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;org.apache.hive:hive-jdbc:0.14.0
org.apache.hadoop:hadoop-common:2.6.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、测试&lt;/p&gt;
&lt;p&gt;Zeppelin增加一个note&lt;/p&gt;
&lt;p&gt;增加一个DB：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%hive
CREATE SCHEMA user_hive&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;%hive
use user_hive&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一张表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%hive
create table if not exists user_hive.employee(id int ,name string ,age int)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%hive
insert into user_hive.employee(id,name,age) values(1,&quot;aaa&quot;,10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再打印一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%hive
select * from user_hive.employee&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有的操作，都是OK的。&lt;/p&gt;
&lt;p&gt;另外，可以从mydql中的hive.DBS表中，查看到刚刚创建的数据库的元信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%jdbc
select * frmo hive.DBS;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138381/201808/1138381-20180816153612955-269233923.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图显示了刚刚创建的DB的元数据。&lt;/p&gt;
&lt;p&gt;登录Hadoop管理后台，应也能看到该文件信息（容器环境将Hadoop的50070端口映射为宿主机的51070）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:51070/explorer.html#/home/hive/warehouse/user_hive.db&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，user_hive.db/employee下，有刚刚创建的数据文件，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138381/201808/1138381-20180816153818787-289481396.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分布式测试&quot;&gt;分布式测试&lt;/h2&gt;
&lt;p&gt;在上一节基础上，进入主从节点，可以看到，在相同的目录下，都存在有相同的数据内容，可见上一节对于hive的操作，在主从节点是都是生效的。操作如下：&lt;/p&gt;
&lt;p&gt;主节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@hadoop-maste:~# hdfs dfs -ls  /home/hive/warehouse/user_hive.db/employee
Found 1 items
-rwxr-xr-x   2 gpadmin supergroup          9 2018-08-15 11:36 /home/hive/warehouse/user_hive.db/employee/000000_0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@hadoop-node1:~# hdfs dfs -ls  /home/hive/warehouse/user_hive.db/employee
Found 1 items
-rwxr-xr-x   2 gpadmin supergroup          9 2018-08-15 11:36 /home/hive/warehouse/user_hive.db/employee/000000_0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试-spark-操作-hive&quot;&gt;测试 Spark 操作 hive&lt;/h2&gt;
&lt;p&gt;通过spark向刚才创建的user_hive.db中写入两条数据，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import org.apache.spark.sql.{SQLContext, Row}
import org.apache.spark.sql.types.{StringType, IntegerType, StructField, StructType}
import org.apache.spark.sql.hive.HiveContext
//import hiveContext.implicits._

val hiveCtx = new HiveContext(sc)

val employeeRDD = sc.parallelize(Array(&quot;6 rc 26&quot;,&quot;7 gh 27&quot;)).map(_.split(&quot; &quot;))

val schema = StructType(List(StructField(&quot;id&quot;, IntegerType, true),StructField(&quot;name&quot;, StringType, true),StructField(&quot;age&quot;, IntegerType, true)))

val rowRDD = employeeRDD.map(p =&amp;gt; Row(p(0).toInt, p(1).trim, p(2).toInt))

val employeeDataFrame = hiveCtx.createDataFrame(rowRDD, schema)

employeeDataFrame.registerTempTable(&quot;tempTable&quot;)

hiveCtx.sql(&quot;insert into user_hive.employee select * from tempTable&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后，查一下hive&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%hive
select * from employee&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，数据已经写进文件中了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138381/201808/1138381-20180816150627675-1113557628.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Aug 2018 07:07:00 +0000</pubDate>
<dc:creator>Fordestiny</dc:creator>
<og:description>在上一节搭建的集群环境基础上，本节对各个模块做个测试 Mysql 测试 1、Mysql节点准备 为方便测试，在mysql节点中，增加点数据 进入主节点 进入数据库节点 创建数据库 创建数据表 增加几条</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Fordestiny/p/9487303.html</dc:identifier>
</item>
<item>
<title>案例学编程系列：案例认识 Spring IOC - 一只阿木木</title>
<link>http://www.cnblogs.com/yizhiamumu/p/9487380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yizhiamumu/p/9487380.html</guid>
<description>&lt;p data-source-line=&quot;2&quot;&gt;本文spring libs 地址&lt;a href=&quot;https://github.com/yizhiamumu/springlibs/&quot; target=&quot;_blank&quot;&gt;：https://github.com/yizhiamumu/springlibs&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-能帮我们做什么&quot; data-source-line=&quot;5&quot;&gt;Spring 能帮我们做什么&lt;/h2&gt;
&lt;ul data-source-line=&quot;7&quot;&gt;&lt;li&gt;①.Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系。&lt;/li&gt;
&lt;li&gt;②.Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。&lt;/li&gt;
&lt;li&gt;③.Spring 能非常简单的帮我们管理数据库事务。&lt;/li&gt;
&lt;li&gt;④.Spring 还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板来方便数据库访问。&lt;/li&gt;
&lt;li&gt;⑤.Spring 还提供与第三方Web（如Struts1/2、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。&lt;/li&gt;
&lt;li&gt;⑥.Spring 能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-的优势&quot; data-source-line=&quot;15&quot;&gt;Spring 的优势&lt;/h2&gt;
&lt;ul data-source-line=&quot;17&quot;&gt;&lt;li&gt;低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦）&lt;/li&gt;
&lt;li&gt;声明式事务管理（基于切面和惯例）&lt;/li&gt;
&lt;li&gt;方便集成其他框架（如MyBatis、Hibernate）&lt;/li&gt;
&lt;li&gt;降低 Java 开发难度&lt;/li&gt;
&lt;li&gt;Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-ioc-是什么&quot; data-source-line=&quot;24&quot;&gt;Spring IoC 是什么&lt;/h2&gt;
&lt;ul data-source-line=&quot;25&quot;&gt;&lt;li&gt;IoC：Inverse of Control（控制反转）&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;27&quot;&gt;读作“反转控制”更好理解。将原本在程序中手动创建对象的控制权，交由Spring框架来管理。&lt;/p&gt;
&lt;ul data-source-line=&quot;30&quot;&gt;&lt;li&gt;正控：若要使用某个对象，需要自己去负责对象的创建&lt;/li&gt;
&lt;li&gt;反控：若要使用某个对象，只需要从 Spring 容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;33&quot;&gt;在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。&lt;/p&gt;
&lt;h4 id=&quot;谁控制谁&quot; data-source-line=&quot;35&quot;&gt;●谁控制谁？&lt;/h4&gt;
&lt;p data-source-line=&quot;37&quot;&gt;我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；&lt;/p&gt;
&lt;h4 id=&quot;控制什么&quot; data-source-line=&quot;39&quot;&gt;●控制什么？&lt;/h4&gt;
&lt;p data-source-line=&quot;40&quot;&gt;主要控制了外部资源获取。&lt;/p&gt;
&lt;h4 id=&quot;为何是反转&quot; data-source-line=&quot;42&quot;&gt;●为何是反转？&lt;/h4&gt;
&lt;p data-source-line=&quot;44&quot;&gt;有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；&lt;/p&gt;
&lt;p data-source-line=&quot;46&quot;&gt;为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；&lt;/p&gt;
&lt;h4 id=&quot;反转了什么&quot; data-source-line=&quot;48&quot;&gt;●反转了什么？&lt;/h4&gt;
&lt;p data-source-line=&quot;49&quot;&gt;依赖对象的获取被反转了。&lt;/p&gt;
&lt;h3 id=&quot;案例1认识springioc&quot; data-source-line=&quot;51&quot;&gt;案例1：认识springIOC&lt;/h3&gt;
&lt;h4 id=&quot;正控&quot; data-source-line=&quot;53&quot;&gt;正控&lt;/h4&gt;
&lt;p data-source-line=&quot;55&quot;&gt;1.创建员工类&lt;/p&gt;
&lt;p data-source-line=&quot;57&quot;&gt;Employee.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Employee {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 系统id &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 员工编号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String employeeNo;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 员工姓名 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String employeeName;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 员工性别 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 出生日期 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date birthDay;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 部门编号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String officeNo;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 岗位编号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String postNo;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 入职时间 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date entryTime;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 特长 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String speciality;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 兴趣爱好 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String hobby;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; setter and getter &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;96&quot;&gt;2.创建测试方法，并调用构造函数创建对象。&lt;/p&gt;
&lt;p data-source-line=&quot;98&quot;&gt;TestSpringEmp.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSpringEmp {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Employee emp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Employee();

        System.out.println(emp);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;springioc-控制反转&quot; data-source-line=&quot;111&quot;&gt;springIOC 控制反转&lt;/h4&gt;
&lt;h5 id=&quot;环境搭建&quot; data-source-line=&quot;113&quot;&gt;环境搭建：&lt;/h5&gt;
&lt;p data-source-line=&quot;115&quot;&gt;1.idea 工程添加Spring相关jar包。【libs 上传至git 地址，操作方法见附录】&lt;/p&gt;
&lt;p data-source-line=&quot;117&quot;&gt;2.创建配置文件，可以自定义文件名spring.xml。&lt;/p&gt;
&lt;p data-source-line=&quot;119&quot;&gt;3.调用API。&lt;/p&gt;
&lt;h5 id=&quot;程序思路&quot; data-source-line=&quot;121&quot;&gt;程序思路：&lt;/h5&gt;
&lt;p data-source-line=&quot;123&quot;&gt;1.在spring.xml中配置bean标签，IOC容器通过加载bean标签来创建对象。&lt;/p&gt;
&lt;p data-source-line=&quot;125&quot;&gt;2.调用API获取IOC创建的对象。&lt;/p&gt;
&lt;p data-source-line=&quot;127&quot;&gt;两种方式&lt;/p&gt;
&lt;p data-source-line=&quot;129&quot;&gt;2.1 通过id获取对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.加载spring.xml配置文件&lt;/span&gt;
        ApplicationContext applicationContext = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;spring.xml&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.通过id值获取对象&lt;/span&gt;
        Employee emp = (Employee) applicationContext.getBean(&quot;emp&quot;&lt;span&gt;);
        System.out.println(emp);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;139&quot;&gt;2.2 通过运行时类获取对象&lt;/p&gt;
&lt;p data-source-line=&quot;141&quot;&gt;注意: 当spring.xml中配置两个Employee的bean时程序报错，因为此时两个bean都是由Employee类生成的，IOC容器无法将两个bean都返回。&lt;/p&gt;
&lt;h5 id=&quot;必须指定一个唯一的bean&quot; data-source-line=&quot;143&quot;&gt;必须指定一个唯一的bean&lt;/h5&gt;
&lt;p data-source-line=&quot;145&quot;&gt;spring.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &amp;lt;bean id=&quot;emp1&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.Employee&quot;&amp;gt;
        &amp;lt;property name=&quot;id&quot; value=&quot;1&quot;&amp;gt;&amp;lt;/property&amp;gt;
 &amp;lt;/bean&amp;gt;
 
  &amp;lt;bean id=&quot;emp2&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.Employee&quot;&amp;gt;
        &amp;lt;property name=&quot;id&quot; value=&quot;2&quot;&amp;gt;&amp;lt;/property&amp;gt;
 &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;158&quot;&gt;TestSpringEmp.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　  //&lt;/span&gt;&lt;span&gt;1.加载spring.xml配置文件&lt;/span&gt;
        ApplicationContext applicationContext = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;spring.xml&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.通过运行时类获取对象&lt;/span&gt;
        Employee emp = applicationContext.getBean(Employee.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        System.out.println(emp);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 id=&quot;无参构造代码&quot; data-source-line=&quot;167&quot;&gt;无参构造代码&lt;/h5&gt;
&lt;p data-source-line=&quot;169&quot;&gt;spring.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

        &amp;lt;!-- 配置员工 Employee 对象--&amp;gt;
        &amp;lt;bean id=&quot;emp&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.Employee&quot;&amp;gt;&amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;182&quot;&gt;TestSpringEmp.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.spring.model.Employee;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSpringEmp {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.加载spring.xml配置文件&lt;/span&gt;
        ApplicationContext applicationContext = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;spring.xml&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.通过id值获取对象&lt;/span&gt;
        Employee emp = (Employee) applicationContext.getBean(&quot;emp&quot;&lt;span&gt;);
        System.out.println(emp);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;201&quot;&gt;第一步：加载spring.xml配置文件，生成ApplicationContext对象。&lt;/p&gt;
&lt;p data-source-line=&quot;203&quot;&gt;第二步：调用ApplicationContext的getBean方法获取对象，参数为配置文件中的id值。&lt;/p&gt;
&lt;p data-source-line=&quot;207&quot;&gt;程序在加载spring.xml时创建stu对象，通过反射机制调用无参构造函数，所有要求交给IOC容器管理的类必须有无参构造函数。&lt;/p&gt;
&lt;h5 id=&quot;如何赋值呢&quot; data-source-line=&quot;209&quot;&gt;如何赋值呢？&lt;/h5&gt;
&lt;p data-source-line=&quot;211&quot;&gt;调用无参构造只会创建对象而不会进行赋值，如何赋值呢？只需要在spring.xml中进行相关配置即可。&lt;/p&gt;
&lt;p data-source-line=&quot;214&quot;&gt;添加property标签：name对应属性名，value是属性的值。&lt;/p&gt;
&lt;p data-source-line=&quot;216&quot;&gt;&lt;em&gt;注：若包含特殊字符，比如name=&quot;&amp;lt;一只阿木木&amp;gt;&quot;，使用&amp;lt;![CDATA[&amp;lt;一只阿木木&amp;gt;]]&amp;gt;进行配置。&lt;/em&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;218&quot;&gt;spring.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
　　　　　&amp;lt;property name=&quot;id&quot; value=&quot;1&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeNo&quot; value=&quot;10001&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeName&quot; value=&quot;一只阿木木&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;sex&quot; value=&quot;1&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;birthDay&quot; value=&quot;1990-08-15&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;officeNo&quot; value=&quot;7&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;postNo&quot; value=&quot;1&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;entryTime&quot; value=&quot;2018-07-01&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;speciality&quot; value=&quot;java,python&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hobby&quot;&amp;gt;
            &amp;lt;value&amp;gt;&amp;lt;![CDATA[&amp;lt;漫画&amp;gt;]]&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 id=&quot;有参构造代码&quot; data-source-line=&quot;235&quot;&gt;有参构造代码&lt;/h5&gt;
&lt;p data-source-line=&quot;237&quot;&gt;在实体类中创建有参构造&lt;/p&gt;
&lt;p data-source-line=&quot;239&quot;&gt;Employee.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Employee(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, String employeeNo, String employeeName) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.employeeNo =&lt;span&gt; employeeNo;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.employeeName =&lt;span&gt; employeeName;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;249&quot;&gt;spring.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 通过有参构造函数创建对象 --&amp;gt;
    &amp;lt;bean id=&quot;emp3&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.Employee&quot;&amp;gt;
        &amp;lt;constructor-arg name=&quot;id&quot; value=&quot;3&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg name=&quot;employeeNo&quot; value=&quot;10001&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg name=&quot;employeeName&quot; value=&quot;一只阿木木&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;259&quot;&gt;除了使用name对应参数外，还可以通过下标index对应。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 通过有参构造函数创建对象 --&amp;gt;
    &amp;lt;bean id=&quot;emp3&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.Employee&quot;&amp;gt;
        &amp;lt;constructor-arg index=&quot;0&quot; value=&quot;3&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg index=&quot;1&quot; value=&quot;10001&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg index=&quot;2&quot; value=&quot;一只阿木木&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;进阶1多个对象级联关系&quot; data-source-line=&quot;269&quot;&gt;进阶1：多个对象级联关系？&lt;/h4&gt;
&lt;p data-source-line=&quot;271&quot;&gt;创建工作经历类 job.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Job {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 序号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 单位名称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String companyName;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 职位名称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String position;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 工作薪水 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; BigDecimal salary;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; setter and getter &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;292&quot;&gt;在员工Employee 类中添加工作经历job 类：&lt;/p&gt;
&lt;p data-source-line=&quot;294&quot;&gt;Employee.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 工作经历类&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Job job;
   
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 系统id &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 员工编号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String employeeNo;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 员工姓名 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String employeeName;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;309&quot;&gt;spring.xml中配置Job 对象，然后将该对象赋值给emp 对象。&lt;/p&gt;
&lt;p data-source-line=&quot;311&quot;&gt;spring.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 创建job 对象 --&amp;gt;
    &amp;lt;bean id=&quot;job&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.Job&quot;&amp;gt;
        &amp;lt;property name=&quot;id&quot; value=&quot;1&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;companyName&quot; value=&quot;阿木木国际集团&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;position&quot; value=&quot;研发副总监&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;salary&quot; value=&quot;10000.00&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 创建emp对象 --&amp;gt;
    &amp;lt;bean id=&quot;emp&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.Employee&quot;&amp;gt;
        &amp;lt;property name=&quot;id&quot; value=&quot;1&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeNo&quot; value=&quot;10001&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeName&quot;&amp;gt;
            &amp;lt;value&amp;gt;&amp;lt;![CDATA[&amp;lt;一只阿木木&amp;gt;]]&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- 将job 对象赋给emp 对象--&amp;gt;
        &amp;lt;property name=&quot;job&quot; ref=&quot;job&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;334&quot;&gt;在spring.xml中，通过ref属性将其他bean赋给当前bean对象，这种方式叫做依赖注入（DI），是Spring非常重要的机制，DI是将不同对象进行关联的一种方式，是IOC的具体实现方式，通常DI和IOC是紧密结合在一起的，所以一般说的IOC包括DI。&lt;/p&gt;
&lt;h4 id=&quot;如果是集合属性如何依赖注入&quot; data-source-line=&quot;336&quot;&gt;如果是集合属性如何依赖注入？&lt;/h4&gt;
&lt;p data-source-line=&quot;338&quot;&gt;Job 类中添加List&amp;lt;Employee&amp;gt;属性。&lt;/p&gt;
&lt;p data-source-line=&quot;340&quot;&gt;Job.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; List&amp;lt;Employee&amp;gt;属性&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;Employee&amp;gt; employeeList;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;346&quot;&gt;spring.xml中配置2个emp对象，1个job对象，并将2个emp对象注入到job对象中。&lt;/p&gt;
&lt;p data-source-line=&quot;348&quot;&gt;spring.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&quot;job&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.Job&quot;&amp;gt;
        &amp;lt;property name=&quot;id&quot; value=&quot;1&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;companyName&quot; value=&quot;阿木木国际集团&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;position&quot; value=&quot;研发副总监&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;salary&quot; value=&quot;10000.00&quot;&amp;gt;&amp;lt;/property&amp;gt;

        &amp;lt;property name=&quot;emp&quot;&amp;gt;
            &amp;lt;!-- 注入emp对象 --&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;ref bean=&quot;emp&quot;/&amp;gt;
                &amp;lt;ref bean=&quot;emp2&quot;/&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;emp&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.Employee&quot;&amp;gt;
        &amp;lt;property name=&quot;id&quot; value=&quot;1&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeNo&quot; value=&quot;10001&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeName&quot;&amp;gt;
            &amp;lt;value&amp;gt;&amp;lt;![CDATA[&amp;lt;一只阿木木&amp;gt;]]&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;emp2&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.Employee&quot;&amp;gt;
        &amp;lt;property name=&quot;id&quot; value=&quot;2&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeNo&quot; value=&quot;10002&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeName&quot;&amp;gt;
            &amp;lt;value&amp;gt;&amp;lt;![CDATA[&amp;lt;两只阿木木&amp;gt;]]&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;381&quot;&gt;集合属性通过list标签和ref标签完成注入。ref的bean属性指向需要注入的bean对象。&lt;/p&gt;
&lt;h2 id=&quot;ioc和di&quot; data-source-line=&quot;383&quot;&gt;IoC和DI&lt;/h2&gt;
&lt;p data-source-line=&quot;385&quot;&gt;2004年大师级人物Martin Fowler：“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。&lt;/p&gt;
&lt;p data-source-line=&quot;388&quot;&gt;DI—Dependency Injection，即“依赖注入”：我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。&lt;/p&gt;
&lt;p data-source-line=&quot;390&quot;&gt;理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”。&lt;/p&gt;
&lt;ul data-source-line=&quot;392&quot;&gt;&lt;li&gt;谁依赖于谁：当然是应用程序依赖于IoC容器；&lt;/li&gt;
&lt;li&gt;为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；&lt;/li&gt;
&lt;li&gt;谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；&lt;/li&gt;
&lt;li&gt;注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;ioc和di-是什么关系呢&quot; data-source-line=&quot;398&quot;&gt;IoC和DI 是什么关系呢？&lt;/h4&gt;
&lt;p data-source-line=&quot;400&quot;&gt;其实它们是同一个概念的不同角度描述。&lt;/p&gt;
&lt;p data-source-line=&quot;402&quot;&gt;IoC 是spring的核心，所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。由spring来负责控制对象的生命周期和对象间的关系，这叫控制反转。&lt;/p&gt;
&lt;p data-source-line=&quot;404&quot;&gt;Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。&lt;/p&gt;
&lt;p data-source-line=&quot;406&quot;&gt;控制的什么被反转了？就是：获得依赖对象的方式反转了。&lt;/p&gt;
&lt;h2 id=&quot;案例2工厂方法&quot; data-source-line=&quot;408&quot;&gt;案例2：工厂方法&lt;/h2&gt;
&lt;p data-source-line=&quot;410&quot;&gt;IOC是典型的工厂模式，IOC通过工厂模式创建bean有两种方式：&lt;/p&gt;
&lt;ul data-source-line=&quot;412&quot;&gt;&lt;li&gt;1.静态工厂方法&lt;/li&gt;
&lt;li&gt;2.实例工厂方法&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;一静态工厂方法&quot; data-source-line=&quot;415&quot;&gt;一.静态工厂方法&lt;/h4&gt;
&lt;p data-source-line=&quot;418&quot;&gt;1.1 创建工作实体类&lt;/p&gt;
&lt;p data-source-line=&quot;420&quot;&gt;job.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Job {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 序号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 单位名称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String companyName;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 职位名称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String position;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Job(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, String companyName, String position) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt; ();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.companyName =&lt;span&gt; companyName;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.position =&lt;span&gt; position;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Job() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Job [id=&quot; + id + &quot;, companyName=&quot; + companyName + &quot;, postion=&quot; + position + &quot; ]&quot;&lt;span&gt;;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;453&quot;&gt;1.2 创建静态工厂类，静态工厂方法。&lt;/p&gt;
&lt;p data-source-line=&quot;455&quot;&gt;StaticFactoryJob.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;Integer, Job&amp;gt;&lt;span&gt; jobs;

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        jobs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        jobs.put(&lt;/span&gt;1, &lt;span&gt;new&lt;/span&gt; Job(1, &quot;猫厂&quot;, &quot;p7&quot;&lt;span&gt;));
        jobs.put(&lt;/span&gt;2, &lt;span&gt;new&lt;/span&gt; Job(2, &quot;鹅厂&quot;,&quot;T2&quot;&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  Job getJob(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  jobs.get(id);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;471&quot;&gt;1.3 在spring.xml中配置静态工厂。&lt;/p&gt;
&lt;p data-source-line=&quot;473&quot;&gt;spring.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 配置静态工厂创建job对象 --&amp;gt;
    &amp;lt;bean id=&quot;job1&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.StaticFactoryJob&quot; factory-method=&quot;getJob&quot;&amp;gt;
        &amp;lt;constructor-arg value=&quot;1&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;481&quot;&gt;factory-method指向静态方法。&lt;/p&gt;
&lt;p data-source-line=&quot;483&quot;&gt;constructor-arg 的value属性为调用静态方法所传的参数。&lt;/p&gt;
&lt;p data-source-line=&quot;487&quot;&gt;1.4 在测试类中直接获取job1对象。 TestSpringStatic.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        ApplicationContext applicationContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;spring.xml&quot;&lt;span&gt;);
        Job job &lt;/span&gt;= (Job) applicationContext.getBean(&quot;job1&quot;&lt;span&gt;);
        System.out.println(job);
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印：Job [id=1, companyName=猫厂, postion=p7 ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;二实例工厂方法&quot; data-source-line=&quot;501&quot;&gt;二.实例工厂方法&lt;/h4&gt;
&lt;p data-source-line=&quot;503&quot;&gt;2.1 创建实例工厂类，工厂方法 。&lt;/p&gt;
&lt;p data-source-line=&quot;505&quot;&gt;InstanceFactoryJob.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;Integer, Job&amp;gt;&lt;span&gt; jobs;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  InstanceFactoryJob() {
        jobs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        jobs.put(&lt;/span&gt;1, &lt;span&gt;new&lt;/span&gt; Job(1, &quot;猫厂&quot;, &quot;p7&quot;&lt;span&gt;));
        jobs.put(&lt;/span&gt;2, &lt;span&gt;new&lt;/span&gt; Job(2, &quot;鹅厂&quot;, &quot;T2&quot;&lt;span&gt;));
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  Job getJob(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jobs.get(id);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;519&quot;&gt;2.2 spring.xml 中配置 bean&lt;/p&gt;
&lt;p data-source-line=&quot;521&quot;&gt;spring.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 配置实例工厂对象 --&amp;gt;
    &amp;lt;bean id=&quot;jobFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.InstanceFactoryJob&quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;!-- 通过实例工厂对象创建car对象 --&amp;gt;
    &amp;lt;bean id=&quot;job2&quot; factory-bean=&quot;jobFactory&quot; factory-method=&quot;getJob&quot;&amp;gt;
        &amp;lt;constructor-arg value=&quot;2&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;532&quot;&gt;2.3 在测试类中直接获取car2对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        ApplicationContext applicationContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;spring.xml&quot;&lt;span&gt;);
        Job job &lt;/span&gt;= (Job) applicationContext.getBean(&quot;job2&quot;&lt;span&gt;);
        System.out.println(job);
    }


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印： Job [id=2, companyName=鹅厂, postion=T2 ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;区别&quot; data-source-line=&quot;547&quot;&gt;区别&lt;/h4&gt;
&lt;p data-source-line=&quot;549&quot;&gt;静态工厂方法的方式创建job对象，不需要实例化工厂对象，因为静态工厂的静态方法，不需要创建对象即可调用。所以spring.xml只需要配置一个Job bean，而不需要配置工厂bean。&lt;/p&gt;
&lt;p data-source-line=&quot;551&quot;&gt;实例工厂方法创建job对象，必须先实例化工厂对象，因为调用的是非静态方法，必须通过对象调用，不能直接通过类来调用，所以spring.xml中需要先配置工厂bean，再配置Job bean。&lt;/p&gt;
&lt;h2 id=&quot;案例3ioc自动装载autowire&quot; data-source-line=&quot;553&quot;&gt;案例3：IOC自动装载（autowire）&lt;/h2&gt;
&lt;p data-source-line=&quot;555&quot;&gt;自动装载有两种方式：&lt;/p&gt;
&lt;ul data-source-line=&quot;557&quot;&gt;&lt;li&gt;byName：通过属性名自动装载&lt;/li&gt;
&lt;li&gt;byType：通过属性对应的数据类型自动装载&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;31-通过属性名自动装载&quot; data-source-line=&quot;560&quot;&gt;3.1 通过属性名自动装载&lt;/h3&gt;
&lt;p data-source-line=&quot;561&quot;&gt;1 新建BaseEmployee.java 类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEmployee {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 系统id &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 员工编号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String employeeNo;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 员工姓名 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String employeeName;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 工作经历&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Job job;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; setter and getter &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
     
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;BaseEmployee [id=&quot; + id + &quot;, employeeNo=&quot; + employeeNo + &quot;, employeeName=&quot; + employeeName + &quot;, job=&quot; + job + &quot;]&quot;&lt;span&gt;;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;588&quot;&gt;2 spring.xml中配置Car bean和Person bean，并通过自动装载进行依赖注入。&lt;/p&gt;
&lt;p data-source-line=&quot;590&quot;&gt;spring.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!--autowire=&quot;byName&quot;&lt;span&gt;表示通过匹配属性名的方式去装载对应的bean，
    BaseEmployee实体类中有 job 属性，所以就将id&lt;/span&gt;=&quot;job&quot;的bean注入到baseEmployee中--&amp;gt;

    &amp;lt;bean id=&quot;emp&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.BaseEmployee&quot; autowire=&quot;byName&quot;&amp;gt;
        &amp;lt;property name=&quot;id&quot; value=&quot;1&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeNo&quot; value=&quot;10001&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeName&quot; value=&quot;一只阿木木&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;job&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.StaticFactoryJob&quot; factory-method=&quot;getJob&quot;&amp;gt;
        &amp;lt;constructor-arg value=&quot;2&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;607&quot;&gt;注意：通过property标签手动进行car的注入优先级更高，若两种方式同时配置，以property的配置为准。&lt;/p&gt;
&lt;p data-source-line=&quot;609&quot;&gt;3 测试类中获取baseEmployee 对象。&lt;/p&gt;
&lt;p data-source-line=&quot;611&quot;&gt;TestSpringBaseEmployee.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSpringBaseEmployee {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ApplicationContext applicationContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;spring.xml&quot;&lt;span&gt;);
        BaseEmployee emp &lt;/span&gt;= (BaseEmployee) applicationContext.getBean(&quot;emp&quot;&lt;span&gt;);
        System.out.println(emp);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-通过属性对应的数据类型自动装载&quot; data-source-line=&quot;623&quot;&gt;3.2 通过属性对应的数据类型自动装载&lt;/h3&gt;
&lt;p data-source-line=&quot;625&quot;&gt;知识点：使用byType进行自动装载时，spring.xml中只能配置一个装载的bean。&lt;/p&gt;
&lt;p data-source-line=&quot;627&quot;&gt;1.spring.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;bean id=&quot;emp&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.BaseEmployee&quot; autowire=&quot;byType&quot;&amp;gt;
        &amp;lt;property name=&quot;id&quot; value=&quot;1&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeNo&quot; value=&quot;10001&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;employeeName&quot; value=&quot;一只阿木木&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;job&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.StaticFactoryJob&quot; factory-method=&quot;getJob&quot;&amp;gt;
        &amp;lt;constructor-arg value=&quot;2&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--&amp;lt;bean id=&quot;job2&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.model.StaticFactoryJob&quot; factory-method=&quot;getJob&quot;&amp;gt;
        &amp;lt;constructor-arg value=&quot;2&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;--&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;645&quot;&gt;2.测试类中获取person对象&lt;/p&gt;
&lt;p data-source-line=&quot;647&quot;&gt;TestSpringBaseEmployee.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印：BaseEmployee [id=1, employeeNo=10001, employeeName=一只阿木木, job=Job [id=2, companyName=鹅厂, postion=T2 ]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;案例4程序架构mvc-分层&quot; data-source-line=&quot;653&quot;&gt;案例4：程序架构MVC 分层&lt;/h2&gt;
&lt;p data-source-line=&quot;656&quot;&gt;经典三层架构：Controller层，Service层，DAO层。&lt;/p&gt;
&lt;p data-source-line=&quot;658&quot;&gt;有两种方式：&lt;/p&gt;
&lt;ul data-source-line=&quot;659&quot;&gt;&lt;li&gt;基于xml配置文件&lt;/li&gt;
&lt;li&gt;基于注解&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;41-基于-xml-配置&quot; data-source-line=&quot;662&quot;&gt;4.1 基于 xml 配置&lt;/h3&gt;
&lt;h5 id=&quot;model-层实体类&quot; data-source-line=&quot;664&quot;&gt;model 层实体类：&lt;/h5&gt;
&lt;p data-source-line=&quot;666&quot;&gt;BaseEmployee.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEmployee {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 系统id &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 员工编号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String employeeNo;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 员工姓名 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String employeeName;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseEmployee(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, String employeeNo, String employeeName) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.employeeNo =&lt;span&gt; employeeNo;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.employeeName =&lt;span&gt; employeeName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseEmployee() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;BaseEmployee [id=&quot; + id + &quot;, employeeNo=&quot; + employeeNo + &quot;, employeeName=&quot; + employeeName + &quot;]&quot;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; setter and getter &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 id=&quot;dao-层接口&quot; data-source-line=&quot;699&quot;&gt;Dao 层接口&lt;/h5&gt;
&lt;p data-source-line=&quot;701&quot;&gt;BaseEmployeeDao.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BaseEmployeeDao {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseEmployee getBaseEmpById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;707&quot;&gt;BaseEmployeeDaoImpl.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseEmployeeDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BaseEmployeeDao{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;Integer,BaseEmployee&amp;gt;&lt;span&gt; baseEmployee;

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
            baseEmployee &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Integer,BaseEmployee&amp;gt;&lt;span&gt;();
            baseEmployee.put(&lt;/span&gt;1, &lt;span&gt;new&lt;/span&gt; BaseEmployee(1, &quot;10001&quot;, &quot;一只阿木木&quot;&lt;span&gt;));
            baseEmployee.put(&lt;/span&gt;2, &lt;span&gt;new&lt;/span&gt; BaseEmployee(2, &quot;10002&quot;, &quot;两只阿木木&quot;&lt;span&gt;));
            baseEmployee.put(&lt;/span&gt;3, &lt;span&gt;new&lt;/span&gt; BaseEmployee(3, &quot;10003&quot;, &quot;三只阿木木&quot;&lt;span&gt;));
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseEmployee getBaseEmpById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; baseEmployee.get(id);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 id=&quot;service-层&quot; data-source-line=&quot;728&quot;&gt;Service 层&lt;/h5&gt;
&lt;p data-source-line=&quot;729&quot;&gt;创建BaseEmployeeService 接口以及实现类BaseEmployeeServiceImpl。&lt;/p&gt;
&lt;p data-source-line=&quot;731&quot;&gt;BaseEmployeeService&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BaseEmployeeService {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseEmployee getBaseEmpById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;738&quot;&gt;BaseEmployeeServiceImpl.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseEmployeeServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BaseEmployeeService {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BaseEmployeeDAO baseEmployeeDAO;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseEmployeeDAO getBaseEmployeeDAO() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; baseEmployeeDAO;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBaseEmployeeDAO(BaseEmployeeDAO baseEmployeeDAO) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.baseEmployeeDAO =&lt;span&gt; baseEmployeeDAO;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; User getBaseEmpById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; baseEmployeeDAO.getBaseEmpById(id);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 id=&quot;controller-层&quot; data-source-line=&quot;760&quot;&gt;Controller 层&lt;/h5&gt;
&lt;p data-source-line=&quot;762&quot;&gt;BaseEmployeeController.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEmployeeController {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BaseEmployeeService baseEmployeeService;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseEmployeeService getBaseEmployeeService() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; baseEmployeeService;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBaseEmployeeService(BaseEmployeeService baseEmployeeService) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.baseEmployeeService =&lt;span&gt; baseEmployeeService;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseEmployee getBaseEmpById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; baseEmployeeService.getBaseEmpById(id);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 id=&quot;springxml&quot; data-source-line=&quot;784&quot;&gt;spring.xml&lt;/h5&gt;
&lt;p data-source-line=&quot;786&quot;&gt;在spring.xml配置Controller，Service，DAO，并完成依赖注入。 spring.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 配置BaseEmployeeController --&amp;gt;
    &amp;lt;bean id=&quot;baseEmployeeController&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.controller.BaseEmployeeController&quot;&amp;gt;
        &amp;lt;property name=&quot;baseEmployeeService&quot; ref=&quot;baseEmployeeService&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 配置BaseEmployeeService --&amp;gt;
    &amp;lt;bean id=&quot;baseEmployee&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.service.BaseEmployeeServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;baseEmployeeDAO&quot; ref=&quot;baseEmployeeDAO&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 配置BaseEmployeeDAO --&amp;gt;
    &amp;lt;bean id=&quot;baseEmployeeDAO&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.spring.dao.BaseEmployeeDaoImpl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 id=&quot;测试&quot; data-source-line=&quot;804&quot;&gt;测试&lt;/h5&gt;
&lt;p data-source-line=&quot;805&quot;&gt;TestSpringBaseEmployee.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ApplicationContext applicationContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;spring.xml&quot;&lt;span&gt;);
        BaseEmployeeController baseEmployeeController &lt;/span&gt;= (BaseEmployeeController) applicationContext.getBean(&quot;baseEmployeeController&quot;&lt;span&gt;);
        BaseEmployee baseEmployee &lt;/span&gt;= baseEmployeeController.getBaseEmpById(1&lt;span&gt;);
        System.out.println(baseEmployee);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;42基于注解的方式&quot; data-source-line=&quot;816&quot;&gt;4.2基于注解的方式&lt;/h2&gt;
&lt;h3 id=&quot;421-默认bytype-方式&quot; data-source-line=&quot;817&quot;&gt;4.2.1 默认byType 方式&lt;/h3&gt;
&lt;p data-source-line=&quot;819&quot;&gt;第一步：将Controller，Service，DAO类扫描到IOC容器中。&lt;/p&gt;
&lt;p data-source-line=&quot;821&quot;&gt;第二步：在类中设置注解完成依赖注入。&lt;/p&gt;
&lt;p data-source-line=&quot;824&quot;&gt;1 修改 spring.xml&lt;/p&gt;
&lt;p data-source-line=&quot;824&quot;&gt;知识点：引入context 命名空间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context/spring-context-4.0.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;


    &amp;lt;!-- 将类扫描到IOC容器中 --&amp;gt;
    &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;com.spring&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;841&quot;&gt;2 修改DAOImpl&lt;/p&gt;
&lt;p data-source-line=&quot;843&quot;&gt;改动：在类名处添加@Repository注解，表示该类是数据接口层。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Repository
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseEmployeeDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BaseEmployeeDao{

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;Integer,BaseEmployee&amp;gt;&lt;span&gt; baseEmployee;

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
            baseEmployee &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Integer,BaseEmployee&amp;gt;&lt;span&gt;();
            baseEmployee.put(&lt;/span&gt;1, &lt;span&gt;new&lt;/span&gt; BaseEmployee(1, &quot;10001&quot;, &quot;一只阿木木&quot;&lt;span&gt;));
            baseEmployee.put(&lt;/span&gt;2, &lt;span&gt;new&lt;/span&gt; BaseEmployee(2, &quot;10002&quot;, &quot;两只阿木木&quot;&lt;span&gt;));
            baseEmployee.put(&lt;/span&gt;3, &lt;span&gt;new&lt;/span&gt; BaseEmployee(3, &quot;10003&quot;, &quot;三只阿木木&quot;&lt;span&gt;));
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseEmployee getBaseEmpById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; baseEmployee.get(id);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;866&quot;&gt;3 修改ServiceImpl。&lt;/p&gt;
&lt;ul data-source-line=&quot;868&quot;&gt;&lt;li&gt;在类名处添加@Service注解，表示该类是业务层。&lt;/li&gt;
&lt;li&gt;DAO属性出添加@Autowired注解，表示IOC容器自动完成装载，默认是byType的方式。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseEmployeeServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BaseEmployeeService{

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BaseEmployeeDAO baseEmployeeDAO;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseEmployee getBaseEmpById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; baseEmployeeDAO.getBaseEmpById(id);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;889&quot;&gt;4 修改 Controller类，添加注解。&lt;/p&gt;
&lt;p data-source-line=&quot;892&quot;&gt;有两处改动：&lt;/p&gt;
&lt;ul data-source-line=&quot;894&quot;&gt;&lt;li&gt;在类名处添加@Controller注解，表示该类作为一个控制器。&lt;/li&gt;
&lt;li&gt;Service属性出添加@Autowired注解，表示IOC容器自动完成装载，默认是byType的方式。&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;897&quot;&gt;BaseEmployeeControler.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEmployeeController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BaseEmployeeService baseEmployeeService;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseEmployee getBaseEmpById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; baseEmployeeService.getBaseEmpById(id);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;422-byname&quot; data-source-line=&quot;913&quot;&gt;4.2.2 ByName&lt;/h3&gt;
&lt;p data-source-line=&quot;915&quot;&gt;自动装载除了byType的方式，还可以结合@Qualifier注解, 使用byName的方式。&lt;/p&gt;
&lt;p data-source-line=&quot;917&quot;&gt;知识点：@Qualifier（）中的值必须与@Service（）中的值一致，才能完成自动装载。&lt;/p&gt;
&lt;p data-source-line=&quot;919&quot;&gt;BaseEmployeeControler.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEmployeeController {

    @Autowired
    @Qualifier(&lt;/span&gt;&quot;baseEmployeeService&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BaseEmployeeService baseEmployeeService;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseEmployee getBaseEmpById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; baseEmployeeService.getBaseEmpById(id);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;935&quot;&gt;基于注解的方式我们并没有给bean设置id，byName的方式是通过属性名去匹配对应bean的id属性值。&lt;/p&gt;
&lt;p data-source-line=&quot;937&quot;&gt;添加注解时，类名首字母小写之后的值就是id的默认值。IOC容器中默认赋值，BaseEmployeeService bean的id=baseEmployeeService，与Controller中的属性名一致&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseEmployeeServiceImpl &lt;span&gt;implements&lt;/span&gt; BaseEmployeeService
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;修改&quot; data-source-line=&quot;945&quot;&gt;修改&lt;/h4&gt;
&lt;p data-source-line=&quot;947&quot;&gt;BaseEmployeeService bean的id=sortBaseEmployeeService。&lt;/p&gt;
&lt;h5 id=&quot;service-层-2&quot; data-source-line=&quot;949&quot;&gt;Service 层&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@Service(&quot;sortBaseEmployeeService&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseEmployeeServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BaseEmployeeService{

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BaseEmployeeDAO baseEmployeeDAO;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseEmployee getBaseEmpById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; baseEmployeeDAO.getBaseEmpById(id);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 id=&quot;controller-层-2&quot; data-source-line=&quot;966&quot;&gt;Controller 层&lt;/h5&gt;
&lt;p data-source-line=&quot;968&quot;&gt;Controller中的Service属性也需要去匹配name=sortBaseEmployeeService的bean，所以设置@Qualifier（&quot;sortBaseEmployeeService&quot;）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEmployeeController {

    @Autowired
    @Qualifier(&lt;/span&gt;&quot;sortBaseEmployeeService&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BaseEmployeeService baseEmployeeService;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseEmployee getBaseEmpById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; baseEmployeeService.getBaseEmpById(id);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;小结&quot; data-source-line=&quot;984&quot;&gt;小结&lt;/h2&gt;
&lt;h4 id=&quot;ioc概念&quot; data-source-line=&quot;986&quot;&gt;IOC概念&lt;/h4&gt;
&lt;p data-source-line=&quot;988&quot;&gt;控制反转，由容器创建组件对象，然后注入参数建立应用关系。&lt;/p&gt;
&lt;p data-source-line=&quot;990&quot;&gt;例如EmployeeDao调用Data，由Spring容器创建EmployeeDao和Data对象，然后再由容器将Data对象注入给EmployeeDao中的属性。&lt;/p&gt;
&lt;p data-source-line=&quot;992&quot;&gt;Data注入途径可以是set方法，也可以是带参数构造器等。&lt;/p&gt;
&lt;h4 id=&quot;编写规则&quot; data-source-line=&quot;995&quot;&gt;编写规则&lt;/h4&gt;
&lt;p data-source-line=&quot;997&quot;&gt;EmployeeDao类在编写时，需要定义一个set方法或带参数构造器，参数类型为Data。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EmployeeDao {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Data data;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 set 方法注入&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setData(Data data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2 带参数构造器注入&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; EmployeeDao(Data data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;配置原理&quot; data-source-line=&quot;1016&quot;&gt;配置原理&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;!--原理，利用反射创建对象（无参构造器）， 然后利用反射注入参数--&amp;gt;
    &amp;lt;bean id=&quot;&quot; &lt;span&gt;class&lt;/span&gt;=&quot;&quot;&amp;gt;
        &amp;lt;property name=&quot;&quot; value|ref=&quot;&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!--原理：利用反射直接调用带参数构造器创建对象--&amp;gt;
    &amp;lt;bean id=&quot;&quot; &lt;span&gt;class&lt;/span&gt;=&quot;&quot;&amp;gt;
        &amp;lt;constructor-arg index=&quot;&quot;  value|ref=&quot;&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;使用方法&quot; data-source-line=&quot;1029&quot;&gt;使用方法&lt;/h4&gt;
&lt;ol data-source-line=&quot;1031&quot;&gt;&lt;li&gt;引入spring 开发包&lt;/li&gt;
&lt;li&gt;配置文件.xml&lt;/li&gt;
&lt;li&gt;编写组件，定义到xml 配置中&lt;/li&gt;
&lt;li&gt;创建窗口对象，调用 getBean 获取Bean 对象使用&lt;/li&gt;
&lt;/ol&gt;&lt;div data-source-line=&quot;1038&quot; data-role=&quot;mermaid&quot; data-src=&quot;graph%20LR%0A1libs%E6%89%93%E5%8C%85--%3E2xml%E9%85%8D%E7%BD%AE%0A%0A3%E7%BB%84%E4%BB%B6%E7%BC%96%E5%86%99--%3E4getBean%E8%B0%83%E7%94%A8%0A&quot; data-processed-src=&quot;graph%20LR%0A1libs%E6%89%93%E5%8C%85--%3E2xml%E9%85%8D%E7%BD%AE%0A%0A3%E7%BB%84%E4%BB%B6%E7%BC%96%E5%86%99--%3E4getBean%E8%B0%83%E7%94%A8%0A&quot; data-processed=&quot;true&quot;&gt;


&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/960593/201808/960593-20180816150237038-613557195.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-source-line=&quot;1045&quot;&gt;由于Java语言本身的类反射功能，使得仅凭一个配置文件，就能魔法般地实例化并装配好程序所用的Bean。容器启动时，Spring根据配置文件的描述信息，自动实例化Bean并完成依赖关系的装配，从容器中即可返回准备就绪的Bean实例，后续可直接使用之。&lt;/p&gt;
&lt;p data-source-line=&quot;1045&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;1045&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;1049&quot;&gt;本文spring libs 地址&lt;a href=&quot;https://github.com/yizhiamumu/springlibs/&quot; target=&quot;_blank&quot;&gt;：https://github.com/yizhiamumu/springlibs&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p data-source-line=&quot;1052&quot;&gt;公众号：一只阿木木&lt;/p&gt;
&lt;p data-source-line=&quot;1054&quot;&gt;博客园：&lt;a href=&quot;http://www.cnblogs.com/yizhiamumu//&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/yizhiamumu/&lt;/a&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;1056&quot;&gt;github&lt;span class=&quot;Apple-converted-space&quot;&gt; :&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;https://github.com/yizhiamumu//&quot; target=&quot;_blank&quot;&gt;https://github.com/yizhiamumu/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Aug 2018 07:04:00 +0000</pubDate>
<dc:creator>一只阿木木</dc:creator>
<og:description>本文spring libs 地址：https://github.com/yizhiamumu/springlibs Spring 能帮我们做什么 ①.Spring 能帮我们根据配置文件创建及组装对象之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yizhiamumu/p/9487380.html</dc:identifier>
</item>
<item>
<title>线程、进程、协程 - Alexen</title>
<link>http://www.cnblogs.com/yu110812/p/9487324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yu110812/p/9487324.html</guid>
<description>&lt;p&gt;进程是资源分配单位，系统会分配内存，屏幕，窗口。&lt;br/&gt;线程是进程中真正执行的东西。&lt;/p&gt;&lt;p&gt;　python中的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用。&lt;/p&gt;
&lt;p&gt;1、多线程执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;/&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;/&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;      python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。&lt;/p&gt;

&lt;p&gt;      多线程之间共享全局变量，优点是方便在多个线程之间共享数据，缺点是线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）。&lt;/p&gt;
&lt;p&gt;      如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import threading
&lt;span class=&quot;hljs-keyword&quot;&gt;import time

g_num = &lt;span class=&quot;hljs-number&quot;&gt;0

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;work1&lt;span class=&quot;hljs-params&quot;&gt;(num):
    &lt;span class=&quot;hljs-keyword&quot;&gt;global g_num
    &lt;span class=&quot;hljs-keyword&quot;&gt;for i &lt;span class=&quot;hljs-keyword&quot;&gt;in range(num):
        g_num += &lt;span class=&quot;hljs-number&quot;&gt;1
    print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;----in work1, g_num is %d---&quot;%g_num)


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;work2&lt;span class=&quot;hljs-params&quot;&gt;(num):
    &lt;span class=&quot;hljs-keyword&quot;&gt;global g_num
    &lt;span class=&quot;hljs-keyword&quot;&gt;for i &lt;span class=&quot;hljs-keyword&quot;&gt;in range(num):
        g_num += &lt;span class=&quot;hljs-number&quot;&gt;1
    print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;----in work2, g_num is %d---&quot;%g_num)


print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;---线程创建之前g_num is %d---&quot;%g_num)

t1 = threading.Thread(target=work1, args=(&lt;span class=&quot;hljs-number&quot;&gt;1000000,))
t1.start()

t2 = threading.Thread(target=work2, args=(&lt;span class=&quot;hljs-number&quot;&gt;1000000,))
t2.start()

&lt;span class=&quot;hljs-keyword&quot;&gt;while len(threading.enumerate()) != &lt;span class=&quot;hljs-number&quot;&gt;1:
    time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;1)

print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;2个线程对同一个全局变量操作之后的最终结果是:%s&quot; % g_num)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;p&gt;测试结果：
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;---线程创建之前g_num &lt;span class=&quot;hljs-keyword&quot;&gt;is &lt;span class=&quot;hljs-number&quot;&gt;0---
----&lt;span class=&quot;hljs-keyword&quot;&gt;in work1, g_num &lt;span class=&quot;hljs-keyword&quot;&gt;is &lt;span class=&quot;hljs-number&quot;&gt;1088005---
----&lt;span class=&quot;hljs-keyword&quot;&gt;in work2, g_num &lt;span class=&quot;hljs-keyword&quot;&gt;is &lt;span class=&quot;hljs-number&quot;&gt;1286202---
&lt;span class=&quot;hljs-number&quot;&gt;2个线程对同一个全局变量操作之后的最终结果是:&lt;span class=&quot;hljs-number&quot;&gt;1286202&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同步：&lt;/p&gt;
&lt;p&gt;同步就是协同步调，按预定的先后次序进行运行&lt;/p&gt;
&lt;p&gt;互斥锁：&lt;/p&gt;
&lt;p&gt;某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。&lt;/p&gt;
&lt;p&gt;写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;/&gt;
&lt;/pre&gt;

&lt;p&gt;锁的好处：&lt;/p&gt;
&lt;p&gt;确保了某段关键代码只能由一个线程从头到尾完整地执行&lt;br/&gt;锁的坏处：&lt;br/&gt;阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了&lt;br/&gt;由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁&lt;/p&gt;
&lt;p&gt;死锁解决办法(&lt;/p&gt;
&lt;p&gt;看门狗思想：过一一段时间就执行一次特殊的某行代码，如果长时间不执行，系统就自动重启&lt;/p&gt;
&lt;p&gt;2.银行家算法&lt;/p&gt;
&lt;p&gt;互斥锁：线程能够同步保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。某个线程要更改共享数据时，先将其锁定，此时资源的状态为锁定状态，其他线程不能更改，直到该线程释放资源。&lt;/p&gt;&lt;p&gt;当创建一个线程之后，函数里面所有的内存空间是这个线程独有的，在创建一个时，会重新创建一个内存空间。各人是各人的。函数里面的代码各人是各人的，不会共享。&lt;/p&gt;&lt;p&gt;非全局变量不需要加锁。&lt;/p&gt;&lt;p&gt;死锁：在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源时，就会造成死锁。&lt;/p&gt;&lt;p&gt;同步：同步就是协调步调，按照预定的先后次序进行运行  三把锁一环扣一环&lt;br/&gt;异步：不同步&lt;/p&gt;&lt;p&gt;生产者与消费者模式：&lt;br/&gt;1。队列 :进程中的队列和线程中的队列不是一个概念。队列就是用来给生产者和消费者解耦的。&lt;br/&gt;2。栈&lt;br/&gt;fifo: frist in frist out =&amp;gt;Queue&lt;br/&gt;filo: frist in last out =&amp;gt;&lt;/p&gt;&lt;p&gt;一个函数想得到另一个函数的值，要么return 返回值，要么通过全局变量。&lt;/p&gt;&lt;p&gt;1、使用全局字典的方法&lt;br/&gt;2、ThreadLocal：不用传参数，用一个全局变量，能过完成线程里边的所有的数据的传递，不会因为多个线程对参数的修改对程序产生影响。&lt;/p&gt;
&lt;p&gt;孤儿进程：父进程先结束，子进程还没结束&lt;br/&gt;僵尸进程：如果一个子进程死了，父进程没有收尸，在收尸前的整个期间，子进程就称为僵尸进程。&lt;/p&gt;&lt;p&gt;线程之间共享全局变量。&lt;/p&gt;&lt;p&gt;原子操作（原子性）：要么不做，要做就做完。&lt;/p&gt;&lt;p&gt;线程安全问题：可能在一句代码还没执行完，操作系统就停止了代码的运行。&lt;/p&gt;&lt;p&gt;轮询：是一种CPU决策如何提供周边设备服务的方式，又称程控输出入&lt;/p&gt;
&lt;p&gt;多任务UDP聊天器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import socket
&lt;span class=&quot;hljs-keyword&quot;&gt;import threading


&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;===========================================================================&lt;/p&gt;
&lt;p&gt;进程：操作系统中的算法包括：时间片轮转、优先级调度、&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;并发：看上去一起执行。当前的任务数量大于核数。&lt;br/&gt;并行：真正的一起执行。当前任务数小于核数。&lt;/p&gt;&lt;p&gt;调度算法：什么样的情况下按照什么样的规则让谁去执行。&lt;br/&gt;编写完毕的代码，在没有运行的时候称之为程序，在运行的时候称之为进程。&lt;/p&gt;&lt;p&gt;1、fork（）创造子线程&lt;br/&gt;import os&lt;br/&gt;fork（）：可以在python程序中创建子进程。&lt;br/&gt;ret = os.fork()&lt;br/&gt;在fork()中，主进程想要结束，不会因为子进程没有结束而等待。只要子进程产生，子进程的执行顺序和执行过程和主进程一样，就是众所周知的代码执行的过程。&lt;/p&gt;&lt;p&gt;2.pid值：&lt;br/&gt;getpid()：获取当前进程的pid值。&lt;br/&gt;pid值：在操作系统当中，当进程运行起来时，操作系统都会给这个进程分配一个独一无二的值，即pid值。processID&lt;br/&gt;父进程中fork的返回值，就是刚刚创建出来的子进程的id。&lt;br/&gt;getppid()：获取父进程的pid值。&lt;br/&gt;pid值小于等于65535&lt;/p&gt;&lt;p&gt;3.Process（）创造子线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import multiprocessing
&lt;span class=&quot;hljs-keyword&quot;&gt;import time

&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;    p.join()#加了join之后,主进程会等子进程执行完代码之后,再开始执行join下面的代码&lt;/p&gt;
&lt;p&gt;    join（[timeout]）#堵塞：主进程等待子进程结束之后才结束。timeout表示操作时间。&lt;br/&gt;    terminate():不管任务是否完成，立即终止。&lt;/p&gt;
&lt;p&gt;    由于process的跨平台更好，以后不用fork，而是用process&lt;/p&gt;


&lt;p&gt;Process语法结构如下:&lt;/p&gt;
&lt;p&gt;Process([group [, target [, name [, args [, kwargs]]]]])&lt;br/&gt;target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码&lt;br/&gt;args：给target指定的函数传递的参数，以元组的方式传递&lt;br/&gt;kwargs：给target指定的函数传递命名参数&lt;br/&gt;name：给进程设定一个名字，可以不设定&lt;/p&gt;
&lt;p&gt;group：指定进程组，大多数情况下用不到&lt;/p&gt;
&lt;p&gt;Process创建的实例对象的常用方法：&lt;br/&gt;start()：启动子进程实例（创建子进程）&lt;br/&gt;is_alive()：判断进程子进程是否还在活着&lt;br/&gt;join([timeout])：是否等待子进程执行结束，或等待多少秒&lt;/p&gt;
&lt;p&gt;terminate()：不管任务是否完成，立即终止子进程&lt;/p&gt;
&lt;p&gt;Process创建的实例对象的常用属性：&lt;br/&gt;name：当前进程的别名，默认为Process-N，N为从1开始递增的整数&lt;/p&gt;
&lt;p&gt;pid：当前进程的pid（进程号）&lt;/p&gt;

&lt;h3&gt;进程间不同享全局变量&lt;/h3&gt;
&lt;p&gt;进程线程对比：&lt;/p&gt;
&lt;p&gt;进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ&lt;/p&gt;
&lt;p&gt;线程，能够完成多任务，比如 一个QQ中的多个聊天窗口&lt;/p&gt;
&lt;p&gt;进程是系统进行资源分配和调度的一个独立单位.&lt;/p&gt;

&lt;p&gt;线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.&lt;br/&gt;区别：&lt;br/&gt;一个程序至少有一个进程,一个进程至少有一个线程.&lt;br/&gt;线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。&lt;br/&gt;进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 &lt;br/&gt;线线程不能够独立执行，必须依存在进程中&lt;br/&gt;可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人 &lt;br/&gt;优缺点：&lt;/p&gt;
&lt;p&gt;线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。&lt;/p&gt;

&lt;p&gt;4.进程池Pool创建子线程&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import multiprocessing
&lt;span class=&quot;hljs-keyword&quot;&gt;import time


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;copy_work&lt;span class=&quot;hljs-params&quot;&gt;():
    print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;拷贝中....&quot;,multiprocessing.current_process().pid)
    time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;0.3)


&lt;span class=&quot;hljs-keyword&quot;&gt;if __name__ == &lt;span class=&quot;hljs-string&quot;&gt;'__main__':

    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;进程池Pool：主进程一般用来等待，真正的任务都在子进程中执行。&lt;/p&gt;

&lt;p&gt;multiprocessing.Pool常用函数解析：&lt;br/&gt;apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；&lt;br/&gt;close()：关闭Pool，使其不再接受新的任务；&lt;br/&gt;terminate()：不管任务是否完成，立即终止；&lt;/p&gt;
&lt;p&gt;join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；&lt;/p&gt;

&lt;p&gt;进程池中的Queue&lt;br/&gt;如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息：&lt;br/&gt;RuntimeError: Queue objects should only be shared between processes through inheritance.&lt;/p&gt;
&lt;p&gt;下面的实例演示了进程池中的进程如何通信：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import multiprocessing
&lt;span class=&quot;hljs-keyword&quot;&gt;import time


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;write_queue&lt;span class=&quot;hljs-params&quot;&gt;(queue):
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;q.put()：存数据  q.get()：取数据  q.full()：判断数据是否是满的  q.empty()判断数据是否为空  q.get_nowait()：立即存数据不等待   q.put_nowait()：立即取数据不等待&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;进程间通信的方式：命名管道  无名管道 共享内存 队列  网络功能&lt;/p&gt;

&lt;p&gt;fork ()是最底层的方法。&lt;br/&gt;pool = Pool(3)&lt;br/&gt;pool.apply_async(xx)&lt;br/&gt;pool 中，主进程一般不干活，主要是创建的子进程干活，join（）方法用来等待。&lt;/p&gt;&lt;p&gt;apply()=&amp;gt;堵塞式&lt;/p&gt;&lt;p&gt;进程共享数据，写实拷贝。&lt;/p&gt;&lt;p&gt;主进程的pid 是运行程序的那个软件的pid值&lt;/p&gt;
&lt;p&gt;案例：文件夹copy器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import multiprocessing
&lt;span class=&quot;hljs-keyword&quot;&gt;import os


&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;============================================================================&lt;/p&gt;
&lt;p&gt;协程：&lt;/p&gt;
&lt;p&gt;迭代器（iterator）：&lt;/p&gt;
&lt;p&gt;迭代是访问集合元素的一种方式。&lt;/p&gt;
&lt;p&gt;迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。&lt;/p&gt;
&lt;p&gt;迭代器只能往前不会后退。&lt;/p&gt;
&lt;p&gt;可以对list、tuple、str等类型的数据使用for...in...的循环语法从其中依次拿到数据进行使用，这样的过程称为遍历，也叫迭代。&lt;/p&gt;
&lt;p&gt;可迭代对象（Iterable）：可以通过for...in...这类语句迭代读取一条数据供我们使用的对象。列表元组字典都是  可迭代对象。&lt;/p&gt;
&lt;p&gt;可迭代对象通过&lt;code&gt;__iter__&lt;/code&gt;方法向我们提供一个迭代器，我们&lt;span class=&quot;pg-emphasize pg-emphasize-yellow&quot;&gt;在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据.&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个具备了&lt;code&gt;__iter__&lt;/code&gt;方法的对象，就是一个可迭代对象。&lt;/p&gt;
&lt;p&gt;一个实现了&lt;code&gt;__iter__&lt;/code&gt;方法和&lt;code&gt;__next__&lt;/code&gt;方法的对象，就是迭代器。&lt;/p&gt;
&lt;p&gt;iter()函数与next()函数&lt;br/&gt;list、tuple等都是可迭代对象，我们可以通过iter()函数获取这些可迭代对象的迭代器。然后我们可以对获取到的迭代器不断使用next()函数来获取下一条数据。iter()函数实际上就是调用了可迭代对象的__iter__方法。&lt;/p&gt;
&lt;ol class=&quot;hljs-ln&quot;&gt;&lt;li readability=&quot;0&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-prompt&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; li = [&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;11, &lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;22, &lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;33, &lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;44, &lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;55]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-prompt&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; li_iter = iter(li)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-prompt&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; next(li_iter)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-prompt&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; next(li_iter)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-prompt&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; next(li_iter)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-prompt&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; next(li_iter)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-prompt&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; next(li_iter)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-prompt&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; next(li_iter)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;lang-python&quot;&gt;Traceback (most recent call last):&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code class=&quot;lang-python&quot;&gt;File &lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;, line &lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;div class=&quot;hljs-ln-code&quot;&gt;
&lt;p&gt;&lt;code class=&quot;lang-python&quot;&gt;StopIteration&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以使用 isinstance() 判断一个对象是否是 Iterator 对象.&lt;/p&gt;
&lt;p&gt;一个实现了&lt;code&gt;__iter__&lt;/code&gt;方法和&lt;code&gt;__next__&lt;/code&gt;方法的对象，就是迭代器。&lt;/p&gt;
&lt;p&gt;自定义迭代器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from collections &lt;span class=&quot;hljs-keyword&quot;&gt;import Iterable
&lt;span class=&quot;hljs-keyword&quot;&gt;from collections &lt;span class=&quot;hljs-keyword&quot;&gt;import Iterator


&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;StudentList&lt;span class=&quot;hljs-params&quot;&gt;(object):

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;span class=&quot;hljs-params&quot;&gt;(self):
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;for...in...循环的本质&lt;br/&gt;for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束。&lt;/p&gt;

&lt;p&gt;8. 迭代器的应用场景&lt;/p&gt;
&lt;p&gt;我们发现迭代器最核心的功能就是可以通过next()函数的调用来返回下一个数据值。如果每次返回的数据值不是在一个已有的数据集合中读取的，而是通过程序按照一定的规律计算生成的，那么也就意味着可以不用再依赖一个已有的数据集合，也就是说不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，这样可以节省大量的存储（内存）空间。&lt;/p&gt;
&lt;p&gt;斐波那契数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Fibonacci&lt;span class=&quot;hljs-params&quot;&gt;():

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;span class=&quot;hljs-params&quot;&gt;(self, num):
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并不是只有for循环能接收可迭代对象，除了for循环能接收可迭代对象，list、tuple等也能接收。&lt;/p&gt;
&lt;ol class=&quot;hljs-ln&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;li = list(FibIterator(&lt;span class=&quot;hljs-number&quot;&gt;15))&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;

&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;tp = tuple(FibIterator(&lt;span class=&quot;hljs-number&quot;&gt;6))&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;


&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;生成器：&lt;/p&gt;
&lt;p&gt;利用迭代器，我们可以在每次迭代获取数据（通过next()方法）时按照特定的规律进行生成。但是我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合next()函数进行迭代使用，我们可以采用更简便的语法，即生成器(generator)。生成器是一类特殊的迭代器。&lt;br/&gt;创建生成器方法1&lt;br/&gt;要创建一个生成器，有很多种方法。第一种方法很简单，只要把一个列表生成式的 [ ] 改成 ( )。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;15]: L = [ x*&lt;span class=&quot;hljs-number&quot;&gt;2 &lt;span class=&quot;hljs-keyword&quot;&gt;for x &lt;span class=&quot;hljs-keyword&quot;&gt;in range(&lt;span class=&quot;hljs-number&quot;&gt;5)]

In [&lt;span class=&quot;hljs-number&quot;&gt;16]: L
Out[&lt;span class=&quot;hljs-number&quot;&gt;16]: [&lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;2, &lt;span class=&quot;hljs-number&quot;&gt;4, &lt;span class=&quot;hljs-number&quot;&gt;6, &lt;span class=&quot;hljs-number&quot;&gt;8]

In [&lt;span class=&quot;hljs-number&quot;&gt;17]: G = ( x*&lt;span class=&quot;hljs-number&quot;&gt;2 &lt;span class=&quot;hljs-keyword&quot;&gt;for x &lt;span class=&quot;hljs-keyword&quot;&gt;in range(&lt;span class=&quot;hljs-number&quot;&gt;5))

In [&lt;span class=&quot;hljs-number&quot;&gt;18]: G
Out[&lt;span class=&quot;hljs-number&quot;&gt;18]: &amp;lt;generator object &amp;lt;genexpr&amp;gt; at &lt;span class=&quot;hljs-number&quot;&gt;0x7f626c132db0&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt; 创建生成器方法2&lt;br/&gt;generator非常强大。如果推算的算法比较复杂，用类似列表生成式的 for 循环无法实现的时候，还可以用函数来实现。&lt;/p&gt;

&lt;p&gt;使用了yield关键字的函数不再是函数，而是生成器。（使用了yield的函数就是生成器）&lt;br/&gt;yield关键字有两点作用：&lt;br/&gt;保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起&lt;br/&gt;将yield关键字后面表达式的值作为返回值返回，此时可以理解为起到了return的作用&lt;br/&gt;可以使用next()函数让生成器从断点处继续执行，即唤醒生成器（函数）&lt;/p&gt;
&lt;p&gt;Python3中的生成器可以使用return返回最终运行的返回值，而Python2中的生成器不允许使用return返回一个返回值（即可以使用return从生成器中退出，但return后不能有任何表达式）。&lt;/p&gt;

&lt;p&gt;使用send唤醒&lt;/p&gt;
&lt;p&gt;我们除了可以使用next()函数来唤醒生成器继续执行外，还可以使用send()函数来唤醒执行。使用send()函数的一个好处是可以在唤醒的同时向断点处传入一个附加数据。&lt;/p&gt;&lt;p&gt;例子：执行到yield时，gen函数作用暂时保存，返回i的值; temp接收下次c.send(&quot;python&quot;)，send发送过来的值，c.next()等价c.send(None)&lt;/p&gt;
&lt;p&gt;协程：&lt;/p&gt;
&lt;p&gt;又称微线程。通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定&lt;/p&gt;

&lt;h3&gt;协程和线程差异：&lt;/h3&gt;
&lt;p&gt;在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文（可以理解为方法之间的切换），所以一秒钟切换个上百万次系统都抗的住。简单说，就是比线程占用资源更少。&lt;/p&gt;
&lt;p&gt;用yield()和next()实现简单协程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import time

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;work1&lt;span class=&quot;hljs-params&quot;&gt;():
    &lt;span class=&quot;hljs-keyword&quot;&gt;while &lt;span class=&quot;hljs-keyword&quot;&gt;True:
        print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;----work1---&quot;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;yield
        time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;0.5)

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;work2&lt;span class=&quot;hljs-params&quot;&gt;():
    &lt;span class=&quot;hljs-keyword&quot;&gt;while &lt;span class=&quot;hljs-keyword&quot;&gt;True:
        print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;----work2---&quot;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;yield
        time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;0.5)

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;span class=&quot;hljs-params&quot;&gt;():
    w1 = work1()
    w2 = work2()
    &lt;span class=&quot;hljs-keyword&quot;&gt;while &lt;span class=&quot;hljs-keyword&quot;&gt;True:
        next(w1)
        next(w2)

&lt;span class=&quot;hljs-keyword&quot;&gt;if __name__ == &lt;span class=&quot;hljs-string&quot;&gt;&quot;__main__&quot;:
    main()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用greenlet实现协程：&lt;/p&gt;
&lt;p&gt;greenlet 相当于集成了yield()和next(),使用的时候自动调用这两个方法。&lt;/p&gt;
&lt;p&gt;先装包：sudo pip3 install preenlet&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;/&gt;
&lt;/pre&gt;


&lt;p&gt;gevent的原理：当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。&lt;/p&gt;
&lt;p&gt;由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。&lt;/p&gt;
&lt;p&gt;安装：pip install gevent&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import time
&lt;span class=&quot;hljs-keyword&quot;&gt;import gevent


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;work1&lt;span class=&quot;hljs-params&quot;&gt;():
    &lt;span class=&quot;hljs-keyword&quot;&gt;for i &lt;span class=&quot;hljs-keyword&quot;&gt;in range(&lt;span class=&quot;hljs-number&quot;&gt;5):
        print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;work1 -----1&quot;)
        time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;0.5)


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;work2&lt;span class=&quot;hljs-params&quot;&gt;():
    &lt;span class=&quot;hljs-keyword&quot;&gt;for i &lt;span class=&quot;hljs-keyword&quot;&gt;in range(&lt;span class=&quot;hljs-number&quot;&gt;5):
        print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;work2 -----2&quot;)
        time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;0.5)


&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：上面代码中的time方法用的是gevent包中的。&lt;/p&gt;
&lt;p&gt;用gevent时，只要加入堵塞的方法都需要gevent里面的，所有的延时堵塞方法都要用gevent里面的。&lt;/p&gt;
&lt;p&gt;这样使用时就不是很方便，可能会不知道哪些方法需要用gevent里面的 。因此需要导入monkey。并在代码的最前面写一句：&lt;/p&gt;
&lt;p&gt;monkey .patch_all()#相当于monkey把代码中的所有延时操作都改成用gevent里面的。&lt;/p&gt;

&lt;p&gt;协程并发下载器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;/&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;进程线程协程之间的区别：&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;进程是资源分配的单位&lt;br/&gt;线程是操作系统调度的单位&lt;br/&gt;进程切换需要的资源很最大，效率很低&lt;br/&gt;线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）&lt;br/&gt;协程切换任务资源很小，效率高&lt;br/&gt;多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发&lt;/p&gt;

</description>
<pubDate>Thu, 16 Aug 2018 06:59:00 +0000</pubDate>
<dc:creator>Alexen</dc:creator>
<og:description>进程是资源分配单位，系统会分配内存，屏幕，窗口。线程是进程中真正执行的东西。　python中的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yu110812/p/9487324.html</dc:identifier>
</item>
<item>
<title>《React Native 精解与实战》书籍连载「React Native 中的生命周期」 - Parry</title>
<link>http://www.cnblogs.com/parry/p/9487227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/parry/p/9487227.html</guid>
<description>&lt;p&gt;此文是我的出版书籍&lt;a href=&quot;http://rn.parryqiu.com/&quot;&gt;《React Native 精解与实战》&lt;/a&gt;连载分享，此书由机械工业出版社出版，书中详解了 React Native 框架底层原理、React Native 组件布局、组件与 API 的介绍与代码实战，以及 React Native 与 iOS、Android 平台的混合开发底层原理讲解与代码实战演示，精选了大量实例代码，方便读者快速学习。&lt;/p&gt;
&lt;p&gt;书籍还配套了视频教程「80 节实战课精通 React Native 开发」，此视频课程建议配合书籍学习，书籍中原理性的东西讲解的比较清晰，而视频教程对于组件、API 等部分的代码实战开发讲解比较直观。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;书籍相关所有资料请访问：&lt;a href=&quot;http://rn.parryqiu.com/&quot;&gt;http://rn.parryqiu.com&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;任何生命体都会经历从出生到消亡的过程，而 React Native 框架中的组件同样具有这样的属性。&lt;br/&gt;在组件生命周期的每个阶段，React Native 提供了多个生命周期函数，供开发者作为切入组件生命周期的钩子（hook），这样在对应的时间点程序就可以做对应的逻辑处理，从而实现相应的功能。&lt;br/&gt;在 React Native 程序启动时，内部的虚拟 DOM 开始建立，生命周期就是建立在此虚拟 DOM 的整个生命周期之中，从虚拟 DOM 的初始化到虚拟 DOM 的卸载，React Native 为组件的不同状态建立了不同的生命周期。&lt;/p&gt;

&lt;p&gt;在图 3-4 中，可以看到在 React Native 虚拟 DOM 的几个大的阶段中，都有对应的生命周期函数存在。&lt;br/&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_ba22c9a478fcc261ec751d2b3584c22a.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 3-4 React Native 生命周期&lt;/p&gt;
&lt;h2 id=&quot;初始化阶段&quot;&gt;1. 初始化阶段&lt;/h2&gt;
&lt;p&gt;此阶段进行组件的默认 props 和 state 的设定，可通过如下代码赋值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. static defaultProps = {  
2. autoPlay: false,  
3. maxLoop: 10,  
4. };  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;加载阶段&quot;&gt;2. 加载阶段&lt;/h2&gt;
&lt;p&gt;此阶段为组件开始实例化的阶段，比如当该组件开始被其他组件调用的时候。主要包含以下三个生命周期函数。&lt;/p&gt;
&lt;ul readability=&quot;13.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;componentWillMount：组件将要开始加载，需要在组件开始加载前添加一些业务逻辑，那么就可以添加在此函数中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;render：组件开始根据 props 和 state 生成页面的 DOM，并在最后返回此 DOM。在此函数中不可以修改 props 和 state 的值，只可以读取，并且返回的 DOM 只能有一个顶层元素，比如说只能由一个 div 包裹所有的元素进行返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;componentDidMount：组件已加载完毕，在 render 函数之后立即执行此函数。一般可以在这里进行网络请求，因为组件 UI 渲染好之后再进行网络请求，一般不会造成 UI 的错乱问题。在此生命周期函数中修改设置了 state 的值后，UI 会立即进行重新渲染，所以是一个通过加载网络数据更新 UI 的好时机。&lt;/p&gt;
&lt;h2 id=&quot;更新阶段&quot;&gt;3. 更新阶段&lt;/h2&gt;
此阶段一般因为用户操作或者父组件有更新时，当组件因为 props 或 state 的变更导致组件重新渲染时，会经历此阶段。而在更新渲染的几个重要时机，React Native 提供了如下的生命周期函数供开发者执行对应的逻辑操作。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;componentWillReceiveProps：当接收到新的 props 值更新时，会执行到此生命周期函数，此时可以将接收到的 props 值赋值给 state。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;shouldComponentUpdate：在此生命周期中，可以通过逻辑判断新的 props 和 state 的变更需不需要引起组件的 UI 更新，默认是都会引起更新的，但是 React Native 提供了此生命周期供开发者自主决定是否需要更新。如果让此函数返回 True，那么组件将进行更新，如果返回 False，那么组件就不更新。此生命周期在优化 App 性能时非常重要，因为可以通过此生命周期函数拦截掉很多不必要的组件 UI 更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;componentWillUpdate：如果上面的生命周期函数 shouldComponentUpdate 返回了 True，那么此生命周期函数将继续执行，表示组件即将进行更新操作。在更新操作前，还有时机进行相关的逻辑处理。但是从逻辑上你也应该明白，这里不可以再修改 state 的值，而只可以做一些进行更新前的其他准备工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;componentDidUpdate：组件更新完毕之后执行的生命周期函数。此函数有两个参数 prevProps 和 prevState，分别为更新前的 props 与 state。这里可以进行一些新旧值的比较，如果发现值有变化可以进行一些网络请求、加载数据等操作。&lt;/p&gt;
&lt;h2 id=&quot;卸载阶段&quot;&gt;4. 卸载阶段&lt;/h2&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;componentWillUnmount：此生命周期函数在组件被卸载和注销前执行，这里可以进行一些所谓的扫尾工作，如关闭掉之前的网络请求、一些不必要存储的清空、循环执行的定时器的清除等等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此，React Native 一个组件的完整生命周期执行完毕，你可以通过下面的代码体会 React Native 每个生命周期的执行过程。实际开发时只需要根据实际的项目需求在对应的生命周期函数中添加上自己的业务逻辑即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. /** 
2. * 章节: 03-06 
3. * React Native 中的生命周期 
4. * FilePath: /03-06/lifecycle.js 
5. * @Parry 
6. */  
7. 
8. import React, { Component } from 'react';  
9. import { AppRegistry,View,Text } from 'react-native';  
10. 
11. export default class LifeCycle extends Component {  
12. 
13. constructor(props) {  
14. super(props);  
15. this.state = {  
16. name: &quot;React&quot;  
17. }  
18. }  
19. 
20. //组件即将加载  
21. componentWillMount() {  
22. console.log(&quot;componentWillMount&quot;);  
23. }  
24. 
25. //开始组件渲染  
26. render() {  
27. console.log(&quot;render&quot;);  
28. return (  
29. &amp;lt;View&amp;gt;  
30. &amp;lt;Text&amp;gt;  
31. {this.state.name}  
32. &amp;lt;/Text&amp;gt;  
33. &amp;lt;/View&amp;gt;  
34. );  
35. }  
36. 
37. //组件加载完毕后  
38. componentDidMount() {  
39. console.log(&quot;componentDidMount&quot;);  
40. }  
41. 
42. //组件接收到新的 props  
43. componentWillReceiveProps(nextProps) {  
44. console.log(&quot;componentWillReceiveProps&quot;);  
45. }  
46. 
47. //逻辑控制是否需要更新组件  
48. shouldComponentUpdate(nextProps, nextState) {  
49. console.log(&quot;shouldComponentUpdate&quot;);  
50. }  
51. 
52. //组件即将更新重新渲染  
53. componentWillUpdate(nextProps, nextState) {  
54. console.log(&quot;componentWillUpdate&quot;);  
55. }  
56. 
57. //组件重新渲染后  
58. componentDidUpdate(prevProps, prevState) {  
59. console.log(&quot;componentDidUpdate&quot;);  
60. }  
61. 
62. //组件卸载注销前  
63. componentWillUnmount() {  
64. console.log(&quot;componentWillUnmount&quot;);  
65. }  
66. }  
67. 
68. AppRegistry.registerComponent('LifeCycle', () =&amp;gt; Main);  &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本章如同修炼武功中必备的内功一样，看起来和使用 React Native 框架的关系不大，而且底层原理的部分理解起来还有点晦涩难懂。不过，如果你想成为一个精通 React Native 框架的开发者，而不仅仅是一个使用者的话，这部分的内容是非常重要的，而且在后期你遇到此框架的难题时，你可以快速地根据这部分底层原理性的知识快速定位到问题所在。其他软件开发语言的学习原则也是如此，希望能对你有所有启发。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Aug 2018 06:49:00 +0000</pubDate>
<dc:creator>Parry</dc:creator>
<og:description>此文是我的出版书籍[《React Native 精解与实战》](http://rn.parryqiu.com/)连载分享，此书由机械工业出版社出版，书中详解了 React Native 框架底层原理、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/parry/p/9487227.html</dc:identifier>
</item>
<item>
<title>Python 学习经历分享 - YJK923</title>
<link>http://www.cnblogs.com/YJK923/p/9487222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YJK923/p/9487222.html</guid>
<description>&lt;p&gt;如果说 Java 是亲儿子的话，那么 Python 应该就是干儿子了。看了一下所有关于 Python 的笔记，我发现原来我在 4 月份的时候就已经涉足 Python 了，但是到目前为止才真正算做出了一个案例，我尝试回忆一下我的 Python 学习过程，分享给大家，这中间有很多弯路。&lt;/p&gt;

&lt;p&gt;我最开始学习 Python 就是看廖雪峰的官方网站，大概是将 Python 基础部分学习完了，然后我就直接上手做了一个 Python 可视化的案例，这前前后后也就一两周的时间吧！能在这个时候就开始动手学 Python 也是拜同学所赐，天天叫着让我教她，完成她的那个可视化相关的作业，就这样推着我学习了 Python 。最后作业搞定了，后面就没有然后了。&lt;/p&gt;

&lt;p&gt;5 月我们决定继续搞 Python，为了进度的统一，我们找到一套视频教程，小甲鱼学 Python 。我们商定一个月搞定这套教程，显然最终也是以失败告终，失败的原因大致有两点，她的时间分配不足，我的积极性下降且回学校准备答辩去了。因为在学习的过程中，我还一直起到引导的作用，后面积极性下降，也就不管不问了。到了 6 月对于 Python 我也只是学到了面向对象。&lt;/p&gt;

&lt;p&gt;6 月底我突然冒出一个想法，要用爬虫去抓取 boss 直聘上的招聘信息，于是我再一次开始了我的 Python 学习之路，这次我又换了一种学习方式，我买了书籍，然后就是每天有的没的看看书，这次我开始整理一些东西出来，整理一章可能要比看完一章多花一倍的时间。那段时间我的时间是这样分配的，周一到周四的晚上留在公司看书，周五浪，周末睡睡觉，陪陪家人，over ~&lt;/p&gt;

&lt;p&gt;就这样，我开始看书，记笔记，实话说，我的主业是 Java，对 Python 也就是想着拓展知识的心态，实际的应用几乎没有。进度一直很慢，还有一个原因是我心里一直有个小小的疙瘩，我这 Java 都不会的人，还去搞什么 Python，Java 和 Python 这两个小人一直在打架，显然最近都是在整理 Java ，但是看到 Python 我就心累，拖了这么久，自己都看不下去的那种。&lt;/p&gt;

&lt;p&gt;还好，我这也算是有结果了，以后就能正大光明的吹牛逼说自己也会 Python 了。为什么会如此拖拉，我尝试总结一下，第一，对 Python 没有整体的认识，最开始学习 Python 的时候我都不知道这可以干什么。就想着很火，我应该学习一下。第二，有了认识之后没有确定好方向，是搞可视化，数据分析，还是爬虫，web ，甚至人工智能，根本没有想清楚。第三，选择好方向之后就是选择学习的资料，一点不要贪多呀！有一个就足够。第四，时间有限，产出有限，要相信时间的积累，不然会很累。&lt;/p&gt;

&lt;p&gt;为什么这些我都能想的清楚，理的明白。还是要归功于我看过的书，所以说，要多看书！我的生活一点都不单调，工作之外有阅读，有 Java ，有 Python ，还有各种博客要写，打理公号等等 ，生活五彩缤纷，但不是一下就能展示给大家的。慢慢来 ~ 还是那句话，相信时间的力量。&lt;/p&gt;

&lt;p&gt;说回 Python ，还没说我现在到底实现了什么呢。说起来很简单，就是将 boss 上的招聘信息爬下来，然后分别存在了 Excel 中和数据库中。这样我就得到了原始数据。后期可能在数据上的基础上进行操作，目前只是第一步，不得不说，若你是一个小白，学起 Python 实现这个案例也不需要很长时间。&lt;/p&gt;

&lt;p&gt;如果你也刚好想学 Python ，我给的建议就是先了解一下 Python 可以用来做什么，你想使用 Python 做什么，然后就是干了。但是在学的过程中一定要有 &quot; 目的性 &quot; ，尽快的实现一个可以让你感到成就感的 demo ，这样会增加你的动力。至于细致的研究，后面再说！&lt;/p&gt;

&lt;p&gt;代码和展示我就不贴了，主要和大家说的是经历和感悟。想要具体实现的，可以留言哦！这个项目后续还会跟进的~&lt;/p&gt;
</description>
<pubDate>Thu, 16 Aug 2018 06:48:00 +0000</pubDate>
<dc:creator>YJK923</dc:creator>
<og:description>如果说 Java 是亲儿子的话，那么 Python 应该就是干儿子了。看了一下所有关于 Python 的笔记，我发现原来我在 4 月份的时候就已经涉足 Python 了，但是到目前为止才真正算做出了一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YJK923/p/9487222.html</dc:identifier>
</item>
<item>
<title>Flask-数据与路由 - 山丘i</title>
<link>http://www.cnblogs.com/mengd/p/9487210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengd/p/9487210.html</guid>
<description>&lt;h3 id=&quot;数据&quot;&gt;数据&lt;/h3&gt;
&lt;p&gt;图书数据库的地址&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 基地址
http://t.yushu.im
# 关键字搜索
http://t.yushu.im/v2/book/search?q={}&amp;amp;start={}&amp;amp;count={}
# isbn搜索
http://t.yushu.im/v2/book/search/isbn/{isbn}
# 豆瓣api
https://api.douban.com/v2/book/1003078&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;搜索关键字&quot;&gt;搜索关键字&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;根据上面的地址可以知道搜索的时候有两种方式，而对于isbn搜索，又分为两种&lt;code&gt;isbn13 由13个0-9在数字组成&lt;/code&gt;,&lt;code&gt;isbn10 由10表0-9表数字组组成，中间可能包含' - ' ,&lt;/code&gt;所以要分开来判断&lt;/li&gt;
&lt;li&gt;在函数中要注意：&lt;code&gt;isdigit()&lt;/code&gt;可以判断是否为数字 ，&lt;code&gt;replace()&lt;/code&gt;用来替换，&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@app.route(&quot;/search/&amp;lt;q&amp;gt;/&amp;lt;page&amp;gt;&quot;)
def search(q,page):
    &quot;&quot;&quot;
    搜索书籍路由
    :param q: 关键字 OR isbn
    :param page: 页码
    &quot;&quot;&quot;
    isbn_or_key = 'key'
    # 1. 判断长度是否为13且是否为数字
    if len(q) == 13 and q.isdigit():
        isbn_or_key = 'isbn'
    # 2. 把-替换掉，判断是否为纯数字
    short_q = q.replace('-', '')
    if '-' in q and len(short_q) == 10 and short_q.isdigit():
        isbn_or_key = 'isbn'
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;多逻辑判断的时候，应该把结果看着为假的放到前面，对数据库操作的放到后面，这样有利于节约资源&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;简单的重构&quot;&gt;简单的重构&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;上面的代码都写到视图中这样不妥，体现不了封装性，看起来不好，应该把一个实现的功能封装起来，建立一个函数，方便日后的管理&lt;/li&gt;
&lt;li&gt;在目录下建立一个&lt;code&gt;helper.py&lt;/code&gt;文件，这个文件主要就是提供一些方法，把上面的内容放到这里,只需要返回一个值就可以了&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

def is_isbn_or_key(word):
    isbn_or_key = 'key'
    if len(word) == 13 and word.isdigit():
        isbn_or_key = 'isbn'

    short_word = word.replace('-', '')
    if '-' in word and len(short_word) == 10 and short_word.isdigit():
        isbn_or_key = 'isbn'

    return isbn_or_key
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在主文件中调用这个方法就可以了，记得传值，和接收返回的值&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

from flask import Flask,make_response
# 1. 这里要导入
from helper import is_isbn_or_key

app = Flask(__name__)
app.config.from_object('config')

@app.route('/book/search/&amp;lt;q&amp;gt;/&amp;lt;page&amp;gt;')
def search(q,page):
    # 2. 调用方法即可
    is_or_key = is_isbn_or_key(q)
    pass

if __name__ == '__main__':
    app.rundebug=app.config['DEBUG'])&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;requests请求&quot;&gt;requests请求&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;因为这个项目要访问不同的网址，所以在目录下新建一个&lt;code&gt;http.py&lt;/code&gt;文件，专门用来提供访问网址&lt;/li&gt;
&lt;li&gt;这里使用的requests，要先进行安装，注意：代码写的时候一定要简洁，&lt;strong&gt;千万不要使用python的关键字，以免与Python的模块冲突并导致此错误&lt;/strong&gt;，把这个类名http改为别的名称&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

import requests
class aaa:

    # 传入url和是否返回的是json数据，这里是静态方法
    @staticmethod
    def get(url,return_json=True):
        # 发送get请求
        r = requests.get(url)
        # 因为有的url返回的json数据，但是有的并不是,所以加一个判断,不是的话返回文本
        # 还要判断状态码，200的话就是访问成功有数据
        if r.status_code != 200:
            return {} if return_json else ''
        return r.json() if return_json else r.text

        # 下面的写法太low
        # if r.status_code == 200:
        #     if return_json:
        #         return r.json()
        #     else:
        #         return r.text
        # else:
        #     if return_json:
        #         return {}
        #     else:
        #         return ''
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;从api中获取数据&quot;&gt;从API中获取数据&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;首先在目录下定义一个类，用于用于获取数据，&lt;code&gt;ShanqiuBook&lt;/code&gt;,&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

from http import aaa
class ShanqiuBook:

    isbn_url = 'http://t.yushu.im/v2/book/search/isbn/{}'
    keyword_url = 'http://t.yushu.im/v2/book/search?q={}&amp;amp;count={}&amp;amp;start={}'


    # 根据isbn进行搜索,这里使用这个静态装饰器,调用类变量更加的方便
    @classmethod
    def search_by_isbn(cls,isbn):
        # 调用类变量，
        url = cls.isbn_url.format(isbn)
        # 调用上面的方法用于请求网址
        result = aaa.get(url)
        # 这里返回的是json数据，但是在py中就是字典了
        return result

    # 根据关键字进行搜索
    @classmethod
    def search_by_keyword(cls,keyword,count=15,start=0):
        url = cls.keyword_url.format(keyword,count,start)
        result = aaa.get(url)
        return result
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;然后在视图中获取返回的数据&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

from flask import Flask
from helper import is_isbn_or_key

from flask import jsonify
# 实例化
from shanqiu_book import ShanQiuBook

app = Flask(__name__)
# 载入这个配置文件
app.config.from_object('config')

@app.route('/book/search/&amp;lt;q&amp;gt;/&amp;lt;page&amp;gt;')
def search(q,page):
     is_or_key = is_isbn_or_key(q)
     if is_or_key == 'isbn':
         # 这里直接使用使用类名调用就可以
         result = ShanQiuBook.search_by_isbn(q)
    else:
         result = ShanQiuBook.search_by_keyword(q)
    
    # 因为返回的是json数据，要手动的进行解析，这样写的话非常麻烦
    # return json.dumps(result), 200, {'content-type': 'application/json'}
    # 这里使用flask自带的jsonify替换麻烦的json.dumps和元组
     return jsonify(result)

    
if __name__ == '__main__':
    app.run(debug=app.config['DEBUG'])&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;将视图函数拆分到单独的文件中&quot;&gt;将视图函数拆分到单独的文件中&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果视图函数都写在主文件中，不利于维护，而是应该把他们放入到一个文件中，每一个模块就是一个试图，用的时候直接引用，这样有利于维护&lt;/li&gt;
&lt;li&gt;在根目录下建立一个app/web文件夹，在这个文件夹下面建立一个book.py文件，专门用来存放book模块，然后在主文件中引用这个模块就可以了，&lt;code&gt;book.py&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
from flask import jsonify
from helper import is_isbn_key
from ShanqiuBook import ShanqiuBook

# 为了让book.py模块可以使用app对象
from demo import app

@app.route('/book/search/&amp;lt;q&amp;gt;/&amp;lt;page&amp;gt;')
def hello(q,page):

    # 调用方法判断用户是根据什么查的
    is_or_key = is_isbn_key(q)
    if is_or_key == 'isbn':
        result = ShanqiuBook.search_by_isbn(q)
    else:
        result = ShanqiuBook.search_by_keyword(q)

    return jsonify(result)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;此时的主文件中&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
from flask import Flask
# 为了可以注册book.py中的路由
from app.web import book

app = Flask(__name__)
app.config.from_object('config')

if __name__ == '__main__':
    app.run(debug=app.config['DEBUG'])
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;但是这样写的话，会出现404，因为出现了循环引用&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;循环引入流程分析&quot;&gt;循环引入流程分析&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;因为在整个的流程中，app两次初始化，如图&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212924/201808/1212924-20180816144609561-1145915740.png&quot; alt=&quot;解释&quot;/&gt;&lt;/li&gt;
&lt;li&gt;整个流程中，出现了两次核心app对象的初始化，注册路由是在蓝色流程中初始化的app注册的。但是启动服务是红色流程中的app启动的&lt;/li&gt;
&lt;li&gt;book中注册路由所使用的app对象，是他自己所导入fisher模块的app对象（蓝色流程中），而不是红色主流程中所实例化的app对象&lt;/li&gt;
&lt;li&gt;问题1：因为都是由fisher引入book，一个模块只会引入另一个模块一次，所以只执行了一次book&lt;/li&gt;
&lt;li&gt;问题2：由于一次是主流程执行fisher文件；一次是由book模块导入 fisher&lt;/li&gt;
&lt;li&gt;为了验证我们的结论，我们在app实例化，启动，注册路由是哪个地方加入日志信息，&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(&quot;id为&quot;+str(id(app))+&quot;的app注册路由&quot;)
@app.route(&quot;/book/search/&amp;lt;q&amp;gt;/&amp;lt;page&amp;gt;&quot;)
def search(q, page):
    isbn_or_key = is_isbn_or_key(q)
    if isbn_or_key == 'isbn':
        result = YuShuBook.search_by_isbn(q)
    else:
        result = YuShuBook.search_by_key(q)
    return jsonify(result)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;主文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;app = Flask(__name__)
print(&quot;id为&quot;+str(id(app))+&quot;的app实例化&quot;)
app.config.from_object(&quot;config&quot;)
# 为了可以注册book.py中的路由
from app.web import book
if __name__ == '__main__':
    print(&quot;id为&quot; + str(id(app)) + &quot;的app启动&quot;)
    app.run(debug=app.config['DEBUG'])&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;结果如下&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;id为92323280的app实例化
id为107142192的app实例化
id为107142192的app注册路由
id为92323280的app启动&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到注册路由的app，和启动服务的app不是同一个app。并且最后启动的app是最先实例化的app，也就是红色主流程的app；而注册路由的app是后实例化的app，也就是由book导入fisher模块的蓝色流程的app&lt;/p&gt;
</description>
<pubDate>Thu, 16 Aug 2018 06:47:00 +0000</pubDate>
<dc:creator>山丘i</dc:creator>
<og:description>数据 图书数据库的地址 搜索关键字 1. 根据上面的地址可以知道搜索的时候有两种方式，而对于isbn搜索，又分为两种 ,`isbn10 由10表0 9表数字组组成，中间可能包含' ' ,`所以要分开来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mengd/p/9487210.html</dc:identifier>
</item>
</channel>
</rss>