<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一道360 crackme的分析 - bamb00</title>
<link>http://www.cnblogs.com/goodhacker/p/8395240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodhacker/p/8395240.html</guid>
<description>&lt;p&gt;该crackme主要实现都在so中，用ida加载libqihoo.so，出现以下错误&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223042062-833108211.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223054578-2147384262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个错误说明是节区头部表格的表项大小错误，第二个错误是指节区头部表格的大小或偏移值错误。不管它，点击“Yes”继续加载。找到JNI_OnLoad函数，发现该函数已经加密：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223119031-1825627825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道so 文件加载时首先会查看 .init 或 .init_array 段是否存在，如果存在那么就先运行这段的内容，如果不存在的话那么就检查是否存在JNI_OnLoad，存在则执行。所以JNI_OnLoad的解密可能在 .init 或 .init_array 段中。&lt;br/&gt;因为 .init 或者 .init_array 在 IDA 动态调试的时候是不会显示出来的，所以需要静态分析出这两段的偏移量然后动态调试的时候计算出绝对位置，然后在 make code（快捷键：c），这样才可以看到该段内的代码内容。&lt;br/&gt;查看 .init_array 段的地址有两种办法：&lt;br/&gt;（1）.可以使用 IDA 加载 .so 文件，按ctrl+s快捷键查看 “Segments” 视图，这里会列出不同类型的代码段信息，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223138265-1580378770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）.可以使用二进制工具 readelf 来查看 .so 文件的结构，在 OS X 上面可以使用 greadelf 代替。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223151187-872765132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上述（1）可以看出，并没有显示该so的.init 或者 .init_array段，所以我们需要对该so进行修复。&lt;br/&gt;因为节区头部表的偏移值e_shoff为0x2118c(在0x20h处），所以根据ELF文件的结构，从该偏移值开始到文件结尾的数据为整个节区头部表。由于节区头部表项的大小（e_shentsize)固定为0x28，所以我们可以由:(0x214fb - 0x2118c + 1)/0x28 = 0x16 得出真正的节区头部表项数目(e_shnum)为0x16。&lt;br/&gt;下面再来看e_shstrndx字段，我们从ELF文件中可以明显地看出，字符串表节区为最后一个节区，所以它的索引值应当为0x15。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223211062-1552034277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据上述规则将对应数值修改好后保存文件，然后再次加载修复后的so文件，已经不会报错了，按ctrl+s快捷键也可以查看到.init_array段信息了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223230984-520491704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IDA 定位到.init_array段，可以看到.init_array段会执行__gnu_armfini_26函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223250671-161685888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该函数含义大量花指令，为了便于分析，我们在该函数下断点，对其进行动态调试。通过动态调试，我们会发现该so中花指令与真实指令的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131223307109-1806545325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;__gnu_armfini_26函数清除花指令后的汇编代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BL __gnu_armfini_30
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R4, R0
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt; R0, #0x28 &lt;span&gt;;&lt;/span&gt;&lt;span&gt; '('&lt;/span&gt;
BL sysconf &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 获取系统的cpu个数和可用的cpu个数&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; R1, R4, #0x8A00
BIC R0, R4, #0xFF0
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt; R2, #&lt;span&gt;7&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; R1, R1, #0xEC
BIC R0, R0, #0xF
BL __gnu_arm_fini_06
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R1, #0x8A00
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R0, R4
&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; R1, R1, #0xEC
BL __gnu_armfini_29
&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; R1, R4, #0x8A00
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R0, R4
&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt; R1, R1, #0xEC
BL sub_B6E37614&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中调用的__gnu_armfini_29函数比较可疑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224324765-159300300.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;_arm_aeabi_6去掉花指令后是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;102&quot;&gt;
&lt;pre&gt;
&lt;span&gt;STMFD SP!, {R3-R8,R10,LR}
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R4, R0
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt; R5, R1    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;0000000C&lt;/span&gt;
&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R8, R2
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt; R3, #&lt;span&gt;0&lt;/span&gt;&lt;span&gt;

:loc_B6EFDA74
STRB R3, [R8,R3]    &lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;0x00 将r8开始的地址依次填充0-0x99&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt; R3, R3, #&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;0+1&lt;/span&gt;
&lt;span&gt;CMP&lt;/span&gt;&lt;span&gt; R3, #0x100
BNE loc_B6EFDA74
&lt;/span&gt;&lt;span&gt;MOV&lt;/span&gt; R3, #&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R6, R3
STRB R3, [R8,#0x100]    &lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;R8+#0x100地址处的内容置0&lt;/span&gt;
STRB R3, [R8,#0x101]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R8+#0x101地址处的内容置0&lt;/span&gt;
&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R7, R8
&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt; R10, R8, #0x100    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R8:BEF9C6F4, R10:BEF9C7F4&lt;/span&gt;
&lt;span&gt;MOV&lt;/span&gt;&lt;span&gt; R0, R3

:loc_B6EFD914
LDRB R2, [R4,R0]    &lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;r2=0x96,0xE6,0x57&lt;/span&gt;
LDRB R3, [R7]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R3=0x00, R3=0xC2,0x00&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt; R0, R0, #&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;r0=0x01, 0x02, 0x03&lt;/span&gt;
&lt;span&gt;MOV&lt;/span&gt; R1, R5    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R1=R5=0x0C&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt; R2, R2, R3    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R2 = R2+R3=0xC6+0x00, R2 = R2+R3=0x96+0xC2=0x158, R2 = R2+R3=0xE6+0x00=0xE6&lt;/span&gt;
&lt;span&gt;ADD&lt;/span&gt; R6, R2, R6    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R6 = R2+R6=0xC6+0x00, R6 = R2+R6=0x158+0xC6=0x21E, R6 = R2+R6=0xE6+0x01E=0x104&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; R6, R6, #0xFF    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;R6 = 0xC6, 0x01E, 0x004&lt;/span&gt;
LDRB R2, [R8,R6]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;r2=0x00, 0xEF, 0xE9&lt;/span&gt;
STRB R2, [R7],#&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;STR R0，[R1], #8 将R0中的字数据写入以R1为地址的存储器 中，并将新地址R1＋8写入R1。&lt;/span&gt;
STRB R3, [R8,R6]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;r3=0x00, 0xC2, 0x00&lt;/span&gt;
BL __aeabi_idivmod    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;执行完后r1=r0=0x01,0x02,0x03&lt;/span&gt;
&lt;span&gt;CMP&lt;/span&gt; R7, R10    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;r7=0xC2,r10=0x00 &lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; R0, R1, #0xFF    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;r0:0x01&lt;/span&gt;
&lt;span&gt;BNE loc_B6EFD914
LDMFD SP!, {R3-R8,R10,PC}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这实际上就是RC4算法的第一个步骤（参考：https://www.jianshu.com/p/fcfdcc3ff9d5）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;/*&lt;br/&gt;初始化状态向量S和临时向量T，供keyStream方法调用&lt;br/&gt;*/&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; initial() { 
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;256&lt;/span&gt;;++&lt;span&gt;i){ 
        S[i]&lt;/span&gt;=&lt;span&gt;i; 
        T[i]&lt;/span&gt;=K[i%&lt;span&gt;keylen]; 
    } 
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;_gnu_arm_message函数具有rc4算法的典型特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224418546-1359129603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;_gnu_armfini_29这个函数解密从0x75EEC6DC地址开始，大小为0x8AEC内存区域的数据，实际上是对地址为“基址0x75ED5000+0x176dc”，大小为0x8AEC的内存区域数据进行解密。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224433218-128421651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224447656-1300969751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解密完毕后将该so dump下来，dump的起始地址及大小可以通过ida的Modules菜单获取：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224503218-438379998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dump脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static main(void)
{
auto fp, begin, end, ptr;
fp &lt;/span&gt;= fopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d:\\dump.so&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
begin &lt;/span&gt;= &lt;span&gt;0x75ED5000&lt;/span&gt;&lt;span&gt;;
end &lt;/span&gt;= begin + &lt;span&gt;0x23000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( ptr = begin; ptr &amp;lt; end; ptr ++&lt;span&gt; )
fputc(Byte(ptr), fp);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;按快捷键“shift+F2”打开脚本编写窗口写入上述脚本代码，点击“Run&quot;运行该代码就可以在D盘根目录看到dump下来的so文件dump.so。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用IDA打开dump.so，定位到JNI_OnLoad函数，按“C”键，将数据转换成代码，按”F5“查看反编译的伪代码，按“Y”键修正变量类型，得到如下的代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224541562-565658618.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们知道RegisterNatives的函数原型是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
jint RegisterNatives(jclass clazz, &lt;span&gt;const&lt;/span&gt; JNINativeMethod*&lt;span&gt; methods,jint nMethods)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第二个参数是JNINativeMethod结构体&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
　　&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; name;
　　&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; signature;
　　&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;*&lt;span&gt; fnPtr;
} JNINativeMethod;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结构体的第三个参数是函数指针，该结构体的偏移地址为0x22004，定位到该偏移地址处发现没有正常把函数指针解析出来，需要进一步调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224647218-440124959.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;重新打开libqihoo.so，在 __gnu_armfini_29函数处下断点，进行动态调试。按F9运行到这里后，函数会进行内存区块解密，解密完成之后，在Modules菜单中找到libqihoo.so，点开，我们就可以看到“verify”和“JNI_OnLoad”函数了，分别下断点（注意，一定要在解密完之后，即执行完__gnu_arm_message函数后再下断点），如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224703718-1769979765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再按F9就来到了JNI_OnLoad函数处&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224721015-1299614566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定位到JNINativeMethod结构体地址，从ida中我们可以看到该结构体函数指针指向verify函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224733453-1638684610.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;继续F9，执行到verify函数。&lt;br/&gt;在verify函数中调用了__gnu_Unwind_8和__gnu_Unwind_6函数。&lt;br/&gt;__gnu_Unwind_8函数的作用是将jstring转换成为c/c++中的char*&lt;br/&gt;从java程序中传过去的String对象在本地方法中对应的是jstring类型，jstring类型和c中的char*不同，所以如果你直接当做char*使用的话，就会出错。因此在使用之前需要将jstring转换成为c/c++中的char*，这里使用JNIEnv提供的方法转换。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; java jstring turn to c/c++ char* &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;char&lt;/span&gt;* jstringToChar(JNIEnv*&lt;span&gt; env, jstring jstr)
{ 
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;* pStr =&lt;span&gt; NULL;
    jclass jstrObj &lt;/span&gt;= (*env)-&amp;gt;FindClass(env, &quot;java/lang/String&quot;&lt;span&gt;);
    jstring encode &lt;/span&gt;= (*env)-&amp;gt;NewStringUTF(env, &quot;utf-8&quot;&lt;span&gt;);
    jmethodID methodId &lt;/span&gt;= (*env)-&amp;gt;GetMethodID(env, jstrObj, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;&lt;span&gt;);
    jbyteArray byteArray &lt;/span&gt;= (jbyteArray)(*env)-&amp;gt;&lt;span&gt;CallObjectMethod(env, jstr, methodId, encode);
    jsize strLen &lt;/span&gt;= (*env)-&amp;gt;&lt;span&gt;GetArrayLength(env, byteArray);
    jbyte &lt;/span&gt;*jBuf = (*env)-&amp;gt;&lt;span&gt;GetByteArrayElements(env, byteArray, JNI_FALSE);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (jBuf &amp;gt; 0&lt;span&gt;)
    {
        pStr &lt;/span&gt;= (&lt;span&gt;char&lt;/span&gt;*)malloc(strLen + 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pStr)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
        }
        memcpy(pStr, jBuf, strLen);
        pStr[strLen] &lt;/span&gt;= 0&lt;span&gt;;
    }
    env&lt;/span&gt;-&amp;gt;ReleaseByteArrayElements(byteArray, jBuf, 0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pStr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;实际上上述转换的字符串就是用户输入的用户名、邮箱以及序列号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在__gnu_Unwind_6函数中会判断用户输入的序列号长度是否为8。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131224945312-361974330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用__gnu_Unwind_1函数，此函数又有很多花指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225005812-719313284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次调用_gnu_armfini_29函数，通过前面的分析我们知道这是一个RC4加解密函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225019640-2132287394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里实际上是取“用户名+邮箱”组成的字符串的的前四个字节进行加密，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225035296-711506956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就是一个比较关键的函数__gnu_Unwind_4了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225050343-275696637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个函数实际上是实现了SHA1加密算法，以下为该算法初始化缓冲区时的特征：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225106140-144495833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;__gnu_Unwind_4将”用户名+邮箱“组成的字符串（包括前四个被RC4算法加密过的字符）进行SHA1加密后，通过__gnu_Unwind_11函数与用户输入的序列号进行对比，从而判断是否破解成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225119546-1297073529.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/282719/201801/282719-20180131225131781-859003127.png&quot; alt=&quot;&quot; width=&quot;341&quot; height=&quot;607&quot;/&gt;&lt;/p&gt;
&lt;p&gt;附：其它方法&lt;br/&gt;我们重新打开一个ida，加载libqihoo.so，按快捷键“shift+F2”打开脚本编写窗口编写脚本对该内存区域进行解密。如下图所示：&lt;/p&gt;
&lt;p&gt;这样得到的就是完全解密的so文件了。&lt;br/&gt;脚本内容:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; idaapi

def rc4(data, key):
&lt;/span&gt;&quot;&quot;&quot;RC4 encryption and decryption method.&quot;&quot;&quot;&lt;span&gt;
S, j, out &lt;/span&gt;= list(range(256)), 0&lt;span&gt;, []

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i in range(256&lt;span&gt;):
j &lt;/span&gt;= (j + S[i] + ord(key[i % len(key)])) % 256&lt;span&gt;
S[i], S[j] &lt;/span&gt;=&lt;span&gt; S[j], S[i]

i &lt;/span&gt;= j = 0
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; ch in data:
i &lt;/span&gt;= (i + 1) % 256&lt;span&gt;
j &lt;/span&gt;= (j + S[i]) % 256&lt;span&gt;
S[i], S[j] &lt;/span&gt;=&lt;span&gt; S[j], S[i]
out.append(chr(ord(ch) &lt;/span&gt;^ S[(S[i] + S[j]) % 256&lt;span&gt;]))

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;.join(out)

key&lt;/span&gt;=idaapi.get_many_bytes(0x20434,12&lt;span&gt;)
addr&lt;/span&gt;= 0x176dc&lt;span&gt;;
data&lt;/span&gt;=idaapi.get_many_bytes(addr,0x8aec&lt;span&gt;)
decode&lt;/span&gt;=&lt;span&gt;rc4(data,key)
idaapi.patch_bytes(addr, decode)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 31 Jan 2018 14:53:00 +0000</pubDate>
<dc:creator>bamb00</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goodhacker/p/8395240.html</dc:identifier>
</item>
<item>
<title>中小研发团队架构实践之统一应用分层 - arch-system</title>
<link>http://www.cnblogs.com/dotnet-arch-system/p/8395207.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnet-arch-system/p/8395207.html</guid>
<description>&lt;h2 id=&quot;magicdomid2&quot; class=&quot;gutter-author-3423802 heading-2 locate lineguid-OAU9reFCIyvYUWQ2&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;一、写在前面&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;应用分层这件事情看起来很简单，但每个程序员都有自己的一套，哪怕是初学者。如何让一家公司的几百个应用采用统一的分层结构，并得到大部分程序员的认同呢？这可不是件简单的事情，接下来以我们真实案例与大家一起探讨，先问大家两个技术问题：&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid4&quot; class=&quot;list-start-number1 font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-5ylaBPK6ZygoPtjT&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;服务的调用代码你觉得放到哪一层好呢？A表现层；B业务逻辑层；C数据层；D公共层。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid5&quot; class=&quot;font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-HeMBlRPKIWq6lyur&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;如何组织好VO(View Object视图对象)、BO(Business Object业务对象)、DO(Data Object数据对象)、DTO(Data Transfer Object数据传输对象)呢？&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;不同的人会有不同的答案，所以要&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;统一&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;公司应用分层，以减少开发维护学习成本。统一应用分层要可大可小、&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;简单易用、&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;支持多种场景，我们采用IPO方式：I是Input、O是Output、P是Process，一进一出一处理。&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;应用系统的本质是机器，是处理设备，一进一出一处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid7&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-RySHmuawNgSOEzRp&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131223816218-344903290.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-size-3&quot;&gt;&lt;span&gt;                                                                  &lt;strong&gt;IPO&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;原理图&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;magicdomid9&quot; class=&quot;gutter-author-3423802 heading-2 locate lineguid-t6D71njO4gZzkZbv&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;二、统一逻辑架构&lt;/span&gt;&lt;/h2&gt;
&lt;div id=&quot;magicdomid10&quot; class=&quot;gutter-author-3423802 line-center locate lineguid-BLBKtNgc2I2SCbe5&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131223838546-1466285923.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;                                         统一应用分层的逻辑架构图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;author-3423802 b&quot;&gt;职责说明：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid13&quot; class=&quot;gutter-author-3423802 table-div&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;div class=&quot;iframe-container&quot;&gt;
&lt;div class=&quot;shadow-table&quot;&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr&gt;&lt;td&gt;层英文名&lt;/td&gt;
&lt;td&gt;中文名&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PresentationLayer&lt;/td&gt;
&lt;td&gt;表现层文件夹&lt;/td&gt;
&lt;td&gt;上层向用户提供服务，负责视图展示。项目类型包括WebSite、WebForm、MVC、WCF、WebService等。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BusinessLayer&lt;/td&gt;
&lt;td&gt;业务逻辑层文件夹&lt;/td&gt;
&lt;td&gt;中间逻辑处理，负责应用系统的业务逻辑的处理。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DataLayer&lt;/td&gt;
&lt;td&gt;数据访问层文件夹&lt;/td&gt;
&lt;td&gt;下层调用服务，负责数据资源提供方如数据库、SOA、OpenAPI的交互。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;EntityLayer&lt;/td&gt;
&lt;td&gt;实体层文件夹&lt;/td&gt;
&lt;td&gt;VO：View Object视图对象；&lt;br/&gt;DTO：Data Transfer Object数据传输对象；&lt;br/&gt;BO：Business Object业务对象；&lt;br/&gt;DO：Data Object数据对象；&lt;br/&gt;在实际项目中，为简化设计可进行裁剪，BO和DO为可选，DTO属于服务项目类型，VO属于网站项目类型，也不会同时存在。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CommonLayer&lt;/td&gt;
&lt;td&gt;公共层文件夹&lt;/td&gt;
&lt;td&gt;工具类库，负责提供应用系统中常用的操作。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TestLayer&lt;/td&gt;
&lt;td&gt;测试层文件夹&lt;/td&gt;
&lt;td&gt;单元测试（可选），负责对其它类库的自动化单元测试。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;magicdomid14&quot; class=&quot;font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-Hdj1daU6AJzQvXlL&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;文件夹分层法：应用分层采用文件夹方式的优点是可大可小、简单易用、统一规范，可以包括5个项目，也可以包括50个项目，以满足所有业务应用的多种不同场景；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid15&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-Cwbs0zCLHJqWOGz8&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt;调用规约：在开发过程中，需要遵循分层架构的约束，禁止跨层次的调用；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid16&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-a2Me3eY6KB3NtepK&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt;下层为上层服务：以用户为中心，以目标为导向。上层（业务逻辑层）需要什么，下层（数据访问层）提供什么，而不是下层（数据访问层）有什么，就向上层（业务逻辑层）提供什么；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid17&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-ublfpKOchCDEy5kU lineguid-gc9w8ZmLcY7pRRjR lineguid-aPcH2RckSOBmqh5i&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt;实体层规约：DO是数据表对象，不是数据访问层对象，不是只能给数据访问层使用；DTO是网络传输对象，不是表现层对象，不是只能给表现层使用；BO是内存计算逻辑对象，不是业务逻辑层对象，不是只能给业务逻辑层使用 。&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;如果仅限定在本层访问，则导致单个应用内大量没有价值的对象转换。以用户为中心来设计实体类，可以减少无价值重复对象和无用转换；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid18&quot; class=&quot;gutter-author-3423802 list-div locate lineguid-2M0YFmDlRfUtdejF&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt;U型访问：下行时表现层是Input，业务逻辑层是Process，数据访问层是Output。上行时数据访问层是Input，业务逻辑层是Process,  表现层就Output。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2 id=&quot;magicdomid19&quot; class=&quot;gutter-author-3423802 heading-2 locate lineguid-o0GVP94e5kr2XHF4&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802&quot;&gt;三、我们的具体规范&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;        此规范我们用了四年，牵涉几百个应用，200多个研发人员，是一个成功的实践。接下来就借用本文&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;提供下载的TripOrderService、TripSellerMVCSite这两个Demo&lt;span class=&quot;author-3423802&quot;&gt;来进行具体规范的说明，&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;以下是截图：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid21&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-Z0N6MtzErqcRz3dS&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131223910500-1784436339.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid22&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-pFoxDYfCaWtXzBFv&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131223924468-715036767.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;magicdomid23&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-qd10e7gTFhe5qKK5&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-6&quot;&gt;&lt;span&gt;3.1、&lt;/span&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;&lt;span&gt;项目命名规则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;项目命名规则：{产品线英文名全称}.{子系统英文名全称+应用名}.{项目职责英文名全称}，如：Trip.Seller.DTO。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid25&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-AQ8sqW7Lur3o9AfF&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b font-size-6&quot;&gt;3.2、业务逻辑层的项目规范&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid26&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-7qJkzSRxowY0JA7y&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131223945015-728845028.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、项目名的命名规则：{产品线英文名全称}.{子系统英文名全称&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;+应用名}&lt;span class=&quot;author-3423802&quot;&gt;.xxxBusiness，如上图的Trip.Order.Business。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、类名以Logic结尾，如上图的OrderLogic.cs。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid30&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-1E8nDlgbpSXbDKaJ&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-6&quot;&gt;&lt;span&gt;3.3、数据操作项目&lt;/span&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;规范&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid31&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-fGYtDcIJpM5mNUsq&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224002406-1860863187.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、各数据操作项目名根据使用什么数据库进行分类，然后以DB为结尾，具体命名规则是：{产品线英文名全称}.{子系统英文名全称+应用名}.{使用什么数据库}DB，如上图的Trip.Seller.MSSQLDB。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、如果涉及到多个数据库访问的，那么数据操作项目下的类文件需要按数据库名称（以DB为结尾）创建文件夹分开，如上图的TripOrderDB文件夹。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;3、建议在应用中使用SQL语句，不使用存储过程。在数据库中不新增存储过程，但旧的存储过程可以继续使用和修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;4、分页建议使用数据库（如SQLServer）的最新特性进行分页，并将每个分页SQL直接写到应用中。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid37&quot; class=&quot;font-size-4 gutter-author-3423802 heading-1 locate lineguid-AwzWhLWSSfhdBy3Q&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b font-size-6&quot;&gt;3.4、实体类项目&lt;span class=&quot;author-3423802 b font-size-4&quot;&gt;规范&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid38&quot; class=&quot;gutter-author-3423802 list-div heading-1 locate lineguid-smsiCgcpp6Gg6Jv2&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;
&lt;h3&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;&lt;span&gt;数据传输对象&lt;/span&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;DTO&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;&lt;span&gt;规范&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid39&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-m8TGevpWbw4DjfHk&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-3 upload-image img-a9RxZW4fjDfWb2DR image-width-275 image-height-306&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/CsPh1kBAD8sTAp0X/%E5%9B%BE8_%E5%AE%9E%E4%BD%93%E7%B1%BB%E9%A1%B9%E7%9B%AE%E4%B9%8BDTO%E8%A7%84%E8%8C%83.png!thumbnail&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;gutter-author-3423802 locate lineguid-UK0SKE9sQcqMM3vk&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131225027906-930059743.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;1、DTO项目命名规则：{产品线英文名全称}.{子系统英文名全称+应用名}.DTO，如上图的Trip.Order.DTO&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;2、请求参数DTO实体类、响应DTO实体类存放规范以及其命名规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;      a、请求参数DTO实体类放在Request文件夹下，且命名规则为：以Request结尾，如上图的SearchOrderRequest.cs。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;       b、响应DTO实体类放在Response文件夹下，且命名规则为：以Response结尾，如上图的SearchOrderResponse.cs。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;       c、如果请求参数DTO实体类或响应DTO实体类的属性中有对象或枚举，那么这些对象所属的类、枚举放在DTO项目的Common文件夹下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;3、如果请求参数DTO实体类、响应DTO实体类有基类要继承，那么建议为基类取名为RequestBase.cs、ResponseBase.cs。且这些基类直接放在DTO项目的Common文件夹下。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid47&quot; class=&quot;gutter-author-3423802 list-div heading-1 locate lineguid-8cWH6bsZXcUXCved&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;
&lt;h3&gt;&lt;span class=&quot;author-3423802&quot;&gt;视图对象VO规范&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid48&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-Ha9x6hdFURNrPbko&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224045437-1180834418.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、VO项目命名规则：{产品线英文名全称}.{子系统英文名全称+应用名}.ViewModel，如上图的Trip.Seller.ViewModel。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、各VO实体类，我们用Controller名作为文件夹名进行分开，如上图的Order文件夹。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;3、VO实体类名的命名建议：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;     a、请求参数VO实体类以Input/Form/Query结尾，如上图的SearchOrderInput.cs。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;     b、响应VO实体类以Output/List/Result结尾，如上图的SearchOrderOutput.cs。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid55&quot; class=&quot;font-size-4 gutter-author-3423802 list-div heading-1 locate lineguid-BRtEc8C8lVNwX5Ia&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;
&lt;h3&gt;&lt;span class=&quot;author-3423802&quot;&gt;业务对象BO规范（可选）&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;BO实体类名以Model&lt;span class=&quot;author-3423802&quot;&gt;为结尾：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid57&quot; class=&quot;font-size-4 gutter-author-3423802 line-left locate lineguid-JE3KCe33lOuwq06s&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224123796-1421783543.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;1、BO项目命名规则：{产品线英文名全称}.{子系统英文名全称+应用名}.BO，如上图的Trip.Order.BO;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;2、以Model结尾，如上图的OrderModel.cs；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;3、为了简化设计，BO项目为可选，可在DO项目里建文件夹。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid62&quot; class=&quot;gutter-author-3423802 list-div heading-1 locate lineguid-4u5df5Hk4udw6Uxo&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ul class=&quot;list-bullet1&quot;&gt;&lt;li&gt;
&lt;h3&gt;&lt;span class=&quot;author-3423802&quot;&gt;数据对象DO规范（可选）&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid63&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-9ZfG5d8G8OnxtGUf&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224145125-368030097.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、DO项目命名规则：{产品线英文名全称}.{子系统英文名全称+应用名}.Entity，如上图的Trip.Seller.Entity；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、如果涉及到多个数据库访问的，那么需要按数据库名称（以DB为结尾）创建文件夹分开，如上图的TripOrderDB文件夹；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;3、表名+Entity结尾，如上图的OrderEntity.cs；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;4、DO是数据表对象，供&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;单表&lt;span class=&quot;author-3423802&quot;&gt;CURD操作。对于多表查询请求对象和返回对象，可&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;定义新对象或&lt;span class=&quot;author-3423802&quot;&gt;使用现有对象（DTO/BO）来完成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid69&quot; class=&quot;font-color-12 font-size-3 gutter-author-3423802 heading-1 locate lineguid-NTfjkqxZGatlkBU1&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;3.5、数据库连接配置规范&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid70&quot; class=&quot;gutter-author-3423802 line-center locate lineguid-x117VI52Zq6vWQn0&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224235796-641906963.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、数据库连接的配置必须读写分离。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、数据库连接字符串建议加密处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;3、数据库连接配置名的命名规则：{以DB为结尾的数据库名称}_读写类型，如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;TripOrderDB_SELECT、TripOrderDB_INSERT。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid76&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-Th8nuC0Wm1dFXrCg&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-6&quot;&gt;&lt;span&gt;3.6、配置文件方面的规范&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid77&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-vfsgHTNoZw5L2FMj&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224307328-1815702971.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div class=&quot;gutter-author-3423802 line-left locate lineguid-vfsgHTNoZw5L2FMj&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224318421-657930216.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;1、所有配置文件（除Web.config文件外）都必须放到Config文件夹下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;所有配置文件（除Web.config&lt;span class=&quot;author-3423802&quot;&gt;文件外）按不同环境区分开，具体命名规则是：{功能模块英文名}.{环境英文简称名}.config，其中本地环境的英文简称名是Dev，测试环境的英文简称名是Test，正式环境的英文简称名是Prod，如上图的AppSetting.Dev.config。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;3、保持Web.config&lt;span class=&quot;author-3423802&quot;&gt;配置文件的干净，只留环境设置节点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid83&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-RVo7J9KCw2LfGSfv&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 b font-size-6&quot;&gt;3.7、静态资源文件方面的规范&lt;/span&gt;&lt;/h3&gt;
&lt;div id=&quot;magicdomid84&quot; class=&quot;gutter-author-3423802 line-left locate lineguid-9v8kUH0xwpo2p6ti&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1099513/201801/1099513-20180131224333828-321333919.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;规范说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;1、公共的静态资源文件（css、js、image等）放在另外的静态站点中，统一由前端进行开发和维护。一般，css文件放在css文件夹下，js文件放在js文件夹下，image图片文件放在img文件夹下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802&quot;&gt;2、与某项业务有关的js文件可以放到各自业务项目的表现层PresentationLayer下，以方便开发人员调试，js文件可放在项目的js文件夹下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;3、静态资源文件必须使用版本号管理，以防更新后由于客户端浏览器缓存而导致站点使用的依然是旧版本的静态资源文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;gutter-author-3423802 locate lineguid-ngsPIZIsDlllibMY&quot; data-author-name=&quot;dotnet-arch-system&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/js/order.js?v=@AppSetting.StaticFileVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;四、写在最后&lt;/span&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;h3 id=&quot;magicdomid91&quot; class=&quot;font-size-7 gutter-author-3423802 heading-1 locate lineguid-kotVnOpVyzxvRIRQ&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-4&quot;&gt;4.1、问题回答&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;问：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;服务的调用代码应该放到哪一层呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;A表现层、B业务逻辑层 、C数据层、D公共层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;我们的规范是统一放到数据资源访问层即C。上层提供服务，下层调用服务，中间处理业务逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;问：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;如何组织好VO(View Object视图对象)、BO(Business Object业务对象)、DO(Data Object数据对象)、DTO(Data Transfer Object数据传输对象)呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;通常有两种做法，限定访问范围和不限定&lt;span class=&quot;author-3423802 font-size-3&quot;&gt;访问&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;范围，实际项目中可根据需要选择、折中或裁剪。我们使用后者，将EntityLayer作为通用对象放到左侧，具体可参考实体层规约：“DO是数据表对象，不是数据访问层对象，不是只能给数据访问层使用；DTO是网络传输对象，不是表现层对象，不是只能给表现层使用；BO是内存计算逻辑对象，不是业务逻辑层对象，不是只能给业务逻辑层使用 。如果仅限定在本层访问，则导致单个应用内大量没有价值的对象转换。以用户为中心来设计实体类，可以减少无价值重复对象和无用转换。”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12 font-size-3&quot;&gt;&lt;span&gt;&lt;span&gt;问：&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;应用分层范例代码的编写需要注意些什么？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;author-3423802 b font-color-12&quot;&gt;&lt;span&gt;答：&lt;/span&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;应用分层范例的代码要想写好，非常不容易，很容易引起&lt;span class=&quot;author-3423802&quot;&gt;争议，很难让所有人满意。我们&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;在具体实践时遵循以下几点：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;magicdomid101&quot; class=&quot;list-start-number1 font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-MOxnuFneYLdA4YGm&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;应用分层范例的主要价值是明确层的职责和交互，每个层的职责是什么，哪些要干，哪些不要干，以及层与层之间依赖和交互；&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid102&quot; class=&quot;font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-oxWbDt5BocWwdBjq&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;私人定制：减少通用帮助类的编写，如果每一个应用中有大量相同的帮助类，这在架构层面上是有问题。在我们的几百个线上应用中，尽管减少通用的代码，包括分页帮助类、数据库帮助类、缓存帮助类、MQ帮助类、日志帮助类、AOP帮助类、线程帮助类。业务应用的重点是为业务服务，每一个应用都是特别的，都需要私人定制，极少有通用的代码，如果有，那么应该由框架或组件专门解决；&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid103&quot; class=&quot;font-color-12 font-size-3 gutter-author-3423802 list-div locate lineguid-I0zRdSo99pJgNrRI&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;3&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802 font-color-12 font-size-3&quot;&gt;少即是多：应用的场景多，参考人员多，每个人想法不同，牵涉的时间长，所以尽量只做大家都认同的规范、正确的事情，要自底向上、要减少有争议的代码范例，否则一个错误将会放大百倍、一个有争议的规范将会很难推行。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid104&quot; class=&quot;font-color-12 gutter-author-3423802 list-div locate lineguid-OqOPX8QTG17Nfhsx&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;4&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt;追求简单：代码编写可分为三个层次，简单、复杂、简单。第一简单是不知道的简单，第二个复杂是知道后的复杂，第三个简单是知道后有取舍的简单。范例代码要追求简单，既可轻松扩展支持复杂场景，又要简单到初级程序员也能操作。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;magicdomid105&quot; class=&quot;font-color-12 gutter-author-3423802 list-div locate lineguid-nsO5rwwWsvfLQTwG lineguid-wVUlRoBWZqb1zMCs&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;
&lt;ol class=&quot;list-number1&quot; start=&quot;5&quot;&gt;&lt;li&gt;&lt;span class=&quot;author-3423802&quot;&gt; 内聚大于解耦：内聚是什么，内聚是部门内有共同的目标，然后大家紧密合作。解耦是什么，解耦是部门间各自职责明确，然后减少不必要的连接。一个应用如同一个部门，应有一个共同的目标和职责，然后大家紧密合作。换句话说，应用内部应减少不必要契约接口（如同公司间才签约合同），减少不必要的依赖注入实现，减少不必要且代价过大的解耦。一切以简单实用为主，以应用价值输出、应用的目标（接口或界面）为导向。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;h3 id=&quot;magicdomid106&quot; class=&quot;gutter-author-3423802 heading-1 locate lineguid-PYASinuDFGblFuuw&quot; data-author-name=&quot;dotnet-arch-system&quot;&gt;&lt;span class=&quot;author-3423802 font-size-7&quot;&gt;&lt;span&gt;4.2、Demo下载&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;



</description>
<pubDate>Wed, 31 Jan 2018 14:45:00 +0000</pubDate>
<dc:creator>arch-system</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotnet-arch-system/p/8395207.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——29. 优先考虑泛型 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8394876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8394876.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参数化声明并使用JDK提供的泛型类型和方法通常不会太困难。 但编写自己的泛型类型有点困难，但值得努力学习。&lt;/p&gt;
&lt;p&gt;考虑条目 7中的简单堆栈实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Object-based collection - a prime candidate for generics
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        Object result = elements[--size];
        elements[size] = null; // Eliminate obsolete reference
        return result;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类应该已经被参数化了，但是由于事实并非如此，我们可以对它进行泛型化。 换句话说，我们可以参数化它，而不会损害原始非参数化版本的客户端。 就目前而言，客户端必须强制转换从堆栈中弹出的对象，而这些强制转换可能会在运行时失败。 泛型化类的第一步是在其声明中添加一个或多个类型参数。 在这种情况下，有一个类型参数，表示堆栈的元素类型，这个类型参数的常规名称是&lt;code&gt;E&lt;/code&gt;（条目 68）。&lt;/p&gt;
&lt;p&gt;下一步是用相应的类型参数替换所有使用的Object类型，然后尝试编译生成的程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Initial attempt to generify Stack - won't compile!
public class Stack&amp;lt;E&amp;gt; {
    private E[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new E[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(E e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public E pop() {
        if (size == 0)
            throw new EmptyStackException();
        E result = elements[--size];
        elements[size] = null; // Eliminate obsolete reference
        return result;
    }
    ... // no changes in isEmpty or ensureCapacity
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你通常会得到至少一个错误或警告，这个类也不例外。 幸运的是，这个类只产生一个错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack.java:8: generic array creation
        elements = new E[DEFAULT_INITIAL_CAPACITY];
                   ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如条目 28所述，你不能创建一个不可具体化类型的数组，例如类型&lt;code&gt;E&lt;/code&gt;。每当编写一个由数组支持的泛型时，就会出现此问题。 有两种合理的方法来解决它。 第一种解决方案直接规避了对泛型数组创建的禁用：创建一个Object数组并将其转换为泛型数组类型。 现在没有了错误，编译器会发出警告。 这种用法是合法的，但不是（一般）类型安全的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack.java:8: warning: [unchecked] unchecked cast
found: Object[], required: E[]
        elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
                       ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译器可能无法证明你的程序是类型安全的，但你可以。 你必须说服自己，不加限制的类型强制转换不会损害程序的类型安全。 有问题的数组（元素）保存在一个私有属性中，永远不会返回给客户端或传递给任何其他方法。 保存在数组中的唯一元素是那些传递给&lt;code&gt;push&lt;/code&gt;方法的元素，它们是&lt;code&gt;E&lt;/code&gt;类型的，所以未经检查的强制转换不会造成任何伤害。&lt;/p&gt;
&lt;p&gt;一旦证明未经检查的强制转换是安全的，请尽可能缩小范围（条目 27）。 在这种情况下，构造方法只包含未经检查的数组创建，所以在整个构造方法中抑制警告是合适的。 通过添加一个注解来执行此操作，Stack可以干净地编译，并且可以在没有显式强制转换或担心ClassCastException异常的情况下使用它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// The elements array will contain only E instances from push(E).
// This is sufficient to ensure type safety, but the runtime
// type of the array won't be E[]; it will always be Object[]!
@SuppressWarnings(&quot;unchecked&quot;)
public Stack() {
    elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消除Stack中的泛型数组创建错误的第二种方法是将属性元素的类型从&lt;code&gt;E []&lt;/code&gt;更改为&lt;code&gt;Object []&lt;/code&gt;。 如果这样做，会得到一个不同的错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack.java:19: incompatible types
found: Object, required: E
        E result = elements[--size];
                           ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过将从数组中检索到的元素转换为&lt;code&gt;E&lt;/code&gt;来将此错误更改为警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack.java:19: warning: [unchecked] unchecked cast
found: Object, required: E
        E result = (E) elements[--size];
                               ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为E是不可具体化的类型，编译器无法在运行时检查强制转换。 再一次，你可以很容易地向自己证明，不加限制的转换是安全的，所以可以适当地抑制警告。 根据条目 27的建议，我们只在包含未经检查的强制转换的分配上抑制警告，而不是在整个&lt;code&gt;pop&lt;/code&gt;方法上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Appropriate suppression of unchecked warning
public E pop() {
    if (size == 0)
        throw new EmptyStackException();

    // push requires elements to be of type E, so cast is correct
    @SuppressWarnings(&quot;unchecked&quot;) E result =
        (E) elements[--size];

    elements[size] = null; // Eliminate obsolete reference
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种消除泛型数组创建的技术都有其追随者。 第一个更可读：数组被声明为&lt;code&gt;E []&lt;/code&gt;类型，清楚地表明它只包含E实例。 它也更简洁：在一个典型的泛型类中，你从代码中的许多点读取数组; 第一种技术只需要一次转换（创建数组的地方），而第二种技术每次读取数组元素都需要单独转换。 因此，第一种技术是优选的并且在实践中更常用。 但是，它确实会造成堆污染（heap pollution）（条目 32）：数组的运行时类型与编译时类型不匹配（除非E碰巧是Object）。 这使得一些程序员非常不安，他们选择了第二种技术，尽管在这种情况下堆的污染是无害的。&lt;/p&gt;
&lt;p&gt;下面的程序演示了泛型Stack类的使用。 该程序以相反的顺序打印其命令行参数，并将其转换为大写。 对从堆栈弹出的元素调用String的&lt;code&gt;toUpperCase&lt;/code&gt;方法不需要显式强制转换，而自动生成的强制转换将保证成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Little program to exercise our generic Stack
public static void main(String[] args) {
    Stack&amp;lt;String&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
    for (String arg : args)
        stack.push(arg);
    while (!stack.isEmpty())
        System.out.println(stack.pop().toUpperCase());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子似乎与条目 28相矛盾，条目 28中鼓励使用列表优先于数组。 在泛型类型中使用列表并不总是可行或可取的。 Java本身生来并不支持列表，所以一些泛型类型（如ArrayList）必须在数组上实现。 其他的泛型类型，比如HashMap，是为了提高性能而实现的。&lt;/p&gt;
&lt;p&gt;绝大多数泛型类型就像我们的Stack示例一样，它们的类型参数没有限制：可以创建一个&lt;code&gt;Stack &amp;lt;Object&amp;gt;&lt;/code&gt;，&lt;code&gt;Stack &amp;lt;int []&amp;gt;&lt;/code&gt;，&lt;code&gt;Stack &amp;lt;List &amp;lt;String &amp;gt;&amp;gt;&lt;/code&gt;或者其他任何对象的Stack引用类型。 请注意，不能创建基本类型的堆栈：尝试创建&lt;code&gt;Stack&amp;lt;int&amp;gt;&lt;/code&gt;或&lt;code&gt;Stack&amp;lt;double&amp;gt;&lt;/code&gt;将导致编译时错误。 这是Java泛型类型系统的一个基本限制。 可以使用基本类型的包装类（条目 61）来解决这个限制。&lt;/p&gt;
&lt;p&gt;有一些泛型类型限制了它们类型参数的允许值。 例如，考虑&lt;code&gt;java.util.concurrent.DelayQueue&lt;/code&gt;，它的声明如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class DelayQueue&amp;lt;E extends Delayed&amp;gt; implements BlockingQueue&amp;lt;E&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类型参数列表（&lt;code&gt;&amp;lt;E extends Delayed&amp;gt;&lt;/code&gt;）要求实际的类型参数&lt;code&gt;E&lt;/code&gt;是&lt;code&gt;java.util.concurrent.Delayed&lt;/code&gt;的子类型。 这使得&lt;code&gt;DelayQueue&lt;/code&gt;实现及其客户端可以利用&lt;code&gt;DelayQueue&lt;/code&gt;元素上的&lt;code&gt;Delayed&lt;/code&gt;方法，而不需要显式的转换或ClassCastException异常的风险。 类型参数E被称为限定类型参数。 请注意，子类型关系被定义为每个类型都是自己的子类型[JLS，4.10]，因此创建&lt;code&gt;DelayQueue &amp;lt;Delayed&amp;gt;&lt;/code&gt;是合法的。&lt;/p&gt;
&lt;p&gt;总之，泛型类型比需要在客户端代码中强制转换的类型更安全，更易于使用。 当你设计新的类型时，确保它们可以在没有这种强制转换的情况下使用。 这通常意味着使类型泛型化。 如果你有任何现有的类型，应该是泛型的但实际上却不是，那么把它们泛型化。 这使这些类型的新用户的使用更容易，而不会破坏现有的客户端（条目 26）。&lt;/p&gt;
</description>
<pubDate>Wed, 31 Jan 2018 12:55:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8394876.html</dc:identifier>
</item>
<item>
<title>《JavaScript权威指南》读书笔记——JavaScript核心 - 王磊的博客</title>
<link>http://www.cnblogs.com/vipstone/p/8371824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipstone/p/8371824.html</guid>
<description>&lt;p&gt;&lt;span&gt;这本由David Flanagan著作，并由淘宝前端团队译的《JavaScript权威指南》，也就是我们俗称的“犀牛书”，算是JS界公认的“圣经”了。本书较厚（有1004页），读起来颇费功夫，但作为JavaScript（下文简称：JS）相关从业者，我还是鼎力推荐，一定要读完这本经久不息，好评如潮的JS“圣经”（如果您有耐心的读完，觉得还不错的，博客最后附有购买本书的优惠券，可自行领取）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说完本书重要性，下面重点介绍一下本书作者写书的逻辑性，简单来说本书分为四部分，第一部分：JS核心；第二部分：客户端JS；第三部分：JS核心参考和第一部分相呼应，是JS核心的重点归纳和讲解，也是第一部分的总结和升华部分，所以建议看完第一部分之后可以直接去看第三部分；第四部分：客户端JS参考，和第三方的模式一样，也是第二部分的总结、提炼、讲解已经升华。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以整体来说其实本书可以分为2部分，第一部分：js的核心；第二部分：客户端js；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;js的核心讲的是js的最基础的逻辑、原理、方法、属性、以及使用；而客户端js和服务器端js，只是作为js语言的一种实践部分，是js语言的一种使用场景，然后在具体场景中一些细化的使用。而本文只是整理了第一部分：JS核心，结合我自己的理解，做一个总结和记录。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、JS的类型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照数据类型划分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原始类型：Number、String、Boolean、Null、Undefined、Symbol(ES6加入，它的实例唯一，且不可改变，不能使用关键“new”声明)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对象类型：Object&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;扩展：&lt;/strong&gt;普通的js对象是“命名值”的无序集合，js同样定义了一种特殊对象——数组（array），表示带编号的有序集合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ES6新出了键控集合：Set和Map,Set集合值唯一，不会重复；Map存储的为键值对。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JS还定义了另一种特殊对象——函数。如果函数用new来初始化一个新建对象，我们称为构造函数（constructor），每个构造函数定义一类对象，除了数组（array）类和函数（Function）类之外，还有日期（Date）类、正则（RegExp）类、错误（Error）类都是js的核心类。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、JS中的算术运算&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算术运算符除了+、-、*、/、%（求余运算符，求整数后的余数）、还有更复杂的运算通过定义Math对象的函数和常量来实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
Math.abs(-10);      　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 10：绝对值&lt;/span&gt;
Math.ceil(0.6);  　　   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 1.0：向上取整数&lt;/span&gt;
Math.floor(0.6);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 向下取整数&lt;/span&gt;
Math.round(0.6);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt;:1.0：四舍五入&lt;/span&gt;
Math.random();         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 0-1随机数&lt;/span&gt;
Math.max(1, 3, 5);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 返回最高值&lt;/span&gt;
Math.min(1, -3, 50);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 返回最低值&lt;/span&gt;
Math.pow(2, 3);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 8：2的3次方&lt;/span&gt;
Math.PI;         　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; π：圆周率&lt;/span&gt;
Math.sin(3);           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 3的正弦值&lt;/span&gt;
Math.sqrt(30);      　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 平方根&lt;/span&gt;
Math.tan(100);      　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 正切&lt;/span&gt;
Math.acos(10);      　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 反余弦值&lt;/span&gt;
Math.cos(100);      　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 余弦值&lt;/span&gt;
Math.exp(100);      　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; e的100次幂&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math&quot; target=&quot;_blank&quot;&gt;点击访问&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math&quot; target=&quot;_blank&quot;&gt;更多&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、string的slice用法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;string的slice()用法，提取字符串的一部分，返回一个新字符，不改变原来字符串（和array.slice用法一致）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; str1 = &quot;hello world&quot;&lt;span&gt;;
str1.slice(&lt;/span&gt;1, 4);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;ell&quot;：截取下标1到下标4，不包含最后一位&lt;/span&gt;
str1.slice(1);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;ello world&quot;：截取下标1以后的所有字符&lt;/span&gt;
str1.slice(-3); 　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;rld&quot;：截取后三位&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;点击访问更多String类的方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、JS中的“假值”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;undefined、null、0、-0、&quot;&quot;、NaN 这6个可以转换成false的值，称作“假值”。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; exp1 =&lt;span&gt; undefined;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (exp1) {
    console.log(&lt;/span&gt;&quot;真&quot;&lt;span&gt;);
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    console.log(&lt;/span&gt;&quot;假&quot;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:假&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、数字转换的方法（科学技术或四舍五入）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Number转换成字符串的场景提供了三种方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;toFixed() =&amp;gt; 根据小数点后指定位数将数字转化成字符串，会进行四舍五入；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;toExponential() =&amp;gt; 使用指数计数法将数字转换为字符串；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;toPrecision() =&amp;gt; 根据指定的有效字位数将数字转换成字符串；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; n = 123456.78&lt;span&gt;;
n.toFixed(&lt;/span&gt;0);  　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:123457&lt;/span&gt;
n.toFixed(1);  　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ouput:123456.8&lt;/span&gt;
n.toFixed(5);  　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:123456.78000&lt;/span&gt;&lt;span&gt;
n.toExponential(&lt;/span&gt;1);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:1.2e+5&lt;/span&gt;&lt;span&gt;
n.toPrecision(&lt;/span&gt;4);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:1.2346e+5&lt;/span&gt;
n.toPrecision(7);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:123456.8&lt;/span&gt;
n.toPrecision(10);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:123456.7800&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六、parseInt()的“高级”玩法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;parseInt()可以接收第二个可选参数，这个参数指定了数字转换的基数，有效的取值范围是2-36.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
parseInt(&quot;11&quot;, 5);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6 =&amp;gt; 1*5+1&lt;/span&gt;
parseInt(&quot;ff&quot;, 16);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;255 =&amp;gt; 15*16+15&lt;/span&gt;
parseInt(&quot;077&quot;, 10);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;77 =&amp;gt; 70*10+7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;七、全局变量和&lt;/strong&gt;&quot;&lt;/span&gt;全局属性&quot;&lt;span&gt;的delete&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;js声明变量使用var和不用var的区别，大部分我们使用的时候都是一样的，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; str1 = &quot;hello&quot;&lt;span&gt;;
str2 &lt;/span&gt;= &quot;world!&quot;&lt;span&gt;;
console.log(&lt;/span&gt;&quot;%s %s&quot;&lt;span&gt;, str1, str2);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:hello world!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;而在使用delete属性时，使用var的变量是不允许删除的，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; str1 = &quot;hello&quot;&lt;span&gt;;
str2 &lt;/span&gt;= &quot;world!&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.str3 = &quot;!!!&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt; str1;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;delete&lt;/span&gt; str2;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;delete&lt;/span&gt; str3;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;总结：使用var的变量，可以理解为全局变量，全局变量属性是不可编辑的，而不使用var的可以看做是声明了一个全局属性，等同于this.xxx=yyy，属性是可以编辑的，所以是可以delete的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;八、JS的局部变量提升和块级作用域&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来看代码执行的结果（也是一道经典的js面试题）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; scope = &quot;global&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f() {
    console.log(scope);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scope = &quot;local&quot;&lt;span&gt;;
    console.log(scope);
}
f();
console.log(scope);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;output: undefined、local、global&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这是什么原因造成的？为什么不是global/local/global呢？因为es5没有块级作用域，局部变量被提升到最前了声明了，js解析器的机制造成的，上面的代码类似于下面这段代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; scope = &quot;global&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scope; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只声明变量，变量前置&lt;/span&gt;
&lt;span&gt;    console.log(scope);
    scope &lt;/span&gt;= &quot;local&quot;&lt;span&gt;;
    console.log(scope);
}
f();
console.log(scope);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;output: undefined、local、global&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以通常来说，在作用域里面变量声明的代码要放在代码的最顶部，这是一个非常不错的编程习惯，也可以避免一些不必要的问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;九、特殊的Date类型转换&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我告诉你typeof(new Date()+1)和typeof(new Date-1)的值不同你信吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面来看具体代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; now = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; (now + 1);   　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:string&lt;/span&gt;
&lt;span&gt;typeof&lt;/span&gt; (now - 1);   　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:number&lt;/span&gt;
now == now.toString(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output:true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那上面的问题是怎么造成的，typeof(now+1)不应该是number类型吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;“+” 有两种含义，一个是字符串连接，一个是加法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;类型转换的时候，默认先调用valueOf，然后才调用toString，而Date类型除外，所以对于new Date()的时候优先，调用的是toString()，而“+”操作是把他当成了字符串连接而不是数字相加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;“-”的时候，只有减法的含义，也就是说优先调用valuleOf，所以结果为number类&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;十、js的继承机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;继承机制：js是通过原型链实现继承的。简单实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Animal(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = name || 'Animal'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sleep = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name + '正在睡觉！'&lt;span&gt;);
    }
}
Animal.prototype.eat &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (food) {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name + '正在吃：' +&lt;span&gt; food);
};

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Cat() {
}
Cat.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Animal();
Cat.prototype.name &lt;/span&gt;= 'cat'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cat = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat();
console.log(cat.name);
console.log(cat.eat(&lt;/span&gt;'fish'&lt;span&gt;));
console.log(cat.sleep());
console.log(cat &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt; Animal); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
console.log(cat &lt;span&gt;instanceof&lt;/span&gt; Cat); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;更多的可以查看阮一峰老师的：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html&quot; target=&quot;_blank&quot;&gt;Javascript继承机制的设计思想型&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;十一、Array的高级用法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.slice和splice区别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然都是截取数组然而slice和splice的区别很大，接下来具体来看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;先说slice&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;slice定义：方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;dates&quot;, &quot;fig&quot;&lt;span&gt;];
array.slice(&lt;/span&gt;1, 4);  　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;banana&quot;, &quot;cherry&quot;, &quot;dates&quot;]&lt;/span&gt;
array.slice(1);     　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;banana&quot;, &quot;cherry&quot;, &quot;dates&quot;, &quot;fig&quot;]&lt;/span&gt;
array.slice(-2);    　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;dates&quot;, &quot;fig&quot;]&lt;/span&gt;
console.log(array);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;dates&quot;, &quot;fig&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Array.prototype.slice(x,y); 第一位参数为截取开始下标，截取的时候包含此下标，第二位参数缺省参数，如果不填写，标识截取到数组的最后一位，如果填写了，标识截取到下标的位置，截取元素不包含最后一位，截取不改变原来数组。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;splice部分&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;splice定义：&lt;/span&gt;&lt;/span&gt;方法通过删除现有元素和/或添加新元素来更改一个数组的内容。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码1：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;22.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法通过删除现有元素和/或添加新元素来更改一个数组的内容。&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; array = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;dates&quot;, &quot;fig&quot;&lt;span&gt;];
array.splice(&lt;/span&gt;2, 2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从下标2开始截取，截取2个&lt;/span&gt;
console.log(array); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;apple&quot;, &quot;banana&quot;, &quot;fig&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码2：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;dates&quot;, &quot;fig&quot;&lt;span&gt;];
array.splice(&lt;/span&gt;2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从下标2开始截取，截取到最后&lt;/span&gt;
console.log(array); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;apple&quot;, &quot;banana&quot;] &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码3：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;dates&quot;, &quot;fig&quot;&lt;span&gt;];
array.splice(&lt;/span&gt;2, 2, &quot;plum&quot;, &quot;orange&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;截取下标2到后面2个元素替换成&quot;plum&quot;, &quot;orange&quot;&lt;/span&gt;
console.log(array); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;apple&quot;, &quot;banana&quot;, &quot;plum&quot;, &quot;orange&quot;, &quot;fig&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;小技巧：可以使用var newArray = array.splice();实现数组复制。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.length的另一种用法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;dates&quot;, &quot;fig&quot;&lt;span&gt;];
array.length &lt;/span&gt;= 3; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]&lt;/span&gt;
array.length = 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[] =&amp;gt; 删除所有元素&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.reduce()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义：方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array = [10, 5, 20, 15&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sum = array.reduce(&lt;span&gt;function&lt;/span&gt; (x, y) { &lt;span&gt;return&lt;/span&gt; x + y }, 0);    　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求和&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; product = array.reduce(&lt;span&gt;function&lt;/span&gt; (x, y) { &lt;span&gt;return&lt;/span&gt; x * y }, 0);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求积&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; max = array.reduce(&lt;span&gt;function&lt;/span&gt; (x, y) { &lt;span&gt;return&lt;/span&gt; (x &amp;gt; y) ? x : y }); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求最大值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.every()和some()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义：数组的逻辑判断，对每一个元素进行判断，返回true或者false.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;every()每一个元素都要满足条件才会返回true，some()其中一项满足条件即会为true.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fun(element, index, array) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; element &amp;gt; 10&lt;span&gt;;
}

[&lt;/span&gt;2, 5, 8, 1, 4].some(fun);  　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
[12, 5, 8, 1, 4].some(fun); 　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;span&gt;
[&lt;/span&gt;12, 5, 8, 1, 4].every(fun); 　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
[12, 15, 18, 11, 14].every(fun);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.map()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义：将调用数组的每一个元素传递给指定的函数，并返回一个新的数组，不会改变老数组。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array = [1, 4, 9, 16&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; map = array.map(x =&amp;gt; x * 2);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[2, 8, 18, 32]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.Arguments.callee&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义：当前正在执行的函数.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在匿名函数中使用Arguments.callee引用自身，以便实现递归。代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; fun = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (x) {
    console.log(x);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x &amp;lt; 1&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x + arguments.callee(x - 1&lt;span&gt;);
}

fun(&lt;/span&gt;3);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7 =&amp;gt; 3+2+1+1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;7.sort()排序规则的理解&lt;/span&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sort()是可以介绍一个匿名函数作为排序规则的，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array = [3, 9, 3, 12, 5, 8, 1, 4&lt;span&gt;];
array.sort(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; (a, b) { &lt;span&gt;return&lt;/span&gt; a - b; }); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1, 3, 3, 4, 5, 8, 9, 12]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;理解：a-b得到一个值，而这个正常的值将按照数字的正常规则进行排序，也就是 负数=&amp;gt;0=&amp;gt;正数，所以理解a-b不能单纯的理解他为一个boolean值，而是根据a-b给数组一个排序规则，如果需要倒叙的话就用b-a.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array&quot; target=&quot;_blank&quot;&gt;点击访问更多Array基础操作方法 &lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;十二、高阶函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;定义： 高阶函数就是操作函数的函数，它接受一个或多个作为参数，并返回一个新函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sum(x, y, f) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; f(x) +&lt;span&gt; f(y);
}

console.log(sum(&lt;/span&gt;-5, 6, Math.abs));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;十三、正则表达式字符&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[...] 　　 方块内任意字符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[^...] 　  非方块内任意字符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;\w 　　　　[a-zA-Z0-9]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;\W 　　　　[^a-zA-Z0-9]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;\d 　　　　[0-9]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;\D 　　　　[^0-9]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;点击访问更多&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;十四、解构赋值&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let [x, y] = [1, 2&lt;span&gt;];
[x, y] &lt;/span&gt;= [x + 1, y + 1&lt;span&gt;];
[x, y] &lt;/span&gt;=&lt;span&gt; [y, x];
console.log(x, y);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;十五、闭包&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“闭包”这个词刚开始开的时候就头皮发麻，感觉很“高大上”难以理解，其实掌握之后，发现也挺好用的，下面介绍一下我对于闭包的理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义：闭包就是可以访问一个函数局部（私有）变量的方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Cat = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = &quot;cat&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getAge = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }
}


&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cat = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat();
console.log(cat.name);      　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
console.log(cat.age);       　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
console.log(cat.getName());    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;
console.log(cat.getAge());     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上代码：利用闭包可以给用特权的方法访问私有属性，保证了私有变量不被修改和污染，当然根据实际需求可以设置通过方法修改私有属性也是可行的。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 31 Jan 2018 12:15:00 +0000</pubDate>
<dc:creator>王磊的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vipstone/p/8371824.html</dc:identifier>
</item>
<item>
<title>ZooKeeper、Eureka对比 - jieqing</title>
<link>http://www.cnblogs.com/jieqing/p/8394001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jieqing/p/8394001.html</guid>
<description>&lt;p&gt;刚开始看到Eureka这个单词的时候真心不会念，查了后发现他有一个好听的名字，来，大家一起念 [ jʊ'rikə ]&lt;/p&gt;

&lt;p&gt;Eureka本身是Netflix开源的一款提供服务注册和发现的产品，并且提供了相应的Java封装。在它的实现中，节点之间相互平等，部分注册中心的节点挂掉也不会对集群造成影响，即使集群只剩一个节点存活，也可以正常提供发现服务。哪怕是所有的服务注册节点都挂了，Eureka Clients（客户端）上也会缓存服务调用的信息。这就保证了我们微服务之间的互相调用足够健壮。&lt;/p&gt;
&lt;p&gt;Zookeeper主要为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。曾经是Hadoop项目中的一个子项目，用来控制集群中的数据，目前已升级为独立的顶级项目。很多场景下也用它作为Service发现服务解决方案。&lt;/p&gt;

&lt;p&gt;在分布式系统中有个著名的CAP定理（C-数据一致性；A-服务可用性；P-服务对网络分区故障的容错性，这三个特性在任何分布式系统中不能同时满足，最多同时满足两个）；&lt;/p&gt;
&lt;h2 id=&quot;zookeeper&quot;&gt;Zookeeper&lt;/h2&gt;
&lt;p&gt;Zookeeper是基于CP来设计的，即任何时刻对Zookeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务请求的可用性。从实际情况来分析，在使用Zookeeper获取服务列表时，如果zookeeper正在选主，或者Zookeeper集群中半数以上机器不可用，那么将无法获得数据。所以说，Zookeeper不能保证服务可用性。&lt;/p&gt;
&lt;p&gt;诚然，在大多数分布式环境中，尤其是涉及到数据存储的场景，数据一致性应该是首先被保证的，这也是zookeeper设计成CP的原因。但是对于服务发现场景来说，情况就不太一样了：针对同一个服务，即使注册中心的不同节点保存的服务提供者信息不尽相同，也并不会造成灾难性的后果。&lt;strong&gt;因为对于服务消费者来说，能消费才是最重要的——拿到可能不正确的服务实例信息后尝试消费一下，也好过因为无法获取实例信息而不去消费。&lt;/strong&gt;（尝试一下可以快速失败，之后可以更新配置并重试）所以，对于服务发现而言，可用性比数据一致性更加重要——AP胜过CP。而Spring Cloud Netflix在设计Eureka时遵守的就是AP原则。&lt;/p&gt;
&lt;h2 id=&quot;eureka&quot;&gt;Eureka&lt;/h2&gt;
&lt;p&gt;Eureka Server也可以运行多个实例来构建集群，解决单点问题，但不同于ZooKeeper的选举leader的过程，Eureka Server采用的是Peer to Peer对等通信。这是一种去中心化的架构，无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。&lt;/p&gt;
&lt;p&gt;如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。&lt;/p&gt;
&lt;p&gt;一个新的Eureka Server节点启动后，会首先尝试从邻近节点获取所有实例注册表信息，完成初始化。Eureka Server通过getEurekaServiceUrls()方法获取所有的节点，并且会通过心跳续约的方式定期更新。默认配置下，如果Eureka Server在一定时间内没有接收到某个服务实例的心跳，Eureka Server将会注销该实例（默认为90秒，通过eureka.instance.lease-expiration-duration-in-seconds配置）。当Eureka Server节点在短时间内丢失过多的心跳时（比如发生了网络分区故障），那么这个节点就会进入自我保护模式。&lt;/p&gt;
&lt;p&gt;什么是自我保护模式？默认配置下，如果Eureka Server每分钟收到心跳续约的数量低于一个阈值（instance的数量&lt;em&gt;(60/每个instance的心跳间隔秒数)&lt;/em&gt;自我保护系数），并且持续15分钟，就会触发自我保护。在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳数重新恢复到阈值以上时，该Eureka Server节点就会自动退出自我保护模式。它的设计哲学前面提到过，那就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。该模式可以通过eureka.server.enable-self-preservation = false来禁用，同时eureka.instance.lease-renewal-interval-in-seconds可以用来更改心跳间隔，eureka.server.renewal-percent-threshold可以用来修改自我保护系数（默认0.85）。&lt;/p&gt;

&lt;p&gt;ZooKeeper基于CP，不保证高可用，如果zookeeper正在选主，或者Zookeeper集群中半数以上机器不可用，那么将无法获得数据。Eureka基于AP，能保证高可用，即使所有机器都挂了，也能拿到本地缓存的数据。作为注册中心，其实配置是不经常变动的，只有发版和机器出故障时会变。对于不经常变动的配置来说，CP是不合适的，而AP在遇到问题时可以用牺牲一致性来保证可用性，既返回旧数据，缓存数据。&lt;/p&gt;
&lt;p&gt;所以理论上Eureka是更适合作注册中心。而现实环境中大部分项目可能会使用ZooKeeper，那是因为集群不够大，并且也比基本不会遇到用做注册中心的机器一半以上都挂了的情况。所以实际上也没什么大问题。&lt;/p&gt;
&lt;p&gt;参考&lt;br/&gt;&lt;a href=&quot;http://tech.lede.com/2017/03/15/rd/server/SpringCloud1/&quot; class=&quot;uri&quot;&gt;http://tech.lede.com/2017/03/15/rd/server/SpringCloud1/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 31 Jan 2018 11:21:00 +0000</pubDate>
<dc:creator>jieqing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jieqing/p/8394001.html</dc:identifier>
</item>
<item>
<title>使用“消息服务框架”（MSF）实现分布式事务的三阶段提交协议（电商创建订单的示例） - 深蓝医生</title>
<link>http://www.cnblogs.com/bluedoctor/p/8384948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bluedoctor/p/8384948.html</guid>
<description>&lt;p&gt;在上一篇 《&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/bluedoctor/p/8146604.html&quot;&gt;消息服务框架（MSF）应用实例之分布式事务三阶段提交协议的实现&lt;/a&gt;》中，我们分析了分布式事务的三阶段提交协议的原理，现在我们来看看如何使用消息服务框架（MSF）来具体实现并且看用它来实现的一些优势。&lt;/p&gt;
&lt;p&gt;首先，从Github克隆项目源码，地址：&lt;a href=&quot;https://github.com/bluedoctor/MSF-DistTransExample&quot; target=&quot;_blank&quot;&gt;https://github.com/bluedoctor/MSF-DistTransExample&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解决方案如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201801/114517-20180130145020953-656305827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到解决方案有4个项目：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DistTransClient：分布式事务示例的客户端，它调用“订单服务”，创建一个订单，服务会返回创建结果是成功还是失败；&lt;/li&gt;
&lt;li&gt;DistTransDto：包含商品，订单和订单详情的实体类型接口以及相关的接口实现；&lt;/li&gt;
&lt;li&gt;DistTransServices：包含订单服务，商品服务和分布式事务控制器服务；&lt;/li&gt;
&lt;li&gt;TistTransApp：本测试的宿主程序项目，主要用于安装消息服务框架的服务宿主程序，以及启动订单，商品和分布式事务控制器的服务进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;2.1，基本概念&lt;/h2&gt;
&lt;p&gt;下面先介绍本示例要解决的业务，并通过这个业务来分析分布式事务的执行过程。&lt;/p&gt;
&lt;p&gt;在本示例中，使用的是电商系统最常见的业务场景：下单业务，它的业务流程也概括起来比较简单：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创建订单：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生成订单基本信息；&lt;/li&gt;
&lt;li&gt;生成订单项目明细（已购商品清单）：
&lt;ol&gt;&lt;li&gt;检查库存是否足够&lt;/li&gt;
&lt;li&gt;扣减库存&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 当然，在具体的电商业务系统中，下单业务比较复杂，特别是对库存的扣减方式，但大体的业务流程就是这样的，我们今天的重点是研究这个下单过程在分布式环境下如何实现。&lt;/p&gt;
&lt;h2&gt;2.2，微服务架构&lt;/h2&gt;
&lt;p&gt;假设我们的电商平台使用微服务架构的，包含了用户服务，商品服务，订单服务和支付服务，这4个服务在下单业务中的功能分别如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;用户服务&lt;/strong&gt;：检查当前用户是否有效，查询用户的相关信息，比如用户姓名，联系电话等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;订单服务&lt;/strong&gt;：生成订单，包括结合用户服务的用户信息，生成订单基本信息；结合商品服务，生成订单项目明细；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;商品服务&lt;/strong&gt;：向订单服务返回商品的相关信息，并返回库存是否可用，如果可用就扣减库存；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支付服务&lt;/strong&gt;：由第三方提供，但参与创建订单的流程，用户下单后需要用户去第三方支付系统完成支付，然后支付服务回调订单服务，完成有效订单确认。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 下面是这4个服务在创建订单的业务流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201801/114517-20180131105925875-158439797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，支付服务是第三方提供的服务，需要用户在创建订单后跳转调用，所以本质上不是订单服务直接调用，订单服务需要提供一个支付完成的回调通知接口，完成有效订单的确认。 而用户服务作为服务调用的发起方，它会传递必要的信息给订单服务，因此，对于“创建订单”这个具体的业务功能，它涉及的需要同时进行操作的只有创建订单和扣减库存这两个子业务，并且要求这2个子业务操作具有原子性，即要么同时成功，要么同时失败撤销，所以这两个操作组成一个事务操作，在我们当前的场景中，它是一个分布式事务。&lt;/p&gt;
&lt;h2&gt;2.3，分布式事务中的微服务容器&lt;/h2&gt;
&lt;p&gt;在本例中，我们使用消息服务框架（MSF）来实现分布式事务，为了更加真实的模拟微服务架构，我们将创建订单相关的服务划分为3个独立的进程，这些进程就是MSF.Host服务容器，这里分为3个服务容器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;协调器服务容器&lt;/strong&gt;：运行分布式事务协调器服务；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;订单服务容器&lt;/strong&gt;：运行订单服务和分布式事务控制器组件；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;商品服务容器&lt;/strong&gt;：运行商品服务和分布式事务控制器组件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是这3个服务容器的进程调用关系图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201801/114517-20180131151149593-268291227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;下面来看创建订单的分布式事务处理过程，为简单起见，只讨论正常的流程，其中异常的流程，请参考原文对于3阶段提供分布式事务的具体原理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201801/114517-20180131141810968-1772048604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1，客户端调用订单服务的创建订单方法；（上图步骤1）&lt;/p&gt;
&lt;p&gt;2，订单服务实例化，接受一个订单号，用户号，要购买的商品清单3个参数来创建订单；（上图步骤1）&lt;/p&gt;
&lt;p&gt;3，创建订单的方法向分布式事务控制器进行本地事务注册，传入创建订单的事务方法（委托）；（上图步骤2）&lt;/p&gt;
&lt;p&gt;4，创建订单的事务方法远程调用商品服务，更新商品库存；（上图步骤3）&lt;/p&gt;
&lt;p&gt;5，商品服务的更新商品库存方法向分布式事务控制器进行本地事务注册，传入具体更新库存的事务方法（委托）；（上图步骤4）&lt;/p&gt;
&lt;p&gt;6，商品服务执行完成更新库存的方法，向订单服务返回必要的信息，准备好提交事务；（上图步骤5）&lt;/p&gt;
&lt;p&gt;7，订单服务收到商品服务的返回信息，构建好订单和订单明细，准备好提交事务；（上图步骤6）&lt;/p&gt;
&lt;p&gt;8，分布式事务控制器检测到注册的各事务资源服务器（商品服务和订单服务）都已经准备好提交事务，向它们发出提交指令；&lt;/p&gt;
&lt;p&gt;9，商品服务和订单服务收到提交指令，提交本地事务，事务资源服务方法执行完成；（上图步骤7，8）&lt;/p&gt;
&lt;p&gt;10，分布式事务控制器收到事务资源服务器的反馈，登记本次分布式事务执行完成；&lt;/p&gt;
&lt;p&gt;11，订单服务标记创建订单成功，向客户端返回信息。&lt;/p&gt;

&lt;h2&gt;4.1，分布式事务控制器&lt;/h2&gt;
&lt;p&gt;分布式事务控制器是提供给事务资源服务使用的组件，在本示例中是类 DTController，它提供了如下重要方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查并开启一个分布式事务控制器对象&lt;/li&gt;
&lt;li&gt;移除一个事务控制器&lt;/li&gt;
&lt;li&gt;累计事务资源服务器&lt;/li&gt;
&lt;li&gt;获取分布式事务的状态&lt;/li&gt;
&lt;li&gt;3阶段分布式事务请求函数&lt;/li&gt;
&lt;li&gt;提交事务的方法&lt;/li&gt;
&lt;li&gt;回滚事务的方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中“3阶段分布式事务请求函数”，是事务控制器对象重要的函数，它负责对“3阶段分布式事务”的各个阶段进行流程控制，其中每一阶段，都要和“分布式事务协调服务”进行通信，接受它的指令，完成本地事务资源的控制，比如是提交还是回滚事务资源。下面我们看看它主要的代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201801/114517-20180131152607015-393723295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 在上面的函数中，MSF的客户端服务访问代理类 Proxy 对象它请求的是“分布式事务协调服务”，即名字为“DTCService”的远程服务；Proxy的RequestService 方法的最后一个参数，表示服务调用过程中，服务端回调的客户端函数，在这个回调函数中，提供了3阶段分布式事务协议中的各种指令的响应处理，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CanCommit--询问本地事务是否可以提交；&lt;/li&gt;
&lt;li&gt;PreCommit--预提交指令；&lt;/li&gt;
&lt;li&gt;Abort--撤销事务的指令；&lt;/li&gt;
&lt;li&gt;DoCommit--提交事务的指令。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Proxy对象的RequestService 方法它是一个异步方法，所以调用它之后代码会立即向下执行，因此我们用 TaskCompletionSource 对象将异步方法的结果获取过程作为一个任务来处理，这样便可以阻塞异步方法的执行并等待执行完的结果，如果这个过程中发生了错误，就立即回滚事务，即下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                tcs.Task.Wait();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tcs.Task.Result;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                PrintLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSF DTC({0}) Task Error:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, transIdentity,ex.Message);
                TryRollback(dbHelper);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 4.2，分布式事务协调服务&lt;/h2&gt;
&lt;p&gt; 分布式事务控制器在执行本地事务方法的前后，需要有一个分布式事务协调服务来协调它的执行过程，这个协调过程包括以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（提供给控制器）调用指定标识的分布式事务，直到事务执行完成；&lt;/li&gt;
&lt;li&gt;管理系统的分布式事务阶段，向控制器推送（回调）系统的分布式事务状态；&lt;/li&gt;
&lt;li&gt;分布式事务协调服务需要运行在独立服务进程中，所以它可以协调多个分布式事务控制器的工作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是本服务的具体代码实现，比较简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 分布式事务协调器服务，基于3PC过程。
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DTCService:ServiceBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; TransactionResourceCount;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DistTrans3PCState CurrentDTCState;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private static System.Collections.Concurrent.ConcurrentBag&amp;lt;DistTransInfo&amp;gt; DTResourceList = new System.Collections.Concurrent.ConcurrentBag&amp;lt;DistTransInfo&amp;gt;();&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 参加指定标识的分布式事务，直到事务执行完成。一个分布式事务包含若干本地事务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;identity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;标识一个分布式事务&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AttendTransaction(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; identity)
        {
            DistTransInfo info &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DistTransInfo();
            info.ClientIdentity &lt;/span&gt;= &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CurrentContext.Request.ClientIdentity;
            info.CurrentDTCState &lt;/span&gt;=&lt;span&gt; DistTrans3PCState.CanCommit;
            info.LastStateTime &lt;/span&gt;=&lt;span&gt; DateTime.Now;
            info.TransIdentity &lt;/span&gt;=&lt;span&gt; identity;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DTResourceList.Add(info);&lt;/span&gt;
            DateTime dtcStart =&lt;span&gt; DateTime.Now;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取一个当前事务标识的协调器线程&lt;/span&gt;
            DTController controller =&lt;span&gt; DTController.CheckStartController(identity);

            CurrentDTCState &lt;/span&gt;=&lt;span&gt; DistTrans3PCState.CanCommit;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (CurrentDTCState !=&lt;span&gt; DistTrans3PCState.Completed)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取资源服务器的事务状态，资源服务器可能自身或者因为网络情况出错&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;SendDTCState(info, controller, identity))
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            SendDTCState(info, controller, identity);
            DTController.RemoveController(identity);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DTC Current Use time:{0}(s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,DateTime.Now.Subtract(dtcStart).TotalSeconds);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; SendDTCState(DistTransInfo info, DTController controller, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; identity)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; clientIdentity = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[{0}:{1}-{2}]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CurrentContext.Request.ClientIP, 
                &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CurrentContext.Request.ClientPort, 
                &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CurrentContext.Request.ClientIdentity);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DTC Service Callback {0} Message:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, clientIdentity, CurrentDTCState);
                info.CurrentDTCState &lt;/span&gt;= &lt;span&gt;base&lt;/span&gt;.CurrentContext.CallBackFunction&amp;lt;DistTrans3PCState, DistTrans3PCState&amp;gt;&lt;span&gt;(CurrentDTCState);
                info.LastStateTime &lt;/span&gt;=&lt;span&gt; DateTime.Now;
                CurrentDTCState &lt;/span&gt;=&lt;span&gt; controller.GetDTCState(info.CurrentDTCState);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DTC Service Callback {0}  Error:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, clientIdentity, ex.Message);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
        


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ProcessRequest(IServiceContext context)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.ProcessRequest(context);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在本服务中，通过 &lt;span data-mce-=&quot;&quot;&gt;base.CurrentContext.CallBackFunction&lt;/span&gt; 方法回调分布式控制器，将当前阶段系统的分布式状态告诉控制器。&lt;/p&gt;

&lt;h2&gt;5.1，订单服务&lt;/h2&gt;
&lt;p&gt;订单服务方法首先它要实例化一个分布式事务控制器对象，在控制器对象里面完成创建订单的事务操作，它会首先调用商品服务去更新相应的商品库存数并取得相关的商品信息，然后接着构造订单和订单明细，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成订单的服务方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;orderId&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;订单号&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;userId&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;用户号&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buyItems&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;购买的商品简要清单&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;订单是否创建成功&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CreateOrder(&lt;span&gt;int&lt;/span&gt; orderId,&lt;span&gt;int&lt;/span&gt; userId,IEnumerable&amp;lt;BuyProductDto&amp;gt;&lt;span&gt; buyItems)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在分布式事务的发起端，需要先定义分布式事务标识：&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; DT_Identity =&lt;span&gt; System.Guid.NewGuid().ToString();
            productProxy.RegisterData &lt;/span&gt;=&lt;span&gt; DT_Identity;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用3阶段提交的分布式事务，保存订单到数据库&lt;/span&gt;
            OrderDbContext context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderDbContext();

            DTController controller &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DTController(DT_Identity);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; controller.DistTrans3PCRequest&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt;(DTS_Proxy, 
                context.CurrentDataBase,
                db &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先请求商品服务，扣减库存，并获取商品的仓库信息&lt;/span&gt;
                    ServiceRequest request = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceRequest();
                    request.ServiceName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProductService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    request.MethodName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpdateProductOnhand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    request.Parameters &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] { DT_Identity, buyItems };
                    List&lt;/span&gt;&amp;lt;SellProductDto&amp;gt; sellProducts = productProxy.RequestServiceAsync&amp;lt;List&amp;lt;SellProductDto&amp;gt;&amp;gt;&lt;span&gt;(request).Result;

                    &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 构造订单明细和订单对象
                    &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;                    productProxy.Connect();
                    List&lt;/span&gt;&amp;lt;OrderItemEntity&amp;gt; orderItems = &lt;span&gt;new&lt;/span&gt; List&amp;lt;OrderItemEntity&amp;gt;&lt;span&gt;();
                    OrderEntity order &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderEntity()
                    {
                        ID &lt;/span&gt;=&lt;span&gt; orderId,
                        OwnerID &lt;/span&gt;=&lt;span&gt; userId,
                        OrderTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                        OrderName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Prudoct:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    };
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (BuyProductDto item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; buyItems)
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：在商品数据库上，前面更新商品，但还没有提交事务，下面这个查询直接使用的话会导致查询等待，因为SQLSERVER的事务隔离级别是这样的
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所以 GetProductInfo 的实现需要注意。
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ProductDto product = this.GetProductInfo(item.ProductId).Result;&lt;/span&gt;
                        ProductDto product = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetProductInfoSync(item.ProductId);

                        OrderItemEntity temp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderItemEntity()
                        {
                            OrderID &lt;/span&gt;=&lt;span&gt; orderId,
                            ProductID &lt;/span&gt;=&lt;span&gt; product.ID,
                            BuyNumber &lt;/span&gt;=&lt;span&gt; item.BuyNumber,
                            OnePrice &lt;/span&gt;=&lt;span&gt; product.Price,
                            ProductName &lt;/span&gt;=&lt;span&gt; product.ProductName
                        };
                        temp.StoreHouse &lt;/span&gt;= (&lt;span&gt;from&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; sellProducts &lt;span&gt;where&lt;/span&gt; i.ProductId == temp.ProductID &lt;span&gt;select&lt;/span&gt;&lt;span&gt; i.StoreHouse).FirstOrDefault();

                        orderItems.Add(temp);
                        order.OrderName &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; temp.ProductName;
                        order.AmountPrice &lt;/span&gt;+= temp.OnePrice *&lt;span&gt; temp.BuyNumber;
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭商品服务订阅者连接&lt;/span&gt;
&lt;span&gt;                    productProxy.Close();

                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存订单数据到数据库&lt;/span&gt;
                    context.Add&amp;lt;OrderEntity&amp;gt;&lt;span&gt;(order);
                    context.AddList&lt;/span&gt;&amp;lt;OrderItemEntity&amp;gt;&lt;span&gt;(orderItems);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意在上面的方法中，我们创建订单的代码并没有直接提交或者回滚事务，而是通过控制器的 DistTrans3PCRequest 方法传入了一个AdoHelper对象，由控制器来决定提交或者回滚事务。 其它相关代码请看Github上的源码。&lt;/p&gt;
&lt;h2&gt;5.2，商品服务&lt;/h2&gt;
&lt;p&gt;商品服务比较简单，这里只列出订单服务需要直接调用的 UpdateProductOnhand方法，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductService:ServiceBase
{
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其它代码略&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新商品库存，并返回商品售卖简要信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;transIdentity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;分布式事务标识&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buyItems&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;购买的商品精简信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;SellProductDto&amp;gt; UpdateProductOnhand(&lt;span&gt;string&lt;/span&gt; transIdentity, IEnumerable&amp;lt;BuyProductDto&amp;gt;&lt;span&gt; buyItems)
        {
            ProductDbContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProductDbContext();
            DTController controller &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DTController(transIdentity);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; controller.DistTrans3PCRequest&amp;lt;List&amp;lt;SellProductDto&amp;gt;&amp;gt;&lt;span&gt;(DTS_Proxy,
                context.CurrentDataBase,
                c &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; InnerUpdateProductOnhand(context,buyItems);
                });
           
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，商品服务的更新商品库存数的方法内部也实例化了一个分布式事务控制器对象，然后在它里面执行具体的本地事务操作。其它具体代码略。&lt;/p&gt;
&lt;p&gt;需要注意的是，订单服务在事务执行过程中，多次调用了商品服务的其它方法，这些方法会操作数据库，如果这些商品服务操作的表正好是更新商品库存的方法使用的表，此&lt;strong&gt;时如果两个方法操作的数据库连接不是同一个事务的连接，那么会导致死锁&lt;/strong&gt;。所以商品服务需要设置会话状态来正确存储和访问连接对象，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductService:ServiceBase
{
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其它代码略&lt;/span&gt;

        &lt;span&gt;private&lt;/span&gt; List&amp;lt;SellProductDto&amp;gt; InnerUpdateProductOnhand(ProductDbContext context, IEnumerable&amp;lt;BuyProductDto&amp;gt;&lt;span&gt; buyItems)
        {
            List&lt;/span&gt;&amp;lt;SellProductDto&amp;gt; result = &lt;span&gt;new&lt;/span&gt; List&amp;lt;SellProductDto&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (BuyProductDto item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; buyItems)
            {
                ProductEntity entity &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProductEntity()
                {
                    ID &lt;/span&gt;=&lt;span&gt; item.ProductId,
                    Onhand&lt;/span&gt;=&lt;span&gt; item.BuyNumber
                };
                OQL q &lt;/span&gt;=&lt;span&gt; OQL.From(entity)
                    .UpdateSelf(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, entity.Onhand)
                    .Where(cmp &lt;/span&gt;=&amp;gt; cmp.EqualValue(entity.ID) &amp;amp; cmp.Comparer(entity.Onhand, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, item.BuyNumber))
                    .END;


                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; context.ProductQuery.ExecuteOql(q);
                SellProductDto sell &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SellProductDto();
                sell.BuyNumber &lt;/span&gt;=&lt;span&gt; item.BuyNumber;
                sell.ProductId &lt;/span&gt;=&lt;span&gt; item.ProductId;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改库存成功，才能得到发货地&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    sell.StoreHouse &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetStoreHouse(item.ProductId);
                result.Add(sell);
            }
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;.CurrentContext.Session.Set&amp;lt;ProductDbContext&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DbContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, context);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----------1,-Session ID:{0}----------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CurrentContext.Session.SessionID);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ProcessRequest(IServiceContext context)
        {
            context.SessionRequired &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端（订单服务）将使用事务标识作为连接的 RegisterData，因此采用这种会话模式&lt;/span&gt;
            context.SessionModel =&lt;span&gt; SessionModel.RegisterData;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.ProcessRequest(context);
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5.3，客户端下单&lt;/h2&gt;
&lt;p&gt;前面我们讨论了分布式事务控制器，分布式事务协调服务，订单服务和商品服务的具体实现，现在，我们终于可以看看客户端如何调用订单服务来创建一个订单了，请看代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestCreateOrder(Proxy client)
        {
            List&lt;/span&gt;&amp;lt;BuyProductDto&amp;gt; buyProducts = &lt;span&gt;new&lt;/span&gt; List&amp;lt;BuyProductDto&amp;gt;&lt;span&gt;();
            buyProducts.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BuyProductDto() {  ProductId=&lt;span&gt;1&lt;/span&gt;, BuyNumber=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;});
            buyProducts.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BuyProductDto() { ProductId =&lt;span&gt;2&lt;/span&gt;, BuyNumber = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; });

            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; orderId = &lt;span&gt;2000&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; userId = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;

            ServiceRequest request &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceRequest();
            request.ServiceName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            request.MethodName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CreateOrder&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            request.Parameters &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] { orderId,userId, buyProducts };

            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; result=client.RequestServiceAsync&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt;(request).Result;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(result)
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建订单成功，订单号：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,orderId);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建订单失败，订单号：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, orderId);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的方法构造了一个准备购买的商品清单，这就是电商“购物车”的简化版本，另外为了简便起见，我们直接设定了一个订单号和用户号，用这种方式来调用创建订单的功能。&lt;/p&gt;
&lt;p&gt;由于我们的订单号固定的，所以我们的测试程序第一次会创建成功订单，而第二次就会失败，正好可以用它来观察系统的执行情况。&lt;/p&gt;

&lt;h2&gt;6.1，测试环境简介：&lt;/h2&gt;
&lt;p&gt;为了简化测试环境，所有服务实例都运行在一台PC机器上，包括数据。测试机器的性能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU:Inter i7-4790 4.00GHz;&lt;/li&gt;
&lt;li&gt;内存：16GB，可用内存：8.7GB&lt;/li&gt;
&lt;li&gt;测试开发环境：VS2017 社区版&lt;/li&gt;
&lt;li&gt;数据库：SqlServer 2008 R2&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;打开VS开发环境，按F5以调试模式编译运行，设置多启动项目：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DistTransClient&lt;/li&gt;
&lt;li&gt;TistTransApp&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试项目 TistTransApp下面的配置文件 PdfNetEF.MessageServiceHost.exe.config    配置内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d16370c5-372c-4eaa-bd7b-586731361808')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_d16370c5-372c-4eaa-bd7b-586731361808&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d16370c5-372c-4eaa-bd7b-586731361808&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d16370c5-372c-4eaa-bd7b-586731361808',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d16370c5-372c-4eaa-bd7b-586731361808&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appSettings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;IOCConfigFile&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;.\IOCConfig.xml&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;ServerIP&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;127.0.0.1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;ServerPort&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;12345&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;ProductUri&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;net.tcp://127.0.0.1:12306&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;OrderUri&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;net.tcp://127.0.0.1:12308&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;MSF_DTS_Uri 分布式事务控制器服务连接地址&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;MSF_DTS_Uri&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;net.tcp://127.0.0.1:12345&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 全局缓存配置
    GlobalCacheProvider=&quot;CacheServer&quot; 将使用分布式的缓存服务器，这时候需要配置 CacheConfigFile，其它值将使用本地的缓存
    CacheConfigFile ：缓存服务器的地址的配置文件，也就是本 ServiceHost 运行的另外一些实例
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;GlobalCacheProvider&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;CacheConfigFile&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;CacheServerCfg.xml&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 全局缓存配置结束 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;PDF.NET SQL 日志记录配置（for 4.0）开始
        记录执行的SQL语句，关闭此功能请将SaveCommandLog 设置为False，或者设置DataLogFile 为空；
        如果DataLogFile 的路径中包括~符号，表示SQL日志路径为当前Web应用程序的根目录；
        如果DataLogFile 不为空且为有效的路径，当系统执行SQL出现了错误，即使SaveCommandLog 设置为False，会且仅仅记录出错的这些SQL语句；
        如果DataLogFile 不为空且为有效的路径，且SaveCommandLog 设置为True，则会记录所有的SQL查询。
        在正式生产环境中，如果不需要调试系统，请将SaveCommandLog 设置为False 。
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;SaveCommandLog&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;DataLogFile&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;.\SqlLog.txt&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;LogExecutedTime 需要记录的时间，如果该值等于0会记录所有查询，否则只记录大于该时间的查询。单位毫秒。&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;LogExecutedTime&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;PDF.NET SQL 日志记录配置 结束&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;ClientSettingsProvider.ServiceUri&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appSettings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;connectionStrings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;SOD for SQL Server ,框架会自动创建需要的库  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;OrdersDb&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=.;Initial Catalog=OrdersDb;Integrated Security=True&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;SqlServer&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ProductsDb&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=.;Initial Catalog=ProductsDb;Integrated Security=True&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;SqlServer&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; SOD for SQL Server LocalDB  
      注意：请将下面的连接字符串，修改为你VS 里面打开的数据库文件的连接字符串 
    &amp;lt;add name=&quot;OrdersDb&quot; connectionString=&quot;Data Source=(LocalDB)\MSSQLLocalDB;AttachDbFilename=~\DataBase\OrdersDB_data.mdf;Integrated Security=True;Connect Timeout=30&quot; providerName=&quot;SqlServer&quot;/&amp;gt;
    &amp;lt;add name=&quot;ProductsDb&quot; connectionString=&quot;Data Source=(LocalDB)\MSSQLLocalDB;AttachDbFilename=~\DataBase\ProductsDB_data.mdf;Integrated Security=True;Connect Timeout=30&quot; providerName=&quot;SqlServer&quot;/&amp;gt;
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; MSSQLLocalDB 连接示例
    &amp;lt;add name=&quot;OrdersDb&quot; connectionString=&quot;Data Source=(LocalDB)\MSSQLLocalDB;AttachDbFilename=E:\Git\MSF-DistTransExample\Host\DataBase\OrdersDB_data.mdf;Integrated Security=True;Connect Timeout=30&quot; providerName=&quot;SqlServer&quot;/&amp;gt;
    &amp;lt;add name=&quot;ProductsDb&quot; connectionString=&quot;Data Source=(LocalDB)\MSSQLLocalDB;AttachDbFilename=E:\Git\MSF-DistTransExample\Host\DataBase\ProductsDB_data.mdf;Integrated Security=True;Connect Timeout=30&quot; providerName=&quot;SqlServer&quot;/&amp;gt;
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; SOD for Access 2007 ,2013,2016
   &amp;lt;add name=&quot;OrdersDb&quot; connectionString=&quot;Provider=Microsoft.ACE.OLEDB.12.0;Data Source=~\DataBase\OrdersDb.accdb;Persist Security Info=False;&quot; providerName=&quot;Access&quot;/&amp;gt;
    &amp;lt;add name=&quot;ProductsDb&quot; connectionString=&quot;Provider=Microsoft.ACE.OLEDB.12.0;Data Source=~\DataBase\Products.accdb;Persist Security Info=False;&quot; providerName=&quot;Access&quot;/&amp;gt;
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; SOD for Access 2000,2003
   &amp;lt;add name=&quot;OrdersDb&quot; connectionString=&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=~\DataBase\OrdersDb.mdb;Persist Security Info=False;&quot; providerName=&quot;Access&quot;/&amp;gt;
    &amp;lt;add name=&quot;ProductsDb&quot; connectionString=&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=~\DataBase\Products.mdb;Persist Security Info=False;&quot; providerName=&quot;Access&quot;/&amp;gt;
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; SOD for SQLite 
   &amp;lt;add name=&quot;OrdersDb&quot; connectionString=&quot;Data Source=DataBase\OrdersDb.db;&quot; providerName=&quot;PWMIS.DataProvider.Data.SQLite,PWMIS.SQLiteClient&quot;/&amp;gt;
    &amp;lt;add name=&quot;ProductsDb&quot; connectionString=&quot;Data Source=DataBase\Products.db;&quot; providerName=&quot;PWMIS.DataProvider.Data.SQLite,PWMIS.SQLiteClient&quot;/&amp;gt;
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;connectionStrings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;supportedRuntime &lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;=&quot;v4.0&quot;&lt;/span&gt;&lt;span&gt; sku&lt;/span&gt;&lt;span&gt;=&quot;.NETFramework,Version=v4.0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;system.web&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;membership &lt;/span&gt;&lt;span&gt;defaultProvider&lt;/span&gt;&lt;span&gt;=&quot;ClientAuthenticationMembershipProvider&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;providers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ClientAuthenticationMembershipProvider&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;System.Web.ClientServices.Providers.ClientFormsAuthenticationMembershipProvider, System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35&quot;&lt;/span&gt;&lt;span&gt; serviceUri&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;providers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;membership&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;roleManager &lt;/span&gt;&lt;span&gt;defaultProvider&lt;/span&gt;&lt;span&gt;=&quot;ClientRoleProvider&quot;&lt;/span&gt;&lt;span&gt; enabled&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;providers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ClientRoleProvider&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;System.Web.ClientServices.Providers.ClientRoleProvider, System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35&quot;&lt;/span&gt;&lt;span&gt; serviceUri&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; cacheTimeout&lt;/span&gt;&lt;span&gt;=&quot;86400&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;providers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;roleManager&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;system.web&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;配置文件中配置了多种数据库连接方式，根据你的情况具体选择。当前是SqlServer.&lt;/p&gt;
&lt;p&gt;然后，按照下图输入相关的信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201801/114517-20180131165634703-996330912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于我现在的测试环境是SQLSERVER数据库，所以不需要初始化数据库。选择启动事务协调器，测试程序会帮我们启动 协调器服务宿主进程，商品服务宿主进程和订单服务宿主进程。之后，我们在客户端控制台输入 12308，这是订单服务的端口号，接着客户端就会调用订单服务准备创建订单。&lt;/p&gt;
&lt;h2&gt;6.2，测试结果&lt;/h2&gt;
&lt;p&gt;下面是各种情况下的测试结果，分为订单创建成功和创建失败两种情况。注意我们在分析真正的测试数据之前，要先跑一次&lt;strong&gt;服务进行预热&lt;/strong&gt;，也就是先进行一次测试，取第二次以后的测试结果。&lt;/p&gt;
&lt;h3&gt;6.2.1，订单创建成功：&lt;/h3&gt;
&lt;p&gt;分布式协调服务：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[2018-01-31 17:13:45.807]订阅消息-- From: 127.0.0.1:53276
[2018-01-31 17:13:45.807]正在处理服务请求--From: 127.0.0.1:53276,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]Service://DTCService/AttendTransaction/System.String=1b975548-afac-4e7a-be6d-5821bce38ce7
DTC Service Callback [127.0.0.1:53276-WMI2114256838] Message:CanCommit
[2018-01-31 17:13:45.853]订阅消息-- From: 127.0.0.1:53278
[2018-01-31 17:13:45.854]正在处理服务请求--From: 127.0.0.1:53278,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]Service://DTCService/AttendTransaction/System.String=1b975548-afac-4e7a-be6d-5821bce38ce7
DTC Service Callback [127.0.0.1:53278-WMI2114256838] Message:CanCommit
DTC Service Callback [127.0.0.1:53276-WMI2114256838] Message:PreCommit
DTC Service Callback [127.0.0.1:53278-WMI2114256838] Message:PreCommit
DTC Service Callback [127.0.0.1:53278-WMI2114256838] Message:DoCommit
DTC Service Callback [127.0.0.1:53278-WMI2114256838] Message:Completed
DTC Current Use time:0.042516(s)
[2018-01-31 17:13:45.897]请求处理完毕(43.0236ms)--To: 127.0.0.1:53278,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]消息长度：4字节 -------
result:True
Reponse Message OK.
DTC Service Callback [127.0.0.1:53276-WMI2114256838] Message:DoCommit
[2018-01-31 17:13:45.898]取消订阅-- From: 127.0.0.1:53278
DTC Service Callback [127.0.0.1:53276-WMI2114256838] Message:Completed
DTC Current Use time:0.1009371(s)
[2018-01-31 17:13:45.909]请求处理完毕(101.9327ms)--To: 127.0.0.1:53276,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]消息长度：4字节 -------
result:True
Reponse Message OK.
[2018-01-31 17:13:45.912]取消订阅-- From: 127.0.0.1:53276
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;订单服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
[2018-01-31 17:13:45.798]订阅消息-- From: 127.0.0.1:53275
[2018-01-31 17:13:45.801]正在处理服务请求--From: 127.0.0.1:53275,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]Service://OrderService/CreateOrder/System.Int32=2000&amp;amp;System.Int32=100&amp;amp;System.Collections.Generic.List`1[[DistTransDto.BuyProductDto, DistTransDto, Version%Eqv;1.0.0.0, Culture%Eqv;neutral, PublicKeyToken%Eqv;null]]=[{&quot;ProductId&quot;:1,&quot;BuyNumber&quot;:3},{&quot;ProductI
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Resource at 17:13:45.809 receive DTC Controller state:CanCommit
[2018-01-31 17:13:45.879]请求处理完毕(77.9367ms)--To: 127.0.0.1:53275,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]消息长度：4字节 -------
result:True
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Resource at 17:13:45.879 receive DTC Controller state:PreCommit
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) 1PC,Child moniter task has started at time:17:13:45.879
Reponse Message OK.
[2018-01-31 17:13:45.888]取消订阅-- From: 127.0.0.1:53275
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) 2PC,Child moniter task has started at time:17:13:45.888
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) 1PC,Child moniter task find DistTrans3PCState has changed,Now is ACK_Yes_2PC,task break!
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Resource at 17:13:45.898 receive DTC Controller state:DoCommit
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Try Commit..
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Try Commit..OK
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Resource at 17:13:45.903 receive DTC Controller state:Completed
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) 3PC Request Completed,use time:0.1019383 seconds.
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) 2PC,Child moniter task find DistTrans3PCState has changed,Now is Completed,task break!
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Controller Process Reuslt:True,Receive time:17:13:45.913
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;商品服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
[2018-01-31 17:13:45.848]正在处理服务请求--From: 127.0.0.1:53277,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]Service://ProductService/UpdateProductOnhand/System.String=1b975548-afac-4e7a-be6d-5821bce38ce7&amp;amp;System.Collections.Generic.List`1[[DistTransDto.BuyProductDto, DistTransDto, Version%Eqv;1.0.0.0, Culture%Eqv;neutral, PublicKeyToken%Eqv;null]]=[{&quot;ProductId&quot;:1
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Resource at 17:13:45.855 receive DTC Controller state:CanCommit
----------1,-Session ID:1b975548-afac-4e7a-be6d-5821bce38ce7----------
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) 1PC,Child moniter task has started at time:17:13:45.856
[2018-01-31 17:13:45.856]请求处理完毕(8.011ms)--To: 127.0.0.1:53277,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]消息长度：97字节 -------
result:[{&quot;StoreHouse&quot;:&quot;广州&quot;,&quot;ProductId&quot;:1,&quot;BuyNumber&quot;:3},{&quot;StoreHouse&quot;:&quot;广州&quot;,&quot;ProductId&quot;:2,&quot;BuyNumber&quot;:1}]
Reponse Message OK.
[2018-01-31 17:13:45.857]取消订阅-- From: 127.0.0.1:53277
[2018-01-31 17:13:45.858]订阅消息-- From: 127.0.0.1:53277
[2018-01-31 17:13:45.867]正在处理服务请求--From: 127.0.0.1:53277,Identity:WMI2114256838
&amp;gt;&amp;gt;[RMID:0]Service://ProductService/GetProductInfo/System.Int32=1
---------2,--Session ID:1b975548-afac-4e7a-be6d-5821bce38ce7----------
[2018-01-31 17:13:45.868]请求处理完毕(1.0005ms)--To: 127.0.0.1:53277,Identity:WMI2114256838
&amp;gt;&amp;gt;[RMID:0]消息长度：53字节 -------
result:{&quot;ID&quot;:1,&quot;Onhand&quot;:88,&quot;Price&quot;:10.0,&quot;ProductName&quot;:&quot;商品0&quot;}
[2018-01-31 17:13:45.869]正在处理服务请求--From: 127.0.0.1:53277,Identity:WMI2114256838
&amp;gt;&amp;gt;[RMID:0]Service://ProductService/GetProductInfo/System.Int32=2
---------2,--Session ID:1b975548-afac-4e7a-be6d-5821bce38ce7----------
[2018-01-31 17:13:45.869]请求处理完毕(0.5005ms)--To: 127.0.0.1:53277,Identity:WMI2114256838
&amp;gt;&amp;gt;[RMID:0]消息长度：53字节 -------
result:{&quot;ID&quot;:2,&quot;Onhand&quot;:96,&quot;Price&quot;:11.0,&quot;ProductName&quot;:&quot;商品1&quot;}
[2018-01-31 17:13:45.870]取消订阅-- From: 127.0.0.1:53277
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Resource at 17:13:45.888 receive DTC Controller state:PreCommit
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) 2PC,Child moniter task has started at time:17:13:45.889
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Resource at 17:13:45.890 receive DTC Controller state:DoCommit
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Try Commit..
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Try Commit..OK
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Resource at 17:13:45.895 receive DTC Controller state:Completed
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) 3PC Request Completed,use time:0.0470229 seconds.
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) 1PC,Child moniter task find DistTrans3PCState has changed,Now is Completed,task break!
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) Controller Process Reuslt:True,Receive time:17:13:45.900
MSF DTC(1b975548-afac-4e7a-be6d-5821bce38ce7) 2PC,Child moniter task find DistTrans3PCState has changed,Now is Completed,task break!
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;性能总结：&lt;/p&gt;
&lt;p&gt; 订单创建成功的情况下，分布式协调器服务总共耗时 0.042516(s),订单服务耗时0.1019383秒，商品服务耗时0.0470229秒。&lt;/p&gt;
&lt;p&gt;总体上，执行一个创建订单的分布式事务，耗时在50毫秒以内。&lt;/p&gt;
&lt;h3&gt;6.2.2，订单创建失败：&lt;/h3&gt;
&lt;p&gt;分布式协调服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[2018-01-31 17:04:11.669]订阅消息-- From: 127.0.0.1:53201
[2018-01-31 17:04:11.670]正在处理服务请求--From: 127.0.0.1:53201,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]Service://DTCService/AttendTransaction/System.String=76d175cc-5d40-4d05-adfb-94158b5c2215
DTC Service Callback [127.0.0.1:53201-WMI2114256838] Message:CanCommit
[2018-01-31 17:04:11.679]订阅消息-- From: 127.0.0.1:53203
[2018-01-31 17:04:11.680]正在处理服务请求--From: 127.0.0.1:53203,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]Service://DTCService/AttendTransaction/System.String=76d175cc-5d40-4d05-adfb-94158b5c2215
DTC Service Callback [127.0.0.1:53203-WMI2114256838] Message:CanCommit
DTC Service Callback [127.0.0.1:53201-WMI2114256838] Message:Abort
DTC Service Callback [127.0.0.1:53201-WMI2114256838] Message:Completed
DTC Service Callback [127.0.0.1:53203-WMI2114256838] Message:Abort
DTC Current Use time:0.0434914(s)
[2018-01-31 17:04:11.715]请求处理完毕(45.0015ms)--To: 127.0.0.1:53201,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]消息长度：4字节 -------
result:True
Reponse Message OK.
DTC Service Callback [127.0.0.1:53203-WMI2114256838] Message:Completed
[2018-01-31 17:04:11.717]取消订阅-- From: 127.0.0.1:53201
DTC Current Use time:0.0400005(s)
[2018-01-31 17:04:11.724]请求处理完毕(44.4941ms)--To: 127.0.0.1:53203,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]消息长度：4字节 -------
result:True
Reponse Message OK.
[2018-01-31 17:04:11.731]取消订阅-- From: 127.0.0.1:53203
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;订单服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
[2018-01-31 17:04:11.662]订阅消息-- From: 127.0.0.1:53200
[2018-01-31 17:04:11.665]正在处理服务请求--From: 127.0.0.1:53200,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]Service://OrderService/CreateOrder/System.Int32=2000&amp;amp;System.Int32=100&amp;amp;System.Collections.Generic.List`1[[DistTransDto.BuyProductDto, DistTransDto, Version%Eqv;1.0.0.0, Culture%Eqv;neutral, PublicKeyToken%Eqv;null]]=[{&quot;ProductId&quot;:1,&quot;BuyNumber&quot;:3},{&quot;ProductI
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Resource at 17:04:11.672 receive DTC Controller state:CanCommit
PDF.NET AdoHelper Query Error：
DataBase ErrorMessage:;违反了 PRIMARY KEY 约束 'PK__Orders__2CE8FBFB7F60ED59'。不能在对象 'dbo.Orders' 中插入重复键。
语句已终止。
SQL:INSERT INTO [Orders]([OerderID],[OrderName],[AmountPrice],[OwnerID],[OrderTime]) VALUES (@P0,@P1,@P2,@P3,@P4)
CommandType:Text
Parameters:
Parameter[&quot;@P0&quot;]        =       &quot;2000&quot;                          //DbType=Int32
Parameter[&quot;@P1&quot;]        =       &quot;Prudoct:,商品0,商品1&quot;
//DbType=String
Parameter[&quot;@P2&quot;]        =       &quot;41&quot;                    //DbType=Single
Parameter[&quot;@P3&quot;]        =       &quot;100&quot;                   //DbType=Int32
Parameter[&quot;@P4&quot;]        =       &quot;2018-1-31 17:04:11&quot;                    //DbType=DateTime

MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) 1PC,Child moniter task has started at time:17:04:11.710
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Task Error:发生一个或多个错误。
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Try Rollback..
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Resource at 17:04:11.711 receive DTC Controller state:Abort
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Try Rollback..OK
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Try Rollback..
[2018-01-31 17:04:11.712]请求处理完毕(46.5004ms)--To: 127.0.0.1:53200,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]消息长度：5字节 -------
result:False
Reponse Message OK.
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Try Rollback..OK
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Resource at 17:04:11.714 receive DTC Controller state:Completed
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) 3PC Request Completed,use time:0.0469998 seconds.
[2018-01-31 17:04:11.716]取消订阅-- From: 127.0.0.1:53200
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Controller Process Reuslt:True,Receive time:17:04:11.719
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) 1PC,Child moniter task find DistTrans3PCState has changed,Now is Completed,task break!
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;商品服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
[2018-01-31 17:04:11.674]订阅消息-- From: 127.0.0.1:53202
[2018-01-31 17:04:11.675]正在处理服务请求--From: 127.0.0.1:53202,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]Service://ProductService/UpdateProductOnhand/System.String=76d175cc-5d40-4d05-adfb-94158b5c2215&amp;amp;System.Collections.Generic.List`1[[DistTransDto.BuyProductDto, DistTransDto, Version%Eqv;1.0.0.0, Culture%Eqv;neutral, PublicKeyToken%Eqv;null]]=[{&quot;ProductId&quot;:1
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Resource at 17:04:11.681 receive DTC Controller state:CanCommit
----------1,-Session ID:76d175cc-5d40-4d05-adfb-94158b5c2215----------
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) 1PC,Child moniter task has started at time:17:04:11.682
[2018-01-31 17:04:11.682]请求处理完毕(7.5003ms)--To: 127.0.0.1:53202,Identity:WMI2114256838
&amp;gt;&amp;gt;[PMID:1]消息长度：97字节 -------
result:[{&quot;StoreHouse&quot;:&quot;广州&quot;,&quot;ProductId&quot;:1,&quot;BuyNumber&quot;:3},{&quot;StoreHouse&quot;:&quot;广州&quot;,&quot;ProductId&quot;:2,&quot;BuyNumber&quot;:1}]
Reponse Message OK.
[2018-01-31 17:04:11.685]取消订阅-- From: 127.0.0.1:53202
[2018-01-31 17:04:11.686]订阅消息-- From: 127.0.0.1:53202
[2018-01-31 17:04:11.687]正在处理服务请求--From: 127.0.0.1:53202,Identity:WMI2114256838
&amp;gt;&amp;gt;[RMID:0]Service://ProductService/GetProductInfo/System.Int32=1
---------2,--Session ID:76d175cc-5d40-4d05-adfb-94158b5c2215----------
[2018-01-31 17:04:11.688]请求处理完毕(1.5019ms)--To: 127.0.0.1:53202,Identity:WMI2114256838
&amp;gt;&amp;gt;[RMID:0]消息长度：53字节 -------
result:{&quot;ID&quot;:1,&quot;Onhand&quot;:88,&quot;Price&quot;:10.0,&quot;ProductName&quot;:&quot;商品0&quot;}
[2018-01-31 17:04:11.690]正在处理服务请求--From: 127.0.0.1:53202,Identity:WMI2114256838
&amp;gt;&amp;gt;[RMID:0]Service://ProductService/GetProductInfo/System.Int32=2
---------2,--Session ID:76d175cc-5d40-4d05-adfb-94158b5c2215----------
[2018-01-31 17:04:11.694]请求处理完毕(4ms)--To: 127.0.0.1:53202,Identity:WMI2114256838
&amp;gt;&amp;gt;[RMID:0]消息长度：53字节 -------
result:{&quot;ID&quot;:2,&quot;Onhand&quot;:96,&quot;Price&quot;:11.0,&quot;ProductName&quot;:&quot;商品1&quot;}
[2018-01-31 17:04:11.694]取消订阅-- From: 127.0.0.1:53202
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Resource at 17:04:11.714 receive DTC Controller state:Abort
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Try Rollback..
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Try Rollback..OK
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Resource at 17:04:11.717 receive DTC Controller state:Completed
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) 3PC Request Completed,use time:0.0410005 seconds.
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) 1PC,Child moniter task find DistTrans3PCState has changed,Now is Completed,task break!
MSF DTC(76d175cc-5d40-4d05-adfb-94158b5c2215) Controller Process Reuslt:True,Receive time:17:04:11.731
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;性能总结：&lt;/p&gt;
&lt;p&gt; 订单创建成功的情况下，分布式协调器服务总共耗时 0.0434914(s),订单服务耗时0.0469998秒，商品服务耗时0.0410005秒。&lt;/p&gt;
&lt;p&gt;总体上，执行一个创建订单的分布式事务，耗时在50毫秒以内。&lt;/p&gt;
&lt;h3&gt;6.2.3，总体性能总结：&lt;/h3&gt;
&lt;p&gt; 从上面的测试结果看到，不论是订单创建成功提交事务，还是订单创建失败回滚事务，总体上事务执行时间都在50毫秒以内，多次测试也没用发现某个事务节点严重等待耗时的情况。&lt;/p&gt;

&lt;p&gt;消息服务框架（MSF）成功的实现了基于3阶段提交的分布式事务协议，并且事务执行性能在分布式环境下是可以接受的。&lt;/p&gt;
&lt;p&gt;当前实现过程中，利用消息服务框架的&lt;strong&gt;长连接特性&lt;/strong&gt;，它可以及时的发现网络异常情况而不会出现出现“傻等”的问题（等到超时），这可以保证分布式事务执行的可靠性和效率。&lt;/p&gt;

</description>
<pubDate>Wed, 31 Jan 2018 10:26:00 +0000</pubDate>
<dc:creator>深蓝医生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bluedoctor/p/8384948.html</dc:identifier>
</item>
<item>
<title>HTTPS原理 - Xjng</title>
<link>http://www.cnblogs.com/Xjng/p/8393808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Xjng/p/8393808.html</guid>
<description>&lt;h2 id=&quot;一原理&quot;&gt;一、原理&lt;/h2&gt;
&lt;h3 id=&quot;数据传输过程&quot;&gt;1. 数据传输过程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;浏览器发送支持的加密方式给服务器&lt;/li&gt;
&lt;li&gt;服务器选取一种加密方式，返回服务器的证书给浏览器，证书包含：网站域名，非对称加密的公钥，证书的颁发机构等&lt;/li&gt;
&lt;li&gt;客户端验证证书是否合法。&lt;/li&gt;
&lt;li&gt;如果证书合法或者用户同意使用不合法的证书，客户端随机生成一个随机密码TOKEN。&lt;/li&gt;
&lt;li&gt;使用服务器返回的公钥加密随机密码，得到加密后的字符串TOKEN_EN&lt;/li&gt;
&lt;li&gt;使用TOKEN（对称加密方法）加密一段握手信息（MSG），得到EN_MSG。&lt;/li&gt;
&lt;li&gt;对MSG进行hash加密，得到HASH_MSG&lt;/li&gt;
&lt;li&gt;把TOKEN_EN，HASH_MSG,EN_MSG一起发回给服务端&lt;/li&gt;
&lt;li&gt;服务端使用密钥解密TOKEN_EN，得到TOKEN&lt;/li&gt;
&lt;li&gt;服务端使用TOKEN解密EN_MSG，得到握手信息MSG，对MSG进行hash加密，得到HASH_MSG_，并验证是否与客户端发来的HASH_MSG一样。&lt;/li&gt;
&lt;li&gt;服务端生成一段握手信息MSG1，使用TOKEN进行加密，得到EN_MSG1。使用hash加密，得到HASH_MSG1，把EN_MSG1和HASH_MSG1发送给客户端。&lt;/li&gt;
&lt;li&gt;服务端使用TOKEN解密EN_MSG1，得到握手信息MSG1，对MSG进行hash加密，得到HASH_MSG1_，并验证是否与服务端发来的HASH_MSG1一样。&lt;/li&gt;
&lt;li&gt;这样，握手阶段就结束了，握手阶段的作用：1. 验证服务端的证书 2. 客户端和服务端约定一个对称加密的秘钥，也就是TOKEN&lt;/li&gt;
&lt;li&gt;后面所有的数据传输，都是发送方使用对称加密后，发送给接收方，接收方再进行解密，这样就可以保证，传输的过程中，1. 明文不会泄漏，2. 明文不会被篡改。这样就可以保证传输的安全性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后的对MSG和MSG1的加密和解密，主要是用于测试的，也就是测试服务端和客户端的TOKEN，加密方式是不是都是一致的，这样可以保证后面的数据传输不会出错。&lt;br/&gt;常用的加密方式：&lt;br/&gt;非对称加密算法：RSA，DSA/DSS&lt;br/&gt;对称加密算法：AES，RC4，3DES&lt;br/&gt;HASH算法：MD5，SHA1，SHA256&lt;/p&gt;
&lt;p&gt;非对称加密用于客户端和服务端协商TOKEN，这样可以做到只有服务端和客户端知道TOKEN的明文，使用密文来传输，防止被别人看到TOKEN&lt;br/&gt;对称加密用于对HTTP传输的数据进行加密，发送方使用对称加密进行加密得到密文，传输密文给接收方，接收方解密后得到明文，这样传输的过程中，其他人看不到明文&lt;br/&gt;HASH加密用于协商TOKEN后，客户端和服务端的传输测试，主要作用是判断加密前的数据和加密后再被解密得到的数据，是否一样。也就是验证测试是否通过。其实也可以不用hash加密，测试的时候直接发送明文，但是相对来说，安全性会差一点。&lt;/p&gt;
&lt;h2 id=&quot;二变化&quot;&gt;二、变化&lt;/h2&gt;
&lt;h3 id=&quot;相对http能解决的问题&quot;&gt;1. 相对HTTP，能解决的问题&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;网络中间人。也就是有人破解了你的路由器，就可以看到你所有的请求。使用HTTPS后，所有经过路由器的数据都是经过加密的数据，所以别人看不到真实的数据。&lt;/li&gt;
&lt;li&gt;运营商HTTP劫持。运营商会在返回的HTML文件里面加上自己的推广DOM，但是由于浏览器会对返回数据进行解密，这样会导致解密失败，可能会显示乱码。&lt;/li&gt;
&lt;li&gt;运营商DNS劫持。DNS劫持的话，运营商会把域名解析为他们自己的IP，这样，返回的证书可能是假的，这样浏览器能够辨别，如果是真的，但是浏览器检查证书会发现DNS解析的IP和证书的IP不一样，也会报错，告诉用户。&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&quot;还是不能解决的问题&quot;&gt;2. 还是不能解决的问题&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;钓鱼网站。用户一开始就访问了错误的域名，所以HTTPS也不能解决，钓鱼网站也可能是HTTPS，但是现在相对较少。&lt;/li&gt;
&lt;li&gt;篡改跳转链接。很多时候，并不是所有页面都是https的，有时候是从一个http页面跳转到https页面，这样网络中间人就可以修改http页面里的跳转地址，改为非https的，这样用户一般不会察觉。这样就可以实现中间人和服务器建立https链接，浏览器和中间人建立http链接，这样用户的所有输入，例如密码，中间人都可以看到。即使JS中对密码进行md5加密也没有用，因为中间人也可以修改JS代码。所以最好的方法是输入密码前，看看浏览器的地址是不是https的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/mfc-itblog/p/5780295.html&quot;&gt;运营商&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三证书验证原理&quot;&gt;三、证书验证原理&lt;/h2&gt;
&lt;p&gt;假如有证书机构A，服务器B，客户端C&lt;br/&gt;有数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A的公钥A_PUB和私钥A_PRI&lt;/li&gt;
&lt;li&gt;B的公钥B_PUB和私钥B_PRI&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;流程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端会有一个信任的根证书库。保存的是证书机构的公钥，当然会有很多个证书机构。这个证书库，可能是系统级别的（例如window），也有可能是浏览器级别的。&lt;/li&gt;
&lt;li&gt;服务器B，生成公钥和私钥后，需要证书机构的签发。证书机构会对服务器B进行详细的验证，然后会为B生成一张证书，证书的内容有：有效期，对应的网站，B的公钥，证书颁发机构的名字，B对证书的数字签名，A对证书的数字签名。&lt;/li&gt;
&lt;li&gt;当C访问B的时候，B会把证书发送给C&lt;/li&gt;
&lt;li&gt;C会根据证书颁发机构的名字，从自己的根证书库里面找出A的公钥A_PUB。如果找不到，会提示用户，证书不可靠。&lt;/li&gt;
&lt;li&gt;证书中会有B_PUB，这样通过B_PUB，A_PUB就可以验证A和B的数字签名是否正确。如果正确，就可以确定证书没有被篡改，而且是A颁发的。否则提示证书不可靠。&lt;/li&gt;
&lt;li&gt;C再验证其他内容，例如有效期，是否吊销（下面会说是否吊销的验证方法）等。&lt;/li&gt;
&lt;li&gt;如果都通过，就可以认定，证书没有被修改，而且是属于B的证书。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数字签名的原理就是：证书机构，对证书的内容（数字签名外的其他内容，例如网站，有效期等）计算HASH值，然后使用A的私钥或者B的私钥进行加密。具体可以看RSA数字签名方法。&lt;/p&gt;
&lt;h4 id=&quot;fiddler抓包https的原理&quot;&gt;1.Fiddler抓包HTTPS的原理&lt;/h4&gt;
&lt;p&gt;步骤是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Fiddler会自己生成一个模拟证书机构MA的公钥和私钥，还有一个模拟服务器MB的公钥和私钥&lt;/li&gt;
&lt;li&gt;然后需要我们把模拟证书机构的公钥添加到客户端的信任的根证书库里面。&lt;/li&gt;
&lt;li&gt;当服务端B下发证书CA给Fiddler时，Fiddler会通过MA和MB的公钥和私钥，生成另一张正式MCA给客户端。&lt;/li&gt;
&lt;li&gt;由于客户端信任了MA的公钥，所以客户端不会发现MCA有异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实这就说明Fiddler可以实现中间人的攻击。而可以实现攻击的根本原因是客户端信任了MA的公钥。&lt;br/&gt;所以平时我们不要轻易相信未知的证书。&lt;/p&gt;
&lt;h4 id=&quot;证书是否吊销&quot;&gt;2. 证书是否吊销&lt;/h4&gt;
&lt;p&gt;吊销是指在有效期过期前，证书被吊销了。&lt;br/&gt;这样的话，客户端怎么发现证书是否被吊销呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端会定期从信任的服务器下载已吊销的证书的MD5。&lt;/li&gt;
&lt;li&gt;客户端收到服务端的证书后，可以访问信任的网站，查验证书是否有效。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其他：&lt;br/&gt;访问一个https的网站，网站的旁边会有个信任的标志，里面可以看到证书的详细信息。&lt;br/&gt;Internet选项-内容-证书 可以看到浏览器信任的证书和根证书&lt;/p&gt;
&lt;p&gt;未经许可，请不要转载。&lt;/p&gt;
</description>
<pubDate>Wed, 31 Jan 2018 10:22:00 +0000</pubDate>
<dc:creator>Xjng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Xjng/p/8393808.html</dc:identifier>
</item>
<item>
<title>.NET: 谈谈共享项目 (Shared Project) 的使用 - WPInfo</title>
<link>http://www.cnblogs.com/wpinfo/p/shared_project.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wpinfo/p/shared_project.html</guid>
<description>&lt;p&gt;从 Visual Studio 2015 起，共享项目 (Shared Project) 作为新的一种项目类型被添加到项目模板列表中，它的主要目的是使多个不同类型的项目之间可以共享代码或资源。相比它的前任 PCL(Portable Class Library)，它要灵活得多。因为 Shared Project 共享的是代码或资源，并且不会创建单独的程序集；而 PCL 则是共享程序集，需要单独编译，且会生成单独的程序集。&lt;/p&gt;
&lt;p&gt;在项目中，使用 Shared Project 可以帮助我们很容易地解决一些难题。本文主要讨论，在开发过程中，我们如何使用它以及它具体能够帮助我们解决哪些问题。在这之前，首先来看如何创建与使用 Shared Project。&lt;/p&gt;
&lt;h2&gt;创建与使用&lt;/h2&gt;
&lt;p&gt;前面说过，Shared Project 是一种项目模板类型，因此我们可以在现有的解决方案中创建一个新项目，然后在项目模板列表中选择 Shared Project：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/676860/201801/676860-20180131172139203-376150087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个 Shared Project 中我们可以添加所有需要与其它项目共享的代码或资源（如图片、Html文件、JS 文件等）。另外，为了保持它与现有项目命名空间一致，可以在“解决方案管理器&quot;中右击它，选择”属性“，更改其 Root namespace。&lt;/p&gt;
&lt;p&gt;接着，要在那些需要引用它的项目中对其添加引用，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/676860/201801/676860-20180131170225250-1273359475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当引用后，所有在 Shared Project 中代码和资源能够在这些项目中正常使用。&lt;/p&gt;
&lt;p&gt;此外，Shared Project 自己无法编译，我们需要通过编译引用它的项目来生成 exe 或 dll 等程序集。并且 Shared Project 本身不会输出为程序集。&lt;/p&gt;
&lt;h2&gt;使用场景&lt;/h2&gt;
&lt;h3&gt;场景一：输出针对不同 .NET Framework 版本的类库&lt;/h3&gt;
&lt;p&gt;如果你正在开发一个类库或框架，而且最终要发布它，好让别人能够使用，所以你的类库可能需要满足多个 .NET Framework 版本，如 2.0/3.5/4.0/4.5 等，由于更高版本的 Framework 加入了更多的 API 以及更多的语法，使得在代码编写时更容易，比如 LINQ 等，然而低版本却不支持，因此在类库中的代码就需要对不同的版本有区分。&lt;/p&gt;
&lt;p&gt;对于这种情况，借助于 Shared Project 和条件编译符号 (Conditional compilation symbols)，就可以解决上述问题。我们可以这样做：&lt;/p&gt;
&lt;p&gt;1. 创建一个 Shared Project 项目；&lt;br/&gt;2. 再分别创建多个类库 (Class Library) 项目，它们的目标框架 (Target framework) 分别指定不同的 Framework 版本；&lt;br/&gt;3. 为每个类库类目设置不同的条件编译符号（在项目属性中的“编译”选项卡里设置），如 NET2_0/NET4_0/NET4_5 等；&lt;br/&gt;4. 然后，在 Shared Project 中就可以使用这些符号来判断 Framework 版本，并写出针对不同版本的代码，例如下面的代码（注意其中加粗部分）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;this&lt;/span&gt;.windowChrome = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WindowChrome
            {
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;#if&lt;/span&gt; NET4_5&lt;/strong&gt;&lt;span&gt;
                ResizeBorderThickness &lt;/span&gt;=&lt;span&gt; SystemParameters.WindowResizeBorderThickness, 
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;#else&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
                ResizeBorderThickness &lt;/span&gt;=&lt;span&gt; SystemParameters2.Current.WindowResizeBorderThickness,
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
                CaptionHeight &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                CornerRadius &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CornerRadius(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;),
                GlassFrameThickness &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thickness(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;),
                UseAeroCaptionButtons &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;场景二：输出针对不同 Platform 的类库&lt;/h3&gt;
&lt;p&gt;如果项目中一个（或多个）类库需要同时支持 x86 与 x64 两个不同的 Platform，以使软件能够在 x86/x64 上都能运行，这时 Shared Project 也可以派上用场。&lt;/p&gt;
&lt;p&gt;一个具体的例子是开发 Office 加载项，如果你的加载项是 COM 类型的，则需要分别为 32位与 64位 Office 提供对应的版本。对于32位，程序集的目标平台 (Platform target) 可以是 Any CPU，但对于64位，则应该是 x64。&lt;/p&gt;
&lt;p&gt;使用 Shared Project 可以很容易解决这样的问题，具体做法：&lt;/p&gt;
&lt;p&gt;1. 针对加载项创建一个 Shared Project，将所有代码与资源文件放到这个项目中；&lt;br/&gt;2. 分别创建两个不同的 Class Library，使它们引用 Shared Project，不同的是，这两个项目的目标平台不一样，一个是 Any CPU，另一个是 x64；&lt;br/&gt;3. 如果用到了第三方库，为两个项目添加同样的引用；&lt;br/&gt;4. 除此以外，你还要修改它们的程序集名称，使它们的输出的程序集名称有区别、且有意义。&lt;/p&gt;
&lt;p&gt;最后，需要注意的是，修改项目属性时，无论是设置&quot;条件编译符号&quot;，还是修改&quot;目标平台&quot;，都要注意它们都与项目的配置 (Debug/Release) 是关联的，也就是说，在 Debug 配置中改了，还要在 Release 配置中改；对于此，一个替代的办法是，从配置下拉列表选择“所有配置”，然后再设置符号或目标平台，则能够对 Debug/Release 都有效。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要讨论了 Shared Project 的使用以及它的实际使用场景，它能够使我们的程序集面向不同 .NET Framework 版本以及不同的 Platform。其实不难看出，这都是通过修改项目的属性而实现的，这样一来，多个项目就可以达到代码相同、程序集属性却不同，从而解决实际对应的问题。如果你在开发过程中遇到了类似的问题，也可以尝试一下使用 Shared Project 来解决。&lt;/p&gt;
</description>
<pubDate>Wed, 31 Jan 2018 09:51:00 +0000</pubDate>
<dc:creator>WPInfo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wpinfo/p/shared_project.html</dc:identifier>
</item>
<item>
<title>Mysql中的force index和ignore index - 神雕爱大侠</title>
<link>http://www.cnblogs.com/sdadx/p/8391985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdadx/p/8391985.html</guid>
<description>&lt;p&gt;　　前几天统计一个sql，是一个人提交了多少工单，顺便做了相关sql优化。数据大概2000多w。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;  CustName,&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) c &lt;span&gt;from&lt;/span&gt; WorkOrder  &lt;span&gt;where&lt;/span&gt; CreateDate&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-5-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; CreateDate&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-1-1&lt;/span&gt;&lt;span&gt;'&lt;br/&gt;&lt;/span&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; CustName &lt;span&gt;having&lt;/span&gt; c&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了实验最少受其他因素干扰，将生产库的200多w数据导出来，用测试服务器进行测试。&lt;/p&gt;
&lt;p&gt;　　导出来的数据是一个堆表，没有主键，没有索引。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; show &lt;span&gt;index&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; WorkOrder;   查询index方法1
Empty &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; show keys &lt;span&gt;from&lt;/span&gt;&lt;span&gt; WorkOrder;    查询index方法2
Empty &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　1.堆表的情况&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　这时候就在这时候，用执行计划分析下语句。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt;  explain &lt;span&gt;select&lt;/span&gt;  CustName,&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) c &lt;span&gt;from&lt;/span&gt;&lt;span&gt; WorkOrder 
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; CreateDate&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-5-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; CreateDate&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-1-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; CustName &lt;span&gt;having&lt;/span&gt; c&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+------+---------------+------+---------+------+---------+----------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows    &lt;span&gt;|&lt;/span&gt; Extra                                        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+------+---------------+------+---------+------+---------+----------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2528727&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;; Using &lt;span&gt;temporary&lt;/span&gt;; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+------+---------------+------+---------+------+---------+----------------------------------------------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　select_type的值为SIMPLE，表示简单的select查询，不使用union或子查询。&lt;/p&gt;
&lt;p&gt;　　type的值为ALL，表示要对表进行表扫描。&lt;/p&gt;
&lt;p&gt;　　possible_keys 表示能使用哪个索引找到行记录。&lt;/p&gt;
&lt;p&gt;　　key 表示Mysql决定使用的索引（键）。&lt;/p&gt;
&lt;p&gt;       key_len 表示Mysql决定使用索引的长度。&lt;/p&gt;
&lt;p&gt;　　ref  表示使用哪个列和key一起从表中选择行。&lt;/p&gt;
&lt;p&gt;　　rows 表示Mysql认为它执行查询时必须检查的行数。&lt;/p&gt;
&lt;p&gt;　　extra 表示查询的详情信息，用到where，临时表，排序。&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　执行下该语句三次，发现执行了16.30 sec、16.34 sec、16.24 sec。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;　2.有索引的情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　建了四个索引，分别以custname，CreateDate建两个单列索引，另外两个是联合索引，只是最左边列不一样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; WorkOrder &lt;span&gt;add&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;&lt;span&gt; ix_name(custname)  
&lt;/span&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; WorkOrder &lt;span&gt;add&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;&lt;span&gt; ix_date(CreateDate)  
&lt;/span&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; WorkOrder &lt;span&gt;add&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;&lt;span&gt; ix_namedate(custname,CreateDate)  
&lt;/span&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; WorkOrder &lt;span&gt;add&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; ix_datename(CreateDate,custname)  
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; show keys &lt;span&gt;from&lt;/span&gt;&lt;span&gt; WorkOrder;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;Table&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; Non_unique &lt;span&gt;|&lt;/span&gt; Key_name    &lt;span&gt;|&lt;/span&gt; Seq_in_index &lt;span&gt;|&lt;/span&gt; Column_name &lt;span&gt;|&lt;/span&gt; Collation &lt;span&gt;|&lt;/span&gt; Cardinality &lt;span&gt;|&lt;/span&gt; Sub_part &lt;span&gt;|&lt;/span&gt; Packed &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Null&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Index_type &lt;span&gt;|&lt;/span&gt; Comment &lt;span&gt;|&lt;/span&gt; Index_comment &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ix_name     &lt;span&gt;|&lt;/span&gt;            &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CustName    &lt;span&gt;|&lt;/span&gt; A         &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1264363&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt; YES  &lt;span&gt;|&lt;/span&gt; BTREE      &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ix_date     &lt;span&gt;|&lt;/span&gt;            &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CreateDate  &lt;span&gt;|&lt;/span&gt; A         &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2528727&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; BTREE      &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ix_namedate &lt;span&gt;|&lt;/span&gt;            &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CustName    &lt;span&gt;|&lt;/span&gt; A         &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1264363&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt; YES  &lt;span&gt;|&lt;/span&gt; BTREE      &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ix_namedate &lt;span&gt;|&lt;/span&gt;            &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CreateDate  &lt;span&gt;|&lt;/span&gt; A         &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2528727&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; BTREE      &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ix_datename &lt;span&gt;|&lt;/span&gt;            &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CreateDate  &lt;span&gt;|&lt;/span&gt; A         &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2528727&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; BTREE      &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ix_datename &lt;span&gt;|&lt;/span&gt;            &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CustName    &lt;span&gt;|&lt;/span&gt; A         &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2528727&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt; YES  &lt;span&gt;|&lt;/span&gt; BTREE      &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　之后，用执行计划分析下sql查询语句。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;  CustName,&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) c &lt;span&gt;from&lt;/span&gt;&lt;span&gt; WorkOrder 
    &lt;/span&gt; &lt;span&gt;where&lt;/span&gt; CreateDate&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-5-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; CreateDate&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-1-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; CustName &lt;span&gt;having&lt;/span&gt; c&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+-----------------------------------------+-------------+---------+------+--------+-----------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; type  &lt;span&gt;|&lt;/span&gt; possible_keys                           &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows   &lt;span&gt;|&lt;/span&gt; Extra                                                     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+-----------------------------------------+-------------+---------+------+--------+-----------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt; range &lt;span&gt;|&lt;/span&gt; ix_name,ix_date,ix_namedate,ix_datename &lt;span&gt;|&lt;/span&gt; ix_datename &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;824372&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;; Using &lt;span&gt;index&lt;/span&gt;; Using &lt;span&gt;temporary&lt;/span&gt;; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+-----------------------------------------+-------------+---------+------+--------+-----------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.01&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从执行计划可以看出，Mysql从四个索引中选取了ix_datename这个索引，type为range表示索引范围扫描。rows的数量值是没堆表的1/3。&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　执行语句三次，时间是 8.64 sec、8.61sec、8.55 sec。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我建了三个索引，那么我想用下另外三个索引怎么办？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　这里可以用force index()，这个指令可以指定本次查询强制使用哪个索引，因为Mysql优化器的选择并不是最优的索引。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;  CustName,&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) c &lt;span&gt;from&lt;/span&gt; WorkOrder force &lt;span&gt;index&lt;/span&gt;(ix_namedate) &lt;br/&gt;&lt;span&gt;where&lt;/span&gt; CreateDate&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-5-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; CreateDate&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-1-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; CustName &lt;span&gt;having&lt;/span&gt; c&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+---------------------------------+-------------+---------+------+---------+-----------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; type  &lt;span&gt;|&lt;/span&gt; possible_keys                   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows    &lt;span&gt;|&lt;/span&gt; Extra                                                     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+---------------------------------+-------------+---------+------+---------+-----------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ix_name,ix_namedate,ix_datename &lt;span&gt;|&lt;/span&gt; ix_namedate &lt;span&gt;|&lt;/span&gt; &lt;span&gt;307&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2528727&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;; Using &lt;span&gt;index&lt;/span&gt;; Using &lt;span&gt;temporary&lt;/span&gt;; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+---------------------------------+-------------+---------+------+---------+-----------------------------------------------------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　  选用另一个联合索引 &lt;strong&gt;ix_namedate，&lt;/strong&gt;这次type变为index，可以这样理解，根据索引的顺序进行全表扫描，比ALL效率要高些，rows的值和堆表的值差不多。&lt;/p&gt;
&lt;p&gt;　　  &lt;span&gt;执行语句三次，时间是 7.84 sec、7.92 sec、7.84 sec。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;  CustName,&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) c &lt;span&gt;from&lt;/span&gt; WorkOrder force &lt;span&gt;index&lt;/span&gt;&lt;span&gt;(ix_name) 
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; CreateDate&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-5-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; CreateDate&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-1-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; CustName &lt;span&gt;having&lt;/span&gt; c&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+---------------------------------+---------+---------+------+---------+----------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; type  &lt;span&gt;|&lt;/span&gt; possible_keys                   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows    &lt;span&gt;|&lt;/span&gt; Extra                                        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+---------------------------------+---------+---------+------+---------+----------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ix_name,ix_namedate,ix_datename &lt;span&gt;|&lt;/span&gt; ix_name &lt;span&gt;|&lt;/span&gt; &lt;span&gt;303&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2528727&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;; Using &lt;span&gt;temporary&lt;/span&gt;; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+---------------------------------+---------+---------+------+---------+----------------------------------------------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  　　选用另一个联合索引&lt;strong&gt; ix_name，&lt;/strong&gt;这次type是index，可以这样理解，根据索引的顺序进行全表扫描，比ALL效率要高些，rows的值和堆表的值差不多。&lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt; 执行语句三次，时间是 1 min 28.17 sec、1 min 27.64 sec、1 min 27.58 sec。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;  CustName,&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) c &lt;span&gt;from&lt;/span&gt; WorkOrder force &lt;span&gt;index&lt;/span&gt;&lt;span&gt;(ix_date) 
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; CreateDate&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-5-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; CreateDate&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-1-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; CustName &lt;span&gt;having&lt;/span&gt; c&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+-----------------------------------------+---------+---------+------+--------+-------------------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; type  &lt;span&gt;|&lt;/span&gt; possible_keys                           &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows   &lt;span&gt;|&lt;/span&gt; Extra                                                             &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+-----------------------------------------+---------+---------+------+--------+-------------------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt; range &lt;span&gt;|&lt;/span&gt; ix_name,ix_date,ix_namedate,ix_datename &lt;span&gt;|&lt;/span&gt; ix_date &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;921062&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; condition; Using MRR; Using &lt;span&gt;temporary&lt;/span&gt;; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+-----------------------------------------+---------+---------+------+--------+-------------------------------------------------------------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  　　选用另一个联合索引&lt;strong&gt; ix_date，&lt;/strong&gt;这次type是range，表示索引范围扫描，rows的值是堆表的1/3多些 。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　  执行语句三次，时间是 9.55 sec、9.52 sec、9.39 sec。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;假如我不想用索引了怎么办？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　可以使用ignore index()，这个指令可以强制Mysql在查询时，不使用某索引。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;  CustName,&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) c &lt;span&gt;from&lt;/span&gt; WorkOrder  ignore &lt;span&gt;index&lt;/span&gt;&lt;span&gt;(ix_date) 
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; CreateDate&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-5-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; CreateDate&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-1-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; CustName &lt;span&gt;having&lt;/span&gt; c&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+---------------------------------+-------------+---------+------+--------+-----------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; type  &lt;span&gt;|&lt;/span&gt; possible_keys                   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows   &lt;span&gt;|&lt;/span&gt; Extra                                                     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+---------------------------------+-------------+---------+------+--------+-----------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt; range &lt;span&gt;|&lt;/span&gt; ix_name,ix_namedate,ix_datename &lt;span&gt;|&lt;/span&gt; ix_datename &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;824372&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;; Using &lt;span&gt;index&lt;/span&gt;; Using &lt;span&gt;temporary&lt;/span&gt;; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+-------+---------------------------------+-------------+---------+------+--------+-----------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;
mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;  CustName,&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) c &lt;span&gt;from&lt;/span&gt; WorkOrder  ignore &lt;span&gt;index&lt;/span&gt;&lt;span&gt;(ix_date,ix_name,ix_namedate,ix_datename) 
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; CreateDate&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-5-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; CreateDate&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-1-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; CustName &lt;span&gt;having&lt;/span&gt; c&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+------+---------------------------------+------+---------+------+---------+----------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys                   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows    &lt;span&gt;|&lt;/span&gt; Extra                                        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+------+---------------------------------+------+---------+------+---------+----------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; WorkOrder &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; ix_name,ix_namedate,ix_datename &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2528727&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;; Using &lt;span&gt;temporary&lt;/span&gt;; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-----------+------+---------------------------------+------+---------+------+---------+----------------------------------------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面第一个强制不使用&lt;strong&gt;ix_date&lt;/strong&gt;索引，那么就Mysql就从剩下的三个索引中，选取他认为是最优的索引。第二个时将四个索引都不使用，那么Mysql就进行全表扫描了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　  1.Mysql的语句优化，没有绝对的正确，&lt;span&gt;explain&lt;/span&gt;也只是给出个大致的方向，例如&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;key_len&lt;/span&gt;&lt;span&gt;值小的，&lt;span&gt;rows&lt;/span&gt;小的按理说，时间应该最短，效率最高。但是，实验中时间最少的却不是那个值最小的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　   2. 优化还需根据实际数据情况，例如，假如我where选取的时间范围变化，或者说CustName的分布有些变化，可能跟刚才的实验，又会产生一定偏差。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　   3. 同样我还实验了，当给表加上主键时，整体的查询时间会缩短些。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;------------------附相关index命令--------------&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;删除主键&lt;p&gt;ALTER TABLE &lt;/p&gt;&lt;/span&gt;WorkOrder  &lt;span&gt;MODIFY&lt;/span&gt; &lt;span&gt;id int(11)； --&lt;/span&gt;1.先删除auto_increment
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;  WorkOrder  &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;;  &lt;span&gt;--2.再&lt;/span&gt;&lt;span&gt;删除主键&lt;/span&gt;

&lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; WorkOrder &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; ix_datename;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;删除索引&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://www.2cto.com/database/201709/683142.html&quot; target=&quot;_blank&quot;&gt;mysql如何添加主键约束和唯一性约束，删除主键和唯一性约束&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;a href=&quot;http://blog.csdn.net/wufei1314a/article/details/51753425&quot; target=&quot;_blank&quot;&gt;mysql强制使用索引与不使用索引&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;a href=&quot;http://blog.csdn.net/bruce128/article/details/46777567&quot; target=&quot;_blank&quot;&gt;利用 force index优化sql语句性能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　   &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/dsitn/p/7091283.html&quot;&gt;mysql 存在索引但不能使用索引的典型场景&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　   &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/yycc/p/7338894.html&quot;&gt;mysql explain用法和结果的含义&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　   &lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/digdeep/p/4975977.html&quot;&gt;MySQL 优化之 index merge(索引合并)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 31 Jan 2018 08:43:00 +0000</pubDate>
<dc:creator>神雕爱大侠</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdadx/p/8391985.html</dc:identifier>
</item>
<item>
<title>疑难杂症——关于EntityFramework的SqlQuery方法的执行效率差异的探讨 - 懒得安分</title>
<link>http://www.cnblogs.com/landeanfen/p/8392498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/landeanfen/p/8392498.html</guid>
<description>&lt;p&gt;前言：最近项目上面遇到一个问题，在Code First模式里面使用EntityFramework的SqlQuery()方法查询非常慢，一条数据查询出来需要10秒以上的时间，可是将sql语句放在plsql里面执行，查询时间基本可以忽略不计。折腾了半天时间，仍然找不到原因。最后通过对比和原始Ado的查询方式的差异找到原因，今天将此记录下。&lt;/p&gt;
&lt;p&gt;本文原创地址：&lt;a href=&quot;http://www.cnblogs.com/landeanfen/p/8392498.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/landeanfen/p/8392498.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其实问题很简单，上面前言已经描述过。就是一个多表的联合查询，没有什么特殊的语法。大致代码如下：（PS：不要问为什么用了EF还要使用sql语句，你就当这是个梗！）&lt;/p&gt;
&lt;p&gt;通用的sql语句查询方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　public&lt;/span&gt; IEnumerable&amp;lt;TEntity&amp;gt; SqlQuery&amp;lt;TEntity&amp;gt;(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] parameters)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._dbContext.Database.SqlQuery&amp;lt;TEntity&amp;gt;&lt;span&gt;(sql, parameters).ToArray();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在外层调用这个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; sql = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;select * from (
                select ax.*,rownum as rnum from (
                select o.* from order o
                left join ordertt a on o.id=a.orderid
                left join orderdd d on o.id=d.orderid
                left join orderstation ts on d.station = ts.id
                left join ordermodel m on o.materialid=m.id
                where 1=1  and o.status = 30
                order by ts.no,tw.seq
                ) ax ) t 
                 where t.rnum&amp;gt;0 and t.rnum &amp;lt;=15&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = SqlQuery(sql);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后查询，每次得到的结果都是一条记录，但是却需要10秒以上，可能你不相信，但这是真的！&lt;/p&gt;
&lt;p&gt;问题就这么个问题，没办法，出现了问题就要想办法解决。&lt;/p&gt;

&lt;p&gt;我们将SqlQuery&amp;lt;T&amp;gt;()方法转到定义，最终发现它是EntityFramework.dll里面的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/459756/201801/459756-20180131153812500-831648195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然转到定义已经找不到任何突破口，那我们常规的做法就只有对比了。然后博主在本地定义了一个对比的例子。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;原始组：EF的SqlQuery()方法&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　 //&lt;/span&gt;&lt;span&gt;EF查询方法&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;TestModel&amp;gt; EFSqlQuery(DbContext db, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; sql)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; db.Database.SqlQuery&amp;lt;TestModel&amp;gt;&lt;span&gt;(sql).ToArray();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;对比照：Ado的查询方法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　 //&lt;/span&gt;&lt;span&gt;ADO的查询方法&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;TestModel&amp;gt; AdoSqlQuery(DbContext db, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; sql)
        {
            DataTable dt &lt;/span&gt;=&lt;span&gt; ExecuteDataTable(db, sql);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ms = GetListByDataTable&amp;lt;TestModel&amp;gt;&lt;span&gt;(dt);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ms;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('82d4ccbd-fc11-4655-bb7a-d262641cc931')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_82d4ccbd-fc11-4655-bb7a-d262641cc931&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_82d4ccbd-fc11-4655-bb7a-d262641cc931&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('82d4ccbd-fc11-4655-bb7a-d262641cc931',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_82d4ccbd-fc11-4655-bb7a-d262641cc931&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DataTable转List&amp;lt;T&amp;gt;公共的方法&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DataTable ExecuteDataTable(DbContext db, &lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; System.Data.Common.DbParameter[] parameters)
        {
            DataTable dt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataTable();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; conn =&lt;span&gt; db.Database.Connection;

            conn.Open();
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; cmd =&lt;span&gt; db.Database.Connection.CreateCommand())
            {
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; parameters) cmd.Parameters.Add(p);

                cmd.CommandText &lt;/span&gt;=&lt;span&gt; sql;
                dt.Load(cmd.ExecuteReader());
            }
            conn.Close();

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dt;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;T&amp;gt; GetListByDataTable&amp;lt;T&amp;gt;(DataTable dt) &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个意思是一个约束，约定泛型T必须要有一个无参数的构造函数&lt;/span&gt;
&lt;span&gt;        {
            List&lt;/span&gt;&amp;lt;T&amp;gt; lstResult = &lt;span&gt;new&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dt.Rows.Count &amp;lt;= &lt;span&gt;0&lt;/span&gt; || dt == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lstResult;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射这个类得到类的类型。&lt;/span&gt;
            Type t = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(T);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个泛型类对象&lt;/span&gt;
&lt;span&gt;            T oT;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到这个类的所有的属性&lt;/span&gt;
            PropertyInfo[] lstPropertyInfo =&lt;span&gt; t.GetProperties();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DataRow dr &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dt.Rows)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个DataRow对应一个泛型对象&lt;/span&gt;
                oT = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; T();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历所有的属性&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; lstPropertyInfo.Length; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到属性名&lt;/span&gt;
                    &lt;span&gt;string&lt;/span&gt; strPropertyValue =&lt;span&gt; lstPropertyInfo[i].Name;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有表格的列包含对应的属性&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dt.Columns.Contains(strPropertyValue))
                    {
                        &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; oValue = Convert.IsDBNull(dr[strPropertyValue]) ? &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T) : GetTypeDefaultValue(lstPropertyInfo[i].PropertyType.ToString(), dr[strPropertyValue]);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给对应的属性赋值&lt;/span&gt;
                        lstPropertyInfo[i].SetValue(oT, oValue, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    }
                }
                lstResult.Add(oT);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lstResult;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; GetTypeDefaultValue(&lt;span&gt;string&lt;/span&gt; strTypeName, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; oValue)
        {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (strTypeName)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.String&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oValue.ToString();
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Int16&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.Int16]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToInt16(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.UInt16&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.UInt16]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToUInt16(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Int32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.Int32]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToInt32(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.UInt32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.UInt32]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToUInt32(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Int64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.Int64]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToInt64(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.UInt64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.UInt64]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToUInt64(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Single&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.Single]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToSingle(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Decimal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.Decimal]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToDecimal(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Double&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.Double]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToDouble(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Boolean&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.Boolean]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToBoolean(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.DateTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.DateTime]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToDateTime(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.SByte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.SByte]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToSByte(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Byte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.Byte]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToByte(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Char&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.Char]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToChar(oValue);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Object&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Nullable`1[System.Object]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oValue;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Array&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; oValue &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Array;

                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;GetListByDataTable&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;然后在控制台里面分别调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Stopwatch sw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (MesDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MesDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sql = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;select * from (
                select ax.*,rownum as rnum from (
                select o.* from order o
                left join ordertt a on o.id=a.orderid
                left join orderdd d on o.id=d.orderid
                left join orderstation ts on d.station = ts.id
                left join ordermodel m on o.materialid=m.id
                where 1=1  and o.status = 30
                order by ts.no,tw.seq
                ) ax ) t 
                 where t.rnum&amp;gt;0 and t.rnum &amp;lt;=15&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;“预热”&lt;/span&gt;
&lt;span&gt;                EFSqlQuery(db, sql);

                sw.Start();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; EFSqlQuery(db, sql);
                sw.Stop();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用EF里面的SqlQuery方法查询得到&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + result.Count() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;条记录。总耗时&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; sw.Elapsed);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同样也预热一下&lt;/span&gt;
&lt;span&gt;                AdoSqlQuery(db, sql);
                sw.Restart();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result2 =&lt;span&gt; AdoSqlQuery(db, sql);
                sw.Stop();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用原始的Ado查询得到&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + result.Count() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;条记录。总耗时&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; sw.Elapsed);

            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/459756/201801/459756-20180131155425640-559579147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;差别有多大大家可以自行脑补。&lt;/p&gt;
&lt;h2&gt;原因分析&lt;/h2&gt;
&lt;p&gt;既然结果差别这么大，而sql语句在plsql里面执行又如此快，那么问题自然而然转到了对象序列化的身上了。也就是说这个SqlQuery()方法实际上可以分为两个步骤：第一步是查询得到DataTable之类的对象，然后第二步是将DataTable之类的对象转换为List&amp;lt;T&amp;gt;，既然我们第一步没有任何效率问题，那么问题肯定就在第二步上面了。&lt;/p&gt;
&lt;h2&gt;解决方案&lt;/h2&gt;
&lt;p&gt;既然初步判断是对象转换的问题，将TestModel这个对象转到定义一看，我地个乖乖，一百来个属性，于是更加坚信自己的分析是正确的。接下来，博主将这一百个字段减少到50个，再次执行发现效率提高了不少，基本在3秒左右，再减少到只剩20个字段，查询时间基本在毫秒级别。原来真是反射赋值的效率问题啊。至于项目为什么会有100个字段的对象，博主也没有想明白，或许真的需要吧！但是由此我们可以得出如下经验：&lt;/p&gt;
&lt;p&gt;1、查询的sql语句里面尽量不要用select * 这种语法，尤其是连表的时候，如果你用了select * ，那有时真的就伤不起了！&lt;/p&gt;
&lt;p&gt;2、如果确定实体里面真的有那么多字段有用（极端的情况），就不要用SqlQuery()了，而改用原生的Ado+DT转List&amp;lt;T&amp;gt;的方式。&lt;/p&gt;

&lt;p&gt;本来以为找到了原因了，正要下结论的时候。听到另一个同事传来了不同的声音：骗纸，你的这个测试程序在我这里跑这么快，哪里有你说的10秒以上！去他那边瞅了一眼，吓我一跳，哪里有什么效率问题，简直快得不要不要的！这就尴尬了，同样的程序，在我这边怎么这么慢呢？&lt;/p&gt;
&lt;p&gt;最后对比一圈下来，发现他那边用的Visual Studio的版本是2017，而我这边是2015。难道真是IDE的环境问题？博主不甘心，在本机装了一个2017，运行程序，依然快得吓人。而关掉2017，再用2015跑，同样需要10秒左右，而且找到其他装了VS 2013的电脑，用2013运行，依然需要10秒左右。好像2017以下的版本速度都会有一些影响。对比各个主要dll的版本，最终找不到任何不同。到这里，博主也没有办法了。如果哪位有解，感谢赐教！&lt;/p&gt;
&lt;p&gt;那就用2017呗，这是最后得出的结论！！！&lt;/p&gt;

&lt;p&gt;以上针对最近遇到的一个问题做了一些记录。如果大家有不同的意见，欢迎交流和斧正！&lt;/p&gt;
&lt;p&gt;本文原创出处：&lt;a href=&quot;http://www.cnblogs.com/landeanfen/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/landeanfen/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎各位转载，但是未经作者本人同意，转载文章之后&lt;strong&gt;必须在文章页面明显位置给出作者和原文连接&lt;/strong&gt;，否则保留追究法律责任的权利&lt;/p&gt;
</description>
<pubDate>Wed, 31 Jan 2018 08:34:00 +0000</pubDate>
<dc:creator>懒得安分</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/landeanfen/p/8392498.html</dc:identifier>
</item>
</channel>
</rss>