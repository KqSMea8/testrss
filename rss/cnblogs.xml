<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一个程序员的自白（无知之者） - wc的一些事一些情</title>
<link>http://www.cnblogs.com/wcd144140/p/9801539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wcd144140/p/9801539.html</guid>
<description>&lt;p&gt;&lt;span&gt;有人说，父母亦老师，但父母并没有告诉他人生是用来折腾而不是用来舒服的；有人告诉他，老师是启蒙者，但老师并没有告诉他，学无止境原来是跟自己的人性死磕到底。有人告诉他，自己才是人生的主导者，但那人并没有告诉他，自己永远无法知道自己不知道的事情。这些真相搞得他在自己面前显得多么地无知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181016235011719-1008985049.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;人生是用来折腾的，不是用来舒服的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;如果有人告诉他，人生是用来折腾的，舒服是留给“躺着”的人的，那么他的大脑就不会总是出现各种“折腾终点”的幻想。如果人生是用来折腾的，那么他的大脑就不应该浪费时间去想那些“人性化”的事情，而是思考有哪些自己可以折腾的或有什么事情是可以经得起数十年的折腾的事情。既然人生是折腾的，那么就不会存在“什么时候可以放假”，“什么时候可以休息”，“什么时候可以退休”等命题，自然而然地更不会去思考什么时候可以一身清闲，什么时候可以财务自由，什么时候可以环游世界的问题。如果没有这些问题的存在，我想他就不会去思考到底多少年薪才算高薪，做到怎么样才算成功，人生到底活成怎么样才算有意义等等这些“毫无意义”的问题。因为人生是用来折腾的，如何才算折腾，看看有哪些事情是别人不愿意做的，去做就对了。别人不愿意6点起床，那你就5点59分起就好；别人喜欢各种好吃，那你就怎么清淡怎么吃就行；别人不愿意学习，那你把行业最基层最难啃的书把它们都啃了准没错;别人不愿意运动，那你每天把自己拉去随便一个能跑上数千米的地方跑一遍就够了；别人喜欢抱着手机24点都不愿意睡觉，那你一回家就把手机丢一旁23点准时趟床上你应该会很难受。如果早知道这个真相，我想他就不会浪费那么多精力和情绪在无谓中挣扎了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181016235041509-504435602.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;学无止境，说白了就是跟自己死磕到底&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 我问他，学习累吗？累，肯定累。那你平时怎么学习？看书和订阅号。看的都是什么书？别人看不下去的书。订阅的都是什么号？只看两个号，一个是不断告诉我人生是用来折腾这个事实的号，另一个是不断告诉我怎么可以自我折腾的号。我想，他受够了那些不正确的输入，所以他只会认可那些“肯定”正确的事情以及不会去做那些“肯定”错误的事情。所以去发觉人生有什么事情是‘“绝对”正确的，他发现了大家都认同的一个观点——“活到老学到老”。同时他还去寻找不认同这个答案的存在，但他没有找到反驳这个观点的答案，所以他得出学习是“绝对”正确的结论。但他在学习的过程中，发现学得很疲惫，因为他不知道原来持续的学习是那么的累。特别是做一些跟自己所想有极大反差的思想是无比痛苦。他带着“学习累吗”的问题去问遍了整个互联网，没有找到“学习不累”的论证，更多都是视学习为逆人性行为。在“人生需要持续的学习”和“学习是一件逆人性的事情”的两个充分且必要（必要是因为他只做正确的事情）的条件下，成为了“人生是用来折腾”的论点之一。面对这样一个具有客观逻辑的事实下，他接受了学无止境就是一个跟自己死磕的事实观点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181016235108241-510633106.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;自己永远不知道自己不知道的事情&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 别人告诉的他的这个“论点”时，他无法反驳，说明这又是一个真命题。但现实中，我们自己好像永远知道自己不知道的事情一样而做出各种“自以为是”的想法和行为。认真观察一番，行为需要认知指导，他在根据自己的“默认值”或者根据各种外界潜移默化的输入作为标准去引导自己。既然自己永远不知道自己不知道的事情，那如何去建立自己的标准？很简单，只有一个办法，那就是去学习，去思考，去论证。这又可以反过来解释学习的“绝对”正确。在人生需要学习以及学习的逆人性的两个充分又必要的条件下得出了人生就是各种折腾的过程。在这几个铁一般的事实面前，他还会有什么理由可以抵抗呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181016235158369-1391585345.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;写到最后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 情绪是各种预期与现实之间的巨大反差。原来一本书可以这么厚，原来一碗青菜可以那么的素，原来1千米的距离那么的长，原来22点是那么的早……原来这些通通都是毫无逻辑和毫无依据的虚实。在这三个真相面前，他输入的99％信息和情绪都经不起推敲的，除非他不承认逻辑的存在。所以他终于知道了不是社会浮躁的虚实，而是自己缺少本质的认知导致自身浮躁所造成的假象。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Oct 2018 15:53:00 +0000</pubDate>
<dc:creator>wc的一些事一些情</dc:creator>
<og:description>有人说，父母亦老师，但父母并没有告诉他人生是用来折腾而不是用来舒服的；有人告诉他，老师是启蒙者，但老师并没有告诉他，学无止境原来是跟自己的人性死磕到底。有人告诉他，自己才是人生的主导者，但那人并没有告</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wcd144140/p/9801539.html</dc:identifier>
</item>
<item>
<title>单例模式 - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/9801530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/9801530.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;具体可以参考博文地址：&lt;/span&gt;https://www.cnblogs.com/garryfu/p/7976546.html&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;定义&lt;/span&gt;：某个类仅有一个唯一的实例，并且提供一个全局的访问点来访问这一实例。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　1.该类只能有一个实例&lt;/p&gt;
&lt;p&gt;　　2.必须是自己创建的这一个唯一的实例&lt;/p&gt;
&lt;p&gt;　　3.必须自己向整个系统提供这个实例&lt;/p&gt;

&lt;p&gt;&lt;span&gt;代码实现&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　1.目的是一个类只有一个实例，并且提供全局的访问点&lt;/p&gt;
&lt;p&gt;　　2.包含的角色只有一个&lt;/p&gt;
&lt;p&gt;　　3.构造函数是私有的，无法通过new对象的方式创建实例&lt;/p&gt;
&lt;p&gt;　　4.有一个静态的私有成员变量和静态的共有的工厂方法&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　1.单例类构造器的可见行为private&lt;/p&gt;
&lt;p&gt;　　2.提供一个类型为自身的静态私有成员变量&lt;/p&gt;
&lt;p&gt;　　3.提供共有的静态工厂方法&lt;/p&gt;

&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1.严格控制客户程序访问其唯一的实例。&lt;/p&gt;
&lt;p&gt;　　2.单例类可以自带一些子类，它的每个子类都是单例类。&lt;/p&gt;
&lt;p&gt;　　3.该模式的类可以比较容易允许创建一定数目的对象类。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　1.单例模式，没有抽象层，扩展比较困难&lt;/p&gt;
&lt;p&gt;　　2.在一定程度上违背了单一职责原则&lt;/p&gt;
&lt;p&gt;　　3.容易导致单例状态丢失，系统存在垃圾回收机制，长时间不使用，会被系统自动回收，再次使用就需要再次实例&lt;/p&gt;
&lt;p&gt; 、&lt;/p&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201810/1488757-20181016231941951-1151997876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.创建一个Singleton类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有构造器&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt;  Singleton(){}

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有的Singleton对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  Singleton instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getInstance(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  Say(){
        System.out.println(&lt;/span&gt;&quot;Hello Singleton&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 2.创建TestSingleton类：&lt;/p&gt;
&lt;p&gt;在类里使用new 的方法是会报错的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSingleton {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

       &lt;span&gt; Singleton singleton &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; Singleton.getInstance();&lt;/span&gt;

        singleton.Say();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.运行结果是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Hello Singleton
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 单例模式的其他实现方式：&lt;/p&gt;
&lt;p&gt;1.懒汉式，线程不安全&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否 Lazy 初始化：&lt;/strong&gt;是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否多线程安全：&lt;/strong&gt;否&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现难度：&lt;/strong&gt;易&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。&lt;br/&gt;这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
   &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt;  Singleton instance;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){};

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt;  Singleton getInstance(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            instance &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.懒汉式，线程安全&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否 Lazy 初始化：&lt;/strong&gt;是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否多线程安全：&lt;/strong&gt;是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现难度：&lt;/strong&gt;易&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。&lt;br/&gt;优点：第一次调用才初始化，避免内存浪费。&lt;br/&gt;缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。&lt;br/&gt;getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;懒汉式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt;  Singleton instance;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){};

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;   Singleton getInstance(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            instance &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.饿汉式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否 Lazy 初始化：&lt;/strong&gt;否&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否多线程安全：&lt;/strong&gt;是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现难度：&lt;/strong&gt;易&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;这种方式比较常用，但容易产生垃圾对象。&lt;br/&gt;优点：没有加锁，执行效率会提高。&lt;br/&gt;缺点：类加载时就初始化，浪费内存。&lt;br/&gt;它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt;  Singleton(){}
&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  Singleton instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getInstance(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.双检锁/双重校验锁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK 版本：&lt;/strong&gt;JDK1.5 起&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否 Lazy 初始化：&lt;/strong&gt;是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否多线程安全：&lt;/strong&gt;是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现难度：&lt;/strong&gt;较复杂&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;这种方式采用双锁机制，安全且在多线程情况下能保持高性能。&lt;br/&gt;getInstance() 的性能对应用程序很关键。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton instance;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){}

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt;&lt;span&gt;  Singleton getInstance(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;synchronized (Singleton.class) {
                if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    instance &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  instance;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;5.登记式/静态内部类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否 Lazy 初始化：&lt;/strong&gt;是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否多线程安全：&lt;/strong&gt;是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现难度：&lt;/strong&gt;一般&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singletontest{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;final &lt;/span&gt;Singleton &lt;span&gt;INSTANCE&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){};
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;final&lt;/span&gt;&lt;span&gt;  Singleton getInstance(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Singletontest.INSTANCE;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;备注：&lt;/p&gt;
&lt;p&gt;代码部分的实现以及部分讲解来源于：http://www.runoob.com/design-pattern/singleton-pattern.html&lt;/p&gt;

</description>
<pubDate>Tue, 16 Oct 2018 15:48:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>具体可以参考博文地址：https://www.cnblogs.com/garryfu/p/7976546.html 单例模式 定义：某个类仅有一个唯一的实例，并且提供一个全局的访问点来访问这一实例。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/9801530.html</dc:identifier>
</item>
<item>
<title>第20天  内置模块一 - 沉沦的罚</title>
<link>http://www.cnblogs.com/huwentao/p/9791370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huwentao/p/9791370.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;人生三问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;. 内置模块是什么&lt;br/&gt;　　内置模块就是python编译器里面自带的一些模块，我们没有必要去写，但是可以直接使用！
&lt;/span&gt;2&lt;span&gt;. 为什么要使用内置模块&lt;br/&gt;　　在日常工作中，我们需要去写一些模块去解决一些特定的功能，但是对于一些比较常用的功能，python解释器已经帮我们写好了，你说你是想直接拿来就用呢？还是再自己去写一个模块，当然是直接用啊。
&lt;/span&gt;3. 内置模块怎么使用&lt;br/&gt;　　内置模块和我们自定义的模块是一样的，通过import和from导入进行使用
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;介绍的模块：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;time
datetime&lt;br/&gt;sys&lt;br/&gt;shutil&lt;br/&gt;random&lt;br/&gt;os&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块一： time&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. 时间戳&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.time()  # 代表的是从1970年开始到现在经过的秒数
&lt;/span&gt;1539593357.4160235   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 结构化时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.localtime()  # 通过localtime方法获得当前系统的结构化时间
time.struct_time(tm_year&lt;/span&gt;=2018, tm_mon=10, tm_mday=15, tm_hour=16, tm_min=49, tm_sec=56, tm_wday=0, tm_yday=288, tm_isdst=&lt;span&gt;0)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a =&lt;span&gt; time.localtime()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; a.tm_year   # 可以通过.后面跟上属性查看相应的值
&lt;/span&gt;2018
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 格式化字符串时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  # 通过输入%多少来获得对应的值
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-10-15 16:57:24&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 格式化的标准：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_5b648caf-0a13-4c4d-9854-3eed2e3ec16d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5b648caf-0a13-4c4d-9854-3eed2e3ec16d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5b648caf-0a13-4c4d-9854-3eed2e3ec16d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
%&lt;span&gt;a    Locale’s abbreviated weekday name.     
&lt;/span&gt;%&lt;span&gt;A    Locale’s full weekday name.     
&lt;/span&gt;%&lt;span&gt;b    Locale’s abbreviated month name.     
&lt;/span&gt;%&lt;span&gt;B    Locale’s full month name.     
&lt;/span&gt;%c    Locale’s appropriate date &lt;span&gt;and&lt;/span&gt;&lt;span&gt; time representation.     
&lt;/span&gt;%d    Day of the month as a decimal number [01,31&lt;span&gt;].     
&lt;/span&gt;%H    Hour (24-hour clock) as a decimal number [00,23&lt;span&gt;].     
&lt;/span&gt;%I    Hour (12-hour clock) as a decimal number [01,12&lt;span&gt;].     
&lt;/span&gt;%j    Day of the year as a decimal number [001,366&lt;span&gt;].     
&lt;/span&gt;%m    Month as a decimal number [01,12&lt;span&gt;].     
&lt;/span&gt;%M    Minute as a decimal number [00,59&lt;span&gt;].     
&lt;/span&gt;%p    Locale’s equivalent of either AM &lt;span&gt;or&lt;/span&gt; PM.    (1&lt;span&gt;)
&lt;/span&gt;%S    Second as a decimal number [00,61].    (2&lt;span&gt;)
&lt;/span&gt;%U    Week number of the year (Sunday as the first day of the week) as a decimal number [00,53]. All days &lt;span&gt;in&lt;/span&gt; a new year preceding the first Sunday are considered to be &lt;span&gt;in&lt;/span&gt; week 0.    (3&lt;span&gt;)
&lt;/span&gt;%w    Weekday as a decimal number [0(Sunday),6&lt;span&gt;].     
&lt;/span&gt;%W    Week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days &lt;span&gt;in&lt;/span&gt; a new year preceding the first Monday are considered to be &lt;span&gt;in&lt;/span&gt; week 0.    (3&lt;span&gt;)
&lt;/span&gt;%&lt;span&gt;x    Locale’s appropriate date representation.     
&lt;/span&gt;%&lt;span&gt;X    Locale’s appropriate time representation.     
&lt;/span&gt;%y    Year without century as a decimal number [00,99&lt;span&gt;].     
&lt;/span&gt;%&lt;span&gt;Y    Year with century as a decimal number.     
&lt;/span&gt;%z    Time zone offset indicating a positive &lt;span&gt;or&lt;/span&gt; negative time difference &lt;span&gt;from&lt;/span&gt; UTC/GMT of the form +HHMM &lt;span&gt;or&lt;/span&gt; -HHMM, where H represents decimal hour digits &lt;span&gt;and&lt;/span&gt; M represents decimal minute digits [-23:59, +23:59&lt;span&gt;].     
&lt;/span&gt;%Z    Time zone name (no characters &lt;span&gt;if&lt;/span&gt;&lt;span&gt; no time zone exists).     
&lt;/span&gt;%%    A literal &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; character.
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;格式化字符串的时间格式&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 4. 三种时间格式之间的转换&lt;/p&gt;
&lt;p&gt;因为计算机认识的时间格式只有时间戳的格式，但是对于我们人类而言，时间戳的格式又太难懂，因此我们把时间戳的格式转换成【结构化的时间】或者是【格式化字符串的时间】类型，转换关系如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201810/1181163-20181015170451404-1870248891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5. 时间的转换&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#------------------------------------------------按照图1中的关系进行时间的转换&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 时间之间的转换操作&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义三个类型的时间&lt;/span&gt;
a = time.time()     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到时间戳&lt;/span&gt;
b = time.localtime()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结构化时间&lt;/span&gt;
c = time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H-%M-%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式化字符串时间&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结构化时间转为时间戳和格式化字符串时间的两种方式&lt;/span&gt;
d =&lt;span&gt; time.mktime(b)
e &lt;/span&gt;= time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, b)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 时间戳转换成结构化时间&lt;/span&gt;
f =&lt;span&gt; time.localtime(a)
g &lt;/span&gt;=&lt;span&gt; time.gmtime(a)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式化字符串时间转化为结构化时间&lt;/span&gt;
h = time.strptime(c, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H-%M-%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  # c是什么样格式的后面的格式就要写成什么样格式的
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201810/1181163-20181015172901770-1495628699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 6. 图二的两种方式其实就是把时间转换成外国人能够接受的时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ---------------------------按照图二的方式进行时间的转换&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果不进行传参，ctime和asctime得到得是一样的效果，都是转换成【week month day time year】&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.asctime()   
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mon Oct 15 18:23:37 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.ctime()
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mon Oct 15 18:23:44 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果进行传参&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; a =&lt;span&gt; time.time()  # 先得到时间戳
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; b =&lt;span&gt; time.localtime()   # 得到结构化时间
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.asctime(b)   # 通过asctime把结构化时间转换成固定的外国人接受的时间
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mon Oct 15 18:28:12 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.ctime(a)  # 通过ctime将时间戳转换成外国人能够接受的时间
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mon Oct 15 18:28:06 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块二：datatime&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(datetime.datetime.now())   # 通过datetime的now方法获取当前时间格式
&lt;/span&gt;2018-10-15 18:40:17.028194
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; datetime.datetime.fromtimestamp(time.time())
datetime.datetime(&lt;/span&gt;2018, 10, 15, 18, 40, 34, 551056&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(datetime.datetime.fromtimestamp(time.time()))  # 通过fromtimestamp转换成相应的时间格式
&lt;/span&gt;2018-10-15 18:40:57.722764
&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;datetime重要的作用，用来做时间的加减&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(datetime.datetime.now())　　# 展示现在的时间 格式为   【year:month:day hour:minute:second 】
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(datetime.datetime.fromtimestamp(time.time()))   # 将时间戳转换成datetime的形式



&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  当前时间加减三天&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(datetime.datetime.now() + datetime.timedelta(3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(datetime.datetime.now() + datetime.timedelta(-3&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前时间加减三个小时&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(datetime.datetime.now() + datetime.timedelta(hours=3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(datetime.datetime.now() + datetime.timedelta(hours=-3&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前时间加减三十分钟&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(datetime.datetime.now() + datetime.timedelta(minutes=30&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(datetime.datetime.now() + datetime.timedelta(minutes=-30))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;替换：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
c_time =&lt;span&gt; datetime.datetime.now()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c_time, type(c_time))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(c_time.replace(month=11, year=2020, minute=10&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(c_time)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块三： sys模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
sys模块(python解释器相关的)
    1. sys.argv    # 这个是传入的参数，返回的是列表的形式，第一个是当前执行文件的名称
    2. sys.path　　 # 系统的环境变量，可以通过append方法进行更改
    3. sys.modules　　# 内存已经加载的模块，以字典的形式存在
    4. sys.version　　# 解释器的版本
    5. sys.platform   # 当前执行的平台
    6. sys.exit()    # 退出当前执行的python解释器

    # 了解
    7. sys.api_version   # api版本号
    8. sys.maxsize　　# 最大值得整数32位为 2 ** 32 - 1 64位为2 ** 64 -1 
    9. sys.maxunicode   # 最大的unicode  0x10FFFF 
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54.5&quot;&gt;&lt;img id=&quot;code_img_closed_f6b59634-c873-42dd-84f2-43e106679f76&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f6b59634-c873-42dd-84f2-43e106679f76&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f6b59634-c873-42dd-84f2-43e106679f76&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;104&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; sys.version
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:04:45) [MSC v.1900 32 bit (Intel)]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; sys.api_version
&lt;/span&gt;1013
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; sys.platform
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;win32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; sys.path
[&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\python36.zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\DLLs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\site-packages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; ays.maxunicode
Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;stdin&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 1, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;span&gt;
NameError: name &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ays&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; defined
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; sys.maxunicode
&lt;/span&gt;1114111
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; sys.maxsize
&lt;/span&gt;2147483647
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; sys.modules
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;builtins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;builtins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_frozen_importlib&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_frozen_importlib&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (frozen)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_imp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_imp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_warnings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_warnings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_thread&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_thread&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_weakref&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_weakref&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_frozen_importlib_external&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_frozen_importlib_external&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (frozen)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_io&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;marshal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;marshal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;nt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;nt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;winreg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;winreg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zipimport&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zipimport&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;encodings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;encodings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\encodings\\__init__.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;codecs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;codecs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\codecs.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_codecs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_codecs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;encodings.aliases&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;encodings.aliases&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\encodings\\aliases.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;encodings.utf_8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;encodings.utf_8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\encodings\\utf_8.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_signal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_signal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;encodings.latin_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;encodings.latin_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\encodings\\latin_1.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\io.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\abc.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_weakrefset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_weakrefset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\_weakrefset.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;site&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;site&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\site.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;os&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;os&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\os.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;errno&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;errno&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;stat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;stat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\stat.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_stat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_stat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ntpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ntpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\ntpath.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;genericpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;genericpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\genericpath.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;os.path&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ntpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\ntpath.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_collections_abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_collections_abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\_collections_abc.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_sitebuiltins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_sitebuiltins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\_sitebuiltins.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sysconfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sysconfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\software\\python3\\lib\\sysconfig.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;atexit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;atexit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; sys.exit()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;sys模块常见的使用方法&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; argv的应用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_4008f5db-23a7-4f72-a8ca-2e7a51a9e456&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4008f5db-23a7-4f72-a8ca-2e7a51a9e456&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4008f5db-23a7-4f72-a8ca-2e7a51a9e456&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 源文件为python解释器第二个参数&lt;/span&gt;
src_file = sys.argv[1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 目的文件问传入的第三个参数&lt;/span&gt;
dst_file = sys.argv[2&lt;span&gt;]

with open(src_file, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) as read_f, open(dst_file, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as write_f:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; read_f:
        write_f.write(line)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在终端中 执行当前文件&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; C:\Users\Administrator&amp;gt;python H:\python_study\day20\内容回顾.py H:\python_study\day20\test2.py H:\python_study\day20\test22.py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;copy文件时当做参数使用&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;sys的应用（进度条）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_8d8e7fed-e91c-4643-b1fa-c98043b64430&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8d8e7fed-e91c-4643-b1fa-c98043b64430&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8d8e7fed-e91c-4643-b1fa-c98043b64430&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; progress(percent, width=50&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当百分比大于1的时候都按照1来显示&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; percent &amp;gt;= 1&lt;span&gt;:
        percent &lt;/span&gt;= 1
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; '[%%-%ds]' % width  ====&amp;gt; %-50s&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 然后通过格式化得到我们想要的值&lt;/span&gt;
    show_str = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[%%-%ds]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % width) % (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; * int((width *&lt;span&gt; percent)))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最后打印的时候加上百分比&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{show_str} {percent}%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(
        show_str&lt;/span&gt;=&lt;span&gt;show_str,
        percent&lt;/span&gt;=int(percent * 100&lt;span&gt;)
    ))


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟下载数据数据大小为1024567&lt;/span&gt;
data_size = 1024567&lt;span&gt;
recv_size &lt;/span&gt;=&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; recv_size &amp;lt;&lt;span&gt; data_size:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟数据延迟0.1秒&lt;/span&gt;
    time.sleep(0.1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每次下载1024&lt;/span&gt;
    recv_size += 1024
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到百分比打印&lt;/span&gt;
    percent = recv_size /&lt;span&gt; data_size
    progress(percent)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;模拟下载数据显示打印条&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 模块四：random&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

random.random()   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到一个（0-1）之间的浮点数&lt;/span&gt;
random.uniform(1, 3)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到一个(1, 3)之间的一个小数&lt;/span&gt;
&lt;span&gt;
random.randint(&lt;/span&gt;1, 3)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到一个[1, 3]之间的整数&lt;/span&gt;
random.randrange(1, 3)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到一个[1, 3)之间的一个整数&lt;/span&gt;
&lt;span&gt;
random.choice([&lt;/span&gt;1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [4, 5]])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获得列表中的一个值&lt;/span&gt;
random.choices([1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [4, 5]], k=2)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获得列表中的两个值返回一个列表&lt;/span&gt;
random.sample([1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [4, 5]], k=2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列表元素任意2个组合&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打乱顺序&lt;/span&gt;
l = [1,2,3,4,5&lt;span&gt;]
random.shuffle(l) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传递的必须是一个列表&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(l)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成一个随机验证码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_d13d990a-f89f-45ac-8f92-cff665e6bd72&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d13d990a-f89f-45ac-8f92-cff665e6bd72&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d13d990a-f89f-45ac-8f92-cff665e6bd72&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 验证码包含数字和字母&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_auth_code(num):
    temp_list &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; num:
        num &lt;/span&gt;-= 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 首先获得数字&lt;/span&gt;
        a = str(random.randint(0, 10&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 其次获得字符&lt;/span&gt;
        b = chr(random.randint(0, 120&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加到列表中&lt;/span&gt;
&lt;span&gt;        temp_list.append(random.choice([a, b]))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp_list

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;.join(get_auth_code(4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;随机验证码的生成&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块五： shutil&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
shutil 高级的文件，文件夹，压缩包处理模块

文件处理：
    shutil.copyfileobj  传入的是两个对象，源文件，目的文件
    shutil.copyfile     传入的是两个路径，原路径，目的路径
    shutil.copymode     只复制文件的权限，目的恩瑾可定是要存在
    shutil.copystat     只复制文件的状态信息，修改时间，查看时间，更改时间，flag是
    shutil.copy         拷贝文件和权限
    shutil.copy2        拷贝文件和状态信息
    shutil.move()       更改文件名称
文件夹处理
    shutil.copytree     拷贝目录
    shutil.ignore_patterns  根据这个模块去设置是否不拷贝某个类型的文件
    shutil.rmtree       删除目录
压缩包处理
    shutil.make_archive()    压缩后的目录名称，格式，源目录
    shutile.unpack_archive() 压缩后的目录名称， 格式，解压后的目录
    
    tarfile.open().add() 
    zipfile.ZipFile().write()
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;文件的操作：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方法1： copyfileobj:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方法copyfileobj&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 我们要首先得到两个打开的文件对象&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; src就是源文件对象&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; dst目标文件对象&lt;/span&gt;
src = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
dst &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块2.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
shutil.copyfileobj(src, dst)
src.close()
dst.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法2: copyfile &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 和方法1类似，只不过它传递的是路径，而方法1传递的是对象&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 拷贝一个文件，而不是一个对象，目标文件可以不存在&lt;/span&gt;
shutil.copyfile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块3.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法3：copymode&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拷贝源文件的权限，在linux下面就是xrw之类的&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 但是它的内容，用户，组都是不变的&lt;/span&gt;
shutil.copymode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块2.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  # 目标文件必须要存在
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法4： copystat&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拷贝源文件的状态信息&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 包括权限，查看时间，修改时间，flags等&lt;/span&gt;
shutil.copystat(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块2.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法5： copy2和copy&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拷贝的是文件的内容和权限&lt;/span&gt;
shutil.copy(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块4.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拷贝的是文件的内容和状态&lt;/span&gt;
shutil.copy2(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块5.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;文件夹操作：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方法1：copytree&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拷贝一个目录，目标目录不能存在，而且还要对其父目录可以有写权限&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; symlinks 代表的是软连接，就相当于是一个快捷方式&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; shutil.ignore_patterns拷贝的时候把符合模式的给删除掉就是了&lt;/span&gt;
&lt;span&gt;shutil.ignore_patterns()
shutil.copytree(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;..\day20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;forlder3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                ignore&lt;/span&gt;=shutil.ignore_patterns(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*pyc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tmp*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
                symlinks&lt;/span&gt;=&lt;span&gt;True
                )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法2：rmtree&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 递归的删除一个文件夹&lt;/span&gt;
shutil.rmtree(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;forlder2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法3：move&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 就像是linux下面的重命名mv命令&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数一为源文件名，参数二为目标文件名&lt;/span&gt;
shutil.move(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;forlder3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;forlder2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;压缩文件夹&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方法1： make_archive&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数一：压缩之后的名字&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数二: 以什么样的格式压缩，可以是zip,tar,bztar, gztar&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数三: 要压缩的目录&lt;/span&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
owner：    用户，默认当前用户
group：    组，默认当前组
logger：    用于记录日志，通常是logging.Logger对象
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
shutil.make_archive(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;forlder2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, root_dir=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../day20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解压文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方法1：unpack_archive&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先打包一份zip的文件&lt;/span&gt;
shutil.make_archive(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;day19&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, root_dir=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;..\day19&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解压文件，要加上后缀名称&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数一: 解压的文件&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; format: 解压的格式&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; extract_dir: 解压的目录&lt;/span&gt;
shutil.unpack_archive(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;day19.zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, format=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,extract_dir=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法2：tarfile模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tarfile
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 压缩&lt;/span&gt;
t = tarfile.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;day.tar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
t.add(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
t.add(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块2.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
t.add(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块3.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
t.close()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解压&lt;/span&gt;
t = tarfile.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;day.tar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
t.extractall(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./day&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
t.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法3:  zipfile模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; zipfile
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 压缩&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 首先得到一个zipfile的对象，然后通过write压缩进对象中&lt;/span&gt;
z = zipfile.ZipFile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;day.zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
z.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
z.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块2.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
z.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sys模块3.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
z.close()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解压&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 也是先得到对象，然后通过extractall获得对象&lt;/span&gt;
z = zipfile.ZipFile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;day.zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
z.extractall(path&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./day&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
z.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块六：os模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
os模块： 指的是和操作系统相关的模块

1. 目录操作
    增
        os.mkdir     创建一个单级目录
        os.makedirs  创建多级目录，递归创建
    删
        os.rmdir     删除一个目录
        os.removedirs  递归删除目录，如果目录为空
    改
        chdir       改变当前目录
        pardir      当前执行目录的父目录
        curdir      当前执行文件的目录
    查
        getcwd()    获得当前解释器执行文件目录
        listdir()   以列表的形式返回当前目录下面有什么内容
2. 文件操作
    删
        os.remove()   删除文件
    改
        os.rename()   修改文件名称
    查
        os.stat        查看当前文件的状态信息
        os.path.getsize()   查看当前文件的大小
        os.path.getatime()   查看当前文件的创建时间
        os.path.getmtime()   查看当前文件的修改时间
3. 变量信息
    os.stat     # 文件的状态信息
    os.name     # win是‘nt’， linux平台是'posix'
    os.sep      # 操作系统特定的路径分隔符
    os.linesep  # 换行符win为'\t\n', linux为'\t'
    os.pathsep  # 分割文件路径的字符串win为;, linux为：
    os.environ  # 系统环境变量
    os.system() # 运行shell命令，直接显示
4. 路径的判断
    os.path.exists()   # 判断路径是否存在
    os.path.isfile()   # 判断是否是个文件
    os.path.isdir()    # 判断是否是个目录
    os.path.join()     # 拼接路径
5. 路径操作
    os.path.split()  # 以列表的形式返回文件名和目录
    os.path.basename # 获得得就是split的文件名
    os.path.dirname  # 获得得就是split的目录
5. 规范化路径
    os.path.normcase()  # 将大写变小写，并将所有斜杠转成反斜杠(返回的是原字符串)
    os.path.normpath()  # 会把反斜杠转换成斜杠，然后可以识别相对路径
    os.path.abspath()   # 返回path规范化的绝对路径

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一般路径的处理使用这种方式&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os, sys

TOP_DIR &lt;/span&gt;=&lt;span&gt; os.path.normpath(os.path.join(
    os.path.abspath(&lt;/span&gt;&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;),
    os.pardir,
))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(TOP_DIR)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不建议使用下面这种方式&lt;/span&gt;
TOP_DIR = os.path.dirname(os.path.dirname(&lt;span&gt;__file__&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;在Linux和Mac平台上，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为饭斜杠。
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; os.path.normcase(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c:/windows\\system32\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)   
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c:\\windows\\system32\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   
   

规范化路径，如..和&lt;/span&gt;/
&amp;gt;&amp;gt;&amp;gt; os.path.normpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c://windows\\System32\\../Temp/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)   
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c:\\windows\\Temp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   

&amp;gt;&amp;gt;&amp;gt; a=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/Users/jieli/test1/\\\a1/\\\\aa.py/../..&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(os.path.normpath(a))
&lt;/span&gt;/Users/jieli/test1
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 16 Oct 2018 15:26:00 +0000</pubDate>
<dc:creator>沉沦的罚</dc:creator>
<og:description>人生三问 介绍的模块： 模块一： time 1. 时间戳 2. 结构化时间 3. 格式化字符串时间 格式化的标准： %a Locale’s abbreviated weekday name. %A L</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huwentao/p/9791370.html</dc:identifier>
</item>
<item>
<title>Unity游戏神经网络版坦克大战 - 卧龙浪士</title>
<link>http://www.cnblogs.com/pojdd/p/9801400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pojdd/p/9801400.html</guid>
<description>&lt;p&gt;基于遗传算法优化的神经网络来训练坦克AI是什么体验呢？下面有bulid好的demo。&lt;/p&gt;
&lt;p&gt;包括window和安卓两个版本。&lt;/p&gt;
&lt;p&gt;这是一个Unity项目。&lt;/p&gt;
&lt;p&gt;下载链接：https://pan.baidu.com/s/1gJr6ZmiHdJqoFW7RUdtRZA&lt;br/&gt;提取码：zi2q&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1215297/201810/1215297-20181016230128156-17560570.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;353&quot;/&gt;&lt;/p&gt;
&lt;p&gt;链接里面还有有一个神经网络训练框架，由于明天还有课，先到这,明天再来更新。&lt;/p&gt;
&lt;p&gt;对了，感谢菠菜大佬的分享。&lt;/p&gt;

</description>
<pubDate>Tue, 16 Oct 2018 15:15:00 +0000</pubDate>
<dc:creator>卧龙浪士</dc:creator>
<og:description>基于遗传算法优化的神经网络来训练坦克AI是什么体验呢？下面有bulid好的demo。 包括window和安卓两个版本。 这是一个Unity项目。 下载链接：https://pan.baidu.com/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pojdd/p/9801400.html</dc:identifier>
</item>
<item>
<title>Ubuntu Server下docker实战 02: docker进阶配置 - Coolincy</title>
<link>http://www.cnblogs.com/Luckey/p/9801306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Luckey/p/9801306.html</guid>
<description>&lt;p&gt;在上一篇文章里&lt;a title=&quot;Ubuntu Server下docker实战 01: 安装docker&quot; href=&quot;https://www.cnblogs.com/Luckey/p/9800939.html&quot; target=&quot;_blank&quot;&gt;《Ubuntu Server下docker实战 01: 安装docker》&lt;/a&gt;，我们已经把docker安装起来了，并运行了一个hello-world&lt;/p&gt;
&lt;p&gt;这一篇，我们继续讲进阶配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 配置docker在系统启动时候自动启动&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; /lib/systemd/systemd-sysv-&lt;span&gt;install&lt;/span&gt;&lt;span&gt; enable docker
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; systemctl enable docker
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; systemctl restart docker.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们重启服务器后，docker服务也自动启动了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 转移docker数据文件路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vi&lt;/span&gt; /etc/default/docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们假设要把数据移动到 /data/docker下，那么在配置文件中添加如下内容，保存退出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
OPTIONS=--graph=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/docker&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H fd:&lt;span&gt;//&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;停止docker&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service docker stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;确认不存在 /data/docker 目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rm&lt;/span&gt; -rf /data/docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;转移文件，将docker数据从/var/lib/docker 移到 /data/docker，并创建连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;mv&lt;/span&gt; /var/lib/docker /data/&lt;span&gt;docker
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;ln&lt;/span&gt; -s /data/docker /var/lib
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动docker&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service docker start
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3. 创建docker子网，docker默认使用 172.17.0.0/24 子网，但我们可能有自己的需要，那么可以通过下面方法创建子网&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显示已有子网&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker network &lt;span&gt;ls&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个172.18.0.0/24的子网&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker network create --subnet=&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; dockernetwork
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看下现在的子网列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker network &lt;span&gt;ls&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NETWORK ID          NAME                DRIVER              SCOPE
b295fdf8279f        bridge              bridge              local
b338774b3d02        dockernetwork       bridge              local
88b7535d052a        host                host                local
79814a08c6d1        none                &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;                local
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 16 Oct 2018 15:08:00 +0000</pubDate>
<dc:creator>Coolincy</dc:creator>
<og:description>在上一篇文章里《Ubuntu Server下docker实战 01: 安装docker》，我们已经把docker安装起来了，并运行了一个hello-world 这一篇，我们继续讲进阶配置。 1. 配置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Luckey/p/9801306.html</dc:identifier>
</item>
<item>
<title>【Maven】---Linux搭建Nexus3.X私服 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9801325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9801325.html</guid>
<description>&lt;p&gt;备注:linux版本: ubuntu 同时已经部署好JDK8环境&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、linux安装nexus&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;   1、创建文件夹并进入该目录&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd /usr/local &amp;amp;&amp;amp; mkdir nexus &amp;amp;&amp;amp; cd nexus&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt; &lt;span&gt; &lt;/span&gt;&lt;span&gt; 2、下载nexus安装包&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget http://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;    3、解压、重命名&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tar -zxvf nexus-3.6.0-02-unix.tar.gz&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解压&lt;/span&gt;
&lt;span&gt;mv nexus-3.6.0-02  nexus &lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重命名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;   4、自定义配置虚拟机可打开 nexus.vmoptions 文件进行配置&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;   如果Linux硬件配置比较低的话，建议修改为合适的大小，否则会出现运行崩溃的现象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# vim nexus/bin/nexus.vmoptions&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚拟机选项配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;    5、启动nexus&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;启动 Nexus（默认端口是8081），Nexus 常用的一些命令包括：&lt;span&gt;/usr/local/nexus/nexus/bin/nexus {start|stop|run|run-redirect|status|restart|force-reload}&lt;/span&gt;，下面我们启动Nexus：&lt;/p&gt;
&lt;p&gt;启动命令：&lt;span&gt;bin/nexus start&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181016223617737-2126696279.png&quot; alt=&quot;&quot; width=&quot;836&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明已经安装启动成功，上面报错意思是nexus建议不要用root用户来启动nexus，但并不影响启动,如果要去除这个可以百度。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;6、其它说明&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;   1）&lt;span&gt;Nexus默认的端口是8081&lt;/span&gt;，可以在etc/nexus-default.properties配置中修改。&lt;/p&gt;
&lt;p&gt;   2）&lt;span&gt;Nexus默认的用户名密码是admin/admin123&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   3）当遇到奇怪问题时，重启nexus，启动时间会比较慢 要1分钟左右后才能访问。&lt;/p&gt;
&lt;p&gt;   4）Nexus的工作目录是sonatype-work（路径一般在nexus同级目录下）&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、仓库介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当访问：&lt;span&gt;http://ip:8081/&lt;/span&gt; 会有nexus界面&lt;/p&gt;
&lt;p&gt;用户登陆，进入Repositories页面点击Nexus“Log in”，输入默认用户名（admin）和默认密码（admin123）登录。后找到Repositories&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181016224027598-166654223.png&quot; alt=&quot;&quot; width=&quot;836&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;    1、四种仓库类型介绍&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;默认仓库介绍&lt;/p&gt;
&lt;p&gt;   1）&lt;span&gt;maven-central：&lt;/span&gt;      maven中央库，默认从https://repo1.maven.org/maven2/拉取jar&lt;/p&gt;
&lt;p&gt;   2）&lt;span&gt;maven-releases&lt;/span&gt;：   私库发行版jar&lt;/p&gt;
&lt;p&gt;   3）&lt;span&gt;maven-snapshots：&lt;/span&gt;私库快照（调试版本）jar&lt;/p&gt;
&lt;p&gt;   4）&lt;span&gt;maven-public：&lt;/span&gt;     仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置settings.xml中使用。&lt;/p&gt;
&lt;p&gt;Nexus默认的仓库类型有以下四种：（上面的名字可以随便取，关键是它对应的是什么仓库类型）&lt;/p&gt;
&lt;p&gt;   1）&lt;span&gt;group(仓库组类型)&lt;/span&gt;：又叫组仓库，用于方便开发人员自己设定的仓库；&lt;/p&gt;
&lt;p&gt;   2）&lt;span&gt;hosted(宿主类型)&lt;/span&gt;：内部项目的发布仓库（内部开发人员，发布上去存放的仓库）；&lt;/p&gt;
&lt;p&gt;   3）&lt;span&gt;proxy(代理类型)&lt;/span&gt;：  从远程中央仓库中寻找数据的仓库（可以点击对应的仓库的Configuration页签下Remote Storage Location属性的值即被代理的远程仓库的路径）；&lt;/p&gt;
&lt;p&gt;   4）&lt;span&gt;virtual(虚拟类型)&lt;/span&gt;： 虚拟仓库（这个基本用不到，重点关注上面三个仓库的使用）；&lt;/p&gt;
&lt;p&gt;Policy(策略):&lt;span&gt;表示该仓库为发布(Release)版本仓库还是快照(Snapshot)版本仓库；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;    2、仓库拉取jar包流程&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1）Maven可直接从宿主仓库下载构件,也可以从代理仓库下载构件,而代理仓库间接的从远程仓库下载并缓存构件&lt;/p&gt;
&lt;p&gt;2）为了方便,Maven可以从仓库组下载构件,而仓库组并没有时间的内容(下图中用虚线表示,它会转向包含的宿主仓库或者代理仓库获得实际构件的内容).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181016224719851-667721849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、创建新用户和新仓库&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;   1、创建用户&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;登陆admin后，可以点击上面的“设置”图标，在“设置”里可以添加用户、角色，对接LDAP等的设置，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181016224833277-1622519547.png&quot; alt=&quot;&quot; width=&quot;565&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181016224911126-89863328.png&quot; alt=&quot;&quot; width=&quot;563&quot; height=&quot;574&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建用户好后，重新登陆创建的用户&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181016225005299-840513500.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;264&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;    2、创建仓库&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;上面对仓库的概率清楚后，我们开始创建新仓库，主要创建3个仓库&lt;/p&gt;
&lt;p&gt;  proxy仓库 作用是去远程拉取jar包&lt;/p&gt;
&lt;p&gt;  hosted仓库 作用是存放本地上传的三方jar包&lt;/p&gt;
&lt;p&gt;  group仓库 作用是将上面来个放到这个组里，进行统一管理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）proxy 代理仓库创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中央仓库的代理默认为https://repo1.maven.org/maven2/ 我们可以更换成阿里云中央仓库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181016225156838-665402784.png&quot; alt=&quot;&quot; width=&quot;565&quot; height=&quot;362&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （2）hosted 仓库创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;host仓库这里了两种不同的存储类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181016225441153-468634115.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;458&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181016225527695-801278988.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;461&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）group仓库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要就是把上面三个仓库放到该组里，然后让这个组给外面访问。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181016225647179-559771804.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;424&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全家福来一个&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181016225739260-546842369.png&quot; alt=&quot;&quot; width=&quot;1152&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有关在linux服务器上搭建nexus的工作已经完成，接下来就需要配置maven相关配置文件，来测试该仓库的是否成功，下一篇博客详细写配置信息。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/fa33a9cdab99&quot; target=&quot;_blank&quot;&gt;1、 使用 Nexus 3.x 搭建 Maven2 私服&lt;/a&gt;（对组解释很好）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/smartbetter/article/details/55116889&quot; target=&quot;_blank&quot;&gt;2、 Linux 使用 Nexus3.x 搭建 Maven 私服指南&lt;/a&gt; （一整套讲的还是蛮清晰的）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chenhaifeng2016/article/details/78625280&quot; target=&quot;_blank&quot;&gt;3、linux部署Nexus OSS&lt;/a&gt;（这里面将默认镜像改成了阿里云镜像）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果一个人充满快乐，正面的思想，那么好的人事物就会和他共鸣，而且被他吸引过来。同样，一个人老带悲伤，倒霉的事情也会跟过来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                                     ——在自己心情低落的时候，告诫自己不要把负能量带给别人。（大校1）&lt;/span&gt;&lt;/p&gt;



</description>
<pubDate>Tue, 16 Oct 2018 15:02:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>Linux搭建Nexus3.X私服 备注:linux版本: ubuntu 同时已经部署好JDK8环境 一、linux安装nexus 1、创建文件夹并进入该目录 2、下载nexus安装包 3、解压、重命</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9801325.html</dc:identifier>
</item>
<item>
<title>Jvm垃圾回收器（算法篇） - 致力it</title>
<link>http://www.cnblogs.com/chenpt/p/9799095.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenpt/p/9799095.html</guid>
<description>&lt;p&gt;　　在《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chenpt/p/9797126.html&quot; target=&quot;_blank&quot;&gt;Jvm垃圾回收器（基础篇）&lt;/a&gt;》中我们主要学习了判断对象是否存活还是死亡？两种基础的垃圾回收算法：引用计数法、可达性分析算法。以及Java引用的4种分类：强引用、软引用、弱引用、虚引用。和方法区的回收介绍。&lt;/p&gt;
&lt;p&gt;那么接下来我们重点研究下虚拟机的几种常见的垃圾回收算法：标记-清除算法、复制算法、标记-整理算法、分代收集算法。&lt;/p&gt;
&lt;h2&gt;一：标记-清除算法&lt;/h2&gt;
&lt;p&gt;　　最基础的收集算法，总共分为‘ 标记 ’和‘ 清除 ’两个阶段&lt;/p&gt;
&lt;h3&gt;1.标记&lt;/h3&gt;
&lt;p&gt;　　标记出所有需要回收的对象&lt;/p&gt;
&lt;p&gt;　　在《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chenpt/p/9797126.html&quot; target=&quot;_blank&quot;&gt;Jvm垃圾回收器（基础篇）&lt;/a&gt;》中说明了判断对象是否回收需要两次标记，现在我们再来回顾一下&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;一次标记&lt;/strong&gt;：在经过&lt;span&gt;可达性分析算法&lt;/span&gt;后，对象没有与GC Root相关的引用链，那么则被第一次标记。并且进行一次筛选：当对象有必要执行finalize()方法时，则把该对象放入F-Queue队列中。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;二次标记&lt;/strong&gt;：对F-Queue队列中的对象进行二次标记。在执行finalize()方法时，如果对象重新与GC Root引用链上的任意对象建立了关联，则把他移除出“ 即将回收 ”集合。否则就等着被回收吧！！！&lt;/p&gt;
&lt;p&gt;　　对被第一次标记切被第二次标记的，就可以判定位可回收对象了。&lt;/p&gt;
&lt;h3&gt;2.清除&lt;/h3&gt;
&lt;p&gt;　　两次标记后，还在“ 即将回收 ”集合的对象进行回收。&lt;/p&gt;
&lt;p&gt;　　执行过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1326194/201810/1326194-20181016211110981-747164417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　优点&lt;/strong&gt;：基础最基础的可达性算法，后续的收集算法都是基于这种思想实现的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　缺点&lt;/strong&gt;：标记和清除效率不高，产生大量不连续的内存碎片，导致创建大对象时找不到连续的空间，不得不提前触发另一次的垃圾回收。&lt;/p&gt;
&lt;h2&gt;二：复制算法&lt;/h2&gt;
&lt;p&gt;　　将可用内存按容量分为大小相等的两块，每次只使用其中一块，当这一块的内存用完了，就将还存活的对象复制到另外一块内存上，然后再把已使用过的内存空间一次清理掉。&lt;/p&gt;
&lt;p&gt;　　复制算法执行过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1326194/201810/1326194-20181016212130158-934403846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;优点&lt;/strong&gt;：实现简单，效率高。解决了标记-清除算法导致的内存碎片问题。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;缺点&lt;/strong&gt;：代价太大，将内存缩小了一半。效率随对象的存活率升高而降低。&lt;/p&gt;
&lt;p&gt; 现在的商业虚拟机都采用这种算法（需要改良1:1的缺点）来回收新生代。&lt;/p&gt;
&lt;h3&gt;2.1 HotSpot虚拟机的改良算法　&lt;/h3&gt;
&lt;h4&gt;1.弱代理论　&lt;/h4&gt;
&lt;p&gt;　　分代垃圾收集基于弱代理论。具体描述如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;大多说分配了内存的对象并不会存活太长时间，在处于年轻时代就会死掉。&lt;/li&gt;
&lt;li&gt;很少有对象会从老年代变成年轻代。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　其中IBM研究表明：新生代中98%的对象都是&quot;朝生夕死&quot;； 所以并不需要按1:1比例来划分内存（解决了缺点1）；&lt;/p&gt;
&lt;h3&gt; 2.Hotspot虚拟机新生代内存布局及算法&lt;/h3&gt;
&lt;p&gt;　　新生代内存分配一块较大的Eden空间和两块较小的Survivor空间&lt;/p&gt;
&lt;p&gt;　　每次使用Eden和其中一块Survivor空间&lt;/p&gt;
&lt;p&gt;　　回收时将Eden和Survivor空间中存活的对象一次性复制到另一块Survivor空间上&lt;/p&gt;
&lt;p&gt;　　最后清理掉Eden和使用过的Survivor空间。&lt;/p&gt;
&lt;p&gt;Hotspot虚拟机默认Eden和Survivor的大小比例是8:1。&lt;/p&gt;
&lt;h4&gt;分配担保&lt;/h4&gt;
&lt;p&gt;　　如果另一块Survivor空间没有足够内存来存放上一次新生代收集下来的存活对象，那么这些对象则直接通过担保机制进入老年代。&lt;/p&gt;
&lt;p&gt;关于分配担保的内容，我会在讲述垃圾收集器时详细描述。&lt;/p&gt;
&lt;h2&gt;三：标记-整理算法&lt;/h2&gt;
&lt;p&gt;　　标记-整理算法是根据老年代的特点应运而生。&lt;/p&gt;
&lt;h3&gt;3.1 标记&lt;/h3&gt;
&lt;p&gt;　　标记过程和标记-清理算法一致（也是基于可达性分析算法）。&lt;/p&gt;
&lt;h3&gt;3.2 整理&lt;/h3&gt;
&lt;p&gt;　　和标记-清理不同的是，该算法不是针对可回收对象进行清理，而是根据存活对象进行整理。让存活对象都向一端移动，然后直接清理掉边界以外的内存。&lt;/p&gt;
&lt;p&gt;标记-整理算法示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1326194/201810/1326194-20181016222516407-1839539051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　优点&lt;/strong&gt;：不会像复制算法那样随着存活对象的升高而降低效率，不像标记-清除算法那样产生不连续的内存碎片&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　缺点&lt;/strong&gt;：效率问题，除了像标记-清除算法的标记过程外，还多了一步整理过程，效率更低。&lt;/p&gt;
&lt;h2&gt;四：分代收集算法&lt;/h2&gt;
&lt;p&gt;　　当前商业虚拟机的垃圾收集都是采用“ 分代收集 ”算法。&lt;/p&gt;
&lt;p&gt;根据对象存活周期的不同将内存划分为几块。一般把java堆分为新生代和老年代。JVM根据各个年代的特点采用不同的收集算法。&lt;/p&gt;
&lt;p&gt;新生代中，每次进行垃圾回收都会发现大量对象死去，只有少量存活，因此比较适合复制算法。只需要付出少量存活对象的复制成本就可以完成收集。&lt;/p&gt;
&lt;p&gt;老年代中，因为对象存活率较高，没有额外的空间进行分配担保，所以适合标记-清理、标记-整理算法来进行回收。&lt;/p&gt;


&lt;p&gt;----对《深入理解Java虚拟机》第3章垃圾收集器与内存分配策略 3.3小节总结。接下来总结3.5垃圾收集器。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《深入理解Java虚拟机》&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/tjiyu/article/details/53983064&lt;/p&gt;

</description>
<pubDate>Tue, 16 Oct 2018 14:53:00 +0000</pubDate>
<dc:creator>致力it</dc:creator>
<og:description>在《Jvm垃圾回收器（基础篇）》中我们主要学习了判断对象是否存活还是死亡？两种基础的垃圾回收算法：引用计数法、可达性分析算法。以及Java引用的4种分类：强引用、软引用、弱引用、虚引用。和方法区的回收</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenpt/p/9799095.html</dc:identifier>
</item>
<item>
<title>3DLut表实现log视频的后期调色原理 - 一棹烟波</title>
<link>http://www.cnblogs.com/riddick/p/9801187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/riddick/p/9801187.html</guid>
<description>&lt;p&gt;现在越来越多的视频或者图像拍摄设备支持log模式，比如大疆无人机的D-Log模式等等，log模式的起源和发展就不多做介绍，其在普通显示器上显示画面通常看起来是平坦的灰色，因此也常被称为log灰视频。&lt;/p&gt;
&lt;p&gt;由于其能记录更多的图像细节，动态范围更广，使得后期调色可操作空间更大，所以今天就来说一说怎么用3Dlut表实现log图的调色。&lt;/p&gt;
&lt;p&gt;首先，要准备Log图、3DLut表，如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.Log图长酱紫的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看起来确实是灰灰的，妹子也显得如此的忧郁。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201810/1138496-20181016231359849-1188399261.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.  3DLut表内容是酱紫的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用adobe的调色软件PR或者PS啥的都可以自己手动调色，然后保存一个lut表出来，以后所有图片都可以直接载入这个lut表自动实现调色，非常之方便。&lt;/p&gt;
&lt;p&gt;以Adobe 的PR软件或者PhotoShop保存的.cube文件为例，当然我只是截取的一部分，下面还有很长很长，都是如下形式排布。&lt;/p&gt;
&lt;p&gt;第一行是lut表的名称，第二行是lut表三个维度的尺寸，64就是指R，G， B三个分量分别只保存64个值。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201810/1138496-20181016225456036-960389255.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;933&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 调色原理是酱紫的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lut全称是look up table，没错就是你熟悉的查找表，3D LUT就只指三维的查找表，这个三维是指RGB三个通道是独立的，查找的时候也是独立查找。那么怎么个查找法，简单来说就是给你一个像素点的RGB三个值，我从表里面找到新的RGB三个值，调色过程至此完成。&lt;/p&gt;
&lt;p&gt;如果真有这个简单就好了，细想一下如果要把0-255所有三个通道的颜色值保存下来，数据量是256*256*256个，文件有点庞大了。因此为了减小数据的存储量，通常将256阶缩放到16阶或者64阶保存下来。上面的lut表就是64阶，存储的点个数就是64*64*64个。&lt;/p&gt;
&lt;p&gt;lut表的具体排布含义如下：&lt;/p&gt;
&lt;p&gt;R     G       B&lt;/p&gt;
&lt;p&gt;0      0        0&lt;/p&gt;
&lt;p&gt;0      0         1&lt;/p&gt;
&lt;p&gt;0       0        2&lt;/p&gt;
&lt;p&gt;0       0        3&lt;/p&gt;
&lt;p&gt;........&lt;/p&gt;
&lt;p&gt;0       0         63  &lt;/p&gt;

&lt;p&gt;0        1          0&lt;/p&gt;
&lt;p&gt;0         1         1&lt;/p&gt;
&lt;p&gt;0         1          2&lt;/p&gt;
&lt;p&gt;0         1          3&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;0          1         63&lt;/p&gt;

&lt;p&gt;.......&lt;/p&gt;
&lt;p&gt;.......&lt;/p&gt;
&lt;p&gt;.......&lt;/p&gt;
&lt;p&gt;0          63          63&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;63         63          63&lt;/p&gt;

&lt;p&gt;敲空格好难受，不过聪明的你一定看出来规律了，没错就是依次把三个通道的值一一列出来，想象一个三维的坐标轴，分别是R G B，取值范围都是0-63.  那么这个立方体内整点的个数就是63*63*63个。而表里面的值是将 0-63 归一化到 0-1，存为浮点数而已。&lt;/p&gt;
&lt;p&gt;当我们得到一张log妹纸图片后，每次取一个像素点，假如RGB三个值（50,100,200），然后将其量化到0-63范围，其实简单做法就是直接除以4，得到（12.5, 25, 50），那么从查找表中找到R = 12， G=25 ， B=50位置的三个浮点值（这个预先把lut表读入三维数组就可以了，根据索引下标取很简单），将三个浮点值再乘以255，扩展到0-255范围，得到一组新的RGB值，这个就是调色后的颜色值。&lt;/p&gt;
&lt;p&gt;没错，就是酱紫。当然上面用的是最简单的最近邻插值方法，因为（12.5, 25, 50）直接取整是不准确的，输出的图片会有比较明显的条纹断层现象。可以使用稍微复杂点的三线性插值（三维空间中浮点周围的8个整数点插值）或者四面体插值，能够得到比较平滑的输出图。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.  忧郁的妹纸调色后是酱紫的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近邻插值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201810/1138496-20181016233954374-1794381361.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三线性插值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201810/1138496-20181016233904325-86227322.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四面体插值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201810/1138496-20181016234043006-1384332482.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到最近邻插值妹纸的衣服上有明显的条纹，后两种插值方法要改善很多，突然感觉也没那么忧郁了。&lt;/p&gt;

&lt;p&gt;放两张其他LUT文件调色出的忧郁妹纸：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201810/1138496-20181016234402916-1503452360.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138496/201810/1138496-20181016234457244-1956042733.jpg&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面是博主用OpenCVC++写代码实现的，并不麻烦。&lt;/p&gt;
&lt;p&gt;FFmpeg中集成有3DLutFilter，同样也是有这三种插值算法，命令行调用也非常方便。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Oct 2018 14:39:00 +0000</pubDate>
<dc:creator>一棹烟波</dc:creator>
<og:description>现在越来越多的视频或者图像拍摄设备支持log模式，比如大疆无人机的D-Log模式等等，log模式的起源和发展就不多做介绍，其在普通显示器上显示画面通常看起来是平坦的灰色，因此也常被称为log灰视频。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/riddick/p/9801187.html</dc:identifier>
</item>
<item>
<title>解决JPA懒加载典型的N+1问题-注解@NamedEntityGraph - EalenXie</title>
<link>http://www.cnblogs.com/ealenxie/p/9800818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ealenxie/p/9800818.html</guid>
<description>&lt;p&gt;因为在设计一个树形结构的实体中用到了多对一，一对多的映射关系，在加载其关联对象的时候，为了性能考虑，很自然的想到了懒加载。&lt;/p&gt;
&lt;p&gt;也由此遇到了N+1的典型问题 : 通常1的这方，通过1条SQL查找得到1个对象，而JPA基于Hibernate，fetch策略默认为select(并非联表查询)，由于关联的存在 ，又需要将这个对象关联的集合取出，集合数量是N，则要发出N条SQL，于是本来的1条联表查询SQL可解决的问题变成了N+1条SQL&lt;/p&gt;
&lt;p&gt;我采取的解决方法是 : 不修改懒加载策略，JPA也不写native SQL，通过联表查询进行解决。&lt;/p&gt;
&lt;p&gt;如果对该例子比较感兴趣或者觉得言语表达比较啰嗦，可查看完整的demo地址 : &lt;a href=&quot;https://github.com/EalenXie/springboot-jpa-N-plus-One&quot; target=&quot;_blank&quot;&gt;https://github.com/EalenXie/springboot-jpa-N-plus-One&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;场景如下 : &lt;/p&gt;
&lt;p&gt;　　我设计了一个典型的二叉树结构实体叫做Area，代表的含义是区域 (省、市、区)。省是树的一级根节点，市是省的子节点，区是市的子节点。如 : 广东省，广州市，天河区&lt;/p&gt;
&lt;p&gt;　　1 . Area实体设计采用自关联，关联的子集fetch策略为懒加载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; name.ealen.entity;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.fasterxml.jackson.annotation.JsonIgnore;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.annotations.GenericGenerator;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; javax.persistence.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by EalenXie on 2018/10/16 16:49.
 * 典型的 多层级 区域关系
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

@Entity
@Table(name &lt;/span&gt;= &quot;jpa_area&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Area {


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Id 使用UUID生成策略
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Id
    @GeneratedValue(generator &lt;/span&gt;= &quot;UUID&quot;&lt;span&gt;)
    @GenericGenerator(name &lt;/span&gt;= &quot;UUID&quot;, strategy = &quot;org.hibernate.id.UUIDGenerator&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String id;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 区域名
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 一个区域信息下面很多子区域(多级) 比如 : 广东省  (子)区域 : 广州市  (孙)子区域 : 天河区
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @ManyToOne(fetch &lt;/span&gt;=&lt;span&gt; FetchType.LAZY)
    @JoinColumn(name &lt;/span&gt;= &quot;parent_id&quot;&lt;span&gt;)
    @JsonIgnore
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Area parent;

    @OneToMany(mappedBy &lt;/span&gt;= &quot;parent&quot;, fetch =&lt;span&gt; FetchType.LAZY)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Area&amp;gt;&lt;span&gt; children;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(String id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Area getParent() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; parent;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setParent(Area parent) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Area&amp;gt;&lt;span&gt; getChildren() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; children;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setChildren(List&amp;lt;Area&amp;gt;&lt;span&gt; children) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.children =&lt;span&gt; children;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2 . 为Area写一个简单的dao进行数据库访问：AreaRepository&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; name.ealen.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; name.ealen.entity.Area;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.jpa.repository.JpaRepository;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by EalenXie on 2018/10/16 16:56.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; AreaRepository &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;Area, String&amp;gt;&lt;span&gt; {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3.  现在来进行一波关键性的测试 : 首先我们插入数据测试 : &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AreaRepository areaRepository;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 新增区域测试
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addArea() {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 广东省 (顶级区域)&lt;/span&gt;
        Area guangdong = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Area();
        guangdong.setName(&lt;/span&gt;&quot;广东省&quot;&lt;span&gt;);
        areaRepository.save(guangdong);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;广东省 下面的 广州市(二级区域)&lt;/span&gt;
        Area guangzhou = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Area();
        guangzhou.setName(&lt;/span&gt;&quot;广州市&quot;&lt;span&gt;);
        guangzhou.setParent(guangdong);
        areaRepository.save(guangzhou);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;广州市 下面的 天河区(三级区域)&lt;/span&gt;
        Area tianhe = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Area();
        tianhe.setName(&lt;/span&gt;&quot;天河区&quot;&lt;span&gt;);
        tianhe.setParent(guangzhou);
        areaRepository.save(tianhe);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;广东省 下面的 湛江市(二级区域)&lt;/span&gt;
        Area zhanjiang = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Area();
        zhanjiang.setName(&lt;/span&gt;&quot;湛江市&quot;&lt;span&gt;);
        zhanjiang.setParent(guangdong);
        areaRepository.save(zhanjiang);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;湛江市 下面的 霞山区(三级区域)&lt;/span&gt;
        Area xiashan = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Area();
        xiashan.setName(&lt;/span&gt;&quot;霞山区&quot;&lt;span&gt;);
        xiashan.setParent(zhanjiang);
        areaRepository.save(xiashan);

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4 . 进行查询，并触发懒加载 : &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 触发懒加载查询 典型的 N+1 现象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    @Transactional
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; findAllArea() {
        List&lt;/span&gt;&amp;lt;Area&amp;gt; areas =&lt;span&gt; areaRepository.findAll();
        System.out.println(JSONArray.toJSONString(areas.get(&lt;/span&gt;0&lt;span&gt;)));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时，我们可以在控制台中看到，触发了懒加载，导致了N+1的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/994599/201810/994599-20181016220553078-751866244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面我们首先发出 1 条SQL查出了所有的Area对象，然后为了取第一个中的关联对象发了5条SQL。&lt;/p&gt;

&lt;p&gt;解决的方法如下 : &lt;/p&gt;
&lt;p&gt;　　1 . 首先在实体上面注解@NamedEntityGraph，指明name供查询方法使用，attributeNodes 指明被标注为懒加载的属性节点&lt;/p&gt;

&lt;p&gt;　　如下 : Category实体&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; name.ealen.entity;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.fasterxml.jackson.annotation.JsonIgnore;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.annotations.GenericGenerator;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; javax.persistence.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by EalenXie on 2018/10/16 16:13.
 * 典型的 多层级 分类
 * &amp;lt;p&amp;gt;
 * :@NamedEntityGraph :注解在实体上 , 解决典型的N+1问题
 * name表示实体图名, 与 repository中的注解 @EntityGraph的value属性相对应,
 * attributeNodes 表示被标注要懒加载的属性节点 比如此例中 : 要懒加载的子分类集合children
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

@Entity
@Table(name &lt;/span&gt;= &quot;jpa_category&quot;&lt;span&gt;)
@NamedEntityGraph(name &lt;/span&gt;= &quot;Category.Graph&quot;, attributeNodes = {@NamedAttributeNode(&quot;children&quot;&lt;span&gt;)})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Category {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Id 使用UUID生成策略
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Id
    @GeneratedValue(generator &lt;/span&gt;= &quot;UUID&quot;&lt;span&gt;)
    @GenericGenerator(name &lt;/span&gt;= &quot;UUID&quot;, strategy = &quot;org.hibernate.id.UUIDGenerator&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String id;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 分类名
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 一个商品分类下面可能有多个商品子分类(多级) 比如 分类 : 家用电器  (子)分类 : 电脑  (孙)子分类 : 笔记本电脑
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @ManyToOne(fetch &lt;/span&gt;=&lt;span&gt; FetchType.LAZY)
    @JoinColumn(name &lt;/span&gt;= &quot;parent_id&quot;&lt;span&gt;)
    @JsonIgnore
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Category parent;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父分类&lt;/span&gt;
&lt;span&gt;
    @OneToMany(mappedBy &lt;/span&gt;= &quot;parent&quot;, fetch =&lt;span&gt; FetchType.LAZY)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;Category&amp;gt; children;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子分类集合&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(String id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Category getParent() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; parent;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setParent(Category parent) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Category&amp;gt;&lt;span&gt; getChildren() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; children;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setChildren(Set&amp;lt;Category&amp;gt;&lt;span&gt; children) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.children =&lt;span&gt; children;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　   2 . 在访问的dao的查询方法上面注解@EntityGraph，value属性值为@NamedEntityGraph的name属性值，如 CategoryRepository : &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; name.ealen.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; name.ealen.entity.Category;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.jpa.repository.EntityGraph;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.jpa.repository.JpaRepository;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by EalenXie on 2018/10/16 16:19.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; CategoryRepository &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;Category, String&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 解决 懒加载 JPA 典型的 N + 1 问题
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @EntityGraph(value &lt;/span&gt;= &quot;Category.Graph&quot;, type =&lt;span&gt; EntityGraph.EntityGraphType.FETCH)
    List&lt;/span&gt;&amp;lt;Category&amp;gt;&lt;span&gt; findAll();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3 . 进行测试 : 新增一些分类 &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　@Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CategoryRepository categoryRepository;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 新增分类测试
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCategory() {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个 家用电器分类(顶级分类)&lt;/span&gt;
        Category appliance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Category();
        appliance.setName(&lt;/span&gt;&quot;家用电器&quot;&lt;span&gt;);
        categoryRepository.save(appliance);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;家用电器 下面的 电脑分类(二级分类)&lt;/span&gt;
        Category computer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Category();
        computer.setName(&lt;/span&gt;&quot;电脑&quot;&lt;span&gt;);
        computer.setParent(appliance);
        categoryRepository.save(computer);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;电脑 下面的 笔记本电脑分类(三级分类)&lt;/span&gt;
        Category notebook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Category();
        notebook.setName(&lt;/span&gt;&quot;笔记本电脑&quot;&lt;span&gt;);
        notebook.setParent(computer);
        categoryRepository.save(notebook);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;家用电器 下面的 手机分类(二级分类)&lt;/span&gt;
        Category mobile = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Category();
        mobile.setName(&lt;/span&gt;&quot;手机&quot;&lt;span&gt;);
        mobile.setParent(appliance);
        categoryRepository.save(mobile);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手机 下面的 智能机 / 老人机(三级分类)&lt;/span&gt;
        Category smartPhone = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Category();
        smartPhone.setName(&lt;/span&gt;&quot;智能机&quot;&lt;span&gt;);
        smartPhone.setParent(mobile);
        categoryRepository.save(smartPhone);

        Category oldPhone &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Category();
        oldPhone.setName(&lt;/span&gt;&quot;老人机&quot;&lt;span&gt;);
        oldPhone.setParent(mobile);
        categoryRepository.save(oldPhone);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　进行查询 ，并触发懒加载 : &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查找分类测试  已经解决了经典的 N+1 问题
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    @Transactional
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; findCategory() {
        List&lt;/span&gt;&amp;lt;Category&amp;gt; categories =&lt;span&gt; categoryRepository.findAll();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Category category : categories) {
            System.out.println(JSONArray.toJSONString(category));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时可以看到控制台里面只发了一条联表查询就得到了关联对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/994599/201810/994599-20181016223035209-17603160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 16 Oct 2018 14:37:00 +0000</pubDate>
<dc:creator>EalenXie</dc:creator>
<og:description>因为在设计一个树形结构的实体中用到了多对一，一对多的映射关系，在加载其关联对象的时候，为了性能考虑，很自然的想到了懒加载。 也由此遇到了N+1的典型问题 : 通常1的这方，通过1条SQL查找</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ealenxie/p/9800818.html</dc:identifier>
</item>
<item>
<title>使用 xUnit 编写 ASP.NET Core 单元测试 - Liam Wang</title>
<link>http://www.cnblogs.com/willick/p/aspnetcore-unit-tests-with-xunit.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/aspnetcore-unit-tests-with-xunit.html</guid>
<description>&lt;p&gt;还记得 .NET Framework 的 ASP.NET WebForm 吗？那个年代如果要在 Web 层做单元测试简直就是灾难啊。.NET Core 吸取教训，在设计上考虑到了可测试性，就连 ASP.NET Core 这种 Web 或 API 应用要做单元测试也是很方便的。其中面向接口和依赖注入在这方面起到了非常重要的作用。&lt;/p&gt;
&lt;p&gt;本文就来手把手教你如何用 xUnit 对 ASP.NET Core 应用做单元测试。.NET Core 常用的测试工具还有 NUnit 和 MSTest，我本人习惯用 xUnit 作为测试工具，所以本文用的是 xUnit。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;创建示例项目&lt;/h2&gt;
&lt;p&gt;先用 ASP.NET Core API 模板建一个应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3sPhWOo.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板为我们自动创建了一个 ValuesController，为了方便演示，我们只留其中一个 Get 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesController&lt;/span&gt; : &lt;span class=&quot;hljs-title&quot;&gt;ControllerBase&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;[HttpGet(&lt;span class=&quot;hljs-string&quot;&gt;&quot;{id}&quot;&lt;/span&gt;)]&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; ActionResult&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; id)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再添加一个 xUnit 单元测试项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Q6Cwvwb.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板自动为我们添加好了 xUnit 引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;PackageReference&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Include&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;Microsoft.NET.Test.Sdk&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Version&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;15.9.0&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;PackageReference&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Include&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;xunit&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Version&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;2.4.0&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;PackageReference&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Include&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;xunit.runner.visualstudio&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Version&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;2.4.0&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但要测试 ASP.NET Core 应用还需要添加两个 NuGet 包：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-bash&quot;&gt;Install-Package Microsoft.AspNetCore.App
Install-Package Microsoft.AspNetCore.TestHost
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然还要引入目标项目。最后的引用是这样的：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs language-xml&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;PackageReference&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Include&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;Microsoft.AspNetCore.App&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Version&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;2.1.5&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;PackageReference&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Include&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;Microsoft.AspNetCore.TestHost&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Version&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;2.1.1&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;PackageReference&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Include&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;Microsoft.NET.Test.Sdk&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Version&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;15.9.0&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;PackageReference&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Include&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;xunit&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Version&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;2.4.0&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;PackageReference&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Include&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;xunit.runner.visualstudio&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Version&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;2.4.0&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;ProjectReference&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;Include&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;..\WebApplication1\WebApplication1.csproj&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加完引用后编译一下，确认引用没有问题。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;编写单元测试&lt;/h2&gt;
&lt;p&gt;写单元测试一般有三个步骤：Arrange，Act 和 Assert。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;Arrange&lt;/strong&gt;&lt;/span&gt; 是准备阶段，这个阶段是准备工作，比如模拟数据、初始化对象等；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Act&lt;/strong&gt;&lt;/span&gt; 是行为阶段，这个阶段是用准备好的数据去调用要测试的方法；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Assert&lt;/strong&gt;&lt;/span&gt; 是断定阶段，就是把调用目标方法返回的值和预期的值进行比较，如果和预期一致说明测试通过，否则为失败。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按照这个步骤我们来编写一个单元测试方法，以 ValuesController 中的 Get 方法作为要测试的目标。一般一个单元测试方法就是一个测试用例。&lt;/p&gt;
&lt;p&gt;我们在测试工程添加一个 ValuesTests 单元测试类，然后编写一个单元测试方法，代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;9&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesTests&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesTests&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; server = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TestServer(WebHost.CreateDefaultBuilder()&lt;br/&gt;.UseStartup&amp;lt;Startup&amp;gt;());&lt;br/&gt;Client = server.CreateClient();&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; HttpClient Client { &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;; }&lt;/p&gt;&lt;p&gt;[Fact]&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; Task &lt;span class=&quot;hljs-title&quot;&gt;GetById_ShouldBe_Ok&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; id = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; response = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; Client.GetAsync($&lt;span class=&quot;hljs-string&quot;&gt;&quot;/api/values/{id}&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Assert.Equal(HttpStatusCode.OK, response.StatusCode);&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们通过 TestServer 拿到一个 HttpClient 对象，用它我们可以模拟 Http 请求。我们写了一个非常简单的测试用例，完整演示了单元测试的 Arrange，Act 和 Assert 三个步骤。&lt;/p&gt;
&lt;p&gt;建议单元测试的方法名使用“什么应该是什么”的模式。比如上面的 GetById_ShouldBe_Ok，表示调用 GetById 这个 API 返回的结果应该是 OK 的，这样一看就知道你这个测试用例是干吗的，不需要过多的注释。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;运行单元测试&lt;/h2&gt;
&lt;p&gt;单元测试用例写好后，打开“Test Explore”（中文版 VS 看到的是中文），在测试方法上右击，选择“Run Seleted Tests”，也可以在方法代码块内鼠标右击选择“Run Tests”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/IGDXls3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意看测试方法前面图标的颜色，目前是蓝色的，表示测试用例还没有运行过。&lt;/p&gt;
&lt;p&gt;测试用例执行结束后如果结果和预期一致就是绿色的图标：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/XqcJwVY.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果运行结果和预期不一致就会是红色图标，然后你需要修改代码直到出现绿色图标。你可以在“Test Explore”的下方看到执行消耗的时间，也可以在 Output 窗口看到执行的细节。&lt;/p&gt;
&lt;p&gt;以上图标颜色的变化过程是：蓝色，红色，再绿色，有可能蓝色经过一次运行就直接变成绿色，也有可能经过很多次红色才变成绿色。测试驱动开发中的 &lt;span&gt;&lt;strong&gt;BRG（蓝红绿）&lt;/strong&gt;&lt;/span&gt;术语就是这么来的。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;调试单元测试&lt;/h2&gt;
&lt;p&gt;你可以通过添加断点的方式在单元测试中调试。方法很简单，在需要调试的方法上右键选择“Debug Seleted Tests”即可，和平时的调试是一样的。&lt;/p&gt;
&lt;p&gt;如果我们要查看 API 具体返回了什么，可以通过加断点调试来查看返回结果的变量字符串值，但这种方式不是最好的选择。比如对于同一个 API，我要看看 10 种参数返回的结果是什么样的，每次都通过断点调试来查看就很麻烦。&lt;/p&gt;
&lt;p&gt;除了添加断点来调试，还有一种打印日志的方法来快速调试，xUnit 可以很方便地做到这一点。为此我们来修改一下 ValuesTests：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesTests&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ITestOutputHelper outputHelper)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; server = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TestServer(WebHost.CreateDefaultBuilder()&lt;br/&gt;.UseStartup&amp;lt;Startup&amp;gt;());&lt;br/&gt;Client = server.CreateClient();&lt;br/&gt;Output = outputHelper;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; ITestOutputHelper Output{ &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;; }&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们在构造函数中添加了 ITestOutputHelper 参数，xUnit 会将一个实现此接口的实例注入进来。拿到这个实例后，我们就可以用它来输出日志了：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;7&quot;&gt;[Fact]&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; Task &lt;span class=&quot;hljs-title&quot;&gt;GetById_ShouldBe_Ok&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; id = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; response = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; Client.GetAsync($&lt;span class=&quot;hljs-string&quot;&gt;&quot;/api/values/{id}&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; responseText = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; response.Content.ReadAsStringAsync();&lt;br/&gt;Output.WriteLine(responseText);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Assert.Equal(HttpStatusCode.OK, response.StatusCode);&lt;br/&gt;}
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行（注意不是 Debug）此方法，运行结束后，在“Test Explore”的下方可以可以看到“Output”字样，点击它就可以看到输出的结果，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mwfC500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这种方式，每次运行测试我们就可以很方便的查看输出结果了。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;上面我们是通过模拟 Http 请求的方式来调用 API 测试的，还有一种就是 new 一个 Controller 来直接调用它的 Action 方法来测试。比如这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; id = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; controller = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ValuesController();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; result = controller.Get(id);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 Controller 没有其它依赖，这种方式当然是最方便的。但通常 Controller 是会有一个或多个依赖的，比如这样：&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesController&lt;/span&gt; : &lt;span class=&quot;hljs-title&quot;&gt;Controller&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;readonly&lt;/span&gt; ISessionRepository _sessionRepository;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesController&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ISessionRepository sessionRepository)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_sessionRepository = sessionRepository;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;}
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们就要模拟实例化这个 Controller 的所有依赖，当然手动模拟是不现实的，因为一个依赖类还可能会依赖其它的类或接口，依赖链可能很长，你不可能每个依赖都手动去实例化它们。有一个叫 Moq 的工具可以自动来模拟实例化依赖，它的用法是这样的：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;2&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; mockRepo = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Mock&amp;lt;ISessionRepository&amp;gt;();&lt;br/&gt;mockRepo.Setup(...);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; controller = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HomeController(mockRepo.Object);&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; result = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; controller.Index();
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式我是不推荐的，因为抛开 Moq 的学习成本不说，重要的是它不如模拟 Http 请求那样接近真实的调用场景，所以本文对它不作过多的介绍，大家知道有这么回事就行。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Oct 2018 14:17:00 +0000</pubDate>
<dc:creator>Liam Wang</dc:creator>
<og:description>还记得 .NET Framework 的 ASP.NET WebForm 吗？那个年代如果要在 Web 层做单元测试简直就是灾难啊。.NET Core 吸取教训，在设计上考虑到了可测试性，就连 ASP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willick/p/aspnetcore-unit-tests-with-xunit.html</dc:identifier>
</item>
</channel>
</rss>