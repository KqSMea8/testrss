<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>k8s 创建资源的两种方式 - 每天5分钟玩转 Docker 容器技术（124） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8351975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8351975.html</guid>
<description>&lt;h3&gt;&lt;span&gt;命令 vs 配置文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Kubernetes 支持两种方式创建资源：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 用 kubectl 命令直接创建，比如：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl run nginx-deployment --image=nginx:1.7.9 --replicas=2&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;在命令行中通过参数指定资源的属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2. 通过配置文件和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 创建，要完成前面同样的工作，可执行命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl apply -f nginx.yml&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;nginx.yml 的内容为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180125164002272-1139097572.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;资源的属性写在配置文件中，文件格式为 YAML。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面对这两种方式进行比较。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于命令的方式：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;简单直观快捷，上手快。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;适合临时测试或实验。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;基于配置文件的方式：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;配置文件描述了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;What&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，即应用最终要达到的状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;配置文件提供了创建资源的模板，能够重复部署。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;可以像管理代码一样管理部署。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;适合正式的、跨环境的、规模化部署。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;这种方式要求熟悉配置文件的语法，有一定难度。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;后面我们都将采用配置文件的方式，大家需要尽快熟悉和掌握。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 不但能够创建 Kubernetes 资源，也能对资源进行更新，非常方便。不过 Kubernets 还提供了几个类似的命令，例如 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl create&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl replace&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl edit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl patch&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为避免造成不必要的困扰，我们会尽量只使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;br/&gt;此命令已经能够应对超过 90% 的场景，事半功倍。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下节我们来分析一个 Deployment 的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 22:28:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8351975.html</dc:identifier>
</item>
<item>
<title>上传本地文件或项目到GitHub的教程 - B7和弦</title>
<link>http://www.cnblogs.com/buyan/p/8355036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buyan/p/8355036.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;既然是往GitHub上传文件，那GitHub账号必须得有，这时候就会有同学问：妖怪吧，我没有GitHub账号怎么办？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;别急别急，打开GitHub网站&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot;&gt;https://github.com/&lt;/a&gt;，然后注册就OK了，怎么注册我就不说了，这时候还会有同学问：全是英文我怎么看得懂！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;看不懂怎么办，找软件翻译啊，在线翻译也可以，好了，废话不多说直接进入正题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;声明一下：这是在Windows下的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、创建GitHub账号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、新建仓库（直接图片伺候，红色矩形圈住的就是）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180125225536194-223508248.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;三、填写名称，按照图片按照自己的需求把该填的填上，该写的写上，Initialize this repository with a README这个勾上，勾上之后就不用你再去创建README.md文件了，这个README.md文件就是文档，就是描述你这个仓库是做什么用的，怎么使用等等（只是在这儿的作用）有兴趣的可以自己查一下，最后点Create &lt;span&gt;repository，好了，仓库创建好了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180125230728490-552818764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;83.282474226804&quot;&gt;
&lt;p&gt;四、准备工具，下载Git，网址：&lt;a href=&quot;https://git-scm.com/downloads&quot; target=&quot;_blank&quot;&gt;https://git-scm.com/downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;五、&lt;span&gt;为github账号设置SSH key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开git-bash后输入命令ssh-keygen  -C &quot;邮箱地址&quot;-t rsa（引号不要），然后依次按三次回车，注意：第一次回车是确认路径，记住那个路径，下面要用到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注意：在做这步操作之前要先执行这步操作&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;打开git-bash后输入这两条命令&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hljs stylus&quot;&gt;&lt;span&gt;&lt;code class=&quot;stylus&quot;&gt;git config --global user&lt;span class=&quot;hljs-selector-class&quot;&gt;.name &lt;span class=&quot;hljs-string&quot;&gt;&quot;（这里填你注册GitHub的用户名）&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hljs stylus&quot;&gt;&lt;span&gt;&lt;code class=&quot;stylus&quot;&gt;git config --global user&lt;span class=&quot;hljs-selector-class&quot;&gt;.email &lt;span class=&quot;hljs-string&quot;&gt;&quot;（这里填你注册GitHub时用的邮箱）&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180125234650803-1114078131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成之后用文本编辑器打开上面那个路径下的id_rsa.pub，然后复制所有字符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180125235301319-1331589036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在配置GitHub账号下的SSH KEY，先点开账号设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180125235949990-1818650424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再点开SSH and GPG keys&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126000051928-1486195700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后点New SSH key&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126000136709-491487062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再把刚刚复制下来的字符都粘贴到key下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126000240412-896697751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加成功后就是这个样子滴&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126000448694-230002896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;六、建立本地仓库，安装好git之后打开git-bash，红色矩形圈住的这个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180125232600412-333512375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      1、先在你的电脑上创建本地项目，然后通过命令进入到该目录下，我自己创建的项目目录是 E:\PyProject，下面是具体命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126011445459-1656477205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、克隆刚才创建好的仓库，回到GitHub账号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126001458272-1283091274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　进去之后点开你创建的仓库（这个hello-world是我创建的仓库）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126001551053-2068104901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后在地址栏复制链接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126001648319-500435831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　克隆仓库到本地，命令git clone https://github.com/BuYanS/hello-world.git（后面的链接改成刚才你复制的自己仓库的地址最后加上.git&lt;/p&gt;
&lt;p&gt;　　克隆的时候切换到你创建的项目目录下&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：克隆完仓库后会在当前目录下生成一个和创建的仓库名相同的一个文件夹，将你要上传的文件或目录复制到该目录下然后通过命令进入到该目录下再进行后续操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126002014615-1719918475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　然后进行一系列的命令（这些命令也在你创建的项目目录下进行）&lt;/p&gt;
&lt;p&gt;　　git init&lt;/p&gt;
&lt;p&gt;　　git add .  （这儿是添加当前目录下的文件到仓库，如果你只想添加某个文件的话把add后的那个点改为具体的文件名，文件名一定要全，加上后缀）&lt;/p&gt;
&lt;p&gt;　　git commit -m ”stumansys” （这里是添加注释，-m之后的内容自己随便写，-m之后有空格，后面的内容加上引号）&lt;/p&gt;
&lt;p&gt;　　这儿如果没有出错的话就是这样的（最后文件可能不一样，按照你添加的看，我上一步添加的是helloworld.py，所以这儿最后显示helloworl.py）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126004351350-2044894440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　git remote add origin https://github.com/BuYanS/hello-world.git  （这儿的http地址还是你刚才复制下来的那个地址）&lt;/p&gt;
&lt;p&gt;　　这儿如果没有出错的话是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126004604709-920363762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　git pull origin master  （这儿没出错的话应该是这样的）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126005836100-716541300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　git push origin master  （这儿如果没错的话应该是这样的）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1275991/201801/1275991-20180126005941631-284272335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;嗯，上传项目/文件到这儿就结束了，在这期间可能会出错误，我再说一下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果执行git remote add origin https://github.com/BuYanS/hello-world.git 出现错误提示：fatal: remote origin already exists&lt;/p&gt;
&lt;p&gt;　　则执行以下语句：git remote rm origin&lt;/p&gt;
&lt;p&gt;　　再往后执行git remote add origin https://github.com/BuYanS/hello-world.git&lt;em id=&quot;__mceDel&quot;/&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;就好了&lt;/p&gt;
&lt;p&gt;如果没有出错那就恭喜你，一次性就成功了&lt;/p&gt;
&lt;p&gt;上传成功之后你就可以在你的GitHub仓库中看到你上传的文件或者项目了。&lt;/p&gt;
&lt;p&gt;这个教程对小白来说再合适不过了，很多细节都写到了，应该不会让你走弯路了。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Thu, 25 Jan 2018 17:25:00 +0000</pubDate>
<dc:creator>B7和弦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/buyan/p/8355036.html</dc:identifier>
</item>
<item>
<title>webpack优化之code splitting - 潇湘待雨</title>
<link>http://www.cnblogs.com/pqjwyn/p/8064966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pqjwyn/p/8064966.html</guid>
<description>&lt;p&gt;作为当前风头正盛的打包工具，webpack风靡前端界。确实作为引领了一个时代的打包工具，很多方面都带来了颠覆性的改进，让我们更加的感受到自动化的快感。不过最为大家诟病的一点就是用起来太难了。&lt;br/&gt;要想愉快的使用，要使用n多的配置项，究其原因在于文档的不够详细、本身默认集成的不足。也不能说这是缺点吧，更多的主动权放给用户就意味着配置工作量的增加，这里就不过多探讨了。当历尽千辛万苦，你的项目跑起来之后，可能会发现有一些不太美好的问题的出现，编译慢、打包文件大等。那么，我们还要花些时间来看看怎么优化相关配置了。 下面一起看下code splitting&lt;/p&gt;
&lt;h2 id=&quot;code-splitting出现的背景&quot;&gt;code splitting出现的背景&lt;/h2&gt;
&lt;p&gt;对于前端资源来说，文件体积过大是很影响性能的一项。特别是对于移动端的设备而言简直是灾难。此外对于某些只要特定环境下才需要的代码，一开始就加载进来显然也不那么合理，这就引出了按需加载的概念了。&lt;br/&gt;为了解决这些情况，代码拆分就应运而生了。代码拆分故名思意就是将大的文件按不同粒度拆分，以满足解决生成文件体积过大、按需加载等需求。具体到webpack而言有下面几种方式来达到我们的目的。&lt;/p&gt;
&lt;h2 id=&quot;webpack实现代码拆分的方式&quot;&gt;webpack实现代码拆分的方式&lt;/h2&gt;
&lt;p&gt;webpack通过下面三种方式来达到以上目的&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Entry Points: 多入口分开打包&lt;/li&gt;
&lt;li&gt;Prevent Duplication:去重，抽离公共模块和第三方库&lt;/li&gt;
&lt;li&gt;Dynamic Imports:动态加载&lt;br/&gt;这里不去扒文档上的定义了，我们从一个例子中来逐步体会他们不同的作用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;假设我们有这么个项目，有下面几个文件&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/790851/201801/790851-20180125225749459-168953789.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码很简单(示例而已，直接用commonjs的语法来写了):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//a.js&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; react &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; tool &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./tool'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./b'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;load&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;b&lt;/span&gt;()
    &lt;span class=&quot;at&quot;&gt;tool&lt;/span&gt;()
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'全部文件都从一个入口打包'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;load&lt;/span&gt;()
&lt;span class=&quot;co&quot;&gt;//b.js&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; react &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; tool &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./tool'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;b&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;tool&lt;/span&gt;()
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'这是bjs文件'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; b&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//tool.js&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; react &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;tool&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'这是tooljs文件'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tool&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置很简单:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; webpack &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'webpack'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./codesplitting/c1/a.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; __dirname&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'/dist/index.js'&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//*****&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接打包：可以看到文件大小有2047行,体积也变大了&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/790851/201801/790851-20180125225816959-1957544046.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前只引入了react，并且业务代码几乎没有的情况下。大家可以猜到实际项目中的情况了。来让我们进行第一优化&lt;/p&gt;
&lt;h3 id=&quot;entry-points&quot;&gt;Entry Points&lt;/h3&gt;
&lt;p&gt;如果业务中的项目不是单页面应用，这一步可以忽略了，直接是多入口打包。这里是为了演示效果，强行分一个模块出来打包，假设我们的文件也很大，需要将b.js单独打个包出来:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    entry&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'./codesplitting/c1/a.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'./codesplitting/c1/a.js'&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    output&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(__dirname&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./dist'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'[name].js'&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;，
    &lt;span class=&quot;co&quot;&gt;//***&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里a.js也需要修改,去掉对b的引用。入口文件之间不能相互引用的。不然，问题就大了，到底以谁为主呢，这样就陷入了循环引用的问题。&lt;br/&gt;此时的生成文件如下:&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/790851/201801/790851-20180125225835694-464893659.png&quot;/&gt;&lt;br/&gt;看来文件竟然只小了那么一点了吧？第一步的优化这里就完成了，显然你会认为我在开玩笑。&lt;br/&gt;当然这只是万里长征第一步，看一下dist下的文件不难发现两个文件中都把react这个第三方库和tool.js这个可复用模块打进去了，显然这样重复打包有点没必要。&lt;br/&gt;是不是可以把这些复用性强的模块拿出来单独打包呢？&lt;br/&gt;这样浏览器第一次请求之后就会将该文件缓存起来，从服务端请求的只有体积缩小之后的业务文件了，这样的话加载速度显然会有所提升。&lt;br/&gt;如果你也是这么想的，来一起继续看下去。&lt;/p&gt;
&lt;h3 id=&quot;prevent-duplication&quot;&gt;Prevent Duplication&lt;/h3&gt;
&lt;p&gt;webpack去除重复引用是通过&lt;a href=&quot;https://webpack.js.org/plugins/commons-chunk-plugin/&quot;&gt;CommonsChunkPlugin&lt;/a&gt;插件来实现的。该插件的配置项如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//被抽离为公共文件的chunk名，例如common,可以是string或者数组&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//显然如果是单个的模块，就是name多个就是names&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;string&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;[]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//打包之后公共模块的名称模板&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//例如'[name].js'&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//如果省略，则和name名称一致&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;string&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;co&quot;&gt;//模块被引的最小次数，也就是说至少有几个组件引用了该模块。&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//如果是Infinity，则表明单纯的创建，并不做任何事情&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;minChunks&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;  
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体在webpack中去重对于第三方库显示声明vendor，公共模块声明common的方式来处理&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;entry&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'./codesplitting/c1/a.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'./codesplitting/c1/b.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//第三方库显示声明&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;vendor&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//公共组件声明为common&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;'./codesplitting/c1/tool'&lt;/span&gt;]
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//***&lt;/span&gt;
    plugins&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [
        &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;webpack&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;optimize&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;CommonsChunkPlugin&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;&quot;common&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;vendor&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;[name].js&quot;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)  
    ]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打包结果如下：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/790851/201801/790851-20180125225859334-1675173269.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到index和other两个业务包已经很小了，react被抽离到单独的包中。&lt;br/&gt;这样还有一个问题，对于某些代码可能只有在特定条件下才执行，或者可能就不执行。&lt;br/&gt;我不希望在首屏就去加载它，也就是我们常说的按需加载是要怎么做呢。一起看下去。&lt;/p&gt;
&lt;h3 id=&quot;dynamic-imports&quot;&gt;Dynamic Imports&lt;/h3&gt;
&lt;p&gt;webpack建议如下两种方式使用动态加载。&lt;br/&gt;1)、ECMAScript中出于提案状态的import()&lt;br/&gt;2)、webpack 特定的 require.ensure&lt;br/&gt;我们这里就是用第二种来看下效果(毕竟偷懒没用babel...),在ajs中动态引入di.js&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;co&quot;&gt;//虽然始终会加载,大家能明白就行&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;require&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;ensure&lt;/span&gt;([]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(require)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; di &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./di'&lt;/span&gt;)
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//新增动态加载的js&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;di&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;tool&lt;/span&gt;()
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'这是动态引入的文件'&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; di&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行之后可以发现多了个2.2.js,打开可以发现就是我们新建的动态引入的di.js&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/790851/201801/790851-20180125225922803-1905798910.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家可能会问怎么确定就是动态引入的呢，虽然本示例只能看打包之后的例子(就不引入dev server了，毕竟是懒。。。)我们依然可以从代码里看到结果。&lt;br/&gt;首先、查看index.js文件，可以看到下面的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;      &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; react &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;__webpack_require__&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
       &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; tool &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;__webpack_require__&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)  
       &lt;span class=&quot;co&quot;&gt;/****省略8*****/&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;//虽然始终会加载&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;__webpack_require__&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/* nsure */&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(require)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; di &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;__webpack_require__&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;)
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与直接require的模块不同,require.ensure被转化为了 &lt;strong&gt;webpack_require&lt;/strong&gt;.e方法，来继续看一下该方法有什么用。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;__webpack_require__&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;requireEnsure&lt;/span&gt;(chunkId&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; callback) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// &quot;0&quot; is the signal for &quot;already loaded&quot;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(installedChunks[chunkId] &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;callback&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; __webpack_require__)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;// an array means &quot;currently loading&quot;.&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(installedChunks[chunkId] &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;undefined&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            installedChunks[chunkId].&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(callback)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// start chunk loading&lt;/span&gt;
            installedChunks[chunkId] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [callback]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; head &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'head'&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; script &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'script'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;script&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'text/javascript'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;script&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;charset&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'utf-8'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;script&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;va&quot;&gt;script&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__webpack_require__&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; chunkId &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;.&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;common&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;index&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;other&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;[chunkId]&lt;span class=&quot;op&quot;&gt;||&lt;/span&gt;chunkId) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;.js&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;head&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;appendChild&lt;/span&gt;(script)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结合注释直接从源码中可以看出来，最后面的条件语句来创建script标签进而实现动态加载的。所谓动态加载本质还是要创建script标签来实现的。&lt;/p&gt;
&lt;h4 id=&quot;结束语&quot;&gt;结束语&lt;/h4&gt;
&lt;p&gt;至此代码分割部分的优化已经完成了，以上是个人关于代码分割的简单理解，抛砖引玉，共同学习进步。更多请移步&lt;a href=&quot;https://github.com/xiaoxiangdaiyu/webpack_demo/tree/master/codesplitting&quot;&gt;github查看&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 15:02:00 +0000</pubDate>
<dc:creator>潇湘待雨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pqjwyn/p/8064966.html</dc:identifier>
</item>
<item>
<title>有时在面试时，我都替候选人着急——候选人完全可以在面试前准备 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/8353578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/8353578.html</guid>
<description>&lt;p&gt;    我上周和本周面了一些Java高级开发方面的候选人，不能说不好，但根据他们的工作经历和项目经验，完全应该发挥得更好。比如一些只要是做过项目一定会用到的技术，他们普遍都没回答好，而且很多看上去时临场发挥。&lt;/p&gt;
&lt;p&gt;    而且根据我最近的面试经验，这不是个别现象，而是大多数候选人普遍存在的问题，这些问题包括：&lt;/p&gt;
&lt;p&gt;    1 他们在简历上写得一些技术点，比如数据库优化，或Spring MVC框架，我相信候选人在平时项目一定做过，但不知道总结。比如我问在数据库优化方面做过哪些事情？很多人就直接说没做过，但我就不信他们连索引也没用过。&lt;/p&gt;
&lt;p&gt;    2 我就拿java集合里的HashMap举例，我就问hashcode方法重写过吗？如果不重写会有什么后果？我想大多数候选人应该都用过HashMap，但能说上来的寥寥无几，我猜想原因可能还是只会用，不会总结。&lt;/p&gt;
&lt;p&gt;    3 描述项目经验时，条理性不强，往往是想到什么就说什么，比如按我的思路，介绍项目经验时，先大致介绍项目背景，然后谈下用到的技术和框架，然后说下我做的模块，再可以说些亮点。但不少人叙述时基本没逻辑性，比如第一句在说用到某技术，第二句就说项目里有多少人，第三句再补充项目里还用到什么技术。&lt;/p&gt;
&lt;p&gt;    4 回答问题始终无法切中要点，甚至有时候会用模糊语句蒙混过关。比如我问，如果出现OOM异常，该查哪些日志文件，然后该从哪些方面查？这问题不复杂，但有些人会直接说该扩展内存使用量，这就有些文不对题了。&lt;/p&gt;

&lt;p&gt;    可能还有其它问题点，但上述4点给我印象最深刻。面试完给我的感觉是，候选人可能平时项目里也用到过这个技术，但不知道总结，所以导致在面试时没回答好。&lt;/p&gt;
&lt;p&gt;    这很吃亏，因为面试官不得不根据候选人的答题情况来衡量候选人的能力。如果他们在面试前做过准备，面试结果一定会比现在要好。同时我就很奇怪，现在的候选人是不是大多在面试前不做准备？或者说不知道该如何准备？&lt;/p&gt;

&lt;p&gt;    在我的博文里，很多文章是讲如何准备面试，在&lt;span&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/4843&quot;&gt;java web轻量级开发面试教程&lt;/a&gt;&lt;/span&gt;里，我也总结了一些简历和面试方面的经验。这里再根据我的一些面试经验，再总结下面试前该如何做准备，以及面试里的实战技巧。&lt;/p&gt;

&lt;p&gt;    准备要点1：介绍项目&lt;/p&gt;
&lt;p&gt;    你可以在家里列个发言提纲，着重说你用到的技术，以及你做的亮点，请注意，再介绍时，一定得准备些亮点，比如在微服务这块你如何做部署，在分布式集群方面，你做过哪些配置。总之这是你比别人强的地方。当你抛出亮点时，面试官会有意无意地接口问。我也知道，这其实是相当于被候选人牵着鼻子走，我在面试时也会注意，但这可能是人的思维惯性，我有时也会无意中接口问候选人提出的名词。&lt;/p&gt;
&lt;p&gt;    也就是说，你如果准备好项目介绍，一方面能让面试官感觉你条理性很强，另外你甚至可以引导面试后面的问题。&lt;/p&gt;

&lt;p&gt;    准备要点2：适当看些文档，夯实你的基础知识。&lt;/p&gt;
&lt;p&gt;    我就拿Java里的集合来举例，大家可以看ArrayList,LinkedList，可以看些HashMap和ConcurrentHashMap，泛型，每个要点都适当深入，必要时甚至可以看些ArrayList或ConcurrentHashMap部分的源代码，面试时找机会说出来。&lt;/p&gt;
&lt;p&gt;   面试过程中普遍出现的问题是，候选人会用这个技术，但说不好。出现这个问题的原因是候选人没做准备，其实在面试时，做不做准备给人的感觉就完全两样了。&lt;/p&gt;

&lt;p&gt;    准备要点3：看些值钱的技术，这些技术小而言之是优化方面的，比如JVM优化，数据库性能优化，大而言之是框架，比如分布式集群，反向代理等，然后想办法把这些技术嵌入到你的项目介绍里，并准备些衍生问题。&lt;/p&gt;

&lt;p&gt;    最后说下我的结论：&lt;/p&gt;
&lt;p&gt;    1 面试前不做准备，哪怕你工作经验再丰富，通过面试的可能性很小。大家对此别抱有任何侥幸心理，这是从很多实例中总结出来的。&lt;/p&gt;
&lt;p&gt;    2 我在其它博文里写过些做准备工作的方式，大家可以看下我的其它文章。&lt;/p&gt;
&lt;p&gt;    3 积累面试经验不仅得靠准备，更得靠实战。比如你最近想要换工作了，你可以提前找些小公司练手，一方面看下最近流行哪些面试题，另一方面不断在实战中发现自己的问题，再不断准备。&lt;/p&gt;
&lt;p&gt;    4 我也见过一些比较极端的例子，比如候选人只有初级开发的能力，但凭着能说会道，最终面上了高级开发，但毕竟这是少数，面试技巧大概占30%，最终还得靠实力，所谓一力降十会。&lt;/p&gt;





</description>
<pubDate>Thu, 25 Jan 2018 14:50:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/8353578.html</dc:identifier>
</item>
<item>
<title>记node前后端代码共用的一次坑 - WoodK</title>
<link>http://www.cnblogs.com/woodk/p/8353573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woodk/p/8353573.html</guid>
<description>&lt;h2&gt;项目背景&lt;/h2&gt;
&lt;p&gt;nodejs项目，webpack打包，用axios请求，Promise封装，nunjucks模板引擎；&lt;/p&gt;
&lt;p&gt;之前已将nunjucks模板通过webpack打包策略，做成前后端共用；&lt;/p&gt;
&lt;p&gt;目前需要将网络请求以及数据处理封装成service模块；&lt;/p&gt;
&lt;p&gt;目录划分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776126/201801/776126-20180125223251256-1156523451.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;p&gt;将公共代码放到service中，整合两端共同的一些网络请求以及数据处理（node首屏，客户端再次请求数据更新等操作）&lt;/p&gt;

&lt;h2&gt;这里碰到的两个问题：&lt;/h2&gt;
&lt;p&gt;1. node模块使用module.exports，而webpack我们使用的是import/export，两者共用会报错；&lt;/p&gt;
&lt;p&gt;2.我们使用了Promise做了两层封装（service封装、service中的fetch封装：抹平node和客户端的环境差异）&lt;/p&gt;

&lt;p&gt;第一个问题，其实webpack也提供了module.exports的方法，所以两端的模块是可以共用的。&lt;/p&gt;
&lt;p&gt;而第二个问题，我们使用了Promise，也在webpack全局引入了babel-polyfill，但是会报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&lt;span&gt;Uncaught TypeError: Cannot assign to read only property 'exports' of object '#&amp;lt;Object&amp;gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导致前面的排查思路一直以为是module.exports出了问题；&lt;/p&gt;

&lt;h2&gt;解决方法&lt;/h2&gt;
&lt;p&gt;但最终我们是通过引入es6-promise来解决的：&lt;/p&gt;
&lt;p&gt;service/fetch.js:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; axios = require('axios'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Promise = require('es6-promise'&lt;span&gt;).Promise;

module.exports &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(opts, request) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) {
    axios(opts).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res) {
      res &lt;/span&gt;=&lt;span&gt; res.data
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res.success) {
        resolve(res)
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        reject({ ___req: opts, ___res: res })
      }
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err) {
      reject({ ___req: opts, ___res: err.data &lt;/span&gt;|| err.stack ||&lt;span&gt; err })
    })
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;service/wawa.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; fetch = require('./fetch'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Promise = require('es6-promise'&lt;span&gt;).Promise;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; getGamelist = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(params, req) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) {
    fetch({
      url: &lt;/span&gt;'/api/appeal/appealJoinOrderPage'&lt;span&gt;,
      type: &lt;/span&gt;'get'&lt;span&gt;,
      params: params
    }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res) {
      resolve(res.data)
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err) {
      reject(err)
    })
  })
}

module.exports &lt;/span&gt;=&lt;span&gt; {
  getGamelist
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;并且我们也尝试在全局引入es6-promise，仍然报错；&lt;/p&gt;
&lt;p&gt;这样我们暂时得出结论，是原生Promise语法，直接与module.exports冲突报错。目前只能通过在当前js中引入es6-promise来规避。&lt;/p&gt;

&lt;p&gt;所幸的是，每个js中重复引入的es6-promise，在最终webpack打包的时候会去重，也避免了打包体积变大的问题。&lt;/p&gt;

&lt;p&gt;至此，node前后端代码共用的方案通过。并且后面还可以写除了service以外的共用代码，提升了复用性和可维护性。&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 14:49:00 +0000</pubDate>
<dc:creator>WoodK</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woodk/p/8353573.html</dc:identifier>
</item>
<item>
<title>Logback日志配置的简单使用 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/8353543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/8353543.html</guid>
<description>&lt;h2 id=&quot;logback介绍&quot;&gt;Logback介绍&lt;/h2&gt;
&lt;p&gt;Logback是由log4j创始人设计的又一个开源日志组件。logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个 改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging。logback-access访问模块与Servlet容器集成提供通过Http来访问日志的功能。&lt;/p&gt;
&lt;h2 id=&quot;logback的优点&quot;&gt;Logback的优点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;执行速度快，初始化内存加载小;&lt;/li&gt;
&lt;li&gt;原生实现了 SLF4J API，不需要进行转换;&lt;/li&gt;
&lt;li&gt;配置简单，并可以适应多种环境;&lt;/li&gt;
&lt;li&gt;可以定时的删除过期日志;&lt;/li&gt;
&lt;li&gt;更为强大的过滤器，不必因更改日志级别而产生大量的日志;&lt;/li&gt;
&lt;li&gt;可以从 IO 错误中进行恢复;&lt;/li&gt;
&lt;li&gt;....&lt;br/&gt;关于logback的优点还有很多，这里我就不一一列举了。详细的可以查看官方的Api文档。&lt;br/&gt;地址:&lt;a href=&quot;https://logback.qos.ch/documentation.html&quot; class=&quot;uri&quot;&gt;https://logback.qos.ch/documentation.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;logback的配置说明&quot;&gt;Logback的配置说明&lt;/h2&gt;
&lt;p&gt;关于这块的配置说明，我就简单的列举一些比较常用配置来进行说明。如果还想了解更多，请看官方的文档说明。&lt;/p&gt;
&lt;h3 id=&quot;logback的层级说明&quot;&gt;Logback的层级说明&lt;/h3&gt;
&lt;p&gt;简单的层级结构，实际有更多，仅供参考。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;configuration  
    root
    logger                     
    property                        
    appender 
        layout 
        rollingPolicy
           Pattern
           fileNamePattern
           maxFileSize
           maxHistory
           totalSizeCap&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;具体说明&quot;&gt;具体说明&lt;/h3&gt;
&lt;h4 id=&quot;configuration-根节点-一般有三个属性分别是scanscanperiod和debug&quot;&gt;configuration 根节点， 一般有三个属性，分别是scan、scanPeriod和debug。&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;scan:是否自动加载，默认为true。&lt;/li&gt;
&lt;li&gt;scanPeriod:监听修改时间间隔，默认一分钟。&lt;/li&gt;
&lt;li&gt;debug: 是否查看logback运行状态，默认true。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么我们要使用这个的话，可以进行如下配置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;configuration  scan=&quot;true&quot; scanPeriod=&quot;30 seconds&quot; debug=&quot;true&quot;&amp;gt;
...
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;root-和logger-子节点用于指定输入的日志级别&quot;&gt;root 和logger 子节点，用于指定输入的日志级别。&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;root ：这个是指定主日志的级别。&lt;/li&gt;
&lt;li&gt;logger :这个是指定自定义日志的级别。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:root 指定的日志级别就是用类进行输出的日志,例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  private static Logger LOG = LoggerFactory.getLogger(logbackTest.class);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;logger 指定的日志级别是自定义的级别，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static Logger LOG2 = LoggerFactory.getLogger(&quot;oneInfo&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;他们的用法如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;logger name=&quot;oneInfo&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&amp;gt;
       &amp;lt;appender-ref ref=&quot;ONE_INFO&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;root level=&quot;INFO&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;STDOUT&quot;/&amp;gt;
        &amp;lt;appender-ref ref=&quot;FILE&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明二&lt;/strong&gt;: level 是日志输出的级别，additivity表示是否在控制台打印该日志。&lt;/p&gt;
&lt;h4 id=&quot;property-子节点一般用来定义变量值有两个属性name和value类似java中map的key和value&quot;&gt;property 子节点，一般用来定义变量值。有两个属性name和value。类似Java中Map的key和value。&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;name: 变量的名称&lt;/li&gt;
&lt;li&gt;value: 变量的值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用法如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;property name=&quot;LOG_HOME&quot; value=&quot;logs/pcm&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明:value指定的文件路径，会在项目同级目录下自动生成，无需手动创建。&lt;/p&gt;
&lt;h4 id=&quot;appender-子节点负责写日志的组件有两个属性name和class&quot;&gt;appender 子节点，负责写日志的组件。有两个属性，name和class。&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;name: 自定义名称。&lt;/li&gt;
&lt;li&gt;class:对应自定义名称的全限定名，就是使用何种方式进行日志的输出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个非常重要，也可以说是logback的核心吧。简单的用法如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
&amp;lt;/appender&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:定义一个STDOUT名称，在控制台进行输出。&lt;/p&gt;
&lt;h4 id=&quot;layout和pattern-这两个一般是一起使用的&quot;&gt;layout和Pattern 这两个一般是一起使用的。&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;layout:格式化日志信息;&lt;/li&gt;
&lt;li&gt;Pattern :layout 子节点，定义输出信息的格式;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单的用法如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&amp;gt;
            &amp;lt;Pattern&amp;gt;
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level - %msg%n
            &amp;lt;/Pattern&amp;gt;
&amp;lt;/layout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:Pattern里面格式的%d表示输出的时间格式，%thread 表示输出的线程名称，%-5level 表示字符宽度，%msg 表示输出的信息，%n表示换行。&lt;/p&gt;
&lt;h4 id=&quot;rollingpolicyfilenamepatternmaxfilesize-maxhistory和totalsizecap-这些一般用于对日志进行滚动也就是日志切割管理之类的&quot;&gt;rollingPolicy、fileNamePattern、maxFileSize、 maxHistory和totalSizeCap 这些一般用于对日志进行滚动，也就是日志切割管理之类的。&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;rollingPolicy: 决定日志滚动行为，一般用于日志切割。&lt;/li&gt;
&lt;li&gt;fileNamePattern:必要的节点，一般用于指定日志的文件的路径以及生成格式。&lt;/li&gt;
&lt;li&gt;maxFileSize:单个日志文件最大值，达到之后就进行切割。&lt;/li&gt;
&lt;li&gt;maxHistory:日志文件最多保留的天数，也就是过期时间。&lt;/li&gt;
&lt;li&gt;totalSizeCap : 日志文件总体的最大值，达到之后就不再产生日志。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单的用法如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_HOME}/mylog-%d{yyyy-MM-dd}.%i.txt&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;maxFileSize&amp;gt;10MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;maxHistory&amp;gt;31&amp;lt;/maxHistory&amp;gt;
            &amp;lt;totalSizeCap&amp;gt;10GB&amp;lt;/totalSizeCap&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
    &amp;lt;/appender&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:这段的配置意义是，每天产生一个日志文件，如果超出了10M，日志就进行切割，并且在日志文件名称上加一，日志文件最多保持31天，日志文件总共最大为10G。&lt;/p&gt;
&lt;h2 id=&quot;logback使用说明&quot;&gt;Logback使用说明&lt;/h2&gt;
&lt;p&gt;在对logback日志的配置文件进行了简单的说明之后，那我们来简单的使用logback吧。&lt;br/&gt;logback.xml 使用需要依赖三个 jar 包，分别是 slf4j-api，logback-core，logback-classic。&lt;br/&gt;mavan配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
     &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
     &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    
    
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;logback-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功在maven添加依赖包之后，我们写个简单的demo来测试下吧。&lt;br/&gt;定义三个log日志，一个主log，两个自定义log。&lt;br/&gt;整体配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;configuration  scan=&quot;true&quot; scanPeriod=&quot;30 seconds&quot; debug=&quot;true&quot;&amp;gt;
    &amp;lt;property name=&quot;LOG_HOME&quot; value=&quot;logs/pcm&quot;/&amp;gt;
    &amp;lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
        &amp;lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&amp;gt;
            &amp;lt;Pattern&amp;gt;
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level - %msg%n
            &amp;lt;/Pattern&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_HOME}/mylog-%d{yyyy-MM-dd}.%i.txt&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;maxFileSize&amp;gt;10MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;maxHistory&amp;gt;31&amp;lt;/maxHistory&amp;gt;
            &amp;lt;totalSizeCap&amp;gt;10GB&amp;lt;/totalSizeCap&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&amp;gt;
            &amp;lt;Pattern&amp;gt;
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level - %msg%n
            &amp;lt;/Pattern&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    
    &amp;lt;appender name=&quot;ONE_INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;!-- rollover daily --&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_HOME}/oneInfo/%d{yyyy-MM-dd}/oneInfo.%i.txt&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;maxFileSize&amp;gt;10MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;maxHistory&amp;gt;31&amp;lt;/maxHistory&amp;gt;
            &amp;lt;totalSizeCap&amp;gt;10GB&amp;lt;/totalSizeCap&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&amp;gt;
            &amp;lt;Pattern&amp;gt;
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level - %msg%n
            &amp;lt;/Pattern&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    
    &amp;lt;appender name=&quot;TWO_INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;!-- rollover daily --&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_HOME}/twoInfo/%d{yyyy-MM-dd}/twoInfo.%i.txt&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;maxFileSize&amp;gt;10MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;maxHistory&amp;gt;31&amp;lt;/maxHistory&amp;gt;
            &amp;lt;totalSizeCap&amp;gt;10GB&amp;lt;/totalSizeCap&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&amp;gt;
            &amp;lt;Pattern&amp;gt;
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level - %msg%n
            &amp;lt;/Pattern&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    
    &amp;lt;logger name=&quot;oneInfo&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&amp;gt;
       &amp;lt;appender-ref ref=&quot;ONE_INFO&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&quot;twoInfo&quot; level=&quot;WARN&quot; additivity=&quot;true&quot;&amp;gt;
       &amp;lt;appender-ref ref=&quot;TWO_INFO&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    
    &amp;lt;root level=&quot;INFO&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;STDOUT&quot;/&amp;gt;
        &amp;lt;appender-ref ref=&quot;FILE&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;

&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后分别在控制台输出和文件中进行输出。&lt;br/&gt;该java的代码示例如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 
* Title: logbackTest
* Description:
* logback日志测试 
* Version:1.0.0  
* @author pancm
* @date 2018年1月24日
 */
public class logbackTest {
    private static Logger LOG = LoggerFactory.getLogger(logbackTest.class);
    private static Logger LOG2 = LoggerFactory.getLogger(&quot;oneInfo&quot;);
    private static Logger LOG3 = LoggerFactory.getLogger(&quot;twoInfo&quot;);
    
    public static void main(String[] args) {
        test();
    }
    
    private static void test(){

        LOG.debug(&quot;主程序的debug&quot;);
        LOG.info(&quot;主程序的info&quot;);
        LOG.warn(&quot;主程序的warn&quot;);
        LOG.error(&quot;主程序的error&quot;);
        
        LOG2.debug(&quot;oneInfo的debug&quot;);
        LOG2.info(&quot;oneInfo的info&quot;);
        LOG2.warn(&quot;oneInfo的warn&quot;);
        LOG2.error(&quot;oneInfo的error&quot;);
        
        LOG3.debug(&quot;twoInfo的debug&quot;);
        LOG3.info(&quot;twoInfo的info&quot;);
        LOG3.warn(&quot;twoInfo的warn&quot;);
        LOG3.error(&quot;twoInfo的error&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180125223411264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;日志的生成目录:&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180125223435387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出结果的说明:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LOG： 因为设置打印的级别是info，所以debug级别的不会打印 。&lt;/li&gt;
&lt;li&gt;LOG2: 因为自定义配置设定的是 additivity=&quot;false&quot; 不在控制台打印。 所以一条都不会打印，但是debug级别以上的日志可以在logs/pcm/oneInfo中查看。&lt;/li&gt;
&lt;li&gt;LOG3: 因为自定义配置设定的是 additivity=&quot;true&quot; 可以在控制台打印。所以会打印两条warn级别的日志，日志也可以在logs/pcm/oneInfo中查看。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;参考:&lt;br/&gt;&lt;a href=&quot;https://logback.qos.ch/documentation.html&quot; class=&quot;uri&quot;&gt;https://logback.qos.ch/documentation.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/warking/p/5710303.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/warking/p/5710303.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到此，本文的logback日志简单讲解结束，谢谢阅读！&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 14:37:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/8353543.html</dc:identifier>
</item>
<item>
<title>跟我一起读postgresql源码(十三)——Executor(查询执行模块之——Join节点(上)) - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/8331425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/8331425.html</guid>
<description>&lt;p&gt;JOIN节点有以下三种：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    T_NestLoopState,
    T_MergeJoinState,
    T_HashJoinState,&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连接类型节点对应于关系代数中的连接操作，PostgreSQL中定义了如下几种&lt;strong&gt;连接类型&lt;/strong&gt;(以T1 JOIN T2 为例)：&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1)Inner Join:内连接，将T1的所有元组与T2中所有满足连接条件的元组进行连接操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2)Left Outer Join:左连接，在内连接的基础上，对于那些找不到可连接T2元组的T1元组，用一个空值元组与之连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;3)Right Outer Join:右连接，在内连接的基础上，对于那些找不到可连接T1元组的T2元组，用一个空值元组与之连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;4)Full Outer Join:全外连接，在内连接的基础上，对于那些找不到可连接T2元组的T1元组，以及那些找不到可连接T1元组的T2元组，都要用一个空值元组与之连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;5)Semi Join:类似IN操作，当T1的一个元组在T2中能够找到一个满足连接条件的元组时，返回该T1元组，但并不与匹配的T2元组连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;6)Anti Join:类型NOT IN操作，当T1的一个元组在T2中未找到满足连接条件的元组时，返回该T1元组与空元组的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们再看看postgres用户手册里是怎么说的：&lt;/p&gt;
&lt;p&gt;条件连接：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 ON boolean_expression
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 USING ( join column list )
T1 NATURAL { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样看起来，只有头四种连接方式(INNER, LEFT JOIN, RIGHT JOIN, FULL JOIN)在SQL语句中显示使用了，后两种其实是作为postgres内部使用的，例如Semi Join，我之前说过对于SubqueryScan节点，有可能把ANY和EXIST子句转换为半连接。半连接就是Semi Join。&lt;/p&gt;
&lt;p&gt;而对于你所指定的&lt;strong&gt;连接方式&lt;/strong&gt;，PostgreSQL内部会见机行事，使用不同的&lt;strong&gt;连接操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里，postgres实现了三种连接操作，分别是：&lt;strong&gt;嵌套循环连接(Nest Loop)、归并连接(Merge Join)和Hash连接(Hash Join)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中归并连接算法可以实现上述六种连接，而嵌套循环连接和Hash连接只能实现 Inner Join、Left Outer Join、Semi Join 和 AntiJoin四种连接。&lt;/p&gt;
&lt;p&gt;如图6-52所示，连接节点有公共父类Join, Join继承了 Plan的所有属性，并扩展定义了 jointype用以存储连接的类型，joinqual用于存储连接的条件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct Join
{
    Plan        plan;
    JoinType    jointype;
    List       *joinqual;       /* JOIN quals (in addition to plan.qual) */
} Join;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的执行状态节点JoinState中定义了jointype存储连接类型，joinqual存储连接条件初始化后的状态链表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct JoinState
{
    PlanState   ps;
    JoinType    jointype;
    List       *joinqual;       /* JOIN quals (in addition to ps.qual) */
} JoinState;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;nestloop节点&quot;&gt;1.NestLoop节点&lt;/h2&gt;
&lt;p&gt;NestLoop节点实现了嵌套循环连接方法，能够进行Inner Join、Left Outer Join、Semi Join和Anti Join四种连接方式。&lt;br/&gt;举例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# explain select a.*,b.* from test_dm a join test_dm2 b on a.id &amp;gt; b.id;
                                   QUERY PLAN
--------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..150000503303.17 rows=3333339000000 width=137)
   Join Filter: (a.id &amp;gt; b.id)
   -&amp;gt;  Seq Scan on test_dm2 b  (cost=0.00..223457.17 rows=10000017 width=69)
   -&amp;gt;  Materialize  (cost=0.00..27346.00 rows=1000000 width=68)
         -&amp;gt;  Seq Scan on test_dm a  (cost=0.00..22346.00 rows=1000000 width=68)
(5 行)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct NestLoop
{
    Join        join;
    List       *nestParams;     /* list of NestLoopParam nodes */
} NestLoop;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NestLoop节点在Join节点的基础上扩展了nestParams字段，这个字段nestParams是一些执行器参数的列表，这些参数的用处是将外部子计划的当前行执行值传递到内部子计划中。目前主要的传递形式是Var型，这个数据结构的定义在：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;src/include/nodes/primnodes.h
Var - expression node representing a variable (ie, a table column)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是状态节点NestLoopState的定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct NestLoopState
{
    JoinState   js;             /* its first field is NodeTag */
    bool        nl_NeedNewOuter;            //true if need new outer tuple on next call
    bool        nl_MatchedOuter;            //true if found a join match for current outer tuple
    TupleTableSlot *nl_NullInnerTupleSlot;  //prepared null tuple for left outer joins
} NestLoopState;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NestLoop节点的初始化过程(ExecEndNestLoop函数)中初始化NestLoopState节点，构造表达式上下文这些自不必说，还会对节点中连接条件(joinqual字段)进行处理，转化为对应的状态节点JoinState中的joinqual链表。并且对于LEFT JOIN和ANTI JOIN会初始化一个nl_NullInnerTupleSlot。why？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为对于T1 JOIN T2，当T1的一个元组在T2中未找到满足连接条件的元组时，这两种连接方式会返回该T1元组与空元组的连接，这个空元组就是由nl_NullInnerTupleSlot实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后还将进行如下两个操作：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1)将nl_NeedNewOuter标记为true,表示需要获取左子节点元组。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;2)将nl_MatchedOuter标记为false,表示没有找到与当前左子节点元组匹配的右子节点元组。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;初始化就是这些。&lt;/p&gt;
&lt;p&gt;接下来是NESTLOOP的执行过程(ExecNestLoop函数)。&lt;/p&gt;
&lt;p&gt;循环嵌套连接的基本思想如下(以表R(左关系)与表S(右关系)连接为例)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    FOR each tuple s in S DO
        FOR each tuple r in R DO

            IF r and s join to make a tuple t THEN
            output t;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了迭代实现此方法，NestLoopState中定义了字段nl_NeedNewOuter和nl_MatchedOuter。当元组处于内层循环时，nl_NeedNewOuter为false,内层循环结束时nl_NeedNewOuter设置为true。为了能够处理Left Outer Join和Anti Join,需要知道内层循环是否找到了满足连接条件的内层元组，此信息由nl_MatchedOuter记录，当内层循环找到符合条件的元组时将其标记为true。&lt;/p&gt;
&lt;p&gt;NestLoop执行过程主要是由ExecNestLoop函数来做。该函数主要是一个如上面提到的一个大循环。&lt;/p&gt;
&lt;p&gt;该循环执行如下操作：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&amp;lt;1&amp;gt;如果nl_NeedNewOuter为true，则从左子节点获取元组，若获取的元组为NULL则返回空元组并结束执行过程。如果nLNeedNewOuter为false,则继续进行步骤2。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&amp;lt;2&amp;gt;从右子节点获取元组，若为NULL表明内层扫描完成，设置nl_NeedNewOuter为true,跳过步骤3继续循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&amp;lt;3&amp;gt;判断右子节点元组是否与当前左子节点元组符合连接条件，若符合则返回连接结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上过程能够完成Inner Join的递归执行过程。但是为了支持其他几种连接则还需要如下两个特殊的处理：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;1)当找到符合连接条件的元组后将nl_MatchedOuter标记为true。内层扫描完毕时，通过判断nl_MatchedOuter即可知道是否已经找到满足连接条件的元组，在处理Left Outer Join和Anti Join时需要进行与空元组(nl_NullInnerTupleSlot)的连接，然后将nLMatchedOuter设置为false。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;2)当找到满足匹配条件的元组后，对于Semi JOIN和Anti JOIN方法需要设置nl_NeedNewOuter为true。区别在于Anti Join需要不满足连接条件才能返回，所以要跳过返回连接结果继续执行循环。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;NestLoop节点的清理过程(ExecEndNestLoop函数)没有特殊处理，只需递归调用左右子节点的清理过程。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;mergejoin-节点&quot;&gt;2.MergeJoin 节点&lt;/h2&gt;
&lt;p&gt;Mergejoin实现了对排序关系的归并连接算法，归并连接的输人都是已经排好序的。PostgreSQL中Mergejoin算法实现的伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Join {
        get initial outer and inner tuples              INITIALIZE
        do forever {
            while (outer != inner) {                    SKIP_TEST
                if (outer &amp;lt; inner)
                    advance outer                       SKIPOUTER_ADVANCE
                else
                    advance inner                       SKIPINNER_ADVANCE
            }
            mark inner position                         SKIP_TEST
            do forever {
                while (outer == inner) {
                    join tuples                         JOINTUPLES
                    advance inner position              NEXTINNER
                }
                advance outer position                  NEXTOUTER
                if (outer == mark)                      TESTOUTER
                    restore inner position to mark      TESTOUTER
                else
                    break   // return to top of outer loop
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;算法首先初始化左右子节点，然后执行以下操作(其中对于大小的比较都是指对连接属性值的比较)：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1)扫描到第一个匹配的位置，如果左子节点(outer)较大，从右子节点(inner)中获取元组；如果右子节点较大，从左子节点中获取元组。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2)标记右子节点当前的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;3)循环执行左子节点==右子节点判断，若符合则连接元组，并获取下一条右子节点元组，否则退出循环执行步骤4。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;4)获取下一条左子节点元组。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;5)如果左子节点==标记处的右子节点(说明该条左子节点与上一条相等)，需要将右子节点扫描位置回退到扫描位置，并返冋步骤3;否则跳转到步骤1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了说明归并排序的连接算法，我们以Inner Join为例给出部分执行过程，两个current分别指向输人的当前元组，mark用于标记扫描的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1)首先找到左右序列第一个匹配位置，下图中current(outer)=0小于Current(inner)，因此outer的current向后移动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180125214422537-708248351.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2)如图所示，当找到匹配项后，则进行连接，使用mark标记当前inner的扫描位置，并将inner的current向后移动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180125214429350-510156311.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3)接着判断current(outer) = 1小于current(inner) =2,则将outer的current向后移动，并判断outer是否与mark相同(这是为了发现outer的current与前一个相同的情况)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180125214437225-1639741470.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4)下图显示current(outer) =2不等于mark(inner) = 1，则继续扫描过程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180125214441975-1715887229.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5)判断两个current是否相同，发现Currem(outer)=2等于current(inner)=2，则进行连接，同样标记inner的当前位置，并将inner的cuirent向后移动，如下图所示。其中的current(inner) = 2仍满足连接条件，因此连接完成后inner的current继续向后移动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180125214456772-1600966403.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6)如下图所示，current(outer)=2 小于current(inner)=5,则将 outer的current指针向后移动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180125214513069-920484113.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7)此时判断current(outer)和mark(inner)相等，则将inner的current指向mark的位置，重新获取inner的元组进行匹配，如下图所示。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180125214518631-1709641532.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8)不断重复这样的匹配模式，直到inner或outer中的一方被扫描完毕，则表示连接完成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MergeJoin节点的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct MergeJoin
{
    Join        join;
    List       *mergeclauses;   /* mergeclauses as expression trees */
    /* these are arrays, but have the same length as the mergeclauses list: */
    Oid        *mergeFamilies;  /* per-clause OIDs of btree opfamilies */
    Oid        *mergeCollations;    /* per-clause OIDs of collations */
    int        *mergeStrategies;    /* per-clause ordering (ASC or DESC) */
    bool       *mergeNullsFirst;    /* per-clause nulls ordering */
} MergeJoin;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该节点在join的基础上扩展定义了几个mergexxx字段。其中mergeclauses存储用于计算左右子节点元组是否匹配的表达式链表，mergeFamilies、mergeCollations、mergeStrategies、mergeNullsFirst均与表达式链表对应，表明其中每一个操作符的操作符类、执行的策略(ASC或DEC)以及空值排序策略。&lt;/p&gt;
&lt;p&gt;在初始化过程中，会使用Mergejoin构造MergeJoinState结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct MergeJoinState
{
    JoinState   js;             /* its first field is NodeTag */
    int         mj_NumClauses;
    MergeJoinClause mj_Clauses; /* array of length mj_NumClauses */
    int         mj_JoinState;
    bool        mj_ExtraMarks;
    bool        mj_ConstFalseJoin;
    bool        mj_FillOuter;
    bool        mj_FillInner;
    bool        mj_MatchedOuter;
    bool        mj_MatchedInner;
    TupleTableSlot *mj_OuterTupleSlot;
    TupleTableSlot *mj_InnerTupleSlot;
    TupleTableSlot *mj_MarkedTupleSlot;
    TupleTableSlot *mj_NullOuterTupleSlot;
    TupleTableSlot *mj_NullInnerTupleSlot;
    ExprContext *mj_OuterEContext;
    ExprContext *mj_InnerEContext;
} MergeJoinState;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过对于连接类型的判断来设置如下几个变量的值：&lt;/p&gt;
&lt;p&gt;1)mj_FillOuter:为true表示不能忽略没有匹配项的左子节点元组，需要与空元组进行连接，在 LEFT JOIN、ANTI JOIN 和 FULL JOIN时为true。&lt;/p&gt;
&lt;p&gt;2)mj_FillInner:为true表示不能忽略没有匹配项的右子节点元组，需要与空元组进行连接，在 RIGHT JOIN、FULL JOIN 时为 true。&lt;/p&gt;
&lt;p&gt;3)mj_InnerTupleSlot:为右子节点元组生成的空元组，在mj_FillOuter为真时构造。&lt;/p&gt;
&lt;p&gt;4)mj_OuterTupleSlot:为左子节点元组生成的空元组，在mj_FillInner为真时构造。&lt;/p&gt;
&lt;p&gt;除此之外，需要将标记当前左(右)子节点元组是否找到能够连接的元组的变量mj_MatchedOuter(mj_MatchedInner)设置为 false,将存储左(右)子节点元组的字段mj_NullOuterTupleSlot(mj_InnerTupleSlot)设置为 NULL,并为mj_MarkedTupleSlot分配存储空间。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;还剩一个hashjoin，我看了半天看不太懂，下篇再说吧~&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 13:54:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/8331425.html</dc:identifier>
</item>
<item>
<title>Spring Cache - Dan_Go</title>
<link>http://www.cnblogs.com/daniels/p/8331509.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daniels/p/8331509.html</guid>
<description>&lt;p&gt;&lt;code&gt;　　缓存&lt;/code&gt;是实际工作中非常常用的一种提高性能的方法, 我们会在许多场景下来使用缓存。本文通过一个简单的例子进行展开，通过对比我们原来的自定义缓存和 spring 的基于注释的 cache 配置方法，展现了 spring cache 的强大之处，然后介绍了其基本的原理，扩展点和使用场景的限制。通过阅读本文，你应该可以短时间内掌握 spring 带来的强大缓存技术，在很少的配置下即可给既有代码提供缓存能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Spring Cache 介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Spring 3.1 引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如EHCache 或者 OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。从Spring 4.1开始，通过&lt;a title=&quot;JSR-107&quot; href=&quot;https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/integration.html#cache-jsr-107&quot; target=&quot;_blank&quot;&gt;JSR-107&lt;/a&gt;注释和更多定制选项的支持，缓存抽象得到了显着改善。&lt;/p&gt;
&lt;p&gt;　　Spring 的缓存技术还具备相当的灵活性，不仅能够使用 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/core.html#expressions-beandef&quot; target=&quot;_blank&quot;&gt;SpEL（Spring Expression Language）&lt;/a&gt;来定义缓存的 key 和各种 condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存例如 EHCache 集成。&lt;/p&gt;
&lt;p&gt;其特点总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过少量的配置 annotation 注释即可使得既有代码支持缓存&lt;/li&gt;
&lt;li&gt;支持开箱即用 Out-Of-The-Box，即不用安装和部署额外第三方组件即可使用缓存&lt;/li&gt;
&lt;li&gt;支持 Spring Express Language，能使用对象的任何属性或者方法来定义缓存的 key 和 condition&lt;/li&gt;
&lt;li&gt;支持 AspectJ，并通过其实现任何方法的缓存支持&lt;/li&gt;
&lt;li&gt;支持自定义 key 和自定义缓存管理者，具有相当的灵活性和扩展性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　本文将针对上述特点对 Spring cache 进行详细的介绍，主要通过一个简单的例子和原理来展开介绍，同时会介绍一些我们平时使用需要特别注意的地方以及使用限制，然后我们将一起看一个比较实际的缓存例子，最后会介绍Spring如何去集成第三方的缓存解决方案。在详细介绍如何使用Spring cache之前，我们不妨先想一下，如果不使用Spring cache,我们来自己实现一个Cache，你会怎么来做呢？下面使我自己的实现方式，看看和你想的是否相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;自定义Cache实现方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：创建实体类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.gao.cache;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * @Date: 20:09 2018/1/23 0023
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Account &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getId() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第二步： 创建服务接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.gao.cache;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * @Date: 20:15 2018/1/23 0023
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; AccountService {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    Account getAccountById();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     Account UpdateAccount(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Account account);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteAccountById();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     List&amp;lt;Account&amp;gt;&lt;span&gt; getAccountsByName();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第三步：创建默认的服务类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.gao.cache.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.gao.cache.Account;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.gao.cache.AccountService;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * @Date: 20:21 2018/1/23 0023
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultAccountService &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountService {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(DefaultAccountService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Account getAccountById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         logger.info(&quot;real querying db {..}&quot;&lt;span&gt;, id);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Account(id);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Account UpdateAccount(Account account) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         logger.info(&quot;update account to db&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; account;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteAccountById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         logger.info(&quot;delete account from db&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Account&amp;gt;&lt;span&gt; getAccountsByName(String name) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         logger.info(&quot;querying from db&quot;&lt;span&gt;, name);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Arrays.asList(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Account(name));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第四步：创建缓存管理器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.gao.cache;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentHashMap;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * @Date: 21:37 2018/1/23 0023
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CacheManagement&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, T&amp;gt; cache = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, T&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; T get(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache.get(key);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put(&lt;span&gt;final&lt;/span&gt; String key, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; T value) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        cache.put(key, value);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; evict(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; System key) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(cache.containsKey(key)){
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            cache.remove(key);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reload(){
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        cache.clear();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第五步：创建服务代理类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.gao.cache.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.gao.cache.Account;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.gao.cache.AccountService;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.gao.cache.CacheManagement;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * @Date: 21:50 2018/1/23 0023
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; @Service(&quot;defaultAccountServiceProxy&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultAccountServiceProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountService {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(DefaultAccountServiceProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     @Resource(name = &quot;defaultAccountService&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountService accountService;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    @Resource
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; CacheManagement&amp;lt;Account&amp;gt;&lt;span&gt; cacheManagement;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Account getAccountById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         Account account =&lt;span&gt; cacheManagement.get(String.valueOf(id));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (account == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             Account account1 =&lt;span&gt; accountService.getAccountById(id);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            cacheManagement.put(String.valueOf(account1.getId()), account1);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; account1;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             logger.info(&quot;get account from cache&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; account;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Account UpdateAccount(Account account) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         Account account1 =&lt;span&gt; accountService.UpdateAccount(account);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         logger.info(&quot;update cache value&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        cacheManagement.put(String.valueOf(account1.getId()), account1);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; account1;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteAccountById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        accountService.deleteAccountById(id);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         logger.info(&quot;delete from cache&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        cacheManagement.evict(String.valueOf(id));
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Account&amp;gt;&lt;span&gt; getAccountsByName(String name) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第六步：创建测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.gao.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.gao.cache.Account;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.gao.cache.AccountService;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.junit.Assert.assertNotNull;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * @Date: 22:14 2018/1/23 0023
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CacheTest {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(CacheTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountService accountService;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    @Before
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUp() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         ClassPathXmlApplicationContext classPathXmlApplicationContext =
&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         accountService = classPathXmlApplicationContext.getBean(&quot;defaultAccountServiceProxy&quot;, AccountService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testInject() {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        assertNotNull(accountService);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testCache() {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         accountService.getAccountById(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         accountService.getAccountById(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         accountService.deleteAccountById(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         accountService.getAccountById(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         accountService.getAccountById(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         Account account = &lt;span&gt;new&lt;/span&gt; Account(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        accountService.UpdateAccount(account);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         accountService.getAccountById(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果如下，完全按照了我们之前预测的那样，这样我就实现了一个简单的Cache功能，接下来们来看看Spring给我们提供的Cache功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
DefaultAccountService - real querying db {..}
 DefaultAccountServiceProxy - get account from cache
 DefaultAccountService - delete account from db
 DefaultAccountServiceProxy - delete from cache
 DefaultAccountService - real querying db {..}
 DefaultAccountServiceProxy - get account from cache
 DefaultAccountService - update account to db
 DefaultAccountServiceProxy - update cache value
 DefaultAccountServiceProxy - get account from cache
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;通过Spirng Cache重新来实现上述的功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：重写服务实体类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.gao.cache.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.gao.cache.Account;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.gao.cache.AccountService;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CacheEvict;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CachePut;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.Cacheable;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * @Auther: dan gao
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; * @Description:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; * @Date: 20:21 2018/1/23 0023
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; @Service(&quot;defaultAccountService&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultAccountService &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountService {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(DefaultAccountService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     @Cacheable(value = &quot;accounts&quot;, key = &quot;#p0&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Account getAccountById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         logger.info(&quot;real querying db {..}&quot;&lt;span&gt;, id);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Account(id);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     @CachePut(cacheNames=&quot;accounts&quot;, key=&quot;#p0.getId()&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Account UpdateAccount(Account account) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         logger.info(&quot;update account to db&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; account;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     @CacheEvict(cacheNames=&quot;accounts&quot;, key = &quot;#p0&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteAccountById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         logger.info(&quot;delete account from db&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Account&amp;gt;&lt;span&gt; getAccountsByName(String name) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         logger.info(&quot;querying from db&quot;&lt;span&gt;, name);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Arrays.asList(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Account(name));
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第二步：写测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; dan.gao.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.gao.cache.Account;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; dan.gao.cache.AccountService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.junit.Assert.assertNotNull;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Auther: dan gao
 * @Description:
 * @Date: 22:14 2018/1/23 0023
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CacheTest {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(CacheTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountService accountService;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountService spirngCacheAccountService;

    @Before
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUp() {
        ClassPathXmlApplicationContext classPathXmlApplicationContext &lt;/span&gt;=
                &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
        accountService &lt;/span&gt;= classPathXmlApplicationContext.getBean(&quot;defaultAccountServiceProxy&quot;, AccountService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        spirngCacheAccountService &lt;/span&gt;= classPathXmlApplicationContext.getBean(&quot;defaultAccountService&quot;, AccountService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testInject() {
        assertNotNull(accountService);
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testCache() {
        accountService.getAccountById(&lt;/span&gt;1&lt;span&gt;);
        accountService.getAccountById(&lt;/span&gt;1&lt;span&gt;);
        accountService.deleteAccountById(&lt;/span&gt;1&lt;span&gt;);
        accountService.getAccountById(&lt;/span&gt;1&lt;span&gt;);
        accountService.getAccountById(&lt;/span&gt;1&lt;span&gt;);
        Account account &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Account(2&lt;span&gt;);
        accountService.UpdateAccount(account);
        accountService.getAccountById(&lt;/span&gt;2&lt;span&gt;);
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSpringCache(){
        spirngCacheAccountService.getAccountById(&lt;/span&gt;1&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;#########&quot;&lt;span&gt;);
        spirngCacheAccountService.getAccountById(&lt;/span&gt;1&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;#########&quot;&lt;span&gt;);
        spirngCacheAccountService.deleteAccountById(&lt;/span&gt;1&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;#########&quot;&lt;span&gt;);
        spirngCacheAccountService.getAccountById(&lt;/span&gt;1&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;#########&quot;&lt;span&gt;);
        spirngCacheAccountService.getAccountById(&lt;/span&gt;1&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;#########&quot;&lt;span&gt;);
        Account account &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Account(2&lt;span&gt;);
        spirngCacheAccountService.UpdateAccount(account);
        logger.info(&lt;/span&gt;&quot;#########&quot;&lt;span&gt;);
        spirngCacheAccountService.getAccountById(&lt;/span&gt;2&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;#########&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下，我们明显得可以看出我们的Cache已经成功运行。 通过Spring Cache注解的方式我们可以很轻松的给原有的方法加上缓存的功能，不需要写任何的代码，看起来是不是很酷。接下来我将详细介绍之前在服务类中使用的注解，让我们可以在项目中更加灵活的使用它们。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
DefaultAccountService - real querying db {..}
 CacheTest - #########
 CacheTest - #########
 DefaultAccountService - delete account from db
 CacheTest - #########
 DefaultAccountService - real querying db {..}
 CacheTest - #########
 CacheTest - #########
 DefaultAccountService - update account to db
 CacheTest - #########
 CacheTest - #########
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;cache-annotations-cacheable&quot;&gt;&lt;strong&gt;1. @Cacheable annotation&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　从上面的测试结果我们明显的看出来使用了@Cacheable注解的方法，当第一次请求过之后，第二次再使用相同的参数调用时，方法就不会再执行了。这是因为当我们第一次请求之后，spring cache会将执行结果与我们定义的Key以key-value的形式存储起来，第二次请求时会先用key在缓存中找，看能不能找到结果。如果找到的话，就不会在执行方法体，直接返回缓存中的结果。如果没有找，就会执行方法体，在方法执行完成之后，再将执行结果与key保存到缓存里边。在我们的代码中getAccountById方法与名为acounts的缓存相关联。 每次调用该方法时，都会检查缓存以查看调用是否已经执行并且不必重复。 在大多数情况下，只声明一个缓存，注释允许指定多个名称，以便使用多个缓存。 在这种情况下，将在执行方法之前检查每个缓存 - 如果至少有一个缓存被命中，则返回相关的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@Cacheable(cacheNames = {&quot;accounts&quot;, &quot;default&quot;}, key = &quot;#p0&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Account getAccountById(&lt;span&gt;long&lt;/span&gt; id) {..}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;在这一有一点我们需要注意，即使缓存的方法没有被执行，但是其他不包含该值的缓存也会被更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 由于缓存本质上是键值存储，所以缓存方法的每次调用都需要被转换为适合缓存访问的密钥。Spring cache默认的key基于以下算法的简单KeyGenerator：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果没有给出参数，则返回SimpleKey.EMPTY。&lt;/li&gt;
&lt;li&gt;如果只给出一个参数，则返回该实例。&lt;/li&gt;
&lt;li&gt;如果给出了超过一个参数，返回一个包含所有参数的SimpleKey。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　这种方法适用于大多数使用情况; 只要参数具有自然键并实现有效的hashCode（）和equals（）方法。 如果情况并非如此，那么战略就需要改变。为了提供不同的默认密钥生成器，需要实现org.springframework.cache.interceptor.KeyGenerator接口。@Cacheable注解允许用户指定如何通过其关键属性来生成密钥。 开发人员可以使用SpEL来选择感兴趣的参数（或它们的嵌套属性），执行操作，甚至调用任意方法，而不必编写任何代码或实现任何接口。 这是默认生成器的推荐方法，因为方法与代码库增长的方式在签名方面会有很大差异; 而默认策略可能适用于某些方法，但对于所有方法都很少。下面是各种SpEL声明的一些例子 - 如果你不熟悉它，请阅读&lt;a href=&quot;https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/core.html#expressions&quot; target=&quot;_blank&quot;&gt;Spring Expression Language&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
@Cacheable(cacheNames=&quot;books&quot;, key=&quot;#isbn&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book findBook(ISBN isbn, &lt;span&gt;boolean&lt;/span&gt; checkWarehouse, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; includeUsed)

@Cacheable(cacheNames&lt;/span&gt;=&quot;books&quot;, key=&quot;#isbn.rawNumber&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book findBook(ISBN isbn, &lt;span&gt;boolean&lt;/span&gt; checkWarehouse, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; includeUsed)

@Cacheable(cacheNames&lt;/span&gt;=&quot;books&quot;, key=&quot;T(someType).hash(#isbn)&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book findBook(ISBN isbn, &lt;span&gt;boolean&lt;/span&gt; checkWarehouse, &lt;span&gt;boolean&lt;/span&gt; includeUsed)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码片断展示了选择某个参数，它的一个属性，甚至是一个任意的（静态）方法特别的便捷。如果负责生成密钥的算法过于具体，或者需要共享，则可以在操作中定义一个自定义密钥生成器。 为此，请指定要使用的KeyGenerator bean实现的名称：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@Cacheable(cacheNames=&quot;books&quot;, keyGenerator=&quot;myKeyGenerator&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book findBook(ISBN isbn, &lt;span&gt;boolean&lt;/span&gt; checkWarehouse, &lt;span&gt;boolean&lt;/span&gt; includeUsed)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;但在这个我们需要注意的是key和keyGenerator我们同时只能指定一个，否则将会产生操作异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在多线程环境中，某些操作可能会同时调用相同的参数（通常在启动时）。 默认情况下，缓存抽象不会锁定任何内容，并且可能会多次计算相同的值，从而导致缓存失效。对于这些特定情况，可以使用sync属性指示基础缓存提供者在计算值时锁定缓存条目。 结果，只有一个线程忙于计算值，而其他线程被阻塞，直到在高速缓存中更新条目。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@Cacheable(cacheNames=&quot;foos&quot;, sync=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foo executeExpensiveOperation(String id) {...}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这是一个可选的功能，你选择的缓存库可能并不支持这个功能，核心框架提供的所有CacheManager实现都支持它。 请查看你选择的缓存库的文档查看详细信息。&lt;/p&gt;
&lt;p&gt;　　有时候，一个方法可能并不适合于所有的缓存（例如，它可能取决于给定的参数）。缓存注释通过条件参数来支持这样的功能，该条件参数采用被评估为真或假的SpEL表达式。如果为true，则该方法被缓存 - 如果不是，则其行为就像该方法没有被缓存，每当无论缓存中的值或使用什么参数时都执行该方法。一个简单的例子 - 只有参数名称的长度小于32时才会缓存以下方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@Cacheable(cacheNames=&quot;book&quot;, condition=&quot;#name.length() &amp;lt; 32&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book findBook(String name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外还可以使用条件参数unless来否决向缓存添加值。 与condition不同，unless在方法被调用之后评估表达式。 扩展前面的例子 - 也许我们只想缓存paperback books：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@Cacheable(cacheNames=&quot;book&quot;, condition=&quot;#name.length() &amp;lt; 32&quot;, unless=&quot;#result.hardback&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book findBook(String name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的例子我们直接是用了result.hardback，如果result返回为null呢？我们上边的写法并不安全，为了结果这个问题，我们可以向下边这样来写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@Cacheable(cacheNames=&quot;book&quot;, condition=&quot;#name.length() &amp;lt; 32&quot;, unless=&quot;#result?.hardback&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Optional&amp;lt;Book&amp;gt; findBook(String name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个SpEL表达式都会重新声明一个专用的上下文。 除了内置参数外，框架还提供了与参数名称相关的专用缓存相关元数据。 详细信息请查看&lt;a href=&quot;https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/integration.html#cache-spel-context&quot; target=&quot;_blank&quot;&gt;Available caching SpEL evaluation context&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;2. @CachePut annotation &lt;/h4&gt;
&lt;p&gt;　　对于需要在不干扰方法执行的情况下更新缓存的情况，可以使用@CachePut注解。 也就是说，这个方法总是被执行，并且它的结果放入缓存。 它支持与@Cacheable相同的选项，应该用于缓存填充而不是方法流程优化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@CachePut(cacheNames=&quot;accounts&quot;, key=&quot;#p0.getId()&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Account UpdateAccount(Account account)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　请注意，在同一个方法上使用@CachePut和@Cacheable注解通常是冲突的，因为它们有不同的行为。 后者导致使用缓存跳过方法执行，前者强制执行以执行缓存更新。 这会导致意想不到的行为，除了特定的角落案例（例如具有排除他们的条件的注释）之外，应该避免这种声明。 还要注意，这样的条件不应该依赖于结果对象（即#result变量），因为它们是预先验证的以确认排除。&lt;/p&gt;
&lt;h4&gt;3. @CacheEvict annotation&lt;/h4&gt;
&lt;p&gt;　　Spring Cache不仅允许缓存存储，而且还可以删除。此过程对于从缓存中删除过时或未使用的数据很有用。与@Cacheable相反，注解@CacheEvict划定了执行缓存删除的方法，即充当从缓存中移除数据的触发器的方法。就像其兄弟一样，@CacheEvict需要指定一个（或多个）受操作影响的缓存，允许指定自定义的缓存和密钥解析或条件，但另外还有一个额外的参数allEntries，来判断是否删除缓存中的所有数据而不仅仅只是一条数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@CacheEvict(cacheNames=&quot;books&quot;, allEntries=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; loadBooks(InputStream batch)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　当需要清除整个缓存区域时，这个选项会派上用场，而不是逐条清除每个条目（这会耗费很长的时间，因为效率很低），所有的条目在一个操作中被删除，如上所示。请注意，该框架将忽略在此方案中指定的任何key，因为它不适用（删除整个缓存不仅仅是一个条目）。我们还可以通过也beforeInvocation属性来指定缓存清除的时间。beforeInvocation=true表明不管方法有没有被成功执行都先清除缓存。beforeInvocation=false则表明只有当方法成功执行之后，才进行缓存清理动作。默认beforeInvocation=false。需要注意的是void方法可以和@CacheEvict一起使用 - 由于这些方法充当触发器，所以返回值被忽略（因为它们不与缓存交互） - @Cacheable并不是这种情况，它添加/将数据更新到缓存中并因此需要结果。&lt;/p&gt;
&lt;h4&gt;4. @Caching annotation&lt;/h4&gt;
&lt;p&gt;　　在某些情况下，需要指定相同类型的多个注释（例如@CacheEvict或@CachePut），例如因为条件或密钥表达式在不同的缓存之间是不同的。 @Caching允许在同一个方法上使用多个嵌套的@Cacheable，@CachePut和@CacheEvict：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@Caching(evict = { @CacheEvict(&quot;primary&quot;), @CacheEvict(cacheNames=&quot;secondary&quot;, key=&quot;#p0&quot;&lt;span&gt;) })
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book importBooks(String deposit, Date date)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的代码表示当方法被成功执行之后会删除缓存primary中的所有数据，同时删除缓存池secondary中key=传入参数deposit的那一条数据。&lt;/p&gt;
&lt;h4&gt;5. @CacheConfig annotation&lt;/h4&gt;
&lt;p&gt;　　到目前为止，我们已经看到，缓存操作提供了许多定制选项，可以在操作基础上进行设置。 但是，如果某些自定义选项适用于该类的所有操作，则可能会进行繁琐的配置。 例如，指定要用于该类的每个缓存操作的缓存的名称可以由单个类级别的定义替换。 这是@CacheConfig使用的地方：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@CacheConfig(&quot;books&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BookRepositoryImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BookRepository {

    @Cacheable
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Book findBook(ISBN isbn) {...}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;@CacheConfig是一个类级注释，允许共享缓存名称，自定义KeyGenerator，自定义CacheManager和自定义CacheResolver。 将该注释放在类上不会启用任何缓存操作。在方法上定制缓存配置将始终覆盖@CacheConfig上的定制设置。&lt;/p&gt;
&lt;h4&gt;6. 开启缓存功能&lt;/h4&gt;
&lt;p&gt;　　需要注意的是，即使声明缓存注释并不会自动触发它们的动作 - 就像Spring中的许多事情一样，这个功能必须被声明性地启用（这意味着如果你怀疑是缓存引起的问题的话，你可以通过删除一个配置行，而不是代码中的所有注释，来关闭缓存）。要启用缓存注释，请将注释@EnableCaching添加到您的@Configuration类之一中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@EnableCaching
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AppConfig {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者使用Spring配置文件来进行开启&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
       xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
       xmlns:cache&lt;/span&gt;=&quot;http://www.springframework.org/schema/cache&quot;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/cache&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/cache/spring-cache.xsd&quot;&amp;gt;&lt;/span&gt;
    &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;dan.gao&quot;/&amp;gt;
    &amp;lt;cache:annotation-driven /&amp;gt;
    &amp;lt;bean id=&quot;cacheManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.cache.support.SimpleCacheManager&quot;&amp;gt;
        &amp;lt;property name=&quot;caches&quot;&amp;gt;
            &amp;lt;set&amp;gt;
                &amp;lt;bean &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot;&amp;gt;
                    &amp;lt;property name=&quot;name&quot; value=&quot;default&quot;/&amp;gt;
                &amp;lt;/bean&amp;gt;
                &amp;lt;bean &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot;&amp;gt;
                    &amp;lt;property name=&quot;name&quot; value=&quot;accounts&quot;/&amp;gt;
                &amp;lt;/bean&amp;gt;
            &amp;lt;/set&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在上面的配置中&amp;lt;cache:annotation-driven /&amp;gt;表示开启缓存。因为Spring cache是只是提供了一个抽象的缓存管理，因此我们还需要创建cacheManager对象和Cahce对象。在本次的例子中我是用了Spring默认给我们提供的SimpleCacheManager和ConcurrentMapCacheFactoryBean， 并且创建了两个缓存池default和accounts.&lt;/p&gt;
&lt;p&gt;　　直到现在，我们已经学会了如何使用开箱即用的 spring cache，这基本能够满足一般应用对缓存的需求。但现实总是很复杂，当你的用户量上去或者性能跟不上，总需要进行扩展，这个时候你或许对其提供的内存缓存不满意了，因为其不支持高可用性，也不具备持久化数据能力，这个时候，你就需要自定义你的缓存方案了。&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 13:53:00 +0000</pubDate>
<dc:creator>Dan_Go</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daniels/p/8331509.html</dc:identifier>
</item>
<item>
<title>JVM GC杂谈之理论入门 - Secondworld</title>
<link>http://www.cnblogs.com/Kidezyq/p/8353217.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kidezyq/p/8353217.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;jvm堆布局介绍&quot;&gt;JVM堆布局介绍&lt;/h2&gt;
&lt;p&gt;​ JVM堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor，其中两个Survivor区的大小一致。&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math inline&quot;&gt;\(堆新生代老年代老年代java堆 = 新生代(Young) + 老年代(Old) = 老年代(Old) + Eden + From Survivor + To Survivor\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ 特殊参数说明：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;–XX:NewRatio&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;老年代(Old):新生代的值(Young)，默认为2的情况下：老年代占整个堆的2/3,新生代占1/3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;–XX:SurvivorRatio&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Eden:一个Survivor区的值，默认为8的情况下：Eden区占整个新生代的8/10,FromSurvivor和ToSurvivor各占1/10&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;h2 id=&quot;gc的分类&quot;&gt;GC的分类&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Minor GC(Young GC): 发生在新生代的垃圾收集工作。新生代几乎是所有对象出生的地方（当然存在例外，如果对象内存分配的时候发现新生代空间不够的时候会将对象直接分配在老年区）。&lt;br/&gt;Java中大部分对象不需要长久存活，因此新生代是GC发生最频繁的地方。简单的GC流程大致是:&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/922893/201801/922893-20180125211105006-1508567011.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Full GC(Major GC):发生在老年代的垃圾收集动作。没有Minor GC那么频繁。且耗时比Minor GC要久的多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;两种gc的触发条件&quot;&gt;两种GC的触发条件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Minor GC：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;新生代GC的触发情况很简单，就是当在新生代Eden或者某个Survivor区创建对象内存不够的时候，就会尝试Minor GC。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;如何判断对象是否存活&quot;&gt;如何判断对象是否存活&lt;/h2&gt;
&lt;p&gt;​ GC-Garbage Collection。垃圾回收，也就是回收&quot;垃圾&quot;对象。那么如何判断一个对象是否是垃圾对象呢？&lt;/p&gt;
&lt;p&gt;当一个对象不被程序中的任何对象引用的时候，我们可以认为该对象是垃圾对象，可以被收集掉。具体算法包括:&lt;/p&gt;
&lt;h2 id=&quot;引用计数法&quot;&gt;引用计数法&lt;/h2&gt;
&lt;p&gt;​ 每个对象都有一个引用计数器，当有对象引用它时，计数器+1；当引用失效时，计数器-1；任何时刻计数器为0时就是不可能再被使用的。&lt;/p&gt;
&lt;p&gt;​ 下图中左图是对象的引用关系，中图有一个引用失效，右图是清理引用计数器=0的对象后。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/922893/201801/922893-20180125210830819-1696027657.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 缺点：&lt;/p&gt;
&lt;p&gt;关于循环引用的对象无法回收的分析参照下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/922893/201801/922893-20180125211126865-563668322.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;根搜索&quot;&gt;根搜索&lt;/h2&gt;
&lt;p&gt;​ 根搜索算法的出现，就是为了解决循环引用的时候引用计数法无法判断对象是否可以被回收的问题。&lt;/p&gt;
&lt;p&gt;其算法的核心在于，只要对象没有一条到根对象的可达路径，就可以被回收。&lt;/p&gt;
&lt;p&gt;​ 那么什么对象才可以认为是根对象呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟机栈的栈帧的局部变量表所引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈的JNI所引用的对象&lt;/li&gt;
&lt;li&gt;方法区的静态变量和常量所引用的对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/922893/201801/922893-20180125211143225-1926673807.jpg&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;gc算法&quot;&gt;GC算法&lt;/h2&gt;
&lt;h2 id=&quot;mark-sweep标记-清除算法&quot;&gt;Mark-Sweep(标记-清除)算法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/922893/201801/922893-20180125211202397-1236763817.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 分为两个阶段:&lt;/p&gt;
&lt;p&gt;存在的两个问题:&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;标记和清除的效率都不高（标记和清除都需要对堆中的所有对象进行遍历）,且在GC的时候需要停止整个应用（即发生STOP THE WORLD）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;被标记的对象在内存中的位置可能不连续，回收之后可能会导致空间碎片太多&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;copying复制算法&quot;&gt;Copying(复制)算法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/922893/201801/922893-20180125211212990-2100572463.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 在标记-清除算法上做的简单优化，主要思路是：将可用内存分为相等大小的两份（活动区间和空闲区间），每次只使用其中的一份（活动区间）。在进行GC的时候，首先将活动区间的存活对象依次复制到空闲区间，然后再全量清除活动区间即可。每次GC之后，活动区间和空闲区间就会交换过来。&lt;/p&gt;
&lt;p&gt;​ 这种GC算法的优点有:&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;GC的时候效率较高：复制存活对象到空闲区间的时候，只需移动堆指针分配合适大小内存即可。清除的时候对活动区间可以做全量清除。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以保证内存连续性: 复制存活对象到空闲区间的时候严格按照在活动区间的内存位置先后按顺序连续分配内存&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，这种GC算法的缺点也很明显：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;50%的内存浪费：必须要有一块与活动区间同等大小的空闲区间，用来做GC复制操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对象存活率高的情况下，会存在大量的重复存活对象的复制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mark-compact标记整理标记压缩算法&quot;&gt;Mark-Compact(标记/整理、标记/压缩)算法&lt;/h2&gt;
&lt;p&gt;​ 针对前两个GC算法的改进。标记的过程和Mark-Sweep算法一致。第二个整理的步骤为:移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/922893/201801/922893-20180125211239381-584468885.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mark-sweep-compact标记-清理-压缩整理算法&quot;&gt;Mark-Sweep-Compact(标记-清理-压缩/整理)算法&lt;/h2&gt;
&lt;p&gt;​ 该算法在Mark-Compact算法的基础上进一步做了改进。结合使用了Mark-Sweep和Mark-Compact算法。并不是每次标记清理都会执行压缩，而是多次GC之后，才会执行一次压缩。这种实现，减少了移动对象的成本。&lt;/p&gt;
&lt;h2 id=&quot;jvm分代收集算法&quot;&gt;JVM分代收集算法&lt;/h2&gt;
&lt;p&gt;​ 严格的来讲，这个不能叫做一个算法。而只能叫做JVM垃圾收集的一个实现策略。该策略基于以下的弱分代假设：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;大多数对象的生存时间都很短，很快就会变得不可达&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;只有少数情况才会出现老年代对象持有新生代对象的引用，即新生代对象很少引用老年代对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JVM也根据这个特性，将堆内存分为两部分：新生代和老年代。针对不同的部分采用不同的垃圾收集算法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;Mark-Sweep&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;不需要额外空间&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;两次扫描，耗时严重&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;N&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;老年代&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;Copying&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;没有标记和清除&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;需要额外空间&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;N&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;新生代&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;Mark-Compact&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;没有内存碎片&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;需要移动对象的成本&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Y&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;N&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;老年代&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;​&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;gc收集器类型&quot;&gt;GC收集器类型&lt;/h2&gt;
&lt;p&gt;​ 前面所讲的堆的布局，堆被分为新生代、老年代。其实就是利用了大部分对象存活时间都较短这个特性。合理的利用不同的垃圾收集算法来处理收集对象。对应各种不同的垃圾收集算法，也就产生了各种GC收集器。具体列表如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;Serial&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;SerialOld&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;ParNew&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;ParallelOld&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;Parallel Scavenge&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CMS&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面就来对各种收集器进行一一说明：&lt;/p&gt;
&lt;h2 id=&quot;年轻代收集器&quot;&gt;年轻代收集器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Serial收集器:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Serial收集器是Hotspot运行在Client模式下的&lt;strong&gt;默认新生代收集器&lt;/strong&gt;, 采用Copying算法进行垃圾回收。它的特点是 &lt;strong&gt;只用一个CPU/一条收集线程去完成GC工作, 且在进行垃圾收集时会发生STW(Stop The World)&lt;/strong&gt;.虽然是单线程收集, 但它省去了多线程上下文切换的开销，简单而高效, 在JVM管理内存不大的情况下(收集几十M~一两百M的新生代), 停顿时间完全可以控制在几十毫秒~一百多毫秒内。当然缺点也很明显：没法利用目前主流机器的多核多CPU优势。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参数控制：&lt;strong&gt;-XX:+UseSerialGC&lt;/strong&gt;** **串行收集器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;ParNew收集器：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ParNew收集器其实是前面&lt;strong&gt;Serial的多线程版本&lt;/strong&gt;, 除&lt;strong&gt;使用多条线程进行GC&lt;/strong&gt;外, 包括Serial可用的所有控制参数、收集算法、STW、对象分配规则、回收策略等都与Serial完全一样(也是JVM启用CMS收集器&lt;code&gt;-XX: +UseConcMarkSweepGC&lt;/code&gt;的默认新生代收集器)。&lt;/p&gt;
&lt;p&gt;由于存在线程切换的开销, ParNew在单CPU的环境中比不上Serial, 且在通过超线程技术实现的两个CPU的环境中也不能100%保证能超越Serial. 但随着可用的CPU数量的增加, 收集效率肯定也会大大增加(默认ParNew收集线程数与CPU的数量相同, 因此在CPU数量过大的环境中, 可用&lt;code&gt;-XX:ParallelGCThreads&lt;/code&gt;参数控制GC线程数)。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;参数控制：&lt;strong&gt;-XX:+UseParNewGC&lt;/strong&gt; ParNew收集器&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;-XX:ParallelGCThreads&lt;/strong&gt; 限制线程数量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Parallel Scavenge收集器:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与ParNew类似, Parallel Scavenge也是&lt;strong&gt;使用复制算法&lt;/strong&gt;, 也是&lt;strong&gt;并行多线程收集器&lt;/strong&gt;. 但与其他收集器关注&lt;em&gt;尽可能缩短垃圾收集时间&lt;/em&gt;不同, Parallel Scavenge更关注&lt;strong&gt;系统吞吐量&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;系统吞吐量=运行用户代码时间(运行用户代码时间+垃圾收集时间)&lt;/p&gt;
&lt;p&gt;停顿时间越短就越适用于用户交互的程序-良好的响应速度能提升用户的体验;而高吞吐量则适用于后台运算而不需要太多交互的任务-可以最高效率地利用CPU时间,尽快地完成程序的运算任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关的参数如下:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;-XX:+UseParallelGC&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;使用Parallel收集器+ 老年代串行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;MaxGCPauseMillis&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;(毫秒数) 收集器将尽力保证内存回收花费的时间不超过设定值, 但如果太小将会导致GC的频率增加.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;GCTimeRatio&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;(整数:&lt;code&gt;0 &amp;lt; GCTimeRatio &amp;lt; 100&lt;/code&gt;) 是垃圾收集时间占总时间的比率&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;8&quot;&gt;&lt;td align=&quot;center&quot;&gt;-XX:+UseAdaptiveSizePolicy&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;启用GC自适应的调节策略: 不再需要手工指定&lt;code&gt;-Xmn&lt;/code&gt;、&lt;code&gt;-XX:SurvivorRatio&lt;/code&gt;、&lt;code&gt;-XX:PretenureSizeThreshold&lt;/code&gt;等细节参数, VM会根据当前系统的运行情况收集性能监控信息, 动态调整这些参数以提供最合适的停顿时间或最大的吞吐量&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;老年代收集器&quot;&gt;老年代收集器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Serial Old收集器：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;是Serial收集器的老年代版本。同样是单线程收集器，使用Mark-Compact算法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDK1.5之前与Parallel Scavenge配合使用&lt;/li&gt;
&lt;li&gt;作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候启用&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Parallel Old收集器：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Parallel Old是Parallel Scavenge收老年代版本, 使用&lt;strong&gt;多线程和Mark-Compact算法, 吞吐量优先&lt;/strong&gt;, 主要与Parallel Scavenge配合在 &lt;em&gt;注重吞吐量&lt;/em&gt; 及 &lt;em&gt;CPU资源敏感&lt;/em&gt; 系统内使用。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参数控制：&lt;strong&gt;-XX:+UseParallelOldGC&lt;/strong&gt; 使用Parallel收集器+ 老年代并行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;CMS收集器：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Concurrent Mark Sweep。从全称上就可以看出，CMS收集器是基于Mark-Sweep算法实现的。CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中部署在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的相应速度，希望系统停顿时间最短，以给用户带来较好的体验。&lt;/p&gt;
&lt;p&gt;CMS收集器是Sun HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集器线程和用户线程同时工作。CMS收集器的工作机制也比其他收集器更加复杂，具体来说整个过程可以分为以下4个阶段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Initial Mark(初始标记阶段): 只是标记以下根对象(GC Roots)能直接关联的对象，速度很快，但是仍然需要&lt;strong&gt;STW&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Concurrent Mark(并发标记阶段): 进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程&lt;/li&gt;
&lt;li&gt;Remark(重新标记阶段):为了修正并发标记期间，因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要&lt;strong&gt;STW&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Concurrent Sweep(并发清除阶段): 清除GC Roots不可达对象，和用户线程一起工作，不需要暂停线程&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;由于耗时最长的并发标记和并发清除阶段，垃圾收集线程和用户线程是一起工作的，所以总体来说，减少了STW的时间，缩短了应用的相应时间。但是这样的设计也存在一下不足：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;对CPU资源非常敏感： CMS默认启动的回收线程数=(CPU数目+3)4。当CPU数&amp;gt;4时, GC线程最多占用不超过&lt;code&gt;25%&lt;/code&gt;的CPU资源, 但是当CPU数&amp;lt;=4时, GC线程可能就会过多的占用用户CPU资源, 从而导致应用程序变慢, 总吞吐量降低。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;无法处理浮动垃圾，可能出现&lt;em&gt;Promotion Failure&lt;/em&gt;、&lt;em&gt;Concurrent Mode Failure&lt;/em&gt;而导致另一次Full GC的产生：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;浮动垃圾是指在CMS并发清理阶段用户线程运行而产生的新垃圾. 由于在GC阶段用户线程还需运行, 因此还需要预留足够的内存空间给用户线程使用, 导致CMS不能像其他收集器那样等到老年代几乎填满了再进行收集. 因此CMS提供了&lt;code&gt;-XX:CMSInitiatingOccupancyFraction&lt;/code&gt;参数来设置GC的触发百分比(以及&lt;code&gt;-XX:+UseCMSInitiatingOccupancyOnly&lt;/code&gt;来启用该触发百分比), 当老年代的使用空间超过该比例后CMS就会被触发(JDK 1.6之后默认92%). 但当CMS运行期间预留的内存无法满足程序需要, 就会出现上述&lt;em&gt;Promotion Failure&lt;/em&gt;等失败, 这时JVM将启动后备预案: 临时启用Serial Old收集器来重新执行Full GC(CMS通常配合大内存使用, 一旦大内存转入串行的Serial GC, 那停顿的时间就是大家都不愿看到的了)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无法避免内存碎片：CMS的收集算法不涉及整理/压缩的步骤，可能会产生大量内存碎片. 内存碎片过多可能会导致无法分配大对象而提前触发Full GC. 因此CMS提供了&lt;code&gt;-XX:+UseCMSCompactAtFullCollection&lt;/code&gt;开关参数, 用于在Full GC后再执行一个碎片整理过程. 但内存整理是无法并发的, 内存碎片问题虽然没有了, 但停顿时间也因此变长了, 因此CMS还提供了另外一个参数&lt;code&gt;-XX:CMSFullGCsBeforeCompaction&lt;/code&gt;用于设置在执行N次不进行内存整理的Full GC后, 跟着来一次带整理的(默认为0: 每次进入Full GC时都进行碎片整理)。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;相关参数设置如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;-XX:+UseConcMarkSweepGC&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;使用CMS收集器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;-XX:+ UseCMSCompactAtFullCollection&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Full GC后，进行一次碎片整理；整理过程会STW&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;-XX:+CMSFullGCsBeforeCompaction&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;设置进行几次Full GC后，进行一次碎片整理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;-XX:ParallelCMSThreads&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;设定CMS的线程数量（一般情况约等于可用CPU数量）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;分区收集---g1收集器&quot;&gt;分区收集---G1收集器：&lt;/h2&gt;
&lt;p&gt;​ JDK7引入了G1(Garbage-First)是一款面向服务端应用的收集器, 主要目标用于配备多颗CPU的服务器治理大内存.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;gt;- G1 is planned as the long term replacement for the Concurrent Mark-Sweep Collector (CMS).
    &amp;gt;- -XX:+UseG1GC 启用G1收集器.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;空间整合：G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。&lt;/li&gt;
&lt;li&gt;可预测停顿：这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;​ 前面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。&lt;/p&gt;
&lt;p&gt;​ 每块区域既有可能属于O区、也有可能是Y区, 因此不需要一次就对整个老年代/新生代回收. 而是当线程并发寻找可回收的对象时, 有些区块包含可回收的对象要比其他区块多很多. 虽然在清理这些区块时G1仍然需要暂停应用线程, 但可以用相对较少的时间优先回收垃圾较多的Region(这也是G1命名的来源). 这种方式保证了G1可以在有限的时间内获取尽可能高的收集效率.&lt;/p&gt;
&lt;p&gt;​ G1的新生代收集跟ParNew类似: 存活的对象被转移到一个/多个Survivor Regions. 如果存活时间达到阀值, 这部分对象就会被提升到老年代.&lt;/p&gt;
&lt;p&gt;​ G1的新生代收集特点如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;一整块堆内存被分为多个Regions.&lt;/li&gt;
&lt;li&gt;存活对象被拷贝到新的Survivor区或老年代.&lt;/li&gt;
&lt;li&gt;年轻代内存由一组不连续的heap区组成, 这种方法使得可以动态调整各代区域尺寸.&lt;/li&gt;
&lt;li&gt;Young GCs会有STW事件, 进行时所有应用程序线程都会被暂停.&lt;/li&gt;
&lt;li&gt;多线程并发GC.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;​ G1老年代垃圾收集的步骤:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Initial Mark(初始标记): 在G1中, 该操作附着一次Young GC, 以标记Survivor中有可能引用到老年代对象的Regions. 该阶段会&lt;strong&gt;STW&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Root Region Scanning(根区域扫描)：程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在Young GC之前完成&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Concurrent Marking(并发标记)：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被Young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;Remark(重新标记)：完成堆内存中存活对象的标记. 使用&lt;strong&gt;snapshot-at-the-beginning(SATB, 起始快照)&lt;/strong&gt;算法, 比CMS所用算法要快得多(空Region直接被移除并回收, 并计算所有区域的活跃度).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cleanup(清理):&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Performs accounting on live objects and completely free regions. (Stop the world)&lt;/li&gt;
&lt;li&gt;Scrubs the Remembered Sets. (Stop the world)&lt;/li&gt;
&lt;li&gt;Reset the empty regions and return them to the free list. (Concurrent)&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;Copying(复制): These are the stop the world pauses to evacuate or copy live objects to new unused regions. This can be done with young generation regions which are logged as &lt;code&gt;[GC pause (young)]&lt;/code&gt;. Or both young and old generation regions which are logged as &lt;code&gt;[GC Pause (mixed)]&lt;/code&gt;.选择”活跃度”最低的区域(这些区域可以最快的完成回收). 拷贝/转移存活的对象到新的尚未使用的regions.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;|&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​ G1收集器的相关特性:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;Concurrent Marking Phase&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;Liveness information is calculated concurrently while the application is running.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;This liveness information identifies which regions will be best to reclaim during an evacuation pause.&lt;/li&gt;
&lt;li&gt;There is no sweeping phase like in CMS.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Remark Phase&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;Uses the Snapshot-at-the-Beginning (SATB) algorithm which is much faster then what was used with CMS.&lt;/li&gt;
&lt;li&gt;Completely empty regions are reclaimed.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Copying/Cleanup Phase&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;Young generation and old generation are reclaimed at the same time.&lt;/li&gt;
&lt;li&gt;Old generation regions are selected based on their liveness.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;常用收集器组合&quot;&gt;常用收集器组合&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;Serial&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Serial Old&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;Serial&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CMS+Serial Old&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;ParNew&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CMS&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;使用-XX:+UseParNewGC选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew GC策略。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot;&gt;ParNew&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Serial Old&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;使用-XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;Parallel Scavenge&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Serial Old&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;Parallel Scavenge&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Parallel Old&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Parallel Old是Serial Old的并行版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;G1GC&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;G1GC&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC #开启- XX:MaxGCPauseMillis =50 #暂停时间目标 -XX:GCPauseIntervalMillis =200 #暂停间隔目标 -XX:+G1YoungGenSize=512m #年轻代大小 -XX:SurvivorRatio=6 #幸存区比例&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;h2 id=&quot;jvm相关工具说明&quot;&gt;JVM相关工具说明&lt;/h2&gt;
&lt;p&gt;在${JAVA_HOME}/bin/目录下Sun/Oracle给我们提供了一些处理应用程序性能问题、定位故障的工具, 包含&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;jps&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;打印Hotspot VM进程&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;VMID、JVM参数、&lt;code&gt;main()&lt;/code&gt;函数参数、主类名/Jar路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;jstat&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;查看Hotspot VM &lt;strong&gt;运行时&lt;/strong&gt;信息&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;类加载、内存、GC[&lt;strong&gt;可分代查看&lt;/strong&gt;]、JIT编译&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;jinfo&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;查看和修改虚拟机各项配置&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-flag name=value&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td align=&quot;center&quot;&gt;jmap&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;heapdump: 生成VM堆转储快照、查询finalize执行队列、Java堆和永久代详细信息&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;jmap -dump:live,format=b,file=heap.bin [VMID]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;jstack&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;查看VM当前时刻的线程快照: 当前VM内每一条线程正在执行的方法堆栈集合&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;Thread.getAllStackTraces()&lt;/code&gt;提供了类似的功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td align=&quot;center&quot;&gt;javap&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;查看经javac之后产生的JVM字节码代码&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;自动解析&lt;code&gt;.class&lt;/code&gt;文件, 避免了去理解class文件格式以及手动解析class文件内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td align=&quot;center&quot;&gt;jcmd&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;一个多功能工具, 可以用来导出堆, 查看Java进程、导出线程信息、 执行GC、查看性能相关数据等&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;几乎集合了jps、jstat、jinfo、jmap、jstack所有功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td align=&quot;center&quot;&gt;jconsole&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;基于JMX的可视化监视、管理工具&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;可以查看内存、线程、类、CPU信息, 以及对JMX MBean进行管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;jvisualvm&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;JDK中最强大运行监视和故障处理工具&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;可以监控内存泄露、跟踪垃圾回收、执行时内存分析、CPU分析、线程分析…&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;h2 id=&quot;jvm常用参数配置&quot;&gt;JVM常用参数配置&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-Xms&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;最小堆大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-Xmx&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;最大堆大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-Xmn&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;新生代大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-XX:PermSize&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;永久代大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-XX:MaxPermSize&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;永久代最大大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-XX:+PrintGC&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;输出GC日志&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-verbose:gc&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-XX:+PrintGCDetails&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;输出GC的详细日志&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-XX:+PrintGCTimeStamps&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;输出GC时间戳(以基准时间的形式)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-XX:+PrintHeapAtGC&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在进行GC的前后打印出堆的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-Xloggc:/path/gc.log&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;日志文件的输出路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;-XX:+PrintGCApplicationStoppedTime&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;打印由GC产生的停顿时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;blockquote readability=&quot;0.39807692307692&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.importnew.com/14630.html&quot; class=&quot;uri&quot;&gt;http://www.importnew.com/14630.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HS1VT9ww7XOWqKciUOhwUw&quot; class=&quot;uri&quot;&gt;https://mp.weixin.qq.com/s/HS1VT9ww7XOWqKciUOhwUw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://epy.iteye.com/blog/1914455&quot; class=&quot;uri&quot;&gt;http://epy.iteye.com/blog/1914455&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/duke2016/p/6250766.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/duke2016/p/6250766.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ityouknow/p/5614961.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/ityouknow/p/5614961.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sunfie/p/5125283.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/sunfie/p/5125283.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zqhxuyuan.github.io/2016/07/26/JVM/&quot; class=&quot;uri&quot;&gt;http://zqhxuyuan.github.io/2016/07/26/JVM/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.importnew.com/23035.html&quot; class=&quot;uri&quot;&gt;http://www.importnew.com/23035.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html#t5&quot; class=&quot;uri&quot;&gt;http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html#t5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf&quot; class=&quot;uri&quot;&gt;http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 25 Jan 2018 13:42:00 +0000</pubDate>
<dc:creator>Secondworld</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Kidezyq/p/8353217.html</dc:identifier>
</item>
<item>
<title>我的第一个python web开发框架（21）——小结 - AllEmpty</title>
<link>http://www.cnblogs.com/EmptyFS/p/8353338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyFS/p/8353338.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　这个小网站终于成功上线，小白除了收获一笔不多的费用外，还得到女神小美的赞赏，心中满满的成就感。这一天下班后，他请老菜一起下馆子，兑现请吃饭的承诺，顺便让老菜点评一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;小白：&lt;/strong&gt;&lt;/span&gt;老大，在你的指导下终于完成了我人生当中第一个项目，非常感谢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;老菜：&lt;/strong&gt;&lt;/span&gt;挺不错的，在这么短时间完成了一个项目，值得祝贺一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;小白：&lt;/strong&gt;&lt;/span&gt;老大，代码你看了没有，你觉得有什么问题或需要改进的地方吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;老菜：&lt;/strong&gt;&lt;/span&gt;你自己完成后，重新查看代码有什么想法？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;小白：&lt;/strong&gt;&lt;/span&gt;嗯，我觉得有好多地方代码都是一样的，重复的，复制粘贴后改起来容易出错，其他的有些地方感觉代码写起来有点别扭，但说不上来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;老菜：&lt;/span&gt;&lt;/strong&gt;看来项目完成后，你的技术也长进了不少。代码重复是一个框架从无到有发展过程中必须经历的阶段，当然有不少人直接使用别人的框架进行修改可以跳过这个阶段，但他们的感悟就没那么深了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　很多软件开发框架一开始都是很简单很简漏的，它能满足一般的需求，直接明了，一般来说只要严格遵循开发规范，这样的代码可读性也是最好的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而开发人员在整个项目实现的过程中一直在进步，当完成项目以后回头再看看你自己写的东西，就会发现它其实存在着很多不合理的地方，而自己在成长过程中也会学到很多新的知识，可以融入到现有体系中，让已开发出来的框架变得更好更成熟。在自己持续的学习成长过程中，通过对旧框架的重构升级，开发框架也会变得越来越成熟和强大起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你这个框架代码我看了一下，存在以下几个问题：与数据交互的代码重复，没有进行合理封装；前后台系统接口没有分离，权限管理混乱；后台管理系统无权限管理模块，无法控制页面权限，容易引发安全问题；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果有时间的话，你可以抽空重构一下，将数据库读写操作单独分离出来，认真琢磨一下sql代码规律，封装成ORM统一管理；在接口与对数据操作之间加多一个逻辑层，用来放置各种对数据操作的逻辑函数，方便代码的封装与管理；后台与前台代码各自独立出来，分成各自独立的两大前后端系统，方便管理；后台管理系统增加权限管理模块等，暂时想到这些，你可以先弄弄。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　做好这些工作，这个开发框架就可以算得上比较成熟了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;小白：&lt;/strong&gt;&lt;/span&gt;好的，谢谢老大的指点，我会认真学习，再琢磨琢磨的。菜已经上了，我们边吃边聊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　......&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　本系列的第一部分终于完成了，比预想中多花了不少时间，后半部分因为年底各种事情，加上参加了敏捷个人线上练习占用了大量的时间，所以没时间写，一直拖着，没想到拖了这么长时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在开笔之前其实有很多想法，对于前端也想写的很细很细，但编写过程中总会遇到这个那个事情，有这样那样的各种顾虑，所以有时将就了一下，写的并不是太满意。没有前端基础的朋友可能看起来有点吃力，等这个系列全部完成以后，看看有没有可能录制一些视频，直接讲解可能会更容易理解，毕竟很多东西直接讲比较容易，用文字表达起来确实有点头痛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二部分大纲初步整理了一下，大概30多章节，在年后会安排时间慢慢完善更新，大家如果有什么建议可以直接发信息给我。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;一次XXX引起的安全小事故
项目版本控制与接口文档
代码审查与重构
什么是ORM
ORM基类开发
Nosql在ORM中的应用
逻辑层类开发与测试
接口代码重构
后台管理系统权限设计
权限数据库结构设计
后台菜单管理功能
后台主界面菜单实现
部门（角色组）管理功能
职位（角色）管理功能
管理员管理功能
后台接口权限访问控制处理
接口访问加密处理
后台操作日志处理
前后台分离与部署&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;版权声明：本文原创发表于 &lt;a href=&quot;http://www.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;博客园&lt;/a&gt;，作者为 &lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/EmptyFS/&quot; target=&quot;_blank&quot;&gt;AllEmpty&lt;/a&gt; &lt;/strong&gt;本文欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则视为侵权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python开发QQ群：669058475    作者博客：http://www.cnblogs.com/EmptyFS/&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 13:34:00 +0000</pubDate>
<dc:creator>AllEmpty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyFS/p/8353338.html</dc:identifier>
</item>
</channel>
</rss>