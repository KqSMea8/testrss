<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[Design] 高并发与异步 - 黑眼诗人</title>
<link>http://www.cnblogs.com/farwish/p/9513100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/farwish/p/9513100.html</guid>
<description>
&lt;p&gt;既然涉及到高并发这个概念，就少不了先谈这么几个概念，并发数、多进程、多线程、协程、负载均衡。&lt;/p&gt;

&lt;p&gt;操作系统上讲的并发是操作系统上有几个程序在同时执行，而单核CPU在微观上是由CPU调度执行，非同时执行，多核CPU在微观上才是真正的并行。&lt;/p&gt;
&lt;p&gt;互联网产品的并发通常是指并发连接数，用户同时访问数量，哪些因素能影响到并发能力，既有编程模型，也有服务器负载能力。&lt;/p&gt;

&lt;p&gt;PHP 依赖多进程解决并发数，是最原始和耗费资源的一种方式。&lt;/p&gt;
&lt;p&gt;以 8G 内存服务器为例，一个PHP进程占用20M内存，最多也就开几百个进程，假如任务比较耗时且并发很高，那么新请求很快就得不到响应了。&lt;/p&gt;
&lt;p&gt;另外对于并发访问 PHP 提供 curl_multi_* 系列函数，对于纯接口并发调用就不需要自己写多进程、多线程程序了。&lt;/p&gt;

&lt;p&gt;Java是多线程模型，每个进程可以创建多个线程，线程使用进程的上下文，所以每个线程只需要小部分运行资源，所以比进程轻量许多。&lt;/p&gt;

&lt;p&gt;进程和线程都是依赖操作系统的系统调用支持的，所以这部分调度开销是难以避免的。&lt;/p&gt;
&lt;p&gt;协程是程序级的调度模型，最轻量，好比框架级实现像操作系统一样能自由对程序中断、调度，比如借助于 C 的 setjmp 系列函数就能做到中断。&lt;/p&gt;

&lt;p&gt;不管编程模型多先进，单机总会达到并发上限，要想突破限制就必须引入负载均衡，通过横向扩展解决问题。&lt;/p&gt;

&lt;p&gt;上面所提到的编程模型优劣，本质上还都是语言层面的，短期内并不能真正解决问题，下面就延伸出从应用层面的考虑：&lt;/p&gt;
&lt;p&gt;为什么高性能都离不开异步，比如 Swoole ？ 目的就是提升响应时间，提高Qps。&lt;/p&gt;

&lt;p&gt;在我们通常的业务开发过程中，逻辑代码一般是同步阻塞模式，一方面它容易理解，另一方面也方便进行一些测试。&lt;/p&gt;
&lt;p&gt;这些优势再加上大部分业务场景对并发并没有较高的要求，所以是可以接受的。&lt;/p&gt;
&lt;p&gt;但是对于一个大的网站，以及对响应速度和并发要求高的场景，这时候就需要做些优化了，尽量把阻塞操作给异步化。&lt;/p&gt;

&lt;p&gt;通过消息队列来做异步的场景：&lt;/p&gt;
&lt;p&gt;　　加速响应：比如注册后的提醒邮件，注册操作成功后将发消息交给队列，直接返回信息给用户，写入队列的非常快，然后由订阅的异步任务处理邮件发送。&lt;/p&gt;
&lt;p&gt;　　应用解耦：比如用户发帖之后要给他的粉丝推送帖子，这时候实时性要求并不高，可以将新帖的消息写入队列，然后由队列处理程序操作。&lt;/p&gt;
&lt;p&gt;　　流量削峰：比如秒杀活动，我们不需要实时处理一些购买逻辑，只要将用户请求写入消息队列，长度达到限制就提示用户已结束，后续程序再对队列内容处理。&lt;/p&gt;
&lt;p&gt;　　日志收集：日志一般都需要进行写磁盘操作，大访问量会对 I/O 造成压力，降低程序性能；此时可以将日志写入消息队列，由处理程序订阅该队列进行消费。&lt;/p&gt;
&lt;p&gt;　　广播聊天：用户通过订阅频道来获得最新发布的消息。&lt;/p&gt;

&lt;p&gt;实例演示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Pub.php
 *
 * @author farwish
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.连接并选择数据库&lt;/span&gt;
&lt;span&gt;$redis&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; \Redis();

&lt;/span&gt;&lt;span&gt;$bool&lt;/span&gt; = &lt;span&gt;$redis&lt;/span&gt;-&amp;gt;connect('127.0.0.1', 6379, 2.5, &lt;span&gt;null&lt;/span&gt;, 100&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (! &lt;span&gt;$bool&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;('连接失败'&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;$bool&lt;/span&gt; = &lt;span&gt;$redis&lt;/span&gt;-&amp;gt;select(0&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟将一个任务放置队列中, 并发布
//$phone = 13199999999;
//$redis-&amp;gt;lpush('sms-signin', $phone);
//$redis-&amp;gt;publish('sms-signin', $phone);
//

// 2.模拟生成批量数据&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;$i&lt;/span&gt; = 0; &lt;span&gt;$i&lt;/span&gt; &amp;lt; 10; &lt;span&gt;$i&lt;/span&gt;++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;$phone&lt;/span&gt; = &lt;span&gt;mt_rand&lt;/span&gt;(10000000000, 99999999999&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$phone&lt;/span&gt; . &lt;span&gt;PHP_EOL&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟每个任务耗时100ms, 使用 publish 代替方案，在subscribe中处理
    //echo $phone . PHP_EOL;
    //usleep(100000);&lt;/span&gt;

    &lt;span&gt;$redis&lt;/span&gt;-&amp;gt;publish('signin-sms', &lt;span&gt;$phone&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不将消息写入队列，而是每次都自己执行，响应时间很长，用户体验不好。 &lt;/p&gt;
&lt;p&gt;通过订阅程序异步处理任务，用户无感知，并且体验会很好。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Sub.php
 *
 * @author farwish
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.连接并选择数据库&lt;/span&gt;
&lt;span&gt;$redis&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; \Redis();

&lt;/span&gt;&lt;span&gt;$bool&lt;/span&gt;= &lt;span&gt;$redis&lt;/span&gt;-&amp;gt;connect('127.0.0.1', 6379, 2.5, &lt;span&gt;null&lt;/span&gt;, 100&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (! &lt;span&gt;$bool&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;('连接失败'&lt;span&gt;);
}
&lt;br/&gt;// * 阻止 redis read timeout
&lt;/span&gt;&lt;span&gt;$redis&lt;/span&gt;-&amp;gt;setOption(Redis::OPT_READ_TIMEOUT, -1&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.订阅耗时任务并处理
// 如果这个订阅的任务比较重要，将对可用性有要求，日志收集等可以采用。&lt;/span&gt;
&lt;span&gt;$redis&lt;/span&gt;-&amp;gt;subscribe(['signin-sms', 'signin-mail', 'crawler-task-1'], &lt;span&gt;function&lt;/span&gt;(&lt;span&gt;$redis&lt;/span&gt;, &lt;span&gt;$chan&lt;/span&gt;, &lt;span&gt;$msg&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;$chan&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'signin-sms':

            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 耗时1s, 发送并记录数据库&lt;/span&gt;
            &lt;span&gt;sleep&lt;/span&gt;(1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;{&lt;span&gt;$msg&lt;/span&gt;} 发注册短信\n&quot;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'signin-mail':

            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'crawler-task-1':
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他耗时任务，通过 $msg 传递参数来执行&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它常见消息队列产品有 RabbitMQ、ZeroMQ、ActiveMQ、Kafka 可以选择。&lt;/p&gt;

&lt;p&gt;Link：&lt;a href=&quot;https://www.cnblogs.com/farwish/p/9513100.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/farwish/p/9513100.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 21 Aug 2018 15:47:00 +0000</pubDate>
<dc:creator>黑眼诗人</dc:creator>
<og:description>既然涉及到高并发这个概念，就少不了先谈这么几个概念，并发数、多进程、多线程、协程、负载均衡。 操作系统上讲的并发是操作系统上有几个程序在同时执行，而单核CPU在微观上是由CPU调度执行，非同时执行，多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/farwish/p/9513100.html</dc:identifier>
</item>
<item>
<title>Java 多线程之 Thread 类 和 Runnable 接口初步使用 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9515229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9515229.html</guid>
<description>&lt;p&gt;Thread 类是在 JDK1.0 时就存在的， 在 Java 中接触的多线程开发基本上都会从这个类开始。&lt;/p&gt;
&lt;h2 id=&quot;thread之定义线程类&quot;&gt;Thread之定义线程类&lt;/h2&gt;
&lt;p&gt;使用 Thread 创建线程的方法很简单， Thread 是一个类， 在需要创建线程时， 我们只需要继承这个类， 并将 run() 方法进行重写即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class PrimeThread extends Thread {
    long minPrime;
    PrimeThread(long minPrime) {
        this.minPrime = minPrime;
    }
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot; begin&quot;);
        try {
            Thread.sleep(500);
            System.out.println(minPrime);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+&quot; end&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上的 PrimeThread 类， 继承了 Thread 类， 因此， 可以通过该类来实现开启线程。&lt;/p&gt;
&lt;h2 id=&quot;thread之开启线程&quot;&gt;Thread之开启线程&lt;/h2&gt;
&lt;p&gt;开启线程的方法具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    System.out.println(&quot;Thread begin:&quot; + Thread.currentThread().getName());
    PrimeThread primeThread = new PrimeThread(100L);
    primeThread.start();

    System.out.println(&quot;Thread end:&quot; + Thread.currentThread().getName());

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用时， new 出一个 PrimeThread 类的对象， 然后调用 start() 方法(注意不是调用 run() 方法)。最终得到的结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180821233155175?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;运行结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建一个简单的多线程在 Java 里面就是这么简单， 但因为 Java 是单继承的 因此继承 Thread 类是很不划算的一种做法。 而在 JDK1.0 , 提供了另一种方式可以对此进行弥补， 就是实现 Runnable 接口的方式。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;runnable-之定义线程类&quot;&gt;Runnable 之定义线程类&lt;/h2&gt;
&lt;p&gt;至此，使用 Runnable 接口的方式来创建多线程类的方式就是实现 Runnable, 然后重写 run() 方法， 具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PrimeRun implements Runnable {
    long minPrime;

    PrimeRun(long minPrime) {
        this.minPrime = minPrime;
    }

    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot; Run begin&quot;);
        try {
            Thread.sleep(500);
            System.out.println(minPrime);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &quot; Run end&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;runnable-之开启线程&quot;&gt;Runnable 之开启线程&lt;/h2&gt;
&lt;p&gt;大体上与继承 Thread 类类似， 但我们可以不用继承。 调用的话还是要通过 Thread 类的， 调用方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    System.out.println(Thread.currentThread().getName()+&quot; begin&quot;);
    PrimeRun primeRun = new PrimeRun(100L);// new 
    new Thread(primeRun).start(); // 调用

    System.out.println(Thread.currentThread().getName()+&quot; end&quot;);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180821233217116?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;运行结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，其实该两种实现多线程的方式在本质上都是一样的。最终都通过 Thread 类中的 start() 方法来开启线程， 该方法可以通知 「线程规划器」本线程已经准备就绪， 系统就可以安排时间来调用 Thread 类中的 run() 方法。因此， 如果没有分配优先级， 线程执行的顺序就是根据系统的调度算法来执行， 是无序的。&lt;/p&gt;
&lt;p&gt;以上是对 Java 最基本的开启多线程的方法进行了介绍， 后面几篇会更深入一下介绍一下几个方法和原理。&lt;/p&gt;
</description>
<pubDate>Tue, 21 Aug 2018 15:44:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>本文介绍初步介绍 Thread 类 和 Runnable 使用的方法， 为后续的多线程深入做铺垫。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9515229.html</dc:identifier>
</item>
<item>
<title>我来悟微服务(2)-惊魂一刻 - 从此启程</title>
<link>http://www.cnblogs.com/fancunwei/p/9515132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9515132.html</guid>
<description>&lt;p&gt;&lt;strong&gt;电动车牌照&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大上海生活不易，由于住的地方离工作地较远，买车开车消费较大，也相当堵车，做公交也是堵的很慢。所以买了个电动车，上班体验上升很多。昨天看天气还好，就请了个假去上车牌。到交警大队，先验车，然后复印电动车合格证，发票，身份证，居住证。然后排队领证。&lt;/p&gt;
&lt;p&gt;以上事情完毕。重点说下回来途中，路经一个小广场，非机动车道一侧，一个绿化工人双手抬着那种带电机的修草机在修剪冬青。我看着有点危险有靠另一边过去。那家伙突然来个大回环修草机转了圈。把我吓得不轻，差点车倒。还好那里的非机动车宽一些，要不然新车或我的腿得开个口子了。真是气煞我也！停车后，我愤怒的瞪了他一眼，看他脸色也吓得不轻，我也没有继续深究。&lt;/p&gt;
&lt;p&gt;以上事情完毕。&lt;/p&gt;
&lt;p&gt;一条一条来总结&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务授权验证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;办证，办车牌，买房等生活事，在和谐的大中国以及外国，都需要各种证。相互依赖。&lt;/p&gt;
&lt;p&gt;在微服务世界里，也应该提供类似的授权认证。这是一道安全防线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务预警&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路如果太窄，或微服务世界里的硬盘空间不足，网络访问量超限等风险情况，要提前预知，进行报警。现实生活里可以通过鸣笛来提醒对方有人来注意安全，或者行人自主根据安全来即时停下或绕开。这在微服务世界里，都要有对应的体现。要考虑内存，cpu，硬盘，网络访问量等各个维度的监控。根据预警情报自动或人工辅助调节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务分布式监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说起车牌，各种各样的车牌，行驶在大街小巷，在街道鹰眼的监控下，行驶轨迹一幕了然。证换来车牌，鹰眼监控车牌而不直接监控你的身份证。这类似于软件世界里的解藕。我们思路切换到微服务世界，某个关键间合参数生成唯一key，这个key在系统间的任何调用都做记录，形成监控。每个key每时每刻都记录成典，分散开来，无边无界，形成了微服务的分布式业务监控。&lt;/p&gt;
&lt;p&gt;微服务来源于生活，高于生活。&lt;/p&gt;
&lt;p&gt;由于简书手机端操作方便，已首发简书：https://www.jianshu.com/p/2b681b1c7947&lt;/p&gt;
</description>
<pubDate>Tue, 21 Aug 2018 15:23:00 +0000</pubDate>
<dc:creator>从此启程</dc:creator>
<og:description>电动车牌照 大上海生活不易，由于住的地方离工作地较远，买车开车消费较大，也相当堵车，做公交也是堵的很慢。所以买了个电动车，上班体验上升很多。昨天看天气还好，就请了个假去上车牌。到交警大队，先验车，然后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9515132.html</dc:identifier>
</item>
<item>
<title>存储是怎样炼成的？ - 叁金</title>
<link>http://www.cnblogs.com/jixin/p/9515128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jixin/p/9515128.html</guid>
<description>&lt;p&gt;什么FAT,NTFS,NFS,DAS,SAN,NAS,OSD这些名词我一个都不认识。&lt;/p&gt;
&lt;p&gt;不知道各位大佬对上面的名词了解多少，通过上面的一些名词其实可以大致的看到存储是怎样一步步发展的。其中FAT,NTFS和NFS都是支持特定存储协议的存储系统，DAS,SAN,NAS,OSD是一种存储模型。稍微科普一下：&lt;/p&gt;
&lt;p&gt;FAT,NTFS大家肯定比较熟悉，这个就是单机文件系统，类似的还有EXT4等等。windows系统就是NTFS，Linux是EXT4居多。&lt;/p&gt;
&lt;p&gt;NFS（Network File System）即网络文件系统，它允许网络中的计算机之间通过TCP/IP网络共享资源。使计算机可以像操作单机文件系统一样操作网络中的资源。&lt;/p&gt;
&lt;p&gt;DAS（Direct-Attached Storage）直连式存储，是一种常用的存储模型。比如我们常用的移动硬盘，U盘就是直连式存储。它有非常大的弊端，不易扩容，性能低，不可靠等。&lt;/p&gt;
&lt;p&gt;SAN（Storage Area Network）存储区域网络，它其实是建立专用于存储的区域网络，以达到存储和主机的物理分离。主要面向企业级存储，从理论上讲其易扩容可以支撑海量的数据存储，但是需要建立专用的光纤网络，成本较高。&lt;/p&gt;
&lt;p&gt;NAS（Network Attached Storage）网络附加存储，可以简单理解为便捷的局域网存储装置，在linux系统中可以通过NFS协议挂载NAS存储。NAS相对于SAN拥有自己的操作系统，可以与各个系统更好的兼容，且更加灵活。&lt;/p&gt;
&lt;p&gt;OSD（Object-based Storage Device）对象存储，对象存储是一种新的网络存储架构，它兼具SAN高速直接访问磁盘和NAS分布式共享的特点，将数据存储和元数据信息分离，可以更加灵活的管理数据的存储。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/585224/201808/585224-20180821232103269-1684305041.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;了解了上面那么多的名词，我们对于存储的发展大概有了一个认识了。其实存储的发展大概可以分为4个阶段，分别是单机文件系统，网络文件系统，集群文件系统和分布式文件系统。&lt;/p&gt;
&lt;h2 id=&quot;单机文件系统&quot;&gt;单机文件系统&lt;/h2&gt;
&lt;p&gt;以FAT,NTFS为代表，DAS其实也可以算作单机文件系统，他们共同的特点就是文件存储在单台服务器上，依靠操作系统的文件系统来实现文件的存储和管理。随着数据量的增大以及对与数据安全性的需求越来越高，它们的缺点也日益显露。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可扩展性：容量小，无法存储大量数据，而且不能进行扩展。&lt;/li&gt;
&lt;li&gt;性能：随着文件数量的增多，读写性能会下降&lt;/li&gt;
&lt;li&gt;可靠性：没有备份机制，一旦硬件出了故障会造成数据的丢失。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;网络文件系统&quot;&gt;网络文件系统&lt;/h2&gt;
&lt;p&gt;以NAS为代表，应用实现比如我们常用的网盘。它依托于网络提供了一定的便捷性，而且支持容量扩展，解决了单机文件系统容量小的问题。但是对于性能和可靠性的问题并没解决。&lt;/p&gt;
&lt;h2 id=&quot;集群文件系统&quot;&gt;集群文件系统&lt;/h2&gt;
&lt;p&gt;以SAN为代表，实现比如RedHat的GFS（非Google的GFS），它是通过多个节点构成一个集群，各个节点的数据是相同的，对其中一个节点的数据进行修改时，其会以广播的形式通知其他各个节点。通过这一特性解决了单机文件系统存在的各项缺点。支持多个节点的扩展，多台节点共同提供服务提高性能，多个节点都进行数据保存保障数据的可靠性。但是其同样拥有很多缺点，集群的节点不能太多，对某一数据进行修改需要修改整个集群等等&lt;/p&gt;
&lt;h2 id=&quot;分布式文件系统&quot;&gt;分布式文件系统&lt;/h2&gt;
&lt;p&gt;以HDFS,CEPH和OSD为代表，实现了支持大规模节点的集群，并且提高了存储性能和数据的可靠性。我们用过HDFS或者CEPH的都清楚，他们依托于廉价的存储设备，可以随时增删节点对整个集群进行动态的扩容，高度可扩展。可以有效的避免单点故障，具有很高的容错性，可以提高稳定可靠的服务。整个分布式系统具有较高的吞吐量，可以满足大数据时代对于数据的存储。&lt;/p&gt;
&lt;p&gt;前面的文章初识大数据中我们提到了HDFS和CEPH，两者都是当前使用较广泛的分布式存储服务，支持万级集群规模，应用感知进行负载均衡优化性能和效率。HDFS作为Hadoop的一大核心为分布式计算提供了有力的支持，但是由于其设计对于小文件的支持并不好。CEPH实现了统一存储，同时支持文件，块和对象存储。两者都支持数据的归档压缩提高存储空间利用率，并以纠删码技术为主，复制副本技术为辅提高数据的可靠性。&lt;/p&gt;
&lt;p&gt;是时候发明一个新名词了~~~&lt;/p&gt;
&lt;p&gt;欢迎关注我：叁金大数据（不稳定持续更新~~~）&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/585224/201808/585224-20180821232048234-395012815.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Aug 2018 15:22:00 +0000</pubDate>
<dc:creator>叁金</dc:creator>
<og:description>什么FAT,NTFS,NFS,DAS,SAN,NAS,OSD这些名词我一个都不认识。 不知道各位大佬对上面的名词了解多少，通过上面的一些名词其实可以大致的看到存储是怎样一步步发展的。其中FAT,NTF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jixin/p/9515128.html</dc:identifier>
</item>
<item>
<title>Nerd的套现ATM机 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/9515074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/9515074.html</guid>
<description>
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180821230422362-1925194818.jpg&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;425&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Nerd是一群似乎只在学生阶段才出尽风头的人。不善言辞，闷头学习，每遇考试便战功赫赫风光无限，赢得天下名。这样的描述，对那些成绩一般、喜欢天马行空、甚至有些多动症倾向的人来讲，无异于是噩梦。幸好有社会这座大染缸，在成年人的世界里，只看市场、名利。于是，口若悬河也好、拼爹拼钱也好、暗送秋波也好、坑蒙拐骗也好，总是有那么些个套利的途径，狠狠地在成年人的世界里出尽风头。&lt;/p&gt;
&lt;p&gt;而此时的nerd，无疑开始郁郁寡欢、走火入魔。难道自己做错了什么吗？难道前半段的努力，反而会导致人生轨迹向下倾斜？世界充斥着各种曾经被nerd虐得体无完肤之辈的声音：情商最重要；死读书有什么用？不就是会考试么，木鱼脑袋；不就是会刷题吗，你到现实社会看看，刷题有个毛用？成绩好怎么了，重要的是动手，是会说话，是会拍马屁。不一而足。&lt;/p&gt;
&lt;p&gt;面对这些声音，nerd自己也毫无反驳之力。市场这个东西怎么如此奇怪？！为什么有人可以动动嘴皮，把A家的货口头转卖给B家，就套利上万？为什么有人可以啥也不干，偷奸耍滑，只是酒桌上口若悬河了得，就能一路攀升？为什么有人，可以只是在视频面前说说话，只因为颜值或者整容后的颜值，就能够月入十几万？为什么有人可以插插花、喝喝茶，满嘴胡扯一些佛经道教，就能把各种达官贵人聚集在周围，任凭差遣？&lt;/p&gt;
&lt;p&gt;太多的为什么，让nerd感觉自己似乎除了学习、除了考试，啥也不会。市场这么大，可却就是没有自己的一亩三分地。有各种变现的途径，可就是没有自己的份。为什么呢？因为曾经的时光和精力，都花在了学习和考试上啊，哪TM的有精力干别的？！这可如何是好？！&lt;/p&gt;
&lt;p&gt;Nerd毕竟是nerd，手拿宝剑，却浑然不知，把宝剑当做拐杖使。&lt;/p&gt;
&lt;p&gt;考试和学习，就是nerd性价比最高的变现途径！&lt;/p&gt;
&lt;p&gt;在技术领域（如CS、法律、金融等），整个职场生涯就是一场打怪升级的确定性路线。而练级的小怪兽，就是充斥在各类教科书里的知识点和习题集，对程序员来讲它们是算法、是语言特性、是底层构架，对律师来讲是从业资格证、是某个方向的法律专著，对金融从业者来讲是CFA及相关证书，是某个特定市场层级的细致剖分。&lt;/p&gt;
&lt;p&gt;从各个专业内部来看，它们是一些检验手段、是一些必要但却不充分的上升条件、是可以用title镇住场面的定海神针、是跳槽面试的利器法宝。但若跳出来，以考试和学习的视角来看，那不过是各个科目进阶版的期末考试和刷题准备。&lt;/p&gt;
&lt;p&gt;而如果以投资的视角来考察整个过程就更让人惊讶了。你投入的生产要素是：书本、头脑和时间，产出的不过是在一张考卷上答题通过的结果。但这个产出结果，却可以让你升职加薪，待遇翻番，并以此为跳板，结识更多的人脉资源和资本资源，从而更加接近“不用出售自己时间来获取财富”的财务自由。绝对的低成本生产要素投入，高回报复利产出！&lt;/p&gt;
&lt;p&gt;也即是，nerd们可以通过继续学校里就已熟练的技能——学习+考试，来把自己的“通过考试”这个技能给资本化、货币化。这个市场有多大呢？看看各大招聘软件上的招聘需求吧！从“投入时间和教科书，产出通过考试”这样的模型来看，市场上充斥着无数的机会和需求，来购买这份技能。只要你能够通过考试（面试），无论你是刷题通过的、还是天资聪颖通过的，在技术人的世界里，这个硬指标的符合就足以让你拿到应有的套利回报。&lt;/p&gt;
&lt;p&gt;或许你会问，这样的世界有什么意义呢？又或是常见的牢骚：面试造核弹，工作变搬砖，这样的社会有何希望？&lt;/p&gt;
&lt;p&gt;毕竟是nerd，too young too simple，天真、善良还是愚蠢呢？！在资本的世界里，重要的是风口、是流行、是机会。网红直播月入几十万有什么意义？看着一个整容妹纸搔首弄姿，一天打赏几大万有什么意义？放出各种魔性视频，用算法消耗你的时间和生命的产品有什么意义？当你被这些资本逼得来买不起房、租不起房，无法为善、只能被为恶的人牵着鼻子走的时候，有什么意义？！当你勤学苦练、想要干出一番事业的时候，却发现自己囊中羞涩、市场上存在的都只有各种妖魔鬼怪的App、只有深谙传销洗脑之道的人做出来的产品时，有何意义？！&lt;/p&gt;
&lt;p&gt;面试造核弹，工作变搬砖。那不更好么，你不就可以更有信心和机会，投入更多的时间去继续准备下一场面试、刷下一本习题集去升职加薪跳槽吗？如果各个公司都要装X、要各种酷炫的面试题目镇场，那不更好么，说明如今的套现市场就是这样。况且，那些最早掌握移动端，如iOS、Android编程技能的初级选手，就叫做有远光、会踩风口，那TM洞察到整个行业就是由考试来构建各种升迁机会和人才流动的人，就不能叫做有洞见、有远光吗？那些社会多金人士可以靠两片嘴，胡诌、坑蒙拐骗赚到钞票，还被称赞作“就是有本事”，那么，依靠学习、依靠刷题换来的高薪、优质圈子，就TM不叫有本事了？！&lt;/p&gt;
&lt;p&gt;Nerd们，请不要把世界让给你所鄙视的人。拿起你浑然不知的套现利器，刷起你的题目，和那些人再TM干一架吧！&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484431&amp;amp;idx=1&amp;amp;sn=9ab37eabfc56c309bfc183c4ad202f79&amp;amp;chksm=ec20e3b3db576aa5beab21c16db95b28d660f76ade46a7dba86dfacc8173cf2eac4cd1083b91&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;不过是备选的一道菜罢了&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484431&amp;amp;idx=2&amp;amp;sn=47220db14dfe1c94d669b561ec128c74&amp;amp;chksm=ec20e3b3db576aa5e7987092dc11c740134b42e1c79324af053d6ec5f354a3cf2182db971811&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;2018年07月写字总结&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484426&amp;amp;idx=1&amp;amp;sn=157fadbad18eb31488a7792bcc75f296&amp;amp;chksm=ec20e3b6db576aa06b587cf21595528a893e417c19aa6d9baab2327c1170ba7e44cff3f5b0e5&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;thinking的定价&lt;/a&gt;》&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180821230516641-720920613.jpg&quot; alt=&quot;&quot; width=&quot;712&quot; height=&quot;356&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;h3&gt;   &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;更多信息交流和观点分享，可加入知识星球：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180821230555562-990520140.png&quot; alt=&quot;&quot; width=&quot;342&quot; height=&quot;414&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;VIP赞赏专区：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201808/672506-20180821230658590-1226411479.jpg&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;289&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Aug 2018 15:08:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<og:description>Nerd是一群似乎只在学生阶段才出尽风头的人。不善言辞，闷头学习，每遇考试便战功赫赫风光无限，赢得天下名。这样的描述，对那些成绩一般、喜欢天马行空、甚至有些多动症倾向的人来讲，无异于是噩梦。幸好有社会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/9515074.html</dc:identifier>
</item>
<item>
<title>造轮子，模仿WPF的UI框架，还没完善。。。 - DSkin</title>
<link>http://www.cnblogs.com/dskin/p/9514881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dskin/p/9514881.html</guid>
<description>&lt;p&gt;Wtf(暂时命名，随便起的 = _=)，模仿WPF的框架，还没有完善，只有简单的基础元素，支持数据绑定。虽然支持mono但是mono有bug&lt;/p&gt;
&lt;p&gt;写这个只是兴趣爱好，感觉也没多大意义了，如果这个UI框架完善了，有多少人愿意用？毕竟Windows上有WPF，而且C#跨平台需求也不多啊。我对WPF也不算熟悉，要完善的话，还有很多要写。一大堆常用控件和设计器。不过我不用XML来描述，而是直接用C#来定义，设计器直接生成C#代码，因为我觉得，如果有强大的设计器，写XML就是多余的，而且解析XML还影响性能，对于WPF，我觉得Xaml太啰嗦了。&lt;/p&gt;

&lt;p&gt;WtfObject  相当于WPF里的DependencyObject依赖对象。继承该类的对象，所有属性默认都是依赖属性&lt;/p&gt;
&lt;p&gt;属性写法：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 绑定的数据上下文
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [UIPropertyMetadata(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; DataContext
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; GetValue&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;(); }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; { SetValue(value); }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;属性上的特性可以是 PropertyMetadata或者UIPropertyMetadata 中的一个，默认值可以通过这两个特性来设置。如果不加这两个特性，那默认值就是null或者0&lt;/p&gt;
&lt;p&gt;如果是复杂属性类型默认值，可以通过重写 OnOverrideMetadata 来设置&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnOverrideMetadata(OverrideMetadata overridePropertys)
       {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnOverrideMetadata(overridePropertys);
            overridePropertys.Override(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StrokeStyle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; UIPropertyMetadataAttribute(&lt;span&gt;new&lt;/span&gt; Stroke(&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;数据绑定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; bind = label[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;lt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右到左数据绑定，数据源是DataContext的属性&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; bind = label[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左到右数据绑定，数据源是DataContext的属性&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; bind = label[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//右到左&lt;/span&gt;&lt;span&gt;数据绑定,只传递一次 ，数据源是DataContext的属性&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; bind = label[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;双向绑定，数据源是DataContext的属性，双向绑定需要对象实现INotifyPropertyChanged&lt;/span&gt;
 


&lt;span&gt;var&lt;/span&gt; bind = label[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;lt;= button[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右到左数据绑定&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; bind = label[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;gt;= button[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左到右数据绑定&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; bind = label[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] != button[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右到左数据绑定,只传递一次&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; bind = label[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == button[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;双向绑定&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令绑定：&lt;/p&gt;
&lt;p&gt;当事件触发或者属性变化的时候调用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
label.AddCommand(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MouseDown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button1_Click&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CommandContext&quot;&lt;/span&gt;, Wtf.Windows.CommandParameter.EventArgs);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 添加处理命令，命令方法在CommandContext或者其他属性的对象上
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;eventName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;触发的事件名或者属性名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;methodName&quot;&amp;gt;&lt;span&gt;命令&lt;/span&gt;&lt;/span&gt;&lt;span&gt;方法名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;propertyName&quot;&amp;gt;&lt;span&gt;命令对象所在的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;属性名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ps&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法参数，可以是自定义的数据或者相关属性或者事件的数据&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddCommand(&lt;span&gt;string&lt;/span&gt; eventName, &lt;span&gt;string&lt;/span&gt; methodName, &lt;span&gt;string&lt;/span&gt; propertyName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CommandContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] ps)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一些类型的隐式转换&lt;/p&gt;
&lt;p&gt;Brush, Color :  &quot;#0000ff&quot; &quot;#ff0000ff&quot; “255,255,255”  “255,255,255,255”  颜色字符串转换，按顺序是r,g,b、a,r,g,b&lt;/p&gt;

&lt;p&gt;FloatValue： &quot;10%&quot; “100” &quot;zero&quot; &quot;auto&quot;  100  100.5     数字或者百分比字符串转换，整形，浮点数据自动转换&lt;/p&gt;

&lt;p&gt;触发器样式例子&lt;/p&gt;

&lt;p&gt;按钮的鼠标操作效果，鼠标移入移出按下背景色变化&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
　　　　　　　Styling.Trigger hover = &lt;span&gt;new&lt;/span&gt; Styling.Trigger { Condition = Styling.Conditions.Equals, Property = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IsMouseOver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Value = &lt;span&gt;true&lt;/span&gt;&lt;span&gt; };

            hover.Setters.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Drawing.Brush.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ff0000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

            Styling.Trigger normal &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Styling.Trigger { };

            normal.Setters.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Drawing.Brush.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#00ff00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

            Styling.Trigger press &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Styling.Trigger { Condition = Styling.Conditions.Equals, Property = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IsMouseCaptured&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Value = &lt;span&gt;true&lt;/span&gt;&lt;span&gt; };

            press.Setters.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Drawing.Brush.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ffff00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

            label.Triggers.Add(normal);

            label.Triggers.Add(hover);

            label.Triggers.Add(press);

            label.MouseDown &lt;/span&gt;+= &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;
            {
                label.CaptureMouse();
            };

            label.MouseUp &lt;/span&gt;+= &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;
            {
                label.ReleaseMouseCapture();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;WtfObject 的属性设置的值优先级比触发器样式设置的值要高，所以当你设置了属性值，触发器样式可能没有效果&lt;/p&gt;


&lt;p&gt;添加UI元素，UI元素可以互相嵌套&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; root =&lt;span&gt; testControl1.RootUIElement;
            root.Foreground &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ff0000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            root.FontFamily &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;微软雅黑&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            root.FontSize &lt;/span&gt;= &lt;span&gt;16&lt;/span&gt;&lt;span&gt;;
            root.Children.Add(label);
            root.Children.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Windows.Shapes.Ellipse
            {
                Stroke &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#0000ff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Fill &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Width &lt;/span&gt;= &lt;span&gt;40&lt;/span&gt;&lt;span&gt;,
                Height &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
                MarginLeft &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;,
                MarginTop &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;
            });

            root.Children.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Windows.Shapes.Ellipse
            {
                Stroke &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#0000ff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Fill &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Width &lt;/span&gt;= &lt;span&gt;40&lt;/span&gt;&lt;span&gt;,
                Height &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
                MarginRight &lt;/span&gt;= &quot;&lt;span&gt;30%&quot;&lt;/span&gt;&lt;span&gt;,
                MarginTop &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;

            });    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;元素布局，支持百分比布局，margin调整定位，默认居中。&lt;/p&gt;

&lt;p&gt;触发器绑定动画&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; t = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Trigger();
            Storyboard ss &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Storyboard();
            ss.Duration &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TimeSpan(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tl = &lt;span&gt;new&lt;/span&gt; Timeline(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            tl.KeyFrames.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyFrame&amp;lt;FloatValue&amp;gt; { Property = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Value = &lt;span&gt;300&lt;/span&gt;, Ease = &lt;span&gt;new&lt;/span&gt; BounceEase(), AnimateMode =&lt;span&gt; AnimateMode.EaseIn });
            tl.KeyFrames.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyFrame&amp;lt;FloatValue&amp;gt; { Property = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Ease = &lt;span&gt;new&lt;/span&gt; BounceEase(), AnimateMode =&lt;span&gt; AnimateMode.EaseIn });
            tl.KeyFrames.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyFrame&amp;lt;GeneralTransform&amp;gt; { Property = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RenderTransform&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, AnimateMode = AnimateMode.EaseOut, Value = &lt;span&gt;new&lt;/span&gt; GeneralTransform { Angle = &lt;span&gt;30&lt;/span&gt; }, Ease = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ElasticEase() });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tl.KeyFrames.Add(new KeyFrame&amp;lt;SolidColorBrush&amp;gt; { Property = Shape.FillProperty, Value = &quot;White&quot; });&lt;/span&gt;
&lt;span&gt;            ss.Timelines.Add(tl);
            t.Property &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IsMouseOver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            t.Value &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            t.Animation &lt;/span&gt;=&lt;span&gt; ss;
            t.Setters.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fill&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Brush.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#fff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            v.Triggers.Add(t);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果写自定义控件，继承Wtf.Windows.Controls.Control  然后重写InitializeComponent 把样式定义代码写在里面，如果再次继承修改的话，可以重写覆盖。&lt;/p&gt;
&lt;p&gt;dll暂时不提供下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/774637/201808/774637-20180821190034115-1928068591.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 21 Aug 2018 14:33:00 +0000</pubDate>
<dc:creator>DSkin</dc:creator>
<og:description>Wtf(暂时命名，随便起的 = _=)，模仿WPF的框架，还没有完善，只有简单的基础元素，支持数据绑定。虽然支持mono但是mono有bug 写这个只是兴趣爱好，感觉也没多大意义了，如果这个UI框架完</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dskin/p/9514881.html</dc:identifier>
</item>
<item>
<title>有趣的   zkw  线段树（超全详解） - Judge_Cheung</title>
<link>http://www.cnblogs.com/Judge/p/9514862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Judge/p/9514862.html</guid>
<description>&lt;p&gt;&lt;strong&gt;zkw segment-tree 真是太棒了（重口味）！写篇博客纪念入门&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;emmm...首先我们来介绍一下 zkw 线段树这个东西（俗称 &quot;重口味&quot; ，与 KMP 类似，咳咳...）&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;其实 zkw 线段树和普通线段树区别没多大（区别可大了去了！）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;emmm...起码它们的思想是一致的，都是节点维护区间信息嘛。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只不过...普通线段树的维护和查询是递归式，而 zkw线段树是循环式的...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是不要以为 zkw线段树只是靠循环加速上位的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zkw线段树能支持非常多强（luan）如（qi）闪（ba）电（zao）的操作（最后例题讲）。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1452724/201808/1452724-20180821160156936-1884947255.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;emmm...这里你看着 普通线段树 的节点比 zkw线段树 的小对吧，但其实两者差不多，（因为线段树是要开4倍空间的啊，这里只是没有画出用不到的节点罢了），&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;其实上图...还是无法体现zkw 线段树的具体形态的，&lt;span&gt;（但是相信聪明的你一定看懂了所以我就不讲了）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;emmm...于是乎还是上图解释一切&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1452724/201808/1452724-20180821223038494-1334459442.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;首先你要写个循环，让 m 这个值（也就是非叶子节点）大于 n （也就是总叶子结点数），&lt;/strong&gt;&lt;strong&gt;以此保证 这棵树的叶子 能够容纳你要维护的 n 个值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后你要从 m 倒推 到 1 号节点&lt;/strong&gt;（注意是 m 倒推回 1 ，保证维护每个节点时该节点的孩子都已经被维护完毕&lt;strong&gt;）&lt;/strong&gt;，&lt;strong&gt;让每个节点维护它左右孩子的信息&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;代码实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这里我们假设要维护的信息有：区间和，区间最小值，区间最大值 。 下同&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt; build(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  维护这么多信息都只需要这么几行，可见维护信息单一时代码应该会短的不像话（压行过的话大概三四行）&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(m=&lt;span&gt;1&lt;/span&gt;;m&amp;lt;=n;m&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=m+&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=m+n;++&lt;span&gt;i)
        sum[i]&lt;/span&gt;=mn[i]=mx[i]=&lt;span&gt;read();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=m-&lt;span&gt;1&lt;/span&gt;;i;--&lt;span&gt;i)
        sum[i]&lt;/span&gt;=a[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;]+a[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;],
        mn[i]&lt;/span&gt;=min(mn[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;],mn[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]),
        mx[i]&lt;/span&gt;=max(mx[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;],mx[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;但是，这里对 mn 和 mx 的处理是在无修改操作的基础上实行的，所以这样写并不支持修改操作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么我们可以这样写：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; build(){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(m=&lt;span&gt;1&lt;/span&gt;;m&amp;lt;=n;m&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=m+&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=m+n;++&lt;span&gt;i)
        sum[i]&lt;/span&gt;=mn[i]=mx[i]=&lt;span&gt;read();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=m-&lt;span&gt;1&lt;/span&gt;;i;--&lt;span&gt;i){
        sum[i]&lt;/span&gt;=sum[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;]+sum[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        
        mn[i]&lt;/span&gt;=min(mn[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;],mn[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]),
        mn[i&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;]-=mn[i],mn[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;]-=&lt;span&gt;mn[i];
        
        mx[i]&lt;/span&gt;=max(mx[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;],mx[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]),
        mx[i&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;]-=mx[i],mx[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;]-=&lt;span&gt;mx[i];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;PS：以下的操作（单点、区间更新，单点、区间查询）所附的代码，都基于可修改的版本&lt;/strong&gt;&lt;/p&gt;



&lt;h2&gt;&lt;strong&gt;单点更新&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这个单点更新还是比较好解决的，你只要找到更新的节点所在的叶子结点，&lt;/strong&gt;&lt;strong&gt;然后修改后一直向父节点更新即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（这个。。。就不用上图了吧...你脑补一下就差不多了）&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;这里我们假设将一个节点的值增加 v （修改的话...就记录一下原数组，然后算差值就好了吧？）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt; update_node(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; v,&lt;span&gt;int&lt;/span&gt; A=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
    x&lt;/span&gt;+=m,mx[x]+=v,mn[x]+=v,sum[x]+=&lt;span&gt;v;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(;x&amp;gt;&lt;span&gt;1&lt;/span&gt;;x&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
        sum[x]&lt;/span&gt;+=&lt;span&gt;v;
        A&lt;/span&gt;=min(mn[x],mn[x^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        mn[x]&lt;/span&gt;-=A,mn[x^&lt;span&gt;1&lt;/span&gt;]-=A,mn[x&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A;
        A&lt;/span&gt;=max(mx[x],mx[x^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]),
        mx[x]&lt;/span&gt;-=A,mx[x^&lt;span&gt;1&lt;/span&gt;]-=A,mx[x&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;h2&gt;&lt;strong&gt;区间更新&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这个东西...有点麻烦（你得稍微感性理解）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就是说...你每次要更新一段区间的时候，你要让左端点 -1 ，右端点 +1 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后你在更新权值的时候要判断 左端点当前所处的节点是否是它父节点的左孩子，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是的话就让该节点的兄弟（也就是它父节点的右孩子）得到更新，否则不做处理，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后左节点再向右移一位（也就是跳到了父节点），重复迭代以上步骤。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么右端点呢？其实也就是和左端点反着来了而已。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有一点，循环的终止条件？&lt;/strong&gt;&lt;strong&gt;这个简单，就是当左右端点所处的节点是兄弟节点的时候结束循环。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类似的，你更新一个节点时 同样可以用这种方法维护（只不过这样就更麻烦了啊）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1452724/201808/1452724-20180821171953032-1239333219.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;这样我们可以看到要被更新的区间都已经被染成黄色了。但是，zkw 没有下传标记啊！&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;那么我们查询的区间如果在染成黄色的节点的下部（也就是黄色节点的子树内）该怎么办？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;我们可以这样...这样...没错！标记永久化！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为我们已经将一个节点的标记永久化了，那么在该节点被访问到的时候，&lt;/strong&gt;&lt;strong&gt;只要将当前查询到的、包含在该节点所管辖区间范围内的  区间长度乘上标记值，累加入答案即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（具体实现得看代码）&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;

&lt;h3&gt;&lt;strong&gt;区间查询的特殊情况&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;同学们有没有注意到一种区间查询的特殊情况？没错，就是右区间+1后到达下一层的特殊情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就以上图为例，假设维护区间为 1 ~ 7 ，现在对 2 ~ 7 进行区间加操作，那么  t = 7+1 = 8 ，于是 t 就到达了不存在的第 5 层！&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;现在你想的一定是这种情况该怎么避免这种情况（其实很简单，你在建树确定 m 的值的时候，将判断条件改成 &quot; m&amp;lt;=n+1 &quot; 就行了）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;但我现在要证明这种情况不需要避免也不会出问题（基本上...吧？）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1452724/201808/1452724-20180821205012482-1932199708.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们可以看到，s 和 t 在跳到 0 和 1 时满足了终止条件，并且需要更新的节点都得到了更新，而且，其实 t 就没有更新过节点...&lt;/strong&gt;&lt;/p&gt;


&lt;h3&gt;代码实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;这里我们假设要将一段区间的每个数加上 v ，然后维护的信息同上&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;void&lt;/span&gt; update_part(&lt;span&gt;int&lt;/span&gt; s,&lt;span&gt;int&lt;/span&gt; t,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; A=&lt;span&gt;0&lt;/span&gt;,lc=&lt;span&gt;0&lt;/span&gt;,rc=&lt;span&gt;0&lt;/span&gt;,len=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(s+=m-&lt;span&gt;1&lt;/span&gt;,t+=m+&lt;span&gt;1&lt;/span&gt;;s^t^&lt;span&gt;1&lt;/span&gt;;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,t&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,len&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){ //在这里的 add 就是标记数组了
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s&amp;amp;&lt;span&gt;1&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;) add[s^&lt;span&gt;1&lt;/span&gt;]+=v,lc+=len, mn[s^&lt;span&gt;1&lt;/span&gt;]+=v,mx[s^&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;v;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t&amp;amp;&lt;span&gt;1&lt;/span&gt;)    add[t^&lt;span&gt;1&lt;/span&gt;]+=v,rc+=len, mn[t^&lt;span&gt;1&lt;/span&gt;]+=v,mx[t^&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;v;
        
        sum[s&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=v*lc, sum[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=v*&lt;span&gt;rc;
        
        A&lt;/span&gt;=min(mn[s],mn[s^&lt;span&gt;1&lt;/span&gt;]),mn[s]-=A,mn[s^&lt;span&gt;1&lt;/span&gt;]-=A,mn[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A,
        A&lt;/span&gt;=min(mn[t],mn[t^&lt;span&gt;1&lt;/span&gt;]),mn[t]-=A,mn[t^&lt;span&gt;1&lt;/span&gt;]-=A,mn[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A;
        
        A&lt;/span&gt;=max(mx[s],mx[s^&lt;span&gt;1&lt;/span&gt;]),mx[s]-=A,mx[s^&lt;span&gt;1&lt;/span&gt;]-=A,mx[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A,
        A&lt;/span&gt;=max(mx[t],mx[t^&lt;span&gt;1&lt;/span&gt;]),mx[t]-=A,mx[t^&lt;span&gt;1&lt;/span&gt;]-=A,mx[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(lc+=&lt;span&gt;rc;){
        sum[s&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]=v*&lt;span&gt;lc;
        A&lt;/span&gt;=min(mn[s],mn[s^&lt;span&gt;1&lt;/span&gt;]),mn[s]-=A,mn[s^&lt;span&gt;1&lt;/span&gt;]-=A,mn[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A,
        A&lt;/span&gt;=max(mx[s],mx[s^&lt;span&gt;1&lt;/span&gt;]),mx[s]-=A,mx[s^&lt;span&gt;1&lt;/span&gt;]-=A,mx[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A;
        s&lt;/span&gt;&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这里的 lc 和 rc 的所代表的含义需要讲一下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lc 代表左端点所处的节点下有多少长度的区间在更新区间内, rc 同理 ，通俗一点地说，就是 s 和 t 所分别走过的节点中包含的更新过的区间的总长&lt;/strong&gt;&lt;/p&gt;






&lt;h2&gt;单点查询&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这个没什么好说的吧，你从叶子结点一直跳父&lt;span&gt;节点，把途中节点的 mn&lt;/span&gt; （或者 mx ）权值累加，最后得到的就是答案&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;代码实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;int&lt;/span&gt; query_node(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(x+=m;x;x&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;) ans+=&lt;span&gt;mn[s];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;h2&gt;区间查询&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么？zkw线段树的区间查询？我不会啊。&lt;/strong&gt;&lt;/span&gt;     &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么这里的区间查询...其实有点难说啊！&lt;span&gt;要不就直接上代码得了？&lt;/span&gt;咳咳...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个其实和上面的区间更新的思路差不多，可能要讲的就是标记累加的问题了吧。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么 lc 和 rc 之前已经讲过了，就是 s 节点和 t 节点分别走过的节点中所包含的更新区间的长度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么 add 这个数组啊...啊...啊...这个数组啊，它...它好啊，它...&lt;span&gt;要不我们直接看代码吧？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它好在哪里啊？好难说啊...其实它就是记录了你每次大块累加区间时的副产品啊，类似于线段树的懒标记。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是和普通线段树不一样的是，线段树的查询是自上而下查询（顺便释放标记）然后又自下而上的递归回去的&lt;span&gt;（溜溜球的感觉&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而 zkw 的查询是直接自下而上的，于是它无法释放标记，于是它就在遇到某个打过懒标记的节点时，将当前查询到的区间长度乘上标记值，累加入答案。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（所以这还是懒标记啊！不上图了自行脑补。emmm...算了吧那还是上一张图好了&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1452724/201808/1452724-20180821213328366-29077353.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;int&lt;/span&gt; query_sum(&lt;span&gt;int&lt;/span&gt; s,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lc=&lt;span&gt;0&lt;/span&gt;,rc=&lt;span&gt;0&lt;/span&gt;,len=&lt;span&gt;1&lt;/span&gt;,ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(s+=m-&lt;span&gt;1&lt;/span&gt;,t+=m+&lt;span&gt;1&lt;/span&gt;;s^t^&lt;span&gt;1&lt;/span&gt;;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,t&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,len&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s&amp;amp;&lt;span&gt;1&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;) ans+=sum[s^&lt;span&gt;1&lt;/span&gt;]+len*add[s^&lt;span&gt;1&lt;/span&gt;],lc+=&lt;span&gt;len;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t&amp;amp;&lt;span&gt;1&lt;/span&gt;) ans+=sum[t^&lt;span&gt;1&lt;/span&gt;]+len*add[t^&lt;span&gt;1&lt;/span&gt;],rc+=&lt;span&gt;len;
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(add[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]) ans+=add[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]*&lt;span&gt;lc;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(add[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]) ans+=add[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]*&lt;span&gt;rc; 
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(lc+=rc;s;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(add[s]) ans+=add[s]*&lt;span&gt;lc;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
}

inline &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; query_min(&lt;span&gt;int&lt;/span&gt; s,&lt;span&gt;int&lt;/span&gt; t,&lt;span&gt;int&lt;/span&gt; L=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; R=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s==t) &lt;span&gt;return&lt;/span&gt; query_node(s);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 单点要特判, 下同&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(s+=m,t+=m;s^t^&lt;span&gt;1&lt;/span&gt;;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,t&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里 s 和 t 直接加上 m&lt;/span&gt;
        L+=mn[s],R+=&lt;span&gt;mn[t];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s&amp;amp;&lt;span&gt;1&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;) L=min(L,mn[s^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t&amp;amp;&lt;span&gt;1&lt;/span&gt;) R=min(R,mn[t^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(ans=min(L,R),s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;;s;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;) ans+=&lt;span&gt;mn[s];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
}

inline &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; query_max(&lt;span&gt;int&lt;/span&gt; s,&lt;span&gt;int&lt;/span&gt; t,&lt;span&gt;int&lt;/span&gt; L=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; R=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s==t) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; query_node(s);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(s+=m,t+=m;s^t^&lt;span&gt;1&lt;/span&gt;;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,t&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
        L&lt;/span&gt;+=mx[s],R+=&lt;span&gt;mx[t];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s&amp;amp;&lt;span&gt;1&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;) L=max(L,mx[s^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t&amp;amp;&lt;span&gt;1&lt;/span&gt;) R=max(R,mx[t^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(ans=max(L,R),s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;;s;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;) ans+=&lt;span&gt;mx[s];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这里询问时 s 和 t 不能 -1 或 +1 ，不然会查询到旁边不相干的节点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后 s == t 的情况要特判一下，防止 s 和 t 一直都不是兄弟，陷入死循环。&lt;/strong&gt;&lt;/p&gt;





&lt;h2&gt;完全代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9acf5646-a591-4ea1-aebf-4a300b282624')&quot; readability=&quot;89.5&quot;&gt;&lt;img id=&quot;code_img_closed_9acf5646-a591-4ea1-aebf-4a300b282624&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9acf5646-a591-4ea1-aebf-4a300b282624&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9acf5646-a591-4ea1-aebf-4a300b282624',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9acf5646-a591-4ea1-aebf-4a300b282624&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;174&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;by Judge&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt;  3&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; M=1e5+&lt;span&gt;111&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define getchar() (p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,1&amp;lt;&amp;lt;21,stdin),p1==p2)?EOF:*p1++)&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;21&lt;/span&gt;],*p1=buf,*p2=&lt;span&gt;buf;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt;&lt;span&gt; read(){
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; x=&lt;span&gt;0&lt;/span&gt;,f=&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;char&lt;/span&gt; c=&lt;span&gt;getchar();
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;!isdigit(c);c=getchar()) &lt;span&gt;if&lt;/span&gt;(c==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) f=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;isdigit(c);c=getchar()) x=x*&lt;span&gt;10&lt;/span&gt;+c-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;return&lt;/span&gt; x*&lt;span&gt;f;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; sr[&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;21&lt;/span&gt;],z[&lt;span&gt;20&lt;/span&gt;];&lt;span&gt;int&lt;/span&gt; C=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,Z;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; Ot(){fwrite(sr,&lt;span&gt;1&lt;/span&gt;,C+&lt;span&gt;1&lt;/span&gt;,stdout),C=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;}
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; print(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(C&amp;gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;20&lt;/span&gt;)Ot();&lt;span&gt;if&lt;/span&gt;(x&amp;lt;&lt;span&gt;0&lt;/span&gt;)sr[++C]=&lt;span&gt;45&lt;/span&gt;,x=-&lt;span&gt;x;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(z[++Z]=x%&lt;span&gt;10&lt;/span&gt;+&lt;span&gt;48&lt;/span&gt;,x/=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(sr[++C]=z[Z],--Z);sr[++C]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m,q;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum[M&amp;lt;&amp;lt;&lt;span&gt;2&lt;/span&gt;],mn[M&amp;lt;&amp;lt;&lt;span&gt;2&lt;/span&gt;],mx[M&amp;lt;&amp;lt;&lt;span&gt;2&lt;/span&gt;],add[M&amp;lt;&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; build(){
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(m=&lt;span&gt;1&lt;/span&gt;;m&amp;lt;=n;m&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=m+&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=m+n;++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         sum[i]=mn[i]=mx[i]=&lt;span&gt;read();
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=m-&lt;span&gt;1&lt;/span&gt;;i;--&lt;span&gt;i){
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         sum[i]=sum[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;]+sum[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         mn[i]=min(mn[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;],mn[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         mn[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;]-=mn[i],mn[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;]-=&lt;span&gt;mn[i];
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         mx[i]=max(mx[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;],mx[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         mx[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;]-=mx[i],mx[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;]-=&lt;span&gt;mx[i];
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; update_node(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; v,&lt;span&gt;int&lt;/span&gt; A=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     x+=m,mx[x]+=v,mn[x]+=v,sum[x]+=&lt;span&gt;v;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;x&amp;gt;&lt;span&gt;1&lt;/span&gt;;x&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         sum[x]+=&lt;span&gt;v;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         A=min(mn[x],mn[x^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         mn[x]-=A,mn[x^&lt;span&gt;1&lt;/span&gt;]-=A,mn[x&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         A=max(mx[x],mx[x^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         mx[x]-=A,mx[x^&lt;span&gt;1&lt;/span&gt;]-=A,mx[x&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; update_part(&lt;span&gt;int&lt;/span&gt; s,&lt;span&gt;int&lt;/span&gt; t,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v){
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; A=&lt;span&gt;0&lt;/span&gt;,lc=&lt;span&gt;0&lt;/span&gt;,rc=&lt;span&gt;0&lt;/span&gt;,len=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(s+=m-&lt;span&gt;1&lt;/span&gt;,t+=m+&lt;span&gt;1&lt;/span&gt;;s^t^&lt;span&gt;1&lt;/span&gt;;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,t&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,len&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(s&amp;amp;&lt;span&gt;1&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;) add[s^&lt;span&gt;1&lt;/span&gt;]+=v,lc+=len, mn[s^&lt;span&gt;1&lt;/span&gt;]+=v,mx[s^&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;v;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(t&amp;amp;&lt;span&gt;1&lt;/span&gt;)    add[t^&lt;span&gt;1&lt;/span&gt;]+=v,rc+=len, mn[t^&lt;span&gt;1&lt;/span&gt;]+=v,mx[t^&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;v;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         sum[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=v*lc, sum[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=v*&lt;span&gt;rc;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         A=min(mn[s],mn[s^&lt;span&gt;1&lt;/span&gt;]),mn[s]-=A,mn[s^&lt;span&gt;1&lt;/span&gt;]-=A,mn[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A,
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         A=min(mn[t],mn[t^&lt;span&gt;1&lt;/span&gt;]),mn[t]-=A,mn[t^&lt;span&gt;1&lt;/span&gt;]-=A,mn[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         A=max(mx[s],mx[s^&lt;span&gt;1&lt;/span&gt;]),mx[s]-=A,mx[s^&lt;span&gt;1&lt;/span&gt;]-=A,mx[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A,
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;         A=max(mx[t],mx[t^&lt;span&gt;1&lt;/span&gt;]),mx[t]-=A,mx[t^&lt;span&gt;1&lt;/span&gt;]-=A,mx[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(lc+=rc;s;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         sum[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=v*&lt;span&gt;lc;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         A=min(mn[s],mn[s^&lt;span&gt;1&lt;/span&gt;]),mn[s]-=A,mn[s^&lt;span&gt;1&lt;/span&gt;]-=A,mn[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A,
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         A=max(mx[s],mx[s^&lt;span&gt;1&lt;/span&gt;]),mx[s]-=A,mx[s^&lt;span&gt;1&lt;/span&gt;]-=A,mx[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;A;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt; query_node(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(x+=m;x;x&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;) ans+=mn[x]; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt; query_sum(&lt;span&gt;int&lt;/span&gt; s,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t){
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; lc=&lt;span&gt;0&lt;/span&gt;,rc=&lt;span&gt;0&lt;/span&gt;,len=&lt;span&gt;1&lt;/span&gt;,ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(s+=m-&lt;span&gt;1&lt;/span&gt;,t+=m+&lt;span&gt;1&lt;/span&gt;;s^t^&lt;span&gt;1&lt;/span&gt;;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,t&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,len&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(s&amp;amp;&lt;span&gt;1&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;) ans+=sum[s^&lt;span&gt;1&lt;/span&gt;]+len*add[s^&lt;span&gt;1&lt;/span&gt;],lc+=&lt;span&gt;len;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(t&amp;amp;&lt;span&gt;1&lt;/span&gt;) ans+=sum[t^&lt;span&gt;1&lt;/span&gt;]+len*add[t^&lt;span&gt;1&lt;/span&gt;],rc+=&lt;span&gt;len;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(add[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]) ans+=add[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]*&lt;span&gt;lc;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(add[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]) ans+=add[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]*&lt;span&gt;rc; 
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(lc+=rc,s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;;s;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;if&lt;/span&gt;(add[s]) ans+=add[s]*&lt;span&gt;lc;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt; query_min(&lt;span&gt;int&lt;/span&gt; s,&lt;span&gt;int&lt;/span&gt; t,&lt;span&gt;int&lt;/span&gt; L=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; R=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(s==t) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; query_node(s);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(s+=m,t+=m;s^t^&lt;span&gt;1&lt;/span&gt;;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,t&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         L+=mn[s],R+=&lt;span&gt;mn[t];
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(s&amp;amp;&lt;span&gt;1&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;) L=min(L,mn[s^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(t&amp;amp;&lt;span&gt;1&lt;/span&gt;) R=min(R,mn[t^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(ans=min(L,R),s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;;s;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;) ans+=&lt;span&gt;mn[s];
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt; query_max(&lt;span&gt;int&lt;/span&gt; s,&lt;span&gt;int&lt;/span&gt; t,&lt;span&gt;int&lt;/span&gt; L=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; R=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(s==t) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; query_node(s);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(s+=m,t+=m;s^t^&lt;span&gt;1&lt;/span&gt;;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,t&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         L+=mx[s],R+=&lt;span&gt;mx[t];
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(s&amp;amp;&lt;span&gt;1&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;) L=max(L,mx[s^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(t&amp;amp;&lt;span&gt;1&lt;/span&gt;) R=max(R,mx[t^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(ans=max(L,R),s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;;s;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;) ans+=&lt;span&gt;mx[s];
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;signed main(){
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     
&lt;span&gt; 98&lt;/span&gt;     
&lt;span&gt; 99&lt;/span&gt;     
&lt;span&gt;100&lt;/span&gt;     
&lt;span&gt;101&lt;/span&gt;     
&lt;span&gt;102&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;板子题？这个真没有...（不过你可以拿普通线段树的板子题等练手）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默默放上线段树板子题的链接... &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. &lt;a href=&quot;https://www.luogu.org/problemnew/show/P3372&quot; target=&quot;_blank&quot;&gt;线段树 1&lt;/a&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. &lt;a href=&quot;https://www.luogu.org/problemnew/show/P3372&quot; target=&quot;_blank&quot;&gt;线段树 2&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('77d3c3d1-1db1-415e-aae6-734113bd181a')&quot; readability=&quot;58&quot;&gt;&lt;img id=&quot;code_img_closed_77d3c3d1-1db1-415e-aae6-734113bd181a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_77d3c3d1-1db1-415e-aae6-734113bd181a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('77d3c3d1-1db1-415e-aae6-734113bd181a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_77d3c3d1-1db1-415e-aae6-734113bd181a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;111&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;by Judge&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ll long long
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; M=1e5+&lt;span&gt;111&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define getchar() (p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,1&amp;lt;&amp;lt;21,stdin),p1==p2)?EOF:*p1++)&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;21&lt;/span&gt;],*p1=buf,*p2=&lt;span&gt;buf;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;inline ll read(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     ll x=&lt;span&gt;0&lt;/span&gt;,f=&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;char&lt;/span&gt; c=&lt;span&gt;getchar();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;!isdigit(c);c=getchar()) &lt;span&gt;if&lt;/span&gt;(c==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) f=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;isdigit(c);c=getchar()) x=x*&lt;span&gt;10&lt;/span&gt;+c-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;return&lt;/span&gt; x*&lt;span&gt;f;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; sr[&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;21&lt;/span&gt;],z[&lt;span&gt;20&lt;/span&gt;];&lt;span&gt;int&lt;/span&gt; C=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,Z;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; Ot(){fwrite(sr,&lt;span&gt;1&lt;/span&gt;,C+&lt;span&gt;1&lt;/span&gt;,stdout),C=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print(ll x){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(C&amp;gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;20&lt;/span&gt;)Ot();&lt;span&gt;if&lt;/span&gt;(x&amp;lt;&lt;span&gt;0&lt;/span&gt;)sr[++C]=&lt;span&gt;45&lt;/span&gt;,x=-&lt;span&gt;x;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(z[++Z]=x%&lt;span&gt;10&lt;/span&gt;+&lt;span&gt;48&lt;/span&gt;,x/=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(sr[++C]=z[Z],--Z);sr[++C]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;ll n,m,q;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; ll sum[M&amp;lt;&amp;lt;&lt;span&gt;2&lt;/span&gt;],add[M&amp;lt;&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; build(){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(m=&lt;span&gt;1&lt;/span&gt;;m&amp;lt;=n;m&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=m+&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=m+n;++i) sum[i]=&lt;span&gt;read();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=m-&lt;span&gt;1&lt;/span&gt;;i;--i) sum[i]=sum[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;]+sum[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; update_part(&lt;span&gt;int&lt;/span&gt; s,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t,ll v){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     ll A=&lt;span&gt;0&lt;/span&gt;,lc=&lt;span&gt;0&lt;/span&gt;,rc=&lt;span&gt;0&lt;/span&gt;,len=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(s+=m-&lt;span&gt;1&lt;/span&gt;,t+=m+&lt;span&gt;1&lt;/span&gt;;s^t^&lt;span&gt;1&lt;/span&gt;;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,t&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,len&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(s&amp;amp;&lt;span&gt;1&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;) add[s^&lt;span&gt;1&lt;/span&gt;]+=v,lc+=&lt;span&gt;len;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(t&amp;amp;&lt;span&gt;1&lt;/span&gt;)    add[t^&lt;span&gt;1&lt;/span&gt;]+=v,rc+=&lt;span&gt;len;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         sum[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=v*lc,sum[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]+=v*&lt;span&gt;rc;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     } &lt;span&gt;for&lt;/span&gt;(lc+=rc,s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;;s;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;) sum[s]+=v*&lt;span&gt;lc; 
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; inline ll query_sum(&lt;span&gt;int&lt;/span&gt; s,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t){
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     ll lc=&lt;span&gt;0&lt;/span&gt;,rc=&lt;span&gt;0&lt;/span&gt;,len=&lt;span&gt;1&lt;/span&gt;,ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(s+=m-&lt;span&gt;1&lt;/span&gt;,t+=m+&lt;span&gt;1&lt;/span&gt;;s^t^&lt;span&gt;1&lt;/span&gt;;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,t&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,len&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(s&amp;amp;&lt;span&gt;1&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;) ans+=sum[s^&lt;span&gt;1&lt;/span&gt;]+len*add[s^&lt;span&gt;1&lt;/span&gt;],lc+=&lt;span&gt;len;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(t&amp;amp;&lt;span&gt;1&lt;/span&gt;) ans+=sum[t^&lt;span&gt;1&lt;/span&gt;]+len*add[t^&lt;span&gt;1&lt;/span&gt;],rc+=&lt;span&gt;len;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(add[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]) ans+=add[s&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]*&lt;span&gt;lc;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(add[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]) ans+=add[t&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;]*&lt;span&gt;rc; 
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     } &lt;span&gt;for&lt;/span&gt;(lc+=rc,s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;;s;s&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;if&lt;/span&gt;(add[s]) ans+=add[s]*&lt;span&gt;lc;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;signed main(){
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     n=read(),q=&lt;span&gt;read(),build();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; opt,x,y; ll k;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(q--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         opt=read(),x=read(),y=&lt;span&gt;read();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(opt&amp;amp;&lt;span&gt;1&lt;/span&gt;) k=&lt;span&gt;read(),update_part(x,y,k);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; print(query_sum(x,y));
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     } Ot(); &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;emmm...实在是太晚啦&lt;span&gt;（其实是没有研究过区间乘）&lt;/span&gt;，所以就...您自个儿研究呗~~~&lt;/strong&gt;&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;题目：  &lt;a href=&quot;https://www.luogu.org/problemnew/show/P1438&quot; target=&quot;_blank&quot;&gt;无聊的数列&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其实这道题用普通线段树 + 懒标记也可以做 （你可以试试？）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是用了 zkw 之后...那个代码量的差别，我都不想说什么...&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a5712e87-5c3e-403f-b110-30c650de9c66')&quot; readability=&quot;55&quot;&gt;&lt;img id=&quot;code_img_closed_a5712e87-5c3e-403f-b110-30c650de9c66&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a5712e87-5c3e-403f-b110-30c650de9c66&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a5712e87-5c3e-403f-b110-30c650de9c66',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a5712e87-5c3e-403f-b110-30c650de9c66&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;105&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;by Judge&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; M=&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m,q,opt,L,R,k,d;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a[M],lt[M],dt[M];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define getchar() (p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,1&amp;lt;&amp;lt;21,stdin),p1==p2)?EOF:*p1++)&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;21&lt;/span&gt;],*p1=buf,*p2=&lt;span&gt;buf;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt;&lt;span&gt; read(){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; x=&lt;span&gt;0&lt;/span&gt;,f=&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;char&lt;/span&gt; c=&lt;span&gt;getchar();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;!isdigit(c);c=getchar()) &lt;span&gt;if&lt;/span&gt;(c==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) f=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;isdigit(c);c=getchar()) x=x*&lt;span&gt;10&lt;/span&gt;+c-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;return&lt;/span&gt; x*&lt;span&gt;f;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; sr[&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;21&lt;/span&gt;],z[&lt;span&gt;20&lt;/span&gt;];&lt;span&gt;int&lt;/span&gt; C=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,Z;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; Ot(){fwrite(sr,&lt;span&gt;1&lt;/span&gt;,C+&lt;span&gt;1&lt;/span&gt;,stdout),C=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; print(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(C&amp;gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;20&lt;/span&gt;)Ot();&lt;span&gt;if&lt;/span&gt;(x&amp;lt;&lt;span&gt;0&lt;/span&gt;)sr[++C]=&lt;span&gt;45&lt;/span&gt;,x=-&lt;span&gt;x;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(z[++Z]=x%&lt;span&gt;10&lt;/span&gt;+&lt;span&gt;48&lt;/span&gt;,x/=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(sr[++C]=z[Z],--Z);sr[++C]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; Ot();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; build(){
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=m;i;--i) lt[i]=lt[i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; update(&lt;span&gt;int&lt;/span&gt; L,&lt;span&gt;int&lt;/span&gt; R,&lt;span&gt;int&lt;/span&gt; k,&lt;span&gt;int&lt;/span&gt; d){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;update 还是蛮常规的&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; l=L+m-&lt;span&gt;1&lt;/span&gt;,r=R+m+&lt;span&gt;1&lt;/span&gt;;l^r^&lt;span&gt;1&lt;/span&gt;;l&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,r&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(l&amp;amp;&lt;span&gt;1&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;) a[l^&lt;span&gt;1&lt;/span&gt;]+=k+(lt[l^&lt;span&gt;1&lt;/span&gt;]-L)*d,dt[l^&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;d;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(r&amp;amp;&lt;span&gt;1&lt;/span&gt;) a[r^&lt;span&gt;1&lt;/span&gt;]+=k+(lt[r^&lt;span&gt;1&lt;/span&gt;]-L)*d,dt[r^&lt;span&gt;1&lt;/span&gt;]+=&lt;span&gt;d;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt; query(&lt;span&gt;int&lt;/span&gt; p,&lt;span&gt;int&lt;/span&gt; res){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;query 感性理解一下：非叶子节点存储的是附加值，也就是操作 1 当中加入的等差数列&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=m+p;i;i&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;) res+=a[i]+(p-lt[i])*&lt;span&gt;dt[i];
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     n=read(),q=read(); &lt;span&gt;for&lt;/span&gt;(m=&lt;span&gt;1&lt;/span&gt;;m&amp;lt;=n;m&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;); printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,m);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;++i) a[m+i]=read(),lt[m+i]=&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    build();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(q--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         opt=&lt;span&gt;read();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(opt&amp;amp;&lt;span&gt;1&lt;/span&gt;) L=read(),R=read(),k=read(),d=&lt;span&gt;read(),update(L,R,k,d);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; k=read(),print(query(k,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     } Ot(); &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Co&lt;strong&gt;d&lt;/strong&gt;e&lt;/span&gt;&lt;/div&gt;






&lt;p&gt;最后推荐一下：  &lt;a href=&quot;https://blog.csdn.net/keshuqi/article/details/52205884&quot; target=&quot;_blank&quot;&gt;某位大佬的 blog&lt;/a&gt; （写的也蛮详细的&lt;span&gt;但没我详细哈哈哈哈&lt;/span&gt;，emmm...但是他那片博客里的区间求最值是错的，坑！）&lt;/p&gt;
</description>
<pubDate>Tue, 21 Aug 2018 14:31:00 +0000</pubDate>
<dc:creator>Judge_Cheung</dc:creator>
<og:description>zkw segment-tree 真是太棒了（重口味）！写篇博客纪念入门 emmm...首先我们来介绍一下 zkw 线段树这个东西（俗称 &quot;重口味&quot; ，与 KMP 类似，咳咳...</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Judge/p/9514862.html</dc:identifier>
</item>
<item>
<title>mysql 主从同步 - 你是我的独家记忆</title>
<link>http://www.cnblogs.com/derrickrose/p/9514606.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derrickrose/p/9514606.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt; 1、mysql主从复制介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       mysql 服务器之间的复制是基于二进制日志机制的。在主服务器上开启二进制日志，当mysql实例进行写操作时会同时生成一条操作事件日志并写入二进制日志文件中，而从服务器则负责读取主服务器上的二进制日志，并在从服务器上重新执行该事件，从而实现复制数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       从库生成两个线程，一个I/O线程，一个SQL线程；I/O线程去请求主库 的binlog，并将得到的binlog日志写到relay log（中继日志） 文件中；主库会生成一个 log dump 线程，用来给从库 i/o线程传binlog；SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;img src=&quot;https://images2018.cnblogs.com/blog/1266412/201808/1266412-20180821223620009-223745167.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、主从形式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1266412/201808/1266412-20180821223752199-1957001839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、主从复制实战&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;环境:centos 6.5  192.168.2.11(主)
    centos 6.5  192.168.2.22(从)

1、关闭iptables
[root@mysql01 yum.repos.d]# service iptables stop
[root@mysql01 yum.repos.d]# chkconfig iptables off

2、在两台机器安装mysql(一样的操作)
[root@mysql01 yum.repos.d]# yum install -y mysql mysql-server
[root@mysql01 yum.repos.d]# service mysqld start
[root@mysql01 yum.repos.d]# chkconfig mysqld on
[root@mysql01 yum.repos.d]# mysqladmin -uroot password '00000000'

3、在mysql01上创建数据库test01，并在上面创建student表
[root@mysql01 yum.repos.d]# mysql -uroot -p
mysql&amp;gt; create database test01;
mysql&amp;gt; use test01;
mysql&amp;gt; create table student(name varchar(10),id int(4));
mysql&amp;gt; insert into student(name,id)values('long01',1);
mysql&amp;gt; insert into student(name,id)values('long02',2);
mysql&amp;gt; exit

4、在mysql01编辑my.cnf文件
[root@mysql01 yum.repos.d]# vi /etc/my.cnf
[mysqld]
log-bin=long-bin
#启用二进制日志
server-id=101
#设置服务器编号，不能重复
binlog-do-db=test01,test02
#binlog-ignore-db=test01,test02
#这两个参数分别的作用是需要复制的库和定义不需要复制的库，用其一即可
[root@mysql01 yum.repos.d]# service mysqld restart

5、在mysql02设置服务器编号(不能和mysql01一样)
[root@mysql02 ~]# vi /etc/my.cnf
[mysqld]
server-id=102
binlog-do-db=test01,test02
#binlog-ignore-db=test01
[root@mysql01 yum.repos.d]# service mysqld restart

6、在mysql01上创建复制账号
[root@mysql01 yum.repos.d]# mysql -uroot -p
mysql&amp;gt; create user 'slave_cp'@'%' identified by '00000000';
mysql&amp;gt; grant replication slave on *.* to 'slave_cp'@'%';
mysql&amp;gt; exit

7、获取mysql01二进制日志信息
[root@mysql01 yum.repos.d]# mysql -uroot -p
mysql&amp;gt; flush tables with read lock;
#锁定数据库的写操作，作用是对所用的表执行只读锁定，写的操作会被拒绝，防止在查看二进制日志时有人对数据进行修改
mysql&amp;gt; show master status;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1266412/201808/1266412-20180821224749096-1387008728.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;mysql&amp;gt; unlock tables;
#对全局锁执行结束操作
mysql&amp;gt; exit

8、对mysql01现有的数据库进行备份,并导入mysql02
[root@mysql01 yum.repos.d]# mysqldump -uroot -p00000000 test01 &amp;gt;/tmp/long.sql
[root@mysql01 yum.repos.d]# scp /tmp/long.sql 192.168.2.22:/tmp/
[root@mysql02 ~]# mysql -uroot -p
mysql&amp;gt; create database test01;
[root@mysql02 ~]# mysql -uroot -p00000000 test01 &amp;lt;/tmp/long.sql

9、配置从服务器mysql02连接主服务器mysql01进行数据复制
[root@mysql02 ~]# mysql -uroot -p
mysql&amp;gt; change master to
-&amp;gt; master_host='192.168.2.11',
-&amp;gt; master_user='slave_cp',
-&amp;gt; master_password='00000000',
-&amp;gt; master_log_file='long-bin.000001',
-&amp;gt;master_log_pos=339;
mysql&amp;gt; start slave;
mysql&amp;gt; show slave status\G;
 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1266412/201808/1266412-20180821224921927-197376434.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;10、数据同步验证(在mysql01上创建新的数据库和在数据库test01上的表student加入新的数据)
[root@mysql01 yum.repos.d]# mysql -uroot -p
mysql&amp;gt; create database test02;
mysql&amp;gt; use test01;
mysql&amp;gt; insert into student values('long03',3);

[root@mysql02 ~]# mysql -uroot -p
mysql&amp;gt; show databases;
 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1266412/201808/1266412-20180821225118626-662967362.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;mysql&amp;gt; select * from student;
 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1266412/201808/1266412-20180821225155377-214396270.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;#如果slave上写了数据，主从复制会被破坏。重启master，得先关闭slave(slave stop),然后&lt;br/&gt;重启master 的mysql 服务，slave 也重新start slave。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 21 Aug 2018 14:30:00 +0000</pubDate>
<dc:creator>你是我的独家记忆</dc:creator>
<og:description>mysql 主从复制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derrickrose/p/9514606.html</dc:identifier>
</item>
<item>
<title>RxJS v6 学习指南 - 万里秋山</title>
<link>http://www.cnblogs.com/ang-/p/9514430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ang-/p/9514430.html</guid>
<description>&lt;h2 id=&quot;为什么要使用-rxjs&quot;&gt;为什么要使用 RxJS&lt;/h2&gt;
&lt;p&gt;RxJS 是一套处理异步编程的 API，那么我将从异步讲起。&lt;/p&gt;
&lt;p&gt;前端编程中的异步有：事件（event）、AJAX、动画（animation）、定时器（timer）。&lt;/p&gt;
&lt;h3 id=&quot;异步常见的问题&quot;&gt;异步常见的问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;回调地狱（Callback Hell）&lt;/li&gt;
&lt;li&gt;竞态条件（Race Condition）&lt;/li&gt;
&lt;li&gt;内存泄漏（Memory Leak）&lt;/li&gt;
&lt;li&gt;管理复杂状态（Manage Complex States）&lt;/li&gt;
&lt;li&gt;错误处理（Exception Handling）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;回调地狱就是指层层嵌套的回调函数，造成代码难以理解，并且难以协调组织复杂的操作。&lt;/p&gt;
&lt;p&gt;竞态条件出现的原因是无法保证异步操作的完成会和他们开始时的顺序一样，因此最终结果不可控。比如常见的 AutoComplete 效果，每次输入后向后端发送请求获取结果展示在搜索框下面，由于网络、后端数据查询等原因有可能出现最后发送的请求比之前的请求更快地完成了，这时最终展现的并不是最后那个请求的结果，而这并不是我们所希望的。&lt;/p&gt;
&lt;p&gt;这里说的内存泄漏指的是单页应用切换页面时由于忘记在合适的时机移除监听事件造成的内存泄漏。&lt;/p&gt;
&lt;p&gt;异步带来了状态的改变，可能会使状态管理变得非常复杂，尤其是某个状态有多个来源时，比如有些应用，一开始有一个默认值，再通过 AJAX 获取初始状态，存储在 localStorage，之后通过 WebSocket 获取更新。这时查询状态可能是同步或者异步的，状态的变更可能是主动获取也可能是被动推送的，如果还有各种排序、筛选，状态管理将会更加复杂。&lt;/p&gt;
&lt;p&gt;JavaScript 中的 try/catch 只能捕获同步的错误，异步的错误不易处理。&lt;/p&gt;
&lt;h3 id=&quot;promise&quot;&gt;Promise&lt;/h3&gt;
&lt;p&gt;使用 Promise 可以减轻一些异步问题，如将回调函数变为串行的链式调用，统一同步和异步代码等，async/await 中也可以使用 try/catch 来捕获错误。但是对于复杂的场景，仍然难于处理。而且 Promise 还有其他的问题，一是只有一个结果，二是不可以取消。&lt;/p&gt;
&lt;h3 id=&quot;异步-api&quot;&gt;异步 API:&lt;/h3&gt;
&lt;p&gt;异步编程时不仅要面对这些问题，还有下面这些使用方式各异的 API：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DOM Events&lt;/li&gt;
&lt;li&gt;XMLHttpRequest&lt;/li&gt;
&lt;li&gt;fetch&lt;/li&gt;
&lt;li&gt;WebSocket&lt;/li&gt;
&lt;li&gt;Service Worker&lt;/li&gt;
&lt;li&gt;setTimeout&lt;/li&gt;
&lt;li&gt;setInterval&lt;/li&gt;
&lt;li&gt;requestAnimationFrame&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而如果使用 RxJS，可以用统一的 API 来进行处理，而且借助 RxJS 各种强大的操作符，我们可以更简单地实现我们的需求。&lt;/p&gt;
&lt;h2 id=&quot;认识-rxjs&quot;&gt;认识 RxJS&lt;/h2&gt;
&lt;h3 id=&quot;什么是-rxjs&quot;&gt;什么是 RxJS&lt;/h3&gt;
&lt;p&gt;我们都知道 JS 是什么，那么什么是 Rx 呢？Rx 是 Reactive Extension（也叫 ReactiveX）的简称，指的是实践响应式编程的一套工具，&lt;a href=&quot;http://reactivex.io/&quot;&gt;Rx 官网&lt;/a&gt;首页的介绍是一套通过可监听流来做异步编程的 API（An API for asynchronous programming with observable streams）。&lt;/p&gt;
&lt;p&gt;Rx 最早是由微软开发的 LinQ 扩展出来的开源项目，之后由开源社区维护，有多种语言的实现，如 Java 的 RxJava，Python 的 RxPY 等，而 RxJS 就是 Rx 的 JavaScript 语言实现。&lt;/p&gt;
&lt;h3 id=&quot;rxjs-的两种编程思想&quot;&gt;RxJS 的两种编程思想&lt;/h3&gt;
&lt;p&gt;RxJS 引入了两种重要的编程思想：函数式编程和响应式编程。&lt;/p&gt;
&lt;p&gt;函数式编程（Functional Programming，简称 FP）是一种编程范式，强调使用函数来思考问题、编写代码。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;In computer science, functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数式编程的主要设计点在于避免使用状态和可变的数据，即 stateless and immutable。&lt;/p&gt;
&lt;p&gt;函数式编程对函数的使用有一些特殊要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;声明式（Declarative）&lt;/li&gt;
&lt;li&gt;纯函数（Pure Function）&lt;/li&gt;
&lt;li&gt;数据不可变性（Immutability）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;声明式的函数，让开发者只需要表达”想要做什么”，而不需要表达“怎么去做”。&lt;/p&gt;
&lt;p&gt;纯函数指的是执行结果由输入参数决定，参数相同时结果相同，不受其他数据影响，并且不会带来副作用（Side Effect）的函数。副作用指的是函数做了和本身运算返回值没有关系的事情，如修改外部变量或传入的参数对象，甚至是执行 console.log 都算是 Side Effect。前端中常见的副作用有发送 http 请求、操作 DOM、调用 alert 或者 confirm 函数等。满足纯函数的特性也叫做引用透明度（Referential Transparency）。&lt;/p&gt;
&lt;p&gt;数据不可变就是指这个数据一旦产生，它的值就永远不会变。JavaScript 中字符串类型和数字类型就是不可改变的，而对象基本都是可变的，可能会带来各种副作用。现在有各种库可以实现 Immutable 特性，如 &lt;a href=&quot;https://github.com/facebook/immutable-js/&quot;&gt;immutable.js&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/mweststrate/immer&quot;&gt;immer.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文维基上说响应式编程（Reactive Programming）是一种面向数据流（stream）和变化传播的编程范式。个人的理解是对数据流进行编程的一种编程范式，使用各种函数创建、组合、过滤数据流，然后通过监听这个数据流来响应它的变化。响应式编程抽象出了流这个概念，提高了代码的抽象级别，我们不用去关心大量的实现细节，而专注于对数据流的操作。&lt;/p&gt;
&lt;p&gt;响应式流可以认为是随着时间发出的一系列元素。响应式和观察者模式有点相似，订阅者订阅后，发布者吐出数据时，订阅者会响应式进行处理。实际上Rx 组合了观察者模式（Observer pattern ）、迭代器模式（Iterator pattern）和函数式编程。&lt;/p&gt;
&lt;p&gt;RxJS 是上面两种编程思想的结合，但是对于它是不是函数响应式编程（FRP）有比较大的争议，因为它虽然既是函数式又是响应式但是不符合早期 FRP 的定义。&lt;/p&gt;
&lt;h3 id=&quot;rxjs-的特点&quot;&gt;RxJS 的特点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;数据流抽象了很多现实问题&lt;/li&gt;
&lt;li&gt;擅长处理异步问题&lt;/li&gt;
&lt;li&gt;把复杂问题分解为简单问题的组合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前端中的 DOM 事件、WebSocket 推送消息、AJAX 请求资源、动画都可以看作是数据流。&lt;/p&gt;
&lt;p&gt;RxJS 对数据采用“推”的方式，当一个数据产生时，会将其推送给对应的处理函数，这个处理函数不用关心数据时同步产生还是异步产生的，因此处理异步将会变得非常简单。&lt;/p&gt;
&lt;p&gt;RxJS 中很多操作符，每个操作符都提供了一个小功能，学习 RxJS 最重要的就是学习如何组合操作符来解决复杂问题。&lt;/p&gt;
&lt;h2 id=&quot;rxjs-入门&quot;&gt;RxJS 入门&lt;/h2&gt;
&lt;h3 id=&quot;rxjs-使用&quot;&gt;RxJS 使用&lt;/h3&gt;
&lt;p&gt;RxJS 仓库现在移到了 ReactiveX 组织下，最新的大版本为 6，与之前的版本相比有许多破坏性变更，请注意。&lt;/p&gt;
&lt;p&gt;RxJS 的 import 路径有以下 5 种：&lt;/p&gt;
&lt;ol readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;创建 Observable 的方法、types、schedulers 和一些工具方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import { Observable, Subject, asapScheduler, pipe, of, from, interval, merge, fromEvent, SubscriptionLike, PartialObserver } from 'rxjs';&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;操作符 operators&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import { map, filter, scan } from 'rxjs/operators';&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;webSocket&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import { webSocket } from 'rxjs/webSocket';&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ajax&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import { ajax } from 'rxjs/ajax';&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import { TestScheduler } from 'rxjs/testing';&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;本文所有 demo 均在 v6.2.1 中测试过&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;一个简单的例子&quot;&gt;一个简单的例子&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import { fromEvent } from 'rxjs';
import { take } from 'rxjs/operators';

const eleBtn = document.querySelector('#btn')
const click$ = fromEvent(eleBtn, 'click')

click$.pipe(take(1))
  .subscribe(e =&amp;gt; {
    console.log('只可点击一次')
    eleBtn.setAttribute('disabled', '')
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里演示了 RxJS 的大概用法，通过 fromEvent 将点击事件转换为 RxJS 的 Observable （响应式数据流），take(1) 表示只操作一次，观察者通过订阅（subscribe）来响应变化。具体 API 的使用会在后面讲到。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackblitz.com/edit/js-epiwre?file=index.js&quot;&gt;演示地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代表流的变量用 $ 符号结尾，是 RxJS 中的一种惯例。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;rxjs-要点&quot;&gt;RxJS 要点&lt;/h3&gt;
&lt;p&gt;RxJS 有一个核心和三个重点，一个核心是 Observable 再加上相关的 Operators，三个重点分别是 Observer、Subject、Schedulers。&lt;/p&gt;
&lt;h4 id=&quot;什么是-observable&quot;&gt;什么是 Observable&lt;/h4&gt;
&lt;p&gt;个人认为在文档中说的 Observable 更确切的说法是 Observable Stream，也就是 Rx 的响应式数据流。&lt;/p&gt;
&lt;p&gt;在 RxJS 中 Observable 是可被观察者，观察者则是 Observer，它们通过 Observable 的 subscribe 方法进行关联。&lt;/p&gt;
&lt;p&gt;前面提到了 RxJS 结合了观察者模式和迭代器模式。&lt;/p&gt;
&lt;p&gt;对于观察者模式，我们其实比较熟悉了，比如各种 DOM 事件的监听，也是观察者模式的一种实践。核心就是发布者发布事件，观察者选择时机去订阅（subscribe）事件。&lt;/p&gt;
&lt;p&gt;在 ES6 中，Array、String 等可遍历的数据结构原生部署了迭代器（Iterator ）接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const numbers = [1, 2, 3]
const iterator = numbers[Symbol.iterator]()
iterator.next() // {value: 1, done: false}
iterator.next() // {value: 2, done: false}
iterator.next() // {value: 3, done: false}
iterator.next() // {value: undefined, done: true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察者模式和迭代器模式的相同之处是两者都是渐进式使用数据的，只不过从数据使用者的角度来说，观察者模式数据是推送（push）过来的，而迭代器模式是自己去拉取（pull）的。Rx 中的数据是 Observable 推送的，观察者不需要主动去拉取。&lt;/p&gt;
&lt;p&gt;Observable 与 Array 相当类似，都可以看作是 Collection，只不过 Observable 是 a collection of items over time，是随时间发出的一序列元素，所以下面我们会看到 Observable 的一些操作符与 Array 的方法极其相似。&lt;/p&gt;
&lt;h3 id=&quot;创建-observable&quot;&gt;创建 Observable&lt;/h3&gt;
&lt;p&gt;要创建一个 Observable，只要给 new Observable 传递一个接收 observer 参数的回调函数，在这个函数中去定义如何发送数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { Observable } from 'rxjs';

const source$ = new Observable(observer =&amp;gt; {
  observer.next(1)
  observer.next(2)
  observer.next(3)
})

const observer = {
  next : item =&amp;gt; console.log(item)
}

console.log('start')
source$.subscribe(observer)
console.log('end')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码通过 new Observable 创建了一个 Observable，调用它的 subscribe 方法进行订阅，执行结果为依次输出 'start'，1，2，3，'end'。&lt;/p&gt;
&lt;p&gt;下面我们再看一个异步的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { Observable } from 'rxjs';
    
const source$ = new Observable(observer =&amp;gt; {
  let number = 1
  setInterval(() =&amp;gt; {
    observer.next(number++)
  }, 1000)
})

const observer = {
  next : item =&amp;gt; console.log(item)
}

console.log('start')
source$.subscribe(observer)
console.log('end')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先输出 ’start' 、'end'，然后每隔 1000 ms 输出一个递增的数字。&lt;/p&gt;
&lt;p&gt;通过这两个小例子，我们知道 RxJS 既能处理同步的行为，也能处理异步的。&lt;/p&gt;
&lt;h4 id=&quot;观察者-observer&quot;&gt;观察者 Observer&lt;/h4&gt;
&lt;p&gt;观察者 Observer 是一个有三个方法的对象：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;next: 当 Observable 发出新的值时被调用，接收这个值作为参数&lt;/li&gt;
&lt;li&gt;complete：当 Observable 完结，没有更多数据时被调用。complete 之后，next 方法无效&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;error：当 Observable 内部发生错误时被调用，之后不会调用 complete，next 方法无效&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const source$ = new Observable(observer =&amp;gt; {
  observer.next(1)
  observer.next(2)
  observer.complete()
  observer.next(3)
})

const observer = {
  next: item =&amp;gt; console.log(item),
  complete: () =&amp;gt; console.log('complete')
}

source$.subscribe(observer)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的代码会输出 1，2，'complete'，而不会输出 3。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const source$ = new Observable(observer =&amp;gt; {
  try {
    observer.next(1)
    observer.next(2)
    throw new Error('there is an exception')
    observer.complete()
  } catch (e) {
    observer.error(e)
  }
})

const observer = {
  next: item =&amp;gt; console.log(item),
  error: e =&amp;gt; console.log(e),
  complete: () =&amp;gt; console.log('complete')
}

source$.subscribe(observer)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意 error 之后不会再调用 complete。&lt;/p&gt;
&lt;p&gt;Observer 还有简单形式，即不用构建一个对象，而是直接把函数作为 subscribe 方法的参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source$.subscribe(
  item =&amp;gt; console.log(item),
  e =&amp;gt; console.log(e),
  () =&amp;gt; console.log('complete')
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数依次为 next 、error、complete，后面两个参数可以省略。&lt;/p&gt;
&lt;h3 id=&quot;延迟执行lazy-evaluation&quot;&gt;延迟执行（lazy evaluation）&lt;/h3&gt;
&lt;p&gt;我们传给 new Observable 的回调函数如果没有订阅是不会执行的，订阅一个 Observable 就像是执行一个函数，和下面的函数类似。这和我们常见的那种内部保存有观察者列表的观察者模式是不同的，Observable 内部没有这个观察者列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function subscribe (observer) {
  let number = 1
  setInterval(() =&amp;gt; {
    observer.next(number++)
  }, 1000)
}

subscribe({
    next: item =&amp;gt; console.log(item),
    error: e =&amp;gt; console.log(e),
    complete: () =&amp;gt; console.log('complete')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;退订unsubscribe&quot;&gt;退订（unsubscribe）&lt;/h3&gt;
&lt;p&gt;观察者想退订，只要调用订阅返回的对象的 unsubscribe 方法，这样观察者就再也不会接受到 Observable 的信息了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const source$ = new Observable(observer =&amp;gt; {
  let number = 1
  setInterval(() =&amp;gt; {
    observer.next(number++)
  }, 1000)
})

const observer = {
  next : item =&amp;gt; console.log(item)
}

const subscription = source$.subscribe(observer)

setTimeout(() =&amp;gt; {
  subscription.unsubscribe()
}, 5000)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;操作符&quot;&gt;操作符&lt;/h3&gt;
&lt;p&gt;在 RxJS 中，操作符是用来处理数据流的。我们往往需要对数据流做一系列处理，才交给 Observer，这时一个操作符就像一个管道一样，数据进入管道，完成处理，流出管道。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { interval } from 'rxjs';
import { map } from 'rxjs/operators'
    
const source$ = interval(1000).pipe(
  map(x =&amp;gt; x * x)
)

source$.subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;interval 操作符创造了一个数据流，interval(1000) 会产生一个每隔 1000 ms 就发出一个从 0 开始递增的数据。map 操作符和数组的 map 方法类似，可以对数据流进行处理。具体见&lt;a href=&quot;https://stackblitz.com/edit/js-azpqqb?file=index.js&quot;&gt;演示地址&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这个 map 和数组的 map 方法会产生新的数组类似，它会产生新的 Observable。每一个操作符都会产生一个新的 Observable，不会对上游的 Observable 做任何修改，这完全符合函数式编程“数据不可变”的要求。&lt;/p&gt;
&lt;p&gt;上面的 pipe 方法就是数据管道，会对数据流进行处理，上面的例子只有一个 map 操作符进行处理，可以添加更多的操作符作为参数。&lt;/p&gt;
&lt;h3 id=&quot;弹珠图&quot;&gt;弹珠图&lt;/h3&gt;
&lt;p&gt;弹珠图（Marble diagrams）就是用图例形象地表示 Observable 和各种操作符的一种方法。&lt;/p&gt;
&lt;p&gt;用 - 表示一小段时间，X 代表有错误发生， | 表示结束，() 表示同步发生。&lt;/p&gt;
&lt;p&gt;上面的例子可以如下表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source: -----0-----1-----2-----3--...
        map(x =&amp;gt; x * x)
newest: -----0-----1-----4-----9--...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体关于弹珠图的使用可以查看这个网站&lt;a href=&quot;http://rxmarbles.com/&quot; class=&quot;uri&quot;&gt;http://rxmarbles.com/&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;创建-observable-1&quot;&gt;创建 Observable&lt;/h2&gt;
&lt;p&gt;创建 Observable 的这些方法就是用来创建 Observable 数据流的，&lt;strong&gt;注意和操作符不同，它们是从 rxjs 中导入的，而不是 rxjs/operators&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;of-方法&quot;&gt;of 方法&lt;/h3&gt;
&lt;p&gt;之前我们写的这种形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const source$ = new Observable(observer =&amp;gt; {
  observer.next(1)
  observer.next(2)
  observer.next(3)
  observer.complete()
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 of 方法将会非常简洁：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import {of} from 'rxjs'
const source$ = of(1, 2, 3)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;from-方法&quot;&gt;from 方法&lt;/h3&gt;
&lt;p&gt;上面的代码用 from 则是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import {from} from 'rxjs'
const source$ = from([1, 2, 3])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;from 可以将可遍历的对象（iterable）转化为一个 Observable，字符串也部署有 iterator 接口，所以也支持。&lt;/p&gt;
&lt;p&gt;from 还可以根据 promise 创建一个 Observable。我们用 fetch 或者 axios 等类库发送的请求都是一个 promise 对象，我们可以使用 from 将其处理为一个 Observable 对象。&lt;/p&gt;
&lt;h3 id=&quot;fromevent-方法&quot;&gt;fromEvent 方法&lt;/h3&gt;
&lt;p&gt;用 DOM 事件创建 Observable，第一个参数为 DOM 对象，第二个参数为事件名称。具体示例见前面 RxJS 入门章节的一个简单例子。&lt;/p&gt;
&lt;h3 id=&quot;fromeventpattern-方法&quot;&gt;fromEventPattern 方法&lt;/h3&gt;
&lt;p&gt;将添加事件处理器、删除事件处理器的 API 转化为 Observable。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function addClickHandler (handler) {
  document.addEventListener('click', handler)
}
 
function removeClickHandler (handler) {
  document.removeEventListener('click', handler)
}
 
fromEventPattern(
  addClickHandler,
  removeClickHandler
).subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以是我们自己实现的和事件类似，拥有注册监听和移除监听的 API。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { fromEventPattern } from 'rxjs'

class EventEmitter {
  constructor () {
    this.handlers = {}
  }
  on (eventName, handler) {
    if (!this.handlers[eventName]) {
      this.handlers[eventName] = []
    }
    if(typeof handler === 'function') {
        this.handlers[eventName].push(handler)
    } else {
        throw new Error('handler 不是函数！！！')
    }
  }
  off (eventName, handler) {
    this.handlers[eventName].splice(this.handlers[eventName].indexOf(handler), 1)
  }
  emit (eventName, ...args) {
    this.handlers[eventName].forEach(handler =&amp;gt; {
      handler(...args)
    })
  }
}

const event = new EventEmitter()

const subscription = fromEventPattern(
  event.on.bind(event, 'say'), 
  event.off.bind(event, 'say')
).subscribe(x =&amp;gt; console.log(x))

let timer = (() =&amp;gt; {
  let number = 1
  return setInterval(() =&amp;gt; {
    if (number === 5) {
      clearInterval(timer)
      timer = null
    }
    event.emit('say', number++)
  }, 1000)
})()

setTimeout(() =&amp;gt; {
  subscription.unsubscribe()
}, 3000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://stackblitz.com/edit/js-azpqqb&quot;&gt;演示地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;intervaltimer&quot;&gt;interval、timer&lt;/h3&gt;
&lt;p&gt;interval 和 JS 中的 setInterval 类似，参数为间隔时间，下面的代码每隔 1000 ms 会发出一个递增的整数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interval(1000).subscribe(console.log)
// 0
// 1
// 2
// ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;timer 则可以接收两个参数，第一个参数为发出第一个值需要等待的时间，第二个参数为之后的间隔时间。第一个参数可以是数字，也可以是一个 Date 对象，第二个参数可省。&lt;/p&gt;
&lt;h3 id=&quot;range&quot;&gt;range&lt;/h3&gt;
&lt;p&gt;操作符 of 产生较少的数据时可以直接写如 of(1, 2, 3)，但是如果是 100 个呢？这时我们可以使用 range 操作符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;range(1, 100) // 产生 1 到 100 的正整数&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;emptythrowerrornever&quot;&gt;empty、throwError、never&lt;/h3&gt;
&lt;p&gt;empty 是创建一个立即完结的 Observable，throwError 是创建一个抛出错误的 Observable，never 则是创建一个什么也不做的 Observable（不完结、不吐出数据、不抛出错误）。这三个操作符单独用时没有什么意义，主要用来与其他操作符进行组合。目前官方不推荐使用 empty 和 never 方法，而是推荐使用常量 EMPTY 和 NEVER（注意不是方法，已经是一个 Observable 对象了）。&lt;/p&gt;
&lt;h3 id=&quot;defer&quot;&gt;defer&lt;/h3&gt;
&lt;p&gt;defer 创建的 Observable 只有在订阅时才会去创建我们真正想要操作的 Observable。defer 延迟了创建 Observable，而又有一个 Observable 方便我们去订阅，这样也就推迟了占用资源。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;defer(() =&amp;gt; ajax(ajaxUrl))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有订阅了才会去发送 ajax 请求。&lt;/p&gt;
&lt;h2 id=&quot;操作符-1&quot;&gt;操作符&lt;/h2&gt;
&lt;p&gt;操作符其实看作是处理数据流的管道，每个操作符实现了针对某个小的具体应用问题的功能，RxJS 编程最大的难点其实就是如何去组合这些操作符从而解决我们的问题。&lt;/p&gt;
&lt;p&gt;在 RxJS 中，有各种各样的操作符，有转化类、过滤类、合并类、多播类、错误处理类、辅助工具类等等。一般不需要自己去实现操作符，但是我们需要知道操作符是一个函数，实现的时候必须考虑以下功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;返回一个全新的 Observable 对象&lt;/li&gt;
&lt;li&gt;对上游和下游的订阅和退订处理&lt;/li&gt;
&lt;li&gt;处理异常情况&lt;/li&gt;
&lt;li&gt;及时释放资源&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;pipeable-操作符&quot;&gt;pipeable 操作符&lt;/h3&gt;
&lt;p&gt;之前版本的 RxJS 各种操作符都挂载到了全局 Observable 对象上，可以这样链式调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source$.filter(x =&amp;gt; x % 2 === 0).map(x =&amp;gt; x * 2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在需要这样使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import {filter, map} from 'rxjs/operators'

source$.pipe(
  filter(x =&amp;gt; x % 2 === 0),
  map(x =&amp;gt; x * 2)
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实也很好理解，pipe 就是管道的意思，数据流通过操作符处理，流出然后交给下一个操作符。&lt;/p&gt;
&lt;h3 id=&quot;几个类似数组方法的基础操作符&quot;&gt;几个类似数组方法的基础操作符&lt;/h3&gt;
&lt;p&gt;map、filter 和数组的 map、filter 方法类似，scan 则是和 reduce 方法类似，mapTo 是将所有发出的数据映射到一个给定的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import {mapTo} from 'rxjs/operators'

fromEvent(document, 'click').pipe(
  mapTo('Hi')
).subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次点击页面时都会输出 Hi。&lt;/p&gt;
&lt;h3 id=&quot;一些过滤的操作符&quot;&gt;一些过滤的操作符&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;take 是从数据流中选取最先发出的若干数据&lt;/li&gt;
&lt;li&gt;takeLast 是从数据流中选取最后发出的若干数据&lt;/li&gt;
&lt;li&gt;takeUntil 是从数据流中选取直到发生某种情况前发出的若干数据&lt;/li&gt;
&lt;li&gt;first 是获得满足判断条件的第一个数据&lt;/li&gt;
&lt;li&gt;last 是获得满足判断条件的最后一个数据&lt;/li&gt;
&lt;li&gt;skip 是从数据流中忽略最先发出的若干数据&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;skipLast 是从数据流中忽略最后发出的若干数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { interval } from 'rxjs';
import { take } from 'rxjs/operators';

interval(1000).pipe(
  take(3)
).subscribe(
  x =&amp;gt; console.log(x),
  null,
  () =&amp;gt; console.log('complete')
)
// 0
// 1
// 2
// 'complete'&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用了 take(3)，表示只取 3 个数据，Observable 就进入完结状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { interval, fromEvent } from 'rxjs'
import { takeUntil } from 'rxjs/operators'

interval(1000).pipe(
  takeUntil(fromEvent(document.querySelector('#btn'), 'click'))
).subscribe(
  x =&amp;gt; { document.querySelector('#time').textContent = x + 1 },
  null,
  () =&amp;gt; console.log('complete')
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有一个 interval 创建的数据流一直在发出数据，直到当用户点击按钮时停止计时，见&lt;a href=&quot;https://stackblitz.com/edit/js-ucdsmw?file=index.js&quot;&gt;演示&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;合并类操作符&quot;&gt;合并类操作符&lt;/h3&gt;
&lt;p&gt;合并类操作符用来将多个数据流合并。&lt;/p&gt;
&lt;p&gt;1）concat、merge&lt;/p&gt;
&lt;p&gt;concat、merge 都是用来把多个 Observable 合并成一个，但是 concat 要等上一个 Observable 对象 complete 之后才会去订阅第二个 Observable 对象获取数据并把数据传给下游，而 merge 时同时处理多个 Observable。使用方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { interval } from 'rxjs'
import { merge, take } from 'rxjs/operators'

interval(500).pipe(
  take(3),
  merge(interval(300).pipe(take(6)))
).subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以&lt;a href=&quot;https://stackblitz.com/edit/js-wwphh4?file=index.js&quot;&gt;点此&lt;/a&gt;去比对效果，concat 的结果应该比较好理解，merge 借助弹珠图也比较好理解，它是在时间上对数据进行了合并。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source : ----0----1----2|
source2: --0--1--2--3--4--5|
            merge()
example: --0-01--21-3--(24)--5|&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;merge 的逻辑类似 OR，经常用来多个按钮有部分相同行为时的处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意最新的&lt;a href=&quot;https://rxjs-dev.firebaseapp.com/api&quot;&gt;官方文档&lt;/a&gt;和&lt;a href=&quot;https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md&quot;&gt;RxJS v5.x 到 6 的更新指南&lt;/a&gt;中指出不推荐使用 merge、concat、combineLatest、race、zip 这些操作符方法，而是推荐使用对应的静态方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将上面的 merge 改成从 rxjs 中导入，使用方式变成了合并多个 Observable，而不是一个 Observable 与其他 Observable 合并。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { interval，merge } from 'rxjs'
import { take } from 'rxjs/operators'

merge(
  interval(500).pipe(take(3)),
  interval(300).pipe(take(6))
).subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）concatAll、mergeAll、switchAll&lt;/p&gt;
&lt;p&gt;用来将高阶的 Observable 对象压平成一阶的 Observable，和 loadash 中压平数组的 flatten 方法类似。concatAll 会对内部的 Observable 对象做 concat 操作，和 concat 操作符类似，如果前一个内部 Observable 没有完结，那么 concatAll 不会订阅下一个内部 Observable，mergeAll 则是同时处理。switchAll 比较特殊一些，它总是切换到最新的内部 Observable 对象获取数据。上游高阶 Observable 产生一个新的内部 Observable 时，switchAll 就会立即订阅最新的内部 Observable，退订之前的，这也就是 ‘switch’ 的含义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { interval } from 'rxjs';
import { map, switchAll, take } from 'rxjs/operators';

interval(1500).pipe(
  take(2),
  map(x =&amp;gt; interval(1000).pipe(
    map(y =&amp;gt; x + ':' + y), 
    take(2))
  ),
  switchAll()
).subscribe(console.log)

// 0:0
// 1:0
// 1:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内部第一个 Observable 对象的第二个数据还没来得及发出，第二个 Observable 对象就产生了。&lt;/p&gt;
&lt;p&gt;3）concatMap、mergeMap、switchMap&lt;/p&gt;
&lt;p&gt;从上面的例子我们也可以看到高阶 Observable 常常是由 map 操作符将每个数据映射为 Observable 产生的，而我们订阅的时候需要将其压平为一阶 Observable，而就是要先使用 map 操作符再使用 concatAll 或 mergeAll 或 switchAll 这些操作符中的一个。RxJS 中提供了对应的更简洁的 API。使用的效果可以用下面的公式表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;concatMap = map + concatAll
mergeMap = map + mergeAll
switchMap = map + switchAll&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4）zip、combineLatest、withLatestFrom&lt;/p&gt;
&lt;p&gt;zip 有拉链的意思，这个操作符和拉链的相似之处在于数据一定是一一对应的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { interval } from 'rxjs';
import { zip, take } from 'rxjs/operators';
const source$ = interval(500).pipe(take(3))
const newest$ = interval(300).pipe(take(6))

source$.pipe(
  zip(newest$, (x, y) =&amp;gt; x + y)
).subscribe(x =&amp;gt; console.log(x))
// 0
// 2
// 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;zip 是内部的 Observable 都发出相同顺序的数据后才交给下游处理，最后一个参数是可选的 resultSelector 参数，这个函数用来处理操作符的结果。上面的示例运行过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;newest 发出第一个值 0，但这时 source 还没有发出第一个值，所以不执行 resultSelector 函数也不会像下游发出数据&lt;/li&gt;
&lt;li&gt;source 发出第一个值 0，此时 newest 之前已发出了第一个值 0，执行 resultSelector 函数得到结果 0，发出这个结果&lt;/li&gt;
&lt;li&gt;newest 发出第二个值 1，但这时 source 还没有发出第二个值，所以不执行 resultSelector 函数也不会像下游发出数据&lt;/li&gt;
&lt;li&gt;newest 发出第三个值 2，但这时 source 还没有发出第三个值，所以不执行 resultSelector 函数也不会像下游发出数据&lt;/li&gt;
&lt;li&gt;source 发出第二个值 1，此时 newest 之前已发出了第一个值 1，执行 resultSelector 函数得到结果 2，发出这个结果&lt;/li&gt;
&lt;li&gt;newest 发出第四个值 3，但这时 source 还没有发出第四个值，所以不执行 resultSelector 函数也不会像下游发出数据&lt;/li&gt;
&lt;li&gt;source 发出第三个值 2，此时 newest 之前已发出了第一个值 2，执行 resultSelector 函数得到结果 4，发出这个结果&lt;/li&gt;
&lt;li&gt;source 完结，不可能再有对应的数据了，整个 Observable 完结&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面如果没有传递最后一个参数 resultSelector 函数，将会依次输出数组 [0, 0]、[1, 1]、[2, 2]。在更新指南中，官方指出不推荐使用 resultSelector 参数，将会在 v7 中移除。加上之前提到的推荐使用静态方法，这个示例应该改成这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { interval, zip } from 'rxjs';
import { take, map } from 'rxjs/operators';

const source$ = interval(500).pipe(take(3))
const newest$ = interval(300).pipe(take(6))

const add = (x, y) =&amp;gt; x + y

zip(source$, newest$).pipe(
  map(x =&amp;gt; add(...x))
).subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 zip 当有数据流吐出数据很快，而有数据流发出值很慢时，要小心数据积压的问题。这时快的数据流已经发出了很多数据，由于对应的数据还没发出，RxJS 只能保存数据，快的数据流不断地发出数据，积压的数据越来越多，消耗的内存也会越来越大。&lt;/p&gt;
&lt;p&gt;combineLatest 与 zip 不同，只要其他的 Observable 已经发出过值就行，顾名思义，就是与其他 Observable 最近发出的值结合。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { interval, combineLatest } from 'rxjs';
import { take } from 'rxjs/operators';

const source$ = interval(500).pipe(take(3))
const newest$ = interval(300).pipe(take(6))

combineLatest(source$, newest$).subscribe(x =&amp;gt; console.log(x))
// [0, 0]
// [0, 1]
// [0, 2]
// [1, 2]
// [1, 3]
// [2, 3]
// [2, 4]
// [2, 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;withLatestFrom 没有静态方法，只有操作符方法，前面的方法所有 Observable 地位是平等的，而这个方法是使用这个操作符的 Observable 起到了主导作用，即只有它发出值才会进行合并产生数据发出给下游。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { interval } from 'rxjs';
import { take, withLatestFrom } from 'rxjs/operators';

const source$ = interval(500).pipe(take(3))
const newest$ = interval(300).pipe(take(6))

source$.pipe(
  withLatestFrom(newest$)
).subscribe(x =&amp;gt; console.log(x))
// [0, 0]
// [1, 2]
// [2, 4]&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;source 发出 0 时，newest 最新发出的值为 0，结合为 [0, 0] 发出&lt;/li&gt;
&lt;li&gt;source 发出 1，此时 newest 最新发出的值为 2，结合为 [1, 2] 发出&lt;/li&gt;
&lt;li&gt;source 发出 2，此时 newest 最新发出的值为 4，结合为 [2, 4] 发出&lt;/li&gt;
&lt;li&gt;source 完结，整个 Observable 完结&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;5）startWith、forkJoin、race&lt;/p&gt;
&lt;p&gt;startWith 是在 Observable 的一开始加入初始数据，同步立即发送，常用来提供初始状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { fromEvent, from } from 'rxjs';
import { startWith, switchMap } from 'rxjs/operators';

const source$ = fromEvent(document.querySelector('#btn'), 'click')

let number = 0
const fakeRequest = x =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
      resolve(number++)
    }, 1000)
  })
}

source$.pipe(
  startWith('initData'),
  switchMap(x =&amp;gt; from(fakeRequest(x)))
).subscribe(x =&amp;gt; document.querySelector('#number').textContent = x)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里通过 startWith 操作符获取了页面的初始数据，之后通过点击按钮获取更新数据。&lt;/p&gt;
&lt;p&gt;forkJoin 只有静态方法形式，类似 Promise.all ，它会等内部所有 Observable 都完结之后，将所有 Observable 对象最后发出来的最后一个数据合并成 Observable。&lt;/p&gt;
&lt;p&gt;race 操作符产生的 Observable 会完全镜像最先吐出数据的 Observable。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const obs1 = interval(1000).pipe(mapTo('fast one'));
const obs2 = interval(3000).pipe(mapTo('medium one'));
const obs3 = interval(5000).pipe(mapTo('slow one'));

race(obs3, obs1, obs2)
.subscribe(
  winner =&amp;gt; console.log(winner)
);

// result:
// a series of 'fast one'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;一个小的练习&quot;&gt;一个小的练习&lt;/h3&gt;
&lt;p&gt;本文中的例子基本来自&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10186104&quot;&gt;30 天精通 RxJS&lt;/a&gt;，使用 RxJS v6 版本进行重写。&lt;/p&gt;
&lt;p&gt;页面上有一个 p 标签存放一个状态，初始为 0，有两个按钮，一个按钮点击后这个状态增加 1，另一个按钮点击后这个状态减少 1。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;button id=&quot;addButton&quot;&amp;gt;Add&amp;lt;/button&amp;gt;
&amp;lt;button id=&quot;minusButton&quot;&amp;gt;Minus&amp;lt;/button&amp;gt;
&amp;lt;p id=&quot;state&quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个按钮的点击事件我们都可以建立响应式数据流，可以使用 mapTo(1) 和 mapTo(-1) 分别表示点击后增加 1 和减少 1。我们可以使用 EMPTY 创建一个空的数据流来表示这个状态，用 startWith 设定初始值。然后 merge 这两个点击的数据流，但是这还有一个问题，点击事件的数据流需要与表示状态的数据流进行逻辑计算，发出最终的状态，我们才能去订阅这个最终的数据流来更改页面的显示。而这种累计计算的方法，可以用 scan 操作符来实现。最终实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { fromEvent, EMPTY, merge } from 'rxjs'
import { mapTo, startWith, scan } from 'rxjs/operators'

const addButton = document.getElementById('addButton')
const minusButton = document.getElementById('minusButton')
const state = document.getElementById('state')

const addClick$ = fromEvent(addButton, 'click').pipe(mapTo(1))
const minusClick$ = fromEvent(minusButton, 'click').pipe(mapTo(-1))

merge(
  EMPTY.pipe(startWith(0)),
  addClick$, 
  minusClick$)
.pipe(
  scan((origin, next) =&amp;gt; origin + next)
).subscribe(item =&amp;gt; {
  state.textContent = item
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://stackblitz.com/edit/js-ysqj3b?file=index.js&quot;&gt;查看演示&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;简单拖拽&quot;&gt;简单拖拽&lt;/h3&gt;
&lt;p&gt;页面上有一个 id 为 drag 的 div：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div id=&quot;drag&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;页面 css：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;html, body {
  height: 100%;
  background-color: tomato;
  position: relative;
}

#drag {
  position: absolute;
  width: 100px;
  height: 100px;
  background-color: #fff;
  cursor: all-scroll;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要实现的功能如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当在这个 div 上按下鼠标左键(mousedown)时，开始监听鼠标移动(mousemove)位置&lt;/li&gt;
&lt;li&gt;当鼠标松开(mouseup)时，结束监听鼠标移动&lt;/li&gt;
&lt;li&gt;当鼠标移动被监听时，更新 div 样式来实现拖拽效果&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实现思路：&lt;/p&gt;
&lt;ol readability=&quot;13.462131837307&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;我们可以使用 fromEvent 去转化 DOM 事件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const mouseDown$ = fromEvent(eleDrag, 'mousedown')
const mouseMove$ = fromEvent(eleBody, 'mousemove')
const mouseUp$ = fromEvent(eleBody, 'mouseup')&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于鼠标按下这个数据流，每次鼠标按下事件发生时都转成鼠标移动的数据流&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mouseDown$.pipe(
  map(mouseDownEvent =&amp;gt; mouseMove$)
)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;鼠标松开时，结束监听鼠标移动，我们可以用 takeUntil 表示这个逻辑&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mouseDown$.pipe(
  map(mouseDownEvent =&amp;gt; mouseMove$.pipe(
    takeUntil(mouseUp$)
  ))
)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;上面的 map 操作符内将每次 mousedown 映射为一个 Observable，形成了高阶 Observable，我们需要用 concatlAll 压平，map 和 concatAll 连用，可以用更简洁的 concatMap&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mouseDown$.pipe(
  concatMap(mouseDownEvent =&amp;gt; mouseMove$.pipe(
    takeUntil(mouseUp$)
  ))
)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7.9478827361564&quot;&gt;
&lt;p&gt;订阅这个 mousemove 数据流更新 div 位置。我们可以获取 mousemove event 中的 clientX 和 clientY，减去初始鼠标按下时鼠标相对 div 元素的值来得到最终 div 的绝对位置的 left 和 top。也可以使用 withLatestFrom 操作符，见 &lt;a href=&quot;https://stackblitz.com/edit/js-uujnnv&quot;&gt;demo&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mouseDown$.pipe(
  concatMap(mouseDownEvent =&amp;gt; mouseMove$.pipe(
    map(mouseMoveEvent =&amp;gt; ({
      left: mouseMoveEvent.clientX - mouseDownEvent.offsetX,
      top: mouseMoveEvent.clientY - mouseDownEvent.offsetY
    })),
    takeUntil(mouseUp$)
  ))
).subscribe(position =&amp;gt; {
  eleDrag.style.left = position.left + 'px'
  eleDrag.style.top = position.top + 'px'
})&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://stackblitz.com/edit/js-wexzbx?file=index.js&quot;&gt;这里&lt;/a&gt;是一个更复杂一些的例子，当页面滑动到视频出页面时视频 fixed 定位，这是可以拖拽移动视频位置。通过 getValidValue 对视频拖拽的位置进行了一个限制。&lt;/p&gt;
&lt;h3 id=&quot;缓存&quot;&gt;缓存&lt;/h3&gt;
&lt;p&gt;把上游的多个数据缓存起来，当时机合适时再把汇聚的数据传给下游。&lt;/p&gt;
&lt;p&gt;1）buffer、bufferTime、bufferCount、bufferWhen、bufferToggle&lt;/p&gt;
&lt;p&gt;对于 buffer 这一组操作符，数据汇聚的形式就是数组。&lt;/p&gt;
&lt;p&gt;buffer 接收一个 Observable 作为 notifier，当 notifier 发出数据时，将 缓存的数据传给下游。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interval(300).pipe(
  take(30),
  buffer(interval(1000))
).subscribe(
  x =&amp;gt; console.log(x)
)
// [0, 1, 2]
// [3, 4, 5]
// [6, 7, 8]
// [9, 10, 11, 12]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bufferTime 是用时间来控制时机，上面可以改成 bufferTime(1000)&lt;/p&gt;
&lt;p&gt;bufferCount 是用数量来控制时机，如 3 个一组，bufferCount(3)&lt;/p&gt;
&lt;p&gt;bufferWhen 接收一个叫做 closeSelector 的参数，它应该返回一个 Observable。通过这个 Observable 来控制缓存。这个函数没有参数。下面的方法等价于前面的 buffer：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interval(300).pipe(
  take(30),
  bufferWhen(() =&amp;gt; {
    return interval(1000)
  })
).subscribe(
  x =&amp;gt; console.log(x)
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bufferToggle 和 buffer 的不同是可以不断地控制缓存窗口的开和关，一个参数是一个 Observable，称为 opening，第二个参数是称为 closeSelector 的一个函数。这个函数的参数是 opening 产生的数据。前一个参数用来控制缓存的开始时间，后一个控制缓存的结束。与 bufferWhen 相比，它的 closeSelector 可以接收参数，控制性更强。&lt;/p&gt;
&lt;p&gt;我们可以使用 buffer 来做事件的过滤，下面的代码只有 500ms 内连续点击两次以上才会输出 ‘success’ 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fromEvent(document.querySelector('#btn'), 'click').pipe(
  bufferTime(500),
  filter(arr =&amp;gt; arr.length &amp;gt;= 2)
).subscribe(
  x =&amp;gt; console.log('success')
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）window、windowTime、windowCount、windowWhen、windowToggle&lt;/p&gt;
&lt;p&gt;与前面的 buffer 类似，不过 window 缓存数据汇聚的形式是 Observable，因此形成了高阶 Observable。&lt;/p&gt;
&lt;h4 id=&quot;debouncetimethrottletime&quot;&gt;debounceTime、throttleTime&lt;/h4&gt;
&lt;p&gt;类似 lodash 的 debounce 和 throttle，用来降低事件的触发频率。&lt;/p&gt;
&lt;p&gt;我们做搜索时，常常要对输入进行 debounce 来减少请求频率。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fromEvent(document.querySelector('#searchInput'), 'input').pipe(
  debounceTime(300),
  map(e =&amp;gt; e.target.value)
).subscribe(
  input =&amp;gt; document.querySelector('#text').textContent = input
  // 发送请求
)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;distinctdistinctuntilchanged&quot;&gt;distinct、distinctUntilChanged&lt;/h3&gt;
&lt;p&gt;distinct 操作符可以用来去重，将上游重复的数据过滤掉。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1).pipe(
  zip(interval(1000)),
  map(arr =&amp;gt; arr[0]),
  distinct()
).subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码只会输出 1, 2, 3, 4&lt;/p&gt;
&lt;p&gt;distinct 操作符还可以接收一个 keySelector 的函数作为参数，这是官网的一个 typescript 的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface Person {
  age: number,
  name: string
}

of&amp;lt;Person&amp;gt;(
  { age: 4, name: 'Foo' },
  { age: 7, name: 'Bar' },
  { age: 5, name: 'Foo' },
).pipe(
  distinct((p: Person) =&amp;gt; p.name),
).subscribe(x =&amp;gt; console.log(x))
 
// { age: 4, name: 'Foo' }
// { age: 7, name: 'Bar' }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;distinctUntilChanged 也是过滤重复数据，但是只会与上一次发出的元素比较。这个操作符比 distinct 更常用。distinct 要与之前发出的不重复的值进行比较，因此要在内部存储这些值，要小心内存泄漏，而 distinctUntilChanged 只用保存上一个的值。&lt;/p&gt;
&lt;h3 id=&quot;dalaydelaywhen&quot;&gt;dalay、delayWhen&lt;/h3&gt;
&lt;p&gt;用来延迟上游 Observable 数据的发出。&lt;/p&gt;
&lt;p&gt;delay 可以接受一个数字（单位默认为 ms）或者 date 对象作为延迟控制。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const clicks = fromEvent(document, 'click')
const delayedClicks = clicks.pipe(delay(1000)) // 所有点击事件延迟 1 秒
delayedClicks.subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们前面介绍过 bufferWhen，dalayWhen 也带有 when，在 RxJS 中，这种操作符它接收的参数都是 Observable Factory，即一个返回 Observable 对象的回调函数，用这个 Observable 来进行控制。&lt;/p&gt;
&lt;p&gt;每个 click 都延迟 0 至 5 秒之间的任意一个时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const clicks = fromEvent(document, 'click')
const delayedClicks = clicks.pipe(
  delayWhen(event =&amp;gt; interval(Math.random() * 5000)),
)
delayedClicks.subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常错误处理&quot;&gt;异常错误处理&lt;/h3&gt;
&lt;p&gt;异常处理的难点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;try/catch 只支持同步&lt;/li&gt;
&lt;li&gt;回调函数容易形成回调地狱，而且每个回调函数的最开始都要判断是否存在错误&lt;/li&gt;
&lt;li&gt;Promise 不能重试，而且不强制异常被捕获&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对错误处理的处理可以分为两类，即恢复(recover)和重试(retry)。&lt;/p&gt;
&lt;p&gt;恢复是虽然发生了错误但是让程序继续运行下去。重试，是认为这个错误是临时的，重试尝试发生错误的操作。实际中往往配合使用，因为一般重试是由次数限制的，当尝试超过这个限制时，我们应该使用恢复的方法让程序继续下去。&lt;/p&gt;
&lt;p&gt;1）catchError&lt;/p&gt;
&lt;p&gt;catchError 用来在管道中捕获上游传递过来的错误。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interval(1000).pipe(
  take(6),
  map(x =&amp;gt; {
    if (x === 4) {
      throw new Error('unlucky number 4')
    } else {
      return x
    }
  }),
  catchError(err =&amp;gt; of(8))
).subscribe(x =&amp;gt; console.log(x))
// 0
// 1
// 2
// 3
// 8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;catchError 中的回调函数返回了一个 Observable，当捕获到上游的错误时，调用这个函数，返回的 Observable 中发出的数据会传递给下游。因此上面当 x 为4 时发生了错误，会用 8 来替换。&lt;/p&gt;
&lt;p&gt;catchError 中的回调函数除了接收错误对象为参数外，还有第二个参数 caught$ 表示上游的 Observable 对象。如果回调函数返回这个 Observable 对象，就会进行重试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interval(1000).pipe(
  take(6),
  map(x =&amp;gt; {
    if (x === 4) {
      throw new Error('unlucky number 4')
    } else {
      return x
    }
  }),
  catchError((err, caught$) =&amp;gt; caught$),
  take(20)
).subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个代码会依次输出 5 次 0, 1, 2, 3。&lt;/p&gt;
&lt;p&gt;2）retry&lt;/p&gt;
&lt;p&gt;retry 可以接收一个整数作为参数，表示重试次数，如果是负数或者没有传参，会无限次重试。重试实际上就是退订再重新订阅。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interval(1000).pipe(
      take(6),
      map(x =&amp;gt; {
        if (x === 4) {
          throw new Error('unlucky number 4')
        } else {
          return x
        }
      }),
      retry(5) // 重试 5 次
    ).subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实际开发中，如果是代码原因造成的错误，重试没有意义，如果是因为外部资源导致的异常错误适合重试，如用户网络或者服务器偶尔不稳定的时候。&lt;/p&gt;
&lt;p&gt;3）retryWhen&lt;/p&gt;
&lt;p&gt;和前面带 when 的操作符一样，retryWhen 操作符接收一个返回 Observable 的回调函数，用这个 Observable 来控制重试的节奏。当这个 Observable 发出一个数据时就会进行一次重试，它完结时 retryWhen 返回的 Observable 也立即完结。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interval(1000).pipe(
  take(6),
  map(x =&amp;gt; {
    if (x === 4) {
      throw new Error('unlucky number 4')
    } else {
      return x
    }
  }),
  retryWhen(err$ =&amp;gt; err$.pipe(
    delay(1000),
    take(5))
  ) // 延迟 1 秒后重试，重试 5 次
).subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;retryWhen 的可定制性非常高，不仅可以实现延迟定制，还可以实现 retry 的控制重试次数。在实践中，这种重试频率固定的方法还不够好，如果之前的重试失败，之后重试成功的几率也不高。Angular 官网介绍了一个 &lt;a href=&quot;https://angular.io/guide/practical-observable-usage#exponential-backoff&quot;&gt;Exponential backoff&lt;/a&gt; 的方法。将每次重试的延迟时间控制为指数级增长。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { pipe, range, timer, zip } from 'rxjs';
import { ajax } from 'rxjs/ajax';
import { retryWhen, map, mergeMap } from 'rxjs/operators';
 
function backoff(maxTries, ms) {
 return pipe(
   retryWhen(attempts =&amp;gt; range(1, maxTries)
     .pipe(
       zip(attempts, (i) =&amp;gt; i),
       map(i =&amp;gt; i * i),
       mergeMap(i =&amp;gt;  timer(i * ms))
     )
   )
 );
}

ajax('/api/endpoint')
  .pipe(backoff(3, 250))
  .subscribe(data =&amp;gt; handleData(data));
 
function handleData(data) {
  // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4）finalize&lt;/p&gt;
&lt;p&gt;返回上游数据流的镜像 Observable，当上游的 Observable 完结或出错时调用传给它的函数，不影响数据流。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interval(1000).pipe(
  take(6),
  map(x =&amp;gt; {
    if (x === 4) {
      throw new Error('unlucky number 4')
    } else {
      return x
    }
  }),
  finalize(() =&amp;gt; console.log('finally'))
).subscribe(x =&amp;gt; console.log('a'))&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;tap-操作符&quot;&gt;tap 操作符&lt;/h3&gt;
&lt;p&gt;我们可以使用 tap 操作符来进行调试。&lt;/p&gt;
&lt;p&gt;拦截源 Observable 的每一次发送，执行一个函数，返回源 Observable 的镜像 Observable。&lt;/p&gt;
&lt;p&gt;这个 API 有助于我们对 Observable 的值进行验证（debug）和执行一个会带来副作用的函数，而不会影响源 Observable。如我们用鼠标进行 canvas 绘图，鼠标按下是开始画图，鼠标松开即停止。我们需要在 mousedown 的时候进行 moveTo，否则这次画的会和上次画的连在一起。我们应该把这个会带来副作用过程放在 tap 操作符的函数中，这样才不会影响原来的数据流。&lt;/p&gt;
&lt;p&gt;tap 操作符和订阅并不相同，tap 返回的 Observable 如果没有被订阅，tap 中产生副作用的函数并不会执行。&lt;/p&gt;
&lt;h3 id=&quot;其他一些操作符&quot;&gt;其他一些操作符&lt;/h3&gt;
&lt;p&gt;1) repeat&lt;/p&gt;
&lt;p&gt;repeat 用来重复上游 Observable&lt;/p&gt;
&lt;p&gt;2）pluck 类似 lodash 的方法 pluck，提取对象的嵌套属性的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const click$ = fromEvent(document, 'click')
const tagName$ = click$.pipe(pluck('target', 'tagName'))
tagName$.subscribe(x =&amp;gt; console.log(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;click$.pipe(map(e =&amp;gt; e.target.tagName))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）toArray&lt;/p&gt;
&lt;p&gt;将发出的数据汇聚为数组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interval(1000).pipe(
  take(3),
  toArray()
).subscribe(x =&amp;gt; console.log(x))
// [0, 1, 2]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4）partition&lt;/p&gt;
&lt;p&gt;将上游的 Observable 分为两个，一个 Observable 的数据是符合判定的数据，另一个时不符合判定的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const part$ = interval(1000).pipe(
  take(6),
  partition(x =&amp;gt; x % 2 === 0)
)

part$[0].subscribe(x =&amp;gt; console.log(x)) // 0, 2, 4
part$[1].subscribe(x =&amp;gt; console.log(x)) // 1, 3, 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5) 更多操作符&lt;/p&gt;
&lt;p&gt;RxJS 中的操作符非常多，这里只介绍了一部分，更多请查看&lt;a href=&quot;https://rxjs-dev.firebaseapp.com/api&quot;&gt;官网 API&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;rxjs-最经典的例子autocomplete&quot;&gt;RxJS 最经典的例子——AutoComplete&lt;/h3&gt;
&lt;p&gt;有一个用于搜索的 input，当输入时自动发送 ajax，并在下方显示结果列表，然后可以选择结果，这就是我们常见的 AutoComplete 效果。要实现这个效果有很多细节要考虑，如防止 race condition 和优化请求次数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;autocomplete&quot;&amp;gt;
    &amp;lt;input class=&quot;input&quot; type=&quot;search&quot; id=&quot;search&quot; autocomplete=&quot;off&quot;&amp;gt;
    &amp;lt;ul id=&quot;suggest-list&quot; class=&quot;suggest&quot;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先获取两个 DOM 元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const input = document.querySelector('#search');
const suggestList = document.querySelector('#suggest-list');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先将输入框的 input 的事件转化为 Observable。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const input$ = fromEvent(input, 'input');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们根据输入的值去发送 ajax 请求，由于我们是要获取最新的值而丢弃之前 ajax 返回的值，我们应该使用 switchMap 操作符。通过使用这个操作符，我们解决了 race condition 问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;input$.pipe(
  switchMap(e =&amp;gt; from(getSuggestList(e.target.value)))
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getSuggestList 是一个发送 ajax 请求的方法，返回 promise，我们使用 from 来将其转化为 Observable。&lt;/p&gt;
&lt;p&gt;为了优化请求，首先 e.target.value 是空字符串时不应该发送请求，然后可以使用 debounceTime 减少触发频率，也可以使用 distinctUntilChanged 操作符来表示只有与上次不同时才去发送请求。我们还可以在 API 失败时重试 3 次。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;input$.pipe(
  filter(e =&amp;gt; e.target.value.length &amp;gt; 1),
  debounceTime(300),
  distinctUntilChanged(),
    switchMap(
      e =&amp;gt; from(getSuggestList(e.target.value)).pipe(retry(3))
    )
  )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们去订阅渲染就可以了。&lt;/p&gt;
&lt;p&gt;对于结果列表上的点击事件，比较简单，具体见&lt;a href=&quot;https://stackblitz.com/edit/js-xq5bqd?file=index.js&quot;&gt;demo&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;操作符和数组方法&quot;&gt;操作符和数组方法&lt;/h3&gt;
&lt;p&gt;Observable 的操作符和数组的方法有相似之处，但是也有很大的不同，体现在以下两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;延迟运算&lt;/li&gt;
&lt;li&gt;渐进式取值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;延迟运算，我们之前有讲到过，就是只有订阅后才会开始对元素进行运算。&lt;/p&gt;
&lt;p&gt;因为 Observable 是时间上的集合，操作符不是像数组方法那样运算完所有元素再返回交给下一个方法，而是一个元素一直运算到底，就像管道中的水流一样，先发出的数据先经过操作符的运算。&lt;/p&gt;
&lt;h2 id=&quot;多播&quot;&gt;多播&lt;/h2&gt;
&lt;p&gt;前面的例子都是只有一个订阅者的情况，实际上当然可以有多个订阅者，这就是多播(multicast)，即一个数据流的内容被多个 Observable 订阅。&lt;/p&gt;
&lt;h3 id=&quot;hot-observable-和-cold-observable&quot;&gt;Hot Observable 和 Cold Observable&lt;/h3&gt;
&lt;p&gt;先思考一下下面的例子结果是什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const source$ = interval(1000).pipe(
  take(3)
)

source$.subscribe(x =&amp;gt; console.log('Observer 1: ' + x))

setTimeout(() =&amp;gt; {
  source$.subscribe(x =&amp;gt; console.log('Observer 2: ' + x))
}, 1000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能会以为 Observer 2 一秒后才订阅，错过了数据 0，因此只会输出 1 和 2，但实际上会先输出 0。为什么如此呢？这就涉及到对已错过数据的两种处理策略。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;错过的就让它过去，只要订阅之后生产的数据就好&lt;/li&gt;
&lt;li&gt;不能错过，订阅之前生产的数据也要&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一种策略类似于直播，第二种和点播相似。使用第一种策略的 Observable 叫做 Cold Observable，因为每次都要重新生产数据，是 “冷”的，需要重新发动。第二种，因为一直在生产数据，只要使用后面的数据就可以了，所以叫 Hot Observable。&lt;/p&gt;
&lt;p&gt;RxJS 中如 interval、range 这些方法产生的 Observable 都是 Cold Observable，产生 Hot Observable 的是由 Promise、Event 这些转化而来的 Observable，它们的数据源都在外部，和 Observer 无关。&lt;/p&gt;
&lt;p&gt;前面我们提到 Observable 都是 lazy evaluation 的，数据管道内的逻辑只有订阅后才会执行，但是 Cold Observable 相对更 lazy 一些。Cold Observable 如果没有订阅者连数据都不会产生，对于 Hot Observable，数据仍会产生，但是不会进入管道处理。&lt;/p&gt;
&lt;p&gt;Hot Observable 是多播，对于 Cold Observable，每次订阅都重新生产了一份数据流，所以不是多播。下面的例子更加明显，两个订阅者有很大的概率会接收到不同的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const source$ = interval(1000).pipe(
  map(x =&amp;gt; Math.floor(Math.random() * 10)),
  take(3)
)

source$.subscribe(x =&amp;gt; console.log('Observer 1: ' + x))

setTimeout(() =&amp;gt; {
  source$.subscribe(x =&amp;gt; console.log('Observer 2: ' + x))
}, 1000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要实现多播，就要使用 RxJS 中 Subject。&lt;/p&gt;
&lt;h3 id=&quot;subject&quot;&gt;Subject&lt;/h3&gt;
&lt;p&gt;为了防止每次订阅都重新生产一份数据流，我们可以使用中间人，让这个中间人去订阅源数据流，观察者都去订阅这个中间人。这个中间人能去订阅数据流，所以是个 Observer，又能被观察者订阅，所以也是 Observable。我们可以自己实现一个这样的中间人：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const subject = {
  observers: [],
  subscribe: function (observer) {
    this.observers.push(observer)
  },
  next: function (value) {
    this.observers.forEach(o =&amp;gt; o.next(value))
  },
  error: function (error) {
    this.observers.forEach(o =&amp;gt; o.error(error))
  },
  complete: function () {
    this.observers.forEach(o =&amp;gt; o.complete())
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 subject 拥有 Observer 的 next、error、complete 方法，每次被观察者订阅时都会在内部保存这个观察者。当接收到源数据流的数据时，会把数据发送给每一个观察者。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const source$ = interval(1000).pipe(
  map(x =&amp;gt; Math.floor(Math.random() * 10)),
  take(3)
)

const observerA = {
  next: x =&amp;gt; console.log('Observer A: ' + x),
  error: null,
  complete: () =&amp;gt; console.log('Observer A completed')
}
const observerB = {
  next: x =&amp;gt; console.log('Observer B: ' + x),
  error: null,
  complete: () =&amp;gt; console.log('Observer B completed')
}

source$.subscribe(subject)
subject.subscribe(observerA)
setTimeout(() =&amp;gt; {
  subject.subscribe(observerB)
}, 1000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时我们发现两个观察者接收到的是同一份数据，ObserverB 由于延迟一秒订阅，所以少接收到一个数据。将我们自己实现的 subject 换成 RxJS 中的 Subject，效果相同：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { Subject } from 'rxjs'
const subject = new Subject()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看到，Subject 和 Observable 有一个很大的不同：它内部保存有一个观察者列表。&lt;/p&gt;
&lt;p&gt;前面的 subject 是在源数据流发出值时调用 next 方法，向订阅的观察者发送这个值，我们也可以手动调用 subject 的next 方法送出值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const observerA = {
  next: x =&amp;gt; console.log('Observer A: ' + x)
}
const observerB = {
  next: x =&amp;gt; console.log('Observer B: ' + x)
}

const subject = new Subject()

subject.subscribe(observerA)
setTimeout(() =&amp;gt; {
  subject.subscribe(observerB)
}, 500)

subject.next(1)
setTimeout(() =&amp;gt; {
  subject.next(2)
}, 1000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下，Subject 既是 Observable 又是 Observer，它会对内部的 observers 清单进行组播(multicast)。&lt;/p&gt;
&lt;h3 id=&quot;subject-的错误处理&quot;&gt;Subject 的错误处理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在 RxJS 5 中，如果 Subject 的某个下游数据流产生了错误异常，而又没有被 Observer 处理，那这个 Subject 的其他 Observer 都会失败。但是在 RxJS 6 中不会如此。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 v6 的&lt;a href=&quot;https://stackblitz.com/edit/js-yy1wxg?file=index.js&quot;&gt;这个例子&lt;/a&gt; 中，ObserverA 没有对错误进行处理，但是并不影响 ObserverB，而在 v5 &lt;a href=&quot;https://stackblitz.com/edit/js-h1rduq&quot;&gt;这个demo&lt;/a&gt;中因为 ObserverA 没有对错误进行处理，使得 ObserverB 终止了。很明显 v6 的这种处理更符合直觉。&lt;/p&gt;
&lt;h3 id=&quot;behaviorsubjectreplaysubjectasyncsubject&quot;&gt;BehaviorSubject、ReplaySubject、AsyncSubject&lt;/h3&gt;
&lt;p&gt;1）BehaviorSubject&lt;/p&gt;
&lt;p&gt;BehaviorSubject 需要在实例化时给定一个初始值，如果没有默认是 undefined，每次订阅时都会发出最新的状态，即使已经错过数据的发送时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const observerA = {
  next: x =&amp;gt; console.log('Observer A: ' + x)
}
const observerB = {
  next: x =&amp;gt; console.log('Observer B: ' + x)
}

const subject = new BehaviorSubject(0)

subject.subscribe(observerA) // Observer A: 0

subject.next(1) // Observer A: 1
subject.next(2) // Observer A: 2
subject.next(3) // Observer A: 3

setTimeout(() =&amp;gt; {
  subject.subscribe(observerB) // Observer B: 3
}, 500)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;observerB 已经错过流数据的发送时间，但是订阅时也能获取到最新数据 3。&lt;/p&gt;
&lt;p&gt;BehaviorSubject 有点类似于状态，一开始可以提供初始状态，之后订阅都可以获取最新的状态。&lt;/p&gt;
&lt;p&gt;2）ReplaySubject&lt;/p&gt;
&lt;p&gt;ReplaySubject 表示重放，在新的观察者订阅时重新发送原来的数据，可以通过参数指定重放最后几个数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const observerA = {
  next: x =&amp;gt; console.log('Observer A: ' + x)
}
const observerB = {
  next: x =&amp;gt; console.log('Observer B: ' + x)
}

const subject = new ReplaySubject(2) // 重放最后两个

subject.subscribe(observerA)

subject.next(1) // Observer A: 1
subject.next(2) // Observer A: 2
subject.next(3) // Observer A: 3
subject.complete()

setTimeout(() =&amp;gt; {
  subject.subscribe(observerB)
  // Observer B: 2
  // Observer B: 3
}, 500)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们可以看到，即使 subject 完结后再去订阅依然可以重放最后两个数据。&lt;/p&gt;
&lt;p&gt;ReplaySubject(1) 和前面的 BehaviorSubject 是不一样的，首先后者可以提供默认数据，而前者不行，其次前者在 subject 终结后再去订阅依然可以得到最近发出的数据而后者不行。&lt;/p&gt;
&lt;p&gt;3）AsyncSubject&lt;/p&gt;
&lt;p&gt;AsyncSubject 有点类似 operator last，会在 subject 完结后送出最后一个值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const subject = new AsyncSubject()

subject.subscribe(observerA)

subject.next(1)
subject.next(2)
subject.next(3)
subject.complete()
// Observer A: 3
setTimeout(() =&amp;gt; {
  subject.subscribe(observerB)
  // Observer B: 3
}, 500)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;observerA 即使早就订阅了，但是并不会响应前面的 next，完结后才接收到最后一个值 3。&lt;/p&gt;
&lt;h3 id=&quot;多播操作符&quot;&gt;多播操作符&lt;/h3&gt;
&lt;p&gt;前面我们写的 Subject 需要去订阅源数据流和被观察者订阅，写起来比较繁琐，我们可以借助操作符来实现。&lt;/p&gt;
&lt;p&gt;1）multicast&lt;/p&gt;
&lt;p&gt;使用方式如下，接收一个 subject 或者 subject factory。这个操作符返回了一个 connectable 的 Observable。等到执行 connect() 才会用真的 subject 订阅 source，并开始发送数据，如果没有 connect，Observable 是不会执行的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const source = interval(1000).pipe(
  map(x =&amp;gt; Math.floor(Math.random() * 10)),
  take(3),
  multicast(new Subject)
)

const observerA = {
  next: x =&amp;gt; console.log('Observer A: ' + x),
  error: null,
  complete: () =&amp;gt; console.log('Observer A completed')
}
const observerB = {
  next: x =&amp;gt; console.log('Observer B: ' + x),
  error: null,
  complete: () =&amp;gt; console.log('Observer B completed')
}

source.subscribe(observerA) // subject.subscribe(observerA)

source.connect() // source.subscribe(subject)

setTimeout(() =&amp;gt; {
  source.subscribe(observerB) // subject.subscribe(observerB)
}, 1000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）refCount&lt;/p&gt;
&lt;p&gt;上面使用了 multicast，但是还是有些麻烦，还需要去手动 connect。这时我们可以再搭配 refCount 操作符创建只要有订阅就会自动 connect 的 Observable。只需要去掉 connect 方法调用，在 multicast 后面再加一个 refCount 操作符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;multicast(new Subject),
refCount()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;refCount 其实就是自动计数的意思，当 Observer 数量大于 1 时，subject 订阅上游数据流，减少为 0 时退订上游数据流。&lt;/p&gt;
&lt;p&gt;3）multicast selector 参数&lt;/p&gt;
&lt;p&gt;multicast 第一个参数除了是一个 subject，还可以是一个 subject factory，即返回 subject 的函数。这时使用了不同的中间人，每个观察者订阅时都重新生产数据，适用于退订了上游之后再次订阅的场景。&lt;/p&gt;
&lt;p&gt;multicast 还可以接收可选的第二个参数，称为 selector 参数。它可以使用上游数据流任意多次，而不会重复订阅上游的数据。当使用了这个参数时，multicast 不会返回 connectable Observable，而是这个参数（回调函数）返回的 Observable。selecetor 回调函数有一个参数，通常叫做 shared，即 multicast 第一个参数所代表的 subject 对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const selector = shared =&amp;gt; {
  return shared.pipe(concat(of('done')))
}
const source = interval(1000).pipe(
  take(3),
  multicast(new Subject, selector)
)

const observerA = {
  next: x =&amp;gt; console.log('Observer A: ' + x),
  error: null,
  complete: () =&amp;gt; console.log('Observer A completed')
}
const observerB = {
  next: x =&amp;gt; console.log('Observer B: ' + x),
  error: null,
  complete: () =&amp;gt; console.log('Observer B completed')
}

source.subscribe(observerA)
setTimeout(() =&amp;gt; {
  source.subscribe(observerB)
}, 5000)
// Observer A: 0
// Observer A: 1
// Observer A: 2
// Observer A: done
// Observer A completed
// Observer B: done
// Observer B: completed&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;observerB 订阅时会调用 selector 函数，subject 即shared 已经完结，但是 concat 依然会在这个 Observable 后面加上 'done'。&lt;/p&gt;
&lt;p&gt;可以利用 selector 处理 “三角关系”的数据流，如有一个 tick$ 数据流，对其进行 delay(500) 操作后的下游 delayTick$， 一个由它们合并得到的 mergeTick$，这时就形成了三角关系。delayTick$ 和 mergeTick$ 都订阅了 tick$。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const tick$ = interval(1000).pipe(
  take(1),
  tap(x =&amp;gt; console.log('source: ' + x))
)

const delayTick$ = tick$.pipe(
  delay(500)
)

const mergeTick$ = merge(tick$, delayTick$).subscribe(x =&amp;gt; console.log('observer: ' + x))
// source: 0
// observer: 0
// source: 0
// observer: 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的结果我们可以验证，tick$ 被订阅了两次。&lt;/p&gt;
&lt;p&gt;我们可以使用 selector 函数来使其只订阅一次，将上面的过程移到 selector 函数内即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const source$ = interval(1000).pipe(
  take(1),
  tap(x =&amp;gt; console.log('source: ' + x))
)

const result$ = source$.pipe(
  multicast(new Subject(), shared =&amp;gt; {
    const tick$ = shared
    const delayTick$ = tick$.pipe(delay(500))
    const mergeTick$ = merge(tick$, delayTick$)
    return mergeTick$
  })
)

result$.subscribe(x =&amp;gt; console.log('observer: ' + x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时只会输出一次 'source: 0'。&lt;/p&gt;
&lt;p&gt;4）publish&lt;/p&gt;
&lt;p&gt;publish 是 multicast 的一种简写方式，效果等同于如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function publish (selector) {
  if (selector) {
    return multicast(() =&amp;gt; new Subject(), selector)
  } else {
    return multicast(new Subject())
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有上一节说到的 selector 函数时，等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;multicast(() =&amp;gt; new Subject(), selector)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没有时，等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;multicast(new Subject())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5）share&lt;/p&gt;
&lt;p&gt;share 是 multicast 和 refCount 的简写，share() 等同于在 pipe 中先调用了 multicast(() =&amp;gt; new Subject())，再调用了 refCount()。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const source = interval(1000).pipe(
  take(3),
  share()
)

const observerA = {
  next: x =&amp;gt; console.log('Observer A: ' + x),
  error: null,
  complete: () =&amp;gt; console.log('Observer A completed')
}
const observerB = {
  next: x =&amp;gt; console.log('Observer B: ' + x),
  error: null,
  complete: () =&amp;gt; console.log('Observer B completed')
}

source.subscribe(observerA)
setTimeout(() =&amp;gt; {
  source.subscribe(observerB)
}, 5000)
// Observer A: 0
// Observer A: 1
// Observer A: 2
// Observer A completed
// Observer B: 0
// Observer B: 1
// Observer B: 2
// Observer B completed&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 share 是调用了 subject 工厂函数，而不是一个 subject 对象，因此 observerB 订阅时可以重新获取数据。&lt;/p&gt;
&lt;p&gt;6）publishLast、publishBehavior、publishReplay&lt;/p&gt;
&lt;p&gt;同前面的 publish，只不过使用的不是普通 Subject，而是对应的 AsyncSubject、BehaviorSubject、ReplaySubject。&lt;/p&gt;
&lt;h2 id=&quot;scheduler&quot;&gt;Scheduler&lt;/h2&gt;
&lt;p&gt;Scheduler(调度器)用于控制数据流中数据的推送节奏。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { range, asapScheduler } from 'rxjs'

const source$ = range(1, 3, asapScheduler)

console.log('before subscribe')
source$.subscribe(x =&amp;gt; console.log(x))
console.log('subscribed')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码，如果去掉 asapScheduler 参数，因为 range 是同步的，会先输出 1, 2, 3，再输出 'subscribed'，但是加了以后就变成 先输出 'subscribed'，改变了原来数据产生的方式。asap 是 as soon as possible 的缩写，同步任务完成后就会马上执行。&lt;/p&gt;
&lt;p&gt;Scheduler 拥有一个虚拟时钟，如 interval 创建的数据流每隔一段时间要发出数据，由 Scheduler 提供时间来判断是否到了发送数据的时间。&lt;/p&gt;
&lt;h3 id=&quot;scheduler-实例&quot;&gt;Scheduler 实例&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;undefined/null：不指定 Scheduler，代表同步执行的 Scheduler&lt;/li&gt;
&lt;li&gt;asap：尽快执行的 Scheduler&lt;/li&gt;
&lt;li&gt;async：利用 setInterval 实现的 Scheduler&lt;/li&gt;
&lt;li&gt;queue：利用队列实现的 Scheduler，用于迭代一个的大的集合的场景。&lt;/li&gt;
&lt;li&gt;animationFrame：用于动画的 Scheduler&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;asap 会尽量使用 micro task，而 async 会使用 macro task。&lt;/p&gt;
&lt;h3 id=&quot;相关操作符&quot;&gt;相关操作符&lt;/h3&gt;
&lt;p&gt;一些创建数据流的方法可以提供 Scheduler 参数，合并类操作符如 merge 也可以，在创建数据流后我们也可以使用操作符，使得产生的下游 Observable 推送数据的节奏由指定的 Scheduler 来控制。这个操作符就是 observeOn。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const tick$ = interval(10) // Intervals are scheduled with async scheduler by default...
tick$.pipe(
  observeOn(animationFrameScheduler)  // but we will observe on animationFrame scheduler to ensure smooth animation.
)
.subscribe(val =&amp;gt; {
  someDiv.style.height = val + 'px'
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本来每 10 ms 就会发送一个数据，修改 Scheduler 为 animationFrame 后只有浏览器重绘才会发送数据更新样式。&lt;/p&gt;
&lt;p&gt;我们还可以通过操作符 subscribeOn 控制订阅的时机。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const source$ = new Observable(observer =&amp;gt; {
  console.log('on subscribe')
  observer.next(1)
  observer.next(2)
  observer.next(3)
  return () =&amp;gt; {
    console.log('on unsubscribe')
  }
})

const tweaked$ = source$.pipe(subscribeOn(asapScheduler))

console.log('before subscribe')
tweaked$.subscribe(x =&amp;gt; console.log(x))
console.log('subscribed')
// before subscribe
// subscribed
// on subscribe
// 1
// 2
// 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 subscribeOn(asapScheduler)，我们把订阅时间推迟到尽快执行。&lt;/p&gt;
&lt;h3 id=&quot;testscheduler&quot;&gt;TestScheduler&lt;/h3&gt;
&lt;p&gt;RxJS 中有一个 用于测试的 TestScheduler，RxJS 的测试大家可以查看程墨的《深入浅出 RxJS》或者其他资料。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { TestScheduler } from 'rxjs/testing'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;rxjs-的一些实践&quot;&gt;RxJS 的一些实践&lt;/h2&gt;
&lt;h3 id=&quot;rxjs-与前端框架结合&quot;&gt;RxJS 与前端框架结合&lt;/h3&gt;
&lt;p&gt;Angular 自身引用了 RxJS，如 http 和 animation 都使用了 Observable，状态管理可以使用 &lt;a href=&quot;https://github.com/ngrx/platform&quot;&gt;ngrx&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Vue 官方有与 RxJS 集成的 &lt;a href=&quot;https://github.com/vuejs/vue-rx&quot;&gt;vue-rx&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;React 可以通过 Subject 建立桥梁，Redux 也有与 RxJS 结合的中间件 Redux-Observable。&lt;/p&gt;
&lt;h3 id=&quot;轮询中的错误处理&quot;&gt;轮询中的错误处理&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;interval(10000).pipe(
  switchMap(() =&amp;gt; from(axios.get(url))),
  catchError(err =&amp;gt; EMPTY)
).subscribe(data =&amp;gt; render(data))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码，每隔 10s 去发送一个请求，当某个请求返回出错时，返回空的 Observable 而不渲染数据。这样处理貌似正确，但是实际上某个请求出错时，整个 Observable 终结了，因此轮询就结束了。为了保持轮询，我们需要进行隔离，把错误处理移到 switchMap 内部进行处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interval(10000).pipe(
  switchMap(() =&amp;gt; from(axios.get(url)).pipe(
    catchError(err =&amp;gt; EMPTY)
  ))
).subscribe(data =&amp;gt; render(data))&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;订阅管理&quot;&gt;订阅管理&lt;/h3&gt;
&lt;p&gt;如果没有及时退订可能会引发内存泄露，我们需要通过退订去释放资源。&lt;/p&gt;
&lt;p&gt;1）命令式管理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const subscription = source$.subscribe(observer)
// later...
subscription.unsubscribe()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的管理方式，数量很少时还好，如果数量较多，将会显得十分笨拙。&lt;/p&gt;
&lt;p&gt;2) 声明式管理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const kill1 = fromEvent(button, 'click')
const kill2 = getStreamOfRouteChanges()
const kill3 = new Subject()

const merged$ = mege(
    source1.pipe(takeUntil(kill1)),
    source2.pipe(takeUntil(kill2)),
    source3.pipe(takeUntil(kill3))
)

const sub = merged$.subscribe(observer)
// later...
sub.unsubscribe()

// 或者发出任意结束的事件
kill3.next(true)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 takeUntil、map 或者其他操作符组合进行管理。这样更不容易漏掉某个退订，订阅也减少了。&lt;/p&gt;
&lt;p&gt;3）让框架或者某些类库去处理&lt;/p&gt;
&lt;p&gt;比如 Angular 中的 async pipe，当 unmount 时会自动退订，也不用写订阅。&lt;/p&gt;
&lt;h3 id=&quot;不要-rx-一切&quot;&gt;不要 Rx 一切&lt;/h3&gt;
&lt;p&gt;不要过度使用 Rx，它比较适合以下场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;组合事件时&lt;/li&gt;
&lt;li&gt;增加延迟和控制频率&lt;/li&gt;
&lt;li&gt;组合异步任务&lt;/li&gt;
&lt;li&gt;需要取消时&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单的应用并不需要 RxJS。&lt;/p&gt;
&lt;h3 id=&quot;rxjs-的业务实践&quot;&gt;RxJS 的业务实践&lt;/h3&gt;
&lt;p&gt;可以看看徐飞的相关思考：&lt;a href=&quot;https://github.com/xufei/blog/issues/38&quot;&gt;流动的数据——使用 RxJS 构造复杂单页应用的数据逻辑&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;rxjs-与-async-iterator&quot;&gt;RxJS 与 Async Iterator&lt;/h2&gt;
&lt;p&gt;Async Iterator 提案已经进入了 ES2018，可以认为是 iterator 的异步版本。在 Symbol 上部署了 asyncIterator 的接口，不过它的 next 方法返回的是 { value, done } 对象的 Promise 版本。可以使用 for-await-of 进行迭代：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for await (const line of readLines(filePath)) {
  console.log(line)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 Async Iterator 我们可以很容易实现类似 RxJS 操作符的功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const map = async function*(fn) {
  for await(const value of this) yield fn(value)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他如 fromEvent 等也比较容易实现。Async Iterator 扩展库 &lt;a href=&quot;https://github.com/jamiemccrindle/axax&quot;&gt;axax&lt;/a&gt; 的一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { fromEvent } from &quot;axax/es5/fromEvent&quot;;

const clicks = fromEvent(document, 'click');

for await (const click of clicks) {
    console.log('a button was clicked');
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是 Benjamin Gruenbaum 用 Async Iterator 实现 AutoComplete 的一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let tooSoon = false, last;
for await (const {target: {value}} of fromEvent(el, &quot;keyup&quot;)) {
  if(!value || tooSoon) continue;
  if(value === last) continue;
  last = value;
  yield await fetch(&quot;/autocomplete/&quot; + value); // misses `last` 
  tooSoon = true;
  delay(500).then(() =&amp;gt; tooSoon = false);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Async Iterator 相比 RxJS，没有那么多概念，上手快，也比较容易扩展实现那些操作符。&lt;/p&gt;
&lt;p&gt;从数据消费者的角度上看，RxJS 是 push stream，由生产者把数据推送过来，Async Iterator 是 pull stream，是自己去拉取数据。&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;p&gt;博客：&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10186104&quot;&gt;30 天精通 RxJS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;书：&lt;a href=&quot;https://book.douban.com/subject/30217949/&quot;&gt;深入浅出RxJS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;视频：&lt;a href=&quot;https://www.youtube.com/watch?v=3LKMwkuK0ZE&amp;amp;t=14s&quot;&gt;RxJS 5 Thinking Reactively | Ben Lesh&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Aug 2018 14:08:00 +0000</pubDate>
<dc:creator>万里秋山</dc:creator>
<og:description>为什么要使用 RxJS RxJS 是一套处理异步编程的 API，那么我将从异步讲起。 前端编程中的异步有：事件（event）、AJAX、动画（animation）、定时器（timer）。 异步常见的问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ang-/p/9514430.html</dc:identifier>
</item>
<item>
<title>毕业入职两个月离职-职场小白的碎碎念(2) - 墨墨墨墨小宇</title>
<link>http://www.cnblogs.com/danvic712/p/9510944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danvic712/p/9510944.html</guid>
<description>&lt;p&gt;　　看了看今天的日期，好像正好毕业离开学校有两个月了，毕业后很快就入职了现在的公司，也差不多快上了两个月的班了，我最终还是选择离职了。&lt;/p&gt;
&lt;p&gt;　　原本想要写博客记录自己的学习过程的，结果技术相关的没写几篇，全变成吐槽、牢骚了，呵。等离职办完了，把之前落下的学习内容全部补上来吧。为什么想离职的原因，可能还是因为自己目前从事的工作与自己设想的方向不同吧（&lt;a href=&quot;https://www.cnblogs.com/danvic712/p/9458689.html&quot; target=&quot;_blcak&quot;&gt;毕业入职两个月-职场小白的碎碎念&lt;/a&gt;），我也清楚能找到百分百满意的工作是不可能的，只是希望自己从事的工作内容不会让自己有抵触吧。如果有在合肥的博友所在的公司是做.NET B/S开发并且准备招人的话，希望可以一丢丢的考虑下我，逃~~~&lt;/p&gt;
&lt;p&gt;　　入职两个月，试用期还没结束，按理说并不应该这么快就提出离职的，可是自己考虑来考虑去，最终还是在昨天和老大和HR说了自己想要离职的想法，今天部门的领导又和自己谈了很长时间，聊了很多，又想了想，还是准备正式提出离职。PS，能够在一家公司稳定的干下去一两年之后，后面觉得不满意再选择跳槽，相对来说还是比很快就跳槽的好，希望各位刚入职场的童鞋别学我，逃~~~&lt;/p&gt;
&lt;p&gt;　　我从大三开始实习做.NET的B/S开发，到今年6月毕业，我对自己今后的规划还是希望可以从事做.NET的B/S开发。对于我来说，对于现在工作最大的抵触很大一部分就是我们部门需要做delphi开发，c#只是从事接口的开发，甚至可能我都不会接触到这一块。领导说，delphi在我们部门的开发中会占据50~60%，可是在我观察部门的工作后觉得，这个比例可能还要提高，当然，也有可能我还是小菜鸟，没办法接触到部门深层次的工作。部门的主要使用delphi，有熟悉的会知道这主要是做C/S端应用的，当然，现在使用的人数也是极少的了，同时，通过慢慢了解现有的业务，发现对于业务的实现，全部是放在存储过程中实现，em，怎么说呢，我还是觉得没有用代码实现来的便利。&lt;/p&gt;
&lt;p&gt;　　用delphi做C/S端应用，很少甚至是不接触.NET开发，其实就是我很抵触的原因吧。在与领导的聊天中，他谈到部门后期也是采用C#做web service开发的，前期培训业务、delphi是因为这是我们部门工作的基础(嗯，其实就是自己看)，可能对我来说，这个后期会后多长时间，我不敢冒险，两年，三年，甚至是五年？如果我很长时间内没办法接触到.NET的B/S开发，仅靠自己下班时间后的自学，当我最终还是选择离开的时候，我到底还是不是一个.NET的B/S开发人员？我还能不能符合.NET B/S开发岗位的工作要求？&lt;/p&gt;
&lt;p&gt;　　平台，对于一个刚毕业的学生来说，会有多重要？对于我这样的学历不好的，会不会更加凸显重要性？这个我不清楚，可是周围人都是和我说，一个好的平台会更重要，可是，如果这个平台并不是你想要的呢？&lt;/p&gt;
&lt;p&gt;　　不管是用C#、还是用Java，采用面向对象的思想还是面向过程的思想，其实最后还是面向工资编程，我们大多数都是普通人，都要靠自己工资生活的啊，既然我已经做出了选择，还是希望自己能够坚持下去，嗯，加油~~~&lt;/p&gt;
</description>
<pubDate>Tue, 21 Aug 2018 13:36:00 +0000</pubDate>
<dc:creator>墨墨墨墨小宇</dc:creator>
<og:description>看了看今天的日期，好像正好毕业离开学校有两个月了，毕业后很快就入职了现在的公司，也差不多快上了两个月的班了，我最终还是选择离职了。 原本想要写博客记录自己的学习过程的，结果技术相关的没写几篇，全变成吐</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danvic712/p/9510944.html</dc:identifier>
</item>
</channel>
</rss>