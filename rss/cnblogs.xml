<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>B树和B+树的插入、删除图文详解 - nullzx</title>
<link>http://www.cnblogs.com/nullzx/p/8729425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nullzx/p/8729425.html</guid>
<description>&lt;p&gt;&lt;span&gt;简介：本文主要介绍了B树和B+树的插入、删除操作。写这篇博客的目的是发现没有相关博客以举例的方式详细介绍B+树的相关操作，由于自身对某些细节也感到很迷惑，通过查阅相关资料，对B+树的操作有所顿悟，写下这篇博客以做记录。由于是自身对B+树的理解，肯定有考虑不周的情况，或者理解错误的地方，请留言指出。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;欢迎探讨，如有错误敬请指正&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如需转载，请注明出处&lt;/span&gt; &lt;a href=&quot;http://www.cnblogs.com/nullzx/&quot;&gt;&lt;span&gt;http://www.cnblogs.com/nullzx/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. B树&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1. B树的定义&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B树也称B-树,它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一颗m阶的B树定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）每个结点最多有m-1个关键字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）根结点最少可以只有1个关键字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）非根结点至少有Math.ceil(m/2)-1个关键字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232632321-1557309284.png&quot;&gt;&lt;img title=&quot;clip_image002&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232634472-395289491.png&quot; alt=&quot;clip_image002&quot; width=&quot;691&quot; height=&quot;291&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图是一颗阶数为4的B树。在实际应用中的B树的阶数m都非常大（通常大于100），所以即使存储大量的数据，B树的高度仍然比较小。每个结点中存储了关键字（key）和关键字对应的数据（data），以及孩子结点的指针。&lt;strong&gt;我们将一个key和其对应的data称为一个记录&lt;/strong&gt;。&lt;strong&gt;但为了方便描述，除非特别说明，后续文中就用key来代替（key, value）键值对这个整体&lt;/strong&gt;。在数据库中我们将B树（和B+树）作为索引结构，可以加快查询速速，此时B树中的key就表示键，而data表示了这个键对应的条目在硬盘上的逻辑地址。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;1.2 B树的插入操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插入操作是指插入一条记录，即（key, value）的键值对。如果B树中已存在需要插入的键值对，则用需要插入的value替换旧的value。若B树不存在这个key,则一定是在叶子结点中进行插入操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）根据要插入的key的值，找到叶子结点并插入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面以5阶B树为例，介绍B树的插入操作，在5阶B树中，结点最多有4个key,最少有2个key&lt;/span&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;a）在空树中插入39&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232636141-111908062.png&quot;&gt;&lt;img title=&quot;clip_image002[4]&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232637766-945625689.png&quot; alt=&quot;clip_image002[4]&quot; width=&quot;144&quot; height=&quot;44&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时根结点就一个key，此时根结点也是叶子结点&lt;/span&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;b）继续插入22，97和41&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232639538-1500322324.png&quot;&gt;&lt;img title=&quot;clip_image004&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232641280-907189483.png&quot; alt=&quot;clip_image004&quot; width=&quot;144&quot; height=&quot;44&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根结点此时有4个key&lt;/span&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;c）继续插入53&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232643024-803862278.png&quot;&gt;&lt;img title=&quot;clip_image006&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232644645-1214967776.png&quot; alt=&quot;clip_image006&quot; width=&quot;172&quot; height=&quot;44&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插入后超过了最大允许的关键字个数4，所以以key值为41为中心进行分裂，结果如下图所示，分裂后当前结点指针指向父结点，满足B树条件，插入操作结束。当阶数m为偶数时，需要分裂时就不存在排序恰好在中间的key，那么我们选择中间位置的前一个key或中间位置的后一个key为中心进行分裂即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232646553-550588616.png&quot;&gt;&lt;img title=&quot;clip_image008&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232701452-1205325216.png&quot; alt=&quot;clip_image008&quot; width=&quot;291&quot; height=&quot;102&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;d）依次插入13，21，40，同样会造成分裂，结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232714654-717185244.png&quot;&gt;&lt;img title=&quot;clip_image010&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232716269-1873273300.png&quot; alt=&quot;clip_image010&quot; width=&quot;382&quot; height=&quot;94&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;e）依次插入30，27, 33 ；36，35，34 ；24，29，结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232718059-1454315021.png&quot;&gt;&lt;img title=&quot;clip_image012&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232719931-1845157889.png&quot; alt=&quot;clip_image012&quot; width=&quot;715&quot; height=&quot;137&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;f）插入key值为26的记录，插入后的结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232722072-2101780219.png&quot;&gt;&lt;img title=&quot;clip_image014&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232724001-1518264552.png&quot; alt=&quot;clip_image014&quot; width=&quot;722&quot; height=&quot;139&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前结点需要以27为中心分裂，并向父结点进位27，然后当前结点指向父结点，结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232727483-1657363165.png&quot;&gt;&lt;img title=&quot;clip_image016&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232732844-330586131.png&quot; alt=&quot;clip_image016&quot; width=&quot;871&quot; height=&quot;144&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进位后导致当前结点（即根结点）也需要分裂，分裂的结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232735788-403419538.png&quot;&gt;&lt;img title=&quot;clip_image018&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232737701-1115673096.png&quot; alt=&quot;clip_image018&quot; width=&quot;871&quot; height=&quot;206&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分裂后当前结点指向新的根，此时无需调整。&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;g）最后再依次插入key为17,28,29,31,32的记录，结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232742794-343445338.png&quot;&gt;&lt;img title=&quot;clip_image020&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232748270-1888091858.png&quot; alt=&quot;clip_image020&quot; width=&quot;893&quot; height=&quot;177&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;在实现B树的代码中，为了使代码编写更加容易，我们可以将结点中存储记录的数组长度定义为m而非m-1，这样方便底层的结点由于分裂向上层插入一个记录时，上层有多余的位置存储这个记录。同时，每个结点还可以存储它的父结点的引用，这样就不必编写递归程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般来说，对于确定的m和确定类型的记录，结点大小是固定的，无论它实际存储了多少个记录。但是分配固定结点大小的方法会存在浪费的情况，比如key为28,29所在的结点，还有2个key的位置没有使用，但是已经不可能继续在插入任何值了，因为这个结点的前序key是27,后继key是30,所有整数值都用完了。所以如果记录先按key的大小排好序，再插入到B树中，结点的使用率就会很低，最差情况下使用率仅为50%。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.3 B树的删除操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除操作是指，根据key删除记录，如果B树中的记录中不存对应key的记录，则删除失败。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面以5阶B树为例，介绍B树的删除操作，5阶B树中，结点最多有4个key,最少有2个key&lt;/span&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;a）原始状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232752206-912030342.png&quot;&gt;&lt;img title=&quot;clip_image021&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232754144-973589199.png&quot; alt=&quot;clip_image021&quot; width=&quot;893&quot; height=&quot;177&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;b）在上面的B树中删除21，删除后结点中的关键字个数仍然大于等2，所以删除结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232757867-616298444.png&quot;&gt;&lt;img title=&quot;clip_image023&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232800149-881832132.png&quot; alt=&quot;clip_image023&quot; width=&quot;871&quot; height=&quot;174&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;c）在上述情况下接着删除27。从上图可知27位于非叶子结点中，所以用27的后继替换它。从图中可以看出，27的后继为28，我们用28替换27，然后在28（原27）的右孩子结点中删除28。删除后的结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232802141-205923916.png&quot;&gt;&lt;img title=&quot;clip_image025&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232805316-736624542.png&quot; alt=&quot;clip_image025&quot; width=&quot;871&quot; height=&quot;229&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除后发现，当前叶子结点的记录的个数小于2，而它的兄弟结点中有3个记录（当前结点还有一个右兄弟，选择右兄弟就会出现合并结点的情况，不论选哪一个都行，只是最后B树的形态会不一样而已），我们可以从兄弟结点中借取一个key。所以父结点中的28下移，兄弟结点中的26上移,删除结束。结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232807512-453871893.png&quot;&gt;&lt;img title=&quot;clip_image027&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232813762-797146286.png&quot; alt=&quot;clip_image027&quot; width=&quot;871&quot; height=&quot;175&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;d）在上述情况下接着32，结果如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232815746-1461337715.png&quot;&gt;&lt;img title=&quot;clip_image029&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232817843-722364883.png&quot; alt=&quot;clip_image029&quot; width=&quot;871&quot; height=&quot;226&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当删除后，当前结点中只key，而兄弟结点中也仅有2个key。所以只能让父结点中的30下移和这个两个孩子结点中的key合并，成为一个新的结点，当前结点的指针指向父结点。结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232825385-1019850877.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image031&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232829066-149754287.png&quot; alt=&quot;clip_image031&quot; width=&quot;871&quot; height=&quot;175&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前结点key的个数满足条件，故删除结束。&lt;/span&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;e）上述情况下，我们接着删除key为40的记录，删除后结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232835261-354192121.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image033&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232837287-2101391374.png&quot; alt=&quot;clip_image033&quot; width=&quot;871&quot; height=&quot;226&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理，当前结点的记录数小于2，兄弟结点中没有多余key，所以父结点中的key下移，和兄弟（这里我们选择左兄弟，选择右兄弟也可以）结点合并，合并后的指向当前结点的指针就指向了父结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232842439-531453423.png&quot;&gt;&lt;img title=&quot;clip_image035&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232846836-538278275.png&quot; alt=&quot;clip_image035&quot; width=&quot;800&quot; height=&quot;161&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理，对于当前结点而言只能继续合并了，最后结果如下所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232848657-2062660750.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image037&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232851299-447892778.png&quot; alt=&quot;clip_image037&quot; width=&quot;684&quot; height=&quot;110&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;合并后结点当前结点满足条件，删除结束。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;&lt;span&gt;2.B+树&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.1 B+树的定义&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232853119-1460626460.png&quot;&gt;&lt;img title=&quot;clip_image039&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232854940-1019144331.png&quot; alt=&quot;clip_image039&quot; width=&quot;530&quot; height=&quot;252&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各种资料上B+树的定义各有不同，一种定义方式是关键字个数和孩子结点个数相同。这里我们采取维基百科上所定义的方式，即关键字个数比孩子结点个数小1，这种方式是和B树基本等价的。上图就是一颗阶数为4的B+树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除此之外B+树还有以下的要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3） m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都&lt;strong&gt;小于&lt;/strong&gt;它，右子树中的key都&lt;strong&gt;大于等于&lt;/strong&gt;它。叶子结点中的记录也按照key的大小排列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.2 B+树的插入操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是一颗5阶B树的插入过程，5阶B数的结点最少2个key，最多4个key。&lt;/span&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;a）空树中插入5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232856515-1989097703.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image041&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232858129-694616618.png&quot; alt=&quot;clip_image041&quot; width=&quot;155&quot; height=&quot;56&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;b）依次插入8，10，15&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232859746-1983069652.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image043&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232901391-1401289774.png&quot; alt=&quot;clip_image043&quot; width=&quot;150&quot; height=&quot;55&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;c）插入16&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232903956-296813367.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image045&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232905559-1698012761.png&quot; alt=&quot;clip_image045&quot; width=&quot;184&quot; height=&quot;55&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，右边3个记录，中间key成为索引结点中的key，分裂后当前结点指向了父结点（根结点）。结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232907805-1210471622.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image047&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232909712-1807724284.png&quot; alt=&quot;clip_image047&quot; width=&quot;404&quot; height=&quot;185&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然我们还有另一种分裂方式，给左结点3个记录，右结点2个记录，此时索引结点中的key就变为15。&lt;/span&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;d）插入17&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232911666-589419211.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image049&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232913379-576202883.png&quot; alt=&quot;clip_image049&quot; width=&quot;327&quot; height=&quot;125&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;e）插入18，插入后如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232915173-859633380.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image051&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232917817-1240573630.png&quot; alt=&quot;clip_image051&quot; width=&quot;404&quot; height=&quot;199&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232919602-1261506387.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image053&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232921679-618565224.png&quot; alt=&quot;clip_image053&quot; width=&quot;520&quot; height=&quot;140&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前结点的关键字个数满足条件，插入结束。&lt;/span&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;f）插入若干数据后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232924458-602071692.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image055&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232926305-812650003.png&quot; alt=&quot;clip_image055&quot; width=&quot;761&quot; height=&quot;129&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;g）在上图中插入7，结果如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232932420-897395371.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image057&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232935105-1001982143.png&quot; alt=&quot;clip_image057&quot; width=&quot;762&quot; height=&quot;127&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前结点的关键字个数超过4，需要分裂。左结点2个记录，右结点3个记录。分裂后关键字7进入到父结点中，将当前结点的指针指向父结点，结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232938704-1997149607.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image059&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232940557-1204742223.png&quot; alt=&quot;clip_image059&quot; width=&quot;870&quot; height=&quot;123&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232943232-17049271.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image061&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232945267-543224744.png&quot; alt=&quot;clip_image061&quot; width=&quot;870&quot; height=&quot;164&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前结点的关键字个数满足条件，插入结束。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;2.3 B+树的删除操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。&lt;/span&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;a）初始状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232947400-1567033079.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image063&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232951603-2095664521.png&quot; alt=&quot;clip_image063&quot; width=&quot;870&quot; height=&quot;164&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;b）删除22,删除后结果如下图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232954830-219884109.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image065&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232956857-909502342.png&quot; alt=&quot;clip_image065&quot; width=&quot;870&quot; height=&quot;164&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除后叶子结点中key的个数大于等于2，删除结束&lt;/span&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;c）删除15，删除后的结果如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232959965-1316994866.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image067&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233002074-155906598.png&quot; alt=&quot;clip_image067&quot; width=&quot;870&quot; height=&quot;218&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除后当前结点只有一个key,不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233005979-1876471897.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image069&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233008129-433585803.png&quot; alt=&quot;clip_image069&quot; width=&quot;872&quot; height=&quot;165&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;d）删除7，删除后的结果如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233010241-2135973119.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image071&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233017339-92051658.png&quot; alt=&quot;clip_image071&quot; width=&quot;1024&quot; height=&quot;254&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233019407-1044051627.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image073&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233022828-172757536.png&quot; alt=&quot;clip_image073&quot; width=&quot;870&quot; height=&quot;171&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233024613-583960048.png&quot;&gt;&lt;img title=&quot;clip_image075&quot; src=&quot;https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233027773-1578264573.png&quot; alt=&quot;clip_image075&quot; width=&quot;871&quot; height=&quot;140&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;3.参考内容&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://www.cnblogs.com/wade-luffy/p/6292784.html&quot;&gt;B+树介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;http://hedengcheng.com/?p=525&quot;&gt;从MySQL Bug#67718浅谈B+树索引的分裂优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;https://www.jianshu.com/p/6f68d3c118d6&quot;&gt;B+树的几点总结&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 15:30:00 +0000</pubDate>
<dc:creator>nullzx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nullzx/p/8729425.html</dc:identifier>
</item>
<item>
<title>详解k8s一个完整的监控方案(Heapster+Grafana+InfluxDB) - kubernetes - 据说甜蜜呢</title>
<link>http://www.cnblogs.com/justmine/p/8723467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justmine/p/8723467.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;heapster以k8s内置的cAdvisor作为数据源收集集群信息，并汇总出有价值的性能数据(Metrics)：cpu、内存、网络流量等，然后将这些数据输出到外部存储，如InfluxDB，最后就可以通过相应的UI界面显示出来，如grafana。&lt;/strong&gt; 另外heapster的数据源和外部存储都是可插拔的，所以可以很灵活的组建出很多监控方案，如：Heapster+ElasticSearch+Kibana等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用官方提供的yml文件有一些小问题，请参考以下改动和说明：&lt;/p&gt;
&lt;h2 id=&quot;创建influxdb资源对象&quot;&gt;2.1、创建InfluxDB资源对象&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;apiVersion&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; apps/v1
kind&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; Deployment
metadata&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;influxdb
  namespace&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; kube&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;system
spec&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  replicas&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
  selector&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
    matchLabels&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      task&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring
      k8s&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;app&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; influxdb
  template&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
    metadata&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      labels&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
        task&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring
        k8s&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;app&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; influxdb
    spec&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      containers&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; influxdb
        image&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;k8s&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;gcr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;io&lt;/span&gt;/&lt;span class=&quot;at&quot;&gt;heapster&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;influxdb&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;amd64&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;v1&lt;/span&gt;.&lt;span class=&quot;fl&quot;&gt;3.3&lt;/span&gt;
        volumeMounts&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; mountPath&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/data&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;          name: influxdb-storage&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;      volumes:&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;      - name: influxdb-storage&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;        emptyDir: {}&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;apiVersion: v1&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;kind: Service&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;metadata:&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  labels:&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    task: monitoring&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    kubernetes.io/cluster&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;service&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'true'&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;kubernetes&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;io&lt;/span&gt;/name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;influxdb
  name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;influxdb
  namespace&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; kube&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;system
spec&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  type&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; NodePort
  ports&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; nodePort&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;31001&lt;/span&gt;
    port&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8086&lt;/span&gt;
    targetPort&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8086&lt;/span&gt;
  selector&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
    k8s&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;app&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; influxdb&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：这里我们使用NotePort暴露monitoring-influxdb服务在主机的31001端口上，那么InfluxDB服务端的地址：&lt;a class=&quot;uri&quot;&gt;http://[host-ip]:31001&lt;/a&gt; ，记下这个地址，以便创建heapster和为grafana配置数据源时，可以直接使用。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建grafana资源对象&quot;&gt;2.1、创建Grafana资源对象&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;apiVersion&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; apps/v1
kind&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; Deployment
metadata&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;grafana
  namespace&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; kube&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;system
spec&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  replicas&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
  selector&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
    matchLabels&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      task&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring
      k8s&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;app&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; grafana
  template&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
    metadata&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      labels&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
        task&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring
        k8s&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;app&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; grafana
    spec&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      containers&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; grafana
        image&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;k8s&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;gcr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;io&lt;/span&gt;/&lt;span class=&quot;at&quot;&gt;heapster&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;grafana&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;amd64&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;v4&lt;/span&gt;.&lt;span class=&quot;fl&quot;&gt;4.3&lt;/span&gt;
        ports&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; containerPort&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3000&lt;/span&gt;
          protocol&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; TCP
        volumeMounts&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; mountPath&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/etc/ssl/certs&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;          name: ca-certificates&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;          readOnly: true&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;        - mountPath: /var&lt;/span&gt;
          name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; grafana&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;storage
        env&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; INFLUXDB_HOST
          value&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;influxdb
        &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; GF_SERVER_HTTP_PORT
          value&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;3000&quot;&lt;/span&gt;
          # The following env variables are required to make Grafana accessible via
          # the kubernetes api&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;server &lt;span class=&quot;va&quot;&gt;proxy&lt;/span&gt;. &lt;span class=&quot;at&quot;&gt;On&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;production&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;clusters&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; we recommend
          # removing these env variables&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; setup auth &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; grafana&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; and expose the grafana
          # service using a LoadBalancer or a &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;IP&lt;/span&gt;.
        &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; GF_AUTH_BASIC_ENABLED
          value&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; GF_AUTH_ANONYMOUS_ENABLED
          value&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; GF_AUTH_ANONYMOUS_ORG_ROLE
          value&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; Admin
        &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; GF_SERVER_ROOT_URL
          # If you&lt;span class=&quot;st&quot;&gt;'re only using the API Server proxy, set this value instead:&lt;/span&gt;
          # value&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/api/v1/namespaces/kube&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;system/services/monitoring&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;grafana/proxy
          value&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&lt;/span&gt;
      volumes&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; ca&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;certificates
        hostPath&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
          path&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/etc/ssl/certs&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;      - name: grafana-storage&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;        emptyDir: {}&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;apiVersion: v1&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;kind: Service&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;metadata:&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  labels:&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    # For use as a Cluster add-on &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;https://github.com/kubernetes/kubernetes/tree/master/cluster/addons&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    # If you are NOT using this as an addon, you should comment out this line.&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    kubernetes.io/cluster&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;service&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'true'&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;kubernetes&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;io&lt;/span&gt;/name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;grafana
  name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;grafana
  namespace&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; kube&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;system
spec&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  # In a production setup&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; we recommend accessing Grafana through an external Loadbalancer
  # or through a &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;IP&lt;/span&gt;.
  # type&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; LoadBalancer
  # You could also use NodePort to expose the service at a randomly&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;generated port
  type&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; NodePort
  ports&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; nodePort&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;30108&lt;/span&gt;
    port&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt;
    targetPort&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3000&lt;/span&gt;
  selector&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
    k8s&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;app&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; grafana&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：这里我们使用NotePort暴露monitoring-grafana服务在主机的30108上，那么Grafana服务端的地址：&lt;a href=&quot;http://registry.wuling.com:30108/&quot; class=&quot;uri&quot;&gt;http://registry.wuling.com:30108&lt;/a&gt; ，通过浏览器访问，为Grafana修改数据源，如下：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406220801924-150830694.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;标红的地方，为上一步记录下的InfluxDB服务端的地址。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建heapster资源对象&quot;&gt;2.2、创建Heapster资源对象&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;apiVersion&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; v1
kind&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; ServiceAccount
metadata&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; heapster
  namespace&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; kube&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;system
&lt;span class=&quot;op&quot;&gt;---&lt;/span&gt;
apiVersion&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; extensions/v1beta1
kind&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; Deployment
metadata&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; heapster
  namespace&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; kube&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;system
spec&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  replicas&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
  selector&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
    matchLabels&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      task&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring
      k8s&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;app&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; heapster
  template&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
    metadata&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      labels&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
        task&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; monitoring
        k8s&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;app&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; heapster
    spec&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      serviceAccountName&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; heapster
      containers&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; heapster
        image&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;k8s&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;gcr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;io&lt;/span&gt;/&lt;span class=&quot;at&quot;&gt;heapster&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;amd64&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;v1&lt;/span&gt;.&lt;span class=&quot;fl&quot;&gt;4.2&lt;/span&gt;
        imagePullPolicy&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; IfNotPresent
        command&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/heapster&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;        - --source=kubernetes:https://kubernetes.default &lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;        - --sink=influxdb:http://150.109.39.33:31001  # 这里填写刚刚记录下的InfluxDB服务端的地址。&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;apiVersion: v1&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;kind: Service&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;metadata:&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  labels:&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    task: monitoring&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    # For use as a Cluster add-on &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;https://github.com/kubernetes/kubernetes/tree/master/cluster/addons&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    # If you are NOT using this as an addon, you should comment out this line.&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    kubernetes.io/cluster&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;service&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'true'&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;kubernetes&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;io&lt;/span&gt;/name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; Heapster
  name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; heapster
  namespace&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; kube&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;system
spec&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  ports&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; port&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt;
    targetPort&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8082&lt;/span&gt;
  selector&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
    k8s&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;app&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; heapster&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;--source 为heapster指定获取集群信息的数据源。参考：&lt;a href=&quot;https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md&quot; class=&quot;uri&quot;&gt;https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md&lt;/a&gt;&lt;br/&gt;--sink 为heaster指定后端存储，这里我们使用InfluxDB，其他的，请参考：&lt;a href=&quot;https://github.com/kubernetes/heapster/blob/master/docs/sink-owners.md&quot; class=&quot;uri&quot;&gt;https://github.com/kubernetes/heapster/blob/master/docs/sink-owners.md&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;这里heapster留下了一个的坑，请继续往下看&lt;/strong&gt;，当我部署完heapster，通过查看Heapster容器组的镜像发现：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406221458187-1923970011.png&quot;/&gt;&lt;br/&gt;很多人都以为是https或者k8s配置的问题，于是去就慌忙的去配置InSecure http方式，导致坑越来越深，透明度越来越低，更是无从下手，我也是这样弄了很久，都较上劲了，此处省略一万字。。。，当这些路子都走遍了，再次品读下面的原文：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406222216240-1816414187.png&quot;/&gt;&lt;br/&gt;才发现是权限的问题，heaster默认使用一个令牌(Token)与ApiServer进行认证，通过查看heapster.yml发现 &lt;strong&gt;serviceAccountName: heapster&lt;/strong&gt; ，现在明白了吧，就是heaster没有权限，那么如何授权呢-----&lt;strong&gt;给heaster绑定一个有权限的角色就行了&lt;/strong&gt;，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;apiVersion&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;rbac&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;authorization&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;k8s&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;io&lt;/span&gt;/&lt;span class=&quot;at&quot;&gt;v1beta1&lt;/span&gt;
kind&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; ClusterRoleBinding
metadata&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; heapster
roleRef&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
  apiGroup&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;rbac&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;authorization&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;k8s&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;io&lt;/span&gt;
  kind&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; ClusterRole
  name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; cluster&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;admin
subjects&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; kind&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; ServiceAccount
  name&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; heapster
  namespace&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; kube&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;system&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当创建heapster资源的时候，直接把这段代码加上，就行了。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406215755378-1027666287.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406220000071-493955843.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406220309557-160835267.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406215841846-172071997.png&quot;/&gt;&lt;br/&gt;整个监控方案部署成功后，从上图可以看到，在不同粒度/维度下，dashboard上可以呈现对象的具体CPU和内存使用率。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406224046382-456132151.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406230209900-1524012118.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406224131436-415803334.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406224202090-1000727847.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406224218176-1570602118.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201804/1082769-20180406224255298-464071001.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 14:48:00 +0000</pubDate>
<dc:creator>据说甜蜜呢</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/justmine/p/8723467.html</dc:identifier>
</item>
<item>
<title>我的前端故事----来聊聊react-native应用的健康监控 - F-happy</title>
<link>http://www.cnblogs.com/fuhuixiang/p/8729255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fuhuixiang/p/8729255.html</guid>
<description>&lt;h2 id=&quot;监控什么&quot;&gt;监控什么&lt;/h2&gt;
&lt;p&gt;今天我们来聊聊如何监控你的应用程序，这里的监控说的不是让我们去监控用户，而是监控应用的&lt;strong&gt;健康状态&lt;/strong&gt;，什么是健康状态呢？对于后端的同学来说，在微服务的架构下，每个子服务是否正常工作、返回的结果是否满足预期，这些就算是健康状态，再举个例子，你的台式机，对于操作系统来说，每个硬件是否能正常的工作、工作的稳定性，这些都是需要关注的健康状态。&lt;/p&gt;
&lt;p&gt;既然我们关心健康状态，那么我们该如何衡量一个“&lt;strong&gt;设备&lt;/strong&gt;”的健康状态呢？对于上面的例子，CPU运行的温度、硬盘读取的速度、子服务执行的效率，这些都可以作为健康状态的参考标准。而对于我们前端来说，一个服务的响应速度、某个页面渲染的时间、外接设备是否正常运行、以及正常运行的时间比，这些都可以作为我们衡量一个“&lt;strong&gt;设备&lt;/strong&gt;”是否健康的标准。&lt;/p&gt;
&lt;p&gt;上面说的了要监控什么指标，那这些指标具体的实例又是什么呢？由于我主要做react-native应用的开发，我今天就基于react-native来讨论一下这件事，而对于传统的web，相对来说就简单一些了，但具体的思路不会差太多。&lt;/p&gt;
&lt;p&gt;在我遇到的实际场景中，我的应用程序常常需要链接多个外接设备，例如：键盘、扫码枪、各种个感应器，所以我需要时刻关注这些设备的健康状态，一旦发现某个设备不能正常工作或者在未来的某个时刻不能正常工作，就需要马上反馈出来，而这只是一部分，这些物理设备有着很明确的“指标”。&lt;/p&gt;
&lt;p&gt;另一方面，诸如网络状态、电池电量，这些应用内的“指标”也需要我时刻的关注，什么时候处于弱网环境、什么时候出现低电量等各种各样的异常情况都会让我们的应用程序变得不健康。所以，我们的目标就是围绕着这两块展开监控，那么接下来我 们说说该从什么地方下手。&lt;/p&gt;
&lt;h2 id=&quot;生命周期&quot;&gt;生命周期&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;将所有想要监控的服务收集到一起，作为一个总控制，然后在总控中对各个服务器的各个生命周期埋点。&lt;/p&gt;
&lt;p&gt;1、主动式：手动的从各个生命周期中hook想要的数据，然后通过计算，收集上报。&lt;/p&gt;
&lt;p&gt;2、被动式： 在各个生命周期中埋点，等待某一类事件的触发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可是这么多设备，如果我们一个个的去监控、去适配，那就和给windows系统的硬件写驱动一样繁杂了，这对于我们前端开发来说工作量实在是太大了，所以为了方便我们进行统一的管理，和复用统一的代码，我们需要一个“模式”去规范和统一我们的设备。&lt;/p&gt;
&lt;p&gt;现在我们用一个统一的class去集中监控我们的设备，另外一个问题就是众多的设备，无论是“物理”的设备还是“虚拟”的设备，如果我们专门为每一种去写监控代码，工作量实在是太大了，所以我们可以让这些设备在上层表现的“一致”，为此，我们引入“生命周期”这个概念，在一个设备启动、运行、暂停、卸载的各个阶段，我们都可以进行监控，无论是扫码器，还是网络请求的发起，各种各样的形态都逃不过这个步骤，所以，只要能在这个上面做好文章，那么监控各种数据就易如反掌了。&lt;/p&gt;
&lt;p&gt;以下我会从两个方面来介绍一下我总结的“基础”的监控项，个人认为，无论你的项目为了应对什么样的场景，下面的这些例子基本都会是“必备”的选项了，即便你的项目比我的项目更加精简，但是下面介绍的思路也会是不错的参考。&lt;/p&gt;
&lt;h2 id=&quot;主动式监控&quot;&gt;主动式监控&lt;/h2&gt;
&lt;p&gt;上面说了这么多，那么我们来具体的看看需要监控些什么呢？&lt;/p&gt;
&lt;p&gt;在一个项目刚上线的时候，存在着很多隐藏的问题，所以我们需要更多的日志去监控应用程序是否正常的运行，以及是否按照我们自身设定的路线去执行，一旦项目稳定，一些模块或逻辑被证实是没有问题的了，那么相应的我们也要去移除一些埋点日志，另外一方面，在开始上线的时候由于用户量少，一旦出现线上bug，由于缺少案例，导致定位和分析的难度都会增大，所以，这个时候我们就需要主动的埋一些监控点，来应对这种情况的发生，在出现紧急bug的时候我们可以通过日志点去推测和演算用户的行为，以及当时的情况。&lt;/p&gt;
&lt;p&gt;但是，说到底这些监控都是临时的，不一个长期的监控，所以我的原则也是尽可能的不去侵入到业务代码中，无论是通过切面编程还是高阶组件封装，都要保证这些监控代码可以通过一个或一组规则快速的关闭统计，解放算力。&lt;/p&gt;
&lt;p&gt;因此，凡是主动监控都要具备自动判断和动态策略这两个特点，可以动态的感知到当前的状态，从而做出对主业务影响最小的行为，即便监控再重要，也不能因为监控的行为而影响业务进程的工作，这只能是一个锦上添花行为。&lt;/p&gt;
&lt;h2 id=&quot;被动式监控&quot;&gt;被动式监控&lt;/h2&gt;
&lt;p&gt;为什么要有被动式的监控呢？首先，有些监控的相对“独立”的，每一次的监控点并不会100%的触发，每次的触发并不存在上下文或者前后的必然联系。也就是说，这些点的触发都是单独存在的，所以我们不需要对其进行诸如计算、格式化等分析操作，也不需要保存它的上下文，比如开始、结束时间。&lt;/p&gt;
&lt;p&gt;相对于上面介绍的主动式监控，被动式监控的代码和逻辑都会长期的运行，因为在项目的中后期，在移除了大多数异常、性能监控后，这些仅存的代码就成了我们排查问题的关键所在了。因此，这些监控要保证自身的稳定，以及所积累的信息准确、及时，谁都不希望看到奔溃或者逻辑错误的警报在发生之后很久才上报出来。&lt;/p&gt;
&lt;p&gt;那么有哪些需要我们做被动式的监控呢？在我的项目中，一个外接设备是否在线，用户点击键盘上某个按钮等行为就是一个典型的被动式监控，我不知道用户什么时候去点键盘，我也不知道我的外接设备什么时候断开，我只是需要捕获到这个行为的发生就可以了。&lt;/p&gt;
&lt;p&gt;而且对于这些监控点，我们实际上是不需要开发自己去写代码的，它应该存在于依赖的包中，这就避免了我多次写重复代码的问题，举个例子，我在A项目中有个对扫码器扫描到内容的监控，而在B、C项目中我仍旧需要这个功能，那么我就可以不再反复的去写这块的日志代码了，因为它应该存在于这个扫码器的包中，我要做的，只是提供一个logger方法而已，返回的格式、内容都不需要我去关心。&lt;/p&gt;
&lt;p&gt;而这些通过埋点、用户输入、事件回调等方式收集上来的日志，我们都要如实的上报到远程服务器（这里和主动式监控有所区别，主动监控的内容可以允许我们自己计算、统计），因为这些都是真正的异常，以后会影响我们debug的日志要最大程度的保留现场。&lt;/p&gt;
&lt;h3 id=&quot;客户端流程图&quot;&gt;客户端流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/665852/201804/665852-20180406224134984-1921150675.png&quot; width=&quot;100%&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务端&quot;&gt;服务端&lt;/h2&gt;
&lt;p&gt;上面说了那么多，都是基于客户端去做的，现在我们在客户端已经准备好了想要的数据，那么我们该如何去使用他们呢？&lt;/p&gt;
&lt;p&gt;对于发送上来的日志，我可以做如下三件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;监控24小时在线状态&lt;/li&gt;
&lt;li&gt;异常指标的快速报警&lt;/li&gt;
&lt;li&gt;可视化的展示监控信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们就围绕这三点来设计我们的服务端系统。&lt;/p&gt;
&lt;p&gt;对于第一点，我们可以通过与客户端的心跳包来检查客户端是否存活，因为在业务场景中，我们的应用为react-native的，所以在检测心跳的时候就要区分是native模块还是js的业务模块了，同时很多场景下存在无人使用时js业务不会上传日志以及在移动网络下业务精简日志的情况，因此我们的24小时监控服务就要足够灵活、多变。所以在报警的时候可以通过读取配置的方式在服务器不重启的情况下动态的变换监控规则。&lt;/p&gt;
&lt;p&gt;例如什么项目需要监控native存活，什么项目需要监控js环境存活，什么时候将报警通知给何人，并且可以通知到是什么地方的什么设备出了什么故障，这些都是基础功能。&lt;/p&gt;
&lt;p&gt;而第二点，需要我们做的除了包含第一点之外的功能外，还有一个异常记录的功能，因为第二点的异常具有偶发性，并且相对于心跳包来说，日志内容更加丰富，因此我们可以针对这些日志做更多的事情，但首先就是将这些日志分类的保存起来。同时，在第二点中存在不同的应用对不同的异常有不同的定义的情况，比如说A应用认为数据初始化的接口超时就属于异常，而B应用则认为即便超时也不影响，那么就需要为每个应用单独配置异常指标，从而做到分项目、分阈值的功能。&lt;/p&gt;
&lt;p&gt;还有一些额外的拓展，由于上面做的分项目、分阈值处理，就势必存在一些通用异常，那么每个项目就应该具有继承公共异常的功能，以及一些模板异常的设定。这些都是这个服务所需要的功能。&lt;/p&gt;
&lt;p&gt;最后一点，在搜集到异常以及通知到相关负责人之后，这次异常报警就算结束了嘛？当然没有这么简单了，我们可以基于web服务来查看一些日志的基本情况，例如什么项目报警最多，什么地方报警最多，什么时间报警最多等等图表提供我们查看和分析。更有甚者我们可以根据不同的报警级别给不同的人发送不同的报警内容。&lt;/p&gt;
&lt;p&gt;最后是这个服务端自身的健壮性，由于我们的服务是基于nodejs来做的，因此通过pm2，我可以很方便的在进程挂掉之后马上恢复服务，同时为了服务相互解耦和最大化cpu效率，通过pm2启动脚本来将24小时离线服务、异常指标报警、日志分析展示服务相互独立开，并为可以启动多线程的服务提供cluster模式的支持。并且将共享的数据通过redis缓存，配置通过数据库持久化等方式来备份和保证服务的健壮与高效。&lt;/p&gt;
&lt;h3 id=&quot;服务端流程图&quot;&gt;服务端流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/665852/201804/665852-20180406224200720-563474925.png&quot; width=&quot;100%&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此，一个由客户端+服务端的健康监控系统初步完成。它们这些服务看似相互依赖，但又相互解耦，不会造成一个环节失效导致整个系统奔溃，同时又可以做到对正常业务最小化的侵入。&lt;/p&gt;
&lt;p&gt;当然，这些都只是一个雏形，一个全部由js去完成的项目，相对于大公司那些完整而又系统的监控来说，仅仅只能作为开发业务的我们自查的一个工具。虽然有这些系统来保证我们的项目正常、健康的运行，但是更重要的是我们开发者自己代码的健壮和稳定。工具做的再好，也不能替代我们自己写的优异的代码。&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 14:47:00 +0000</pubDate>
<dc:creator>F-happy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fuhuixiang/p/8729255.html</dc:identifier>
</item>
<item>
<title>读论文系列：Object Detection ECCV2016 SSD - 梦里风林</title>
<link>http://www.cnblogs.com/hellocwh/p/8729260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellocwh/p/8729260.html</guid>
<description>&lt;p&gt;转载请注明作者：&lt;a href=&quot;https://github.com/ahangchen&quot;&gt;梦里茶&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Single Shot MultiBox Detector&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;一句话概括：SSD就是关于类别的多尺度RPN网络&lt;/p&gt;
&lt;p&gt;基本思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基础网络后接多层feature map&lt;/li&gt;
&lt;li&gt;多层feature map分别对应不同尺度的固定anchor&lt;/li&gt;
&lt;li&gt;回归所有anchor对应的class和bounding box&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;model&quot;&gt;Model&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-89fe5dc4d9d31d24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;SSD&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;输入：300x300&lt;/li&gt;
&lt;li&gt;经过VGG-16（只到conv4_3这一层）&lt;/li&gt;
&lt;li&gt;经过几层卷积，得到多层尺寸逐渐减小的feature map&lt;/li&gt;
&lt;li&gt;每层feature map分别做3x3卷积，每个feature map cell(又称slide window)对应k个类别和4个bounding box offset，同时对应原图中6（或4）个anchor(又称default box)&lt;/li&gt;
&lt;li&gt;38x38, 最后3x3, 1x1三个feature map的每个feature map cell只对应4个anchor，分别为宽高比: 1:1两种，1:2, 2:1两种，因此总共有 38 * 38 * 4 + 19 * 19 * 6 + 10 * 10 * 6 + 5 * 5 * 6 + 3 * 3 * 4 + 1 * 1 * 4 = 8732 个anchor&lt;/li&gt;
&lt;li&gt;其他feature map的feature map cell对应6个anchor，分别为宽高比: 1:1两种，1:2, 2:1两种，1:3， 3:1两种&lt;/li&gt;
&lt;li&gt;每层的feature map cell对应的anchor计算方法如下&lt;/li&gt;
&lt;li&gt;位置：假设当前feature map cell是位于第i行，第j列，则anchor的中心为 ((i+0.5)/|f&lt;sub&gt;k&lt;/sub&gt;|,(j+0.5)/|f&lt;sub&gt;k&lt;/sub&gt;|), f&lt;sub&gt;k&lt;/sub&gt;是第k层feature map的size（比如38）
&lt;ul&gt;&lt;li&gt;缩放因子:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-91ef6530e5dce4b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Scale&quot;/&gt;&lt;br/&gt;其中s&lt;sub&gt;min&lt;/sub&gt;为0.2，s&lt;sub&gt;max&lt;/sub&gt;为0.9，m为添加的feature map的层数，缩放因子就是为不同feature map选择不同的大小的anchor，要求小的feature map对应的anchor尽量大，因为越小的feature map，其feature map cell的感受野就越大&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;anchor宽高：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-ba128e30ed7637e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;width&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-4898e977cc483570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;height&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，a&lt;sub&gt;r&lt;/sub&gt;∈{1,2,3,1/2,1/3}，可以理解为在缩放因子选择好anchor尺寸后，用a&lt;sub&gt;r&lt;/sub&gt;来控制anchor形状，从而得到多尺度的各种anchor，当a&lt;sub&gt;r&lt;/sub&gt;=1时，增加一种 s&lt;sub&gt;k&lt;/sub&gt;=sqrt(s&lt;sub&gt;k-1&lt;/sub&gt;s&lt;sub&gt;k+1&lt;/sub&gt;)，于是每个feature map cell通常对应6种anchor。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;网络的训练目标就是，回归各个anchor对应的类别和位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;training&quot;&gt;Training&lt;/h2&gt;
&lt;h3 id=&quot;样本&quot;&gt;样本&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;正样本&lt;br/&gt;选择与bounding box jaccard overlap（两张图的交集/并集）大于0.5的anchor作为正样本&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;样本比例&lt;br/&gt;Hard negative mining：由于负样本很多，需要去掉一部分负样本，先整图经过网络，根据每个anchor的最高类置信度进行排序，选择置信度靠前的样本，这样筛选出来的负样本也会更难识别，并且最终正负样本比例大概是1:3&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;loss&quot;&gt;Loss&lt;/h3&gt;
&lt;p&gt;还是一如既往的location loss + classification loss，并为location loss添加了系数α（然而实际上α=1）进行平衡，并在batch维度进行平均&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-d6d2d65d71a11cb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;SSD Loss&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x是x&lt;sub&gt;ij&lt;/sub&gt;&lt;sup&gt;p&lt;/sup&gt;的集合x&lt;sub&gt;ij&lt;/sub&gt;&lt;sup&gt;p&lt;/sup&gt;={1,0}，用于判断第i个anchor是否是第j个bounding box上的p类样本&lt;/li&gt;
&lt;li&gt;c是c&lt;sub&gt;i&lt;/sub&gt;&lt;sup&gt;p&lt;/sup&gt;的集合，c&lt;sub&gt;i&lt;/sub&gt;&lt;sup&gt;p&lt;/sup&gt;是第i个anchor预测为第p类的概率&lt;/li&gt;
&lt;li&gt;l是预测的bounding box集合&lt;/li&gt;
&lt;li&gt;g是ground true bounding box集合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中定位loss与faster rcnn相同&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-85b5465531c2b9bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Location loss&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个式子里的k不是很明确，其实想表达不算背景0类的意思，且前景类只为match的类算location loss&lt;/p&gt;
&lt;p&gt;分类loss就是很常用的softmax交叉熵了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-5f9a84cd98dce905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;classification&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;核心的内容到这里就讲完了，其实跟YOLO和faster rcnn也很像，是一个用anchor box充当固定的proposal的rpn，并且用多尺度的anchor来适应多种尺度和形状的目标对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;detail&quot;&gt;Detail&lt;/h2&gt;
&lt;p&gt;在训练中还用到了data augmentation（数据增强/扩充），每张图片多是由下列三种方法之一随机采样而来&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用整图&lt;/li&gt;
&lt;li&gt;crop图片上的一部分，crop出来的min面积为0.1,0.3,0.5,0.7,0.9&lt;/li&gt;
&lt;li&gt;完全随机地crop&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后这些图片会被resize到固定的大小，随机水平翻转，加入一些图像上的噪声，详情可以参考另一篇论文：&lt;/p&gt;
&lt;p&gt;Some improvements on deep convolutional neural network based image classification&lt;/p&gt;
&lt;p&gt;从切除实验中，可以看到data augmentaion是很重要的（从65.6到71.6）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1828517-3ddd324e48e37468.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Experiment&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个表中还提到了atrous，其实是指空洞卷积，是图像分割（deeplab）领域首先提出的一个卷积层改进，主要是能让测试速度更快。具体可以参考 &lt;a href=&quot;https://arxiv.org/pdf/1412.7062.pdf&quot;&gt;ICLR2015 Deeplab&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从这个表中也可以看出多种形状的anchor可以提升准确率&lt;/p&gt;
&lt;h2 id=&quot;result&quot;&gt;Result&lt;/h2&gt;
&lt;p&gt;输入尺寸为300x300，batch size为8的SSD300可以做到实时(59FPS)且准确(74.3% mAP)的测试&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;SSD算是一个改进性的东西，站在Faster RCNN的肩膀上达到了实时且准确的检测&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 14:43:00 +0000</pubDate>
<dc:creator>梦里风林</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellocwh/p/8729260.html</dc:identifier>
</item>
<item>
<title>ASP.NET Web API编程——路由 - 甜橙很酸</title>
<link>http://www.cnblogs.com/hdwgxz/p/8729000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hdwgxz/p/8729000.html</guid>
<description>&lt;p&gt;路由过程大致分为三个阶段：&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;请求&lt;/span&gt;URI匹配已存在路由模板&lt;/p&gt;
&lt;p&gt;2）选择控制器&lt;/p&gt;
&lt;p&gt;3）选择操作&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1匹配已存在的路由模板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路由模板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;WebApiConfig.Register方法中定义路由，例如模板默认生成的路由为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;config.Routes.MapHttpRoute(
                name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultApi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                routeTemplate: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/{controller}/{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                defaults: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; { id =&lt;span&gt; RouteParameter.Optional }
            );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面使用了public static IHttpRoute MapHttpRoute(this HttpRouteCollection routes, string name, string routeTemplate, object defaults)方法来配置路由。相关参数为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;name&lt;/strong&gt;：路由名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;routeTemplate&lt;/strong&gt;&lt;span&gt;：路由模板，与&lt;/span&gt;URI相似。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;api/{controller}/{id}、&lt;/p&gt;
&lt;p&gt;api/{controller}/{action}/{id}、api/{controller}/public/{category}/{id}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;defaults&lt;/strong&gt;：路由值对象。可为占位符设置默认值。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;api/{controller}/public/{category}/{id}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置&lt;/span&gt;defaults: new { category = &quot;all&quot; }&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;路由词典&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果&lt;/span&gt;Web API匹配到一个已存在的路由模板，会创建一个路由词典，词典的键是模板中占位符的名称，值是占位符对应的值。如果路由值对象被指定为RouteParameter.Optional，那么这个值不会被放入词典中。路由词典会被存储到IHttpRouteData实例中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;匹配示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;api/{controller}/{id}&lt;/p&gt;
&lt;p&gt;首先匹配&lt;span&gt;字符串&lt;/span&gt;api,然后匹配控制器（controller），第三匹配以HTTP&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;开头的&lt;/span&gt;&lt;span&gt;操作（&lt;/span&gt;Action）,占位符id匹配Action接收的参数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;api/{controller}/{action}/{id}&lt;/p&gt;
&lt;p&gt;首先匹配&lt;span&gt;字符串&lt;/span&gt;api,然后匹配控制器（controller），最后匹配&lt;span&gt;操作（&lt;/span&gt;Action）,占位符id匹配Action接收的参数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;api/root/{id}&lt;/p&gt;
&lt;p&gt;务必对defaults设置控制器（controller）的默认值,，不然无法执行路由过程。可以不设置&lt;span&gt;操作（&lt;/span&gt;Action）。首先匹配api和root,然后匹配默认的控制器（controller），&lt;span&gt;最后占位符&lt;/span&gt;id匹配操作（Action）接收的参数。若不设置操作（Action）那么匹配以HTTP方法开头的&lt;span&gt;操作（&lt;/span&gt;Action）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2控制器的选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;控制器（controller）&lt;span&gt;的选择是由&lt;/span&gt;IHttpControllerSelector.SelectController完成的，IHttpControllerSelector接口默认实现是DefaultHttpControllerSelector&lt;span&gt;。&lt;/span&gt;IHttpControllerSelector.SelectController&lt;span&gt;方法获取&lt;/span&gt;HttpRequestMessage实例并返回HttpControllerDescriptor。&lt;/p&gt;
&lt;p&gt;DefaultHttpControllerSelector查找控制器（controller）的算法为：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在路由词典中查找键为&lt;/span&gt;“controller”的值，找到键“controller”对应的值后，将字符串Controller拼接到这个值的后边，便可获得&lt;span&gt;控制器（&lt;/span&gt;Controller&lt;span&gt;）名&lt;/span&gt;&lt;span&gt;。根据获得的&lt;/span&gt;控制器（Controller）名查找Web API&lt;span&gt;中的控制器（&lt;/span&gt;controller）。如果没有查找到控制器（controller）&lt;span&gt;名或者匹配到了多个，那么返回错误。&lt;/span&gt;DefaultHttpControllerSelector使用IHttpControllerTypeResolver来获得Web API控制器（controller）类型列表。IHttpControllerTypeResolver的默认实现返回具有如下特征的公有类：&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;实现了&lt;/span&gt;IHttpController接口。&lt;/p&gt;
&lt;p&gt;2）不被abstract修饰。&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;命名以&lt;/span&gt;“Controller”结尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3匹配控制器操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IHttpActionSelector.SelectAction方法获取HttpControllerContext并返回HttpActionDescriptor，IHttpActionSelector接口的默认实现是ApiControllerActionSelector。ApiControllerActionSelector会查找请求的HTTP方法、路由模板中的{action}占位符、控制器操作的参数列表。&lt;/p&gt;
&lt;p&gt;Web API框架认为控制器（controller）的操作（Action）具有如下特征：&lt;/p&gt;
&lt;p&gt;1）公有类型的实例方法。&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;继承自&lt;/span&gt;ApiController的方法&lt;/p&gt;
&lt;p&gt;3）非构造器，事件，操作符重载等特殊方法。&lt;/p&gt;
&lt;p&gt;Web API框架仅选择那些匹配请求的HTTP方法的操作，原则为：&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;指定了相应特性的操作，例如使用&lt;/span&gt;HttpGet特性的操作，只能匹配Get请求。&lt;/p&gt;
&lt;p&gt;2）如果控制器（controller&lt;span&gt;）操作以&lt;/span&gt;&quot;Get&quot;, &quot;Post&quot;, &quot;Put&quot;, &quot;Delete&quot;, &quot;Head&quot;, &quot;Options&quot;, or &quot;Patch&quot;开头，按照惯例控制器（controller&lt;span&gt;）操作支持对应的&lt;/span&gt;HTTP请求。&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;如果不满足以上两条，默认支持&lt;/span&gt;POST请求。&lt;/p&gt;

&lt;p&gt;ApiControllerActionSelector选择控制器（controller）操作的算法如下：&lt;/p&gt;
&lt;p&gt;1）创建一个链表，链表元素为所有与HTTP请求相匹配的操作（Action）。&lt;/p&gt;
&lt;p&gt;2）如果路由词典中包含关于操作（Action）的键值对，移除链表中名称和值不匹配的操作（Action）。&lt;/p&gt;
&lt;p&gt;3）匹配操作（Action）参数与URI。&lt;/p&gt;
&lt;p&gt;l 对于每一个操作（Action），获得简单类型的参数列表，参数绑定从URI获得操作（Action）参数，不包括可选的参数。&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;在参数列表中，从路由表中或请求&lt;/span&gt;URI查询字符串中，为每一个参数名找到一个匹配，匹配是不区分大小写的，并且不依赖于参数顺序。&lt;/p&gt;
&lt;p&gt;l 选择一个操作（Action），其参数列表中的每一个参数在请求URI中都对应一个值。&lt;/p&gt;
&lt;p&gt;l 如果有多个操作（Action）满足以上规则，选择有最多参数匹配的一个操作（Action）。&lt;/p&gt;
&lt;p&gt;4）忽略被标记为[NonAction]的方法。&lt;/p&gt;
&lt;p&gt;补充说明：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于步骤&lt;/span&gt;3）一个参数可以从URI，请求消息体，或者自定义绑定中获得它的值。对于来自于URI的参数，要确保URI确实包含对应参数的值，这个值可能在路由词典中或查询字符串中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于可选的参数，如果绑定不能从&lt;/span&gt;URI中获得参数的值，对于操作（Action）的选择也没有影响。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于复杂类型，只能通过自定义绑定来匹配&lt;/span&gt;URI中的参数值。操作（Action）选择算法的目的是在完成模型绑定之前选出操作（Action），因此操作（Action）选择算法对复杂类型无效。&lt;/p&gt;
&lt;p&gt;一旦操作（Action）被选出，模型绑定器才会被调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4路由过程的扩展&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;IHttpControllerSelector&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;选择控制器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;IHttpControllerTypeResolver&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;获得控制器（controller）类型列表，DefaultHttpControllerSelector会从这个列表中选择控制器（controller）类型。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;IAssembliesResolver&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;获得项目程序集列表，&lt;strong&gt;IHttpControllerTypeResolver&lt;/strong&gt; 会从这个列表中找到控制器（controller）类型&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;IHttpControllerActivator&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;创建新的控制器（controller）实例&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;IHttpActionSelector&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;选择操作（Action）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;IHttpActionInvoker&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;调用操作（Action）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;要想使用自定义的上述接口实现，那么要注册服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebApiConfig
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register(HttpConfiguration config)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他配置&lt;/span&gt;
            config.Services.Replace(&lt;span&gt;typeof&lt;/span&gt;(IHttpControllerSelector), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomHttpControllerSelector());
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例：扩展IHttpControllerSelector&lt;/p&gt;
&lt;p&gt;实现GetControllerMapping和SelectController方法，GetControllerMapping为发现系统所有可能的控制器（controller），SelectController会使用这些所有可能的控制器（controller），因此需要CustomHttpControllerSelector的属性存储所有可能的控制器（controller&lt;span&gt;）。具体示例见&lt;/span&gt;“ASP.NET Web API编程——版本控制”&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomHttpControllerSelector : IHttpControllerSelector
{

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, System.Web.Http.Controllers.HttpControllerDescriptor&amp;gt;&lt;span&gt; GetControllerMapping()
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; System.Web.Http.Controllers.HttpControllerDescriptor SelectController(HttpRequestMessage request)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;此外，有时扩展&lt;/span&gt;Web API框架的DefaultHttpControllerSelector或许是更加合理的方式。&lt;/p&gt;

&lt;p&gt;例：扩展IAssembliesResolver&lt;span&gt;，&lt;/span&gt;&lt;span&gt;动态加载&lt;/span&gt;控制器（controller）&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以将&lt;/span&gt;控制器（controller）&lt;span&gt;类单独编制为一个&lt;/span&gt;dll,放在指定的文件夹内，这样无需编译整个框架，就能修改控制器（controller）&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceAssembliesResolver : IAssembliesResolver
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; path;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceAssembliesResolver(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; path)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.path =&lt;span&gt; path;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ICollection&amp;lt;System.Reflection.Assembly&amp;gt;&lt;span&gt; GetAssemblies()
        {
            List&lt;/span&gt;&amp;lt;Assembly&amp;gt; assemblies = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Assembly&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
                assemblies = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Assembly&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载每一个服务插件&lt;/span&gt;
                &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; Directory.GetFiles(path, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllersAssembly =&lt;span&gt; Assembly.LoadFrom(file);
                    assemblies.Add(controllersAssembly);
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理异常&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; assemblies;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此外继承&lt;/span&gt;Web API框架默认的DefaultAssembliesResolver也是一个好办法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceAssembliesResolver : DefaultAssembliesResolver
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务插件路径&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; path;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceAssembliesResolver(&lt;span&gt;string&lt;/span&gt; path):&lt;span&gt;base&lt;/span&gt;&lt;span&gt;()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.path =&lt;span&gt; path;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; ICollection&amp;lt;Assembly&amp;gt;&lt;span&gt; GetAssemblies()
        {
            List&lt;/span&gt;&amp;lt;Assembly&amp;gt; assemblies = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Assembly&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得已有的服务&lt;/span&gt;
                ICollection&amp;lt;Assembly&amp;gt; baseAssemblies = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.GetAssemblies();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
                assemblies = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Assembly&amp;gt;&lt;span&gt;(baseAssemblies);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载每一个服务插件&lt;/span&gt;
                &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; Directory.GetFiles(path, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllersAssembly =&lt;span&gt; Assembly.LoadFrom(file);
                    assemblies.Add(controllersAssembly);
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理异常&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; assemblies;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5使用特性设置路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了更好地支持&lt;/span&gt;URI参数，所以使用路由特性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.1使用特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RouteAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路由特性定义为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RouteAttribute : Attribute, IDirectRouteFactory, IHttpRouteInfoProvider
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RouteAttribute();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;template:描述要匹配的 URI 模式的路由模板&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; RouteAttribute(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; template);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由名称&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由顺序&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Order { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;描述要匹配的 URI 模式的路由模板&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Template { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;RoutePrefix&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;RoutePrefix特性为整个控制器（controller）设置路由前缀，路由前缀特性定义为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RoutePrefixAttribute : Attribute, IRoutePrefix
{
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; RoutePrefixAttribute();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;prefix: 控制器的路由前缀。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; RoutePrefixAttribute(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; prefix);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取路由前缀。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Prefix { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    [RoutePrefix(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/values&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ApiController
    {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GET api/values/getvalues&lt;/span&gt;
        [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getvalues&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;“~”可重写路由前缀，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[RoutePrefix(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/values&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ApiController
{
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/api/allvalues&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;路由前缀可以包含参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[RoutePrefix(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/values/{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ApiController
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GET api/values/1/getvalues&lt;/span&gt;
        [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getvalues&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;路由约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;限制参数的类型，语法为：{parameter:constraint}，&lt;span&gt;可以指定多个约束，每个约束用：分隔。&lt;/span&gt;Route和RoutePrefix特性均支持这种用法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[RoutePrefix(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/values/{id：int：min(1)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ApiController
{
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetValues&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;约束规则如下：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;约束&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;alpha&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;匹配大写或小写拉丁字母（A-Z，a-z）&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:alpha}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;bool&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;匹配Boolean 类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:bool}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;datetime&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;匹配DateTime 类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:datetime}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;decimal&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;匹配decimal类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:decimal}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;double&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;匹配double类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:double}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;float&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;匹配float类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:float}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;guid&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;匹配GUID值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:guid}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;int&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;匹配int类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:int}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;length&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;匹配指定长度或指定长度范围内的字符串&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;{x:length(6)} {x:length(1,20)}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;long&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;匹配long类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:long}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;max&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;匹配整型，其值不能大于设置的值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:max(10)}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;maxlength&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;匹配字符串，它的长度不能超过设定的值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:maxlength(10)}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;min&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;匹配整型，其值不能小于设定的值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:min(10)}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;minlength&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;匹配字符串，它的长度不能小于设置的值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:minlength(10)}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;range&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;指定整型的范围&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;{x:range(10,50)}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;regex&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;匹配正则表达式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;{x:regex(^\d{3}-\d{3}-\d{4}$)}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;可选&lt;/span&gt;URI参数与默认值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用？来标识路由值为可选的，同时必须为操作参数设置默认值。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v1/user/{id:int?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHttpActionResult User(&lt;span&gt;int&lt;/span&gt; id=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;id);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;设置路由名称&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置路由名称后，可以在使用控制器（controller）的属性ApiController.Url或ApiController.Route&lt;span&gt;拼接&lt;/span&gt;URL。&lt;/p&gt;
&lt;p&gt;例：在GetPublicationNew中获得路由到操作GetPublication&lt;span&gt;的&lt;/span&gt;URL&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v1/publication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;V1Publication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IHttpActionResult GetPublication()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v1/publication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v2/publication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IHttpActionResult GetPublicationNew()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; url = Url.Link(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;V1Publication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Json(url);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;路由顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RouteOrder值较小的路由先被使用，默认的RouteOrder值为0。&lt;/p&gt;
&lt;p&gt;比较顺序的规则为：&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;先比较&lt;/span&gt;RouteOrder的值&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;查看路由模板的&lt;/span&gt;URI参数，对于每一个参数，由参数决定的顺序为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字面值顺序排第一。&lt;/li&gt;
&lt;li&gt;含有路由约束的顺序排第二。&lt;/li&gt;
&lt;li&gt;没有路由约束的顺序排第三。&lt;/li&gt;
&lt;li&gt;含有通配符和路由约束的顺序排第四。&lt;/li&gt;
&lt;li&gt;含有通配符和无路由约束的顺序排第五。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3）在上述规则无法区分的情况下，即上述规则判定顺序相同的两个路由，决定顺序的依据是：不区分大小写地，比较字符串的序号。&lt;/p&gt;
&lt;p&gt;例：这里引用官网文档的例子&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;https://docs.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[RoutePrefix(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orders&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrdersController : ApiController
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id:int}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置路由约束&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; HttpResponseMessage Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) { ... }

    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;details&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字面值&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpResponseMessage GetDetails() { ... }

    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pending&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, RouteOrder = &lt;span&gt;1&lt;/span&gt;)]&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定路由顺序&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpResponseMessage GetPending() { ... }

    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{customerName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;无路由约束&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; HttpResponseMessage GetByCustomer(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; customerName) { ... }

    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{*date:datetime}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 含有通配符&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpResponseMessage Get(DateTime date) { ... }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;路由顺序依次为：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一&lt;/span&gt;.orders/details&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二&lt;/span&gt;.orders/{id}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三&lt;/span&gt;.orders/{customerName}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四&lt;/span&gt;.orders/{*date}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五&lt;/span&gt;.orders/pending&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使路由特性起作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要想使路由特性起作用，必须在WebApiConfig.Register方法中加入代码：config.MapHttpAttributeRoutes();&lt;/p&gt;
&lt;p&gt;如下完整代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebApiConfig
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register(HttpConfiguration config)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启用路由特性&lt;/span&gt;
&lt;span&gt;            config.MapHttpAttributeRoutes();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他配置&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以同时使用路由特性与基于协定路由：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register(HttpConfiguration config)
{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启用路由特性&lt;/span&gt;
&lt;span&gt;        config.MapHttpAttributeRoutes();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于协定的路由&lt;/span&gt;
&lt;span&gt;        config.Routes.MapHttpRoute(
            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultApi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            routeTemplate: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/{controller}/{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            defaults: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; { id =&lt;span&gt; RouteParameter.Optional }
        );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;自定义路由约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现一个继承自&lt;/span&gt;IHttpRouteConstraint接口的类，然后注册此类。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;自定义CustomHttpRouteConstraint&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomHttpRouteConstraint : IHttpRouteConstraint
{

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Match(HttpRequestMessage request, IHttpRoute route, &lt;span&gt;string&lt;/span&gt; parameterName, IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; values, HttpRouteDirection routeDirection)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现验证过程   &lt;/span&gt;
&lt;span&gt;        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注册CustomHttpRouteConstraint，为这个约束提供一个简称。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebApiConfig
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register(HttpConfiguration config)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他配置&lt;/span&gt;

            &lt;span&gt;var&lt;/span&gt; constraintResolver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultInlineConstraintResolver();
            constraintResolver.ConstraintMap.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;customcons&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(CustomHttpRouteConstraint));

            config.MapHttpAttributeRoutes(constraintResolver);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用自定义约束&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{name:customcons}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHttpActionResult SUser(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; name);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5.2应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;支持多版本&lt;/span&gt;API：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设随着业务的扩展，对&lt;/span&gt;API接口进行升级改造，老的接口还要使用一段时间而不会立即停用，这时需要版本控制机制。如下面的例子，使用路由特性后，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然&lt;/span&gt;URI片段中的指定的操作（Action）名称一样，但是调用的操作（Action）却不一样。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v1/publication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IHttpActionResult GetPublication()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v1/publication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v2/publication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IHttpActionResult GetPublicationNew()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v2/publication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当在浏览器中输入：http://localhost:45778/api/v1/publication时，显示&quot;api/v1/publication&quot;&lt;/p&gt;
&lt;p&gt;当在浏览器中输入：http://localhost:45778/api/v2/publication时，显示&quot;api/v2/publication&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于上述操作定义在同一个控制器（&lt;/span&gt;Controller）类中，所以方法名不能相同。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：由于上述操作名称中含有&lt;/span&gt;Get字符串，所以支持Get请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了支持重载的方法，使用路由特性&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v1/user/{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHttpActionResult GetUser(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;id);
        }

        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v2/user/{name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHttpActionResult GetUser(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; name);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当在浏览器中输入&lt;/span&gt;http://localhost:45778/api/v1/user/1时，页面显示“id:1”&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当在浏览器中输入&lt;/span&gt;http://localhost:45778/api/v2/user/coding时，页面显示“name:coding”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;支持&lt;/span&gt;URI时间参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请求&lt;/span&gt;Url：http://localhost:45778/api/user/1982-02-01&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/user/{time:datetime}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IHttpActionResult User(DateTime time)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; time);
        }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;pre&quot;&gt;输出为：&quot;time:1982/2/1 0:00:00&quot;&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;请求&lt;/span&gt;Url：http://localhost:45778/api/user/1982/02/01&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/user/{*time:datetime:regex(\\d{4}/\\d{2}/\\d{2})}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IHttpActionResult User(DateTime time)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; time);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;pre&quot;&gt;输出为：&quot;time:1982/2/1 0:00:00&quot;&lt;/p&gt;

&lt;p&gt;也可以将两种约束一起使用，这样可以同时支持两种格式了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpGet]     
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/user/{*time:datetime:regex(\\d{4}/\\d{2}/\\d{2})}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/user/{time:datetime:regex(\\d{4}-\\d{2}-\\d{2})}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IHttpActionResult User(DateTime time)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; time);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;https://docs.microsoft.com/en-us/aspnet/web-api/&lt;/p&gt;

&lt;p&gt;---------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;转载与引用请注明出处。&lt;/p&gt;
&lt;p&gt;时间仓促，水平有限，如有不当之处，欢迎指正。&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 13:40:00 +0000</pubDate>
<dc:creator>甜橙很酸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hdwgxz/p/8729000.html</dc:identifier>
</item>
<item>
<title>salesforce零基础学习（八十七）Apex 中Picklist类型通过Control 字段值获取Dependent List 值 - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/8728550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/8728550.html</guid>
<description>&lt;p&gt;&lt;span&gt;注：本篇解决方案内容实现转自：&lt;/span&gt;&lt;a href=&quot;https://developer.salesforce.com/docs/atlas.en-us.api.meta/api/sforce_api_calls_describesobjects_describesobjectresult.htm&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;http://mysalesforceescapade.blogspot.com/2015/03/getting-dependent-picklist-values-from.html&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;群里面有个小伙伴问了一个关于两个有Dependence关系的Picklist字段如何在Apex中通过control字段的值获取到Dependence字段的值，针对Salesforce配置来说，我们很好配置出两个Dependence字段的关系，通过点击设置一下include关系即可。如下图，我们在Goods__c自定义表中新建了两个Picklist类型字段，并且设置了依赖关系，这个在配置中清晰可见，如何在代码中获取呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180406190748147-642253381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们最先想到的肯定是通过metadata，查一下Schema命名空间下的类得方法有没有直接可以搞定需求的，针对Picklist值，通常处理的类为Schema.PicklistEntry以及Schema.DescribeFieldResult这两个类，然而这两个类的API中并没有直接可以搞定需求的，只能判断出当前的字段是否为空值字段等信息。既然标准的API没有提供，那么就得想办法搞定了。我的第一次想法是这样的，尽管这种方式最终确认是失败的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.将两个依赖字段放置在页面中，Util方法读取页面中指定元素从而获取Control字段的某一个值情况下Dependence的值集合。&lt;/strong&gt;&lt;span&gt;（此方法已确认失败）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zero-zyq/p/6251173.html&quot;&gt;salesforce 零基础学习（六十二）获取sObject中类型为Picklist的field values(含record type)&lt;/a&gt; &lt;span&gt;写过关于读取中间页面获取含Record Type的Picklist field Values，是不是也可以将中间页面写两个apex:inputField设置级联关系，通过参数将需要读取的内容获取出来，从而实现需求？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.PicklistParserController作为中间页的Controller,获取参数信息，通过参数对数据进行初始化处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; without sharing &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PicklistParserController {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Sobject sobj {get;set;}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String picklistFieldName {get;set;}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String dependentPicklistListFieldName { get; set; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String picklistFieldValue { get; set; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PicklistParserController() {
        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; requestMap =&lt;span&gt; ApexPages.currentPage().getParameters();
        String sobjId &lt;/span&gt;= requestMap.get('id'&lt;span&gt;);
        String recordTypeId &lt;/span&gt;= requestMap.get('recordTypeId'&lt;span&gt;);
        String sobjectTypeName &lt;/span&gt;= requestMap.get('sobjectType'&lt;span&gt;); 
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pickListFieldName = requestMap.get('picklistFieldName'&lt;span&gt;); 
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dependentPicklistListFieldName = requestMap.get('dependentPicklistListFieldName'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.picklistFieldValue = requestMap.get('picklistFieldValue'&lt;span&gt;);
        
        Schema.SobjectType sobjectType &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sobjectTypeName != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; sobjectTypeName.trim().length() &amp;gt; 0&lt;span&gt;) {
            sobjectType &lt;/span&gt;=&lt;span&gt; Schema.getGlobalDescribe().get(sobjectTypeName);
            sobj &lt;/span&gt;=&lt;span&gt; sobjectType.newSobject();
            sobj.put(&lt;/span&gt;'RecordTypeId'&lt;span&gt;, recordTypeid);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(picklistFieldValue != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                sobj.put(pickListFieldName,picklistFieldValue);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sobjId != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; sobjId.trim().length() &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; find the so&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (SobjectType sobjType : Schema.getGlobalDescribe().values()){
                String sobjPrefix &lt;/span&gt;=&lt;span&gt; sobjType.getDescribe().getKeyPrefix();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sobjPrefix == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sobjId.toLowerCase().startsWith(sobjPrefix.toLowerCase())) {
                    sobjectType &lt;/span&gt;=&lt;span&gt; sobjType;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
            sobj &lt;/span&gt;= Database.query ('SELECT ' + pickListFieldName + ',' + dependentPicklistListFieldName +  ' FROM ' + sobjectType + ' WHERE ID =:sobjId'&lt;span&gt;);
        }
        System.debug(LoggingLevel.INFO, &lt;/span&gt;'*** sobj: ' +&lt;span&gt; JSON.serialize(sobj));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.PicklistParser.page 显示两个依赖关系字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;apex:page controller=&quot;PicklistParserController&quot;&lt;span&gt;
    contentType&lt;/span&gt;=&quot;application/xml&quot; showHeader=&quot;false&quot; sidebar=&quot;false&quot;&lt;span&gt;
    standardStylesheets&lt;/span&gt;=&quot;false&quot; language=&quot;en_US&quot;&amp;gt;
    &amp;lt;apex:form &amp;gt;
        &amp;lt;apex:inputField value=&quot;{!sobj[pickListFieldName]}&quot; /&amp;gt;
        &amp;lt;apex:inputField value=&quot;{!sobj[dependentPicklistListFieldName]}&quot; id=&quot;dependentPicklistListFieldName&quot; required=&quot;true&quot;/&amp;gt;
    &amp;lt;/apex:form&amp;gt;
&amp;lt;/apex:page&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.PicklistParserUtil：此方法用于查看解析中间页面的结果展示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; with sharing &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PicklistParserUtil {&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String parseOptions(Map&amp;lt;String, String&amp;gt;&lt;span&gt; params) {
        Pagereference pr &lt;/span&gt;=&lt;span&gt; Page.PicklistParser;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to handle development mode, if ON&lt;/span&gt;
        pr.getParameters().put('core.apexpages.devmode.url', '1'&lt;span&gt;);
        System.debug(LoggingLevel.INFO, &lt;/span&gt;'*** params: ' +&lt;span&gt; JSON.serialize(params));
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String key : params.keySet()) {
            pr.getParameters().put(key, params.get(key));   
        }
        
        String xmlContent &lt;/span&gt;=&lt;span&gt; pr.getContent().toString();
        return xmlContent;&lt;/span&gt;&lt;span&gt;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;中间页面效果展示如下：&lt;/strong&gt; 通过下图可以看到，当控制字段选择了某个以后，级联字段展示了其对应的依赖字段值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180406195949703-971024232.bmp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 测试代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Map&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;,String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; m = new Map&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;,String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;();
m.put('sobjectType', 'Goods__c');
m.put('picklistFieldName','TestP1__c');
m.put('dependentPicklistListFieldName','TestP2__c');
m.put('picklistFieldValue', '测试1');
System.debug(LoggingLevel.INFO, '*** : ' + PicklistParserUtil.parseOptions(m));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是当解析这个输出结果时，发现输出的内容和设想的不太一样。原来设想的内容是解析的结果会有两个select option 区域，两个区域分别展示对应的value，后期只需要针对获取指定select下所有的option即可。然而实际的部分结果展示如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select  &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;j_id0:j_id1:j_id2&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;j_id0:j_id1:j_id2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;--None--&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;T1&quot;&lt;/span&gt;&lt;span&gt; selected&lt;/span&gt;&lt;span&gt;=&quot;selected&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;T1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;T2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;T2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;T3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;T3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;T4&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;T4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;测试1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;测试1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;测试2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;测试2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;requiredInput&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;requiredBlock&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select  &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;j_id0:j_id1:dependentPicklistListFieldName&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;j_id0:j_id1:dependentPicklistListFieldName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; selected&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;--None--&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;j_id0:j_id1:j_id3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;window.pl &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; window.pl &lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;&lt;span&gt;; {};
pl.map_00N0I00000JsNOk_01228000000U1u0&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;T4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DAAA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;IQAA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ggAA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;T1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wAAA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;T2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MAAA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;T3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GAAA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;};
pl.vals_00N0I00000JsNOk_01228000000U1u0&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestS6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试S1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试S1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试S2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试S2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];
pl.noneLabel&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--None--&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
pl.naLabel&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\*\*Not Applicable\*\*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
pl.selectedLabel&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chosen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
pl.availableLabel&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Available&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; picklist(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;j_id0:j_id1:dependentPicklistListFieldName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;00N0I00000JsNOk_01228000000U1u0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;00N0I00000JsNOk_01228000000U1u0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;j_id0:j_id1:j_id2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,[&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;],&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; id=\&quot;j_id0:j_id1:dependentPicklistListFieldName\&quot; name=\&quot;j_id0:j_id1:dependentPicklistListFieldName\&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说每次点击父的值情况下，js会动态通过当前的父的值获取子内容，通过解析页面方式无法获取其真实的依赖关系，所以此种方式弃用了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二.使用PicklistEntry方式&lt;/strong&gt;&lt;span&gt;（正确方式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;此部分内容参考内容：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://developer.salesforce.com/docs/atlas.en-us.api.meta/api/sforce_api_calls_describesobjects_describesobjectresult.htm&quot; target=&quot;_blank&quot;&gt;https://developer.salesforce.com/docs/atlas.en-us.api.meta/api/sforce_api_calls_describesobjects_describesobjectresult.htm&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.salesforce.com/docs/atlas.en-us.api.meta/api/sforce_api_calls_describesobjects_describesobjectresult.htm&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span&gt;http://mysalesforceescapade.blogspot.com/2015/03/getting-dependent-picklist-values-from.html&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个Picklist的Dependence肯定是以某种方式存储在MetaData中的，即使官方的API没有提供可以直接调用的方法获取到Dependence关系，肯定某个属性中也存储了这种关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过第一个链接可以发现，PicklistEntry的validFor属性中存储了两者的关系，对于PicklistEntry来说，每一个Denpendence Picklist 的Value代表一个PicklistEntry。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一个validFor属性存储了一组的Bits,每个bit对应着一个Control Field Picklist Value。官方的描述为 A set of bits where each bit indicates a controlling value for which this &lt;span class=&quot;keyword parmname&quot;&gt;PicklistEntry is valid。validFor在java中返回类型为byte[]，因为salesforce中没有byte这个基本类型，我们可以通过byte的性质，或者直接看byte在java中的定义，模拟出byte的Wrapper使用，官方给了一个java版的获取方式，下面的链接为国外一个大牛写的demo可以获取到Picklist中的Dependence关系，内容和java版的获取方式相差不大，区别为自己封装了一个Byte类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;keyword parmname&quot;&gt;代码测试：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
System.debug(LoggingLevel.INFO, '*** : ' + JSON.serialize(&lt;span&gt;new&lt;/span&gt; PicklistFieldController().getDependentOptionsImpl('Goods__c','TestP1__c','TestP2__c')));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180406212728313-1364427327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;在Apex Class中获取Picklist间的级联关系，主要是通过PicklistEntry中的隐藏属性validFor获取其中的关系，并对返回的byte[]数组进行解析找到其对应的control的关系。篇中有错误地方欢迎指出，不懂的欢迎留言。&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 13:39:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/8728550.html</dc:identifier>
</item>
<item>
<title>移动端H5活动页优化方案 - liuyongjia</title>
<link>http://www.cnblogs.com/liuyongjia/p/8728900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyongjia/p/8728900.html</guid>
<description>&lt;p&gt;&lt;strong&gt;项目&lt;/strong&gt;：移动端H5电商项目&lt;br/&gt;&lt;strong&gt;痛点&lt;/strong&gt;：慢！！！&lt;br/&gt;&lt;strong&gt;初始方案&lt;/strong&gt;：最基本的图片懒加载，静态资源放到cdn，predns等等已经都做了。但是还是慢，慢在哪？&lt;br/&gt;&lt;strong&gt;显而易见的原因&lt;/strong&gt;：由于前后端分离，所有的数据都由接口下发，之后根据模板渲染页面。也就是说，我们需要先加载js，等到js加载完毕之后，请求接口，接口返回数据之后，渲染页面，加载图片等等。尽管使用了模块化的加载方式，但是对于要求高的首页和活动页，给用户的感知也不是很好。&lt;/p&gt;

&lt;p&gt;最初，由于时间紧迫，基本上都是从客户端作优化处理，基本上可以总结为以下几个方面。&lt;/p&gt;
&lt;h3 id=&quot;一本地缓存&quot;&gt;一、本地缓存&lt;/h3&gt;
&lt;p&gt;我们做了本地缓存优化的策略，第一次请求之后就把接口数据缓存到localStorage里面，并且存储当时的时间，设定过期时间，一般设置为5分钟，用户在5分钟内重复打开页面，不会再次请求接口，从localstorage中拿取数据，直接渲染页面。&lt;br/&gt;后续干脆把模板渲染好的html片段存储了起来，直接拼接，省去了模板计算的时间。&lt;br/&gt;基本实现方案如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; 
    cache &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;localStorage&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getItem&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'cache'&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; expires &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 判断是否过期&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;isOverdue&lt;/span&gt;(pastTime&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; expires) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Date&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;now&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; pasttime &lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt; expires&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (cache &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;isOverdue&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;cache&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; expires)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 说明缓存存在，并且没有过期&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 就正常取cache.data做相应的渲染&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 说明缓存不存在或者已经过期了&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 重新请求接口&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'a.cn'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;funciton&lt;/span&gt; (res) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// do something&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 把对应的渲染操作处理完成之后，将数据缓存，并记录当前的时间&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;localStorage&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setItem&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'cache'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; res&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Date&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;now&lt;/span&gt;()
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而还是不够，新用户在首次打开时，还是不能秒开页面，并且用户在5分钟之后重新加载之时，仍然会有一定的延迟（由于浏览器会缓存一部分静态资源，此时再打开并不会像用户初次打开一样那么慢）。&lt;/p&gt;
&lt;h2 id=&quot;二进一步缓存静态资源&quot;&gt;二、进一步缓存静态资源&lt;/h2&gt;
&lt;p&gt;在日常开发中，有很多依赖库，常用的fastclick，swipe等等，这些库，没有必要每次都去加载，虽然浏览器会对一些静态资源做缓存，但是却不能完全被我们控制，所以，可以将这些不常发生变化的静态资源缓存起来，同样的，存到localStorage里面。&lt;/p&gt;
&lt;h3 id=&quot;需要注意&quot;&gt;需要注意&lt;/h3&gt;
&lt;p&gt;这个方案有一个问题，如果是直接加载的script标签，是无法直接拿到它的脚本内容的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;script1&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;js/jquery.js&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;querySelector&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'#script1'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;innerHTML&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 此时输出的是undefined，因为innerHTML是获取标签内容，此时script标签里并没有内容。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;script2&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'2'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;querySelector&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'#script2'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;innerHTML&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 此时输出的是console.log('2');&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 因为innerHTML是获取标签内容，此时script标签里并没有内容。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这当然不是我们想要的，我们需要的是外链js的可执行代码。&lt;/p&gt;
&lt;h3 id=&quot;动态添加js的两种方案&quot;&gt;动态添加js的两种方案&lt;/h3&gt;
&lt;p&gt;我在前一篇&lt;a href=&quot;http://www.cnblogs.com/liuyongjia/p/8502576.html&quot;&gt;高性能JavaScript读书笔记&lt;/a&gt;中提到了两种方案。&lt;/p&gt;
&lt;h4 id=&quot;动态脚本元素&quot;&gt;1. 动态脚本元素&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; script &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'script'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;script&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'text/javascript'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;script&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// do something&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;script&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'jquery.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'heda'&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].&lt;span class=&quot;at&quot;&gt;appendChild&lt;/span&gt;(script)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方法可以监控到脚本的完成事件，但是由于也是通过添加一个script标签，并不能拿到我们想要的js代码。&lt;/p&gt;
&lt;h4 id=&quot;通过xmlhttprequest脚本注入&quot;&gt;2. 通过XMLHttPRequest脚本注入&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; xhr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;XMLHttpRequest&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;get&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;file1.js&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onreadystatechange&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readyState&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;300&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;304&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;localStorage&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setItem&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'file1'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;xhr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;responseText&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;需要特别注意的是，这个方法有跨域的风险，所以，我们需要静态资源服务器的allow-origin设置为*。或者直接加载本域名下的js。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有同学要问了，既然localStorage这么强大，为什么不把所有的东西都缓存起来呢？&lt;br/&gt;当然是因为它的大小有限制，在FireFox和chrome中，一般来说，sessionStorage和localStorage大小为10MB，而safari只有5MB。详见&lt;a href=&quot;https://www.html5rocks.com/en/tutorials/offline/quota-research/&quot;&gt;这篇文章&lt;/a&gt;。&lt;br/&gt;这就限制了我们什么都存的想法。如果图片较小，可以缓存起来。&lt;/p&gt;

&lt;p&gt;在前一版方案里，我们解决了后续加载的速度缓慢问题，在后续的页面打开速度上，基本上可以做到秒开。&lt;br/&gt;但是这个方案还是有不足，对于新用户的体验不是很好，如果用户在5min的这个时间点上打开，速度还是会有所下降。&lt;br/&gt;最后还是只能做SSR。&lt;br/&gt;知乎上有一个问题，&lt;a href=&quot;https://www.zhihu.com/question/59578433/answer/326694511&quot;&gt;为什么现在又流行服务端渲染html？&lt;/a&gt;。&lt;br/&gt;服务端渲染有很多好处，对我们此时而言，最大的好处就是页面直出。省去了请求接口这一步操作。并且对于提高用户体验上来说，很有好处。&lt;br/&gt;如果时间充裕，可以使用node做服务端，但是由于历史原因，我们这个项目迁移起来也比较费时间，所以最后决定使用openresty来做。&lt;br/&gt;openResty的教程网上很多了，我也不多说，除了&lt;a href=&quot;https://github.com/openresty&quot;&gt;官方git&lt;/a&gt;，推荐&lt;a href=&quot;http://jinnianshilongnian.iteye.com/category/333854&quot;&gt;开涛博客&lt;/a&gt;学习。&lt;/p&gt;
&lt;p&gt;不论我们是在客户端取接口数据，还是服务端，活动页的数据一般来说都有一定持续时长，也就是说，我们也可以在我们的nginx服务器上做一个缓存，假设有一个用户访问了一个活动，那么在接下来的五分钟之内，其他任何用户（相同权限下）访问到的就是第一个用户访问时缓存好的页面。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode lua&quot;&gt;
&lt;code class=&quot;sourceCode lua&quot;&gt;&lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; args &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;req&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;get_uri_args&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; acId &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; args&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'acId'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; key &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'ac'&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;..&lt;/span&gt; acId
&lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; expire &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;--缓存时间5分钟&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; value &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; dict&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;getData&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; expire&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;not&lt;/span&gt; value &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;local&lt;/span&gt; res &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;location&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;capture&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/a.json'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; res&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;status &lt;span class=&quot;ot&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- dict是一个用来处理存储和读取逻辑的脚本&lt;/span&gt;
        dict&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;setData&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;body&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
        ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;say&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;dict&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;getData&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;ot&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;--  ngx.log(4, type(value))&lt;/span&gt;
    ngx&lt;span class=&quot;ot&quot;&gt;.&lt;/span&gt;say&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在dict中，我们可以把接口数据转换成通过模板转换为html片段存储起来。这样，用户在第一次进入我们的页面以后，也不会感觉慢了。&lt;/p&gt;

&lt;p&gt;openResty能做的事不仅仅是这些，一些网关上权限的控制等等都可以用它来实现。&lt;br/&gt;上面两个方案还有一些不足之处，比如首屏可能内容比较多，一次都加载过来，不一定会快。直观的首屏的由服务端渲染，对于不重要的内容，可以通过AJAX来异步加载。&lt;br/&gt;如何计算活动页这样的页面中，首屏有多大，如何组织代码，哪些部分采用服务端渲染，哪些采用AJAX。这些问题在实际开发中也需要考虑。&lt;br/&gt;限于时间，此次没有能比较完善的解决这个问题，在日后开发中，还会继续完善活动页优化方案。&lt;/p&gt;
</description>
<pubDate>Fri, 06 Apr 2018 13:06:00 +0000</pubDate>
<dc:creator>liuyongjia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyongjia/p/8728900.html</dc:identifier>
</item>
<item>
<title>Java 持久化操作之 --io流与序列化 - 房上的猫</title>
<link>http://www.cnblogs.com/lsy131479/p/8728724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsy131479/p/8728724.html</guid>
<description>&lt;p&gt;1)File类操作文件的属性&lt;/p&gt;
&lt;p&gt;1.File类的常用方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406193059790-1227942159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;文件的绝对完整路径：getAbsolutePath()&lt;/p&gt;
&lt;p&gt;文件名：getName()&lt;/p&gt;
&lt;p&gt;文件相对路径：getPath()&lt;/p&gt;
&lt;p&gt;文件的上一级目录：getParent()&lt;/p&gt;
&lt;p&gt;文件的大小为：length()&lt;/p&gt;
&lt;p&gt;删除文件：delete()&lt;/p&gt;
&lt;p&gt;具体操作请参考如下代码：&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406193529250-1127519151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如何读写文件？&lt;/p&gt;
&lt;p&gt;    分析：流是指一连串流动的字符，是以先进先出方式发送信息的通道&lt;/p&gt;
&lt;p&gt; 输入/输出流于数据源：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406193347488-1484789188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;java流的分类：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;我们可以对它进行如下分类：&lt;/p&gt;
&lt;p&gt;· 按处理的数据类型可分为&lt;strong&gt;字节流&lt;/strong&gt;与&lt;strong&gt;字符流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;· 按流的流向可分为&lt;strong&gt;输入流&lt;/strong&gt;(in)与&lt;strong&gt;输出流&lt;/strong&gt;(out)&lt;/p&gt;
&lt;p&gt;· 按流的功能可分为&lt;strong&gt;节点流&lt;/strong&gt;(Node)和&lt;strong&gt;过滤流&lt;/strong&gt;(Filter)&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;在Java中，字节流一般适用于处理字节数据(诸如图片、视频),字符流适用于处理字符数据(诸如文本文件)，但二者并没有严格的功能划分，因为有转换流的存在，使得对于数据的处理变得更加灵活。&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;1）字节流读写文件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一般用于处理字节数据，但字节流采用ASCII编码的，所以处理字符数据时容易出现中文乱码&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;1. &lt;strong&gt;输入流&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;InputStream：此抽象类是表示字节输入流的所有类的超类（基类）&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;83&quot;&gt;
&lt;p&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;646&quot;&gt;
&lt;p&gt;&lt;strong&gt;方法描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;83&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;646&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final int read(byte[] r, int off, int len)throws IOException&lt;/strong&gt;&lt;br/&gt;从所包含的输入流中将 len 个字节读入一个字节数组中。如果len为-1，则返回已读字节数。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;83&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;646&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Public final int read(byte [] b)throws IOException&lt;/strong&gt;&lt;br/&gt;从所包含的输入流中读取一定数量的字节，并将它们存储到缓冲区数组 b 中。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;83&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;646&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;1. &lt;strong&gt;public final Boolean readBooolean()throws IOException,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;strong&gt;public final byte readByte()throws IOException,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;strong&gt;public final short readShort()throws IOException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;strong&gt;public final Int readInt()throws IOException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从输入流中读取字节，返回输入流中两个字节作为对应的基本数据类型返回值。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;83&quot;&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;646&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public String readLine() throws IOException&lt;/strong&gt;&lt;br/&gt;从输入流中读取下一文本行。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;所有字节输入流都是以此类发散出来的，但此类是一个抽象类，不可被实例化，所以实际编程过程中，都是使用它发散出来的一些子类，下面是输入流的关系图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406194049795-1376978778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入流最常用的就是FileInputStream类：&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1-1 &lt;/strong&gt;&lt;strong&gt;文本文件的读取：用FileInputStream&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;该流用于从文件读取数据，它的对象可以用关键字 new 来创建。&lt;/p&gt;
&lt;p&gt;·有多种构造方法可用来创建对象。&lt;/p&gt;
&lt;p&gt;·可以使用字符串类型的文件名来创建一个输入流对象来读取文件：&lt;/p&gt;
&lt;p&gt;·····InputStream f = new FileInputStream(&quot;C:/java/hello&quot;);&lt;/p&gt;
&lt;p&gt;·也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：&lt;/p&gt;
&lt;p&gt;·····File f = new File(&quot;C:/java/hello&quot;);&lt;/p&gt;
&lt;p&gt;·····InputStream out = new FileInputStream(f);&lt;/p&gt;
&lt;p&gt;·创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。&lt;/p&gt;
&lt;p&gt;    字节流：&lt;/p&gt;
&lt;p&gt;    基类：InputStream     子类：FileInputStream&lt;/p&gt;
&lt;p&gt;    构造：&lt;/p&gt;
&lt;p&gt;    FileInputStream(File file)   ||   FileInputStream(String name)&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406193728403-1850554491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    方法：&lt;/p&gt;
&lt;p&gt;    read() 按字节读    &lt;/p&gt;
&lt;p&gt;    read(byte[] b) 读到字节数组缓冲区，数组存满统一批次循环读取&lt;/p&gt;
&lt;p&gt;    read(byte[] b, int off, int len)  向数组存放时进行了限制，起始位置off和终止位置len&lt;/p&gt;
&lt;p&gt;    int  available()   表示当前还剩多少个字节未读取&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406193739015-574879951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    注意：read方法返回 int 类型 返回读入字节数组的长度，如果读取到文件末尾的时候，则返回-1&lt;/p&gt;
&lt;p&gt;代码演示按字节读取到控制台：&lt;/p&gt;
&lt;p&gt;    四步走：1.导入相关类   2.创建字节流对象   3.实现读取文本文件的数据   4.关闭文件流对象&lt;/p&gt;
&lt;p&gt;    测试文档：&lt;/p&gt;
&lt;p&gt;    使用Read（）读取&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;废话不多说 举个栗子：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package text;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.FileInputStream;
public class FileInputStream01 {
    public static void main(String[] args) {
        //创建字节流对象
        InputStream fls=null;
        try {
            fls=new FileInputStream(&quot;D://TextFile//A.txt&quot;);
            //实现读取操作
            int data;//存储读取的字节
            while((data=fls.read())!=-1)
            {
                //System.out.print(data);//读取的是数字
                System.out.print((char)data);//读取的是和文件一致
            }
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }finally
        {
            try {
                if(fls!=null)
                fls.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改代码使用Read（byte[] b）读取&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
int len;//存储读入数组的长度
byte[] wrods=new byte[1024];
while((len=fls.read(wrods))!=-1)
{
    System.out.print(new String(wrods,0,len));//String构造方法 把字节byte[] 转换成字符串形式，0代表截取起始位置，len表示截取终止位置
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果与上述一致：&lt;/p&gt;

&lt;h4&gt;1. &lt;strong&gt;输出流&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;OutputStream：此抽象类是表示字节输出流的所有类的超类（基类）&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;71&quot;&gt;
&lt;p&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;658&quot;&gt;
&lt;p&gt;&lt;strong&gt;方法描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;71&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;658&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final void write(byte[] w, int off, int len)throws IOException&lt;/strong&gt;&lt;br/&gt;将指定字节数组中从偏移量 off 开始的 len 个字节写入此字节数组输出流。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;71&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;658&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Public final int write(byte [] b)throws IOException&lt;/strong&gt;&lt;br/&gt;将指定的字节写入此字节数组输出流。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;71&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;658&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;1. &lt;strong&gt;public final void writeBooolean()throws IOException,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;strong&gt;public final void writeByte()throws IOException,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;strong&gt;public final void writeShort()throws IOException,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;strong&gt;public final void writeInt()throws IOException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些方法将指定的基本数据类型以字节的方式写入到输出流。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;71&quot;&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;658&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Public void flush()throws IOException&lt;/strong&gt;&lt;br/&gt;  刷新此输出流并强制写出所有缓冲的输出字节。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;71&quot;&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;658&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final void writeBytes(String s) throws IOException&lt;/strong&gt;&lt;br/&gt;将字符串以字节序列写入到底层的输出流，字符串中每个字符都按顺序写入，并丢弃其高八位。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所有字节输出流都是以此类发散出来的，但此类是一个抽象类，不可被实例化，所以实际编程过程中，都是使用它发散出来的一些子类，下面是输出流的关系图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406194223556-1821814761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;输出流最常用的就是FileOutputStream 类：&lt;/p&gt;
&lt;h3&gt;1-2文本文件的写入：用FileOutputStream &lt;/h3&gt;
&lt;p&gt;该类用来创建一个文件并向文件中写数据。&lt;/p&gt;
&lt;p&gt;如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。&lt;/p&gt;
&lt;p&gt;有两个构造方法可以用来创建 FileOutputStream 对象。&lt;/p&gt;
&lt;p&gt;使用字符串类型的文件名来创建一个输出流对象：&lt;/p&gt;
&lt;p&gt;OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;)&lt;/p&gt;
&lt;p&gt;也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：&lt;/p&gt;
&lt;p&gt;File f = new File(&quot;C:/java/hello&quot;);&lt;/p&gt;
&lt;p&gt;OutputStream f = new FileOutputStream(f);&lt;/p&gt;
&lt;p&gt;    输出流：&lt;/p&gt;
&lt;p&gt;    基类：OutputStream&lt;/p&gt;
&lt;p&gt;    子类：FileOutputStream  ..............&lt;/p&gt;
&lt;p&gt;    构造:&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406194402310-1992389369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406194412546-408142395.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;   &lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;废话不多说 举个栗子：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;1-3文件读取和写入同步&lt;/h3&gt;
&lt;p&gt;   &lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;废话不多说 举个栗子：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2）字符流读和缓冲流读文件&lt;/h2&gt;
&lt;p&gt;    用BufferedReader 和 BufferedWriter读写文本文件//字符流&lt;/p&gt;
&lt;p&gt;    或 FileReader&lt;/p&gt;
&lt;p&gt;    字符编码：ASCII码   0~127  8位二进制数1个字节。  16位二进制数表示一个字符 两个字节&lt;/p&gt;
&lt;p&gt;    字符流：输入流&lt;/p&gt;
&lt;p&gt;    基类：Reader----FileReader&lt;/p&gt;
&lt;p&gt;                &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406194629194-1775966264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    构造：&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406194638265-178650738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    常用方法：&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406194648977-743176976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1）如果 使用字节流读取带有汉字的文件会怎么样那&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package text;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.FileInputStream;
public class FileInputStream01 {
    public static void main(String[] args) {
        //创建字节流对象
        InputStream fls=null;
        try {
            fls=new FileInputStream(&quot;D://TextFile//A.txt&quot;);
            //实现读取操作
            int data;//存储读取的字节
            while((data=fls.read())!=-1)
            {
                //System.out.print(data);//读取的是数字
                //System.out.println(&quot;还剩：&quot;+fls.available()+&quot;字节未读取&quot;);            
                System.out.print((char)data);
            }
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }finally
        {
            try {
                if(fls!=null)
                fls.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406194740070-386735233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;很明显出现了乱码&lt;/p&gt;
&lt;h3&gt;2）下面使用FileReader字符流 Read（）读取文件，示例如下&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package text;
/**
 * 使用字符流读取文本文件
 *&amp;lt;p&amp;gt;Title:FileReaderDemo&amp;lt;/p&amp;gt;
 *&amp;lt;p&amp;gt;Description:&amp;lt;/p&amp;gt;
 *&amp;lt;p&amp;gt;Company:&amp;lt;/p&amp;gt;
 * @author MLQ
 * @date 2018年3月7日 下午12:38:35
 */
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;

public class FileReaderDemo {
    public static void main(String[] args) {
        //创建一个字符流对象
        Reader rd=null;
        try {
            rd=new FileReader(&quot;D://TextFile//A.txt&quot;);
            int word;//就收读取的字符
            while((word=rd.read())!=-1)
            {
                System.out.print((char)word);
            }
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }finally
        {
            if(rd!=null)
            {
                try {
                    rd.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果你会发现，乱码消失了&lt;/p&gt;

&lt;h3&gt;3）下面使用FileReader字符流 Read（char[] b）读取文件，示例如下&lt;/h3&gt;
&lt;p&gt;      修改代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
package text;
/**
 * 使用字符流读取文本文件
 *&amp;lt;p&amp;gt;Title:FileReaderDemo&amp;lt;/p&amp;gt;
 *&amp;lt;p&amp;gt;Description:&amp;lt;/p&amp;gt;
 *&amp;lt;p&amp;gt;Company:&amp;lt;/p&amp;gt;
 * @author MLQ
 * @date 2018年3月7日 下午12:38:35
 */
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;

public class FileReaderDemo {
    public static void main(String[] args) {
        //创建一个字符流对象
        Reader rd=null;
        StringBuffer sb=new StringBuffer();
        try {
            rd=new FileReader(&quot;D://TextFile//A.txt&quot;);
            int word;//就收读取的字符
            char[] ch=new char[1024];
            while((word=rd.read(ch))!=-1)
            {
                sb.append(ch,0,word);
            }
            System.out.println(sb.toString());
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }finally
        {
            if(rd!=null)
            {
                try {
                    rd.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406194923321-221231494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;温馨提示：如果上述的代码 sb.append(ch,0,word)  只写数组的话，会把空格也会追加到 StringBuffer。读取文&lt;/p&gt;
&lt;p&gt;                  件的时候最后可能没有写满数组&lt;/p&gt;

&lt;h3&gt;4)使用BufferedReader读取文本文件&lt;/h3&gt;
&lt;p&gt;（增强）&lt;/p&gt;
&lt;p&gt;    BufferedReader类是Reader类的子类&lt;/p&gt;
&lt;p&gt;    bufferedReader类带有缓冲区&lt;/p&gt;
&lt;p&gt;    按行读取内容的ReadLine（）方法&lt;/p&gt;
&lt;p&gt;    实现步骤：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406194958275-799704509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    构造：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195010135-1784409823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    方法：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195016916-584462374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;演示代码如下：&lt;/p&gt;


&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195046429-1918400862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3/&gt;
&lt;h2&gt;3）字符流读和缓冲流写文件&lt;/h2&gt;
&lt;p&gt;    基类：Write    子类：FileWrite&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195057877-2022984128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    构造：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195105564-1112757633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    方法：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195112836-1101396510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;演示代码如下：&lt;/p&gt;
&lt;h4&gt;3-1）使用FileWrite字符流写入文档&lt;/h4&gt;

&lt;h4&gt;3-2）使用BufferedWrite字符流写入文件&lt;/h4&gt;
&lt;p&gt;        如何提高字符流写文本文件的效率？&lt;/p&gt;
&lt;p&gt;        解：使用FileWrite类与BufferReader类&lt;/p&gt;
&lt;p&gt;        BufferedWrite类是Write类的子类&lt;/p&gt;
&lt;p&gt;        BufferedWrite类带有缓冲区&lt;/p&gt;
&lt;p&gt;        步骤：&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195145067-96839775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    构造：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195154692-1368594728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    方法：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195201452-1614596464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;代码演示如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package text;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;

public class BufferedWrite01 {
    public static void main(String[] args) {
        //创建FileWrite 和 BufferedWrite 对象
        Writer wd=null;
        BufferedWriter bw=null;
        //创建FileReader  和 BufferedReader  对象
        Reader ed=null;
        BufferedReader br=null;
        try {
            wd=new FileWriter(&quot;D:\\TextFile\\A.txt&quot;);
            bw=new BufferedWriter(wd);
            bw.write(&quot;我是测试员&quot;);
            bw.newLine();//换行符方法
            bw.write(&quot;负责测试程序运行问题&quot;);
            bw.flush();
            System.out.println(&quot;成功写入&quot;);
            //读取文本文件信息
            ed=new FileReader(&quot;D:\\TextFile\\A.txt&quot;);
            br=new BufferedReader(ed);
            String word=null;
            while((word=br.readLine())!=null)
            {
                System.out.println(word);
            }
            
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        finally
        {
            if(wd!=null){
                try {
                    wd.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            if(bw!=null){
                try {
                    bw.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            if(ed!=null){
                try {
                    ed.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            if(bw!=null){
                try {
                    bw.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4）使用数据流读写文件&lt;/h2&gt;
&lt;p&gt;    二进制文件读写：&lt;/p&gt;
&lt;p&gt;    使用DataInputStream  和  DataOutputStream 读写二进制文件  //属于字节流&lt;/p&gt;
&lt;p&gt;    DataInputStream  类：&lt;/p&gt;
&lt;p&gt;        FileInputStream的子类&lt;/p&gt;
&lt;p&gt;        与FileInputStream类结合使用读取二进制文件&lt;/p&gt;
&lt;p&gt;    DataOutputStream 类：&lt;/p&gt;
&lt;p&gt;        FileOutputStream的子类&lt;/p&gt;
&lt;p&gt;        与FileOutputStream类结合使用写二进制文件&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195240371-553360817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;DataOutputStream:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195251769-1972013454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195300090-534681838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;演示代码如下：&lt;/p&gt;
&lt;p&gt;实现步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195324516-1594004863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package text;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
@SuppressWarnings(&quot;unused&quot;)
public class DataInOutStream {
    @SuppressWarnings(&quot;resource&quot;)
    public static void main(String[] args)throws Exception {
        DataInputStream di=null;
        DataOutputStream ds=null;
        di=new DataInputStream(new FileInputStream(&quot;D://TextFile//dd.class&quot;));
        ds=new DataOutputStream(new FileOutputStream(&quot;D://TextFile//coty.class&quot;));
        int len;//接收读取的字节
        while((len=di.read())!=-1)
        {
            ds.write(len);
        }
        System.out.println(&quot;执行完毕&quot;);
        if(di!=null)
        di.close();
        ds.close();
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;    序列化和反序列化的过程&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195347905-323627294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;序列化的步骤：&lt;/p&gt;
&lt;p&gt;    1.实现 Serializable 接口&lt;/p&gt;
&lt;p&gt;    2.创建对象输出流&lt;/p&gt;
&lt;p&gt;    3.调用 writeObject()方法将对象写入文件&lt;/p&gt;
&lt;p&gt;    4.关闭对象输出流&lt;/p&gt;
&lt;p&gt;    使用集合保存对象，可以将集合中的所有对象序列化&lt;/p&gt;
&lt;p&gt;    序列化构造和常用方法   &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195414631-1681520869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195428849-683344318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;反序列化构造和常用方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195436144-369534116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195443115-867451902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;    实现序列化 和 反序列化 演示代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_c5b1fbfa-a887-4b2d-b2f0-1f02cc88762a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c5b1fbfa-a887-4b2d-b2f0-1f02cc88762a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c5b1fbfa-a887-4b2d-b2f0-1f02cc88762a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
package text;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
public class TextStudent {
    @SuppressWarnings(&quot;unchecked&quot;)
    public static void main(String[] args) {
        //创建序列化对象
        ObjectOutputStream xl=null;
        //创建反序列化对象
        ObjectInputStream xl1=null;
        //初始化要序列化的对象
        Map&amp;lt;String,Student&amp;gt; map=new HashMap&amp;lt;String,Student&amp;gt;();
        Map&amp;lt;String,Student&amp;gt; map1=new HashMap&amp;lt;String,Student&amp;gt;();
        Student stu=new Student(&quot;小明&quot;,18,&quot;男&quot;);
        Student stu1=new Student(&quot;小红&quot;,18,&quot;女&quot;);
        map.put(stu.getName(), stu);
        map.put(stu1.getName(), stu1);
        try {
            xl=new ObjectOutputStream(new FileOutputStream(&quot;D://TextFile//xuliehua.bin&quot;));
            xl1=new ObjectInputStream(new FileInputStream(&quot;D://TextFile//xuliehua.bin&quot;));
            xl.writeObject(map);
            System.out.println(&quot;写入成功&quot;);
            //反序列化文件输出到控制台
            map1=(Map&amp;lt;String,Student&amp;gt;)xl1.readObject();
            Set&amp;lt;String&amp;gt; key=map1.keySet();
            Iterator&amp;lt;String&amp;gt; l=key.iterator();
            while(l.hasNext())
            {
                String keys=l.next();
                map1.get(keys).show();
            }
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        finally
        {
            if(xl!=null){
                try {
                    xl.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                e.printStackTrace();
                }
            }
            if(xl1!=null)
            {
                try {
                    xl1.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }

    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;测试类&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;提示：如果不希望Student类某一属性被序列化可使用 transient 修饰&lt;/p&gt;

&lt;p&gt; biu ～biu ～ biu ～  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：最后在提一句：使用序列化操作时，一定要将准备序列化的类或数据声明为可序列化操作！！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180406195834349-1733309474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 06 Apr 2018 12:14:00 +0000</pubDate>
<dc:creator>房上的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsy131479/p/8728724.html</dc:identifier>
</item>
<item>
<title>python全栈开发-logging模块(日记专用) - 天王盖地虎宝塔镇河妖</title>
<link>http://www.cnblogs.com/ManyQian/p/8728558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManyQian/p/8728558.html</guid>
<description>&lt;h2&gt;一、概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　很多程序都有记录日志的需求，并且日志中包含的信息即有正常的程序访问日志，还可能有错误、警告等信息输出，python的logging模块提供了标准的日志接口，你可以通过它存储各种格式的日志，logging的日志可以分为 &lt;code class=&quot;xref py py-func docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;debug()&lt;/span&gt;&lt;/code&gt;, &lt;code class=&quot;xref py py-func docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;info()&lt;/span&gt;&lt;/code&gt;, &lt;code class=&quot;xref py py-func docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;warning()&lt;/span&gt;&lt;/code&gt;, &lt;code class=&quot;xref py py-func docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;error()&lt;/span&gt;&lt;/code&gt; and &lt;code class=&quot;xref py py-func docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;critical() 5个级别，其中他们级别大小关系&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;xref py py-func docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;&lt;strong&gt;&lt;code class=&quot;xref py py-func docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;debug() &amp;lt;&lt;/span&gt;&lt;/code&gt;&lt;code class=&quot;xref py py-func docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;info() &lt;/span&gt;&lt;/code&gt;&amp;lt;&lt;code class=&quot;xref py py-func docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;warning() &lt;/span&gt;&lt;/code&gt;&amp;lt;&lt;code class=&quot;xref py py-func docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;error() &lt;/span&gt;&lt;/code&gt;&amp;lt;&lt;code class=&quot;xref py py-func docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;critical()  级别越低打印的日记等级就越多&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面我们看一下他是怎样的用法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二、了解用法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、最简单的用法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging

logging.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logging debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logging info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user [qianduoduo] attempted wrong password more than 3 times&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logging error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.critical(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logging critical&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出&lt;/span&gt;
WARNING:root:user [qianduoduo] attempted wrong password more than 3&lt;span&gt; times
ERROR:root:logging error
CRITICAL:root:logging critical  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;root  就是默认的用户名&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;重点：为什么上面debug和info没有输出，那是因为一个模块默认的日志级别是warning，比他级别低的就不会输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、日志级别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看一下这几个日志级别分别代表什么意思，如表：&lt;/strong&gt;&lt;/p&gt;
&lt;table class=&quot;docutils&quot; border=&quot;1&quot;&gt;&lt;colgroup data-filtered=&quot;filtered&quot;&gt;&lt;col width=&quot;24%&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;col width=&quot;76%&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/colgroup&gt;&lt;thead valign=&quot;bottom&quot;&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;th class=&quot;head&quot;&gt;Level&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;When it’s used&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;row-even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;DEBUG&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;详细的信息，通常只有在诊断问题时才感兴趣。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;INFO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;确认事情按预期工作。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;WARNING&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;3-0&quot; data-section=&quot;3&quot; data-sentence=&quot;0&quot;&gt;表明发生了意外的事情，或预示在不久的将来会出现一些问题(例如“磁盘空间低”)。&lt;span class=&quot;tgt&quot; data-group=&quot;3-1&quot; data-section=&quot;3&quot; data-sentence=&quot;1&quot;&gt;该软件仍按预期运行。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;ERROR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;由于一个更严重的问题，软件无法执行某些功能。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;CRITICAL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;一个严重的错误，表明程序本身可能无法继续运行。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;3、将日记写入文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging

logging.basicConfig(filename&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;duoduo.log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,level=&lt;span&gt;logging.INFO)
logging.debug(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;This message should go to the log file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logging.info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;So should this&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) logging.warning(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;And this, too&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logging.warning(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;And this, too&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;‘duoduo.log’文件输出&lt;/span&gt;
&lt;span&gt;INFO:root:So should this
WARNING:root:And this, too   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这日记的级别设置在info，所以比他更低的debug不显示&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重点： 如果我们想显示所有级别的日记就要把日记的等级设置为debug,就在level=logging.DEBUG，设置是级别的名称要大写&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、加入日期格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　感觉上面的日志格式忘记加上时间啦，日志不知道时间怎么行呢，下面就来加上&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging

logging.basicConfig(filename&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;duoduo.log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    level&lt;/span&gt;=&lt;span&gt;logging.DEBUG,
                    format&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%(asctime)s %(message)s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;#&lt;/span&gt;&lt;span&gt;asctime字符串形式的当前时间，message用户输出的消息&lt;/span&gt;
                    datefmt=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %I:%M:%S %p &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logging.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logging debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logging info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user [qianduoduo] attempted wrong password more than 3 times&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logging error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logging.critical(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logging critical&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出到文件‘duoduo.log’&lt;/span&gt;
2018-01-27 07:33:30&lt;span&gt; PM  logging debug
&lt;/span&gt;2018-01-27 07:33:30&lt;span&gt; PM  logging info
&lt;/span&gt;2018-01-27 07:33:30 PM  user [qianduoduo] attempted wrong password more than 3&lt;span&gt; times
&lt;/span&gt;2018-01-27 07:33:30&lt;span&gt; PM  logging error
&lt;/span&gt;2018-01-27 07:33:30 PM  logging critical
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5、 format的日志格式&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr&gt;&lt;td&gt;

&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;strong&gt;Logger的名字&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(levelno)s&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;数字形式的日志级别&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(levelname)s&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;文本形式的日志级别&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(pathname)s&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;调用日志输出函数的模块的完整路径名，可能没有&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(filename)s&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;调用日志输出函数的模块的文件名&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(module)s&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;调用日志输出函数的模块名&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(funcName)s&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;调用日志输出函数的函数名&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(lineno)d&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;调用日志输出函数的语句所在的代码行&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(created)f&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;当前时间，用UNIX标准的表示时间的浮 点数表示&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(relativeCreated)d&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;输出日志信息时的，自Logger创建以 来的毫秒数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(asctime)s&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(thread)d&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;strong&gt;线程ID。可能没有&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(threadName)s&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;strong&gt;线程名。可能没有&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(process)d&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;strong&gt;进程ID。可能没有&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;%(message)s&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;strong&gt;用户输出的消息&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;三、log的用法，大约了解这个操作步骤&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果想同时把log打印在屏幕和文件日志里，就需要了解一点复杂的知识 了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python 使用logging模块记录日志涉及四个主要类，使用官方文档中的概括最为合适：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、logger提供了应用程序可以直接使用的接口；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、handler将(logger创建的)日志记录发送到合适的目的输出；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、filter提供了细度设备来决定输出哪条日志记录；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、formatter决定日志记录的最终输出格式。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）、logger&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①每个程序在输出信息之前都需要获得一个logger。logger通常对应了程序的模块名，比如聊天工具的图形界面模块可以这样获得它的logger：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_596465&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;logger &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;logging.getLogger(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;chat.gui&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;核心模块可以这样写：(自己想叫什么名称就叫什么名称)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_624521&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;logger &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;logging.getLogger(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;chat.kernel&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;②logger.setLevel(lel)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：指定最低的日志级别，低于lel的级别将被忽略(debug是最低的内置级别，critical为最高)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_743411&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;logger.setLevel(logging.DEBUG)  &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;③Logger.addFilter(filt)、Logger.removeFilter(filt)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：添加或删除指定的filter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;④logger.addHandler(hdlr)、logger.removeHandler(hdlr)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：增加或删除指定的handler&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_635795&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;logger.addHandler(ch)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;logger.removeHandler(ch) &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;⑤Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：可以设置的日志级别&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_335085&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;logger.debug(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'debug message'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;logger.info(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'info message'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;logger.warn(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'warn message'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;logger.error(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'error message'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;logger.critical(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'critical message'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;⑥获取handler个数&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_551504&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;div id=&quot;highlighter_551504&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_551504&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;handler_len &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python functions&quot;&gt;len&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(logger.handlers)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python functions&quot;&gt;print&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;(handler_len)&lt;/code&gt;&lt;/p&gt;


&lt;p&gt;&lt;code class=&quot;python value&quot;&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）、handler&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　handler对象负责发送相关的信息到指定目的地。Python的日志系统有多种Handler可以使用。有些Handler可以把信息输出到控制台，有些Logger可以把信息输出到文件，还有些 Handler可以把信息发送到网络上。如果觉得不够用，还可以编写自己的Handler。可以通过addHandler()方法添加多个多handler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①Handler.setLevel(lel)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：指定被处理的信息级别，低于lel级别的信息将被忽略。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_730642&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;ch &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;logging.StreamHandler()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;ch.setLevel(logging.DEBUG)&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;②Handler.setFormatter()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：给这个handler选择一个格式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_809610&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;ch_formatter &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;logging.Formatter(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;) &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;ch.setFormatter(ch_formatter) &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;③Handler.addFilter(filt)、Handler.removeFilter(filt)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：新增或删除一个filter对象&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;四、handler详解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、logging.StreamHandler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：使用这个Handler可以向类似与sys.stdout或者sys.stderr的任何文件对象(file object)输出信息，也就是屏幕输出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它的构造函数是：StreamHandler([strm])，其中strm参数是一个文件对象，默认是sys.stderr。具体用法看下面代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging
logger &lt;/span&gt;= logging.getLogger(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEST-LOG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logger.setLevel(logging.DEBUG)
  
ch &lt;/span&gt;= logging.StreamHandler() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个StreamHandler对象&lt;/span&gt;
ch.setLevel(logging.DEBUG) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置输出StreamHandler日志级别&lt;/span&gt;
&lt;span&gt;
ch_formatter &lt;/span&gt;= logging.Formatter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%(asctime)s - %(name)s - %(levelname)s - %(message)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;格式&lt;/span&gt;
ch.setFormatter(ch_formatter)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;传入格式参数&lt;/span&gt;
logger.addHandler(ch)       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;增加handler&lt;/span&gt;
&lt;span&gt;

logger.info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logger.warn(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;warn message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logger.error(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logger.critical(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;critical message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2018-01-28 21:15:02,112 - TEST-LOG - INFO - info message&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2018-01-28 21:15:02,112 - TEST-LOG - WARNING - warn message&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2018-01-28 21:15:02,112 - TEST-LOG - ERROR - error message&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2018-01-28 21:15:02,112 - TEST-LOG - CRITICAL - critical message&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、logging.FileHandler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：和StreamHandler类似，用于向一个文件输出日志信息，不过FileHandler会帮你打开这个文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它的构造函数是：FileHandler(filename[,mode])。filename是文件名，必须指定一个文件名。mode是文件的打开方式。参见Python内置函数open()的用法。默认是’a'，即添加到文件末尾。用法看下面代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;create logging&lt;/span&gt;
logger = logging.getLogger(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEST-LOG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logger.setLevel(logging.DEBUG)

fh &lt;/span&gt;= logging.FileHandler(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;日志输出到debug.log文件中&lt;/span&gt;
fh.setLevel(logging.INFO) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置FileHandler日志级别&lt;/span&gt;
&lt;span&gt; 
fh_formatter &lt;/span&gt;= logging.Formatter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%(asctime)s %(module)s:%(levelname)s %(message)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
 
fh.setFormatter(fh_formatter)
 
logger.addHandler(fh)
  
logger.info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logger.warning(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;warning message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logger.error(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logger.critical(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;critical message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;文件debug.log里的输出：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2018-01-28 21:19:45,221 logging文件输出:INFO info message&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2018-01-28 21:19:45,221 logging文件输出:WARNING warning message&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2018-01-28 21:19:45,221 logging文件输出:ERROR error message&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2018-01-28 21:19:45,221 logging文件输出:CRITICAL critical message&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、logging.handlers.RotatingFileHandler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：这个Handler类似于上面的FileHandler，但是它可以管理文件大小。当文件达到一定大小之后，它会自动将当前日志文件改名，然后创建 一个新的同名日志文件继续输出。比如日志文件是chat.log。当chat.log达到指定的大小之后，RotatingFileHandler自动把 文件改名为chat.log.1。不过，如果chat.log.1已经存在，会先把chat.log.1重命名为chat.log.2。。。最后重新创建 chat.log，继续输出日志信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它的构造函数是：RotatingFileHandler( filename[, mode[, maxBytes[, backupCount]]])，其中filename和mode两个参数和FileHandler一样。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;maxBytes用于指定日志文件的最大文件大小。如果maxBytes为0，意味着日志文件可以无限大，这时上面描述的重命名过程就不会发生。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;backupCount用于指定保留的备份文件的个数。比如，如果指定为2，当上面描述的重命名过程发生时，原有的chat.log.2并不会被更名，而是被删除。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 用法看下面代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; logging &lt;span&gt;import&lt;/span&gt; handlers  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;需要导入handlers&lt;/span&gt;
&lt;span&gt;
logger &lt;/span&gt;= logging.getLogger(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
log_file &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timelog.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;按文件大小来分割，10个字节maxBytes，保留个数是3个&lt;/span&gt;
fh=handlers.RotatingFileHandler(filename=log_file,maxBytes=10,backupCount=3,encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
formatter &lt;/span&gt;= logging.Formatter(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%(asctime)s %(module)s: %(message)s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
fh.setFormatter(formatter)
logger.addHandler(fh)

logger.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logger.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logger.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test13&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logger.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test14&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logger.warning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test15&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;文件的结果就是&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;timelog.log     2018-01-28 21:31:38,513 logging文件个数保留: test15&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;timelog.log1   2018-01-28 21:31:38,500 logging文件个数保留: test14&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;timelog.log2    2018-01-28 21:31:38,487 logging文件个数保留: test13&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;timelog.log3    2018-01-28 21:31:38,471 logging文件个数保留: test12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4、logging.handlers.TimedRotatingFileHandler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：这个Handler和RotatingFileHandler类似，不过，它没有通过判断文件大小来决定何时重新创建日志文件，而是间隔一定时间就 自动创建新的日志文件。重命名的过程与RotatingFileHandler类似，不过新的文件不是附加数字，而是当前时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它的构造函数是：TimedRotatingFileHandler( filename [,when [,interval [,backupCount]]])，其中filename参数和backupCount参数和RotatingFileHandler具有相同的意义。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;interval是时间间隔。when参数是一个字符串。表示时间间隔的单位，不区分大小写。它有以下取值：①S：秒②M：分③H：小时④D：天⑤W ：每星期（interval==0时代表星期一）⑥midnight：每天凌晨&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、控制台和文件日志共同输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要什么样的输出，只需要添加相应的handler就ok了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/936656/201704/936656-20170413172847876-625973873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;create logging&lt;/span&gt;
logger = logging.getLogger(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEST-LOG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
logger.setLevel(logging.DEBUG)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;屏幕handler&lt;/span&gt;
ch =&lt;span&gt; logging.StreamHandler()
ch.setLevel(logging.DEBUG)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;文件handler&lt;/span&gt;
fh = logging.FileHandler(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
fh.setLevel(logging.INFO)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分别创建输出日志格式&lt;/span&gt;
ch_formatter = logging.Formatter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%(asctime)s - %(name)s - %(levelname)s - %(message)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
fh_formatter &lt;/span&gt;= logging.Formatter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%(asctime)s %(module)s:%(levelname)s %(message)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置handler的输出格式&lt;/span&gt;
&lt;span&gt;ch.setFormatter(ch_formatter)
fh.setFormatter(fh_formatter)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加handler&lt;/span&gt;
&lt;span&gt;logger.addHandler(ch)
logger.addHandler(fh)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'application' code&lt;/span&gt;
logger.debug(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;debug message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logger.info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logger.warn(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;warn message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logger.error(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
logger.critical(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;critical message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 注：如果添加时间分割或者文件大小分割，再修改上述代码写入文件的handler即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;五、运用模板做日记功能&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;了解记住上面的流程，我们来做一个简单的日记配置（此方法高能）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
logging配置
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging.config

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义三种日志输出格式 开始&lt;/span&gt;
&lt;span&gt;
standard_format &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
                  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[%(levelname)s][%(message)s]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;其中name为getlogger指定的名字&lt;/span&gt;
&lt;span&gt;
simple_format &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

id_simple_format &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[%(levelname)s][%(asctime)s] %(message)s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义日志输出格式 结束&lt;/span&gt;
&lt;span&gt;
logfile_dir &lt;/span&gt;= os.path.dirname(os.path.abspath(&lt;span&gt;__file__&lt;/span&gt;))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; log文件的目录&lt;/span&gt;
&lt;span&gt;
logfile_name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;all2.log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; log文件名&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果不存在定义的日志目录就创建一个&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; os.path.isdir(logfile_dir):
    os.mkdir(logfile_dir)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; log文件的全路径&lt;/span&gt;
logfile_path =&lt;span&gt; os.path.join(logfile_dir, logfile_name)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; log配置字典&lt;/span&gt;
LOGGING_DIC =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;disable_existing_loggers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: False,    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;前面两个暂时不关注&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;formatters&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;standard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: standard_format
        },
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;simple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: simple_format
        },
    },
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;filters&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {},
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;handlers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印到终端的日志&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;console&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DEBUG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;logging.StreamHandler&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印到屏幕&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;formatter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;simple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印到文件的日志,收集info及以上的日志&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DEBUG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;logging.handlers.RotatingFileHandler&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存到文件&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;formatter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;standard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;filename&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: logfile_path,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 日志文件&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;maxBytes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1024*1024*5,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 日志大小 5M&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;backupCount&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 5&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;encoding&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 日志文件的编码，再也不用担心中文log乱码了&lt;/span&gt;
&lt;span&gt;        },
    },
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;loggers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;logging.getLogger(__name__)拿到的logger配置&lt;/span&gt;
        &lt;span&gt;''&lt;/span&gt;: {     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里可以匹配相同的key,然后输出,还有空,默认都可以输出&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;handlers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;console&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DEBUG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;propagate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: True,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 向上（更高level的logger）传递&lt;/span&gt;
&lt;span&gt;        },
    },
}


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; load_my_logging_cfg():
    logging.config.dictConfig(LOGGING_DIC)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入上面定义的logging配置&lt;/span&gt;
    logger = logging.getLogger(&lt;span&gt;__name__&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成一个log实例&lt;/span&gt;
    logger.info(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;It works!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录该文件的运行状态&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    load_my_logging_cfg()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 06 Apr 2018 11:22:00 +0000</pubDate>
<dc:creator>天王盖地虎宝塔镇河妖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ManyQian/p/8728558.html</dc:identifier>
</item>
<item>
<title>javascript中数组的深拷贝的方法 - Hyacinth-zqz</title>
<link>http://www.cnblogs.com/Hyacinth-zqz/p/8428874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Hyacinth-zqz/p/8428874.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、什么是浅拷贝&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　在js当中，我们常常遇到数组复制的的情况，许多人一般都会使用“=”来直接把一个数组赋值给一个变量，如&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; a=[1,2,3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; b=&lt;span&gt;a;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;console.log(b);　　&lt;span&gt;//输出的是1,2,3
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; a[2]=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; console.log(b);　　&lt;span&gt;//输出的是1,2,0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　把数组a用等号“=”的形式复制给变量b，这种就是js数组的浅拷贝。然而，正如上面代码所示，一旦对数组a做出修改，实际上会影响拷贝出来的其他数组，这并不是我们所想要的结果，因此就必须用到数组的深拷贝来解决这个问题。&lt;/p&gt;
&lt;h3&gt;二、实现数组的深拷贝的方法&lt;/h3&gt;
&lt;h4&gt; （1）for循环实现数组的深拷贝&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr1 = [1, 2, 3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr2 =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; arr1.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    arr2.push(arr1[i]);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; arr1[0] = 4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; console.log(arr1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4, 2, 3&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; console.log(arr2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1, 2, 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;（2）concat 方法实现数组的深拷贝&lt;/h4&gt;
&lt;p&gt;　　concat() 方法用于连接两个或多个数组。&lt;/p&gt;
&lt;p&gt;　　该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr1 = [1, 2, 3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr2 =&lt;span&gt; arr1.concat();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; arr1[0] = 4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(arr1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4, 2, 3&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; console.log(arr2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1, 2, 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;（3）slice 方法实现数组的深拷贝&lt;/h4&gt;
&lt;p&gt;　　slice() 方法可从已有的数组中返回选定的元素。&lt;/p&gt;
&lt;p&gt;　　arrayObject.slice(start,end)&lt;/p&gt;
&lt;p&gt;　　该方法返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr1 = [1, 2, 3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr2 = arr1.slice(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; arr1[0] = 4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(arr1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4, 2, 3&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; console.log(arr2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1, 2, 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;（4）ES6扩展运算符实现数组的深拷贝&lt;/h4&gt;
&lt;p&gt;　　...扩展运算符是ES6的语法，使用起来非常的方便简洁，相信在写ES6的时候也是备受欢迎的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr1 = [1, 2, 3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; [...arr2] =&lt;span&gt; arr1;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; arr1[0] = 4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(arr1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4, 2, 3&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; console.log(arr2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1, 2, 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 06 Apr 2018 10:33:00 +0000</pubDate>
<dc:creator>Hyacinth-zqz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Hyacinth-zqz/p/8428874.html</dc:identifier>
</item>
</channel>
</rss>