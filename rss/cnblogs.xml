<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Go基础系列：互斥锁Mutex和读写锁RWMutex用法详述 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9998729.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9998729.html</guid>
<description>&lt;h2 id=&quot;sync.mutex&quot;&gt;sync.Mutex&lt;/h2&gt;
&lt;p&gt;Go中使用sync.Mutex类型实现mutex(排他锁、互斥锁)。在源代码的sync/mutex.go文件中，有如下定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// A Mutex is a mutual exclusion lock.
// The zero value for a Mutex is an unlocked mutex.
//
// A Mutex must not be copied after first use.
type Mutex struct {
    state int32
    sema uint32
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这没有任何非凡的地方。&lt;strong&gt;和mutex相关的所有事情都是通过sync.Mutex类型的两个方法sync.Lock()和sync.Unlock()函数来完成的，前者用于获取sync.Mutex锁，后者用于释放sync.Mutex锁&lt;/strong&gt;。sync.Mutex一旦被锁住，其它的Lock()操作就无法再获取它的锁，只有通过Unlock()释放锁之后才能通过Lock()继续获取锁。&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;已有的锁会导致其它申请Lock()操作的goroutine被阻塞，且只有在Unlock()的时候才会解除阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外需要注意，&lt;strong&gt;sync.Mutex不区分读写锁，只有Lock()与Lock()之间才会导致阻塞的情况&lt;/strong&gt;，如果在一个地方Lock()，在另一个地方不Lock()而是直接修改或访问共享数据，这对于sync.Mutex类型来说是允许的，因为mutex不会和goroutine进行关联。如果想要区分读、写锁，可以使用sync.RWMutex类型，见后文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Lock()和Unlock()之间的代码段称为资源的临界区(critical section)，在这一区间内的代码是严格被Lock()保护的，是线程安全的，任何一个时间点都只能有一个goroutine执行这段区间的代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以下是使用sync.Mutex的一个示例，稍后是非常详细的分析过程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

// 共享变量
var (
    m  sync.Mutex
    v1 int
)

// 修改共享变量
// 在Lock()和Unlock()之间的代码部分是临界区
func change(i int) {
    m.Lock()
    time.Sleep(time.Second)
    v1 = v1 + 1
    if v1%10 == 0 {
        v1 = v1 - 10*i
    }
    m.Unlock()
}

// 访问共享变量
// 在Lock()和Unlock()之间的代码部分是是临界区
func read() int {
    m.Lock()
    a := v1
    m.Unlock()
    return a
}

func main() {
    var numGR = 21
    var wg sync.WaitGroup

    fmt.Printf(&quot;%d&quot;, read())

    // 循环创建numGR个goroutine
    // 每个goroutine都执行change()、read()
    // 每个change()和read()都会持有锁
    for i := 0; i &amp;lt; numGR; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            change(i)
            fmt.Printf(&quot; -&amp;gt; %d&quot;, read())
        }(i)
    }

    wg.Wait()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 8 -&amp;gt; 9 -&amp;gt; -100 -&amp;gt; -99
-&amp;gt; -98 -&amp;gt; -97 -&amp;gt; -96 -&amp;gt; -95 -&amp;gt; -94 -&amp;gt; -93 -&amp;gt; -92 -&amp;gt; -91 -&amp;gt; -260 -&amp;gt; -259&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二次执行结果：注意其中的-74和-72之间跨了一个数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 8 -&amp;gt; 9 -&amp;gt; -80 -&amp;gt; -79 
-&amp;gt; -78 -&amp;gt; -77 -&amp;gt; -76 -&amp;gt; -75 -&amp;gt; -74 -&amp;gt; -72 -&amp;gt; -71 -&amp;gt; -230 -&amp;gt; -229 -&amp;gt; -229&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的示例中，change()、read()都会申请锁，并在准备执行完函数时释放锁，它们如何修改数据、访问数据本文不多做解释。需要详细解释的是main()中的for循环部分。&lt;/p&gt;
&lt;p&gt;在for循环中，会不断激活新的goroutine(共21个)执行匿名函数，在每个匿名函数中都会执行change()和read()，意味着每个goroutine都会申请两次锁、释放两次锁，且for循环中没有任何Sleep延迟，这21个goroutine几乎是一瞬间同时激活的。&lt;/p&gt;
&lt;p&gt;但由于change()和read()中都申请锁，对于这21个goroutine将要分别执行的42个critical section，Lock()保证了在某一时间点只有其中一个goroutine能访问其中一个critical section。当释放了一个critical section，&lt;strong&gt;其它的Lock()将争夺互斥锁，也就是所谓的竞争现象(race condition)&lt;/strong&gt;。因为竞争的存在，&lt;strong&gt;这42个critical section被访问的顺序是随机的&lt;/strong&gt;，完全无法保证哪个critical section先被访问。&lt;/p&gt;
&lt;p&gt;对于前9个被调度到的goroutine，无论是哪个goroutine取得这9个change(i)中的critical section，都只是对共享变量v1做加1运算，但当第10个goroutine被调度时，由于v1加1之后得到10，它满足if条件，会执行&lt;code&gt;v1 = v1 - i*10&lt;/code&gt;，但这个i可能是任意0到numGR之间的值(因为无法保证并发的goroutine的调度顺序)，这使得v1的值从第10个goroutine开始出现随机性。但从第10到第19个goroutine被调度的过程中，也只是对共享变量v1做加1运算，这些值是可以根据第10个数推断出来的，到第20个goroutine，又再次随机。依此类推。&lt;/p&gt;
&lt;p&gt;此外，&lt;strong&gt;每个goroutine中的read()也都会参与锁竞争，所以并不能保证每次change(i)之后会随之执行到read()&lt;/strong&gt;，可能goroutine 1的change()执行完后，会跳转到goroutine 3的change()上，这样一来，goroutine 1的read()就无法读取到goroutine 1所修改的v1值，而是访问到其它goroutine中修改后的值。所以，前面的第二次执行结果中出现了一次数据跨越。只不过执行完change()后立即执行read()的几率比较大，所以多数时候输出的数据都是连续的。&lt;/p&gt;
&lt;p&gt;总而言之，&lt;strong&gt;Mutex保证了每个critical section安全，某一时间点只有一个goroutine访问到这部分，但也因此而出现了随机性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果Lock()后忘记了Unlock()，将会永久阻塞而出现死锁。如果&lt;/p&gt;

&lt;h3 id=&quot;适合sync.mutex的数据类型&quot;&gt;适合sync.Mutex的数据类型&lt;/h3&gt;
&lt;p&gt;其实，对于内置类型的共享变量来说，使用sync.Mutex和Lock()、Unlock()来保护也是不合理的，因为它们自身不包含Mutex属性。真正合理的共享变量是那些包含Mutex属性的struct类型。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type mytype struct {
    m   sync.Mutex
    var int
}

x := new(mytype)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时只要想保护var变量，就先x.m.Lock()，操作完var后，再x.m.Unlock()。这样就能保证x中的var字段变量一定是被保护的。&lt;/p&gt;

&lt;h2 id=&quot;sync.rwmutex&quot;&gt;sync.RWMutex&lt;/h2&gt;
&lt;p&gt;Go中使用sync.RWMutex类型实现读写互斥锁rwmutex。在源代码的sync/rwmutex.go文件中，有如下定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// A RWMutex is a reader/writer mutual exclusion lock.
// The lock can be held by an arbitrary number of readers or a single writer.
// The zero value for a RWMutex is an unlocked mutex.
//
// A RWMutex must not be copied after first use.
//
// If a goroutine holds a RWMutex for reading and another goroutine might
// call Lock, no goroutine should expect to be able to acquire a read lock
// until the initial read lock is released. In particular, this prohibits
// recursive read locking. This is to ensure that the lock eventually becomes
// available; a blocked Lock call excludes new readers from acquiring the
// lock.
type RWMutex struct {
    w           Mutex  // held if there are pending writers
    writerSem   uint32 // 写锁需要等待读锁释放的信号量
    readerSem   uint32 // 读锁需要等待写锁释放的信号量
    readerCount int32  // 读锁后面挂起了多少个写锁申请
    readerWait  int32  // 已释放了多少个读锁
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的注释和源代码说明了几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;RWMutex是基于Mutex的，在Mutex的基础之上增加了读、写的信号量，并使用了类似引用计数的读锁数量&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读锁与读锁兼容，读锁与写锁互斥，写锁与写锁互斥，只有在锁释放后才可以继续申请互斥的锁&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可以同时申请多个读锁&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有读锁时申请写锁将阻塞，有写锁时申请读锁将阻塞&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只要有写锁，后续申请读锁和写锁都将阻塞&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此类型有几个锁和解锁的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (rw *RWMutex) Lock()
func (rw *RWMutex) RLock()
func (rw *RWMutex) RLocker() Locker
func (rw *RWMutex) RUnlock()
func (rw *RWMutex) Unlock()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Lock()和Unlock()用于申请和释放写锁&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RLock()和RUnlock()用于申请和释放读锁&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一次RUnlock()操作只是对读锁数量减1，即减少一次读锁的引用计数&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果不存在写锁，则Unlock()引发panic，如果不存在读锁，则RUnlock()引发panic&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RLocker()用于返回一个实现了Lock()和Unlock()方法的Locker接口&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此外，无论是Mutex还是RWMutex都不会和goroutine进行关联，这意味着它们的锁申请行为可以在一个goroutine中操作，释放锁行为可以在另一个goroutine中操作。&lt;/p&gt;
&lt;p&gt;由于RLock()和Lock()都能保证数据不被其它goroutine修改，所以在RLock()与RUnlock()之间的，以及Lock()与Unlock()之间的代码区都是critical section。&lt;/p&gt;
&lt;p&gt;以下是一个示例，此示例中同时使用了Mutex和RWMutex，RWMutex用于读、写，Mutex只用于读。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

var Password = secret{password: &quot;myPassword&quot;}

type secret struct {
    RWM      sync.RWMutex
    M        sync.Mutex
    password string
}

// 通过rwmutex写
func Change(c *secret, pass string) {
    c.RWM.Lock()
    fmt.Println(&quot;Change with rwmutex lock&quot;)
    time.Sleep(3 * time.Second)
    c.password = pass
    c.RWM.Unlock()
}

// 通过rwmutex读
func rwMutexShow(c *secret) string {
    c.RWM.RLock()
    fmt.Println(&quot;show with rwmutex&quot;,time.Now().Second())
    time.Sleep(1 * time.Second)
    defer c.RWM.RUnlock()
    return c.password
}

// 通过mutex读，和rwMutexShow的唯一区别在于锁的方式不同
func mutexShow(c *secret) string {
    c.M.Lock()
    fmt.Println(&quot;show with mutex:&quot;,time.Now().Second())
    time.Sleep(1 * time.Second)
    defer c.M.Unlock()
    return c.password
}

func main() {
    // 定义一个稍后用于覆盖(重写)的函数
    var show = func(c *secret) string { return &quot;&quot; }

    // 通过变量赋值的方式，选择并重写showFunc函数
    if len(os.Args) != 2 {
        fmt.Println(&quot;Using sync.RWMutex!&quot;,time.Now().Second())
        show = rwMutexShow
    } else {
        fmt.Println(&quot;Using sync.Mutex!&quot;,time.Now().Second())
        show = mutexShow
    }
    
    var wg sync.WaitGroup

    // 激活5个goroutine，每个goroutine都查看
    // 根据选择的函数不同，showFunc()加锁的方式不同
    for i := 0; i &amp;lt; 5; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            fmt.Println(&quot;Go Pass:&quot;, show(&amp;amp;Password),time.Now().Second())
        }()
    }
    
    // 激活一个申请写锁的goroutine
    go func() {
        wg.Add(1)
        defer wg.Done()
        Change(&amp;amp;Password, &quot;123456&quot;)
    }()
    // 阻塞，直到所有wg.Done
    wg.Wait()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Change()函数申请写锁，并睡眠3秒后修改数据，然后释放写锁。&lt;/p&gt;
&lt;p&gt;rwMutexShow()函数申请读锁，并睡眠一秒后取得数据，并释放读锁。注意，rwMutexShow()中的print和return是相隔一秒钟的。&lt;/p&gt;
&lt;p&gt;mutexShow()函数申请Mutex锁，和RWMutex互不相干。和rwMutexShow()唯一不同之处在于申请的锁不同。&lt;/p&gt;
&lt;p&gt;main()中，先根据命令行参数数量决定运行哪一个show()。之所以能根据函数变量来赋值，是因为先定义了一个show()函数，它的函数签名和rwMutexShow()、mutexShow()的签名相同，所以可以相互赋值。&lt;/p&gt;
&lt;p&gt;for循环中激活了5个goroutine并发运行，for瞬间激活5个goroutine后，继续执行main()代码会激活另一个用于申请写锁的goroutine。这6个goroutine的执行顺序是随机的。&lt;/p&gt;
&lt;p&gt;如果show选中的函数是rwMutexShow()，则5个goroutine要申请的RLock()锁和写锁是冲突的，但5个RLock()是兼容的。所以，只要某个时间点调度到了写锁的goroutine，剩下的读锁goroutine都会从那时开始阻塞3秒。&lt;/p&gt;
&lt;p&gt;除此之外，还有一个不严格准确，但在时间持续长短的理论上来说能保证的一个规律：当修改数据结束后，各个剩下的goroutine都申请读锁，因为申请后立即print输出，然后睡眠1秒，但1秒时间足够所有剩下的goroutine申请完读锁，使得&lt;code&gt;show with rwmutex&lt;/code&gt;输出是连在一起，输出的&lt;code&gt;Go Pass: 123456&lt;/code&gt;又是连在一起的。&lt;/p&gt;
&lt;p&gt;某次结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Using sync.RWMutex! 58
show with rwmutex 58
Change with rwmutex lock
Go Pass: myPassword 59
show with rwmutex 2
show with rwmutex 2
show with rwmutex 2
show with rwmutex 2
Go Pass: 123456 3
Go Pass: 123456 3
Go Pass: 123456 3
Go Pass: 123456 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果show选中的函数是mutexShow()，则读数据和写数据互不冲突，但读和读是冲突的(因为Mutex的Lock()是互斥的)。&lt;/p&gt;
&lt;p&gt;某次结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Using sync.Mutex! 30
Change with rwmutex lock
show with mutex: 30
Go Pass: myPassword 31
show with mutex: 31
Go Pass: myPassword 32
show with mutex: 32
Go Pass: 123456 33
show with mutex: 33
show with mutex: 34
Go Pass: 123456 34
Go Pass: 123456 35&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;用mutex还是用rwmutex&quot;&gt;用Mutex还是用RWMutex&lt;/h2&gt;
&lt;p&gt;Mutex和RWMutex都不关联goroutine，但RWMutex显然更适用于读多写少的场景。仅针对读的性能来说，RWMutex要高于Mutex，因为rwmutex的多个读可以并存。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 15:58:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>sync.Mutex Go中使用sync.Mutex类型实现mutex(排他锁、互斥锁)。在源代码的sync/mutex.go文件中，有如下定义： 这没有任何非凡的地方。 和mutex相关的所有事情都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9998729.html</dc:identifier>
</item>
<item>
<title>绘制矩形 - Myuniverse</title>
<link>http://www.cnblogs.com/MyUniverse/p/9998723.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MyUniverse/p/9998723.html</guid>
<description>&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;　　&amp;lt;head&amp;gt;&lt;br/&gt;　　　　&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&lt;br/&gt;　　　　&amp;lt;title&amp;gt;绘制矩形&amp;lt;/title&amp;gt;&lt;br/&gt;　　&amp;lt;/head&amp;gt;&lt;br/&gt;　　&amp;lt;body&amp;gt;&lt;br/&gt;　　　　&amp;lt;canvas id=&quot;drawing&quot; height=&quot;500&quot; width=&quot;500&quot;&amp;gt;A drawing of something.&amp;lt;/canvas&amp;gt;&lt;br/&gt;　　　　&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;br/&gt;　　　　var drawing = document.getElementById(&quot;drawing&quot;)&lt;br/&gt;　　　　if(drawing.getContext)&lt;br/&gt;　　　　{&lt;br/&gt;　　　　　　var context = drawing.getContext(&quot;2d&quot;)&lt;/p&gt;&lt;p&gt;　　　　　　context.strokeStyle.lineCap = &quot;square&quot;&lt;br/&gt;　　　　　　&lt;span&gt;//绘制红色矩形&lt;/span&gt;&lt;br/&gt;　　　　　　context.fillStyle = &quot;#ff0000&quot;;&lt;br/&gt;　　　　　　context.strokeStyle = &quot;black&quot;&lt;br/&gt;　　　　　　context.fillRect(10,10,60,60);&lt;br/&gt;　　　　　　context.strokeRect(10,10,60,60);&lt;/p&gt;&lt;p&gt;　　　　　&lt;span&gt;　//绘制半透明的蓝色矩形&lt;/span&gt;&lt;br/&gt;　　　　　　context.strokeStyle = &quot;red&quot;&lt;br/&gt;　　　　　　context.fillStyle = &quot;rgba(0,0,255,0.5)&quot;;&lt;br/&gt;　　　　　　context.fillRect(30,30,50,50);&lt;br/&gt;　　　　　　context.strokeRect(30,30,50,50);&lt;/p&gt;&lt;p&gt;　　　　　　&lt;span&gt;//context.fiilRect的第一个和第二个参数代表着以画布的上面为x坐标，左边为y坐标的x,y坐标的值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　　　　　context.clearRect(40,40,20,20)&lt;br/&gt;　　　　　　&lt;span&gt;//第一个和第二个参数表示的是坐标，第三个和第四个表示的是长宽的大小&lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　　　　　// context.beginPath();&lt;br/&gt;　　　　　　context.lineWidth = 10;&lt;span&gt;//线条的宽度&lt;/span&gt;&lt;br/&gt;　　　　　　context.lineCap = &quot;round&quot;;&lt;span&gt;//线条在最后面的位置&lt;/span&gt;&lt;br/&gt;　　　　　　context.moveTo(90,60);&lt;span&gt;//表示线条的末端的位置&lt;/span&gt;&lt;br/&gt;　　　　　　context.lineTo(200,20);&lt;span&gt;//表示线条前端的位置&lt;/span&gt;&lt;br/&gt;　　　　　　context.stroke();&lt;span&gt;//表示画图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　　　　　}&lt;br/&gt;　　　&amp;lt;/script&amp;gt;&lt;br/&gt;　　&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 15:56:00 +0000</pubDate>
<dc:creator>Myuniverse</dc:creator>
<og:description>&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;绘</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MyUniverse/p/9998723.html</dc:identifier>
</item>
<item>
<title>【ABP框架系列学习】介绍篇(1) - 大龄Giser</title>
<link>http://www.cnblogs.com/OlderGiser/p/9998692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OlderGiser/p/9998692.html</guid>
<description>&lt;p id=&quot;main-toc&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该系列博文主要在【&lt;a href=&quot;https://aspnetboilerplate.com/Pages/Documents&quot; data-cke-saved-href=&quot;https://aspnetboilerplate.com/Pages/Documents&quot;&gt;官方文档&lt;/a&gt;】及【】ABP框架理论研究系列博文的基础上进行总结的，或许大家会质问，别人都已经翻译过了，这不是多此一举吗？原因如下：&lt;/p&gt;
&lt;p&gt;1.【&lt;a href=&quot;http://www.cnblogs.com/farb/p/ABPTheory.html&quot; data-cke-saved-href=&quot;http://www.cnblogs.com/farb/p/ABPTheory.html&quot;&gt;tkbSimplest&lt;/a&gt;】的相关博文由于撰写得比较早的，在参照官方文档学习的过程中，发现部分知识未能及时同步(当前V4.0.2版本)，如【EntityHistory】、【Multi-Lingual Engities】章节未涉及、【Caching】章节没有Entity Caching等内容。&lt;/p&gt;
&lt;p&gt;2.进一步深入学习ABP的理论知识。&lt;/p&gt;
&lt;p&gt;3.借此机会提高英文文档的阅读能力，故根据官方当前最新的版本，并在前人的基础上，自己也感受一下英文帮助文档的魅力。&lt;/p&gt;
&lt;p&gt;好了，下面开始进入正题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ABP&lt;/strong&gt;是ASP.NET Boilerplate的简称，从英文字面上理解它是一个关于ASP.NET的模板，在&lt;a href=&quot;https://github.com/aspnetboilerplate/aspnetboilerplate&quot; data-cke-saved-href=&quot;https://github.com/aspnetboilerplate/aspnetboilerplate&quot;&gt;github&lt;/a&gt;上已经有5.7k的star(截止2018年11月21日)。官方的解释：ABP是一个&lt;strong&gt;开源&lt;/strong&gt;且文档友好的&lt;strong&gt;应用程序框架&lt;/strong&gt;。ABP不仅仅是一个框架，它还提供了一个&lt;strong&gt;最徍实践&lt;/strong&gt;的基于&lt;strong&gt;领域驱动设计(DDD)&lt;/strong&gt;的体系结构模型。&lt;/p&gt;
&lt;p&gt;ABP与最新的&lt;strong&gt;ASP.NET CORE&lt;/strong&gt;和&lt;strong&gt;EF CORE&lt;/strong&gt;版本保持同步，同样也支持ASP.NET MVC 5.x和EF6.x。&lt;/p&gt;

&lt;p&gt; 让我们研究一个简单的类，看看ABP具有哪些优点：&lt;/p&gt;

&lt;p&gt;这里我们看到一个Application Service(应用服务)方法。在DDD中，应用服务直接用于表现层(UI)执行应用程序的用例。那么在UI层中就可以通过javascript ajax的方式调用&lt;strong&gt;UpdateTask&lt;/strong&gt;方法。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;通过上述事例，让我们来看看ABP的一些优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;依赖注入（Dependency Injection）：&lt;/strong&gt;&lt;/span&gt;ABP使用并提供了传统的DI基础设施。上述TaskAppService类是一个应用服务(继承自ApplicationService)，所以它按照惯例以短暂(每次请求创建一次)的形式自动注册到DI容器中。同样的，也可以简单地注入其他依赖(如事例中的IRepository&amp;lt;Task&amp;gt;)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;部分源码分析：&lt;/strong&gt;&lt;/span&gt;TaskAppService类继承自ApplicationService，IApplicaitonServcie又继承自ITransientDependency接口，在ABP框架中已经将ITransientDependency接口注入到DI容器中，所有继承自ITransientDependency接口的类或接口都会默认注入。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;仓储(Repository)：&lt;/strong&gt;&lt;/span&gt;ABP可以为每一个实体创建一个默认的仓储(如事例中的IRepository&amp;lt;Task&amp;gt;)。默认的仓储提供了很多有用的方法，如事例中的FirstOrDefault方法。当然，也可以根据需求扩展默认的仓储。仓储抽象了DBMS和ORMs，并简化了数据访问逻辑。&lt;/p&gt;
&lt;p&gt;                              &lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;11&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/2018112112374863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5bmNoZWU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;588&quot; height=&quot;924&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/2018112112374863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5bmNoZWU=,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/2018112112374863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5bmNoZWU=,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;588&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;924&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;授权(Authorization)：&lt;/strong&gt;&lt;/span&gt;ABP可以通过声明的方式检查权限。如果当前用户没有【update task】的权限或没有登录，则会阻止访问UpdateTask方法。ABP不仅提供了声明属性的方式授权，而且还可以通过其它的方式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;部分源码分析：&lt;/strong&gt;&lt;/span&gt;AbpAuthorizeAttribute类实现了Attribute，可在类或方法上通过【AbpAuthorize】声明。&lt;/p&gt;

&lt;p&gt; 通过AuthorizationProvider类中的SetPermissions方法进行自定义授权。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;验证(Validation)：&lt;/strong&gt;&lt;/span&gt;ABP自动检查输入是否为null。它也基于标准数据注释特性和自定义验证规则验证所有的输入属性。如果请求无效，它会在客户端抛出适合的验证异常。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;部分源码分析：&lt;/strong&gt;&lt;/span&gt;ABP框架中主要通过拦截器ValidationInterceptor(AOP实现方式之一，)实现验证，该拦截器在ValidationInterceptorRegistrar的Initialize方法中调用。&lt;/p&gt;

&lt;p&gt;自定义Customvalidator类&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;审计日志(Audit Logging)：&lt;/strong&gt;&lt;/span&gt;基于约定和配置，用户、浏览器、IP地址、调用服务、方法、参数、调用时间、执行时长以及其它信息会为每一个请求自动保存。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;部分源码分析：&lt;/strong&gt;&lt;/span&gt;ABP框架中主要通过拦截器AuditingInterceptor(AOP实现方式之一，)实现审计日志，该拦截器在AuditingInterceptorRegistrar的Initialize方法中调用。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;工作单元(Unit Of Work)：&lt;/strong&gt;&lt;/span&gt;在ABP中，应用服务方法默认视为一个工作单元。它会自动创建一个连接并在方法的开始位置开启事务。如果方法成功完成并没有异常，事务会提交并释放连接。即使这个方法使用不同的仓储或方法，它们都是原子的(事务的)。当事务提交时，实体的所有改变都会自动保存。如上述事例所示，甚至不需要调用_repository.Update(task)方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;部分源码分析：&lt;/strong&gt;&lt;/span&gt;ABP框架中主要通过拦截器UnitOfWorkInterceptor(AOP实现方式之一，)实现工作单元，该拦截器在UnitOfWorkRegistrar的Initialize方法中调用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;异常处理(Exception)：&lt;/strong&gt;&lt;/span&gt;在使用了ABP框架的Web应用程序中，我们几乎不用手动处理异常。默认情况下，所有的异常都会自动处理。如果发生异常，ABP会自动记录并给客户端返回合适的结果。例如：对于一个ajax请求，返回一个json对象给客户端，表明发生了错误。但会对客户端隐藏实际的异常，除非像上述事例那样使用UserFriendlyException方法抛出。它也理解和处理客户端的错误，并向客户端显示合适的信息。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;部分源码分析：&lt;/strong&gt;&lt;/span&gt;UserFriendlyException抛出异常方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;日志(Logging)：&lt;/strong&gt;&lt;/span&gt;由上述事例可见，可以通过在基类定义的Logger对象来写日志。ABP默认使用了Log4Net，但它是可更改和可配置的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;部分源码分析：&lt;/strong&gt;&lt;/span&gt;Log4NetLoggerFactory类。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;本地化(Localization)：&lt;/strong&gt;&lt;/span&gt;注意，在上述事例中使用了L(&quot;XXX&quot;)方法处理抛出的异常。因此，它会基于当前用户的文化自动实现本地化。详细见后续本地化章节。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;部分源码分析：&lt;/strong&gt;&lt;/span&gt;......&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;自动映射(Auto Mapping)：&lt;/strong&gt;&lt;/span&gt;在上述事例最后一行代码，使用了ABP的MapTo扩展方法将输入对象的属性映射到实体属性。ABP使用AutoMapper第三方库执行映射。根据命名惯例可以很容易的将属性从一个对象映射到另一个对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;部分源码分析：&lt;/strong&gt;&lt;/span&gt;AutoMapExtensions类中的MapTo()方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;动态API层(Dynamic API Layer)：&lt;/strong&gt;&lt;/span&gt;在上述事例中，TaskAppService实际上是一个简单的类。通常必须编写一个Web API Controller包装器给js客户端暴露方法，而ABP会在运行时自动完成。通过这种方式，可以在客户端直接使用应用服务方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;部分源码分析：&lt;/strong&gt;&lt;/span&gt;......&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;动态javascript ajax代理(Dynamic JavaScript AJAX Proxy)：&lt;/strong&gt;&lt;/span&gt;ABP创建动态代理方法，从而使得调用应用服务方法就像调用客户端的js方法一样简单。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;部分源码分析：&lt;/strong&gt;&lt;/span&gt;......&lt;/p&gt;


&lt;p&gt;通过上述简单的类可以看到ABP的优点。完成所有这些任务通常需要花费大量的时间，但是ABP框架会自动处理。&lt;/p&gt;
&lt;p&gt;除了这个上述简单的事例外，ABP还提供了一个健壮的基础设施和开发模型，如模块化、多租户、缓存、后台工作、数据过滤、设置管理、领域事件、单元&amp;amp;集成测试等等，那么你可以专注于业务代码，而不需要重复做这些工作&lt;span&gt;&lt;strong&gt;(DRY)&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 15:46:00 +0000</pubDate>
<dc:creator>大龄Giser</dc:creator>
<og:description>0.引言 该系列博文主要在【官方文档】及【tkbSimplest】ABP框架理论研究系列博文的基础上进行总结的，或许大家会质问，别人都已经翻译过了，这不是多此一举吗？原因如下： 1.【tkbSimpl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OlderGiser/p/9998692.html</dc:identifier>
</item>
<item>
<title>Netty Bootstrap（图解）|秒懂 - 疯狂创客圈</title>
<link>http://www.cnblogs.com/crazymakercircle/p/9998643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crazymakercircle/p/9998643.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;&lt;span&gt;疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之18 【 &lt;span&gt;博客园 总入口&lt;/span&gt; 】&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;源码工程&quot;&gt;源码工程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;源码IDEA工程获取链接&lt;/strong&gt;：&lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;Java 聊天室 实战 源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;​ 大家好，我是作者尼恩。&lt;/p&gt;
&lt;p&gt;​ 今天是百万级流量 Netty 聊天器 打造的系列文章的第18篇，这是一个基础篇，介绍Bootstrap。&lt;/p&gt;
&lt;p&gt;​ 力争以图文并茂的形式，做到非常的易懂。&lt;/p&gt;
&lt;h2 id=&quot;图解几个重要概念&quot;&gt;图解几个重要概念&lt;/h2&gt;
&lt;p&gt;下面的几个概念，非常重要。&lt;/p&gt;
&lt;p&gt;之前没有认真介绍，下面图解说明一下。&lt;/p&gt;
&lt;h3 id=&quot;父子-channel&quot;&gt;父子 channel&lt;/h3&gt;
&lt;p&gt;​ 在 Netty 中, Channel 是一个 Socket 连接的抽象, 它为用户提供了关于底层 Socket 状态(是否是连接还是断开) 以及对 Socket 的读写等操作。&lt;/p&gt;
&lt;p&gt;​ 每当 Netty 建立了一个连接后, 都会有一个对应的 Channel 实例。&lt;/p&gt;
&lt;p&gt;​ 并且，有父子channel 的概念。 服务器连接监听的channel ，也叫 parent channel。 对应于每一个 Socket 连接的channel，也叫 child channel。&lt;/p&gt;
&lt;h3 id=&quot;eventloop-线程与线程组&quot;&gt;EventLoop 线程与线程组&lt;/h3&gt;
&lt;p&gt;在看本文之前，如果不明白 reactor 线程和reactor模式，请 查看 疯狂创客圈的专门文章：&lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9833847.html&quot;&gt;Reactor模式&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;在Netty 中，每一个 channel 绑定了一个thread 线程。&lt;/p&gt;
&lt;p&gt;一个 thread 线程，封装到一个 EventLoop ， 多个EventLoop ，组成一个线程组 EventLoopGroup。&lt;/p&gt;
&lt;p&gt;反过来说，EventLoop 这个相当于一个处理线程，是Netty接收请求和处理IO请求的线程。 EventLoopGroup 可以理解为将多个EventLoop进行分组管理的一个类，是EventLoop的一个组。&lt;/p&gt;
&lt;p&gt;他们的对应关系，大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181121232904955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通道与reactor线程组&quot;&gt;通道与Reactor线程组&lt;/h3&gt;
&lt;p&gt;​ 这里主要是涉及的是服务器端。&lt;/p&gt;
&lt;p&gt;​ 服务器端，一般有设置两个线程组，监听连接的 parent channel 工作在一个独立的线程组，这里名称为boss线程组（有点像负责招人的包工头）。&lt;/p&gt;
&lt;p&gt;​ 连接成功后，负责客户端连接读写的 child channel 工作在另一个线程组，这里名称为 worker 线程组，专门负责搬数据（有点儿像搬砖）。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181121232932923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;channel-通道的类型&quot;&gt;Channel 通道的类型&lt;/h3&gt;
&lt;p&gt;​ 除了 TCP 协议以外, Netty 还支持很多其他的连接协议, 并且每种协议还有 NIO(异步 IO) 和 OIO(Old-IO, 即传统的阻塞 IO) 版本的区别。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;不同协议不同的阻塞类型的连接都有不同的 Channel 类型与之对应，下面是一些常用的 Channel 类型:&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;NioSocketChannel, 代表异步的客户端 TCP Socket 连接.&lt;/li&gt;
&lt;li&gt;NioServerSocketChannel, 异步的服务器端 TCP Socket 连接.&lt;/li&gt;
&lt;li&gt;NioDatagramChannel, 异步的 UDP 连接&lt;/li&gt;
&lt;li&gt;NioSctpChannel, 异步的客户端 Sctp 连接.&lt;/li&gt;
&lt;li&gt;NioSctpServerChannel, 异步的 Sctp 服务器端连接.&lt;/li&gt;
&lt;li&gt;OioSocketChannel, 同步的客户端 TCP Socket 连接.&lt;/li&gt;
&lt;li&gt;OioServerSocketChannel, 同步的服务器端 TCP Socket 连接.&lt;/li&gt;
&lt;li&gt;OioDatagramChannel, 同步的 UDP 连接&lt;/li&gt;
&lt;li&gt;OioSctpChannel, 同步的 Sctp 服务器端连接.&lt;/li&gt;
&lt;li&gt;OioSctpServerChannel, 同步的客户端 TCP Socket 连接.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;启动器初步介绍&quot;&gt;启动器初步介绍&lt;/h2&gt;
&lt;p&gt;Bootstrap 是 Netty 提供的一个便利的工厂类，可以通过它来完成 Netty 的客户端或服务器端的 Netty 初始化。&lt;/p&gt;
&lt;p&gt;当然，Netty 的官方解释说，可以不用这个启动器。&lt;/p&gt;
&lt;p&gt;但是，一点点去手动创建channel 并且完成一些的设置和启动，会非常麻烦。还是使用这个便利的工具类，会比较好。&lt;/p&gt;
&lt;p&gt;有两个启动器，分别应用在服务器和客户端。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201811212329558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个启动器大致的配置，都是相同的。&lt;/p&gt;
&lt;p&gt;下面以服务器serverBootstrap 启动类为主要的介绍对象。&lt;/p&gt;
&lt;h2 id=&quot;图解-bootstrap执行流程&quot;&gt;图解 Bootstrap执行流程&lt;/h2&gt;
&lt;p&gt;​ 首先，创建了一个引导器 ServerBootstrap 实例，这个专门用于引导服务端的启动工作，直接new 创建即可。（客户端的引导器差不多，不过是创建Bootstrap 实例）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 启动引导器
private static ServerBootstrap b = new ServerBootstrap();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 启动一个Bootstrap，大致有8步，如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181121233015647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    try {   //1 设置reactor 线程
            b.group(bossLoopGroup, workerLoopGroup);
            //2 设置nio类型的channel
            b.channel(NioServerSocketChannel.class);
            //3 设置监听端口
            b.localAddress(new InetSocketAddress(port));
            //4 设置通道选项
            b.option(ChannelOption.SO_KEEPALIVE, true);
            b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);

            //5 装配流水线
            b.childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;()
            {
                //有连接到达时会创建一个channel
                protected void initChannel(SocketChannel ch) throws Exception
                {
                    ch.pipeline().addLast(new ProtobufDecoder());
                    ch.pipeline().addLast(new ProtobufEncoder());
                    // pipeline管理channel中的Handler
                    // 在channel队列中添加一个handler来处理业务
                    ch.pipeline().addLast(&quot;serverHandler&quot;, serverHandler);
                }
            });
            // 6 开始绑定server
            // 通过调用sync同步方法阻塞直到绑定成功

            ChannelFuture channelFuture = b.bind().sync();
            LOGGER.info(ChatServer.class.getName() +
                    &quot; started and listen on &quot; + 
                    channelFuture.channel().localAddress());

            // 7 监听通道关闭事件
            // 应用程序会一直等待，直到channel关闭
            ChannelFuture closeFuture=  channelFuture.channel().closeFuture();
            closeFuture.sync();
        } catch (Exception e)
        {
            e.printStackTrace();
        } finally
        {
            // 8 优雅关闭EventLoopGroup，
            // 释放掉所有资源包括创建的线程
            workerLoopGroup.shutdownGracefully();
            bossLoopGroup.shutdownGracefully();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;strong&gt;接下来就是精彩的8个步骤&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;设置reactor-线程组&quot;&gt;1：设置reactor 线程组&lt;/h3&gt;
&lt;p&gt;​ 在设置 reactor 反应器线程组之前，创建了两个 NioEventLoopGroup 线程组：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;bossLoopGroup 表示服务器连接监听线程组，专门接受 accept 新的客户端client 连接&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;workerGroup 表示处理每一条连接的数据收发的线程组&lt;/p&gt;
&lt;p&gt;在线程组和启动器都创建完成后，就可以开始设置线程组：通过 b.group(bossGroup, workerGroup) 方法，给引导器配置两大线程组。&lt;/p&gt;
&lt;p&gt;配置完成之后，整个引导类的 reactor 线程正式确定。这里确定的工作模式，为父子线程的模型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;也可以不设置两个线程组，只设置一个线程组。&lt;/p&gt;
&lt;p&gt;如果只设置一个线程组，具体的方法为 —— b.group( workerGroup) 。&lt;/p&gt;
&lt;p&gt;配置完成一个线程组，则所有的 channel ，包括服务监听通道父亲channel 和所有的子channel ，都工作在同一个线程组中。&lt;/p&gt;
&lt;p&gt;说明一下，一个线程组，可不止一条线程哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018112123303877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置通道的io类型&quot;&gt;2 ：设置通道的IO类型&lt;/h3&gt;
&lt;p&gt;Netty 不止支持 Java NIO ，也支持阻塞式的 BIO （在Netty 中 叫做OIO）。&lt;/p&gt;
&lt;p&gt;这里配置的是NIO，方法如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//2 设置nio类型的channel
b.channel(NioServerSocketChannel.class);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想指定 IO 模型为 BIO，那么这里配置上Netty的 OioServerSocketChannel.class 类型即可。由于NIO 的优势巨大，通常不会在Netty中使用BIO。&lt;/p&gt;
&lt;h3 id=&quot;设置监听端口&quot;&gt;3：设置监听端口&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; //3 设置监听端口
 b.localAddress(new InetSocketAddress(port));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是最为简单的一步操作。&lt;/p&gt;
&lt;h3 id=&quot;设置通道参数&quot;&gt;4：设置通道参数&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;childOption() 方法&lt;/p&gt;
&lt;p&gt;给每条child channel 连接设置一些TCP底层相关的属性，比如上面，我们设置了两种TCP属性，其中 ChannelOption.SO_KEEPALIVE表示是否开启TCP底层心跳机制，true为开&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;option() 方法&lt;/p&gt;
&lt;p&gt;对于server bootstrap而言，这个方法，是给parent channel 连接设置一些TCP底层相关的属性。&lt;/p&gt;
&lt;p&gt;TCP连接的参数详细介绍如下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;option设置的参数&quot;&gt;option设置的参数：&lt;/h3&gt;
&lt;p&gt;SO_RCVBUF ，SO_SNDBUF&lt;/p&gt;
&lt;p&gt;这两个选项就是来设置TCP连接的两个buffer尺寸的。&lt;/p&gt;
&lt;p&gt;每个TCP socket在内核中都有一个发送缓冲区和一个接收缓冲区，TCP的全双工的工作模式以及TCP的滑动窗口便是依赖于这两个独立的buffer以及此buffer的填充状态。&lt;/p&gt;
&lt;p&gt;SO_SNDBUF&lt;br/&gt;  Socket参数，TCP数据发送缓冲区大小。该缓冲区即TCP发送滑动窗口，linux操作系统可使用命令：cat /proc/sys/net/ipv4/tcp_smem 查询其大小。&lt;/p&gt;
&lt;p&gt;TCP_NODELAY&lt;br/&gt;  TCP参数，立即发送数据，默认值为Ture（Netty默认为True而操作系统默认为False）。该值设置Nagle算法的启用，改算法将小的碎片数据连接成更大的报文来最小化所发送的报文的数量，如果需要发送一些较小的报文，则需要禁用该算法。Netty默认禁用该算法，从而最小化报文传输延时。&lt;/p&gt;
&lt;p&gt;​ 这个参数，与是否开启Nagle算法是反着来的，true表示关闭，false表示开启。通俗地说，如果要求高实时性，有数据发送时就马上发送，就关闭，如果需要减少发送次数减少网络交互，就开启。&lt;/p&gt;
&lt;p&gt;SO_KEEPALIVE&lt;br/&gt;  底层TCP协议的心跳机制。Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。可以将此功能视为TCP的心跳机制，需要注意的是：默认的心跳间隔是7200s即2小时。Netty默认关闭该功能。&lt;/p&gt;
&lt;p&gt;SO_REUSEADDR&lt;br/&gt;  Socket参数，地址复用，默认值False。有四种情况可以使用：&lt;br/&gt;(1).当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你希望启动的程序的socket2要占用该地址和端口，比如重启服务且保持先前端口。&lt;br/&gt;(2).有多块网卡或用IP Alias技术的机器在同一端口启动多个进程，但每个进程绑定的本地IP地址不能相同。&lt;br/&gt;(3).单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。(4).完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。&lt;/p&gt;
&lt;p&gt;SO_LINGER&lt;br/&gt;  Socket参数，关闭Socket的延迟时间，默认值为-1，表示禁用该功能。-1表示socket.close()方法立即返回，但OS底层会将发送缓冲区全部发送到对端。0表示socket.close()方法立即返回，OS放弃发送缓冲区的数据直接向对端发送RST包，对端收到复位错误。非0整数值表示调用socket.close()方法的线程被阻塞直到延迟时间到或发送缓冲区中的数据发送完毕，若超时，则对端会收到复位错误。&lt;/p&gt;
&lt;p&gt;SO_BACKLOG&lt;br/&gt;  Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。&lt;/p&gt;
&lt;pre class=&quot;//如下设置&quot;&gt;
&lt;code&gt; b.option(ChannelOption.SO_BACKLOG, 1024) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示系统用于临时存放已完成三次握手的请求的队列的最大长度，如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数.&lt;/p&gt;
&lt;p&gt;SO_BROADCAST&lt;br/&gt;  Socket参数，设置广播模式。&lt;/p&gt;
&lt;h3 id=&quot;装配流水线&quot;&gt;5: 装配流水线&lt;/h3&gt;
&lt;p&gt;​ ChannelPipeline 这是Netty处理请求的责任链，这是一个ChannelHandler的链表，而ChannelHandler就是用来处理网络请求的内容的。&lt;/p&gt;
&lt;p&gt;​ 每一个channel ，都有一个处理器流水线。&lt;/p&gt;
&lt;p&gt;​ 装配 child channel 流水线，调用 childHandler()方法，传递一个ChannelInitializer 的实例。&lt;/p&gt;
&lt;p&gt;​ 在 child channel 创建成功，开始通道初始化的时候，在bootstrap启动器中配置的 ChannelInitializer 实例就会被调用。&lt;/p&gt;
&lt;p&gt;​ 这个时候，才真正的执行去执行 initChannel 初始化方法，开始通道流水线装配。&lt;/p&gt;
&lt;p&gt;​ 流水线装配，主要是在流水线pipeline 的后面，增加负责数据读写、处理业务逻辑的handler。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; b.childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;()
            {
                //有连接到达时会创建一个channel
                protected void initChannel(SocketChannel ch) throws Exception
                {
                    ch.pipeline().addLast(new ProtobufDecoder());
                    ch.pipeline().addLast(new ProtobufEncoder());
                    // pipeline管理channel中的Handler
                    // 在channel队列中添加一个handler来处理业务
                    ch.pipeline().addLast(&quot;serverHandler&quot;, serverHandler);
                }
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明一下，ChannelInitializer这个类中，有一个泛型参数 SocketChannel，这里的类型，需要和前面的Channel类型对应上。&lt;/p&gt;
&lt;p&gt;顺便说一下处理器。&lt;/p&gt;
&lt;p&gt;处理器 ChannelHandler 用来处理网络请求内容，有ChannelInboundHandler和ChannelOutboundHandler两种，ChannlPipeline会从头到尾顺序调用ChannelInboundHandler处理网络请求内容，从尾到头调用ChannelOutboundHandler 处理网络请求内容。&lt;/p&gt;
&lt;p&gt;pipeline 流水线的图，大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180330-154727.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何装配parent 通道呢？&lt;/p&gt;
&lt;p&gt;使用serverBootstrap.handler() 方法 。 handler()方法，可以和前面分析的childHandler()方法对应起来。childHandler()用于指定处理新连接数据的读写处理逻辑。 handler()方法装配parent 通道。&lt;/p&gt;
&lt;p&gt;比方说：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;serverBootstrap.handler(new ChannelInitializer() 
 { 
    protected void initChannel(NioServerSocketChannel ch) 
    {
        System.out.println(&quot;服务端启动中&quot;); 
     } 
 }
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;handler()用于指定在服务端启动过程中的一些逻辑，通常情况下呢，我们用不着这个方法。&lt;/p&gt;
&lt;h3 id=&quot;开始绑定server&quot;&gt;6： 开始绑定server&lt;/h3&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 通过调用sync同步方法阻塞直到绑定成功
    ChannelFuture channelFuture = b.bind().sync();
        LOGGER.info(ChatServer.class.getName() +
                &quot; started and listen on &quot; + 
                channelFuture.channel().localAddress());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个也很简单。&lt;/p&gt;
&lt;h3 id=&quot;channelfuture&quot;&gt;7： ChannelFuture&lt;/h3&gt;
&lt;p&gt;ChannelFuture 在Netty中的所有的I/O操作都是异步执行的，这就意味着任何一个I/O操作会立刻返回，不保证在调用结束的时候操作会执行完成。因此，会返回一个ChannelFuture的实例，通过这个实例可以获取当前I/O操作的状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            // 7 监听通道关闭事件
            // 应用程序会一直等待，直到channel关闭
            ChannelFuture closeFuture=  channelFuture.channel().closeFuture();
            closeFuture.sync();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于客户端来说，Bootstrap是开发netty客户端的基础,通过Bootstrap的connect方法来连接服务器端。该方法返回的也是ChannelFuture。&lt;/p&gt;
&lt;h3 id=&quot;优雅关闭eventloopgroup&quot;&gt;8 优雅关闭EventLoopGroup&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        // 8 优雅关闭EventLoopGroup，
        // 释放掉所有资源包括创建的线程
        workerLoopGroup.shutdownGracefully();
        bossLoopGroup.shutdownGracefully();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个，会关闭所有的child channel，这是非常重要的。&lt;/p&gt;
&lt;p&gt;关闭之后，会释放掉底层的资源，如TCP Socket 文件描述符，等等。&lt;/p&gt;
&lt;h2 id=&quot;疯狂创客圈-java-死磕系列&quot;&gt;疯狂创客圈 Java 死磕系列&lt;/h2&gt;
&lt;ul readability=&quot;-0.85082872928177&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Java (Netty) 聊天程序【 亿级流量】实战 开源项目实战&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Netty 源码、原理、JAVA NIO 原理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java 面试题 一网打尽&lt;/strong&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.37209302325581&quot;&gt;
&lt;p&gt;疯狂创客圈 &lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;&lt;strong&gt;【 博客园 总入口 】&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;</description>
<pubDate>Wed, 21 Nov 2018 15:34:00 +0000</pubDate>
<dc:creator>疯狂创客圈</dc:creator>
<og:description>Netty Bootstrap（图解） 疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之18 【 博客园 总入口 】 [toc] 源码工程 源码IDEA工程获取链接 ：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crazymakercircle/p/9998643.html</dc:identifier>
</item>
<item>
<title>深入浅出Android单元测试（一）：单元测试基础 - 程序引力</title>
<link>http://www.cnblogs.com/chengxuyinli/p/9998637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxuyinli/p/9998637.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/21/5bf57844a4872.jpg&quot; alt=&quot;安卓机器人&quot;/&gt;&lt;br/&gt;想学习单元测试无从下手，本文对以最易懂的方式介绍单元测试。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;若有错漏，烦请斧正。转载请注明出处。欢迎关注程序引力&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作者：程序引力 | 谢一 （Evan Xie）&lt;/li&gt;
&lt;li&gt;邮箱：evanyixie@gmail.com&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;软件测试作为软件质量的保障，有着十分重要的意义。按照不同的层次划分，测试也有着诸多的种类。按照测试方式分，有白盒测试、黑盒测试、灰盒测试。按照测试范围或流程来分，有单元测试、集成测试与系统测试等。其中，应用覆盖面最广、也是最为基础的就是单元测试。&lt;/p&gt;
&lt;h3 id=&quot;何为单元测试&quot;&gt;何为单元测试&lt;/h3&gt;
&lt;p&gt;单元测试（Unit Test）又被称为模块测试，是针对程序中最小可测试单元来进行测试的活动。一般来讲，在如今的软件开发工程中，是指对程序中方法（或称函数）的测试。通过为这个方法构造初始化的条件，并运行这个方法，看这个方法的行为是否与预期的一致，以此来决定该方法是否正常。&lt;/p&gt;
&lt;h3 id=&quot;单元测试的意义&quot;&gt;单元测试的意义&lt;/h3&gt;
&lt;h4 id=&quot;快速定位问题&quot;&gt;快速定位问题&lt;/h4&gt;
&lt;p&gt;单元测试的主要作用，就是将原本人工检查程序行为的方式，在最小可测单元范围内，用程序检测程序的方法来代替。为此，单元测试的主要作用就是定位问题。同时，由于单元测试的执行效率较高，可以大批量快速执行。这对于对于单元测试覆盖率较高的工程，若代码工程有任何问题，则可以快速执行全部单元测试，能够帮助开发者快速定位或排除问题。&lt;/p&gt;
&lt;h4 id=&quot;持续集成&quot;&gt;持续集成&lt;/h4&gt;
&lt;p&gt;目前的软件交付要求快速迭代与持续集成，在这样的团队中每一天都有代码合入，并且定期都会有新版本发布。在这一过程中，若使用单元测试覆盖软件各部分，在开发与集成的过程中不对代码进行测试，发现问题就立即告警，则可以提高软件质量与开发效率。&lt;/p&gt;
&lt;h4 id=&quot;优化软件设计与架构&quot;&gt;优化软件设计与架构&lt;/h4&gt;
&lt;p&gt;单元测试并不是在代码开发完毕才开始撰写的，一般情况下都是与开发过程并行或者先与开发过程的。在这个过程中，为了构造可测试的接口与参数，自然会让开发者在软件设计时让程序趋于模块化，并且接口明确，层次清晰。这也就在无形中优化了软件的设计与架构。&lt;/p&gt;
&lt;h4 id=&quot;重构的保障&quot;&gt;重构的保障&lt;/h4&gt;
&lt;p&gt;在重构代码时，可能会影响既有业务和功能，常常会为了解决一个问题而不慎引入更多问题。若有单元测试的覆盖，在重构时则有所保障，能够帮助开发者快速发现问题，提高重构效率。&lt;/p&gt;
&lt;h3 id=&quot;单元测试思路&quot;&gt;单元测试思路&lt;/h3&gt;
&lt;p&gt;开发者在未接触单元测试之前，往往无从下手。其实，单元测试代码的开发与普通程序的开发没有本质的差别。它的核心逻辑是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确认待测试的方法或对象&lt;/li&gt;
&lt;li&gt;为待测试的方法构造初始化条件&lt;/li&gt;
&lt;li&gt;调用（运行）该测试方法&lt;/li&gt;
&lt;li&gt;比较被测试方法的行为（结果）与预期的是否一致&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过这样一个模板或思路去理解单元测试，那就非常简单了。在现行的软件测试实践中，为了提高测试代码的开发效率，业界有着许多测试框架，利用这些测试框架，可以帮助开发者快速开发测试代码。为此，在进行单元测试前，需要根据自身的情况，对单元测试框架做一定的学习。但不管测试框架是怎样的，其核心思路都与上文讨论的一致。&lt;/p&gt;
&lt;h3 id=&quot;单元测试原则&quot;&gt;单元测试原则&lt;/h3&gt;
&lt;p&gt;单元测试原则常被概括为：FIRST，分别是：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;快速（Fast）&lt;br/&gt;单元测试应该能够被快速地执行完毕，执行效率低会让开发者不愿意运行。同时，单元测试需要在整个开发过程中执行很多次，过慢的运行速度会影响开发效率&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;用例独立（Independent）:&lt;br/&gt;单元测试用例之间应该相互独立，最好不要有关联，也不要有执行顺序的要求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可重复（Repeatable）：&lt;br/&gt;单元测试不应该依赖于环境中的数据，它应该有自己的初始化数据或条件，每一次单元测试都是可重复的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可自验证的（Self-Validating）：&lt;br/&gt;单元测试应该不用人工检查，而是可以自验证的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;全面完整的（Thorough）：&lt;br/&gt;单元测试不应该追求每一个方法都覆盖到，而是应该追求所有的使用场景都全面完整的覆盖到。例如对边界条件，错误输入，大数据量的情况都要覆盖到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;android单元测试分类&quot;&gt;Android单元测试分类&lt;/h3&gt;
&lt;p&gt;按照单元测试运行的环境区分，可以分为本地测试以及设备测试.&lt;/p&gt;
&lt;h4 id=&quot;本地测试&quot;&gt;本地测试&lt;/h4&gt;
&lt;p&gt;本地测试(Local unit test)运行在JVM中，一般适用于对于没有Android依赖的测试。该部分测试代码一般放置于安卓工程的&amp;lt;模块名&amp;gt;/src/test/java中。&lt;/p&gt;
&lt;h4 id=&quot;设备测试&quot;&gt;设备测试&lt;/h4&gt;
&lt;p&gt;设备测试（Instrumented test)运行在手机或模拟器中，一般适用于需要Android依赖的测试。该部分测试代码一般放置于安卓工程的&amp;lt;模块名&amp;gt;/src/androidTest/java中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：测试代码直接支持对Android的依赖。&lt;/li&gt;
&lt;li&gt;缺点：需要真机或模拟器配合，运行速度较本地测试稍慢。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，在这类测试过程中是编译了一个额外的Apk，并安装到手机或模拟器中运行的。&lt;/p&gt;
&lt;h3 id=&quot;测试框架选择&quot;&gt;测试框架选择&lt;/h3&gt;
&lt;p&gt;目前流行的Android测试框架较多，按照对Android依赖的强弱情况，可以分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无依赖：JUnit&lt;/li&gt;
&lt;li&gt;弱依赖：AndroidJUnitRunner、Mockito&lt;/li&gt;
&lt;li&gt;强依赖：Espresso&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;开发者可以根据自身情况来对测试框架进行选择，若仅仅测试无安卓依赖的Java代码，可以仅仅使用JUnit框架。若待测试的代码对安卓库有一定的弱依赖，则可以选择AndroidJUnitRunner、Mockito。若待测试代码对安卓库有着非常强的依赖，可以选择Espresso。&lt;/p&gt;
&lt;p&gt;这些框架除了可以满足待测试代码对安卓库的不同依赖情况，还有各自不同的特点，如运行环境与条件均可能存在差异。开发者可以对所需要的框架有一个大致了解后，再选择进行学习。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;若你喜欢本文或觉得有所帮助，请点赞或关注。&lt;br/&gt;你的支持是对笔者最大的鼓励与肯定。比芯~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/21/5bf579f822a3f.png&quot; alt=&quot;底部关注二维码：小&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 15:33:00 +0000</pubDate>
<dc:creator>程序引力</dc:creator>
<og:description>想学习单元测试无从下手，本文对以最易懂的方式介绍单元测试。 若有错漏，烦请斧正。转载请注明出处。欢迎关注程序引力 作者：程序引力 | 谢一 （Evan Xie） 邮箱：evanyixie@gmail.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxuyinli/p/9998637.html</dc:identifier>
</item>
<item>
<title>聊聊RPC原理二 - 黄青石</title>
<link>http://www.cnblogs.com/huangqingshi/p/9998404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangqingshi/p/9998404.html</guid>
<description>&lt;p&gt;　　之前写了一篇关于RPC的文章，浏览量十分感人:)，但是感觉&lt;a href=&quot;https://www.cnblogs.com/huangqingshi/p/7803642.html&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;写得有些粗，觉得很多细节没有讲出来，这次把里边的细节再次补充和说明。&lt;/p&gt;
&lt;p&gt;　　这次主要说的内容分为：&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1. RPC的主要结构图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.分析结构图的中的细节和步骤。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　关于RPC，大家都不陌生，其简写和介绍什么的我就不过多介绍了，可以从我上篇文章中看到，下面直接上我画的图，简单粗暴：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236784/201811/1236784-20181121220619042-1395610606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　RPC的主要目的是将一个庞大的系统分离成不同的子系统，按照不同的功能，比如读库功能，记录日志等可以单独出来的功能单独出来，这样的好处是，不会像以前那样庞大的系统部署的时候每次都要整个系统进行重启，可以修改单独的模块，并且自己独立部署，这样大大提升效率。但是如果拆分的过细的话，可能需要维护很多的小项目，代码工程由一个大工程，拆分成很多小工程，而且启动功能并且进行测试的话一般至少启动两个服务，一个server和一个client，同时相应的zookeeper也要启动。&lt;/p&gt;
&lt;p&gt;　　下面来说一下上图中每个模块的功能。&lt;/p&gt;
&lt;p&gt;　　先来说一下zookeeper, 可能有些同学已经很熟悉zookeeper使用了，当然我也在博客中写过zookeepr实现的锁&lt;a href=&quot;https://www.cnblogs.com/huangqingshi/p/9650837.html&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;，它非常强大，但是这里不过多解释它强大之处，这次说它的作用。在RPC中zookeeper承担着服务的注册，心跳检测，记录client的相关信息，最关键的是要记录server的IP和端口号以及它提供service信息，版本号等信息。每个client在调用之前都要从zookeeper那里获取存活server的相关信息及提供服务的版本。这样client拿到这些信息后可以直接和server进行通信了。&lt;/p&gt;
&lt;p&gt;　　里边有一个细节就是client和server在zookeeper中注册的znode是临时的ephemral的，这样的目的是在心跳检测的时候发现client或者server已经down了，需要从zk中剔除，这样client连接server失败的情况下重新从zookeeper中获取有效的server及service信息。&lt;/p&gt;
&lt;p&gt;　　接下来就是server，在一些大型系统中，其实server是由很多台机器构成的，这里我为了简化就画了一台机器，当server和其中部署的service启动之后需要到zookeeper中进行注册，这样client就可以发现新部署的service了，通过zookeeper实现了动态的service上线和下线，是不是很厉害。在server中，由service声明和implementation实现，同时还有在使用过程中对应的bean对象。当然在server中还部署着netty服务，这个一会儿咱们就说。&lt;/p&gt;
&lt;p&gt;　　继续看client，client在这里边充当着的是consumer，就是消费service所produce的服务。client应该也是多台的。client其实就相对比较简单，因为是调用方，所以只需要声明对应的service接口和相应的bean对象就行了。&lt;/p&gt;
&lt;p&gt;　　然后就是netty服务了，这次咱们不说netty的详细内容，大家知道它是用来进行通信的，拥有高吞吐量，高并发，多协议实现，并且支持NIO，AIO的工具。有兴趣的同学可以读一些关于netty的文章。netty在这里扮演的角色就是通信，将调用的service以及相关的bean对象和参数进行序列化，找到从zookeeper获取的service所在的主机、IP、端口号、服务及版本等信息后进行TCP连接，发送给server后，在server中也有一个netty在对应的端口进行接口，接收后进行反序列化，然后通过动态代理实现接口调用，关于动态代理的实现可以参考我之前写过的&lt;a href=&quot;https://www.cnblogs.com/huangqingshi/p/7651376.html&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;。调用之后获取到执行结果后再以相反的顺序返回去。这就是netty实现的功能了。&lt;/p&gt;
&lt;p&gt;　　这块基本就是RPC的主要核心实现细节，当然里边可能还会有一些细节我没有提到，因为RPC的功能也在不断完善中，所以还有一些新增的一些功能没有提及，比如server机器的比重等，这些在用到的工程中一看应该就会明白。&lt;/p&gt;
&lt;p&gt;　　好了，希望你们能从这篇文章中获得收获。&lt;/p&gt;
&lt;p&gt;　　欢迎转载，但转载请署名黄青石，谢谢。&lt;/p&gt;



</description>
<pubDate>Wed, 21 Nov 2018 14:43:00 +0000</pubDate>
<dc:creator>黄青石</dc:creator>
<og:description>之前写了一篇关于RPC的文章，浏览量十分感人:)，但是感觉文章写得有些粗，觉得很多细节没有讲出来，这次把里边的细节再次补充和说明。 这次主要说的内容分为： 1. RPC的主要结构图。 2.分析结构图的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangqingshi/p/9998404.html</dc:identifier>
</item>
<item>
<title>两个星期，用Flutter撸个APP - Game_over</title>
<link>http://www.cnblogs.com/game-over/p/9998392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/game-over/p/9998392.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Flutter是Google推出的跨平台的解决方案，Slogan是“Design beautiful apps”，国内也有知名企业在使用和推广，例如阿里、美团都有在尝试。&lt;/p&gt;
&lt;p&gt;个人对其中的一些特性，比如JIT、Material Design、快速开发等很感兴趣，于是决定尝试一下。&lt;/p&gt;
&lt;h3 id=&quot;诗词汇&quot;&gt;诗词汇&lt;/h3&gt;
&lt;p&gt;于是诞生了诗词汇APP，首先看一下是个什么样的APP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/15038736-01c04a047b8dacdc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们一步步从不同方面说说Flutter的开发。&lt;/p&gt;
&lt;h3 id=&quot;开始&quot;&gt;开始&lt;/h3&gt;
&lt;p&gt;FLutter可以在Windows、Linux、Mac上进行开发，开发工具可以使用VS Code、Android Studio、IDEA等，本文推荐使用Android Studio，主要在于Android Studio提供了FLutter Inspector工具，可以实时审查元素，解决界面的显示适配问题。&lt;/p&gt;
&lt;h4 id=&quot;搭建开发环境&quot;&gt;搭建开发环境&lt;/h4&gt;
&lt;p&gt;搭建环境的主要步骤：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-0.55555555555556&quot;&gt;
&lt;p&gt;下载SDK，&lt;a href=&quot;https://flutter.io/docs/get-started/install&quot;&gt;下载地址&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置PATH，如果使用Mac或者Linux系统，一定要将&lt;code&gt;bin&lt;/code&gt;目录添加到系统PATH。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置依赖源镜像，这一步很重要，并且需要将脚本放到启动shell中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;
export PUB_HOSTED_URL=https://pub.flutter-io.cn

export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;-0.875&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行&lt;code&gt;flutter doctor&lt;/code&gt;，这一步耗时会很长，需要耐心等耐。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.6875&quot;&gt;
&lt;p&gt;安卓开发工具及插件，&lt;a href=&quot;https://flutter.io/docs/get-started/editor&quot;&gt;配置编辑器&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;配置编辑器&quot;&gt;配置编辑器&lt;/h4&gt;
&lt;p&gt;主要是给编辑器安装相应的插件。&lt;/p&gt;
&lt;p&gt;VS Code安装&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter&quot;&gt;flutter插件&lt;/a&gt;，Android Studio和IDEA需要安装Flutter和Darter插件。&lt;/p&gt;
&lt;p&gt;其中Android Studio和IDEA基本一样，跟VS Code的主要区别在于：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;VS Code提供了更好的代码提示功能&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IDEA提供了Flutter Inspector，可实时审查页面元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可根据个人喜好、习惯选择使用。&lt;/p&gt;
&lt;h4 id=&quot;推荐网站&quot;&gt;推荐网站&lt;/h4&gt;
&lt;p&gt;在安装、配置过程中，可参考以下中文资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://flutter-io.cn/&quot;&gt;Flutter中国&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://doc.flutter-dev.cn/docs/&quot;&gt;Flutter中文文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;主要技术点&quot;&gt;主要技术点&lt;/h3&gt;
&lt;h4 id=&quot;dart&quot;&gt;Dart&lt;/h4&gt;
&lt;p&gt;Flutter项目的开发语言是Dart，Dart 是由 Google 开发的一种面向对象语言，可以编译成 ARM 和 x86 代码直接运行在 iOS、Android 设备上。&lt;/p&gt;
&lt;p&gt;推荐先学习Dart语言&lt;a href=&quot;https://www.dartlang.org/guides/language/language-tour&quot;&gt;官方教程&lt;/a&gt;，对Dart有初步了解之后再进行Flutter的学习和开发。&lt;/p&gt;
&lt;h4 id=&quot;界面开发&quot;&gt;界面开发&lt;/h4&gt;
&lt;p&gt;终于可以进入Flutter本身了。&lt;/p&gt;
&lt;h5 id=&quot;widget&quot;&gt;Widget&lt;/h5&gt;
&lt;p&gt;Flutter中页面所有元素都是Widget，又分为StatelessWidget和StatefulWidget。&lt;/p&gt;
&lt;p&gt;顾名思义，StatelessWidget 就是指无可变状态的 Widget，这类 Widget 的状态只由创建 Widget 时传入的参数决定，一旦创建，其状态、在页面上的展示效果也就不再改变。&lt;/p&gt;
&lt;p&gt;而 StatefulWidget 内部则存在着可变状态。当通过setState改变这些状态时，Flutter 会重新渲染该 Widget。&lt;/p&gt;
&lt;h5 id=&quot;布局&quot;&gt;布局&lt;/h5&gt;
&lt;p&gt;在实际开发中，主要使用了Row、Column、Container、Expanded、Stack等。&lt;/p&gt;
&lt;p&gt;Row、Column提供了水平、垂直方向的布局，Stack提供了堆叠方式的布局，各种容器有不同的特性，可根据实际页面需求选择搭配不同的布局。&lt;/p&gt;
&lt;p&gt;推荐学习 &lt;a href=&quot;https://flutter.io/docs&quot;&gt;官方文档&lt;/a&gt; 及 &lt;a href=&quot;https://flutterchina.club/docs/&quot;&gt;国内维护的中文翻译&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;主要插件&quot;&gt;主要插件&lt;/h4&gt;
&lt;p&gt;话题切回到诗词汇APP，本APP收集了4000余位诗人的30多万首诗词，提供了古诗词的查询、收藏、朗诵功能，并且实现了初步的社区功能。&lt;/p&gt;
&lt;p&gt;项目目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/15038736-41bee798c8cfa7a9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开发这个APP大概用了一个月的业余时间，每天抽出一两个小时，这样折算为工作日，大概是两个星期左右，开发效率还是很高的。&lt;/p&gt;
&lt;p&gt;下面跟大家分享一下主要功能及所使用的一些插件。&lt;/p&gt;
&lt;h5 id=&quot;切换主题&quot;&gt;切换主题&lt;/h5&gt;
&lt;p&gt;为了实现实时切换主题颜色，使用了状态管理插件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/flutter_redux&quot;&gt;flutter_redux&lt;/a&gt; 。&lt;/p&gt;
&lt;h5 id=&quot;极光推送&quot;&gt;极光推送&lt;/h5&gt;
&lt;p&gt;在国内厂商中，极光是少有的对Flutter提供了技术支持的，这里给极光大大的👍。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/jpush_flutter&quot;&gt;jpush_flutter&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;qq&quot;&gt;QQ&lt;/h5&gt;
&lt;p&gt;QQ的Flutter插件提供了基本的登录、分享功能。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/flutter_qq&quot;&gt;flutter_qq&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;微信&quot;&gt;微信&lt;/h5&gt;
&lt;p&gt;微信的Flutter插件提供的功能稍微丰富，包含了支付、登录、分享、启动小程序的功能。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/fluwx&quot;&gt;fluwx&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;事件总线event-bus&quot;&gt;事件总线Event Bus&lt;/h5&gt;
&lt;p&gt;大名鼎鼎的event_bus也提供了对Flutter的支持。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/event_bus&quot;&gt;event_bus&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;音频&quot;&gt;音频&lt;/h5&gt;
&lt;p&gt;录音及播放音频也有很好的支持。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/audio_recorder&quot;&gt;audio_recorder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/audioplayer2&quot;&gt;audioplayer2&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;其它&quot;&gt;其它&lt;/h5&gt;
&lt;p&gt;其它诸如加载HTML、Toast提示、图片选择器、图片加载等也有较好的插件支持。&lt;/p&gt;
&lt;p&gt;可在 &lt;a href=&quot;https://pub.flutter-io.cn/&quot;&gt;官方插件库&lt;/a&gt; 查询相关的插件。&lt;/p&gt;
&lt;h3 id=&quot;坑&quot;&gt;坑&lt;/h3&gt;
&lt;h4 id=&quot;安装升级&quot;&gt;安装、升级&lt;/h4&gt;
&lt;p&gt;FLutter的安装、升级会经常遇到卡死的问题，主要原因就是使用了Google的源，但是莫名的，即使使用了科学上网、设置了国内镜像后，也会遇到同样的问题。只能通过反复的&lt;code&gt;flutter doctor&lt;/code&gt; 或 &lt;code&gt;flutter upgrade&lt;/code&gt;直到解决问题。&lt;/p&gt;
&lt;h4 id=&quot;开发&quot;&gt;开发&lt;/h4&gt;
&lt;p&gt;由于笔者最近一段时间Android项目做得较多，习惯了Android的XML布局方式，对于在代码中编写页面的形式一开始还有些不习惯，但是在按照官方例子实践了几个页面后，用代码写页面的优势就体现出来了。&lt;/p&gt;
&lt;p&gt;在页面已经设计好的情况下，开发的时候脑海中就构思出一个Widget树，从根节点到每一个节点一级一级嵌套下去，自然而然的布局就写好了。&lt;/p&gt;
&lt;h4 id=&quot;dialog弹出框&quot;&gt;Dialog弹出框&lt;/h4&gt;
&lt;p&gt;使用Dialog的时候，弹出Dialog的Context及Dialog本身都会压入栈中，所以让Dialog消失的方法是&lt;code&gt;Navigator.of(ctx).pop()&lt;/code&gt;，这样的设计既不同于Android也不同于iOS，也许跟Flutter本身所有元素都是Widget的设计有关。&lt;/p&gt;
&lt;h4 id=&quot;编译&quot;&gt;编译&lt;/h4&gt;
&lt;p&gt;在编译Android版本的时候很顺畅，没有遇到任何问题。但是在编译iOS版本的时候，遇到了很多问题，直到现在也没有解决。&lt;/p&gt;
&lt;p&gt;问题在于使用了&lt;code&gt;audio_recorder&lt;/code&gt;和&lt;code&gt;flutter_qq&lt;/code&gt;两个插件，而这两个插件一个要求编译选项需要设置&lt;code&gt;!use_framework&lt;/code&gt;，一个要求不能设置，造成了冲突，在实际编译中一直编译不通过。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;开发结束，最终打包了Release版本的APK，安装到手机后，发现惊喜。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;竟然如丝般顺滑，这是我始料未及的，转场效果、页面相应速度不输原生APP。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总而言之，个人对Flutter的前景相当看好，毕竟是Google大厂出品，并且项目本身的迭代速度很快，目前已经是0.11版本，期望在不远的将来发布正式的1.0版本，更期望国内厂商加大对Flutter的支持力度。&lt;/p&gt;
&lt;p&gt;**顺便推广一下笔者的诗词汇APP，欢迎大家 &lt;a href=&quot;https://android.myapp.com/myapp/detail.htm?apkName=com.liuzb.allpoems&quot;&gt;下载试用&lt;/a&gt; ，或者访问 &lt;a href=&quot;https://52gushici.cn/&quot;&gt;诗词汇&lt;/a&gt; 体验下Flutter如丝般的顺滑。^_^**&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/15038736-59805a7508bf3e5b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 14:42:00 +0000</pubDate>
<dc:creator>Game_over</dc:creator>
<og:description>前言 Flutter是Google推出的跨平台的解决方案，Slogan是“Design beautiful apps”，国内也有知名企业在使用和推广，例如阿里、美团都有在尝试。 个人对其中的一些特性，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/game-over/p/9998392.html</dc:identifier>
</item>
<item>
<title>IOS免越狱虚拟定位修改工具共享 Jocation - 董侨</title>
<link>http://www.cnblogs.com/jonneydong/p/9998324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jonneydong/p/9998324.html</guid>
<description>
&lt;p&gt;Jocation IOS虚拟定位修改器 具体使用方法可以按照 location cleaned软件相同的操作.&lt;/p&gt;
&lt;p&gt;主要是因为本人有一部 IphoneX 和Iphone Xs Max 网上的location cleaned破解软件只支持 Xs以下设备. 而作者最新版本的软件虽说支持了xs 但是会对系统进行老版本的删除操作, 具有病毒的式的操作.&lt;/p&gt;
&lt;p&gt;因为原location cleaned作者对软件进行收费,并且软件有病毒式操作,因此萌生自己开发一个工具自己用.&lt;/p&gt;
&lt;p&gt;经过查阅相关文档,发现实现功能并不难, 因此花了两个小时将功能实现了. 后因朋友推荐不如做成成品软件供需要的人使用. 特此将软件做成跟location cleaned相同的界面以供大家使用.相同的功能,相同的界面,相同的体验.&lt;/p&gt;
&lt;p&gt;Jocation下载地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/jonneydong/JocationRelease/raw/master/Jocation_v1.0(IOS%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D).zip&quot;&gt;https://gitee.com/jonneydong/JocationRelease/raw/master/Jocation_v1.0(IOS%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D).zip&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 14:30:00 +0000</pubDate>
<dc:creator>董侨</dc:creator>
<og:description>Jocation IOS虚拟定位修改器 具体使用方法可以按照 location cleaned软件相同的操作. 主要是因为本人有一部 IphoneX 和Iphone Xs Max 网上的locatio</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jonneydong/p/9998324.html</dc:identifier>
</item>
<item>
<title>Dora.Interception，为.NET Core度身打造的AOP框架 [2]：以约定的方式定义拦截器 - Artech</title>
<link>http://www.cnblogs.com/artech/p/dora-interception-02.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/dora-interception-02.html</guid>
<description>&lt;p&gt;上一篇《&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-01.html&quot;&gt;更加简练的编程体验&lt;/a&gt;》提供了最新版本的Dora.Interception代码的AOP编程体验，接下来我们会这AOP框架的编程模式进行详细介绍，本篇文章着重关注的是拦截器的定义。采用“&lt;strong&gt;&lt;span&gt;基&lt;/span&gt;&lt;span&gt;于约定&lt;/span&gt;&lt;/strong&gt;”的Interceptor定义方式是Dora.Interception区别于其他AOP框架的一个显著特征，要了解拦截器的编程约定，就得先来了解一下Dora.Interception中针对方法调用的拦截是如何实现的。&lt;/p&gt;

&lt;p&gt;总地来说，Dora.Interception针对方法调用的拦截机制分为两种类型，我将它称为“&lt;span&gt;&lt;strong&gt;针对实例的拦截&lt;/strong&gt;&lt;/span&gt;”和“&lt;strong&gt;&lt;span&gt;针对类型&lt;/span&gt;&lt;/strong&gt;”的拦截。针对实例的拦截应用于针对接口的方法调用，其原理如下所示：类型Foobar实现了接口IFoobar，如果需要拦截以接口的方式调用Foobar对象的某个方法，我们可以动态生成另一个用来封装Foobar对象的FoobarProxy类型，FoobarProxy同样实现IFoobar接口，我们在实现的方法中实现对Interceptor链的调用。我们最终将原始提供的Foobar对象封装成FoobarProxy对象，那么针对Foobar的方法调用将转换成针对FoobarProxy对象的调用，拦截得以实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201811/19327-20181121220630063-1654522377.png&quot;&gt;&lt;img width=&quot;530&quot; height=&quot;108&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201811/19327-20181121220630404-1845661468.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果Foobar并未实现任何接口，或者针对它的调用并非以接口的方式进行，那么我们只能采用“针对类型的拦截”，其原理如下：我们动态创建Foobar的派生类型FoobarProxy，并重写其需要被拦截的虚方法来实现对Interceptor链的调用。我们最终创建FoobarProxy对象来替换掉原始的Foobar对象，那么针对Foobar的方法调用将转换成针对FoobarProxy对象的调用，拦截得以实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201811/19327-20181121220630621-1780814130.png&quot;&gt;&lt;img width=&quot;545&quot; height=&quot;125&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201811/19327-20181121220630880-440969547.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于这种拦截方式会直接创建代理对象，无法实现针对目标对象的封装，当我们进行DI服务注册的时候，只能指定注册服务的实现类型，不能指定一个现有的Singleton实例或者提供一个创建实例的Factory。&lt;/p&gt;

&lt;p&gt;要理解Dora.Interception的设计，先得从如下这两个特殊的Delegate类型（&lt;strong&gt;InterceptDelegate&lt;/strong&gt;和&lt;strong&gt;InterceptorDelegate&lt;/strong&gt;）说起。InterceptDelegate代表针对方法的拦截操作，作为输入参数的InvocationContext提供了当前方法调用的所有上下文信息，返回类型被设置为Task意味着Dora.Interception提供了针对基于Task的异步编程的支持。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt; Task InterceptDelegate(InvocationContext context);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt; InterceptDelegate InterceptorDelegate(InterceptDelegate next);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InvocationContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] Arguments { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; MethodBase Method { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; InterceptDelegate Next { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Proxy { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; ReturnValue { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Target { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MethodBase TargetMethod { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; ExtendedProperties { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task ProceedAsync();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;InterceptDelegate表示的是“拦截操作”，即表示作用于InvocationContext上下文上的一个Task，但它并不能表示一个拦截器对象。原因很简单，因为注册到同一个方法上的多个拦截器对象会构成一个链条，最终决定是否调用后一个拦截器或者目标方法（对于链条尾部的Interceptor）是由当前拦截器决定的，所以如果将Interceptor也表示成委托对象，它的输入应该是一个InterceptDelegate对象，表示针对后一个拦截器或者目标方法的调用，它返回的同样也是一个InterceptDelegate对象，表示将自身纳入拦截器链之后，新的拦截器链条（包括调用目标方法）所执行的操作。&lt;/p&gt;
&lt;p&gt;所以一个Interceptor在Dora.Interception中应该表示成一个Func&amp;lt;InterceptDelegate, InterceptDelegate&amp;gt;对象，这与ASP.NET Core的中间件管道其实是一回事。简单起见，我们为它专门定义了一个委托类型InterceptorDelegate。&lt;/p&gt;

&lt;p&gt;虽然Dora.Interception总是将Interceptor对象表示成上面介绍的InterceptorDelegate类型的委托，但是为了更好的编程体验，我们可以选择采用POCO类型的方法来定义Interceptor。为了提供更好的灵活性，能够在方法中动态注入任意依赖服务，我们并不打算为这样的Interceptor类型定义一个接口。接口是一个契约，同时也是一个&lt;strong&gt;&lt;span&gt;限制&lt;/span&gt;&lt;/strong&gt;。如果类型实现某个接口，意味着必需按照规定的声明实现其方法，针对方法的服务注入将无法实现，所以Dora.Interception采用“基于约定”的方式来定义Interceptor类型。具体的约定如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Interceptor只需要定义一个普通的&lt;span&gt;&lt;strong&gt;实例类型&lt;/strong&gt;&lt;/span&gt;即可。&lt;/li&gt;
&lt;li&gt;Interceptor类型必须具有一个&lt;span&gt;&lt;strong&gt;公共构造函数&lt;/strong&gt;&lt;/span&gt;，它可以包含任意的参数，并支持&lt;span&gt;&lt;strong&gt;构造器注入&lt;/strong&gt;&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;拦截功能实现在约定的&lt;span&gt;&lt;strong&gt;InvokeAsync&lt;/strong&gt;&lt;/span&gt;的方法中，这是一个返回类型为&lt;span&gt;&lt;strong&gt;Task&lt;/strong&gt;&lt;/span&gt;的异步方法，它的第一个参数类型为&lt;span&gt;&lt;strong&gt;InvocationContext&lt;/strong&gt;&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;除了表示当前执行上下文的参数之外， 任何可以注入的服务于对象都可以定义成InvokeAsync方法的参数。&lt;/li&gt;
&lt;li&gt;当前Interceptor针对后续的Interceptor或者目标方法的调用通过调用InvocationContext的&lt;span&gt;&lt;strong&gt;ProceedAsync&lt;/strong&gt;&lt;/span&gt;方法来实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下所示的就是一个典型的Interceptor，它提供了针对构造函数和方法的注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarInterceptor
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IFoo Foo { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Baz { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarInterceptor(IFoo foo, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; baz)
    {
        Foo &lt;/span&gt;=&lt;span&gt; foo;
        Baz &lt;/span&gt;=&lt;span&gt; baz;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync(InvocationContext context, IBar bar)
    {
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Foo.DoSomethingAsync();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; bar.DoSomethingAsync();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.ProceedAsync();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-01.html&quot;&gt;[1]：更加简练的编程体验&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-02.html&quot;&gt;[2]：基于约定的拦截器定义方式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-03.html&quot;&gt;[3]：多样性的拦截器应用方式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-04.html&quot;&gt;[4]：与依赖注入框架的深度整合&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-05.html&quot;&gt;[5]：对拦截机制的灵活定制&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 14:07:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>上一篇《更加简练的编程体验》提供了最新版本的Dora.Interception代码的AOP编程体验，接下来我们会这AOP框架的编程模式进行详细介绍，本篇文章着重关注的是拦截器的定义。采用“基于约定”的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/artech/p/dora-interception-02.html</dc:identifier>
</item>
<item>
<title>.NET Core实战项目之CMS 第三章 入门篇-源码解析配置文件及依赖注入 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9998021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9998021.html</guid>
<description>&lt;blockquote readability=&quot;2.125&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9998021.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9998021.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;上篇文章我给大家讲解了ASP.NET Core的概念及为什么使用它，接着带着你一步一步的配置了.NET Core的开发环境并创建了一个ASP.NET Core的mvc项目，同时又通过一个实战教你如何在页面显示一个Content的列表。不知道你有没有跟着敲下代码，千万不要做眼高手低的人哦。这篇文章我们就会设计一些复杂的概念了，因为要对ASP.NET Core的启动及运行原理、配置文件的加载过程进行分析，依赖注入，控制反转等概念的讲解等。俗话说，授人以鱼不如授人以渔，所以文章旨在带着大家分析源码，让大家能知其然更能知其所以然。为了偷懒，继续使用上篇文章的例子了！有兴趣的朋友可以加群637326624相互交流！&lt;br/&gt;再次感谢张队的审稿！&lt;/p&gt;
&lt;h2 id=&quot;asp.net-core启动源码解析&quot;&gt;ASP.NET Core启动源码解析&lt;/h2&gt;
&lt;p&gt;这部分我就带着大家一起看下asp.net core项目的运行流程吧！顺带着了解下asp.net core的运行原理，说的不好的话，希望大家给以指正，从而能够正确的帮助更多的人。&lt;/p&gt;
&lt;ol readability=&quot;44.706723073405&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;首先上一下上篇文章的项目结构吧，如下所示，熟悉C#的朋友应该知道，要找程序的入库，那么就应该找到Main方法。而asp.net core的main方法就在Program.cs文件中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213438879-1797210540.png&quot; alt=&quot;1542771232412&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;打开后看到如下的代码，我加了注释，大伙将就看下，下面我们来一步一步的分析&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
        /// Main方法，程序的入口方法
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static void Main(string[] args)
        {
            CreateWebHostBuilder(args)//调用下面的方法，返回一个IWebHostBuilder对象
                .Build()//用上面返回的IWebHostBuilder对象创建一个IWebHost
                .Run();//运行上面创建的IWebHost对象从而运行我们的Web应用程序换句话说就是启动一个一直运行监听http请求的任务
        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)//使用默认的配置信息来初始化一个新的IWebHostBuilder实例
                .UseStartup&amp;lt;Startup&amp;gt;();// 为Web Host指定了Startup类&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到asp.net core程序实际上就是一个控制台程序，运行一个webhost对象从而启动一个一直运行的监听http请求的任务。所以我们的重点就是分析一下这个WebHost创建的过程：&lt;br/&gt;创建IWebHostBuilder-》创建IWebHost-》然后运行创建的IWebHost。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这里我们从IWebHostBuilder的&lt;strong&gt;Build&lt;/strong&gt;分析下创建的过程，有兴趣的朋友可以看下，没兴趣的朋友可以直接跳到下一个步骤继续阅读。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;16.7&quot;&gt;&lt;li readability=&quot;1.7461024498886&quot;&gt;
&lt;p&gt;首先到aspnetcore的github开源地址https://github.com/aspnet/AspNetCore/tree/release/2.1 上去下载源码（我们使用的是2.1）。然后使用vscode打开解压后的文件夹。至于vscode如何加载文件，你可以看我这篇文章&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9926078.html&quot;&gt;使用Visual Studio Code开发.NET Core看这篇就够了&lt;/a&gt; 当然你也可以在上面的网页上直接找到相应的目录浏览也是可以的。（看结构好像是使用vscode进行开发的）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;根据IWebHostBuilder的命名空间我们找到了它的实现，路径为src/Hosting/Hosting/src/WebHostBuilder.cs&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213438602-229104760.png&quot; alt=&quot;1542782994757&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;通过上面的代码我们可以看到首先是通过BuildCommonServices来构建一个ServiceCollection。为什么说这么说呢，先让我们我们跳转到BuidCommonServices方法中看下吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213438244-1309490072.png&quot; alt=&quot;1542784242634&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，&lt;code&gt;var services = new ServiceCollection();&lt;/code&gt;首先new一个ServiceCollection然后往services里面注入很多内容，比如：WebHostOptions ，IHostingEnvironment ，IHttpContextFactory ，IMiddlewareFactory 等等（其实这里已经设计到依赖注入的概念了，先思考下吧），然后我们在后续就可以使用了！最后这个BuildCommonServices就返回了这个services对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在上面的依赖注入中有一个方法，不知道大家注意到没有，因为我们在步骤2贴出的代码里面有一个&lt;code&gt;UseStartup&amp;lt;Startup&amp;gt;()&lt;/code&gt; 其实在上面的BuildCommonServices方法中也有对&lt;code&gt;IStartup&lt;/code&gt;的注入的。首先，判断Startup类是否继承于IStartup接口，如果是继承的，那么就可以直接加入在services 里面去，如果不是继承的话，就需要通过ConventionBasedStartup(methods)把method转换成IStartUp后注入到services里面去。结合上面我们的代码，貌似我们平时用的时候注入的方式都是采用后者。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我们再回到build方法拿到了BuildCommonServices方法构建的ServiceCollection实例后，通过GetProviderFromFactory(hostingServices) 方法构造出了IServiceProvider 对象。到目前为止，IServiceCollection和IServiceProvider都拿到了。然后根据IServiceCollection和IServiceProvider对象构建WebHost对象。构造了WebHost实例还不能直接返回，还需要通过Initialize对WebHost实例进行初始化操作。那我们看看在初始化函数&lt;strong&gt;Initialize中&lt;/strong&gt;，都做了什么事情吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213437947-1485998.png&quot; alt=&quot;1542786448255&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这里我们把代码导航到src/Hosting/Hosting/src/Internal/WebHost.cs找到Initialize方法。如下图所示：主要就是一个EnsureApplicationServices 方法。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213437665-169962483.png&quot; alt=&quot;1542787078949&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们继续导航查看这个方法的内容如下：就是拿到Startup 对象，然后把_applicationServiceCollection 中的对象注入进去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213437379-1519205760.png&quot; alt=&quot;1542787219703&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;至此我们build中注册的对象以及StartUp中注册的对象都已经加入到依赖注入容器中了，接下来就是Run起来了。这个run的代码在src\Hosting\Hosting\src\WebHostExtensions.cs中，代码如下：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213436983-885259821.png&quot; alt=&quot;1542787884205&quot;/&gt;WebHost执行RunAsync运行web应用程序并返回一个只有在触发或关闭令牌时才完成的任务（这里又涉及到异步编程的知识了，咱们以后再详细讲解） 。这就是我们运行ASP.Net Core程序的时候，看到的那个命令行窗口了，如果不关闭窗口或者按Ctrl+C的话是无法结束的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;至此启动的过程的源码分析完成了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;配置文件&quot;&gt;配置文件&lt;/h2&gt;
上面给大家介绍了ASP.NET Core的启动过程，中间牵扯到了一些依赖注入的概念。关于依赖注入的概念呢，我们后面再说，这里先给大家讲解下配置文件的加载过程。&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;打开上篇文章我们创建的项目，并在appsettings.json里面加入如下内容：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Warning&quot;
    }
  },
  &quot;Content&quot;: {
    &quot;Id&quot;: 1,
    &quot;title&quot;: &quot;title1&quot;,
    &quot;content&quot;: &quot;content1&quot;,
    &quot;status&quot;: 1,
    &quot;add_time&quot;: &quot;2018-11-21 16:29&quot;,
    &quot;modify_time&quot;: null
  },
  &quot;AllowedHosts&quot;: &quot;*&quot;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;然后在Startup类中ConfigureServices中注册TOptions对象如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; services.Configure&amp;lt;Content&amp;gt;(Configuration.GetSection(&quot;Content&quot;));//注册TOption实例对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码也就是从appsettings.json这个配置文件中的&lt;code&gt;Content&lt;/code&gt;这个节点匹配到Content这个对象上。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;修改下ContentController这个控制器代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private readonly Content contents;
        public ContentController(IOptions&amp;lt;Content&amp;gt; option)
        {
            contents = option.Value;
        }
        /// &amp;lt;summary&amp;gt;
        /// 首页显示
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public IActionResult Index()
        {

            return View(new ContentViewModel { Contents=new List&amp;lt;Content&amp;gt; { contents} });
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;按下F5运行下，然后导航到Content目录看到如下页面：说明成功从appsettings.json这个文件中加载了内容。这一切是怎么发生的呢？下面我们就一步一步的来分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213436707-1008587323.png&quot; alt=&quot;1542792298052&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们回过头来看我们的Main方法，发现里面有一个CreateDefaultBuilder方法，就是这个方法里面为我们做了一些默认的设置，然后加载我们的配置文件的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213436434-453312146.png&quot; alt=&quot;1542801612869&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我们在源码里面找到CreateDefaultBuilder 的源码（反正我找了半天，起初在Hosting下面找，实际上在MetaPackages下面的），位置在src\MetaPackages\src\Microsoft.AspNetCore\WebHost.cs 有的人可能找不到哦，可以看到这个方法会在ConfigureAppConfiguration 的时候默认加载&lt;code&gt;appsetting&lt;/code&gt;文件，并做一些初始的设置，所以我们不需要任何操作，就能加载&lt;code&gt;appsettings&lt;/code&gt; 的内容了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213436128-559978156.png&quot; alt=&quot;1542801370627&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;既然知道了原理后，我们就试着重写下这个&lt;code&gt;ConfigureAppConfiguration&lt;/code&gt; 然后加载我们自定义的json文件吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;鼠标右键新建一个Content.json文件，然后输入如下的内容：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;{
  &quot;ContentList&quot;: 
    {
      &quot;Id&quot;: 1,
      &quot;title&quot;: &quot;title1 from diy json&quot;,
      &quot;content&quot;: &quot;content1 from diy json&quot;,
      &quot;status&quot;: 1,
      &quot;add_time&quot;: &quot;2018-11-21 16:29&quot;,
      &quot;modify_time&quot;: null
    }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;然后打开Program.cs。按如下代码进行改造：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
        /// Main方法，程序的入口方法
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static void Main(string[] args)
        {
            CreateWebHostBuilder(args)//调用下面的方法，返回一个WebHostBuilder对象
                .Build()//用上面返回的WebHostBuilder对象创建一个WebHost
                .Run();//运行上面创建的WebHost对象从而运行我们的Web应用程序换句话说就是启动一个一直运行监听http请求的任务
        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)//使用默认的配置信息来初始化一个新的IWebHostBuilder实例
            .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
            {
                var env = hostingContext.HostingEnvironment;

                config.AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
                      .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;, optional: true, reloadOnChange: true)
                      .AddJsonFile(&quot;Content.json&quot;,optional:false,reloadOnChange:false)
                      .AddEnvironmentVariables();

            })
            .UseStartup&amp;lt;Startup&amp;gt;();// 为Web Host指定了Startup类&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213435838-1502421717.png&quot; alt=&quot;1542804422257&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;然后Startup里面ConfigureServices中的代码修改如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213435497-1179687345.png&quot; alt=&quot;1542804670714&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;然后按下F5运行下代码吧，如下图所示，从我们最新添加的json文件中加载出来数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213435187-340881669.png&quot; alt=&quot;1542804899927&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;这里多讲一点，传统asp.net的web.config文件如果有更改的话是必须要重启站点才能使，配置文件生效的，但是asp.net core的配置文件是支持热更新的，及不重启网站也能加载更新，只需要设置一下属性即可，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213434825-470174909.png&quot; alt=&quot;1542805102992&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置文件的源码解读这块就到这里了。下面开始依赖注入的讲解。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;依赖注入与控制反转&quot;&gt;依赖注入与控制反转&lt;/h2&gt;
&lt;p&gt;如果大家仔细阅读文章的话，相信已经看出来了，我上面提到过好几次依赖注入的概念。那么究竟什么是依赖注入呢？下面我们就拿我们上面的ContentController来好好的来理解下。&lt;br/&gt;依赖注入：当一个对象ContentController需要另一个对象Content来协同完成任务的时候，那么这个ContentController就对这个Content对象产生了依赖关系。那么在这个ContentController中，是怎么注入的呢？就是从控制器中注入的了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213434373-1598413045.png&quot; alt=&quot;1542805959559&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从asp.net 转过来的你是不是想起了之前的千篇一律的new对象啊。没对象自己new（要是女朋友也能new多好啊……）当然除了单例对象，静态哈。&lt;/p&gt;
&lt;p&gt;这里又设计一个概念就是控制反转。&lt;/p&gt;
&lt;p&gt;那么什么是控制反转呢？你上面看到没有，你自己new对象就是整转，因为你自己创建自己所要使用的对象，。那么这种不需要你自己new对象，而是直接传进来就是控制反转了。（不知道比喻的恰不恰当哈）&lt;/p&gt;
&lt;p&gt;依赖注入与控制反转你是否已经了解了呢，喜欢思考的朋友可能会问了，那这个构造函数里面的&lt;code&gt;IOptions&amp;lt;Content&amp;gt; option&lt;/code&gt; 又是怎么出来的？这里就要引入一个容器的概念了。&lt;/p&gt;
&lt;p&gt;什么是容器呢？&lt;/p&gt;
&lt;p&gt;这里创建&lt;code&gt;IOptions&amp;lt;Content&amp;gt; option&lt;/code&gt; 这个对象的东西就是容器。还记得上面我们分析源码的时候，IServiceCollection 里面注入了很多东西吗？其实就是往IServiceCollection 这个容器里面注入方法，这样其他地方使用的时候就能自动注入了。&lt;/p&gt;
&lt;p&gt;这就是容器的好处，由容器来统一管理实例的创建和销毁，你只需要关心怎么用就行了，不需要关系怎么创建跟销毁。&lt;/p&gt;
&lt;p&gt;当然容器创建的实例都是有生命周期的，。下面罗列一下，就不过多的讲解了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Transient： 每一次访问都会创建一个新的实例&lt;/li&gt;
&lt;li&gt;Scoped： 在同一个Scope内只初始化一个实例 ，可以理解为（ 每一个request级别只创建一个实例，同一个http request会在一个 scope内）&lt;/li&gt;
&lt;li&gt;Singleton ：整个应用程序生命周期以内只创建一个实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用的方式也很简单，我会在接下来的课程中详细的通过实例来进行讲解!因为现在的例子还没发演示。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文一步一步带着你先分析了ASP.NET Core的启动过程及运行的原理，紧接着给你讲了配置文件的加载过程及原理，并通过示例代码演示了如何加载自定义的配置文件，最后引出了依赖注入以及控制反转的概念，并通过对我们上面例子的分析来紧身对依赖注入以及控制反转的理解。至此让你知其然更知其所以然。对ASP.NET Core的原理相信你已经了然于胸了！有问题的小伙伴可以加群&lt;code&gt;637326624&lt;/code&gt;讨论。那么接下来让我们再准备下dapper,vue以及git的快速入门就开始我们的asp.net core cms的实战课程吧！还是那句话基础很重要，基础打好，后面才能事半功倍。谢谢大家。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 13:41:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>作者：依乐祝 原文链接：https://www.cnblogs.com/yilezhu/p/9998021.html 写在前面 上篇文章我给大家讲解了ASP.NET Core的概念及为什么使用它，接着</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9998021.html</dc:identifier>
</item>
</channel>
</rss>