<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【计算机网络】应用层（一）  初探HTTP - 外婆的彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/7717093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/7717093.html</guid>
<description>
&lt;h2&gt;&lt;span&gt;HTTP报文&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;HTTP报文是HTTP应用程序间发送的数据块，它由三部分组成：起始行（start line），首部(header)和主体(body)，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171023153555535-1165615971.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/6a2fed1d8bcd4b989e1e83b504c82b9a/2fhohp@mxo%25%60vz%7Dpoy3bfod.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;3537EFB5691D4C88A23D2951C3A487E3&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从分类上，报文又可以分为请求报文和响应报文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;报文结构&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;请求报文的结构：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
--------------------------------
&amp;lt;方法&amp;gt;     &amp;lt;URL&amp;gt;   &amp;lt;版本&amp;gt;
--------------------------------
&amp;lt;首部&amp;gt;
--------------------------------
&amp;lt;主体&amp;gt;
--------------------------------
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;响应报文的结构&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
--------------------------------------
&amp;lt;版本&amp;gt;   &amp;lt;状态码&amp;gt;  &amp;lt;原因短语&amp;gt;
--------------------------------------&lt;span&gt;
首部
&lt;/span&gt;--------------------------------------&lt;span&gt;
主体
&lt;/span&gt;--------------------------------------
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【注意】 请求报文和响应报文在结构上只有起始行有不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图示如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171023153641707-418858085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/10b2940c865f4511bc0f5ae40ad8202f/j9%5Dhu%5D7jbv%7Dol9eu793xx%601.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;32F4D64B4E8E4E1F926CA2B1627071CE&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面对上面的结构组成部分进行进一步的解释&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;起始行各成分解析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;方法（method）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法是客户端用于告诉服务器希望做什么事情，它包括GET, POST, OPTIONS, PUT,DELETE等。例如：GET表示客户机告诉服务器想要发来一份文档， POST表示客户机想要传一份数据过去给服务器处理， OPTIONS表示客户机在不了解的情况下询问服务器：你能处理哪些方法呀？  PUT表示将请求报文上的主体让服务器保存下来，DELETE表示在服务器上删除一份文档&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;URL&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请求的资源的路径&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;版本&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;版本(version)的一般格式为HTTP/x.y, 其中x表示主要版本号，y表示次要版本号， 版本用于客户机和服务器相互告知对方自己能够处理的HTTP协议的最高等级， 这里要说明一下的是 x.y并不是一个数字，而是两个，  HTTP/2.22是要比HTTP/2.23的等级高的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;状态码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法是客户端用来告诉服务器：“我想要做什么事情”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而状态码则是服务器用来告诉客户端：“你要我办的事情现在办得这样XXX了”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;状态码用三位数字表示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2开头表示成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3开头表示资源被移走&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4开头表示客户端请求出错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5开头表示服务器有错误&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/5137913b806346aca543a3e55767ab69/t16zh0$k~j)m2~74eij(@~f.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;73D9A203B46E47EDADB7ED6D99637F27&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171023153702004-1039567294.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;原因短语&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;原因短语用一个单词，去表示执行的大体情况，所以它覆盖的范围要比状态码大一些&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如起始行HTTP/2.0 200 OK 中的OK是表示执行成功的意思&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;HTTP连接管理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;处于应用层的HTTP是以更底层的传输层的TCP为基础的，所以在这一小节我们都将探讨HTTP和TCP的关系所衍生出来的一些知识点&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;并行连接&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;关于HTTP和TCP有以下几点： 1. 每个Web页面上的对象都对应着一个HTTP事务  2. 每个HTTP事务由一个TCP连接传输   3. TCP连接耗时长， 实际上，在客户端和服务器没有过载的情况下， HTTP传输时延主要就是由TCP连接的时延构成的  4. 这几个TCP连接可以串行建立， 也可以并行地建立&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;串行连接： 先后建立多个TCP连接， 分别传输HTTP事务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并行连接： 同时建立多个TCP连接，处理HTTP事务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并行连接图示&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171023153742644-1862038886.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/ae95af9e0ca54ed4bc9a5f82863f90ad/26vflo%7Bz8we%25pm$gu56~n%5Dd.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;B69BC50536024EB7B51B248F3F832624&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;并行连接的优势：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.优化用户体验&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;串行连接有一个很明显的优势，那就是每个时刻只能加载一个页面上的对象，而不能多个页面对象同时加载， 假设一个极简的网站A由三部分组成：左栏的图片，中栏的图片和右栏的图片。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果单纯依靠串行连接，（在网速比较慢的情况下）你可能会这样看到图片加载： 左栏一点一点地加载（中/右栏什么都没有），加载出左栏后，中栏一点一点的加载（右栏什么都没有），这样的用户体验实际是比较差的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果依靠并行连接的话，情况就好一点： 左中右栏都一点一点的加载出来（当然每张图片的加载比之前的要慢）， 这样就能获得比较好的用户体验&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 可能要比串行连接快（可能）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们上面说到，一般情况下， HTTP传输时延主要就是由TCP连接的时延构成的，所以并行连接的时候，TCP时延迟会叠加起来， 这会让并行连接比串行连接要快。 但为什么说不一定呢？ 因为在带宽有限的情况下，多个通过TCP连接运行的HTTP事务对带宽的竞争很可能耗尽带宽，这样每个页面的对象都只能以较慢的速度加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;持久连接&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;一个TCP连接可以只用于处理一个HTTP事务， 并在该事务结束的时候关闭连接，这种连接方式叫做非持久连接； 当然， 一个TCP连接也可以在处理完一个事务后不关闭， 而处理多个HTTP事务，这种连接方式就叫持久连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样，我们上面说到，HTTP传输时延主要就是由TCP连接的时延构成的，所以持久连接省去了相当一部分的TCP建立过程所用的时耗，因而取得了大幅度的性能提升&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面我们介绍了两种体系结构，那么基于http协议搭建的应用（Web应用）是基于哪种体系结构呢？ 大家应该不难知道，是客户端/服务器结构，所以我们接下来的表述，都将基于这一结构展开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户机/服务器结构在硬件层面， 你可以把他俩看成是两个主机，而在Web程序层面，你可以看成这是浏览器程序和服务器程序俩程序，因为我们接下来主要是从Web应用的层面描述http，所以在下面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端 ==浏览器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Web缓存服务器&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Web缓存服务器（Web cache）会将客户机最近向原始服务器请求过的对象进行拷贝和保存，当客户机再次发起对原始服务器请求的时候，Web缓存服务器会进行检查：诶，这个对象是不是我早先保存过的呀？ 如果是，这种现象就叫做”缓存命中“，再然后，这个请求在前往原始服务器的半路上被”劫道“了，这时，缓存服务器直接发送这个对象给客户机，而不需要继续把请求发给原始服务器了。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/befd87d5ee464e799ffe7f1a1eddd3c3/b4t%255Byyd%25609n%257B1%2524549wq%257B_e%257D5.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;4C5D58F5BD7F48228036FB7F6C184CA3&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171023153835410-2094087195.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;使用缓存服务器的好处：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.避免了冗余的数据传输&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 减少传播时延（距离时延）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 缓解了带宽瓶颈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 应对“瞬间拥塞”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我将一一解释：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;一. 避免了冗余的数据传输&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果没有缓存服务器， 冗余的数据传输将会给原始服务器带来巨大的压力， 这次我以博客园为例： 我个人有个抓狂的毛病：在发出博客后我可能会在一段时间内一直刷新博客园的首页（就为了看自己的推荐数和阅读数有没有上升，顺便看会不会被移出首页）， 我可能会在1分钟内连刷首页10次，但大家知道，在一分钟内一般没人会推新博客到首页，所以首页是没有任何变化的。假设没有缓存服务器，我可能一分钟内对博客园的原始服务器发出了10次冗余的请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以如果没有缓存服务器：1. 给原始服务器带来不必要的负载压力  2. 浪费我的带宽&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二. 减少传播时延&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;客户端和原始服务器一般离得比较远， 所以分组的传播时延比较长。例如我家住广东，要访问一个服务器在北京的网址的话， 因为北京和广东距离大约为1900千米， 用最快的物理介质光纤来计算的话：传播时延要1900千米 / (300000千米/s)  ≈ 60毫秒，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而相比起原始服务器，缓存服务器和客户端“离得很近”（一般由学校或居民区的ISP配置），所以走过的链路长度短，所以分组传播时延就短到可以忽略不计的地步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;三. 缓解带宽瓶颈&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;  当客户机和初始服务器的瓶颈带宽远低于客户机和缓存服务器的瓶颈带宽的时候，增加缓存服务器能降低链路的流量强度，流量强度降低意味着链路相对“没那么拥挤了”，从而减少了分组的排队时延&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面举个实际的例子进一步证明缓存服务器的优点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在举例子前，先说一下流量强度的概念： 流量强度（traffic intensity） = 实际数据传输速率/ 链路最大传输速率， 设计链路的时候流量强度不能大于等于1， 因为这时候分组的排队时延将很大并且不断增长&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示， 一个机构（如公司）的内部网络是个高速局域网，内部网络和因特网通过一条15Mbps的链路连接，我们假设和公共因特网相连的路由器从转发请求到接收到响应所用平均时长为2s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时假设机构内的请求速率为每秒15个请求，每个请求对象的平均长度为1Mb，那么可以得出公共接入链路的流量强度为(15个请求/秒) × (1Mb/请求) / (15Mbps) = 1, 接入链路接近1的流量强度会使得分组时延很大而且不断增长，这时所有客户机将长时间得不到响应，所以我们需要采取措施减少接入链路的流量强度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171023153940707-419517761.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/0ca62e22a9b1469485310ea657ca788a/%2560mmljt%2560p%257Bezvk%2524%257Ei%2529jc%2529%255B9k.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;11BBB1BC9B3D44EE8A6A84B669B91375&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;减少接入链路的流量强度的方式有两种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 增加接入链路的带宽&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 增设缓存服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们先看看采用第一种方式会怎样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案一.通过增加带宽&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171023154004207-1841698868.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/6a154ebf971d4f6fad70c51567665419/dt3lgeu_rd4zw%2524zd3_%255Bkev1.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;D563E7244FFD47AAA880D5E1F90EE45D&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示，我们将接入链路的速率从15Mbps拓宽到100Mbps，那么这时候接入链路的流量强度为(15个请求/秒) × (1Mb/请求) / (100Mbps) = 0.15，在流量强度为0.15的情况下，接入链路的排队时延很短，几乎可以忽略，那么这时候每个请求的平均时延就是2s(前面假设的和因特网相连的路由器从转发请求到接收到响应所用的平均时长)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK.  让我们评价下方案一(通过增加带宽减少流量强度)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 平均时延2s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 增加接入链路带宽所付出的高成本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案二. 增设缓存服务器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们现在尝试第二种方案： 不增加接入链路的带宽（仍然是15Mbps），而是为机构的客户机增加一个缓存服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171023154018504-1695414035.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/7be20628375a4487b72fae9119f37147/v%257Ba%255Df%25605e%257Dxb0%2560z%255Br%2528ne1%257D45.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;0668FACC9EE4481490AE2AF8A4F4C7E2&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们假设缓存服务器的命中率是0.4， 那么也就是说，缓存服务器能够拦截掉40%通过接入链路进入因特网的请求，很显然，这时候流量强度将由原来的1下降到 1  -  1 × 0.4 = 0.6， 对一条15Mbps的链路来说， 流量强度小于0.8的时候时延很小（几十毫秒，和假设的2s的因特网时延相比可以忽略）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设缓存命中时，缓存服务器直接返回响应所用时延为0.01s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么客户机得到响应的平均时延应该为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;0.4 × 0.01s + 0.6 × 2s = 1.204s约等于1.2s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(0.4的几率缓存命中，从缓存服务器返回响应，0.6的几率未命中，请求进入因特网)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK.  让我们评价下方案二(通过增设缓存服务器减少流量强度)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 平均时延1.2s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 相比于方案一（增加接入链路带宽）来说成本低（很多缓存器就是使用在廉价PC机上运行的公共领域软件）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;四.  应对“瞬间拥塞”&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;“瞬间拥塞”是原始服务器最为恐惧的状况之一， 那就是，在一个难以预料的时间节点，无数的客户端突然对原始服务器发起海量的请求，例如前段时间的鹿晗炸掉微博的事件就是一个例子，但实际上，虽然微博还是炸了，但缓存服务器也付出了它力所能及的帮助，不然的话，微博崩掉的时间点还得往前提。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;条件GET请求&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Web缓存固然给我们带来了一系列的便利，但与此同时我们还需要考虑另外一些问题: 如果缓存服务器里面保存的对象是陈旧的该怎么办呢？ &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如就可能存在这么一种情况： 我每天都喜欢浏览博客园的首页，去看看他人写的新博客，也许在我第一次浏览博客园网站的时候，缓存服务器帮我保存了和这个网站相关的所有对象，当然，我下次浏览博客园的时候速度会快很多（这会让我感觉很好）， 但是！ 我却永远只能看到我第一次进博客园时所能看到的那些旧的博客页面，这该是多么难受的一件事情！ 博客园每隔几分钟就会有新写的博客被推进首页，但我却永远看不到，就因为缓存服务器已经强制做了“缓存”这件事情&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然， 缓存服务器自有一套机制避免这个烦恼降临， 它就是条件GET请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个请求满足以下两个条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 请求报文使用GET方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 请求报文中包含一个If-modified-since首部行（if-modified-since： 日期XX 表示询问： 对象在日期XX后是否修改（更新）过？）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么这个请求报文就是一个条件GET请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓存服务器在接收到客户机的请求后，可以向原始服务器发送条件GET请求，用于确认对象是否更新过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.如果对象在约定时间后没有更新，则原始服务器发回一个不携带请求对象的报文（节约带宽），告诉缓存服务器缓存是“新”的， 可以使用&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/fcb3c05af2184aa6a876983c20db7cc9/v%257Do5%255D%252500kcx9%2524fsdd%255B%2528f3x4.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;63A8E2817BED4735B5D85AB5C78AD037&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171023154056926-938517641.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 如果对象在约定时间后有更新，则原始服务器发回一个携带新对象的报文给缓存服务器&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171023154129191-1982464569.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/6ade71e922654c95bc38bc38e1f67546/sb1t0mrh1y89%257E%257D%257Eq%255By1qz%257D6.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;036F0E20FF2940E586A5ED26E34C4A32&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;h2&gt;&lt;span&gt;参考书籍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;《计算机网络-自顶向下》  作者 James F. Kurose&lt;/p&gt;
&lt;p&gt;《HTTP权威指南》            作者 Brian Totty, Ansbu Aggarwal, David Gourlay&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201710/1060770-20171023154649707-1995439393.jpg&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;429&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

</description>
<pubDate>Mon, 23 Oct 2017 07:45:00 +0000</pubDate>
<dc:creator>外婆的彭湖湾</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/penghuwan/p/7717093.html</dc:identifier>
</item>
<item>
<title>Java常用类（二）String类详解 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7689974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7689974.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;　　在我们开发中经常会用到很多的常用的工具类，这里做一个总结。他们有很多的方法都是我们经常要用到的。所以我们一定要把它好好的掌握起来！&lt;/p&gt;

&lt;h2&gt;1.1、String（字符串常量）概述&lt;/h2&gt;
&lt;p&gt;　　在API中是这样描述：&lt;/p&gt;
&lt;p&gt;　　　　String 类代表&lt;span&gt;字符串&lt;/span&gt;。Java 程序中的&lt;span&gt;所有字符串字面值（如 &quot;abc&quot; ）都作为此类的实例实现&lt;/span&gt;。&lt;br/&gt;　　　　&lt;span&gt;字符串是常量；它们的值在创建之后不能更改&lt;/span&gt;。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。&lt;/p&gt;
&lt;p&gt;　　java.lang.String：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018234558912-2140346876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.2、分析String源码&lt;/h2&gt;
&lt;p&gt;　　1）String的成员变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a7ade95f-c012-4c20-a4dc-d61fe8f41529')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_a7ade95f-c012-4c20-a4dc-d61fe8f41529&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a7ade95f-c012-4c20-a4dc-d61fe8f41529&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a7ade95f-c012-4c20-a4dc-d61fe8f41529',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a7ade95f-c012-4c20-a4dc-d61fe8f41529&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
　&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* String的属性值 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
    &lt;span&gt;private&lt;/span&gt; final &lt;span&gt;char&lt;/span&gt;&lt;span&gt; value[];

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* The offset is the first index of the storage that is used. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*数组被使用的开始位置*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt;&lt;span&gt; offset;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* The count is the number of characters in the String. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*String中元素的个数*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* Cache the hash code for the string &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*String类型的hash值*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Default to 0&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* use serialVersionUID from JDK 1.0.2 for interoperability &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;long&lt;/span&gt; serialVersionUID = -&lt;span&gt;6849794470754667710L&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Class String is special cased within the Serialization Stream         Protocol.
     *
     * A String instance is written into an ObjectOutputStream according to
     * &amp;lt;a href=&quot;{@docRoot}/../platform/serialization/spec/output.html&quot;&amp;gt;
     * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&amp;lt;/a&amp;gt;
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

　　&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final ObjectStreamField[] serialPersistentFields =
        &lt;span&gt;new&lt;/span&gt; ObjectStreamField[&lt;span&gt;0&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;String的成员变量&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　从源码看出String底层使用一个字符数组来维护的。&lt;/p&gt;
&lt;p&gt;　　　　成员变量可以知道String类的值是final类型的，不能被改变的，所以只要一个值改变就会生成一个新的String类型对象，存储String数据也不一定从数组的第0个元素开始的，而是从offset所指的元素开始。&lt;/p&gt;
&lt;p&gt;　　2）String的构造方法　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;String() 
          初始化一个新创建的 String 对象，使其表示一个空字符序列。 
&lt;span&gt;String(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;byte[] bytes) 
          通过使用平台的默认字符集解码指定的 byte&lt;/span&gt;&lt;span&gt;&lt;span&gt; 数组，构造一个新的 String。&lt;/span&gt; 
String(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes, Charset charset) 
          通过使用指定的 charset 解码指定的 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; 数组，构造一个新的 String。  
&lt;span&gt;String(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;byte[] bytes, int offset, int length) 
          通过使用平台的默认字符集解码指定的 byte&lt;/span&gt;&lt;span&gt;&lt;span&gt; 子数组，构造一个新的 String。&lt;/span&gt; 
String(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes, &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length, Charset charset) 
          通过使用指定的 charset 解码指定的 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; 子数组，构造一个新的 String。 
String(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes, &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length, String charsetName) 
          通过使用指定的字符集解码指定的 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; 子数组，构造一个新的 String。 
String(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes, String charsetName) 
          通过使用指定的 charset 解码指定的 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; 数组，构造一个新的 String。 
&lt;span&gt;String(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;&lt;span&gt;[] value) 
          分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。&lt;/span&gt; 
&lt;span&gt;String(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;char[] value, int offset, int&lt;/span&gt;&lt;span&gt;&lt;span&gt; count) 
          分配一个新的 String，它包含取自字符数组参数一个子数组的字符。&lt;/span&gt; 
&lt;span&gt;String(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;int[] codePoints, int offset, int&lt;/span&gt;&lt;span&gt;&lt;span&gt; count) 
          分配一个新的 String，它包含 Unicode 代码点数组参数一个子数组的字符。&lt;/span&gt; 
&lt;span&gt;String(String original) 
          初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。&lt;/span&gt; 
String(StringBuffer buffer) 
          分配一个新的字符串，它包含字符串缓冲区参数中当前包含的字符序列。 
String(StringBuilder builder) 
          分配一个新的字符串，它包含字符串生成器参数中当前包含的字符序列。 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.1、直接赋值方式创建对象&lt;/h2&gt;
&lt;p&gt;　　直接赋值方式创建对象是&lt;span&gt;在方法区的常量池&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
String str=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接赋值的方式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2、通过构造方法创建字符串对象&lt;/h2&gt;
&lt;p&gt;　　通过构造方法创建字符串对象是&lt;span&gt;在堆内存&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
String str=&lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化的方式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.3、两种实例化方式的比较&lt;/h2&gt;
&lt;p&gt;　　1）编写代码比较&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestString {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String str1 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        String str2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        String str3 &lt;/span&gt;= str2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用传递，str3直接指向st2的堆内存地址&lt;/span&gt;
        String str4 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         *  ==:
         * 基本数据类型：比较的是基本数据类型的值是否相同
         * 引用数据类型：比较的是引用数据类型的地址值是否相同
         * 所以在这里的话：String类对象==比较，比较的是地址，而不是内容
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
         System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(str1==str2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
         System.&lt;span&gt;out&lt;/span&gt;.println(str1==str3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
         System.&lt;span&gt;out&lt;/span&gt;.println(str3==str2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
         System.&lt;span&gt;out&lt;/span&gt;.println(str1==str4);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）内存图分析&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171023133457441-979023158.png&quot; alt=&quot;&quot; width=&quot;496&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　可能这里还是不够明显，构造方法实例化方式的内存图：String str = new String(&quot;Hello&quot;);&lt;/p&gt;
&lt;p&gt;　　　　首先：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171023133639082-908192233.png&quot; alt=&quot;&quot; width=&quot;341&quot; height=&quot;192&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　当我们再一次的new一个String对象时：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171023133716801-1611694471.png&quot; alt=&quot;&quot; width=&quot;372&quot; height=&quot;173&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　3）字符串常量池&lt;/p&gt;
&lt;p&gt;　　　　　　在字符串中，如果&lt;span&gt;采用直接赋值的方式（String str=&quot;Lance&quot;）进行对象的实例化&lt;/span&gt;，则&lt;span&gt;会将匿名对象“Lance”放入对象池&lt;/span&gt;，每当&lt;span&gt;下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;　　　　　　这样，所有直接赋值的String对象，如果利用相同的“Lance”，则String对象==返回true；&lt;/p&gt;
&lt;p&gt;　　　　　　比如：对象手工入池&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestString {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
     String str &lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).intern();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对匿名对象&quot;hello&quot;进行手工入池操作&lt;/span&gt;
     String str1=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
     System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(str==str1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　4）总结：两种实例化方式的区别&lt;/p&gt;
&lt;p&gt;　　　　　　1）直接赋值（String str = &quot;hello&quot;）：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。&lt;/p&gt;
&lt;p&gt;　　　　　　2）构造方法（String str=  new String(&quot;hello&quot;);）:会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public  String intern();方法进行手工入池。&lt;/p&gt;
&lt;p&gt;　　　　　　　　在&lt;span&gt;开发的过程中不会采用构造方法进行字符串的实例化&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　5）避免空指向&lt;/p&gt;
&lt;p&gt;　　　　　　首先了解： == 和public boolean equals()比较字符串的区别&lt;/p&gt;
&lt;p&gt;　　　　　　==在对字符串比较的时候，对比的是&lt;span&gt;内存地&lt;/span&gt;址，而equals比较的是&lt;span&gt;字符串内容&lt;/span&gt;，在开发的过程中&lt;span&gt;，equals()通过接受参数，可以避免空指向&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　　　　　String str = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
　　　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(str.equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时会出现空指向异常&lt;/span&gt;
&lt;span&gt;　　　　　　　　...
　　　　　　}
　　　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.equals(str)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时equals会处理null值，可以避免空指向异常&lt;/span&gt;
&lt;span&gt;　　　　　　　　　...
　　　　　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　　　6）String类对象一旦声明则不可以改变；而改变的只是地址，原来的字符串还是存在的，并且产生垃圾&lt;/p&gt;
&lt;p&gt; 　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171023134707348-495320073.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018235737990-1836009057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.1、String的判断功能&lt;/h2&gt;
&lt;p&gt;　　1）常用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　boolean equals(Object obj)：比较字符串的内容是否相同
　　boolean equalsIgnoreCase(String str)： 比较字符串的内容是否相同,忽略大小写
　　boolean startsWith(String str)： 判断字符串对象是否以指定的str开头
　　boolean endsWith(String str)： 判断字符串对象是否以指定的str结尾&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）代码测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4fa4ad88-fdf4-4044-845a-603906db7b79')&quot; readability=&quot;33&quot;&gt;　&lt;img id=&quot;code_img_closed_4fa4ad88-fdf4-4044-845a-603906db7b79&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4fa4ad88-fdf4-4044-845a-603906db7b79&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4fa4ad88-fdf4-4044-845a-603906db7b79',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4fa4ad88-fdf4-4044-845a-603906db7b79&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestString {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建字符串对象&lt;/span&gt;
        String s1 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        String s2 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        String s3 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; boolean equals(Object obj):比较字符串的内容是否相同&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(s1.equals(s2));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(s1.equals(s3));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(s1.equalsIgnoreCase(s2));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(s1.equalsIgnoreCase(s3));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; boolean startsWith(String str):判断字符串对象是否以指定的str开头&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(s1.startsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;he&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(s1.startsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;测试&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　结果：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171023145038223-1285641874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2、String类的获取功能&lt;/h2&gt;
&lt;p&gt;　　1）常用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  int&lt;span&gt; length():获取字符串的长度，其实也就是字符个数
  char charAt(int&lt;span&gt; index):获取指定索引处的字符
  int&lt;span&gt; indexOf(String str):获取str在字符串对象中第一次出现的索引
  String substring(int&lt;span&gt; start):从start开始截取字符串
  String substring(int start,int end):从start开始，到end结束截取字符串。包括start，不包括end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）代码测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('80cf01a0-3fba-41a1-827f-c86c3649d09c')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_80cf01a0-3fba-41a1-827f-c86c3649d09c&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_80cf01a0-3fba-41a1-827f-c86c3649d09c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('80cf01a0-3fba-41a1-827f-c86c3649d09c',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_80cf01a0-3fba-41a1-827f-c86c3649d09c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestString {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String str1 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        String str2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        String str3 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LANCE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; boolean equals(Object obj):比较字符串的内容是否相同&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(str1.equals(str2));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(str1.equals(str3));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(str1.equalsIgnoreCase(str3));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; boolean startsWith(String str):判断字符串对象是否以指定的str开头
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; boolean endsWith(String str): 判断字符串对象是否以指定的str结尾&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(str1.startsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;La&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(str3.endsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        
    }

}
　　结果：

　　　　

&lt;/span&gt;&lt;span&gt;3.2&lt;/span&gt;&lt;span&gt;、String类的获取功能

　　&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）常用方法

 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; length():获取字符串的长度，其实也就是字符个数
 &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; charAt(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index):获取指定索引处的字符
 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(String str):获取str在字符串对象中第一次出现的索引
 String substring(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; start):从start开始截取字符串
 String substring(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; start,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; end):从start开始，到end结束截取字符串。包括start，不包括end
　　&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）测试代码

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestString {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建字符串对象&lt;/span&gt;
        String s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;helloworld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; int length():获取字符串的长度，其实也就是字符个数&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(s.length());
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; char charAt(int index):获取指定索引处的字符&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(s.charAt(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(s.charAt(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; int indexOf(String str):获取str在字符串对象中第一次出现的索引&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(s.indexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(s.indexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;owo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(s.indexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ak&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; String substring(int start):从start开始截取字符串&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(s.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(s.substring(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; String substring(int start,int end):从start开始，到end结束截取字符串&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(s.substring(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, s.length()));
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(s.substring(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;));
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;测试&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　结果：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171023141414441-1590183840.png&quot; alt=&quot;&quot; width=&quot;111&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.3、String的转换功能&lt;/h2&gt;
&lt;p&gt;　　1）常用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　char&lt;/span&gt;&lt;span&gt;[] toCharArray()：把字符串转换为字符数组
　　String toLowerCase()：把字符串转换为小写字符串
　　String toUpperCase()：把字符串转换为大写字符串&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）核心代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5dda5c8e-a94d-4d54-9121-3333241bdb50')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_5dda5c8e-a94d-4d54-9121-3333241bdb50&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5dda5c8e-a94d-4d54-9121-3333241bdb50&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5dda5c8e-a94d-4d54-9121-3333241bdb50',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5dda5c8e-a94d-4d54-9121-3333241bdb50&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestString {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建字符串对象&lt;/span&gt;
        String s = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abcde&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; char[] toCharArray():把字符串转换为字符数组&lt;/span&gt;
        &lt;span&gt;char&lt;/span&gt;[] chs =&lt;span&gt; s.toCharArray();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; chs.length; x++&lt;span&gt;) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(chs[x]);
        }
 
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; String toLowerCase():把字符串转换为小写字符串&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.toLowerCase());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; String toUpperCase():把字符串转换为大写字符串&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.toUpperCase());
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;测试&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　结果：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171023142147879-1943610637.png&quot; alt=&quot;&quot; width=&quot;109&quot; height=&quot;145&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意：　　&lt;/p&gt;
&lt;p&gt;　　　　字符串的遍历有两种方式：一是ength()加上charAt()。二是把字符串转换为字符数组，然后遍历数组。&lt;/p&gt;
&lt;h2&gt;3.4、其他常用方法&lt;/h2&gt;
&lt;p&gt;　　1）常用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　去除字符串两端空格：String trim()
　　按照指定符号分割字符串：String[] split(String str)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）核心代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('59350e73-967e-42ce-ba9f-608c7afccb89')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_59350e73-967e-42ce-ba9f-608c7afccb89&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_59350e73-967e-42ce-ba9f-608c7afccb89&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('59350e73-967e-42ce-ba9f-608c7afccb89',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_59350e73-967e-42ce-ba9f-608c7afccb89&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestString {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建字符串对象&lt;/span&gt;
        String s1 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;helloworld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        String s2 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; helloworld &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        String s3 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; hello world &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + s1 + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + s1.trim() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + s2 + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + s2.trim() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + s3 + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + s3.trim() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; String[] split(String str)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建字符串对象&lt;/span&gt;
        String s4 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aa,bb,cc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        String[] strArray &lt;/span&gt;= s4.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; strArray.length; x++&lt;span&gt;) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(strArray[x]);
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;测试&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　结果：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171023142647379-946244251.png&quot; alt=&quot;&quot; width=&quot;173&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当我们去阅读源代码的时候，会发现有这样的一句话：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171023143321613-1675148197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;意思就是说：&lt;span&gt;String是个常量，从一出生就注定不可变&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我想大家应该就知道为什么String不可变了，String类被final修饰，官方注释说明创建后不能被改变，但是&lt;span&gt;为什么String要使用final修饰呢？　&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.1、前言&lt;/h2&gt;
&lt;p&gt;　　了解一个经典的面试题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Apple {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String a &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        String b &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        String c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(a==&lt;span&gt;b);  //true
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(a.equals(b));  //true
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(a==&lt;span&gt;c);  //false
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(a.equals(c));  //true
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　内存图：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171023144041019-1564794379.png&quot; alt=&quot;&quot; width=&quot;367&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.2、分析&lt;/h2&gt;
&lt;p&gt;　　因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即&lt;span&gt;采用了享元模式&lt;/span&gt;,每当&lt;span&gt;生成一个新内容的字符串时，他们都被添加到一个共享池中&lt;/span&gt;，当第二次再次生成同样内容的字符串实例时，&lt;/p&gt;
&lt;p&gt;　　就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。　　&lt;/p&gt;
&lt;p&gt;　　需要说明一点的是，在object中，&lt;span&gt;equals()是用来比较内存地址的，但是String重写了equals()方法，用来比较内容的，即使是不同地址，只要内容一致，也会返回true&lt;/span&gt;，这也就是为什么a.equals(c)返回true的原因了。&lt;/p&gt;
&lt;h2&gt;4.3、String不可变的好处&lt;/h2&gt;
&lt;p&gt;　　可以实现&lt;span&gt;多个变量引用堆内存中的同一个字符串实例，避免创建的开销&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　我们的程序中&lt;span&gt;大量使用了String字符串，有可能是出于安全性考虑&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　大家都知道&lt;span&gt;HashMap中key为String类型，如果可变将变的多么可怕&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　当我们&lt;span&gt;在传参的时候，使用不可变类不需要去考虑谁可能会修改其内部的值，如果使用可变类的话，可能需要每次记得重新拷贝出里面的值，性能会有一定的损失&lt;/span&gt;。&lt;/p&gt;

&lt;h2&gt;5.1、字符串常量池概述&lt;/h2&gt;
&lt;p&gt;　　1）常量池表（Constant_Pool table）&lt;/p&gt;
&lt;p&gt;　　　　Class文件中&lt;span&gt;存储所有常量（包括字符串）的table。&lt;/span&gt;&lt;br/&gt;　　　　这是Class文件中的内容，还不是运行时的内容，不要理解它是个池子，其实就是Class文件中的字节码指令。&lt;/p&gt;
&lt;p&gt;　　2）运行时常量池（Runtime Constant Pool）　&lt;/p&gt;
&lt;p&gt;　　　　JVM内存中&lt;span&gt;方法区的一部分，这是运行时的内容&lt;/span&gt;&lt;br/&gt;　　　　这部分内容（绝大部分）是&lt;span&gt;随着JVM运行时候，从常量池转化而来，每个Class对应一个运行时常量池&lt;/span&gt;&lt;br/&gt;　　　　上一句中说绝大部分是因为：除了 Class中常量池内容，还可能包括动态生成并加入这里的内容&lt;/p&gt;
&lt;p&gt;　　3）字符串常量池（String Pool）&lt;/p&gt;
&lt;p&gt;　　　　这部分也在方法区中，但与Runtime Constant Pool不是一个概念，&lt;span&gt;String Pool是JVM实例全局共享的，全局只有一个&lt;/span&gt;&lt;br/&gt;　　　　JVM规范&lt;span&gt;要求进入这里的String实例叫“被驻留的interned string”&lt;/span&gt;，各个JVM可以有不同的实现，HotSpot是设置了一个哈希表StringTable来引用堆中的字符串实例，被引用就是被驻留。&lt;/p&gt;
&lt;h2&gt;5.2、亨元模式&lt;/h2&gt;
&lt;p&gt;　　其实字符串常量池这个问题涉及到一个设计模式，叫“&lt;span&gt;享元模式”，顾名思义 - - - &amp;gt; 共享元素模式&lt;/span&gt;&lt;br/&gt;　　也就是说：&lt;span&gt;一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素&lt;/span&gt;&lt;br/&gt;　　Java中&lt;span&gt;String部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - String Pool”&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5.3、详细分析&lt;/h2&gt;
&lt;p&gt;　　举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; x  = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
String y &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1)首先，&lt;code&gt;10&lt;/code&gt;和&lt;code&gt;&quot;hello&quot;&lt;/code&gt;会在经&lt;span&gt;过javac（或者其他编译器）编译过后变为Class文件中&lt;code&gt;constant_pool table&lt;/code&gt;&lt;/span&gt;的内容&lt;/p&gt;
&lt;p&gt;　　2)当我们的程序运行时，也就是说JVM运行时，&lt;span&gt;每个Class&lt;code&gt;constant_pool table&lt;/code&gt;中的内容会被加载到JVM内存中的方法区中各自Class的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Runtime Constant Pool&lt;/span&gt;。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　3)一个没有被String Pool包含的Runtime Constant Pool中的字符串（这里是&quot;hello&quot;）会被加入到String Pool中（HosSpot使用hashtable引用方式），步骤如下：　　　&lt;/p&gt;
&lt;p&gt;　　　　一是：在Java Heap中根据&quot;hello&quot;字面量create一个字符串对象&lt;br/&gt;　　　　二是：将字面量&quot;hello&quot;与字符串对象的引用在hashtable中关联起来，键 - 值 形式是：&quot;hello&quot; = 对象的引用地址。&lt;/p&gt;
&lt;p&gt;　　　另外来说，当一个新的字符串出现在Runtime Constant Pool中时怎么判断需不需要在Java Heap中创建新对象呢？&lt;/p&gt;
&lt;p&gt;　　策略是这样：会先去根据equals来&lt;span&gt;比较Runtime Constant Pool中的这个字符串是否和String Pool中某一个是相等&lt;/span&gt;的（也就是找是否已经存在），如果有那么就不创建，直接使用其引用；反之，如上3&lt;/p&gt;
&lt;p&gt;　　如此，就实现了享元模式，提高的内存利用效率。&lt;/p&gt;
&lt;p&gt;　　举例：&lt;/p&gt;
&lt;p&gt;　　　　　　使用String s = new String(&quot;hello&quot;);会创建几个对象&lt;/p&gt;
&lt;p&gt;　　　　　　会创建2个对象&lt;/p&gt;
&lt;p&gt;　　　　　　首先，出现了字面量&quot;hello&quot;，那么去&lt;span&gt;String Pool中查找是否有相同字符串存在，因为程序就这一行代码所以肯定没有，那么就在Java Heap中用字面量&quot;hello&quot;首先创建1个String对象&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　接着，new String(&quot;hello&quot;)，&lt;span&gt;关键字new又在Java Heap中创建了1个对象&lt;/span&gt;，然后调用接收String参数的构造器进行了初始化。最终s的引用是这个String对象.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;喜欢就点个“推荐”！　　&lt;/strong&gt;&lt;/span&gt;　　　　　　　&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 06:52:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7689974.html</dc:identifier>
</item>
<item>
<title>【深度学习系列】PaddlePaddle之手写数字识别 - Charlotte77</title>
<link>http://www.cnblogs.com/charlotte77/p/7712856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlotte77/p/7712856.html</guid>
<description>&lt;pre&gt;
I1023 14:01:51.653827 34244 Util.cpp:166] commandline:  --use_gpu=True --trainer_count=1&lt;span&gt;
[INFO &lt;/span&gt;2017-10-23 14:01:57,830 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_pool_0___conv&lt;/span&gt;: c = 20, h = 24, w = 24, size = 11520&lt;span&gt;
[INFO &lt;/span&gt;2017-10-23 14:01:57,831 layers.py:2667] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_pool_0___pool&lt;/span&gt;: c = 20, h = 12, w = 12, size = 2880&lt;span&gt;
[INFO &lt;/span&gt;2017-10-23 14:01:57,832 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_pool_1___conv&lt;/span&gt;: c = 50, h = 8, w = 8, size = 3200&lt;span&gt;
[INFO &lt;/span&gt;2017-10-23 14:01:57,833 layers.py:2667] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_pool_1___pool&lt;/span&gt;: c = 50, h = 4, w = 4, size = 800&lt;span&gt;
I1023 &lt;/span&gt;14:01:57.842871 34244 GradientMachine.cpp:85&lt;span&gt;] Initing parameters..
I1023 &lt;/span&gt;14:01:57.854014 34244 GradientMachine.cpp:92&lt;span&gt;] Init parameters done.
Pass 0, Batch 0, Cost &lt;/span&gt;2.536199, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.875&lt;span&gt;}
Pass 0, Batch &lt;/span&gt;100, Cost 1.668236, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.515625&lt;span&gt;}
Pass 0, Batch &lt;/span&gt;200, Cost 1.024846, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.375&lt;span&gt;}
Pass 0, Batch &lt;/span&gt;300, Cost 1.086315, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.46875&lt;span&gt;}
Pass 0, Batch &lt;/span&gt;400, Cost 0.767804, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.25&lt;span&gt;}
Pass 0, Batch &lt;/span&gt;500, Cost 0.545784, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.1875&lt;span&gt;}
Pass 0, Batch &lt;/span&gt;600, Cost 0.731662, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.328125&lt;span&gt;}
```
```
```
Pass &lt;/span&gt;49, Batch 0, Cost 0.415184, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.09375&lt;span&gt;}
Pass &lt;/span&gt;49, Batch 100, Cost 0.067616, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.0&lt;span&gt;}
Pass &lt;/span&gt;49, Batch 200, Cost 0.161415, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.046875&lt;span&gt;}
Pass &lt;/span&gt;49, Batch 300, Cost 0.202667, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.046875&lt;span&gt;}
Pass &lt;/span&gt;49, Batch 400, Cost 0.336043, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.140625&lt;span&gt;}
Pass &lt;/span&gt;49, Batch 500, Cost 0.290948, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.125&lt;span&gt;}
Pass &lt;/span&gt;49, Batch 600, Cost 0.223433, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.109375&lt;span&gt;}
Pass &lt;/span&gt;49, Batch 700, Cost 0.217345, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.0625&lt;span&gt;}
Pass &lt;/span&gt;49, Batch 800, Cost 0.163140, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.046875&lt;span&gt;}
Pass &lt;/span&gt;49, Batch 900, Cost 0.203645, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.078125&lt;span&gt;}
Test with Pass &lt;/span&gt;49, Cost 0.033639, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.008100000210106373&lt;span&gt;}

Best &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; 48, testing Avgcost &lt;span&gt;is&lt;/span&gt; 0.0313018567383&lt;span&gt;
The classification accuracy &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; 99.28%&lt;span&gt;
Label of image&lt;/span&gt;/infer_3.png &lt;span&gt;is&lt;/span&gt;: 3&lt;span&gt;

real    5m3.151s
user    4m0.052s
sys    1m8.084s&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 23 Oct 2017 06:33:00 +0000</pubDate>
<dc:creator>Charlotte77</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlotte77/p/7712856.html</dc:identifier>
</item>
<item>
<title>Git 工作流的正确打开方式 - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/git-workflow.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/git-workflow.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/c74535a35ba195450eabbfa44a95bc1cc8e89182/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f636f6c6c61626f726174696e672f636f6d706172696e672d776f726b666c6f77732f676974666c6f772d776f726b666c6f772f30342e737667&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一直在使用git做版本控制，也一直工作很顺利，直到和别人发生冲突的时候。这才注意到git 工作流并不是那么简单。比如，之前遇到的&lt;a href=&quot;http://www.cnblogs.com/woshimrf/p/git-rebase.html&quot;&gt;清理历史&lt;/a&gt;。百度到的资料很多，重复性也很多，但实践性操作很少，我很难直接理解其所表达的含义。直接望文生义经常得到错误的结论，只能用时间去检验真理了，不然看到的结果都是似懂非懂，最后还是一团糟。&lt;/p&gt;


&lt;h2 id=&quot;创建仓库&quot;&gt;1.1.创建仓库&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;$ pwd
/home/ryan/workspace/l4git-workflow
$ touch readme.md
$ ls
readme.md
$ touch .gitignore
$ git init
初始化空的 Git 仓库于 /home/ryan/workspace/l4git-workflow/.git/
$ touch test.txt
$ git add .
$ git commit -m &quot;init&quot;
[master （根提交） dae77d6] init
 3 files changed, 12 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 readme.md
 create mode 100644 test.txt
$ git remote add origin git@github.com:Ryan-Miao/l4git-workflow.git
$ git push -u origin master
对象计数中: 5, 完成.
Delta compression using up to 4 threads.
压缩对象中: 100% (3/3), 完成.
写入对象中: 100% (5/5), 388 bytes | 0 bytes/s, 完成.
Total 5 (delta 0), reused 0 (delta 0)
To git@github.com:Ryan-Miao/l4git-workflow.git
 * [new branch]      master -&amp;gt; master
分支 master 设置为跟踪来自 origin 的远程分支 master。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/80e8ec5e80b76f403fb19f5d601302655d2f8f6c/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f636f6c6c61626f726174696e672f636f6d706172696e672d776f726b666c6f77732f63656e7472616c697a65642d776f726b666c6f772f30312e737667&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;模拟用户a&quot;&gt;1.2. 模拟用户A&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;git clone git@github.com:Ryan-Miao/l4git-workflow.git
git checkout a
touch a.txt
//write one
//....
$ git add .
$ git commit -m &quot;one&quot;
[a 53ff45e] one
 2 files changed, 34 insertions(+), 2 deletions(-)
 create mode 100644 a.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，a还没有提交到&lt;code&gt;origin&lt;/code&gt;。 git log 如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/a-one.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;模拟用户b&quot;&gt;1.3. 模拟用户B&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;git clone git@github.com:Ryan-Miao/l4git-workflow.git
git checkout b&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;$ touch b.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;//write something&lt;br/&gt;//...&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git add .
$ git commit -m &quot;b write one&quot;
[b 847078e] b write one
 1 file changed, 1 insertion(+)
 create mode 100644 b.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;//write something&lt;br/&gt;//....&lt;br/&gt;&lt;code&gt;$ git add . $ git commit -m &quot;b write two&quot; [b 3f30f41] b write two 1 file changed, 2 insertions(+), 1 deletion(-)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时，git log如下&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/b-two.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;模拟用户a-1&quot;&gt;1.4. 模拟用户A&lt;/h2&gt;
&lt;p&gt;A和B分别是在本地开发，所以这种顺序是未知的，也许A比B先commit一次，也许B先commit一次。这里的先后是指commit的时间戳。但都是在本地提交的代码。&lt;br/&gt;write something&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git add .
git commit -m &quot;a write two&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wirte something&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git add .
git commit -m &quot;write three&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;A push to server branch &lt;code&gt;a&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git push origin a:a
Total 0 (delta 0), reused 0 (delta 0)
To git@github.com:Ryan-Miao/l4git-workflow.git
 * [new branch]      a -&amp;gt; a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;A created a Pull Request&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/a-push.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/a-pr.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;模拟用户c&quot;&gt;1.5. 模拟用户C&lt;/h2&gt;
&lt;p&gt;C review the PR and then merged it.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/c-merge.png&quot;/&gt;&lt;br/&gt;此时，github的历史如下：&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/github-a.png&quot;/&gt;&lt;br/&gt;可以看出，merge的时候多了一次commit，message默认为 &lt;code&gt;Merge pull request #1 from Ryan-Miao/a...&lt;/code&gt;&lt;br/&gt;现在看起来，只有a一个人的历史记录，还算清楚，a做了3次提交。&lt;/p&gt;
&lt;h2 id=&quot;模拟用户b-1&quot;&gt;1.6. 模拟用户B&lt;/h2&gt;
&lt;p&gt;用户B提交前先pull master，更新最新的代码到本地，防止冲突。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git fetch
 git merge origin/master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时log看起来有点乱。如下：&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/b-merge-master.png&quot;/&gt;&lt;br/&gt;让人感到混乱的是b原来的历史只有自己的提交，更新了master到本地之后，历史记录被插入了master中的历史。于是，发现原来自己干净的历史被中间插入多次commit。甚至两次merge master的日志显得又长又碍眼。但不管怎么说，B还是要提交的。&lt;/p&gt;
&lt;p&gt;于是，B提交到远程分支b：&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/b-push.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;模拟用户c-1&quot;&gt;1.7. 模拟用户C&lt;/h2&gt;
&lt;p&gt;这时候，A完成了feature a，然后提了PR，然后找他人C merge了。而后，B也完成了feature b，提了PR，需要review and merge。 C review之后，approved， 然后D review， D merge。&lt;/p&gt;
&lt;p&gt;此时，项目基本走上正规。feature一个一个添加进去，重复之前的工作流程： fetch -》 work -》 commit -》 push -》 PR -》 merged。&lt;br/&gt;然后，项目历史就变成了这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/github-log2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一眼大概看起来还好，每次都能看到提交历史，只要不是message写的特别少，差不多可以理解最近提交的内容。然而，仔细一看，顺序好像不对。目前一共两个feature，但历史却远远超过2个。没关系，保证细粒度更容易体现开发进度。然而，这些历史并不是按照feature的发布顺序，那么，当我想要找到feature a的时候就很难串联起来。如果commit足够多，时间跨度足够大，甚至根本看不出来feature a到底做了哪些修改。&lt;/p&gt;
&lt;p&gt;这时候想要使用图形化git 历史工具来帮助理解历史：&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/tu.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里，还好，还勉强能看出走向。但当10个上百个人同时开发的话，线简直不能看了，时间跨度足够大的话，线也看不完。&lt;/p&gt;
&lt;p&gt;因此，这种模式，正是我们自己当前采用的模式。差评。这还不算完，后面更大的困难来了。最先发布的feature a出了问题，必须回滚。怎么做到。关于&lt;a href=&quot;http://www.cnblogs.com/woshimrf/p/5702696.html&quot;&gt;回滚&lt;/a&gt;，就是另一个话题了。 但我们应该知道使用&lt;code&gt;revert&lt;/code&gt;而不是&lt;code&gt;reset&lt;/code&gt;. 但revert只能回滚指定的commit，或者连续的commit，而且revert不能revert merge操作。这样，想回滚feature a, 我们就要找到a的几次提交的版本号，然后由于不是连续的，分别revert。这会造成复杂到不想处理了。好在github给了方便的东西，PR提供了revert的机会。找到以前的PR。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/revert.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，这绝对不是个好操作！&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;造成上述现象的原因是因为各自异步编程决定的。因为每个人都可以随时间提交，最后合并起来的时候以提交时间戳来作为序列的依据，就会变成这样。因此，当需要提交的远程服务器的时候，如果能重写下commit的时间为当前时间，然后push到服务端，历史就会序列到最后了。&lt;/p&gt;
&lt;h2 id=&quot;模拟用户c-2&quot;&gt;2.1 模拟用户C&lt;/h2&gt;
&lt;p&gt;C用户新下载代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git clone git@github.com:Ryan-Miao/l4git-workflow.git c正克隆到 'c'...
remote: Counting objects: 28, done.
remote: Compressing objects: 100% (17/17), done.
remote: Total 28 (delta 8), reused 22 (delta 4), pack-reused 0
接收对象中: 100% (28/28), 5.90 KiB | 0 bytes/s, 完成.
处理 delta 中: 100% (8/8), 完成.
检查连接... 完成。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后编辑，提交&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cd c
$ git config user.name &quot;C&quot;
$ ls
a.txt  b.txt  readme.md  test.txt
$ vim c.txt
$ git add .
$ git commit -m &quot;C write one&quot;
[master cf3f757] C write one
 1 file changed, 2 insertions(+)
 create mode 100644 c.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;模拟用户d&quot;&gt;2.2 模拟用户D&lt;/h2&gt;
&lt;p&gt;同时，D也需要开发新feature&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git clone git@github.com:Ryan-Miao/l4git-workflow.git d正克隆到 'd'...
remote: Counting objects: 28, done.
remote: Compressing objects: 100% (17/17), done.
remote: Total 28 (delta 8), reused 22 (delta 4), pack-reused 0
接收对象中: 100% (28/28), 5.90 KiB | 0 bytes/s, 完成.
处理 delta 中: 100% (8/8), 完成.
检查连接... 完成。
$ cd d
/d$ git config user.name &quot;D&quot;
/d$ vim d.txt
/d$ git add .
/d$ git commit -m &quot;d write one&quot;
[master db7a6e9] d write one
 1 file changed, 1 insertion(+)
 create mode 100644 d.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;c继续开发&quot;&gt;2.3 C继续开发&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;$ vim c.txt
$ git add .
$ git commit -m &quot;c write two&quot;
[master 01b1210] c write two
 1 file changed, 1 insertion(+)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;d继续开发&quot;&gt;2.4 D继续开发&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;/d$ vim d.txt
/d$ git add .
/d$ git commit -m &quot;d write two&quot;
[master a1371e4] d write two
 1 file changed, 1 insertion(+)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;c-提交&quot;&gt;2.5 C 提交&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;$ vim c.txt 
$ git add .
$ git commit -m &quot;c write three&quot;
[master 13b7dde] c write three
 1 file changed, 1 insertion(+)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C开发结束，提交到远程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git status
位于分支 master
您的分支领先 'origin/master' 共 3 个提交。
  （使用 &quot;git push&quot; 来发布您的本地提交）
无文件要提交，干净的工作区
$ git push origin master:C
对象计数中: 9, 完成.
Delta compression using up to 4 threads.
压缩对象中: 100% (6/6), 完成.
写入对象中: 100% (9/9), 750 bytes | 0 bytes/s, 完成.
Total 9 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 1 local object.
To git@github.com:Ryan-Miao/l4git-workflow.git
 * [new branch]      master -&amp;gt; C
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;c-提pr&quot;&gt;2.6 C 提PR&lt;/h2&gt;
&lt;p&gt;然后，create a Pull Request.&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/c-pr.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;c修改再push&quot;&gt;2.7 C修改再push&lt;/h2&gt;
&lt;p&gt;然后，发现还有个bug要修复，再次修改提交到远程C&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ vim c.txt 
$ git add .
$ git commit -m &quot;C finish something else&quot;
[master 2c5ff94] C finish something else
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git push origin master:C
对象计数中: 3, 完成.
Delta compression using up to 4 threads.
压缩对象中: 100% (3/3), 完成.
写入对象中: 100% (3/3), 301 bytes | 0 bytes/s, 完成.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To git@github.com:Ryan-Miao/l4git-workflow.git
   13b7dde..2c5ff94  master -&amp;gt; C
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;c发现提交次数过多历史太乱合并部分历史&quot;&gt;2.8 C发现提交次数过多，历史太乱，合并部分历史&lt;/h2&gt;
&lt;p&gt;这时，发现一个问题，由于C在开发过程中提交了多次，而这几次提交的message其实没有多大意思，只是因为C可能为了保存代码，也可能是暂存。总之，C的前3次提交的message的含义其实是一样的，都是创建C文件，都是一个主题，那么为了维护历史的干净。最好把这3条信息合并成一条&lt;code&gt;C create file c.txt&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;参考&lt;a href=&quot;http://www.cnblogs.com/woshimrf/p/git-rebase.html&quot;&gt;git 合并历史&lt;/a&gt;，我们需要将3次历史合并成显示为一次。&lt;/p&gt;
&lt;p&gt;查看git历史，找到需要合并的起始区间&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git log --oneline
2c5ff94 C finish something else
13b7dde c write three
01b1210 c write two
cf3f757 C write one
7151f4c 记录操作。
0bfe562 Merge pull request #2 from Ryan-Miao/b_remote
d81ce20 Merge remote-tracking branch 'origin/master' into b
2d74cfb Merge pull request #1 from Ryan-Miao/a
b90a3dd write three
4b1629e a write two
3f30f41 b write two
847078e b write one
53ff45e one
dae77d6 init
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，是要合并&lt;code&gt;cf3f757&lt;/code&gt;到&lt;code&gt;13b7dde&lt;/code&gt;。那么找到前一个的版本号为&lt;code&gt;7151f4c&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git rebase - i 7151f4c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后进入交互界面，因为我们想要把第3次和第2次以及第1次提交信息合并。将第3次的类型修改为&lt;code&gt;squash&lt;/code&gt;, 意思是和第2次合并。然后将第2次的类型修改为&lt;code&gt;squash&lt;/code&gt;, 同样是指合并的前一个commit。&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/c-rebase-i.png&quot;/&gt;&lt;br/&gt;不同git的交互略有不同，之前在windows上的git bash是完全按照vim的命令修改的。本次测试基于Ubuntu，发现存档命令为&lt;code&gt;ctel + X&lt;/code&gt;。确认后进入下一个界面，合并3次提交后需要一个message&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/c-rebase-i-2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除或者anyway you like， 更改message。存档。完成。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git rebase -i 7151f4c
[分离头指针 e3764c5] c create  file c.txt
 Date: Fri Oct 20 22:06:24 2017 +0800
 1 file changed, 4 insertions(+)
 create mode 100644 c.txt
Successfully rebased and updated refs/heads/master.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;&lt;br/&gt;当在rebase过程中出现了失误，可以使用&lt;code&gt;git rebase --abort&lt;/code&gt;返回初始状态。如果发现冲突，则可以解决冲突，然后&lt;code&gt;git rebase --continue&lt;/code&gt; .&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;好像已有 rebase-merge 目录，我怀疑您正处于另外一个变基操作&lt;br/&gt;过程中。 如果是这样，请执行&lt;br/&gt;git rebase (--continue | --abort | --skip)&lt;br/&gt;如果不是这样，请执行&lt;br/&gt;rm -fr &quot;/home/ryan/temp/c/.git/rebase-merge&quot;&lt;br/&gt;然后再重新执行变基操作。 为避免丢失重要数据，我已经停止当前操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时，查看log， 显然，C的那三次提交已经合并了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git log --oneline
50b9fe9 C finish something else
e3764c5 c create  file c.txt
7151f4c 记录操作。
0bfe562 Merge pull request #2 from Ryan-Miao/b_remote
d81ce20 Merge remote-tracking branch 'origin/master' into b
2d74cfb Merge pull request #1 from Ryan-Miao/a
b90a3dd write three
4b1629e a write two
3f30f41 b write two
847078e b write one
53ff45e one
dae77d6 init&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;c再次push&quot;&gt;2.9 C再次push&lt;/h2&gt;
&lt;p&gt;之前的push已经不能用了。需要开新分支推送过去。因为 &lt;strong&gt;rebase 只能在本地分支做。不要修改公共分支&lt;/strong&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git push origin master:C
To git@github.com:Ryan-Miao/l4git-workflow.git
 ! [rejected]        master -&amp;gt; C (non-fast-forward)
error: 无法推送一些引用到 'git@github.com:Ryan-Miao/l4git-workflow.git'
提示：更新被拒绝，因为推送的一个分支的最新提交落后于其对应的远程分支。
提示：检出该分支并整合远程变更（如 'git pull ...'），然后再推送。详见
提示：'git push --help' 中的 'Note about fast-forwards' 小节。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;选择推送的新分支C2&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git push origin master:C2
对象计数中: 6, 完成.
Delta compression using up to 4 threads.
压缩对象中: 100% (5/5), 完成.
写入对象中: 100% (6/6), 569 bytes | 0 bytes/s, 完成.
Total 6 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 1 local object.
To git@github.com:Ryan-Miao/l4git-workflow.git
 * [new branch]      master -&amp;gt; C2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建新的PR&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/c-new.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新的merge方式-rebase&quot;&gt;2.10 新的merge方式： rebase&lt;/h2&gt;
&lt;p&gt;通过开始的普通流程发现，每次merge的时候，都会多出一条新的提交信息，这让历史看起来很奇怪。那么，可以选择rebase到master，变基，就是重新以master为基本，把当前的提交直接移动到master的后面。不会因为提交时间的离散导致多次commit的message被拆散。 选择 &lt;code&gt;rebase and merge&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/c-merge-rebase.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/c-rebase-merge.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候，可以看到C提交的两次信息都是最新的，没有发生交叉。而且也没有产生多余的merge信息。&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/c-log-clean.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有人会问，那么岂不是看不到PR的地址了。点开C的历史。可以看到message下方是有PR的编号的：&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/c-detail.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对了，刚开始的PR要记得close&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/c-pr-close.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;这时候d也完成了&quot;&gt;2.11 这时候D也完成了&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/d$ git push origin master:D
对象计数中: 10, 完成.
Delta compression using up to 4 threads.
压缩对象中: 100% (7/7), 完成.
写入对象中: 100% (10/10), 4.49 KiB | 0 bytes/s, 完成.
Total 10 (delta 2), reused 4 (delta 1)
remote: Resolving deltas: 100% (2/2), completed with 1 local object.
To git@github.com:Ryan-Miao/l4git-workflow.git
 * [new branch]      master -&amp;gt; D
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提PR， 这时候，如果采用merge：&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/d-merge.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/d-log.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果必然发现，1） d提交message被按照时间分散插入历史了(被插入到c的历史之前)， 2）多了一次 &lt;code&gt;Merge pull request #5 from Ryan-Miao/D..&lt;/code&gt;的提交信息。同开头所述一样，历史开始变得混乱了。那么，这种问题怎么办呢？&lt;/p&gt;
&lt;h3 id=&quot;提交前rebase&quot;&gt;2.12 提交前rebase&lt;/h3&gt;
&lt;p&gt;就像C rebase后merge到master一样。我们一样可以在本地做到这样的事情。在本地rebase，让我们本次feature的提交全部插到master节点之后，有序，而且容易revert。&lt;br/&gt;本次，以新的E和F交叉commit为例子，最终将得到各自分开的历史&lt;/p&gt;
&lt;p&gt;E:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git clone git@github.com:Ryan-Miao/l4git-workflow.git e
正克隆到 'e'...
remote: Counting objects: 52, done.
remote: Compressing objects: 100% (33/33), done.
remote: Total 52 (delta 18), reused 36 (delta 7), pack-reused 0
接收对象中: 100% (52/52), 7.91 KiB | 0 bytes/s, 完成.
处理 delta 中: 100% (18/18), 完成.
检查连接... 完成。

$ cd e
/e$ vim e.txt
/e$ git add .
/e$ git config user.name &quot;E&quot;
/e$ git commit -m &quot;e commit one&quot;
[master 77ecd73] e commit one
 1 file changed, 1 insertion(+)
 create mode 100644 e.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;F:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git clone git@github.com:Ryan-Miao/l4git-workflow.git f
正克隆到 'f'...
remote: Counting objects: 52, done.
remote: Compressing objects: 100% (33/33), done.
remote: Total 52 (delta 18), reused 36 (delta 7), pack-reused 0
接收对象中: 100% (52/52), 7.91 KiB | 0 bytes/s, 完成.
处理 delta 中: 100% (18/18), 完成.
检查连接... 完成。

$ cd f
$ vim f.txt
$ git config user.name &quot;F&quot;
$ git add .
$ git commit -m &quot;d write one&quot;
[master b41f8c5] d write one
 1 file changed, 2 insertions(+)
 create mode 100644 f.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;E:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/e$ vim e.txt
/e$ git add .
/e$ git commit -m &quot;e write two&quot;
[master 2b8c9fb] e write two
 1 file changed, 1 insertion(+)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;F:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ vim f.txt
$ git add .
$ git commit -m &quot;f write two&quot;
[master de9051b] f write two
 1 file changed, 1 insertion(+)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;E:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/e$ vim e.txt 
/e$ git add .
/e$ git commit -m &quot;e write three&quot;
[master b1b9f6e] e write three
 1 file changed, 2 insertions(+)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候，e完成了，需要提交。提交前先rebase：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/e$ git fetch
/e$ git rebase origin/master
当前分支 master 是最新的。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，再提交&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/e$ git push origin master:E
对象计数中: 9, 完成.
Delta compression using up to 4 threads.
压缩对象中: 100% (6/6), 完成.
写入对象中: 100% (9/9), 753 bytes | 0 bytes/s, 完成.
Total 9 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 1 local object.
To git@github.com:Ryan-Miao/l4git-workflow.git
 * [new branch]      master -&amp;gt; E
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后， PR, merge.&lt;/p&gt;
&lt;p&gt;同样F:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git status
位于分支 master
您的分支领先 'origin/master' 共 2 个提交。
  （使用 &quot;git push&quot; 来发布您的本地提交）
无文件要提交，干净的工作区
$ git fetch 
remote: Counting objects: 12, done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 12 (delta 6), reused 6 (delta 3), pack-reused 0
展开对象中: 100% (12/12), 完成.
来自 github.com:Ryan-Miao/l4git-workflow
   24c6818..f36907c  master     -&amp;gt; origin/master
 * [新分支]          E          -&amp;gt; origin/E
$ git rebase origin/master
首先，回退分支以便在上面重放您的工作...
应用：d write one
应用：f write two

$ git push origin master:F
对象计数中: 6, 完成.
Delta compression using up to 4 threads.
压缩对象中: 100% (4/4), 完成.
写入对象中: 100% (6/6), 515 bytes | 0 bytes/s, 完成.
Total 6 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 1 local object.
To git@github.com:Ryan-Miao/l4git-workflow.git
 * [new branch]      master -&amp;gt; F
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PR， rebase and merge。 这时候看history：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/f-rebase.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照前几次的做法，E和F交叉在本地提交，每次commit的时间戳也是交叉，最终合并到master的时候，历史并没有被拆散。而是像我们期待的一样，顺序下来。这才是我们想要的。通过看图形化界面也能看出区别：&lt;/p&gt;
&lt;p&gt;绿色的线是master&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/final.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，操作便是fetch-》rebase。事实上，可以二合一为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git pull --rebase origin master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/f1ce447510fcd8c37f0dcb0f677de4896907e607/68747470733a2f2f7777772e61746c61737369616e2e636f6d2f6769742f696d616765732f7475746f7269616c732f636f6c6c61626f726174696e672f636f6d706172696e672d776f726b666c6f77732f63656e7472616c697a65642d776f726b666c6f772f31312e737667&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最终结果&quot;&gt;最终结果&lt;/h2&gt;
&lt;p&gt;在都没提交到server的时候， 历史是分散在各个开发者的本地，但commit时间有先后。&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/start.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照&lt;code&gt;rebase&lt;/code&gt;的用法，提交前&lt;code&gt;rebase&lt;/code&gt;一次，就可以使得一个feature的提交串联到一起&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/end.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终在github的commit看起来也就是顺畅的多&lt;br/&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2017/git/git-end.png&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;想维持树的整洁，方法就是：在git push之前，先git fetch，再git rebase。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;git fetch origin master
git rebase origin/master
git push&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git pull --rebase origin master&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，就不会有事。 假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。&lt;/p&gt;
&lt;p&gt;如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;绝对不要在公共(远程分支)上rebase，也就是说，如果没有必要就不要在github merge的时候选择rebase，而是用上述的办法，&lt;strong&gt;在本地自己的分支推送前rebase&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;绝对不可以在公共分支上reset，也不要用--force&lt;/li&gt;
&lt;li&gt;单独功能的多次提交要学会合并提交，保持提交的简洁。&lt;/li&gt;
&lt;li&gt;提交message尽量能概括修改内容。&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Mon, 23 Oct 2017 05:12:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woshimrf/p/git-workflow.html</dc:identifier>
</item>
<item>
<title>JPA + SpringData 操作数据库原来可以这么简单 ---- 深入了解 JPA - 2 - crawl+</title>
<link>http://www.cnblogs.com/crawl/p/7704914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crawl/p/7704914.html</guid>
<description>&lt;h4&gt;原创播客，如需转载请注明出处。原文地址：&lt;span&gt;&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: JPA + SpringData 操作数据库原来可以这么简单 ---- 深入了解 JPA - 2&quot; href=&quot;http://www.cnblogs.com/crawl/p/7704914.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/crawl/p/7704914.html&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;-----------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;笔记中提供了大量的代码示例，需要说明的是，大部分代码示例都是本人所敲代码并进行测试，不足之处，请大家指正~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本博客中所有言论仅代表博主本人观点，若有疑惑或者需要本系列分享中的资料工具，敬请联系 &lt;span&gt;qingqing_crawl@163.com&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;-----------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;前言：继续介绍 JPA ，这一篇将介绍 JPA 的常用 API，以及在 JPA 中映射关联关系。上一篇讲到 JPA 和 Hibernate 关系密切，尤其是在 API 和映射关联关系上，大家可以参看 LZ关于 Hibernate 介绍的博客 &lt;span&gt;&lt;a title=&quot;Hibernate 学习笔记 - 1&quot; href=&quot;http://www.cnblogs.com/crawl/p/7678753.html%20&quot; target=&quot;_blank&quot;&gt;Hibernate 学习笔记 - 1&lt;/a&gt; &lt;span&gt;和&lt;/span&gt; &lt;a title=&quot;Hibernate 学习笔记 - 2&quot; href=&quot;http://www.cnblogs.com/crawl/p/7680415.html%20&quot; target=&quot;_blank&quot;&gt;Hibernate 学习笔记 - 2&lt;/a&gt; ，&lt;span&gt;与 Hibernate 类似的地方LZ也会特别指出。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;四、JPA 的 API&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1.&lt;strong&gt;&lt;span&gt;Persistence&lt;/span&gt;&lt;/strong&gt; ：用于&lt;strong&gt;&lt;span&gt;获取 EntiryManagerFactory 的实例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）常用方法：Persistence.&lt;strong&gt;createEntityManagerFactory(persistenceUnitName)&lt;/strong&gt; 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; String persistenceUnitName = &quot;jpa-1&quot;&lt;span&gt;;&lt;/span&gt;        
&lt;span&gt;2&lt;/span&gt; EntityManagerFactory entityManagerFactory = &lt;span&gt;Persistence.createEntityManagerFactory(persistenceUnitName);&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. &lt;strong&gt;&lt;span&gt;EntiryManagerFactory&lt;/span&gt;&lt;/strong&gt; ：常用方法&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;&lt;span&gt;获取 EntiryManager&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建 EntityManager,类似于 Hibernate 的 SessionFactory&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; EntityManager entityManager = &lt;span&gt;entityManagerFactory.createEntityManager();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）close() 方法，关闭自身，此方法不再演示&lt;/p&gt;
&lt;p&gt;3. &lt;strong&gt;&lt;span&gt;EntityManager&lt;/span&gt;&lt;/strong&gt; 的常用 API&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;&lt;span&gt;find() 方法&lt;/span&gt;&lt;/strong&gt;，&lt;span&gt;类似于 Hibernate 中的 Session 的 get() 方法&lt;strong&gt;，&lt;/strong&gt;&lt;/span&gt;在执行 find 方法时就发送 SQL 语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类似于 Hibernate 中 Session 的 get 方法&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testFind() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         Customer customer = entityManager.find(Customer.&lt;span&gt;class&lt;/span&gt;, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         
&lt;span&gt;6&lt;/span&gt;         System.out.println(&quot;----------------------------------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        System.out.println(customer);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果为：查看横线的位置便可证明结论。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;Hibernate: 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    select
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        customer0_.id as id1_2_0_,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        customer0_.age as age2_2_0_,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        customer0_.birth as birth3_2_0_,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        customer0_.createTime as createTi4_2_0_,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        customer0_.email as email5_2_0_,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        customer0_.LAST_NAME as LAST_NAM6_2_0_ 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    from
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        JPA_CUSTOMER customer0_ 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    where
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         customer0_.id=?
&lt;span&gt;13&lt;/span&gt; ----------------------------------------
&lt;span&gt;14&lt;/span&gt; Customer [id=1, lastName=AA, email=aa@163.com, age=21, birth=2015-10-22, createTime=2017-10-11 22:39:13.0]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）&lt;strong&gt;&lt;span&gt;getReference()&lt;/span&gt;&lt;/strong&gt; 方法，&lt;span&gt;类似于 Hibernate 的 Session 的 load() 方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于 Hibernate 中 Session 的 load 方法，若不使用查询的对象则返回一个代理对象，到真正使用时才发送 SQL 语句查询
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可能会发生懒加载异常&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testGetReference() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Customer customer = entityManager.getReference(Customer.&lt;span&gt;class&lt;/span&gt;, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        System.out.println(customer.getClass().getName());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;         System.out.println(&quot;---------------------------------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;      transaction.commit();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;      entityManager.close();&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        System.out.println(customer);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果为：打印的是一个代理对象，并且横线打印在  SQL 前面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;com.software.jpa.helloworld.Customer_$$_javassist_1
&lt;/span&gt;---------------------------------------&lt;span&gt;
Hibernate: 
    select
        customer0_.id as id1_2_0_,
        customer0_.age as age2_2_0_,
        customer0_.birth as birth3_2_0_,
        customer0_.createTime as createTi4_2_0_,
        customer0_.email as email5_2_0_,
        customer0_.LAST_NAME as LAST_NAM6_2_0_ 
    from
        JPA_CUSTOMER customer0_ 
    where
        customer0_.id&lt;/span&gt;=?&lt;span&gt;
Customer [id&lt;/span&gt;=1, lastName=AA, email=aa@163.com, age=21, birth=2015-10-22, createTime=2017-10-11 22:39:13.0]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3）&lt;strong&gt;&lt;span&gt;persistence()&lt;/span&gt;&lt;/strong&gt; 方法，类似于 Hibernate 的 save() 方法，与 Hibernate 的 save() 方法不同的是&lt;span&gt;&lt;strong&gt;其不能插入一个有 id 属性的对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;类似于 Hibernate 的 save 方法，使对象由临时状态变为持久化对象
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;和 Hibernate 的 save 方法的区别为若有 id 属性，则不会执行插入操作而会抛出异常&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testPersistence() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Customer customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         customer.setLastName(&quot;BB&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         customer.setEmail(&quot;bb@163.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         customer.setBirth(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         customer.setCreateTime(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         customer.setAge(21&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;      customer.setId(100);&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        entityManager.persist(customer);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        System.out.println(customer.getId());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4）&lt;strong&gt;&lt;span&gt;remove()&lt;/span&gt;&lt;/strong&gt; 方法，&lt;strong&gt;类似于 Hibernate 中 Session 的 delete 方&lt;span&gt;法&lt;/span&gt;&lt;/strong&gt;，但是&lt;span&gt;其不能删除 游离化对象（仅有 id）&lt;span&gt;，执行 5，6行会抛出异常，因为 5 行的 customer 对象为游离化对象&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;类似于 Hibernate Session 的 delete 方法，把对象对应的记录从数据库中删除
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注：该方法只能移出 持久化 对象，而 Hibernate 的 delete 方法可以移除游离对象&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testRemove() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;      Customer customer = new Customer();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;      customer.setId(2);&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;         Customer customer = entityManager.find(Customer.&lt;span&gt;class&lt;/span&gt;, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        entityManager.remove(customer);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         
&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5）&lt;strong&gt;&lt;span&gt;merge()&lt;/span&gt;&lt;/strong&gt; 方法，&lt;span&gt;类似于 Hibernate 中 Session 的 saveOrUpdate()&lt;/span&gt; 方法&lt;/p&gt;
&lt;p&gt;① 传入的是一个&lt;span&gt;临时对象（没有 id）&lt;/span&gt;：会创建一个新的对象，把临时对象的属性复制到新的对象中，然后对新的对象执行持久化操作，&lt;span&gt;13行执行了 merge() 方法，传入了一个临时对象，返回了一个新的对象，产看 15，16 行的结果可知，新的对象有 id，传入的对象木有id，说明是将新的对象插入了数据库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.若传入的是一个临时对象（没有 Id）
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;会创建一个新的对象，把临时对象的属性复制到新的对象中，然后对新的对象执行持久化操作
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所以 新的对象中有 id，而之前的临时对象中没有 id&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMerge1() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Customer customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         customer.setAge(23&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         customer.setBirth(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         customer.setCreateTime(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         customer.setEmail(&quot;cc@126.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         customer.setLastName(&quot;CC&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;        &lt;span&gt; Customer customer2 =&lt;/span&gt;&lt;span&gt;&lt;span&gt; entityManager.merge(customer);  &lt;/span&gt;      
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         
&lt;span&gt;15&lt;/span&gt;         System.out.println(&quot;customer's id:&quot; + customer.getId());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; null&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         System.out.println(&quot;customer's id:&quot; + customer2.getId());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 传入的是一个&lt;span&gt;游离对象（有 ID）&lt;/span&gt;：若在 EntityManager &lt;span&gt;缓存中没有该对象&lt;/span&gt;，在&lt;span&gt;数据库中也没有对应的记录&lt;/span&gt;，&lt;span&gt;JPA 会创建一个新的对象，把当前游离对象的属性复制到新的对象中，对新创建的对象执行 insert 操作&lt;span&gt;，LZ的数据库对应的表中并没有 id 为 100 customer，15 行同样返回了一个新的对象，根据返回结果可知 ，确实插入的是新的对象&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.若传入的是一个游离对象，即传入的对象有 OID
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若在 EntityManager 缓存中没有该对象，在数据库中也没有对应的记录，JPA 会创建一个新的对象，
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把当前游离对象的属性复制到新的对象中，对新创建的对象执行 insert 操作&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMerge2() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Customer customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         customer.setAge(23&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         customer.setBirth(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         customer.setCreateTime(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         customer.setEmail(&quot;dd@126.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         customer.setLastName(&quot;DD&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;         customer.setId(100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         
&lt;span&gt;15&lt;/span&gt;        &lt;span&gt; Customer customer2 = entityManager.merge(customer);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         System.out.println(&quot;customer's id:&quot; + customer.getId());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 100&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         System.out.println(&quot;customer's id:&quot; + customer2.getId());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 传入的是&lt;span&gt;游离对象&lt;/span&gt;，即传入的对象有 OID，缓存中没有，&lt;span&gt;但数据库中有对应的对象&lt;/span&gt;：JPA 会查询对应的记录，然后返回该记录对应的对象把当前游离对象的属性复制到查询到的对象中，对查询到的对象执行 update 操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.若传入的是一个游离对象，即传入的对象有 OID
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若在 EntityManager 缓存中没有该对象，在数据库中有对应的记录，JPA 会查询对应的记录，然后返回该记录对应的对象
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把当前游离对象的属性复制到查询到的对象中，对查询到的对象执行 update 操作&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMerge3() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Customer customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         customer.setAge(23&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         customer.setBirth(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         customer.setCreateTime(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         customer.setEmail(&quot;ff@126.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         customer.setLastName(&quot;FF&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;         customer.setId(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         
&lt;span&gt;15&lt;/span&gt;        &lt;span&gt; Customer customer2 = entityManager.merge(customer);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         System.out.println(customer == customer2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 传入的是&lt;span&gt;游离对象&lt;/span&gt;，即传入的对象有 OID，&lt;span&gt;EntityManager 缓存中有对应的对象&lt;/span&gt;：JPA 会把当前游离对象的属性复制到查询到的 EntityManager 缓存中的对象，对 EntityManager 缓存中的对象执行 update 操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.若传入的是一个游离对象，即传入的对象有 OID
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若在 EntityManager 缓存中有对应的对象，JPA 会把当前游离对象的属性复制到查询到的 EntityManager 缓存中的对象，
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对 EntityManager 缓存中的对象执行 update 操作&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMerge4() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Customer customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         customer.setAge(23&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         customer.setBirth(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         customer.setCreateTime(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         customer.setEmail(&quot;dd@126.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         customer.setLastName(&quot;DD&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;         customer.setId(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Customer customer2 = entityManager.find(Customer.&lt;span&gt;class&lt;/span&gt;, 3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        entityManager.merge(customer);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         System.out.println(customer == customer2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.&lt;strong&gt;EntityTransaction&lt;/strong&gt;：&lt;span&gt;JPA 中的事务操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;常用 API： &lt;span&gt;begin()      commit()     rollback()  &lt;span&gt;代码不再演示&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;五、JPA 中映射关联关系&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. 映射&lt;span&gt;&lt;strong&gt;&lt;span&gt;单向多对一&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;的关联关系：Order : Custome&lt;span&gt;r&lt;/span&gt;  n:1 ,&lt;strong&gt;Order&lt;/strong&gt; &lt;strong&gt;中有 Customer 属性，而 Customer 中没有 Order 属性&lt;/strong&gt;（&lt;strong&gt;单向多对一区别于单向一对多&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;1）创建 Order 实体类，标注注解，生成数据表，使用 &lt;span&gt;@ManyToOne 映射多对一的关联关系，使用 @JoinColumn 来标注外键&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.software.jpa.helloworld;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Column;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.FetchType;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinColumn;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.ManyToOne;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; @Table(name=&quot;JPA_ORDERS&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;@Entity
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Order {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String orderName;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @GeneratedValue
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Id
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     @Column(name=&quot;ORDER_NAME&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getOrderName() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderName;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOrderName(String orderName) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.orderName =&lt;span&gt; orderName;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Customer customer;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;     * 映射单项 n-1 的关联关系（Customer 和 Order，Order 中有 Customer 属性，而 Customer 中没有 Order 属性）
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;     * &lt;span&gt;使用 @ManyToOne 来映射多对一的关联关系
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;     * 使&lt;span&gt;用 @JoinColumn 来映射外键
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;     * &lt;span&gt;可以使用 @ManyToOne 的 fetch 属性来修改默认的关联属性的加载策略
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;@JoinColumn(name=&quot;CUSTOMER_ID&quot;)
48     @ManyToOne(fetch=FetchType.LAZY)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Customer getCustomer() {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; customer;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomer(Customer customer) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.customer =&lt;span&gt; customer;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     
&lt;span&gt;57&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）单向多对一的&lt;strong&gt;保存（persist）&lt;/strong&gt;：&lt;strong&gt;保存多对一时，建议先保存 1 的一端&lt;/strong&gt;，后保存 n 的一端，这样不会多出额外的 UPDATE 语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161238412-5138144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;获取操作（find）&lt;/strong&gt;：&lt;strong&gt;默认情况下使用左外连接的方式来获取 n 的一端的对象和其关联的 1 的一端的对象&lt;/strong&gt;，可以使用 &lt;span&gt;&lt;strong&gt;@ManyToOne 的 fetch 属性&lt;/strong&gt;&lt;/span&gt;来&lt;strong&gt;修改默认的关联属性的加载策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161331459-1275649756.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161341959-1504171335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4）&lt;strong&gt;&lt;span&gt;删除操作（remove）&lt;/span&gt;&lt;/strong&gt;：不能直接删除 1 的一端，因为有外键约束&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161445631-1597664588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5）修改操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161503193-421266444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.映射&lt;strong&gt;&lt;span&gt;单向 1-n&lt;/span&gt;&lt;/strong&gt; 的关联关系 &lt;strong&gt;Customer ：Order&lt;/strong&gt;  &lt;strong&gt;1&lt;/strong&gt; &lt;strong&gt;： n&lt;/strong&gt;，&lt;strong&gt;Customer 中有 Order 的 Set 集合属性，Order 中没有 Customer的属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;在 Customer 中添加 Order 的 Set 集合属性，并映射 1-n 关联关系&lt;/strong&gt;，重新生成数据表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161615802-713501391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;保存操作（persist）&lt;/strong&gt;：&lt;strong&gt;总会多出 UPDATE 语句，n 的一端在插入时不会同时插入外键列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161645490-175802889.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;查询操作（find）&lt;/strong&gt;:&lt;strong&gt;&lt;span&gt;默认使用懒加载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161735068-886057935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161741115-1014776929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4）&lt;strong&gt;删除操作（remove&lt;/strong&gt;）：默认情况下，若删除 1 的一端，会先把关联的 n 的一端的外键置空，然后再进行删除，可以通过 @OneToMany 的 cascade 属性修改默认的删除策略（CascadeType.REMOVE 为级联删除）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161803490-2050995358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161809287-483107731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;映射双向多对一的关联关系&lt;/strong&gt;（&lt;strong&gt;&lt;span&gt;注：双向多对一 同 双向一对多&lt;/span&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;1）实体：&lt;strong&gt;Customer 中有 Order 的 Set 集合属性，Order 中有 Customer 的属性，注两个实体映射的外键列必须一致，都为 CUSTOMER_ID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161913412-816511709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161926084-1935675900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2)&lt;strong&gt;保存操作（persist）&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021161945802-57051209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021162002381-270510207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;映射双向一对一的关联关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）实体：&lt;strong&gt;Manager 和 Department ，一个部门有一个经理，一个经理管一个部门&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2）创建 Manager 类和 Department 类，&lt;strong&gt;Manager 类中有 Department 的引用，Department 中有 Manager 的引用&lt;/strong&gt;，由 &lt;strong&gt;Department 来维护关联关系（实际上双向 1- 1 双方均可以维护关联关系）&lt;/strong&gt;，使用 &lt;strong&gt;@OneToOne&lt;/strong&gt; 来&lt;strong&gt;映射 1-1 关联关系&lt;/strong&gt;。添加必要注解，生成数据表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021162024349-592063253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021162030959-1955676761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;保存操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021162049287-518801843.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4）&lt;strong&gt;查询操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021162101740-1415465702.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;strong&gt;映射双向多对多的关联关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）实体：&lt;strong&gt;Item 和 Category ，一个类别有多个商品，一个商品对应多个类别&lt;/strong&gt;。&lt;strong&gt;双方都包含对方的 Set 集合。&lt;/strong&gt;创建实体类，添加对应的注解，生成数据表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021162118427-659635790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;保存操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021162130193-2105658680.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;查询操作&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1105175/201710/1105175-20171021162143662-196068483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;----------------------------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相关链接：&lt;a title=&quot;JPA + SpringData 操作数据库原来可以这么简单 ---- 深入了解 JPA - 1&quot; href=&quot;http://www.cnblogs.com/crawl/p/7703679.html%20&quot; target=&quot;_blank&quot;&gt;JPA + SpringData 操作数据库原来可以这么简单 ---- 深入了解 JPA - 1&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 04:41:00 +0000</pubDate>
<dc:creator>crawl+</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crawl/p/7704914.html</dc:identifier>
</item>
<item>
<title>React与Preact差异之 -- setState - SuperEVO</title>
<link>http://www.cnblogs.com/zhang740/p/7714625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhang740/p/7714625.html</guid>
<description>&lt;p&gt;Preact是React的轻量级实现，是React比较好的替代者之一，有着体积小的优点，当然与React之间一定会存在实现上的差异，本文介绍了在 setState 方面的差异之处。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;首先来分析下React以及Preact在setState部分的具体实现。&lt;/p&gt;
&lt;p&gt;(太长不看想偷懒，可以直接下翻看结论)&lt;/p&gt;
&lt;h3 id=&quot;react&quot;&gt;React&lt;/h3&gt;
&lt;p&gt;关键代码：&lt;/p&gt;
&lt;h4 id=&quot;setstate-阶段&quot;&gt;setState 阶段：&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// ReactUpdateQueue.js&lt;/span&gt;
enqueueSetState&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(publicInstance&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; partialState) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  ...

  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; queue &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;internalInstance&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_pendingStateQueue&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt;
    (&lt;span class=&quot;va&quot;&gt;internalInstance&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_pendingStateQueue&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;queue&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(partialState)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;enqueueUpdate&lt;/span&gt;(internalInstance)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到React在 setState 的时候不会做任何处理，会把变更直接放到一个专门处理 state 的队列里供组件更新时使用。&lt;/p&gt;
&lt;h4 id=&quot;更新阶段&quot;&gt;更新阶段：&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;29&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// ReactCompositeComponent.js&lt;/span&gt;
updateComponent&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(
  transaction&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  prevParentElement&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  nextParentElement&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  prevUnmaskedContext&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  nextUnmaskedContext&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; inst &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_instance&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  ...

  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; willReceive &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; nextContext&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_context&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; nextUnmaskedContext) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    nextContext &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;inst&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    nextContext &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_processContext&lt;/span&gt;(nextUnmaskedContext)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    willReceive &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; prevProps &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;prevParentElement&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; nextProps &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;nextParentElement&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (prevParentElement &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; nextParentElement) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    willReceive &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (willReceive &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;inst&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;componentWillReceiveProps&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    ...
    &lt;span class=&quot;va&quot;&gt;inst&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;componentWillReceiveProps&lt;/span&gt;(nextProps&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; nextContext)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;co&quot;&gt;// 在此处才计算 nextState&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; nextState &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_processPendingState&lt;/span&gt;(nextProps&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; nextContext)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 此处传入了 nextProps&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; shouldUpdate &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_pendingForceUpdate&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;inst&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;shouldComponentUpdate&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      ...
      shouldUpdate &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;inst&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;shouldComponentUpdate&lt;/span&gt;(
        nextProps&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        nextState&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        nextContext&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      )&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_compositeType&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;CompositeTypes&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;PureClass&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 敲黑板，知识点 —— 如果你的组件没实现shouldComponentUpdate，那么把React.Component 换成 React.PureComponent 可以获得基础版优化，提高性能。&lt;/span&gt;
        shouldUpdate &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;
          &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;shallowEqual&lt;/span&gt;(prevProps&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; nextProps) &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt;
          &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;shallowEqual&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;inst&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; nextState)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 浅比较，可以抄去自己改成属性黑/白名单版&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  ...
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// ReactCompositeComponent.js&lt;/span&gt;
_processPendingState&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(props&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; context) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// props: nextProps&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; inst &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_instance&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; queue &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_pendingStateQueue&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; replace &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_pendingReplaceState&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_pendingReplaceState&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_pendingStateQueue&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;queue) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;inst&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (replace &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;queue&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; queue[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; nextState &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;assign&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{},&lt;/span&gt; replace &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; queue[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] : &lt;span class=&quot;va&quot;&gt;inst&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; replace &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;queue&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; partial &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; queue[i]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;assign&lt;/span&gt;(
      nextState&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; partial &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'function'&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;partial&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;call&lt;/span&gt;(inst&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; nextState&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; props&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; context) &lt;span class=&quot;co&quot;&gt;// nextProps&lt;/span&gt;
        : partial&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    )&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; nextState&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面组件更新的流程代码可以看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 updateComponent 中，在 componentWillReceiveProps 之后才会计算 nextState，所以在 componentWillReceiveProps 中 setState 是可以在当次更新中生效的。&lt;/li&gt;
&lt;li&gt;在 _processPendingState 会对队列里的 state 进行叠加，如果修改是函数方式，此处传入的state参数是 nextState，props 是 nextProps。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;preact&quot;&gt;Preact&lt;/h3&gt;
&lt;p&gt;关键代码：&lt;/p&gt;
&lt;h4 id=&quot;setstate-阶段-1&quot;&gt;setState 阶段：&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// component.js&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(state&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; callback) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; s &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prevState&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prevState&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{},&lt;/span&gt; s)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;(s&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; state&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'function'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;state&lt;/span&gt;(s&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;) : state)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (callback) (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_renderCallbacks&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_renderCallbacks&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; [])).&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(callback)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;enqueueRender&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现的简单粗暴，在 setState 的时候就进行了合并，会立即改写 this.state，在第一次 setState 时会保留 state 状态到 prevState。由于是立即合并state，如果入参state是函数，props 将只是当前 this.props。&lt;/p&gt;
&lt;h4 id=&quot;更新阶段-1&quot;&gt;更新阶段：&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;renderComponent&lt;/span&gt;(component&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; opts&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; mountAll&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; isChild) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  ...
  previousProps &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prevProps&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; props&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  previousState &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prevState&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; state&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  previousContext &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prevContext&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; context&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  ...

  &lt;span class=&quot;co&quot;&gt;// if updating&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (isUpdate) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; previousProps&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; previousState&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; previousContext&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (opts&lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt;FORCE_RENDER
      &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;shouldComponentUpdate&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;shouldComponentUpdate&lt;/span&gt;(props&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; state&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; context) &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      skip &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;componentWillUpdate&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;componentWillUpdate&lt;/span&gt;(props&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; state&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; context)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; props&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; state&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;component&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; context&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  ...
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在更新流程前提取了旧 state，shouldComponentUpdate、componentWillUpdate 之后还原回新值，所以在 shouldComponentUpdate 生命周期中，this.props 将获取的是 prevProps，这里与 React 的逻辑并不一致。&lt;/p&gt;
&lt;h2 id=&quot;划重点&quot;&gt;划重点&lt;/h2&gt;
&lt;p&gt;相同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 componentWillReceiveProps 中 setState 都会应用到 nextState。&lt;/li&gt;
&lt;li&gt;在 shouldComponentUpdate 中 setState 都&lt;strong&gt;不&lt;/strong&gt;会应用到 nextState，但是可以直接操作传入的 nextState。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;React下 setState 的值不会立即生效，会一直积累到 componentWillReceiveProps，在此之后会进行合并，并提供给后续生命周期。而Preact下 setState 会立即反映到 this.state，&lt;strong&gt;但是&lt;/strong&gt;，在更新组件的生命周期到 render 前(eg: shouldComponentUpdate), this.state 将会是 prevState。&lt;/li&gt;
&lt;li&gt;shouldComponentUpdate 阶段 setState 虽然不会影响到最终 state 的值，但是Preact下会影响 this.state 的值，比如之后 componentWillUpdate 中的 this.state, 总之此阶段不要 setState 反正也没用。&lt;/li&gt;
&lt;li&gt;setState 如果使用函数修改，Preact下传入的 props 将会是 prevProps，而React中是 nextProps，在 componentWillReceiveProps 中 setState 时要注意。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;如果你写的工程需要同时兼容React及Preact的话：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要利用React下 setState 在同一次组件更新执行前 state 不立即更新的特性，注意多个 setState 之间是否影响，必要时手动保存旧值。&lt;/li&gt;
&lt;li&gt;在组件更新生命周期内,除 componentWillReceiveProps 之外不要使用 setState，提供了 nextState 的生命周期，可以直接修改 nextState。&lt;/li&gt;
&lt;li&gt;尽量避免使用 setState 函数修改方式，在 componentWillReceiveProps 中使用时，使用生命周期中的 prevProps(this.props) 和 nextProps。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;p.s: antd-mobile 2.0正式版已发布，同时兼容react、preact，轻量、快速、易用的移动端组件库，等你来用~ &lt;a href=&quot;http://mobile.ant.design/&quot;&gt;【传送门】&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 02:13:00 +0000</pubDate>
<dc:creator>SuperEVO</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhang740/p/7714625.html</dc:identifier>
</item>
<item>
<title>2017上海QCon之旅总结（上） - 杭州.Mark</title>
<link>http://www.cnblogs.com/hzmark/p/2017qcon.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hzmark/p/2017qcon.html</guid>
<description>&lt;p&gt;本来这个公众号的交流消息中间件相关的技术的。这周去上海参加了QCon，第一次参加这样的技术会议，感受挺多的，所以整理一下自己的一些想法接公众号和大家交流一下。&lt;/p&gt;
&lt;p&gt;下面进入正题，从自己参加了的一些分享中挑一些有趣的议题来和大家讨论。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;toc_1&quot;&gt;《“深蓝”20年之后的人工智能》&lt;/h3&gt;
&lt;p&gt;2017年可以说是人工智能的元年了，AlphaGo战胜李世石然人工智能一下进入了大众的视野。之后以Master的身份60连胜，接着战胜长期世界排名第一的柯洁，QCon期间AlphaGo Zero通过3天自学的方式就以100:0的方式战胜了AlphaGo，可以说在棋类领域人类对人工智能已经没有任何胜算了。&lt;/p&gt;
&lt;p&gt;这次QCon，复旦大学的危辉教授从人工智能的历史说起，之后从人工智能的问题域、解题步骤步步深入，清晰的描述了目前人工智能领域的进展。&lt;/p&gt;
&lt;p&gt;危辉教授的《“深蓝”20年之后的人工智能》分享可能从听众的感受上有点“反”人工智能热潮，但是我认为这场分享是给人工智能的门外的我们一个很好的入门介绍，让我们明白目前人工智能领域的发展状况，让我们对遍地的人工智能现象有一个清晰的任务。&lt;/p&gt;
&lt;p&gt;另外危辉教授演讲的逻辑性、严谨性和现场把控能力，真的是单从一场分享能感受到功底的深厚。&lt;/p&gt;
&lt;p&gt;这场分享的PPT没能从QCon网站上下载到，并不能回忆起很多具体的分享内容，以上是个人现场感受的一些体验。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;toc_2&quot;&gt;《免费的性能午餐——Alibaba JDK协程》&lt;/h3&gt;
&lt;p&gt;这一场是阿里巴巴技术专家郁磊带来关于Alibaba JDK协程的介绍。&lt;/p&gt;
&lt;p&gt;在参加这次分享之前，我对协程并没有什么概念（没写过C++程序）。这场分享下来只能说有个简单的认识，另外就是感叹于阿里的同学在这块技术领域的深入。&lt;/p&gt;
&lt;p&gt;不过就目前的状况，对我们这样一些小公司而言，可能并没有技术能力去修改JVM，短期内的编程方式并不会有太大的改变。可能当协程成为一种标准，一种官方提倡的编程方式之后才会慢慢进入大众程序员的领域（那为什么不提前学习一些呢？）。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;toc_3&quot;&gt;《基于内存的分布式计算》&lt;/h3&gt;
&lt;p&gt;这是这次QCon去听的第一个具体问题领域的解决方案。&lt;/p&gt;
&lt;p&gt;包含内容如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;背景介绍及问题阐述&lt;/li&gt;
&lt;li&gt;候选解决方案分析&lt;/li&gt;
&lt;li&gt;分布式内存计算框架介绍&lt;/li&gt;
&lt;li&gt;客户实践&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里我简要的说一下第1点和第3点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Talking Data技术团队使用bitmap索引技术移动运营各项指标（如日活、留存）的实时计算，因为bitmap索引高效且能节省存储空间，它能很方便地做指标的实时排重。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/471426/201710/471426-20171022142535084-1584512804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是日活的一个例子，其实就是用一个二进制位来保存用户的状态。比如第一位表示用户设备1，该位为0表示用户未登录过，为1表示用户登录过。那么用户重复的登录自然就被忽略了。&lt;/p&gt;
&lt;p&gt;Talking Data使用MySQL的blob类型存储bitmap数据，那么每次需要更新数据时，如需要更新某一个用户的状态，那么需要将bitmap读取出来，修改其中一位，之后将数据写回到MySQL中。那么就带来了一个问题，当某个APP的日活数据量特别大时，bitmap数据特别大，频繁的update导致了产生大量的MySQL binlog。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/471426/201710/471426-20171022142558849-1906590239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概思路就是在MySQL之前加上一层缓存，前端的更新操作都在Blade内存中操作，之后定时同步写到MySQL中，这样就解决了频繁更新bitmap导致的大量binlog问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/471426/201710/471426-20171022142624802-2069643175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;几个组件如上图：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;APP中使用的Client&lt;/li&gt;
&lt;li&gt;内存计算服务Blade Server（分为Master和Slave）&lt;/li&gt;
&lt;li&gt;Blade Data Sync负责从Server定时同步数据到MySQL&lt;/li&gt;
&lt;li&gt;Blade Admin提供管控功能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上图中Blade Server有主备关系，且主备间有交互。&lt;/p&gt;
&lt;p&gt;现场提问环节，我提了以下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;主从复制是怎么做的、支持一主多从吗？&lt;/li&gt;
&lt;li&gt;Blade Server是基于内存的，没有做持久化，那么可么保证系统的可靠性，比如如果主从两个节点宕机了，未同步到MySQL的数据是否就丢失了？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;得到的答复是目前他们并没有做主从复制，当前其实是双写的模式，即Client会将数据写到Master和Slave。这样也就没有第二个问题的处理了。&lt;/p&gt;
&lt;p&gt;对于分布式系统，认为首先要考虑的就是系统的可靠性和可用性。&lt;/p&gt;
&lt;p&gt;我们常常说的一点就是为了保证数据的可靠性，我们需要一式三份，而且是尽量让三分数据分不到不同机器中，比如同机柜的机器存一份，跨机柜的存一份，像HDFS那样存储数据。&lt;/p&gt;
&lt;p&gt;所以我觉得上面的方案并不是一个很可靠的方案。&lt;/p&gt;
&lt;p&gt;比如使用消息中间件的方式是否能代替上面的方案呢？&lt;/p&gt;
&lt;p&gt;客户端将消息发送到消息中间件中，类似于RocketMQ和Kafka这样的组件中，之后通过Consumer定时从中取消费数据来解决频繁更新的问题（数据的可靠性通过消息中间件得到了保证）。&lt;/p&gt;
&lt;p&gt;也可启动实时消费的Consumer来消费数据更新到某个内存服务中，这样可以提供实时的查询服务。&lt;/p&gt;
&lt;p&gt;以上是自己的一些疑问和拍脑袋的一个替代方案，欢迎交流不同的想法。&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;toc_4&quot;&gt;《饿了么异地多活的基础设施建设》&lt;/h3&gt;
&lt;p&gt;之前我们团队考虑过一些异地多活的实现方案，所以特地去听了这场分享。&lt;/p&gt;
&lt;p&gt;之前在自己考虑异地多活方案时，遇到的最大的问题是数据同步和数据一致性。&lt;/p&gt;
&lt;p&gt;下面看饿了么是如何实现基地多活的。&lt;/p&gt;
&lt;p&gt;首先是饿了么的业务特点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/471426/201710/471426-20171022142659865-673384292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中最重要的一点就是地域性。&lt;/p&gt;
&lt;p&gt;饿了么的业务特点，可以将所有数据按照商户所在的位置信息来进行划分。&lt;/p&gt;
&lt;p&gt;比如所有南方商户的数据走上海机房，所有北方商户的数据走北京机房。对于用户和订单信息，都可以关联到对应的商家，然后访问商家对应所在的机房的服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/471426/201710/471426-20171022142757740-560058749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是饿了么异地多活的数据复制实现。思路就是在两个机房之间进行双向的数据复制。&lt;/p&gt;
&lt;p&gt;回想一下，因为饿了么的业务特点，双向复制的数据中不会有重叠的部分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从北京机房往上海机房复制的是北方商户的数据&lt;/li&gt;
&lt;li&gt;从上海机房到北京机房复制的是南方商户的数据&lt;/li&gt;
&lt;li&gt;在复制中过滤掉不必要的数据，比如从上海复制到北京的数据，这部分数据应用到MySQL之后也会产生binlog，这部分binlog需要从北京复制到上海的数据中剔除（这个通过改造SQL或者增加标识是可以做到的）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样就避免掉了一个数据在两个机房同时被修改的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑一个问题，比如在电商场景中做异地多活。&lt;/p&gt;
&lt;p&gt;对于一个商品，在北京机房和上海机房都会被访问，这个时候就产生了一个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;商品的库存为1，北京机房下了一单，将商品库存变更为0；同时上海机房也下了一单，也将库存变更为0。这样就产生了超卖的问题。&lt;/li&gt;
&lt;li&gt;另外，如何在双向数据同步中将上线的数据修复，即使其中一个订单失效，将库存修复也会一个问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Otter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;阿里巴巴B2B公司，因为业务的特性，卖家主要集中在国内，买家主要集中在国外，所以衍生出了杭州和美国异地机房的需求，同时为了提升用户体验，整个机房的架构为双A，两边均可写，由此诞生了otter这样一个产品。&lt;/p&gt;
&lt;p&gt;Otter在解决数据一致性问题时（同一行记录多地修改），有两种方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;事前控制：比如paoxs协议，在多地数据写入各自数据存储之前，就已经决定好最后保留哪条记录&lt;/li&gt;
&lt;li&gt;事后补救：指A/B两地修改的数据，已经保存到数据库之后，通过数据同步后保证两数据的一致性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;两种方式都是数据最终一致性的保证，具体内容可以参考：&lt;a href=&quot;https://github.com/alibaba/otter/wiki/Otter%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7&quot;&gt;Otter数据一致性解决方案&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;未完待续...&lt;/h3&gt;
&lt;p&gt;QCon3天，还有挺多想和大家分享的，所以还有下篇，包含《PhxQueue——微信开源高可用强一致分布式队列的设计与实现》、《Heron的Exactly-Once实现》几个议题的分享感受。&lt;/p&gt;
&lt;p&gt;欢迎关注公众号交流。&lt;/p&gt;
&lt;p&gt;2017QCon上海站PPT下载：&lt;a href=&quot;http://ppt.geekbang.org/qconsh2017&quot;&gt;PPT&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/471426/201710/471426-20171023100232144-806414004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 02:03:00 +0000</pubDate>
<dc:creator>杭州.Mark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hzmark/p/2017qcon.html</dc:identifier>
</item>
<item>
<title>[译]ASP.NET Core 2.0 带初始参数的中间件 - 三生石上(FineUI控件)</title>
<link>http://www.cnblogs.com/sanshi/p/7708264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanshi/p/7708264.html</guid>
<description>&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;如何在ASP.NET Core 2.0向中间件传入初始参数？&lt;/p&gt;
&lt;h2&gt;答案&lt;/h2&gt;
&lt;p&gt;在一个空项目中，创建一个POCO（Plain Old CLR Object）来保存中间件所需的参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreetingOptions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GreetAt { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GreetTo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加一个中间件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreetingMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; GreetingOptions _options;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GreetingMiddleware(RequestDelegate next, GreetingOptions options)
    {
        _next &lt;/span&gt;=&lt;span&gt; next;
        _options &lt;/span&gt;=&lt;span&gt; options;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(HttpContext context)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; message = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Good {_options.GreetAt} {_options.GreetTo}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.Response.WriteAsync(message);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;答案1：实例类型&lt;/h3&gt;
&lt;p&gt;添加一个扩展方法来配置中间件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseGreetingMiddleware(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IApplicationBuilder app, GreetingOptions options)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; app.UseMiddleware&amp;lt;GreetingMiddleware&amp;gt;&lt;span&gt;(options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用中间件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseGreetingMiddleware(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetingOptions {
        GreetAt &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Morning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        GreetTo &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tahir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;答案2：函数类型&lt;/h3&gt;
&lt;p&gt;添加一个扩展方法来配置中间件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseGreetingMiddlewareAction(&lt;span&gt;this&lt;/span&gt; IApplicationBuilder app, Action&amp;lt;GreetingOptions&amp;gt;&lt;span&gt; optionsAction)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetingOptions();
    optionsAction(options);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; app.UseMiddleware&amp;lt;GreetingMiddleware&amp;gt;&lt;span&gt;(options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用中间件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseGreetingMiddlewareAction(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        options.GreetAt &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Morning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        options.GreetTo &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tahir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述两种方法结果一致。&lt;/p&gt;
&lt;p&gt;运行，此时页面显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/48817/201710/48817-20171022110539193-1494190457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;讨论&lt;/h2&gt;
&lt;p&gt;之前我们曾讨论过，在单独的类中定义中间件并使用扩展方法将其添加到请求管道中是最佳实践。我们也可能需要向中间件传入参数，通过对ASP.NET Core源代码以及其他在线示例的学习，我总结出来上面两种模式。&lt;/p&gt;
&lt;p&gt;上述的两种解决方法都非常直观。我们将参数封装到一个POCO类中，然后创建一个扩展方法来接受下面的参数：&lt;/p&gt;
&lt;p&gt;1. POCO实例&lt;/p&gt;
&lt;p&gt;2. 需要调用的函数（在函数内设置POCO）&lt;/p&gt;
&lt;p&gt;注：POCO实例通过构造函数传入中间件。UseMiddleware()方法接收可变参数params object[]，并将这些参数传入中间件构造函数。&lt;/p&gt;
&lt;h3&gt;配置服务&lt;/h3&gt;
&lt;p&gt;这些模式也能用于向服务容器中添加服务实例。为了便于说明，我们先添加一个服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IMessageService
{
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; FormatMessage(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; message);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MessageService : IMessageService
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; GreetingOptions _options;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MessageService(GreetingOptions options)
    {
        _options &lt;/span&gt;=&lt;span&gt; options;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FormatMessage(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; message)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Good {_options.GreetAt} {_options.GreetTo} - {message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加如下任一个扩展方法来配置服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddMessageService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, GreetingOptions options)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; services.AddScoped&amp;lt;IMessageService&amp;gt;(factory =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageService(options));
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddMessageServiceAction(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;GreetingOptions&amp;gt;&lt;span&gt; optionsAction)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetingOptions();
    optionsAction(options);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; services.AddScoped&amp;lt;IMessageService&amp;gt;(factory =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageService(options));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Configure()中使用此服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    services.AddMessageService(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetingOptions
    {
        GreetAt &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Morning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        GreetTo &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tahir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    });

    services.AddMessageServiceAction(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        options.GreetAt &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Morning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        options.GreetTo &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tahir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为ConfigureServices()先于Configure()执行，因此我们可以直接在Configure()注入此服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env, IMessageService msg)
{
    app.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; (context) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(msg.FormatMessage(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;by sanshi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行，此时页面显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/48817/201710/48817-20171022112212896-1632560946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;原文：&lt;a href=&quot;https://tahirnaushad.com/2017/08/29/passing-parameters-to-middleware-in-asp-net-core-2-0/&quot; target=&quot;_blank&quot;&gt;https://tahirnaushad.com/2017/08/29/passing-parameters-to-middleware-in-asp-net-core-2-0/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 01:29:00 +0000</pubDate>
<dc:creator>三生石上(FineUI控件)</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanshi/p/7708264.html</dc:identifier>
</item>
<item>
<title>学习一门新语言需要了解的基础-07 进程内存模型 - 李永京</title>
<link>http://www.cnblogs.com/lyj/p/foundation_07_processmemory_free.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyj/p/foundation_07_processmemory_free.html</guid>
<description>&lt;p&gt;本节内容&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可执行文件和进程的差异&lt;/li&gt;
&lt;li&gt;进程内存模型&lt;/li&gt;
&lt;li&gt;使用readelf -l查看段映射&lt;/li&gt;
&lt;li&gt;使用gdb查看运行期内存模型[付费阅读]&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;可执行文件和进程的差异&quot;&gt;可执行文件和进程的差异&lt;/h2&gt;
&lt;p&gt;一个普通的程序编译完了以后，程序还没有运行就提供了虚拟内存地址空间，这个虚拟地址就已经有了。回过头来想一想这个事情，就会发觉虚拟地址的好处。&lt;/p&gt;
&lt;p&gt;程序需要载入到内存中才能执行，既然每个程序都有一套完整的虚拟地址，那么在编译的时候就可以确定下来地址作用，比如某块地址用于映射程序可执行文件空间，运行期的堆、栈在别的地方分配。那么也就意味着编译时候可以确定执行时候放在哪，因为虚拟地址是我私有的，所以在编译时候就可以预先安排好虚拟地址。那么这就有很多好处，比如说.text段可以提前安排好了，起始地址加上偏移量就是函数在运行期的内存地址，编译汇编指令的时候就可以把地址写到汇编指令里面，编译时候就可以做这件事，所有的代码合并到.text段里面，既然这个地址已经确定下来了，里面有个函数指令，起始地址加上偏移量就是就等于这个函数的指针地址，这个地址就变成类似常量值。那调用这个函数时候直接call这个常量值就可以了，编译时候就能确定这个事情，这就是虚拟地址带来的好处。你如果是物理地址的话就麻烦了，因为物理地址你根本不知道你最终运行时候会挂在哪个地方，所以没有办法在编译时候把地址就确定下来但是虚拟地址可以因为虚拟地址是完整的一套独有的。所以我们在编译时地址都可以确定下来。这样在编译期通过虚拟地址就可以确定很多东西。&lt;/p&gt;
&lt;h2 id=&quot;进程内存模型&quot;&gt;进程内存模型&lt;/h2&gt;
&lt;p&gt;接下来搞清楚可执行文件究竟怎么样映射到内存里面去。&lt;/p&gt;
&lt;p&gt;我们可以看到可执行文件内部有很多段，但是不是所有的段都会载入内存里面去，有些数据只是存下来在调试时候用，但是程序执行时候不需要这些数据，那我没必要把它放到内存里面去。&lt;/p&gt;
&lt;p&gt;首先可执行文件内部有很多段，运行时候也有很多段，这两个地方的确有相似的地方，但也有不一样的地方。它可能把可执行文件某些东西映射到运行时候里面，比如说可执行文件中.text段映射到运行时某段中，当我们读取数据的时候，假如数据没有载入，引发缺页异常，然后就会把可执行文件.text段数据换入到内存里，这样的话我们就可以读到指令。也就是说可执行文件和进程之间是有映射关系的，这个映射关系并不是一一对应的。在可执行文件有些数据段在运行时是不需要的，还有些段需要合并。&lt;/p&gt;
&lt;p&gt;进程内存模型也是把地址空间分为一个一个段，这些段在初始化状态下的时候，它会和可执行文件中某些段建立映射关系，当我们读这些信息时，如果没有载入物理内存，会引发缺页异常，然后从可执行文件里把这些数据交换到物理内存里面，接下来就可以读到。因为我们从这里面读取的数据基本上分为两种状态，一种是只读的，另外一种运行期写的，运行期写的不要求写回去，只读的比如像指令肯定不能换出的，因为没有必要换出，因为需要把它干掉重新换入就可以了。&lt;/p&gt;
&lt;h2 id=&quot;使用readelf--l查看段映射&quot;&gt;使用readelf -l查看段映射&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;readelf&lt;/span&gt; -l test&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是程序运行时进程初始化时分配好的段，这个才是程序执行时候需要创建的段，下面有个映射表是可执行文件和进程模型的映射关系。&lt;br/&gt;上面所有的段除了内存地址结束地址大小以外还有运行期标记位，例如RW代表可读写。例如下面.data .bss段被映射到3段，3段LOAD的标记位是RW。.text段映射到2段，2段LOAD标记位是R E只读可执行。也就是说这两种存在一定的映射关系。操作系统载入器通过这个表来确定哪些东西怎么样去映射。读数据时候怎么去读。然后确定虚拟地址空间的起止地址在哪。这样就确定了映射关系当我们去读内存的时候如果这数据没有载入到物理内存，那么就引发缺页异常，把这些数据从可执行文件里面读出来。&lt;/p&gt;
&lt;h2 id=&quot;使用gdb查看运行期内存模型付费阅读&quot;&gt;使用gdb查看运行期内存模型[付费阅读]&lt;/h2&gt;
&lt;p&gt;这个系列的每篇文章有大半篇幅内容属于付费阅读。提供&lt;a href=&quot;http://www.cnblogs.com/lyj/gallery/image/194720.html&quot;&gt;微信支付&lt;/a&gt;或&lt;a href=&quot;http://www.cnblogs.com/lyj/gallery/image/194720.html&quot;&gt;支付宝支付&lt;/a&gt;打赏50元备注留言手动提供付费文章访问密码。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 01:15:00 +0000</pubDate>
<dc:creator>李永京</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyj/p/foundation_07_processmemory_free.html</dc:identifier>
</item>
<item>
<title>读Zepto源码之Form模块 - 对角另一面</title>
<link>http://www.cnblogs.com/hefty/p/7714478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hefty/p/7714478.html</guid>
<description>&lt;p&gt;&lt;code&gt;Form&lt;/code&gt; 模块处理的是表单提交。表单提交包含两部分，一部分是格式化表单数据，另一部分是触发 &lt;code&gt;submit&lt;/code&gt; 事件，提交表单。&lt;/p&gt;
&lt;p&gt;读 Zepto 源码系列文章已经放到了github上，欢迎star: &lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto&quot;&gt;reading-zepto&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;源码版本&quot;&gt;源码版本&lt;/h2&gt;
&lt;p&gt;本文阅读的源码为 &lt;a href=&quot;https://github.com/madrobby/zepto/tree/v1.2.0&quot;&gt;zepto1.2.0&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;gitbook&quot;&gt;GitBook&lt;/h2&gt;
&lt;p&gt;《&lt;a href=&quot;https://yeyuqiudeng.gitbooks.io/reading-zepto/content/&quot;&gt;reading-zepto&lt;/a&gt;》&lt;/p&gt;
&lt;h2 id=&quot;serializearray&quot;&gt;.serializeArray()&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;serializeArray&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; type&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      add &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;value&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;) &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;value&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(add)
        &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; value &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]) &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;each&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].&lt;span class=&quot;at&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(_&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; field)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    type &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;field&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;field&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (name &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;field&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;nodeName&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toLowerCase&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'fieldset'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;field&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;disabled&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'submit'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'reset'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'button'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'file'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        ((type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'radio'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'checkbox'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;field&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;checked&lt;/span&gt;))
      &lt;span class=&quot;at&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(field).&lt;span class=&quot;at&quot;&gt;val&lt;/span&gt;())
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; result
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;serializeArray&lt;/code&gt; 是格式化部分的核心方法，后面的 &lt;code&gt;serialize&lt;/code&gt; 方法内部调用的也是 &lt;code&gt;serializeArray&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;serializeArray&lt;/code&gt; 最终返回的结果是一个数组，每个数组项为包含 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 属性的对象。其中 &lt;code&gt;name&lt;/code&gt; 为表单元素的 &lt;code&gt;name&lt;/code&gt; 属性值。&lt;/p&gt;
&lt;h3 id=&quot;add函数&quot;&gt;add函数&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;add &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;value&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;) &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;value&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(add)
  &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; value &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表单的值交由 &lt;code&gt;add&lt;/code&gt; 函数处理，如果值为数组（支持 &lt;code&gt;forEach&lt;/code&gt; ） 方法，则调用 &lt;code&gt;forEach&lt;/code&gt; 遍历，继续由 &lt;code&gt;add&lt;/code&gt; 函数处理。否则将结果存入数组 &lt;code&gt;result&lt;/code&gt; 中。最后返回的结果也是这个 &lt;code&gt;result&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;遍历表单元素&quot;&gt;遍历表单元素&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]) &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;each&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].&lt;span class=&quot;at&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(_&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; field)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  type &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;field&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;field&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (name &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;field&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;nodeName&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toLowerCase&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'fieldset'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;field&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;disabled&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'submit'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'reset'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'button'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'file'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
      ((type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'radio'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; type &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'checkbox'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;field&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;checked&lt;/span&gt;))
    &lt;span class=&quot;at&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(field).&lt;span class=&quot;at&quot;&gt;val&lt;/span&gt;())
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果集合中有多个表单，则只处理第一个表单的表单元素。&lt;code&gt;this[0].elements&lt;/code&gt; 用来获取第一个表单所有的表单元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 为表单类型，&lt;code&gt;name&lt;/code&gt; 为表单元素的 &lt;code&gt;name&lt;/code&gt; 属性值。&lt;/p&gt;
&lt;p&gt;这一大段代码的关键在 &lt;code&gt;if&lt;/code&gt; 中的条件判断，其实是将一些无关的表单元素排除，只处理符合条件的表单元素。&lt;/p&gt;
&lt;p&gt;以下一个条件一个条件来分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;field.nodeName.toLowerCase() != 'fieldset'&lt;/code&gt; 排除 &lt;code&gt;fieldset&lt;/code&gt; 元素；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!field.disabled&lt;/code&gt; 排除禁用的表单，已经禁用了，肯定是没有值需要提交的了；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type != 'submit'&lt;/code&gt; 排除确定按钮；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type != 'reset'&lt;/code&gt; 排除重置按钮；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type != 'button'&lt;/code&gt; 排除按钮；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type != 'file'&lt;/code&gt; 排除文件选择控件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;((type != 'radio' &amp;amp;&amp;amp; type != 'checkbox') || field.checked))&lt;/code&gt; 如果是 &lt;code&gt;radio&lt;/code&gt; 或 &lt;code&gt;checkbox&lt;/code&gt; 时，则必须要选中，这个也很好理解，如果没有选中，也不会有值需要处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后调用 &lt;code&gt;add&lt;/code&gt; 方法，将表单元素的值获取到交由其处理。&lt;/p&gt;
&lt;h2 id=&quot;serialize&quot;&gt;.serialize()&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;serialize&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;serializeArray&lt;/span&gt;().&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(elm)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;encodeURIComponent&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;elm&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'='&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;encodeURIComponent&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;elm&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;))
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&amp;amp;'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表单元素处理完成后，最终是要拼成如 &lt;code&gt;name1=value1&amp;amp;name2=value2&amp;amp;...&lt;/code&gt; 的形式，&lt;code&gt;serialize&lt;/code&gt; 方法要做的就是这部分事情。&lt;/p&gt;
&lt;p&gt;这里对 &lt;code&gt;serizlizeArray&lt;/code&gt; 返回的数组再做进一步的处理，首先用 &lt;code&gt;encodeURIComponent&lt;/code&gt; 序列化 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 的值，并用 &lt;code&gt;=&lt;/code&gt; 号拼接成字符串，存进新的数组中，最后调用 &lt;code&gt;join&lt;/code&gt; 方法，用 &lt;code&gt;&amp;amp;&lt;/code&gt; 将各项拼接起来。&lt;/p&gt;
&lt;h2 id=&quot;submit&quot;&gt;.submit()&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;submit&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(callback) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; arguments) &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'submit'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; callback)
  &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; event &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Event&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'submit'&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;eq&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;trigger&lt;/span&gt;(event)
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isDefaultPrevented&lt;/span&gt;()) &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;submit&lt;/span&gt;()
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;处理完数据，接下来该到提交了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; arguments) &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'submit'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; callback)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有传递回调函数 &lt;code&gt;callback&lt;/code&gt; ，则在表单上绑定 &lt;code&gt;submit&lt;/code&gt; 事件，以 &lt;code&gt;callback&lt;/code&gt; 作为事件的回调。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; event &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Event&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'submit'&lt;/span&gt;)
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;eq&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;trigger&lt;/span&gt;(event)
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isDefaultPrevented&lt;/span&gt;()) &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;submit&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;否则手动绑定 &lt;code&gt;submit&lt;/code&gt; 事件，如果没有阻止浏览器的默认事件，则在第一个表单上触发 &lt;code&gt;submit&lt;/code&gt; ，提交表单。&lt;/p&gt;
&lt;p&gt;注意 &lt;code&gt;eq&lt;/code&gt; 和 &lt;code&gt;get&lt;/code&gt; 的区别， &lt;code&gt;eq&lt;/code&gt; 返回的是 &lt;code&gt;Zepto&lt;/code&gt; 对象，而 &lt;code&gt;get&lt;/code&gt; 返回的是 &lt;code&gt;DOM&lt;/code&gt; 元素。&lt;/p&gt;
&lt;h2 id=&quot;系列文章&quot;&gt;系列文章&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84.md&quot;&gt;读Zepto源码之代码结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95.md&quot;&gt;读Zepto源码之内部方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0.md&quot;&gt;读Zepto源码之工具函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E7%A5%9E%E5%A5%87%E7%9A%84%24.md&quot;&gt;读Zepto源码之神奇的$&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C.md&quot;&gt;读Zepto源码之集合操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E6%9F%A5%E6%89%BE.md&quot;&gt;读Zepto源码之集合元素查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E6%93%8D%E4%BD%9CDOM.md&quot;&gt;读Zepto源码之操作DOM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C.md&quot;&gt;读Zepto源码之样式操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8B%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C.md&quot;&gt;读Zepto源码之属性操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BEvent%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之Event模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BIE%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之IE模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BCallbacks%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之Callbacks模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BDeferred%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之Deferred模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BAjax%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之Ajax模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8Bassets%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之Assets模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BSelector%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之Selector模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BTouch%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之Touch模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BGesture%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之Gesture模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BIOS3%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之IOS3模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BFx%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之Fx模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8Bfx_methods%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之fx_methods模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yeyuqiudeng/reading-zepto/blob/master/src/%E8%AF%BBZepto%E6%BA%90%E7%A0%81%E4%B9%8BStack%E6%A8%A1%E5%9D%97.md&quot;&gt;读Zepto源码之Stack模块&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;附文&quot;&gt;附文&lt;/h3&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：对角另一面&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 01:09:00 +0000</pubDate>
<dc:creator>对角另一面</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hefty/p/7714478.html</dc:identifier>
</item>
</channel>
</rss>