<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[数据分析工具] Pandas 功能介绍（一） - CodingStar</title>
<link>http://www.cnblogs.com/BoyceYang/p/8338378.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BoyceYang/p/8338378.html</guid>
<description>&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;3ent4-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;3ent4-0-0&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;span data-offset-key=&quot;3ent4-0-0&quot;&gt;如果你在使用 Pandas（Python Data Analysis Library） 的话，下面介绍的对你一定会有帮助的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;221vv-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;221vv-0-0&quot;&gt;首先我们先介绍一些简单的概念&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;2u0cb-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2u0cb-0-0&quot;&gt;Read_csv 方法有很多参数，有效的利用这些参数可以减轻数据预处理的工作。谁都不愿意做数据清洗，那么我们就在加载数据的时候做一些简单的数据处理&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;5sa3d-0-0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;5sa3d-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5sa3d-0-0&quot;&gt;直接加载&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;bpvul-0-0&quot;&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span data-offset-key=&quot;bpvul-0-0&quot;&gt;无参数加载&lt;/span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/80/v2-af3f6fe032d74b7cc3cec985baabf524_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;382&quot; data-rawheight=&quot;108&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180123234102678-1249299757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;daitf-0-0&quot;&gt;&lt;li&gt;
&lt;ul&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth1 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;daitf-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;daitf-0-0&quot;&gt;&lt;span data-offset-key=&quot;daitf-0-0&quot;&gt;选择特定列加载&lt;/span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/80/v2-3f04693ea70b6cd35d8b5d46fc1811e5_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;602&quot; data-rawheight=&quot;230&quot;/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180123234150084-1539381725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;d8tib-0-0&quot;&gt;&lt;li&gt;
&lt;ul&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth1 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;d8tib-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;d8tib-0-0&quot;&gt;时间转换加载&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth1 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;d8tib-0-0&quot;&gt;&lt;span data-offset-key=&quot;d8tib-0-0&quot;&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180123234250225-2091244664.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;d8tib-0-0&quot;&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-d8724006f7b2b02ed13d0e6427113904_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;664&quot; data-rawheight=&quot;162&quot;/&gt;&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;10cbp-0-0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;10cbp-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;10cbp-0-0&quot;&gt;分批加载&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-a7815db54fd8e1b6fadf8d525c9322b8_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;820&quot; data-rawheight=&quot;364&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;fer4v-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fer4v-0-0&quot;&gt;　　　　有时我们可能需要加载的 csv 太大，可能会导致内存爆掉，这时候，我们就需要分批加载数据进行分析、处理&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;fer4v-0-0&quot;&gt;&lt;span data-offset-key=&quot;fer4v-0-0&quot;&gt;&lt;span data-offset-key=&quot;fer4v-0-0&quot;&gt;　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180123234326615-1156850023.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;2o9co-0-0&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;2o9co-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2o9co-0-0&quot;&gt;df.head(n)：浏览数据的前 n 行，默认 5 行&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;dps1q-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dps1q-0-0&quot;&gt;df.tail(n)：浏览数据的末尾 n 行，默认 5 行&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;c7mr2-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c7mr2-0-0&quot;&gt;df.sample(n)：随机浏览 n 行数据，默认 5 行&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;5foub-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5foub-0-0&quot;&gt;df.shape：tuple 类型的数据行列数，（行数，列数）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;8l29r-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8l29r-0-0&quot;&gt;df.describe()：计算评估数据的趋势&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;f30jm-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f30jm-0-0&quot;&gt;df.info()：内存和数据类型&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;48uit-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;48uit-0-0&quot;&gt;在 DataFrame 中添加新列的操作很简单，下面介绍几种方式&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;3kuk-0-0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;3kuk-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3kuk-0-0&quot;&gt;简单方式&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span data-offset-key=&quot;218s0-0-0&quot;&gt;　　　　直接增加新列并赋值&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6rknc-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6rknc-0-0&quot;&gt;　　　　df['new_column'] = 1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;3kuk-0-0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth1 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;907co-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;907co-0-0&quot;&gt;计算方式&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span data-offset-key=&quot;12tjk-0-0&quot;&gt;　　　　df['temp_diff'] = df['atemp'] - df['temp']&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;3kuk-0-0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;2jgs0-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2jgs0-0-0&quot;&gt;条件方式&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span data-offset-key=&quot;enf44-0-0&quot;&gt;　　　　我们仅仅根据风速，简单判断一下人体舒适度，体感比较舒服的温度是 0.3 米/秒&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;enf44-0-0&quot;&gt;&lt;span data-offset-key=&quot;enf44-0-0&quot;&gt;&lt;span data-offset-key=&quot;enf44-0-0&quot;&gt;　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180123234426240-414286627.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-6e622a88b6e16c0cb61251c87828de59_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;914&quot; data-rawheight=&quot;254&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;5iubj-0-0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;5iubj-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5iubj-0-0&quot;&gt;循环方式&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span data-offset-key=&quot;8r0pd-0-0&quot;&gt;　　　　我们将 season 转换为具体季节的名称&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;8r0pd-0-0&quot;&gt;　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180123234501600-1070835308.png&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-294f0ef0360cfe82c939b03e5b20e789_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;774&quot; data-rawheight=&quot;470&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;e55um-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;e55um-0-0&quot;&gt;类似于 Excel 单元格的选择，Pandas 提供了这样的功能，操作很简单，但是我本人理解起来确实没有操作看上去那么简单。Pandas 提供了三个方法做类似的操作，loc，iloc，ix，ix 官方已经不建议使用，所以我们下面介绍 loc 和 iloc&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8k0sl-0-0&quot;&gt;　　　　&lt;/span&gt;&lt;span data-offset-key=&quot;dnp8n-0-0&quot;&gt;df.loc[行索引开始位置：行索引结束位置,[列名数组]]&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;8k0sl-0-0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;b15sa-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;b15sa-0-0&quot;&gt;iloc 根据索引选取&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span data-offset-key=&quot;c8bg3-0-0&quot;&gt;　　　　df.iloc[行索引开始位置：行索引结束位置,列索开始位置：列索引结束位置]&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth1 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;fmpin-0-0&quot;&gt;&lt;span data-offset-key=&quot;fmpin-0-0&quot;&gt;　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180124000638756-208279970.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-a15537e7e2a77a107a54768fbfa1fbeb_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;672&quot; data-rawheight=&quot;154&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;4o3f5-0-0&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;4o3f5-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4o3f5-0-0&quot;&gt;索引开始位置：闭区间&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;9ca9o-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9ca9o-0-0&quot;&gt;索引结束位置：开区间&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;a7jhb-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;a7jhb-0-0&quot;&gt;loc 和 iloc 选取整列数据的时候，看上去与 df[列名数组] 的方式一致，但是其实前者返回的仍然是 DataFrame，后者返回的是 Series&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;3k664&quot; data-offset-key=&quot;a7jhb-0-0&quot;&gt;&lt;span data-offset-key=&quot;a7jhb-0-0&quot;&gt;　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180124000709709-863445168.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-4f386dec555153330096eb2b1bb01b23_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;430&quot; data-rawheight=&quot;320&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Tue, 23 Jan 2018 23:30:00 +0000</pubDate>
<dc:creator>CodingStar</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BoyceYang/p/8338378.html</dc:identifier>
</item>
<item>
<title>HTML5 Canvas 数据持久化存储之属性列表 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/8323781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/8323781.html</guid>
<description>&lt;p&gt;属性列表想必大家都不会陌生，正常用 HTML5 来做的属性列表大概就是用下拉菜单之类的，而且很多情况下，下拉列表还不够好看，怎么办？我试着用 &lt;a href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT for Web&lt;/a&gt; 来实现属性栏点击按钮弹出多功能选框，对传入的数据进行选择的功能，感觉整体实践起来还是比较简单方便的，所以在这边跟大家分享一下。 &lt;/p&gt;
&lt;p&gt;本例链接： &lt;a href=&quot;http://www.hightopo.com/demo/propertyEditor/index.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/demo/propertyEditor/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本例效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201801/591709-20180123220335412-2025563077.png&quot; alt=&quot;&quot; width=&quot;1129&quot; height=&quot;651&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的效果图中我们可以看到，整个页面分为 3 个部分，左边的 &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/beginners/ht-beginners-guide.html#ref_graphview&quot; target=&quot;_blank&quot;&gt;graphView&lt;/a&gt; 拓扑图部分，右下角的 &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/tableview/ht-tableview-guide.html&quot; target=&quot;_blank&quot;&gt;tableView&lt;/a&gt; 表格部分，以及右上角的 &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/propertyview/ht-propertyview-guide.html&quot; target=&quot;_blank&quot;&gt;propertyView&lt;/a&gt; 属性部分。我们先把整个场景划分出来，然后再向各个部分来添加具体的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
gv = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.graph.GraphView();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tablePane = &lt;span&gt;new&lt;/span&gt; ht.widget.TablePane(gv.dm());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表格面板组件&lt;/span&gt;
propertyView = &lt;span&gt;new&lt;/span&gt; ht.widget.PropertyView(gv.dm());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;formPane是在propertyView里的，所以要先定义&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; rightView = &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(propertyView, tablePane, 'v', 0.4);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割组件，v分为上下层，比例为0.4:0.6&lt;/span&gt;
rightView.getView().style.borderLeft = '1px solid #000'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; borderPane = &lt;span&gt;new&lt;/span&gt; ht.widget.BorderPane();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;边框面板组件&lt;/span&gt;
borderPane.setRightView(rightView, 400);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 borderPane 右边组件为 rightView，宽度为400&lt;/span&gt;
borderPane.setCenterView(gv);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 borderPane 中间组件为 gv &lt;/span&gt;
borderPane.addToDOM();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将 borderPane 组件添加进 body 中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中 new 出来的部分都是 HT 封装好的组件，相当于“类”，这里解释一下 &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/splitview/ht-splitview-guide.html&quot; target=&quot;_blank&quot;&gt;SplitView&lt;/a&gt; 分割组件，分割组件用于左右或上下分割两个子组件， 子组件可为 HT 框架提供的组件，也可为 HTML 的原生组件，子组件以 position 为 absolute 方式进行绝对定位，这个组件中的参数分别为（左组件或上组件， 右组件或下组件，h 表示左右分割 v 表示上下分割，分割位置默认值为 0.5，如果设置值为 0~1 则按百分比分割，大于 1 代表左组件或上组件的绝对宽或高，小于 1 代表右组件或下组件的绝对宽或高）；还有 &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/borderpane/ht-borderpane-guide.html&quot; target=&quot;_blank&quot;&gt;BorderPane&lt;/a&gt; 面板组件为布局容器，可在上、下、左、右、中的五个区域位置摆放子组件， 子组件可为 HT 框架提供的组件，也可为 HTML 原生组件，子组件以 position 为 absolute 方式进行绝对定位。这里我结合了 SplitView 和 BorderPane 将场景分成了三个部分。最后记得一定要将最终的布局容器添加进 body 中或者任意一个 HTML 标签中，这样才能在界面上显示，其中 addToDOM 的定义内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
addToDOM = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){   
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
        view &lt;/span&gt;= self.getView(), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取这个组件的底层 div &lt;/span&gt;
        style = view.style;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取底层 div 的样式 style 属性&lt;/span&gt;
    document.body.appendChild(view); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将底层 div 添加进 body 中&lt;/span&gt;
    style.left = '0';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HT 默认将组件都定义为决定定位 absolute，所以需要设置位置&lt;/span&gt;
    style.right = '0'&lt;span&gt;;
    style.top &lt;/span&gt;= '0'&lt;span&gt;;
    style.bottom &lt;/span&gt;= '0'&lt;span&gt;;      
    window.addEventListener(&lt;/span&gt;'resize', &lt;span&gt;function&lt;/span&gt; () { self.iv(); }, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);            
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HT 的组件一般都会嵌入 BorderPane、SplitView 和 TabView 等容器中使用，而最外层的 HT 组件则需要用户手工将 getView() 返回的底层 div 元素添加到页面的 DOM 元素中，这里需要注意的是，当父容器大小变化时，如果父容器是 BorderPane 和 SplitView 等这些 HT 预定义的容器组件，则 HT 的容器会自动递归调用孩子组件 invalidate 函数通知更新。但如果父容器是原生的 html 元素， 则 HT 组件无法获知需要更新，因此最外层的 HT 组件一般需要监听 window 的窗口大小变化事件，调用最外层组件 invalidate 函数进行更新。&lt;/p&gt;
&lt;p&gt;场景创建完毕。为了显示不同节点对应的属性的不同，我们在拓扑图上添加了七个节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initModel(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = &quot;设备&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = createNode(name + count++, name + (++count));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数1为name，参数2为tag&lt;/span&gt;
    root.setImage('./symbols/机房/服务器.json'&lt;span&gt;);
    root.setName(&lt;/span&gt;'服务器'&lt;span&gt;);
    root.s(&lt;/span&gt;'label.position', 3&lt;span&gt;);
    gv.sm().ss(root);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认选中root节点&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 2; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iNode = createNode(name + count++, name + (++count));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数1为name，参数2为tag&lt;/span&gt;
&lt;span&gt;        createEdge(root, iNode);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; 2; j++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jNode = createNode(name + count++, name + (++&lt;span&gt;count));
            createEdge(iNode, jNode);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;createNode 函数的声明如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; createNode(name, tag){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Node节点&lt;/span&gt;
    flag++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Node();
    node.setName(name);
    node.setTag(tag);
    node.setImage(&lt;/span&gt;'./symbols/机房/XX分系统.json'&lt;span&gt;);
    node.a(&lt;/span&gt;'hidden', &lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义属性，可以控制node.a('hidden')来控制节点显隐&lt;/span&gt;
&lt;span&gt;
    node.a(&lt;/span&gt;'接口类型', 'SATA'&lt;span&gt;);
    node.a(&lt;/span&gt;'显卡', 'Nvidia'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag % 2 === 0&lt;span&gt;){
        node.a(&lt;/span&gt;'接口类型', 'IDE'&lt;span&gt;);
        node.a(&lt;/span&gt;'显卡', 'ATI'&lt;span&gt;);
    }
    node.s(&lt;/span&gt;'label.position', 11&lt;span&gt;);
    gv.dm().add(node);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将节点添加进数据容器DataModel中&lt;/span&gt;
&lt;span&gt;
    node.tablePane1 &lt;/span&gt;= createTableView(serviceType, dataModel1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建表格面板&lt;/span&gt;
    node.tablePane2 =&lt;span&gt; createTableView(serviceSize, dataModel2);
    node.tablePane3 &lt;/span&gt;=&lt;span&gt; createTableView(version, dataModel3);

    node.formPane1 &lt;/span&gt;= createFormPane(node.tablePane1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建表单面板&lt;/span&gt;
    node.formPane1.title = '类型';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了给后面dialog对话框的标题做准备&lt;/span&gt;
    node.formPane2 =&lt;span&gt; createFormPane(node.tablePane2);
    node.formPane2.title &lt;/span&gt;= '内存'&lt;span&gt;;
    node.formPane3 &lt;/span&gt;=&lt;span&gt; createFormPane(node.tablePane3);
    node.formPane3.title &lt;/span&gt;= '型号'&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag % 3 === 0&lt;span&gt;){
        node.formPane3.v(&lt;/span&gt;'tag', '联想（Lenovo）服务器X3650M5 8871'&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        node.formPane3.v(&lt;/span&gt;'tag', 'Lenovo IBM X3250 5458I21'&lt;span&gt;);
    }
    node.a(&lt;/span&gt;'型号', node.formPane3.v('tag'&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们通过控制这个节点的 hidden 属性，利用 graphView 中的可视过滤器 setVisibleFunc 函数来控制节点的显隐：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
gv.setVisibleFunc(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data.a('hidden'&lt;span&gt;)){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了节点自然就需要显示属性了，加上下面的 tablePane 表格面板中的值，一共添加了七种属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; createProperty(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建属性&lt;/span&gt;
&lt;span&gt;    propertyView.addProperties([
        {
            name: &lt;/span&gt;'name',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 name 属性，结合 accessType 属性最终实现对节点属性的存取，accessType 默认值为 null，如name为age，采用getAge()和setAge(98)的get/set或is/set方式存取(这边name为name，所以通过 getName() 获取)&lt;/span&gt;
            displayName: '名称'&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置属性名的显示文本值&lt;/span&gt;
&lt;span&gt;        },
        {
            name: &lt;/span&gt;'hidden',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 hidden 属性&lt;/span&gt;
            displayName: '隐藏这个节点'&lt;span&gt;,
            accessType: &lt;/span&gt;'attr',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如name为hidden，采用getAttr('hidden')和setAttr('hidden', false)的方式存取&lt;/span&gt;
            icon: 'images/alert.gif',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置属性名左侧显示的图标&lt;/span&gt;
            valueType: 'boolean',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于提示组件提供合适的renderer渲染 布尔类型，显示为勾选框&lt;/span&gt;
            editable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置该属性是否可编辑&lt;/span&gt;
&lt;span&gt;        },
        {
            name: &lt;/span&gt;'grade'&lt;span&gt;,
            displayName: &lt;/span&gt;'类型'&lt;span&gt;,
            accessType: &lt;/span&gt;'attr'&lt;span&gt;,
            drawPropertyValue: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(g, property, value, rowIndex, x, y, w, h, data, view){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义属性值渲染函数&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; cb = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(v) {
                    data.a(&lt;/span&gt;'grade'&lt;span&gt;, v);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fillFormPane(data.formPane1, w, h, data.tablePane1, serviceType, cb);
            }
        },
        {
            name: &lt;/span&gt;'number'&lt;span&gt;,
            displayName: &lt;/span&gt;'内存'&lt;span&gt;,
            accessType: &lt;/span&gt;'attr'&lt;span&gt;,
            drawPropertyValue: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(g, property, value, rowIndex, x, y, w, h, data, view){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cb = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(v) {
                    data.a(&lt;/span&gt;'number'&lt;span&gt;, v);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fillFormPane(data.formPane2, w, h, data.tablePane2, serviceSize, cb);
            }
        },
        {
            name: &lt;/span&gt;'接口类型'&lt;span&gt;,
            accessType: &lt;/span&gt;'attr'&lt;span&gt;,
            displayName: &lt;/span&gt;'接口类型'&lt;span&gt;
        },
        {
            name: &lt;/span&gt;'显卡'&lt;span&gt;,
            accessType: &lt;/span&gt;'attr'&lt;span&gt;,
            displayName: &lt;/span&gt;'显卡'&lt;span&gt;
        },
        {
            name: &lt;/span&gt;'型号'&lt;span&gt;,
            accessType: &lt;/span&gt;'attr'&lt;span&gt;,
            displayName: &lt;/span&gt;'型号'&lt;span&gt;,
        }
    ]);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三第四个属性中 drawPropertyValue 属性的返回值为 fillFormPane 函数，这个函数的参数分别为（表单组件 formP，表单组件宽 w，表单组件高 h，表单组件中按钮点击生成弹出框中的表格组件 tableP，表格组件中的数组内容 arr，cb 函数将双击表格组件中的行返回的值赋值给 form 表单中的 ht.widget.TextField 文本框）。&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;17.5&quot;&gt; 第四个参数 tableP 表格组件，也没有什么特别的，就是创建一个表单组件，然后向表单组件中添加列，步骤简单，代码也相当简单：&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; createTableView(arr, dm){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建表格组件&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; tableView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.widget.TableView(dm);
    tableView.addColumns([&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用json的数组参数方式批量添加列信息&lt;/span&gt;
&lt;span&gt;        {
            displayName: &lt;/span&gt;'ID',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取表头的列名内容&lt;/span&gt;
            drawCell: &lt;span&gt;function&lt;/span&gt;(g, data, selected, column, x, y, w, h, tableView){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义单元格渲染方式&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; id = tableView.getRowIndex(data);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回data对象所在的行索引&lt;/span&gt;
                ht.Default.drawText(g, 'row' + (id + 1), &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, x, y, w, h, 'center');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制文字参数(g画笔对象，value文字内容，font文字字体，color文字颜色，x绘制开始的x坐标，y绘制开始的y坐标，w绘制的宽度，h绘制的高度，align文字水平对齐方式，vAlign文字垂直对齐方式)&lt;/span&gt;
&lt;span&gt;            }
        },
        {
            displayName: &lt;/span&gt;'Name'&lt;span&gt;,
            drawCell: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(g, data, selected, column, x, y, w, h, tableView){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id =&lt;span&gt; tableView.getRowIndex(data);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; info =&lt;span&gt; arr[id];
                ht.Default.drawText(g, info, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, x, y, w, h, 'center'&lt;span&gt;);
            }
        }
    ]);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tableView;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;解释完 fillFormPane 中的参数，来看看这个函数是如何定义的，基本上只差最后一步，点击 tablePane 表格组件中的元素，将这个元素返回给 formPane 表单组件中的 textField 文本框：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; fillFormPane(formP, w, h, tableP, arr, cb){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右边的formpane&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(formP ===&lt;span&gt; undefined){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    formP.setWidth(w);
    formP.setHeight(h);
    formP.setHGap(&lt;/span&gt;0&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(formP.v('tag') === 'undefined' || formP.v('tag') === ''&lt;span&gt;) {
        formP.v(&lt;/span&gt;'tag', arr[0&lt;span&gt;]);
    }

    tableP.onDataDoubleClicked &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(data){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表格组件中的data所在行被双击时回调&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; v = arr[data.a('index'&lt;span&gt;)];
        formP.v(&lt;/span&gt;'tag', v);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据id设置对应item元素值 为 setValue 的简写，这个id为tag的元素就是文本框&lt;/span&gt;
&lt;span&gt;        dialog.hide();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cb){cb(v);} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果传入了cb参数，则设置data.a('number')/data.a('helloName')的值为表格中被双击的那一行的值，即赋值给第三第四属性&lt;/span&gt;
&lt;span&gt;    }

    tableP.onDataClicked &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(data){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表格组件中的data所在行被单击时回调&lt;/span&gt;
        dialog.getConfig().buttons[1].action = &lt;span&gt;function&lt;/span&gt;(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击“确定”才进行下面的操作&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; v = arr[data.a('index'&lt;span&gt;)];
            formP.v(&lt;/span&gt;'tag'&lt;span&gt;, v);
            dialog.hide();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cb){cb(v);} 
        }
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; formP.getView();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;右上方属性栏的显示到这里就全部结束了，右下方的表格面板的创建方式也是雷同的，大家可以自行看代码理解。&lt;/p&gt;
&lt;p&gt;最后说一下整个界面节点的排布，HT 中的 autolayout 自动布局组件，即根据节点和连线关系，提供多种类型算法进行自动排布节点位置。 自动布局常用于图元较多，或连接关系教复杂时，不易于人工拖拽摆放的场景。我把各个布局方式通过按钮的方式呈现出来了，点击对应的按钮，布局方式就会根据按下的按钮设置的排布方式来自动布局：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201801/591709-20180123222957225-2038271260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 首先，创建一个新的实例，传入需要自动布局的对象，可以为 DataModel、graphView 以及 graph3dView 三种，然后设置默认的排布方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
autoLayout = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.layout.AutoLayout(gv);
setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    layout(&lt;/span&gt;'towardsouth', &lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为图片还没加载出来的时候，自动布局就按照节点的默认大小来布局的&lt;/span&gt;
}, 200);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着创建 formPane 表单面板，添加进 body 中，放在 body 左上角，我不将所有代码粘出来了，就显示第一个布局的按钮就好：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createDirectionForm(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; form = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.widget.FormPane();
    form.setWidth(&lt;/span&gt;200);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置表单宽度&lt;/span&gt;
    form.setHeight(80&lt;span&gt;);
    document.body.appendChild(form.getView());
    form.getView().style.background &lt;/span&gt;= '#fff'&lt;span&gt;;
    form.getView().style.boxShadow &lt;/span&gt;= '4px 16px 16px rgba(0, 0, 0, 0.1)';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置阴影样式&lt;/span&gt;
    form.addRow([&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一行单独拿出来，作为标题&lt;/span&gt;
&lt;span&gt;        {
            element: &lt;/span&gt;'自动布局:',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示的文字&lt;/span&gt;
&lt;span&gt;        }
    ], [&lt;/span&gt;0.1]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组内只有一个对象，就只设置一个对象的宽度就好&lt;/span&gt;
&lt;span&gt;    form.addRow([
        {
            button: {
                icon: &lt;/span&gt;'布局/南布局.json'&lt;span&gt;,
                onClicked: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    layout(&lt;/span&gt;'towardsouth', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                },
                background: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                labelColor: &lt;/span&gt;'#fff'&lt;span&gt;,
                groupId: &lt;/span&gt;'btn'&lt;span&gt;,
                toolTip: &lt;/span&gt;'朝南布局'&lt;span&gt;,
                borderColor: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
            }
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....接下来添加剩下的6个按钮&lt;/span&gt;
    ], [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组中有七个对象，就要设置七个对象的宽度&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; form;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比较有趣的部分就是这些啦，感谢大家的阅读，如果有些地方我解释的不够清楚，欢迎留言~或者去 &lt;a href=&quot;http://hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT for Web&lt;/a&gt; 官网多多学习~&lt;/p&gt;

</description>
<pubDate>Tue, 23 Jan 2018 22:49:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/8323781.html</dc:identifier>
</item>
<item>
<title>rexray在CentOS上不能创建ceph rbd的docker volume问题定位 - BookShu</title>
<link>http://www.cnblogs.com/styshoo/p/8339811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/styshoo/p/8339811.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;　　我们通过docker的rexray插件来创建ceph rbd设备的docker volume，但总提示创建失败。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# docker volume create --driver=rexray --opt=size=5 --name=cephrbd-book
Error response from daemon: create test_cephrbd_volume: VolumeDriver.Create: {&quot;Error&quot;:&quot;Failed to create new volume&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　OS版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# lsb_release -a
LSB Version:    :core-4.1-amd64:core-4.1-noarch
Distributor ID: CentOS
Description:    CentOS Linux release 7.4.1708 (Core) 
Release:        7.4.1708
Codename:       Core&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　Ceph版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ceph version
ceph version 0.94.5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　rexray版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# rexray version
REX-Ray
-------
Binary: /usr/bin/rexray
Flavor: client+agent+controller
SemVer: 0.9.0
OsArch: Linux-x86_64
Branch: (detached from 2a7458d
Commit: 2a7458dd90a79c673463e14094377baf9fc8695e
Formed: Wed, 26 Jul 2017 14:35:37 CST

libStorage
----------
SemVer: 0.6.0
OsArch: Linux-x86_64
Branch: (detached from fa055d6
Commit: fa055d6da595602715bdfd5541b4aa6d4dcbcbd9
Formed: Wed, 26 Jul 2017 14:35:11 CST&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;　　之前我们在ubuntu 16.04的环境中，也搭建过docker+ceph+rexray的环境，使用docker命令创建volume并没有报错。正常的流程是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 创建docker volume：rexray会使用rbd create命令创建一个rbd设备；
2. 使用该volume创建docker 容器：rexray会将rbd 设备map到docker host上成为一个/dev/rbd设备，再使用mount命令将/dev/rbd设备挂载到/var/lib/libstorage/volumes/目录，供容器使用；
3. 删除该容器时：先umount掉/dev/rbd设备在/var/lib/libstorage/volumes/目录的挂载，再rbd unmap掉rbd设备在docker host上的映射；
4. 删除docker volume：rexray会使用rbd rm命令删除该rbd设备；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　在我们的实际使用情况中，发现只有第一步会出错，后面的三步都并未出现任何异常。而且，如果我们不使用docker volume create命令创建rbd设备，而是直接使用“rbd create”命令来创建rbd设备，也并未出现任何错误，且该rbd设备也可以正常使用。这是很奇怪的一个地方。&lt;br/&gt;　　查看docker日志，也只是提示“Failed to create new volume”，并没有其他有用的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# journalctl -xu docker
...
Jan 22 10:45:13 dcos-agent2 dockerd[66886]: time=&quot;2018-01-22T10:45:13.937645601+08:00&quot; level=error msg=&quot;Handler for POST /v1.29/volumes/create returned error: create cephrbd-book: VolumeDri
ver.Create: {\&quot;Error\&quot;:\&quot;Failed to create new volume\&quot;}\n&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　既然docker中没有更有价值的日志，那么就尝试看下rexray的日志，这里需要打开rexray的debug选项(打开方法&lt;a href=&quot;https://github.com/thecodeteam/rexray/issues/769&quot;&gt;参考&lt;/a&gt;)，从而可以看到更多的日志。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# vim /var/log/rexray/rexray.log
...
time=&quot;2018-01-19T19:12:32+08:00&quot; level=info msg=&quot;    -------------------------- HTTP REQUEST (CLIENT) -------------------------&quot;
time=&quot;2018-01-19T19:12:32+08:00&quot; level=info msg=&quot;    GET /volumes/rbd?attachments=0 HTTP/1.1&quot;
time=&quot;2018-01-19T19:12:32+08:00&quot; level=info msg=&quot;    Host: libstorage-server&quot;
time=&quot;2018-01-19T19:12:32+08:00&quot; level=info msg=&quot;    Libstorage-Instanceid: rbd=109.105.115.73&quot;
time=&quot;2018-01-19T19:12:32+08:00&quot; level=info msg=&quot;    Libstorage-Localdevices: rbd=&quot;
time=&quot;2018-01-19T19:12:32+08:00&quot; level=info msg=&quot;    Libstorage-Tx: txID=b9fb044b-d47a-4ac5-7533-5824b8dc737a, txCR=1516360352&quot;
time=&quot;2018-01-19T19:12:32+08:00&quot; level=info msg=&quot;    &quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    -------------------------- HTTP RESPONSE (CLIENT) -------------------------&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    HTTP/1.1 200 OK&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Content-Length: 228&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Content-Type: application/json&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Date: Fri, 19 Jan 2018 11:12:33 GMT&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Libstorage-Servername: jade-chopper-ky&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    &quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    {&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;      \&quot;rbd.test_fs_device2\&quot;: {&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        \&quot;name\&quot;: \&quot;test_fs_device2\&quot;,&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        \&quot;size\&quot;: 16,&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        \&quot;id\&quot;: \&quot;rbd.test_fs_device2\&quot;,&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        \&quot;type\&quot;: \&quot;rbd\&quot;&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;      },&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;      \&quot;rbd.test_majk\&quot;: {&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        \&quot;name\&quot;: \&quot;test_majk\&quot;,&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        \&quot;id\&quot;: \&quot;rbd.test_majk\&quot;,&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        \&quot;type\&quot;: \&quot;rbd\&quot;&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;      }&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    }&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    -------------------------- HTTP REQUEST (CLIENT) -------------------------&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    POST /volumes/rbd HTTP/1.1&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Host: libstorage-server&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Libstorage-Instanceid: rbd=109.105.115.73&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Libstorage-Localdevices: rbd=&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Libstorage-Tx: txID=b1565614-1b5f-4de2-5756-b74fb99887aa, txCR=1516360353&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    &quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    {\&quot;name\&quot;:\&quot;cephrbd-book\&quot;,\&quot;availabilityZone\&quot;:\&quot;\&quot;,\&quot;iops\&quot;:0,\&quot;size\&quot;:5,\&quot;type\&quot;:\&quot;\&quot;,\&quot;opts\&quot;:{\&quot;size\&quot;:\&quot;5\&quot;}}&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    -------------------------- HTTP RESPONSE (CLIENT) -------------------------&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    HTTP/1.1 500 Internal Server Error&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Content-Length: 319&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Content-Type: application/json&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Date: Fri, 19 Jan 2018 11:12:33 GMT&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    Libstorage-Servername: jade-chopper-ky&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    &quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    {&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;      \&quot;message\&quot;: \&quot;Failed to create new volume\&quot;,&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;      \&quot;status\&quot;: 500,&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;      \&quot;error\&quot;: {&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        \&quot;driverName\&quot;: \&quot;rbd\&quot;,&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        \&quot;inner\&quot;: {&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;          \&quot;inner\&quot;: \&quot;Error running command: [rbd: strict_strtoll: garbage at end of string. got: '5G'\\n]\&quot;,&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;          \&quot;msg\&quot;: \&quot;unable to create rbd\&quot;&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        },&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        \&quot;opts.Size\&quot;: 5,&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;        \&quot;volumeName\&quot;: \&quot;cephrbd-book\&quot;&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;      }&quot;
time=&quot;2018-01-19T19:12:33+08:00&quot; level=info msg=&quot;    }&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　通过日志可以看到，每次发送docker volume create命令时，实际发送了两次http请求，第一次是列出当前的rbd设备，第二次才是发出post请求来创建一个rbd设备。而这里的日志，则给出了更多的信息“rbd: strict_strtoll: garbage at end of string. got: '5G'”。也就是说，很可能就是在rexray调用rbd create命令时发生了错误。这里，我们打开&lt;a href=&quot;https://github.com/thecodeteam/rexray&quot;&gt;rexray源码&lt;/a&gt;继续跟踪，具体的源码文件为rexray/blob/master/libstorage/drivers/storage/rbd/utils/utils.go。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//RBDCreate creates a new RBD volume on the cluster
func RBDCreate(
    ctx types.Context,
    pool *string,
    image *string,
    sizeGB *int64,
    objectSize *string,
    features []*string) error {

    cmd := exec.Command(
        rbdCmd, &quot;create&quot;, poolOpt, *pool,
        &quot;--object-size&quot;, *objectSize,
        &quot;--size&quot;, strconv.FormatInt(*sizeGB, 10)+&quot;G&quot;,
    )

    for _, feature := range features {
        cmd.Args = append(cmd.Args, &quot;--image-feature&quot;)
        cmd.Args = append(cmd.Args, *feature)
    }

    cmd.Args = append(cmd.Args, *image)
    _, _, err := RunCommand(ctx, cmd)
    if err != nil {
        return goof.WithError(&quot;unable to create rbd&quot;, err)
    }

    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　根据上面的代码可以大致看出，rexray就是直接调用rbd create命令来创建rbd设备，和我们直接调用命令不同的是它这里是把rbd的大小转化成GB，然后再字符串拼接了一个“G”。这里我们就按照它这里的方法，组装了一个新的rbd命令，然后在CentOS上测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# rbd create cephrbd-test --size 5G
rbd: strict_strtoll: garbage at end of string. got: '5G'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　果然，还是报错了，我们再使用该命令在ubuntu上测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# rbd create cephrbd-test --size 5G&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　在ubuntu上运行，没有报错。同一条命令，在不同的环境下结果不同。那么最大的可能就是rbd(ceph)的版本不一致了。在ubuntu下获取ceph版本。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ceph version
ceph version 10.2.7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　而CentOS上默认安装的ceph版本只是0.94.5(Hammer版)，而Ubuntu上默认安装的却是更高的10.2.7(jewel版本)。而0.94.5 ceph版本的rbd命令无法解析“G”，“M”等描述rbd大小的参数。这就是问题出现的原因。&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;解决方法&lt;/h2&gt;
&lt;p&gt;　　在CentOS上安装更新的Ceph版本(jewel或更新的版本)即可。&lt;/p&gt;
&lt;p&gt;ps：后面的博客会介绍如何在CentOS上安装更新的Ceph版本。&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jan 2018 22:48:00 +0000</pubDate>
<dc:creator>BookShu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/styshoo/p/8339811.html</dc:identifier>
</item>
<item>
<title>用 Deployment 运行应用 - 每天5分钟玩转 Docker 容器技术（123） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8336904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8336904.html</guid>
<description>&lt;p&gt;&lt;span&gt;从本章开始，我们将通过实践深入学习 Kubernetes 的各种特性。作为容器编排引擎，最重要也是最基本的功能当然是运行容器化应用，这就是本章的内容。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Deployment&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;前面我们已经了解到，Kubernetes 通过各种 Controller 来管理 Pod 的生命周期。为了满足不同业务场景，Kubernetes 开发了 Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job 等多种 Controller。我们首先学习最常用的 Deployment。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先从例子开始，运行一个 Deployment：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl run nginx-deployment --image=nginx:1.7.9 --replicas=2&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上面的命令将部署包含两个副本的 Deployment &lt;/span&gt;&lt;code&gt;&lt;span&gt;nginx-deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，容器的 image 为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nginx:1.7.9&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面详细分析 Kubernetes 都做了些什么工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180123172141397-24396006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;kubectl get deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 命令可以查看 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nginx-deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的状态，输出显示两个副本正常运行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来我们用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl describe deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 了解更详细的信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180123172245725-660514347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;大部分内容都是自解释的，我们重点看最下面部分。这里告诉我们创建了一个 ReplicaSet &lt;/span&gt;&lt;code&gt;&lt;span&gt;nginx-deployment-1260880958&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Events&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是 Deployment 的日志，记录了 ReplicaSet 的启动过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过上面的分析，也验证了 Deployment 通过 ReplicaSet 来管理 Pod 的事实。接着我们将注意力切换到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nginx-deployment-1260880958&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl describe replicaset&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180123172307178-1893836923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;两个副本已经就绪，用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl describe replicaset&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看详细信息：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180123172322522-1402773410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;Controlled By&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指明此 ReplicaSet 是由 Deployment &lt;/span&gt;&lt;code&gt;&lt;span&gt;nginx-deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 创建。&lt;/span&gt;&lt;code&gt;&lt;span&gt;Events&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记录了两个副本 Pod 的创建。接着我们来看 Pod，执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl get pod&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180123172336365-918922581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;两个副本 Pod 都处于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Running&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 状态，用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl describe pod&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看更详细的信息：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180123172348397-692516689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;Controlled By&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指明此 Pod 是由 ReplicaSet &lt;/span&gt;&lt;code&gt;&lt;span&gt;nginx-deployment-1260880958&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 创建。&lt;/span&gt;&lt;code&gt;&lt;span&gt;Events&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记录了 Pod 的启动过程。如果操作失败（比如 image 不存在），也能在这里查看到原因。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结一下这个过程：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;用户通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 创建 Deployment。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Deployment 创建 ReplicaSet。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;ReplicaSet 创建 Pod。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180123172402147-1245930764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从上图也可以看出，对象的命名方式是：&lt;/span&gt;&lt;code&gt;&lt;span&gt;子对象的名字&lt;/span&gt;&lt;/code&gt;&lt;span&gt; = &lt;/span&gt;&lt;code&gt;&lt;span&gt;父对象名字&lt;/span&gt;&lt;/code&gt;&lt;span&gt; + &lt;/span&gt;&lt;code&gt;&lt;span&gt;随机字符串或数字&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;本节我们是通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl run&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 创建的 Deployment，下一节学习另一种更常用的方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jan 2018 22:24:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8336904.html</dc:identifier>
</item>
<item>
<title>Android中与task相关的几个属性 - AmyZYX</title>
<link>http://www.cnblogs.com/amyzhu/p/8338608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amyzhu/p/8338608.html</guid>
<description>&lt;h2 id=&quot;与任务相关的属性&quot;&gt;1、与任务相关的属性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;taskAffinity ：修改任何给定Activity的关联
&lt;ul&gt;&lt;li&gt;系统使用包名标识应用的默认任务关联；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;taskAffinity属性取字符串值，必须不同于包名；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;taskAffinify起作用的两种情况
&lt;ul&gt;&lt;li&gt;启动Activity的Intent包含FLAG_ACTIVITY_NEW_TASK；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Activity的allowTaskReparenting为true；&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;lauchMode
&lt;ul&gt;&lt;li&gt;standard，默认模式 —— 系统在启动Activity的任务中创建Activity的新实例并向其传送Intent。Activity可以多次实例化，每个实例可以属于不同任务，一个任务可以拥有多个实例。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;singleTop —— 若当前任务的顶部已经存在Activity的一个实例，则系统会通过onNewIntent()方法传送Intent。Activity可以多次实例化，每个实例均可属于不同的任务，一个任务可以拥有多个实例（前提是位于返回栈顶的Activity并不是Activity的现有实例）。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;singleTask —— 系统创建新任务并实例化位于新任务底部的Activity。如果该Activity的一个实例已经存在一个单独任务中，系统会通过现有实例的onNewIntent()方法向其传送Intent。一次只能存在Activity的一个实例。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;singleInstance —— 与singleTask相同，只是系统不会将任何其他Acitivty启动到包含实例的任务中。该Activity是其任务唯一仅有的成员；由此Activity启动的任何Activity均在单独任务打开。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用launchMode属性为Activity指定的行为可以由Intent附带的Activity启动标志替代。&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;allowTaskReparenting —— true/false，Activity是否可以从其启动的任务移动到与其具有关联的任务。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;clearTaskOnLaunch —— true/false，若设置为true，每当用户离开任务后返回时，系统都会将堆栈清除到只剩下根Activity。与alwaysRetainTaskState刚好相反。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;alwaysRetainTaskState —— true/false，用户长时间离开任务后，仍将所有Activity保留在其堆栈中（默认会清除根Activity外的其他Activity）。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;finishOnTaskLaunch —— true/false，类似clearTaskOnLaunch，但只对单个Activity起作用。可能导致任何Activity停止，包括根Activity。用户离开后返回任务，任务将不复存在。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;与任务相关的intent标志-启动模式&quot;&gt;2、与任务相关的Intent标志 （启动模式）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;FLAG_ACTIVITY_NEW_TASK —— 在新任务中启动Activity。如果正在启动的Activity已经处于运行状态，则该任务会转到前台并恢复其最后状态，同时Activity会在onNewIntent()中收到新Intent。
&lt;ul&gt;&lt;li&gt;在Activity上下文之外启动Activity需要给Intent设置FLAG_ACTIVITY_NEW_TASK标志，否则会报异常。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;首先会查找是否存在和被启动Activity具有相同亲和性的任务栈，如果有，则直接把这个栈整体移动到前台，并保持栈中状态不变。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;默认情况下同一个应用中的所有Activity拥有相同的taskAffinity&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;FLAG_ACTIVITY_SINGLE_TOP—— 如果正在启动的Activity是当前Activity（位于返回战顶部），则现有实例会接收对onNewIntent()的调用，而不是创建新实例。产生与singleTop相同的行为。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;FLAG_ACTIVITY_CLEAR_TOP —— 如果正在启动的Activity已在当前任务中运行，则会销毁当前任务顶部所有Activity，并通过onNewIntent()将此Intent传递给Activity已恢复的实例。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;FLAG_ACTIVITY_CLEAR_TOP通常与FLAG_ACTIVITY_NEW_TASK结合使用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;处理关联即activity优先属于哪个任务&quot;&gt;3、处理关联（即Activity优先属于哪个任务）&lt;/h2&gt;
&lt;p&gt;（1）默认情况下，同一应用中的所有Activity彼此关联，优先位于相同任务中。&lt;br/&gt;（2）通过 taskAffinity属性设置关联&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jan 2018 17:09:00 +0000</pubDate>
<dc:creator>AmyZYX</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/amyzhu/p/8338608.html</dc:identifier>
</item>
<item>
<title>数据结构09 哈夫曼树 - nnngu</title>
<link>http://www.cnblogs.com/nnngu/p/8338577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnngu/p/8338577.html</guid>
<description>&lt;p&gt;作者：&lt;a href=&quot;https://github.com/nnngu&quot;&gt;nnngu&lt;/a&gt;&lt;br/&gt;GitHub：&lt;a href=&quot;https://github.com/nnngu&quot; class=&quot;uri&quot;&gt;https://github.com/nnngu&lt;/a&gt;&lt;br/&gt;博客园：&lt;a href=&quot;http://www.cnblogs.com/nnngu/&quot;&gt;http://www.cnblogs.com/nnngu&lt;/a&gt;&lt;br/&gt;简书：&lt;a href=&quot;https://www.jianshu.com/users/1df20d76ea5c&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/users/1df20d76ea5c&lt;/a&gt;&lt;br/&gt;知乎：&lt;a href=&quot;https://www.zhihu.com/people/nnngu/posts&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/people/nnngu/posts&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这一篇要总结的是树中的哈夫曼树(Huffman Tree)，我想从以下几点对其进行总结：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8338577.html#1&quot;&gt;1、什么是哈夫曼树&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8338577.html#2&quot;&gt;2、如何构建哈夫曼树&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8338577.html#3&quot;&gt;3、哈夫曼编码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8338577.html#4&quot;&gt;4、代码实现&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1&quot;&gt;1、什么是哈夫曼树&lt;/h2&gt;
&lt;p&gt;什么是哈夫曼树呢？&lt;/p&gt;
&lt;p&gt;哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。下面用一幅图来说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/23/1516720428913.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它们的带权路径长度分别为：&lt;/p&gt;
&lt;p&gt;图a： WPL=5*2+7*2+2*2+13*2=54&lt;/p&gt;
&lt;p&gt;图b： WPL=5*3+2*3+7*2+13*1=48&lt;/p&gt;
&lt;p&gt;可见，图b的带权路径长度较小，我们可以证明图b就是哈夫曼树(也称为最优二叉树)。&lt;/p&gt;
&lt;h2 id=&quot;2&quot;&gt;2、如何构建哈夫曼树&lt;/h2&gt;
&lt;p&gt;一般可以按下面步骤构建：&lt;/p&gt;
&lt;p&gt;（1）将所有左，右子树都为空的节点作为根节点。&lt;/p&gt;
&lt;p&gt;（2）在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值。&lt;/p&gt;
&lt;p&gt;（3）从森林中删除这两棵树，同时把新树加入到森林中。&lt;/p&gt;
&lt;p&gt;（4）重复2、3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。&lt;/p&gt;
&lt;p&gt;下面是构建哈夫曼树的图解过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/23/1516721219578.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3&quot;&gt;3、哈夫曼编码&lt;/h2&gt;
&lt;p&gt;利用哈夫曼树求得的用于通信的二进制编码称为哈夫曼编码。树中从根到每个叶子节点都有一条路径，对路径上的各分支约定指向左子树的分支表示”0”码，指向右子树的分支表示“1”码，取每条路径上的“0”或“1”的序列作为各个叶子节点对应的字符编码，即是哈夫曼编码。&lt;/p&gt;
&lt;p&gt;就拿上图例子来说：&lt;/p&gt;
&lt;p&gt;A，B，C，D对应的哈夫曼编码分别为：111，10，110，0&lt;/p&gt;
&lt;p&gt;用图说明如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/23/1516722135904.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4&quot;&gt;4、代码实现&lt;/h2&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;节点类 Node.java&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 节点类&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Node &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Comparable {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; value;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node leftChild;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node rightChild;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Node(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; value) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; = value;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; value;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setValue&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; value) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; = value;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;getLeftChild&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; leftChild;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setLeftChild&lt;/span&gt;(Node leftChild) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;leftChild&lt;/span&gt; = leftChild;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;getRightChild&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; rightChild;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setRightChild&lt;/span&gt;(Node rightChild) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rightChild&lt;/span&gt; = rightChild;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;compareTo&lt;/span&gt;(Object o) {
        Node that = (Node) o;
        &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; result = that.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; - that.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ? &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; : result == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ? &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; : -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;HuffmanTreeBuilder.java&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Arrays;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Collections;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 哈夫曼树构造类&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HuffmanTreeBuilder {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        List&amp;lt;Node&amp;gt; nodes = Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(
                &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;),
                &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;),
                &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;),
                &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;)
        );
        Node node = HuffmanTreeBuilder.&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;(nodes);
        &lt;span class=&quot;fu&quot;&gt;printTree&lt;/span&gt;(node);
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 构造哈夫曼树&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param nodes &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;节点集合&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;构造出来的树的根节点&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;(List&amp;lt;Node&amp;gt; nodes) {
        nodes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Node&amp;gt;(nodes);
        &lt;span class=&quot;fu&quot;&gt;sortList&lt;/span&gt;(nodes);
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (nodes.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
            &lt;span class=&quot;fu&quot;&gt;createAndReplace&lt;/span&gt;(nodes);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; nodes.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 组合两个权值最小节点，并在节点列表中用它们的父节点替换它们&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param nodes &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;节点集合&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;createAndReplace&lt;/span&gt;(List&amp;lt;Node&amp;gt; nodes) {
        Node left = nodes.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
        Node right = nodes.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        Node parent = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node(left.&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;() + right.&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;());
        parent.&lt;span class=&quot;fu&quot;&gt;setLeftChild&lt;/span&gt;(left);
        parent.&lt;span class=&quot;fu&quot;&gt;setRightChild&lt;/span&gt;(right);
        nodes.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
        nodes.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
        nodes.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(parent);
        &lt;span class=&quot;fu&quot;&gt;sortList&lt;/span&gt;(nodes);
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 将节点集合由小到大排序&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param nodes&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sortList&lt;/span&gt;(List&amp;lt;Node&amp;gt; nodes) {
        Collections.&lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(nodes);
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 打印树结构，显示的格式是node(left,right)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param node&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;printTree&lt;/span&gt;(Node node) {
        Node left = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        Node right = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (node != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;(node.&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;());
            left = node.&lt;span class=&quot;fu&quot;&gt;getLeftChild&lt;/span&gt;();
            right = node.&lt;span class=&quot;fu&quot;&gt;getRightChild&lt;/span&gt;();
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;(&quot;&lt;/span&gt; + (left != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; ? left.&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;() : &lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt;) + &lt;span class=&quot;st&quot;&gt;&quot;,&quot;&lt;/span&gt; + (right != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; ? right.&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;() : &lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt;) + &lt;span class=&quot;st&quot;&gt;&quot;)&quot;&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (left != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;fu&quot;&gt;printTree&lt;/span&gt;(left);
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (right != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;fu&quot;&gt;printTree&lt;/span&gt;(right);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516726852534.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jan 2018 17:07:00 +0000</pubDate>
<dc:creator>nnngu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnngu/p/8338577.html</dc:identifier>
</item>
<item>
<title>企业级分布式监控系统--zabbix - 姚红</title>
<link>http://www.cnblogs.com/yaohong/p/8338442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaohong/p/8338442.html</guid>
<description>&lt;h2&gt;1.Zabbix简介&lt;/h2&gt;
&lt;p&gt;　　Zabbix 是一个企业级的分布式开源监控方案。&lt;/p&gt;
&lt;h2&gt;2.zabbix安装&lt;/h2&gt;
&lt;p&gt;zabbix重要的不是部署，而是学会操作使用，所以推荐大家进行一键部署。&lt;/p&gt;
&lt;p&gt;手动部署可参考官方文档：&lt;a href=&quot;https://www.zabbix.com/documentation/3.4/zh/manual/installation/install_from_packages&quot; target=&quot;_blank&quot;&gt;https://www.zabbix.com/documentation/3.4/zh/manual/installation/install_from_packages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一键部署可参考：&lt;a href=&quot;https://github.com/BillWang139967/zabbix_manager&quot; target=&quot;_blank&quot;&gt;https://github.com/BillWang139967/zabbix_manager&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;docker上一键部署：&lt;a href=&quot;https://github.com/BillWang139967/zabbix_install/wiki/server_docker&quot; target=&quot;_blank&quot;&gt;https://github.com/BillWang139967/zabbix_install/wiki/server_docker&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3.工作原理&lt;/h2&gt;
&lt;p&gt;一个监控系统运行的大概的流程是这样的：&lt;/p&gt;
&lt;p&gt;　　zabbix agent需要安装到被监控的主机上，它负责定期收集各项数据，并发送到zabbix server端，zabbix server将数据存储到数据库中，zabbix web根据数据在前端进行展现和绘图。这里agent收集数据分为主动和被动两种模式：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;主动&lt;/strong&gt;：agent请求server获取主动的监控项列表，并主动将监控项内需要检测的数据提交给server/proxy&lt;/p&gt;
&lt;p&gt;　    &lt;strong&gt;被动&lt;/strong&gt;：server向agent请求获取监控项的数据，agent返回数据。&lt;/p&gt;
&lt;h2&gt;4.监控功能&lt;/h2&gt;
&lt;p&gt;主机的性能监控、网络设备性能监控、数据库性能监控、多种告警方式、详细的报表图表绘制&lt;/p&gt;
&lt;p&gt;监控主机zabbix有专用的agent，可以监控Linux，Windows，FreeBSD等 。&lt;/p&gt;
&lt;p&gt;监控网络设备zabbix通过SNMP，ssh(不多用)&lt;/p&gt;
&lt;p&gt;可监控对象&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设备：服务器，路由器，交换机&lt;/li&gt;
&lt;li&gt;软件：OS，网络，应用程序&lt;/li&gt;
&lt;li&gt;主机性能指标监控&lt;/li&gt;
&lt;li&gt;故障监控： down机，服务不可用，主机不可达&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;5.监控系统架构&lt;/h2&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;&lt;strong&gt;C/S架构&lt;/strong&gt;   &lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;       客户端/服务器端，这种架构适合规模较小，处于同一地域的环境
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1024482/201711/1024482-20171130105131370-232458490.png&quot; alt=&quot;&quot; width=&quot;717&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C/P/S&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     客户端/代理端/服务器端/,这种适用于大规模系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1024482/201711/1024482-20171130105840261-1525040355.png&quot; alt=&quot;&quot; width=&quot;723&quot; height=&quot;261&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;6.Zabbix系统架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1024482/201711/1024482-20171130151910761-608795329.png&quot; alt=&quot;&quot; width=&quot;792&quot; height=&quot;496&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;7.Zabbix组件构成&lt;/h2&gt;
&lt;h4&gt;Server&lt;/h4&gt;
&lt;div class=&quot;level5&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;　　Zabbix server 是监控代理程序报告系统可用性、系统完成整性和统计信息的核心组件。Zabbix Server是所有配置信息、统计信息和操作数据的核心存储器。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;数据库存储&quot; class=&quot;sectionedit4&quot;&gt;数据库存储&lt;/h4&gt;
&lt;div class=&quot;level5&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;　　所有配置信息和Zabbix收集到的数据都被存储在数据库中。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;web界面&quot; class=&quot;sectionedit5&quot;&gt;Web界面&lt;/h4&gt;
&lt;div class=&quot;level5&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;　　为了从任何地方和任何平台都轻松的访问Zabbix,Zabbix提供了基于Web的界面。该界面是Zabbix Server的一部分，通常(但不一定)跟Zabbix Server运行在同一台物理机器上。 &lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&quot;proxy代理服务器&quot; class=&quot;sectionedit6&quot;&gt;Proxy代理服务器&lt;/h5&gt;
&lt;div class=&quot;level5&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;　　Zabbix proxy 可以替Zabbix Server收集性能和可用性数据。Proxy代理服务器是Zabbix软件可选择部署的一部分；当然，Proxy代理服务器可以帮助单台Zabbix Server分担负载压力。&lt;/p&gt;
&lt;/div&gt;
&lt;h5 id=&quot;agent监控代理&quot; class=&quot;sectionedit7&quot;&gt;Agent监控代理&lt;/h5&gt;
&lt;div class=&quot;level5&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;　　Zabbix agents监控代理 部署在监控目标上，能够主动监控本地资源和应用程序，并将收集到的数据报告给Zabbix Server。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;数据流&quot; class=&quot;sectionedit8&quot;&gt;数据流&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;　　此外，了解Zabbix内部的数据流同样很重要。为了创建一个监控项用于采集数据，必须先创建一个主机。转换到Zabbix功能的其他部分，你必须先有一个监控项来创建触发器，你必须有一个触发器来创建动作。 因此，如果你想收到&lt;em&gt;X服务器&lt;/em&gt;CPU负载过高的告警，你必须先为&lt;em&gt;X服务器&lt;/em&gt;创建一个主机实体并关联一个用于对CPU进行监控的监控项，然后如果CPU负载太高便会激活触发器，接着会执行一个动作，给你发送告警邮件。虽然看起来有很多步骤，但是使用模板的话可以会很简单。同时，这个设计可以创建一个非常灵活的配置。&lt;/p&gt;

&lt;/div&gt;
&lt;h2&gt;8.zabbix监控环境中基本概念&lt;/h2&gt;
&lt;p&gt;　　1、主机（host）：要监控的网络设备，可由IP或DNS名称指定；&lt;/p&gt;
&lt;p&gt;　　2、主机组（host group）：主机的逻辑容器，可以包含主机和模板，但同一个组织内的主机和模板不能互相链接；主机组通常在给用户或用户组指派监控权限时使用；&lt;/p&gt;
&lt;p&gt;　　3、监控项（item）：一个特定监控指标的相关的数据；这些数据来自于被监控对象；item是zabbix进行数据收集的核心，相对某个监控对象，每个item都由&quot;key&quot;标识；&lt;/p&gt;
&lt;p&gt;　　4、触发器（trigger）：一个表达式，用于评估某监控对象的特定item内接收到的数据是否在合理范围内，也就是阈值；接收的数据量大于阈值时，触发器状态将从&quot;OK&quot;转变为&quot;Problem&quot;，当数据再次恢复到合理范围，又转变为&quot;OK&quot;；&lt;/p&gt;
&lt;p&gt;　　5、事件（event）：触发一个值得关注的事情，比如触发器状态转变，新的agent或重新上线的agent的自动注册等；&lt;/p&gt;
&lt;p&gt;　　6、动作（action）：指对于特定事件事先定义的处理方法，如发送通知，何时执行操作；&lt;/p&gt;
&lt;p&gt;　　7、报警升级（escalation）：发送警报或者执行远程命令的自定义方案，如每隔5分钟发送一次警报，共发送5次等；&lt;/p&gt;
&lt;p&gt;　　8、媒介（media）：发送通知的手段或者通道，如Email、Jabber或者SMS等；&lt;/p&gt;
&lt;p&gt;　　9、通知（notification）：通过选定的媒介向用户发送的有关某事件的信息；&lt;/p&gt;
&lt;p&gt;　　10、远程命令（remote command）：预定义的命令，可在被监控主机处于某特定条件下时自动执行；&lt;/p&gt;
&lt;p&gt;　　11、模板（template）：用于快速定义被监控主机的预设条目集合，通常包含了item、trigger、graph、screen、application以及low-level discovery rule；模板可以直接链接至某个主机；&lt;/p&gt;
&lt;p&gt;　　12、应用（application）：一组item的集合；&lt;/p&gt;
&lt;p&gt;　　13、web场景（web scennario）：用于检测web站点可用性的一个活多个HTTP请求；&lt;/p&gt;
&lt;p&gt;　　14、前端（frontend）：Zabbix的web接口；&lt;/p&gt;

</description>
<pubDate>Tue, 23 Jan 2018 16:05:00 +0000</pubDate>
<dc:creator>姚红</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaohong/p/8338442.html</dc:identifier>
</item>
<item>
<title>内核知识第十一讲,门,以及中断和中断异常. - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/8338423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/8338423.html</guid>
<description>&lt;h2&gt;一丶TSS和TR寄存器.&lt;/h2&gt;
&lt;p&gt;首先,CUP在执行代码的时候.是按照任务执行的&lt;/p&gt;
&lt;p&gt;每个任务有一个任务状态段TSS&lt;/p&gt;
&lt;p&gt;用于保护任务的有关信息.在任务内变换特权级和任务切换的时候.要用到这些信息.&lt;/p&gt;
&lt;p&gt;这个就是TSS任务状态段.&lt;/p&gt;
&lt;p&gt;而在windows 80386中.有两种系统段.一种就是TSS,另一种就是LDT&lt;/p&gt;
&lt;p&gt;系统段描述符格式:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180123221951412-2133712430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180123221956569-174178925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个系统段和存储段相同.&lt;/p&gt;
&lt;p&gt;当DT = 1 表示这是个存储段&lt;/p&gt;
&lt;p&gt;当DT = 0 则表示这个是系统段.&lt;/p&gt;
&lt;p&gt;而如果是系统段.那么Type属性就很重要了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180123222156365-1427445185.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180123222204522-760659512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而TR寄存器,就是保存了当前任务段的选择子.&lt;/p&gt;
&lt;p&gt;而且是存放在GDT表中的.&lt;/p&gt;
&lt;p&gt;当属性为C的是否.则是门描述符. &lt;/p&gt;
&lt;p&gt;格式:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180123235005740-716502960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180123235011678-1432964042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;门描述符的作用就是描述某个子程序的入口. 用门内的选择子.还有偏移.利用Call或者Jmp可以调用.&lt;/p&gt;
&lt;p&gt;也就是说当我们三环调用API的是否,内部会使用门来进行特权级转换.而且门描述符记录了参数的个数. 还会保存 ring0的栈,&lt;/p&gt;
&lt;p&gt;从栈里面获取参数信息.&lt;/p&gt;
&lt;p&gt;当返回的是否,调用 retf汇编指令,从0环切换到3环.&lt;/p&gt;
&lt;h2&gt;二丶中断和中断异常.&lt;/h2&gt;
&lt;p&gt;首先,什么是中断?&lt;/p&gt;
&lt;p&gt;在我们的8086的年代里面. 调用API的是否是 int 21来进行调用的.&lt;/p&gt;
&lt;p&gt;这就是一个中断.中断是什么?  其实中断就是一个电信号.&lt;/p&gt;
&lt;p&gt;比如用户操作键盘,键当被按下就会产生一个中断.  但是CPU能接受到这个中断.但是不能去处理. 这个要操作系统去处理.&lt;/p&gt;
&lt;p&gt;所以当有中断产生, CPU就会查表 . 表内容是固定的. 操作系统会填写函数指针. 当我们按键,产生中断了. 那么就会查表进行操作.&lt;/p&gt;

&lt;p&gt;中断其实也是CPU和操作系统通信的一种机制.&lt;/p&gt;
&lt;p&gt;比如我们的 int 3指令. 就产生一个异常.而在CPU接受到了,就会去查表.这样就可以处理int 3的指令了.&lt;/p&gt;
&lt;h3&gt;1.中断和异常.&lt;/h3&gt;
&lt;p&gt;中断我们说过了,是电信号. 而表则是CPU和操作系统的通信机制.&lt;/p&gt;
&lt;p&gt;那么说下异常把. 其实异常也是中断. 只不过,我们的软件调试的时候.当我们的程序用内联汇编写的int 3的时候,就会产生断点功能.&lt;/p&gt;
&lt;p&gt;其实软件产生的中断,就叫做异常. 而且int 3指令在ring3调用的时候.会产生特权级改变. CPU也会固定的去查表.&lt;/p&gt;
&lt;p&gt;在80386里面.有两个银脚,是专门接受中断信号的.&lt;/p&gt;
&lt;p&gt;而且80386最多接受256种中断或者异常.&lt;/p&gt;
&lt;p&gt;引脚:&lt;/p&gt;
&lt;p&gt;　　INTR 专门接受中断或者异常, 当我们调用CLI汇编指令的时候.其实屏蔽的就是INTR.不让其接受中断信号.&lt;/p&gt;
&lt;p&gt;　　NMI  这个也是接受的.但是不能屏蔽的. 比如我们的系统在运行中,你把内存条拔了.那么就会产生电信号.有NMI引脚发送.&lt;/p&gt;


&lt;h3&gt; 二丶中断表的概念&lt;/h3&gt;
&lt;p&gt;我们上面说过,中断是CPU和操作系统通信的一种机制.&lt;/p&gt;
&lt;p&gt;CPU接受中断. 那么就要查表.而操作系统要往这个表中填写函数指针.让CPU去执行.&lt;/p&gt;
&lt;p&gt;比如我们的8086CPU,调用API的是否,其实就是 int 21h,其实21h就是在查表.查表中的第21项.可以把表看作成数组.&lt;/p&gt;

&lt;h2&gt;三丶IDT表&lt;/h2&gt;
&lt;p&gt;上面说的中断表.其实就是IDT表. IDT表因为在80386下,最多处理256个,所以这个IDT表只有256项.&lt;/p&gt;
&lt;p&gt;而IDT表和GDT一样.只不过IDT表中存储的是门描述符.&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;p&gt;　　我们的int 3断点产生了. 那么就回去IDT表中寻找第三项.进行操作.&lt;/p&gt;
&lt;p&gt;WinDbg调试查看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124011800256-1721915495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IDT表的首地址会存放在IDTR寄存器中. 然后每一项都是按照门描述符来管理. 所以当我们拆出来的地址拼接成一个完整的地址,就可以查看完整的处理int 3断点的代码了.&lt;/p&gt;
&lt;p&gt;当我们HOOK了这个第三项.那么你的程序将永运不会产生int 3断点.&lt;/p&gt;
&lt;p&gt;其中,IDT表中每一项都是8个字节,因为不光要描述函数地址,还要藐视额外的属性信息.&lt;/p&gt;

</description>
<pubDate>Tue, 23 Jan 2018 15:56:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/8338423.html</dc:identifier>
</item>
<item>
<title>视频目标处理涉及的目标分割、目标识别、目标检测和目标跟踪都是指什么？ - 在海一方美猴王</title>
<link>http://www.cnblogs.com/liuyihai/p/8338393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyihai/p/8338393.html</guid>
<description>&lt;div class=&quot;RichContent RichContent--unescapable&quot; data-reactid=&quot;238&quot; readability=&quot;42&quot;&gt;
&lt;div class=&quot;RichContent-inner&quot; data-reactid=&quot;239&quot; readability=&quot;40&quot;&gt;
&lt;p&gt;&lt;span&gt;      （1）目标分割，应该是Target Segmentation，应该是data/image segmentation的一种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        这里假定数据是图像，就如楼上说的，任务是把目标对应的部分分割出来。对于一般的光学图像而言，分割像素是一个比较常见的目标，就是要提取哪一些像素是用于表述已知目标的。这种Segmentation可以是一个分类（classificatio）问题，就是把每一个pixel做labeling，提出感兴趣的那一类label的像素。也可以是clustering的问题，即是不知道label，但需要满足一些optimality，比如要cluster之间的correlation最小之类的。当然，答主也见过一些针对其他数据的目标分割，比如hyperspectral data，也需要分割哪些频率或者通道对应的是目标。比如视频流，那段时间对应是目标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        下面是一个Target Segmentation的栗子：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/5a767c0f13b253eedb23199b7454d0b4_hd.jpg&quot; alt=&quot;&quot; width=&quot;602&quot; data-rawwidth=&quot;602&quot; data-rawheight=&quot;337&quot; data-original=&quot;https://pic3.zhimg.com/5a767c0f13b253eedb23199b7454d0b4_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/50/5a767c0f13b253eedb23199b7454d0b4_hd.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;      （2）目标识别，应该是Target Recognition。&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;RichContent-inner&quot; data-reactid=&quot;239&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;        这是一个基于分类（Classification）的识别（Recognition）问题，即是在所有的给定数据中，分类出哪一些sample是目标，哪一些不是。还是拿图片作为数据举例，这个分类的层面往往不是pixel，给定的一些segment，或者定义的对象（Object），或者图片本身。&lt;br/&gt;       下面是一个Target Recognition的栗子：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/7b2f4dcc46920adfef0594343dfce0c3_hd.jpg&quot; alt=&quot;&quot; width=&quot;1024&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;317&quot; data-original=&quot;https://pic4.zhimg.com/7b2f4dcc46920adfef0594343dfce0c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/50/7b2f4dcc46920adfef0594343dfce0c3_hd.jpg&quot;/&gt;&lt;br/&gt;       （3）目标检测，应该是Target Detection。&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;RichContent-inner&quot; data-reactid=&quot;239&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;        最早的detection system应该是搞雷达的人首先提出并且heavily study的，最简单的任务就是从看似随机（random）又充满干扰（interference）和噪音（noise）的信号中，抓取到有信息的特征（information-bearing pattern）。最简单的一个栗子，就是当你拿到一段随机的雷达回波，可以设置一个threshold，当高于这个threshold，就认为是探测到了高速大面积飞行器之类的高回波的目标。当然，这里面的threshold该怎么设计，涉及到False Alarm和Miss Detection之间的平衡。人们往往需要寻找最佳的transform或者domain去对信号进行分析。&lt;br/&gt;        下面是一个Target Detection的栗子：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/ba971eab1ba26ac432f78ccbfb37388b_hd.jpg&quot; alt=&quot;&quot; width=&quot;1045&quot; data-rawwidth=&quot;1045&quot; data-rawheight=&quot;1035&quot; data-original=&quot;https://pic3.zhimg.com/ba971eab1ba26ac432f78ccbfb37388b_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/50/ba971eab1ba26ac432f78ccbfb37388b_hd.jpg&quot;/&gt;&lt;br/&gt;      （4）目标追踪，应该是Target Tracking。&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;        这个任务很重要的第一点是目标定位（Target Locating），而且这个任务设计到的数据一般具有时间序列（Temporal Data）。常见的情况是首先Target被Identify以后，算法或者系统需要在接下来时序的数据中，快速并高效地对给定目标进行再定位。任务需要区别类似目标，需要避免不要的重复计算，充分利用好时序相关性（Temporal Correlation），并且需要对一些简单的变化Robust，必须旋转，遮盖，缩小放大，Motion Blur之类的线性或者非线性变化。&lt;br/&gt;        下面是一个Target Detection的栗子：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;RichContent-inner&quot; data-reactid=&quot;239&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;240&quot;&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/cd89972dcddad9f7e7a9b760d71d7d57_hd.jpg&quot; alt=&quot;&quot; width=&quot;480&quot; data-rawwidth=&quot;480&quot; data-rawheight=&quot;360&quot; data-original=&quot;https://pic2.zhimg.com/cd89972dcddad9f7e7a9b760d71d7d57_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/50/cd89972dcddad9f7e7a9b760d71d7d57_hd.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;本文摘录自：https://www.zhihu.com/question/36500536&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 23 Jan 2018 15:41:00 +0000</pubDate>
<dc:creator>在海一方美猴王</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyihai/p/8338393.html</dc:identifier>
</item>
<item>
<title>20165233 我期望的师生关系 - minchan0624</title>
<link>http://www.cnblogs.com/minchan0624/p/8338384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minchan0624/p/8338384.html</guid>
<description>[unable to retrieve full-text content]老师能提供的帮助 我印象最深刻的老师应该是中学时的老师。 初中时的班主任是一名语文老师，她文学功底很深厚，但是一个十分活泼的老师。我记得她的脾气还是挺大的，尤其是在我们在语文学习中犯一些低级错误，或者她强调多遍的问题还是出错的时候。有时候还是挺怕她的。但是她也会经常因为我们哭，她觉得我们像她的孩子一</description>
<pubDate>Tue, 23 Jan 2018 15:38:00 +0000</pubDate>
<dc:creator>minchan0624</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minchan0624/p/8338384.html</dc:identifier>
</item>
</channel>
</rss>