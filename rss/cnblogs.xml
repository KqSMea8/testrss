<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>gulp菜鸟级零基础详细教程 - WEICHAO</title>
<link>http://www.cnblogs.com/weichao1996/p/8620652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weichao1996/p/8620652.html</guid>
<description>&lt;h4&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/h4&gt;
&lt;h4&gt;相信大家一定听说过gulp或者webpack，grunt等前端构建工具。gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 它能自动化地完成javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。&lt;/h4&gt;
&lt;p&gt;言归正传这篇是gulp菜鸟级别的教程。大佬们觉得太简单了请不要喷我，毕竟我也是一个菜鸟。写下这篇笔记，不是为了证明什么，就是方便我以后忘了时候回顾看一下。好，废话不多说 下面开始了&lt;br/&gt;&lt;strong&gt;1、node环境搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想要使用gulp，首先你得在你得电脑里面安装node.js，因为gulp是基于Nodejs的自动任务运行器。这个我就不详细介绍怎么安装了吧，网上教程一搜一大把。相信正在使用gulp的朋友，也知道怎么安装node.js&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2、使用命令行工具&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;开发的环境安装好了以后，接下来就是通过命令行来下载相应开发的模块包。什么是&lt;strong&gt;命令行&lt;/strong&gt;？命令行在OSX是终端（Terminal），在windows是命令提示符（Command Prompt）windows系统下　　WIN+R打开命令行工具，在里面输入cmd,回车。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149203/201803/1149203-20180321223608362-1685474386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、选装cnpm（淘宝镜像）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常.&lt;span class=&quot;iconfont&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;3.1、&lt;/strong&gt;官方网址：&lt;a href=&quot;http://npm.taobao.org/&quot; target=&quot;_blank&quot;&gt;http://npm.taobao.org&lt;/a&gt;；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;3.2、&lt;/strong&gt;安装：命令提示符执行&lt;span class=&quot;cmd&quot;&gt;&lt;code&gt;npm install cnpm -g --registry=https://registry.npm.taobao.org&lt;/code&gt;；  注意：安装完后最好查看其版本号&lt;span class=&quot;cmd&quot;&gt;cnpm -v或关闭命令提示符重写打开，安装完直接使用有可能会出现错误；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）。&lt;/p&gt;
&lt;h3 class=&quot;ti15&quot;&gt;&lt;strong&gt;4、全局安装gulp&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;4.1&lt;/strong&gt;、说明：全局安装gulp目的是为了通过她执行gulp任务；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;4.2&lt;/strong&gt;、安装：命令提示符执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
cnpm install gulp -g
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;4.3&lt;/strong&gt;、查看是否正确安装：命令提示符执行&lt;span class=&quot;cmd&quot;&gt;gulp -v，出现版本号即为正确安装。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;span class=&quot;cmd&quot;&gt;&lt;strong&gt;4.4&lt;/strong&gt;、依赖安装： npm install gulp --save-dev，这个可以在你的当前的项目目录下，打开命令行工具进行依赖安装。下面我们会在介绍packge.json文件当中介绍为什么需要依赖安装&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ti15&quot;&gt;&lt;strong&gt;&lt;span class=&quot;cmd&quot;&gt;5、&lt;/span&gt;新建package.json文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;5.1&lt;/strong&gt;、package.json文件是基于node.js项目必不可少的配置文件，它是存放在项目根目录的普通json文件，里面有你各个依赖安装模块插件的版本信息，以至于你能清楚看到你安装了那些模块。如下图我安装很多模块以后的json文件。&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149203/201803/1149203-20180321224904539-1582141182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.2、配置packge.json文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
npm init    //初始化packge.json文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ti15&quot;&gt; 注意：初始化packge.json文件必须在你项目的根目录下打开命令行工具，执行初始化代码。（怎么在当前目录下打开命令行工具？shift+右键。当然，win10系统的命令行工具被微软改版了，叫Powershell，作用还是一样）&lt;/p&gt;
&lt;h3 class=&quot;ti15&quot;&gt;&lt;strong&gt;6、新建gulpfile.js文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;ti15&quot;&gt;既然我们要使用gulp,我们就需要建立一个gulpfile.js文件，gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件。gulp的开发代码都写在这个里面的&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;&lt;strong&gt;js代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;67&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const  gulp=require('gulp');    &lt;span&gt;//引用gulp&lt;/span&gt;
const  del=require('del');      &lt;span&gt;//引用gulp删除插件&lt;/span&gt;
const  uglify=require('gulp-uglify');　　&lt;span&gt;//引用压缩Js插件&lt;/span&gt;
const  css=require('gulp-clean-css');　　&lt;span&gt;//gulp压缩css文件&lt;/span&gt;
const  rename = require(&quot;gulp-rename&quot;);　　&lt;span&gt;//引用重命名插件&lt;/span&gt;

gulp.task('hello',function () {     &lt;span&gt;//定义一个hello任务&lt;/span&gt;
    console.log('hello')
});

&lt;span&gt;//task()：定义任务
//src():源文件
// pipe():管道流，接通源头文件与目标文件的输出
// dest():输出文件的目的地
// watch():监视文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//事例：&lt;/span&gt;
&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 1、复制单个文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('copyHtml',function () {
    return gulp.src('./src/public/login.html').pipe(gulp.dest(&quot;dist/public&quot;))
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 2、复制多个文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('copyAllHtml',function () {
    return gulp.src(&quot;./src/public/*.html&quot;).pipe(gulp.dest('dist/public'));
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 3、复制指定文件&lt;/span&gt;
&lt;span&gt;// [指定的文件已，指定的文件2]&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('copy2Js',function () {
    return gulp.src([&quot;./src/public/js/ajax.js&quot;,'dist/public/js/classPage.js'])
    .pipe(gulp.dest(&quot;dist/public/js&quot;))
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 4、某个文件
// ！排队的文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task(&quot;copyNoJs&quot;,function () {
    return gulp.src(['./src/public/js/*.js','!./src/public/js/Classroom.js'])
        .pipe(gulp.dest('dist/public/js'))
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 5、复制多个后缀名的图片
// {选项一，选项二}&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task(&quot;copyImage&quot;,function () {
    return gulp.src('./src/public/img/*.{png,jpg,bmp,jpeg,gif}')
        .pipe(gulp.dest('dist/public/img'))
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 6、执行多个任务
// gulp.task('任务名称',[任务依赖的模块],回调函数)
// 依赖任务之间没有顺序之分，异步执行
// 依赖任务之间完成后，在执行当前的回调函数&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('build',['copyAllHtml','copyNoJs','copyImage'],function () {
    console.log('编译成功')
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 7、Watch:监视文件的变化&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('myWatch',function () {
    gulp.watch('./src/public/login.html',['build'])
});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 8、删除文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task(&quot;del&quot;,function () {
    // del('./dist/public/img/*.{jpg,png,jepg,gif}')
    // *：所有文件
    // **：所有文件夹
    del(['./dist/public/js/*']);
    del(['./dist/**/*']);
});

gulp.task('default',function () {
    gulp.start('serve')

});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;// 9、压缩js文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('ysjs',function(){
    return gulp.src('./src/public/js/*.js')
    .pipe(uglify())
    .pipe(gulp.dest('./src/public/js'));


});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;//10、 添加监听&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('watch_js',function(){
    return gulp.watch('./src/public/js/*.js',['ysjs'])

});

&lt;em&gt;&lt;strong&gt;&lt;span&gt;//11、压缩css文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('css',function () {
    return gulp.src('./src/public/sass/*.css')
        .pipe(css())
        .pipe(gulp.dest('./src/public/sass'))
});
&lt;em&gt;&lt;strong&gt;&lt;span&gt;//添加监听&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('jtCss',function () {
    return gulp.watch('./src/public/sass/*.css',['css'])
});
&lt;em&gt;&lt;strong&gt;&lt;span&gt;//12、重命名css文件&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
gulp.task('reName',function () {
    return gulp.src('./src/public/sass/*.css')
        .pipe(rename({suffix: '.css'}))
        .pipe(css())
        .pipe(gulp.dest('./src/public/sass'))
});　　
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;lesson9&quot;&gt;7、运行gulp&lt;/h3&gt;
&lt;p class=&quot;ti15&quot;&gt;7.1、说明：命令提示符执行&lt;span class=&quot;cmd&quot;&gt;gulp 任务名称；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;7.2、编译less：命令提示符执行&lt;span class=&quot;cmd&quot;&gt;gulp testLess；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;7.3、当执行&lt;span class=&quot;cmd&quot;&gt;gulp default或&lt;span class=&quot;cmd&quot;&gt;gulp将会调用default任务里的所有任务&lt;strong&gt;&lt;span&gt;[‘testLess’,’elseTask’]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;lesson10&quot;&gt;8、使用webstorm运行gulp任务&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149203/201803/1149203-20180321232448546-653084594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;9、使用vscode运行gulp任务&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;vcode是微软出的一款轻量级代码编辑器，免费而且功能强大，对JavaScript和NodeJS的支持非常好，自带很多功能，例如代码格式化，代码智能提示补全、Emmet插件等。&lt;/p&gt;
&lt;p&gt;在vscode上我们想要简单的运行gulp任务，我们可以下载一款名为“Gulp Tasks ”的插件。安装好插件以后，我们将项目文件添加到工作区当中，然后打开gulpfile.js文件。&lt;/p&gt;
&lt;p&gt;在左下角我们可以启动任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149203/201803/1149203-20180321233509707-2067950526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;10、总结：&lt;/h3&gt;
&lt;p class=&quot;ti15&quot;&gt;10.1、安装nodejs；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;10.2、新建package.json文件；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;10.3、全局和本地依赖安装gulp；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;10.4、安装gulp插件；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;10.5、新建gulpfile.js文件；&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt;10.6、通过命令提示符或者开发工具运行gulp任务。&lt;/p&gt;

&lt;p class=&quot;ti15&quot;&gt;&lt;span class=&quot;cmd&quot;&gt;&lt;span class=&quot;cmd&quot;&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ti15&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 15:37:00 +0000</pubDate>
<dc:creator>WEICHAO</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weichao1996/p/8620652.html</dc:identifier>
</item>
<item>
<title>Beego 框架学习(一) - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8620635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8620635.html</guid>
<description>&lt;p&gt; Beego官网本身已经整理的非常详细了，但是作为一个学习者，我还是决定自己好好整理一下，这样在后面使用的时候自己对每部分才能非常熟悉，即使忘记了，也可以迅速定位自己要用的知识在哪里。当然也是对官网的一个精简整理，同时结合一些例子，更好的理解和学习Beego&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;Beego官网地址：&lt;a href=&quot;https://beego.me&quot;&gt;https://beego.me&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这次整理也是一个初步的整理，正好在这个之后把之前通过net/http实现的短url项目通过beego框架实现一遍&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;Beego的安装&lt;/h2&gt;
&lt;p&gt;go get github.com/astaxie/beego&lt;/p&gt;
&lt;p&gt;bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署。&lt;/p&gt;
&lt;p&gt;go get github.com/beego/bee&lt;/p&gt;
&lt;p&gt;当我们安装好bee之后，bee命令默认是放在&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-1-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;G&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;O&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;P&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;A&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;T&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;H&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;/&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;i&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x91CC;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x9762;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#xFF0C;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x6240;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x4EE5;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x9700;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x8981;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x628A;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-3&quot; class=&quot;mi&quot;&gt;G&lt;span id=&quot;MathJax-Span-4&quot; class=&quot;mi&quot;&gt;O&lt;span id=&quot;MathJax-Span-5&quot; class=&quot;mi&quot;&gt;P&lt;span id=&quot;MathJax-Span-6&quot; class=&quot;mi&quot;&gt;A&lt;span id=&quot;MathJax-Span-7&quot; class=&quot;mi&quot;&gt;T&lt;span id=&quot;MathJax-Span-8&quot; class=&quot;mi&quot;&gt;H&lt;span id=&quot;MathJax-Span-9&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-10&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-11&quot; class=&quot;mo&quot;&gt;/&lt;span id=&quot;MathJax-Span-12&quot; class=&quot;mi&quot;&gt;b&lt;span id=&quot;MathJax-Span-13&quot; class=&quot;mi&quot;&gt;i&lt;span id=&quot;MathJax-Span-14&quot; class=&quot;mi&quot;&gt;n&lt;span id=&quot;MathJax-Span-15&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-16&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-17&quot; class=&quot;mo&quot;&gt;里&lt;span id=&quot;MathJax-Span-18&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-19&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-20&quot; class=&quot;mo&quot;&gt;面&lt;span id=&quot;MathJax-Span-21&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-22&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-23&quot; class=&quot;mo&quot;&gt;，&lt;span id=&quot;MathJax-Span-24&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-25&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-26&quot; class=&quot;mo&quot;&gt;所&lt;span id=&quot;MathJax-Span-27&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-28&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-29&quot; class=&quot;mo&quot;&gt;以&lt;span id=&quot;MathJax-Span-30&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-31&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-32&quot; class=&quot;mo&quot;&gt;需&lt;span id=&quot;MathJax-Span-33&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-34&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-35&quot; class=&quot;mo&quot;&gt;要&lt;span id=&quot;MathJax-Span-36&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-37&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-38&quot; class=&quot;mo&quot;&gt;把&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;GOPATH/bin里面，所以需要把GOPATH/bin 添加到您的环境变量中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;bee常用的命令&lt;/p&gt;
&lt;p&gt;bee new &amp;lt;项目名&amp;gt; ：创建一个项目,这样的项目一般是web项目&lt;br/&gt;需要注意的是这个命令须在 $GOPATH/src 下执行，最后生成的目录结构为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── conf
│   └── app.conf
├── controllers
│   └── default.go
├── main.go
├── models
├── routers
│   └── router.go
├── static
│   ├── css
│   ├── img
│   └── js
│       └── reload.min.js
├── tests
│   └── default_test.go
└── views
    └── index.tpl&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bee api myapi : 创建一个api项目，生成的目录结构为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── conf
│   └── app.conf
├── controllers
│   ├── object.go
│   └── user.go
├── main.go
├── models
│   ├── object.go
│   └── user.go
├── routers
│   └── router.go
└── tests
    └── default_test.go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bee run 命令是监控 beego 的项目，通过 fsnotify监控文件系统。但是注意该命令必须在 $GOPATH/src/appname 下执行。这样当我们在开发过程中，beego可以实时监测我们的代码文件发生变化，这样我们就不用重新编译运行，非常方便我们调试，我们可以将上面的myweb2项目通过bee run运行起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;localhost:myweb2 zhaofan$ go run
go run: no go files listed
localhost:myweb2 zhaofan$ bee run
______
&lt;/span&gt;|&lt;span&gt; ___ \
&lt;/span&gt;| |_/ /&lt;span&gt;  ___   ___
&lt;/span&gt;| ___ \ / _ \ /&lt;span&gt; _ \
&lt;/span&gt;| |_/ /|  __/|  __/&lt;span&gt;
\____&lt;/span&gt;/  \___| \___| v1.9.1
2018/03/19 23:59:20 INFO     ▶ 0001 Using 'myweb2' as 'appname'
2018/03/19 23:59:20 INFO     ▶ 0002&lt;span&gt; Initializing watcher...
myweb2&lt;/span&gt;/&lt;span&gt;controllers
myweb2&lt;/span&gt;/&lt;span&gt;routers
myweb2
&lt;/span&gt;2018/03/19 23:59:22 SUCCESS  ▶ 0003 Built Successfully!
2018/03/19 23:59:22 INFO     ▶ 0004 Restarting 'myweb2'&lt;span&gt;...
&lt;/span&gt;2018/03/19 23:59:22 SUCCESS  ▶ 0005 './myweb2'&lt;span&gt; is running...
&lt;/span&gt;2018/03/19 23:59:22.572 [I] [asm_amd64.s:2337] http server Running on http://:8080
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们通过打开浏览器访问：http://127.0.0.1:8080,可以看到如图：&lt;a href=&quot;http://127.0.0.1:8080,%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E5%9B%BE%EF%BC%9A&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180321232942204-1402119529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;Beego 架构了解&lt;/h2&gt;
&lt;p&gt;Beego架构图如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180321233004672-238888081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是Beegode 八大独立的模块&lt;/p&gt;
&lt;p&gt;Beego的执行逻辑，beego 是一个典型的 MVC 架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180321233021296-480972597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们从上面myweb2的目录接口也可以看出来：&lt;br/&gt;M（models 目录）、V（views 目录）和 C（controllers 目录）的结构&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;Beego路由设置&lt;/h2&gt;
&lt;p&gt;我们看一下Beego的入口函数：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    _ &lt;/span&gt;&quot;myweb2/routers&quot;
    &quot;github.com/astaxie/beego&quot;&lt;span&gt;
)

func main() {
    beego.Run()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引入了一个包 _ &quot;myweb2/routers 我们看一下这个包的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package routers

import (
    &lt;/span&gt;&quot;myweb2/controllers&quot;
    &quot;github.com/astaxie/beego&quot;&lt;span&gt;
)

func init() {
    beego.Router(&lt;/span&gt;&quot;/&quot;, &amp;amp;&lt;span&gt;controllers.MainController{})
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里仅仅做了一个初始化，路由包里面我们看到执行了路由注册 beego.Router, 这个函数的功能是映射 URL 到 controller，第一个参数是 URL (用户请求的地址)，这里我们注册的是 /，也就是我们访问的不带任何参数的 URL，第二个参数是对应的 Controller，也就是我们即将把请求分发到那个控制器来执行相应的逻辑。这里对路由设置的一个小结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Router方法设置url和处理url的controller&lt;/li&gt;
&lt;li&gt;程序启动时，路由配置加载好，保存在map中&lt;/li&gt;
&lt;li&gt;请求处理时，通过请求的url进行查找对应的controller,把处理路由到controller进行执行&lt;/li&gt;
&lt;li&gt;我们就只需要编写自己的controller就好啦&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们看一下controller的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package controllers

import (
    &lt;/span&gt;&quot;github.com/astaxie/beego&quot;&lt;span&gt;
)

type MainController struct {
    beego.Controller  &lt;/span&gt;//&lt;span&gt; 这里可以看做是其他语言中的继承
}

func (c &lt;/span&gt;*&lt;span&gt;MainController) Get() {
    c.Data[&lt;/span&gt;&quot;Website&quot;] = &quot;beego.me&quot;&lt;span&gt;
    c.Data[&lt;/span&gt;&quot;Email&quot;] = &quot;astaxie@gmail.com&quot;&lt;span&gt;
    c.TplName &lt;/span&gt;= &quot;index.tpl&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对上述代码进行简单分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户的controller嵌套bee.Controller， 继承bee.Controller所有属性和&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;li&gt;Controller默认使用restful的风格，Get请求对应Get方法&lt;/li&gt;
&lt;li&gt;请求处理时，通过请求的url进行查找对应的controller，把处理路由到 controller进行执行&lt;/li&gt;
&lt;li&gt;通过业务逻辑处理之后，把数据赋值给Controller.Data这个map即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述代码中：c.TplName = &quot;index.tpl&quot;默认回去views下面去找模板文件&lt;br/&gt;除了上面的C.Data这种方法之外，还有很多方法，如常用的c.ServerJson()这样就会去c.Data中寻找key为json的值&lt;/p&gt;
&lt;p&gt;用户设置了模板之后系统会自动的调用 Render 函数（这个函数是在 beego.Controller 中实现的），所以无需用户自己来调用渲染。&lt;/p&gt;
&lt;p&gt;当然也可以不使用模版，直接用 this.Ctx.WriteString 输出字符串，如：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
func (c *&lt;span&gt;MainController) Get() {
        c.Ctx.WriteString(&lt;/span&gt;&quot;hello&quot;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正则路由&lt;br/&gt;beego.Router(“/api/?:id”, &amp;amp;controllers.RController{}) 默认匹配 //匹配 /api/123 :id = 123 可以匹配 /api/ 这个URL&lt;/p&gt;
&lt;p&gt;beego.Router(“/api/:id”, &amp;amp;controllers.RController{}) 默认匹配 //匹配 /api/123 :id = 123 不可以匹配 /api/ 这个URL&lt;/p&gt;
&lt;p&gt;beego.Router(“/api/:id([0-9]+)“, &amp;amp;controllers.RController{}) 自定义正则匹配 //匹配 /api/123 :id = 123&lt;/p&gt;
&lt;p&gt;beego.Router(“/user/:username([\w]+)“, &amp;amp;controllers.RController{}) 正则字符串匹配 //匹配 /user/astaxie :username = astaxie&lt;/p&gt;
&lt;p&gt;beego.Router(“/download/*.*”, &amp;amp;controllers.RController{}) *匹配方式 //匹配 /download/file/api.xml :path= file/api :ext=xml&lt;/p&gt;
&lt;p&gt;beego.Router(“/download/ceshi/*“, &amp;amp;controllers.RController{}) *全匹配方式 //匹配 /download/ceshi/file/api.json :splat=file/api.json&lt;/p&gt;
&lt;p&gt;beego.Router(“/:id:int”, &amp;amp;controllers.RController{}) int 类型设置方式，匹配 :id为int 类型，框架帮你实现了正则 ([0-9]+)&lt;/p&gt;
&lt;p&gt;beego.Router(“/:hi:string”, &amp;amp;controllers.RController{}) string 类型设置方式，匹配 :hi 为 string 类型。框架帮你实现了正则 ([\w]+)&lt;/p&gt;
&lt;p&gt;beego.Router(“/cms_:id([0-9]+).html”, &amp;amp;controllers.CmsController{}) 带有前缀的自定义正则 //匹配 :id 为正则类型。匹配 cms_123.html 这样的 url :id = 123&lt;/p&gt;
&lt;p&gt;可以在 Controller 中通过如下方式获取上面的变量：&lt;br/&gt;this.Ctx.Input.Param(&quot;:id&quot;)&lt;br/&gt;this.Ctx.Input.Param(&quot;:username&quot;)&lt;br/&gt;this.Ctx.Input.Param(&quot;:splat&quot;)&lt;br/&gt;this.Ctx.Input.Param(&quot;:path&quot;)&lt;br/&gt;this.Ctx.Input.Param(&quot;:ext&quot;)&lt;/p&gt;
&lt;p&gt;自定义方法及 RESTful 规则:&lt;br/&gt;beego.Router(&quot;/&quot;,&amp;amp;IndexController{},&quot;*:Index&quot;)&lt;br/&gt;使用第三个参数，第三个参数就是用来设置对应 method 到函数名，定义如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;*表示任意的 method 都执行该函数&lt;/li&gt;
&lt;li&gt;使用 httpmethod:funcname 格式来展示&lt;/li&gt;
&lt;li&gt;多个不同的格式使用 ; 分割&lt;/li&gt;
&lt;li&gt;多个 method 对应同一个 funcname，method 之间通过 , 来分割&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;beego.Router(&quot;/api&quot;,&amp;amp;RestController{},&quot;get,post:ApiFunc&quot;)&lt;/p&gt;
&lt;p&gt;可用的 HTTP Method：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;*: 包含以下所有的函数&lt;/li&gt;
&lt;li&gt;get: GET 请求&lt;/li&gt;
&lt;li&gt;post: POST 请求&lt;/li&gt;
&lt;li&gt;put: PUT 请求&lt;/li&gt;
&lt;li&gt;delete: DELETE 请求&lt;/li&gt;
&lt;li&gt;patch: PATCH 请求&lt;/li&gt;
&lt;li&gt;options: OPTIONS 请求&lt;/li&gt;
&lt;li&gt;head: HEAD 请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果同时存在 * 和对应的 HTTP Method，那么优先执行 HTTP Method 的方法&lt;/p&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;Beego的model&lt;/h2&gt;
&lt;p&gt;我们知道 Web 应用中我们用的最多的就是数据库操作，而 model 层一般用来做这些操作，我们的 bee new 例子不存在 Model 的演示，但是 bee api 应用中存在 model 的应用。说的简单一点，如果您的应用足够简单，那么 Controller 可以处理一切的逻辑，如果您的逻辑里面存在着可以复用的东西，那么就抽取出来变成一个模块。因此 Model 就是逐步抽象的过程，&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;Beego的views层&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Beego模板默认支持:.tpl和.html两种后缀&lt;/li&gt;
&lt;li&gt;beego.AddTemplateExt增加新的模板后缀&lt;/li&gt;
&lt;li&gt;Beego模板用的就是Go官网自带的模板&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_6&quot;&gt;静态文件&lt;/h2&gt;
&lt;p&gt;beego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在/main.go文件中beego.Run()之前加入）：StaticDir[&quot;/static&quot;] = &quot;static&quot;&lt;/p&gt;
&lt;p&gt;Beego默认使用static目录作为静态文件目录&lt;br/&gt;beego.SetStaticPath增加新的静态文件目录&lt;/p&gt;
&lt;h2 id=&quot;toc_7&quot;&gt;配置文件读取&lt;/h2&gt;
&lt;p&gt;默认的配置文件内容：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
appname =&lt;span&gt; myweb2
httpport &lt;/span&gt;= 8080&lt;span&gt;
runmode &lt;/span&gt;= dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然前提是你已经在自己配置文件中添加了下面这些字段：&lt;br/&gt;beego.AppConfig.String(&quot;mysql_user&quot;)&lt;br/&gt;beego.AppConfig.String(&quot;mysql_pwd&quot;)&lt;/p&gt;
&lt;p&gt;如果我们将配置文件更改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
appname =&lt;span&gt; myweb2
httpport &lt;/span&gt;= 8080&lt;span&gt;
runmode &lt;/span&gt;=&lt;span&gt; dev

[dbconfig]
mysqlhost &lt;/span&gt;= 127.0.0.1&lt;span&gt;
mysqlport &lt;/span&gt;= 3308&lt;span&gt;
username &lt;/span&gt;=&lt;span&gt; root
passwd &lt;/span&gt;= 123
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以通过[命名]的方式将配置文件进行分组&lt;br/&gt;这样当我们获取变量的时候，可以通过下面方式获取：&lt;/p&gt;
&lt;p&gt;beego.AppConfig.String(&quot;dbconfig::mysql_user&quot;)&lt;br/&gt;beego.AppConfig.String(&quot;dbconfig::mysql_port&quot;)&lt;/p&gt;
&lt;p&gt;AppConfig 的方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Set(key, val string) error
String(key string) string
Strings(key string) []string
Int(key string) (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;, error)
Int64(key string) (int64, error)
Bool(key string) (bool, error)
Float(key string) (float64, error)
DefaultString(key string, defaultVal string) string
DefaultStrings(key string, defaultVal []string)
DefaultInt(key string, defaultVal &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt;
DefaultInt64(key string, defaultVal int64) int64
DefaultBool(key string, defaultVal bool) bool
DefaultFloat(key string, defaultVal float64) float64
DIY(key string) (interface{}, error)
GetSection(section string) (map[string]string, error)
SaveConfigFile(filename string) error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_8&quot;&gt;获取用户提交的参数&lt;/h2&gt;
&lt;p&gt;Controller中的方法获取&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GetString(key string) string&lt;/li&gt;
&lt;li&gt;GetStrings(key string) []string&lt;/li&gt;
&lt;li&gt;GetInt(key string) (int64, error)&lt;/li&gt;
&lt;li&gt;GetBool(key string) (bool, error)&lt;/li&gt;
&lt;li&gt;GetFloat(key string) (float64, error)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不管是post还是get的其他方式提交的数据都可以通过上面的方式获取&lt;/p&gt;
&lt;p&gt;如果在平常开发中肯定设计到和其他语言的对接数据，这个时候对方发过来的数据可能就是一个json格式的数据，如果想要获取可以通过下面方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接通过Ctx.Input.RequestBody获取原始的数据&lt;/li&gt;
&lt;li&gt;配置文件里设置 copyrequestbody = true&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样就可以通过c.Ctx.Input.RequestBody 获取&lt;/p&gt;

</description>
<pubDate>Wed, 21 Mar 2018 15:35:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8620635.html</dc:identifier>
</item>
<item>
<title>NEO从入门到开窗(2) - 智能合约的面相 - Dexter Di</title>
<link>http://www.cnblogs.com/DexterDi/p/8620589.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DexterDi/p/8620589.html</guid>
<description>&lt;p&gt;一、啰嗦两句&lt;/p&gt;
&lt;p&gt;昨天讲了智能合约的一生，那丫长啥样啊？今儿我就跟各位唠叨唠叨。&lt;/p&gt;

&lt;p&gt;二、一个简单的智能合约&lt;/p&gt;
&lt;p&gt;下面这段就是NEO实例源码里的一个，干撒用的？聪明的你一眼儿就看出来了吧，就是一个所谓域名合约的增删改查。有几点我唠叨两句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Neo.SmartContract.Framework.Services.Neo;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Neo.SmartContract
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Domain : Framework.SmartContract
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt; operation, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (operation)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Query((&lt;span&gt;string&lt;/span&gt;)args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;register&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Register((&lt;span&gt;string&lt;/span&gt;)args[&lt;span&gt;0&lt;/span&gt;], (&lt;span&gt;byte&lt;/span&gt;[])args[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;transfer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Transfer((&lt;span&gt;string&lt;/span&gt;)args[&lt;span&gt;0&lt;/span&gt;], (&lt;span&gt;byte&lt;/span&gt;[])args[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Delete((&lt;span&gt;string&lt;/span&gt;)args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] Query(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; domain)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Storage.Get(Storage.CurrentContext, domain);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Register(&lt;span&gt;string&lt;/span&gt; domain, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] owner)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Runtime.CheckWitness(owner)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] value =&lt;span&gt; Storage.Get(Storage.CurrentContext, domain);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Storage.Put(Storage.CurrentContext, domain, owner);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Transfer(&lt;span&gt;string&lt;/span&gt; domain, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] to)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Runtime.CheckWitness(to)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] &lt;span&gt;from&lt;/span&gt; =&lt;span&gt; Storage.Get(Storage.CurrentContext, domain);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;from&lt;/span&gt; == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Runtime.CheckWitness(&lt;span&gt;from&lt;/span&gt;)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Storage.Put(Storage.CurrentContext, domain, to);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Delete(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; domain)
        {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] owner =&lt;span&gt; Storage.Get(Storage.CurrentContext, domain);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (owner == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Runtime.CheckWitness(owner)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Storage.Delete(Storage.CurrentContext, domain);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1. 上一节讲了，一个智能合约就是继承自SmartContract的类，Main函数啊，方法啊，全得是静态的，因为NEO的编译器就认静态的。&lt;/p&gt;
&lt;p&gt;2. Main就是智能合约的入口，调用的时候会穿些参数，第一个就是opeartion，根据这个来判断是啥操作，这点和Fabric很像，就一个init一个invoke，Etherenum不是这样的。&lt;/p&gt;
&lt;p&gt;3. 逻辑都能看明白，这个Storage是个啥玩意，看上去像个存储，在哪存储？这不就是serverless吗？ok，咱就以此为突破，重点关注一下这个Storage。&lt;/p&gt;
&lt;p&gt;源码说话。这个Storage是NEO工具包（SmartContract那个类一个项目下的）里的一个类，我们看下源码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Numerics;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Neo.SmartContract.Framework.Services.Neo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Storage
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt;&lt;span&gt; StorageContext CurrentContext
        {
            [Syscall(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Neo.Storage.GetContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;
        }

        [Syscall(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Neo.Storage.Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] Get(StorageContext context, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] key);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我把其他方法都删了，留一个Get方法，示意一下。看到这，是不是有点懵逼，SysCall什么鬼，这种写法是不是似曾相识？是不是和dllimport差不多？其实我琢磨着作者写的时候也有这么个意图，就说啊，这是一系统调用啊，调用咱系统的东西。那到底这玩意儿咋个原理，咱们就得看NEO的编译器源码了。上一节咱提了，NEO的编译器就是根据规则把对应的代码翻译成指令码，编译器这部分咱后面也要说，找源码的过程比较琐碎，不贴代码了，这里先理解成编译器把他编译成OpCode.SYSCALL Neo.Storage.Get，就是系统调用Neo.Storage.Get。下面的问题就是NEO的虚拟机该怎么解释这个指令了，我们再去NEO.VM项目里找结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span readability=&quot;2&quot;&gt;private readonly InteropService service;&lt;p&gt;　　　　　　　　　　　　case&lt;/p&gt;&lt;/span&gt;&lt;span&gt; OpCode.SYSCALL:
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!service.Invoke(Encoding.ASCII.GetString(context.OpReader.ReadVarBytes(&lt;span&gt;252&lt;/span&gt;)), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;))
                            State &lt;/span&gt;|=&lt;span&gt; VMState.FAULT;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看看Interopservice里Invoke都干了些啥，也是删除了部分代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Neo.VM
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InteropService
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Func&amp;lt;ExecutionEngine, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; dictionary = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Func&amp;lt;ExecutionEngine, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InteropService()
        {
            Register(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.ExecutionEngine.GetScriptContainer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetScriptContainer);
            Register(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.ExecutionEngine.GetExecutingScriptHash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetExecutingScriptHash);
            Register(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.ExecutionEngine.GetCallingScriptHash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetCallingScriptHash);
            Register(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.ExecutionEngine.GetEntryScriptHash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetEntryScriptHash);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Register(&lt;span&gt;string&lt;/span&gt; method, Func&amp;lt;ExecutionEngine, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; handler)
        {
            dictionary[method] &lt;/span&gt;=&lt;span&gt; handler;
        }

        &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Invoke(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; method, ExecutionEngine engine)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!dictionary.ContainsKey(method)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dictionary[method](engine);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来InteropService里保留了一个字段，根据不同的方法名，注册不同的执行方法，我们要找的Neo.Storage.Get这个方法key是在那里注册的呢？搜。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Neo.SmartContract
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StateReader : InteropService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; EventHandler&amp;lt;NotifyEventArgs&amp;gt;&lt;span&gt; Notify;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; EventHandler&amp;lt;LogEventArgs&amp;gt;&lt;span&gt; Log;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; StateReader Default = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StateReader();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StateReader()
        {
            Register(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Neo.Storage.Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Storage_Get);
        }

       &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Storage_Get(ExecutionEngine engine)
        {
            StorageContext context &lt;/span&gt;= engine.EvaluationStack.Pop().GetInterface&amp;lt;StorageContext&amp;gt;&lt;span&gt;();
            ContractState contract &lt;/span&gt;=&lt;span&gt; Blockchain.Default.GetContract(context.ScriptHash);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (contract == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!contract.HasStorage) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] key =&lt;span&gt; engine.EvaluationStack.Pop().GetByteArray();
            StorageItem item &lt;/span&gt;= Blockchain.Default.GetStorageItem(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StorageKey
            {
                ScriptHash &lt;/span&gt;=&lt;span&gt; context.ScriptHash,
                Key &lt;/span&gt;=&lt;span&gt; key
            });
            engine.EvaluationStack.Push(item&lt;/span&gt;?.Value ?? &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到Blockchain.Default.GetstorageItem()这个方法了吧，虚拟机执行器把链上的数据取出来了，这个Blockchain的实现是leveldb这个咱也后面再讲。&lt;/p&gt;
&lt;p&gt;好啦，到现在这一圈可以理解智能合约的执行过程了吧。聪明的你也一定发现了，你看的懂的那些逻辑，也会被NEO的编译器编译成指令码，这部分就复杂咯，后面咱们讲编译器的时候详细的说，编译器这块还是挺复杂的，面向代码作者拜一拜。。。&lt;/p&gt;

&lt;p&gt;三、小结&lt;/p&gt;
&lt;p&gt;智能合约好写，很容易理解，但是从头撸到底才能透彻的知道了解它的运行原理，撸的过程略过了很多东西，聪明的你一定很好奇吧，别着急，咱们下回书，再说。&lt;/p&gt;

</description>
<pubDate>Wed, 21 Mar 2018 15:28:00 +0000</pubDate>
<dc:creator>Dexter Di</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DexterDi/p/8620589.html</dc:identifier>
</item>
<item>
<title>线程池ThreadPoolExecutor源码解读研究（JDK1.8） - 我心自在</title>
<link>http://www.cnblogs.com/10158wsj/p/8620200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/10158wsj/p/8620200.html</guid>
<description>&lt;h2&gt;一、什么是线程池&lt;/h2&gt;
&lt;p&gt;       为什么要使用线程池？在多线程并发开发中，线程的数量较多，且每个线程执行一定的时间后就结束了，下一个线程任务到来还需要重新创建线程，这样线程数量特别庞大的时候，频繁的创建线程和销毁线程需要一定时间而且增加系统的额外开销。基于这样的场景，线程池就出现了，线程池可以做到一个线程的任务处理完可以接受下一个任务，并不需要频繁的创建销毁，这样大大节省了时间和系统的开销。&lt;/p&gt;
&lt;p&gt;         线程池，顾名思义，就是一个池子，任务提交的到线程池后，线程池会在池子里边找有没有空闲的线程，如果没有，就会进入等待状态，有就会分配一个空闲的线程来接受这个任务，当服务执行完，从新放回到线程池，不需要销毁。在这种模式下，系统大大减少了创建线程个销毁线程的资源开销，而且一个线程可以用来执行多个任务，我们可以根据系统的配置灵活调整线程池的大小，从而更高效的执行任务。&lt;/p&gt;
&lt;h2&gt;二、线程池类之间关系&lt;/h2&gt;
&lt;p&gt;       线程池主要包含：Executors，Executor，ExecutorService，AbstractExecutorService，ThreadPoolExecutor这些类。Executors用来创建线程池，返回ExecutorService的对象，该对象就可以调用execute方法或者submit方法执行线程。当然，我们也可以自己new一个。&lt;/p&gt;
&lt;p&gt;Executor，ExecutorService，AbstractExecutorService，ThreadPoolExecutor的继承关系的继承关系为：Executor是一个接口，里面只有execute方法声明，接口ExecutorService继承Executor接口，里面包含shutdown()，shutdownNow()，isTerminated()，submit等方法; AbstractExecutorService是ExecutorService的实现类，实现了该类中的方法，ThreadPoolExecutor继承AbstractExecutorService。&lt;/p&gt;
&lt;h2&gt;三、线程池状态说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;RUNNING&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;可以接受新任务，也可以处理阻塞队列里面的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SHUTDOWN&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;不接受新任务，但是可以处理阻塞队列里的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STOP&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;不在接收新任务，也不再处理阻塞队列里的任务，并中断正在处理的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIDYING&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;中间状态：线程池中没有有效的线程，调用terminate进入TERMINATE状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TERMINATE：&lt;/strong&gt;终止状态&lt;/p&gt;
&lt;h2&gt;四、线程池源码分析&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ExecutorService  executor = Executors.newFixedThreadPool(100);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过API我们可以看到创建线程池的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService newFixedThreadPool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(nThreads, nThreads,
                                      &lt;/span&gt;0L&lt;span&gt;, TimeUnit.MILLISECONDS,
                                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Executors这个类中基本都是静态方法，代理了线程池的创建，大大简化了我么创建线程池工作量，通过方法名我们就可以创建我们想要的线程池，他的内部其实都是统一的方法实现的，通过构造方法重载实现不同的功能，但是不看源码，是很难知道他们的具体作用的。我们可以看到，这里面有好几种创建线程池的方法，他们有什么区别呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. newFixedThreadPool(int)&lt;/strong&gt;方法,内部实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建指定大小的线程池，如果超出大小，放入block队列，即LinkedBlockingQueue队列，默认的线程工厂为defaultThreadFactory。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. newWorkStealingPool(int)，&lt;/strong&gt;内部实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService newWorkStealingPool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; parallelism) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ForkJoinPool
            (parallelism,
             ForkJoinPool.defaultForkJoinWorkerThreadFactory,
             &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JDK1.8新增，返回ForkJoin，个人感觉有一点mapReduce的思想。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.newSingleThreadPool&lt;/strong&gt;，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newSingleThreadExecutor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FinalizableDelegatedExecutorService
            (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 1&lt;span&gt;,
                                    &lt;/span&gt;0L&lt;span&gt;, TimeUnit.MILLISECONDS,
                                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建单个线程的线程池。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. newCachedThreadPool&lt;/strong&gt;，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newCachedThreadPool() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(0&lt;span&gt;, Integer.MAX_VALUE,
                                      &lt;/span&gt;60L&lt;span&gt;, TimeUnit.SECONDS,
                                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;线程池长度超过处理需要，灵活回收空闲线程，若无可回收，则创建新线程。&lt;/p&gt;
&lt;p&gt;        Executors里面还有好多方法，我们仔细查看API就可以了解的个大概，它是一个工具类，提供了一些静态方法。从源码中我们可以看到创建线程池返回的是return new ThreadPoolExecutor方法，它的源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_994d3cd4-f80f-45cf-9d38-b04d517f506e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_994d3cd4-f80f-45cf-9d38-b04d517f506e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_994d3cd4-f80f-45cf-9d38-b04d517f506e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
                              &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
                              &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (corePoolSize &amp;lt; 0 ||&lt;span&gt;
            maximumPoolSize &lt;/span&gt;&amp;lt;= 0 ||&lt;span&gt;
            maximumPoolSize &lt;/span&gt;&amp;lt; corePoolSize ||&lt;span&gt;
            keepAliveTime &lt;/span&gt;&amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workQueue == &lt;span&gt;null&lt;/span&gt; || threadFactory == &lt;span&gt;null&lt;/span&gt; || handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.corePoolSize =&lt;span&gt; corePoolSize;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maximumPoolSize =&lt;span&gt; maximumPoolSize;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.workQueue =&lt;span&gt; workQueue;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.keepAliveTime =&lt;span&gt; unit.toNanos(keepAliveTime);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.threadFactory =&lt;span&gt; threadFactory;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handler =&lt;span&gt; handler;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;        刚看源码的时候的确很痛苦，我们得熟悉作者的思想，他为什么要这么写，知道了作者的思想以后就好办多了，我是结合英文说明来揣摩的，下面我们看每个参数的意思。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;corePoolSize&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;核心线程大小，线程数一旦超过这个值，多余的就会被放入等待队列&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;maximumPoolSize&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;线程池中的最大线程数量，这个一般用不到，源码中可以看到corePoolSize和maximumPoolSize是一样的，不同的是大于这个值会由丢弃处理机制来处理，不会被放入等待队列。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;keepAliveTime&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;保持时间，当线程没有任务处理后，保持多久结束，默认是0&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;workQueue&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;等待队列，默认为LinkedBlockingQueue，这就是前面提到的等待队列，里面是一个HashSet，内部包装了一层。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;threadFactory&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;构造Thread方法，我们可以自己包装和传递，实现newThread方法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;handler&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;这就是前面提到的丢弃处理机制方法，实现接口RejectExecutionHandler中的方法即可。&lt;/p&gt;
&lt;p&gt;在做项目的时候发现线程池有两个执行方法可供调用，分别是execute和submit，那么这两个方法有什么区别呢？在看submit源码的时候可以看到submit最终还是会调用execute方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1153367/201803/1153367-20180321222544158-494558207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;不同的是submit方法提供了一个Future来托管返回值的处理，当调用这个方法需要有返回值的时候，可以用这个方法，execute只能接受Runnable作为参数，而submit除了Runnable还可以接收Callable。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下面来分析最重要的execute方法源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_f068fca8-a503-4a08-9268-598523556c57&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f068fca8-a503-4a08-9268-598523556c57&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f068fca8-a503-4a08-9268-598523556c57&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(Runnable command) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (command == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         * Proceed in 3 steps:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;         * 1. If fewer than corePoolSize threads are running, try to
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;         * start a new thread with the given command as its first
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;         * task.  The call to addWorker atomically checks runState and
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;         * workerCount, and so prevents false alarms that would add
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;         * threads when it shouldn't, by returning false.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;         * 2. If a task can be successfully queued, then we still need
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;         * to double-check whether we should have added a thread
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         * (because existing ones died since last checking) or that
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;         * the pool shut down since entry into this method. So we
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;         * recheck state and if necessary roll back the enqueuing if
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;         * stopped, or start a new thread if there are none.
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;         * 3. If we cannot queue task, then we try to add a new
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;         * thread.  If it fails, we know we are shut down or saturated
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;         * and so reject the task.
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt;&lt;span&gt; corePoolSize) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (addWorker(command, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             c =&lt;span&gt; ctl.get();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp;&lt;span&gt; workQueue.offer(command)) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; recheck =&lt;span&gt; ctl.get();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (! isRunning(recheck) &amp;amp;&amp;amp;&lt;span&gt; remove(command))
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                reject(command);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (workerCountOf(recheck) == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 addWorker(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!addWorker(command, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            reject(command);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;代码解释：如果任务为空，返回空异常；接下来int c = ctl.get();获取线程池的状态位，进入if中计算线程池的数量，如果小于线程池的核心线程数，就封装成一个工作（work），失败了继续获取线程池状态位；if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command))判断线程池是否正常运行，正常的话就把当前线程添加到工作队列并且再次获取线程池状态位，if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))如果没有运行的线程了，就把刚才添加的线程移除，移除成功后，使用拒绝策略reject(command); else if (workerCountOf(recheck) == 0)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                addWorker(null, false);如果线程池的线程数为0，那么就要添加一个空任务继续运行，以此来保证可以继续接收新任务而继续运行。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;else if (!addWorker(command, false))&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            reject(command);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果核心线程满了，工作队列也饱和了，开启非核心线程也失败了就会拒绝，此时已经达到最大线程数了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;从英文解释中，我们可以看到：基本分三步：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;a)       开启线程执行任务，直到达到最大核心线程数&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;b)      达到核心线程数时，将接受的新任务放入工作队列&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;c)       当工作队列也放满后，就会开启线程（非核心）执行任务，直到到达最大线程数&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;d)      以上条件都不满足时，就执行默认的拒绝策略&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;addWork源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_e39d2654-3fd2-4d34-84df-30a5d5be309a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e39d2654-3fd2-4d34-84df-30a5d5be309a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e39d2654-3fd2-4d34-84df-30a5d5be309a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addWorker(Runnable firstTask, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; core) {
        retry: &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环标志&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) { 死循环
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c = ctl.get();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取状态位&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; rs = runStateOf(c);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算线程池的状态

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if queue empty only if necessary.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
                ! (rs == SHUTDOWN &amp;amp;&amp;amp;&lt;span&gt;
                   firstTask &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
                   !&lt;span&gt; workQueue.isEmpty()))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一段说的是线程池不能正常运行的情况：线程池状态关闭、任务为空、队列为空返回错误&lt;/span&gt;

            &lt;span&gt;for&lt;/span&gt; (;;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;死循环&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; wc = workerCountOf(c);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算线程数&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (wc &amp;gt;= CAPACITY ||&lt;span&gt;
                    wc &lt;/span&gt;&amp;gt;= (core ?&lt;span&gt; corePoolSize : maximumPoolSize))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果线程数超出核心线程数，返回错误&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (compareAndIncrementWorkerCount(c))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加worker的数量&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt; retry;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回到进入该方法的循环状态&lt;/span&gt;
                c = ctl.get();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Re-read ctl&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (runStateOf(c) !=&lt;span&gt; rs)
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt; retry;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果状态发生改变，就回退
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else CAS failed due to workerCount change; retry inner loop&lt;/span&gt;
&lt;span&gt;            }
        }

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; workerStarted = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程是否开始运行&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; workerAdded = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;worker是否添加成功&lt;/span&gt;
        Worker w = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            w &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Worker(firstTask);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装成worker&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; Thread t =&lt;span&gt; w.thread;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;.mainLock;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加锁&lt;/span&gt;
&lt;span&gt;                mainLock.lock();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Recheck while holding lock.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Back out on ThreadFactory failure or if
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; shut down before lock acquired.&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(ctl.get());计算线程池状态

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rs &amp;lt; SHUTDOWN ||&lt;span&gt;
                        (rs &lt;/span&gt;== SHUTDOWN &amp;amp;&amp;amp; firstTask == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.isAlive()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; precheck that t is startable&lt;/span&gt;
                            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalThreadStateException();
                        workers.add(w);
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; workers.size();
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; largestPoolSize)
                            largestPoolSize &lt;/span&gt;=&lt;span&gt; s;
                        workerAdded &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;worker添加成功&lt;/span&gt;
&lt;span&gt;                    }
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    mainLock.unlock();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (workerAdded) {
                    t.start();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动刚刚添加的任务&lt;/span&gt;
                    workerStarted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt; workerStarted)
                addWorkerFailed(w);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;失败后执行的操作&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; workerStarted;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;从对源码的翻译中我们可以知道这个方法是有什么作用，简单说就是：创建任务，封装任务。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;五、线程测试&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;进行一个简单的测试模拟线程池的工作原理：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;模拟多线程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_4ad98431-c598-40ed-a21f-52cdd4005d62&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4ad98431-c598-40ed-a21f-52cdd4005d62&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4ad98431-c598-40ed-a21f-52cdd4005d62&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestThreadPool &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_e0018a4d-9e0f-4f9c-8c32-447bbf98b0ae&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e0018a4d-9e0f-4f9c-8c32-447bbf98b0ae&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e0018a4d-9e0f-4f9c-8c32-447bbf98b0ae&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定3个长度的工作队列&lt;/span&gt;
        LinkedBlockingDeque&amp;lt;Runnable&amp;gt; workQueue=&lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;(3&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定线程池参数：核心线程数，线程池最大线程数量，活跃时间，工作队列&lt;/span&gt;
        ThreadPoolExecutor threadPoolExecutor=&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(4, 7, 90&lt;span&gt;, 
                TimeUnit.SECONDS, workQueue);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 15; i++&lt;span&gt;) {
            threadPoolExecutor.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestThreadPool(), 
                    &lt;/span&gt;&quot;线程:&quot;.concat(i+&quot;&quot;&lt;span&gt;)));
            System.out.println(&lt;/span&gt;&quot;线程池中活跃线程数&quot;+&lt;span&gt;threadPoolExecutor.getActiveCount());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(workQueue.size()&amp;gt;0&lt;span&gt;){
                System.out.println(&lt;/span&gt;&quot;被阻塞的线程数为：&quot;+&lt;span&gt;workQueue.size());
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;指定线程池核心数为4，最大线程数量7，工作队列最大放入3个线程，模拟15个线程并发。运行结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_4b39003e-10f1-4105-99bc-060bf7364cdf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4b39003e-10f1-4105-99bc-060bf7364cdf&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4b39003e-10f1-4105-99bc-060bf7364cdf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;线程池中活跃线程数1
线程池中活跃线程数2
线程池中活跃线程数3
线程池中活跃线程数4
线程池中活跃线程数4
被阻塞的线程数为：&lt;/span&gt;1&lt;span&gt;
线程池中活跃线程数4
被阻塞的线程数为：&lt;/span&gt;2&lt;span&gt;
线程池中活跃线程数4
被阻塞的线程数为：&lt;/span&gt;3&lt;span&gt;
线程池中活跃线程数5
被阻塞的线程数为：&lt;/span&gt;3&lt;span&gt;
线程池中活跃线程数6
被阻塞的线程数为：&lt;/span&gt;3&lt;span&gt;
线程池中活跃线程数7
被阻塞的线程数为：&lt;/span&gt;3&lt;span&gt;
Exception in thread &lt;/span&gt;&quot;main&quot; java.util.concurrent.RejectedExecutionException: Task Thread[线程:10,5,main] rejected from java.util.concurrent.ThreadPoolExecutor@42a57993[Running, pool size = 7, active threads = 7, queued tasks = 3, completed tasks = 0&lt;span&gt;]
    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:&lt;/span&gt;2047&lt;span&gt;)
    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:&lt;/span&gt;823&lt;span&gt;)
    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:&lt;/span&gt;1369&lt;span&gt;)
    at main.Main.main(Main.java:&lt;/span&gt;19)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;        可以看到，创建了4个核心线程和3个非核心线程，当线程数超出了线程池可容纳的的最大数量，执行了拒绝策略Reject，说明队列和线程池都满了，线程池处于饱和状态，另外一个原因是完成的线程没有及时释放，而是进入了休眠。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        线程池工作原理：任务开始后，开始创建新的线程，当达到核心线程数后，新的任务进来不在创建新的线程，这时候把任务加入工作队列，当达到工作队列的长度后，新任务开始创建新的普通线程，直到数量达到线程池的最大核心数量，后面再有新任务则执行饱和策略或拒绝，抛出异常。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 14:37:00 +0000</pubDate>
<dc:creator>我心自在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/10158wsj/p/8620200.html</dc:identifier>
</item>
<item>
<title>阅读好书依然是提升自己的高效方法：兼以作者的身份告诉大家如何选择书，以及高效学习的方法 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/8620225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/8620225.html</guid>
<description>&lt;p&gt;    国内技术网站多如牛毛，质量高的网站也不少，博客园也算一个，各类文章数以百万计，我随便输入一个关键字，比如Spring Cloud，都能看到大量的技术文章和教学视频，我无意贬低技术文章和教学视频的作用，否则博客园第一个就封杀我的文章了，我只是想说，如果大家想让自己成为大牛，系统性地阅读书籍不失为一条捷径。&lt;/p&gt;
&lt;p&gt;      我给出如下的论据：&lt;/p&gt;
&lt;p&gt;      论据一：我见过不少大牛，他们办公桌上的图书都是堆积如山。我可以这样说，看了很多书还未必成大牛，但不读书一定成不了大牛。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201803/1226172-20180321212724538-2075407706.png&quot; alt=&quot;&quot; width=&quot;373&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    论据二：正是因为网上文章太多，这导致了纸质书的幅度衰退。正因如此，各出版社才会严格把关，一些不好的书很少有机会出版，因为出版了一定亏，这话反过来说，目前能经过出版社审核出版的书，大多质量不会差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201803/1226172-20180321213155409-1052965156.png&quot; alt=&quot;&quot; width=&quot;270&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    论据三，目前大家公认的大神，总会以教学视频或图书等方式向大家展示自己，不看书，那怎么知道写技术书的条条框框？也就是说，从看书，到写书再到成为大牛，很多著名大牛就这样过来的。&lt;/p&gt;
&lt;p&gt;    总结性观点：网上知识虽然很多，说是海量也不为过，但太杂，有些甚至相互矛盾，假设某书有12个章节，可能其中的内容网上都有，但我得用很长的时间才能收集全，即使收集全了，我还无法有效甄别哪些该学，以及学习的方法（如果我都知道了我干嘛还要学？），但如果我买了一本经过出版社检验过的书，我就省去了收集和鉴别的精力，而且还能沿着作者给出的途径快速地上手某个知识点。&lt;/p&gt;

&lt;p&gt;    好了，如下给些干货，我毕竟也出了不少书，最近一本书是&lt;a href=&quot;http://www.broadview.com.cn/book/4843&quot;&gt;java web轻量级开发面试教程&lt;/a&gt;，我就以作者的身份告诉大家该如何甄别好书。&lt;/p&gt;
&lt;p&gt;     第一，出现如下情况的图书慎买。声明下，我只是列出一些鉴定方法，无意针对任何一本书。&lt;/p&gt;
&lt;p&gt;     1 出版社不知名，从目录上看，内容叙述一般，这有可能是自费出的书，出书的目的：世艰不拆。&lt;/p&gt;
&lt;p&gt;     2 随便翻下书，一般来说，技术图书总是会结合代码结合图表来说，如果出现大段大段纯文字的，这本书慎重买。因为缺少代码等必要说明手段，这本书未必能把你教会。&lt;/p&gt;
&lt;p&gt;     3 看下一本书的前言和内容介绍，以及每个章节的起头文字和每章小结，看下这些文字作者是否是在敷衍，不排除正文内容好但这些文字有些敷衍的好书，但毕竟少。&lt;/p&gt;
&lt;p&gt;     4 看下书里作者有没有骗篇幅的嫌疑，比如安装某个组件，作者把所有的步骤都贴上图，或者大段引入现成的API说明， 一处不要紧，但如果很多地方都这样，而且文字看上很随意，明显看得出敷衍的痕迹，那么这本书慎重，都骗篇幅了，那可能连读者一块骗。&lt;/p&gt;
&lt;p&gt;     5 看最后几章的文字质量是否还是一丝不苟，因为写书是个长期的活，我的书350页，写了半年，如果到最后工作忙 ，或者写书热情过了，可能虎头蛇尾了，甚至烂尾了，这样的话，书的精华部分就要大打折扣了。&lt;/p&gt;
&lt;p&gt;     6 有些书讲的知识点非常吸引人，但是实用性不强，说白了学好了也没处用，这种书大家可以自行选择。&lt;/p&gt;
&lt;p&gt;     7 再如一些案例书，案例虽然多，但大多中规中矩，明显看不出这些案例是从项目中抽取了，也无法从这些案例中看出实践中总结出来的精华点，那这类书中的案例可能是从别人那山寨出来的，不会有版权问题，但也别想得到太多的收获，说白了这些书可能就是 简单能跑通的代码加看图说话。&lt;/p&gt;

&lt;p&gt;    第二，如何选择对自己有帮助的书。&lt;/p&gt;
&lt;p&gt;    1 看目录，从目录中看这本书是否系统性地给出了知识点，比如 Spring Cloud的书，看下目录，看这本书的选材是否是过于偏重理论而忽略实现，再看下这本书的内容是否涵盖了当前的热点。&lt;/p&gt;
&lt;p&gt;    2 看前言和内容介绍。一般比较上心的作者，可能文字功底参差不齐，但总是会尽最大努力写好书，那么这些书的前言和内容介绍，一般就不会落俗套。&lt;/p&gt;
&lt;p&gt;    3 看下代码以及相关的说明，一般好书里的代码不会少，而且在讲述代码时不会过于简单，也不会看图说话，而是会针对性地给出自己的见解，或者讲下项目中的实践经验。&lt;/p&gt;
&lt;p&gt;     4 看书的附带资料。一般的好书除了附带代码外，还会附带视频教学，这样书就物超所值了。&lt;/p&gt;
&lt;p&gt;     5 看下叙述性文字，是简单的照本宣科，还是看上去有种亲和力，或者到处可见项目中凝结出的经验。&lt;/p&gt;

&lt;p&gt;    第三，从书中学内容的局限性。&lt;/p&gt;
&lt;p&gt;     1 能把资深架构级别知识点讲清楚的书不多，比如有100万个程序员，最终可能也就60万能升级到高级程序员，也就20万成升级到架构师，估计最后成为资深架构级别的大牛也就5万人。达到高级别的人很少，而且这些人未必会写书。&lt;/p&gt;
&lt;p&gt;    .所以，目前的情况是，对于架构师而言，能适合阅读的书不多，而且即使有适合的，可能也就其中的2个章节有帮助，所以对这些大牛而言，只能是多读书，从多本书里抽取知识点。&lt;/p&gt;
&lt;p&gt;    2 有些经验，或者技巧，或者心得，根本无法从书里得到，这些只能靠自己总结，或者偶尔能从网上得到些秘籍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201803/1226172-20180321222035288-303538590.png&quot; alt=&quot;&quot; width=&quot;141&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    不过话说回来，大牛们一定是读了很多书积累了扎实的功底后，才能自己领悟出各种武林秘籍。&lt;/p&gt;

&lt;p&gt;    最后，书山有路勤为径.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201803/1226172-20180321222620660-843203978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    比如升级，总是要靠时间积累，哪怕我不看书，是从其他渠道获得知识，总不能三天打鱼两天晒网。&lt;/p&gt;
&lt;p&gt;    最后自夸下，就看在我将近11点还在写博，而且我在博客园更新博客的频率不算低，希望各位大神保佑我早日成为资深架构师。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201803/1226172-20180321222809841-597545079.png&quot; alt=&quot;&quot; width=&quot;180&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   我也相信，不管用什么方法，只要大家勤奋刻苦了，总能总结出针对自己的进阶方法，总能达到自己的预期目标。&lt;/p&gt;




</description>
<pubDate>Wed, 21 Mar 2018 14:31:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/8620225.html</dc:identifier>
</item>
<item>
<title>回归与梯度下降法及实现原理 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/8620058.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/8620058.html</guid>
<description>&lt;h2&gt;批量梯度下降法BGD&lt;/h2&gt;
&lt;p&gt;批量梯度下降法（Batch Gradient Descent，简称BGD）是梯度下降法最原始的形式，它的具体思路是在更新每一参数时都使用所有的样本来进行更新，其数学形式如下：&lt;/p&gt;
&lt;p&gt;　　(1) 对上述的能量函数求偏导：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130525190603437&quot; alt=&quot;&quot; width=&quot;250&quot; height=&quot;60&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(2) 由于是最小化风险函数，所以按照每个参数&lt;span id=&quot;MathJax-Element-5-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B8;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-104&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-105&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-106&quot; class=&quot;mi&quot;&gt;θ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;θ的梯度负方向来更新每个&lt;span id=&quot;MathJax-Element-6-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B8;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-107&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-108&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-109&quot; class=&quot;mi&quot;&gt;θ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;θ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130525190954867&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;60&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　具体的伪代码形式为：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;repeat&lt;/strong&gt;{　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://img.blog.csdn.net/20130525190954867&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;60&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　（for every j=0, ... , n）&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;　　从上面公式可以注意到，它得到的是一个全局最优解，但是每迭代一步，都要用到训练集所有的数据，如果样本数目&lt;span id=&quot;MathJax-Element-7-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;m&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-110&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-111&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-112&quot; class=&quot;mi&quot;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;m很大，那么可想而知这种方法的迭代速度！所以，这就引入了另外一种方法，随机梯度下降。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;优点：&lt;/strong&gt;全局最优解；易于并行实现；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;缺点：&lt;/strong&gt;当样本数目很多时，训练过程会很慢。&lt;/p&gt;
&lt;p&gt;　　从迭代的次数上来看，BGD迭代的次数相对较少。其迭代的收敛曲线示意图可以表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/764050/201512/764050-20151230190320667-1412088485.png&quot; alt=&quot;&quot; width=&quot;294&quot; height=&quot;244&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;随机梯度下降法SGD&lt;/h2&gt;
&lt;p&gt;由于批量梯度下降法在更新每一个参数时，都需要所有的训练样本，所以训练过程会随着样本数量的加大而变得异常的缓慢。随机梯度下降法（Stochastic Gradient Descent，简称SGD）正是为了解决批量梯度下降法这一弊端而提出的。&lt;/p&gt;
&lt;p&gt;　　将上面的能量函数写为如下形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130525191712216&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;109&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　利用每个样本的损失函数对&lt;span id=&quot;MathJax-Element-8-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B8;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-113&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-114&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-115&quot; class=&quot;mi&quot;&gt;θ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;θ求偏导得到对应的梯度，来更新&lt;span id=&quot;MathJax-Element-9-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B8;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-116&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-117&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-118&quot; class=&quot;mi&quot;&gt;θ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;θ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130525192139662&quot; alt=&quot;&quot; width=&quot;204&quot; height=&quot;40&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　具体的伪代码形式为：&lt;/p&gt;
&lt;p&gt;　　1. Randomly shuffle dataset；&lt;/p&gt;
&lt;p&gt;　　2. &lt;strong&gt;repeat&lt;/strong&gt;{&lt;/p&gt;
&lt;p&gt;　　　　for i=1, ... , &lt;span id=&quot;MathJax-Element-10-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;m&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-119&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-120&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-121&quot; class=&quot;mi&quot;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;m{&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://img.blog.csdn.net/20130525192139662&quot; alt=&quot;&quot; width=&quot;204&quot; height=&quot;40&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　(for j=0, ... , &lt;span id=&quot;MathJax-Element-11-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-122&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-123&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-124&quot; class=&quot;mi&quot;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;n)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　}&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;　　随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已经将theta迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;优点：&lt;/strong&gt;训练速度快；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;缺点：&lt;/strong&gt;准确度下降，并不是全局最优；不易于并行实现。&lt;/p&gt;
&lt;p&gt;　　从迭代的次数上来看，SGD迭代的次数较多，在解空间的搜索过程看起来很盲目。其迭代的收敛曲线示意图可以表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/764050/201512/764050-20151230193523495-665207012.png&quot; alt=&quot;&quot; width=&quot;329&quot; height=&quot;263&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;小批量梯度下降法MBGD&lt;/h2&gt;
&lt;p&gt;有上述的两种梯度下降法可以看出，其各自均有优缺点，那么能不能在两种方法的性能之间取得一个折衷呢？即，算法的训练过程比较快，而且也要保证最终参数训练的准确率，而这正是小批量梯度下降法（Mini-batch Gradient Descent，简称MBGD）的初衷。&lt;/p&gt;
&lt;p&gt;　　MBGD在每次更新参数时使用b个样本（b一般为10），其具体的伪代码形式为：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Say&lt;/strong&gt; b=10, m=1000.&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Repeat&lt;/strong&gt;{&lt;/p&gt;
&lt;p&gt;　　　　for i=1, 11, 21, 31, ... , 991{&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/764050/201512/764050-20151230193948073-572720704.png&quot; alt=&quot;&quot; width=&quot;349&quot; height=&quot;61&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　(for every j=0, ... , &lt;span id=&quot;MathJax-Element-12-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-125&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-126&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-127&quot; class=&quot;mi&quot;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;n)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　}&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;假设我们已知门店销量为&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;门店数X&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;实际销量Y&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;25&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;30&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们如何预测门店数X与Y的关系式呢？假设我们设定为线性：Y=a0+a1X&lt;/p&gt;

&lt;p&gt;接下来我们如何使用已知数据预测参数a0和a1呢？这里就是用了梯度下降法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160216220027231&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;左侧就是梯度下降法的核心内容，右侧第一个公式为假设函数，第二个公式为损失函数。&lt;/p&gt;
&lt;p&gt;其中 &lt;img src=&quot;http://img.blog.csdn.net/20160216220138044&quot; alt=&quot;&quot;/&gt;表示假设函数的系数，&lt;img src=&quot;http://img.blog.csdn.net/20160216220353871&quot; alt=&quot;&quot;/&gt;为学习率。&lt;/p&gt;
&lt;p&gt;对我们之前的线性回归问题运用梯度下降法，关键在于求出代价函数的导数，即：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160216220257651&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;直观的表示，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160216234325679&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;python代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Training data set  &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;each element in x represents (x1)  &lt;/span&gt;
x = [1,2,3,4,5,6&lt;span&gt;]  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;y[i] is the output of y = theta0+ theta1 * x[1]  &lt;/span&gt;
y = [13,14,20,21,25,30&lt;span&gt;]  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置允许误差值  &lt;/span&gt;
epsilon = 1  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;学习率  &lt;/span&gt;
alpha = 0.01&lt;span&gt;  
diff &lt;/span&gt;=&lt;span&gt; [0,0]  
max_itor &lt;/span&gt;= 20&lt;span&gt;  
error1 &lt;/span&gt;=&lt;span&gt; 0  
error0 &lt;/span&gt;=&lt;span&gt;0  
cnt &lt;/span&gt;=&lt;span&gt; 0  
m &lt;/span&gt;=&lt;span&gt; len(x)  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;init the parameters to zero  &lt;/span&gt;
theta0 =&lt;span&gt; 0  
theta1 &lt;/span&gt;=&lt;span&gt; 0  
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:  
    cnt&lt;/span&gt;=cnt+1&lt;span&gt;  
    diff &lt;/span&gt;=&lt;span&gt; [0,0]  
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(m):  
        diff[0]&lt;/span&gt;+=theta0+ theta1 * x[i]-&lt;span&gt;y[i]  
        diff[&lt;/span&gt;1]+=(theta0+theta1*x[i]-y[i])*&lt;span&gt;x[i]  
    theta0&lt;/span&gt;=theta0-alpha/m*&lt;span&gt;diff[0]  
    theta1&lt;/span&gt;=theta1-alpha/m*diff[1&lt;span&gt;]  
    error1&lt;/span&gt;=&lt;span&gt;0  
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(m):  
        error1&lt;/span&gt;+=(theta0+theta1*x[i]-y[i])**2  
    &lt;span&gt;if&lt;/span&gt; abs(error1-error0)&amp;lt;&lt;span&gt; epsilon:  
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;  
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;theta0 :%f,theta1 :%f,error:%f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(theta0,theta1,error1))  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cnt&amp;gt;20&lt;span&gt;:  
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cnt&amp;gt;20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;  
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;theta0 :%f,theta1 :%f,error:%f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(theta0,theta1,error1))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
theta0 :0.205000,theta1 :0.816667,error:1948.212261&lt;span&gt;
theta0 :&lt;/span&gt;0.379367,theta1 :1.502297,error:1395.602361&lt;span&gt;
theta0 :&lt;/span&gt;0.527993,theta1 :2.077838,error:1005.467313&lt;span&gt;
theta0 :&lt;/span&gt;0.654988,theta1 :2.560886,error:730.017909&lt;span&gt;
theta0 :&lt;/span&gt;0.763807,theta1 :2.966227,error:535.521394&lt;span&gt;
theta0 :&lt;/span&gt;0.857351,theta1 :3.306283,error:398.166976&lt;span&gt;
theta0 :&lt;/span&gt;0.938058,theta1 :3.591489,error:301.147437&lt;span&gt;
theta0 :&lt;/span&gt;1.007975,theta1 :3.830615,error:232.599138&lt;span&gt;
theta0 :&lt;/span&gt;1.068824,theta1 :4.031026,error:184.147948&lt;span&gt;
theta0 :&lt;/span&gt;1.122050,theta1 :4.198911,error:149.882851&lt;span&gt;
theta0 :&lt;/span&gt;1.168868,theta1 :4.339471,error:125.631467&lt;span&gt;
theta0 :&lt;/span&gt;1.210297,theta1 :4.457074,error:108.448654&lt;span&gt;
theta0 :&lt;/span&gt;1.247197,theta1 :4.555391,error:96.255537&lt;span&gt;
theta0 :&lt;/span&gt;1.280286,theta1 :4.637505,error:87.584709&lt;span&gt;
theta0 :&lt;/span&gt;1.310171,theta1 :4.706007,error:81.400378&lt;span&gt;
theta0 :&lt;/span&gt;1.337359,theta1 :4.763073,error:76.971413&lt;span&gt;
theta0 :&lt;/span&gt;1.362278,theta1 :4.810533,error:73.781731&lt;span&gt;
theta0 :&lt;/span&gt;1.385286,theta1 :4.849922,error:71.467048&lt;span&gt;
theta0 :&lt;/span&gt;1.406686,theta1 :4.882532,error:69.770228&lt;span&gt;
theta0 :&lt;/span&gt;1.426731,theta1 :4.909448,error:68.509764&lt;span&gt;
theta0 :&lt;/span&gt;1.445633,theta1 :4.931579,error:67.557539&lt;span&gt;
cnt&lt;/span&gt;&amp;gt;20&lt;span&gt;
theta0 :&lt;/span&gt;1.445633,theta1 :4.931579,error:67.557539&lt;span&gt;
[Finished &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; 0.2s]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到学习率在0.01时，error会正常下降。图形如下：（第一张图是学习率小的时候，第二张图就是学习率较大的时候）&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160216234340812&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们再调整一下新的学习率看看是否能看到第二张图：&lt;/p&gt;
&lt;p&gt;我们将学习率调整成了0.3的时候得到以下结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
theta0 :6.150000,theta1 :24.500000,error:38386.135000&lt;span&gt;  
theta0 :&lt;/span&gt;-15.270000,theta1 :-68.932500,error:552053.226569&lt;span&gt;  
theta0 :&lt;/span&gt;67.840125,theta1 :285.243875,error:7950988.401277&lt;span&gt;  
theta0 :&lt;/span&gt;-245.867981,theta1 :-1059.347887,error:114525223.507401&lt;span&gt;  
theta0 :&lt;/span&gt;946.357695,theta1 :4043.346381,error:1649619133.261223&lt;span&gt;  
theta0 :&lt;/span&gt;-3576.913313,theta1 :-15323.055232,error:23761091159.680252&lt;span&gt;  
theta0 :&lt;/span&gt;13591.518674,theta1 :58177.105053,error:342254436006.869995&lt;span&gt;  
theta0 :&lt;/span&gt;-51565.747234,theta1 :-220775.317546,error:4929828278909.234375&lt;span&gt;  
theta0 :&lt;/span&gt;195724.210360,theta1 :837920.911885,error:71009180027939.656250&lt;span&gt;  
theta0 :&lt;/span&gt;-742803.860227,theta1 :-3180105.158068,error:1022815271242165.875000&lt;span&gt;  
theta0 :&lt;/span&gt;2819153.863813,theta1 :12069341.864380,error:14732617369683060.000000&lt;span&gt;  
theta0 :&lt;/span&gt;-10699395.102930,theta1 :-45806250.675551,error:212208421856953728.000000&lt;span&gt;  
theta0 :&lt;/span&gt;40606992.787278,theta1 :173846579.256281,error:3056647245837464576.000000&lt;span&gt;  
theta0 :&lt;/span&gt;-154114007.118001,theta1 :-659792674.286440,error:44027905696333684736.000000&lt;span&gt;  
theta0 :&lt;/span&gt;584902509.168162,theta1 :2504083725.690765,error:634177359734604038144.000000&lt;span&gt;  
theta0 :&lt;/span&gt;-2219856149.407590,theta1 :-9503644836.328783,error:9134682134868024885248.000000&lt;span&gt;  
theta0 :&lt;/span&gt;8424927779.709908,theta1 :36068788150.345154,error:131575838248146814631936.000000&lt;span&gt;  
theta0 :&lt;/span&gt;-31974778105.915466,theta1 :-136890372077.920685,error:1895216599231190653730816.000000&lt;span&gt;  
theta0 :&lt;/span&gt;121352546013.825867,theta1 :519534337912.329712,error:27298674329760760684609536.000000&lt;span&gt;  
theta0 :&lt;/span&gt;-460564272592.117981,theta1 :-1971767072878.787598,error:393209736799816196514906112.000000&lt;span&gt;  
theta0 :&lt;/span&gt;1747960435714.394287,theta1 :7483365594965.919922,error:5663787744653302294061776896.000000&lt;span&gt;  
cnt&lt;/span&gt;&amp;gt;20&lt;span&gt;  
theta0 :&lt;/span&gt;1747960435714.394287,theta1 :7483365594965.919922,error:5663787744653302294061776896.000000&lt;span&gt;  
[Finished &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; 0.2s]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到theta0和theta1都在跳跃，与预期相符。&lt;/p&gt;
&lt;p&gt;上文使用的是批量梯度下降法，如遇到大型数据集的时候这种算法非常缓慢，因为每次迭代都需要学习全部数据集，后续推出了随机梯度下降，其实也就是抽样学习的概念。&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
</description>
<pubDate>Wed, 21 Mar 2018 14:01:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/8620058.html</dc:identifier>
</item>
<item>
<title>路线图：程序员领域知识体系搭建 - mindwind</title>
<link>http://www.cnblogs.com/mindwind/p/8619843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mindwind/p/8619843.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/815275/201803/815275-20180321212821050-1780706746.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;读完了梁宁的专栏《产品思维30讲》，其中有一篇是《点线面体的战略选择》，特别有感触。虽然是讲产品，但假如把个人的成长当成产品演进一样来发展，会有一种异曲同工，殊途同归的感觉。&lt;/p&gt;
&lt;p&gt;个人的成长有很多方面，但关于技术人的成长最重要的是知识体系构建，这其实就是一个「点线面体」的演进过程，下面结合我自己的成长演进过程来梳理下。&lt;/p&gt;
&lt;h2 id=&quot;点&quot;&gt;点&lt;/h2&gt;
&lt;p&gt;进入任一领域，都是选择从一个点开始的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/815275/201803/815275-20180321212911231-888384454.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是我从大学进入软件开发领域的一系列的点，按时间序列排列。我入行的年代，流行的是 C/S 架构的软件开发模型。当时客户端开发三剑客是 PB（PowerBuilder）、VB（VisualBasic）和 Delphi，所以我顺势选了其中的一两点，开启了程序员生涯。&lt;/p&gt;
&lt;p&gt;没过两年陆续 B/S 架构开始流行，逐步取代了 C/S 架构。只是因为研究生时学校开了一门面向对象语言课，老师用 Java 做教学语言，所以我后来就成了一名 Java 程序员，只是因为 Java 的生命力特别旺盛，所以也就延续至今。&lt;/p&gt;
&lt;p&gt;早些年，前后端还没太分离时，因为项目需要，所以又去涉猎了一些前端 JS 开发，之后移动互联网崛起，又去学习了些移动开发的东西，再之后就是 ABC（AI 人工智能、Big Data 大数据、Cloud 云计算） 时代，又被潮流裹挟去追逐技术的浪潮。&lt;/p&gt;
&lt;p&gt;每一个技术点，似乎都是自己选择的，但又感觉只是一种被趋势推动的一次次无意选择。有些点之间有先后的承接关系，而更多点都慢慢变成了孤点，从这片技术的星空中暗淡下去。&lt;/p&gt;
&lt;h2 id=&quot;线&quot;&gt;线&lt;/h2&gt;
&lt;p&gt;当形成的点足够多了后，一部分点开始形成线，而另一些点这在技术趋势的演进中被自然淘汰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/815275/201803/815275-20180321212923508-54075798.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，我用了一个技术人成长的形象 T（纵横）型图来串联如今沉淀下来的点。从成为了一名 Java 程序员开始，以前涉猎的技术点逐步就暗淡了。在纵深线，先向下走，专注于解决业务发展碰到的技术问题。后来开始往上走，更多关注目标的价值、路径的有效与合理性。&lt;/p&gt;
&lt;p&gt;整个纵向的技术线，最终汇总到顶点，就体现了我对这条线的 「掌控力」。然后在这里可以横向发展，如图中，也就有了新的能力域 —— 领导力、组织力。&lt;/p&gt;
&lt;p&gt;一个个点，构成了基本的价值点。这些点串起来，就形成了更大的价值输出链条。&lt;/p&gt;
&lt;h2 id=&quot;面&quot;&gt;面&lt;/h2&gt;
&lt;p&gt;线的交织，将形成面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/815275/201803/815275-20180321212947010-747352630.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，近六年我都在做电商客服和即时通讯领域的工作，所以我的整个面都围绕于此织就。从最早的聚焦于某个业务点和技术栈，逐步延伸扩展到整个面。&lt;/p&gt;
&lt;p&gt;事实是，整个团队才会分布工作在整个面上，而每个个体只会具体工作在这个面上的某个或某些点。&lt;/p&gt;
&lt;p&gt;在点上我们解决具体问题，是做解答题；但在整个面上我们选择路径，是做选择题。&lt;/p&gt;
&lt;h2 id=&quot;体&quot;&gt;体&lt;/h2&gt;
&lt;p&gt;体是经济体或其中的单元。&lt;/p&gt;
&lt;p&gt;从电力时代到信息时代再到智能时代，互联网、电商、移动互联网，这些都是 “体” 的变化。今天互联网行业的软件工程师，它们面临的挑战和难度不见得比传统的机械电力工程师更大，只不过他们所从事的点所属的面，附着于一个快速崛起的体上，获得了更大的加速度。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;在领域知识体系中，“点” 是利器，“线” 是路径，“面” 是地图。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写点文字，画点画儿，记录成长瞬间。&lt;br/&gt;微信公众号「瞬息之间」，既然遇见，不如同行。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/815275/201602/815275-20160216164606173-1251141402.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 13:30:00 +0000</pubDate>
<dc:creator>mindwind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mindwind/p/8619843.html</dc:identifier>
</item>
<item>
<title>python 练完这些，你的函数编程就ok了 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/8476359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/8476359.html</guid>
<description>&lt;h2&gt;　　文件处理相关&lt;/h2&gt;
&lt;p&gt;1，编码问题&lt;/p&gt;
&lt;p&gt;（1）请问python2与python3中的默认编码是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
python 2.x默认的字符编码是ASCII，默认的文件编码也是ASCII
python 2.x默认的字符编码是unicode，默认的文件编码也是utf-8
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）为什么会出现中文乱码，你能举例说明乱码的情况有哪几种？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
无论以什么编码在内存里显示字符，存到硬盘上都是2进制，所以编码不对，程序就会出错了。
（ascii编码（美国），GBK编码（中国），shift_JIS编码（日本），，，，）
要注意的是，存到硬盘上时是以何种编码存的，再从硬盘上读出来时，就必须以何种编码读，要不然就乱了。。

常见的编码错误的原因有:
　　python解释器的默认编码
　　Terminal使用的编码
　　python源文件文件编码
　　操作系统的语言设置,掌握了编码之前的关系后,挨个排错就ok
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）如何进行编码转换？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
如果想要中国的软件可以正常的在美国人的电脑上实现，有下面两种方法：
    1，让美国人的电脑都装上gbk编码
    2，让你的软件编码以utf-8编码

    第一种方法不可现实，第二种方法比较简单，但是也只能针对新开发的软件，
如果你之前开发的软件就是以gbk的编码写的，上百万行代码已经写出去了，
重新编码成utf-8格式也会费很大力气。
    所以，针对已经用gbk开发的软件项目如何让项目在美国人的电脑上正常显示
    还记得unicode的一个功能就是其包含了跟全球所有国家编码的映射关系，
所以无论你以什么编码存储的数据，只要我们的软件把数据从硬盘上读到内存，
转成unicode来显示即可，由于所有的系统，编程语言都默认支持unicode，
所有我们的gbk软件放在美国电脑上，加载到内存里面，变成了unicode，中文就可正常展示
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（4）#_*_coding:utf-8_*_  的作用是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#_*_coding:utf-8 _*_ 的作用是.py文件是什么编码，就需要告诉python用什么编码去读取这个.py文件
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（5）解释python2.x  bytes与python3.x  bytes的区别&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
简单点说：
Python 2 将 strings 处理为原生的 bytes 类型，而不是 unicode，
Python 3 所有的 strings 均是 unicode 类型。
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
在python2.x中，写字符串，比如
&amp;gt;&amp;gt;&amp;gt;s = ”学习“
&amp;gt;&amp;gt;&amp;gt;print s
学习
&amp;gt;&amp;gt;&amp;gt;s
'\xd1\xa7\xcf\xb0'

    
    虽然说打印的是学习，但是直接调用的变量s，确实一个个16进制表示的二进制字节，
我们称这个为byte类型，即字节类型，它把8个二进制一组称为一个byte，用16进制表示
    所以说python2.x的字符串其实更应该称为字符串，通过存储的方式就能看出来，
但是在python2.x中还有一个bytes类型，两个是否相同呢，回答是肯定的，在python2.x中，bytes==str


python3.x中
    把字符串变成了unicode，文件默认编码编程了utf-8，这意味着，只要用python3.x，
无论我们的程序以那种语言开发，都可以在全球各国电脑上正常显示。
    python3.x除了把字符串的编码改成了unicode，还把str和bytes做了明确区分，
str就是unicode格式的字符串bytes就是单纯的二进制
（补充一个问题，为什么在python3.x中，把unicode编码后，字符串就变成了bytes格式
，为什么不直接打印成gbk的字符，我觉得就是想通过这样的方式明确的告诉你，想在python3.x中看字符，
必须是unicode，其他编码一律是bytes格式）
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2，文件处理&lt;/p&gt;
&lt;p&gt;（1） r和rb的区别是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
文件操作时候，以“r&quot;或者”rb&quot;模式打开，只能读取，无法写入；
硬盘上保存的文件都是某种编码的0101010，打开时需要注意：
    rb，直接读取文件保存时原生的0101010，在Python中用字节类型表示
    r和encoding，读取硬盘的0101010，并按照encoding指定的编码格式进行断句，
再将“断句”后的每一段0101010转换成unicode的 010101010101，在Python中用字符串类型表示
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）解释一下下面三个参数的作用分别是什么？&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
open(f_name,'r',encoding=&quot;utf-8&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
f_name 是文件的路径，mode是打开的方式，encoding是编码格式
 encoding #文件编码 
 mode #打开模式 
 name #文件名 
 newlines #文件中用到的换行模式，是一个tuple 
 softspace #boolean型，一般为0，据说用于print
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3） w和wb的区别是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
文件操作时候，以 “w”或“wb” 模式打开，则只能写，并且在打开的同时会先将内容清空。
写入到硬盘上时，必须是某种编码的0101010，打开时需要注意：
    wb，写入时需要直接传入以某种编码的0100101，即：字节类型
    w 和 encoding，写入时需要传入unicode字符串，内部会根据encoding制定的编码
将unicode字符串转换为该编码的 010101010
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（4）a和ab的区别是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
文件操作时，以 “a”或“ab” 模式打开，则只能追加，即：在原来内容的尾部追加内容
写入到硬盘上时，必须是某种编码的0101010，打开时需要注意：
    ab，写入时需要直接传入以某种编码的0100101，即：字节类型
    a 和 encoding，写入时需要传入unicode字符串，内部会根据encoding制定的编码
将unicode字符串转换为该编码的 010101010
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（5）readline和readlines的区别&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
readline() #读取一行

readlines() #读取所有内容，并返回列表（一行为列表的一个元素值）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（6）全局替换程序：&lt;/p&gt;
&lt;p&gt;写一个脚本，允许用户按以下方式执行时，即可以对指定文件内容进行全局替换&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
`python your_script.py old_str new_str filename`
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　替换完毕后打印替换了多少处内容&lt;/p&gt;


&lt;p&gt;（7）模拟登陆&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户输入帐号密码进行登陆&lt;/li&gt;
&lt;li&gt;用户信息保存在文件内&lt;/li&gt;
&lt;li&gt;用户密码输入错误三次后锁定用户，下次再登录，检测到是这个用户也登录不了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;　　　函数基础&lt;/h2&gt;
&lt;p&gt;1，写函数，计算传入数字参数的和。（动态传参）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#写函数，计算传入数字参数的和。（动态传参）
x = int(input(&quot;输入要计算的值x: &quot;))  #定义动态输入的x值
y = int(input(&quot;输入要计算的值y: &quot;))  #定义动态输入的y值

def calc(x,y):
    result = x+y
    return (&quot;结果是：&quot;,result)
a = calc(x,y)
print(a)
# 输入要计算的值x: 123
# 输入要计算的值y: 456
# ('结果是：', 579)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2，写函数，用户传入修改的文件名，与要修改的内容，执行函数，完成整个文件的批量修改操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 2、写函数，用户传入修改的文件名，与要修改的内容，执行函数，完成整个文件的批量修改操作
import os

file_name = &quot;print_tofile.txt&quot;
file_new_name = '%s.new' %file_name

old_str = '最近学习不太好'
new_str = '最近学习真不好'

f_old = open(file_name,'r',encoding='utf-8')
f_new = open(file_new_name,'w',encoding='utf-8')

for line in f_old:
    if old_str in line:
        line = line.replace(old_str,new_str)
        f_new.write(line)
        print(line)
f_old.close()
f_new.close()
os.replace(file_new_name,file_name)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import os
def update_func(a: object, old_str: object, new_str: object) -&amp;gt; object:  #定义三个接受值的形参，a是要修改的文件名，b是要修改的内容，c是修改后的内容
    #打开文件，文件名为接受的形参a
    file_old = 'a.txt'
    file_new = 'aa.txt'
    f_old = open(file_old,'r',encoding='utf-8')
    #打开修改后写入的文件
    f_new = open(file_new,'w',encoding='utf-8')

    # old_str = '你是我唯一的爱'
    # new_str = 'you are my everything'

    #循环每一行的文件的数据
    for line in f_old:
        new_content = line.replace(old_str,new_str)      #将要修改的内容字符串用replace替换
        f_new.write(new_content)             #将替换后的内容写入修改后写入的文件中
    f_new.close()
    f_old.close()
    os.replace(file_new,file_old)

update_func('a.txt','你是我唯一的爱','you are my everything')
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改前的文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
你是我唯一的爱，you are my everything
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改后的文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
you are my everything，you are my everything
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3，写函数，检查用户传入的对象（字符串、列表、元组）的每一个元素是否含有空内容。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def check_str(a):  #a为传过来的参数
    calc = False  #空格统计默认False没有
    for line in a:
        if line.isspace():
            calc = True
    return calc

a = '123 132 456 7489 456'
res = check_str(a)
print(res)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
def func(strr,listt,tuplee):
    if strr.isspace():
        print(&quot;字符串有空内容&quot;)
    else:
        print(&quot;字符串里面没有空内容&quot;)

    if len(listt) ==0:
        print(&quot;列表有空内容&quot;)
    else:
        print(&quot;列表里面没有空内容&quot;)

    if len(tuplee) == 0:
        print(&quot;元祖有空内容&quot;)
    else:
        print(&quot;元组里面没有空内容&quot;)

res = func('123456',[],())
# 字符串里面没有空内容
# 列表有空内容
# 元祖有空内容
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4，写函数，检查传入字典的每一个value的长度,如果大于2，那么仅保留前两个长度的内容，并将新内容返回给调用者。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
dic = {&quot;k1&quot;: &quot;v1v1&quot;, &quot;k2&quot;: [11,22,33,44]}
PS:字典中的value只能是字符串或列表
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 4，写函数，检查传入字典的每一个value的长度,如果大于2，
        # 那么仅保留前两个长度的内容，并将新内容返回给调用者。

dic = {&quot;k1&quot;: &quot;v1v1&quot;, &quot;k2&quot;: [11,22,33,44]}
def check_func(a):  #a为传过来的参数
    li = []
    for item in a.values():
        length = len(item)
        if length &amp;gt;2:
            li.append(item[0:2])
        else:
            continue
    return li

a = check_func(dic)
print(a)
# ['v1', [11, 22]]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5，解释闭包的概念&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    关于闭包，即函数定义和函数表达式位于另一个函数的函数体内（嵌套函数）。
而且这些内部函数可以访问他们所在的外部函数中声明的所有局部变量，参数。
当其中一个这样的内部函数在包含他们的外部函数之外被调用时候，就形成了闭包。
也就是说，内部函数会在外部函数返回后被执行。而当这个内部函数执行的时候，
它仍然必需访问其外部函数的局部变量，参数以及其他内部函数，这些局部变量，
参数声明（最初时）的值是外部函数返回时候的值，但也会受到内部函数的影响。
    闭包的意义：返回的函数对象，不仅仅是一个函数对象，在该函数外还包裹了一层作用域，
这使得，该函数无论在何处调用，优先使用自己外层包裹的作用域
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　简单的说，闭包就是一个内部函数+外部环境 &lt;/p&gt;

&lt;p&gt;6，写函数，计算传入字符串中的【数字】、【字母】、【空格】和【其他】的个数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 6，写函数，计算传入字符串中的【数字】、【字母】、【空格】和【其他】的个数
def func(strr):
    digit_number = 0
    space_number = 0
    alpha_number = 0
    else_number = 0
    for i in strr:
        if i.isdigit():
            digit_number +=1
        elif i.isspace():
            space_number +=1
        elif i.isalpha():
            alpha_number +=1
        else:
            else_number +=1
    return (&quot;数字，空格，字母，其他内容分别有：&quot;,(digit_number,space_number,alpha_number,else_number))
res = func('sda!@#$%^&amp;amp;1234567dfghj da da ')
print(res)
# ('数字，空格，字母，其他内容分别有：', (7, 3, 12, 7))
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　函数进阶&lt;/h2&gt;
&lt;p&gt;1，写函数，返回一个扑克牌列表，里面有52项，每一项是一个元组&lt;/p&gt;
&lt;p&gt;　　例如：[(‘红心’，2),(‘草花’，2), …(‘黑桃A’)]&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;146&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def cards():
    num = []
    for i in range(2,11):
        num.append(i)
    num.extend(['J','Q','K','A'])
    type = ['红心','草花','方块','黑桃']
    result = []
    for i in num:
        for j in type:
            result.append((j,i))
    return result
print(cards())
# [('红心', 2), ('草花', 2), ('方块', 2), ('黑桃', 2),
#  ('红心', 3), ('草花', 3), ('方块', 3), ('黑桃', 3),
#  ('红心', 4), ('草花', 4), ('方块', 4), ('黑桃', 4),
#  ('红心', 5), ('草花', 5), ('方块', 5), ('黑桃', 5),
#  ('红心', 6), ('草花', 6), ('方块', 6), ('黑桃', 6), 
#  ('红心', 7), ('草花', 7), ('方块', 7), ('黑桃', 7), 
#  ('红心', 8), ('草花', 8), ('方块', 8), ('黑桃', 8),
#  ('红心', 9), ('草花', 9), ('方块', 9), ('黑桃', 9), 
#  ('红心', 10), ('草花', 10), ('方块', 10), ('黑桃', 10), 
#  ('红心', 'J'), ('草花', 'J'), ('方块', 'J'), ('黑桃', 'J'),
#  ('红心', 'Q'), ('草花', 'Q'), ('方块', 'Q'), ('黑桃', 'Q'), 
#  ('红心', 'K'), ('草花', 'K'), ('方块', 'K'), ('黑桃', 'K'), 
#  ('红心', 'A'), ('草花', 'A'), ('方块', 'A'), ('黑桃', 'A')]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2，写函数，传入n个数，返回字典{‘max’:最大值,’min’:最小值}&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
例如:min_max(2,5,7,8,4)
返回:{‘max’:8,’min’:2}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 2，写函数，传入n个数，返回字典{‘max’:最大值,’min’:最小值}
# 例如:min_max(2,5,7,8,4)
# 返回:{‘max’:8,’min’:2}

def max_min(*args):
    the_max = args[0]
    the_min = args[0]
    for i in args:
        if i&amp;gt;the_max:
            the_max = i
        else:
            the_min = i
    return {'max':the_max,'min':the_min}


res = max_min(2,4,6,48,-16,486)
print(res)
# {'max': 486, 'min': -16}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3，写函数，专门计算图形的面积&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其中嵌套函数，计算圆的面积，正方形的面积和长方形的面积&lt;/li&gt;
&lt;li&gt;调用函数area(‘圆形’,圆半径) 返回圆的面积&lt;/li&gt;
&lt;li&gt;调用函数area(‘正方形’,边长) 返回正方形的面积&lt;/li&gt;
&lt;li&gt;调用函数area(‘长方形’,长，宽) 返回长方形的面积&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def area():
    def 计算长方形面积():
        pass

    def 计算正方形面积():
        pass

    def 计算圆形面积():
        pass
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import math
print('''
请按照如下格式输出：
    调用函数area(‘圆形’,圆半径) 返回圆的面积
    调用函数area(‘正方形’,边长) 返回正方形的面积
    调用函数area(‘长方形’,长，宽) 返回长方形的面积''')
def area(name,*args):
    def areas_rectangle(x,y):
        return (&quot;长方形的面积为：&quot;,x*y)

    def area_square(x):
        return (&quot;正方形的面积为：&quot;,x**2)

    def area_round(r):
        return (&quot;圆形的面积为：&quot;,math.pi*r*r)
    if name =='圆形':
        return area_round(*args)
    elif name =='正方形':
        return area_square(*args)
    elif name =='长方形':
        return areas_rectangle(*args)


print(area('长方形', 3, 4))
print(area('圆形', 3))
print(area('正方形', 3))
# 请按照如下格式输出：
#     调用函数area(‘圆形’,圆半径) 返回圆的面积
#     调用函数area(‘正方形’,边长) 返回正方形的面积
#     调用函数area(‘长方形’,长，宽) 返回长方形的面积
# ('长方形的面积为：', 12)
# ('圆形的面积为：', 28.274333882308138)
# ('正方形的面积为：', 9)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4，写函数，传入一个参数n，返回n的阶乘&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
例如:cal(7)
计算7*6*5*4*3*2*1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 4、写函数，传入一个参数n，返回n的阶乘。
# 例如: cal(7） 计算7 * 6 * 5 * 4 * 3 * 2 * 1
def cal(n):
    res= 1
    for i in range(n,0,-1):
        # print(i)
        res = res*i
        print(res)
    return res

print(cal(7))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5，编写装饰器，为多个函数加上认证的功能（用户的账号密码来源于文件），要求登录成功一次，后续的函数都无需再输入用户名和密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 5，编写装饰器，为多个函数加上认证的功能（用户的账号密码来源于文件），
# 要求登录成功一次，后续的函数都无需再输入用户名和密码


def login(func):
    def wrapper(*args,**kwargs):
        username = input(&quot;account:&quot;).strip()
        password = input(&quot;password:&quot;).strip()
        with open('userinfo.txt','r',encoding='utf-8') as f:
            userinfo = f.read().strip(',')
            userinfo = eval(userinfo)
            print(userinfo)
            if username in userinfo['name'] and password in userinfo['password']:
                print(&quot;success&quot;)
            else:
                print(&quot;pass&quot;)

    return wrapper

@login
def name():
    print(&quot;hello&quot;)

name()
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　生成器和迭代器&lt;/h2&gt;
&lt;p&gt;1，生成器和迭代器的区别？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
对于list、string、tuple、dict等这些容器对象,使用for循环遍历是很方便的。
在后台for语句对容器对象调用iter()函数。iter()是python内置函数。
iter()函数会返回一个定义了 next()方法的迭代器对象，它在容器中逐个访问容器内的
元素。next()也是python内置函数。在没有后续元素时，next()会抛出
一个StopIteration异常，通知for语句循环结束。
迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的
时候，迭代器会向我们返回它所记录位置的下一个位置的数据。实际上，在使用next()函数
的时候，调用的就是迭代器对象的_next_方法（Python3中是对象的_next_方法，
Python2中是对象的next()方法）。所以，我们要想构造一个迭代器，
就要实现它的_next_方法。但这还不够，python要求迭代器本身也是可迭代的，
所以我们还要为迭代器实现_iter_方法，而_iter_方法要返回一个迭代器，
迭代器自身正是一个迭代器，所以迭代器的_iter_方法返回自身self即可。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2，生成器有几种方式获取value？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
两种方式获取：
    for 循环
    next 获取
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3，通过生成器写一个日志调用方法， 支持以下功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据指令向屏幕输出日志&lt;/li&gt;
&lt;li&gt;根据指令向文件输出日志&lt;/li&gt;
&lt;li&gt;根据指令同时向文件&amp;amp;屏幕输出日志&lt;/li&gt;
&lt;li class=&quot;_mce_tagged_br&quot;&gt;以上日志格式如下&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
2017-10-19 22:07:38 [1] test log db backup 3
2017-10-19 22:07:40 [2]    user alex login success 
#注意：其中[1],[2]是指自日志方法第几次调用，每调用一次输出一条日志
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代码结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def logger(filename,channel='file'):
    &quot;&quot;&quot;
    日志方法
    :param filename: log filename
    :param channel: 输出的目的地，屏幕(terminal)，文件(file)，屏幕+文件(both)
    :return:
    &quot;&quot;&quot;
    ...your code...

 #调用
 log_obj = logger(filename=&quot;web.log&quot;,channel='both')
 log_obj.__next__()
 log_obj.send('user alex login success')
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　内置函数&lt;/h2&gt;
&lt;p&gt; 1，用map来处理字符串列表,把列表中所有人都变成sb,比方alex_sb&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
name=['alex','wupeiqi','yuanhao','nezha']
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
map()函数
map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把
函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：map()函数在不改变原有的lisy，而是返回一个新的list&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#  1，用map来处理字符串列表,把列表中所有人都变成sb,比方alex_sb
# name=['alex','wupeiqi','yuanhao','nezha']

name=['alex','wupeiqi','yuanhao','nezha']
def sb(x):
    return x+'_sb'

res = map(sb,name)
print(list(res))
# 结果：
['alex_sb', 'wupeiqi_sb', 'yuanhao_sb', 'nezha_sb']
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;2，用filter函数处理数字列表，将列表中所有的偶数筛选出来&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
num = [1,3,5,6,7,8]
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 2，用filter函数处理数字列表，将列表中所有的偶数筛选出来
# num = [1,3,5,6,7,8]

num = [1,3,5,6,7,8]
def func(x):
    if x%2 == 0:
        return True

ret = filter(func,num)
print(list(ret))
# 结果：
[6, 8]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3，如下，每个小字典的name对应股票名字，shares对应多少股，price对应股票的价格&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　计算购买每支股票的总价&lt;/p&gt;
&lt;p&gt;　　用filter过滤出，单价大于100的股票有哪些&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;81&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 3，如下，每个小字典的name对应股票名字，shares对应多少股，price对应股票的价格
portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
# 　　
# 　　计算购买每支股票的总价
# 　　用filter过滤出，单价大于100的股票有哪些

portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
m = map(lambda y:y['shares']*y['price'],portfolio)
print(list(m))
# [9110.0, 27161.0, 4218.0, 1111.25, 735.7500000000001, 8673.75]

a = []
for index,i in enumerate(portfolio):
    res= i['shares'] * i['price']
    a.append(res)
print(a)
# [9110.0, 27161.0, 4218.0, 1111.25, 735.7500000000001, 8673.75]
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 　3、用filter过滤出，单价大于100的股票有哪些
f = filter(lambda d:d['price']&amp;gt;=100,portfolio)
print(list(f))
# [{'name': 'AAPL', 'shares': 50, 'price': 543.22}, {'name': 'ACME', 'shares': 75, 'price': 115.65}]
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　其他练习&lt;/h2&gt;
&lt;p&gt;1，有列表 li = ['alex', 'egon', 'smith', 'pizza', 'alen'], 请将以字母“a”开头的元素的首字母改为大写字母；&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 1，有列表 li = ['alex', 'egon', 'smith', 'pizza', 'alen'],
# 请将以字母“a”开头的元素的首字母改为大写字母；
li = ['alex', 'egon', 'smith', 'pizza', 'alen']
li_new = []
for i in li:
    if i.startswith('a'):
        li_new.append(i.capitalize())
    else:
        li_new.append(i)
print(li_new)

for i in range(len(li)):
    if li[i][0] == 'a':
        li[i] = li[i].capitalize()
    else:
        continue
print(li)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2，有如下程序, 请给出两次调用&lt;code&gt;&lt;span&gt;show_num&lt;/span&gt;&lt;/code&gt;函数的执行结果，并说明为什么：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
num = 20

   def show_num(x=num):
       print(x)

   show_num()

   num = 30

   show_num()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象，相当于通过“传值’来传递对象，此时如果想改变这些变量的值，可以将这些变量申明为全局变量。&lt;/p&gt;

&lt;p&gt;3，有列表 li = ['alex', 'egon', 'smith', 'pizza', 'alen'], 请以列表中每个元素的第二个字母倒序排序；&lt;/p&gt;

&lt;p&gt;4，有名为&lt;code&gt;&lt;span&gt;poetry.txt&lt;/span&gt;&lt;/code&gt;的文件，其内容如下，请删除第三行；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
   昔人已乘黄鹤去，此地空余黄鹤楼。

   黄鹤一去不复返，白云千载空悠悠。

   晴川历历汉阳树，芳草萋萋鹦鹉洲。

   日暮乡关何处是？烟波江上使人愁。
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 4，有名为poetry.txt的文件，其内容如下，请删除第三行；
# 方法一：
# import os
# p = 'poetry.txt'
# file = open(p,'r',encoding='utf-8')
# print(file)
# pnew = '%s.new'%p
# filenew = open(pnew,'w',encoding='utf-8')
# str1 = '晴川历历汉阳树，芳草萋萋鹦鹉洲。'
# for i in file:
#     if str1 in i:
#         i = ''
#         filenew.write(i)
#     else:
#         filenew.write(i)
# file.close()
# filenew.close()
# os.replace(pnew,p)
# 方法二：逐行读取文件
import os
f1=open('poetry.txt', 'r',encoding='utf-8')

str='晴川历历汉阳树，芳草萋萋鹦鹉洲。'
with open('poetry1.txt', 'w', encoding='utf-8') as f2:
    ff1='poetry.txt'
    ff2='poetry1.txt'
    for line in f1:
        if str in line:
            line=''
            f2.write(line)

        else:
            f2.write(line)
f1.close()
f2.close()
os.replace(ff2,ff1)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;5，有名为&lt;code&gt;&lt;span&gt;username.txt&lt;/span&gt;&lt;/code&gt;的文件，其内容格式如下，写一个程序，判断该文件中是否存在&quot;alex&quot;, 如果没有，则将字符串&quot;alex&quot;添加到该文件末尾，否则提示用户该用户已存在；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
   pizza
   alex
   egon
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 5，有名为username.txt的文件，其内容格式如下，写一个程序，
# 判断该文件中是否存在&quot;alex&quot;, 如果没有，
# 则将字符串&quot;alex&quot;添加到该文件末尾，否则提示用户该用户已存在；
with open('username.txt','r+',encoding='utf-8') as f:
    str1 = 'alexx'
    i = f.read()
    print(i)
    if str1 in i:
        print(&quot;the user already exist in&quot;)
    else:
        f.write('\nalexx')
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6，有名为user_info.txt的文件，其内容格式如下，写一个程序，删除id为100003的行；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
   pizza,100001
   alex, 100002
   egon, 100003
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 6，有名为user_info.txt的文件，其内容格式如下，
# 写一个程序，删除id为100003的行；
import os
a = 'user_info.txt'
b = 'user_info1.txt'
with open(a,'r',encoding='utf-8') as f:
    with open(b, 'w', encoding='utf-8') as f2:
        for i in f:
            if '100003' in i:
                pass
            else:
                f2.write(i)
os.replace(b,a)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7，有名为user_info.txt的文件，其内容格式如下，写一个程序，将id为100002的用户名修改为&lt;code&gt;&lt;span&gt;alex li&lt;/span&gt;&lt;/code&gt;；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
   pizza,100001
   alex, 100002
   egon, 100003
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 7，有名为user_info.txt的文件，其内容格式如下，写一个程序，
# 将id为100002的用户名修改为alex li；
file = 'user_info.txt'
old_str = '100002'
new_str = 'alex, 100002'
file_data=''
with open(file,'r',encoding='utf-8') as f1:

    for line in f1:
        if old_str in line:
            line =new_str
        file_data +=line

        with open(file,'w',encoding='utf-8') as f1:
            f1.write(file_data)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;8，什么是装饰器？，写一个计算每个程序执行时间的装饰器；&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，
同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。
    这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，
提供了额外的功能。
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
8，写一个计算每个程序执行时间的装饰器；
import time
def timer(func):
    def wrapper(*args,**kwargs):
        start_time = time.time()
        func(*args)
        stop_time = time.time()
        d_time = stop_time-start_time
        print(d_time)
    return wrapper

@timer
def sayhi():
    print(&quot;hello word&quot;)

sayhi()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;9，lambda是什么？请说说你曾在什么场景下使用lambda？&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
lambda函数就是可以接受任意多个参数(包括可选参数)并且返回单个表达式值得函数
    好处：
        1.lambda函数比较轻便，即用即扔，适合完成只在一处使用的简单功能
        2.匿名函数，一般用来给filter，map这样的函数式编程服务
        3.作为回调函数，传递给某些应用，比如消息处理
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;10，请分别介绍文件操作中不同文件之间打开方式的区别&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;模式&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;r&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;文本只读模式&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;rb&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;二进制模式 这种方法是用来传输或存储，不给人看的&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;r+&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;读写模式，只要有r，那么文件必须存在&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;rb+&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;二进制读写模式&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;w&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;只写模式，不能读，用w模式打开一个已经存在的文件，如果有内容会清空，重新写&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;wb&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;以二进制方式打开，只能写文件，如果不存在，则创建&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;w+&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;读写模式，先读后写，只要有w，会清空原来的文件内容&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;wb+&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;二进制写读模式&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;a&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;追加模式，也能写，在文件的末尾添加内容&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;ab&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;二进制追加模式&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;a+&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;追加模式，如果文件不存在，则创建文件，如果存在，则在末尾追加&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;ab+&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;追读写二进制模式，从文件顶部读取文件，从文件底部添加内容，不存在则创建&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 21 Mar 2018 13:14:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/8476359.html</dc:identifier>
</item>
<item>
<title>SpringtMVC运行流程：@RequestMapping 方法中的 Map、HttpServletRequest等参数信息是如何封装和传递的（源码理解） - cyhbyw</title>
<link>http://www.cnblogs.com/cyhbyw/p/8618747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyhbyw/p/8618747.html</guid>
<description>&lt;p&gt;在平时开发SpringtMVC程序时，在Controller的方法上，通常会传入如Map、HttpServletRequest类型的参数，并且可以方便地向里面添加数据。同时，在Jsp中还可以直接使用request等对象方便地获取出来。&lt;/p&gt;
&lt;p&gt;如下面2图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321173806877-1681655341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321173846379-2018213888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可问题是：@RequestMapping 方法中的 Map、HttpServletRequest等参数信息是如何封装和传递的？&lt;/p&gt;
&lt;p&gt;带着这个问题，写了个简单的Demo，来进行源码调试。&lt;/p&gt;
&lt;p&gt;Demo代码地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cyhbyw/springMVC_atguigu_TongGang&quot; target=&quot;_blank&quot;&gt;https://github.com/cyhbyw/springMVC_atguigu_TongGang&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工程名称：&lt;/p&gt;
&lt;p&gt;springMVC_DebugSourceCode&lt;/p&gt;

&lt;p&gt;===========以下是源码调试==================&lt;/p&gt;
&lt;p&gt;01.首先，浏览器发出的请求到DispatcherServlet；然后，找到合适的HandlerAdapter（此处是RequestMappingHandlerAdapter）；然后调用RequestMappingHandlerAdapter的handle()方法。此时，方法堆栈从Line959开始。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321234816122-455214471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;02.还是在DispatcherServlet的Line959的doDispatch()方法内，又调用了几个方法，到达invokeForRequest()方法；顾名思义，此方法会真正的调用Request方法（即Controller中的方法）；不过，先会在Line128解析参数。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321234829637-792061302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 03.解析参数的方法又会走到Line161.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321234848500-1519984497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 04.再经过两个方法的调用，可以看到上述的参数解析方法是直接返回了 mavContainer.getModle()&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321234859329-192242126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;05.而getModel() 方法返回 defaulutModel 的成员变量。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321234914001-9382969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;06. defaulutModel 其实就是一个 BindingAwareModelMap&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321234927286-1086434018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 07.回到刚才的Line161，可以看到 args[i] 指向了刚才得到的BindingAwareModelMap@4821。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321234938473-2032475302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;08.再返回一层，此处的 Object[] args 还是BindingAwareModelMap@4821，且其中的元素为空；此处Line136的 doInvoke(args) 方法就是通过反射调用真实的Controller中的方法。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235039573-743310093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;09.真实Controller方法调用返回后，可以看到 mavContainer 对象中的 defaultModel 属性已经被赋值，且这个值就是BindingAwareModelMap@5010，与args是同一个对象（非常重要）！！！！&lt;/p&gt;
&lt;p&gt;（备注：SpringMVC是如何为mavContainer 对象中的 defaultModel 属性赋值的，最开始调试了很久也没有发现，心想着，它既然是个Map，那应该是调用setXXX(), put(), putAll()这样的方法赋值进去的，但调试了很久始终没发现这样的方法被调用；同时，也可以确定它是在Line136行调用后就被赋值的；最后猜测，是同一个对象引用；现在，证明确实如此）&lt;/p&gt;
&lt;p&gt;再啰嗦一句，其实就是：Line128的 Object[] args 变量指向了 mavContainer 对象的 defaultModel 属性！所以在将 args 通过Line136反射调用真实的Controller方法并填充数据后，defaultModel中也就有了相应数据！&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235104081-411642643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;10.控制台打印的入参Map其实也是BindingAwareModelMap&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235123689-1402110645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 11.真实Controller方法调用完成后，开始处理返回值&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235144582-1333510090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235420252-93074786.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;

&lt;p&gt;12.设置视图名称&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235429812-1096020842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 13.准备创建ModelAndView对象&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235436989-1156635234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;14.从 mavContainer 中取出Model数据，并通过构造函数传入ModelAndView&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235445765-595462428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;15.已经获得ModelAndView对象，进行后续操作（如渲染）；注意，此时DispatcherServlet中的方法堆栈从Line971开始。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235453266-536095757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;16.准备渲染&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235503057-779878574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;17.得到View对象&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235512573-1914441315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;18.遍历 viewResolvers 找到一个合适的就返回给17步中的View对象&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235520624-750375644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;19.准备渲染&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235527137-576556320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;20.将Model数据暴露为RequestAttribute&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235541028-850784762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;21.暴露的本质其实是：request.setAttribute(modelName, modelValue)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235556600-1604475790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;22.最后是一个转发操作&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180321235603881-444955948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 21 Mar 2018 13:03:00 +0000</pubDate>
<dc:creator>cyhbyw</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyhbyw/p/8618747.html</dc:identifier>
</item>
<item>
<title>JavaScript变量提升的理解 - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8619437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8619437.html</guid>
<description>&lt;h2 id=&quot;变量提升&quot;&gt;变量提升&lt;/h2&gt;
&lt;p&gt;先说三句总结性的话：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;let 的「创建」过程被提升了，但是初始化没有提升。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;var 的「创建」和「初始化」都被提升了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;function 的「创建」「初始化」和「赋值」都被提升了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，我们要注意，这三种变量提升，含义是不同的。&lt;/p&gt;
&lt;h3 id=&quot;变量提升的规律&quot;&gt;变量提升的规律&lt;/h3&gt;
&lt;p&gt;在进入一个执行上下文后，先把 var 和 function 声明的变量前置，再去顺序执行代码。&lt;/p&gt;
&lt;p&gt;PS：作用域分为全局作用域和函数作用域，用var声明的变量，只在自己所在的所用域有效。&lt;/p&gt;
&lt;p&gt;我们举例来看看下面的代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码 1：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(fn)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fn &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(fn)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相当于：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fn &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(fn)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    fn &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(fn)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180321_1810.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码 2：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(i)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(i)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相当于：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(i)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(i)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180321_1817.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码 3：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a)
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相当于：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a

        a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a)
        a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a)
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;

    a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180321_1827.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;声明时的重名问题&quot;&gt;声明时的重名问题&lt;/h3&gt;
&lt;p&gt;假设&lt;code&gt;a&lt;/code&gt;被声明为变量，紧接着&lt;code&gt;a&lt;/code&gt;又被声明为函数，原则是：声明会被覆盖（先来后到，就近原则）。&lt;/p&gt;
&lt;p&gt;PS：&lt;/p&gt;
&lt;p&gt;举例1：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fn&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//fn被声明为变量&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;// fn被声明为function，就近原则&lt;/span&gt;

    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(fn)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//打印结果：function fn(){}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例2：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//fn被声明为function，且此时fn已经被赋值，这个值就是function的对象&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fn&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//fn已经在上一行被声明且已经有值， 再 var 无效，并不会重置为 undefined&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(fn)  &lt;span class=&quot;co&quot;&gt;//打印结果：function fn(){}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然再var无效，但是再function，是有效的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//fn被声明为function，且此时fn已经有值，这个值就是function的对象&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//此时fn被重复赋值，会覆盖上一行的值&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'smyhvae'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(fn)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180321_1845.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;函数作用域中的变量提升两点提醒&quot;&gt;函数作用域中的变量提升（两点提醒）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;提醒1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在函数作用域也有声明提前的特性：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用var关键字声明的变量，是在函数作用域内有效，而且会在函数中所有的代码执行之前被声明&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;函数声明也会在函数中所有的代码执行之前执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，在函数中，没有var声明的变量都会成为&lt;strong&gt;全局变量&lt;/strong&gt;，而且并不会提前声明。&lt;/p&gt;
&lt;p&gt;举例1：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;// 此处的a相当于window.a&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//打印结果是2&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上方代码中，foo()的打印结果是&lt;code&gt;1&lt;/code&gt;。如果去掉第一行代码，打印结果是&lt;code&gt;Uncaught ReferenceError: a is not defined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提醒2：&lt;/strong&gt;定义形参就相当于在函数作用域中声明了变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        function fun6(e) {
            console.log(e);
        }

        fun6();  //打印结果为 undefined
        fun6(123);//打印结果为123&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其他题目&quot;&gt;其他题目&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (a &lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1

2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上方代码中，不存在块级作用域的概念。if语句中用var定义的变量，仍然是全局变量。&lt;/p&gt;
&lt;p&gt;顺便延伸一下，用let定义的变量，是在块级作用域内有效。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Mar 2018 12:33:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8619437.html</dc:identifier>
</item>
</channel>
</rss>