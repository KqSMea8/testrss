<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>记第一次离职 - xnchall</title>
<link>http://www.cnblogs.com/xnchll/p/8636048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xnchll/p/8636048.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;/strong&gt;　记录职业生涯中第一次跳槽，回忆一下前前后后，算是对自己一个交代吧，balabala&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;繁杂的一天&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　新东家要求入职体检，昨晚憋了整整一晚，一大早为了&quot;释放天性&quot;就早早去了要求医院，结果分东院和西院。是的，我跑错了，最后到了西院。没想到三级甲等医院没有体检套餐，好吧，我错了，不应该抱怨。毕竟他们有解决方案的，想要体检必须到每个想查项目的科室挂号（黑人问号脸？？），想了想按照他们的要求那可能挂号都需要半天，更别说体检了，果断逃之！联系了新东家HR，商量结果是可以去我提出的医院体检。来到比较熟悉的医院，交了费用，明天早上去，应该半个小时内就可以查完。这时候已是中午11点多了，吃完了去公司办理离职后续档案类手续。ps--即将离开的公司性质是央企（研究院），就不吐槽流程和效率了，本来抱着一颗感恩的心离开这个地方，以为毕竟是带我入门的平台。但是在和人力同事沟通中，我说给领导发了短信，审批oa流程。然后一个不知道身份的说“没什么事儿别和领导直接联系”（后来打听到管党建的职员），当然我做出了反驳，她说“你直接找领导会显得我们工作失职”。哎，公司最后一点好感被这“人”彻底毁灭了，轰然倒塌的那种！罢了，毕竟以后和我没啥交集。写到这里不知道自己今天干了啥，真是无聊的文字，远不及看两集《迷雾》。。。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;离职起因与规划&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　个人是一个忧患意识很强的选手，15年来到这里，公司的定位中最核心是“保证系统安全、稳定生产”，提前转正后自己的想法换来的是一盆接着一盆的冷水，给我感觉是这里工作只要是个人就能干，真的毫不夸张！（写着写着让我想起了鸣人），在学长的经验传授和经历的一次次教训下，我开始强迫自己去适应，找一套自己的工作与学习方式。是的，我很快找到了！那就是最短时间干完交付工作，剩下时间学习自己感兴趣的技术，可是实际大多是下班时间或者零碎的工作时间。这样坚持了近两年，这之间被组长、经理多次批评，原因很简单，不说都明白。但是对于一个有长远打算的选手，深知业务专家不是我的方向，当下这个阶段需要积累强大的技能。一定要练就成的技能是——能解决大多数人不能解决的问题。使蛮力埋头加班苦干，当一个搬砖老黄牛的是肯定没有前途的，天天被业务压得喘不过气来！我宁愿被leader们批，也要把时间挤出来努力学习基础知识，多掌握一些技术，然后才能有机会改变自己目前的状况。因为，比起个人未来，被老板骂、绩效不好拿不到奖金，都不是什么事儿。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　想到之前那段时间，一直泡在业务中（业务很重要），慢慢发现自己啥都不会了，除了内心很恐惧，同时也抱怨自己当初做的这个选择。这段时光会深埋在我的内心，相信会伴随我以后的职业生涯，用来提醒自己。好了，那么离职原因就是：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;个人发展与公司定位冲突&lt;/strong&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;薪资不满意；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;央企体制比较烦；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;看不惯溜须拍马、阿谀奉承；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最后就是本公司职能同事喜欢装逼（通过今天的事儿才发现，一副领导语气）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;其他的就不写了&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;走出保护圈&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;按照我的计划，确实很见成效，对于环境搭建、高级开发、新技术等等可以独立负责，越来越多的时间为别人解答问题了。于是17年12月的一天，又失眠了！天一亮就开始动手在StackEdit制作个人简历，这一夜不知道自己有没有睡着，反正第二天格外的兴奋。接下来是将简历公开并投递了一家知名公司，最后拿到了offer，给我的是自动化架构师职位，薪资接近翻倍（因为现在低0~0）。想了好久，最终结论是自动化永远不可能成为核心部门，获取资源必定有限，果断放弃！接着接到了各个行业的it公司电话，都不满意，整整一月很暗淡，都有些怀疑自己了。快过年时接到了几个猎头电话，为了不相互耽搁，婉拒了几个，和一个S猎头做了深入了解。最后安排了一系列的见面沟通、和面试，最后个人选择放弃了，因为我目前还属于一个积累学习技能阶段，还没到他们提供的职位。最后去了目前这家，至于过程嘛，感觉不具有代表性（运气成分高），就不细致说了。希望以后的道路自己注意一下几点：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;坚持长期学习，积累技能才能掌握主动权；&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;重要的事要有长远打算不可浮躁；&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;一旦下定决心就去做；&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不要在乎眼前那点所谓的晋升前景；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;远离“只说不做的队友”；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;多和大牛、志同道合交流，&lt;/span&gt;&lt;span&gt;远离“装大牛的队友”；&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;　   &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;希望帝国企业效率高点，快点给我办理后续手续，都快一个月了！！！&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　感谢学长和那些志同道合的兄弟们过去的完美合作，以后有机会一起干，祝愿你们bug少少，事业有成~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，感谢女票这些年的理解、陪伴与支持，顺带也祝自己生日快乐~（都忘记了，刚才接到电话才想起来~）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　night~&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Mar 2018 16:45:00 +0000</pubDate>
<dc:creator>xnchall</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xnchll/p/8636048.html</dc:identifier>
</item>
<item>
<title>python函数式编程之yield表达式形式 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/8635777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/8635777.html</guid>
<description>&lt;p&gt;先来看一个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;starting...&quot;)
    while True:
        res = yield
        print(&quot;res:&quot;,res)

g = foo()
next(g)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的例子里，因为foo函数中有yield关键字，所以foo()函数的执行结果g是一个生成器，此时可以使用&lt;code&gt;next(g)&lt;/code&gt;或者&lt;code&gt;g.__next__()&lt;/code&gt;方法触发生成器的执行&lt;/p&gt;
&lt;p&gt;程序的执行结果为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;starting...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;next(g)&lt;/code&gt;触发生成器的执行时，程序会按照正常的顺序从上向下执行，遇到yield，程序就会暂停&lt;br/&gt;并把yield后面所接的值返回&lt;/p&gt;
&lt;p&gt;打印next(g)的执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;starting...&quot;)
    while True:
        res = yield
        print(&quot;res:&quot;,res)

g = foo()
print(next(g))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;starting...
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的例子里，执行一次next(g)方法，程序暂停在yield那一行，此时再次调用next(g)，程序会从yield语句那一行继续向下运行&lt;/p&gt;
&lt;p&gt;修改上面的代码，多调用几次next方法，并打印next方法的返回结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;starting...&quot;)
    while True:
        res = yield
        print(&quot;res:&quot;,res)

g = foo()
print(next(g))
print(&quot;*&quot;*20)
print(next(g))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码的执行结果为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;starting...
None
********************
res: None
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，程序确实按猜想的步骤运行，但是上面的程序也有一个很明显的缺点：那就是上面的代码没有任何的实际意义:&lt;code&gt;res的值永远为None&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在实际的开发中，使用yield表达式形式的目的是yield可以得到一个值，然后yield把这个值赋值给某个变量，这样才有实际意义&lt;/p&gt;
&lt;p&gt;那应该怎么操作才能为res变量赋一个值呢？？那就是调用生成器自身的send方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;send方法可以触发一次生成器执行，同时还可以把send方法的参数传递给yield&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改上面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;starting...&quot;)
    while True:
        res = yield
        print(&quot;res:&quot;,res)

g = foo()
next(g)
print(g.send(5))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序的执行结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;starting...
res: 5
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来分析一下上面的代码的执行过程 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g.
2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环
3.程序遇到yield关键字，程序暂停，此时next(g)语句执行完成
4.程序执行g.send(5)，程序会从yield关键字那一行继续向下运行，send会把5这个值传递给yield
5.yield接收到send方法传递过来的值，然后由yield赋值给res变量
6.由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环
7.程序执行再次遇到yield关键字，yield会返回后面的值，由于yield后面没有接任何参数，所以yield会返回None,程序再次暂停，直到再次调用next方法或send方法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改代码，多次调用send方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;starting...&quot;)
    while True:
        res = yield
        print(&quot;res:&quot;,res)

g = foo()
next(g)
print(g.send(5))
print(&quot;*&quot;*20)
print(g.send(10))
print(&quot;#&quot;*20)
print(g.send(15))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行程序，得到如下结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;starting...
res: 5
None
********************
res: 10
None
####################
res: 15
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，上面代码的执行过程如同上面的分析的执行过程一样运行&lt;/p&gt;
&lt;p&gt;在上面的例子里，如果调用send方法时，传递的参数为None,得到的结果会是怎么样的呢？？&lt;/p&gt;
&lt;p&gt;从上面的分析中，可以知道:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如果`g.send()`方法发送给yield关键字的参数为None,则yield关键字传递给res变量的值就为None
由于yield后面本来没有接任何值，所以yield返回的值默认也为None,所以程序执行结果会得到两个None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改代码，验证上面的猜想&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;starting...&quot;)
    while True:
        res = yield
        print(&quot;res:&quot;,res)

g = foo()
next(g)
print(&quot;#&quot;*20)
print(g.send(None))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看程序的执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;starting...
####################
res: None
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从程序的执行结果可以看出，如果调用生成器的send方法时，传递的参数为None,则程序执行的结果将会是两个None&lt;/p&gt;
&lt;h2 id=&quot;使用yield表达式形式实现linux系统中的grep--rl-root-etc命令&quot;&gt;使用yield表达式形式实现linux系统中的&lt;code&gt;&quot;grep -rl root /etc&quot;&lt;/code&gt;命令&lt;/h2&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import os

def init(func):
    def wrapper(*args, **kwargs):
        g = func(*args, **kwargs)
        next(g)
        return g
    return wrapper

@init
def get_file_path(target):
    &quot;&quot;&quot;
    get file abspath
    # 阶段一：递归找文件的绝对路径，把文件的完事路径发送给阶段二
    :param target:
    :return:
    &quot;&quot;&quot;
    while True:
        start_path = yield
        g = os.walk(start_path)
        for parent_dir, _, files in g:
            for file in files:
                file_path = r&quot;%s\%s&quot; % (parent_dir, file)
                target.send(file_path)

@init
def opener(target):
    &quot;&quot;&quot;
    get file obj
    # 阶段二：收到文件的完整路径，打开文件获取文件对象，把文件对象发送给阶段三
    :param target:
    :return:
    &quot;&quot;&quot;
    while True:
        file_path = yield
        with open(file_path, encoding='utf-8') as f:
            target.send((file_path, f))

@init
def cat_file(target):
    &quot;&quot;&quot;
    read file content
    # 阶段三：收到文件对象，for循环读取文件的每一行内容，把每一行内容发给阶段四
    :param target:
    :return:
    &quot;&quot;&quot;
    while True:
        file_path, f = yield
        for line in f:
            file_content = target.send((file_path, line))
            if file_content:
                break

@init
def grep(target, pattern):
    &quot;&quot;&quot;
    grep function
    # 阶段四：收到文件的一行内容，判断要查找的内容是否在这一行中，如果在，则把文件名发送给阶段五
    :param target:
    :param pattern:
    :return:
    &quot;&quot;&quot;
    tag = False
    while True:
        file_path, line = yield tag
        tag = False
        if pattern in line:
            target.send(file_path)
            tag = True

@init
def printer():
    &quot;&quot;&quot;
    print file name
    # 阶段五：收到文件名，打印结果
    :return:
    &quot;&quot;&quot;
    while True:
        filename = yield
        print(filename)

path1 = &quot;/root&quot;         # 定义要搜索的路径
path2 = &quot;/etc&quot;          # 定义要搜索的路径

g = get_file_path(opener(cat_file(grep(printer(), &quot;root&quot;))))
print(g)
g.send(path1)
g.send(path2)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 23 Mar 2018 15:45:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/8635777.html</dc:identifier>
</item>
<item>
<title>rocketMq概念介绍 - king-晴天</title>
<link>http://www.cnblogs.com/lebron374/p/8635657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lebron374/p/8635657.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://rocketmq.apache.org/&quot; target=&quot;_blank&quot;&gt;    http://rocketmq.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;rocketMq逻辑概念介绍&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;http://upload-images.jianshu.io/upload_images/6302559-44e8478907e758d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;rocketMq逻辑图&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：&lt;br/&gt;    改图片分享自&lt;a href=&quot;https://www.cnblogs.com/tommyli/p/5081846.html&quot; target=&quot;_blank&quot;&gt;李占卫的网上家园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;    在rocketMq的中核心4组件为namesrv、broker、consumer、producer。&lt;/p&gt;
&lt;p&gt;    broker：消息存储中心，主要用来存储消息并通过namesrv对外提供服务。&lt;/p&gt;
&lt;p&gt;    namesrv：无状态的注册中心，功能用来保存broker的相关的元信息并提供给producer在发送消息过程中和提供给consumer消费消息过程中查找broker信息。&lt;/p&gt;
&lt;p&gt;    producer：消息生产者，通过namesrv获取broker的地址并发送消息。&lt;/p&gt;
&lt;p&gt;    consumer：消息消费者，通过namesrv获取broker的地址并消费消息。&lt;/p&gt;


&lt;h2&gt;rocketMq部署情况介绍&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;http://upload-images.jianshu.io/upload_images/6302559-e017e68f261d7bc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;rocketMq部署图&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;http://upload-images.jianshu.io/upload_images/6302559-a51c7f797c9368ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;rocketMq的集群概念细分&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;    rocketMq实际部署图，每个组件都可以用集群形式出现。&lt;/p&gt;
&lt;p&gt;    producer：通过producerGroup的名字来标记自己是一个集群。&lt;/p&gt;
&lt;p&gt;    consumer：通过consumerGroup的名字来标记自己是一个集群。&lt;/p&gt;
&lt;p&gt;    namesrv：相互之间无通信，通过部署多台机器来标记自己是一个伪集群。&lt;/p&gt;
&lt;p&gt;    broker：通过clusterName来标记集群，每个broker通过clusterName来表明cluster层面集群，通过brokerName来标明broker层面集群，通过brokerId标明主从身份。&lt;/p&gt;

&lt;h2&gt;rocketMq消息存储介绍&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;http://upload-images.jianshu.io/upload_images/6302559-09495c7337e2d910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;rocketMq消息存储&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    rocketMq的消息存储通过二级索引来进行，其中实际消息存储在Commit Log的逻辑队列中（磁盘文件消息顺序写），consume queue保存着每个消息消费队列的待消费的数据并且指向commit Log。&lt;/p&gt;

&lt;h2&gt;rocketMq线上配置介绍&lt;/h2&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;http://upload-images.jianshu.io/upload_images/6302559-86b2bab2a187ef25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;rocketMq实际数据存储&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    rocketMq线上环境的真实存储，每个broker的存储数据格式就是类似上图。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;config目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        consumerFilter：保存consumer端的消息过滤配置，应该是等消费端配置了过滤规则就会在这个文件中增加记录。&lt;/p&gt;
&lt;p&gt;        consumerOffset：消费进度偏移量，以topic@consumerGroup作区别，0:125的0代表队列，125代表消费偏移量。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;http://upload-images.jianshu.io/upload_images/6302559-d10dd49cf2c9e7bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;consumerOffset&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;delayOffset：延迟队列消费进度，其中2代表延迟粒度，2000代表消费进度。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;http://upload-images.jianshu.io/upload_images/6302559-32270f3bd8d4f0e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;delayOffset&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;subscriptionGroup：表示订阅消费的消费组。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;http://upload-images.jianshu.io/upload_images/6302559-5d5224bab6021fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;subscriptionGroup&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;topic：rocketMq中topic的信息，可以理解topic为业务消息分组的粒度，一般一个topic为一类业务的逻辑消息集合。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;http://upload-images.jianshu.io/upload_images/6302559-6a947773111d4ff4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;topic &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;commitlog目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    rocketMq实际存储消息的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;consumequeue目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    %DLQ%@ConsumeGroupA：消费分组的死信队列，保存指向commit log的索引。&lt;/p&gt;
&lt;p&gt;    %RETRY%@ConsumeGroupA：消费分组的充实队列，保存指向commit log的索引。&lt;/p&gt;
&lt;p&gt;    SCHEDULE_TOPIC_XXXX：延迟消息队列，保存指向commit log的索引。&lt;/p&gt;
&lt;p&gt;    TOPICA：topic的消费队列存储，保存指向commit log的索引。&lt;/p&gt;
</description>
<pubDate>Fri, 23 Mar 2018 15:30:00 +0000</pubDate>
<dc:creator>king-晴天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lebron374/p/8635657.html</dc:identifier>
</item>
<item>
<title>15.C++-操作符重载 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8635556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8635556.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;首先回忆下以前学的函数重载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数重载&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;函数重载的本质为&lt;strong&gt;&lt;span&gt;相互独立的不同函数&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;&lt;span&gt;函数名&lt;/span&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;span&gt;函数参数&lt;/span&gt;&lt;/strong&gt;来确定函数调用&lt;/li&gt;
&lt;li&gt;无法直接通过函数名得到重载函数的入口地址&lt;/li&gt;
&lt;li&gt;函数重载必然发生在&lt;strong&gt;&lt;span&gt;同一个作用域&lt;/span&gt;&lt;/strong&gt;中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;类中的函数重载&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;静态成员函数&lt;/span&gt;&lt;/strong&gt;能与&lt;strong&gt;&lt;span&gt;普通成员函数&lt;/span&gt;&lt;/strong&gt;建立重载关系&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;全局函数&lt;/span&gt;&lt;/strong&gt;和成员函数&lt;span&gt;&lt;strong&gt;不能构成&lt;/strong&gt;&lt;/span&gt;重载关系&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;操作符重载&lt;/strong&gt;(operator)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是操作符重载?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大家都知道,在C里,有&lt;strong&gt;&lt;span&gt;'+，-，*，/'&lt;/span&gt;&lt;/strong&gt;这些操作符,且它们的功能就是实现普通变量运算。&lt;/p&gt;
&lt;p&gt;由于C++是面向对象的,遇到的变量大多都是对象,所以优化了C里的操作符,&lt;span&gt;&lt;strong&gt;使它们拥有了重载能力&lt;/strong&gt;&lt;/span&gt;.能通过一定方式,使&lt;span&gt;&lt;strong&gt;对象&lt;/strong&gt;&lt;/span&gt;能进行&lt;strong&gt;&lt;span&gt;'+，-，*，/'&lt;/span&gt;&lt;/strong&gt;等运算.&lt;/p&gt;
&lt;p&gt;操作符的重载是&lt;span&gt;&lt;strong&gt;以函数的方式&lt;/strong&gt;&lt;/span&gt;进行.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;操作符重载定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;操作符重载,通过&lt;span&gt;&lt;strong&gt;operator关键字&lt;/strong&gt;&lt;/span&gt;在函数前定义:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[返回类型]  operator  [需要重载的操作符](函数参数)

{

       //......

}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;操作符重载有几种方式 : &lt;span&gt;全局操作符重载函数、全局操作符重载函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;编译器首先会判断运算的若是对象,就会先从类里寻找&lt;strong&gt;&lt;span&gt;成员操作符重载函数&lt;/span&gt;&lt;/strong&gt;,若没找到,就会再去全局里寻找&lt;span&gt;&lt;strong&gt;全局操作符重载函数.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意事项:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;操作符重载&lt;span&gt;&lt;strong&gt;不能改变&lt;/strong&gt;&lt;/span&gt;原操作符的&lt;span&gt;&lt;strong&gt;优先级&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;操作符重载&lt;span&gt;&lt;strong&gt;不能改变&lt;/strong&gt;&lt;/span&gt;操作数的&lt;span&gt;&lt;strong&gt;个数&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;操作符重载的参数一般设为&lt;span&gt;&lt;strong&gt;const class_name &amp;amp;&lt;/strong&gt;&lt;/span&gt;类型&lt;span&gt;(若只设为const class_name,&lt;span&gt;会产生临时对象&lt;/span&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在C++中,有些操作符必须需要&lt;span&gt;&lt;strong&gt;有对象支持&lt;/strong&gt;&lt;/span&gt;,所以只能为成员函数.  比如&lt;span&gt;赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&amp;gt;）:&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Test t3=t2;   //相当于调用了: Test  t3.operator =(t2);  里面会通过this指针来代替左侧数t3
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;有些操作符既可以当做&lt;strong&gt;&lt;span&gt;成员操作符重载函数&lt;/span&gt;&lt;/strong&gt;,也可以当做&lt;span&gt;&lt;strong&gt;全局操作符重载函数&lt;/strong&gt;&lt;/span&gt;,比如&lt;span&gt;加法(+):&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;当设为全局操作符重载函数时,执行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Test t3=t1+t2;  //相当于调用了:  Test t3 = operator +(t1,t2); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当设为成员操作符重载函数时,执行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Test t3=t1+t2;  //相当于调用了:  Test t3 =t1.operator +(t2);  //里面会通过this指针来代替左侧数t1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;初步试验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.接下来,来个&lt;span&gt;&lt;strong&gt;全局操作符重载函数&lt;/strong&gt;&lt;/span&gt;例子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#include &quot;stdio.h&quot;


class Test{

       int x;
       int y;

public:
       Test(int x=0,int y=0)
       {
              this-&amp;gt;x=x;
              this-&amp;gt;y=y;     
       }
       int getx()
       {
              return x;
       }
       int gety()
       {
              return y;
       }

       friend Test operator + (const Test&amp;amp; t1,const Test&amp;amp; t2);
                                                 //声明友元函数,可以使用私有成员变量     

};

Test operator + (const Test&amp;amp; t1,const Test&amp;amp; t2)              //重载
{
       Test ret;
       ret.x=t1.x+t2.x;
       ret.y=t1.y+t2.y;
       return ret;
}

int main()
{
       Test t1(1,3);
       Test t2(2,4);
       Test t3= t1 + t2;           // 其实就是调用: Test t3 = operator +(t1,t2);

       printf(&quot;t3.x:%d  t3.y:%d\n&quot;,t3.getx(),t3.gety());  

       Test t4 =operator +(t1,t3);   // t4 =t1 +t3

       printf(&quot;t4.x:%d  t4.y:%d\n&quot;,t4.getx(),t4.gety());

       return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;打印结果:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
t3.x:3  t3.y:7
t4.x:4  t4.y:10
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.换成&lt;span&gt;&lt;strong&gt;成员操作符重载函数&lt;/strong&gt;&lt;/span&gt;例子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#include &quot;stdio.h&quot;

class Test{

       int x;
       int y;

public:
       Test(int x=0,int y=0)
       {
         this-&amp;gt;x =x;
         this-&amp;gt;y =y;
       }

       int getx()
       {
              return x;
       }

       int gety()
       {
              return y;
       }   

    Test operator + (const Test&amp;amp; t2)
       {
              Test ret;

              ret.x = this-&amp;gt;x + t2.x;
              ret.y = this-&amp;gt;y + t2.y;
              return ret;
       }                                 
};

int main()
{
       Test t1(1,3);
       Test t2(2,4); 
       Test t3= t1 + t2;           // 其实就是调用: Test t3 =t1.operator +(t2);

       printf(&quot;t3.x:%d  t3.y:%d\n&quot;,t3.getx(),t3.gety());   

       Test t4 =t1.operator +(t3);   // t4 =t1 +t3

       printf(&quot;t4.x:%d  t4.y:%d\n&quot;,t4.getx(),t4.gety()); 

       return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;打印结果:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
t3.x:3  t3.y:7
t4.x:4  t4.y:10
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;加深理解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于C++里,&lt;span&gt;&lt;strong&gt;没有复数的慨念&lt;/strong&gt;&lt;/span&gt;,而在刚刚又学习了&lt;span&gt;&lt;strong&gt;操作符重载&lt;/strong&gt;&lt;/span&gt;,所以接下来便通过操作符重载来&lt;span&gt;&lt;strong&gt;实现复数类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复数类应该具有&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;两个成员&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实部a 、虚部b&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;运算操作符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;+ -&lt;/span&gt;&lt;/strong&gt; :  结果 = 两个实部进行加减,两个虚部进行加减&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;*  &lt;/span&gt;&lt;/strong&gt; :  结果 = (a1+b1)(a2+b2)= (a1*a2 - b1*b2 )+( a2*b1 + a1*b2);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;/  &lt;/span&gt;&lt;/strong&gt; :  结果 =(a1+b1)/(a2+b2)= (a1*a2+b1*b2)/(a2* a2+b2* b2) +(b1*a2-a1*b2)/(a2* a2+b2* b2)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;比较操作符&lt;/strong&gt;&lt;/span&gt;:&lt;span&gt;&lt;strong&gt;== ,!=&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;赋值操作符:&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;求模成员函数&lt;/span&gt; :&lt;/strong&gt; 等于a^2+b^2的算术平方根&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以复数类的操作符重载共有以下几个:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201803/1182576-20180323224436410-595684387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.写头文件Complex.h:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#ifndef __COMPLEX_H
#define __COMPLEX_H

class Complex{

private:
       double a;
       double b;

public:
       Complex(int a=0,int b=0);
       Complex operator + (const Complex&amp;amp; t);
       Complex operator - (const Complex&amp;amp; t);
       Complex operator * (const Complex&amp;amp; t);
       Complex operator / (const Complex&amp;amp; t);
       bool operator == (const Complex&amp;amp; t);
       bool operator != (const Complex&amp;amp; t);
       Complex&amp;amp; operator = (const Complex&amp;amp; t);

       double getModulus();

       double getA();
       double getB();
};

#endif
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.写源文件Complex.cpp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#include &quot;Complex.h&quot;
#include &quot;math.h&quot;

Complex::Complex(int a,int b)
{
       this-&amp;gt;a = a;
       this-&amp;gt;b = b;
}

Complex Complex::operator + (const Complex&amp;amp; t)
{
       Complex ret;   

       ret.a = a + t.a;
       ret.b = b + t.b;
       return ret;
}   

Complex Complex::operator - (const Complex&amp;amp; t)
{
       Complex ret;  

       ret.a = a - t.a;
       ret.b = b - t.b;
       return ret;
}

      

Complex Complex::operator * (const Complex&amp;amp; t)
{
       Complex ret;
       ret.a = (a* t.a - b* t.b );
       ret.b = (t.a *b + a* t.b );     
       return ret;
}

 

      

Complex Complex::operator / (const Complex&amp;amp; t)
{
       Complex ret;
       ret.a = (a* t.a + b* t.b)/(t.a * t.a + t.b * t.b);
       ret.b = (b* t.a - a* t.b)/(t.a * t.a + t.b * t.b);     
       return ret;
}

      

bool Complex::operator == (const Complex&amp;amp; t)
{
       if((a== t.a)&amp;amp;&amp;amp;(b== t.b))
        return true;

       else
        return false;
}     

bool Complex::operator != (const Complex&amp;amp; t)
{
       if((a!= t.a)||(b!= t.b))
        return true;

       else
        return false;
}

Complex&amp;amp; Complex::operator = (const Complex&amp;amp; t)
{
       if(this != &amp;amp;t)
       {
         a = t.a;
         b = t.b;
       }
       return *this;
}     

double Complex::getModulus()
{
       return sqrt( a*a + b*b);
}
     

double Complex::getA()
{
       return a;
}     

double Complex::getB()
{
       return b;
}     
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.写测试文件test.cpp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#include &quot;stdio.h&quot;
#include &quot;Complex.h&quot;

int main()
{
       Complex t1(1,3);
       Complex t2(2,6);

       Complex t3=t1+t2;

       printf(&quot;t3.a=%f  t3.b=%f\n&quot;,t3.getA(),t3.getB());

       printf(&quot;t3 Modulus:%f\n&quot;,t3.getModulus());

       Complex t4=t3;

       printf(&quot;t4==t3: %d\n&quot;,t4==t3);
       printf(&quot;t4!=t3: %d\n&quot;,t4!=t3);
       printf(&quot;t3==t1: %d\n&quot;,t3==t1);

       return 0;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.编译运行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
t3.a=3.000000  t3.b=9.000000
t3 Modulus:9.486833
t4==t3: 1                                   //为真
t4!=t3: 0                                   //为假
t3==t1: 0                                   //为假
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Mar 2018 14:57:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8635556.html</dc:identifier>
</item>
<item>
<title>numpy用法小结 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/8635261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/8635261.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　个人感觉网上对numpy的总结感觉不够详尽细致，在这里我对numpy做个相对细致的小结吧，在数据分析与人工智能方面会有所涉及到的东西在这里都说说吧，也是对自己学习的一种小结！&lt;/p&gt;
&lt;h2&gt;numpy用法的介绍&lt;/h2&gt;
&lt;p&gt;　　安装部分我就不说了，装个pip，使用命令pip install numpy就可以安装了，在Ubuntu中可能会出现没有权限的提示，直接加上sudo即可，以下讲解都是建立在python3平台的讲解，python2类似，python3中安装的时候使用sudo pip3 install numpy即可。&lt;/p&gt;
&lt;p&gt;　　首先，numpy是个求解数学矩阵，做矩阵计算&lt;/p&gt;
&lt;h3&gt;1.genfromtxt&lt;/h3&gt;
&lt;p&gt;　　numpy numpy.genfromtxt(&quot;&quot;)，这里我们讲解下，genfromtxt函数的意思是读取文件信息，用来处理数据信息，可以处理数据文件&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy

world_alcohol &lt;/span&gt;= numpy.genfromtxt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world_alcohol.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,delimiter = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,dtype =&lt;span&gt; str)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(world_alcohol))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(world_alcohol)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(help(numpy.genfromtxt))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;numpy.ndarray&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
[[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;WHO region&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Country&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Beverage Types&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Display Value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
 [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1986&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Western Pacific&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Viet Nam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Wine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
 [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1986&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Americas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Uruguay&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Other&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
 ...,
 [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1987&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Africa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Malawi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Other&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.75&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
 [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1989&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Americas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bahamas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Wine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
 [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1985&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Africa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Malawi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Spirits&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.31&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]]
Help on function genfromtxt &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; module numpy.lib.npyio:

genfromtxt(fname, dtype&lt;/span&gt;=&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, comments=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, delimiter=None, skip_header=0, skip_footer=0, converters=None, missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, autostrip=False, case_sensitive=True, defaultfmt=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;f%i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, unpack=None, usemask=False, loose=True, invalid_raise=True, max_rows=&lt;span&gt;None)
    Load data &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; a text file, with missing values handled as specified.

    Each line past the first `skip_header` lines &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; split at the `delimiter`
    character, &lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt; characters following the `comments` character are discarded.

    Parameters
    &lt;/span&gt;----------&lt;span&gt;
    fname : file, str, pathlib.Path, list of str, generator
        File, filename, list, &lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt; generator to read.  If the filename
        extension &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; `.gz` &lt;span&gt;or&lt;/span&gt; `.bz2`, the file &lt;span&gt;is&lt;/span&gt;&lt;span&gt; first decompressed. Note
        that generators must &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; byte strings &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Python 3k.  The strings
        &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; a list &lt;span&gt;or&lt;/span&gt;&lt;span&gt; produced by a generator are treated as lines.
    dtype : dtype, optional
        Data type of the resulting array.
        If None, the dtypes will be determined by the contents of each
        column, individually.
    comments : str, optional
        The character used to indicate the start of a comment.
        All the characters occurring on a line after a comment are discarded
    delimiter : str, int, &lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt; sequence, optional
        The string used to separate values.  By default, any consecutive
        whitespaces act as delimiter.  An integer &lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt; sequence of integers
        can also be provided as width(s) of each field.
&lt;/span&gt;-- More  --
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我解释一下上面的用法，genfromtxt传入了三个参数，第一个参数是数据文件，名为world_alcohol.txt，该数据文件有需要的同学可以加我好友私聊我，或者把你的请求发邮箱至i_love_sjtu@qq.com&lt;/p&gt;
&lt;p&gt;然后delimiter是分隔符，由于数据集中的数据是用逗号分隔的，所以设定参数delimiter=','，dtype是获取数据类型，数据集中的类型为str&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;print&lt;span data-mce-=&quot;&quot;&gt;(type(world_alcohol))打印数据文件的数据类型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;print&lt;span data-mce-=&quot;&quot;&gt;(world_alcohol)&lt;/span&gt;&lt;/span&gt;打印数据集&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;print(help(numpy.genfromtxt))&lt;/span&gt;打印genfromtxt用法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;加入skip_header，跳转至以1开头的数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
world_alcohol &lt;/span&gt;= numpy.genfromtxt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world_alcohol.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,delimiter=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,dtype=str,skip_header=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(world_alcohol)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1986&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Western Pacific&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Viet Nam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Wine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
 [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1986&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Americas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Uruguay&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Other&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
 [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1985&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Africa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cte d'Ivoire&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Wine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.62&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
 ...,
 [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1987&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Africa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Malawi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Other&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.75&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
 [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1989&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Americas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bahamas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Wine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
 [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1985&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Africa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Malawi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Spirits&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.31&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;2.shape&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　xxx.shape 显示的功能是查看矩阵或者数组的维数&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy

vector &lt;/span&gt;= numpy.array([5,10,15,20&lt;span&gt;])
matrix &lt;/span&gt;= numpy.array([[5,10,15],[20,25,30],[35,40,45&lt;span&gt;]])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(vector)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(matrix)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(vector.shape)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(matrix.shape)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[ 5 10 15 20&lt;span&gt;]
[[ &lt;/span&gt;5 10 15&lt;span&gt;]
 [&lt;/span&gt;20 25 30&lt;span&gt;]]
(&lt;/span&gt;4&lt;span&gt;,)
(&lt;/span&gt;2, 3&lt;span&gt;)
[Finished &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; 0.6s]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示出当前vector的维度是一维矩阵&lt;br/&gt;matrix的维度是2行3列&lt;/p&gt;
&lt;h3&gt;3.索引&lt;/h3&gt;
&lt;p&gt;一维数组的索引：与Python的列表索引功能相似&lt;/p&gt;
&lt;p&gt;先举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
world_alcohol &lt;/span&gt;= numpy.genfromtxt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world_alcohol.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,delimiter=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,dtype=str,skip_header=1&lt;span&gt;)

uruguay_other_1986 &lt;/span&gt;= world_alcohol[1,4&lt;span&gt;]

third_country &lt;/span&gt;= world_alcohol[2,2&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(uruguay_other_1986)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(third_country)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
0.5&lt;span&gt;
Cte d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ivoire&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;uruguay_other_1986取值的时候取的是第一个列表中的第四个值(从0开始算)&lt;br/&gt;third_country取值的时候取的是第二个列表中的第二个值(从0开始算)&lt;/p&gt;
&lt;h3&gt;4.切片&lt;/h3&gt;
&lt;p&gt;举例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
vector &lt;/span&gt;= numpy.array([5,10,15,20&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(vector[0:3])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[ 5 10 15]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个和python中切片效果一样，取的是左闭右开的界线&lt;/p&gt;
&lt;p&gt;下一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
matrix &lt;/span&gt;= numpy.array([[5,10,15],[20,25,30],[35,40,45&lt;span&gt;]])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(matrix[:,1])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[10 25 40]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;:表示选取所有的行 逗号隔开 然后取列 取第一列(从0开始计算)&lt;/p&gt;
&lt;p&gt;下一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
matrix &lt;/span&gt;= numpy.array([[5,10,15],[20,25,30],[35,40,45&lt;span&gt;]])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(matrix[:,0:2])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[[ 5 10&lt;span&gt;]
 [&lt;/span&gt;20 25&lt;span&gt;]
 [&lt;/span&gt;35 40]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个意思是:表示选取所有的行 逗号隔开 然后取列 这里用到了切片 取的是从第零列开始到第二列(小于2) 实际上取的就是前两列&lt;/p&gt;
&lt;p&gt;下一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
matrix &lt;/span&gt;= numpy.array([[5,10,15],[20,25,30],[35,40,45&lt;span&gt;]])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(matrix[1:3,0:2])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[[20 25&lt;span&gt;]
 [&lt;/span&gt;35 40]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个意思是我们选取的行是第一行到第三行(小于3) 这里用到了切片 然后取列 这也用到了切片 取的是从第零列开始到第二列(小于2) 实际上取的就是前两列&lt;/p&gt;
&lt;h3&gt;5.布尔类型的相关判断&lt;/h3&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
vector &lt;/span&gt;= numpy.array([5,10,15,20&lt;span&gt;])
vector &lt;/span&gt;== 10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;array([False,  True, False, False], dtype=bool)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回一个布尔型结果 判断了该矩阵中是否有值等于10&lt;/p&gt;
&lt;p&gt;== 相当于对矩阵中的每一个元素都进行了一个判断&lt;/p&gt;
&lt;p&gt;下一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
matrix &lt;/span&gt;= numpy.array([[5,10,15],[20,25,30],[35,40,45&lt;span&gt;]])

matrix &lt;/span&gt;== 25
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;array([[False, False, False],
       [False,  True, False],
       [False, False, False]], dtype&lt;/span&gt;=bool)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释的原理和上述一样&lt;/p&gt;
&lt;p&gt;下一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy 
vector &lt;/span&gt;= numpy.array([5,10,15,20&lt;span&gt;])

equal_to_ten &lt;/span&gt;= (vector == 10&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(equal_to_ten)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(vector[equal_to_ten])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[False  True False False]
[&lt;/span&gt;10]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;意思是 vector == 10 直接对矩阵的值做了个判断 把布尔类型的矩阵传递给equal_to_ten&lt;br/&gt;然后的话打印结果为布尔类型的矩阵 这个布尔类型是一个索引 我们打印这个vector[布尔类型的索引]即可找回原值 返回真实值&lt;/p&gt;
&lt;p&gt;下一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
matrix &lt;/span&gt;= numpy.array([[5,10,15],[20,25,30],[35,40,45&lt;span&gt;]])

second_conlumn_25 &lt;/span&gt;= (matrix[:,1] == 25&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(second_conlumn_25)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(matrix[second_conlumn_25, :])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[False  True False]
[[&lt;/span&gt;20 25 30]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;意思是 :表示选取所有的行 逗号隔开 然后取列 取的是第一列(从0开始) 然后直接对这一列的值进行判断 判断这一列&lt;br/&gt;中的元素是否等于25 并将其布尔类型的值传递给second_conlumn_25&lt;/p&gt;
&lt;p&gt;然后打印出的second_conlumn_25的结果为一个布尔类型的列表&lt;/p&gt;
&lt;p&gt;而把second_conlumn_25当作索引值 我们去寻找有25的这一行 逗号隔开 :表示直接选取这一行的数据 然后打印出来&lt;/p&gt;
&lt;p&gt;下一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
vector &lt;/span&gt;= numpy.array([5,10,15,20&lt;span&gt;])
equal_to_ten_and_five &lt;/span&gt;= (vector == 10) &amp;amp; (vector == 5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(equal_to_ten_and_five)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[False False False False]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;意思是查找当前的这个矩阵中的数既等于10又等于5的数 显然不存在 所以全部输出False&lt;/p&gt;
&lt;p&gt;下一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
vector &lt;/span&gt;= numpy.array([5,10,15,20&lt;span&gt;])
equal_to_ten_or_five &lt;/span&gt;= (vector == 10) | (vector == 5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(equal_to_ten_or_five)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[ True  True False False]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;意思是查找当前的这个矩阵中的数等于10或者等于5的数 显然不存在 所以输出True True  False  False&lt;/p&gt;
&lt;h3&gt;6.dtype与astype&lt;/h3&gt;
&lt;p&gt;　　dtype 输出的是矩阵中的数据类型 &lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
vector &lt;/span&gt;= numpy.array([5,10,15,20&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(vector.dtype)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;

&lt;p&gt;如果我们想转换矩阵中的数据类型 我们应该使用astype进行转换&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy

vector &lt;/span&gt;=&lt;span&gt; vector.astype(float)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(vector.dtype)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;

&lt;p&gt;这样就OK了！！！&lt;/p&gt;
&lt;h3&gt;7.min与max&lt;/h3&gt;
&lt;p&gt;min求解该矩阵中的最小值&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
vector &lt;/span&gt;= numpy.array([5,10,15,20&lt;span&gt;])
vector.min()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;

&lt;p&gt;max求解该矩阵中的最大值&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
vector &lt;/span&gt;= numpy.array([5,10,15,20&lt;span&gt;])
vector.max()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;

&lt;h3&gt;8.sum&lt;/h3&gt;
&lt;p&gt;　　sum 可以指定了一个维度 对行或者列求和&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy

matrix &lt;/span&gt;= numpy.array([[5,10,15],[20,25,30],[35,40,45&lt;span&gt;]])

matrix.sum(axis&lt;/span&gt;=1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;array([ 30,  75, 120])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定了一个维度 对行求和&lt;/p&gt;
&lt;p&gt;下个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy

matrix &lt;/span&gt;= numpy.array([[5,10,15],[20,25,30],[35,40,45&lt;span&gt;]])

matrix.sum(axis&lt;/span&gt;=0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;array([60, 75, 90])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定了一个维度 axis = 0 行号为0 相当于对列求和&lt;/p&gt;
&lt;h3&gt;9.reshape&lt;/h3&gt;
&lt;p&gt;　　reshape给数组一个新的形状而不改变其数据&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(np.arange(15&lt;span&gt;))

a &lt;/span&gt;= np.arange(15).reshape(3,5&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14&lt;span&gt;]
[[ 0  &lt;/span&gt;1  2  3  4&lt;span&gt;]
 [ &lt;/span&gt;5  6  7  8  9&lt;span&gt;]
 [&lt;/span&gt;10 11 12 13 14]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;np是指定了numpy的别名，np.arange依次造出十五个元素 变成了一个向量的形式，reshape函数表明，我们要生成一个3行5列这样的矩阵&lt;/p&gt;
&lt;p&gt;此时我们输入如下语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(a.shape)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将会打印出如下结果：&lt;/p&gt;

&lt;h3&gt;10.ndim&lt;/h3&gt;
&lt;p&gt;　　ndim中的dim是英文dimension维度的缩写，表示打印出矩阵的维度&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
a &lt;/span&gt;= np.arange(15).reshape(3,5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a.ndim)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;

&lt;p&gt;打印出当前矩阵的维度为2&lt;/p&gt;
&lt;h3&gt;11.size&lt;/h3&gt;
&lt;p&gt;　　size打印出矩阵的元素个数&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy 
a &lt;/span&gt;= np.arange(15).reshape(3,5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a.size)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;

&lt;h3&gt;12.zeros&lt;/h3&gt;
&lt;p&gt;　　初始化一个矩阵,可以传入参数行和列，生成一个零矩阵&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
np.zeros((&lt;/span&gt;3,4))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;array([[ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.]])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化一个矩阵，生成一个三行四列的零矩阵&lt;/p&gt;
&lt;h3&gt;13.ones&lt;/h3&gt;
&lt;p&gt;　　初始化一个矩阵，可以传入参数行和列，还可以传入数据类型dtype&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
np.ones((&lt;/span&gt;2,3,4),dtype=np.int32)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
array([[[1, 1, 1, 1&lt;span&gt;],
        [&lt;/span&gt;1, 1, 1, 1&lt;span&gt;],
        [&lt;/span&gt;1, 1, 1, 1&lt;span&gt;]],

       [[&lt;/span&gt;1, 1, 1, 1&lt;span&gt;],
        [&lt;/span&gt;1, 1, 1, 1&lt;span&gt;],
        [&lt;/span&gt;1, 1, 1, 1]]])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造出一个三维矩阵 矩阵中的元素均为1 然后我们用dtype指定元素类型为int32&lt;/p&gt;
&lt;h3&gt;14.arange&lt;/h3&gt;
&lt;p&gt;　　arange通过定义起点 终点 步长 然后我们构造出了一个数组 右边界不可以取等号，取的是左闭右开区间&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
np.arange(&lt;/span&gt;10,30,5)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
array([10, 15, 20, 25])
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;15.random&lt;/h3&gt;
&lt;p&gt;　　random构造出一个矩阵 产生的值默认在-1-1之间&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np 
np.random.random((&lt;/span&gt;2,3))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
array([[ 0.77296788,  0.00748236,  0.59905565&lt;span&gt;],
       [ &lt;/span&gt;0.05577331,  0.08520327,  0.58034632]])
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;16.linspace&lt;/h3&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; numpy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pi
np.linspace(0,&lt;/span&gt;2*pi,100)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;134&quot;&gt;
&lt;pre&gt;
array([ 0.        ,  0.06346652,  0.12693304,  0.19039955,  0.25386607&lt;span&gt;,
        &lt;/span&gt;0.31733259,  0.38079911,  0.44426563,  0.50773215,  0.57119866&lt;span&gt;,
        &lt;/span&gt;0.63466518,  0.6981317 ,  0.76159822,  0.82506474,  0.88853126&lt;span&gt;,
        &lt;/span&gt;0.95199777,  1.01546429,  1.07893081,  1.14239733,  1.20586385&lt;span&gt;,
        &lt;/span&gt;1.26933037,  1.33279688,  1.3962634 ,  1.45972992,  1.52319644&lt;span&gt;,
        &lt;/span&gt;1.58666296,  1.65012947,  1.71359599,  1.77706251,  1.84052903&lt;span&gt;,
        &lt;/span&gt;1.90399555,  1.96746207,  2.03092858,  2.0943951 ,  2.15786162&lt;span&gt;,
        &lt;/span&gt;2.22132814,  2.28479466,  2.34826118,  2.41172769,  2.47519421&lt;span&gt;,
        &lt;/span&gt;2.53866073,  2.60212725,  2.66559377,  2.72906028,  2.7925268&lt;span&gt; ,
        &lt;/span&gt;2.85599332,  2.91945984,  2.98292636,  3.04639288,  3.10985939&lt;span&gt;,
        &lt;/span&gt;3.17332591,  3.23679243,  3.30025895,  3.36372547,  3.42719199&lt;span&gt;,
        &lt;/span&gt;3.4906585 ,  3.55412502,  3.61759154,  3.68105806,  3.74452458&lt;span&gt;,
        &lt;/span&gt;3.8079911 ,  3.87145761,  3.93492413,  3.99839065,  4.06185717&lt;span&gt;,
        &lt;/span&gt;4.12532369,  4.1887902 ,  4.25225672,  4.31572324,  4.37918976&lt;span&gt;,
        &lt;/span&gt;4.44265628,  4.5061228 ,  4.56958931,  4.63305583,  4.69652235&lt;span&gt;,
        &lt;/span&gt;4.75998887,  4.82345539,  4.88692191,  4.95038842,  5.01385494&lt;span&gt;,
        &lt;/span&gt;5.07732146,  5.14078798,  5.2042545 ,  5.26772102,  5.33118753&lt;span&gt;,
        &lt;/span&gt;5.39465405,  5.45812057,  5.52158709,  5.58505361,  5.64852012&lt;span&gt;,
        &lt;/span&gt;5.71198664,  5.77545316,  5.83891968,  5.9023862 ,  5.96585272&lt;span&gt;,
        &lt;/span&gt;6.02931923,  6.09278575,  6.15625227,  6.21971879,  6.28318531])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定一个区间 我们要生成100个数 指定了一个值 起点值为0 终点值为2*pi&lt;br/&gt;linspace意思就是在区间里面造出100个值 这100个值间隔是平均的&lt;/p&gt;
&lt;p&gt;再举一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; numpy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pi
np.sin(np.linspace(0,&lt;/span&gt;2*pi,100))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;134&quot;&gt;
&lt;pre&gt;
array([  0.00000000e+00,   6.34239197e-02,   1.26592454e-01&lt;span&gt;,
         &lt;/span&gt;1.89251244e-01,   2.51147987e-01,   3.12033446e-01&lt;span&gt;,
         &lt;/span&gt;3.71662456e-01,   4.29794912e-01,   4.86196736e-01&lt;span&gt;,
         &lt;/span&gt;5.40640817e-01,   5.92907929e-01,   6.42787610e-01&lt;span&gt;,
         &lt;/span&gt;6.90079011e-01,   7.34591709e-01,   7.76146464e-01&lt;span&gt;,
         &lt;/span&gt;8.14575952e-01,   8.49725430e-01,   8.81453363e-01&lt;span&gt;,
         &lt;/span&gt;9.09631995e-01,   9.34147860e-01,   9.54902241e-01&lt;span&gt;,
         &lt;/span&gt;9.71811568e-01,   9.84807753e-01,   9.93838464e-01&lt;span&gt;,
         &lt;/span&gt;9.98867339e-01,   9.99874128e-01,   9.96854776e-01&lt;span&gt;,
         &lt;/span&gt;9.89821442e-01,   9.78802446e-01,   9.63842159e-01&lt;span&gt;,
         &lt;/span&gt;9.45000819e-01,   9.22354294e-01,   8.95993774e-01&lt;span&gt;,
         &lt;/span&gt;8.66025404e-01,   8.32569855e-01,   7.95761841e-01&lt;span&gt;,
         &lt;/span&gt;7.55749574e-01,   7.12694171e-01,   6.66769001e-01&lt;span&gt;,
         &lt;/span&gt;6.18158986e-01,   5.67059864e-01,   5.13677392e-01&lt;span&gt;,
         &lt;/span&gt;4.58226522e-01,   4.00930535e-01,   3.42020143e-01&lt;span&gt;,
         &lt;/span&gt;2.81732557e-01,   2.20310533e-01,   1.58001396e-01&lt;span&gt;,
         &lt;/span&gt;9.50560433e-02,   3.17279335e-02,  -3.17279335e-02&lt;span&gt;,
        &lt;/span&gt;-9.50560433e-02,  -1.58001396e-01,  -2.20310533e-01&lt;span&gt;,
        &lt;/span&gt;-2.81732557e-01,  -3.42020143e-01,  -4.00930535e-01&lt;span&gt;,
        &lt;/span&gt;-4.58226522e-01,  -5.13677392e-01,  -5.67059864e-01&lt;span&gt;,
        &lt;/span&gt;-6.18158986e-01,  -6.66769001e-01,  -7.12694171e-01&lt;span&gt;,
        &lt;/span&gt;-7.55749574e-01,  -7.95761841e-01,  -8.32569855e-01&lt;span&gt;,
        &lt;/span&gt;-8.66025404e-01,  -8.95993774e-01,  -9.22354294e-01&lt;span&gt;,
        &lt;/span&gt;-9.45000819e-01,  -9.63842159e-01,  -9.78802446e-01&lt;span&gt;,
        &lt;/span&gt;-9.89821442e-01,  -9.96854776e-01,  -9.99874128e-01&lt;span&gt;,
        &lt;/span&gt;-9.98867339e-01,  -9.93838464e-01,  -9.84807753e-01&lt;span&gt;,
        &lt;/span&gt;-9.71811568e-01,  -9.54902241e-01,  -9.34147860e-01&lt;span&gt;,
        &lt;/span&gt;-9.09631995e-01,  -8.81453363e-01,  -8.49725430e-01&lt;span&gt;,
        &lt;/span&gt;-8.14575952e-01,  -7.76146464e-01,  -7.34591709e-01&lt;span&gt;,
        &lt;/span&gt;-6.90079011e-01,  -6.42787610e-01,  -5.92907929e-01&lt;span&gt;,
        &lt;/span&gt;-5.40640817e-01,  -4.86196736e-01,  -4.29794912e-01&lt;span&gt;,
        &lt;/span&gt;-3.71662456e-01,  -3.12033446e-01,  -2.51147987e-01&lt;span&gt;,
        &lt;/span&gt;-1.89251244e-01,  -1.26592454e-01,  -6.34239197e-02&lt;span&gt;,
        &lt;/span&gt;-2.44929360e-16])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定一个区间 我们要生成100个数 指定了一个值 起点值为0 终点值为2*pi&lt;br/&gt;linspace意思就是在区间里面造出100个值 这100个值间隔是平均的 然后最后我们对这个值取正弦即可&lt;/p&gt;
&lt;h3&gt;17.floor与ravel&lt;/h3&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
a &lt;/span&gt;= np.floor(10*np.random.random((3,4&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a.ravel())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
a.shape &lt;/span&gt;= (6,2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a.T)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[[ 4.  9.  0.  4&lt;span&gt;.]
 [ &lt;/span&gt;8.  5.  4.  9&lt;span&gt;.]
 [ &lt;/span&gt;1.  9.  2.  6&lt;span&gt;.]]
&lt;/span&gt;------&lt;span&gt;
[ &lt;/span&gt;4.  9.  0.  4.  8.  5.  4.  9.  1.  9.  2.  6&lt;span&gt;.]
&lt;/span&gt;------&lt;span&gt;
[[ &lt;/span&gt;4.  9&lt;span&gt;.]
 [ 0.  &lt;/span&gt;4&lt;span&gt;.]
 [ &lt;/span&gt;8.  5&lt;span&gt;.]
 [ &lt;/span&gt;4.  9&lt;span&gt;.]
 [ &lt;/span&gt;1.  9&lt;span&gt;.]
 [ &lt;/span&gt;2.  6&lt;span&gt;.]]
&lt;/span&gt;------&lt;span&gt;
[[ &lt;/span&gt;4.  0.  8.  4.  1.  2&lt;span&gt;.]
 [ &lt;/span&gt;9.  4.  5.  9.  9.  6.]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;random.random((3,4))是建立一个3行4列的一个区间范围在-1~1的矩阵&lt;br/&gt;然后我们如果觉得值太小了 就可以在np这里*10 floor操作是向下取整&lt;/p&gt;
&lt;p&gt;ravel 是将一个矩阵拉平成一个向量 即用向量的形式表示这个矩阵&lt;/p&gt;
&lt;p&gt;而a.shape(6,2)又将一个向量转换为一个6*2的矩阵 &lt;/p&gt;
&lt;p&gt;a.T表示求矩阵a的一个转置矩阵 行和列进行变换&lt;/p&gt;
&lt;p&gt;如果一个向量中的元素个数已知 我们已经确定了其中的行数或者列数 其实此时另外一个数已经默认确定了 我们不想去计算那个列数或者行数&lt;br/&gt;是多少时 我们应该怎么办呢 我们如果已经确定了其中的行数或者列数 我们只需要在另外一个位置写上-1就好了 此时计算机会自动帮你计算好这个值&lt;/p&gt;
&lt;h3&gt;18.hstack与vstack&lt;/h3&gt;
&lt;p&gt;　　np.hstack((a,b)) 将a矩阵和b矩阵进行横向拼接&lt;/p&gt;
&lt;p&gt;　　np.vstack((a,b))将a矩阵和b矩阵进行纵向拼接&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
a &lt;/span&gt;= np.floor(10*np.random.random((2,12&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(np.hsplit(a,3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(np.hsplit(a,(3,4&lt;span&gt;)))
a &lt;/span&gt;= np.floor(10*np.random.random((12,2&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
np.vsplit(a,&lt;/span&gt;3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;104&quot;&gt;
&lt;pre&gt;
[[ 5.  1.  3.  4.  6.  5.  4.  5.  4.  8.  2.  2&lt;span&gt;.]
 [ &lt;/span&gt;4.  9.  2.  6.  8.  9.  5.  9.  6.  5.  5.  7&lt;span&gt;.]]
&lt;/span&gt;------&lt;span&gt;
[array([[ &lt;/span&gt;5.,  1.,  3.,  4&lt;span&gt;.],
       [ &lt;/span&gt;4.,  9.,  2.,  6.]]), array([[ 6.,  5.,  4.,  5&lt;span&gt;.],
       [ &lt;/span&gt;8.,  9.,  5.,  9.]]), array([[ 4.,  8.,  2.,  2&lt;span&gt;.],
       [ &lt;/span&gt;6.,  5.,  5.,  7&lt;span&gt;.]])]
&lt;/span&gt;------&lt;span&gt;
[array([[ &lt;/span&gt;5.,  1.,  3&lt;span&gt;.],
       [ &lt;/span&gt;4.,  9.,  2.]]), array([[ 4&lt;span&gt;.],
       [ &lt;/span&gt;6.]]), array([[ 6.,  5.,  4.,  5.,  4.,  8.,  2.,  2&lt;span&gt;.],
       [ &lt;/span&gt;8.,  9.,  5.,  9.,  6.,  5.,  5.,  7&lt;span&gt;.]])]
&lt;/span&gt;------&lt;span&gt;
[[ &lt;/span&gt;1.  8&lt;span&gt;.]
 [ &lt;/span&gt;7.  4&lt;span&gt;.]
 [ 0.  &lt;/span&gt;5&lt;span&gt;.]
 [ &lt;/span&gt;9.  1&lt;span&gt;.]
 [ &lt;/span&gt;6.  5&lt;span&gt;.]
 [ &lt;/span&gt;4.  5&lt;span&gt;.]
 [ &lt;/span&gt;1.  2&lt;span&gt;.]
 [ 0.  &lt;/span&gt;1&lt;span&gt;.]
 [ &lt;/span&gt;3.  6&lt;span&gt;.]
 [ &lt;/span&gt;2.  7&lt;span&gt;.]
 [ &lt;/span&gt;7.  8&lt;span&gt;.]
 [ &lt;/span&gt;7.  6&lt;span&gt;.]]

[array([[ &lt;/span&gt;1.,  8&lt;span&gt;.],
        [ &lt;/span&gt;7.,  4&lt;span&gt;.],
        [ 0.,  &lt;/span&gt;5&lt;span&gt;.],
        [ &lt;/span&gt;9.,  1.]]), array([[ 6.,  5&lt;span&gt;.],
        [ &lt;/span&gt;4.,  5&lt;span&gt;.],
        [ &lt;/span&gt;1.,  2&lt;span&gt;.],
        [ 0.,  &lt;/span&gt;1.]]), array([[ 3.,  6&lt;span&gt;.],
        [ &lt;/span&gt;2.,  7&lt;span&gt;.],
        [ &lt;/span&gt;7.,  8&lt;span&gt;.],
        [ &lt;/span&gt;7.,  6.]])]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hsplit是对行进行切分 a表示待切分的行参数 3表示切分成三份&lt;/p&gt;
&lt;p&gt;np.hsplit(a,(3,4)) 传入元组 指定位置进行切割&lt;/p&gt;
&lt;p&gt;vsplit是对列进行切分 a表示待切分的行参数 3表示切分成三份&lt;/p&gt;
&lt;h3&gt;19.view与copy&lt;/h3&gt;
&lt;p&gt;　　view是浅复制&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
a &lt;/span&gt;= np.arange(12&lt;span&gt;)

b &lt;/span&gt;=&lt;span&gt; a

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(b &lt;span&gt;is&lt;/span&gt;&lt;span&gt; a)

b.shape &lt;/span&gt;= 3,4

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a.shape)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(a))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(id(b))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;True
(&lt;/span&gt;3, 4&lt;span&gt;)
&lt;/span&gt;3144967327792
3144967327792
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以发现a与b的地址是相同的，这个就是所谓的深复制&lt;/p&gt;
&lt;p&gt;让我再看看下面这个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
a &lt;/span&gt;= np.arange(12&lt;span&gt;)
c &lt;/span&gt;=&lt;span&gt; a.view()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(c &lt;span&gt;is&lt;/span&gt;&lt;span&gt; a) 
c.shape &lt;/span&gt;= 2,6
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a.shape)
c[0,&lt;/span&gt;4] = 1234
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(a))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(id(c))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;False
(&lt;/span&gt;12&lt;span&gt;,)
[   0    &lt;/span&gt;1    2    3 1234    5    6    7    8    9   10   11&lt;span&gt;]
&lt;/span&gt;2391025174608
2391025175008
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看出浅复制不会复制a的地址到c，改变c的值不会影响到a&lt;/p&gt;
&lt;p&gt;再看下一个写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
a &lt;/span&gt;= np.arange(12&lt;span&gt;)
d &lt;/span&gt;=&lt;span&gt; a.copy()
d &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;

&lt;p&gt;从结果我们可以看出，copy也是属于浅拷贝&lt;/p&gt;
&lt;h3&gt;20.argmax&lt;/h3&gt;
&lt;p&gt;　　argmax 索引最大值的位置&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
data &lt;/span&gt;= np.sin(np.arange(20)).reshape(5,4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data)
ind &lt;/span&gt;= data.argmax(axis=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ind)
data_max &lt;/span&gt;= data[ind,range(data.shape[1&lt;span&gt;])]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data_max)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[[ 0.          0.84147098  0.90929743  0.14112001&lt;span&gt;]
 [&lt;/span&gt;-0.7568025  -0.95892427 -0.2794155   0.6569866&lt;span&gt; ]
 [ &lt;/span&gt;0.98935825  0.41211849 -0.54402111 -0.99999021&lt;span&gt;]
 [&lt;/span&gt;-0.53657292  0.42016704  0.99060736  0.65028784&lt;span&gt;]
 [&lt;/span&gt;-0.28790332 -0.96139749 -0.75098725  0.14987721&lt;span&gt;]]
[&lt;/span&gt;2 0 3 1&lt;span&gt;]
[ &lt;/span&gt;0.98935825  0.84147098  0.99060736  0.6569866 ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;argmax 索引最大值的位置&lt;/p&gt;
&lt;p&gt;data.argmax(axis=0) axis=0意思是指定列去索引 找出最大值返回索引值的位置&lt;/p&gt;
&lt;h3&gt;21.tile&lt;/h3&gt;
&lt;p&gt;　　tile 对当前的行和列进行扩展&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
a &lt;/span&gt;= np.arange(0,40,10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
b &lt;/span&gt;= np.tile(a,(3,5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[ 0 10 20 30&lt;span&gt;]
[[ 0 &lt;/span&gt;10 20 30  0 10 20 30  0 10 20 30  0 10 20 30  0 10 20 30&lt;span&gt;]
 [ 0 &lt;/span&gt;10 20 30  0 10 20 30  0 10 20 30  0 10 20 30  0 10 20 30&lt;span&gt;]
 [ 0 &lt;/span&gt;10 20 30  0 10 20 30  0 10 20 30  0 10 20 30  0 10 20 30]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看出，矩阵由原来的一维扩展到了三行五列&lt;/p&gt;
&lt;h3&gt;22.sort与argsort　&lt;/h3&gt;
&lt;p&gt;　　sort 对当前的数组按照行的维度进行排序(因为axis=1)&lt;/p&gt;
&lt;p&gt;　　argsort 是对值的索引进行排序 默认是值从小到大 然后按照值排序获取索引 输出索引&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
a &lt;/span&gt;= np.array([[4,3,5],[1,2,4&lt;span&gt;]])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
b &lt;/span&gt;= np.sort(a,axis=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
a.sort(axis&lt;/span&gt;=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
a &lt;/span&gt;= np.array([4,3,1,2&lt;span&gt;])
j &lt;/span&gt;=&lt;span&gt; np.argsort(a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(j)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a[j])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[[4 3 5&lt;span&gt;]
 [&lt;/span&gt;1 2 4&lt;span&gt;]]
&lt;/span&gt;------&lt;span&gt;
[[&lt;/span&gt;3 4 5&lt;span&gt;]
 [&lt;/span&gt;1 2 4&lt;span&gt;]]
&lt;/span&gt;------&lt;span&gt;
[[&lt;/span&gt;3 4 5&lt;span&gt;]
 [&lt;/span&gt;1 2 4&lt;span&gt;]]
&lt;/span&gt;------&lt;span&gt;
[&lt;/span&gt;2 3 1&lt;span&gt; 0]
&lt;/span&gt;------&lt;span&gt;
[&lt;/span&gt;1 2 3 4]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是我在运用中所用到的一些函数及用法，欢迎大家指正批评，如果有需要改进的地方，还希望不吝赐教，如果觉得本文对你有用，别忘记关注订阅推荐博主，谢谢大家的支持！！！&lt;/p&gt;

</description>
<pubDate>Fri, 23 Mar 2018 13:49:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/8635261.html</dc:identifier>
</item>
<item>
<title>来自后端的突袭? --开包即食的教程带你浅尝最新开源的C# Web引擎 Blazor - 愚溪</title>
<link>http://www.cnblogs.com/Gerryz/p/get-start-with-dotnet-blazor.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Gerryz/p/get-start-with-dotnet-blazor.html</guid>
<description>&lt;p&gt;在今年年初, 恰逢新春佳节临近的时候. 微软给全球的C#开发者们, 着实的送上了一分惊喜. 微软正式开源Blazor ，将.NET带回到浏览器.&lt;/p&gt;
&lt;p&gt;这个小惊喜, 迅速的在dotnet开发者中间传开了. 而就在昨天(2018年3月22日) Blazor发布了它的第一次Release. Blazor到底是个什么样的东西呢?我们是否真的可以携着C#语言进入前端的市场中? 不如现在就跟我一起体验dotnet blazor吧.&lt;/p&gt;

&lt;p&gt;获取最新版的dotnet core 并安装Blazor模板:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装 最新的.Net Core(版本需要高于2.1.101)&lt;/li&gt;
&lt;li&gt;对于简单的尝试来说, VS code 已经足够. 所以笔者并没有亲自安装Visual Studio.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用命令行初始化项目:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
dotnet new -&lt;span&gt;i Microsoft.AspNetCore.Blazor.Templates
dotnet new blazor -&lt;span&gt;o BlazorApp1
cd BlazorApp1
dotnet run&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;如果你需要使用Visual Studio,
&lt;ul&gt;&lt;li&gt;安装最新的Visual Studio 2017.&lt;/li&gt;
&lt;li&gt;安装 ASP.NET Core Blazor Language Services extension&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;在Visual Studio中创建新的测试项目:&lt;/li&gt;
&lt;li&gt;选择 File -&amp;gt; New Project -&amp;gt; Web -&amp;gt; ASP.NET Core Web Application&lt;/li&gt;
&lt;li&gt;确定在Target Framework里选择了 .NET Core and ASP.NET Core 2.0.&lt;/li&gt;
&lt;li&gt;选择 Blazor 模板&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323182646575-2064136097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;当我们运行起项目之后, 就可以看到如下提示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323183249841-795963385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候我们在浏览器里打开监听的端口 http://localhost:17477. 就可以看到我们这个项目的网页了.&lt;/p&gt;
&lt;p&gt;这个简单的示例项目带了3个页面&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323183454120-170384946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 第一个页面比较简单, 但先别急,让我们打开浏览器工具. 先看看页面在加载页面过程中都加载了什么&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323184143615-509166437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在初次打开页面的时候, 我们看到的是这样一个Loading..的页面.  这个页面的代码是这样的.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;BlazorDemo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;base &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;css/bootstrap/bootstrap.min.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;css/site.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Loading...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;css/bootstrap/bootstrap-native.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;_framework/blazor.js&quot;&lt;/span&gt;&lt;span&gt; main&lt;/span&gt;&lt;span&gt;=&quot;BlazorDemo.dll&quot;&lt;/span&gt;&lt;span&gt; entrypoint&lt;/span&gt;&lt;span&gt;=&quot;BlazorDemo.Program::Main&quot;&lt;/span&gt;&lt;span&gt; references&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Blazor.Browser.dll,Microsoft.AspNetCore.Blazor.dll,Microsoft.Extensions.DependencyInjection.Abstractions.dll,Microsoft.Extensions.DependencyInjection.dll,mscorlib.dll,netstandard.dll,System.Core.dll,System.Diagnostics.StackTrace.dll,System.dll,System.Globalization.Extensions.dll,System.Net.Http.dll,System.Runtime.Serialization.Primitives.dll,System.Security.Cryptography.Algorithms.dll&quot;&lt;/span&gt;&lt;span&gt; linker-enabled&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到这个页面加载了两个js, 第一个是bootstrap的, 第二个叫做blazor.js. 只不过这个js有非常多的参数, 有 main, entrypoint, 和 references. 看看References里写的是不是很熟悉? 一看就是.net的dll.&lt;/p&gt;
&lt;p&gt;blazor.js 加载了mono.js, mono.js 加载了mono.wasm. 这个是个什么文件?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323184823866-677234911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;wasm代表的就是Web Assembly, 简单地说它就是编译好的二进制文件, 可以由浏览器直接运行, 源语言可以是C/C++或者任何可以编译到Web Assembly的文件, 而这里我们加载的就是mono 编译好的Web Assembly文件, 它被加载之后, 相当于浏览器中启动了一个mono 运行环境.&lt;/p&gt;
&lt;p&gt;随后的两个js 是笔者chrome浏览器插入的js, 在这里不要被他们干扰了. 那么mono 运行时加载完成之后. 就需要加载dotnet 的Dll了, 首先是入口库, 接着就是需要的引用库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323185238433-1285299586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好家伙 1.9MB. 当所有的Dll被下载完毕之后, 这个时候我们的浏览器就可以运行我们这个dotnet的网页了. 于是就回到了我们最开始看到的那个应用程序.&lt;/p&gt;
&lt;p&gt;所以 总结一下 blazor.js 调用mono.js, mono.js加载mono.wsam, 然后根据写在script标签里的内容继续的加载dotnet的库文件. 如果浏览器不支持wsam, 就会尝试使用asm.js加载mono.asm.js&lt;/p&gt;

&lt;p&gt;我们已经知道,经过前面的步骤,浏览器里已经运行了一个.Net 运行时了. 而且加载了项目必须的dll. 那么这样一个简单的程序,它的代码究竟是怎么样的呢? &lt;/p&gt;
&lt;p&gt;打开项目代码,映入眼帘的是一个标准的.net Project&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323190639640-1256432441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;_ViewImports.cshtml包含了项目一些其他页面中最常使用的namespace&lt;/p&gt;
&lt;div readability=&quot;224.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
@using System.Net.Http
@using Microsoft.AspNetCore.Blazor
@using Microsoft.AspNetCore.Blazor.Components
@using Microsoft.AspNetCore.Blazor.Layouts
@using Microsoft.AspNetCore.Blazor.Routing
@using BlazorDemo
@using BlazorDemo.Shared
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Program.cs是程序的入口点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Blazor.Browser.Rendering;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Blazor.Browser.Services;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; BlazorDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceProvider = &lt;span&gt;new&lt;/span&gt; BrowserServiceProvider(configure =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add any custom services here&lt;/span&gt;
&lt;span&gt;            });

            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BrowserRenderer(serviceProvider).AddComponent&amp;lt;App&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在入口点中, 我们注册了一个浏览器渲染服务 BrowserRender,让他渲染App&lt;/p&gt;
&lt;p&gt;App.cshmtl是这样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;Router AppAssembly=&lt;span&gt;typeof&lt;/span&gt;(Program).Assembly /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的Router对应的是Microsoft.AspNetCore.Blazor.Routing.Router. 当给它一个AppAssembly时, 他就会自动的把当前的Url 和 AppAssembly的其他Pages对应起来.&lt;/p&gt;
&lt;p&gt;所以 当我们在浏览器里输入 /Counter时,他就会加载Pages/Couter.cshtml.&lt;/p&gt;
&lt;p&gt;Shared文件夹里分别是布局文件,导航栏, 还有一个我们自定义的控件 SurveyPrompt. &lt;/p&gt;
&lt;p&gt;熟悉Razor引擎的小伙伴们一定很轻车熟路了. 那么当我们打开网站时, 默认显示给我们的 就是Index, 这个时候我们会加载Pages/Index.cshtml&lt;/p&gt;
&lt;p&gt;Index.cshtml的代码是这个样子的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@page &quot;/&quot;

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello, world!&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

Welcome to your new app.

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SurveyPrompt &lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;=&quot;How is Blazor working for you?&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@page 可以告诉Router, 当前页面注册到 &quot;/&quot;&lt;/p&gt;
&lt;p&gt;除了显示hello world以外, 我们在这里还看到了刚刚说到的第三方控件. SurveyPrompt. 果然不简单嘛, 一个看似简单的页面, 居然还告诉了我们如何使用自定义控件.&lt;/p&gt;
&lt;p&gt;从声明上看, 我们知道 SunveyPrompt是一个控件,并且有一个属性Title. 现在我们打开它的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;alert alert-survey&quot;&lt;/span&gt;&lt;span&gt; role&lt;/span&gt;&lt;span&gt;=&quot;alert&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;glyphicon glyphicon-ok-circle&quot;&lt;/span&gt;&lt;span&gt; aria-hidden&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

    Please take our
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;=&quot;_blank&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;alert-link&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://go.microsoft.com/fwlink/?linkid=870381&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        brief survey
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    and tell us what you think.
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

@functions
{
    // This is to demonstrate how a parent component can supply parameters
    public string Title { get; set; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到代码分为两部分, @functions上面是类似html的东西, 下面是类似C#的东西. 熟悉React或者Vue的伙伴们恐怕不会对这种混写感到陌生. 这个就是Blazor的语法. Html部分很像使Razor的模板方式. 而最后整个页面都会被编译成一个类, 这个类派生自 Component. 如果你编译过项目, 你会在Debug下面的Shared目录找到一个叫SurveyPrompt.g.cs的东西&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#pragma&lt;/span&gt; checksum &quot;/Users/pzhi/SCM/gitHub/zhipu123/BlazorDemo/Shared/SurveyPrompt.cshtml&quot; &quot;{ff1816ec-aa5e-4d10-87f7-6f4963833460}&quot; &quot;a2a2ea88635b799343bc6d9647bbb818c8a20c9d&quot;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;auto-generated/&amp;gt;&lt;/span&gt;
&lt;span&gt;#pragma&lt;/span&gt; warning disable 1591
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; BlazorDemo.Shared
{
    &lt;/span&gt;&lt;span&gt;#line&lt;/span&gt; hidden
    &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Blazor;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Blazor.Components;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Blazor.Layouts;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Blazor.Routing;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BlazorDemo;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BlazorDemo.Shared;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SurveyPrompt : Microsoft.AspNetCore.Blazor.Components.BlazorComponent
    {
        &lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; warning disable 1998
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BuildRenderTree(Microsoft.AspNetCore.Blazor.RenderTree.RenderTreeBuilder builder)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.BuildRenderTree(builder);
            builder.OpenElement(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddAttribute(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alert alert-survey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddAttribute(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;role&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alert&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddContent(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.OpenElement(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddAttribute(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;glyphicon glyphicon-ok-circle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddAttribute(&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aria-hidden&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.CloseElement();
            builder.AddContent(&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.OpenElement(&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddContent(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;, Title);
            builder.CloseElement();
            builder.AddContent(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n\n    Please take our\n    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.OpenElement(&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddAttribute(&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_blank&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddAttribute(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alert-link&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddAttribute(&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://go.microsoft.com/fwlink/?linkid=870381&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddContent(&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n        brief survey\n    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.CloseElement();
            builder.AddContent(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n    and tell us what you think.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.CloseElement();
            builder.AddContent(&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; warning restore 1998
        
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is to demonstrate how a parent component can supply parameters&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}
&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; warning restore 1591
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们发现@functions里面的内容 会作为这个类的成员变量和 成员方法, 而上面的内容则被编译到了BuildRenderTree方法中.&lt;/p&gt;
&lt;p&gt;那么到了这里我们大概知道了这个简单的HomePage都有什么玄机了. 我们也大概知道了Blazor的语法, 也知道其实我们所有的页面最终都会是一个Componet.&lt;/p&gt;
&lt;p&gt;那么什么是Componet呢? 在这里并不想过多的去笔墨介绍这个概念. 如果你是一个Vue或者React的开发, 你应该对这个模块化开发不陌生. 一个Componet, 就是满足一定的功能, 有自己的属性, 状态. 可以展示特定数据的元素.&lt;/p&gt;
&lt;p&gt;就如同我们这里的SurveyPrompt, 接受一个Title属性,并且负责把他展示成这样子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323193145874-1768851154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在我们知道了一个简单的页面是如何渲染出来的. 那么让我们打开Counter这个配置来看一看. 数据是如何交互的&lt;/p&gt;
&lt;p&gt;我们第二个page张这样子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323193902287-1759931226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一个button, 大声的叫我们点它. 当我们点击的时候. 上面的current count 变成了 1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323193946918-1629688894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这一切是怎么发生的呢? 以下是Counter.cshtml的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@page &quot;/counter&quot;
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Counter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Current count: @currentCount&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@onclick(IncrementCount)&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Click me&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

@functions {
    int currentCount = 0;

    void IncrementCount()
    {
        currentCount++;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们看到 这个页面非常简单, 我们定义了一个CurrentCount的Field, 然后在IncreaseCount方法里给它加一. 一个叫Click me的button标签里 有一个@onclick方法, 将IncreaseCount作为参数&lt;/p&gt;
&lt;p&gt;Counter.cshtml编译后的代码张这样&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#pragma&lt;/span&gt; checksum &quot;/Users/pzhi/SCM/gitHub/zhipu123/BlazorDemo/Pages/Counter.cshtml&quot; &quot;{ff1816ec-aa5e-4d10-87f7-6f4963833460}&quot; &quot;05ad2dd449cbc9f09f8b759e1f06e7eb5e9583b4&quot;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;auto-generated/&amp;gt;&lt;/span&gt;
&lt;span&gt;#pragma&lt;/span&gt; warning disable 1591
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; BlazorDemo.Pages
{
    &lt;/span&gt;&lt;span&gt;#line&lt;/span&gt; hidden
    &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Blazor;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Blazor.Components;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Blazor.Layouts;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Blazor.Routing;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BlazorDemo;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BlazorDemo.Shared;
    [Microsoft.AspNetCore.Blazor.Layouts.LayoutAttribute(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MainLayout))]
    [Microsoft.AspNetCore.Blazor.Components.RouteAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/counter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Counter : Microsoft.AspNetCore.Blazor.Components.BlazorComponent
    {
        &lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; warning disable 1998
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BuildRenderTree(Microsoft.AspNetCore.Blazor.RenderTree.RenderTreeBuilder builder)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.BuildRenderTree(builder);
            builder.OpenElement(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddContent(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Counter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.CloseElement();
            builder.AddContent(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.OpenElement(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddContent(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Current count: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddContent(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;, currentCount);
            builder.CloseElement();
            builder.AddContent(&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.OpenElement(&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.AddAttribute(&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;, onclick(IncrementCount));
            builder.AddContent(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Click me&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.CloseElement();
            builder.AddContent(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; warning restore 1998
        
    &lt;span&gt;int&lt;/span&gt; currentCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; IncrementCount()
    {
        currentCount&lt;/span&gt;++&lt;span&gt;;
    }
    }
}
&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; warning restore 1591
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们看到 @onclick其实在这里就是执行了一个Component的一个方法onclick, 顾名思义,当这个Component被点击的时候就被调用. 我们的IncreaseCount被作为参数传给了它, 可见onclick会在被点击的时候执行IncreaseCount.&lt;/p&gt;
&lt;p&gt;那么问题来了,当我们执行了IncreaseCount方法时, 页面怎么会知道要不要刷新? 是刷新整个页面还是刷新所有?&lt;/p&gt;
&lt;p&gt;熟悉WPF的同学可能知道, 在WPF中如果我们需要让一个ViewModel可以被监听变化, 他就需要实现INotifyChanged事件. 那么同样道理, 我们的这个IncreaseCount可能也是类似的吗?&lt;/p&gt;
&lt;p&gt;然而基于编译后的代码我们可以发现 CurrentCount作为我们Counter这个类的Field, 并没有任何机会高速Page自己变化了. 而且这个Field非常普通,也不是什么WPF中的DP, 所以到目前为止变化是怎么通知的.并没有一个合理的解释. 后面的时间里我会尝试阅读Blazor的代码搞清楚这件事情. &lt;/p&gt;
&lt;p&gt;第一个问题画个问号, 那么第二个问题呢? &lt;/p&gt;
&lt;p&gt;打开浏览器工具, 定位到button, 再次点击button观察dom的反应.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323195239349-2147348522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到 在点击Button的时候, button上面的&amp;lt;p&amp;gt;标签闪动了, 说明它被刷新了, 而其他标签并没有. 所以局部刷新的功能是有的. 效率问题不用担心了. &lt;/p&gt;
&lt;p&gt;编辑Click me, 把他的内容变成 &quot;点击我&quot;, 再次点击按钮, 我们看到还是只有p变, 而且button也没有变回原来的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323195539730-1252460498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 所以我们知道, 这个局部刷新不是简单的拿Dom作比较, 肯定是有Virtual Dom的机制在里面.&lt;/p&gt;


&lt;p&gt;在简单的尝试了Blazor之后, 还是很兴奋的. 可以看到Blazor是一个初具规模的产品. 我们C#开发可以用Blazor在今后写前端渲染的网页了! &lt;/p&gt;
&lt;p&gt;我很期望这样一个产品能够持续的演进下去.&lt;/p&gt;
&lt;p&gt;就目前版本看(0.1.0), Blazor尚不能应用到产品中. 主要还是有以下的原因&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 打包大小太大, 1.8M的大小对于网站简直是致命的.&lt;/li&gt;
&lt;li&gt; 产品还不成熟, 现在Component还只能支持简单的事件, 笔者测试的时候只有onclick,onchange. &lt;/li&gt;
&lt;li&gt; 兼容性差,使用了WebAssembly,就注定了两年前的浏览器必定不能支持.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然我们还是不能否认, Blazor为如何让更多语言进入前端世界打开了一扇新的大门. 也许未来JavaScript将不仅仅是前端唯一可以使用的利器. 我们会看到C/C++, Python, Java写的前端渲染页面也不一定呢.&lt;/p&gt;
&lt;p&gt;当然在后端语言打入前端世界的道路上, WebAssembly也未必是唯一的路劲, 比如Scala.js就完全使用了js重写了Scala的库函数, 类似的还有Kotlin.js. 可以看到虽然JavaScript已经非常Fancy了,但是后端程序员们进军前端的热情可谓从未停歇过啊.&lt;/p&gt;
&lt;p&gt;祝dotnet的应用越来越广, 祝广大后端程序员们新年成就慢慢, 加薪升职.&lt;/p&gt;
&lt;p&gt;最后软广一波, &lt;/p&gt;


&lt;p&gt;&lt;span&gt;别具一格,追求卓越的ThoughtWorks 2018全面招人啦!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不关你是前端, 后端, 开发,测试, 产品经理, BA, 还是运维, 我们这里有号称最难的面试就问你敢不敢 来&lt;strong&gt;挑战&lt;/strong&gt;?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想来的同学们请留言或者发信哈 我的邮箱是 gerry.zhi@foxmail.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/155027/201803/155027-20180323200929550-985960951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;/div&gt;

</description>
<pubDate>Fri, 23 Mar 2018 12:12:00 +0000</pubDate>
<dc:creator>愚溪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Gerryz/p/get-start-with-dotnet-blazor.html</dc:identifier>
</item>
<item>
<title>ASP.NET MVC编程——控制器 - 甜橙很酸</title>
<link>http://www.cnblogs.com/hdwgxz/p/8633661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hdwgxz/p/8633661.html</guid>
<description>&lt;p&gt;&lt;span&gt;每一个请求都会经过控制器处理，控制器中的每个方法被称为控制器操作，它处理具体的请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;操作输入参数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器的操作的输入参数可以是内置类型也可以是自定义类型。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;操作返回结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;结果类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;调用方法&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;备注&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;ContentResult&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;Content&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;文本类型&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;FileContentResult/FileStreamResult/FilePathResult&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;File&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;文件类型&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;HttpStatusCodeResult（HttpNotFoundResult，HttpUnauthorizedResult）&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;HttpNotFound&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;包含404，401状态码&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;JavaScriptResult&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;JavaScript&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;JavaScript代码&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;JsonResult&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;Json&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;Json字符串&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;PartialViewResult&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;PartialView&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;部分视图&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;RedirectResult&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Redirect/RedirectPermanent&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;跳转到给定URL&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;RedirectToRouteResult&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;RedirectToAction/RedirectToRoute&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;重定向到指定的路由&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;ViewResult&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;View&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;指定视图&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;EmptyResult&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;无&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;不返回任何内容&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;上述返回值类型均继承自&lt;/span&gt;ActionResult，除了上述类型外，控制器可以返回任意的类型！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3 HTTP动词特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特性有&lt;/span&gt;HttpGet、HttpPost、HttpDelete、HttpPut、HttpHead、HttpOptions、HttpPatch，当没有限定任何动词时，不论何种请求，get，post，put等等，被请求的操作都会被调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;操作过滤器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;过滤器接口有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;授权过滤器：&lt;/span&gt;public interface IAuthorizationFilter&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动作过滤器：&lt;/span&gt;public interface IActionFilter&lt;/p&gt;
&lt;p&gt;&lt;span&gt;身份验证过滤器：&lt;/span&gt;public interface IAuthenticationFilter&lt;/p&gt;
&lt;p&gt;&lt;span&gt;异常过滤器：&lt;/span&gt;public interface IExceptionFilter&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果过滤器：&lt;/span&gt;public interface IResultFilter&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;AuthorizeAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public class AuthorizeAttribute : FilterAttribute, IAuthorizationFilter&lt;/p&gt;
&lt;p&gt;AuthorizeAttribute的两个常用属性&lt;/p&gt;
&lt;p&gt;Roles：获取或设置有权访问控制器或操作方法的用户角色。&lt;/p&gt;
&lt;p&gt;Users：获取或设置有权访问控制器或操作方法的用户。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以在&lt;/span&gt;Web.config的&amp;lt;system.web&amp;gt;配置未通过验证跳转的页面：&lt;/p&gt;
&lt;p&gt;&amp;lt;authentication mode=&quot;Forms&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;   &amp;lt;forms loginUrl=&quot;~/Account/Login&quot;&amp;gt;&amp;lt;/forms&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/authentication&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配合其使用的属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AllowAnonymous&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public sealed class AllowAnonymousAttribute : Attribute&lt;/p&gt;
&lt;p&gt;&lt;span&gt;允许跳过&lt;/span&gt;AuthorizeAttribute的验证执行控制器操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）ChildActionOnlyAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public sealed class ChildActionOnlyAttribute : FilterAttribute, IAuthorizationFilter&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指示操作方法只能作为子操作进行调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
{
        [ChildActionOnly]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult TestPy()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; PartialView();
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;分部视图&lt;/span&gt;TestPy.cshtml：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div&amp;gt;
   &amp;lt;h1&amp;gt;这是部分视图&amp;lt;/h1&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;调用页&lt;/span&gt;Index.cshtml：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@Url.Action(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Home&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;TestPy&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;点击调用分部视图&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行报错：&lt;/span&gt;404！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将调用页代码修改如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    @Html.Action(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestPy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;运行可以正常显示部分视图内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）RequireHttpsAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public class RequireHttpsAttribute : FilterAttribute, IAuthorizationFilter&lt;/p&gt;
&lt;p&gt;&lt;span&gt;强制通过&lt;/span&gt; HTTPS 重新发送不安全的 HTTP 请求&lt;/p&gt;
&lt;p&gt;4）&lt;strong&gt;ValidateInputAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public class ValidateInputAttribute : FilterAttribute, IAuthorizationFilter&lt;/p&gt;
&lt;p&gt;&lt;span&gt;验证通过窗体传进来的信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5）&lt;strong&gt;ValidateAntiForgeryTokenAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public sealed class ValidateAntiForgeryTokenAttribute : FilterAttribute, IAuthorizationFilter&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阻止伪造请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6）AsyncTimeoutAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public class AsyncTimeoutAttribute : ActionFilterAttribute&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置异步操作超时时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7）NoAsyncTimeoutAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public sealed class NoAsyncTimeoutAttribute : AsyncTimeoutAttribute&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置异步操作永不超时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8）&lt;/strong&gt;&lt;strong&gt;OutputCacheAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public class OutputCacheAttribute : ActionFilterAttribute, IExceptionFilter&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将缓存其输出的操作方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9）&lt;/strong&gt;&lt;strong&gt;HandleErrorAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public class HandleErrorAttribute : FilterAttribute, IExceptionFilter&lt;/p&gt;
&lt;p&gt;&lt;span&gt;处理由操作方法引发的异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10）ActionNameAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)]&lt;/p&gt;
&lt;p&gt;public sealed class ActionNameAttribute : ActionNameSelectorAttribute&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以使用此特性改变操作的名称，使用新名称作为路由参数，方可路由到该操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[ActionName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AboutName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult About()
{
    ......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;11）NonActionAttribute&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)]&lt;/p&gt;
&lt;p&gt;public sealed class NonActionAttribute : ActionMethodSelectorAttribute&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用此特性修饰控制器操作，不会路由到此控制器方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5向视图传递数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与其说传递数据，倒不如说视图如何获得控制器处理过的数据。视图通过两种方式可以拿到数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;通过控制器操作返回的结果（控制器返回结果是数据和视图的结合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;将结果赋给控制器属性并在&lt;/span&gt;View中使用这些属性。&lt;/p&gt;
&lt;p&gt;public abstract class ControllerBase : IController&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类中有三个属性&lt;/span&gt;ViewData、ViewBag、TempData，使用着三个属性向视图传递数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ViewData&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它是字典类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;public ViewDataDictionary ViewData { get; set; }&lt;/p&gt;
&lt;p&gt;public class ViewDataDictionary : IDictionary&amp;lt;string, object&amp;gt;, ICollection&amp;lt;KeyValuePair&amp;lt;string, object&amp;gt;&amp;gt;, IEnumerable&amp;lt;KeyValuePair&amp;lt;string, object&amp;gt;&amp;gt;, IEnumerable&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种方式，弱类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult TestViewData()
{
            ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Contact&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;视图&lt;/span&gt;Contact.cshtml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
@ViewData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;Index.cshtml视图中&lt;span&gt;调用&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 @Html.Action(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestViewData&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第二种方式，弱型别，使用&lt;/span&gt;ViewData.Model&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种方式无法使用&lt;/span&gt;VS编译器的智能提示功能&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult TestViewData()
{
            ViewData.Model &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ModelF { Field=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;};
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Contact&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;视图&lt;/span&gt;Contact.cshtml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
@Model.Field
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;Index.cshtml视图中&lt;span&gt;调用&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Html.Action(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestViewData&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第三种方式，强型别，使用&lt;/span&gt;ViewData.Model&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器&lt;/span&gt;&lt;span&gt;与第二种方式基本相同，不同点就是视图&lt;/span&gt;Contact.cshtml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@model MVCPointApp.Models.ModelF
@Model.Field&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ViewBag&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它是动态类型，对&lt;/span&gt;ViewData的包装&lt;/p&gt;
&lt;p&gt;public dynamic ViewBag { get; }&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器操作中&lt;/span&gt;ViewBag.Field&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;@ViewBag.Message&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TempData&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它也是字典类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;public TempDataDictionary TempData { get; set; }&lt;/p&gt;
&lt;p&gt;public class TempDataDictionary : IDictionary&amp;lt;string, object&amp;gt;, ICollection&amp;lt;KeyValuePair&amp;lt;string, object&amp;gt;&amp;gt;, IEnumerable&amp;lt;KeyValuePair&amp;lt;string, object&amp;gt;&amp;gt;, IEnumerable&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6 异步控制器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET从线程池获得线程处理异步请求，异步调用完后，该线程回到线程池以便可以处理其他请求，同时通知ASP.NET重新抓取一个线程（不一定是处理异步请求的线程）来完成具体的异步操作（输出数据等）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用异步控制器的目的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;异步控制器操作中也要等待任务直至处理完，所以处理速度不比同步方法快，其主要作用是高效地利用服务器资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用异步控制器的情形：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能引发瓶颈的长操作，网络或&lt;/span&gt;I\O密集型操作，可取消长操作的情形。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构建异步控制器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器继承&lt;/span&gt;AsyncController&lt;span&gt;，控制器操作返回&lt;/span&gt;Task&amp;lt;ActionResult&amp;gt;&lt;span&gt;，并用&lt;/span&gt;async &lt;span&gt;修饰。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnysController : AsyncController
{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Anys&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt;&lt;span&gt; Index()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;睡眠，模拟长任务&lt;/span&gt;
            Thread.Sleep(&lt;span&gt;5000000&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Testpy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;7 扩展控制器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;基类控制器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个基类控制器，以便处理异常或无法找到请求对应的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意如果控制器使用&lt;/span&gt;HttpPost特性修饰，而客户端发起的是get请求，也会认为是无法找到操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseController : Controller
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnException(ExceptionContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误日志记录&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HandleUnknownAction(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; actionName)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理能找到此控制器，但找不到请求对应的操作&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;扩展授权过滤器（&lt;/span&gt;AuthorizeAttribute）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体示例见：验证、授权与安全&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;动作过滤器（&lt;/span&gt;&lt;/strong&gt;ActionFilterAttribute&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ActionFilterAttribute是一个抽象类，有四个方法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作执行后被框架自动调用的方法：&lt;/span&gt;OnActionExecuted&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作执行前被框架自动调用的方法：&lt;/span&gt;OnActionExecuting&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回结果后被框架自动调用的方法：&lt;/span&gt;OnResultExecuted&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回结果前被框架自动调用的方法：&lt;/span&gt;OnResultExecuting&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.Jess Chadwick/Todd Snyder/Hrusikesh Panda，徐雷/徐扬&lt;/p&gt;
&lt;p&gt;译。ASP.NET MVC4 Web编程&lt;/p&gt;
&lt;p&gt;2.Jon Galloway/Phil Haack/Brad Wilson/K. Scott Allen，孙远帅/邹权译  ASP.NET MVC4 高级编程（第四版）&lt;/p&gt;
&lt;p&gt;3.黄保翕，ASP.NET MVC4开发指南&lt;/p&gt;
&lt;p&gt;4.蒋金楠，ASP.NET MVC4框架揭秘&lt;/p&gt;
&lt;p&gt;5.https://www.asp.net/mvc&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;转载与引用请注明出处。&lt;/p&gt;
&lt;p&gt;时间仓促，水平有限，如有不当之处，欢迎指正。&lt;/p&gt;

</description>
<pubDate>Fri, 23 Mar 2018 11:51:00 +0000</pubDate>
<dc:creator>甜橙很酸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hdwgxz/p/8633661.html</dc:identifier>
</item>
<item>
<title>Laravel框架中的make方法详解 - 爱你们的小森</title>
<link>http://www.cnblogs.com/foreverno9/p/8626743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/foreverno9/p/8626743.html</guid>
<description>&lt;p&gt;为什么网上已经有这么多的介绍Laravel的执行流程了，Laravel的容器详解了，Laravel的特性了，Laravel的启动过程了之类的文章，我还要来再分享呢？&lt;/p&gt;
&lt;p&gt;因为，每个人的思维方式和方向是不一样的，所以就会出现这样的一个场景，当你遇到一个问题在网上寻求答案的时候，有很多文章都解释了你的这个问题，但是你只对其中一篇感兴趣，那是因为作者的思维方式和你的很接近而作者的文笔也可能是你喜欢的那种类型。正因如此，我也来分享一些我在研究Laravel框架时的一些观点和看法，希望给那些和我有类似思维方式的同学们一些启发和帮助。也欢迎大家拍砖。&lt;/p&gt;
&lt;p&gt;这次的内容会有些多，因为这个make实在是太重要了，如果大家能耐着性子看完的话，相信会有所帮助。&lt;/p&gt;
&lt;p&gt;Laravel中的make方法是用来从容器当中解析一个type，这个type是源码当中定义的，不是很好翻译成中文。解析后返回的结果就是type的一个实例。&lt;/p&gt;
&lt;p&gt;看过源码的同学应该知道在Illuminate\Foundation\Application这个类和它的父类Illuminate\Container\Container类中都有make方法，那么当执行如index.php中的这行代码，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;$kernel&lt;/span&gt; = &lt;span&gt;$app&lt;/span&gt;-&amp;gt;make(Illuminate\Contracts\Http\Kernel::&lt;span&gt;class&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;的时候，就会首先去执行Illuminate\Foundation\Application中的make方法，那么我们就先看看它。（这篇文章就以make这个Kernel类为例）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Resolve the given type from the container. 从容器当中解析给定的type
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * (Overriding Container::make) 覆盖了父类中的make方法
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * @param  string  $abstract 给定的type
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * @param  array  $parameters 指定一些参数 可选项
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * @return mixed
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; make(&lt;span&gt;$abstract&lt;/span&gt;, &lt;span&gt;array&lt;/span&gt; &lt;span&gt;$parameters&lt;/span&gt; =&lt;span&gt; [])
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;$abstract&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;getAlias(&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;);//调用父类中的getAlias方法
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 　　　　　//如果在deferredServices这个数组设置了这个type并且在instances数组中没有设置这个type
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;deferredServices[&lt;span&gt;$abstract&lt;/span&gt;]) &amp;amp;&amp;amp; ! &lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;instances[&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;])) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;$this&lt;/span&gt;-&amp;gt;loadDeferredProvider(&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;);//那么就执行这个方法：加载被定义为延迟的服务提供者
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; parent::make(&lt;span&gt;$abstract&lt;/span&gt;, &lt;span&gt;$parameters&lt;/span&gt;&lt;span&gt;);//调用父类的make方法
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好，我们一步一步的来，先看看这个getAlias方法，这个方法的作用就是返回这个类的别名，如果给出的是一个完整的类名且在aliases中已经设置了那么就返回这个类名的别名，如果没有设置过就返回这个类名本身，大家在看这个方法的时候可以先var_dump一下$app，对照着看里面的aliases数组，框架作者写这个方法真的很巧妙，至少这种递归方式在我实际开发当中很少用到。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Get the alias for an abstract if available.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * @param  string  $abstract
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * @return string
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * @throws \LogicException
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; getAlias(&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (! &lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;aliases[&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;])) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$this&lt;/span&gt;-&amp;gt;aliases[&lt;span&gt;$abstract&lt;/span&gt;] === &lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LogicException(&quot;[{&lt;span&gt;$abstract&lt;/span&gt;}] is aliased to itself.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;getAlias(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;aliases[&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 接下来就是对deferredServices和instances这个两个数组进行判断，在本例 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;$kernel&lt;/span&gt; = &lt;span&gt;$app&lt;/span&gt;-&amp;gt;make(Illuminate\Contracts\Http\Kernel::&lt;span&gt;class&lt;/span&gt;);&lt;/span&gt; 当中，判断的结果为false，因此不执行loadDeferredProvider方法。&lt;/p&gt;
&lt;p&gt;再接下来就是调用父类Illuminate\Container\Container中的make方法了，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Resolve the given type from the container.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * @param  string  $abstract
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * @param  array  $parameters
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * @return mixed
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; make(&lt;span&gt;$abstract&lt;/span&gt;, &lt;span&gt;array&lt;/span&gt; &lt;span&gt;$parameters&lt;/span&gt; =&lt;span&gt; [])
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;resolve(&lt;span&gt;$abstract&lt;/span&gt;, &lt;span&gt;$parameters&lt;/span&gt;&lt;span&gt;);//直接调用resolve方法
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重点来了，我们看看这个resolve方法执行了哪些操作，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Resolve the given type from the container.
     *
     * @param  string  $abstract
     * @param  array  $parameters
     * @return mixed
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; resolve(&lt;span&gt;$abstract&lt;/span&gt;, &lt;span&gt;$parameters&lt;/span&gt; =&lt;span&gt; [])
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;resolve.注1：还是调用getAlias方法 同上面的一样&lt;/span&gt;
        &lt;span&gt;$abstract&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;getAlias(&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;resolve.注2：判断实例化这个类是否需要其他一些有关联的类
        //如果$parameters非空或getContextualConcrete这个方法返回非空
        //那么该变量就为true 这里所谓的关联并不是类本身的依赖 应该是逻辑上的关联&lt;/span&gt;
        &lt;span&gt;$needsContextualBuild&lt;/span&gt; = ! &lt;span&gt;empty&lt;/span&gt;(&lt;span&gt;$parameters&lt;/span&gt;) || ! &lt;span&gt;is_null&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;getContextualConcrete(&lt;span&gt;$abstract&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;resolve.注3&lt;/span&gt;
&lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        if($abstract == \Illuminate\Contracts\Http\Kernel::class){
//            dump($this-&amp;gt;getContextualConcrete($abstract));
//            exit;
//        }
        //如果当前需要解析的type被定义为一个单例的话 先判断是否已经被实例化了 如果是那么直接返回这个实例
        // If an instance of the type is currently being managed as a singleton we'll
        // just return an existing instance instead of instantiating new instances
        // so the developer can keep using the same objects instance every time.
        //在容器中已经被实例化的类会存储在instances数组中 这跟大部分框架中保存类实例的方式一样&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;instances[&lt;span&gt;$abstract&lt;/span&gt;]) &amp;amp;&amp;amp; ! &lt;span&gt;$needsContextualBuild&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;instances[&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将parameters赋值给成员属性with 在实例化的时候会用到 不过在本例当中parameters为null&lt;/span&gt;
        &lt;span&gt;$this&lt;/span&gt;-&amp;gt;with[] = &lt;span&gt;$parameters&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;resolve.注4&lt;/span&gt;
        &lt;span&gt;$concrete&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;getConcrete(&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们现在已经准备好了去实例化这个具体的type 实例化这个type的同时还会递归的去解析它所有的依赖
        // We're ready to instantiate an instance of the concrete type registered for
        // the binding. This will instantiate the types, as well as resolve any of
        // its &quot;nested&quot; dependencies recursively until all have gotten resolved.
        //resolve.注5：先来判断一下它是否是可以被build的 我们来看一下这个isBuildable方法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$this&lt;/span&gt;-&amp;gt;isBuildable(&lt;span&gt;$concrete&lt;/span&gt;, &lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;$object&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;build(&lt;span&gt;$concrete&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注6：调用build方法开始实例化这个type&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;$object&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;make(&lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt;);
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        if($abstract == \Illuminate\Contracts\Http\Kernel::class){
//            dump($object);
//            exit;
//        }
//        if($abstract == \Illuminate\Contracts\Http\Kernel::class){
//            dump($this-&amp;gt;getExtenders($abstract));
//            exit;
//        }
        //resolve.注6：判断这个type是否有扩展 如果有扩展那么就使用扩展继续处理这个type实例 在本例当中没有
        // If we defined any extenders for this type, we'll need to spin through them
        // and apply them to the object being built. This allows for the extension
        // of services, such as changing configuration or decorating the object.&lt;/span&gt;
        &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$this&lt;/span&gt;-&amp;gt;getExtenders(&lt;span&gt;$abstract&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$extender&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;$object&lt;/span&gt; = &lt;span&gt;$extender&lt;/span&gt;(&lt;span&gt;$object&lt;/span&gt;, &lt;span&gt;$this&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;resolve.注7：判断这个type是否是一个单例 如果在绑定的时候定义为单例的话 那么就将其保存在instances数组中
        //后面其他地方再需要make它的时候直接从instances中取出即可 本例当中Kernel在绑定的时候时通过singleton方法
        //绑定的 因此是一个单例
        // If the requested type is registered as a singleton we'll want to cache off
        // the instances in &quot;memory&quot; so we can return it later without creating an
        // entirely new instance of an object on each subsequent request for it.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$this&lt;/span&gt;-&amp;gt;isShared(&lt;span&gt;$abstract&lt;/span&gt;) &amp;amp;&amp;amp; ! &lt;span&gt;$needsContextualBuild&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;instances[&lt;span&gt;$abstract&lt;/span&gt;] = &lt;span&gt;$object&lt;/span&gt;&lt;span&gt;;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        if($abstract == \Illuminate\Contracts\Http\Kernel::class){
//            dump($this-&amp;gt;instances);
//            exit;
//        }
        //触发解析后的回调动作 也就是在得到了type的实例以后还需要做哪些后续的处理 本例当中没有后续的处理&lt;/span&gt;
        &lt;span&gt;$this&lt;/span&gt;-&amp;gt;fireResolvingCallbacks(&lt;span&gt;$abstract&lt;/span&gt;, &lt;span&gt;$object&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;resolve.注8：设置resolved数组并将with数组中的数据弹出
        // Before returning, we will also set the resolved flag to &quot;true&quot; and pop off
        // the parameter overrides for this build. After those two things are done
        // we will be ready to return back the fully constructed class instance.&lt;/span&gt;
        &lt;span&gt;$this&lt;/span&gt;-&amp;gt;resolved[&lt;span&gt;$abstract&lt;/span&gt;] = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;array_pop&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;with);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;终于return了&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$object&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;resolve.注3：&lt;/strong&gt;这里我就不粘贴这个getContextualConcrete方法的代码了，这个方法就是通过判断在Illuminate\Container\Container类中$contextual这个数组里面有没有这个type的相关数据，如果有就返回这个数据，如果没有就返回null，在本例当中返回的是null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;resolve.注4：&lt;/strong&gt;我们看一下这个getConcrete方法，同样在看代码的时候dump一下$app，对照着看，这个方法在绝大部分时候都是会返回这个type在绑定的时候注册的那个Closure，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Get the concrete type for a given abstract.
     *
     * @param  string  $abstract
     * @return mixed   $concrete
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; getConcrete(&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还是先调用这个方法来判断是否存在有关联关系的数据 如果有直接返回该数据&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (! &lt;span&gt;is_null&lt;/span&gt;(&lt;span&gt;$concrete&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;getContextualConcrete(&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;))) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果上面没有被返回 那么就判断这个type在绑定到容器的时候有没有绑定一个concrete属性
        //也就是一个回调 laravel的习惯是在绑定type的时候会提供一个Closure作为这个type实例化时
        //的一些操作 比如最简单的就是 new xxx();
        // If we don't have a registered resolver or concrete for the type, we'll just
        // assume each type is a concrete name and will attempt to resolve it as is
        // since the container should be able to resolve concretes automatically.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;bindings[&lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;])) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;bindings[&lt;span&gt;$abstract&lt;/span&gt;]['concrete'&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果都没有那么返回它本身了&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;resolve.注5：&lt;/strong&gt;isBuildable方法是很简单的一个判断，通过查看$app，这个type的concrete是一个Closure，因此这里返回true&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    protected&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; isBuildable(&lt;span&gt;$concrete&lt;/span&gt;, &lt;span&gt;$abstract&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回的是一个bool值 如果concrete和abstract全等或concrete是一个Closure返回true&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$concrete&lt;/span&gt; === &lt;span&gt;$abstract&lt;/span&gt; || &lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt; instanceof Closure;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1343223/201803/1343223-20180323091237627-1037226282.png&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;resolve.注6：&lt;/strong&gt;在分析这个build方法之前我们先来看看在本例当中的type对应的concrete保存的是个什么东东，还是使用dump，不得不说symfony的这个var-dumper包真的很好用啊，从下面的截图中可以看到这个闭包函数共有两个参数就是parameters里面的那两个，同时还use了两个参数，这个闭包函数的定义在Container.php文件的251至257行（也就是laravel容器提供的一个通用闭包函数，这个type在绑定的时候并没有提供自己单独的闭包函数），大家可以对照着看一下bindings数组当中其他的一些concrete的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1343223/201803/1343223-20180323092503890-270429051.png&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;293&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好，我们来看一下这个build方法，也是很复杂的一个方法啊。先看方法中第一个判断，在本例当中判断为true，因此直接执行这个Closure并返回结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 实例化一个这个type的具体对象
     * Instantiate a concrete instance of the given type.
     *
     * @param  string  $concrete
     * @return mixed
     *
     * @throws \Illuminate\Contracts\Container\BindingResolutionException
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; build(&lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断如果concrete是一个Closure实例 那么直接执行它 在本例当中是 因此直接执行并返回
        // If the concrete type is actually a Closure, we will just execute it and
        // hand back the results of the functions, which allows functions to be
        // used as resolvers for more fine-tuned resolution of these objects.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt; instanceof Closure) {&lt;br/&gt;//调用这个Closure的时候传递了两个参数
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$concrete&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;, &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;getLastParameterOverride());
        }
        //build.注1
        &lt;/span&gt;&lt;span&gt;$reflector&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; ReflectionClass(&lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt;);
        //build.注2：调用reflection本身的isInstantiable方法来判断这个类是否可以被实例化如果是接口或是抽象类的话就返回false&lt;br/&gt;//在本例当中可以被实例化因此返回true
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the type is not instantiable, the developer is attempting to resolve
        // an abstract type such as an Interface of Abstract Class and there is
        // no binding registered for the abstractions so we need to bail out.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (! &lt;span&gt;$reflector&lt;/span&gt;-&amp;gt;&lt;span&gt;isInstantiable()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;notInstantiable(&lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt;);
        }
        //build.注3：把待实例化的类名保存在buildStack数组当中 因为如果这个类有依赖的话 那么还需要实例化它全部的依赖&lt;br/&gt;//因此将待实例化的类名都保存起来 来确保完整性
        &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;buildStack[] = &lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt;;
        //build.注4：获取类的构造函数
        &lt;/span&gt;&lt;span&gt;$constructor&lt;/span&gt; = &lt;span&gt;$reflector&lt;/span&gt;-&amp;gt;&lt;span&gt;getConstructor();
        &lt;strong&gt;//build.注5：如果构造函数为空那么先将待构建堆栈中数组buildStack中刚才插入那条数据删除 然后直接 new 这个类 结束
        &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If there are no constructors, that means there are no dependencies then
        // we can just resolve the instances of the objects right away, without
        // resolving any other types or dependencies out of these containers.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;is_null&lt;/span&gt;(&lt;span&gt;$constructor&lt;/span&gt;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;array_pop&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;buildStack);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt;;
        }
        //build.注6
        &lt;/span&gt;&lt;span&gt;$dependencies&lt;/span&gt; = &lt;span&gt;$constructor&lt;/span&gt;-&amp;gt;&lt;span&gt;getParameters();
        //一旦我们得到了构造方法中所有的参数 我们就能够依次的去创建这些依赖实例 并使用反射来注入创建好的这些依赖
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Once we have all the constructor's parameters we can create each of the
        // dependency instances and then use the reflection instances to make a
        // new instance of this class, injecting the created dependencies in.&lt;/span&gt;
        &lt;span&gt;$instances&lt;/span&gt; = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;resolveDependencies(//build.注7 调用这个方法来解析这些依赖
            &lt;/span&gt;&lt;span&gt;$dependencies&lt;/span&gt;&lt;span&gt;
        );

        &lt;/span&gt;&lt;span&gt;array_pop&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;buildStack);
        //build.注7
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$reflector&lt;/span&gt;-&amp;gt;newInstanceArgs(&lt;span&gt;$instances&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们去看看这个Closure的执行过程，也就是Container.php的251至257行的代码，看到了吗？再来一遍！！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;在上面build方法中调用这个Closure的时候已经看到传递了两个实参
        //分别对应这里的形参为 $container=$this, $parameters=$this-&amp;gt;getLastParameterOverride()
        //use中的两个参数我们在上面的截图当中也能找到 分别为
        //$abstract=&quot;Illuminate\Contracts\Http\Kernel&quot; $concrete=&quot;Zhiyi\Plus\Http\Kernel&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;$container&lt;/span&gt;, &lt;span&gt;$parameters&lt;/span&gt; = []) &lt;span&gt;use&lt;/span&gt; (&lt;span&gt;$abstract&lt;/span&gt;, &lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$abstract&lt;/span&gt; == &lt;span&gt;$concrete&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不相等&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$container&lt;/span&gt;-&amp;gt;build(&lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行这句 也就是$this-&amp;gt;make(&quot;Zhiyi\Plus\Http\Kernel&quot;, $parameters)
            //我的妈呀 再来一遍的节奏啊&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$container&lt;/span&gt;-&amp;gt;make(&lt;span&gt;$concrete&lt;/span&gt;, &lt;span&gt;$parameters&lt;/span&gt;&lt;span&gt;);
        };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于篇幅的关系我就不带大家看重复的内容了，在执行了make方法的一系列操作之后，会重新来到build方法中，在build的第一个判断中为false&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        if&lt;/span&gt; (&lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt; instanceof Closure) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$concrete&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;, &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;getLastParameterOverride());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此执行它下面的代码，从build.注1开始，根据这个concrete实例化一个反射类（现在这个concrete的值为Zhiyi\Plus\Http\Kernel），反射的相关知识大家自己看手册就了解了，很简单的。&lt;/p&gt;
&lt;p&gt;给大家一个小技巧，在调试PHP代码的时候如果仅仅使用var_dump配合exit这种方法的话，可能不会出现你预期的效果，因为也许exit过早或过完，就没有你想看到的东西了，再或者所有经过这里的代码都打印出来，影响大家的调试。我使用的方法是在需要调试的地方加上一个判断，比如这里，我已经知道concrete的值，那么我就判断一下，如果这里出现了预期的值就dump然后exit&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        $reflector&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; ReflectionClass(&lt;span&gt;$concrete&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$concrete&lt;/span&gt; == 'Zhiyi\Plus\Http\Kernel'&lt;span&gt;){
            dump(&lt;/span&gt;&lt;span&gt;$reflector&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来看下效果吧，果然浏览器中只打印出了我们想看的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1343223/201803/1343223-20180323103720223-562005777.png&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;build.注4：&lt;/strong&gt;在本例当中类为Zhiyi\Plus\Http\Kernel，看这个类的源码发现没有构造函数。那么在看它继承的父类Illuminate\Foundation\Http\Kernel当中有没有，发现是有的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;build.注5：&lt;/strong&gt;如果类及其父类当中都没有构造方法，那么直接 new 这个类并返回这个实例对象，new 这个类是依靠composer的自动加载机制来实现的。&lt;/p&gt;
&lt;p&gt;在本例中，类中是存在构造方法的，那么我们打印出这个获取到的构造函数看看，同样还是使用我介绍那种调试小技巧&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        $constructor&lt;/span&gt; = &lt;span&gt;$reflector&lt;/span&gt;-&amp;gt;&lt;span&gt;getConstructor();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$concrete&lt;/span&gt; == 'Zhiyi\Plus\Http\Kernel'&lt;span&gt;){
            dump(&lt;/span&gt;&lt;span&gt;$constructor&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看看结果吧，发现这个类Illuminate\Foundation\Http\Kernel的构造方法需要两个参数，$app和$router&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1343223/201803/1343223-20180323105844067-988621916.png&quot; alt=&quot;&quot; width=&quot;734&quot; height=&quot;398&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;build.注6：&lt;/strong&gt;执行 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;$dependencies&lt;/span&gt; = &lt;span&gt;$constructor&lt;/span&gt;-&amp;gt;getParameters();&lt;/span&gt; 来获取构造方法的参数，这两个参数在上图中已经看到了，参数$app的typeHint（类型提示）为Illuminate\Contracts\Foundation\Application类的实例，参数$router的typeHint为Illuminate\Routing\Router类的实例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;build.注7：&lt;/strong&gt;执行resolveDependencies方法去依次解析这些依赖，如果依赖是对象的话，也就是去实例化这些类来获取这个对象，也就是再依次重复上面所有的过程，从make开始。因为只要是想在laravel框架的容器里面获得一个类的实例就要执行make方法。我们来看看这个resolveDependencies方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    /*&lt;/span&gt;&lt;span&gt;*
     * Resolve all of the dependencies from the ReflectionParameters.
     *
     * @param  array  $dependencies
     * @return array
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; resolveDependencies(&lt;span&gt;array&lt;/span&gt; &lt;span&gt;$dependencies&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;$results&lt;/span&gt; =&lt;span&gt; [];
        //在循环当中依次解析这些依赖
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$dependencies&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$dependency&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If this dependency has a override for this particular build we will use
            // that instead as the value. Otherwise, we will continue with this run
            // of resolutions and let reflection attempt to determine the result.&lt;br/&gt;&lt;/span&gt;            //判断这个依赖是否被重新定义过 也就是在resolve方法中执行的一句代码 $this-&amp;gt;with[]=$parameters;&lt;br/&gt;//判断的依据（也就是这个方法内部）就是这个with数组 在本例当中with中是两个空数组 因此判断为false
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$this&lt;/span&gt;-&amp;gt;hasParameterOverride(&lt;span&gt;$dependency&lt;/span&gt;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;$results&lt;/span&gt;[] = &lt;span&gt;$this&lt;/span&gt;-&amp;gt;getParameterOverride(&lt;span&gt;$dependency&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            //这里调用$dependency的getClass方法 $dependency是一个ReflectionParameter对象 这个对象有getClass方法&lt;br/&gt;//reflection的相关内容请查阅手册&lt;br/&gt;//在本例当中getClass会返回一个ReflectionClass对象 不为空 那么是哪个类的ReflectionClass对象呢 当前循环中&lt;br/&gt;//的$dependency是illuminate\Contracts\Foundation\Application这个依赖
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the class is null, it means the dependency is a string or some other
            // primitive type which we can not resolve since it is not a class and
            // we will just bomb out with an error since we have no-where to go.&lt;/span&gt;
            &lt;span&gt;$results&lt;/span&gt;[] = &lt;span&gt;is_null&lt;/span&gt;(&lt;span&gt;$dependency&lt;/span&gt;-&amp;gt;&lt;span&gt;getClass())
                            &lt;/span&gt;? &lt;span&gt;$this&lt;/span&gt;-&amp;gt;resolvePrimitive(&lt;span&gt;$dependency&lt;/span&gt;&lt;span&gt;)
                            &lt;/span&gt;: &lt;span&gt;$this&lt;/span&gt;-&amp;gt;resolveClass(&lt;span&gt;$dependency&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$results&lt;/span&gt;&lt;span&gt;;
    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;补充：with这个数组的作用是什么，我理解为类的动态实例化，也就是在不同的情况下new这个类的时候可以传入不同的构造方法参数。&lt;/p&gt;
&lt;p&gt;我们来看一下这个resolveClass方法吧，任然还是执行make方法，这次make的参数大家应该都清楚了吧，就是&lt;span class=&quot;sf-dump-str&quot; title=&quot;43 characters&quot;&gt;Illuminate\Contracts\Foundation\Application，又是一个循环。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    protected&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; resolveClass(ReflectionParameter &lt;span&gt;$parameter&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;make(&lt;span&gt;$parameter&lt;/span&gt;-&amp;gt;getClass()-&amp;gt;&lt;span&gt;name);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we can not resolve the class instance, we will check to see if the value
        // is optional, and if it is we will return the optional parameter value as
        // the value of the dependency, similarly to how we do this with scalars.&lt;/span&gt;
        &lt;span&gt;catch&lt;/span&gt; (BindingResolutionException &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$parameter&lt;/span&gt;-&amp;gt;&lt;span&gt;isOptional()) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$parameter&lt;/span&gt;-&amp;gt;&lt;span&gt;getDefaultValue();
            }

            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次调用make方法，过程就不看了，反正在resolveDependencies这个方法执行结束后，会返回一个results数组，我们dump一下这个results，这次返回的是真正的两个对象了，也就是本例Illuminate\Contracts\Http\Kernel中构造方法所需要的两个参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1343223/201803/1343223-20180323170418901-1143878232.png&quot; alt=&quot;&quot; width=&quot;281&quot; height=&quot;93&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里为止resolveDependcies这个方法就执行结束了，大家还记得这个方法是在哪里被调用的吗？哈哈，我也有点乱了，别急我们看看上面的内容。哦！是在build方法中被调用的，那么我们就接着看build方法下面的代码吧，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;build.注7：&lt;/strong&gt;调用newInstanceArgs方法，手册中给出的这个方法的解释为“创建一个类的新实例，给出的参数将传递到类的构造函数”。  OK，搞定。我们来看看build执行之后的结果，dump一下，终于Kernel类被new出来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1343223/201803/1343223-20180323171817764-2004868010.png&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;199&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你真的以为这样就搞定了吗？还没呢，还记得build方法是在哪里被调用的吗？是在resolve方法中，走吧，我们返回resolve方法中看看build方法执行之后还有哪些操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;resolve.注6：&lt;/strong&gt;判断这个type是否有扩展 如果有扩展那么就使用扩展继续处理这个type实例 在本例当中没有&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;resolve.注7：&lt;/strong&gt;判断这个type是否是一个单例 如果在绑定的时候定义为单例的话 那么就将其保存在instances数组中后面其他地方再需要make它的时候直接从instances中取出即可 本例当中Kernel在绑定的时候时通过singleton方法绑定的，因此是一个单例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;resolve.注8：&lt;/strong&gt;设置resolved数组并将with数组中的数据弹出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;，终于返回这个Illuminate\Contracts\Http\Kernel类的对象了。resolve方法return给了make方法。怎么样？大家看的明白了吗？&lt;/p&gt;

&lt;p&gt;大体的流程就是根据绑定这个类的时候提供的参数， 来对这个类进行实例化。提供的参数可以是很多种类型如：闭包函数，字符串。那么框架会根据不同的类型来确定如何实例化，同时在实例化类的时候去递归的解决类的依赖问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实如果有耐心有时间的话一行行的去读源码，就会发现虽然功能上很复杂，但是原理上很简单。功能上的复杂仅仅是为了做到框架的兼容和全面，仔细看下来发现并没有什么多余的代码，并不像有些人所说的Laravel框架不够精简，很多功能需要实现，就必须要通过一些方式方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原创内容，禁止转载！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Mar 2018 11:04:00 +0000</pubDate>
<dc:creator>爱你们的小森</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/foreverno9/p/8626743.html</dc:identifier>
</item>
<item>
<title>以太坊挖矿源码：ethash算法 - 一面千人</title>
<link>http://www.cnblogs.com/Evsward/p/ethash.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Evsward/p/ethash.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文具体分析以太坊的共识算法之一：实现了POW的以太坊共识引擎ethash。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关键字：ethash，共识算法，pow，Dagger Hashimoto，ASIC，struct{}，nonce，FNV hash，位运算，epoch&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面我们分析了以太坊挖矿的源码，挖了一个共识引擎的坑，研究了DAG有向无环图的算法，这些都是本文要研究的Ethash的基础。Ethash是目前以太坊基于POW工作量证明的一个共识引擎（也叫挖矿算法）。它的前身是Dagger Hashimoto算法。&lt;/p&gt;
&lt;h2 id=&quot;dagger-hashimoto&quot;&gt;Dagger Hashimoto&lt;/h2&gt;
&lt;p&gt;作为以太坊挖矿算法Ethash的前身，Dagger Hashimoto的目的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抵制矿机（ASIC，专门用于挖矿的芯片）&lt;/li&gt;
&lt;li&gt;轻客户端验证&lt;/li&gt;
&lt;li&gt;全链数据存储&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Dagger和Hashimoto其实是两个东西，&lt;/p&gt;
&lt;h3 id=&quot;hashimoto算法&quot;&gt;Hashimoto算法&lt;/h3&gt;
&lt;p&gt;是这个人Thaddeus Dryja创造的。旨在通过IO限制来抵制矿机。在挖矿过程中，使内存读取限制条件，由于内存设备本身会比计算设备更加便宜以及普遍，在内存升级优化方面，全世界的大公司也都投入巨大，以使内存能够适应各种用户场景，所以有了随机访问内存的概念RAM，因此,现有的内存可能会比较接近最优的评估算法。Hashimoto算法使用区块链作为源数据，满足了上面的1和3的要求。&lt;/p&gt;
&lt;h3 id=&quot;dagger算法&quot;&gt;Dagger算法&lt;/h3&gt;
&lt;p&gt;是这个人Vitalik Buterin发明的。它利用了&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/dag.html&quot;&gt;有向无环图DAG&lt;/a&gt;同时实现了Memory-Hard Function内存计算困难但易于验证Memory-easy verification的特性（我们知道这是哈希算法的重要特性之一）。它的理论依据是基于每个特定场合nonce只需要大型数据总量树的一小部分，并且针对每个特定场合nonce的子树的再计算是被禁止挖矿的。因此，需要存储树但也支持一个独立场合nonce的验证价值。Dagger算法注定要替代现存的仅内存计算困难的算法，例如Scrypt（莱特币采用的），它是计算困难同时验证亦困难的算法，当他们的内存计算困难度增加至真正安全的水平，验证的困难度也随之难上加难。然而，Dagger算法被证明是容易受到Sergio Lerner发明的共享内存硬件加速技术，随后在其他路径的研究方面，该算法被遗弃了。&lt;/p&gt;
&lt;h3 id=&quot;memory-hard-function&quot;&gt;Memory-Hard Function&lt;/h3&gt;
&lt;p&gt;直接翻译过来是内存困难函数，这是为了地址矿机而诞生的一种思想。我们知道挖矿是靠我们的电脑，但是有些硬件厂商会制造专门用于挖矿的硬件设备，它们并不是一台完整的PC机，例如ASIC、GPU以及FPGAs（我们经常能听到GPU挖矿等）。所以这些作为矿机的设备是超越普通PC挖矿的存在，这是不符合我们区块链的去中心化精神的，所以我们要让挖矿设备平等。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么该如何让挖矿设备是平等的呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面谈到Dagger算法的时候其实提到了，这里换一种方式再来介绍一下，现在CPU都是多核的，如果从计算能力来讲，CPU有几核就可以模拟几台设备同时平行挖矿，自然效率就高些，但是这里采用的衡量对象是内存，一台电脑只有一个总内存。我们做过java多线程开发的朋友知道，无论机器性能有多高，但我们写的程序就是单线程的，那么这个程序运行在高配多核电脑和低配单核电脑的区别不大，只要他们的单核运算能力和内存大小一样即可。所以也是这个原理，通过Dagger算法，我们将挖矿流程锁定在以内存为衡量标准的硬件性能上，只要通过“塞一堆数据到内存中”的方式，让多核平行处理发挥不出来，降低硬件的运算优势，只与内存大小有关，这样无论是PC机还是ASIC、GPU以及FPGAs，都可达到平等挖矿的诉求，这也是ASIC-resistant原理，目前抵制矿机的主要手段。&lt;/p&gt;
&lt;h3 id=&quot;两个问题的研究&quot;&gt;两个问题的研究&lt;/h3&gt;
&lt;p&gt;在Dagger以及Dagger Hashimoto算法中，有两个问题的研究是被搁置的，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于区块链的工作量证明：一个POW函数包括了运行区块链上的合约。该方法被抛弃是因为这是一个长期的攻击缺陷，因为攻击者能够创建分叉，然后通过一个包含秘密的快速“trapdoor”井盖门的运行机制的合约在该分叉上殖民。&lt;/li&gt;
&lt;li&gt;随机环路：一个POW函数由这个人Vlad Zamfir开发，包含了每1000个场合nonces就生成一个新的程序的功能。本质上来讲，每次选择一个新的哈希函数，会比可重配置的FPGAs(可重编程的芯片，不必重新焊接电路板就可通过软件技术重新自定义硬件功能)更快。该方法被暂时搁置，是因为它很难看到有什么机制可以用来生成随机程序是足够全面，因此它的专业化收益是较低的。然而，我们并没有看到为什么这个概念无法让它生效的根本原因，所以暂时搁置。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;dagger-hashimoto算法&quot;&gt;Dagger Hashimoto算法&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;（区别于Hashimoto）Dagger Hashimoto不是直接将区块链作为数据源，而是使用一个1GB的自定义生成的数据集cache。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个数据集是基于区块数据每N个块就会更新。该数据集是使用Dagger算法生成，允许一个自己的高效计算，特定于每个轻客户端校验算法的场合nonce。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;（区别于Dagger）Dagger Hashimoto克服了Dagger的缺陷，它用于查询区块数据的数据集是半永久的，只有在偶然的间隔才会被更新（例如每周一次）。这意味着生成数据集将非常容易，所以Sergio Lerner的争议共享内存加速变得微不足道了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;挖矿补充&quot;&gt;挖矿补充&lt;/h2&gt;
&lt;p&gt;前面我已经写了一盘关于&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/miner.html&quot;&gt;挖矿&lt;/a&gt;的文章了，这一节是挖矿的补充内容。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以太坊将过渡到POS（proof-of-stake)，代替传统的POW，挖矿将会被淘汰掉，所以现在不推荐再去做一名矿工（前期购买设备等成本较大，POS实现前未必能回本）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;挖掘以太币=网络安全=验证估算&lt;/p&gt;
&lt;p&gt;目前以太坊的POW算法是Ethash，&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Ethash算法包含找到一个nonce值输入到一个算法中，得到的结果是低于一个基于特定困难度的阀值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;POW算法的关键点是除了暴力枚举，没有任何办法可以找到这个nonce值，但对于验证输出的结果是非常简单容易的。如果输出结果有一个均匀分布，我们就可以保证找到一个nonce值的平均所需时间取决于那个难度阀值，因此我们可以通过调整难度阀值来控制找到一个新块的时间，这就是控制出块速度的原理。&lt;/p&gt;
&lt;h3 id=&quot;dag&quot;&gt;DAG&lt;/h3&gt;
&lt;p&gt;Ethash的POW是memory-hard，支持矿机抵御。这意味着POW计算需要选择一个固定的依赖于nonce值和块头的资源的子集。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这个资源(大约1G大小)就是DAG!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一世epoch&quot;&gt;一世epoch&lt;/h3&gt;
&lt;p&gt;每3万个块会&lt;strong&gt;花几个小时&lt;/strong&gt;的时间生成一个有向无环图DAG。这个DAG被称为epoch，一世（为了好记，refer个秦二世）。DAG只取决于区块高度，它可以被预生成，如果没有预生成的话，客户端需要等待预生成流程结束以后才能继续出块操作。除非客户端真实的提前预缓存了DAG，否则在每个epoch的过渡期间，网络可能会经历一个巨大的区块延迟。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;特例：当你从头启动一个结点时，挖矿工作只会在创建了现世DAG以后启动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;挖矿奖励&quot;&gt;挖矿奖励&lt;/h3&gt;
&lt;p&gt;有三部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态区块创建奖励，精确发放3以太币作为奖励。&lt;/li&gt;
&lt;li&gt;当前区块包含的所有交易的gas钱，随着时间推移，gas会越来越便宜，获得的gas总和奖励会低于静态区块创建奖励。&lt;/li&gt;
&lt;li&gt;叔块奖励，整块奖励的1/32。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;ethash-1&quot;&gt;Ethash&lt;/h2&gt;
&lt;p&gt;Ethash算法路线图：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存在一个种子seed，通过扫描块头为每个块计算出来那个点。&lt;/li&gt;
&lt;li&gt;根据这个种子seed，可以计算一个16MB的伪随机缓存cache，轻客户端存储这个缓存。&lt;/li&gt;
&lt;li&gt;从这个缓存cache中，我们能够生成一个1GB的数据集，该数据集中的每一项都取决于缓存中的一小部分。完整客户端和矿工存储了这个数据集，数据集随着时间线性增长。&lt;/li&gt;
&lt;li&gt;挖矿工作包含了抓取数据集的随机片以及运用哈希函数计算他们。校验工作能够在低内存的环境下完成，通过使用缓存再次生成所需的特性数据集的片段，所以你只需要存储缓存cache即可。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以上提到的大数据集是每3万个块更新一次，所以绝大多数的矿工的工作是读取该数据集而不是改变它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;pkg-ethash源码分析&quot;&gt;pkg ethash源码分析&lt;/h2&gt;
&lt;p&gt;以上我们将所有的概念抽象梳理了一下，包括POW，挖矿，Ethash原理流程等，下面我们带着这些理论知识走进源代码中去分析具体的实现。正如我们的题目，本文主要分析的是ethash算法，因此整个源码范围仅限于go-ethereum/consensus/ethash包，该包实现了ethash pow的共识引擎。&lt;/p&gt;
&lt;h3 id=&quot;入口&quot;&gt;入口&lt;/h3&gt;
&lt;p&gt;分析源码要有个入口，这个入口就是在&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/miner.html&quot;&gt;《以太坊源码机制：挖矿》&lt;/a&gt;中挖下的坑“Seal方法”，原文留下了这个印子，在本文进行展开讨论。&lt;/p&gt;
&lt;p&gt;在go-ethereum/consensus/consensus.go 接口中定义了如下的方法，正是对应上面的“Seal方法”，该接口方法的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Seal(chain ChainReader, block *types.Block, stop &amp;lt;-chan struct{}) (*types.Block, error)//该方法通过输入一个包含本地矿工挖出的最高区块在主干上生成一个新块。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数有ChainReader，Block，stop结构体信号，返回一个主链上的新出的块实体。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ChainReader&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 定义了一些方法，用于在区块头验证以及叔块验证期间，访问本地区块链。
type ChainReader interface {
    // 获取区块链的链配置
    Config() *params.ChainConfig

    // 从本地链获取当前块头
    CurrentHeader() *types.Header

    // 通过hash和number从主链中获取一个区块头
    GetHeader(hash common.Hash, number uint64) *types.Header

    // 通过number从主链中获取一个区块头
    GetHeaderByNumber(number uint64) *types.Header

    // 通过hash从主链中获取一个区块头
    GetHeaderByHash(hash common.Hash) *types.Header

    // 通过hash和number从主链中获取一个区块
    GetBlock(hash common.Hash, number uint64) *types.Block
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结，ChainReader定义了几个方法：从本地区块链获取配置、区块头，从主链中获取区块头、区块，参数条件包括hash和number，随意组合。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Block代表以太坊区块链中的一个完整的区块
type Block struct {
    header       *Header // 区块包括头
    uncles       []*Header // 叔块
    transactions Transactions // 交易集合

    // caches缓存
    hash atomic.Value
    size atomic.Value

    // Td用于core包存储所有的链上的难度
    td *big.Int

    // 这些字段用于eth包来跟踪inter-peer内部端点区块的接替
    ReceivedAt   time.Time
    ReceivedFrom interface{}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结，Block除了我们熟知的区块中必有的区块头、叔块以及打包存储的交易信息，还有cache缓存的内容，以及每个块之于链的难度值，还有用于跟踪内部端点的字段。&lt;/p&gt;
&lt;p&gt;stop是一个空结构体作为信号源。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关于空结构体的讨论，为什么go里面经常出现struct{}?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;go中除了struct{}类型以外，其他类型都是width，占有存储，而struct{}没有字段，没有方法，width为0，灵活性高，不占内存空间，这可能是让Gopher青睐的原因。&lt;/p&gt;
&lt;h3 id=&quot;sealer&quot;&gt;sealer&lt;/h3&gt;
&lt;p&gt;seal方法有两个实现，我们选择ethash，该方法存在于consensus/ethash/sealer.go文件中，第一个函数就是seal的实现，先来看该方法的声明部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 尝试找到一个nonce值能够满足区块难度需求。
func (ethash *Ethash) Seal(chain consensus.ChainReader, block *types.Block, stop &amp;lt;-chan struct{}) (*types.Block, error) {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出这个方法是属于Ethash的指针对象的，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Ethash struct {
    // cache配置
    cachedir     string // 缓存位置
    cachesinmem  int    // 在内存中缓存的数量
    cachesondisk int    // 在硬盘中缓存的数量
    
    // DAG挖矿数据集配置
    dagdir       string // DAG位置，存储全部挖矿数据集
    dagsinmem    int    // 在内存中DAG的数量
    dagsondisk   int    // 在硬盘中DAG的数量

    // 内存cache
    caches   map[uint64]*cache   // 内存缓存，可反复使用避免再生太频繁
    fcache   *cache              // 为了下一世估算的预生产缓存
    
    // 内存数据集
    datasets map[uint64]*dataset // 内存数据集，可反复使用避免再生太频繁
    fdataset *dataset            // 为了下一世估算的预生产数据集

    // 挖矿相关字段
    rand     *rand.Rand    // 随机工具，用来为nonce做适当的种子
    threads  int           // 如果在挖矿，代表挖矿的线程编号
    update   chan struct{} // 更新挖矿中参数的通道
    hashrate metrics.Meter // 测量跟踪平均哈希率

    // 以下字段是用于测试
    tester    bool          // 是否使用一个小型测试数据集的标志位
    shared    *Ethash       // 共享pow模式，无法再生缓存
    fakeMode  bool          // Fake模式，是否取消POW检查的标志位
    fakeFull  bool          // 是否取消所有共识规则的标志位
    fakeFail  uint64        // 未通过POW检查的区块号（包含fake模式）
    fakeDelay time.Duration // 验证工作返回消息前的休眠延迟时间

    lock sync.Mutex // 为了内存中的缓存和挖矿字段，保证线程安全
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了更好的读懂之后的代码，我们要对区块头的数据结构进行一个分析：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Header struct {
    ParentHash  common.Hash    `json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`
    UncleHash   common.Hash    `json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`
    Coinbase    common.Address `json:&quot;miner&quot;            gencodec:&quot;required&quot;`
    Root        common.Hash    `json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`
    TxHash      common.Hash    `json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`
    ReceiptHash common.Hash    `json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`
    Bloom       Bloom          `json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`
    Difficulty  *big.Int       `json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`
    Number      *big.Int       `json:&quot;number&quot;           gencodec:&quot;required&quot;`
    GasLimit    *big.Int       `json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`
    GasUsed     *big.Int       `json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`
    Time        *big.Int       `json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`
    Extra       []byte         `json:&quot;extraData&quot;        gencodec:&quot;required&quot;`
    MixDigest   common.Hash    `json:&quot;mixHash&quot;          gencodec:&quot;required&quot;`
    Nonce       BlockNonce     `json:&quot;nonce&quot;            gencodec:&quot;required&quot;`
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到一个区块头包含了父块hash值，叔块hash值，Coinbase结点账户地址，状态根，交易hash，接受者hash，日志，难度值，块编号，最低支付gas，花费的gas，时间戳，额外数据，混合hash，nonce值（8个byte)。我们要对这些区块头的成员属性了然于胸，后面的源码内容才能更好的理解。下面我们继续Seal方法，下面展示完整代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (ethash *Ethash) Seal(chain consensus.ChainReader, block *types.Block, stop &amp;lt;-chan struct{}) (*types.Block, error) {
    // fake模式立即返回0 nonce
    if ethash.fakeMode {
        header := block.Header()
        header.Nonce, header.MixDigest = types.BlockNonce{}, common.Hash{}
        return block.WithSeal(header), nil
    }
    // 共享pow的话，则转到它的共享对象执行Seal操作
    if ethash.shared != nil {
        return ethash.shared.Seal(chain, block, stop)
    }
    // 创建一个runner以及它指挥的多重搜索线程
    abort := make(chan struct{})
    found := make(chan *types.Block)

    ethash.lock.Lock() // 线程上锁，保证内存的缓存（包含挖矿字段）安全
    threads := ethash.threads // 挖矿的线程s
    if ethash.rand == nil {// rand为空，则为ethash的字段rand赋值
        // 获得种子
        seed, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))
        if err != nil {// 执行失败，有报错
            ethash.lock.Unlock() // 先解锁
            return nil, err // 程序中止，直接返回空块和报错信息
        }
        ethash.rand = rand.New(rand.NewSource(seed.Int64())) // 执行成功，拿到合法种子seed，通过其获得rand对象，赋值。
    }
    ethash.lock.Unlock() // 解锁
    if threads == 0 {// 挖矿线程编号为0，则通过方法返回当前物理上可用CPU编号
        threads = runtime.NumCPU()
    }
    if threads &amp;lt; 0 { // 非法结果
        threads = 0 // 置为0，允许在本地或远程没有额外逻辑的情况下，取消本地挖矿操作
    }
    var pend sync.WaitGroup // 创建一个倒计时锁对象，go语法参照 http://www.cnblogs.com/Evsward/p/goPipeline.html#sync.waitgroup
    for i := 0; i &amp;lt; threads; i++ {
        pend.Add(1)
        go func(id int, nonce uint64) {// 核心代码通过闭包多线程技术来执行。
            defer pend.Done()
            ethash.mine(block, id, nonce, abort, found) // Seal核心工作
        }(i, uint64(ethash.rand.Int63()))
    }
    // 直到seal操作被中止或者找到了一个nonce值，否则一直等
    var result *types.Block // 定义一个区块对象result，用于接收操作结果并作为返回值返回上一层
    select { // go语法参照 http://www.cnblogs.com/Evsward/p/go.html#select
    case &amp;lt;-stop:
        // 外部意外中止，停止所有挖矿线程
        close(abort)
    case result = &amp;lt;-found:
        // 其中一个线程挖到正确块，中止其他所有线程
        close(abort)
    case &amp;lt;-ethash.update:
        // ethash对象发生改变，停止当前所有操作，重启当前方法
        close(abort)
        pend.Wait()
        return ethash.Seal(chain, block, stop)
    }
    // 等待所有矿工停止或者返回一个区块
    pend.Wait()
    return result, nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上Seal方法体，针对ethash的各种状态进行了校验和流程处理，以及对线程资源的控制，下面看Seal核心工作的内容（sealer.go文件只有两个函数，一个是Seal方法，另一个就是mine方法，可以看出Seal方法是对外的，而mine方法是内部方法，只能被当前ethash包域调用）：mine方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// mine函数是真正的pow矿工，用来搜索一个nonce值，nonce值开始于seed值，seed值是能最终产生正确的可匹配可验证的区块难度
func (ethash *Ethash) mine(block *types.Block, id int, seed uint64, abort chan struct{}, found chan *types.Block) {
    // 从区块头中提取出一些数据，放在一个全局变量域中
    var (
        header = block.Header()
        hash   = header.HashNoNonce().Bytes()
        target = new(big.Int).Div(maxUint256, header.Difficulty) // 后面有大用，这是用来验证的target

        number  = header.Number.Uint64()
        dataset = ethash.dataset(number)
    )
    // 开始生成随机nonce值知道我们中止或者成功找到了一个合适的值
    var (
        attempts = int64(0) // 初始化一个尝试次数的变量，下面会利用该变量耍一些花枪
        nonce    = seed // 初始化为seed值，后面每次尝试以后会累加
    )
    logger := log.New(&quot;miner&quot;, id)
    logger.Trace(&quot;Started ethash search for new nonces&quot;, &quot;seed&quot;, seed)
    for {
        select {
        case &amp;lt;-abort: // 中止命令
            // 挖矿中止，更新状态，中止当前操作，返回空
            logger.Trace(&quot;Ethash nonce search aborted&quot;, &quot;attempts&quot;, nonce-seed)
            ethash.hashrate.Mark(attempts)
            return

        default: // 默认执行
            // 我们没必要在每一次尝试nonce值的时候更新hash率，可以在尝试了2的X次方nonce值以后再更新即可
            attempts++ // 通过次数attemp来控制
            if (attempts % (1 &amp;lt;&amp;lt; 15)) == 0 {// 这里是定的2的15次方，位操作符请参考 http://www.cnblogs.com/Evsward/p/go.html#%E5%B8%B8%E9%87%8F
                ethash.hashrate.Mark(attempts) // 满足条件了以后，要更新ethash的hash率字段的状态值
                attempts = 0 // 重置尝试次数
            }
            // 为这个nonce值计算pow值
            digest, result := hashimotoFull(dataset, hash, nonce) // 调用的hashimotoFull函数在本包的算法库中，后面会介绍。
            if new(big.Int).SetBytes(result).Cmp(target) &amp;lt;= 0 { // 验证标准，后面介绍
                // 找到正确nonce值，创建一个基于它的新的区块头
                header = types.CopyHeader(header)
                header.Nonce = types.EncodeNonce(nonce) // 将输入的整型值转换为一个区块nonce值
                header.MixDigest = common.BytesToHash(digest) // 将字节数组转换为Hash对象【Hash是32位的根据任意输入数据的Keccak256哈希算法的返回值】

                // 封装返回一个区块
                select {
                case found &amp;lt;- block.WithSeal(header):
                    logger.Trace(&quot;Ethash nonce found and reported&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce)
                case &amp;lt;-abort:
                    logger.Trace(&quot;Ethash nonce found but discarded&quot;, &quot;attempts&quot;, nonce-seed, &quot;nonce&quot;, nonce)
                }
                return
            }
            nonce++ // 累加nonce
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mine方法主要就是对nonce的操作，以及对区块头的重建操作，注释中我们也留了一个坑就是对于nonce尝试的工作，这部分内容会转到算法库中来介绍。&lt;/p&gt;
&lt;h3 id=&quot;algorithm&quot;&gt;algorithm&lt;/h3&gt;
&lt;p&gt;ethash包中包含几个algorithm开头的文件，这些文件的内容是pow核心算法，用来支持挖矿操作。首先我们继续上面留的坑继续研究。&lt;/p&gt;
&lt;h4 id=&quot;hashimotofull函数&quot;&gt;hashimotoFull函数&lt;/h4&gt;
&lt;p&gt;该函数位于ethash/algorithm.go文件中，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 在传入的数据集中通过hash和nonce值计算加密值
func hashimotoFull(dataset []uint32, hash []byte, nonce uint64) ([]byte, []byte) {
    // 本函数核心代码段：定义一个lookup函数，用于在数据集中查找数据
    lookup := func(index uint32) []uint32 {
        offset := index * hashWords // hashWords是上面定义的常量值= 16
        return dataset[offset : offset+hashWords]
    }
    // hashimotoFull函数做的工作就是将原始数据集进行了读取分割，然后传给hashimoto函数。
    return hashimoto(hash, nonce, uint64(len(dataset))*4, lookup)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hashimoto函数&quot;&gt;hashimoto函数&lt;/h4&gt;
&lt;p&gt;继续分析，上面的hashimotoFull函数返回的是hashimoto函数的返回值，hashimoto算法我们在上面概念部分已经介绍过了，读源码的朋友不理解的可以翻回上面仔细了解一番再回到这里继续研究。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 该函数与hashimotoFull有着相同的愿景：在传入的数据集中通过hash和nonce值计算加密值
func hashimoto(hash []byte, nonce uint64, size uint64, lookup func(index uint32) []uint32) ([]byte, []byte) {
    // 计算数据集的理论的行数
    rows := uint32(size / mixBytes)

    // 合并header+nonce到一个40字节的seed
    seed := make([]byte, 40) // 创建一个长度为40的字节数组，名字为seed
    copy(seed, hash)// 将区块头的hash（上面提到了Hash对象是32字节大小）拷贝到seed中。
    binary.LittleEndian.PutUint64(seed[32:], nonce) // 将nonce值填入seed的后（40-32=8）字节中去，（nonce本身就是uint64类型，是64位，对应8字节大小），正好把hash和nonce完整的填满了40字节的seed

    seed = crypto.Keccak512(seed) // seed经历一遍Keccak512加密
    seedHead := binary.LittleEndian.Uint32(seed) // 从seed中获取区块头，代码后面详解

    // 开始与重复seed的混合
    mix := make([]uint32, mixBytes/4)// mixBytes常量= 128，mix的长度为32，元素为uint32，是32位，对应为4字节大小。所以mix总共大小为4*32=128字节大小
    for i := 0; i &amp;lt; len(mix); i++ {
        mix[i] = binary.LittleEndian.Uint32(seed[i%16*4:])// 共循环32次，前16和后16位的元素值相同
    }
    // 做一个temp，与mix结构相同，长度相同
    temp := make([]uint32, len(mix))

    for i := 0; i &amp;lt; loopAccesses; i++ { // loopAccesses常量 = 64，循环64次
        parent := fnv(uint32(i)^seedHead, mix[i%len(mix)]) % rows // mix[i%len(mix)]是循环依次调用mix的元素值，fnv函数在本代码后面详解
        for j := uint32(0); j &amp;lt; mixBytes/hashBytes; j++ {
            copy(temp[j*hashWords:], lookup(2*parent+j))// 通过用种子seed生成的mix数据进行FNV哈希操作以后的数值作为参数去查找源数据（太绕了）拷贝到temp中去。
        }
        fnvHash(mix, temp) // 将mix中所有元素都与temp中对应位置的元素进行FNV hash运算
    }
    // mix大混淆
    for i := 0; i &amp;lt; len(mix); i += 4 {
        mix[i/4] = fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3])
    }
    // 最后有效数据只在前8个位置，后面的数据经过上面的循环混淆以后没有价值了，所以将mix的长度减到8，保留前8位有效数据。
    mix = mix[:len(mix)/4]

    digest := make([]byte, common.HashLength) // common.HashLength=32，创建一个长度为32的字节数组digest
    for i, val := range mix {
        binary.LittleEndian.PutUint32(digest[i*4:], val)// 再把长度为8的mix分散到32位的digest中去。
    }
    return digest, crypto.Keccak256(append(seed, digest...))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该函数除了被hashimotoFull函数调用以外，还会被hashimotoLight函数调用。顾名思义，hashimotoLight是相对于hashimotoFull的存在。hashimotoLight在后面有机会就介绍（看看能不能绕进我们的route吧）。&lt;/p&gt;
&lt;h5 id=&quot;下划线与位运算&quot;&gt;下划线与位运算|&lt;/h5&gt;
&lt;p&gt;以上代码中的seedHead := binary.LittleEndian.Uint32(seed)，我们挑出来单练，跳转到内部方法为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (littleEndian) Uint32(b []byte) uint32 {
    _ = b[3] // bounds check hint to compiler; see golang.org/issue/14808
    return uint32(b[0]) | uint32(b[1])&amp;lt;&amp;lt;8 | uint32(b[2])&amp;lt;&amp;lt;16 | uint32(b[3])&amp;lt;&amp;lt;24
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;go语法补充：下划线变量代表Go语言“垃圾桶”的意思，这个垃圾桶并不是说销毁一个对象，而是针对go语言报错机制来处理的，所以b[3]这一行可以是b[3]未使用防止go报“xxx未使用”的错误，同时观察后面的官方注释，也是为了在真正使用b[3]数据前进行边界检查，如果b[3]为空，则会提前报错，不会引发程序问题。&lt;/li&gt;
&lt;li&gt;位运算，我们在&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/go.html#%E5%B8%B8%E9%87%8F&quot;&gt;《掌握一门语言GO》&lt;/a&gt;中对左移和右移进行了介绍，这里针对或|和与&amp;amp;进行介绍。位运算都是将原数据转换为二进制进行运算，或|就是0和1或得1，例如1和2或得3，因为1的二进制表达为01,2的二进制表达为10，01和10或运算以后就是11，等于3。同理，与&amp;amp;运算就是，0和1与得0，所以1和2的与运算结果为0，因为与&amp;amp;运算是只有都为1才能得1。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;fnv-hash-算法&quot;&gt;FNV hash 算法&lt;/h5&gt;
&lt;p&gt;FNV是由三位创建者的名字得来的，我们知道hash算法最重要的目标就是要平均分布（高度分散），避免碰撞，最好相近的源数据加密后完全不同，哪怕他们只有一个字母不一样，FNV hash算法就是这样的一种算法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func fnv(a, b uint32) uint32 {
    return a*0x01000193 ^ b
}

func fnvHash(mix []uint32, data []uint32) {
    for i := 0; i &amp;lt; len(mix); i++ {
        mix[i] = mix[i]*0x01000193 ^ data[i]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;0x01000193是FNV hash算法的一个hash质数（Prime number，又叫素数，只能被1和其本身整除），哈希算法会基于一个常数来做散列操作。0x01000193是FNV针对32 bit数据的散列质数。&lt;/p&gt;
&lt;h3 id=&quot;验证方式&quot;&gt;验证方式&lt;/h3&gt;
&lt;p&gt;我们一直提，pow是难于计算，上面这么长篇章深刻体现了这一点，但是pow是易于验证的，所以本节讨论的是ethash的pow的验证方式，这个验证方式也很容易找到，就是上面mine方法中我在注释里留下的坑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new(big.Int).SetBytes(result).Cmp(target) &amp;lt;= 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的核心计算nonce对应的加密值digest方法hashimoto算法返回了一个digest和一个result两个值，而由这行代码可知，与验证方式相关的就是result的值。result在hashimoto算法中最终还经过了crypto.Keccak256(append(seed, digest...)的Keccak256加密，参数列表中也看到了digest值。得到result值以后，就要执行上面这行代码的表达式了。这行表达式很简单，主要含义就是将result值和target值进行比较，如果小于等于0，即为通过。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那么target是什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;target被定义在mine方法体中靠前的变量声明部分，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;target = new(big.Int).Div(maxUint256, header.Difficulty)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，target的定义是根据区块头中的难度值运算而得出的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;代码读到这里，已经完成了一个闭环，结合前面的&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/miner.html&quot;&gt;《挖矿》&lt;/a&gt;，我们已经走通了以太坊pow的全部流程，整个流程我没有丝毫懈怠，从入口深入到内核，我们把源码扒了底掉（实际上，目前为止的流程中，以太坊的pow并未真正使用到如我所想的&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/dag.html&quot;&gt;DAG&lt;/a&gt;）。到目前为止，我们对pow，以及以太坊ethash的实现有了深刻的理解与认识，相信如果让我们去实现一套pow，也是完全有能力的。大家在阅读本文时有任何疑问均可留言给我，我一定会及时回复。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;go-ethereum源码，以太坊官方文档，网络名词解释文章&lt;/p&gt;

</description>
<pubDate>Fri, 23 Mar 2018 10:55:00 +0000</pubDate>
<dc:creator>一面千人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Evsward/p/ethash.html</dc:identifier>
</item>
<item>
<title>快速理解web语义化 - weixiao-he</title>
<link>http://www.cnblogs.com/weixiao-he/p/8630084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weixiao-he/p/8630084.html</guid>
<description>&lt;h2 id=&quot;什么是web语义化&quot;&gt;什么是Web语义化&lt;/h2&gt;
&lt;p&gt;Web语义化是指使用恰当语义的html标签、class类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。语义化的web页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而可以读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器（如果访客有视障）能够读懂内容。&lt;br/&gt;简单来说就是利于 SEO，便于阅读维护理解。&lt;/p&gt;
&lt;p&gt;总结起来就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正确的标签做正确的事情&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;页面内容结构化&lt;/li&gt;
&lt;li&gt;无CSS样子时也容易阅读，便于阅读维护和理解&lt;/li&gt;
&lt;li&gt;便于浏览器、搜索引擎解析。 利于爬虫标记、利于SEO&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;html-语义化标签&quot;&gt;html 语义化标签&lt;/h3&gt;
&lt;p&gt;HTML为网页文档内容提供上下文结构和含义。对于HTML体系而言，Web语义化是指使用语义恰当的标签，使页面有良好的结构，让页面元素有含义，便于被浏览器、搜索引擎解析、利于SEO。通常我们所说的HTML应该是完全脱离表现信息的，其中的标签应该都是语义化地定义了文档的结构。&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;article&amp;gt;
            &amp;lt;header&amp;gt;
                &amp;lt;h1&amp;gt;h1 - WEB 语义化&amp;lt;/h1&amp;gt;
            &amp;lt;/header&amp;gt;
            &amp;lt;nav&amp;gt;
                &amp;lt;ul&amp;gt;
                    &amp;lt;li&amp;gt;nav1 - HTML语义化&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;nav2 - CSS语义化&amp;lt;/li&amp;gt;
                &amp;lt;/ul&amp;gt;
            &amp;lt;/nav&amp;gt;
            &amp;lt;section&amp;gt;
                section1 - HTML语义化
            &amp;lt;/section&amp;gt;
            &amp;lt;section&amp;gt;
                section2 - CSS语义化
            &amp;lt;/section&amp;gt;
            &amp;lt;time datetime=&quot;2018-03-23&quot; pubdate&amp;gt;time - 2018年03月23日&amp;lt;/time&amp;gt;
            &amp;lt;footer&amp;gt; footer - by 小维&amp;lt;/footer&amp;gt;
        &amp;lt;/article&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;html语义化标签包括 body, article, nav, aside, section, header, footer, hgroup, 还有 h1-h6 address等。&lt;/p&gt;
&lt;p&gt;下面来简单介绍下常用的html语义化标签&lt;/p&gt;

&lt;p&gt;header代表“网页”或者“section”的页眉，通常包含h1-h6 元素或者 hgroup, 作为整个页面或者一个内容快的标题。也可以包裹一节的目录部分，一个搜索框，一个nav，或者相关logo。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;header&amp;gt;
        &amp;lt;hgroup&amp;gt;
            &amp;lt;h1&amp;gt;网站标题&amp;lt;h1&amp;gt;
            &amp;lt;h2&amp;gt;网站副标题&amp;lt;/h2&amp;gt;
        &amp;lt;/hgroup&amp;gt;
    &amp;lt;header&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以是“网页”或者任意“section”的头部部分&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;没有个数限制&lt;/li&gt;
&lt;li&gt;如果hgroup或者h1-h6自己就能工作得很好，那么就没必要用header。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;hgroup-元素&quot;&gt;hgroup 元素&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;hgroup&lt;/code&gt; 元素代表“网页”或“section”的标题，当元素有多个层级时，该元素可以将&lt;code&gt;h1&lt;/code&gt;到&lt;code&gt;h6&lt;/code&gt;元素放在其内，譬如文章的主标题和副标题组合&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;hgroup&amp;gt;
    &amp;lt;h1&amp;gt;这是一个主标题&amp;lt;/h1&amp;gt;
    &amp;lt;h2&amp;gt;这是一个副标题&amp;lt;/h2&amp;gt;
&amp;lt;/hgroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果只需要一个h1-h6标签就不用hgroup&lt;/li&gt;
&lt;li&gt;如果有连续多个h1-h6标签就用hgroup&lt;/li&gt;
&lt;li&gt;如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;footer&lt;/code&gt;元素代表“网页”或任意“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。如果&lt;code&gt;footer&lt;/code&gt;元素包含了整个节，那么它们就代表附录，索引，提拔，许可协议，标签，类别等一些其他类似信息。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;footer&amp;gt;
    COPYRGHT@小维
&amp;lt;/footer&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以是“网页”或者任意“section”的底部部分&lt;/li&gt;
&lt;li&gt;没有个数限制，除了包裹的内容不一样，其他跟header类似&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;nav-元素&quot;&gt;nav 元素&lt;/h4&gt;
&lt;p&gt;nav 元素代表页面的导航链接区域。用于定义页面的主要导航部分。&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;nav&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;HTML语义化&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;CSS 语义化&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;侧边栏上目录、面包屑导航、搜索样式、或者下一篇上一篇文章我们可能会想要用到nav，但是事实上规范上说nav只能用在页面主要导航部分上。页脚区域中的链接列表，虽然指向不同网站的不同区域，譬如服务条款，版权页等，这些footer元素就能够用了。&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用于整个页面的主要导航部分，不适合就不要用nav元素了&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;article-元素&quot;&gt;article 元素&lt;/h4&gt;
&lt;p&gt;article 代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。&lt;br/&gt;除了它的内容，article会有一个标题(通常会在&lt;code&gt;header&lt;/code&gt;里)，一个&lt;code&gt;footer&lt;/code&gt;页脚。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;article&amp;gt;
    &amp;lt;h1&amp;gt;你好，我是这边文章的标题&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;你好，我是文章的内容&amp;lt;/p&amp;gt;
    &amp;lt;footer&amp;gt;
        &amp;lt;p&amp;gt;最终解释权归XXX所有&amp;lt;/p&amp;gt;
    &amp;lt;/footer&amp;gt;
&amp;lt;/article&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个最简单的例子，如果在article内部再嵌套article，那就代表内嵌的article是与它外部的内容有关联的，如博客文章下面的评论，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;article&amp;gt;

    &amp;lt;header&amp;gt;
        &amp;lt;h1&amp;gt;web 语义化&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;&amp;lt;time pubdate datetime=&quot;2018-03-23&quot;&amp;gt;2018-03-23&amp;lt;/time&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;/header&amp;gt;

    &amp;lt;p&amp;gt;文章内容..&amp;lt;/p&amp;gt;

    &amp;lt;article&amp;gt;
        &amp;lt;h2&amp;gt;评论&amp;lt;/h2&amp;gt;

        &amp;lt;article&amp;gt;
            &amp;lt;header&amp;gt;
                &amp;lt;h3&amp;gt;评论者: 专业水军&amp;lt;/h3&amp;gt;
                &amp;lt;p&amp;gt;&amp;lt;time pubdate datetime=&quot;2018-03-23T15:10-08:00&quot;&amp;gt;~1 min ago&amp;lt;/time&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;/header&amp;gt;
            &amp;lt;p&amp;gt;还行&amp;lt;/p&amp;gt;
        &amp;lt;/article&amp;gt;

        &amp;lt;article&amp;gt;
            &amp;lt;header&amp;gt;
                &amp;lt;h3&amp;gt;评论者: 大水怪&amp;lt;/h3&amp;gt;
                &amp;lt;p&amp;gt;&amp;lt;time pubdate datetime=&quot;2018-03-23T15:10-08:00&quot;&amp;gt;~1 hour ago&amp;lt;/time&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;/header&amp;gt;
            &amp;lt;p&amp;gt;楼上说的对&amp;lt;/p&amp;gt;
        &amp;lt;/article&amp;gt;

    &amp;lt;/article&amp;gt;

&amp;lt;/article&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;article 内部可以嵌套article，表示评论或者其他跟文章有关联的内容。article内部还可以嵌套section，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;article&amp;gt;

    &amp;lt;h1&amp;gt;web语义化&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;什么是语义化？&amp;lt;/p&amp;gt;

    &amp;lt;section&amp;gt;
        &amp;lt;h2&amp;gt;语义化详解&amp;lt;/h2&amp;gt;
        &amp;lt;p&amp;gt;语义化就是。。。&amp;lt;/p&amp;gt;
    &amp;lt;/section&amp;gt;

    &amp;lt;section&amp;gt;
        &amp;lt;h2&amp;gt;语义化特点&amp;lt;/h2&amp;gt;
        &amp;lt;p&amp;gt;语义化特点就是。。。&amp;lt;/p&amp;gt;
    &amp;lt;/section&amp;gt;

&amp;lt;/article&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章内section是独立的部分，但是它们只能算是组成整体的一部分，从属关系，article是大主体，section是构成这个大主体的一个部分。&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自身独立情况下：用article&lt;/li&gt;
&lt;li&gt;是相关内容： 用section&lt;/li&gt;
&lt;li&gt;没有语义的： 用div&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;section-元素&quot;&gt;section 元素&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;section&lt;/code&gt; 元素代表文档中的“节”或“段”，“段”可以是指一片文章里按照主题的分段；“节”可以是指一个页面里的分组。&lt;code&gt;section&lt;/code&gt;通常还带标题，虽然html5中section会自动给标题h1-h6降级，但是最好手动给他们降级。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;section&amp;gt;
    &amp;lt;h1&amp;gt;section是啥？&amp;lt;/h1&amp;gt;
    &amp;lt;article&amp;gt;
        &amp;lt;h2&amp;gt;关于section&amp;lt;/h2&amp;gt;
        &amp;lt;p&amp;gt;section的介绍&amp;lt;/p&amp;gt;
        &amp;lt;section&amp;gt;
            &amp;lt;h3&amp;gt;关于其他&amp;lt;/h3&amp;gt;
            &amp;lt;p&amp;gt;关于其他section的介绍&amp;lt;/p&amp;gt;
        &amp;lt;/section&amp;gt;
    &amp;lt;/article&amp;gt;
&amp;lt;/section&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一张页面可以用section划分为简介、文章条目和联系信息。不过在文章内页，最好用article。section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。&lt;/li&gt;
&lt;li&gt;表示文档中的节或者段。&lt;/li&gt;
&lt;li&gt;acticle、nav、aside可以理解为特殊的section，如果可以用article、nav、aside就不要用section，没有实际意义的就用div&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;aside元素&quot;&gt;aside元素&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;aside&lt;/code&gt; 元素被包含在&lt;code&gt;article&lt;/code&gt;元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料，标签，名词解释等。&lt;br/&gt;在&lt;code&gt;article&lt;/code&gt;元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;article&amp;gt;
    &amp;lt;p&amp;gt;内容&amp;lt;/p&amp;gt;
    &amp;lt;aside&amp;gt;
        &amp;lt;h1&amp;gt;作者简介&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;小维,哈哈哈&amp;lt;/p&amp;gt;
    &amp;lt;/aside&amp;gt;
&amp;lt;/article&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;aside 在 article 内表示主要内容的附属信息。&lt;/li&gt;
&lt;li&gt;在article之外侧可以做侧边栏，没有article与之对应，最好不用&lt;/li&gt;
&lt;li&gt;如果是广告，其他日志链接或者其他分类导航也可以用。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;html语义化小结&quot;&gt;html语义化小结&lt;/h4&gt;
&lt;p&gt;总之，HTML语义化是反对大篇幅使用无语义化的div+span+class，而鼓励使用HTML定义好的语义化标签。&lt;/p&gt;
&lt;p&gt;当然，如果需要兼容低版本的IE浏览器，比如说IE8以及以下，那就需要考虑一些HTML5标签兼容性解决方案了。&lt;br/&gt;更多标签及其兼容性请去往传送门&lt;br/&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5/HTML5_element_list&quot;&gt;html5标签列表传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;css语义化&quot;&gt;CSS语义化&lt;/h3&gt;
&lt;p&gt;CSS语义就是class和ID命名的语义。class属性作为HTML与CSS衔接的纽带，其本意是用来描述元素内容的。指用易于理解的名称对html标签附加的class或id命名。如果说HTML语义化标签是给机器看的，那么CSS命名的语义化就是给人看的。良好的CSS命名方式减少沟通调试成本，易于理解。&lt;/p&gt;
&lt;p&gt;CSS命名首先要满足W3C的命名规范和团队的命名规范。其次是高效和可重用性。&lt;/p&gt;
&lt;p&gt;就好像.main/.sidebar会比.left_content/.right_content的class命名灵活性更好。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 以表现为中心 --&amp;gt;
&amp;lt;div class=&quot;ft margin10&quot;&amp;gt;
    &amp;lt;span&amp;gt;用户名：小维&amp;lt;/span&amp;gt;
&amp;lt;div&amp;gt;

&amp;lt;!-- 以信息为中心 --&amp;gt;
&amp;lt;p class=&quot;user_info&quot;&amp;gt;
    &amp;lt;em&amp;gt;用户名:小维&amp;lt;/em&amp;gt;
&amp;lt;p&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，问题来了。既然CSS class和ID命名的语义化可以便于阅读理解和减少沟通调试成本，那么我们是不是可以用div 结合class和ID语义化命名的方式来代替html的语义化？&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;article&quot;&amp;gt;
            &amp;lt;div class=&quot;header&quot;&amp;gt;
                &amp;lt;h1&amp;gt;h1 - WEB 语义化&amp;lt;/h1&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;nav&quot;&amp;gt;
                &amp;lt;ul&amp;gt;
                    &amp;lt;li&amp;gt;nav1 - HTML语义化&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;nav2 - CSS语义化&amp;lt;/li&amp;gt;
                &amp;lt;/ul&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;section&quot;&amp;gt;
                section1 - HTML语义化
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;section&quot;&amp;gt;
                section2 - CSS语义化
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;time&quot;&amp;gt;time - 2018年03月23日&amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;footer&quot;&amp;gt; footer - by 小维&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码的层面上来看，使用CSS class语义化的命名也是能够便于阅读和维护的，但是这样子并不利于SEO和屏幕阅读器识别。&lt;/p&gt;
&lt;h3 id=&quot;知识拓展aria&quot;&gt;知识拓展——ARIA&lt;/h3&gt;
&lt;p&gt;ARIA即Accessible Rich Internet Application，中文译为无障碍富互联网应用。可以为一些有功能障碍（如听力，视力）的人群通过屏幕阅读器例如voiceover等，提供无障碍访问动态、可交互Web内容。&lt;/p&gt;
&lt;p&gt;而应用于HTML的ARIA有两部分组成：role 和aria-* 。&lt;/p&gt;
&lt;p&gt;其中，role标识了一个元素的作用，aria-描述了与之有关的事物特征及其状态。&lt;/p&gt;
&lt;p&gt;ARIA的具体使用规则可见ARIA in HTML&lt;/p&gt;
&lt;p&gt;W3C对ARIA无障碍Web规范这样解释：&lt;br/&gt;Web developers may use the ARIA role and aria-* attributes on HTML elements, in accordance with the requirements described in [wai-aria-1.1], except where these conflict with the strong native semantics or are equal to the implicit ARIA semantics of a given HTML element.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Setting an ARIA role and/or aria-* attribute that matches the implicit ARIA semantics is unnecessary and is not recommended as these properties are already set by the browser.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，如果使用的元素(HTML5)本身具有语义化，应该使用这些元素，而不用再重新定义一个添加ARIA的角色、状态或属性的元素。&lt;br/&gt;例如：&lt;br/&gt;nav已经隐含ARIA的role=&quot;navigation&quot;声明，就不用在&lt;/p&gt;
&lt;nav readability=&quot;3.3997995991984&quot;&gt;标签上在定义role或者aria就能被读屏软件识别。而没有语义化的元素如

&lt;/nav&gt;</description>
<pubDate>Fri, 23 Mar 2018 10:43:00 +0000</pubDate>
<dc:creator>weixiao-he</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weixiao-he/p/8630084.html</dc:identifier>
</item>
</channel>
</rss>