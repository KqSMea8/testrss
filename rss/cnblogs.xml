<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>DTO – 服务实现中的核心数据 - 超越自我，挑战无极限</title>
<link>http://www.cnblogs.com/hxqcom/p/7795867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hxqcom/p/7795867.html</guid>
<description>
&lt;p&gt;       在一个Web服务的实现中，我们常常需要访问数据库，并将从数据库中所取得的数据显示在用户页面中。这样做的一个问题是：用于在用户页面上展示的数据和从数据库中取得的数据常常具有较大区别。在这种情况下，我们常常需要向服务端发送多个请求才能将用于在页面中展示的数据凑齐。&lt;/p&gt;
&lt;p&gt;　　一个解决该问题的方法就是根据不同需求使用不同的数据表现形式。在一个服务实现中较为常见的数据表现形式有MO（Model Object，在有些上下文中也被称为VO，Value Object）和DTO（Data Transfer Object）。MO用来表示从数据库中读取的数据，而DTO则用来表示在网络上所传输的数据。&lt;/p&gt;
&lt;p&gt;　　在本文中，我们将讨论如何在一个Web服务的实现中使用DTO及MO，并会对其它一些相关数据表现形式，如View Model等进行简单地介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Why DTO?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　无论是桌面应用还是Web服务，其内部的数据表现都是非常重要的。在一个初学者了解一个系统的时候，其首先需要了解整个系统中的各个组件的作用，然后再了解系统中的Workflow，即在执行业务逻辑时各个组件是如何协同工作的。在了解了这两部分之后，该初学者需要做的事情就是详细地梳理一遍数据是如何在整个系统中流动的，即是整理并理解数据流（Dataflow）的过程。而在真正理解了数据流后，该初学者才具有了在系统中开发的能力。&lt;/p&gt;
&lt;p&gt;　　整理数据流的过程是一个逐步细化的过程：从鉴别数据结构到该数据结构中的每个属性到底是如何使用的。在整个数据流中，任何一个属性值的改变都可能会导致数据的处理方式发生变化。&lt;/p&gt;
&lt;p&gt;　　在整理数据流的时候我们要做什么样的事情呢？首先我们需要鉴别出到底哪些数据会在各个组件之间进行传送，在传送过程中进行了什么样的转化，这些数据是如何构建出来的，又由它构建了哪些数据，最终这些数据是否被持久化到了本地存储中等等。&lt;/p&gt;
&lt;p&gt;　　而在整理数据流的过程中，数据的转化常常是最难理解的部分。一个数据类型的定义常常与其运行环境有关。例如在一个电子商务网站中，一个表示商品的类Product可能包含了该商品的所有信息：商品的名称，品牌，详细介绍，价格等。在用户使用电脑浏览器浏览的时候，这些信息都将被显示在页面上。但是在用户使用手机进行浏览时，我们就需要考虑如何为这些手机用户节省流量的问题。一种节省用户手机流量的方法就是首先显示商品的简略信息，并在用户决定查看商品的详细介绍时再从服务端下载商品的详细信息。在这种情况下，包含商品所有信息的类Product将不再是适合传输的数据结构。&lt;/p&gt;
&lt;p&gt;　　而问题不仅仅出在需要将数据结构拆分的情况下，更可能出现在数据合并的情况中。例如网页的UE为了提高用户体验，要求在产品页面中直接将该商品品牌的详细信息显示在页面中。在这种情况下，我们就需要在表示商品的类Product中添加一个记录该商品品牌的域brand。但是在数据库中，表示商品的类Product可能仅仅记录了商品品牌的ID。因此在业务逻辑中，我们就需要将Product和其对应的Brand合并在一起。&lt;/p&gt;
&lt;p&gt;　　甚至说，我们可以将事情弄得更复杂一些：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201711/561186-20171106232334231-1926124245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的图中，我们展示了数据在一个系统中可能存在的多种不同表现形式。在图片的中央位置的是一个服务器，多种客户端都将从它那里获得产品信息。就像前面所说，为了节省客户端的流量，服务端向移动客户端所发送的数据将是产品信息在服务端中的简略版本。而在一个浏览器访问该产品的时候，表示商品品牌的信息将内嵌在产品信息之中，以提供更好的用户体验。除了与客户端通讯，服务端之间也可能产生信息的交换。在该交换过程中，表示产品的Product以及表示品牌的Brand则彼此独立地在服务端之间传递。而就一个运行在远端的Agent而言，其可能仅仅需要一个Product的ID来监控产品在生产制作方面的状态。&lt;/p&gt;
&lt;p&gt;　　而这一切数据都应当从系统的数据库中得到。数据库中的数据不可能同时存储并维护这一系列数据结构，因此在一个复杂的系统中，数据库中的数据表示与系统中所传输的数据之间常常是不同的数据结构。常见的情况则是将其分为两类：一类用来访问数据库，在系统中表现数据库中所记录的数据，叫MO，即Model Object；另一类用来在网络中传输，叫DTO，即Data Transfer Object。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务中的&lt;/strong&gt;&lt;strong&gt;DTO&lt;/strong&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;MO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在了解了我们为什么需要DTO和MO等数据的不同表示之后，就让我们来看看这些数据表示在一个Web服务中是如何工作的。&lt;/p&gt;
&lt;p&gt;　　先让我们从最简单的Web服务分层开始说起。一个最简单的Web服务主要分为数据访问层（DAL），业务逻辑层以及表现层三个部分。其中表现层是运行在客户端的，而其它两个层次则运行在服务端。当数据从DAL层读取出来的时候，其所记录的数据与数据库中所记录的数据是一致的，因此它们就是我们这篇文章中讨论的MO。而在传输给客户端的时候，这些数据可能会和MO不同，因此其为DTO：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201711/561186-20171106232458903-1466582592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在就让我们放大一下数据访问层，来看看数据访问层中MO所在的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201711/561186-20171106232545278-1527484862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;首先要强调的是，实现数据访问层的方式有很多种，而上图所展示的仅仅是一种基于Repository模式的实现。通过Repository来实现DAL是一种最为常见的数据访问层实现方式。就像上图所展示的那样，在一个基于Repository模式的实现中，数据访问层将拥有一系列Repository实例。这些Repository实例依赖于系统所使用的ORM来将数据库中的数据转化为Java类实例。这些Java类实例实际上就是在该数据访问层所提供给业务逻辑层的MO。&lt;/p&gt;
&lt;p&gt;　　而DTO则用于在服务与客户之间以及服务和服务之间进行数据的传递。在这些传递过程中，对DTO的需求可能是多种多样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201711/561186-20171106232618169-289456304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面的图片展示了一段Product这种类型的DTO在服务端和客户端以及服务端之间进行交互的过程。在该流程中，所需要传递的DTO并不相同：在使用浏览器读取和保存有关Product的信息时，两者的数据表现形式可能会有一些细微的差别。而在保存完毕后，服务可能会将新的Product作为负载来向其它服务器发送请求，而此时所使用的Product的表示又可能与前两种略有差别。如果为这些细微的差别定义很多不同的DTO，那么系统对数据的管理可能会遇到一系列麻烦。例如在一个复杂的系统中，DTO可能会按照下面的方式在系统中流转：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/blog2015/126867/201503/310029153575518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在上图中，我们展示了一个DTO在依次流转过多个服务的情况。如果在DTO依次传递的过程中使用了不同的DTO表示，那么一个服务所需要的DTO可能和另一个服务中所拥有的DTO并不匹配。这便是DTO反过来会影响到架构设计的一个最简单的例子，却也是DTO管理中最常见的问题，那就是DTO的表现形式过多。如果为所有的不同需求都创建一个DTO，那么一个概念所对应的DTO可能多达5，6种，非常难于管理。这种管理上的困难常常存在于如何指定某个服务所需要使用的DTO种类，以及在更改DTO时需要同时修改一系列DTO的情况中。&lt;/p&gt;
&lt;p&gt;　　为了防止DTO由于不同的需求而衍生出过多的种类，服务实现中常常允许DTO中的数据包含一些冗余。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;逐步添加你的&lt;/strong&gt;&lt;strong&gt;DTO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　那么我们该如何向系统中添加DTO呢？答案是，根据情况决定。在项目的一开始，数据库中所存储的数据与页面所需要显示的数据常常是一致的，因此在这种情况下，我们并不需要DTO的帮助。而在所需要的数据和数据库所记录的数据不再一样的时候，我们就需要考虑是否需要在项目中添加DTO了。这时软件开发人员就需要问自己：这种所需要的数据与数据库中的数据不一致的情况是否常常出现？如果答案是“是”，那么我们就需要开始着手准备添加对DTO的支持。&lt;/p&gt;
&lt;p&gt;　　在系统中添加DTO主要有以下几部分工作需要完成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;添加DTO类。&lt;/li&gt;
&lt;li&gt;添加从MO到DTO的转化逻辑。&lt;/li&gt;
&lt;li&gt;将原本对MO的使用转换为对DTO的使用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　相信读者最先注意到的就是第三点。可以想象到的是，如果将整个系统的MO替换成DTO，那么它的影响面将会非常大，而且非常容易出错。因此在一个大型项目中，我们常常需要预先判断DTO的必要性，进而尽早地添加DTO。&lt;/p&gt;
&lt;p&gt;　　让我们回过头来看看第一个任务应该如何完成。在一个系统中，DTO常常用来传输数据，因此其自身往往不带有任何逻辑。这也便是这些DTO常常被定义成JavaBean的原因。以JavaBean的形式来定义DTO带来了一个巨大的好处，那就是很多第三方类库都提供了生成JavaBean的功能。在这种情况下，软件开发人员只需要通过一系列描述性语言来描述这些DTO即可。这其中最常用的便是JAXB。&lt;/p&gt;
&lt;p&gt;　　在使用JAXB时，软件开发人员只需要在.xsd文件中编写一系列描述性信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:complexType &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Address&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:sequence&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:element &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:element &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;street&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:element &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;city&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:element &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;state&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:string&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsd:sequence&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsd:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;country&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;xsd:NMTOKEN&quot;&lt;/span&gt;&lt;span&gt; fixed&lt;/span&gt;&lt;span&gt;=&quot;US&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsd:complexType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么在JAXB运行完毕后，相应的Java类型就将被生成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@XmlAccessorType(AccessType.FIELD)
@XmlType(name = &quot;Address&quot;, propOrder = {
    &quot;name&quot;,
    &quot;street&quot;,
    &quot;city&quot;,
    &quot;state&quot;
})
public class Address {
    protected String name;
    protected String street;
    ……
    @XmlAttribute
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    protected String country;

    public String getName() {
        return name;
    }

    public void setName(String value) {
        this.name = value;
    }

    public String getStreet() {
        return street;
    }

    public void setStreet(String value) {
        this.street = value;
    }
    ……
    public String getCountry() {
        if (country == null) {
            return &quot;US&quot;;
        } else {
            return country;
        }
    }

    public void setCountry(String value) {
        this.country = value;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　是不是很简单？在知道了如何创建一个DTO之后，我们就需要考虑如何将MO转化成为DTO。当然，这依然有第三方工具可以帮助我们完成这个事情。一个较为著名的工具就是Dozer。使用Dozer也很简单，在它的配置文件里面标明需要相互转换的两个类型即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.ambergarden.egoods.mo.Address&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;class-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class-b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.ambergarden.edoods.dto.Address&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;class-b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在运行时，Dozer会使用反射来对这两个类型中的各个同名属性进行匹配并赋值。如果两个类型中拥有不同名的属性，那么软件开发人员可以显式地指定相互匹配的属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.ambergarden.egoods.mo.Address&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;class-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class-b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.ambergarden.edoods.dto.Address&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;class-b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;field&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;name&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;owner&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;field&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　除此之外，Dozer还支持非常多的转换功能，在这里我们便不一一进行介绍了。&lt;/p&gt;
&lt;p&gt;　　在有这些工具的辅助下，为系统添加DTO已经变得简单多了。在对DTO的日常维护中，我们可能需要添加一些新的DTO，或者更改已有的DTO。在这种情况下，我们只需要更改对DTO进行描述的文件并更新Dozer的配置文件即可。当然，如果在Dozer中使用了自定义转换逻辑，那么软件开发人员还需要更新相应的转换逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;贫血的&lt;/strong&gt;&lt;strong&gt;DTO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　DTO中只包含数据，并没有包含任何行为。“这我知道”，或许你会说。&lt;/p&gt;
&lt;p&gt;　　但是千万不要大意。这常常会导致你陷入贫血模型的陷阱中。在服务端的业务逻辑实现以及客户端的页面逻辑中，我们有时需要指定对这些数据的操作逻辑。从面向对象设计的角度来说，某些逻辑实际上就应该定义在这些类型中。但是由于DTO本身没有定义这些逻辑，因此我们需要在这些类型之外定义它们，例如在一个Helper类中为这些类型定义一系列辅助函数。&lt;/p&gt;
&lt;p&gt;　　一个最简单的示例就是对数据有效性的检查。例如在一个Person类中，我们使用一个整型数据记录了该人物的年龄：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person {&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;age;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;……&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; }&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;那么在业务逻辑中，我们就需要检查该域是否被设置为负数。由于DTO是使用工具自动生成的，因此这些检查逻辑无法放在该DTO类中。作为一种变通方式，我们需要写一个辅助类来完成该功能。但随着这种需求越来越多，对这些辅助功能的管理将越来越困难。此时你就将完全陷入到贫血模型的陷阱中。&lt;/p&gt;
&lt;p&gt;　　也就是说，DTO的主要职责是为了传输数据，但它并不擅长，甚至是不适合在业务逻辑中表示一个复杂概念。一个复杂概念常常与一些可重用的复杂逻辑关联，但这正是DTO所不能办到的。&lt;/p&gt;
&lt;p&gt;　　为了解决这个问题，我们可以在服务端添加一个业务逻辑表现，即BO（Business Object）。在这种情况下，MO将不会直接转化为DTO，而是转化为BO。在所有业务处理完毕并需要将数据发送给客户的时候，BO将转化为DTO以进行传输。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/blog2015/126867/201503/310037510296478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而在客户端，我们同样可以引入一层新的更适合于页面逻辑的数据表现。这种数据表现被称为VM（ViewModel），即为了表观展示所定义的模型。有时候，有些类库提供了更为简单的方法，例如YUI和ExtJS所提供的Mixin功能。&lt;/p&gt;
&lt;p&gt;　　当然，在添加这些数据展现形式之前，软件开发人员需要仔细考量添加这些模型所需要的工作量和所带来效益之间的平衡。&lt;/p&gt;

</description>
<pubDate>Mon, 06 Nov 2017 15:34:00 +0000</pubDate>
<dc:creator>超越自我，挑战无极限</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hxqcom/p/7795867.html</dc:identifier>
</item>
<item>
<title>Struts2+Spring+Hibernate实现员工管理增删改查功能（一）之ssh框架整合 - 姜飞祥</title>
<link>http://www.cnblogs.com/smfx1314/p/7795837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smfx1314/p/7795837.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言        转载请标明出处：http://www.cnblogs.com/smfx1314/p/7795837.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本项目是我写的一个练习，目的是回顾ssh框架的整合以及使用。项目介绍：此项目主要有前台管理员通过登录进入员工管理系统页面，之后可以对员工列表进行常规的增删改查。以及部门列表的增删改查。IDE使用的是eclipse，个人感觉比较好用，不过最近我正在研究idea,数据库是mysql，前台主要以bootstrap为主。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这点是直接摘抄的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;struts 控制用的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hibernate 操作数据库的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spring 用解耦的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Struts 、 spring 、 Hibernate 在各层的作用&lt;/p&gt;
&lt;p&gt;1 ） struts 负责 web 层 .&lt;/p&gt;
&lt;p&gt;ActionFormBean 接收网页中表单提交的数据，然后通过 Action 进行处理，再 Forward 到对应的网页。&lt;/p&gt;
&lt;p&gt;在 struts-config.xml 中定义 &amp;lt;action-mapping&amp;gt;, ActionServlet 会加载。&lt;/p&gt;
&lt;p&gt;2 ） spring 负责业务层管理，即 Service （或 Manager).&lt;/p&gt;
&lt;p&gt;1 ． service 为 action 提供统计的调用接口，封装持久层的 DAO.&lt;/p&gt;
&lt;p&gt;2 ．可以写一些自己的业务方法。&lt;/p&gt;
&lt;p&gt;3 ．统一的 javabean 管理方法&lt;/p&gt;
&lt;p&gt;4 ．声明式事务管理&lt;/p&gt;
&lt;p&gt;5. 集成 Hiberante&lt;/p&gt;
&lt;p&gt;3 ） Hiberante ，负责持久化层，完成数据库的 crud 操作&lt;/p&gt;
&lt;p&gt;hibernate 为持久层，提供 OR/Mapping 。&lt;/p&gt;
&lt;p&gt;它有一组 .hbm.xml 文件和 POJO, 是跟数据库中的表相对应的。然后定义 DAO ，这些是跟数据库打交道的类，它们会使用 PO 。&lt;/p&gt;
&lt;p&gt;在 struts+spring+hibernate 的系统中，&lt;/p&gt;
&lt;p&gt;对象的调用流程是： jsp-&amp;gt; Action － &amp;gt; Service -&amp;gt;DAO -&amp;gt;Hibernate 。&lt;/p&gt;
&lt;p&gt;数据的流向是 ActionFormBean 接受用户的数据， Action 将数据从 ActionFromBean 中取出，封装成 VO 或 PO,&lt;/p&gt;
&lt;p&gt;再调用业务层的 Bean 类，完成各种业务处理后再 forward 。而业务层 Bean 收到这个 PO 对象之后，会调用 DAO 接口方法，进行持久化操作。&lt;/p&gt;

&lt;p&gt; spring:Aop管理事务控制,IoC管理各个组件的耦合,DaoTemplate作为常规持久层的快速开发模板!&lt;/p&gt;
&lt;p&gt;struts:控制层Action,页面标签和Model数据,调用业务层&lt;/p&gt;
&lt;p&gt;Hibernate:负责数据库和对象的映射,负责DAO层(Data Access Object:数据访问)&lt;/p&gt;

&lt;p&gt;spring整合hibernate和struts，只要在配好了applicationContext.xml,在struts的action中直接调用就可以了。hibernate访问数据库的操作都在spring中实现了，spring的调用又在stuts的action中实现了。这个ssh框架就连到了一起……&lt;/p&gt;

&lt;p&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里关于mysql的表我就不贴出来了，这个大家可以根据实体类进行创建，我创建的是emp和dept表，他们之间是一对多关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，关于jsp页面中的*.js，你可以根据jsp中的路径自己创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于内容过多，今天我先说下ssh框架的整合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来让我们看下目录结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1247498/201711/1247498-20171106225702513-1230093656.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;第一步，导入jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1247498/201711/1247498-20171106230503309-438800691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1247498/201711/1247498-20171106230519825-727129475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二步：我们看下index.jsp页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;&lt;br/&gt;pageEncoding=&quot;UTF-8&quot;%&amp;gt;&lt;br/&gt;&amp;lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&amp;gt;&lt;br/&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&lt;br/&gt;&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;IE=edge&quot;&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;登录&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/js/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;${pageContext.request.contextPath }/utilLib/bootstrap.min.css&quot; type=&quot;text/css&quot; media=&quot;screen&quot; /&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;div_from_aoto&quot; style=&quot;width: 500px;&quot;&amp;gt;&lt;br/&gt;&amp;lt;form action=&quot;${pageContext.request.contextPath }/user_login.action&quot; method=&quot;post&quot;&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;control-group&quot;&amp;gt;&lt;br/&gt;&amp;lt;label class=&quot;laber_from&quot;&amp;gt;用户名&amp;lt;/label&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;controls&quot; &amp;gt;&amp;lt;input class=&quot;input_from&quot; type=text name=&quot;username&quot; placeholder=&quot; 请输入用户名&quot;&amp;gt;&amp;lt;/input&amp;gt;&amp;lt;p class=&quot;help-block&quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;control-group&quot;&amp;gt;&lt;br/&gt;&amp;lt;label class=&quot;laber_from&quot; &amp;gt;密码&amp;lt;/label&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;controls&quot; &amp;gt;&amp;lt;input class=&quot;input_from&quot; type=password name=&quot;password&quot; placeholder=&quot; 请输入密码&quot;&amp;gt;&amp;lt;/input&amp;gt;&amp;lt;p class=&quot;help-block&quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;div class=&quot;control-group&quot;&amp;gt;&lt;br/&gt;&amp;lt;label class=&quot;laber_from&quot; &amp;gt;&amp;lt;/label&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;controls&quot; &amp;gt;&lt;br/&gt;&amp;lt;button class=&quot;btn btn-success&quot; style=&quot;width:120px;&quot; &amp;gt;确认&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/form&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;上面主要使用了bootstrap框架。当然，登录页面我做的比较简单，你也可以根据自己的感觉去写效果&lt;/p&gt;
&lt;p&gt;第三步是配置文件，首先我们配置web.xml&lt;/p&gt;
&lt;p&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;&amp;lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&amp;gt;&lt;br/&gt;&amp;lt;display-name&amp;gt;ssh-day02&amp;lt;/display-name&amp;gt;&lt;br/&gt;&amp;lt;welcome-file-list&amp;gt;&lt;br/&gt;&amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt;&lt;br/&gt;&amp;lt;/welcome-file-list&amp;gt;&lt;br/&gt;&amp;lt;!-- 加载spring监听器 --&amp;gt;&lt;br/&gt;&amp;lt;listener&amp;gt;&lt;br/&gt;&amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;&lt;br/&gt;&amp;lt;/listener&amp;gt;&lt;br/&gt;&amp;lt;!-- 加载spring的配置文件applicationContext.xml --&amp;gt;&lt;br/&gt;&amp;lt;context-param&amp;gt;&lt;br/&gt;&amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;&lt;br/&gt;&amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;&lt;br/&gt;&amp;lt;/context-param&amp;gt;&lt;br/&gt;&amp;lt;!-- 解决no session问题 --&amp;gt;&lt;br/&gt;&amp;lt;filter&amp;gt;&lt;br/&gt;&amp;lt;filter-name&amp;gt;OpenSessionInviewFilter&amp;lt;/filter-name&amp;gt;&lt;br/&gt;&amp;lt;filter-class&amp;gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&amp;lt;/filter-class&amp;gt;&lt;br/&gt;&amp;lt;/filter&amp;gt;&lt;br/&gt;&amp;lt;filter-mapping&amp;gt;&lt;br/&gt;&amp;lt;filter-name&amp;gt;OpenSessionInviewFilter&amp;lt;/filter-name&amp;gt;&lt;br/&gt;&amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;&lt;br/&gt;&amp;lt;/filter-mapping&amp;gt;&lt;br/&gt;&amp;lt;!-- 配置Struts --&amp;gt;&lt;br/&gt;&amp;lt;filter&amp;gt;&lt;br/&gt;&amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;&lt;br/&gt;&amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-class&amp;gt;&lt;br/&gt;&amp;lt;/filter&amp;gt;&lt;br/&gt;&amp;lt;filter-mapping&amp;gt;&lt;br/&gt;&amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;&lt;br/&gt;&amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;&lt;br/&gt;&amp;lt;/filter-mapping&amp;gt;&lt;br/&gt;&amp;lt;!-- 设置session有效时间 --&amp;gt;&lt;br/&gt;&amp;lt;!-- &amp;lt;session-config&amp;gt;&lt;br/&gt;&amp;lt;session-timeout&amp;gt;1&amp;lt;/session-timeout&amp;gt;&lt;br/&gt;&amp;lt;/session-config&amp;gt; --&amp;gt;&lt;br/&gt;&amp;lt;/web-app&amp;gt;&lt;/p&gt;
&lt;p&gt;都是些基本的配置，no session配置是后边两张表进行关联查询时session提前关闭的问题&lt;/p&gt;
&lt;p&gt;第四步：把对应的包类创建出来，方便我们在applicationContext.xml中配置bean实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1247498/201711/1247498-20171106230957559-1870342981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们开始配置applicationContext.xml&lt;/p&gt;
&lt;p&gt;主要是创建数据库连接池，创建sessionFactory ，配置hibernate属性以及声明式事务，aop（我这块没有用到，就没有配置）,以及bean的实例化配置&lt;/p&gt;
&lt;p&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;br/&gt;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;br/&gt;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;&lt;br/&gt;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;&lt;br/&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;&lt;br/&gt;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans&lt;br/&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;br/&gt;http://www.springframework.org/schema/tx&lt;br/&gt;http://www.springframework.org/schema/tx/spring-tx.xsd&lt;br/&gt;http://www.springframework.org/schema/aop&lt;br/&gt;http://www.springframework.org/schema/aop/spring-aop.xsd&lt;br/&gt;http://www.springframework.org/schema/context&lt;br/&gt;http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt; &amp;lt;!-- 整合hibernate --&amp;gt;&lt;br/&gt;&amp;lt;!-- 1.配置数据库--&amp;gt;&lt;br/&gt;&amp;lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/ssh2&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;user&quot; value=&quot;root&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;password&quot; value=&quot;1234&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&amp;lt;!-- 配置sessionFactory --&amp;gt;&lt;br/&gt;&amp;lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;&lt;br/&gt;&amp;lt;!-- 数据源 --&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;!-- 配置hibernate基本属性 --&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;&lt;br/&gt;&amp;lt;props&amp;gt;&lt;br/&gt;&amp;lt;prop key=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/prop&amp;gt;&lt;br/&gt;&amp;lt;prop key=&quot;hibernate.show_sql&quot;&amp;gt;true&amp;lt;/prop&amp;gt;&lt;br/&gt;&amp;lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/prop&amp;gt;&lt;br/&gt;&amp;lt;/props&amp;gt;&lt;br/&gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;!-- 配置hibernate映射文件 --&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;mappingResources&quot;&amp;gt;&lt;br/&gt;&amp;lt;list&amp;gt;&lt;br/&gt;&amp;lt;value&amp;gt;com/ssh/entity/User.hbm.xml&amp;lt;/value&amp;gt;&lt;br/&gt;&amp;lt;value&amp;gt;com/ssh/entity/Emp.hbm.xml&amp;lt;/value&amp;gt;&lt;br/&gt;&amp;lt;value&amp;gt;com/ssh/entity/Dept.hbm.xml&amp;lt;/value&amp;gt;&lt;br/&gt;&amp;lt;/list&amp;gt;&lt;br/&gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&amp;lt;!-- 配置hibernate事务 --&amp;gt;&lt;br/&gt;&amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&amp;lt;!-- 开启事务 --&amp;gt;&lt;br/&gt;&amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;!-- 配置aop --&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/beans&amp;gt;&lt;/p&gt;
&lt;p&gt;然后在引入Struts2的配置文件&lt;/p&gt;
&lt;p&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;br/&gt;&amp;lt;!DOCTYPE struts PUBLIC&lt;br/&gt;&quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;&lt;br/&gt;&quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&amp;gt;&lt;br/&gt;&amp;lt;struts&amp;gt;&lt;br/&gt;&amp;lt;package name=&quot;ssh-day02&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/package&amp;gt;&lt;br/&gt;&amp;lt;/struts&amp;gt;&lt;/p&gt;
&lt;p&gt;注意，上面把hibernate的配置文件和spring进行了整合，所有没有单独创建hibernate的配置文件。&lt;/p&gt;
&lt;p&gt;到这里，ssh的配置基本完成。运行成功就是一个登陆页面&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 15:28:00 +0000</pubDate>
<dc:creator>姜飞祥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smfx1314/p/7795837.html</dc:identifier>
</item>
<item>
<title>Cocoapods安装过程 - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/7795811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/7795811.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;升级&lt;/strong&gt;&lt;strong&gt;Ruby&lt;/strong&gt;&lt;strong&gt;环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gem -v&lt;/p&gt;
&lt;p&gt;gem update --system&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果没有权限去升级&lt;/strong&gt;&lt;strong&gt;Ruby ?&lt;/strong&gt;&lt;strong&gt;就输入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sudo gem update --system&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;换掉&lt;/strong&gt;&lt;strong&gt;Ruby&lt;/strong&gt;&lt;strong&gt;镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先移除现有的Ruby镜像&lt;/p&gt;
&lt;p&gt;gem sources --remove &lt;a href=&quot;https://rubygems.org/&quot;&gt;https://rubygems.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加国内最新镜像源&lt;/p&gt;
&lt;p&gt;gem source -a &lt;a href=&quot;https://gems.ruby-china.org/&quot;&gt;https://gems.ruby-china.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看当前镜像&lt;/p&gt;
&lt;p&gt;gem sources -l&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;strong&gt;CocoaPods&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sudo gem install cocoapods&lt;/p&gt;
&lt;p&gt;如果报错&lt;/p&gt;
&lt;p&gt;sudo gem install -n /usr/local/bin cocoapods&lt;/p&gt;

&lt;p&gt;4.初始化repos文件&lt;/p&gt;
&lt;p&gt;pod repo add master &lt;a href=&quot;https://github.com/CocoaPods/Specs.git&quot;&gt;https://github.com/CocoaPods/Specs.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;报错用这个&lt;/p&gt;
&lt;p&gt;pod setup&lt;/p&gt;

&lt;p&gt;5.安装过程中出现报错&lt;/p&gt;
&lt;p&gt;报错类型1:&lt;/p&gt;
&lt;p&gt;[!] /usr/bin/git clone https://github.com/CocoaPods/Specs.git master --progress&lt;/p&gt;

&lt;p&gt;Cloning into 'master'...&lt;/p&gt;
&lt;p&gt;fatal: unable to access 'https://github.com/CocoaPods/Specs.git/': Could not resolve host: github.com&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原因可能是：&lt;/strong&gt;github.com没有被主机给解析&lt;/p&gt;
&lt;p&gt;解决方法：在本地手动指定&lt;a href=&quot;http://github.com&quot;&gt;github.com&lt;/a&gt;的IP地址&lt;/p&gt;

&lt;p&gt;编辑文件etc/hosts&lt;/p&gt;
&lt;p&gt;sudo vi /etc/hosts&lt;/p&gt;

&lt;p&gt;添加github的地址&lt;/p&gt;
&lt;p&gt;::1             localhost&lt;/p&gt;
&lt;p&gt;192.30.255.112  github.com&lt;/p&gt;


&lt;p&gt;报错类型2:&lt;/p&gt;
&lt;p&gt;[!] /usr/bin/git clone 'https://github.com/CocoaPods/Specs.git' master --depth=1&lt;/p&gt;

&lt;p&gt;Cloning into 'master'...&lt;/p&gt;

&lt;p&gt;fatal: unable to access 'https://github.com/CocoaPods/Specs.git/': Could not resolve host: &lt;a href=&quot;http://github.com&quot;&gt;github.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原因可能是：安装多个&lt;/strong&gt;&lt;strong&gt;Xcdoe&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;strong&gt;xcode&lt;/strong&gt;&lt;strong&gt;路径问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方法：sudo xcode-select -switch /Applications/Xcode.app/&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在终端里输入下方命令可以知道&lt;/strong&gt;&lt;strong&gt;Xcode&lt;/strong&gt;&lt;strong&gt;的路径：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;xcode-select -p&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 15:21:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/7795811.html</dc:identifier>
</item>
<item>
<title>【经验分享(续篇)】Trachtenberg system(特拉亨伯格速算系统) - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/7795753.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/7795753.html</guid>
<description>&lt;p&gt;&lt;span&gt;之前有篇文章简单地介绍了Trachtenberg系统的乘法计算方法，地址在&lt;a href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7411297.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。针对一些特定的数字，Trachtenberg还发展出了更快的计算方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来介绍乘数为11的速算方法。它的计算规则我们可称之为“邻居法则”：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从右至左，把每一位数和其右侧相邻位置的数字相加，取其个位。若所得值大于9，则将其十位则带到下一位计算（这个进位最多也只有1）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以以后碰到和11相乘，直接写结果就成了，举个栗子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如633 x 11:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1位：右侧没数字，所以直接记作3；这里衍生出一条规则，所求值的第1位等于被乘数的第1位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/===lw_pic_up_sina===1476084307.3164&quot;&gt;&lt;span&gt;&lt;img title=&quot;1&quot; src=&quot;http://s4.sinaimg.cn/middle/001K43yhzy75vEliXMDb3&amp;amp;amp;690&quot; alt=&quot;1&quot; width=&quot;308&quot; height=&quot;116&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2位：3 + 3 = 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75vEllxE622&amp;amp;bid=5f2d67f90102wwti&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0000&quot; src=&quot;http://s3.sinaimg.cn/middle/001K43yhzy75vEllxE622&amp;amp;amp;690&quot; alt=&quot;SNAG-0000&quot; width=&quot;280&quot; height=&quot;121&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位： 6 + 3 = 9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75vElofyI74&amp;amp;bid=5f2d67f90102wwti&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0001&quot; src=&quot;http://static5.photo.sina.com.cn/middle/001K43yhzy75vElofyI74&amp;amp;amp;690&quot; alt=&quot;SNAG-0001&quot; width=&quot;290&quot; height=&quot;128&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4位：左侧没数字了，计作0，so，0 + 6 = 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75vElr4qj27&amp;amp;bid=5f2d67f90102wwti&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0002&quot; src=&quot;http://static8.photo.sina.com.cn/middle/001K43yhzy75vElr4qj27&amp;amp;amp;690&quot; alt=&quot;SNAG-0002&quot; width=&quot;311&quot; height=&quot;112&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;计算的时候，也可以习惯性的也在被乘数前加个0，这个看起来更顺眼：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75vEltN7j31&amp;amp;bid=5f2d67f90102wwti&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0003&quot; src=&quot;http://static2.photo.sina.com.cn/middle/001K43yhzy75vEltN7j31&amp;amp;amp;690&quot; alt=&quot;SNAG-0003&quot; width=&quot;395&quot; height=&quot;126&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面这个例子相邻两数的和没有超过9的，所以我决定再来个栗子，计算1754 x 11。当相邻两数的和大于9时，我们在写结果的时候，可以顺手在前面用一个小点标记一下，如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75vElwKD3bd&amp;amp;bid=5f2d67f90102wwti&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0004&quot; src=&quot;http://s14.sinaimg.cn/middle/001K43yhzy75vElwKD3bd&amp;amp;amp;690&quot; alt=&quot;SNAG-0004&quot; width=&quot;577&quot; height=&quot;113&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位：7 + 5 = 12，这里的记作“.2”（相当于12）， 所以要第4位就是：1 + 7 + 1 = 9。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么样？够简单吧？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;12的乘法规则和11一样简单：&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;把被乘数的每一位乘2后再加上右邻那位的值，取其个位。若所得值大于9，则将其十位则带到下一位计算。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;直接来看栗子：413 x 12&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第1位（右起，下同）：3 x 2 + 0 = 6. 3的右侧没数值，直接乘2即可。为方便计算，我们在被乘数的前面补个零，这样对于初学者来说，最后一位的计算不至于被轻易忽略。老手的话，直接脑补即可，以后对于前面补0的操作，不再做专门的说明。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqozzbb1&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0006&quot; src=&quot;http://s2.sinaimg.cn/middle/001K43yhzy75wSqozzbb1&amp;amp;amp;690&quot; alt=&quot;SNAG-0006&quot; width=&quot;451&quot; height=&quot;134&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第2位：1 x 2 + 3 = 5&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqrU8S8e&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0007&quot; src=&quot;http://static15.photo.sina.com.cn/middle/001K43yhzy75wSqrU8S8e&amp;amp;amp;690&quot; alt=&quot;SNAG-0007&quot; width=&quot;375&quot; height=&quot;95&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第3位：4 x 2 + 1 = 9&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqu9p9ab&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0008&quot; src=&quot;http://s12.sinaimg.cn/middle/001K43yhzy75wSqu9p9ab&amp;amp;amp;690&quot; alt=&quot;SNAG-0008&quot; width=&quot;365&quot; height=&quot;82&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第4位：0 x 2 + 4 = 4&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqxcVk6a&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0009&quot; src=&quot;http://static11.photo.sina.com.cn/middle/001K43yhzy75wSqxcVk6a&amp;amp;amp;690&quot; alt=&quot;SNAG-0009&quot; width=&quot;427&quot; height=&quot;85&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;怎么样？还是看到数字直接写结果，比传统的计算简单多了吧？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;照例要解决“乘2加邻居”后带来的进位问题。由于这项操作最大值只有27（9 x 2 + 9），所以进位最大是2。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;再来个栗子：63247 x 12&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第1位：7 x 2 + 0 = 14，留下4，将1进位。还记得我们上一节讲过的前面标个小点来表示有进位的做法么？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqGbrBeb&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0010&quot; src=&quot;http://s12.sinaimg.cn/middle/001K43yhzy75wSqGbrBeb&amp;amp;amp;690&quot; alt=&quot;SNAG-0010&quot; width=&quot;397&quot; height=&quot;88&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第2位：4 x 2 + 7 = 15 + 1 = 16。留6，将1进位。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqIRtof2&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0011&quot; src=&quot;http://static3.photo.sina.com.cn/middle/001K43yhzy75wSqIRtof2&amp;amp;amp;690&quot; alt=&quot;SNAG-0011&quot; width=&quot;514&quot; height=&quot;99&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第3位：2 x 2 + 4 = 8 + 1 = 9&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqLXhq0c&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0012&quot; src=&quot;http://static13.photo.sina.com.cn/middle/001K43yhzy75wSqLXhq0c&amp;amp;amp;690&quot; alt=&quot;SNAG-0012&quot; width=&quot;439&quot; height=&quot;86&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第4位：3 x 2 + 2 = 8&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第5位：6 x 2 + 3 = 15。留5，将1进位。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第6位：0 x 2 + 6 = 6 + 1 = 7。注意此时所得的值如果大于9，则直接将进位写到下1位。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75wSqO9u43c&amp;amp;bid=5f2d67f90102wwup&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0013&quot; src=&quot;http://s13.sinaimg.cn/middle/001K43yhzy75wSqO9u43c&amp;amp;amp;690&quot; alt=&quot;SNAG-0013&quot; width=&quot;289&quot; height=&quot;78&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们讲5、6、7这三个数的乘法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你有这本书，请翻到第28页。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来讲6。擦，为什么要先讲6？请往下看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6的乘法规则有两条，先讲第一条：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;把被乘数的每一位加上右侧邻位的一半，保留个位，若所得值大于9，则将其十位则带到下一位计算。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这个“右侧邻位的一半”的取半操作，准确的说法是“取半求整”，就是碰到1、3、5、7、9这些奇数的时候，取其一半的整数部分。比如5的一半是2.5，我们只取2，其它依此类推。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上栗子吧：计算 622084 x 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1位：4 + 0 / 2 = 4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xEZXeqk50&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0014&quot; src=&quot;http://static1.photo.sina.com.cn/middle/001K43yhzy75xEZXeqk50&amp;amp;amp;690&quot; alt=&quot;SNAG-0014&quot; width=&quot;275&quot; height=&quot;94&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2位：8 + 4 / 2 = 10, 取0，将1进位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF00NbE36&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0015&quot; src=&quot;http://s7.sinaimg.cn/middle/001K43yhzy75xF00NbE36&amp;amp;amp;690&quot; alt=&quot;SNAG-0015&quot; width=&quot;272&quot; height=&quot;87&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位：0 + 1  + 8 / 2 = 5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0qsRh27&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0016&quot; src=&quot;http://static8.photo.sina.com.cn/middle/001K43yhzy75xF0qsRh27&amp;amp;amp;690&quot; alt=&quot;SNAG-0016&quot; width=&quot;262&quot; height=&quot;77&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4位：2 + 0 / 2 = 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第5位：2 + 2 / 2 = 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第6位：6 + 2 / 2 = 7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第7位：0 + 6 / 2 = 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0toCc58&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0017&quot; src=&quot;http://s9.sinaimg.cn/middle/001K43yhzy75xF0toCc58&amp;amp;amp;690&quot; alt=&quot;SNAG-0017&quot; width=&quot;268&quot; height=&quot;84&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而，这并不是乘6的全部规则，完整的规则是：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;把被乘数的每一位加上右侧邻位的一半，如果这个数是奇数，那要先加5. 所得值保留个位。若所得值大于9，则将其十位则带到下一位计算。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;直接上栗子：计算 443052 x 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1位：右侧没数字了，所以直接得2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0uVU82c&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0024&quot; src=&quot;http://s13.sinaimg.cn/middle/001K43yhzy75xF0uVU82c&amp;amp;amp;690&quot; alt=&quot;SNAG-0024&quot; width=&quot;868&quot; height=&quot;203&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2位：注意这一位是5，要先加5，再加右侧的一半，5 + 5 + 2 / 2 = 11, 保留1， 将十位上的1进位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0yfqP4b&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0018&quot; src=&quot;http://static12.photo.sina.com.cn/middle/001K43yhzy75xF0yfqP4b&amp;amp;amp;690&quot; alt=&quot;SNAG-0018&quot; width=&quot;890&quot; height=&quot;223&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位：0  + 1 + 5 / 2 = 3。注意5 / 2的取半求整操作。另外，对有进位的情况，建议养成先加进位的习惯，如在本例中看到0，心里直接说“1”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0QCfv59&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0019&quot; src=&quot;http://static10.photo.sina.com.cn/middle/001K43yhzy75xF0QCfv59&amp;amp;amp;690&quot; alt=&quot;SNAG-0019&quot; width=&quot;911&quot; height=&quot;249&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4位：3是奇数，所以要先加5：3 + 5 + 0  / 2 = 8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF0TOEg70&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0025&quot; src=&quot;http://static1.photo.sina.com.cn/middle/001K43yhzy75xF0TOEg70&amp;amp;amp;690&quot; alt=&quot;SNAG-0025&quot; width=&quot;815&quot; height=&quot;171&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第5位：4 + 3 / 2 = 5. 注意，在练习时要养成一个良好的习惯，不要去想“3的一半是1，4加1等于5”，做取半操作应该直接报出结果。比较理想的状况是心里想“4，5”，在刚开始练习的阶段，也可以想“4，1，5”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF17Fp630&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0021&quot; src=&quot;http://s1.sinaimg.cn/middle/001K43yhzy75xF17Fp630&amp;amp;amp;690&quot; alt=&quot;SNAG-0021&quot; width=&quot;785&quot; height=&quot;166&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第6位：4 + 4 / 2 = 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1dm7H7d&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0022&quot; src=&quot;http://static14.photo.sina.com.cn/middle/001K43yhzy75xF1dm7H7d&amp;amp;amp;690&quot; alt=&quot;SNAG-0022&quot; width=&quot;747&quot; height=&quot;178&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第7位：0  + 4 / 2 = 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1goMk44&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0023&quot; src=&quot;http://static5.photo.sina.com.cn/middle/001K43yhzy75xF1goMk44&amp;amp;amp;690&quot; alt=&quot;SNAG-0023&quot; width=&quot;788&quot; height=&quot;150&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看到这里，或许有童鞋会问，这和传统算法比，好像没什么优势啊？而且貌似更复杂了？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看起来是这个样子！传统算法中，是用乘法口诀将两数相乘，再处理进位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但我认为，Trachtenberg算法最大的优势是进位简单，因为最大只有一。而且相对而言，将乘法转化成了加法，亦更为简单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时，有吃瓜群众指出，你这特么滴还有除法，敢说简单？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;亲，取半的操作辣么简单，难道你也怕？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面请翻到35页，我们开始学习7的乘法规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7的乘法规则和6很相似：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;把被乘数乘2后加上右侧邻位的一半，如果这个数是奇数，那要在乘2后加5。所得值保留个位。若所得值大于9，则将其十位则带到下一位计算。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;我们来看栗子：计算3412 x 7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1位：右侧没数据，所以直接乘2，得4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1jFQI80&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0026&quot; src=&quot;http://static1.photo.sina.com.cn/middle/001K43yhzy75xF1jFQI80&amp;amp;amp;690&quot; alt=&quot;SNAG-0026&quot; width=&quot;864&quot; height=&quot;174&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2位：1是奇数，所以先乘2再加5，1 x 2 + 5 + 2 / 1 = 8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1H3uOda&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0027&quot; src=&quot;http://static11.photo.sina.com.cn/middle/001K43yhzy75xF1H3uOda&amp;amp;amp;690&quot; alt=&quot;SNAG-0027&quot; width=&quot;859&quot; height=&quot;201&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位：注意1取半求整后是0，4 x 2 + 1 / 2 = 8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1Kfhtb7&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0028&quot; src=&quot;http://static8.photo.sina.com.cn/middle/001K43yhzy75xF1Kfhtb7&amp;amp;amp;690&quot; alt=&quot;SNAG-0028&quot; width=&quot;872&quot; height=&quot;200&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4位：3 x 2 + 5 + 4 / 2 = 13. 留3，将1进位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1MWYib2&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0029&quot; src=&quot;http://static3.photo.sina.com.cn/middle/001K43yhzy75xF1MWYib2&amp;amp;amp;690&quot; alt=&quot;SNAG-0029&quot; width=&quot;412&quot; height=&quot;169&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第5位： 0 x 2 + 1 + 3 / 2 = 2，养成先加进位的习惯&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1Sa0I54&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;SNAG-0030&quot; src=&quot;http://static5.photo.sina.com.cn/middle/001K43yhzy75xF1Sa0I54&amp;amp;amp;690&quot; alt=&quot;SNAG-0030&quot; width=&quot;854&quot; height=&quot;197&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后我们来讲5的乘法规则。它有点像6和7规则的杂交版，但更简单：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;取被乘数的每一位右侧邻位的一半，如果当前位是奇数，则再加5&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这回连进位都不需要考虑，因为把最大的数9取半求整后是4，即使要再加5，也只能是9。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们照例用一个栗子来理解这条规则：计算436 x 5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1位：6是偶数，而其右侧没有数字，所以写作0.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF1ZDQK2a&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0031&quot; src=&quot;http://static11.photo.sina.com.cn/middle/001K43yhzy75xF1ZDQK2a&amp;amp;amp;690&quot; alt=&quot;SNAG-0031&quot; width=&quot;462&quot; height=&quot;150&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2位：3是奇数，5 + 6 / 2 = 8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF204nm78&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0032&quot; src=&quot;http://static9.photo.sina.com.cn/middle/001K43yhzy75xF204nm78&amp;amp;amp;690&quot; alt=&quot;SNAG-0032&quot; width=&quot;726&quot; height=&quot;162&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3位：4是偶数，所以只取 3 / 1, 得1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4位：0是偶数，所以只取 4 / 2, 得2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/list/blogpic.php?pid=001K43yhzy75xF24SUX43&amp;amp;bid=5f2d67f90102www3&amp;amp;uid=1596811257&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;img title=&quot;SNAG-0033&quot; src=&quot;http://static4.photo.sina.com.cn/middle/001K43yhzy75xF24SUX43&amp;amp;amp;690&quot; alt=&quot;SNAG-0033&quot; width=&quot;343&quot; height=&quot;117&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结一下就是，在5的乘法中，被乘数的每一位数只是用来判断是不是要加5，并不参与运算。&lt;/span&gt; 所以算起来要简单多了。&lt;/p&gt;

</description>
<pubDate>Mon, 06 Nov 2017 15:06:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/7795753.html</dc:identifier>
</item>
<item>
<title>深入理解JavaScript中的继承：原型链篇 - envision</title>
<link>http://www.cnblogs.com/envision/p/JavaScript.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/envision/p/JavaScript.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;span&gt;原型是一个对象，当我调用一个对象的方法时，如果该方法没有在对象里面，就会从对象的原型去寻找。JavaScript就是通过层层的原型，形成原型链。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　任何对象都可以有原型，当我们创建对象的时候，会自动为对象添加一个属性，这个属性就是原型，我们无法访问到他，但在firefox和chrome中可以通过一个非标准的属性__proto__（双下划线）来访问到原型（或通过Object.getPrototypeOf来访问）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　我们先从以下代码入手&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;　　var&lt;/span&gt; foo =&lt;span&gt; {};
　　&lt;/span&gt;console.log(foo.toString()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [object Object]　　&lt;br/&gt;&lt;span&gt;　　console.log(foo.__proto__); &lt;span&gt;// object { ... }  这里指向Object.prototype&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　foo里面明明没有toString方法，但我却能调用，这就是原型链的作用。当我调用foo.toString时，由于在里面找不到toString方法，那么我从__proto__属性里面去找，找到后并调用。上面的代码中我们就是从Object.prototype中找到了toString方法。你可能会很困惑，prototype是什么？我们不要被prototype所迷惑，他只是一个存放属性的容器而已，你可以如下这样做来实现继承（但尽量不要这么做）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Bar() {}
Bar.test &lt;/span&gt;=&lt;span&gt; {
  say: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
       console.log(&lt;/span&gt;'say test'&lt;span&gt;);     
    }  
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar();
foo.say(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变继承的对象&lt;/span&gt;
&lt;span&gt;
foo.__proto__ &lt;/span&gt;=&lt;span&gt; Bar.test;
foo.say() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; say test&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;　　&lt;span&gt;在上面的代码中我们通过new的形式来创建一个对象，在new的过程中对象会将__proto__指向函数的prototype，由于prototype中是没有say函数的，所以调用会报错，但是之后我们强行改变了继承的对象，将foo的继承对象改为Bar.test，所以我们就能调用say函数了。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　我想你已经明白个大概了，prototype事实上并没有什么特殊的，硬要说有什么特殊的话，他只是被JavaScript默认为原型属性的存放点而已，他本质上只是个对象，原型链的重点就在于__proto__，你可以试着把__proto__当作桥梁，当我在对象内部找不到属性时，我就会通过这座桥梁到对面的对象里去寻找属性，直到找到为止或者对象里没有桥梁时才停下来。JavaScript就是通过这样的方式来形成原型链，实现继承的关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后说一下，__proto__只是方便我们查看对象的原型而已，大家不要通过修改__proto__来实现继承的关系，而是要用如构造函数之类的方式来实现继承，这个我会放到以后的文章去说。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（ps:&lt;span&gt;可能有动手能力强的同学会自己去测试，发现__proto__里面也有__proto__，一直循环下去，无穷无尽，但事实上你去获取的时候你会发现Object.__proto__.__proto__.__proto__的值是null，也就是没有原型。&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 06 Nov 2017 14:23:00 +0000</pubDate>
<dc:creator>envision</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/envision/p/JavaScript.html</dc:identifier>
</item>
<item>
<title>动态类型序列化 - Skyven</title>
<link>http://www.cnblogs.com/Skyven/p/7795535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Skyven/p/7795535.html</guid>
<description>&lt;p&gt;上一篇文章直接就被移除首页了，这次来点大家都能懂的干货.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;之前做一个winform的工具时候有以下几个需求&lt;br/&gt;1. 主窗体(或者叫平台)可以安装若干类型的插件。&lt;br/&gt;2. 插件关闭时候需要保存状态。&lt;br/&gt;3. 插件加载的时候可以加载上次关闭的配置。&lt;br/&gt;4. 插件中的配置可以切换。&lt;br/&gt;5. 主窗体本身保存当前插件，并且可以通过不同的配置文件切换插件&lt;/p&gt;
&lt;p&gt;使用上最方便的做法是将配置给平台来管理。但是平台本身并不知道插件要保存怎样的配置。针对以上问题在配置这个上做了如下设计&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. 动态类型序列化以满足插件的任何配置需要&lt;br/&gt;2. 动态类型基本的就是dynamic,那么我们需用字典作为实现&lt;br/&gt;3. 支持具体的类进行序列化，那么此时需要用xml保存类的元数据信息&lt;br/&gt;4. 支持接口的序列化，此时也是保存实际类型的元数据信息&lt;br/&gt;5. 支持List序列化&lt;br/&gt;6. 支持Arry序列化&lt;br/&gt;7. 支持Dictionary序列化&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接口定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;其中PathOrSourceString 属性这样既可以支持文件，也可以直接支持字符串，扩展更加方便.&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
public interface IConfig
    {
        string PathOrSourceString { get; set; }

        dynamic Data { get; set; }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;动态类型实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;这里是基于字典，网上有很多类似的代码。&lt;/p&gt;
&lt;p&gt;这里字典的Value设计成dynamic是为了嵌套。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
    [Serializable]
    public class DynamicDictionary : DynamicObject
    {
        private Dictionary&amp;lt;string, dynamic&amp;gt; _dictionary = new Dictionary&amp;lt;string, dynamic&amp;gt;();

        public override bool TryGetMember(GetMemberBinder binder, out object result)
        {
            string name = binder.Name;
            if (!_dictionary.ContainsKey(name))
            {
                _dictionary.Add(name, new DynamicDictionary());
            }
            return _dictionary.TryGetValue(name, out result);
        }

        public override bool TrySetMember(SetMemberBinder binder, object value)
        {
            var key = binder.Name;
            if (_dictionary.ContainsKey(key))
                _dictionary[key] = value;
            else
            {
                _dictionary.Add(key, value);
            }


            return true;
        }

        public Dictionary&amp;lt;string, dynamic&amp;gt; Dictionary
        {
            get { return _dictionary; }
        }

        public void AddMember(string name, dynamic value)
        {
            _dictionary.Add(name, value);
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;配置的加载和保存逻辑(核心)&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;138&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
    public static class ConfigManager
    {
        public static IConfig LoadFromFile(this IConfig config)
        {
            if (config == null || string.IsNullOrEmpty(config.PathOrSourceString))
                throw new ArgumentNullException(&quot;config&quot;);
            if (!File.Exists(config.PathOrSourceString))
            {
                return config;
            }
            var doc = new XmlDocument();
            doc.Load(config.PathOrSourceString);
            var element = doc[&quot;Data&quot;];
            config.Data = GetValue(element);
            return config;
        }

        public static IConfig SaveToFile(this IConfig config)
        {
            if (config == null || string.IsNullOrEmpty(config.PathOrSourceString) || config.Data == null)
                throw new ArgumentNullException(&quot;config&quot;);
            var dir = Path.GetDirectoryName(config.PathOrSourceString);
            if (!Directory.Exists(dir))
                Directory.CreateDirectory(dir);
            var doc = new XmlDocument();
            doc.AppendChild(GetXml(&quot;Data&quot;, config.Data, doc));
            doc.Save(config.PathOrSourceString);
            return config;
        }

        public static IConfig LoadFromString(this IConfig config)
        {
            if (config == null || string.IsNullOrEmpty(config.PathOrSourceString))
                throw new ArgumentNullException(&quot;config&quot;);
            var doc = new XmlDocument();
            doc.LoadXml(config.PathOrSourceString);
            var element = doc[&quot;Data&quot;];
            config.Data = GetValue(element);
            return config;
        }

        public static IConfig SaveToString(this IConfig config)
        {
            if (config == null || config.Data == null)
                throw new ArgumentNullException(&quot;config&quot;);
            var doc = new XmlDocument();
            doc.AppendChild(GetXml(&quot;Data&quot;, config.Data, doc));
            config.PathOrSourceString = doc.OuterXml;
            return config;
        }

        #region 解析XmlElement

        public static dynamic GetValue(XmlElement element)
        {
            if (element == null)
                return null;

            Classify clasify;
            Enum.TryParse(element.GetAttribute(&quot;Classify&quot;), out clasify);
            switch (clasify)
            {
                case Classify.Sample:
                    return GetSampleValue(element.GetAttribute(&quot;Assembly&quot;), element.GetAttribute(&quot;Type&quot;), element.InnerText);
                case Classify.Array:
                    return GetArrayValue(element.GetAttribute(&quot;ElementAssembly&quot;), element.GetAttribute(&quot;ElementType&quot;), element.GetChidlren());
                case Classify.List:
                    return GetListValue(element.GetAttribute(&quot;GenericAssembly&quot;), element.GetAttribute(&quot;GenericType&quot;), element.GetChidlren());
                case Classify.Dictionary:
                    return GetDictionaryValue(element.GetAttribute(&quot;KeyGenericAssembly&quot;),
                        element.GetAttribute(&quot;KeyGenericType&quot;),
                        element.GetAttribute(&quot;ValueGenericAssembly&quot;),
                        element.GetAttribute(&quot;ValueGenericType&quot;),
                        element.GetChidlren());
                case Classify.Dynamic:
                    return GetDynamicValue(element.GetChidlren());
                case Classify.Custom:
                    return GetCustomValue(element.GetAttribute(&quot;Assembly&quot;), element.GetAttribute(&quot;Type&quot;), element.GetChidlren());
            }

            return null;
        }
        public static object GetSampleValue(string assembly, string typeFullName, string value)
        {
            var type = Assembly.Load(assembly).GetType(typeFullName);
            if (type == null)
                return null;
            return CoralConvert.Convert(value, type);
        }
        public static object GetListValue(string genericAssembly, string genericTypeName, List&amp;lt;XmlElement&amp;gt; elements)
        {
            var genericType = Assembly.Load(genericAssembly).GetType(genericTypeName);
            var type = typeof(List&amp;lt;&amp;gt;).MakeGenericType(genericType);
            dynamic list = Activator.CreateInstance(type, true);

            foreach (var element in elements)
            {
                list.Add(GetValue(element));
            }
            return list;
        }
        public static object GetArrayValue(string elementAssembly, string elementTypeName, List&amp;lt;XmlElement&amp;gt; elements)
        {
            var elementType = Assembly.Load(elementAssembly).GetType(elementTypeName);
            dynamic list = Array.CreateInstance(elementType, elements.Count);
            for (int i = 0; i &amp;lt; elements.Count; i++)
            {
                list[i] = GetValue(elements[i]);
            }
            return list;
        }
        public static object GetDictionaryValue(string keyAssembly, string keyTypeName, string valueAssembly, string valueTypeName, List&amp;lt;XmlElement&amp;gt; elements)
        {
            var keyType = Assembly.Load(keyAssembly).GetType(keyTypeName);
            var valueType = Assembly.Load(valueAssembly).GetType(valueTypeName);
            var type = typeof(Dictionary&amp;lt;,&amp;gt;).MakeGenericType(keyType, valueType);
            dynamic dict = Activator.CreateInstance(type, true);
            foreach (var element in elements)
            {
                dict.Add(GetValue(element[&quot;Key&quot;]), GetValue(element[&quot;Value&quot;]));
            }
            return dict;
        }
        public static object GetDynamicValue(List&amp;lt;XmlElement&amp;gt; elements)
        {
            var dict = new DynamicDictionary();
            foreach (var element in elements)
            {
                dict.Dictionary.Add(GetValue(element[&quot;Key&quot;]), GetValue(element[&quot;Value&quot;]));
            }
            return dict;
        }
        public static object GetCustomValue(string assemblyFullName, string typeFullName, List&amp;lt;XmlElement&amp;gt; elements)
        {
            var type = Assembly.Load(assemblyFullName).GetType(typeFullName);
            if (type == null)
                return null;
            dynamic obj = Activator.CreateInstance(type, true);

            foreach (var element in elements)
            {
                var property = type.GetProperty(element.Name);
                object value;
                if (!CoralConvert.Convert(GetValue(element), property.PropertyType, out value))
                    continue;
                property.SetValue(obj, value);
            }

            return obj;
        }
        #endregion

        #region 创建XmlElement

        /// &amp;lt;summary&amp;gt;
        /// 创建xml元素
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;doc&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static XmlElement GetXml(string name, object data, XmlDocument doc)
        {
            if (data == null)
                return null;
            if (data.GetType().IsValueType || data is string)
            {
                return GetValueTypeXml(name, data, doc);
            }
            var list = data as IList;
            if (list != null)
            {
                return GetIListXml(name, list, doc);
            }
            var dict = data as IDictionary;
            if (dict != null)
            {
                return GetIDictionaryXml(name, dict, doc);
            }
            var dynamic = data as DynamicDictionary;
            if (dynamic != null)
            {
                return GetDynamicXml(name, dynamic, doc);
            }
            return GetCustomXml(name, data, doc);
        }

        /// &amp;lt;summary&amp;gt;
        /// 创建简单类型的xml元素
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;doc&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        private static XmlElement GetValueTypeXml(string name, object data, XmlDocument doc)
        {
            if (data == null)
                return null;
            var element = doc.CreateElement(name);
            element.SetAttribute(&quot;Type&quot;, data.GetType().FullName);
            element.SetAttribute(&quot;Assembly&quot;, MetaDataManager.Assembly.GetAssemblySortName(data.GetType().Assembly));
            element.SetAttribute(&quot;Classify&quot;, Classify.Sample.ToString());
            element.InnerText = data.ToString();
            return element;
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取列表类型的xml
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;datas&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;doc&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        private static XmlElement GetIListXml(string name, object datas, XmlDocument doc)
        {
            if (datas == null)
                return null;
            var element = doc.CreateElement(name);
            if (datas.GetType().IsArray)
            {
                element.SetAttribute(&quot;Type&quot;, typeof(Array).FullName);
                element.SetAttribute(&quot;Classify&quot;, Classify.Array.ToString());
                element.SetAttribute(&quot;ElementType&quot;, datas.GetType().GetElementType().FullName);
                element.SetAttribute(&quot;ElementAssembly&quot;, datas.GetType().GetElementType().Assembly.FullName);
            }
            else
            {
                element.SetAttribute(&quot;Type&quot;, typeof(IList).FullName);
                element.SetAttribute(&quot;Classify&quot;, Classify.List.ToString());
                element.SetAttribute(&quot;GenericType&quot;, datas.GetType().GenericTypeArguments[0].FullName);
                element.SetAttribute(&quot;GenericAssembly&quot;, datas.GetType().GenericTypeArguments[0].Assembly.FullName);
            }
            foreach (var data in (IList)datas)
            {
                element.AppendChild(GetXml(&quot;Element&quot;, data, doc));
            }
            return element;
        }

        /// &amp;lt;summary&amp;gt;
        /// 创建动态类型的xml
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;doc&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        private static XmlElement GetDynamicXml(string name, dynamic data, XmlDocument doc)
        {
            if (data == null)
                return null;
            var element = doc.CreateElement(name);
            element.SetAttribute(&quot;Type&quot;, &quot;dynamic&quot;);
            element.SetAttribute(&quot;Classify&quot;, Classify.Dynamic.ToString());
            foreach (DictionaryEntry item in (IDictionary)data.Dictionary)
            {
                var child = doc.CreateElement(&quot;Element&quot;);
                child.AppendChild(GetXml(&quot;Key&quot;, item.Key ?? string.Empty, doc));
                child.AppendChild(GetXml(&quot;Value&quot;, item.Value ?? string.Empty, doc));
                element.AppendChild(child);
            }
            return element;
        }

        /// &amp;lt;summary&amp;gt;
        /// 创建字典类型的xml
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;datas&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;doc&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        private static XmlElement GetIDictionaryXml(string name, object datas, XmlDocument doc)
        {
            if (datas == null)
                return null;
            var element = doc.CreateElement(name);
            element.SetAttribute(&quot;Type&quot;, typeof(IDictionary).FullName);
            element.SetAttribute(&quot;Classify&quot;, Classify.Dictionary.ToString());
            element.SetAttribute(&quot;KeyGenericAssembly&quot;, datas.GetType().GetGenericArguments()[0].Assembly.FullName);
            element.SetAttribute(&quot;KeyGenericType&quot;, datas.GetType().GetGenericArguments()[0].FullName);
            element.SetAttribute(&quot;ValueGenericAssembly&quot;, datas.GetType().GetGenericArguments()[1].Assembly.FullName);
            element.SetAttribute(&quot;ValueGenericType&quot;, datas.GetType().GetGenericArguments()[1].FullName);
            foreach (DictionaryEntry data in (IDictionary)datas)
            {
                var child = doc.CreateElement(&quot;Element&quot;);
                child.AppendChild(GetXml(&quot;Key&quot;, data.Key ?? string.Empty, doc));
                child.AppendChild(GetXml(&quot;Value&quot;, data.Value ?? string.Empty, doc));
                element.AppendChild(child);
            }
            return element;
        }

        /// &amp;lt;summary&amp;gt;
        /// 创建自定义类
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;doc&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        private static XmlElement GetCustomXml(string name, object data, XmlDocument doc)
        {
            if (data == null)
                return null;
            var element = doc.CreateElement(name);
            element.SetAttribute(&quot;Assembly&quot;,MetaDataManager.Assembly.GetAssemblySortName(data.GetType().Assembly));
            element.SetAttribute(&quot;Type&quot;, data.GetType().FullName);
            element.SetAttribute(&quot;Classify&quot;, Classify.Custom.ToString());
            data.GetType().GetProperties().ForEach(property =&amp;gt;
            {
                var item = GetXml(property.Name, property.GetValue(data), doc);
                if (item != null)
                    element.AppendChild(item);
            });
            return element;
        }

        #endregion

        public enum Classify
        {
            Sample,
            List,
            Array,
            Dictionary,
            Dynamic,
            Custom,
        }
        public static List&amp;lt;XmlElement&amp;gt; GetChidlren(this XmlElement element)
        {
            return element.Cast&amp;lt;XmlElement&amp;gt;().ToList();
        }
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;核心思路就是递归，充分利用元数据&lt;/p&gt;

&lt;p&gt;&lt;span&gt;测试代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;90&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public class XmlConfig : IConfig
    {
        public string PathOrSourceString { get; set; }
        public dynamic Data { get; set; }
    }

    public interface ITestModel
    {

        string Name { get; set; }

        string DataType { get; set; }

        string Data { get; set; }


    }

    public class TestConfig
    {
        public ITestModel Model { get; set; }

        public  List&amp;lt;ITestModel&amp;gt; List { get; set; }
        public Dictionary&amp;lt;string, ITestModel&amp;gt; Dict { get; set; }
    }



    public class TestModel: ITestModel
    {
        public string Name { get; set; }

        public string DataType { get; set; }

        public string Data { get; set; }

        public List&amp;lt;ITestModel&amp;gt; List { get; set; }
        public Dictionary&amp;lt;string, ITestModel&amp;gt; Dict { get; set; }
    }


    public class ConfigTest
    {
        public static void PerformanceTest()
        {
            var xmlconfig = new XmlConfig();

            xmlconfig.PathOrSourceString = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &quot;Configs&quot;, &quot;test1.Config&quot;);

            #region list 类，字典测试
            
            var testModel=   new TestModel()
            {
                Name = &quot;1&quot;,
                DataType = &quot;1&quot;,
                Data = &quot;1&quot;,
                List = new List&amp;lt;ITestModel&amp;gt;
                {
                    new TestModel
                    {
                        Name = &quot;2&quot;,
                        DataType = &quot;2&quot;,
                        Data = &quot;2&quot;,
                    },
                    new TestModel
                    {
                        Name = &quot;3&quot;,
                        DataType = &quot;3&quot;,
                        Data = &quot;3&quot;,
                    },
                },
                Dict = new Dictionary&amp;lt;string, ITestModel&amp;gt;
                {
                    {&quot;4&quot;, new TestModel
                            {
                                Name = &quot;4&quot;,
                                DataType = &quot;4&quot;,
                                Data = &quot;4&quot;,
                            }
                     },
                    {&quot;5&quot;, new TestModel
                            {
                                Name = &quot;5&quot;,
                                DataType = &quot;5&quot;,
                                Data = &quot;5&quot;,
                            }
                     },
                }
            };
            #endregion

            xmlconfig.Data = new TestConfig()
            {
                Model = testModel,
                Dict = new Dictionary&amp;lt;string, ITestModel&amp;gt;()
                {
                    {&quot;1&quot;,testModel },
                    {&quot;2&quot;,testModel }
                },
                List = new List&amp;lt;ITestModel&amp;gt; { testModel,testModel}
            };


            #region 动态类型，类，list，字典总和测试

            xmlconfig.Data = new DynamicDictionary();

            xmlconfig.Data.Name = &quot;Test1&quot;;
            xmlconfig.Data.DataType = &quot;Test1&quot;;

            xmlconfig.Data.List = new List&amp;lt;TestModel&amp;gt;
            {
                new TestModel
                {
                    Name = &quot;2&quot;,
                    DataType = &quot;2&quot;,
                    Data = &quot;2&quot;,
                },
                new TestModel
                {
                    Name = &quot;3&quot;,
                    DataType = &quot;3&quot;,
                    Data = &quot;3&quot;,
                },
            };
            xmlconfig.Data.Dict = new Dictionary&amp;lt;string, TestModel&amp;gt;
            {
                {
                    &quot;4&quot;, new TestModel
                    {
                        Name = &quot;4&quot;,
                        DataType = &quot;4&quot;,
                        Data = &quot;4&quot;,
                    }
                },
                {
                    &quot;5&quot;, new TestModel
                    {
                        Name = &quot;5&quot;,
                        DataType = &quot;5&quot;,
                        Data = &quot;5&quot;,
                    }
                },
            };
            xmlconfig.Data.Other.Name = &quot;Test1&quot;;
            xmlconfig.Data.Other.DataType = &quot;Test1&quot;;

            #endregion

            xmlconfig.SaveToFile();


            var data = new XmlConfig();

            data.PathOrSourceString = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &quot;Configs&quot;, &quot;test1.Config&quot;);
            data.LoadFromFile();
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　配置文件为&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;Data Type=&quot;dynamic&quot; Classify=&quot;Dynamic&quot;&amp;gt;
  &amp;lt;Element&amp;gt;
    &amp;lt;Key Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;Name&amp;lt;/Key&amp;gt;
    &amp;lt;Value Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;Test1&amp;lt;/Value&amp;gt;
  &amp;lt;/Element&amp;gt;
  &amp;lt;Element&amp;gt;
    &amp;lt;Key Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;DataType&amp;lt;/Key&amp;gt;
    &amp;lt;Value Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;Test1&amp;lt;/Value&amp;gt;
  &amp;lt;/Element&amp;gt;
  &amp;lt;Element&amp;gt;
    &amp;lt;Key Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;List&amp;lt;/Key&amp;gt;
    &amp;lt;Value Type=&quot;System.Collections.IList&quot; Classify=&quot;List&quot; GenericType=&quot;RunnerTest.Common.TestModel&quot; GenericAssembly=&quot;RunnerTest, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot;&amp;gt;
      &amp;lt;Element Assembly=&quot;RunnerTest&quot; Type=&quot;RunnerTest.Common.TestModel&quot; Classify=&quot;Custom&quot;&amp;gt;
        &amp;lt;Name Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;2&amp;lt;/Name&amp;gt;
        &amp;lt;DataType Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;2&amp;lt;/DataType&amp;gt;
        &amp;lt;Data Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;2&amp;lt;/Data&amp;gt;
      &amp;lt;/Element&amp;gt;
      &amp;lt;Element Assembly=&quot;RunnerTest&quot; Type=&quot;RunnerTest.Common.TestModel&quot; Classify=&quot;Custom&quot;&amp;gt;
        &amp;lt;Name Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;3&amp;lt;/Name&amp;gt;
        &amp;lt;DataType Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;3&amp;lt;/DataType&amp;gt;
        &amp;lt;Data Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;3&amp;lt;/Data&amp;gt;
      &amp;lt;/Element&amp;gt;
    &amp;lt;/Value&amp;gt;
  &amp;lt;/Element&amp;gt;
  &amp;lt;Element&amp;gt;
    &amp;lt;Key Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;Dict&amp;lt;/Key&amp;gt;
    &amp;lt;Value Type=&quot;System.Collections.IDictionary&quot; Classify=&quot;Dictionary&quot; KeyGenericAssembly=&quot;mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot; KeyGenericType=&quot;System.String&quot; ValueGenericAssembly=&quot;RunnerTest, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; ValueGenericType=&quot;RunnerTest.Common.TestModel&quot;&amp;gt;
      &amp;lt;Element&amp;gt;
        &amp;lt;Key Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;4&amp;lt;/Key&amp;gt;
        &amp;lt;Value Assembly=&quot;RunnerTest&quot; Type=&quot;RunnerTest.Common.TestModel&quot; Classify=&quot;Custom&quot;&amp;gt;
          &amp;lt;Name Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;4&amp;lt;/Name&amp;gt;
          &amp;lt;DataType Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;4&amp;lt;/DataType&amp;gt;
          &amp;lt;Data Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;4&amp;lt;/Data&amp;gt;
        &amp;lt;/Value&amp;gt;
      &amp;lt;/Element&amp;gt;
      &amp;lt;Element&amp;gt;
        &amp;lt;Key Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;5&amp;lt;/Key&amp;gt;
        &amp;lt;Value Assembly=&quot;RunnerTest&quot; Type=&quot;RunnerTest.Common.TestModel&quot; Classify=&quot;Custom&quot;&amp;gt;
          &amp;lt;Name Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;5&amp;lt;/Name&amp;gt;
          &amp;lt;DataType Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;5&amp;lt;/DataType&amp;gt;
          &amp;lt;Data Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;5&amp;lt;/Data&amp;gt;
        &amp;lt;/Value&amp;gt;
      &amp;lt;/Element&amp;gt;
    &amp;lt;/Value&amp;gt;
  &amp;lt;/Element&amp;gt;
  &amp;lt;Element&amp;gt;
    &amp;lt;Key Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;Other&amp;lt;/Key&amp;gt;
    &amp;lt;Value Type=&quot;dynamic&quot; Classify=&quot;Dynamic&quot;&amp;gt;
      &amp;lt;Element&amp;gt;
        &amp;lt;Key Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;Name&amp;lt;/Key&amp;gt;
        &amp;lt;Value Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;Test1&amp;lt;/Value&amp;gt;
      &amp;lt;/Element&amp;gt;
      &amp;lt;Element&amp;gt;
        &amp;lt;Key Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;DataType&amp;lt;/Key&amp;gt;
        &amp;lt;Value Type=&quot;System.String&quot; Assembly=&quot;mscorlib&quot; Classify=&quot;Sample&quot;&amp;gt;Test1&amp;lt;/Value&amp;gt;
      &amp;lt;/Element&amp;gt;
    &amp;lt;/Value&amp;gt;
  &amp;lt;/Element&amp;gt;
&amp;lt;/Data&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;最大的用处，你拿到一个对象未知的对象，并不需要知道他的实际类型，就可以进行持久化，并且读取出来之后能够还原到原始类型。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;实现这部分我觉得在于以下几个点&lt;/p&gt;
&lt;p&gt;1. 对元数据的充分理解&lt;br/&gt;2. 对xml结构的充分理解&lt;br/&gt;3. 需要一点写算法的能力&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;我觉得代码本身并不复杂，只要耐心单步调试都能看懂。&lt;/p&gt;
&lt;p&gt;当然这个是有一定限制的：&lt;/p&gt;
&lt;p&gt;1. 可读性不强,所以在需要从文件进行修改配置比较麻烦&lt;/p&gt;
&lt;p&gt;2.不可跨系统，文件中类型从程序集加载不到时就会出错&lt;/p&gt;
&lt;p&gt;3.性能不高.性能敏感的部分不太适合&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;所以这部分功能需要结合业务场景使用，在我这里，包含作业调度系统，统计系统,接口测试工具中有使用.&lt;/p&gt;
&lt;p&gt;这其实特别想WSDL的Soap协议，文件中既包含元数据的说明,又包含数据本身.真个元数据变成也是一个做设计时候一个重要思想。&lt;/p&gt;

</description>
<pubDate>Mon, 06 Nov 2017 14:18:00 +0000</pubDate>
<dc:creator>Skyven</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Skyven/p/7795535.html</dc:identifier>
</item>
<item>
<title>【Aladdin Unity3D Shader编程】之三 光照模型(二) - 蓬莱仙羽</title>
<link>http://www.cnblogs.com/dingxiaowei/p/7795507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dingxiaowei/p/7795507.html</guid>
<description>&lt;p&gt;Specular=直射光*pow(cosθ,高光的参数) θ:是反射光和视野方向的夹角&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/369366/201711/369366-20171106212144341-1283749403.png&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;Shader &quot;AladdinShader/07 Specular Vertex Shader&quot;
{
    Properties
    {
        _Diffuse(&quot;Diffuse&quot;,Color)=(1,1,1,1) //添加自身的颜色
    }
    SubShader {
        Pass 
        {
            Tags{&quot;LightMode&quot;=&quot;ForwardBase&quot;}

        CGPROGRAM
#include &quot;Lighting.cginc&quot; //引用一些写好的程序块 会包含一些获取光照的信息  
//_LightColor0 取得第一个直射光的颜色
//_WorldSpaceLightPos0 

#pragma vertex vert
#pragma fragment frag 
    
        fixed4 _Diffuse;

        struct a2v 
        {
            float4 vertex:POSITION;
            float3 normal:NORMAL; //模型空间下法线
        };

        struct v2f
        {
            float4 position:SV_POSITION;
            fixed3 color:COLOR;
        };
        v2f vert(a2v v)
        {
            v2f f;
            f.position = mul(UNITY_MATRIX_MVP, v.vertex);
            fixed3 adbient = UNITY_LIGHTMODEL_AMBIENT.rgb;
            fixed3 normalDir = normalize(mul(v.normal,(float3x3)unity_WorldToObject));
            fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//对于每个顶点来说 光的位置就是光的方向 因为是平行光
            fixed3 diffuse = _LightColor0.rgb * max(dot(normalDir,lightDir), 0) * _Diffuse.rgb;//取得漫反射的颜色
            
            //反射光方向
            fixed3 reflectDir = normalize(reflect(-lightDir,normalDir));
            //视野方向
            //相机是在世界空间下              
            fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(v.vertex,unity_WorldToObject).xyz);

            //高光反射
            fixed3 specular = _LightColor0.rgb * pow(max(dot(reflectDir,viewDir),0),10);
            f.color = diffuse + adbient + specular;
            return f;
        }

        fixed4 frag(v2f f):SV_Target
        {
            return fixed4(f.color, 1);
        }

        ENDCG
        }
    }
    FallBack  &quot;VertexLit&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/369366/201711/369366-20171106214756809-468211719.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;添加一个Range属性，将X次幂的值改成Range属性，做如下修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_Gloss(&quot;Gloss&quot;,Range(8,200)) = 10
//高光反射
fixed3 specular = _LightColor0.rgb * pow(max(dot(reflectDir,viewDir),0),_Gloss);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就会看到高光光圈随着_Gloss改变而改变&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/369366/201711/369366-20171106215644169-1632031633.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/369366/201711/369366-20171106215649153-1797210360.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想要改变高光部分的颜色控制，我们添加一个颜色变量然后将高光颜色与我们设置的颜色属性进行融合计算就会得到新的高光部分的颜色&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Shader &quot;AladdinShader/07 Specular Vertex Shader&quot;
{
    Properties
    {
        _Diffuse(&quot;Diffuse&quot;,Color)=(1,1,1,1) //添加自身的颜色
        _Specular(&quot;Specular&quot;,Color)=(1,1,1,1)
        _Gloss(&quot;Gloss&quot;,Range(8,200)) = 10
    }
    SubShader {
        Pass 
        {
            Tags{&quot;LightMode&quot;=&quot;ForwardBase&quot;}

        CGPROGRAM
#include &quot;Lighting.cginc&quot; //引用一些写好的程序块 会包含一些获取光照的信息  
//_LightColor0 取得第一个直射光的颜色
//_WorldSpaceLightPos0 

#pragma vertex vert
#pragma fragment frag 
    
        fixed4 _Diffuse;
        fixed4 _Specular;
        half _Gloss;

        struct a2v 
        {
            float4 vertex:POSITION;
            float3 normal:NORMAL; //模型空间下法线
        };

        struct v2f
        {
            float4 position:SV_POSITION;
            fixed3 color:COLOR;
        };
        v2f vert(a2v v)
        {
            v2f f;
            f.position = mul(UNITY_MATRIX_MVP, v.vertex);
            fixed3 adbient = UNITY_LIGHTMODEL_AMBIENT.rgb;
            fixed3 normalDir = normalize(mul(v.normal,(float3x3)unity_WorldToObject));
            fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//对于每个顶点来说 光的位置就是光的方向 因为是平行光
            fixed3 diffuse = _LightColor0.rgb * max(dot(normalDir,lightDir), 0) * _Diffuse.rgb;//取得漫反射的颜色
            
            //反射光方向
            fixed3 reflectDir = normalize(reflect(-lightDir,normalDir));
            //视野方向
            //相机是在世界空间下              
            fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(v.vertex,unity_WorldToObject).xyz);

            //高光反射
            fixed3 specular = _LightColor0.rgb * pow(max(dot(reflectDir,viewDir),0),_Gloss) * _Specular.rgb;
            f.color = diffuse + adbient + specular;
            return f;
        }

        fixed4 frag(v2f f):SV_Target
        {
            return fixed4(f.color, 1);
        }

        ENDCG
        }
    }
    FallBack  &quot;VertexLit&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/369366/201711/369366-20171106220712122-1818778668.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/369366/201711/369366-20171106220716981-1289787365.png&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;Shader &quot;AladdinShader/08 Specular Fragment Shader&quot;
{
    Properties
    {
        _Diffuse(&quot;Diffuse&quot;,Color)=(1,1,1,1) //添加自身的颜色
        _Specular(&quot;Specular&quot;,Color)=(1,1,1,1)
        _Gloss(&quot;Gloss&quot;,Range(8,200)) = 10
    }
    SubShader {
        Pass 
        {
            Tags{&quot;LightMode&quot;=&quot;ForwardBase&quot;}

        CGPROGRAM
#include &quot;Lighting.cginc&quot; //引用一些写好的程序块 会包含一些获取光照的信息  
//_LightColor0 取得第一个直射光的颜色
//_WorldSpaceLightPos0 

#pragma vertex vert
#pragma fragment frag 
    
        fixed4 _Diffuse;
        fixed4 _Specular;
        half _Gloss;

        struct a2v 
        {
            float4 vertex:POSITION;
            float3 normal:NORMAL; //模型空间下法线
        };

        struct v2f
        {
            float4 position:SV_POSITION;
            float3 worldNormal:TEXCOORD0;//世界空间下的法线方向 
            float3 worldVertext:TEXCOORD1;//时间空间下的顶点坐标
        };
        v2f vert(a2v v)
        {
            v2f f;
            f.position = mul(UNITY_MATRIX_MVP, v.vertex);
            f.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);
            f.worldVertext = mul(v.vertex , unity_WorldToObject).xyz;
            return f;
        }

        fixed4 frag(v2f f):SV_Target
        {
            fixed3 adbient = UNITY_LIGHTMODEL_AMBIENT.rgb;
            fixed3 normalDir = normalize(f.worldNormal);
            fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);//对于每个顶点来说 光的位置就是光的方向 因为是平行光
            fixed3 diffuse = _LightColor0.rgb * max(dot(normalDir,lightDir), 0) * _Diffuse.rgb;//取得漫反射的颜色
            
            //反射光方向
            fixed3 reflectDir = normalize(reflect(-lightDir,normalDir));
            //视野方向
            //相机是在世界空间下              
            fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - f.worldVertext);

            //高光反射
            fixed3 specular = _LightColor0.rgb * pow(max(dot(reflectDir,viewDir),0),_Gloss) * _Specular.rgb;
            fixed3 tempColor = diffuse + adbient + specular;
            return fixed4(tempColor, 1);
        }

        ENDCG
        }
    }
    FallBack  &quot;VertexLit&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/369366/201711/369366-20171106222426997-1372712153.png&quot;/&gt;&lt;br/&gt;会比逐顶点高光效果更好一些，背光面可以考虑之前说的半兰伯特来处理，这样就不会显示全黑效果不好的情况。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 14:12:00 +0000</pubDate>
<dc:creator>蓬莱仙羽</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dingxiaowei/p/7795507.html</dc:identifier>
</item>
<item>
<title>使用PostgreSQL进行全文检索 - 枕边书</title>
<link>http://www.cnblogs.com/zhenbianshu/p/7795247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenbianshu/p/7795247.html</guid>
<description>

&lt;p&gt;PostgreSQL 被称为是“最高级的开源数据库”，它的数据类型非常丰富，用它来解决一些比较偏门的需求非常适合。&lt;/p&gt;
&lt;p&gt;前些天将 POI 点关键词查询的功能迁到了 PgSQL，总算对前文 &lt;a href=&quot;http://www.cnblogs.com/zhenbianshu/p/6817569.html&quot;&gt;空间索引 - 各数据库空间索引使用报告&lt;/a&gt; 有了一个交代。&lt;/p&gt;
&lt;p&gt;由于 PgSQL 国内的资料较少，迁移过程踩了不少坑，这里总结记录一下，帮助后来的同学能顺利使用 PgSQL。而且目前在灰度测试刚布了一台机器，后续可能还要添加机器，整理一下流程总是好的。&lt;/p&gt;
&lt;p&gt;文章经常被人爬，而且还不注明原地址，我在这里的更新和纠错没法同步，这里注明一下原文地址：http://www.cnblogs.com/zhenbianshu/p/7795247.html&lt;/p&gt;
&lt;hr/&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;首先是安装 PgSQL，这里我使用的是 PgSQL 9.6，PgSQL 10 也刚发布了，有兴趣的可以尝下鲜。&lt;/p&gt;
&lt;p&gt;PgSQL 的安装可以说非常复杂了，除了要安装 Server 和 Client 外，还需要安装 devel 包。为了实现空间索引功能，我们还要安装最重要的 PostGIS 插件，此插件需要很多依赖，自己手动安装非常复杂而且很可能出错。&lt;/p&gt;
&lt;p&gt;推荐自动化方式安装，Yum 一定要配合 epel 这样的 Yum 源，保障能将依赖一网打尽。当然最好的还是使用 docker 来运行，找个镜像就行了。&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;插件&lt;/h3&gt;
&lt;p&gt;由于 PgSQL 的很多功能都由插件实现，所以还要安装一些常用的插件，如:&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-none&quot;&gt;postgis_topology（管理面、边、点等拓扑对象）
pgrouting（路径规划）
postgis_sfcgal（实现3D相关算法）
fuzzystrmatch（字符串相似度计算）
address_standardizer/address_standardizer_data_us（地址标准化）
pg_trgm（分词索引）&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些插件在安装目录 &lt;code&gt;/path/extensions&lt;/code&gt; 下编译完毕后，在数据库中使用前要先使用 &lt;code&gt;create extension xxx&lt;/code&gt; 启用。&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;启动&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;切换到非 root 用户。（PgSQL 在安装完毕后会创建一个名为 &lt;code&gt;postgres&lt;/code&gt; 的超级用户，我们可以使用这个超级用户来操作 PgSQL，后期建议重新创建一个普通用户用来管理数据）；&lt;/li&gt;
&lt;li&gt;切换到 &lt;code&gt;/installPath/bin/&lt;/code&gt; 目录下，PgSQL 在此目录下提供了很多命令，如 &lt;code&gt;createdb、createuser、dropdb、pg_dump&lt;/code&gt; 等；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;createdb&lt;/code&gt; 命令初始化一个文件夹 &lt;code&gt;dir_db&lt;/code&gt; (此目录不能已存在)存放数据库物理数据，使用 &lt;code&gt;-E UTF8&lt;/code&gt; 参数指定数据库字符集为 utf-8；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;pg_ctl -D dir_db&lt;/code&gt; 指定数据库启动后台服务；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;psql -d db&lt;/code&gt; 在命令行登陆 PgSQL;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;
&lt;p&gt;安装完毕后还要配置一些比较基本的参数才能正常使用。&lt;/p&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;Host权限&lt;/h3&gt;
&lt;p&gt;PgSQL需要在 &lt;code&gt;pg_hba.conf&lt;/code&gt; 文件中配置数据库 Host 权限，才能被其他机器访问。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-none&quot;&gt;# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust
host    all             all             127.0.0.1/32            md5
host    all             all             172.16.0.1/16            md5&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件中注释部分对这几个字段介绍得比较详细， 我们很可能需要添加 &lt;code&gt;host(IP)&lt;/code&gt; 访问项， ADDRESS 是普通的网段表示法，METHOD 推荐使用 &lt;code&gt;md5&lt;/code&gt;，表示使用 md5 加密传输密码。&lt;/p&gt;
&lt;h3 id=&quot;toc_7&quot;&gt;服务器配置&lt;/h3&gt;
&lt;p&gt;服务器配置在 &lt;code&gt;postgresql.conf&lt;/code&gt;中，修改配置后需要 使用 &lt;code&gt;pg_ctl restart -D dir_db&lt;/code&gt; 命令重启数据库；&lt;/p&gt;
&lt;p&gt;此外，我们也可以在登陆数据库后修改配置项：使用 &lt;code&gt;SELECT * FROM pg_settings WHERE name = 'config';&lt;/code&gt; 查询当前配置项，再使用 UPDATE 语句更新配置。但有些配置如内存分配策略是只在当前 session 生效的，全局生效需要在配置文件中修改，再重启服务器。&lt;/p&gt;
&lt;p&gt;我们可以修改配置并用客户端验证 SQL 语句的优化，使用 &lt;code&gt;\timing on&lt;/code&gt; 开启查询计时，使用 &lt;code&gt;EXPLAIN ANALYSE&lt;/code&gt; 语句 分析查询语句效率。 下面介绍两个已实践过的配置参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;shared_buffers：用于指定共享内存缓冲区所占用的内存量。它应该足够大来存储常使用的查询结果，以减少物理I/O。但它也不能太大，以避免系统 内存swap 的发生， 一般设置为系统内存的 20%。&lt;/li&gt;
&lt;li&gt;work_mem：一个连接的工作内存，在查询结果数据量较大时，此值如果较小的话，会导致大量系统 I/O，导致查询速度急剧下降，如果你的 explain 语句内 &lt;code&gt;buffer 部分 read&lt;/code&gt;数值过大，则表示工作内存不足，需要调整加此参数。但此值也不能太大，需要保证 &lt;code&gt;work_mem * max_connections + shared_buffers + 系统内存 &amp;lt; RAM&lt;/code&gt;，不然同样可能会导致系统 内存swap。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样，PgSQL 就能作为一个正常的关系型数据使用了。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;全文索引的实现要靠 PgSQL 的 gin 索引。分词功能 PgSQL 内置了英文、西班牙文等，但中文分词需要借助开源插件 &lt;code&gt;zhparser&lt;/code&gt;；&lt;/p&gt;
&lt;h3 id=&quot;toc_9&quot;&gt;SCWS&lt;/h3&gt;
&lt;p&gt;要使用 zhparser，我们首先要安装 SCWS 分词库，SCWS 是 Simple Chinese Word Segmentation 的首字母缩写（即：简易中文分词系统），其 GitHub 项目地址为 &lt;a href=&quot;https://github.com/hightman/scws&quot;&gt;hightman-scws&lt;/a&gt;，我们下载之后可以直接安装。&lt;/p&gt;
&lt;p&gt;安装完后，就可以在命令行中使用 &lt;code&gt;scws&lt;/code&gt; 命令进行测试分词了， 其参数主要有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-c utf8 指定字符集&lt;/li&gt;
&lt;li&gt;-d dict 指定字典 可以是 xdb 或 txt 格式&lt;/li&gt;
&lt;li&gt;-M 复合分词的级别， 1~15，按位异或的 &lt;code&gt;1|2|4|8&lt;/code&gt; 依次表示 &lt;code&gt;短词|二元|主要字|全部字&lt;/code&gt;，默认不复合分词，这个参数可以帮助调整到最想要的分词效果。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;toc_10&quot;&gt;zhpaser&lt;/h3&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li&gt;下载 zhparser 源码 &lt;code&gt;git clone https:github.com/amutu/zhparser.git&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;安装前需要先配置环境变量：&lt;code&gt;export PATH=$PATH:/path/to/pgsql&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;编译 zhparser；&lt;/li&gt;
&lt;li&gt;登陆 PgSQL 使用 &lt;code&gt;CREATE EXTENSION zhparser;&lt;/code&gt; 启用插件；&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;添加分词配置&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-none&quot;&gt;CREATE TEXT SEARCH CONFIGURATION parser_name (PARSER = zhparser); // 添加配置
ALTER TEXT SEARCH CONFIGURATION parser_name ADD MAPPING FOR n,v,a,i,e,l,j WITH simple; // 设置分词规则 （n 名词 v 动词等，详情阅读下面的文档）&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;给某一列的分词结果添加 gin 索引 &lt;code&gt;create index idx_name on table using gin(to_tsvector('parser_name', field));&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;在命令行中使用上一节中介绍的 scws 命令测试分词配置，如我认为复合等级为 &lt;code&gt;7&lt;/code&gt; 时分词结果最好，则我在 &lt;code&gt;postgresql.conf&lt;/code&gt;添加配置&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-none&quot;&gt;zhparser.multi_short = true #短词复合: 1
zhparser.multi_duality = true  #散字二元复合: 2
zhparser.multi_zmain = true  #重要单字复合: 4
zhparser.multi_zall = false  #全部单字复合: 8&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_11&quot;&gt;SQL&lt;/h3&gt;
&lt;p&gt;查询中我们可以使用最简单的 &lt;code&gt;SELECT * FROM table WHERE to_tsvector('parser_name', field) @@ 'word'&lt;/code&gt; 来查询 field 字段分词中带有 word 一词的数据；&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;to_tsquery()&lt;/code&gt; 方法将句子解析成各个词的组合向量，如 &lt;code&gt;国家大剧院&lt;/code&gt; 的返回结果为 &lt;code&gt;'国家' &amp;amp; '大剧院' &amp;amp; '大剧' &amp;amp; '剧院'&lt;/code&gt; ，当然我们也可以使用 &lt;code&gt;&amp;amp; |&lt;/code&gt; 符号拼接自己需要的向量；在查询 长句 时，可以使用 &lt;code&gt;SELECT * FROM table WHERE to_tsvector('parser_name', field) @@ to_tsquery('parser_name','words')&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;有时候我们想像 MySQL 的 &lt;code&gt;SQL_CALC_FOUND_ROWS&lt;/code&gt; 语句一样同步返回结果条数，则可以使用 &lt;code&gt;SELECT COUNT(*) OVER() AS score FROM table WHERE ...&lt;/code&gt;，PgSQL 会在每一行数据添加 score 字段存储查询到的总结果条数；&lt;/p&gt;
&lt;p&gt;到这里，普通的全文检索需求已经实现了。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;我们接着对分词效果和效率进行优化：&lt;/p&gt;
&lt;h3 id=&quot;toc_13&quot;&gt;存储分词结果&lt;/h3&gt;
&lt;p&gt;我们可以使用一个字段来存储分词向量，并在此字段上创建索引来更优地使用分词索引：&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-none&quot;&gt;ALTER TABLE table ADD COLUMN tsv_column tsvector;           // 添加一个分词字段
UPDATE table SET tsv_column = to_tsvector('parser_name', coalesce(field,''));   // 将字段的分词向量更新到新字段中
CREATE INDEX idx_gin_zhcn ON table USING GIN(tsv_column);   // 在新字段上创建索引
CREATE TRIGGER trigger_name BEFORE INSERT OR UPDATE  ON table FOR EACH ROW EXECUTE PROCEDURE
tsvector_update_trigger(tsv_column, 'parser_name', field); // 创建一个更新分词触发器&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，再进行查询时就可以直接使用 &lt;code&gt;SELECT * FROM table WHERE tsv_column @@ 'keyword'&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;这里需要注意，这时候在往表内插入数据的时候，可能会报错，提示指定 parser_name 的 schema， 这时候可以使用 &lt;code&gt;\dF&lt;/code&gt; 命令查看所有 text search configuration 的参数：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-none&quot;&gt;               List of text search configurations
   Schema   |    Name    |              Description
------------+------------+---------------------------------------
 pg_catalog | english    | configuration for english language
 public     | myparser   |&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意 schema 参数，在创建 trigger 时需要指定 schema， 如上面，就需要使用 &lt;code&gt;public.myparser&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;toc_14&quot;&gt;添加自定义词典&lt;/h3&gt;
&lt;p&gt;我们可以在网上下载 xdb 格式的词库来替代默认词典，词库放在 &lt;code&gt;share/tsearch_data/&lt;/code&gt; 文件夹下才能被 PgSQL 读取到，默认使用的词库是 &lt;code&gt;dict.utf8.xdb&lt;/code&gt;。要使用自定义词库，可以将词库放在词库文件夹后，在 &lt;code&gt;postgresql.conf&lt;/code&gt; 配置 &lt;code&gt;zhparser.extra_dict=&quot;mydict.xdb&quot;&lt;/code&gt; 参数；&lt;/p&gt;
&lt;p&gt;当我们只有 txt 的词库，想把这个词库作为默认词库该怎么办呢？使用 scws 带的&lt;code&gt;scwe-gen-dict&lt;/code&gt; 工具或网上找的脚本生成 xdb 后放入词库文件夹后，在 PgSQL 中分词一直报错，读取词库文件失败。我经过多次实验，总结出了一套制作一个词典文件的方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;准备词库源文件 mydict.txt：词库文件的内容每一行的格式为&lt;code&gt;词 TF IDF 词性&lt;/code&gt;，词是必须的，而 &lt;code&gt;TF 词频(Term Frequency)、IDF 反文档频率(Inverse Document Frequency) 和 词性&lt;/code&gt; 都是可选的，除非确定自己的词典资料是对的且符合 scws 的配置，不然最好还是留空，让 scws 自已确定；&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;postgresql.conf&lt;/code&gt; 中设置 &lt;code&gt;zhparser.extra_dicts = &quot;mydict.txt&quot;&lt;/code&gt; 同时设置 &lt;code&gt;zhparser.dict_in_memory = true&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;命令行进入 PgSQL，执行一条分词语句 &lt;code&gt;select to_tsquery('parser', '随便一个词')&lt;/code&gt; ，分词会极慢，请耐心(请保证此时只有一个分词语句在执行)；&lt;/li&gt;
&lt;li&gt;分词成功后，在/tmp/目录下找到生成的 &lt;code&gt;scws-xxxx.xdb&lt;/code&gt; 替换掉 &lt;code&gt;share/tsearch_data/dict.utf8.xdb&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;删除刚加入的 &lt;code&gt;extra_dicts dict_in_memory&lt;/code&gt; 配置，重启服务器。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_15&quot;&gt;扩展&lt;/h3&gt;
&lt;p&gt;由于查询的是 POI 的名称，一般较短，且很多词并无语义，又考虑到用户的输入习惯，一般会输入 POI 名称的前几个字符，而且 scws 的分词准确率也不能达到100%，于是我添加了名称的前缀查询来提高查询的准确率，即使用 B树索引 实现 &lt;code&gt;LIKE '关键词%'&lt;/code&gt; 的查询。这里需&lt;/p&gt;
&lt;p&gt;这里要注意的是，创建索引时要根据字段类型配置 &lt;code&gt;操作符类&lt;/code&gt;，不然索引可能会不生效，如在 字段类型为 varchar 的字段上创建索引需要使用语句&lt;code&gt;CREATE INDEX idx_name ON table(COLUMN varchar_pattern_ops)&lt;/code&gt;，这里的 varchar&lt;em&gt;pattern&lt;/em&gt;ops 就是操作符类，操作符类的介绍和选择可以查看文档：&lt;a href=&quot;http://www.postgres.cn/docs/9.4/indexes-opclass.html&quot;&gt;11.9. 操作符类和操作符族&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;自此，一个良好的全文检索系统就完成了。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;简单的数据迁移并不是终点，后续要做的还有很多，如整个系统的数据同步、查询效率优化、查询功能优化（添加拼音搜索、模糊搜索）等。特别是查询效率，不知道是不是我配置有问题，完全达不到那种 E级毫秒 的速度，1kw 的数据效率在进行大结果返回时就大幅下降（200ms），只好老老实实地提前进行了分表，目前百万级查询速度在 20ms 以内，优化还有一段路要走。&lt;/p&gt;
&lt;p&gt;不过这次倒是对 技术的“生态”有了个更深的体会，这方面 PgSQL 确实和 MySQL 差远了，使用 MySQL 时再奇葩的问题都能在网上快速找到答案，而 PgSQL 就尴尬了，入门级的问题搜索 stackoverflow 来来回回就那么几个对不上的回答。虽然也有阿里的“德哥”一样的大神在辛苦布道，但用户的数量才是根本。不过，随着 PgSQL 越来越完善，使用它的人一定会越来越多的，我这篇文章也算是为 PgSQL 加温了吧，哈哈~希望能帮到后来的使用者。&lt;/p&gt;
&lt;p&gt;关于本文有什么问题可以在下面留言交流，如果您觉得本文对您有帮助，可以点击下面的 &lt;strong&gt;&lt;code&gt;推荐&lt;/code&gt;&lt;/strong&gt; 支持一下我，博客一直在更新，欢迎 &lt;strong&gt;&lt;code&gt;关注&lt;/code&gt;&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://aigo.iteye.com/blog/2064136&quot;&gt;PostgreSQL系统配置优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/80e5d003b62c&quot;&gt;[PG]使用 zhparser 进行中文分词全文检索&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.xunsearch.com/scws/docs.php#libscws&quot;&gt;SCWS 中文分词&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://about.gitlab.com/2016/03/18/fast-search-using-postgresql-trigram-indexes/&quot;&gt;Fast Search Using PostgreSQL Trigram Indexes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/7730&quot;&gt;使用阿里云PostgreSQL zhparser时不可不知的几个参数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/59251&quot;&gt;德哥的PostgreSQL私房菜 - 史上最屌PG资料合集&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 13:35:00 +0000</pubDate>
<dc:creator>枕边书</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenbianshu/p/7795247.html</dc:identifier>
</item>
<item>
<title>深入理解计算机系统（5.1）------优化程序性能 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/7692286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/7692286.html</guid>
<description>&lt;p&gt;　　你能获得的对程序最大的加速比就是当你第一次让它工作起来的时候。&lt;/p&gt;
&lt;p&gt;　　在讲解如何优化程序性能之前，我们首先要明确写程序最主要的目标就是使它在所有可能的情况下都能正常工作，一个运行的很快的程序但是却是错误的结果是没有任何用处的，所以我们在进行程序性能优化之前，首先要保证程序能正常运行，且结果是我们需要的。&lt;/p&gt;
&lt;p&gt;　　而且在很多情况下，让程序跑的更快是我们必须要解决的问题。比如一个程序要实时处理视频帧或者网络包，那么一个运行的很慢的程序就不能解决此问题。再比如一个计算任务计算量非常大，需要数日或者数周，如果我们哪怕只是让它运行的快20%也会产生重大影响。&lt;/p&gt;

&lt;h3&gt;1、编写高效程序的切入点&lt;/h3&gt;
&lt;p&gt;　　①、选择一组合适的算法和数据结构。&lt;/p&gt;
&lt;p&gt;　　②、编写出编译器能够有效优化以转换成高效可执行的源代码。&lt;/p&gt;
&lt;p&gt;　　③、多线程并行处理运算。&lt;/p&gt;
&lt;p&gt;　　对于第一点，程序=数据结构+算法，选择合适的数据结构和算法无疑对于提高程序的运行效率有很大的影响。第二点对于编程者则需要理解编译器的优化能力以及局限性，编写程序看上去只是一点小小的改动，可能都会引起编译器优化方式很大的变化；第三点技术主要这对运算量特别大的运算，我们将一个大的任务分成多个小任务，这些任务又可以在多核和多处理器的某种组合上并行的计算，这里我们也需要知道，即使是利用并行性，每个并行的线程都要以最高性能的方式执行。&lt;/p&gt;

&lt;h3&gt;2、编译器的优化能力和局限性&lt;/h3&gt;
&lt;p&gt;　　正确性，正确性，正确性！！！这个要着重提醒，所以编译器必须很小心的对程序使用安全的优化。限制编译器只进行安全的优化，会消除一些造成错误的运行结果，但是这也意味着程序员必须花费更大的力气写出程序使编译器能够将之转换为有效机器代码。&lt;/p&gt;
&lt;p&gt;　　对于下面两个程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
void add1(int *xp,int *yp){
     *xp += *yp;
     *xp += *yp;    
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
void add2(int *xp,int *yp){
     *xp += 2* *yp;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对上上面两个函数add1和add2，它们都是将存储在由指针 yp 指示的位置处的值两次加到指针 xp 指示的位置处的值。但是明显add2的执行效率要高，它只要求 3 次存储器的引用（读*xp,读*yp,写*xp），而add1需要 6 次存储器引用（2次读*xp,2次读*yp,2次写*xp）。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;因此，如果编译器要优化add1,我们可以认为add2是其优化后的代码。但实际上真的是这样吗？如果 xp 等于 yp，那么变成如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
void add1(int *xp,int *xp){
     *xp += *xp;
     *xp += *xp;    
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
void add2(int *xp,int *xp){
     *xp += 2* *xp;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以看到，这个时候对于 add1,xp的值会增加 4 倍，但是 add2 当中，xp 的值只增加 3 倍。由于编译器不知道参数 xp 和 yp 是否相等，它必须假定他们有可能相等，&lt;strong&gt;所以不会产生 add2 作为 add1 的优化版本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在各种编译器中，我们前面说过的 gcc 编译器，可以通过加参数O0 --&amp;gt;&amp;gt; O1 --&amp;gt;&amp;gt; O2 --&amp;gt;&amp;gt; O3，分别是从没有优化到优化级别最高。但是基本上编译器都不会对程序进行各种激进的优化，所以程序员必须以一种简化编译器生成高效代码的任务来编写程序。如何编写，请接着往下面看。&lt;/p&gt;

&lt;h3&gt;3、程序的性能表示&lt;/h3&gt;
&lt;p&gt;　　处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用千兆赫兹（GHz），即十亿周期每秒来表示。例如，当表明一个系统有“4GHz”处理器，这表示处理器时钟运行频率为 4*10&lt;sup&gt;9&lt;/sup&gt; 千兆赫兹。每个时钟周期的时间是时钟频率的倒数。通常用纳秒（nanosecond,1 纳秒等于10&lt;sup&gt;-9&lt;/sup&gt;秒），或者皮秒（picosecond，1 皮秒等于10&lt;sup&gt;-12&lt;/sup&gt;秒）来表示，一个 4GHz 的十周周期为0.25纳秒，或者说250皮秒。从程序员的角度来看，用时钟周期来表示度量标准要比用纳秒或者皮秒来表示有用的多。&lt;/p&gt;
&lt;p&gt;　　用时钟周期来表示，度量值表示的是执行了多少条指令，而不是时钟运行的有多快。&lt;/p&gt;

&lt;h3&gt;4、提高程序的性能方法&lt;/h3&gt;
&lt;p&gt;　　这本书的作者讲解如何优化程序性能主要从两个方面入手，第一个是与机器无关，第二个是与机器相关。&lt;/p&gt;
&lt;h4&gt;　　与机器无关：&lt;/h4&gt;
&lt;p&gt;　　&lt;strong&gt;①、消除循环的低效率&lt;/strong&gt;：将每次循环中执行多次但计算结果不改变的部分提出循环，这样只需计算一次，而不用循环一次，计算一次。以此提高算法效率。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、减少过程调用&lt;/strong&gt;：也就是减少函数方法的调用，因为函数方法的调用会带来相当大的开销。但是这样也会带来一个缺点，就是破坏程序的模块化，所以我们需要权衡利弊。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、消除不必要的存储器引用&lt;/strong&gt;：在循环中不停地对指针所指向的变量赋值的时候，我们可以用一个中间变量代替指针，以增加速度。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④、选择合适的算法和数据结构&lt;/strong&gt;：为遇到的问题选择合适的算法和数据结构，避免使用产生糟糕性能的算法或编码技术。&lt;/p&gt;
&lt;h4&gt;　　与机器相关：&lt;/h4&gt;
&lt;p&gt;　　&lt;strong&gt;①、理解现代处理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在代码级上，看上去似乎是一次执行条指令，每条指令都从寄存器或存储器中取值，执行一个操作后，并把结果存到一个寄存器或存储器位置。但是实际上，在处理器中是同时对多条指令求值，称为指令级并行。现代微处理器了不起的成就就是它们采用复杂而奇异的微处理结构，多条指令可以并行执行，同时又呈现出一种简单的顺序执行指令的表象。&lt;/p&gt;
&lt;p&gt;　　当一系列操作必须按照严格的顺序执行时，就会遇到延迟界限，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制令处理器利用指令级并行的能力时，延迟界限能够限定程序性能。吞吐量界限刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。&lt;/p&gt;
&lt;p&gt;　　下图是一个现代微处理器的简化示意图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171101115054982-1941686301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　指令控制单元（Instruction Control Unit,ICU）从指令高速缓存（instruction cache）中读取指令，并产生一系列基本操作。指令高速缓存是一个特殊的高速缓存存储器，它存储最近访问的指令。通常ICU会在当前正在执行的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发给执行单元 EU（Execution Unit ,EU），然后由EU完成ICU产生的基本操作。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、提高并行性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;循环分割，利用功能单元的流水线化的能力提高代码性能。对于一个可结合和可交换的合并操作来说，比如说整数加法和乘法，我们可以通过将一组合并操作分割成两个或更多的部分，通过在最后合并结果来提高性能。&lt;/p&gt;

</description>
<pubDate>Mon, 06 Nov 2017 13:31:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/7692286.html</dc:identifier>
</item>
<item>
<title>「设计模式」JavaScript - 设计模式之单例模式与场景实践 - OkayChen</title>
<link>http://www.cnblogs.com/okaychen/p/7794409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okaychen/p/7794409.html</guid>
<description>&lt;p&gt;&lt;span&gt;上次总结了设计模式中的module模式，可能没有真真正正的使用在场景中，发现效果并不好，想要使用起来却不那么得心应手，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以这次我打算换一种方式~~从简单的场景中来看单例模式，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为JavaScript非常灵活，所以在&lt;span&gt;使用设计模式的时候也带来了很强的灵活性，实现单例的方法也有很多，那就需要我们把握住单例模式的核心&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;单例模式介绍：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单例模式是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个&lt;span&gt;唯一的访问点&lt;/span&gt;来访问该对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、模块间通信&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、系统中某各类的对象只能存在一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、保护自己的属性和方法，保证了所有的对象访问的都是同一个实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意事项：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、注意this的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、闭包容易造成内存泄露，不需要的尽快处理等待回收&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们先来实现一个标准的单例模式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、如果实例存在就返回，实例不存在就创建新实例；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、从全局命名空间中隔离出代码，从而为函数提供单一访问点：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;var&lt;/span&gt; mySingleton = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例保持Singleton的一个引用&lt;/span&gt;
&lt;span&gt;            let instance;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Singleton&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有方法和变量&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; init() {
                &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; privateMethod() {
                    console.log(&lt;/span&gt;'I am private'&lt;span&gt;);
                }
                const privateVariable &lt;/span&gt;= ' I am also private '&lt;span&gt;;
                const privateRandomNumber &lt;/span&gt;=&lt;span&gt; Math.random();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 公有方法和变量&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                    publicMethod:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                        console.log(&lt;/span&gt;'I am public'&lt;span&gt;);
                    },
                    getRandomNumber:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; privateRandomNumber; 
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Singleton实例，如果存在就返回，不存在就创建新实例&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                getInstance:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;instance){
                        instance &lt;/span&gt;=&lt;span&gt; init();
                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
                }
            }

        })();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试&lt;/span&gt;
       const singleA =&lt;span&gt; mySingleton.getInstance();
       const singleB &lt;/span&gt;=&lt;span&gt; mySingleton.getInstance();&lt;br/&gt;console.log( singleA.getRandomNumber() &lt;/span&gt;=== singleB.getRandomNumber());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
       console.log(singleA.publicMethod())  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; I am public&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面写一个我们在场景中经常使用的一种简单的非标准的单例模式类型，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景一：使用简单的单例模式实现一个可编辑表格&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;html&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;table table-bordered&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;js-table-test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;编号&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;okaychen&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;StackOverflowChen&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;没使用单例模式之前，我们可能会这样处理：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
   $(&quot;#js-table-test td&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (argument) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; m = $(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).html();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = &quot;&amp;lt;input type='text' value='&quot; + m + &quot;'  /&amp;gt;&quot;&lt;span&gt;;
            $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).html(s);
        })
        $(&lt;/span&gt;&quot;#js-table-test td&quot;).on('keyup','input',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
            e.stopPropagation();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; me = $(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e.keyCode==13&lt;span&gt;){
                me.val();
            }
        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那么就让我们对比一下使用单例的代码 思路&amp;gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、使用自执行函数传递参数$，减少查询次数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、使用简单的单例模式，为之后修改或者模块化打基础&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提供单一访问点&lt;span&gt;init&lt;/span&gt;&lt;strong&gt;，&lt;/strong&gt;通过datas共享数据，render封装对应的元素，bind来绑定事件，_do来规范私有事件；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
  (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ($) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命名空间&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; index =&lt;span&gt; {
                init: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入口&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; me = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
                    me.render();
                    me.bind();
                },
                datas: {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 共享数据&lt;/span&gt;
                    num: 1&lt;span&gt;
                },
                render: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装对应的元素&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; me = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
                    me.test &lt;/span&gt;= $('#js-table-test td'&lt;span&gt;);
                },
                bind: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绑定事件&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; me = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    me.test.on('click', $.proxy(me['_do'], &lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
                },
                _do: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有事件&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; me = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; m =&lt;span&gt; $(e.target).text();
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = &quot;&amp;lt;input type='text' value='&quot; + m + &quot;'  /&amp;gt;&quot;&lt;span&gt;;
                    $(e.target).html(s);
                    console.log(me.datas.num &lt;/span&gt;++&lt;span&gt;)
                }
            }
            index.init();
        })(jQuery);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 06 Nov 2017 13:19:00 +0000</pubDate>
<dc:creator>OkayChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okaychen/p/7794409.html</dc:identifier>
</item>
</channel>
</rss>