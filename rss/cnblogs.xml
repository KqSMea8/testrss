<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【关于封装的那些事】 未利用封装 - 喜欢天黑却怕鬼</title>
<link>http://www.cnblogs.com/songwenjie/p/8979967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/8979967.html</guid>
<description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/hlFKAlhh5F.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;客户代码使用显式类型检查（使用一系列if-else或switch语句检查对象的类型），而不利用出层次结构内已封装的类型变化时，将导致这种坏味。&lt;/p&gt;
&lt;h2 id=&quot;为什么要利用封装&quot;&gt;为什么要利用封装？&lt;/h2&gt;
&lt;p&gt;一种臭名昭著的坏味是，在客户代码中使用条件语句（if-else或switch语句）来显式地检查类型，并根据类型执行相应的操作。我们这里讨论的是：&lt;strong&gt;要检查的类型都封装在了层次结构中，但没有利用这一点，即使用显式类型检查，而不依赖于动态多态性&lt;/strong&gt;。这将导致如下问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;显式类型检查让客户程序和具体类型紧密耦合，降低了设计的可维护性。例如，引入新类型后，必须修改客户程序，在其中检查新类型以及执行相应操作的代码。&lt;/li&gt;
&lt;li&gt;客户程序必须显式地检查层次结构中所有相关的类型。如果未检查一个或多个这样的类型，客户程序在运行阶段可能出现意外的行为。相反，如果利用了&lt;strong&gt;运行时多态&lt;/strong&gt;，完全可以避免这种问题。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;未利用封装潜在的原因&quot;&gt;未利用封装潜在的原因&lt;/h2&gt;
&lt;h3 id=&quot;以过程型思维使用面向对象语言&quot;&gt;以过程型思维使用面向对象语言&lt;/h3&gt;
&lt;p&gt;开发时的思维是以代码执行过程为导向，自然而然就会使用if-else语句和switch语句。&lt;/p&gt;
&lt;h3 id=&quot;未应用面向对象原则&quot;&gt;未应用面向对象原则&lt;/h3&gt;
&lt;p&gt;无力将面向对象的概念付诸实践。&lt;/p&gt;
&lt;h2 id=&quot;示例分析一&quot;&gt;示例分析一&lt;/h2&gt;
&lt;p&gt;根为抽象类DataBuffer的层次结构封装了各种基本数据结构型数组，DataBuffer的子类DataBufferByte、DataBufferUShort、DataBufferInt支持相应的基本数据类型数组。DataBuffer定义了常量TYPE_BYTE、TYPE_USHORT、TYPE_INT。客户程序使用TYPE_BYTE、TYPE_USHORT、TYPE_INT的DataBuffer来存储数据。&lt;/p&gt;
&lt;p&gt;下面是客户程序的示例，演示如何使用switch语句执行针对具体类型的显式类型检查。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;switch (transferType)
{
    case DataBuffer.TYPE_BYTE:
        byte[] bdata = (byte[])inData;
        pixel = bdata[0] &amp;amp; 0xff;
        length = bdata.Length;
        break;
    case DataBuffer.TYPE_USHORT:
        short[] sdata = (short[])inData;
        pixel = sdata[0] &amp;amp; 0xffff;
        length = sdata.Length;
        break;
    case DataBuffer.TYPE_INT:
        int[] idata = (int[])inData;
        pixel = idata[0];
        length = idata.Length;
        break;
    default:
        throw new Exception(&quot;不支持的transferType&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码使用的数据成员transferType定义如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;protected int transferType;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重构建议：将决定行为的条件语句删除，并在层次结构中引入多态方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在客户程序中，提供合适的DataBuffer子类对象。在DataBuffer层次结构类型中，定义方法GetPixel()和GetLengthl()。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public abstract class DataBuffer
{
    public const int TYPE_BYTE = 1;
    public const int TYPE_DOUBLE = 2;
    public const int TYPE_FLOAT = 3;
    public const int TYPE_INT = 4;
    public const int TYPE_USHORT = 5;

    public abstract int GetPixel(object inData);
    public abstract int GetLength(object inData);
}

public class DataBufferInt: DataBuffer
{
    public override int GetPixel(object inData)
    {
        int[] idata = (int[])inData;
        return  idata[0];
    }
    public override int GetLength(object inData)
    {
        int[] idata = (int[])inData;
        return idata.Length;
    }
}

public class DataBufferByte : DataBuffer
{
    public override int GetPixel(object inData)
    {
        byte[] bdata = (byte[])inData;
        return bdata[0] &amp;amp; 0xff;
    }
    public override int GetLength(object inData)
    {
        byte[] bdata = (byte[])inData;
        return bdata.Length;
    }
}

public class DataBufferUShort : DataBuffer
{
    public override int GetPixel(object inData)
    {
        short[] sdata = (short[])inData;
        return sdata[0] &amp;amp; 0xffff;  
    }
    public override int GetLength(object inData)
    {
        short[] sdata = (short[])inData;
        return sdata.Length;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并将客户程序switch语句及其case语句简化为：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;int pixel = GetPixel(inData);
int length = GetLength(inData);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于引用dataBuffer指向的是传入的DataBuffer子类对象，因此上述语句将调用相应子类的GetPixel()和GetLength()方法。这里需要注意的是客户程序代码提供特定DataBuffer子类对象，检查输入数据类型和创建DataBuffer子类对象的工作由客户程序负责。可能需要在客户代码或一个工厂类中使用switch-case语句，而&lt;strong&gt;只需要使用一次这个switch-case语句&lt;/strong&gt;。由于客户程序不知道具体是哪个DataBuffer子类，所以它与DataBuffer层次结构耦合更低。这样在DataBuffer层次结构修改既有类型和添加新类型时，不会对客户程序造成影响。即使有影响也是只需要使用一次的这个switch-case语句，修改代码代价极小。&lt;/p&gt;
&lt;p&gt;这让我想起，我在看完《重构》后天真幼稚的想消除项目中的switch-case语句，只要项目中存在switch-case语句我就觉得存在坏味道，此后的一段时间我很痛苦，因为项目中总是存在消灭不了的switch-case语句。其实如果项目中需要与外部世界的实体交互，要避免使用条件逻辑很难。例如用户在页面的操作在代码中肯定对应不同的对象来处理，这中间必须使用条件逻辑判断使用哪个对象处理。但是这样的判断应该只有一处，负责日后的代码维护是个灾难。&lt;/p&gt;
&lt;h2 id=&quot;示例分析二&quot;&gt;示例分析二&lt;/h2&gt;
&lt;p&gt;还是那句话switch-case语句和if-else语句不可怕，可怕的是多个witch-case语句和if-else语句。&lt;/p&gt;
&lt;p&gt;对于这样的代码我们要给予充分的关注：&lt;/p&gt;
&lt;p&gt;代码1：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;if(obj is XXX)
{
    //做事情A
}
if(obj is YYY)
{
    //做事情B
}
if(obj is ZZZ)
{
    //做事情C
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码2：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;if(obj is XXX)
{
    //做事情A
}
if(obj is YYY)
{
    //做事情B
}
if(obj is ZZZ)
{
    //做事情C
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码3：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;if(obj is XXX)
{
    //做事情A
}
if(obj is YYY)
{
    //做事情B
}
if(obj is ZZZ)
{
    //做事情C
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的代码是难以扩展的，新增一个类NNN，就需要找到代码1、2、3甚至n进行修改，很容易遗漏。而且遗漏造成的错误只用在代码运行阶段才能发现。&lt;/p&gt;
&lt;p&gt;这种情况反映出来的问题就是没有利用封装，已经有了层次结构，却没有予以利用。没有面向接口编程，每个地方面向的都是具体的实现类，每个地方都需要判断实例的类型才可以进行下一步的动作。&lt;/p&gt;
&lt;p&gt;进行重构：&lt;/p&gt;
&lt;p&gt;代码1：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;obj.DoSomething1();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码2：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;obj.DoSomething2();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码3：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;obj.DoSomething3();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;obj可以是XXX、YYY、ZZZ。对于现在的代码，新增一个类NNN，代码1、2、3甚至n处根本不需要任何改动。因为它们实现了统一的接口，并且符合开闭原则。&lt;/p&gt;
&lt;p&gt;参考：《软件设计重构》&lt;/p&gt;

&lt;div class=&quot;content&quot; readability=&quot;26.253521126761&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;

&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div readability=&quot;7.9328063241107&quot;&gt;&lt;strong&gt;来源：&lt;a href=&quot;http://songwenjie.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;http://songwenjie.cnblogs.com/&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;p&gt;&lt;strong&gt;声明：本文为博主学习感悟总结，水平有限，如果不当，欢迎指正。如果您认为还不错，不妨点击一下下方的&lt;span onclick=&quot;Digg();&quot;&gt;【&lt;span&gt;推荐&lt;/span&gt;】&lt;/span&gt;按钮，谢谢支持。转载与引用请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;



</description>
<pubDate>Wed, 02 May 2018 23:37:00 +0000</pubDate>
<dc:creator>喜欢天黑却怕鬼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/8979967.html</dc:identifier>
</item>
<item>
<title>《HelloGitHub》第 25 期 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/8983069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/8983069.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;兴趣是最好的老师，&lt;strong&gt;HelloGitHub&lt;/strong&gt; 就是帮你找到兴趣！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502225712779-540395119.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;分享 GitHub 上有趣、入门级的开源项目。&lt;/p&gt;
&lt;p&gt;这是一个面向&lt;strong&gt;编程新手&lt;/strong&gt;、&lt;strong&gt;热爱编程&lt;/strong&gt;、&lt;strong&gt;对开源社区感兴趣&lt;/strong&gt; 人群的月刊，月刊的内容包括：&lt;strong&gt;各种编程语言的项目&lt;/strong&gt;、&lt;strong&gt;让生活变得更美好的工具&lt;/strong&gt;、&lt;strong&gt;书籍、学习笔记、教程等&lt;/strong&gt;，这些开源项目大多都是非常容易上手，而且非常 Cool。主要是希望大家能动手用起来，加入到&lt;strong&gt;开源社区&lt;/strong&gt;中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会编程的可以贡献代码&lt;/li&gt;
&lt;li&gt;不会编程的可以反馈使用这些工具中的 Bug&lt;/li&gt;
&lt;li&gt;帮着宣传你觉得优秀的项目&lt;/li&gt;
&lt;li&gt;Star 项目⭐️&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在浏览、参与这些项目的过程中，你将学习到&lt;strong&gt;更多编程知识&lt;/strong&gt;、&lt;strong&gt;提高编程技巧&lt;/strong&gt;、&lt;strong&gt;找到编程的乐趣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;🎉 最后 &lt;a href=&quot;https://hellogithub.com/&quot;&gt;HelloGitHub&lt;/a&gt; 这个项目就诞生了 🎉&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;3.5882352941176&quot;&gt;
&lt;p&gt;&lt;strong&gt;以下为本期内容&lt;/strong&gt;｜每个月 &lt;strong&gt;28&lt;/strong&gt; 号发布最新一期｜&lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub#%E5%BE%80%E6%9C%9F%E5%9B%9E%E9%A1%BE&quot;&gt;点击查看往期内容&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;c-项目&quot;&gt;C 项目&lt;/h4&gt;
&lt;p&gt;1、&lt;a href=&quot;https://github.com/CuberL/swipe-workspace&quot;&gt;swipe-workspace&lt;/a&gt;：基于 libinput 实现 Linux 系统下通过二指滑动控制面板，切换屏幕的程序。虽然功能简单，且不支持全平台。但是十分推荐这种自己动手实现一个实用的功能这种行为，这是非常有成就感的事情&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502225740194-1451675240.gif&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;css-项目&quot;&gt;CSS 项目&lt;/h4&gt;
&lt;p&gt;2、&lt;a href=&quot;https://github.com/tabler/tabler&quot;&gt;tabler&lt;/a&gt;：一套基于 Bootstrap 4 免费开源的 Dashboard 模版&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502225810091-989260648.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;go-项目&quot;&gt;Go 项目&lt;/h4&gt;
&lt;p&gt;3、&lt;a href=&quot;https://github.com/FrontMage/dynamo.cli&quot;&gt;dynamo.cli&lt;/a&gt;：AWS DynamoDB 是一项快速灵活的 NoSQL 数据库服务。如果大家使用这个用服务，但又记不住蹩脚的 AWS 客户端的查询命令。可以使用这个工具，通过 SQL 命令查询、操作 Amazon DynamoDB 数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502225754023-1316293995.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://github.com/liangdas/mqant&quot;&gt;mqant&lt;/a&gt;：一款基于 Go 语言的简洁、高性能的分布式游戏服务框架。&lt;a href=&quot;https://github.com/liangdas/mqant/wiki&quot;&gt;快速上手文档&lt;/a&gt;，作者阐述了自己为什么选用 Go 作为开发语言和一些设计思路&lt;/p&gt;
&lt;h4 id=&quot;java-项目&quot;&gt;Java 项目&lt;/h4&gt;
&lt;p&gt;5、&lt;a href=&quot;https://github.com/crossoverJie/Java-Interview&quot;&gt;Java-Interview&lt;/a&gt;：该项目介绍的内容包含：Java 基础知识、底层原理、算法详解、大厂面试真题等&lt;/p&gt;
&lt;h4 id=&quot;javascript-项目&quot;&gt;JavaScript 项目&lt;/h4&gt;
&lt;p&gt;6、&lt;a href=&quot;https://github.com/shinima/battle-city&quot;&gt;battle-city&lt;/a&gt;：基于 React 的经典坦克大战，&lt;a href=&quot;http://shinima.pw/battle-city&quot;&gt;在线试玩&lt;/a&gt;。欢迎感兴趣的小伙伴动起手来提交代码加入到这个项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502225829555-302608246.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&quot;https://github.com/yyued/SVG-Skeleton&quot;&gt;SVG-Skeleton&lt;/a&gt;：通过 SVG 元素去描述去骨骼图的占位元素。支持 JSX 让编写 SVG 无差别化、复用 SVG 片段、类组件化模式。让交互变得更加人性化，适合当下技术流行趋势，2KB 的大小根本不必担心加载问题。示例代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; SVGSkeleton &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'svg-skeleton'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; h&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; render &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; SVGSkeleton&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 内置 #shining 动画&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; Item &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;svg width&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;750&quot;&lt;/span&gt; height&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;191&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;circle cx&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;95&quot;&lt;/span&gt; cy&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;102&quot;&lt;/span&gt; r&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;63&quot;&lt;/span&gt; fill&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#edeff0&quot;&lt;/span&gt; mask&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;url(#shining)&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/circle&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;        &amp;lt;rect width=&quot;160&quot; height=&quot;35&quot; x=&quot;190&quot; y=&quot;45&quot; fill=&quot;#edeff0&quot; mask=&quot;url&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;#shining&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&quot; &amp;gt;&amp;lt;/rect&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;rect width&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;400&quot;&lt;/span&gt; height&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;35&quot;&lt;/span&gt; x&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;190&quot;&lt;/span&gt; y&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;90&quot;&lt;/span&gt; fill&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#edeff0&quot;&lt;/span&gt; mask&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;url(#shining)&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/rect&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;        &amp;lt;line x1=&quot;0&quot; y1=&quot;190&quot; x2=&quot;750&quot; y2=&quot;190&quot; stroke=&quot;#edeff0&quot;&amp;gt;&amp;lt;/line&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/svg&amp;gt;&lt;/span&gt;
&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;const Page = &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; =&amp;gt; {&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    let List = &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;[ ]&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;    for &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; let i = 0; i &amp;lt; 6; i&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; {&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;        List.push&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; &amp;lt;Item y={ i == 0 &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; 0 : i &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; 191 } &amp;gt;&amp;lt;/Item&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; ) )&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    }

    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
        &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;svg width&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;750&quot;&lt;/span&gt; height&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1334&quot;&lt;/span&gt; fill&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#fafafa&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; List &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/svg&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;} &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; Page,  document.body &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502225841851-266888226.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8、&lt;a href=&quot;https://github.com/vuejs/vuepress&quot;&gt;vuepress&lt;/a&gt;：Vue 官方出品的静态网站生成器。大家的个人博客是不是要折腾一番了？&lt;a href=&quot;https://vuepress.vuejs.org/zh/guide/&quot;&gt;官方中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a href=&quot;https://github.com/youzan/zan-proxy&quot;&gt;zan-proxy&lt;/a&gt;：该项目集成了 HTTP 请求转发、模拟响应数据、自定义 DNS 解析等功能。使得可以本地代码调试线上页面，环境再也不是问题。对于处于开发环境“恶劣”的开发者来说是种福音和解脱&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502225854333-669443763.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10、&lt;a href=&quot;https://github.com/hujiulong/gcoord&quot;&gt;gcoord&lt;/a&gt;：一个处理地理坐标的轻型 JS 库。由于处理国内对于地理坐标有特殊的政策，导致从 API 得到的地理坐标放在百度地图或高德地图上会有数百米的偏移，gcoord 可以将坐标在不同坐标系下转换，修正偏移。转换为百度地图坐标系的示例代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;gcoord&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;transform&lt;/span&gt;(
    [ &lt;span class=&quot;fl&quot;&gt;116.403988&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;39.914266&lt;/span&gt; ]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;// 经纬度坐标&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;gcoord&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;WGS84&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;                 &lt;span class=&quot;co&quot;&gt;// 当前坐标系&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;gcoord&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;BD09&lt;/span&gt;                   &lt;span class=&quot;co&quot;&gt;// 目标坐标系&lt;/span&gt;
)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;( result )&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;// [ 116.41661560068297, 39.92196580126834 ]&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;objective-c-项目&quot;&gt;Objective-C 项目&lt;/h4&gt;
&lt;p&gt;11、&lt;a href=&quot;https://github.com/avibrazil/RDM&quot;&gt;RDM&lt;/a&gt;：轻松地改变 MacBook Retina 屏幕分辨率的工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502225905388-1909080486.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;python-项目&quot;&gt;Python 项目&lt;/h4&gt;
&lt;p&gt;12、&lt;a href=&quot;https://github.com/huyingxi/Synonyms&quot;&gt;Synonyms&lt;/a&gt;：中文近义词工具包。支持自然语言理解的很多任务：文本对齐、推荐算法、相似度计算、语义偏移、关键字提取、概念提取、自动摘要、搜索引擎等。示例代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; synonyms
synonyms.seg(&lt;span class=&quot;st&quot;&gt;&quot;能量&quot;&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502225922032-824184949.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;13、&lt;a href=&quot;https://github.com/h2non/pook&quot;&gt;pook&lt;/a&gt;：模拟 HTTP 请求结果的库，可用于单元测试等场景。采用装饰器方式调用的示例代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; pook
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; requests

&lt;span class=&quot;at&quot;&gt;@pook.get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'http://httpbin.org/status/500'&lt;/span&gt;, reply&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;204&lt;/span&gt;)
&lt;span class=&quot;at&quot;&gt;@pook.get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'http://httpbin.org/status/400'&lt;/span&gt;, reply&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; fetch(url):
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; requests.get(url)

res &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fetch(&lt;span class=&quot;st&quot;&gt;'http://httpbin.org/status/400'&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'#1 status:'&lt;/span&gt;, res.status_code)

res &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fetch(&lt;span class=&quot;st&quot;&gt;'http://httpbin.org/status/500'&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'#2 status:'&lt;/span&gt;, res.status_code)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;14、&lt;a href=&quot;https://github.com/apache/incubator-airflow&quot;&gt;incubator-airflow&lt;/a&gt;：定时任务管理平台，管理和调度各种离线定时任务，自带 Web 管理界面。当定时任务量达到百级别的时候，就无法再使用 crontab 有效、方便地管理这些任务了。该项目就是为了解决了这个问题而诞生的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502225935965-786855165.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;15、&lt;a href=&quot;https://github.com/satwikkansal/wtfpython&quot;&gt;wtfpython&lt;/a&gt;：（英文）有趣、令人惊讶（坑爹）、鲜为人知的 Python 代码片段集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502225945846-1235315738.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;其它&quot;&gt;其它&lt;/h4&gt;
&lt;p&gt;16、&lt;a href=&quot;https://github.com/stone0090/javascript-lessons&quot;&gt;javascript-lessons&lt;/a&gt;：《JavaScript 闯关记》该教程部分章节精心设计了挑战关卡&lt;/p&gt;
&lt;p&gt;17、&lt;a href=&quot;https://github.com/MintCN/linux-insides-zh&quot;&gt;linux-insides-zh&lt;/a&gt;：Linux 内核揭密&lt;/p&gt;
&lt;p&gt;18、&lt;a href=&quot;https://github.com/tangweikun/awesome-leetcode&quot;&gt;awesome-leetcode&lt;/a&gt;：该项目收集了各种编程语言的 Leetcode 题解&lt;/p&gt;
&lt;p&gt;19、&lt;a href=&quot;https://github.com/serhii-londar/open-source-mac-os-apps&quot;&gt;open-source-mac-os-apps&lt;/a&gt;：（英文）MacOS 系统上的开源应用集合，并标注了应用通过那种编程语言实现&lt;/p&gt;
&lt;p&gt;20、&lt;a href=&quot;https://github.com/facert/awesome-spider&quot;&gt;awesome-spider&lt;/a&gt;：爬虫集合，大多为 Python 语言项目&lt;/p&gt;
&lt;h4 id=&quot;开源书籍&quot;&gt;开源书籍&lt;/h4&gt;
&lt;p&gt;21、&lt;a href=&quot;https://github.com/changkun/modern-cpp-tutorial&quot;&gt;modern-cpp-tutorial&lt;/a&gt;：《高速上手 C++ 11/14/17》阅读须知：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;本书假定读者已经熟悉了传统 C++ ，至少在阅读传统 C++ 代码上不具备任何困难。换句话说，那些长期使用传统 C++ 进行编码的人、渴望在短时间内迅速了解现代 C++ 特性的人非常适合阅读本书；&lt;/li&gt;
&lt;li&gt;本书一定程度上介绍了一些现代 C++ 的黑魔法，但这些魔法毕竟有限，不适合希望进阶学习现代 C++ 的读者，本书的定位系现代 C++ 的快速上手。当然，希望进阶学习的读者可以使用本书来回顾并检验自己对现代 C++ 的熟悉度。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;22、&lt;a href=&quot;https://github.com/chai2010/advanced-go-programming-book&quot;&gt;advanced-go-programming-book&lt;/a&gt;：《Go语言高级编程》该书针对 Go 语言有一定经验，想更加深入了解 Go 语言各种高级用法的开发人员&lt;/p&gt;
&lt;h4 id=&quot;机器学习&quot;&gt;机器学习&lt;/h4&gt;
&lt;p&gt;23、&lt;a href=&quot;https://github.com/chenyuntc/pytorch-book&quot;&gt;pytorch-book&lt;/a&gt;：书籍《深度学习框架 PyTorch：入门与实践》的示例代码，可以作为一个独立的 PyTorch 入门指南和教程。内容结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/759200/201805/759200-20180502230006246-248009053.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;24、&lt;a href=&quot;https://github.com/warmheartli/ChatBotCourse&quot;&gt;ChatBotCourse&lt;/a&gt;：该项目介绍了如何自己动手做聊天机器人。全面地介绍了所需要的技术：自然语言识别、分词、语料库、机器学习等，包含所需的 Java 和 Python 代码&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;换种方式阅读&quot;&gt;换种方式阅读&lt;/h2&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;如果你发现了好玩、有意义的开源项目 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub/issues/new&quot;&gt;点击这里&lt;/a&gt; 分享你觉得有意思的项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎转载，请注明出处和作者，同时保留声明。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 May 2018 23:36:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xueweihan/p/8983069.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 2.0 : 九.从Windows发布到CentOS的跨平台部署 - FlyLolo</title>
<link>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_9.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_9.html</guid>
<description>&lt;p&gt;　　本文聊一下如何在Windows上用VS开发并发布， 然后将其部署到CentOS上。对于我们一些常在Windows上逛的来说，CentOS用起来还真有些麻烦。MSDN官方有篇文章大概讲了一下（&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/linux-apache?tabs=aspnetcore2x&quot; target=&quot;_blank&quot;&gt;链接&lt;/a&gt;），按照MSDN上面的例子用vs创建个hellomvc项目，还是踩了好多坑，将整个过程和遇到的坑说一下，希望对有需要的朋友有所帮助。（&lt;a href=&quot;http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_0.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core系列目录&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　本文主要内容：&lt;/p&gt;
&lt;p&gt;　　1.工具准备&lt;/p&gt;
&lt;p&gt;　　2.CentOS 上安装.NET Core环境&lt;/p&gt;
&lt;p&gt;　　3.Windows上用VS发布项目&lt;/p&gt;
&lt;p&gt;　　4.项目运行测试&lt;/p&gt;
&lt;p&gt;　　5.安装并配置Apache&lt;/p&gt;
&lt;p&gt;　　6.创建service管理应用&lt;/p&gt;
&lt;p&gt;　　7.其他注意事项&lt;/p&gt;
&lt;p&gt;　　8.独立部署（SCD）&lt;/p&gt;

&lt;p&gt;　　示意图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/548134/201805/548134-20180502111537901-311287491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最近在阿里云上弄了个ECS玩，既然.NET Core跨平台了，也就选了个CentOS的系统，然后踩坑开始。&lt;/p&gt;

&lt;p&gt;　　Putty：阿里云提供了一个网页方式远程操作CentOS的命令行工具，没找到怎么粘贴，挺不好用的。这个是一个命令行的小软件，也省去了每次都要登录阿里云控制台的步骤。&lt;a href=&quot;https://the.earth.li/~sgtatham/putty/latest/w64/putty.exe&quot; target=&quot;_blank&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　FileZila：sftp工具，用于将windows上生成的发布包弄到CentOS上去。&lt;a href=&quot;https://download.filezilla-project.org/client/FileZilla_3.32.0_win64-setup_bundled.exe&quot; target=&quot;_blank&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　安装.NET Core的环境有两种方式，SDK和Runtime，区别类似java的JDK和JRE。&lt;/p&gt;
&lt;p&gt;　　官方提供的&lt;a href=&quot;https://www.microsoft.com/net/download/linux/run&quot; target=&quot;_blank&quot;&gt;下载页面&lt;/a&gt;用Build Apps 和Run Apps描述这两个， 我们不需要在CentOS上编码， 所以安装Runtime就够了。&lt;/p&gt;
&lt;p&gt;　　在页面的all downloads中找到CentOS对应的Runtime版本页面（&lt;a href=&quot;https://www.microsoft.com/net/download/linux-package-manager/centos/runtime-2.0.6&quot; target=&quot;_blank&quot;&gt;链接&lt;/a&gt;）进行安装，这里要注意一下：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;坑一：版本问题，看了一下自己的VS中项目的Microsoft.AspNetCore.All版本是2.0.6， 也就去找了Runtime的2.0.6版本， 否则容易出现某些组件在VS上的引用版本和CentOS上的环境中的版本不一致的错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过Putty链接到CentOS服务器，按照该页面上的步骤执行如下命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; sudo rpm --import https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/keys/microsoft.asc&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; sudo sh -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;echo -e &quot;[packages-microsoft-com-prod]\nname=packages-microsoft-com-prod \nbaseurl= https://packages.microsoft.com/yumrepos/microsoft-rhel7.3-prod\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &amp;gt; /etc/yum.repos.d/dotnetdev.repo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;sudo yum update
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; sudo yum install libunwind libicu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;最后还有下面关键一步我执行后部署仍会有提示某包找不到的问题，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo yum install dotnet-runtime-&lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在github上看到这样一段话：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Linux
On supported Linux systems, register the Microsoft Product feed &lt;/span&gt;&lt;span&gt;as&lt;/span&gt; described above and install dotnet-hosting-&lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; your package manager. This will also install the .NET Core Runtime and other required packages.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　后来测试了一下不安装dotnet-runtime-&lt;span data-mce-=&quot;&quot;&gt;2.0.&lt;span data-mce-=&quot;&quot;&gt;6&lt;/span&gt;&lt;/span&gt;而是安装dotnet-hosting-&lt;span data-mce-=&quot;&quot;&gt;2.0.&lt;span data-mce-=&quot;&quot;&gt;6&lt;/span&gt;&lt;/span&gt;成功。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo yum install dotnet-hosting-&lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　右键项目选择发布，默认情况下是FDD（依赖框架部署），发布生成的内容不包含依赖的框架内容，将依赖上文安装的runtime。&lt;/p&gt;
&lt;p&gt;　　在CentOS上创建个文件夹， 通过FileZila将发布的文件上传到该文件夹。&lt;/p&gt;
&lt;p&gt;　　参考创建目录命令： &lt;span class=&quot;cnblogs_code&quot;&gt;mkdir -p /&lt;span&gt;var&lt;/span&gt;/aspnetcore/hellomvc&lt;/span&gt;   &lt;/p&gt;

&lt;p&gt;　　执行命令运行上传后的项目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet /&lt;span&gt;var&lt;/span&gt;/aspnetcore/hellomvc/hellomvc.dll
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们都知道，默认情况下，项目采用的事5000端口，我运行项目时遇到了端口冲突，可能是被占用了吧，VS中修改一下Program.cs, 将端口改为常用的8080&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHost BuildWebHost(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
            .UseUrls(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://*:8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重新发布并上传，执行上面的命令成功，提示&lt;span data-ttu-id=&quot;24e91-142&quot;&gt;Kestrel&lt;/span&gt;开始监听8080端口。&lt;/p&gt;
&lt;p&gt;　　浏览器访问一下http://ip:8080 &lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/548134/201804/548134-20180428171317951-1548356450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果如上图很怪异，&lt;span&gt;坑二出现，&lt;/span&gt;按F12查看一下提示找不到xxx.css  xxx.js等，通过FileZila确认对应的css和js文件都已成功上传在指定位置。&lt;/p&gt;
&lt;p&gt;　　第一感觉是没有执行UseStaticFiles()， 确认了一下已执行。接着又怀疑是目录大小写问题，一 一排除， 均正常。&lt;/p&gt;
&lt;p&gt;　　后来先cd到发布目录，再次执行，终于成功。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /&lt;span&gt;var&lt;/span&gt;/aspnetcore/hellomvc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果如我们熟悉的下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/548134/201804/548134-20180428171329166-2060405090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　安装Apache，并配置反向代理， 将80端口请求转给上面的8080端口由&lt;span data-ttu-id=&quot;24e91-142&quot;&gt;Kestrel&lt;/span&gt;处理。&lt;/p&gt;
&lt;p&gt;　　安装并启动Apache&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo yum -&lt;span&gt;y install httpd mod_ssl
sudo systemctl start httpd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　访问一下http://ip ，页面是Apache的默认页面，安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/548134/201804/548134-20180428171340250-910561158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　配置代理，创建并打开文件hellomvc.conf：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
nano /etc/httpd/conf.d/hellomvc.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　nano是一个文本编辑工具，如果提示  nano: command not found   可能nano没有安装&lt;br/&gt;　　执行   &lt;span class=&quot;cnblogs_code&quot;&gt;yum install nano&lt;/span&gt;  命令安装即可。&lt;/p&gt;
&lt;p&gt;　　hellomvc.conf文件内写入如下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;VirtualHost *:&lt;span&gt;80&lt;/span&gt;&amp;gt;&lt;span&gt;
    ProxyPreserveHost On
    ProxyPass &lt;/span&gt;/ http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8080/&lt;/span&gt;
    ProxyPassReverse / http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8080/&lt;/span&gt;
&lt;span&gt;    ServerName www.example.com
    ServerAlias &lt;/span&gt;*&lt;span&gt;.example.com
    ErrorLog ${APACHE_LOG_DIR}hellomvc&lt;/span&gt;-&lt;span&gt;error.log
    CustomLog ${APACHE_LOG_DIR}hellomvc&lt;/span&gt;-&lt;span&gt;access.log common
&lt;/span&gt;&amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重启Apache服务并将该服务设置为自动启动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo systemctl restart httpd
sudo systemctl enable httpd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再次通过 &lt;span class=&quot;cnblogs_code&quot;&gt;dotnet /&lt;span&gt;var&lt;/span&gt;/aspnetcore/hellomvc/hellomvc.dll&lt;/span&gt; 将项目运行起来后，访问 &lt;span class=&quot;cnblogs_code&quot;&gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ip &lt;/span&gt;&lt;/span&gt; 或者 &lt;span class=&quot;cnblogs_code&quot;&gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ip:8080&lt;/span&gt;&lt;/span&gt; 均访问正常。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;到现在可能有人比较疑惑， 既然之前的项目已经可以正常访问了，为什么还要用Apache？在项目中直接指定监听80端口不就已经OK？   因为这样做该服务直接占用了80端口， 但有些情况下，我们需要将来自不同域名的访问指定到不同的端口处理，例如可以将a.com的请求指定到8080，将b.com的请求指定到8081.  当然， 如果没有这样的需求，直接用&lt;span data-ttu-id=&quot;24e91-142&quot;&gt;Kestrel&lt;/span&gt;做服务而不用反向代理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另外每次通过命令 &lt;span class=&quot;cnblogs_code&quot;&gt;dotnet xxx.dll&lt;/span&gt; 的方式来启动也不是个很好的体验，我们可以创建个service来管理它， 这也有点向windows的service。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　再次用nano创建文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo nano /etc/systemd/system/kestrel-hellomvc.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　文件内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Unit]
Description&lt;/span&gt;=Example .NET Web API App running on CentOS &lt;span&gt;7&lt;/span&gt;&lt;span&gt;

[Service]
WorkingDirectory&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/aspnetcore/&lt;span&gt;hellomvc
ExecStart&lt;/span&gt;=/usr/local/bin/dotnet /&lt;span&gt;var&lt;/span&gt;/aspnetcore/hellomvc/&lt;span&gt;hellomvc.dll
Restart&lt;/span&gt;=&lt;span&gt;always
# Restart service after &lt;/span&gt;&lt;span&gt;10&lt;/span&gt; seconds &lt;span&gt;if&lt;/span&gt;&lt;span&gt; dotnet service crashes
RestartSec&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
SyslogIdentifier&lt;/span&gt;=dotnet-&lt;span&gt;example
User&lt;/span&gt;=&lt;span&gt;apache
Environment&lt;/span&gt;=ASPNETCORE_ENVIRONMENT=&lt;span&gt;Production 

[Install]
WantedBy&lt;/span&gt;=multi-user.target
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　保存并启动服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl enable kestrel-&lt;span&gt;hellomvc.service
systemctl start kestrel&lt;/span&gt;-hellomvc.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看是否成功：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl status kestrel-hellomvc.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在此处我遇到了问题，提示出错，..........(code=exited, status=203/EXEC)..............  kestrel-hellomvc.service failed。坑三出现，又是各种搜索，后来发现msdn中提供的上面的kestrel-hellomvc.service文件内容中的 &lt;span class=&quot;cnblogs_code&quot;&gt;ExecStart=/usr/local/bin/dotnet&lt;/span&gt; 在我的CentOS系统中不存在，通过 &lt;span class=&quot;cnblogs_code&quot;&gt;which dotnet&lt;/span&gt; 查看我的系统中是在 &lt;span class=&quot;cnblogs_code&quot;&gt;/usr/bin/dotnet&lt;/span&gt; ，修改kestrel-hellomvc.service重新执行 &lt;span class=&quot;cnblogs_code&quot;&gt;systemctl start kestrel-hellomvc.service&lt;/span&gt; 提示成功。注意修改该文件后会提示先执行 &lt;span class=&quot;cnblogs_code&quot;&gt;systemctl daemon-reload&lt;/span&gt; 重新加载。&lt;/p&gt;
&lt;p&gt;　　至此，主要工作均已完成。&lt;/p&gt;

&lt;h2&gt;　　A.kestrel-hellomvc.service中的&lt;span data-mce-=&quot;&quot;&gt;User=&lt;span data-mce-=&quot;&quot;&gt;apache&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;　　　　在安装Apache之前，通过 &lt;span class=&quot;cnblogs_code&quot;&gt;dotnet /&lt;span&gt;var&lt;/span&gt;/aspnetcore/hellomvc/hellomvc.dll&lt;/span&gt; 已经可以将项目运行起来了， 那时候就想先创建Service，因为觉得这与Apache无关， 结果service总是启动失败，后来才注意到了这个&lt;span data-mce-=&quot;&quot;&gt;User=&lt;span data-mce-=&quot;&quot;&gt;apache&lt;/span&gt;&lt;/span&gt;，这里要求这个User存在并且拥有相应的权限。由于对CentOS不熟悉，这点也绕了好久。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;B.启用&lt;/span&gt;&lt;/span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;ForwardedHeaders中间件&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;　　　　由于采用了反向代理，需要启用ForwardedHeaders中间件转发，在Startup的Configure中添加如下代码，注意UseForwardedHeaders要用在UseAuthentication之前。（&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;MSDN上的详细说明&lt;/a&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
app.UseForwardedHeaders(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ForwardedHeadersOptions
{
    ForwardedHeaders &lt;/span&gt;= ForwardedHeaders.XForwardedFor |&lt;span&gt; ForwardedHeaders.XForwardedProto
});

app.UseAuthentication();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 　　下面说一下独立部署（包含依赖项）的发布方式。&lt;/p&gt;
&lt;p&gt;　　在VS中右击项目文件，注意是 &lt;span class=&quot;cnblogs_code&quot;&gt;.csproj&lt;/span&gt; 而不是 &lt;span class=&quot;cnblogs_code&quot;&gt;.sln&lt;/span&gt; ，选择编辑xxx.csproj，打开该文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;Project Sdk=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.NET.Sdk.Web&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp2.&lt;span&gt;0&lt;/span&gt;&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.AspNetCore.All&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.0.6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;DotNetCliToolReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.VisualStudio.Web.CodeGeneration.Tools&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.0.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在PropertyGroup中添加RuntimeIdentifiers标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp2.&lt;span&gt;0&lt;/span&gt;&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;RuntimeIdentifiers&amp;gt;win10-x64;centos.&lt;span&gt;7&lt;/span&gt;-x64&amp;lt;/RuntimeIdentifiers&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;win10-x64;centos.&lt;span&gt;7&lt;/span&gt;-x64&lt;/span&gt; 叫做.NET Core RID， 是一些固定的内容， 具体可选项见&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/core/rid-catalog&quot; target=&quot;_blank&quot;&gt;.NET Core RID的目录&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　当我们再次发布的时候，在发布设置的目标运行时中就出现了这两个选项，我们可以根据需要部署的系统选择对应的RID后进行发布。&lt;/p&gt;
</description>
<pubDate>Wed, 02 May 2018 21:31:00 +0000</pubDate>
<dc:creator>FlyLolo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_9.html</dc:identifier>
</item>
<item>
<title>CRM客户关系管理系统（十） - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/8981691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/8981691.html</guid>
<description>&lt;h2&gt;第十章、kingadmin+admin+actions功能开发&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;10.1. django admin的action&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180502180231966-416306691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 可以自己写个函数执行批量操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;crm/admin.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180502180907667-1062348400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;后台admin action就会多一个change status，可以修改status状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180502180704179-238488243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 执行后&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180502181004570-1767383701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;10.2.kingadmin actions功能开发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）crm/kingadmin.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180502202818374-323087776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）kingamdin/admin_base.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseKingAdmin(object):

    list_display &lt;/span&gt;=&lt;span&gt; []
    list_filter &lt;/span&gt;=&lt;span&gt; []
    search_fields &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只读&lt;/span&gt;
    readonly_fields =&lt;span&gt; []
    filter_horizontal &lt;/span&gt;=&lt;span&gt; []
    list_per_page &lt;/span&gt;= 5&lt;span&gt;
    actions &lt;/span&gt;= []
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）table_obj_list.html&lt;/p&gt;
&lt;p&gt;加个action框+&quot;单选/全选/全部取消&quot;+执行按钮&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;row&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-lg-3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;action&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option value=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;-------&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% for action in admin_class.actions %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{{ action }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ action }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% endfor %}
                    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-lg-2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;执行&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-primary&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;padding: 6px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;给所有客户信息添加一个可选框&lt;/p&gt;
&lt;p&gt;th用来全选&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180502210738061-1915692685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个td都要加&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180502210835702-2083567029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;js代码（可以全选/取消全选）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SelectALLObjs(ele) {

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($(ele).prop('checked'&lt;span&gt;)){
        $(&lt;/span&gt;'input[row-select]').prop('checked',&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)

    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
         $(&lt;/span&gt;'input[row-select]').prop('checked',&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
    }
}

&lt;/span&gt;&amp;lt;/script&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180502203833445-1802165113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;执行action&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;table_obj_list.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180502220905191-352988255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; js代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ActionCheck(ele){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; selected_action = $(&quot;select[name='action']&quot;&lt;span&gt;).val();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; selected_objs = $(&quot;input[row-select]&quot;).filter(&quot;:checked&quot;&lt;span&gt;);
    console.log($(&lt;/span&gt;&quot;select[name='action']&quot;&lt;span&gt;).val())
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;selected_action){
        alert(&lt;/span&gt;&quot;no action selected!&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (selected_objs.length == 0&lt;span&gt; ){
        alert(&lt;/span&gt;&quot;no object selected!&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成一个标签,放到form里&lt;/span&gt;

        &lt;span&gt;var&lt;/span&gt; selected_ids =&lt;span&gt; [];
        $.each(selected_objs,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            console.log($(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) );
            selected_ids.push($(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).val())
        })
        console.log(selected_ids)
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; input_ele = &quot;&amp;lt;input type='hidden' name='selected_ids' value=&quot; + JSON.stringify(selected_ids) + &quot;&amp;gt;&quot;&lt;span&gt;

        $(ele).append(input_ele);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后台kingadmin/views.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180502221028706-2136645959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 现在就可以批量执行action操作了。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;10.3.添加默认的delete action&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; （1）kingadmin/admin_base.html&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;添加一个default_actions = ['delete_selected_objs'&lt;span&gt;]，不能直接加载actions里面，因为子类会覆盖父类的actions&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;利用__init__方法，把defautl_actions里面的值添加到actions里面。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; kingadmin/admin_base.py&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseKingAdmin(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.actions.extend(self.default_actions)

    list_display &lt;/span&gt;=&lt;span&gt; []
    list_filter &lt;/span&gt;=&lt;span&gt; []
    search_fields &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只读&lt;/span&gt;
    readonly_fields =&lt;span&gt; []
    filter_horizontal &lt;/span&gt;=&lt;span&gt; []
    list_per_page &lt;/span&gt;= 5&lt;span&gt;
    default_actions &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;delete_selected_objs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    actions &lt;/span&gt;=&lt;span&gt; []


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; delete_selected_objs(self,request,querysets):

        querysets_ids &lt;/span&gt;= json.dumps([i.id &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; querysets])

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kingadmin/table_obj_delete.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin_class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:self,      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;self就是admin_class&lt;/span&gt;
                                                                 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;objs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:querysets,
                                                                 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;querysets_ids&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:querysets_ids
                                                                 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）table_obj_delete.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180503021627005-646011405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （3）kingadmin/views.py&lt;/p&gt;
&lt;p&gt; 在views中要对post进行判断（因为“执行”和“确认删除” 都是post动作，同时存在在def table_obj_list里面）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180503021700798-1115852151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180503022037663-1998115458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180503022054847-1910113803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 02 May 2018 16:36:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/8981691.html</dc:identifier>
</item>
<item>
<title>pandas数据处理基础——筛选指定行或者指定列的数据 - gangandi</title>
<link>http://www.cnblogs.com/gangandimami/p/8983323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gangandimami/p/8983323.html</guid>
<description>&lt;p&gt;&lt;span&gt;        pandas主要的两个数据结构是：series（相当于一行或一列数据机构）和DataFrame（相当于多行多列的一个表格数据机构）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        本文为了方便理解会与excel或者sql操作行或列来进行联想类比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;重新索引：reindex和ix&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上一篇中介绍过数据读取后默认的行索引是0,1，2,3...这样的顺序号。列索引相当于字段名(即第一行数据)，这里重新索引意思就是可以将默认的索引重新修改成自己想要的样子。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1&lt;/span&gt; &lt;span&gt;Series&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比方说：data=Series([4,5,6],index=['a','b','c'])，行索引为a,b,c。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们用&lt;/span&gt;&lt;span&gt;data.reindex(['a','c','d','e'])修改索引后则输出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000004576-927036888.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以理解成我们用reindex设了索引后，根据索引去原来data里面匹配对应的值，没匹配上的就是NaN。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2&lt;/span&gt; &lt;span&gt;DataFrame&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）行索引修改：DataFrame行索引同Series&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）列索引修改：列索引用reindex(columns=['m1','m2','m3']),用参数columns来指定对列索引进行修改。修改逻辑类似行索引，也是相当于用新列索引去匹配原来的数据，没匹配上的置NaN&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000101515-1612583007.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（3）&lt;/span&gt;&lt;span&gt;同时对行和列索引进行修改可以用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000209147-598167830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;丢弃指定轴上的列（通俗的说法就是删除行或者列）:drop&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过索引进行选择删除哪一行或者哪一列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;data.drop(['a','c'])  相当于delete table a where xid='a' or xid='c'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;data.drop('m1',axis=1)相当于delete table a where yid='m1'&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;strong&gt;选取和过滤（通俗的说就是sql中按照条件筛选查询）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;python中因为有行列索引，在做数据的筛选会比较方便&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;3.1 Series&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（1）按照行索引进行选择如&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000312968-300346171.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;obj['b']相当于select * from tb where xid='b'&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;obj['b','a','c']相当于select * from tb where xid in ('a','b','c')，且结果按照b ,a ,c 的顺序排列后进行展示，这是与sql的区别&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;obj[0:1]和obj['a':'b']的区别如下：      &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mce-=&quot;&quot;&gt;          &lt;span data-mce-=&quot;&quot;&gt;#前者是不包含末端，后者是包含了末端&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000333765-228208218.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（2）按照值的大小进行筛选obj[obj&amp;gt;-0.6]相当于在obj数据中找出值比-0.6大的记录进行展示&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000450758-216616208.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;3.2 DataFrame&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（1）&lt;/span&gt;&lt;span&gt;选择单行用ix或者xs：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;         如筛选索引为b的那条行记录用以下三种方式&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000506708-23957667.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（2）&lt;/span&gt;&lt;span&gt;选择多行:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;       筛选索引为a,b的两条行记录的方式&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000520096-856036518.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;     #以上不能直接写成data[['a','b']]&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;      data[0:2]表示从第一行到第二行的记录。第一行默认从0开始数，不包含末端的2。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（3）&lt;/span&gt;&lt;span&gt;选择单列&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;        筛选m1列的所有行记录数据&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000537537-1612361363.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（4）选择多列&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;       筛选m1,m3两个列，所有行记录的数据&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000549562-1357965100.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;       ix[:,['m1','m2']]前面的：表示所有的行都筛选进来。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（5）&lt;/span&gt;&lt;span&gt;根据值的大小条件筛选行或者列&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;         如筛选出某一列值大于4的所有记录相当于&lt;/span&gt;&lt;span&gt;select * from tb where 列名&amp;gt;4&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000607367-1668452410.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（6）&lt;/span&gt;&lt;span&gt;如果筛选某列值大于4的所有记录，且只需展示部分列的情况时&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1368336/201805/1368336-20180503000623201-759438927.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;行用条件进行筛选，列用[0,2]筛选第一列和第三列的数据 &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 May 2018 16:16:00 +0000</pubDate>
<dc:creator>gangandi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gangandimami/p/8983323.html</dc:identifier>
</item>
<item>
<title>十分钟搞定mongodb副本集 - 凝眸v</title>
<link>http://www.cnblogs.com/zj-blog/p/8983324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zj-blog/p/8983324.html</guid>
<description>&lt;p&gt;                                                                   &lt;strong&gt;&lt;span&gt;mongodb副本集配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       最近项目中用到了mongodb,由于是用mongodb来记录一些程序的日志信息和日常的统计,为了增加应用的可靠性,一直在找mongodb集群的一些资料,下面是对最近做的一个小案例过程进行了一下总结记录。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.先介绍一下副本集是什么?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      副本集(复制)是将数据同步到多台服务器的过程,提供的数据的冗余备份,并且在多个服务器上存储数据的副本,提高了数据的可用性,也降低了数据的损坏风险,提高的安全性,并且可以实现故障的自动的切换恢复。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.副本集的组成结构是什么?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一个副本集的最小结构有用三个成员。一个三个成员的副本集可以有三个成员保存数据，或者有两个保存,一个为监督者&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;即一个主节点(Primary),一个从节点(Secondary),一个监督者(Arbiter),监督者不存储数据,监督者的作用主要是当主节点不可用时从从节点中选中主节点&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;如下图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                        &lt;/strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754814/201805/754814-20180502234142564-1930793631.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三.下面我们就按步骤小试牛刀一下?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一步：&lt;/p&gt;
&lt;p&gt;      我们在本机的1001、1002和1003三个端口上启动三个不同的Mongodb实例；                &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
  mongod --port 1001 --dbpath F:/mongos/mongodb1/data  --logpath  F:/mongos/mongodb1/log/mongodb.log  --pidfilepath F:/mongos/mongodb1/mongodb1.pid  &lt;br/&gt;--replSet  test --logappend --directoryperdb
  mongod --port 1002 --dbpath F:/mongos/mongodb2/data --logpath F:/mongos/mongodb2/log/mongodb.log  --pidfilepath F:/mongos/mongodb2/mongodb2.pid &lt;br/&gt;--replSet test --logappend --directoryperdb
  mongod --port 1003 --dbpath F:/mongos/mongodb3/data --logpath F:/mongos/mongodb3/log/mongodb.log  --pidfilepath F:/mongos/mongodb3/mongodb3.pid &lt;br/&gt;--replSet test --logappend   --directoryperdb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步：&lt;/p&gt;
&lt;p&gt;       登录到1001实例上编写指令，将三个不同的Mongodb实例结合在一起形成一个完整的副本集；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
cd F:\mongos\mongodb1\bin
mongo 127.0.0.1:1001
use admin
config_test={_id:&quot;test&quot;,members:[
    {_id:0,host:&quot;127.0.0.1:1001&quot;,priority:1},
    {_id:1,host:&quot;127.0.0.1:1002&quot;,priority:1},
    {_id:2,host:&quot;127.0.0.1:1003&quot;,arbiterOnly:true},
]};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;到这里，members中可以包含多个值，这里列举的就是刚才启动的三个Mongodb实例，并且通过_id字段给副本集起了名字test。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第三步：&lt;/p&gt;
&lt;p&gt;     通过执行下面的命令初始化副本集。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
rs.initiate(config_test);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    下面的命令可以查看副本集的状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
 rs.status();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里搭建起一个由三个Mongodb实例构成的名称为test的副本集了。&lt;/p&gt;
&lt;p&gt;副本集现在搭建起来了，那么这个副本集能不能解决我们上面主从模式的两个问题呢？&lt;/p&gt;
&lt;p&gt;我们首先从第一个问题开始看，我们将1001端口的Mongodb服务器给关闭，然后我们使用rs.status()命令来查看下，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754814/201805/754814-20180502131520196-1137740035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从返回包信息中，可以看到关闭1001端口后，在副本集节点的状态中该节点是不可达的，重新选取产生的主节点是1002端口上启动的Mongodb实例,选举过程是这样的,当主节点挂掉之后，其他节点可以发起选举行为，只要在选举过程中某个节点得到副本集节点数一半以上的选票并且没有节点投反对票，那么该节点就可以成为主节点。(参数注释请看开始位置)在1001端口上的Mongodb实例挂掉之后,1002成为了新的主节点，可以实现故障自动切换。&lt;/p&gt;
&lt;p&gt;至于第二个问题，那就是主节点负责所有的读写操作造成主节点压力较大，那么在副本集中如何解决这个问题了呢？正常情况下，我们在Java中访问副本集是这样的，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; TestMongoDBReplSet {   
    public static void&lt;span&gt; main(String[] args)  {  
        try&lt;span&gt; {   
            List&amp;lt;ServerAddress&amp;gt; addresses = new ArrayList&amp;lt;ServerAddress&amp;gt;&lt;span&gt;();    
            ServerAddress address1 = new ServerAddress(&quot;127.0.0.1&quot;,1001&lt;span&gt;);   
            ServerAddress address2 = new ServerAddress(&quot;127.0.0.1&quot;,1002&lt;span&gt;);   
            ServerAddress address3 = new ServerAddress(&quot;127.0.0.1&quot;,1003&lt;span&gt;);   
            addresses.add(address1);    
            addresses.add(address2);   
            addresses.add(address3);   
            MongoClient client = new&lt;span&gt; MongoClient(addresses);   
            DB db = client.getDB( &quot;testdb&quot;&lt;span&gt;);   
            DBCollection coll = db.getCollection( &quot;testdb&quot;&lt;span&gt;);   
            // 插入   
            BasicDBObject object = new&lt;span&gt; BasicDBObject();    
            object.append(&quot;userid&quot;,&quot;001&quot;&lt;span&gt;);   
            coll.insert(object);   
            DBCursor dbCursor =&lt;span&gt; coll.find();   
            while&lt;span&gt; (dbCursor.hasNext()) {   
                DBObject dbObject =&lt;span&gt; dbCursor.next();    
                System. out.println(dbObject.toString());   
            }   
        } catch&lt;span&gt; (Exception e) {   
            e.printStackTrace();    
        }   
    }   
} &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是上面不能做到在副本集中读写压力分散,在代码层面我们可以设置再访问副本集的时候只从副节点上读取数据。为了在副本集上实现读写分离，我们需要实现以下两步：&lt;/p&gt;
&lt;p&gt;（1）在副本节点上设置setSlaveOk;&lt;/p&gt;
&lt;p&gt;（2）代码层面，在读操作过程中设置从副本节点读取数据，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class TestMongoDBReplSet {   
    public static void main(String[] args)  {  
        try {   
            List&amp;lt;ServerAddress&amp;gt; addresses = new ArrayList&amp;lt;ServerAddress&amp;gt;();    
            ServerAddress address1 = new ServerAddress(&quot;127.0.0.1&quot;,1001);   
            ServerAddress address2 = new ServerAddress(&quot;127.0.0.1&quot;,1002);   
            ServerAddress address3 = new ServerAddress(&quot;127.0.0.1&quot;,1003);   
            addresses.add(address1);    
            addresses.add(address2);   
            addresses.add(address3);   
            MongoClient client = new MongoClient(addresses);   
            DB db = client.getDB( &quot;test&quot;);   
            DBCollection coll = db.getCollection( &quot;test&quot;);                
            BasicDBObject object = new BasicDBObject();    
            object.append(&quot;userid&quot;,&quot;001&quot;);   
            ReadPreference preference = ReadPreference.secondary();    
            DBObject dbObject = coll.findOne(object, null , preference);    
            System. out .println(dbObject);    
        } catch (Exception e) {   
            e.printStackTrace();    
        }   
    }   
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上面代码中的读参数除了secondary以外,还有其他几个参数可以使用，他们的含义分别如下所示：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  primaryPreferred:大部分从主节点上读取数据,只有主节点不可用时从secondary节点读取数据。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt; &lt;span&gt;secondary:只从secondary节点上进行读取操作，存在的问题是secondary节点的数据会比primary节点数据“旧”。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt; &lt;span&gt;secondaryPreferred:优先从secondary节点进行读取操作，secondary节点不可用时从主节点读取数据； &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  nearest:不管是主节点、secondary节点，从网络延迟最低的节点上读取数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四.最后对使用到的参数进行了一下总结方便以后记忆和复习?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  dbpath：数据存放目录&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  logpath：日志存放路径&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  pidfilepath：进程文件，方便停止mongodb&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; directoryperdb：为每一个数据库按照数据库名建立文件夹存放&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; logappend：以追加的方式记录日志&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; replSet：replica set的名字&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; bind_ip：mongodb所绑定的ip地址&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; port：mongodb进程所使用的端口号，默认为27017&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; oplogSize：mongodb操作日志文件的最大大小。单位为Mb，默认为硬盘剩余空间的5%&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; fork：以后台方式运行进程&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; noprealloc：不预先分配存储&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; priority:优先级,返回时0-100,数组越大,优先级越高,默认是1,0不进行选举&lt;/p&gt;
</description>
<pubDate>Wed, 02 May 2018 16:16:00 +0000</pubDate>
<dc:creator>凝眸v</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zj-blog/p/8983324.html</dc:identifier>
</item>
<item>
<title>深度学习-conv卷积 - 康行天下</title>
<link>http://www.cnblogs.com/makefile/p/conv.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/makefile/p/conv.html</guid>
<description>&lt;h2 id=&quot;过滤器卷积核&quot;&gt;过滤器(卷积核)&lt;/h2&gt;
&lt;p&gt;传统的图像过滤器算子有以下几种:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;blur&lt;/strong&gt; kernel：减少相邻像素的差异，使图像变平滑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sobel&lt;/strong&gt;：显示相邻元素在特定方向上的差异。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sharpen&lt;/strong&gt; ：强化相邻像素的差异，使图片看起来更生动。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;outline&lt;/strong&gt;：也称为edge kernel，相邻像素相似亮度的像素点设成黑，有较大差异的设为白。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多可参考 &lt;a href=&quot;http://setosa.io/ev/image-kernels/&quot;&gt;image-kernels&lt;/a&gt; 在线演示不同的卷积过滤器。&lt;/p&gt;
&lt;h2 id=&quot;cnn-卷积层&quot;&gt;CNN 卷积层&lt;/h2&gt;
&lt;p&gt;CNN做的事情不是提前决定好过滤器，而是把过滤器当成参数不断调整学习，学出合适的过滤器。卷积网络的第一层执行的通常都是边缘检测，后面的层得到的都是更抽象的特征。CNN 卷积层的一个重要特性是权值共享.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;权值共享&lt;/strong&gt;:不同的感受域共享同一权值,因此也称为filter,能够大大减少权重的数量(所占的内存),这通常是有效的,因为filter过滤某一特征与具体的空间位置无关.但无独有偶,人脸图片通常是中心化的,即人的脑袋比较靠近中间,如此可以看出位置信息是有用的.对于这种情形我们可以取消权值共享机制,此时称这一层为&lt;strong&gt;Locally-Connected Layer&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;有时候提到filter的长和宽大小而不提到深度,则深度是输入数据的整个深度(因此1x1的卷积核也是有意义的).如前一层的输入是 [16x16x20],感知域大小是3x3,那么卷积层中每个神经元将有3x3x20 = 180个到前一层的连接.&lt;br/&gt;如果指明了深度,如96,那么卷积层中每个神经元到前一层有3x3x96个连接,96层连接到同一块区域,但是权重不相同.(注意有时候还以RGB三通道这三层作为一个整体,因此还要乘上3).&lt;/p&gt;
&lt;h3 id=&quot;小卷积核&quot;&gt;小卷积核&lt;/h3&gt;
&lt;p&gt;现在流行的网络结构设计多遵循小卷积核的设计原则, &lt;strong&gt;小卷积核的优势&lt;/strong&gt;:&lt;br/&gt;3个3x3的卷积核的累加相当于1个7x7的卷积核,但是参数更少,计算量更小,有更多的非线性层计算.还可以通过加入1x1的&quot;bottleneck&quot;卷积核进一步减少计算(GoogLeNet等大量运用这种方式加深层次).如输入&lt;code&gt;HxWxC&lt;/code&gt;经过下列步骤输出的维数不变:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \require{AMScd} \begin{CD} H\times W\times C @&amp;gt;{\text{C/2 x Conv1x1}}&amp;gt;&amp;gt; H\times W\times C/2 \\ @. @V {\text{C/2 x Conv3x3}} VV \\ H\times W\times C @&amp;lt; \text{C x Conv1x1} &amp;lt;&amp;lt; H\times W\times C/2 \end{CD} \]&lt;/span&gt;&lt;br/&gt;然而上述步骤中仍然使用了3x3卷积核,可以将其转成1x3与3x1的连接.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dilated convolutions&lt;/strong&gt;.卷积核在输入上滑动时可以让步长大到不同的感知域之间有间隙,这个间隙作为超参数(dilation膨胀).其作用相当于减少了一些卷积等层,更快地获取输入的空间信息.&lt;/p&gt;
&lt;h2 id=&quot;卷积实现&quot;&gt;卷积实现&lt;/h2&gt;
&lt;p&gt;卷积有三种主流的计算方式：转化为矩阵乘，winograd，和FFT。&lt;/p&gt;
&lt;p&gt;在现代的 DL 框架中对卷积计算通常采用矩阵乘法的方式,使用&lt;strong&gt;im2col&lt;/strong&gt;操作将输入数据与权重展开成二维矩阵(使得图像矩阵和卷积核能够直接相乘, 转换的反向操作为col2im),运用 &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt; API进行高效计算,缺点是占用许多内存.这种思想也可以用在pooling操作中.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有广泛使用FFT的原因&lt;/strong&gt;:&lt;br/&gt;FFT只有在卷积核比较大的时候才有明显速度优势。但是CNN的卷积核一般都小于5，所以深度学习中一般不用FFT。FFT卷积没有广泛应用的原因是因为通用平台上有更合适的Winograd卷积的存在，而专用平台上直接降低运算精度是更合适的方案。不过，现在CNN里面越来越多的1×1卷积和depthwise卷积被加入，Winograd卷积的价值也越来越小了。&lt;/p&gt;
&lt;p&gt;下边简单介绍下快速傅里叶变换.&lt;/p&gt;
&lt;h3 id=&quot;卷积定理convolution-theorem-convconv2&quot;&gt;卷积定理(convolution theorem) &lt;/h3&gt;
&lt;p&gt;快速傅里叶变换被称为20世纪最重要的算法之一, 一个因素就是卷积定理.&lt;br/&gt;傅里叶变换可以看作是对图像或者音频等数据的重新组织,它将时域和空域上的复杂卷积对应到了频域中的元素间简单的乘积。&lt;br/&gt;一维连续域上两个连续函数的卷积:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ h(x)=f\bigotimes g=\int_{-\infty}^\infty f(x-u)g(u)du=\mathcal F^{-1}(\sqrt{2\pi}\mathcal F[f]\mathcal F[g]) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由卷积定理可以知道,两个矩阵卷积的结果等价于两个矩阵经过傅里叶变换(&lt;span class=&quot;math inline&quot;&gt;\(\mathcal F\)&lt;/span&gt;),进行元素级别相乘,再经过傅里叶逆变换(&lt;span class=&quot;math inline&quot;&gt;\(\mathcal F^{-1}\)&lt;/span&gt;). &lt;span class=&quot;math inline&quot;&gt;\(\sqrt{2\pi}\)&lt;/span&gt;是一个normalizer.&lt;/p&gt;
&lt;p&gt;二维离散域（图像）上的卷积:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align} \text{feature map}=&amp;amp;\text{intput}\bigotimes\text{kernel} \\ =&amp;amp;\sum_{y=0}^M \sum_{x=0}^N \text{intput}(x-a,y-b)\cdot \text{kernel}(x,y) \\ =&amp;amp;\mathcal F^{-1}(\sqrt{2\pi}\mathcal F[\text{intput}]\mathcal F[\text{kernel}]) \end{align} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;快速傅里叶变换是一种将时域和空域中的数据转换到频域上去的算法。傅里叶变换用一些正弦和余弦波的和来表示原函数。必须注意的是，傅里叶变换一般涉及到复数，也就是说一个实数被变换为一个具有实部和虚部的复数。通常虚部只在一部分领域有用，比如将频域变换回到时域和空域上.&lt;br/&gt;傅里叶变换图示&lt;br/&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/large/006Fmjmcly1fdwm3am0yag30dw0b4tji.gif&quot; alt=&quot;fft&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从傅里叶变换中可以看出方向信息:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/606386/201805/606386-20180502234430672-1909057685.png&quot; alt=&quot;FFT-orientation&quot;/&gt;&lt;br/&gt;Images by &lt;a href=&quot;http://timdettmers.com/2015/03/26/convolution-deep-learning/#fisher1998&quot;&gt;Fisher &amp;amp; Koryllos (1998)&lt;/a&gt;. &lt;a href=&quot;http://homepages.inf.ed.ac.uk/rbf/HIPR2/fourier.htm&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;caffe中的卷积实现&quot;&gt;caffe中的卷积实现&lt;/h3&gt;
&lt;p&gt;卷积操作示意图如下，输入图片的维数为[c0,h0,w0]；卷积核的维数为[c1,c0,hk,wk]，其中c0在图中没有表示出来，一个卷积核可以看成由c1个维数为[c0,hk,wk]的三维滤波器组成,输出特征的维数为[c1,h1,w1]&lt;br/&gt;&lt;img src=&quot;https://leanote.com/api/file/getImage?fileId=59cf7426ab644151a2001c54&quot; alt=&quot;conv&quot;/&gt;&lt;br/&gt;转成二维矩阵乘法的高效计算：&lt;br/&gt;&lt;img src=&quot;https://leanote.com/api/file/getImage?fileId=59cf7426ab644151a2001c56&quot; alt=&quot;im2col&quot;/&gt;&lt;br/&gt;更详细的im2col图示：&lt;br/&gt;&lt;img src=&quot;https://leanote.com/api/file/getImage?fileId=59cf7426ab644151a2001c55&quot; alt=&quot;im2col-detail&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 02 May 2018 15:55:00 +0000</pubDate>
<dc:creator>康行天下</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/makefile/p/conv.html</dc:identifier>
</item>
<item>
<title>工作中常用Git指令操作 - 盼先生</title>
<link>http://www.cnblogs.com/dpflying/p/8975867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dpflying/p/8975867.html</guid>
<description>&lt;p&gt;　　前阵子有几天好不顺，可谓是喝水都呛着，更何况被Git给呛着了，还不轻，哈哈。所以打算总结一下自己在工作使用到Git相关的东西以及和大家探讨使用GIt的心得体会。于是，关于Git的的文章也就呼之欲出，总结外加研究一些难啃的指令、Git工作流，后期会慢慢更新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/716120/201805/716120-20180501110258507-949232484.png&quot; alt=&quot;Git命令&quot; width=&quot;586&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;一、GIt的alias&lt;/h2&gt;
&lt;p&gt;　　1.先来说说自己比较喜欢用的简写指令，可根据个人自行配置，下图是本人自己工作常用的git简写：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/716120/201805/716120-20180501110822215-696149316.png&quot; alt=&quot;&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.像这样使用:  git st ---查看文件提交状态 &lt;/p&gt;
&lt;p&gt;　　　　　　　　  git ci -m &quot;提交信息说明&quot; ---提交&lt;/p&gt;
&lt;p&gt;　　　　　　　　  git br -d branchName ---删除本地分支&lt;/p&gt;
&lt;p&gt;　　　　　　　　  git co -b branchName ---切除新分支并跳到该分支上&lt;/p&gt;
&lt;p&gt;　　等一系列简写操作，不用敲一大堆指令出来，高效。&lt;span&gt;虽然看起来没什么，但是工作中非常频繁的使用这些操作，如果能用简写的话其实能提高我们的办公效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 （PS: 但是平时也看到过一些有工作经历的同事还是使用git checkout ,git status, git branch -d等等，我这就不知道其中的原因了）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　欢迎补充自己常用的简写指令，大家相互补充。&lt;/p&gt;
&lt;h2&gt;二、常用指令描述&lt;/h2&gt;
&lt;h3&gt; 　　1.基本开发流程&lt;/h3&gt;
&lt;p&gt;　　  以下是简写：&lt;span&gt;st = status, co = checkout, br = branch, ci = commit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　git co -b BranchName  --切出一个新分支，进入开发&lt;/p&gt;
&lt;p&gt;　　　　git st  --查看当前分支的文件修改状态&lt;/p&gt;
&lt;p&gt;　　　　git diff  --查看哪些文件被修改了哪些部分，指令后面可以接具体的文件路径&lt;/p&gt;
&lt;p&gt;　　　　git add “具体文件路径”  --将文件添加到暂存区&lt;/p&gt;
&lt;p&gt;　　　　git add .  --此时使用点“.”表示将所有的修改的文件添加到暂存区，方便快捷。&lt;/p&gt;
&lt;p&gt;　　　　git ci -m &quot;修改说明&quot;  --提交commit&lt;/p&gt;
&lt;p&gt;　　　　git pull origin BranchName  --拉取远程分支代码到当前分支上，如果出现冲突，解决即可。&lt;/p&gt;
&lt;p&gt;　　　　git push origin BranchName  --将本地分支代码推到远程的对应分支。（PS: 如果有冲突解决后需要重新add和commit，再push）&lt;/p&gt;
&lt;p&gt;　　　　以上就是在开发过程中自己常用的流程&lt;span&gt;：&lt;span&gt;切分支进入开发-&amp;gt; 开发完成后查看修改文件状态-&amp;gt; diff对比修改了文件的哪些部分-&amp;gt; 提交commit-&amp;gt;推到远程分支&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   解释：a. 如果功能需要几天才能开发完成，可以分几次commit，可以防止开发的代码被自己不小心改动；git pull也可以用git fetch 和git merge 来代替。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　b. 也可以使用git stash和git stash apply来暂存已修改的代码，从而不用为了执行git pull而去执行add和commit。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　c. 当多人协同开发的时候，同事可能每天都会往该远程开发分支提交代码；所以建议每天最好有1次以上的git pull操作，这样不会到后期合并的时候冲突太多。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　&lt;/span&gt;2.基本git操作&lt;/h3&gt;
&lt;p&gt;　　　　由于Git的指令用于强大和复杂，在这里介绍的就是自己一些常用的操作，如果你有自己更好的操作方法，欢迎补充完善。&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;新建和切换分支&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　git co -b BranchName  --新建分支并切换到该分支上&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;git br -d  BranchName&lt;/span&gt;  --删除某本地分支 (PS: 当“-d”换成&quot;-D&quot;表示强制删除)&lt;/p&gt;
&lt;p&gt;　　　　　git co -b branchName origin/remoteBranch  --新建切换到该分支上，并关联远程remoteBranch分支。（自己比较常用的操作）&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;push和pull操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;git push origin :BranchName&lt;/span&gt;  --删除远程分支BranchName（空格后面接的是英文冒号哦；其含义就是将一个空分支推到远程该分支上，很好理解。）&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;git push origin -d BranchName&lt;/span&gt;  --这也是用于删除远程分支的。&lt;/p&gt;
&lt;p&gt;　　　　　git push origin localBranch:remoteBranch   --将本地分支推到远程分支上，如果远程分支上不存在remoteBranch，则会自动创建该远程分支。&lt;/p&gt;
&lt;p&gt;　　　　　git push origin remoteBranch  --也可简写成这样。如果当前分支与远程某分支关联后直接可使用git push。&lt;/p&gt;
&lt;p&gt;　　　　　git pull origin remoteBranch:localBranch  --pull类似于push，但是指令是值将远程remoteBranch分支拉取到localBranch分支上，位置关系刚好和push相反&lt;/p&gt;
&lt;p&gt;　　　　　git pull origin remoteBranch  --将远程remoteBranch分支pull到当前分支。&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;分支合并&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　git merge branchName  --将branchName分支合并到当前分支上&lt;/p&gt;
&lt;p&gt;　　　　　&quot;git merge branchName --no-ff&quot;   --不使用fast-forward模式合并，合并后会生成一个合并提交id。 &lt;/p&gt;
&lt;p&gt;　　　　　git merge origin/branchName  --合并远程分支&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;工作区的撤销&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　git co &quot;文件src&quot;  --针对某个具体文件撤销其在工作区的所有修改。（是在只保存而并没有执行add和commit操作）&lt;/p&gt;
&lt;p&gt;　　　　　git co .  --撤销工作区所有的文件的修改。（也是只没有执行add和commit）&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;暂存区 -&amp;gt; 工作区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　git reset &quot;文件src&quot; 或 git reset HEAD &quot;文件src&quot;  --都是指将暂存区的修改撤销到工作区。&lt;/p&gt;
&lt;p&gt;　　　　　“git reset -- . ”   --是指将暂存区的所有修改撤回到工作区.&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;git本地仓库提交 -&amp;gt; 工作区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　&lt;/span&gt;git reset —hard HEAD^  --回退到上一次提交（也即上一次提交）&lt;/p&gt;
&lt;p&gt;　　　　　git reset —hard  commitID  --回退到某一次具体的提交。&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;暂存操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　git stash  --当不想执行add和commit而急需切换分支或者拉取远程代码时，使用这个指令能将本地的修改暂存起来&lt;/p&gt;
&lt;p&gt;　　　　　git stash pop  --当执行完拉取相关操作回到该分支，该指令能将之前暂存的代码还原。&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;查看提交记录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;git log   --列举每次提交的详细信息，包括提交人姓名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　git reflog  --详细列出了用户的每个细节操作，包括切换分支，用户提交等信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　“git log --oneline --graph --decorate --all”   --以命令树的形式展示提交信息,&lt;/span&gt;（最好配置alias，这样就不用写这么多了。我配置的是：git tree）&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;比较修改差异&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　&lt;span&gt;git diff   --展示所有改动文件的修改部分。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　git diff &quot;文件src&quot;   --展示该文件改动哪些部分。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　git diff commit1 commit2 --stat   --比较这两次提交有哪些不同。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　git diff commit1 commit2 “文件src”   --比较这两次提交下，该文件被修改的部分。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　3.开发分支命名&lt;/h3&gt;
&lt;p&gt;　　　　看到一篇Gitflow文章，借用其对各个分支命名的规则。根据不同类型的工作对分支进行定义， 分为&lt;span&gt;功能(feature)分支 ，修复(fixbugs)分支，发布(release)分支，开发(develop)分支和主分支&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;　　　　自己之前对于分支的命名多半是比较随性，或者根据自己的偏好来取名。现在的话，可以根据不同的类型来对分支进行命名，比如是&lt;/p&gt;
&lt;p&gt;　　　　　　功能开发分支可以是feature-1.0，&lt;/p&gt;
&lt;p&gt;　　　　　　修复bugs分支可以使fixbugs-1.0，&lt;/p&gt;
&lt;p&gt;　　　　　　发布分支叫release-1.0，&lt;/p&gt;
&lt;p&gt;　　　　　　开发分支叫develop等等。&lt;/p&gt;
&lt;p&gt;后面的1.0也可以是利用自己理解区分的英文。这样取名的话有利用区分自己的这些分支的含义，便于管理。我觉得这是个好方法。&lt;/p&gt;
&lt;h2&gt;三、小技巧&lt;/h2&gt;
&lt;p&gt;　　1.本人使用的是VScode，相信很多人使用，它轻量、可配置、漂亮的主题等等许多优点。当使用VScode编辑器时，命令行cd到对应的项目的时候，再使用“code .”回车VScode就自动打开项目了。有图有真相：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/716120/201805/716120-20180501150729094-307278185.png&quot; alt=&quot;&quot; height=&quot;350&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　平时比如刚好在命令行，编辑器刚好被我们最小化了，直接使用“code .”就能快捷打开。这是我自己比较喜欢的使用的小技巧，如果你也觉得不错，赶紧去试试吧。&lt;/p&gt;
&lt;p&gt;　 （PS: 同时也可以使用“open .”打开项目对应的文件夹。）&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　Git指令博大精神，本文也只是介绍自己最常用的一些指令和小技巧，还有些指令还没涉及到比如：fetch，rebase，revert等等。自己用rebase比较少，所以不敢多做叙述误人子弟。文中如有纰漏或者改进之处，热烈欢迎留言。&lt;/p&gt;
&lt;p&gt;　　PS: 感觉篇幅有点长，不知道会不会看着乏味，欢迎各位园友指正。&lt;/p&gt;
&lt;p&gt;　　相关文章的链接：&lt;a href=&quot;https://juejin.im/post/5844507761ff4b006c3359a9&quot; target=&quot;_blank&quot;&gt;https://juejin.im/post/5844507761ff4b006c3359a9&lt;/a&gt;  --Gitflow&lt;/p&gt;
</description>
<pubDate>Wed, 02 May 2018 15:52:00 +0000</pubDate>
<dc:creator>盼先生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dpflying/p/8975867.html</dc:identifier>
</item>
<item>
<title>【模板】三分法 - ztz11</title>
<link>http://www.cnblogs.com/ztz11/p/8983269.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ztz11/p/8983269.html</guid>
<description>&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;如题，给出一个N次函数，保证在范围[l,r]内存在一点x，使得[l,x]上单调增，[x,r]上单调减。试求出x的值。&lt;/p&gt;
&lt;h2&gt;输入输出格式&lt;/h2&gt;
&lt;p&gt;输入格式：&lt;/p&gt;

&lt;p&gt;第一行一次包含一个正整数N和两个实数l、r，含义如题目描述所示。&lt;/p&gt;
&lt;p&gt;第二行包含N+1个实数，从高到低依次表示该N次函数各项的系数。&lt;/p&gt;

&lt;p&gt;输出格式：&lt;/p&gt;

&lt;p&gt;输出为一行，包含一个实数，即为x的值。四舍五入保留5位小数。&lt;/p&gt;
&lt;h2&gt;说明&lt;/h2&gt;
&lt;p&gt;时空限制：50ms,128M&lt;/p&gt;
&lt;p&gt;数据规模：&lt;/p&gt;
&lt;p&gt;对于100%的数据：7&amp;lt;=N&amp;lt;=13&lt;/p&gt;
&lt;h2&gt;思路：&lt;/h2&gt;
&lt;p&gt;这是一道三分的模板题，在这里我讲一下三分&lt;/p&gt;
&lt;h3&gt;三分是什么？？：&lt;/h3&gt;
&lt;p&gt;三分是一种优化的暴力，从他的名字就可以知道，这是一种很类似于二分的方法，通过一系列操作时复杂度由O（n）降到O（logn）&lt;/p&gt;
&lt;h3&gt;三分能干什么？&lt;/h3&gt;
&lt;p&gt;求单峰多次函数最值位置（近似值）&lt;/p&gt;
&lt;h3&gt;如何实现三分？（这个是重点）&lt;/h3&gt;
&lt;p&gt;我们先看一幅图（picture by &lt;a href=&quot;https://www.luogu.org/problemnew/show/P3382#sub&quot; target=&quot;_blank&quot;&gt;luogu&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389365/201805/1389365-20180502233252806-1716458643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 现在我们的已知条件有峰所在的区间和函数表达式，这就很好办&lt;/p&gt;
&lt;p&gt;首先我们取区间中点&lt;/p&gt;
&lt;p&gt;然后取离中点很近的两个点（距离必须小于等于要求精度），并求出它们的函数值&lt;/p&gt;
&lt;p&gt;这时候通过判断函数值的大小就可以知道此处是递增还是递减&lt;/p&gt;
&lt;p&gt;如果递增，那点就在左区间，峰在其右，区间左端点就变成区间中点&lt;/p&gt;
&lt;p&gt;反之亦然&lt;/p&gt;
&lt;p&gt;一直缩小区间大小&lt;/p&gt;
&lt;p&gt;到满足精度时，答案就呼之欲出&lt;/p&gt;
&lt;h3&gt;一点小优化：&lt;/h3&gt;
&lt;p&gt;高中的同学应该都知道有个东西叫秦九韶算法&lt;/p&gt;
&lt;p&gt;它可以将a0+a1*x^1+a2*x^2……an^xn这个高复杂度的东西&lt;/p&gt;
&lt;p&gt;优化为an（x+an-1（x……a1（x+a0）））这个线性的式子&lt;/p&gt;
&lt;p&gt;复杂度下降了一个log&lt;/p&gt;
&lt;p&gt;很好使&lt;/p&gt;
&lt;h2&gt;见代码：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cmath&amp;gt;
#define rii register int i
using namespace std;
int n;
double xs[15],l,r,final,mid;
double eps=0.000001;
double dxs(double z)
{
        double ans=0;
        for(rii=n;i&amp;gt;=0;i--)
        {
                ans=ans*z+xs[i];
        }
        return ans; 
}
int main()
{
        cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;l&amp;gt;&amp;gt;r;
        for(rii=n;i&amp;gt;=0;i--)
        {
                cin&amp;gt;&amp;gt;xs[i];
        }
        eps=0.000001;
        while(1)
        {
                if(fabs(r-l)&amp;lt;eps)
                {
                        final=r;
                        break;
                }
                mid=(l+r)/2;
                if(dxs(mid+eps)&amp;gt;dxs(mid-eps))
                {
                        l=mid;
                }
                else
                {
                        r=mid;
                }
        }
        printf(&quot;%.5lf&quot;,final);
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 02 May 2018 15:50:00 +0000</pubDate>
<dc:creator>ztz11</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ztz11/p/8983269.html</dc:identifier>
</item>
<item>
<title>spring boot之入门配置（一） - Johnson木木</title>
<link>http://www.cnblogs.com/Johnson-lin/p/8983259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johnson-lin/p/8983259.html</guid>
<description>&lt;p&gt;&lt;strong&gt;yml、properties配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　yml相比properties配置文件，yml可以省略不必要的前缀，并且看起来更加的有层次感。推荐使用yml文件。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377046/201805/1377046-20180502231629170-1291885610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@Value&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　根据配置文件的配置项获取对应的value，@Value的值必须与配置文件中的配置项一致，使用方法如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377046/201805/1377046-20180502231236995-929587724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;@ConfigurationProperties&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当配置项过多时，可以使用@ConfigurationProperties注解更加的方便。并且可以对不同的配置项进行分组。例如：配置项分为project 和 Johnson两个不同的配置项&lt;/p&gt;
&lt;p&gt;　　@ConfigurationProperties中值对应的前缀。属性名必须与配置项对应。并且实现对应的get、set方法。　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377046/201805/1377046-20180502232547365-1663939338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用方法如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377046/201805/1377046-20180502233030540-2030366638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@Component&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　因为在持久层、业务层和控制层中，分别采用@Repository、@Service和@Controller，因为不清楚这个类是属于哪个层面，又要交给Spring管理，所以就用@Component。&lt;/p&gt;
&lt;p&gt;　　看上图project类和Johnson类可以看到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多环境配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在大多数开发中，一般配置项都会把生产环境和测试环境分开。如果都是用同一个配置文件，那么在生产与测试环境之间不断修改配置项会很麻烦，开发效率会很低。&lt;/p&gt;
&lt;p&gt;　　而&lt;strong&gt;spring.profiles.active&lt;/strong&gt;正好可以解决这个问题&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377046/201805/1377046-20180502234055470-1762518234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意：命名需要规范，必须使用符号&quot;-&quot;进行区别文件。&lt;/p&gt;

&lt;p&gt;　　木木只是一个小白，若那里写的不好或者有更好的建议，请留言 或 发到我的QQ邮箱 821312534@qq.com 。谢谢大家啦~(*^▽^*)&lt;/p&gt;
</description>
<pubDate>Wed, 02 May 2018 15:47:00 +0000</pubDate>
<dc:creator>Johnson木木</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Johnson-lin/p/8983259.html</dc:identifier>
</item>
</channel>
</rss>