<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>javascript设计模式——装饰者模式 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8044759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8044759.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　在程序开发中，许多时候都并不希望某个类天生就非常庞大，一次性包含许多职责。那么可以使用装饰者模式。装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。本文将详细介绍装饰者模式&lt;/p&gt;

&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;　　在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变；另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱”是相对可见性而言的，在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性&lt;/p&gt;
&lt;p&gt;　　使用继承还会带来另外一个问题，在完成一些功能复用的同时，有可能创建出大量的子类，使子类的数量呈爆炸性增长。比如现在有4种型号的自行车，为每种自行车都定义了一个单独的类。现在要给每种自行车都装上前灯、尾灯和铃铛这3种配件。如果使用继承的方式来给每种自行车创建子类，则需要4×3=12个子类。但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加3个类&lt;/p&gt;
&lt;p&gt;　　这种给对象动态地增加职责的方式称为装饰者（decorator）模式。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式，比如天冷了就多穿一件外套，需要飞行时就在头上插一支竹蜻蜓&lt;/p&gt;
&lt;p&gt;　　作为一门解释执行的语言，给javascript中的对象动态添加或者改变职责是一件再简单不过的事情，虽然这种做法改动了对象自身，跟传统定义中的装饰者模式并不一样，但这无疑更符合javascript的语言特色。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt;{
  name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  address:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
};
obj.address&lt;/span&gt;= obj.address + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;平谷区&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　传统面向对象语言中的装饰者模式在javascript中适用的场景并不多，如上面代码所示，通常并不太介意改动对象自身&lt;/p&gt;
&lt;p&gt;　　假设在编写一个飞机大战的游戏，随着经验值的增加，操作的飞机对象可以升级成更厉害的飞机，一开始这些飞机只能发射普通的子弹，升到第二级时可以发射导弹，升到第三级时可以发射原子弹&lt;/p&gt;
&lt;p&gt;　　下面来看代码实现，首先是原始的飞机类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Plane =&lt;span&gt; function(){};

Plane.prototype.fire &lt;/span&gt;=&lt;span&gt; function(){
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发射普通子弹&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来增加两个装饰类，分别是导弹和原子弹：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; MissileDecorator =&lt;span&gt; function( plane ){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.plane =&lt;span&gt; plane;
}
MissileDecorator.prototype.fire &lt;/span&gt;=&lt;span&gt; function(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.plane.fire();
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发射导弹&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; AtomDecorator =&lt;span&gt; function( plane ){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.plane =&lt;span&gt; plane;
}
AtomDecorator.prototype.fire &lt;/span&gt;=&lt;span&gt; function(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.plane.fire();
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发射原子弹&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　导弹类和原子弹类的构造函数都接受参数plane对象，并且保存好这个参数，在它们的fire方法中，除了执行自身的操作之外，还调用plane对象的fire方法。这种给对象动态增加职责的方式，并没有真正地改动对象自身，而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口（fire方法），当请求达到链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象&lt;/p&gt;
&lt;p&gt;　　因为装饰者对象和它所装饰的对象拥有一致的接口，所以它们对使用该对象的客户来说是透明的，被装饰的对象也并不需要了解它曾经被装饰过，这种透明性使得可以递归地嵌套任意多个装饰者对象&lt;/p&gt;
&lt;p&gt;　　在《设计模式》成书之前，GoF原想把装饰者（decorator）模式称为包装器（wrapper）模式。从功能上而言，decorator能很好地描述这个模式，但从结构上看，wrapper的说法更加贴切。装饰者模式将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。请求随着这条链依次传递到所有的对象，每个对象都有处理这条请求的机会&lt;/p&gt;

&lt;h3&gt;javascript装饰者&lt;/h3&gt;
&lt;p&gt;　　javascript语言动态改变对象相当容易，可以直接改写对象或者对象的某个方法，并不需要使用“类”来实现装饰者模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; plane =&lt;span&gt; {
    fire: function(){
        console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发射普通子弹&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    }
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; missileDecorator =&lt;span&gt; function(){
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发射导弹&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; atomDecorator =&lt;span&gt; function(){
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发射原子弹&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fire1 =&lt;span&gt; plane.fire;
plane.fire &lt;/span&gt;=&lt;span&gt; function(){
    fire1();
    missileDecorator();
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fire2 =&lt;span&gt; plane.fire;
plane.fire &lt;/span&gt;=&lt;span&gt; function(){
    fire2();
    atomDecorator();
}
plane.fire();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分别输出： 发射普通子弹、发射导弹、发射原子弹&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;装饰函数&lt;/h3&gt;
&lt;p&gt;　　在javascript中可以很方便地给某个对象扩展属性和方法，但却很难在不改动某个函数源代码的情况下，给该函数添加一些额外的功能。在代码的运行期间，很难切入某个函数的执行环境。要想为函数添加一些功能，最简单粗暴的方式就是直接改写该函数，但这是最差的办法，直接违反了开放——封闭原则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; function(){
  alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;改成：&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; function(){
  alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
  alert(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　很多时候不想去碰原函数，也许原函数是由其他同事编写的，里面的实现非常杂乱。现在需要一个办法，在不改变函数源代码的情况下，能给函数增加功能，通过保存原引用的方式就可以改写某个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt;  function(){
  alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _a =&lt;span&gt; a;

a &lt;/span&gt;=&lt;span&gt; function(){
  _a();
  alert(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
}
a();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是实际开发中很常见的一种做法，比如想给window绑定onload事件，但是又不确定这个事件是不是已经被其他人绑定过，为了避免覆盖掉之前的window.onload函数中的行为，一般都会先保存好原先的window.onload，把它放入新的window.onload里执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
window.onload=&lt;span&gt;function(){
  alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _onload=window.onload||&lt;span&gt;function(){};
window.onload&lt;/span&gt;=&lt;span&gt;function(){
  _onload();
  alert(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样的代码当然是符合开放——封闭原则的，在增加新功能的时候，确实没有修改原来的window.onload代码，但是这种方式存在以下两个问题&lt;/p&gt;
&lt;p&gt;　　1、必须维护_onload这个中间变量，虽然看起来并不起眼，但如果函数的装饰链较长，或者需要装饰的函数变多，这些中间变量的数量也会越来越多&lt;/p&gt;
&lt;p&gt;　　2、遇到了this被劫持的问题，在window.onload的例子中没有这个烦恼，是因为调用普通函数_onload时，this也指向window，跟调用window.onload时一样（函数作为对象的方法被调用时，this指向该对象，所以此处this也只指向window）。现在把window.onload换成document.getElementById，代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; _getElementById =&lt;span&gt; document.getElementById;
document.getElementById&lt;/span&gt;=&lt;span&gt; function(id){
  alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _getElementById(id);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1)&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; button = document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行这段代码，看到在弹出alert(1)之后，紧接着控制台抛出了异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：Uncaught TypeError:Illegal invocation&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　异常发生在(1)处的_getElementById(id)这句代码上，此时_getElementById是一个全局函数，当调用一个全局函数时，this是指向window的，而document.getElementById方法的内部实现需要使用this引用，this在这个方法内预期是指向document，而不是window，这是错误发生的原因，所以使用现在的方式给函数增加功能并不保险&lt;/p&gt;
&lt;p&gt;　　改进后的代码可以满足需求，要手动把document当作上下文this传入_getElementById：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;button id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;
&lt;span&gt;var&lt;/span&gt; _getElementById =&lt;span&gt; document.getElementById;
document.getElementById&lt;/span&gt;=&lt;span&gt;function(){
  alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _getElementById.apply(document,arguments);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; button = document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但这样做显然很不方便&lt;/p&gt;

&lt;h3&gt;AOP&lt;/h3&gt;
&lt;p&gt;　　下面使用AOP来提供一种完美的方法给函数动态增加功能&lt;/p&gt;
&lt;p&gt;　　首先给出Function.prototype.before方法和Function.prototype.after方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
Function.prototype.before =&lt;span&gt; function( beforefn ){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; __self = &lt;span&gt;this&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存原函数的引用&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; function(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回包含了原函数和新函数的&quot;代理&quot;函数&lt;/span&gt;
        beforefn.apply( &lt;span&gt;this&lt;/span&gt;, arguments ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行新函数，且保证this 不被劫持，新函数接受的参数
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也会被原封不动地传入原函数，新函数在原函数之前执行&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; __self.apply( &lt;span&gt;this&lt;/span&gt;, arguments ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行原函数并返回原函数的执行结果，
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并且保证this 不被劫持&lt;/span&gt;
&lt;span&gt;    }
}
Function.prototype.after &lt;/span&gt;=&lt;span&gt; function( afterfn ){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; __self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = __self.apply( &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
        afterfn.apply( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Function.prototype.before接受一个函数当作参数，这个函数即为新添加的函数，它装载了新添加的功能代码。接下来把当前的this保存起来，这个this指向原函数，然后返回一个“代理”函数，这个“代理”函数只是结构上像代理而已，并不承担代理的职责（比如控制对象的访问等）。它的工作是把请求分别转发给新添加的函数和原函数，且负责保证它们的执行顺序，让新添加的函数在原函数之前执行（前置装饰），这样就实现了动态装饰的效果。通过Function.prototype.apply来动态传入正确的this，保证了函数在被装饰之后，this不会被劫持。Function.prototype.after的原理跟Function.prototype.before一模一样，唯一不同的地方在于让新添加的函数在原函数执行之后再执行&lt;/p&gt;
&lt;p&gt;　　下面是一个例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;button id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    Function.prototype.before &lt;/span&gt;=&lt;span&gt; function( beforefn ){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; __self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
            beforefn.apply( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; __self.apply( &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
        }
    }
    document.getElementById &lt;/span&gt;=&lt;span&gt; document.getElementById.before(function(){
        alert (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    });
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; button = document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    console.log( button );
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再回到window.onload的例子，用Function.prototype.before来增加新的window.onload事件非常简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
window.onload =&lt;span&gt; function(){
    alert (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
window.onload &lt;/span&gt;= ( window.onload ||&lt;span&gt; function(){} ).after(function(){
    alert (&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
}).after(function(){
    alert (&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
}).after(function(){
    alert (&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　值得提到的是，上面的AOP实现是在Function.prototype上添加before和after方法，但许多人不喜欢这种污染原型的方式，那么可以做一些变通，把原函数和新函数都作为参数传入before或者after方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; before =&lt;span&gt; function( fn, beforefn ){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
        beforefn.apply( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fn.apply( &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
    }
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; before(
    function(){alert (&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)},
    function(){alert (&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)}
    );
a &lt;/span&gt;= before( a, function(){alert (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);} );
a();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;AOP应用实例&lt;/h3&gt;
&lt;p&gt;　　用AOP装饰函数的技巧在实际开发中非常有用。不论是业务代码的编写，还是在框架层面，都可以把行为依照职责分成粒度更细的函数，随后通过装饰把它们合并到一起，这有助于编写一个松耦合和高复用性的系统&lt;/p&gt;
&lt;p&gt;【数据统计上报】&lt;/p&gt;
&lt;p&gt;　　分离业务代码和数据统计代码，无论在什么语言中，都是AOP的经典应用之一。在项目开发的结尾阶段难免要加上很多统计数据的代码，这些过程可能让我们被迫改动早已封装好的函数。比如页面中有一个登录button，点击这个button会弹出登录浮层，与此同时要进行数据上报，来统计有多少用户点击了这个登录button&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;
&amp;lt;button tag=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;点击打开登录浮层&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; showLogin =&lt;span&gt; function(){
        console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;打开登录浮层&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        log( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getAttribute( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tag&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ) );
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; log =&lt;span&gt; function( tag ){
        console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;上报标签为: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; tag );
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (new Image).src = '&lt;/span&gt;&lt;span&gt;http://xx.com/report?tag=&lt;/span&gt;&lt;span&gt;' + tag; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 真正的上报代码略&lt;/span&gt;
&lt;span&gt;}
document.getElementById( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ).onclick =&lt;span&gt; showLogin;
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在showLogin函数里，既要负责打开登录浮层，又要负责数据上报，这是两个层面的功能，在此处却被耦合在一个函数里。使用AOP分离之后，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;
&amp;lt;button tag=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;点击打开登录浮层&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    Function.prototype.after &lt;/span&gt;=&lt;span&gt; function( afterfn ){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; __self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = __self.apply( &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
            afterfn.apply( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
        }
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; showLogin =&lt;span&gt; function(){
        console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;打开登录浮层&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; log =&lt;span&gt; function(){
        console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;上报标签为: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.getAttribute( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tag&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ) );
    }

    showLogin &lt;/span&gt;= showLogin.after( log ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开登录浮层之后上报数据&lt;/span&gt;
    document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ).onclick =&lt;span&gt; showLogin;
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【用AOP动态改变函数的参数】&lt;/p&gt;
&lt;p&gt;　　观察Function.prototype.before方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Function.prototype.before=&lt;span&gt;function(beforefn){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
    beforefn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,arguments);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; __self.apply(&lt;span&gt;this&lt;/span&gt;,arguments);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(2)&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从这段代码的(1)处和(2)处可以看到，beforefn和原函数__self共用一组参数列表arguments，在beforefn的函数体内改变arguments时，原函数__self接收的参数列表自然也会变化&lt;/p&gt;
&lt;p&gt;　　下面的例子展示了如何通过Function.prototype.before方法给函数func的参数param动态地添加属性b：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; func =&lt;span&gt; function(param){
  console.log(param);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：{a:&quot;a&quot;,b:&quot;b&quot;}&lt;/span&gt;
&lt;span&gt;}

func &lt;/span&gt;=&lt;span&gt; func.before(
  function(param){
    param.b&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
});

func({a:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在有一个用于发起ajax请求的函数，这个函数负责项目中所有的ajax异步请求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; ajax =&lt;span&gt;f unction(type,url,param){
  console.dir(param);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送ajax请求的代码略&lt;/span&gt;
&lt;span&gt;};
ajax(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://xx.com/userinfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{name:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的伪代码表示向后台cgi发起一个请求来获取用户信息，传递给cgi的参数是{name:'match'}。ajax函数在项目中一直运转良好，跟cgi的合作也很愉快。直到有一天，网站遭受了CSRF攻击。解决CSRF攻击最简单的一个办法就是在HTTP请求中带上一个Token参数。假设已经有一个用于生成Token的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getToken =&lt;span&gt; function(){
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在的任务是给每个ajax请求都加上Token参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; ajax =&lt;span&gt; function(type,url,param){
  param&lt;/span&gt;=param||&lt;span&gt;{};
  Param.Token&lt;/span&gt;=getToken();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送ajax请求的代码略...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然已经解决了问题，但ajax函数相对变得僵硬了，每个从ajax函数里发出的请求都自动带上了Token参数，虽然在现在的项目中没有什么问题，但如果将来把这个函数移植到其他项目上，或者把它放到一个开源库中供其他人使用，Token参数都将是多余的。也许另一个项目不需要验证Token，或者是Token的生成方式不同，无论是哪种情况，都必须重新修改ajax函数&lt;/p&gt;
&lt;p&gt;　　为了解决这个问题，先把ajax函数还原成一个干净的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; ajax =&lt;span&gt; function(type,url,param){
  console.log(param);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送ajax请求的代码略&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后把Token参数通过Function.prototyte.before装饰到ajax函数的参数param对象中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getToken =&lt;span&gt;function(){
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
}
ajax&lt;/span&gt;=&lt;span&gt;ajax.before(function(type,url,param){
  param.Token&lt;/span&gt;=&lt;span&gt;getToken();
});

ajax(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://xx.com/userinfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{name:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从ajax函数打印的log可以看到，Token参数已经被附加到了ajax请求的参数中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Token:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　明显可以看到，用AOP的方式给ajax函数动态装饰上Token参数，保证了ajax函数是一个相对纯净的函数，提高了ajax函数的可复用性，它在被迁往其他项目的时候，不需要做任何修改&lt;/p&gt;
&lt;p&gt;【插件式表单验证】&lt;/p&gt;
&lt;p&gt;　　在一个Web项目中，可能存在非常多的表单，如注册、登录、修改用户信息等。在表单数据提交给后台之前，常常要做一些校验，比如登录的时候需要验证用户名和密码是否为空，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;body&amp;gt;&lt;span&gt;
    用户名：&lt;/span&gt;&amp;lt;input id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;&lt;span&gt;
    密码： &lt;/span&gt;&amp;lt;input id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;input id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submitBtn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; username = document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ),
    password &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ),
    submitBtn &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;submitBtn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; formSubmit =&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( username.value === &lt;span&gt;''&lt;/span&gt;&lt;span&gt; ){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; alert ( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名不能为空&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( password.value === &lt;span&gt;''&lt;/span&gt;&lt;span&gt; ){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; alert ( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;密码不能为空&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; param =&lt;span&gt; {
            username: username.value,
            password: password.value
        }
        ajax( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://xx.com/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, param ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ajax 具体实现略&lt;/span&gt;
&lt;span&gt;    }
    submitBtn.onclick &lt;/span&gt;=&lt;span&gt; function(){
        formSubmit();
    }
&lt;/span&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　formSubmit函数在此处承担了两个职责，除了提交ajax请求之外，还要验证用户输入的合法性。这种代码一来会造成函数臃肿，职责混乱，二来谈不上任何可复用性。下面来分离校验输入和提交ajax请求的代码，把校验输入的逻辑放到validata函数中，并且约定当validata函数返回false的时候，表示校验未通过，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; validata =&lt;span&gt; function(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( username.value === &lt;span&gt;''&lt;/span&gt;&lt;span&gt; ){
        alert ( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名不能为空&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( password.value === &lt;span&gt;''&lt;/span&gt;&lt;span&gt; ){
        alert ( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;密码不能为空&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; formSubmit =&lt;span&gt; function(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( validata() === &lt;span&gt;false&lt;/span&gt; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 校验未通过&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; param =&lt;span&gt; {
        username: username.value,
        password: password.value
    }
    ajax( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http:// xxx.com/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, param );
}

submitBtn.onclick &lt;/span&gt;=&lt;span&gt; function(){
    formSubmit();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在的代码已经有了一些改进，把校验的逻辑都放到了validata函数中，但formSubmit函数的内部还要计算validata函数的返回值，因为返回值的结果表明了是否通过校验。接下来进一步优化这段代码，使validata和formSubmit完全分离开来。首先要改写Function.prototype.before，如果beforefn的执行结果返回false，表示不再执行后面的原函数，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
Function.prototype.before =&lt;span&gt; function( beforefn ){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; __self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( beforefn.apply( &lt;span&gt;this&lt;/span&gt;, arguments ) === &lt;span&gt;false&lt;/span&gt;&lt;span&gt; ){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; beforefn 返回false 的情况直接return，不再执行后面的原函数&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; __self.apply( &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; validata =&lt;span&gt; function(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( username.value === &lt;span&gt;''&lt;/span&gt;&lt;span&gt; ){
        alert ( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名不能为空&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( password.value === &lt;span&gt;''&lt;/span&gt;&lt;span&gt; ){
        alert ( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;密码不能为空&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; formSubmit =&lt;span&gt; function(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; param =&lt;span&gt; {
        username: username.value,
        password: password.value
    }
    ajax( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://xx.com/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, param );
}

formSubmit &lt;/span&gt;=&lt;span&gt; formSubmit.before( validata );

submitBtn.onclick &lt;/span&gt;=&lt;span&gt; function(){
    formSubmit();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在这段代码中，校验输入和提交表单的代码完全分离开来，它们不再有任何耦合关系，formSubmit=formSubmit.before(validata)这句代码，如同把校验规则动态接在formSubmit函数之前，validata成为一个即插即用的函数，它甚至可以被写成配置文件的形式，这有利于分开维护这两个函数。再利用策略模式稍加改造，就可以把这些校验规则都写成插件的形式，用在不同的项目当中&lt;/p&gt;
&lt;p&gt;　　值得注意的是，因为函数通过Function.prototype.before或者Function.prototype.after被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; func =&lt;span&gt; function(){
  alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
func.a&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
func&lt;/span&gt;=&lt;span&gt;func.after(function(){
  alert(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
});
alert(func.a);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另外，这种装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一些影响&lt;/p&gt;

&lt;h3&gt;装饰者模式和代理模式&lt;/h3&gt;
&lt;p&gt;　　装饰者模式和代理模式的结构看起来非常相像，这两种模式都描述了怎样为对象提供一定程度上的间接引用，它们的实现部分都保留了对另外一个对象的引用，并且向那个对象发送请求。代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系（Proxy与它的实体之间的关系），这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理——本体的引用，而装饰者模式经常会形成一条长长的装饰链&lt;/p&gt;

</description>
<pubDate>Sat, 16 Dec 2017 18:11:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8044759.html</dc:identifier>
</item>
<item>
<title>ElasticSearch 学习记录之 分布式文档存储往ES中存数据和取数据的原理 - 王守昌</title>
<link>http://www.cnblogs.com/wangshouchang/p/8049492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangshouchang/p/8049492.html</guid>
<description>&lt;h4&gt;分布式文档存储&lt;/h4&gt;
&lt;h5&gt;ES分布式特性&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;屏蔽了分布式系统的复杂性&lt;/li&gt;
&lt;li&gt;集群内的原理&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;垂直扩容和水平扩容&lt;/li&gt;
&lt;li&gt;真正的扩容能力是来自于水平扩容–为集群添加更多的节点，并且将负载压力和稳定性分散到这些节点中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;ES集群特点&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;一个集群拥有相同的cluster.name 配置的节点组成， 它们共同承担数据和负载的压力&lt;/li&gt;
&lt;li&gt;主节点负责管理集群的变更例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作&lt;/li&gt;
&lt;li&gt;集群健康&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;1.GET /_cluster/health&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;返回值中的status 是我们关注的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;green 主副分片均正常&lt;/li&gt;
&lt;li&gt;yellow 主都正常，不是所有的副都正常&lt;/li&gt;
&lt;li&gt;red 所有主分片都不正常&lt;/li&gt;
&lt;li&gt;分片的特点&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;Elasticsearch 是利用分片将数据分发到集群内各处&lt;/li&gt;
&lt;li&gt;分片是数据的容器，文档保存在分片内&lt;/li&gt;
&lt;li&gt;分片又被分配到集群内的各个节点里&lt;/li&gt;
&lt;li&gt;当集群规模变动，ES会自动在各个节点中迁移分片。使得数据任然均匀分布在集群中&lt;/li&gt;
&lt;li&gt;副分片是主分片的一个拷贝，作为硬件故障时的备份。并提供返回文档读操作&lt;/li&gt;
&lt;li&gt;在创建索引时，确定主分片数，但是副分片可以在后面进行更改&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;在更新一个文档时的ES内部操作&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Elasticsearch 已将旧文档标记为已删除，并增加一个全新的文档。&lt;/li&gt;
&lt;li&gt;尽管你不能再对旧版本的文档进行访问，但它并不会立即消失。&lt;/li&gt;
&lt;li&gt;当继续索引更多的数据，Elasticsearch 会在后台清理这些已删除文档&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;ES如何处理冲突&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;使用乐观并发控制&lt;/li&gt;
&lt;li&gt;利用 _version 号来确保 应用中相互冲突的变更不会导致数据丢失&lt;/li&gt;
&lt;li&gt;通过外部系统使用版本控制&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;文档的部分更新&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;文档不能被修改，只能被替换&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;如何路由一个文档到一个分片中&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;当索引一个文档时，我们怎么知道这个文档在什么位置&lt;/li&gt;
&lt;li&gt;使用下面的这个路由选择公式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;1.shard = hash(routing) % number_of_primary_shards&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;下面将对这个公式每个字段进行分析&lt;br/&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&lt;strong&gt;shard&lt;/strong&gt; 哪个分片， 也就是分片id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;routing&lt;/strong&gt; 一个可变值，默认是文档的id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;hash&lt;/strong&gt; 一个哈希函数，对&lt;strong&gt;rounting&lt;/strong&gt;字段进行哈希计算生成一个数字&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;number_of_primary_shards&lt;/strong&gt; 主分片的数量，&lt;strong&gt;routing&lt;/strong&gt;字段经过&lt;strong&gt;hash&lt;/strong&gt;函数计算之后的值，将对 主分片的数量也就是 &lt;strong&gt;number_of_primary_shards&lt;/strong&gt; 进行取与，之后得到的&lt;strong&gt;shard&lt;/strong&gt;就是我们文档所在的分片的位置&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;&lt;code&gt;主分片和副分片如何交互&lt;/code&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;假设一个集群由三个节点组成。有一个索引，这个索引有&lt;strong&gt;两个主分片&lt;/strong&gt;，每个&lt;strong&gt;主分片&lt;/strong&gt;有两个&lt;strong&gt;副分片&lt;/strong&gt;，&lt;em&gt;相同的分片的副本不会放在同一个节点上&lt;/em&gt;。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/758999/201712/758999-20171217012751124-896537590.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;请求发送到集群&lt;strong&gt;任意&lt;/strong&gt;节点，&lt;strong&gt;每个&lt;/strong&gt;节点都有能力处理请求。&lt;strong&gt;每个&lt;/strong&gt;节点都&lt;strong&gt;知道&lt;/strong&gt;集群中&lt;strong&gt;任一文档&lt;/strong&gt;的位置，&lt;strong&gt;所以可以将请求转发到需求节点上&lt;/strong&gt;。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;&lt;code&gt;新建、索引和删除单个文档 时的流程&lt;/code&gt;&lt;/h5&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/758999/201712/758999-20171217012757483-1382712875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;先向 node 1 来一个请求这个请求可能是发送新建，索引或者删除文档等。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node 1 节点根据文档的_id 确定文档属于分片0， 请求被转发到node3 节点&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node 3 在主分片执行了请求，如果主分片执行成功了，它将请求转发给node1 和node 2 节点。当所有的副分片都执行成功，node 3 将协调节点报告成功，并向客户端报告完成&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;consistency 参数的值可以设为 one （只要主分片状态 ok 就允许执行&lt;em&gt;写&lt;/em&gt;操作）,all&lt;/code&gt;（必须要主分片和所有副本分片的状态没问题才允许执行_写_操作）, 或quorum 。默认值为 quorum , 即大多数的分片副本状态没问题就允许执行&lt;em&gt;写&lt;/em&gt;操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;在执行一个写操作时，主分片都需要必须有一个规定数量的（quorum），也就是在大多数主副分片处于活跃状态。这样是防止在网络分区故障是执行写操作会导致数据不一致&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;1.quorum = int( (primary + number_of_replicas) / 2 ) + 1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;h5&gt;&lt;code&gt;取回一个文档&lt;/code&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;可以从主分片或者任意副本分片检索文档&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/758999/201712/758999-20171217012807280-2132617602.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;某个请求向node 1 发送获取请求 节点使用&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;节点使用节点文档_ID来确定文档属于分片0， 分片0 的副本分片存在于所有的三个节点上，在这种情况下，他将请求转发到node 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node 2 将文档返回给node 1 ，然后将文档返回给客户端&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;在每次处理读取请求时，协调结点在每次请求的时候都会轮训所有的副本片来达到负载均衡&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;&lt;code&gt;局部更新文档&lt;/code&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/758999/201712/758999-20171217012817374-1456652673.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;部分更新一个文档的步骤&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;客户端向node1 发送一个请求&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;它将请求转发到主分片这个文档所在的Node 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node 3从主分片检索文档，修改_Source json ，并且尝试重新索引主分片的文档。如果文档被另一个进程修改，他会重复步骤3 知道超过&lt;strong&gt;retry_on_conflict&lt;/strong&gt; 次后放弃&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node 3 成功更新文档，它将新版本的文档并行转发到node 1 和node 2 的副本分片，重新建立索引。所有副本分片都返回成功，node 3 向协调节点也返回成功，协调节点向客户端返回成功&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update 操作也支持 新建索引的时的那些参数 r&lt;strong&gt;outing 、 replication 、 consistency 和 timeout&lt;/strong&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;code&gt;多文档模式&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;mget 和 bulk API 的 模式类似于单文档模式。 协调节点知道每个文档的位置，将多个文档分解成每个文档的的多文档请求，并且将这些请求并行的转发到每个参与节点中 。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;使用 mget 取回多个文档&lt;/strong&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;code&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/758999/201712/758999-20171217012825436-517304222.png&quot; alt=&quot;&quot;/&gt;&lt;/code&gt;&lt;/code&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;客户端向node 1 发送一个mget请求&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node 1 向每个分片构建多文档请求，并行的转发这些请求到托管在每个所需的主分盘或者副分片的节点上一旦收到所有的额回复，node 1 构建响应并将其返回给客户端&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;使用 bulk 修改多个文档&lt;/strong&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/758999/201712/758999-20171217012835889-227540915.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;一个bulk请求请求到node 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node 1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;code&gt;搜索—–最基本的工具&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ElastcSearch 的三个基本概念&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;&lt;strong&gt;映射 Mapping&lt;/strong&gt; 描述数据在每个字段是如何存储的&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;分析 Analysis&lt;/strong&gt; 全文如何处理使之可以被搜索到&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;Query DSL&lt;/strong&gt; ES中强大灵活的查询语言&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;空搜索&lt;/strong&gt;&lt;br/&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;GET /_search 没有指定任何查询的搜索包括没有指定索引&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;1.**查询获取之后**&lt;/code&gt;&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;code&gt;**查询获取之后**&lt;/code&gt;&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
2&lt;span&gt;.
&lt;/span&gt;3&lt;span&gt;. {
&lt;/span&gt;4. &quot;took&quot;: 8, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求耗费多少毫秒&lt;/span&gt;
5. &quot;timed_out&quot;: &lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否超时&lt;/span&gt;
6. &quot;_shards&quot;: {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在查询中参与分片的总数，成功多少，失败多少&lt;/span&gt;
7. &quot;total&quot;: 42,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总分片数&lt;/span&gt;
8. &quot;successful&quot;: 42,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功数&lt;/span&gt;
9. &quot;skipped&quot;: 0,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳过数&lt;/span&gt;
10. &quot;failed&quot;: 0&lt;span&gt;//&lt;/span&gt;&lt;span&gt;失败数&lt;/span&gt;
11&lt;span&gt;. },
&lt;/span&gt;12. &quot;hits&quot;: {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hits指返回的结果集&lt;/span&gt;
13. &quot;total&quot;: 6184,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总文档数量&lt;/span&gt;
14. &quot;max_score&quot;: 1&lt;span&gt;,
&lt;/span&gt;15. &quot;hits&quot;&lt;span&gt;: [
&lt;/span&gt;16&lt;span&gt;. {
&lt;/span&gt;17. &quot;_index&quot;: &quot;.kibana&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引名称&lt;/span&gt;
18. &quot;_type&quot;: &quot;config&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引type&lt;/span&gt;
19. &quot;_id&quot;: &quot;5.6.3&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文档在这个索引下的id&lt;/span&gt;
20. &quot;_score&quot;: 1,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引得分，是查询后的计算得来的&lt;/span&gt;
21. &quot;_source&quot;&lt;span&gt;: {
&lt;/span&gt;22. &quot;buildNum&quot;: 15554
23&lt;span&gt;. }
&lt;/span&gt;24. },
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;&lt;strong&gt;xxxxxxxxxxxxxxxxxx&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 17:30:00 +0000</pubDate>
<dc:creator>王守昌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangshouchang/p/8049492.html</dc:identifier>
</item>
<item>
<title>技术人员如何处理非技术问题思维清单。 - kkyong</title>
<link>http://www.cnblogs.com/codemind/p/8049274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codemind/p/8049274.html</guid>
<description>
&lt;p&gt;9月份，WePhone创始人被骗婚跳楼。&lt;/p&gt;
&lt;p&gt;9月份，成都 软件园F区工程跳楼，传因女友出轨。&lt;/p&gt;
&lt;p&gt;12月份，中兴技术负责人被辞退跳楼。&lt;/p&gt;

&lt;p&gt;感觉最近半年程序跳楼的新闻有点多。很多人无法理解这些聪明程序员为什么会以极端方式来处理问题。&lt;/p&gt;
&lt;p&gt;自己从事程序员职业比较久。深感解决技术问题和生活中的需要不同的思维模式。总结出来希望对大家有帮助。&lt;/p&gt;
&lt;p&gt;技术人员会按照需求来完成任务。常常因为需求不明确和产品经理吵架。 在工程上，未知因素总是越少越好。对于无法确定未知因素，需要需求方给予假设。我们会要求在需求文档里明确这些假设。文档里面常常会这样写：该系统最高能承受每秒xx次请求，该系统最高容纳 xxx个用户。运行该软件最低需要2G内存。这些假设条件设定会给技术人员很强的安全感。虽然需求和假设总是随着业务调整。&lt;/p&gt;
&lt;p&gt;现实生活中，很多问题，特别是重大的问题，不确定因素很多。而且无法了解全局的信息。根本无法做出全局最优的选择。 这时候更多要需要自省。 倾听内心的想法。要相信自己能解决。&lt;/p&gt;
&lt;p&gt;自己整理思维的清单。（未完待续）&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 1.我是不是无法思考，需要休息？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多人生中重要问题，不是通过加班冥思苦想可以解决。不要逼自己用技术手段，逻辑思维去解决问题。有时候你需要一些想象思维。把条件和问题，都写下来。让自己清楚利弊，深深印在脑海里。然后放松，答案就会很神奇慢慢浮现。这个不是冥思苦想的结果。像是深处的“我”的选择，不可”想“的我。要对自己有信心，把问题交给内心深处的那个你。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 2.&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;假如自己80岁高龄时，会不会对今天的决定后悔？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 索贝斯的话。把问题放大到时间维度。等自己老了快要死掉了，会不会对今天决定后悔。不后悔的话，就去干吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt; 3.如果决定导致的后果&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;，明天被登记在新闻报纸上并在网络上传开了，所有人都知道和议论，是否会后悔？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我记得是李开复 的 方法。把自己决定舆论影响力放大。 如果你不会担心媒体们报道你的话。更不会在意，公司同事，朋友怎么看你。 很多名人就是这样敢爱敢恨。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;4.最差的后果是什么，我能承受吗？会有什么收益，回报。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;风险和收益总是成正比。不要去寻找零风险的解决方案。明白自己承担什么风险，最差情况是什么。你的收益在哪里。选择的方案一般都是我能承担最差情况。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;极端情况下，法律和规则可以触犯的，但要承担后果和代价。（找不到原话出处）。特别是你自己和家里人的生命权受到威胁时候。这个是人最天然的反应。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;想想20年前四处躲藏的超生游击队。电影 ”达拉斯买家俱乐部&quot;，讲得也是这个道理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;5. 截止时间是什么？必须马上解决吗？必须要解决吗？这个是个问题吗？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回顾一下问题的本质。很多情况下问题不是问题。而且不要忘了你始终有权利拒绝觉回答问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt; 6.谁可以帮助我？可以帮助我做决定？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;&lt;span class=&quot;red&quot;&gt;（未完待续）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Dec 2017 17:22:00 +0000</pubDate>
<dc:creator>kkyong</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codemind/p/8049274.html</dc:identifier>
</item>
<item>
<title>Mecanim动画系统 - 张三疯_1998</title>
<link>http://www.cnblogs.com/zhh19981104/p/8048191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhh19981104/p/8048191.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;序言：Mecanim动画系统是Unity4.0之后退出的新版动画系统，非常适合人类动画系统。本文是作为自己的学习来讲解的，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可能会有些啰嗦，但尽量把自己的坑都为大家列出来，让大家理解透彻。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、文件的导入与文件类型的区别：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171216213516046-1326210119.jpg&quot; alt=&quot;&quot; width=&quot;684&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171216213550218-1922062640.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;507&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、上图中的是两种不同的素材，图1的是没有进行动画切割的文件动画模型，而图二是已经切割了的动画模型。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;通俗的来讲，就是，切割了的动画模型我们只需要直接用就行了，不用自己手动的去切割动画，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;而未切割的偶的动画模型则是所有动画的集合，程序员要根据动画师提供的动画帧数据来进行手动的动画帧切割，比较繁琐。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、文件导入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;选中导入的模型DefaultAvatar，在Inspector面板进行模型的参数相关设置，有三个选项，分别是Model、Rig、Animations三个选项卡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、Model:设置的是模型导入的参数设置，主要设置的是比例大小的设置，因为每个建模师的所用比例不同，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要根据具体情境进行大小的设置，当然可以在场景中创建一个Cube，一个Cube是1*1*!的，然后进行相对的调整即可。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、Rig：主要是设置模型的动画类型，然后进行相关的正确映射。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171216222823468-539034622.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（1）、选中Humanoid类型，然后设置其骨骼映射和肌肉的设置：其中实圈对应的是必须的骨骼，而虚圈不一定要正确匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（2）、&lt;/span&gt;当匹配成功会在Scene视图中看到骨骼成了绿色了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（3）、&lt;/span&gt;建议是先让系统进行自动匹配（在Mapping选项中选择Automap），然后在对不匹配的骨骼进行手动的调整，减少工作量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（4）、&lt;/span&gt;在对骨骼进行配置的时候，建议将骨骼定义为T型，方便我们进行调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（5）、&lt;/span&gt;在Pose选项中，设置为Enforce T-pose,这样就可以方便我们进行调试了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（6）、&lt;/span&gt;骨骼定义好了，再转到肌肉选项，一般肌肉选项这边保持系统默认的即可了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（7）、&lt;/span&gt;然后选择Done完成配置。这时在其动画模型下就会出现一个以Avatar结尾的骨骼映射文件了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171216222916014-729768826.jpg&quot; alt=&quot;&quot; width=&quot;903&quot; height=&quot;403&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、Animation：动画设置。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、模型的配置：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　将模型拖到Scene视图中，可以看到，在Inspector面板中可以看到自动添加了Animator属性，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;此时里面缺少了动画状态机，Animator Controller,我们可以创建一个状态机，稍后对其进行配置。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、动画模型的配置：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因为是一个角色，则这里将所有的动画模型采用同一种骨骼映射。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;选中骨骼模型，在Inspector面板的Rig面板设置为Humanoid类型的动画，在设置其的骨骼映射为上一步生成以Avatar结尾的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171216225131608-1979769983.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;完成骨骼的配置，接下来就是对动画的帧进行控制，这个需要根据动画师提供的数据进行配置，就不详细叙述了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、状态机的配置：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）、在状态机中可以设置四种控制动画的过渡参数类型，bool float int trigger，可以根据需求进行设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）、将角色的动画拖入状态机中即可导入动画，其中Any State代表的是状态机中的所有动画，这个一般用来控制游戏物体的死亡，因为死亡了，则所有的动画都要进行停止了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）、其他的则根据需求进行动画的设置 ，中间通过过渡条件进行状态的切换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）、在状态机中，橙色的代表的是默认动画，当然可以通过自己设置默认动画。灰色代表的是普通动画。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）、动画如何实现需要按照需求来进行状态的过渡。可以单击过渡条件，选择什么时候进行过渡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）、设置其Conditions即可，按需求设置。就可以在代码中进行控制参数来进行状态的切换了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;这里给大家提一个坑，当初我学的时候被整懵了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、【设置Any State过渡到其他的状态的时候，要把Settings --&amp;gt;Can To Self去掉勾选，这样就不能映射到自身了，不然无法正确播放装换后的动画】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、如果是想通过参数进行控制状态的切换而不用等动画播放完再播放的话，则需要将Has Exit Time取消勾选。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171216233137124-595083857.jpg&quot; alt=&quot;&quot; width=&quot;908&quot; height=&quot;582&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六、状态机设置完毕，就可以通过代码通知其动画的播放了：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;using System.Collections;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;using System.Collections.Generic;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;using UnityEngine;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;public class Controller : MonoBehaviour&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    private Animator animator;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    // Use this for initialization&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    void Start()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        animator = GetComponent&amp;lt;Animator&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    // Update is called once per frame&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    void Update()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        float vertical = Input.GetAxis(&quot;Vertical&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        float horizontal = Input.GetAxis(&quot;Horizontal&quot;);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        animator.SetFloat(&quot;Speed&quot;, vertical);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        animator.SetFloat(&quot;Angular&quot;, horizontal);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        if (Input.GetKeyDown(KeyCode.Space))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            animator.SetBool(&quot;Dead&quot;, true);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        //print(vertical);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;七、重定向功能：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;接下来为大家介绍下重定向功能。其实就是公用一个Animatior Controller而已，只是术语高大上，内容贼逗，哈哈哈。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、使用另一个动画模型，重复以上的步骤进行骨骼的映射，动画调试等一系列设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、设置新模型上的Animator Controller为上一步创建的，拖进即可，然后再关联脚本即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、然后再场景中就可以通过按键进行控制两个角色的行走了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;八、总结：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在这里Mecanim动画系统就结束了，新手肯定会有很多错误，希望大家可以包容包容。总的来说，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;该Mecanim方便了我们设置动画的播放状态，状态机的使用直接大大减少了工作量。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; 　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　2017-12-17 、00:17:16&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 16:18:00 +0000</pubDate>
<dc:creator>张三疯_1998</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhh19981104/p/8048191.html</dc:identifier>
</item>
<item>
<title>C#_表达式目录树的应用 - Torey_li</title>
<link>http://www.cnblogs.com/Torey/p/8048131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Torey/p/8048131.html</guid>
<description>
&lt;p&gt;使用表达式目录树实现两个不同类型的属性赋值：&lt;/p&gt;
&lt;p&gt;public class People&lt;br/&gt;{&lt;br/&gt;public int Age { get; set; }&lt;br/&gt;public string Name { get; set; }&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public int Id;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;}&lt;br/&gt;public class PeopleCopy&lt;br/&gt;{&lt;br/&gt;public int Age { get; set; }&lt;br/&gt;public string Name { get; set; }&lt;/p&gt;
&lt;p&gt;public int Id;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;public class Class1&lt;br/&gt;{&lt;/p&gt;
&lt;p&gt;private static Dictionary&amp;lt;string, object&amp;gt; _Dic = new Dictionary&amp;lt;string, object&amp;gt;();&lt;br/&gt;private static TOut TransExp&amp;lt;TIn, TOut&amp;gt;(TIn tIn) {&lt;br/&gt;string key = $&quot;funckey_{typeof(TIn).FullName}_{typeof(TOut).FullName}&quot;;&lt;br/&gt;if (!_Dic.Keys.Contains(key)) {&lt;br/&gt;ParameterExpression parameterExpression = Expression.Parameter(typeof(TIn), &quot;p&quot;);&lt;br/&gt;List&amp;lt;MemberBinding&amp;gt; memberBindingList = new List&amp;lt;MemberBinding&amp;gt;();&lt;br/&gt;foreach (var item in typeof(TOut).GetProperties())&lt;br/&gt;{&lt;br/&gt;PropertyInfo propertyInfo = typeof(TIn).GetProperty(item.Name);&lt;br/&gt;if (propertyInfo == null) { continue; }&lt;br/&gt;MemberExpression property = Expression.Property(parameterExpression, propertyInfo);&lt;br/&gt;memberBindingList.Add(Expression.Bind(item, property));&lt;br/&gt;}&lt;br/&gt;foreach (var item in typeof(TOut).GetFields())&lt;br/&gt;{&lt;br/&gt;FieldInfo fieldInfo = typeof(TIn).GetField(item.Name);&lt;br/&gt;if (fieldInfo == null) { continue; }&lt;br/&gt;MemberExpression property = Expression.Field(parameterExpression, fieldInfo);&lt;br/&gt;memberBindingList.Add(Expression.Bind(item, property));&lt;br/&gt;}&lt;br/&gt;Expression&amp;lt;Func&amp;lt;TIn, TOut&amp;gt;&amp;gt; expression = Expression.Lambda&amp;lt;Func&amp;lt;TIn, TOut&amp;gt;&amp;gt;(Expression.MemberInit(Expression.New(typeof(TOut)), memberBindingList), new ParameterExpression[]&lt;br/&gt;{&lt;br/&gt;parameterExpression&lt;br/&gt;});&lt;br/&gt;Func&amp;lt;TIn, TOut&amp;gt; func = expression.Compile();&lt;br/&gt;_Dic.Add(key,func);&lt;br/&gt;}&lt;br/&gt;return ((Func &amp;lt; TIn, TOut &amp;gt; )_Dic[key])(tIn);&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static void Main(string[] args)&lt;br/&gt;{&lt;/p&gt;
&lt;p&gt;List&amp;lt;ClassLibrary1.PeopleCopy&amp;gt; PeoleCopyList = new List&amp;lt;ClassLibrary1.PeopleCopy&amp;gt;();&lt;br/&gt;for (int i = 0; i &amp;lt; 5; i++)&lt;br/&gt;{&lt;br/&gt;ClassLibrary1.People people = new ClassLibrary1.People() { Id = 5+1, Age = 25, Name = &quot;aaa&quot;+i };&lt;br/&gt;PeoleCopyList.Add(Class1.ToutGet&amp;lt;ClassLibrary1.People, ClassLibrary1.PeopleCopy&amp;gt;(people));&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 15:44:00 +0000</pubDate>
<dc:creator>Torey_li</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Torey/p/8048131.html</dc:identifier>
</item>
<item>
<title>salesforce零基础学习（八十四）配置篇： 自定义你的home page layout - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/7899371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/7899371.html</guid>
<description>&lt;p&gt;当我们进入salesforce系统或者切换app后，默认第一个看到的就是home页面。home页面简单的来说可以包括&lt;span&gt;左侧(narrow component)&lt;/span&gt;和&lt;span&gt;右侧(wide component)&lt;/span&gt;两部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211221857337-1413264539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;左侧包含Recent View,Custom Link,Create New等快捷入口等组件，右侧包括tasks,item to approval,calendar,dashboard snapshot等等。&lt;/p&gt;
&lt;p&gt;有时，不同简档的用户需要看到不同的Home页面中的组件或者显示不同的custom link等操作，这时我们就需要针对不同的简档配置不同的home page layout。配置步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一. Home Page Layout配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Set Up处搜索home page找到Home Page Layouts进入;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211211258024-873053708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.输入custom home page layout 名称，勾选需要显示在左侧和中间部分需要显示的组件；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211222412946-92584031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.调整顺序并点击save &amp;amp; assign；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211222631274-1837050964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.将创建的page layout 分配给profile 为System Administrator保存；&lt;/strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211222833712-1037924475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.效果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171211223437321-810057550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过第一个图和效果展示的图可以看到通过自定义配置，将左侧的Create New组件拿掉了。&lt;/p&gt;
&lt;p&gt;通过上面的配置，我们看到针对profile自定义home page layout 很简单，无非就是勾选需要的component，调整顺序后分配一个或者多个简档即可。&lt;/p&gt;
&lt;p&gt;那么component是怎么出现的呢？&lt;/p&gt;
&lt;p&gt;component包含两部分，一部分是标准的component,包括Create New,Item to approve等等,另外一部分就是自定义 home page component.使用自定义home page component可以让你的home首页变得更加丰富，更加符合扩充的业务要求。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 二.Home Page Component&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.点击Set Up，搜索Home Page Component后点击Home Page Component&lt;/strong&gt;:从图中可以看到，上面标准的component包括常见的component,其中Messages &amp;amp; Alerts 和Custom Links可以自定义，其他均只能引用，无法修改，下面有新建自定义的Components的按钮可以新建；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171213214040644-1885338527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.点击New按钮新建Custom Components,可以分成四类创建&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　Links：选择一个或者一组custom link作为一个component展示，类似标准组件custom links效果，此种类型仅可以放在左侧（Narrow Component）；&lt;/li&gt;
&lt;li&gt;　　Image/Logo：一张图片展示在sidebar处，此处更多的是使用公司的logo；&lt;/li&gt;
&lt;li&gt;　　HTML Area：富文本编辑器展示HTML区域，此类型可以放在左侧(Narrow Component)，也可以放在右侧(Wide Component)；&lt;/li&gt;
&lt;li&gt;       Visualforce Area:展示一个VF Page，此类型可以放在左侧(Narrow Component),也可以放在右侧(Wide Component)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171213215932082-1357281077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Links类型为可以创建一个自定义链接展示在component中，后面会详细描述Links类型的展示，下面针对Image/Logo,HTML Area 以及Visualforce Area 类型简单描述。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.1 Image/Logo:此类型通常用于展示公司Logo，其他情况下根据业务情况自己抉择。显示的图片需要先上传Document上并且要求图片必须小于100K。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　选择Type类型为Image，Name赋值以后点击Next；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216131928637-973485963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　点击Insert an Image选择图片存在的Document，选择后点击Save。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216132652169-639679482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　点击需要添加的Home Page Layout，将需要的componnet选中，并调整Component显示顺序后Save；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216132743731-1682636155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　Home首页效果展示。 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216132853653-367266010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 　　2.2 Html Area : 此处可以使用富文本编辑器简单的展示你需要展示的HTML区块，此模块不支持HTML标签，区域可以根据你创建时的选择放在左侧以及右侧。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　选择Type为HTML Area 输入名称后选择Next；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216134203091-679292676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　使用富文本编辑器按照要求创建需要的富文本内容以及格式后点击Save；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216135041278-97387133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　更改Home Page Layout，选择Test Html Area后更改显示顺序点击Save.下图为显示效果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216135317841-521832750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;2.3 Visualforce Area : HTML Area展示的效果毕竟没法写样式有很多限制，展示Visualforce Page可以更加丰富页面效果，比如首页展示公司产品进行轮播等等。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　新建Type 为Visualforce Area的Component,并赋值Name；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216140100794-1756712336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 　　选择需要展示的Visualforce Page 设置显示的高度等设置信息点击Save,然后修改Home Page Layout，将此Component勾选；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216140757858-1066784292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　 展示效果：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216141014624-7445872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 三. Custom Link&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二步中有一项是创建类型为Custom Links，选择此类型后将一个或者一组Custom Link放在一起作为一个Component展示，Custom Link入口以及实现展示如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Set Up搜索Custom Link后在home下有一项为Custom Links,选中后即可新建或者更改Custom Link;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216202853389-1984893751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.Custom Link源包括三部分组成：URL,On Click JavaScript以及Visualforce Page。&lt;/strong&gt;重写过标准的action或者新建过action的小伙伴应该对下面的页面很熟悉，Custom Link同样也支持Merge Field；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　URL:此种方式直接在输入框写一下目标的URL即可，当然这里面是可以引用merge field以及function来简单的实现一些动态情况的处理；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216203755124-53945660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　On Click JavaScript：如果此链接是有复杂的逻辑进行确认最终的URL，可以使用On Click JavaScript,此种方式除了可以引用merge field以外，引入ajax toolkit js后还可以使用soql语句进行fetch操作来更加强大的支持你的业务要求。下面的例子为当前登录用户为lightning用户，则显示标准lightning页面，否则显示自定义列表页面；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216232425233-1365423662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Visualforce Page：指定点击此链接跳转到某个Visualforce Page页面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216232756843-767623932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.修改Home Page Component,&lt;/strong&gt;将需要显示的Custom Links 选中后，将此component显示在Home Page Layout上即可.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201712/910966-20171216233202858-2038390666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;此篇主要描述如何自定义Home主页的UI，以及Home Page Layout,Home Page Component,Custom Links使用，主要内容都是基于配置的，开发量基本没有。篇中有描述错误地方欢迎指出，有问题的欢迎留言。&lt;/p&gt;

</description>
<pubDate>Sat, 16 Dec 2017 15:37:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/7899371.html</dc:identifier>
</item>
<item>
<title>观中兴程序员跳楼之我见 - 邹琼俊</title>
<link>http://www.cnblogs.com/jiekzou/p/8048059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiekzou/p/8048059.html</guid>
<description>&lt;p&gt;数日前，中兴的一位42岁程序员跳楼引发了一场风波，中兴重新被推到了风口浪尖上，说实话，最近这几年，我都已经快忘记有中兴这家公司了，忘记这家曾经可以和华为分庭抗礼的公司，显然，它正逐渐被世人遗忘。&lt;img src=&quot;http://images2017.cnblogs.com/blog/413851/201712/413851-20171216231917639-2061374377.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;每次看见城里人跳楼，我总是想吐槽，尤其跳楼的还是同行。&lt;br/&gt;有些人肯定会说我冷漠，我只想说：真冷漠尤胜假仁义。真冷漠无公害，假仁义有如毒鸡汤，贻害无穷。&lt;/p&gt;&lt;p&gt;前阵子一保安伸手去接跳楼自杀的女子，双双身亡，连见义勇为都不算，有些跳楼自杀的人，居然还砸死路人，这，无力吐槽......”路见不平不吭声呀，拍拍屁股就走人哇，回家还要写代码啊...“&lt;/p&gt;&lt;p&gt;本来“死去元知万事空”，可是跳楼这样的事件，总是会成为小市民茶余饭后八卦和津津乐道的段子，别跟我说你有多伤心多同情、觉得多可惜...你若是真仁义，可曾去为死者家属捐过钱或者去悼念过，又或者去慰问过死难者的亲朋......显然是不会有的，最多在媒体上评论上一句：好可惜...何其廉价而又微不足道的一句话......&lt;/p&gt;&lt;p&gt;如果一个人自己都不珍惜自己的生命，别人又何必去怜惜他呢？自杀者，何足惜...&lt;br/&gt;歌词“心若在，梦就在...”说得太不明了，文化人都比较喜欢装B嘛，这大家都能理解，这里的“心”，不是死了的心脏或者冰冻的心脏，而是指人，人若在梦就在，人都不再了，还有啥梦可言呢？&lt;/p&gt;&lt;p&gt;都说三十而立，四十岁，男人正是花样年华，且上有老要孝敬，下有小要抚养，这一跳，死者解脱，活人受罪，作为男人，毫无家庭责任感可言，如果这么一点小挫折都承受不了，那么只能说：“有些人活着，他已经死了...&quot;要知道，社会上本来就存在各种黑暗，我们要学会坚强！从这一跳，不由得想起《三国演义》的歌词《这一拜》，然而到了这里却成了《这一跳》，我自己来填词好了。这一跳，快意恩仇赴黄泉，徒留代码在人间；这一跳，弃家逃避当懦夫，不忠不孝又不义；空余恨，这一跳，阴阳相隔，曾经沧海难为水，这一跳，生死不改，来世再做程序员......&lt;img src=&quot;http://images2017.cnblogs.com/blog/413851/201712/413851-20171216231824577-892498849.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;为什么要说是城里人跳楼，而不是农村人跳楼呢？一来城里楼高，二来城里人高调，三来城里人比较势力&lt;br/&gt;（死也要搏出名，信不信我死给你们看），即便是农村里来的人在城里待久了也很容易被同化。我曾经分析过，自杀的方式千千万，为何城里人钟爱跳楼，而农村人喜欢喝农药，文艺青年则钟情于卧轨自杀...&lt;br/&gt;有人说在城里跳楼最方便，可是这样子高空坠物，万一砸到人或者小朋友怎么办，就算不砸到人，砸到人家车、人家店、或者砸坏了花花草草，也不好嘛！而农村的人相对而言实在得多，也低调得多，更无公害性，独自一个人找个角落，偷偷的、默默的喝农药而亡，死了也无公害。&lt;/p&gt;&lt;p&gt;作为程序员，平时整天对着个电脑写代码，又少与人打交道，还是应该多”读书“，读书可以净化一个人的心灵，提升一个人的精神境界，尤其是读历史书，都说读史可以明智！&lt;/p&gt;&lt;p&gt;额外吐槽一下如今中国现状：以前由于职业习惯，背略微有点沉，个子又不高，而自己又是农村出来孩纸，没见过什么世面，总觉得缺乏男人应有的自信，但是自从遇见遍地低头族，我瞬间充满了自信，因为他们在我面前，总是抬不起头，所以我无论在公交、地铁上还是在走路，我总是昂首挺胸的走，遇见低头族，我头扬得更高，人更加有自信了，因为放眼望去，群雄俯首...哈哈！&lt;/p&gt;&lt;p&gt;自杀而亡者，不独性命堪，更是遗祸家人，悲呼哀哉！愿逝者安息！愿生者引以为戒！&lt;/p&gt;
&lt;p&gt;多少人曾羡慕你年轻时意气风发，可知谁叹息你冲发一怒去跳楼......&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tech.sina.com.cn/i/2017-12-15/doc-ifypsqiz9812858.shtml&quot; target=&quot;_blank&quot;&gt;中兴跳楼员工妻子现身 称跳楼因成公司内斗牺牲品&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 15:17:00 +0000</pubDate>
<dc:creator>邹琼俊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiekzou/p/8048059.html</dc:identifier>
</item>
<item>
<title>SQL基础教程读书笔记-1 - 喜欢天黑却怕鬼</title>
<link>http://www.cnblogs.com/songwenjie/p/8048051.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/8048051.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;51&quot;&gt;

&lt;h2&gt;&lt;span&gt;2.2 算数运算符和比较运算符&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;2.2.1算数运算符&lt;/span&gt;&lt;/h3&gt;
&lt;span&gt;&lt;strong&gt;+ - * /&lt;/strong&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt;需要注意&lt;strong&gt;NULL&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;5 + NULL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;10 - NULL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;1 * NULL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4 / NULL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;NULL / 9&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;NULL / 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;以上运算结果全都是NULL,实际上所有包含NULL的运算，结果肯定是NULL。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;2.2.2比较运算符&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;运算符&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;=&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;和~相等&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;和~不相等&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;大于等于~&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;大于~&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;小于~&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;lt;=&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;小于等于~&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;2.对字符串使用不等号时的注意事项&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;字符串类型的数据原则上按照字典进行排序&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11 &amp;gt; 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;但是 '11'&amp;lt;'2'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.不能对NULL使用比较运算符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;希望选取NULL记录时，需要在条件表达式中使用&lt;strong&gt;IS NULL&lt;/strong&gt;运算符；希望选取不是NULL的记录时，需要在条件表达式中使用&lt;strong&gt;IS NOT NULL&lt;/strong&gt; 运算符。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2.3逻辑运算符&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.SQL中的逻辑运算包含对真、假和不确定进行运算的三值逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;运算符&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;NOT&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;否定某一条件&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;AND&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;并且&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;OR&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;或&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;2.AND优先级高于OR，优先执行OR可以使用括号。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.三值逻辑中的AND和OR真值表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AND&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;P&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;Q&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;P AND Q&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;OR&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;P&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;Q&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;P OR Q&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;真&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;假&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不确定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;span&gt;3.1 对表进行聚合查询&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.聚合函数（集合函数）：计算之前已经将NULL排除在外。&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;COUNT&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;计算表中的记录数（行数）&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;SUM&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;计算表中数值列中数据的合计值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;AVG&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;计算表中数值列中数据的平均值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;MAX&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;求出表中任意列中数据的最大值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;MIN&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;求出表中任意列中数据的最小值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;2.COUNT函数的结果根据参数的不同而不同&lt;/span&gt;&lt;br/&gt;&lt;span&gt;COUNT(*)包含NULL的数据行数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;COUNT(&amp;lt;列名&amp;gt;)NULL之外的数据行数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;MAX/MIN函数几乎适用于所有数据类型的列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SUM/AVG只适用于数值类型的列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.使用聚合函数删除重复值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;COUNT( DISTINCT *)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.2对表进行分组&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.GROUP BY子句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SELECT &amp;lt;列名1&amp;gt;，&amp;lt;列名2&amp;gt;，&amp;lt;列名3&amp;gt;，...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;FROM &amp;lt;表明&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;GROUP BY &amp;lt;列名1&amp;gt;，&amp;lt;列名2&amp;gt;，&amp;lt;列名3&amp;gt;，...;&lt;br/&gt;&lt;strong&gt;聚合键中包含NULL时，在结果中会以&quot;不确定&quot;行（空行）的形式表现出来。&lt;/strong&gt;&lt;br/&gt;2.与聚合函数和GROUP BY子句有关的常见错误&lt;br/&gt;常见错误①——在SELECT子句中书写了多余的列（MYSQL 支持）&lt;br/&gt;使用聚合函数时，SELECT子句只能存在以下三种元素&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;常数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;聚合函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;GROUP BY 子句指定的列名（也就是聚合键）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;常见错误②——在GROUP BY子句中写了列的别名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下列语句会发生执行错误：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT product_type AS pt,count(*)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;FROM product&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GROUP BY pt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这是因为SQL在DBMS中的执行顺序造成的——SELECT子句在GROUP BY子句之后执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常见错误③——GROUP BY子句结果能排序吗&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GROUP BY 子句结果的显示是无序的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常见错误④——在WHERE子句中使用聚合函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;只有SELECT子句和HAVING子句（以及ORDER BY子句）中能够使用聚合函数。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.3为聚合结果指定条件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.HAVING子句为集合（组）指定条件。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HAVING可以使用3中要素：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;常数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;聚合函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;GROUP BY子句中指定的列名（聚合键）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.相对于HAVING子句，更适合写在WHERE 子句中的条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;聚合键所对应的条件不应写在HAVING子句当中，而应写在WHERE子句中。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;原因：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①:WHERE子句 = 指定行所对应的条件；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HAVING子句 = 指定组所对应的条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;②:WHERE执行速度快，使用COUNT函数等对表中数据进行聚合操作时，DBMS内部会进行排序处理，尽可能减少排序的行数，才能增加处理速度。WHERE在排序前过滤，减少了排序行数。HAVING在排序之后进行过滤。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.4 对查询结果进行排序&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.使用ORDER BY对查询结果进行排序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.在ORDER BY 子句中列名的后面使用关键字ASC 可以进行升序排序；使用DESC关键字可以进行降序排序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.ORDER BY子句中可以使用多个排序键。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.排序键包含NULL时，会在开头或末尾进行汇总。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.在ORDER BY子句中可以使用SELECT子句中定义的别名。这是因为SELECT的执行顺序：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;FROM——&amp;gt;WHERE——&amp;gt;GROUP BY ——&amp;gt;HAVING ——&amp;gt;SELECT ——&amp;gt;ORDER BY&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6.在ORDER BY子句中可以使用SELECT子句中未使用的列和聚合函数。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 16 Dec 2017 15:16:00 +0000</pubDate>
<dc:creator>喜欢天黑却怕鬼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/8048051.html</dc:identifier>
</item>
<item>
<title>虚拟DOM详解 - 木的树</title>
<link>http://www.cnblogs.com/dojo-lzz/p/8047742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dojo-lzz/p/8047742.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; global module, document, Node &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
import {Module} from &lt;/span&gt;'./modules/module'&lt;span&gt;;
import {Hooks} from &lt;/span&gt;'./hooks'&lt;span&gt;;
import vnode, {VNode, VNodeData, Key} from &lt;/span&gt;'./vnode'&lt;span&gt;;
import &lt;/span&gt;* as is from './is'&lt;span&gt;;
import htmlDomApi, {DOMAPI} from &lt;/span&gt;'./htmldomapi'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; isUndef(s: any): &lt;span&gt;boolean&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; s ===&lt;span&gt; undefined; }
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; isDef(s: any): &lt;span&gt;boolean&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; s !==&lt;span&gt; undefined; }

type VNodeQueue &lt;/span&gt;= Array&amp;lt;VNode&amp;gt;&lt;span&gt;;

const emptyNode &lt;/span&gt;= vnode(''&lt;span&gt;, {}, [], undefined, undefined);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; sameVnode(vnode1: VNode, vnode2: VNode): &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vnode1.key === vnode2.key &amp;amp;&amp;amp; vnode1.sel ===&lt;span&gt; vnode2.sel;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; isVnode(vnode: any): vnode is VNode {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vnode.sel !==&lt;span&gt; undefined;
}

type KeyToIndexMap &lt;/span&gt;=&lt;span&gt; {[key: string]: number};

type ArraysOf&lt;/span&gt;&amp;lt;T&amp;gt; =&lt;span&gt; {
  [K &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; keyof T]: (T[K])[];
}

type ModuleHooks &lt;/span&gt;= ArraysOf&amp;lt;Module&amp;gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; createKeyToOldIdx(children: Array&amp;lt;VNode&amp;gt;&lt;span&gt;, beginIdx: number, endIdx: number): KeyToIndexMap {
  let i: number, map: KeyToIndexMap &lt;/span&gt;= {}, key: Key |&lt;span&gt; undefined, ch;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = beginIdx; i &amp;lt;= endIdx; ++&lt;span&gt;i) {
    ch &lt;/span&gt;=&lt;span&gt; children[i];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      key &lt;/span&gt;=&lt;span&gt; ch.key;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key !== undefined) map[key] =&lt;span&gt; i;
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
}

const hooks: (keyof Module)[] &lt;/span&gt;= ['create', 'update', 'remove', 'destroy', 'pre', 'post'&lt;span&gt;];

export {h} from &lt;/span&gt;'./h'&lt;span&gt;;
export {thunk} from &lt;/span&gt;'./thunk'&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; init(modules: Array&amp;lt;Partial&amp;lt;Module&amp;gt;&amp;gt;, domApi?&lt;span&gt;: DOMAPI) {
  let i: number, j: number, cbs &lt;/span&gt;=&lt;span&gt; ({} as ModuleHooks);

  const api: DOMAPI &lt;/span&gt;= domApi !== undefined ?&lt;span&gt; domApi : htmlDomApi;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将各个模块的增删改查钩子方法挂在模块钩子集合中&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; hooks.length; ++&lt;span&gt;i) {
    cbs[hooks[i]] &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = 0; j &amp;lt; modules.length; ++&lt;span&gt;j) {
      const hook &lt;/span&gt;=&lt;span&gt; modules[j][hooks[i]];
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hook !==&lt;span&gt; undefined) {
        (cbs[hooks[i]] as Array&lt;/span&gt;&amp;lt;any&amp;gt;&lt;span&gt;).push(hook);
      }
    }
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; emptyNodeAt(elm: Element) {
    const id &lt;/span&gt;= elm.id ? '#' + elm.id : ''&lt;span&gt;;
    const c &lt;/span&gt;= elm.className ? '.' + elm.className.split(' ').join('.') : ''&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vnode(api.tagName(elm).toLowerCase() + id +&lt;span&gt; c, {}, [], undefined, elm);
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createRmCb(childElm: Node, listeners: number) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; rmCb() {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (--listeners === 0&lt;span&gt;) {
        const parent &lt;/span&gt;=&lt;span&gt; api.parentNode(childElm);
        api.removeChild(parent, childElm);
      }
    };
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {
    let i: any, data &lt;/span&gt;=&lt;span&gt; vnode.data;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data !==&lt;span&gt; undefined) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.init)) {
        i(vnode);
        data &lt;/span&gt;=&lt;span&gt; vnode.data;
      }
    }
    let children &lt;/span&gt;= vnode.children, sel =&lt;span&gt; vnode.sel;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sel === '!'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isUndef(vnode.text)) {
        vnode.text &lt;/span&gt;= ''&lt;span&gt;;
      }
      vnode.elm &lt;/span&gt;=&lt;span&gt; api.createComment(vnode.text as string);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sel !==&lt;span&gt; undefined) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parse selector&lt;/span&gt;
      const hashIdx = sel.indexOf('#'&lt;span&gt;);
      const dotIdx &lt;/span&gt;= sel.indexOf('.'&lt;span&gt;, hashIdx);
      const hash &lt;/span&gt;= hashIdx &amp;gt; 0 ?&lt;span&gt; hashIdx : sel.length;
      const dot &lt;/span&gt;= dotIdx &amp;gt; 0 ?&lt;span&gt; dotIdx : sel.length;
      const tag &lt;/span&gt;= hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0&lt;span&gt;, Math.min(hash, dot)) : sel;
      const elm &lt;/span&gt;= vnode.elm = isDef(data) &amp;amp;&amp;amp; isDef(i = (data as VNodeData).ns) ?&lt;span&gt; api.createElementNS(i, tag)
                                                                               : api.createElement(tag);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hash &amp;lt; dot) elm.setAttribute('id', sel.slice(hash + 1&lt;span&gt;, dot));
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dotIdx &amp;gt; 0) elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '&lt;span&gt;));
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.create.length; ++&lt;span&gt;i) cbs.create[i](emptyNode, vnode);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (is.array(children)) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; children.length; ++&lt;span&gt;i) {
          const ch &lt;/span&gt;=&lt;span&gt; children[i];
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));
          }
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (is.primitive(vnode.text)) {
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      i &lt;/span&gt;= (vnode.data as VNodeData).hook; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reuse variable&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(i)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (i.create) i.create(emptyNode, vnode);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (i.insert) insertedVnodeQueue.push(vnode);
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      vnode.elm &lt;/span&gt;=&lt;span&gt; api.createTextNode(vnode.text as string);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vnode.elm;
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; addVnodes(parentElm: Node,
                     before: Node &lt;/span&gt;| &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                     vnodes: Array&lt;/span&gt;&amp;lt;VNode&amp;gt;&lt;span&gt;,
                     startIdx: number,
                     endIdx: number,
                     insertedVnodeQueue: VNodeQueue) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; startIdx &amp;lt;= endIdx; ++&lt;span&gt;startIdx) {
      const ch &lt;/span&gt;=&lt;span&gt; vnodes[startIdx];
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
      }
    }
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; invokeDestroyHook(vnode: VNode) {
    let i: any, j: number, data &lt;/span&gt;=&lt;span&gt; vnode.data;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data !==&lt;span&gt; undefined) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.destroy)) i(vnode);
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.destroy.length; ++&lt;span&gt;i) cbs.destroy[i](vnode);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vnode.children !==&lt;span&gt; undefined) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = 0; j &amp;lt; vnode.children.length; ++&lt;span&gt;j) {
          i &lt;/span&gt;=&lt;span&gt; vnode.children[j];
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; i !== &quot;string&quot;&lt;span&gt;) {
            invokeDestroyHook(i);
          }
        }
      }
    }
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; removeVnodes(parentElm: Node,
                        vnodes: Array&lt;/span&gt;&amp;lt;VNode&amp;gt;&lt;span&gt;,
                        startIdx: number,
                        endIdx: number): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; startIdx &amp;lt;= endIdx; ++&lt;span&gt;startIdx) {
      let i: any, listeners: number, rm: () &lt;/span&gt;=&amp;gt; &lt;span&gt;void&lt;/span&gt;, ch =&lt;span&gt; vnodes[startIdx];
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners &lt;/span&gt;= cbs.remove.length + 1&lt;span&gt;;
          rm &lt;/span&gt;=&lt;span&gt; createRmCb(ch.elm as Node, listeners);
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.remove.length; ++&lt;span&gt;i) cbs.remove[i](ch, rm);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i = ch.data) &amp;amp;&amp;amp; isDef(i = i.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.remove)) {
            i(ch, rm);
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            rm();
          }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Text node&lt;/span&gt;
&lt;span&gt;          api.removeChild(parentElm, ch.elm as Node);
        }
      }
    }
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; updateChildren(parentElm: Node,
                          oldCh: Array&lt;/span&gt;&amp;lt;VNode&amp;gt;&lt;span&gt;,
                          newCh: Array&lt;/span&gt;&amp;lt;VNode&amp;gt;&lt;span&gt;,
                          insertedVnodeQueue: VNodeQueue) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明指针&lt;/span&gt;
    let oldStartIdx = 0, newStartIdx = 0&lt;span&gt;;
    let oldEndIdx &lt;/span&gt;= oldCh.length - 1&lt;span&gt;;

    let oldStartVnode &lt;/span&gt;= oldCh[0&lt;span&gt;];
    let oldEndVnode &lt;/span&gt;=&lt;span&gt; oldCh[oldEndIdx];
    let newEndIdx &lt;/span&gt;= newCh.length - 1&lt;span&gt;;
    let newStartVnode &lt;/span&gt;= newCh[0&lt;span&gt;];
    let newEndVnode &lt;/span&gt;=&lt;span&gt; newCh[newEndIdx];
    let oldKeyToIdx: any;
    let idxInOld: number;
    let elmToMove: VNode;
    let before: any;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (oldStartIdx &amp;lt;= oldEndIdx &amp;amp;&amp;amp; newStartIdx &amp;lt;=&lt;span&gt; newEndIdx) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果节点已经被标记处理过，直接跳过&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (oldStartVnode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        oldStartVnode &lt;/span&gt;= oldCh[++oldStartIdx]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vnode might have been moved left&lt;/span&gt;
      } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldEndVnode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        oldEndVnode &lt;/span&gt;= oldCh[--&lt;span&gt;oldEndIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (newStartVnode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (newEndVnode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        newEndVnode &lt;/span&gt;= newCh[--&lt;span&gt;newEndIdx];

      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sameVnode(oldStartVnode, newStartVnode)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理头头相同情况&lt;/span&gt;
&lt;span&gt;        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode &lt;/span&gt;= oldCh[++&lt;span&gt;oldStartIdx];
        newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sameVnode(oldEndVnode, newEndVnode)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾尾相同&lt;/span&gt;
&lt;span&gt;        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode &lt;/span&gt;= oldCh[--&lt;span&gt;oldEndIdx];
        newEndVnode &lt;/span&gt;= newCh[--&lt;span&gt;newEndIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sameVnode(oldStartVnode, newEndVnode)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头尾相同 // Vnode moved right&lt;/span&gt;
&lt;span&gt;        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将oldStart指向的节点插入到oldEnd指向节点前面&lt;/span&gt;
&lt;span&gt;        api.insertBefore(parentElm, oldStartVnode.elm as Node, api.nextSibling(oldEndVnode.elm as Node));
        oldStartVnode &lt;/span&gt;= oldCh[++&lt;span&gt;oldStartIdx];
        newEndVnode &lt;/span&gt;= newCh[--&lt;span&gt;newEndIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sameVnode(oldEndVnode, newStartVnode)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vnode moved left 尾头相同&lt;/span&gt;
&lt;span&gt;        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将oldEnd指向节点插入到oldStart之前&lt;/span&gt;
&lt;span&gt;        api.insertBefore(parentElm, oldEndVnode.elm as Node, oldStartVnode.elm as Node);
        oldEndVnode &lt;/span&gt;= oldCh[--&lt;span&gt;oldEndIdx];
        newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx];
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldKeyToIdx === undefined) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 制作key-index的哈西集合&lt;/span&gt;
          oldKeyToIdx =&lt;span&gt; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld &lt;/span&gt;=&lt;span&gt; oldKeyToIdx[newStartVnode.key as string];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isUndef(idxInOld)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; New element&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新节点则插入到oldStart指向的dom节点之前&lt;/span&gt;
&lt;span&gt;          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node);
          newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx];
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          elmToMove &lt;/span&gt;=&lt;span&gt; oldCh[idxInOld];
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (elmToMove.sel !==&lt;span&gt; newStartVnode.sel) {
            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node);
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打补丁&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对旧的位置坐标记设为undefined&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将更新后的节点移动到oldStart之前&lt;/span&gt;
&lt;span&gt;            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] &lt;/span&gt;=&lt;span&gt; undefined as any;
            api.insertBefore(parentElm, (elmToMove.elm as Node), oldStartVnode.elm as Node);
          }
          newStartVnode &lt;/span&gt;= newCh[++&lt;span&gt;newStartIdx];
        }
      }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldStartIdx &amp;gt; oldEndIdx) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新的有剩余则需要将这些节点插入到dom树中&lt;/span&gt;
      before = newCh[newEndIdx+1] == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : newCh[newEndIdx+1&lt;span&gt;].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (newStartIdx &amp;gt; newEndIdx) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 老的有节点则应该移除&lt;/span&gt;
&lt;span&gt;      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; patchVnode(oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) {
    let i: any, hook: any;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用prepatch钩子&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (isDef(i = vnode.data) &amp;amp;&amp;amp; isDef(hook = i.hook) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; hook.prepatch)) {
      i(oldVnode, vnode);
    }
    const elm &lt;/span&gt;= vnode.elm =&lt;span&gt; (oldVnode.elm as Node);
    let oldCh &lt;/span&gt;=&lt;span&gt; oldVnode.children;
    let ch &lt;/span&gt;=&lt;span&gt; vnode.children;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldVnode === vnode) &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有变化直接返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (vnode.data !== undefined) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对两个虚拟dom树的根节点进行更新&lt;/span&gt;
      &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.update.length; ++&lt;span&gt;i) cbs.update[i](oldVnode, vnode);
      i &lt;/span&gt;=&lt;span&gt; vnode.data.hook;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(i) &amp;amp;&amp;amp; isDef(i =&lt;span&gt; i.update)) i(oldVnode, vnode);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isUndef(vnode.text)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否有文本节点&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (isDef(oldCh) &amp;amp;&amp;amp; isDef(ch)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 都有子节点对子节点进行diff算法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (oldCh !== ch) updateChildren(elm, oldCh as Array&amp;lt;VNode&amp;gt;, ch as Array&amp;lt;VNode&amp;gt;&lt;span&gt;, insertedVnodeQueue);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (isDef(ch)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新虚拟dom有子节点旧的没有，则把新的子节点挂在dom上&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (isDef(oldVnode.text)) api.setTextContent(elm, ''&lt;span&gt;);
        addVnodes(elm, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, ch as Array&amp;lt;VNode&amp;gt;, 0, (ch as Array&amp;lt;VNode&amp;gt;).length - 1&lt;span&gt;, insertedVnodeQueue);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (isDef(oldCh)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 老的里面有子节点，新的没有直接干掉老的&lt;/span&gt;
        removeVnodes(elm, oldCh as Array&amp;lt;VNode&amp;gt;, 0, (oldCh as Array&amp;lt;VNode&amp;gt;).length - 1&lt;span&gt;);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (isDef(oldVnode.text)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 老的有文本信息直接设置为空字符串&lt;/span&gt;
        api.setTextContent(elm, ''&lt;span&gt;);
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldVnode.text !== vnode.text) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用新的文本信息替换旧的&lt;/span&gt;
&lt;span&gt;      api.setTextContent(elm, vnode.text as string);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDef(hook) &amp;amp;&amp;amp; isDef(i = hook.postpatch)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用postpatch方法&lt;/span&gt;
&lt;span&gt;      i(oldVnode, vnode);
    }
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; patch(oldVnode: VNode |&lt;span&gt; Element, vnode: VNode): VNode {
    let i: number, elm: Node, parent: Node;
    const insertedVnodeQueue: VNodeQueue &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.pre.length; ++i) cbs.pre[i]();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用所有模块的pre钩子方法&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (!isVnode(oldVnode)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 非虚拟dom直接清空&lt;/span&gt;
      oldVnode =&lt;span&gt; emptyNodeAt(oldVnode);
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sameVnode(oldVnode, vnode)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 两个虚拟dom树的根节点完全一样才会进行打补丁&lt;/span&gt;
&lt;span&gt;      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果跟节点不同直接干掉旧的根节点，重新创建dom元素插入到dom树中&lt;/span&gt;
      elm =&lt;span&gt; oldVnode.elm as Node;
      parent &lt;/span&gt;=&lt;span&gt; api.parentNode(elm);

      createElm(vnode, insertedVnodeQueue);

      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parent !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm));
        removeVnodes(parent, [oldVnode], &lt;/span&gt;0, 0&lt;span&gt;);
      }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对每个插入的元素使用相应模块中的insert钩子方法进行更新&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; insertedVnodeQueue.length; ++&lt;span&gt;i) {
      (((insertedVnodeQueue[i].data as VNodeData).hook as Hooks).insert as any)(insertedVnodeQueue[i]);
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; cbs.post.length; ++i) cbs.post[i](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用所有钩子模块的post方法&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; vnode;
  };
}&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 16 Dec 2017 14:20:00 +0000</pubDate>
<dc:creator>木的树</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dojo-lzz/p/8047742.html</dc:identifier>
</item>
<item>
<title>Mybatis框架解析之Builder解析 - KMSFan</title>
<link>http://www.cnblogs.com/kmsfan/p/8047878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kmsfan/p/8047878.html</guid>
<description>&lt;p&gt;首先我们从builder这个类入手，首先我们注意到BaseBuilder,其实它的本质上市一个抽象类，它从本质上抽象出了Builder的一切，我猜想这里一定使用了建造者模式，但是这个抽象类里面居然没有抽象方法！&lt;/p&gt;
&lt;p&gt;其中XXXValueOf方法，其实是把String字符串转换成了相对应的类型，如下代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bd682ed8-cb54-43fe-9d1b-de14354b353b')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_bd682ed8-cb54-43fe-9d1b-de14354b353b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bd682ed8-cb54-43fe-9d1b-de14354b353b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bd682ed8-cb54-43fe-9d1b-de14354b353b',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bd682ed8-cb54-43fe-9d1b-de14354b353b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Boolean booleanValueOf(String value, Boolean defaultValue) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; defaultValue : Boolean.valueOf(value);
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Integer integerValueOf(String value, Integer defaultValue) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; defaultValue : Integer.valueOf(value);
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; stringSetValueOf(String value, String defaultValue) {
    value &lt;/span&gt;= (value == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; defaultValue : value);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;String&amp;gt;(Arrays.asList(value.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中resoveXXXType的目的就是把string转换成相对应的类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('45dba8f4-175e-4503-a8a8-e1cd7a634cd1')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_45dba8f4-175e-4503-a8a8-e1cd7a634cd1&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_45dba8f4-175e-4503-a8a8-e1cd7a634cd1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('45dba8f4-175e-4503-a8a8-e1cd7a634cd1',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_45dba8f4-175e-4503-a8a8-e1cd7a634cd1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; JdbcType resolveJdbcType(String alias) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (alias == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; JdbcType.valueOf(alias);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error resolving JdbcType. Cause: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e, e);
    }
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ResultSetType resolveResultSetType(String alias) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (alias == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultSetType.valueOf(alias);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error resolving ResultSetType. Cause: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e, e);
    }
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ParameterMode resolveParameterMode(String alias) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (alias == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ParameterMode.valueOf(alias);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error resolving ParameterMode. Cause: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e, e);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;下面的方法是通过字符串别名解析出相对应的类型，再从类型创建实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d4589562-b55e-457c-8ce4-fa8785264a7a')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_d4589562-b55e-457c-8ce4-fa8785264a7a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d4589562-b55e-457c-8ce4-fa8785264a7a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d4589562-b55e-457c-8ce4-fa8785264a7a',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d4589562-b55e-457c-8ce4-fa8785264a7a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object createInstance(String alias) {
    Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; resolveClass(alias);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolveClass(alias).newInstance();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error creating instance. Cause: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e, e);
    }
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; resolveClass(String alias) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (alias == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolveAlias(alias);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error resolving class. Cause: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e, e);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;注意下面的，是2个不同的重载类，是第一个调用第二个。首先得到相对应的TypeHanlder类型，如果该TypeHanlder在typeHanlderRegisty注册中心有留存，那么返回，否则从javatype里创建一个新的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('536e4b64-a3ef-443c-82ac-0f85eec35e1b')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_536e4b64-a3ef-443c-82ac-0f85eec35e1b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_536e4b64-a3ef-443c-82ac-0f85eec35e1b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('536e4b64-a3ef-443c-82ac-0f85eec35e1b',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_536e4b64-a3ef-443c-82ac-0f85eec35e1b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; TypeHandler&amp;lt;?&amp;gt; resolveTypeHandler(Class&amp;lt;?&amp;gt;&lt;span&gt; javaType, String typeHandlerAlias) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (typeHandlerAlias == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    Class&lt;/span&gt;&amp;lt;?&amp;gt; type =&lt;span&gt; resolveClass(typeHandlerAlias);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !TypeHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(type)) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + type.getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; is not a valid TypeHandler because it does not implement TypeHandler interface&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    @SuppressWarnings( &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unchecked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; already verified it is a TypeHandler&lt;/span&gt;
    Class&amp;lt;? extends TypeHandler&amp;lt;?&amp;gt;&amp;gt; typeHandlerType = (Class&amp;lt;? extends TypeHandler&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt;) type;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolveTypeHandler(javaType, typeHandlerType);
  }

  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; TypeHandler&amp;lt;?&amp;gt; resolveTypeHandler(Class&amp;lt;?&amp;gt; javaType, Class&amp;lt;? extends TypeHandler&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt; typeHandlerType) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (typeHandlerType == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; javaType ignored for injected handlers see issue #746 for full detail&lt;/span&gt;
    TypeHandler&amp;lt;?&amp;gt; handler =&lt;span&gt; typeHandlerRegistry.getMappingTypeHandler(typeHandlerType);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; not in registry, create a new one&lt;/span&gt;
      handler =&lt;span&gt; typeHandlerRegistry.getInstance(javaType, typeHandlerType);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handler;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中MapperBuilderAssistant在此包下面，并且继承了BaseBuilder,下面对此类做一个解析，比如下面的就是解析命名空间的，就是包名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b6ec82c5-06f1-4b65-97cf-cda253c2edd3')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_b6ec82c5-06f1-4b65-97cf-cda253c2edd3&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b6ec82c5-06f1-4b65-97cf-cda253c2edd3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b6ec82c5-06f1-4b65-97cf-cda253c2edd3',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b6ec82c5-06f1-4b65-97cf-cda253c2edd3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; String applyCurrentNamespace(String &lt;span&gt;base&lt;/span&gt;&lt;span&gt;, boolean isReference) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;base&lt;/span&gt; == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isReference) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is it qualified with any namespace yet?&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;base&lt;/span&gt;.contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;;
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is it qualified with this namespace yet?&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;base&lt;/span&gt;.startsWith(currentNamespace + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;base&lt;/span&gt;.contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dots are not allowed in element names, please remove it from &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;base&lt;/span&gt;&lt;span&gt;);
      }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; currentNamespace + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;base&lt;/span&gt;&lt;span&gt;;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;下面的代码主要是用namespace得到cache的一个实例，就这么理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b430db11-5d08-4ec1-a3ec-0c1163339d76')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_b430db11-5d08-4ec1-a3ec-0c1163339d76&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b430db11-5d08-4ec1-a3ec-0c1163339d76&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b430db11-5d08-4ec1-a3ec-0c1163339d76',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b430db11-5d08-4ec1-a3ec-0c1163339d76&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; Cache useCacheRef(String &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;namespace&lt;/span&gt; == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cache-ref element requires a namespace attribute.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      unresolvedCacheRef &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      Cache cache &lt;/span&gt;= configuration.getCache(&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cache == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IncompleteElementException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No cache for namespace '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;namespace&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' could be found.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      }
      currentCache &lt;/span&gt;=&lt;span&gt; cache;
      unresolvedCacheRef &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IncompleteElementException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No cache for namespace '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;namespace&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' could be found.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;下面的方法是创建cache。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f316c6ed-1725-41ce-9010-6fed9ad92ecb')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_f316c6ed-1725-41ce-9010-6fed9ad92ecb&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f316c6ed-1725-41ce-9010-6fed9ad92ecb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f316c6ed-1725-41ce-9010-6fed9ad92ecb',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f316c6ed-1725-41ce-9010-6fed9ad92ecb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Cache useNewCache(Class&amp;lt;? extends Cache&amp;gt;&lt;span&gt; typeClass,
      Class&lt;/span&gt;&amp;lt;? extends Cache&amp;gt;&lt;span&gt; evictionClass,
      Long flushInterval,
      Integer size,
      boolean readWrite,
      boolean blocking,
      Properties props) {
    Cache cache &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CacheBuilder(currentNamespace)
        .implementation(valueOrDefault(typeClass, PerpetualCache.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;))
        .addDecorator(valueOrDefault(evictionClass, LruCache.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;))
        .clearInterval(flushInterval)
        .size(size)
        .readWrite(readWrite)
        .blocking(blocking)
        .properties(props)
        .build();
    configuration.addCache(cache);
    currentCache &lt;/span&gt;=&lt;span&gt; cache;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中有一个地方要弄清楚，就是Class&amp;lt;? extends Cache&amp;gt; typeClass,    Class&amp;lt;? extends Cache&amp;gt; evictionClass的区别在哪里？在哪里呢？请看下图，一个是实现，一个是装饰者，你可以暂时理解为作用不同，就这么简单。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/567748/201712/567748-20171216214324968-1281445395.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;下面是addParameterMap方法的一些介绍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; ParameterMap addParameterMap(String id, Class&amp;lt;?&amp;gt; parameterClass, List&amp;lt;ParameterMapping&amp;gt;&lt;span&gt; parameterMappings) {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到包名。&lt;/span&gt;
    id = applyCurrentNamespace(id, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工厂方法创建参数Map,并添加到configuration中去。&lt;/span&gt;
    ParameterMap parameterMap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParameterMap.Builder(configuration, id, parameterClass, parameterMappings).build();
    configuration.addParameterMap(parameterMap);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; parameterMap;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是buildParameterMap的介绍，其实它也是利用了工厂方法骑构造。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6c07fa04-8ca6-4f31-bde4-94006be3b017')&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_6c07fa04-8ca6-4f31-bde4-94006be3b017&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6c07fa04-8ca6-4f31-bde4-94006be3b017&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6c07fa04-8ca6-4f31-bde4-94006be3b017',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6c07fa04-8ca6-4f31-bde4-94006be3b017&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ParameterMapping buildParameterMapping(
      Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; parameterType,
      String property,
      Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; javaType,
      JdbcType jdbcType,
      String resultMap,
      ParameterMode parameterMode,
      Class&lt;/span&gt;&amp;lt;? extends TypeHandler&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt; typeHandler,
      Integer numericScale) {
    resultMap &lt;/span&gt;= applyCurrentNamespace(resultMap, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Class parameterType = parameterMapBuilder.type();&lt;/span&gt;
    Class&amp;lt;?&amp;gt; javaTypeClass =&lt;span&gt; resolveParameterJavaType(parameterType, property, javaType, jdbcType);
    TypeHandler&lt;/span&gt;&amp;lt;?&amp;gt; typeHandlerInstance =&lt;span&gt; resolveTypeHandler(javaTypeClass, typeHandler);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParameterMapping.Builder(configuration, property, javaTypeClass)
        .jdbcType(jdbcType)
        .resultMapId(resultMap)
        .mode(parameterMode)
        .numericScale(numericScale)
        .typeHandler(typeHandlerInstance)
        .build();
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;下面的是建立一个结果集，然后把结果集添加到configuration里面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('db783f49-dab1-436d-8279-816419f036d2')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_db783f49-dab1-436d-8279-816419f036d2&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_db783f49-dab1-436d-8279-816419f036d2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('db783f49-dab1-436d-8279-816419f036d2',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_db783f49-dab1-436d-8279-816419f036d2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResultMap addResultMap(
      String id,
      Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; type,
      String extend,
      Discriminator discriminator,
      List&lt;/span&gt;&amp;lt;ResultMapping&amp;gt;&lt;span&gt; resultMappings,
      Boolean autoMapping) {
    id &lt;/span&gt;= applyCurrentNamespace(id, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    extend &lt;/span&gt;= applyCurrentNamespace(extend, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (extend != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;configuration.hasResultMap(extend)) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IncompleteElementException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Could not find a parent resultmap with id '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + extend + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      }
      ResultMap resultMap &lt;/span&gt;=&lt;span&gt; configuration.getResultMap(extend);
      List&lt;/span&gt;&amp;lt;ResultMapping&amp;gt; extendedResultMappings = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;ResultMapping&amp;gt;&lt;span&gt;(resultMap.getResultMappings());
      extendedResultMappings.removeAll(resultMappings);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove parent constructor if this resultMap declares a constructor.&lt;/span&gt;
      boolean declaresConstructor = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ResultMapping resultMapping : resultMappings) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) {
          declaresConstructor &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (declaresConstructor) {
        Iterator&lt;/span&gt;&amp;lt;ResultMapping&amp;gt; extendedResultMappingsIter =&lt;span&gt; extendedResultMappings.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (extendedResultMappingsIter.hasNext()) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (extendedResultMappingsIter.next().getFlags().contains(ResultFlag.CONSTRUCTOR)) {
            extendedResultMappingsIter.remove();
          }
        }
      }
      resultMappings.addAll(extendedResultMappings);
    }
    ResultMap resultMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)
        .discriminator(discriminator)
        .build();
    configuration.addResultMap(resultMap);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;当然，下面的也太多了，就不一一介绍了，还有一些这些结果集的一些Getter方法；有兴趣的可以自己去看看，不过我们从这里得到了一个很重要的东西，那就是贯穿上下文的一个东西：Configuration!,这个东西可以说是无处不在，不管是在基类，还是在派生类中。&lt;/p&gt;
&lt;p&gt;我们还看到了一些工厂的Relover，那这些resover类其实也是调用了上面的一些public方法而已，没啥特别的，真的。&lt;/p&gt;
&lt;p&gt;下面我们再看看SqlSourceBuilder 这个类，这个先从string解析成map,然后再判断是否是sql类型，如果是，继续解析。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e06a2dd0-16ea-4cc7-816f-949e0b689c8c')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_e06a2dd0-16ea-4cc7-816f-949e0b689c8c&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e06a2dd0-16ea-4cc7-816f-949e0b689c8c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e06a2dd0-16ea-4cc7-816f-949e0b689c8c',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e06a2dd0-16ea-4cc7-816f-949e0b689c8c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ParameterMapping buildParameterMapping(String content) {
      Map&lt;/span&gt;&amp;lt;String, String&amp;gt; propertiesMap =&lt;span&gt; parseParameterMapping(content);
      String property &lt;/span&gt;= propertiesMap.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; propertyType;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (metaParameters.hasGetter(property)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; issue #448 get type from additional params&lt;/span&gt;
        propertyType =&lt;span&gt; metaParameters.getGetterType(property);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (typeHandlerRegistry.hasTypeHandler(parameterType)) {
        propertyType &lt;/span&gt;=&lt;span&gt; parameterType;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (JdbcType.CURSOR.name().equals(propertiesMap.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jdbcType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))) {
        propertyType &lt;/span&gt;= java.sql.ResultSet.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (property == &lt;span&gt;null&lt;/span&gt; || Map.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(parameterType)) {
        propertyType &lt;/span&gt;= Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        MetaClass metaClass &lt;/span&gt;=&lt;span&gt; MetaClass.forClass(parameterType, configuration.getReflectorFactory());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (metaClass.hasGetter(property)) {
          propertyType &lt;/span&gt;=&lt;span&gt; metaClass.getGetterType(property);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          propertyType &lt;/span&gt;= Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        }
      }
      ParameterMapping.Builder builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParameterMapping.Builder(configuration, property, propertyType);
      Class&lt;/span&gt;&amp;lt;?&amp;gt; javaType =&lt;span&gt; propertyType;
      String typeHandlerAlias &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, String&amp;gt;&lt;span&gt; entry : propertiesMap.entrySet()) {
        String name &lt;/span&gt;=&lt;span&gt; entry.getKey();
        String value &lt;/span&gt;=&lt;span&gt; entry.getValue();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;javaType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          javaType &lt;/span&gt;=&lt;span&gt; resolveClass(value);
          builder.javaType(javaType);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jdbcType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          builder.jdbcType(resolveJdbcType(value));
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          builder.mode(resolveParameterMode(value));
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numericScale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          builder.numericScale(Integer.valueOf(value));
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          builder.resultMapId(value);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;typeHandler&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          typeHandlerAlias &lt;/span&gt;=&lt;span&gt; value;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jdbcTypeName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          builder.jdbcTypeName(value);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do Nothing&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;expression&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(name)) {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Expression based parameters are not supported yet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BuilderException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An invalid property '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' was found in mapping #{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + content + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}.  Valid properties are &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; parameterProperties);
        }
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (typeHandlerAlias != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        builder.typeHandler(resolveTypeHandler(javaType, typeHandlerAlias));
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder.build();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中比较重要的就是下面的代码，下面做一个分析，首先会得到typeHanldler,然后再在buidler里对这个进行注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;if&lt;/span&gt; (typeHandlerAlias != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        builder.typeHandler(resolveTypeHandler(javaType, typeHandlerAlias));
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; builder.build();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们关键是看看builder.build方法，它是一个private的方法，它的作用就是get到我们开始设置的值，下面的validate方法也是做一些基础验证的，具体的可以略过，没啥价值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; resolveTypeHandler() {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameterMapping.typeHandler == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; parameterMapping.javaType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        Configuration configuration &lt;/span&gt;=&lt;span&gt; parameterMapping.configuration;
        TypeHandlerRegistry typeHandlerRegistry &lt;/span&gt;=&lt;span&gt; configuration.getTypeHandlerRegistry();
        parameterMapping.typeHandler &lt;/span&gt;=&lt;span&gt; typeHandlerRegistry.getTypeHandler(parameterMapping.javaType, parameterMapping.jdbcType);
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们再来看看这个类:StaticSqlSource 其实我觉得这个玩意没啥用！真的不是贬低写mybatis的人，真没看出有什么用，具体看下面的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6760d333-1772-4fd1-96eb-d16774c26563')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_6760d333-1772-4fd1-96eb-d16774c26563&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6760d333-1772-4fd1-96eb-d16774c26563&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6760d333-1772-4fd1-96eb-d16774c26563',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6760d333-1772-4fd1-96eb-d16774c26563&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticSqlSource implements SqlSource {

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; final String sql;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; final List&amp;lt;ParameterMapping&amp;gt;&lt;span&gt; parameterMappings;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; final Configuration configuration;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StaticSqlSource(Configuration configuration, String sql) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(configuration, sql, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; StaticSqlSource(Configuration configuration, String sql, List&amp;lt;ParameterMapping&amp;gt;&lt;span&gt; parameterMappings) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sql =&lt;span&gt; sql;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parameterMappings =&lt;span&gt; parameterMappings;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.configuration =&lt;span&gt; configuration;
  }

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BoundSql getBoundSql(Object parameterObject) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BoundSql(configuration, sql, parameterMappings, parameterObject);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这些类同级的包里面，还有一个XML的包，里面包含的DTD文件，以及一些工具类，大家理解这些东西，其实就是为了把烦人的XML转换成一个可用的configuration对象的的工具类就行了，真的没必要深究。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/567748/201712/567748-20171216220319108-1375933912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于builder的&lt;em id=&quot;__mceDel&quot;&gt;annotation &lt;/em&gt;大家应该不陌生了吧？我介绍了这么多。构造函数说得很清楚了，其实把一些基本的注解加进了，CRUD而已。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d444d3e1-9a7e-4d87-a226-3f2f1f4e4abd')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_d444d3e1-9a7e-4d87-a226-3f2f1f4e4abd&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d444d3e1-9a7e-4d87-a226-3f2f1f4e4abd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d444d3e1-9a7e-4d87-a226-3f2f1f4e4abd',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d444d3e1-9a7e-4d87-a226-3f2f1f4e4abd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; MapperAnnotationBuilder(Configuration configuration, Class&amp;lt;?&amp;gt;&lt;span&gt; type) {
    String resource &lt;/span&gt;= type.getName().replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.java (best guess)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.assistant = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MapperBuilderAssistant(configuration, resource);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.configuration =&lt;span&gt; configuration;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type =&lt;span&gt; type;

    sqlAnnotationTypes.add(Select.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlAnnotationTypes.add(Insert.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlAnnotationTypes.add(Update.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlAnnotationTypes.add(Delete.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    sqlProviderAnnotationTypes.add(SelectProvider.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlProviderAnnotationTypes.add(InsertProvider.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlProviderAnnotationTypes.add(UpdateProvider.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    sqlProviderAnnotationTypes.add(DeleteProvider.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;有一个核心方法，比较重要:parse,作用很明显，就是转换呗，然后是从configuration拿玩意，然后转换成有用的东西。其实这个不就是我们写的mapper类的XML文件吗？！用过mybatis的人都知道的。注释写了一点，不过更深入了，我觉得没必要写了，靠大家自己去发掘。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e2cbda21-f2e0-4e79-b67f-be52783081fc')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_e2cbda21-f2e0-4e79-b67f-be52783081fc&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e2cbda21-f2e0-4e79-b67f-be52783081fc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e2cbda21-f2e0-4e79-b67f-be52783081fc',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e2cbda21-f2e0-4e79-b67f-be52783081fc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parse() {
    String resource &lt;/span&gt;=&lt;span&gt; type.toString();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;configuration.isResourceLoaded(resource)) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;载入XML资源文件。&lt;/span&gt;
&lt;span&gt;      loadXmlResource();
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把资源文件添加到configuation里面。&lt;/span&gt;
&lt;span&gt;      configuration.addLoadedResource(resource);
      assistant.setCurrentNamespace(type.getName());
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改assistant变量&lt;/span&gt;
&lt;span&gt;      parseCache();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改assistant变量2&lt;/span&gt;
&lt;span&gt;      parseCacheRef();
      Method[] methods &lt;/span&gt;=&lt;span&gt; type.getMethods();
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; issue #237&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;method.isBridge()) {
            parseStatement(method);
          }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IncompleteElementException e) {
          configuration.addIncompleteMethod(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MethodResolver(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, method));
        }
      }
    }
    parsePendingMethods();
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 16 Dec 2017 14:13:00 +0000</pubDate>
<dc:creator>KMSFan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kmsfan/p/8047878.html</dc:identifier>
</item>
</channel>
</rss>