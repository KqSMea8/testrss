<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java入门篇（一）——如何编写一个简单的Java程序 - 0o霏霏o0</title>
<link>http://www.cnblogs.com/adamjwh/p/8319525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adamjwh/p/8319525.html</guid>
<description>&lt;p&gt;　　最近准备花费很长一段时间写一些关于Java的从入门到进阶再到项目开发的教程，希望对初学Java的朋友们有所帮助，更快的融入Java的学习之中。&lt;/p&gt;
&lt;p&gt;　　主要内容包括JavaSE、JavaEE的基础知识以及如何用Java语言编写一个简单的软件、一个小型的游戏、一个简易的项目、或者一些比较复杂的项目实战等等。&lt;/p&gt;
&lt;p&gt;　　这些文章我不准备用概念来引入Java知识，因为这些概念类的东西网上各类教程都很齐全，初学的朋友们又会觉得概念很繁琐，所以我的这些文章主要针对于了解Java以及如何用Java语言编写一些简单的程序，所以一切以代码为主，想要更深入学习Java的朋友还要多多查阅资料，深入理解概念以及原理等等。&lt;/p&gt;

&lt;p&gt;　　今天就先了解一下如何建立一个Java程序，安装JDK以及编译器的过程我就不多赘述了，网上也有很多教程，编译器例如Eclipse、IDEA等等有很多种可供选择，下面以eclipse为例，建立一个简单的Java程序。&lt;/p&gt;
&lt;p&gt;　　首先启动eclipse，进入到如下主页面：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180119233913162-1884336797.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;335&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　新建一个项目，选择“File-New-Java Project”：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180119234518021-1897823141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　弹出了一个如下页面，假设命名为Test，其余默认即可：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180119234733553-650333577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击Finish后，左栏的“Package Explorer”中就会出现新建的工程：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180119235220943-931077036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么如何编写一个Java程序呢？&lt;/p&gt;
&lt;p&gt;　　首先我们要先创建一个包，可在上方工具栏直接点击&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180120002516021-1505122158.png&quot; alt=&quot;&quot;/&gt;，或右键Test目录下的src新建一个包如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180119235723896-677742929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在弹出的界面填写包名，如hello：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180119235903740-2118530712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击Finish我们就能看见src目录下多了一个名为hello的空包：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180120000032631-927498750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接下来在包下创建一个类用于编写代码，在上方工具栏点击&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180120002547724-1409778622.png&quot; alt=&quot;&quot;/&gt;，或右键hello包创建一个Class文件如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180120000242162-302037744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在弹出页面输入你的类名如Hello，勾选“public static void main(String[] args)”，可以自动帮你创建一个main方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180120000521443-1852916571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击Finish后就会看到以下界面，然后就可以开始编写代码了：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180120000733756-1533033961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么我们就先来写一个简单的代码吧，初学编程语言时我们都是以“Hello World”开头的，我们可以输出博客地址试一下，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; hello;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Hello {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;http://www.cnblogs.com/adamjwh/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　点击&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180120001625099-787464049.png&quot; alt=&quot;&quot;/&gt;运行，或右键“Run As-Java Application”：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180120001738053-1897192659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后会在控制台（Console）中看到如下输出结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1018770/201801/1018770-20180120001852365-187038115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这就是一个简单的输出语句，Java的入门由此开始，是不是很简单呢。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jan 2018 16:37:00 +0000</pubDate>
<dc:creator>0o霏霏o0</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adamjwh/p/8319525.html</dc:identifier>
</item>
<item>
<title>JAVA实用案例之文件导出（JasperReport踩坑实录） - 小卖铺的老爷爷</title>
<link>http://www.cnblogs.com/laoyeye/p/7707149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoyeye/p/7707149.html</guid>
<description>&lt;p&gt;&lt;span&gt;想想来新公司也快五个月了，恍惚一瞬间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;翻了翻博客，因为太忙，也有将近五个多月没认真总结过了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正好趁着今天老婆出门团建的机会，记录下最近这段时间遇到的大坑-JasperReport。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;六月份的时候写过一篇利用poi文件导入导出的小Demo，&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/laoyeye/p/6938889.html&quot;&gt;JAVA实用案例之文件导入导出（POI方式）&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然简单，但是企业应用的原理基本上也就是这样，只不过是封装的更好些，不像我之前写的那样每个Cell都需要定义，其实poi的方式也是我目前最推崇的方式之一了。主要原因是jxl不支持xlsx，JasperReport坑又太大，哎。下面进入正题，来介绍下今天的猪脚JasperReport或者叫它ireport亦或jasperstudio，当然后面两个是它的可视化工具。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这货其实在国内用户也不少，是个国外的产品，而且可以说在JAVA报表领域应用是相当的广泛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我当初刚刚接触这个报表的时候还是相当的喜欢的，最主要的是它的可视化工具，真的是让我欲罢不能，竟然可以通过简单画图的方式来设计JAVA报表。说起画图就是可以通过可视化的工具，让我们可视化的设计报表模板，并且它支持输出的文件格式很广泛，包括EXCEL、WORD、PDF、HTML、XML、CSV等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看起来是不是很强大，一次设计，多次复用。当然强大得的东西，往往都有两面性，这不就被我遇到了，折磨了我相当长的时间，后文会详细描述的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前面我说，JasperReport或者叫它ireport或jasperstudio，其实这是不准确的。二弟ireport、三弟jasperstudio其实是jasper的辅助视觉设计工具，你不用它也能设计jasper报表，多写点XML白。5.5之前这个工具叫ireport，5.5之后随着三弟jasperstudio的出生，ireport就被完全替代了，其实这两个工具基本上是一样的，一奶同胞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的工作流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①首先Jasper会获取需要输出的格式信息的xml文件，然后从xml文件中编译出.jasper类型的文件，然后这个jasper文件可以在我们的应用程序中被加载生成最终的报表。有没有很熟悉的感觉，是的，这一点和java很像，都需要编译一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图，就是ireport的操作界面，jasperstudio类似，就不贴了，大家可以自行百度下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1075594/201710/1075594-20171021223712740-748841623.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图每种类型的band简单介绍一下。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(1)&lt;strong&gt;Title band&lt;/strong&gt;:title段只在整个报表的第一页的最上面部分显示，除了第一页以外，不管报表中共有多少个页面也不会再出现Title band中的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(2)&lt;strong&gt;pageHeader Band&lt;/strong&gt;：顾名思义，pageHeader 段中的内容将会在整个报表中的每一个页面&lt;/span&gt;&lt;span&gt;中都会出现，显示在位置在页面的上部，如果是报表的第一页，pageHeader 中的内容将显示在&lt;/span&gt;&lt;span&gt;Title Band下面，除了第一页以外的其他所有页面中pageHeader中的内容将在显示在页面的最上端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(3)&lt;strong&gt;pageFooter Band&lt;/strong&gt;：显示在所在页面的最下端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(4)&lt;strong&gt;lastPageFooter Band&lt;/strong&gt;：显示在最后一页的最下端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(5)&lt;strong&gt;Detail Band&lt;/strong&gt;：报表内容段，在这个Band 中设计报表中需要重复出现的内容，Detail 段&lt;/span&gt;&lt;span&gt;中的内容每页都会出现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(6)&lt;strong&gt;columnHeader Band&lt;/strong&gt;：针对Detail Band的表头段，一般情况下在这个段中画报表的表&lt;/span&gt;&lt;span&gt;头。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(7)&lt;strong&gt;columnFooter Band&lt;/strong&gt;:针对Detail Band的表尾段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(8)&lt;strong&gt;Summary Band&lt;/strong&gt;:表格的合计段，出现在整个报表的最后一页中的Detail band 的后面，一般用来统计报表中某一个或某几个字段的合计值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 上面就是可视化的工具的全部，其实怎么用很简单，上手摸索下就会了，既然是踩坑实录，这个自然不是重点，不说了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;这是我总结的步骤，可能描述的不是很准确，大家凑合下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①设计模板，生成JRXML文件，↑↑上面的可视化工具设计你所需要的模板样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②编译模板，JRXML编译成Jasper文件，就像java中的.java和.class文件一样，程序中运行的需要是*.jasper的二进制文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实这一步可以直接用ireport编译生成.jasper，当然也可以在运行时通过jasper程序编译。但是建议如果在程序中编译的话，jasper版本最好和ireport或者jasperstudio的版本一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③执行报表（数据填充到报表）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、 加载模板生成Jasperreport对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、利用JasperFillManager，生成JasperPrint对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④最后利用JRXlsxExporter导出类，将报表导出或者展示&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;加载模板&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;既然我们已经利用可视化工具生成了.jasper或者.jrxml文件了，自然是需要让程序加载它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加载的代码，返回jasperport对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;if&lt;/span&gt; (urlPath.endsWith(&quot;.jrxml&quot;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;compile jrxml to jasper&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                InputStream is &lt;/span&gt;=&lt;span&gt; url.openStream();
                jasperReport &lt;/span&gt;=&lt;span&gt; JasperCompileManager.compileReport(is);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseException(&quot;Load jasper error&quot;&lt;span&gt;, e);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JRException e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseException(&quot;The jrxml template transform to jasper file error&quot;&lt;span&gt;, e);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                log.error(e);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseException(e.getMessage());
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (urlPath.endsWith(&quot;.jasper&quot;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                InputStream is &lt;/span&gt;=&lt;span&gt; url.openStream();
                jasperReport &lt;/span&gt;=&lt;span&gt; (JasperReport) JRLoader.loadObject(is);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseException(&quot;Load jasper error&quot;&lt;span&gt;, e);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JRException e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseException(&quot;The jrxml template file error&quot;&lt;span&gt;, e);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                log.error(e);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseException(e.getMessage());
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseException(&quot;Invalid file!&quot;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;获取报表中的数据源&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里我采用javabean的方式获取&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　　　　　JRDataSource dataSource = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fieldValues != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; fieldValues.size() &amp;gt; 0&lt;span&gt;) {
                dataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JRBeanCollectionDataSource(fieldValues);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                dataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JREmptyDataSource();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;fieldValues 为数据库中获取的pojo集合。&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;执行报表填充&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;得到jasperprint对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Map&amp;lt;String, Object&amp;gt; parameterValue = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
jasperPrint &lt;/span&gt;= JasperFillManager.fillReport(jasperReport, parameterValue, dataSource);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;最后我们利用JRXlsxExporter导出报表&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这个也是需要配置参数最多的一个地方&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
baos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
exporter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JRXlsxExporter();
exporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint);
exporter.setParameter(JRExporterParameter.OUTPUT_STREAM, baos);&lt;br/&gt;exporter.exportReport();&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;完成，数据已经写入输出流中了，怎么输出自己决定，是不是比其他方式代码简介很多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;确实在代码书写中JasperReport有着无法比拟的优势，各种api已经封装好。但是可能是恰恰做的太多，问题也不少。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1、两行前的空白&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果你使用上面的代码导出EXCEL的话，你会发现Excel的背景是白色，没了Excel一个个的小格子，这是因为jasper默认背景为白色，这样在导出其他格式时也好做到兼容，当然当我们导出EXCEL并不需要。只需要加上下面两行就可以解决。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;去除两行之前的空白  &lt;/span&gt;
&lt;span&gt;            exporter.setParameter(JRXlsExporterParameter.IS_REMOVE_EMPTY_SPACE_BETWEEN_ROWS,Boolean.TRUE); 
            exporter.setParameter(JRXlsExporterParameter.IS_REMOVE_EMPTY_SPACE_BETWEEN_COLUMNS,Boolean.TRUE); 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置Excel表格的背景颜色为默认的白色  &lt;/span&gt;
            exporter.setParameter(JRXlsExporterParameter.IS_WHITE_PAGE_BACKGROUND,Boolean.FALSE);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、数据量很大，title多次写入&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果你一个Sheet数据很多，可能会遇到表头多次打印的情况，这种情况下，你需要加上高度设置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Field pageHeight = JRBaseReport.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getDeclaredField(
                    &lt;/span&gt;&quot;pageHeight&quot;&lt;span&gt;);
            pageHeight.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            pageHeight.setInt(jasperReport, Integer.MAX_VALUE);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、Cell的类型的问题&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有时候我们导出的Excel报表，需要使用Excel的函数计算，如果全都是文本格式，自然计算不了，这种情况下，我们需要使用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动选择格式&lt;/span&gt;
 exporter.setParameter(JRXlsExporterParameter.IS_DETECT_CELL_TYPE, Boolean.TRUE);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;切记，在报表设计时，Field字段选择正确的类型。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4、多Sheet的问题&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我上面那个简单的例子，只是一个文件中包含一个Sheet页，假如我们的需求是一个文件导出多个Sheet怎么办，别急，这个Japser早已为我们想到了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只需要将上文中导出步骤换成下面这个样子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
baos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
exporter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JRXlsxExporter();
exporter.setParameter(JRExporterParameter.JASPER_PRINT_LIST, listJasperPrint);
exporter.setParameter(JRExporterParameter.OUTPUT_STREAM, baos);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为true，即可在一个excel中，每个单独的jasper对象放入到一个sheet页中&lt;/span&gt;
&lt;span&gt;exporter.setParameter(JRXlsExporterParameter.IS_ONE_PAGE_PER_SHEET,Boolean.TRUE);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;JRExporterParameter.JASPER_PRINT_LIST，传入一个listJasperPrint的集合，每个JasperPrint即一个Sheet页。&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;5、Linux下启动不报错，但是无法导出报表&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;其实这个问题也困扰了我很久，后来在大佬的帮助下才想起来问题所在，因为它抛出的根本不是个Exception，而是Error。我看到网上也有同学问这个问题，所以贴出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以用throwable捕获，就可以得到错误信息，报错：java.lang.InternalError: Can't connect to X11 window server using ':0.0' as&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方法：修改tomcat/bin/catalina.sh 加JAVA_OPTS=&quot;$JAVA_OPTS  -Djava.awt.headless=true&quot;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;6、大数据内存溢出和内存泄露问题！！&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里需要说一下，&lt;/span&gt;&lt;span&gt;EXCEL 03和07版的区别，03版我记得好像是只支持65532行吧，而07版之后就大的多了，具体数字我忘了，反正不是一个数量级的。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;JRXlsxExporter支持导出xlsx文件，&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;JRXlsExporter则是xls的文件，很好辨认，导出的工具和excel的格式一样。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;然后是内存溢出和内存泄露问题，这个我相信玩JAVA的朋友基本上都遇到过。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于内存溢出最通常的解决办法便是增大容器的内存，增加tomcat的内存大小，方法大家可以百度，有很多，不重复造轮子了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里提醒下，如果你使用的是tomcat的话，windows安装版，解压缩版和Linux版的配置方式都是不同的，需要注意下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我需要介绍的是JasperReport的方式，其实JasperReport是对大数据有解决方案的，在很早期的版本便推出了，JRFileVirtualizer的仿真器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个东西是做啥用的呢，其实它会根据你设置的参数，将数据写到硬盘的临时文件上，这样解决了填充报表时内存占用过大溢出的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前JasperReport有3个仿真器，都是用来解决这个问题的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①JRFileVirtualizer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②JRSwapFileVirtualizer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③JRGzipVirtualizer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这三个仿真器又有什么区别呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是推出最早的JRFileVirtualizer，我在测试时，当导出30W左右的数据，就会报内存溢出，后来加上这个后就可以正常导出了。这个仿真器会把每一个对象生成一个临时文件存放在硬盘上解决内存占用的问题，但是因为产生的临时文件较多，无形中增加了文件创建和删除的内存消耗，所以并不是很推荐。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写多个文件&lt;/span&gt;
 JRFileVirtualizer virtualizer = &lt;span&gt;new&lt;/span&gt; JRFileVirtualizer(2&lt;span&gt;, catchPath);
 Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; parameterValue = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
 parameterValue.put(JRParameter.REPORT_VIRTUALIZER, virtualizer);&lt;br/&gt;virtualizer.setReadOnly(true);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;catchPath为文件缓存路径，必须真实存在，否则会报错。&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;然后是JRSwapFileVirtualizer，这个是为了解决JRFileVirtualizer的问题而推出的。这个仿真器，只会创建一个临时文件，每个对象会占这个文件的一部分，所以就减少的文件创建和删除的内存消耗，其实这个也不是特别推荐。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写单个文件&lt;/span&gt;
RSwapFile arquivoSwap = &lt;span&gt;new&lt;/span&gt; JRSwapFile(catchPath, 4096, 25&lt;span&gt;);
JRAbstractLRUVirtualizer virtualizer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; JRSwapFileVirtualizer(2, arquivoSwap, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;
Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; parameterValue = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
parameterValue.put(JRParameter.REPORT_VIRTUALIZER, virtualizer);&lt;br/&gt;virtualizer.setReadOnly(true);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后是JRGzipVirtualizer这个，看到Gzip，不知道你是否有联系到压缩这个词汇。没错，这个仿真器就是使用一种特殊的压缩算法，可以将内存占用压缩到二十分之一还是十分之一来着，总之很神奇。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
JRAbstractLRUVirtualizer virtualizer = &lt;span&gt;new&lt;/span&gt; JRGzipVirtualizer(2&lt;span&gt;);
Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; parameterValue = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
parameterValue.put(JRParameter.REPORT_VIRTUALIZER, virtualizer);
jasperPrint &lt;/span&gt;= JasperFillManager.fillReport(jasperReport, parameterValue, dataSource);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;说了这么多，总之就是三种仿真器解决内存溢出问题，我也看了很多博客里面写利用JRFileVirtualizer，解决内存大数据问题。然后我在这里想说，&lt;span&gt;我最最最不推荐使用JRFileVirtualizer仿真器，因为它不仅创建文件消耗大，还有个很严重的BUG，内存泄露！！！&lt;/span&gt;还有JRSwapFileVirtualizer也有这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，需要说明的是不使用仿真器，也会有内存泄露的问题，当你导出报表后，dump出堆栈信息，会发现net.sf.jasperreports.engine.fill.JRTemplatePrintText类的实例特别多，无法回收，无法回收！！！并且最新版的japserreport 6.x依旧存在这个问题，在jasper的社区和Stack Overflow存在很多这样的问题，而没有解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里推荐JRGzipVirtualizer仿真器，虽然依旧存在泄露问题，但是因为独特的压缩算法，已经将内存泄露问题控制在很小的范围里了，算是一种缓解的方案吧，大概泄露的内存占用缓解了九成以上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总的来说，我现在已经放弃这种方案了，写出来也是为了后来的兄弟少走弯路。撸了一个POI的工具类,接下来准备把所有的报表改成POI导出的方式，话说POI的大数据方案还是挺不错的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;开发路上的坑，写的不是太好还请见谅。转载还请注明出处：小卖铺的老爷爷 &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: JAVA实用案例之文件导出（JasperReport踩坑实录）&quot; href=&quot;http://www.cnblogs.com/laoyeye/p/7707149.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/laoyeye/p/7707149.html&lt;/a&gt; &lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jan 2018 16:21:00 +0000</pubDate>
<dc:creator>小卖铺的老爷爷</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoyeye/p/7707149.html</dc:identifier>
</item>
<item>
<title>Angular整合zTree、异步加载节点数据 - NeverCtrl_C</title>
<link>http://www.cnblogs.com/NeverCtrl-C/p/8318909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeverCtrl-C/p/8318909.html</guid>
<description>
&lt;h2&gt;1 前提准备&lt;/h2&gt;
&lt;h3&gt;　　1.1 新建一个angular4项目&lt;/h3&gt;
&lt;p&gt;　　　　参考博文：&lt;a href=&quot;http://www.cnblogs.com/NeverCtrl-C/p/7242546.html&quot; target=&quot;_blank&quot;&gt;点击前往&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119151324834-2079490481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　1.2 去zTree官网下载zTree&lt;/h3&gt;
&lt;p&gt;　　　　zTree官网：&lt;a href=&quot;http://www.treejs.cn/v3/main.php#_zTreeInfo&quot; target=&quot;_blank&quot;&gt;点击前往&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　三少使用的版本：&lt;a href=&quot;https://pan.baidu.com/s/1i65bkHn&quot; target=&quot;_blank&quot;&gt;点击前往&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119151547459-2030816328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 　　1.3 参考博客&lt;/h3&gt;
&lt;p&gt;　　　　&lt;a href=&quot;https://my.oschina.net/zhongzhong5/blog/867945&quot; target=&quot;_blank&quot;&gt;点击前往01&lt;/a&gt;        &lt;a href=&quot;http://blog.csdn.net/clq18768172714/article/details/71419903&quot; target=&quot;_blank&quot;&gt;点击前往02 &lt;/a&gt;     &lt;/p&gt;
&lt;h2&gt;2 编程步骤&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119201357943-1074224038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从打印出zTree对象可以看出，zTree对象利用init方法来实现zTree结构；init方法接收三个参数&lt;/p&gt;
&lt;p&gt;　　　　参数1：一个ul标签的DOM节点对象&lt;/p&gt;
&lt;p&gt;　　　　参数2：基本配置对象&lt;/p&gt;
&lt;p&gt;　　　　参数3：标题信息数组&lt;/p&gt;
&lt;h3&gt;　　2.1 在index.html中引入相关js、css&lt;/h3&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119195617615-1712619759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_b35eaf6e-d998-438c-ab9b-31753c7dde02&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b35eaf6e-d998-438c-ab9b-31753c7dde02&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b35eaf6e-d998-438c-ab9b-31753c7dde02&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;TestZtree&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;base &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;icon&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;image/x-icon&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;favicon.ico&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;./assets/zTree/css/zTreeStyle/zTreeStyle.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;./assets/zTree/css/demo.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./assets/zTree/js/jquery-1.4.4.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./assets/zTree/js/jquery.ztree.core.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;app-root&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;app-root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　2.2 在TS文件中声明jquery对象&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
declare var $ : any;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2.3 在TS文件中编写代码&lt;/h3&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119200636443-446470091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;&lt;img id=&quot;code_img_closed_82392f9b-a474-4733-add0-b7de5b0b86eb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_82392f9b-a474-4733-add0-b7de5b0b86eb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_82392f9b-a474-4733-add0-b7de5b0b86eb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;117&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import { Component, OnInit } from '@angular/core';
declare var $ : any;

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent implements OnInit {

  // setting = {
  //   view: {
  //       showLine: true,
  //       showIcon: true,
  //       fontCss: this.getFont
  //   },
  //   data: {
  //     simpleData: {
  //       enable: true,
  //       idKey: 'id',
  //       pIdKey: 'pId'
  //     }
  //   },
  //   callback: {
  //     onClick: this.onCzTreeOnClick
  //   }
  // };

  // zNodes = [
  //   {id: 1, pId: 0, name: '1 一级标题', open: true, iconOpen:&quot;assets/zTree/css/zTreeStyle/img/diy/1_open.png&quot;, iconClose:&quot;assets/zTree/css/zTreeStyle/img/diy/1_close.png&quot;},
  //   {id: 11, pId: 1, name: '1.1 二级标题', open: true, font:{'background-color':'skyblue', 'color':'white'}},
  //   {id: 111, pId: 11, name: '1.1.1 三级标题 -&amp;gt; 博客园', url: 'http://www.cnblogs.com/NeverCtrl-C/'},
  //   {id: 112, pId: 11, name: '1.1.2 三级标题 -&amp;gt; 单击', click: &quot;alert('你单击了')&quot;},
  //   {id: 12, pId: 1, name: '1.2 二级标题'},
  //   {id: 2, pId: 0, name: '2 一级标题'}
  // ]

  // getFont(treeId, node) {
  //   return node.font ? node.font : {};
  // }


  // onCzTreeOnClick(event, treeId, treeNode, clickFlag) {
  //   alert(treeNode.name);
  // }        

  setting = {
    data: {
      simpleData: {
        enable: true
      }
    }
  };
  zNodes = [
    {id: 1, pId: 0, name: '1 一级标题'},
    {id: 11, pId: 1, name: '1.1 二级标题'},
    {id: 111, pId: 11, name: '1.1.1 三级标题'},
    {id: 112, pId: 11, name: '1.1.2 三级标题'},
    {id: 12, pId: 1, name: '1.2 二级标题'},
    {id: 2, pId: 0, name: '2 一级标题'}
  ];

  constructor() { }
  
  ngOnInit() { 
    console.log($);
    console.log($.fn.zTree);
    $.fn.zTree.init($(&quot;#ztree&quot;),this.setting,this.zNodes);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　2.4 在组件HTML中编写代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;ztree&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ztree&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2.5 效果展示&lt;/h3&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119200741084-550381322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3 zTree基本功能&lt;/h2&gt;
&lt;h3&gt;　　3.1 不显示连接线&lt;/h3&gt;
&lt;h4&gt;　　　　3.1.1 官方文档&lt;/h4&gt;
&lt;p&gt;　　　　　　不显示标题之间的连接线&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119202219740-790953186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　3.1.2 编程步骤&lt;/h4&gt;
&lt;p&gt;　　　　　　在基本配置对象中指定showLine属性的值为false即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  setting = {
    data: {
      simpleData: {
        enable: true
      }
    },
    view: {
      showLine: false
    }
  };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3.2 不显示节点图标&lt;/h3&gt;
&lt;h4&gt;　　　　3.2.1 官方文档&lt;/h4&gt;
&lt;p&gt;　　　　　　去掉节点前面的图标&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119202634443-634436191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　3.2.2 编程步骤&lt;/h4&gt;
&lt;p&gt;　　　　　　将基本配置对象的showIcon属性设为false即可&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119202910193-2008209790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_89b7e9d9-bcc8-4937-9dd8-f2514a6a9c30&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_89b7e9d9-bcc8-4937-9dd8-f2514a6a9c30&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_89b7e9d9-bcc8-4937-9dd8-f2514a6a9c30&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
setting =&lt;span&gt; {
    data: {
      simpleData: {
        enable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      }
    },
    view: {
      showLine: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      showIcon: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }
  };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　3.3 自定义节点图标&lt;/h3&gt;
&lt;h4&gt;　　　　3.3.1 官方文档&lt;/h4&gt;
&lt;p&gt;　　　　　　更改节点的图标&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119203223693-589720982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　3.3.2 编程步骤&lt;/h4&gt;
&lt;p&gt;　　　　　　为treeNode节点数据设置icon/iconOpen/iconClose属性即可&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119203402709-1429505290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3.4 自定义字体&lt;/h3&gt;
&lt;h4&gt;　　　　3.4.1 官方文档&lt;/h4&gt;
&lt;p&gt;　　　　　　更改节点字体的样式&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119204320349-1437792184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　3.4.2 编程步骤&lt;/h4&gt;
&lt;p&gt;　　　　　　为treeNode节点数据设置font属性即可，font属性的值是一个对象，该对象的内容和style的数据一样&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119204506959-1185759751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　3.4.3 效果展示&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119204556709-1593582979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3.5 超链接&lt;/h3&gt;
&lt;h4&gt;　　　　3.5.1 官方文档&lt;/h4&gt;
&lt;p&gt;　　　　　　点击节点标题就会自动跳转到对应的url&lt;/p&gt;
&lt;p&gt;　　　　　　注意01：click属性只能进行最简单的 click 事件操作。相当于 onclick=&quot;...&quot; 的内容。 如果操作较复杂，请使用 onClick 事件回调函数。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119204808881-1481928279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　3.5.2 编程步骤&lt;/h4&gt;
&lt;p&gt;　　　　　　为treeNode节点数据设置url、click属性即可&lt;/p&gt;
&lt;p&gt;　　　　　　技巧01：设置click属性时，属性值必须是一些简单的onClick事件&lt;/p&gt;
&lt;p&gt;　　　　　　技巧02：设置target属性时，属性值有 _blank 和 _self&lt;/p&gt;
&lt;p&gt;　　　　　　　　_blank -&amp;gt; 用一个新窗口打开&lt;/p&gt;
&lt;p&gt;　　　　　　　　_self -&amp;gt; 在原来的窗口打开&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119205440553-1422471706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;&lt;img id=&quot;code_img_closed_2e5c0f6f-06c7-4a10-a91e-147f2f0873af&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2e5c0f6f-06c7-4a10-a91e-147f2f0873af&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2e5c0f6f-06c7-4a10-a91e-147f2f0873af&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
  zNodes =&lt;span&gt; [
    {id: &lt;/span&gt;1, pId: 0, name: '1 一级标题', open: &lt;span&gt;true&lt;/span&gt;, iconOpen:&quot;assets/zTree/css/zTreeStyle/img/diy/1_open.png&quot;, iconClose:&quot;assets/zTree/css/zTreeStyle/img/diy/1_close.png&quot;&lt;span&gt;},
    {id: &lt;/span&gt;11, pId: 1, name: '1.1 二级标题', open: &lt;span&gt;true&lt;/span&gt;, font:{'background-color':'skyblue', 'color':'white'&lt;span&gt;}},
    {id: &lt;/span&gt;111, pId: 11, name: '1.1.1 三级标题 -&amp;gt; 博客园1', url: 'http://www.cnblogs.com/NeverCtrl-C/', target: '_blank'&lt;span&gt;},
    {id: &lt;/span&gt;113, pId: 11, name: '1.1.1 三级标题 -&amp;gt; 博客园2', url: 'http://www.cnblogs.com/NeverCtrl-C/', target: '_self'&lt;span&gt;},
    {id: &lt;/span&gt;112, pId: 11, name: '1.1.2 三级标题 -&amp;gt; 单击', click: &quot;alert('你单击了')&quot;&lt;span&gt;},
    {id: &lt;/span&gt;12, pId: 1, name: '1.2 二级标题'&lt;span&gt;},
    {id: &lt;/span&gt;2, pId: 0, name: '2 一级标题'&lt;span&gt;}
  ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;　　3.6 单击控制&lt;/h3&gt;
&lt;h4&gt;　　　　3.6.1 官方文档&lt;/h4&gt;
&lt;p&gt;　　　　　　点击节点标题时触发相应的方法&lt;/p&gt;
&lt;p&gt;　　　　　　技巧01：&lt;span&gt;在angular中可以利用这个用法来实现路由跳转&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119205738006-1007508378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　3.6.2 编程步骤&lt;/h4&gt;
&lt;p&gt;　　　　　　设置基本配置对象的onClick属性&lt;/p&gt;
&lt;p&gt;　　　　　　技巧01：onClick属性值是一个方法的引用，我们需要自己编写这个方法&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119205841099-127881605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_f09dbb74-10b1-40b8-837b-c7fcf21bd0f8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f09dbb74-10b1-40b8-837b-c7fcf21bd0f8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f09dbb74-10b1-40b8-837b-c7fcf21bd0f8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
  setting =&lt;span&gt; {
    view: {
        showLine: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        showIcon: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        fontCss: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getFont
    },
    data: {
      simpleData: {
        enable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        idKey: &lt;/span&gt;'id'&lt;span&gt;,
        pIdKey: &lt;/span&gt;'pId'&lt;span&gt;
      }
    },
    callback: {
      onClick: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onCzTreeOnClick
    }
  };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　编写onClick触发方法&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119210049599-440994131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_74eff19c-f708-457f-b04d-53592519da56&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_74eff19c-f708-457f-b04d-53592519da56&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_74eff19c-f708-457f-b04d-53592519da56&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  onCzTreeOnClick(event, treeId, treeNode, clickFlag) {
    alert(treeNode.name);
  }        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;　　　　3.6.3 代码汇总&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;&lt;img id=&quot;code_img_closed_6408ad2f-bdcf-4684-ae88-0368d1256ec4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6408ad2f-bdcf-4684-ae88-0368d1256ec4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6408ad2f-bdcf-4684-ae88-0368d1256ec4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;117&quot;&gt;
&lt;pre&gt;
import { Component, OnInit } from '@angular/core'&lt;span&gt;;
declare &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; $ : any;

@Component({
  selector: &lt;/span&gt;'app-root'&lt;span&gt;,
  templateUrl: &lt;/span&gt;'./app.component.html'&lt;span&gt;,
  styleUrls: [&lt;/span&gt;'./app.component.scss'&lt;span&gt;]
})
export class AppComponent implements OnInit {

  setting &lt;/span&gt;=&lt;span&gt; {
    view: {
        showLine: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        showIcon: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        fontCss: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getFont
    },
    data: {
      simpleData: {
        enable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        idKey: &lt;/span&gt;'id'&lt;span&gt;,
        pIdKey: &lt;/span&gt;'pId'&lt;span&gt;
      }
    },
    callback: {
      onClick: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onCzTreeOnClick
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; async: {&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   enable: true,&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   url:&quot;http://localhost:3000/data&quot;,&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   type: &quot;get&quot;,&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   // autoParam:[&quot;id&quot;, &quot;name=n&quot;, &quot;level=lv&quot;],&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   // otherParam:{&quot;otherParam&quot;:&quot;zTreeAsyncTest&quot;},&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   dataFilter: this.filter&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;span&gt;  };

  zNodes &lt;/span&gt;=&lt;span&gt; [
    {id: &lt;/span&gt;1, pId: 0, name: '1 一级标题', open: &lt;span&gt;true&lt;/span&gt;, iconOpen:&quot;assets/zTree/css/zTreeStyle/img/diy/1_open.png&quot;, iconClose:&quot;assets/zTree/css/zTreeStyle/img/diy/1_close.png&quot;&lt;span&gt;},
    {id: &lt;/span&gt;11, pId: 1, name: '1.1 二级标题', open: &lt;span&gt;true&lt;/span&gt;, font:{'background-color':'skyblue', 'color':'white'&lt;span&gt;}},
    {id: &lt;/span&gt;111, pId: 11, name: '1.1.1 三级标题 -&amp;gt; 博客园1', url: 'http://www.cnblogs.com/NeverCtrl-C/', target: '_blank'&lt;span&gt;},
    {id: &lt;/span&gt;113, pId: 11, name: '1.1.1 三级标题 -&amp;gt; 博客园2', url: 'http://www.cnblogs.com/NeverCtrl-C/', target: '_self'&lt;span&gt;},
    {id: &lt;/span&gt;112, pId: 11, name: '1.1.2 三级标题 -&amp;gt; 单击', click: &quot;alert('你单击了')&quot;&lt;span&gt;},
    {id: &lt;/span&gt;12, pId: 1, name: '1.2 二级标题'&lt;span&gt;},
    {id: &lt;/span&gt;2, pId: 0, name: '2 一级标题'&lt;span&gt;}
  ]

  getFont(treeId, node) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; node.font ?&lt;span&gt; node.font : {};
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; filter(treeId, parentNode,responseData) {&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   console.log(responseData);&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   if (responseData) {&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     for(var i =0; i &amp;lt; responseData.length; i++) {&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       responseData[i].name += &quot;动态节点数据&quot; + responseData[i].id;&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   }&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   return responseData;&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;span&gt;
  onCzTreeOnClick(event, treeId, treeNode, clickFlag) {
    alert(treeNode.name);
  }        

  constructor() { }
  
  ngOnInit() { 
    console.log(&lt;/span&gt;'打印输出jquery对象'&lt;span&gt;);
    console.log($);
    console.log(&lt;/span&gt;'但因输出zTree对象'&lt;span&gt;);
    console.log($.fn.zTree);
    $.fn.zTree.init($(&lt;/span&gt;&quot;#ztree&quot;),&lt;span&gt;this&lt;/span&gt;.setting,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.zNodes);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $.fn.zTree.init($(&quot;#ztree&quot;),this.setting);&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　3.7 异步加载节点数据&lt;/h3&gt;
&lt;h4&gt;　　　　3.7.1 官方文档&lt;/h4&gt;
&lt;p&gt;　　　　　　节点的数据是从后台进行获取的&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119223546803-2123002464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　3.7.2 编程步骤&lt;/h4&gt;
&lt;p&gt;　　　　　　技巧01：异步加载节点数据时init方法不用传递第三个参数&lt;/p&gt;
&lt;p&gt;　　　　　　　　 &lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119224633693-1520232549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&amp;gt; 准备一个后台用于返回JSON格式的数据&lt;/p&gt;
&lt;p&gt;　　　　　　　　技巧01：返回的JSON数据是一个列表，格式为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
    {
      &lt;/span&gt;&quot;id&quot;: 1&lt;span&gt;,
      &lt;/span&gt;&quot;pId&quot;: 0&lt;span&gt;,
      &lt;/span&gt;&quot;name&quot;: &quot;1 one&quot;&lt;span&gt;
    },
    {
      &lt;/span&gt;&quot;id&quot;: 2&lt;span&gt;,
      &lt;/span&gt;&quot;pId&quot;: 0&lt;span&gt;,
      &lt;/span&gt;&quot;name&quot;: &quot;2 two&quot;&lt;span&gt;
    }
  ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　技巧02：三少偷懒，是利用json-server模拟的后台数据，哈哈；json-server 使用教程请参见 -&amp;gt; &lt;a href=&quot;http://www.cnblogs.com/NeverCtrl-C/p/8092822.html&quot; target=&quot;_blank&quot;&gt;点击前往&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　&amp;gt; 设置基本配置对象的async属性&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119224309818-1038406414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_bd1ebe0f-a673-4bb4-82b1-0f5552bf7cd2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bd1ebe0f-a673-4bb4-82b1-0f5552bf7cd2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bd1ebe0f-a673-4bb4-82b1-0f5552bf7cd2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
  setting =&lt;span&gt; {
    view: {
        showLine: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        showIcon: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        fontCss: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getFont
    },
    data: {
      simpleData: {
        enable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        idKey: &lt;/span&gt;'id'&lt;span&gt;,
        pIdKey: &lt;/span&gt;'pId'&lt;span&gt;
      }
    },
    callback: {
      onClick: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onCzTreeOnClick
    },
    async: {
      enable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      url:&lt;/span&gt;&quot;http://localhost:3000/data&quot;&lt;span&gt;,
      type: &lt;/span&gt;&quot;get&quot;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; autoParam:[&quot;id&quot;, &quot;name=n&quot;, &quot;level=lv&quot;],&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; otherParam:{&quot;otherParam&quot;:&quot;zTreeAsyncTest&quot;},&lt;/span&gt;
      dataFilter: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.filter
    }
  };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　&amp;gt; 编写响应数据处理方法&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119224521912-1139474377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_a5a505a0-66a8-4c56-aae2-b1512c76e741&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a5a505a0-66a8-4c56-aae2-b1512c76e741&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a5a505a0-66a8-4c56-aae2-b1512c76e741&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  filter(treeId, parentNode,responseData) {
    console.log(responseData);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (responseData) {
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i =0; i &amp;lt; responseData.length; i++&lt;span&gt;) {
        responseData[i].name &lt;/span&gt;+= &quot;动态节点数据&quot; +&lt;span&gt; responseData[i].id;
      }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseData;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;　　　　3.7.3 代码总汇&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_478f482b-269f-4737-9fc1-1caa162a4713&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_478f482b-269f-4737-9fc1-1caa162a4713&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_478f482b-269f-4737-9fc1-1caa162a4713&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;data&quot;&lt;span&gt;: 
  [
    {
      &lt;/span&gt;&quot;id&quot;: 1&lt;span&gt;,
      &lt;/span&gt;&quot;pId&quot;: 0&lt;span&gt;,
      &lt;/span&gt;&quot;name&quot;: &quot;1 one&quot;&lt;span&gt;
    },
    {
        &lt;/span&gt;&quot;id&quot;: 11&lt;span&gt;,
        &lt;/span&gt;&quot;pId&quot;: 1&lt;span&gt;,
        &lt;/span&gt;&quot;name&quot;: &quot;1.1 oneToOne&quot;&lt;span&gt;
    },
    {
        &lt;/span&gt;&quot;id&quot;: 12&lt;span&gt;,
        &lt;/span&gt;&quot;pId&quot;: 1&lt;span&gt;,
        &lt;/span&gt;&quot;name&quot;: &quot;1.2 oneToTwo&quot;&lt;span&gt;
    },
    {
      &lt;/span&gt;&quot;id&quot;: 2&lt;span&gt;,
      &lt;/span&gt;&quot;pId&quot;: 0&lt;span&gt;,
      &lt;/span&gt;&quot;name&quot;: &quot;2 two&quot;&lt;span&gt;
    }
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;模拟后台响应数据&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_c83e7bb3-2980-4219-afe2-1bfea28cfef4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c83e7bb3-2980-4219-afe2-1bfea28cfef4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c83e7bb3-2980-4219-afe2-1bfea28cfef4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;ztree&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ztree&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;HTML&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;&lt;img id=&quot;code_img_closed_e570f8f8-72f8-4354-9dd5-04c8a34aae31&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e570f8f8-72f8-4354-9dd5-04c8a34aae31&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e570f8f8-72f8-4354-9dd5-04c8a34aae31&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;117&quot;&gt;
&lt;pre&gt;
import { Component, OnInit } from '@angular/core'&lt;span&gt;;
declare &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; $ : any;

@Component({
  selector: &lt;/span&gt;'app-root'&lt;span&gt;,
  templateUrl: &lt;/span&gt;'./app.component.html'&lt;span&gt;,
  styleUrls: [&lt;/span&gt;'./app.component.scss'&lt;span&gt;]
})
export class AppComponent implements OnInit {

  setting &lt;/span&gt;=&lt;span&gt; {
    view: {
        showLine: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        showIcon: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        fontCss: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getFont
    },
    data: {
      simpleData: {
        enable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        idKey: &lt;/span&gt;'id'&lt;span&gt;,
        pIdKey: &lt;/span&gt;'pId'&lt;span&gt;
      }
    },
    callback: {
      onClick: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onCzTreeOnClick
    },
    async: {
      enable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      url:&lt;/span&gt;&quot;http://localhost:3000/data&quot;&lt;span&gt;,
      type: &lt;/span&gt;&quot;get&quot;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; autoParam:[&quot;id&quot;, &quot;name=n&quot;, &quot;level=lv&quot;],&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; otherParam:{&quot;otherParam&quot;:&quot;zTreeAsyncTest&quot;},&lt;/span&gt;
      dataFilter: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.filter
    }
  };

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; zNodes = [&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   {id: 1, pId: 0, name: '1 一级标题', open: true, iconOpen:&quot;assets/zTree/css/zTreeStyle/img/diy/1_open.png&quot;, iconClose:&quot;assets/zTree/css/zTreeStyle/img/diy/1_close.png&quot;},&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   {id: 11, pId: 1, name: '1.1 二级标题', open: true, font:{'background-color':'skyblue', 'color':'white'}},&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   {id: 111, pId: 11, name: '1.1.1 三级标题 -&amp;gt; 博客园1', url: 'http://www.cnblogs.com/NeverCtrl-C/', target: '_blank'},&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   {id: 113, pId: 11, name: '1.1.1 三级标题 -&amp;gt; 博客园2', url: 'http://www.cnblogs.com/NeverCtrl-C/', target: '_self'},&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   {id: 112, pId: 11, name: '1.1.2 三级标题 -&amp;gt; 单击', click: &quot;alert('你单击了')&quot;},&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   {id: 12, pId: 1, name: '1.2 二级标题'},&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   {id: 2, pId: 0, name: '2 一级标题'}&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ]&lt;/span&gt;
&lt;span&gt;
  getFont(treeId, node) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; node.font ?&lt;span&gt; node.font : {};
  }

  filter(treeId, parentNode,responseData) {
    console.log(responseData);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (responseData) {
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i =0; i &amp;lt; responseData.length; i++&lt;span&gt;) {
        responseData[i].name &lt;/span&gt;+= &quot;动态节点数据&quot; +&lt;span&gt; responseData[i].id;
      }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseData;
  }

  onCzTreeOnClick(event, treeId, treeNode, clickFlag) {
    alert(treeNode.name);
  }        

  constructor() { }
  
  ngOnInit() { 
    console.log(&lt;/span&gt;'打印输出jquery对象'&lt;span&gt;);
    console.log($);
    console.log(&lt;/span&gt;'但因输出zTree对象'&lt;span&gt;);
    console.log($.fn.zTree);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $.fn.zTree.init($(&quot;#ztree&quot;),this.setting,this.zNodes);&lt;/span&gt;
    $.fn.zTree.init($(&quot;#ztree&quot;),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setting);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TS&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;　　　　3.7.4 效果展示&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180119225015803-1398442523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 　　　　3.7.5 参考博文&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;a href=&quot;http://blog.csdn.net/jiaolong724/article/details/25737463&quot; target=&quot;_blank&quot;&gt;点击前往&lt;/a&gt;&lt;/p&gt;







</description>
<pubDate>Fri, 19 Jan 2018 13:32:00 +0000</pubDate>
<dc:creator>NeverCtrl_C</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeverCtrl-C/p/8318909.html</dc:identifier>
</item>
<item>
<title>iptables网络安全服务详细使用 - 酷酷的二连长</title>
<link>http://www.cnblogs.com/lyq863987322/p/8310117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyq863987322/p/8310117.html</guid>
<description>&lt;h2&gt;iptables防火墙概念说明&lt;/h2&gt;
&lt;p&gt;开源的基于数据包过滤的网络安全策略控制工具。&lt;/p&gt;
&lt;p&gt;centos6.9  --- 默认防火墙工具软件iptables&lt;/p&gt;
&lt;p&gt;centos7    --- 默认防火墙工具软件firewalld（zone）&lt;/p&gt;
&lt;p&gt;iptables主要工作在OSI七层的二、三、四层，如果重新编译内核，iptables也可以支持7层控制(squid代理+iptables)。&lt;/p&gt;
&lt;h3&gt;iptables工作流程（规则匹配流程）&lt;/h3&gt;
&lt;p&gt;iptables是采用数据包过滤机制工作的，所以它会对请求的数据包的包头数据进行分析，并根据我们预先设定的规则进行匹配来决定是否可以进入主机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1234532/201801/1234532-20180118105348115-1825310315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;iptables工作流程小结&lt;/h3&gt;
&lt;p&gt;1、防火墙是一层层过滤的。实际是按照配置规则的顺序从上到下，从前到后进行过滤的。&lt;/p&gt;
&lt;p&gt;2、如果匹配上了规则，即明确表明是阻止还是通过，此时数据包就不在向下匹配新规则了。&lt;/p&gt;
&lt;p&gt;3、如果所有规则中没有明确表明是阻止还是通过这个数据包，也就是没有匹配上规则，向下进行匹配，直到匹配默认规则得到明确的阻止还是通过。&lt;/p&gt;
&lt;p&gt;4、防火墙的默认规则是对应链的所有的规则执行完以后才会执行的（最后执行的规则）。&lt;/p&gt;
&lt;h2&gt; iptables四表五链概念&lt;/h2&gt;
&lt;table class=&quot;MsoTableGrid&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;17.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;110&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;表（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;tables&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; valign=&quot;top&quot; width=&quot;602&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;链（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;chains&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td rowspan=&quot;4&quot; width=&quot;110&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Filter&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; valign=&quot;top&quot; width=&quot;602&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;This is the default table (if no -t option is passed)&lt;/span&gt; &lt;span&gt;这是默认表&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td width=&quot;144&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;INPUT&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;for packets destined to local sockets&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;对于指定到本地套接字的包，即到达本地防火墙服务器的数据包&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td width=&quot;144&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;FORWARD&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;for packets being routed through the box&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;路由穿过的数据包，即经过本地防火墙服务器的数据包&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;144&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;OUTPUT&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;for locally-generated packets&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;本地创建的数据包&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td rowspan=&quot;4&quot; width=&quot;110&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;NAT&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; valign=&quot;top&quot; width=&quot;602&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;This table is consulted when a packet that creates a new connection is encountered&lt;/span&gt; &lt;span&gt;当遇到新创建的数据包连接时将参考这个表&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td width=&quot;144&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;PREROUTING&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;for altering packets as soon as they come in&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一进来就对数据包进行改变&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td width=&quot;144&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;OUTPUT&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;or altering locally-generated packets before routing&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;本地创建的数据包在路由之前进行改变&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td width=&quot;144&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;POSTROUTING&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;for altering packets as they are about to go out&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在数据包即将出去时改变数据包信息&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td rowspan=&quot;6&quot; width=&quot;110&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Managle&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; valign=&quot;top&quot; width=&quot;602&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;This table is used for specialized packet alteration&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;这个表专门用于改变数据包&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td width=&quot;144&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;INPUT&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;for packets coming into the box itself&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;进入到设备本身的包&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td width=&quot;144&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;FORWARD&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;for altering packets being routed through the box&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;对路由后的数据包信息进行修改&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td width=&quot;144&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;PREROUTING&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;for altering incoming packets before routing&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在路由之前更改传入的包&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td width=&quot;144&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;OUTPUT&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;for altering locally-generated packets before routing&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;本地创建的数据包在路由之前进行改变&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td width=&quot;144&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;POSTROUTING&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;458&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;for altering packets as they are about to go out&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在数据包即将离开时更改数据包信息&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;110&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;raw&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot; valign=&quot;top&quot; width=&quot;602&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;此表用处较少，可以忽略不计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt; 四表&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
filter    （作用：主机防火墙） 默认的表。*****&lt;span&gt;
nat        （作用：端口或IP映射或共享上网）&lt;/span&gt;*****&lt;span&gt;
mangle    （配置路由标记 ttl tos mark）
raw        （忽略）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;iptables的几个表以及每个表对应链的作用&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;filter表（默认的表，作用：主机防火墙）
    INPUT：进入主机的数据包
    OUTPUT：本地创建的数据包
    FORWARD：路由穿过的数据包，即经过本地防火墙服务器的数据包

NAT表（作用：端口或IP映射或共享上网）
    PREROUTING：一进来就对数据包进行改变
    OUTPUT：本地创建的数据包在路由之前进行改变
    POSTROUTING：在数据包即将出去时改变数据包信息
    
mangle表（配置路由标记 ttl tos mark）
    INPUT：进入到设备本身的包
    FORWARD：对路由后的数据包信息进行修改
    PREROUTING：在路由之前更改传入的包
    OUTPUT：本地创建的数据包在路由之前进行改变
    POSTROUTING：在数据包即将离开时更改数据包信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;filter表信息详细介绍&lt;/h3&gt;
&lt;table class=&quot;MsoTableGrid&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;filter&lt;/span&gt;&lt;span&gt;表&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;601&quot; readability=&quot;9&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;强调：主要和主机自身相关，真正负责主机防火墙功能的（过滤流入流出，流经主机的数据包）&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;filter&lt;/span&gt;&lt;span&gt;表示&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;iptables&lt;/span&gt;&lt;span&gt;默认使用的表，这个表定义了三个链（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;chains )&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;企业工作场景：主机防火墙&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;INPUT&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;601&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;负责过滤所有目标地址是本机地址的数据包&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;通俗来说：就是过滤进入主机的数据包&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;FORWARD&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;601&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;负责转发流经主机的数据包。起转发的作用，和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;NAT&lt;/span&gt;&lt;span&gt;关系很大，后面会详细介绍&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;LVS NAT&lt;/span&gt; &lt;span&gt;模式，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;net ipv4.ip_forward=l&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;OUTPUT&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;601&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;处理所有源地址是本机地址的数据包&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;通俗的讲：就是处理从主机发出去的数据包&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;&lt;span&gt; &lt;/span&gt;NAT表信息详细介绍&lt;/h3&gt;
&lt;table class=&quot;MsoTableGrid&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;14.5&quot;&gt;&lt;td width=&quot;102&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;NAT&lt;/span&gt;&lt;span&gt;表&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;610&quot; readability=&quot;18&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;负责网络地址转换的，即来源与目的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IP&lt;/span&gt;&lt;span&gt;地址和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;port&lt;/span&gt;&lt;span&gt;的转换。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;应用：和主机本身无关，一般用于局域网共享上网或者特殊的端□转换服务相关。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;工作场票：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.  &lt;/span&gt; &lt;span&gt;用于企业路由（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;zebra )&lt;/span&gt;&lt;span&gt;或网关（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;iptables),&lt;/span&gt;&lt;span&gt;共享上网（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;POSTROUTING)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.  &lt;/span&gt; &lt;span&gt;做内部外部&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IP&lt;/span&gt;&lt;span&gt;地址一对一映射（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;dmz),&lt;/span&gt;&lt;span&gt;硬件防火墙映射&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IP&lt;/span&gt;&lt;span&gt;到内部服务器，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;ftp&lt;/span&gt;&lt;span&gt;服务&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;(PREROUTING )&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.   WEB&lt;/span&gt;&lt;span&gt;，单个端口的映射，直接映射&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;80&lt;/span&gt;&lt;span&gt;端口（&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;PREROUTING )&lt;/span&gt;&lt;span&gt;这个表走义了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;个链，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;nat&lt;/span&gt;&lt;span&gt;功能相当于网络的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;acl&lt;/span&gt;&lt;span&gt;控制。和网络交换机&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;acl&lt;/span&gt;&lt;span&gt;类似。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;102&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;OUTPUT&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;610&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;和主机放出去的数据包有关，改变主机发出数据包的目的地址。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td width=&quot;102&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;PREROUTING&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;610&quot; readability=&quot;10&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在数据包到达防火墙时，进行路甶判断之前执行的规则，作用是改变数据包的目的地址、目的端□等就是收信时，根据规则重写收件人的地址。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;例如：把公网&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IP : XXX.XXX.XXX.XXX&lt;/span&gt;&lt;span&gt;映射到局域网的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;XX.XX.XX.XX&lt;/span&gt;&lt;span&gt;服务器上。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;web&lt;/span&gt;&lt;span&gt;服务，可以报&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;80&lt;/span&gt;&lt;span&gt;转换为局域网的服务器&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;9000&lt;/span&gt;&lt;span&gt;端□上&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td width=&quot;102&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;POSTROUTING&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;610&quot; readability=&quot;13&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在数据包离开防火墙时进行路由判断之后执行的规则，作用改变数据包的源地址，源端口等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;写好发件人的地址，要让家人回信时能够有地址可回。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;例如。默认笔记本和虚拟机都是局域网地址，在出网的时候被路甶器将源地址改为了公网地址。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;生产应用：局域网共享上网。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;iptanles企业应用场景&lt;/h2&gt;
&lt;p&gt;1、主机防火墙（filter表的INPUT链）。&lt;/p&gt;
&lt;p&gt;2、局域网共享上网(nat表的POSTROUTING链)。半个路由器，NAT功能。&lt;/p&gt;
&lt;p&gt;3、端口及IP映射(nat表的PREROUTING链)，硬防的NAT功能。&lt;/p&gt;
&lt;p&gt;4、IP一对一映射。&lt;/p&gt;
&lt;h2&gt;iptables工作原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1234532/201801/1234532-20180118110501818-440305545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;iptables基本语法&lt;/h2&gt;
&lt;p&gt;-I(大写i  插入) -A(追加) -R(替换) -D（删除） -L（列表显示）&lt;/p&gt;
&lt;p&gt;-I将会把规则放在&lt;span class=&quot;mark&quot;&gt;第一行，-A将会放在&lt;span class=&quot;mark&quot;&gt;最后一行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
iptables –t filter  -A INPUT  -p  tcp  --dport  &lt;span&gt;22&lt;/span&gt;  -&lt;span&gt;j DROP    
iptables –t filter  &lt;/span&gt;-A INPUT  -p  tcp  --dport  &lt;span&gt;3306&lt;/span&gt;  -&lt;span&gt;j DROP
iptables –t filter  &lt;/span&gt;-I  INPUT  -p  tcp  --dport  &lt;span&gt;80&lt;/span&gt;  -j DROP   &lt;br/&gt;说明：前两句就算是先执行，第三句也会是第一行  
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;查看防火墙规则&lt;/h4&gt;
&lt;p&gt;-L         查看iptables控制策略列表信息&lt;/p&gt;
&lt;p&gt;-n              查看iptables控制策略列表里面的ip地址和端口信息，不翻译，以数字表示&lt;/p&gt;
&lt;p&gt;--line-number       查看iptables策略信息时，显示每条规则序号信息&lt;/p&gt;
&lt;p&gt;-v             查看iptables策略详细信息（进出口）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@iptables ~]# iptables -nL --line-&lt;span&gt;number
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    ACCEPT     all  --  &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;&lt;span&gt;           state RELATED,ESTABLISHED 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    ACCEPT     icmp --  &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;           
&lt;span&gt;3&lt;/span&gt;    ACCEPT     all  --  &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;           
&lt;span&gt;4&lt;/span&gt;    ACCEPT     tcp  --  &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;           state NEW tcp dpt:&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;    REJECT     all  --  &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;           reject-with icmp-host-&lt;span&gt;prohibited 

Chain FORWARD (policy ACCEPT)
num  target     prot opt source               destination         
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    REJECT     all  --  &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;           reject-with icmp-host-&lt;span&gt;prohibited 

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;清除防火墙规则&lt;/h4&gt;
&lt;p&gt;-F             清除所有规则，不会处理默认的规则&lt;/p&gt;
&lt;p&gt;-X             删除用户自定义的链&lt;/p&gt;
&lt;p&gt;-Z             清除链的计数器（数据包计数器与数据包字节计数器）&lt;/p&gt;
&lt;h2&gt;其余参数&lt;/h2&gt;
&lt;p&gt;-A            向指定链添加相应规则，默认从规则号结尾进行添加（添加最后）&lt;/p&gt;
&lt;p&gt;-I             向指定链中插入规则，默认插入到第一条规则之上&lt;/p&gt;
&lt;p&gt;-p              指定访问数据的协议类型（tcp、udp、icmp）&lt;/p&gt;
&lt;p&gt;--dport      指定目标端口信息&lt;/p&gt;
&lt;p&gt;--sport       指定源端口信息&lt;/p&gt;
&lt;p&gt;-j               执行操作的动作（ACCEPT、DROP（丢弃）、REJECT（拒绝））&lt;/p&gt;
&lt;p&gt;-D             删除指定链里面的规则策略&lt;/p&gt;
&lt;p&gt;-i               指定数据流量进入接口信息（只能配置在INPUT链）&lt;/p&gt;
&lt;p&gt;-o              指定数据流量流出接口信息（只能配置在OUTPUT链）&lt;/p&gt;
&lt;p&gt;-s              指定数据流量源地址或网段信息&lt;/p&gt;
&lt;p&gt;-d              指定数据流量目标地址或网段信息&lt;/p&gt;
&lt;p&gt;!               表示控制策略取反&lt;/p&gt;
&lt;p&gt;-m            表示增加扩展匹配功能&lt;/p&gt;
&lt;h3&gt;参数说明&lt;/h3&gt;
&lt;p&gt;禁止10.0.0.0网段连入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
iptables -t filter -A INPUT -i eth0 -s &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; -j DROP &lt;br/&gt;可以不指定 -t filter 因为默认就是filter表
&lt;/pre&gt;
&lt;p&gt;-i：流量进入的接口（从eth0进入）&lt;/p&gt;
&lt;p&gt;-s：源地址&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;源地址不是10.0.0.150的单个IP的禁止连接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
iptables -t filter -A INPUT -i eth0 ！-s &lt;span&gt;10.0.0&lt;/span&gt;&lt;span&gt;.150&lt;/span&gt; -j DROP
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;禁用icmp协议：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
iptables -t filter -A INPUT -p icmp --icmp-type &lt;span&gt;8&lt;/span&gt; -i eth0 -s &lt;span&gt;10.0.0.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; -j DROP
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;禁止访问响应服务端口：&lt;/p&gt;
&lt;p&gt;     以22端口为例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
iptables -A INPUT -p tcp --dport &lt;span&gt;22&lt;/span&gt; -&lt;span&gt;j DROP       在默认表中的INPUT链中追加策略：禁止22端口访问&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除某规则：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
iptables -D INPUT -p tcp --dport &lt;span&gt;22&lt;/span&gt; -j ACCEPT   ---&lt;span&gt; 删除指定规则
iptables &lt;/span&gt;-D INPUT &lt;span&gt;2&lt;/span&gt;     --- 根据规则行号，删除相应的规则
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;禁止网段连入：&lt;/p&gt;
&lt;p&gt;    例子：禁止192.168.17.0网段访问10.0.0.7主机&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
iptables -A INPUT  -s &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;17.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; -d &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.7&lt;/span&gt; -j DROP 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   例子：禁止某个192.168.17.0网段不能访问服务器主机的22端口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
iptables -A INPUT -s &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;17.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; -d &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.7&lt;/span&gt; -p tcp --dport &lt;span&gt;22&lt;/span&gt; -j DROP
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;匹配指定协议以外的所有协议：&lt;/p&gt;
&lt;p&gt;    ！ 表示取反&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
iptables -A INPUT ! –p tcp –s &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; -j DROP     centos6写法
&lt;/pre&gt;
&lt;pre&gt;
-p ! tcp      centos5写法
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置连续多端口控制策略：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
iptables -A INPUT -p tcp --dport &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; -j DROP
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置不连续多端口控制策略：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
iptables -A INPUT -p tcp -m multiport  --dport &lt;span&gt;22&lt;/span&gt;,&lt;span&gt;80&lt;/span&gt; -j DROP 
&lt;/pre&gt;
&lt;p&gt;-m      --- 表示增加扩展匹配功能  multiport   实现不连续多端口扩展匹配&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;对网络数据传输进行限速：&lt;/p&gt;
&lt;div readability=&quot;66&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
iptables -I INPUT -s &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.7&lt;/span&gt; -p icmp --icmp-type &lt;span&gt;8&lt;/span&gt; -m limit --limit &lt;span&gt;6&lt;/span&gt;/min --limit-burst &lt;span&gt;5&lt;/span&gt; -&lt;span&gt;j ACCEPT
iptables &lt;/span&gt;-I INPUT -s &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.7&lt;/span&gt; -p icmp --icmp-type &lt;span&gt;8&lt;/span&gt; -&lt;span&gt;j DROP

&lt;/span&gt;--limit n/{second/minute/&lt;span&gt;hour}:
解释：指定时间内的请求速率”n”为速率，后面为时间分别为：秒 分 时

&lt;/span&gt;--limit-&lt;span&gt;burst [n]
解释：在同一时间内允许通过的请求”n”为数字，不指定默认为5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;企业级防火墙部署案例&lt;/h2&gt;
&lt;p class=&quot;a&quot;&gt;两种思想：对于默认策略为允许状态，防火墙规则就相当于黑名单；对于默认策略为禁止状态，防火墙规则就相当于白名单。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;首先清空默认规则，然后设置远程连接规则，防止自己被踢出，更改默认规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
iptables -&lt;span&gt;F
iptables &lt;/span&gt;-&lt;span&gt;X
iptables &lt;/span&gt;-&lt;span&gt;Z
iptables &lt;/span&gt;-A INPUT -p tcp --dport &lt;span&gt;22&lt;/span&gt; -j ACCEPT   ---&lt;span&gt; 防止被踢出门外
iptables &lt;/span&gt;-&lt;span&gt;P INPUT DROP
iptables &lt;/span&gt;-&lt;span&gt;P FORWARD ACCEPT
iptables &lt;/span&gt;-P OUTPUT ACCEPT
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;被指安全白名单策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
iptables -A INPUT -i lo -j ACCEPT   　　---&lt;span&gt; 让自己可以ping自己
iptables &lt;/span&gt;-A INPUT -p tcp -m multiport --dport &lt;span&gt;80&lt;/span&gt;,&lt;span&gt;443&lt;/span&gt; -j ACCEPT  　　---&lt;span&gt; 允许哪些网站服务可以访问
iptables &lt;/span&gt;-A INPUT -s &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; -j ACCEPT   　　---&lt;span&gt; 允许架构内部服务进行访问
iptables &lt;/span&gt;-A INPUT -s &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; -j ACCEPT    　　 --- 允许一些合作企业的外网服务器进行访问
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这几条就是最简单的企业防火墙部署&lt;/p&gt;
&lt;h3&gt;防火墙配置永久生效方法&lt;/h3&gt;
&lt;h4&gt;第一种方式&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@iptables ~]# /etc/init.d/&lt;span&gt;iptables save
iptables: Saving firewall rules to &lt;/span&gt;/etc/sysconfig/&lt;span&gt;iptables:[  OK  ]
[root@iptables &lt;/span&gt;~]# &lt;span&gt;cat&lt;/span&gt; /etc/sysconfig/&lt;span&gt;iptables
# Generated by iptables&lt;/span&gt;-save v1.&lt;span&gt;4.7&lt;/span&gt; on Wed Jan &lt;span&gt;17&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;
*&lt;span&gt;filter
:INPUT DROP [&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
:FORWARD ACCEPT [&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
:OUTPUT ACCEPT [&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;:&lt;span&gt;9632&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;-A INPUT -p tcp -m tcp --dport &lt;span&gt;22&lt;/span&gt; -&lt;span&gt;j ACCEPT 
&lt;/span&gt;-A INPUT -i lo -&lt;span&gt;j ACCEPT 
&lt;/span&gt;-A INPUT -p tcp -m multiport --dports &lt;span&gt;80&lt;/span&gt;,&lt;span&gt;443&lt;/span&gt; -&lt;span&gt;j ACCEPT 
&lt;/span&gt;-A INPUT -s &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; -&lt;span&gt;j ACCEPT 
COMMIT
# Completed on Wed Jan &lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;第二种方式&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
iptables-save &amp;gt;/etc/sysconfig/iptables
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;状态机制配置&lt;/h2&gt;
&lt;p&gt;# 允许关联的状态包通过（web服务不要使用FTP服务）&lt;/p&gt;
&lt;h3&gt;NEW&lt;/h3&gt;
&lt;p&gt;new说明这个包是我们看到的第一个包，意思就是，这是conntrack模块看到的某个连接的第一个包，它即将被匹配了。比如，我们看到一个SYN包，是我们所留意的连接的第一个包，就要匹配它。&lt;/p&gt;
&lt;p&gt;表示新建立连接的数据包状态&lt;/p&gt;
&lt;h3&gt;ESTABLISHED&lt;/h3&gt;
&lt;p&gt;ESTABLISHED已经注意到两个方向上的数据传输，而且会继续匹配这个连接的包。处于ESTABLISHED状态的连接是非常容易理解的。只要发送并接到应答，连接就是ESTABLISHED的了。一个连接要从new变为ESTABLISHED，只需要接到应答包即可，不管这个包是发往防火墙的，还是要由防火墙转发的。ICMP的错误和重定向信息包也被看作是ESTABLISHED，只要他们是我们所发出的信息的应答。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;a&quot;&gt;表示新建立连接数据包发送之后，回复响应的数据包状态&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;RELATED&lt;/h3&gt;
&lt;p&gt;RELATED是个比较麻烦的状态，当一个连接和某个已处于ESTABLISHED状态的连接有关系时，就会被认为是RELATED的了。换句话说，一个连接要想是RELATED的，首先要有一个ESTABLISHED的连接。这个ESTABLISHED连接再产生一个主连接之外的连接，这个新的连接就是RELATED的了，当然前提是conntarck模块要能理解RELATED。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;a&quot;&gt;表示借助已经建立的链路，发送新的连接数据包&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;INVALID&lt;/h3&gt;
&lt;p&gt;INVALID说明数据包不能被识别属于哪个连接或没有任何状态。有几个原因可以产生这种情况，比如，内存溢出，收到不知属于哪个连接的ICMP错误信息。一般地，我们DROP这个状态的任何东西，因为防火墙任务这是不安全的东西。&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p class=&quot;a&quot;&gt;无效无法识别的数据包&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt; &lt;/p&gt;
&lt;p&gt;防火墙服务配置在FTP服务器上时，需要配置以下策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
iptables -A INPUT -m state --state ESTABLISHED,RELATED -&lt;span&gt;j ACCEPT
iptables &lt;/span&gt;-A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;iptables NAT实践过程&lt;/h2&gt;
&lt;h3 class=&quot;a&quot;&gt;配置内网服务器利用iptables服务器外网网卡上网&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
route add default gw &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.200&lt;/span&gt;    --- 首先在内网服务器设置网关（网关为拥有外网网卡的防火墙服务器内网地址）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在防火墙服务器开启路由转发功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@iptables ~]# vim /etc/&lt;span&gt;sysctl.conf
[root@iptables &lt;/span&gt;~]# sysctl -&lt;span&gt;p
net.ipv4.ip_forward &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现内网访问外网的NAT映射&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
iptables -t nat -A POSTROUTING -s &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; -o eth0 -j SNAT --to-source &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.200&lt;/span&gt;
-s &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;            ---&lt;span&gt; 指定将哪些内网网段进行映射转换
&lt;/span&gt;-o eth0                     ---&lt;span&gt; 指定在共享上网哪个网卡接口上做NAT地址转换
&lt;/span&gt;-j SNAT                     ---&lt;span&gt; 将源地址进行转换变更
&lt;/span&gt;-j DNAT                     ---&lt;span&gt; 将目标地址进行转换变更
&lt;/span&gt;--to-source ip地址           ---&lt;span&gt; 将源地址映射为什么IP地址
&lt;/span&gt;--to-destination ip地址      --- 将目标地址映射为什么IP地址
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;iptables实现外网IP的端口映射到内网IP的端口&lt;/h3&gt;
&lt;p&gt;需求：将网关的IP和9000端口映射到内网服务器的22端口&lt;/p&gt;
&lt;p&gt;端口映射 10.0.0.88:9000 --&amp;gt;172.16.1.8:22&lt;/p&gt;
&lt;p&gt;实现命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
iptables -t nat -A PREROUTING -d &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.88&lt;/span&gt; -p tcp --dport &lt;span&gt;9000&lt;/span&gt; -i eth0 -j DNAT --to-destination &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.8&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;
-d &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.8目标地址
&lt;/span&gt;-j DNAT 目的地址改写
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt;效果：连接88服务器的9000端口，会自动跳转连接到8服务器的22端口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[e:\~]$ &lt;span&gt;ssh&lt;/span&gt; &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.88&lt;/span&gt; &lt;span&gt;9000&lt;/span&gt;&lt;span&gt;

Connecting to &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.88&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;...
Connection established.
To escape to local shell, press &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ctrl+Alt+]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.

Last &lt;/span&gt;&lt;span&gt;login&lt;/span&gt;: Wed Jan &lt;span&gt;17&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt; from &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.88&lt;/span&gt;&lt;span&gt;
[root@web01 &lt;/span&gt;~]#
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Fri, 19 Jan 2018 13:30:00 +0000</pubDate>
<dc:creator>酷酷的二连长</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyq863987322/p/8310117.html</dc:identifier>
</item>
<item>
<title>小乔注：java关键字static - 铜雀春深锁二乔</title>
<link>http://www.cnblogs.com/hellohellozxb/p/8318626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellohellozxb/p/8318626.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;static是java中又一重要的关键字，在一定环境下使用，可以提高程序的运行性能，优化程序的结构。其主要应用有以下几方面：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.static修饰的成员变量，称为类变量/静态变量，以实现所有对象对该成员的共享。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.static修饰的成员方法，称为类方法/静态方法，可直接通过类名调用，无需创建对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.形成静态代码块，优化程序性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.静态导包，一般将类的方法直接导入到当前类中，从而直接使用方法名即可调用类方法，更加方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.修饰内部类，无需实例化外部类就可以调用内部类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面一一附代码说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
        String name;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Name:&quot; + name + &quot;, Age:&quot; +&lt;span&gt; age;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
          Student s1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
            s1.name&lt;/span&gt;=&quot;张三&quot;&lt;span&gt;;
            s1.age&lt;/span&gt;=20&lt;span&gt;;
           Student s2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
            s2.name&lt;/span&gt;=&quot;李四&quot;&lt;span&gt;;
            s2.age&lt;/span&gt;=10&lt;span&gt;;
            System.out.println(s1);
            System.out.println(s2);
        }
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;输出结果
Name:张三, Age:10
Name:李四, Age:10
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上述代码，s1和s2两个对象分别存储在内存中堆区域的不同地址中，所以他们之间相互不会干扰。然而static关键字修饰了成员变量age，让其变成类的所属，而不是对象的所属，任何该类实例的对象都可以共享使用它。所以，输出的age均是最终赋给的10。如果去掉static，显然对象之间互不影响，输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Name:张三, Age:20&lt;span&gt;
Name:李四, Age:&lt;/span&gt;10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1264530/201801/1264530-20180119184106646-1000080859.png&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;478&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;如上述代码，out1调用out2时出错。由此代码可得，静态方法不能调用非静态的成员变量和成员方法。非静态方法可以调用静态的成员变量和成员方法。注意，static不影响成员的访问权限，Java中能够影响到访问权限的关键词是private、public、protected，default。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Base{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         System.out.println(&quot;static静态块1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Test(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         System.out.println(&quot;test构造器&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }    
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         System.out.println(&quot;static静态块2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Base(){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         System.out.println(&quot;base构造器&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上述代码，记住两句话，static代码块随类的加载一起加载。static修饰的变量方法比其他变量方法优先加载，且只加载一次。加载子类时，会首先加载父类。由此可以分析：在执行开始，先要寻找到main方法，因为main方法是程序的入口，但是在执行main方法之前，必须先加载Test类，而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。因此，运行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static静态块2
static静态块1
base构造器
test构造器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; A.java文件 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dogo.test;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outWord(Object o){
        System.out.println(o);
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; B.java文件 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; com.dogo.test.A.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; B
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
    {
        outWord(&lt;/span&gt;&quot;Hello World!&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;输出
     * Hello World!
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上述代码，A.java中包含一个简单的静态方法，在B.java中我们用static关键字将A类导入&lt;strong&gt;，&lt;/strong&gt;由此，便无需使用“类名.方法名”的方法去调用类方法了，直接可以采用&quot;方法名&quot;去调用类方法，就好像是该类自己的方法一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Outer.java&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Outer {
　　&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        System.out.println(&lt;/span&gt;&quot;Outer静态块&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Outer(){
        System.out.println(&lt;/span&gt;&quot;Outer构造器&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Inner{
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;Inner静态块&quot;&lt;span&gt;);
        }
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Inner(){
            System.out.println(&lt;/span&gt;&quot;Inner构造器&quot;&lt;span&gt;);
        }
    }
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Test.java&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Outer.Inner();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如上述代码，记住，用static修饰内部类，外部类可以直接调用内部类，因为static修饰的的内部类是在加载外部类的同时加载的，所以，并不要实例化外部类就能直接调用静态内部类。&lt;/span&gt;&lt;span&gt;例子中，在进入Test的main方法之前，加载Test类，然后执行new Outer.Inner();这里需要注意：因为Inner是静态的，所以这里并不需要加载外部类和实例化外部类，可以直接加载Inner并实例化。运行结果如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Inner静态块
Inner构造器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;大乔注：static另一个很重要的应用就是实现单例设计模式。&lt;span&gt;单利模式的特点是该类只能有一个实例，为了实现这一功能，必须隐藏类的构造函数，即把构造函数声明为private，并提供一个创建对象的方法，由于构造对象被声明为private，外界无法直接创建这个类型的对象，只能通过该类提供的方法来获取类的对象，于是只能把创建对象的方法声明为static，程序实例如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingleDemo{  
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SingleDemo ins=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SingleDemo(){}  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SingleDemo getIns(){  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ins==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){  
                ins&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingleDemo();  
            }  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ins;  
        }  
    }  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2193fbbb-21bb-4ade-8165-be70e3b9b1b2')&quot;&gt;
&lt;div id=&quot;cnblogs_code_open_2193fbbb-21bb-4ade-8165-be70e3b9b1b2&quot; class=&quot;cnblogs_code_hide&quot;&gt;

&lt;pre&gt;
&lt;span&gt;Inner静态块
I&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Fri, 19 Jan 2018 12:06:00 +0000</pubDate>
<dc:creator>铜雀春深锁二乔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellohellozxb/p/8318626.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——22. 接口仅用来定义类型 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8318554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8318554.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当类实现接口时，该接口作为一种类型（type），可以用来引用类的实例。因此，一个类实现了一个接口，因此表明客户端可以如何处理类的实例。为其他目的定义接口是不合适的。&lt;/p&gt;
&lt;p&gt;一种失败的接口就是所谓的常量接口（constant interface）。 这样的接口不包含任何方法; 它只包含静态final属性，每个输出一个常量。 使用这些常量的类实现接口，以避免需要用类名限定常量名。 这里是一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Constant interface antipattern - do not use!
public interface PhysicalConstants {
    // Avogadro's number (1/mol)
    static final double AVOGADROS_NUMBER   = 6.022_140_857e23;

    // Boltzmann constant (J/K)
    static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;

    // Mass of the electron (kg)
    static final double ELECTRON_MASS      = 9.109_383_56e-31;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;常量接口模式是对接口的糟糕使用&lt;/strong&gt;。类在内部使用一些常量，完全属于实现细节。实现一个常量接口会导致这个实现细节泄漏到类的导出API中。对类的用户来说，类实现一个常量接口是没有意义的。事实上，它甚至可能使他们感到困惑。更糟糕的是，它代表了一个承诺：如果在将来的版本中修改了类，不再需要使用常量，那么它仍然必须实现接口，以确保二进制兼容性。如果一个非final类实现了常量接口，那么它的所有子类的命名空间都会被接口中的常量所污染。&lt;/p&gt;
&lt;p&gt;Java平台类库中有多个常量接口，如&lt;code&gt;java.io.ObjectStreamConstants&lt;/code&gt;。 这些接口应该被视为不规范的，不应该被效仿。&lt;/p&gt;
&lt;p&gt;如果你想导出常量，有几个合理的选择方案。 如果常量与现有的类或接口紧密相关，则应将其添加到该类或接口中。 例如，所有数字基本类型的包装类，如&lt;code&gt;Integer&lt;/code&gt;和&lt;code&gt;Double&lt;/code&gt;，都会导出&lt;code&gt;MIN_VALUE&lt;/code&gt;和&lt;code&gt;MAX_VALUE&lt;/code&gt;常量。 如果常量最好被看作枚举类型的成员，则应该使用枚举类型（条目 34）导出它们。 否则，你应该用一个不可实例化的工具类来导出常量（条目 4）。 下是前面所示的&lt;code&gt;PhysicalConstants&lt;/code&gt;示例的工具类的版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Constant utility class
package com.effectivejava.science;

public class PhysicalConstants {
  private PhysicalConstants() { }  // Prevents instantiation

  public static final double AVOGADROS_NUMBER = 6.022_140_857e23;
  public static final double BOLTZMANN_CONST  = 1.380_648_52e-23;
  public static final double ELECTRON_MASS    = 9.109_383_56e-31;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;顺便提一下，请注意在数字文字中使用下划线字符（_）。 从Java 7开始，合法的下划线对数字字面量的值没有影响，但是如果使用得当的话可以使它们更容易阅读。 无论是固定的浮点数，如果他们包含五个或更多的连续数字，考虑将下划线添加到数字字面量中。 对于底数为10的数字，无论是整型还是浮点型的，都应该用下划线将数字分成三个数字组，表示一千的正负幂。&lt;/p&gt;
&lt;p&gt;通常，实用工具类要求客户端使用类名来限定常量名，例如&lt;code&gt;PhysicalConstants.AVOGADROS_NUMBER&lt;/code&gt;。 &lt;strong&gt;如果大量使用实用工具类导出的常量，则通过使用静态导入来限定具有类名的常量&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Use of static import to avoid qualifying constants
import static com.effectivejava.science.PhysicalConstants.*;

public class Test {
    double  atoms(double mols) {
        return AVOGADROS_NUMBER * mols;
    }
    ...
    // Many more uses of PhysicalConstants justify static import
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总之，接口只能用于定义类型。 它们不应该仅用于导出常量。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jan 2018 11:36:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8318554.html</dc:identifier>
</item>
<item>
<title>跟我一起读postgresql源码(十一)——Executor(查询执行模块之——Materialization节点(上)) - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/8302733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/8302733.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;顾名思义，物化节点是一类可缓存元组的节点。在执行过程中，很多扩展的物理操作符需要首先获取所有的元组后才能进行操作(例如聚集函数操作、没有索引辅助的排序等)，这时要用物化节点将元组缓存起来。下面列出了PostgreSQL中提供的物化节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    T_MaterialState,
    T_SortState,
    T_GroupState,
    T_AggState,
    T_WindowAggState,
    T_UniqueState,
    T_HashState,
    T_SetOpState,
    T_LockRowsState,
    T_LimitState,&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;material节点&quot;&gt;1.Material节点&lt;/h2&gt;
&lt;p&gt;先上例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# explain select * from test_dm where id &amp;gt; any (select id from test_new);
                               QUERY PLAN
------------------------------------------------------------------------
 Nested Loop Semi Join  (cost=0.00..32201696.41 rows=333333 width=68)
   Join Filter: (test_dm.id &amp;gt; test_new.id)
   -&amp;gt;  Seq Scan on test_dm  (cost=0.00..22346.00 rows=1000000 width=68)
   -&amp;gt;  Materialize  (cost=0.00..58.25 rows=2550 width=4)
         -&amp;gt;  Seq Scan on test_new  (cost=0.00..35.50 rows=2550 width=4)
(5 行)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的子查询“select id from test_new”的结果在主查询中会使用多次，因此postgres将其查询结果缓存下来，避免多次重复的查询。&lt;/p&gt;
&lt;p&gt;所以我们知道了，Material节点用于缓存子节点结果，对于需要重复多次扫描的子节点（特别是扫描结果每次都相同时）可以减少执行的代价。其实现方式在于将结果元组存储于状态节点MaterialState中的特殊的数据结构Tuplestorestate中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct MaterialState
{
    ScanState   ss;             /* its first field is NodeTag */
    int         eflags;         /* capability flags to pass to tuplestore */
    bool        eof_underlying; /* reached end of underlying plan? */
    Tuplestorestate *tuplestorestate;
} MaterialState;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上下两个数据结构所示，Material节点并没有在Plan的基础上定义扩展属性，执行状态节点MaterialState扩展了ScanState节点的定义，增加了tuplestorestate字段用于缓存元组。eof_underlying则表示下层节点已经扫描完毕，从而避免重复调用下层节点的执行过程，eflags是一个状态变量，它表示当前节点是否需要支持反向扫描、标记扫描位置和重新扫描三种操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct Material
{
    Plan        plan;
} Material;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Material节点的初始化过程（ExecInitMaterial函数〉主要是初始化eflags信息，并调用左子节点的初始化过程。&lt;/p&gt;
&lt;p&gt;在Material节点执行过程（ExecMaterial函数）中，首先判断是否已经初始化tuplestorestate，如没有，则会调用tuplestorej^eginjieap创建Tuplestorestate结构。然后把当前缓存中未返回的元组取出并返回，若不存在未返回的元组，则需要进一步判断下层节点是否扫描完毕（eof_underiying为true表示扫描完毕）。如果下层节点没有扫描完成则会从下层节点获取元组放入缓存中，同时返回元组；如果下层节点已经完成扫描，则Material节点将返回空元组。&lt;/p&gt;
&lt;p&gt;Material节点的清理工作（ExecEndMaterial函数）主要是对于元组缓存结构的清理，并调用左子节点的清理过程，最后释放MaterialState结构。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;sort节点&quot;&gt;2.Sort节点&lt;/h2&gt;
&lt;p&gt;关于Sort节点我在之前已经介绍过，这里是地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/flying-tiger/p/8120046.html&quot;&gt;Postgres中的物化节点之sort节点&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;group节点&quot;&gt;3.Group节点&lt;/h2&gt;
&lt;p&gt;group子句大家应该不陌生，上例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# explain select id from test_dm group by id having id &amp;lt; 5;;
                            QUERY PLAN
-------------------------------------------------------------------
 HashAggregate  (cost=24846.25..24847.25 rows=100 width=4)
   Group Key: id
   -&amp;gt;  Seq Scan on test_dm  (cost=0.00..24846.00 rows=100 width=4)
         Filter: (id &amp;lt; 5)
(4 行)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Group节点用于处理GROUP BY子句，将下层节点满足选择条件（HAVING子句）的元组分组后，只返回该分组的第一个元组。该节点只有一个左子节点，且子节点必须返回在分组属性上已排好序的元组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct Group
{
    Plan        plan;
    int         numCols;        /* number of grouping columns */
    AttrNumber *grpColIdx;      /* their indexes in the target list */
    Oid        *grpOperators;   /* equality operators to compare with */
} Group;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是Group节点的结构，它在Plan的基础上扩展了以下几个字段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;numCols用于记录分组属性的个数;&lt;/li&gt;
&lt;li&gt;grpColIdx数组记录了分组属性的属性号;&lt;/li&gt;
&lt;li&gt;grpOperaticms数组记录了在分组属性上进行等值判断的操作符的OID。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;typedef struct GroupState
{
    ScanState   ss;             /* its first field is NodeTag */
    FmgrInfo   *eqfunctions;    /* per-field lookup data for equality fns */
    bool        grp_done;       /* indicates completion of Group scan */
} GroupState;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Group节点因为只有一个输人节点，因此初始化过程（ExecInitGroup函数）只需调用左子节点的初始化过程。然后对每个属性上的比较操作符进行初始化，找到对应的操作符函数相关信息（用Fmgrlnfo结构保存，该结构实际上记录了对应的操作函数在系统表中的需要用到的字段的值，这些字段值在fmgr模块调用指定函数时需要用到）。&lt;/p&gt;
&lt;p&gt;在执行过程中，由于左子节点返回的结果是按照分组属性排序的，因此只要发现连续的两个元组在分组属性上不等，即可判定前一个元组就是上一个分组的最后一个元组，而后一个元组是一个新分组的第一个元组(很显然不是么)。&lt;/p&gt;
&lt;p&gt;Group节点的执行过程（ExecGroup函数）如下：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;1)获取下层返回元组中符合HAVING子句条件（存储于Plan, qual选择条件链表中）的第一个元组，将其作为分组内的第一个元组，缓存该元组信息到状态节点的ss_ScanTupleSlot中，并输出该元组；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;2)依次获取组内的所有元组，直到获取到一个在分组属性上与当前分组不等的元组，表明当前分组结束；若下层节点返回空元组，表示分组操作完成，则会设置状态节点的grp_done字段为true并结束执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;3)扫描下一个满足HAVING条件的元纽，缓存元组作为新分组的开始，并返回该元组；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4)重复执行2),3)；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5)结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于执行过程中使用了状态节点中的ss_ScanTupleSlot,在Group节点的清理过程（ExecEndGroup函数）中需要调用ExecClearTuple进行元组的淸理工作。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;agg节点&quot;&gt;4.Agg节点&lt;/h2&gt;
&lt;p&gt;上例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# explain select max(name) from test_dm;
                               QUERY PLAN                                   &amp;lt;---    Plain策略
------------------------------------------------------------------------
 Aggregate  (cost=24846.00..24846.01 rows=1 width=45)
   -&amp;gt;  Seq Scan on test_dm  (cost=0.00..22346.00 rows=1000000 width=45)
(2 rows)

postgres=# explain select max(name) from test_dm  group by id order by id;
                                  QUERY PLAN                                &amp;lt;---    Sorted策略
------------------------------------------------------------------------------
 GroupAggregate  (cost=122003.84..139503.84 rows=1000000 width=49)
   Group Key: id
   -&amp;gt;  Sort  (cost=122003.84..124503.84 rows=1000000 width=49)
         Sort Key: id
         -&amp;gt;  Seq Scan on test_dm  (cost=0.00..22346.00 rows=1000000 width=49)
(5 rows)


postgres=# explain select max(name) from test_dm group by id;
                               QUERY PLAN                                   &amp;lt;---    Hash策略
------------------------------------------------------------------------
 HashAggregate  (cost=27346.00..37346.00 rows=1000000 width=23)
   Group Key: id
   -&amp;gt;  Seq Scan on test_dm  (cost=0.00..22346.00 rows=1000000 width=23)
(3 rows)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Agg节点用于执行含有聚集函数的GROUP BY操作，该节点能够实现三种执行策略：Plain (不分组的聚集计算）、Sorted (下层节点提供排好序的元组，类似Group的分组方法，然后进行聚集计算）、Hash (首先对下层节点提供的未排序元组进行分组，然后进行计算）。&lt;/p&gt;
&lt;p&gt;Agg的执行的一般方法是：首先初始化聚集计算的初始值，将其记录在中间结果中。然后，针对每一条输人元组使用迭代聚集函数进行迭代计算，得到新的中间结果。最后，如果有必要的话，使用结束函数进行处理。&lt;/p&gt;
&lt;p&gt;我们可以看看代码中怎么说的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;src/backend/executor/nodeAgg.c

 *    ExecAgg evaluates each aggregate in the following steps:
 *
 *       transvalue = initcond
 *       foreach input_tuple do
 *          transvalue = transfunc(transvalue, input_value(s))
 *       result = finalfunc(transvalue, direct_argument(s))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，initcond表示初始值，transvalue为中间结果，input_tuple是输人的元组，transfunc是迭代聚集函数，finalfunc是结束函数，result是最终的结果。(postgres可以自定义agg，那么我们也就知道了自定义agg需要哪些函数支持了。这个我在&lt;a href=&quot;http://www.cnblogs.com/flying-tiger/p/7814891.html&quot;&gt;在PostgreSQL自定义一个“优雅”的type&lt;/a&gt;的第二节里写了一点用法)&lt;/p&gt;
&lt;p&gt;Agg节点的定义如下所示，除了定义执行的策略类型（aggstrategy)，还定义了聚集属性的数量（mimCols)、聚集属性的属性号数组（gtpColIdx)、分组函数数组（grpOperators)以及估计的分组数量（numGroups)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct Agg
{
    Plan        plan;
    AggStrategy aggstrategy;
    int         numCols;        /* number of grouping columns */
    AttrNumber *grpColIdx;      /* their indexes in the target list */
    Oid        *grpOperators;   /* equality operators to compare with */
    long        numGroups;      /* estimated number of groups in input */
    Bitmapset  *aggParams;      /* IDs of Params used in Aggref inputs */
    /* Note: planner provides numGroups &amp;amp; aggParams only in AGG_HASHED case */
    List       *groupingSets;   /* grouping sets to use */
    List       *chain;          /* chained Agg/Sort nodes */
} Agg;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Agg节点的初始化过程（ExecInitAgg函数）中，首先对目标属性targetlist和査询条件qual进行初始化，并找到其中的Aggref节点（用于表示聚集函数的表达式节点）。然后根据每个Aggref节点中存储的聚集函数信息进行初始化，为其构造一个AggStatePerAgg结构，其中存储了聚集函数信息运算相关的信息和内存上下文。如果有多个相同的Aggref节点，只会构造一个AggStatePerAgg结构（例如“SELECT sum(x)... HAVING sum (x) &amp;gt;0”中的求和运算）。最后根据策略类塱对相应的状态信息进行初始化：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;1)Plain (aggstrategy 值为 AGG_PLAIN)和 Sorted (aggstrategy 值为 AGG_SORTED)策略都不需复杂的分组过程，因此每次执行只需保存一个分组的中间结果，此时可使用pergroup结构数组保存一个分组的所有聚集函数的中间结果。由于Sorted方法与Group的分组方式一致，因此还需要eq_function用于判断分组的分界线，并用grp_firstTuple字段缓存分组的第一个元组。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;2)Hash (aggstrategy值为AGG_HASHED)策略，Hash表中不缓存真正的元组，而只是使用元组计算得到的Hash值作为索引。Hash表（hasJitable)中只存储该分组的聚集函数中间值的数组（由AggStatePerGroup结构存储），而hashslot用于缓存Hash的元组中需要进行Hash的属性值,hash_needed则对应于需要进行Hash的属性序号的链表。在巳经获取了所有下层节点元组后，从Hash表中依次获取分组的中间结果时会用到hashiter。构造Hash函数信息从Agg节点的grpOperators获取，信息存放于hashfunctions数组中。初始化时会对涉及的这些属性进行初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下图展示了 AGG_PLAIN/AGG_SORTED策略的执行状态。其中，peragg用于存储聚集函数(即transfunc),pergroup存储了当前所处理分组的状态，获取的元组将与每一个pergroup值一并被peragg中的函数处理，得到新的中间结果，重新存储于相应的pergroup中。AGG_HASHED过程则需要首先计算输人元组的Hash值，然后从Hash表中获取对应分组的中间结果记录数组，类似于pergroup,然后进行和以上两个策略相同的计算过程。(后续补充....)&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180119191542443-185399109.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Agg节点清理过程需要对使用到的内存上下文进行回收，清理分配的TupleTableSlot结构，并调用下层节点的淸理过程。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;unique-节点&quot;&gt;5.Unique 节点&lt;/h2&gt;
&lt;p&gt;Unique节点用于对下层节点返回的已排序元组进行去重操作。由于下层节点获取到的元组已经排序，因此在Unique节点的执行过程中只需要缓存上一个返回的元组，判断当前获f的元组是否和上一个元组在指定厲性上重复。如果重复，则忽略当前元组并继续从下层节点获取元组；如果不重复，则输出当前元组并用它替换缓存中的元组。Unique节点一般用于处理査询中的DISTINCT关键字，但这不是唯一的处理方式。如果要求去重的属性被“ORDER BY”子句引用时，一般会使用Unique节点进行处理（例如，“SELECT DISTINCT(x) … ORDER BY x”中的属性x)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# explain select distinct(id) from test_dm order by id;
                                 QUERY PLAN
-----------------------------------------------------------------------------
 Unique  (cost=122003.84..127003.84 rows=1000000 width=4)
   -&amp;gt;  Sort  (cost=122003.84..124503.84 rows=1000000 width=4)
         Sort Key: id
         -&amp;gt;  Seq Scan on test_dm  (cost=0.00..22346.00 rows=1000000 width=4)
(4 rows)

postgres=# explain select distinct(id) from test_dm;
                              QUERY PLAN
-----------------------------------------------------------------------
 HashAggregate  (cost=24846.00..34846.00 rows=1000000 width=4)
   Group Key: id
   -&amp;gt;  Seq Scan on test_dm  (cost=0.00..22346.00 rows=1000000 width=4)
(3 rows)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Unique节点的定义如下，其中numCols表示用于去重的属性数量，uniqColIdx数组和uniqOperators数组分别存储了去重属性的属性号和对应的判断操作符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct Unique
{
    Plan        plan;
    int         numCols;        /* number of columns to check for uniqueness */
    AttrNumber *uniqColIdx;     /* their indexes in the target list */
    Oid        *uniqOperators;  /* equality operators to compare with */
} Unique;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在初始化过程中，会根据中的操作符列表初始化UniqueState结构中用于保存判断函数信息的eqfunctions字段。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct UniqueState
{
    PlanState   ps;             /* its first field is NodeTag */
    FmgrInfo   *eqfunctions;    /* per-field lookup data for equality fns */
    MemoryContext tempContext;  /* short-term context for comparisons */
} UniqueState;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Unique节点的执行过程会首先从下层节点获取一个元组，如果是第一个元组，则直接输出。否则将使用eqfunctions中的函数判断当前元组与上次返回的元组在去重属性上是否相等，如果当前元组与上次返回的元组在去重属性上不相等则输出当前元组，如果相等则再从下层节点获取下一个元组进行同样的判断。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;hash节点&quot;&gt;6.Hash节点&lt;/h2&gt;
&lt;p&gt;Hash节点作为Hashjoin节点的辅助节点，共同完成Hash连接方法。Hash节点利用Hash方法(这个后面再讲吧，目前没看到)，将从左子节点获取的元组放人构造好的 Hash 表中。 Hash 节点也只有一个左子节点。&lt;br/&gt;例子如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# explain select a.id,b.id from test_dm a join test_new b on  a.id = b.id;
                                  QUERY PLAN
-------------------------------------------------------------------------------
 Hash Join  (cost=34846.00..34916.56 rows=2550 width=8)
   Hash Cond: (b.id = a.id)
   -&amp;gt;  Seq Scan on test_new b  (cost=0.00..35.50 rows=2550 width=4)
   -&amp;gt;  Hash  (cost=22346.00..22346.00 rows=1000000 width=4)
         -&amp;gt;  Seq Scan on test_dm a  (cost=0.00..22346.00 rows=1000000 width=4)
(5 rows)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下所示，Hash节点定义了skew方法(主要用于Hashjoin节点)需要使用的相关信息。这些信息用于构造Hash表时，使用外连接表的元组统计信息来优化Hash表的组织结构，将最常用的Hash值单独存放，保持在内存中，以优化连接时Hash匹配的过程。这些信息包括了属性偏移量和属性的类型等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct Hash
{
    Plan        plan;
    Oid         skewTable;      /* outer join key's table OID, or InvalidOid */
    AttrNumber  skewColumn;     /* outer join key's column #, or zero */
    bool        skewInherit;    /* is outer join rel an inheritance tree? */
    Oid         skewColType;    /* datatype of the outer key column */
    int32       skewColTypmod;  /* typmod of the outer key column */
    /* all other info is in the parent HashJoin node */
} Hash;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Hash节点的初始化过程仅构造HashState节点，并未构建Hash表和hashkeys (将由Hashjoin节点进行初始化）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct HashState
{
    PlanState   ps;             /* its first field is NodeTag */
    HashJoinTable hashtable;    /* hash table for the hashjoin */
    List       *hashkeys;       /* list of ExprState nodes */
    /* hashkeys is same as parent's hj_InnerHashKeys */
} HashState;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Hash节点在执行时会从下层节点获取元组，并使用hashkeys中的表达式计箅元组的Hash值，通过Hash值中的块号判断是否需要放人缓存文件中（Hash表一次只能将一个块的内容放人内存中），然后将元组保存在Hash表相应的块中。Hash节点的清理过程会调用下层左子节点的清理过程。&lt;/p&gt;
&lt;p&gt;剩下的下篇再说吧~&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jan 2018 11:24:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/8302733.html</dc:identifier>
</item>
<item>
<title>Go并发模式：管道与取消 - 一面千人</title>
<link>http://www.cnblogs.com/Evsward/p/goPipeline.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Evsward/p/goPipeline.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关键字：Go语言，管道，取消机制，并发，sync.WaitGroup，包引用，通道，defer，select&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;Go的并发能力可以使构建一个流数据管道变得非常容易，并且可以高校地使用机器I/O和多核处理器。这篇文章展示了一些例子，包括管道，对操作失败的处理技术。&lt;/p&gt;
&lt;h3 id=&quot;管道的概念&quot;&gt;管道的概念&lt;/h3&gt;
&lt;p&gt;在Go里，并没有正式的管道的定义，它只是众多并发程序其中的一个。通俗来讲，一个管道是一系列由通道连接的阶段，每个阶段都是一组运行着同样函数的goroutine。在每个阶段里，goroutine在干着：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过接入通道（inbound channels）接收上游流下来的值&lt;/li&gt;
&lt;li&gt;对这些数据执行某个函数，通常会产生新的值&lt;/li&gt;
&lt;li&gt;通过导出通道（outbound channels）下游发送值&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;第一个阶段也叫source或者producer&lt;/li&gt;
&lt;li&gt;最后一个阶段也叫sink或者consumer&lt;br/&gt;以上这两个阶段都只能有一个通道，或者是接入通道或者是导出通道，不能同时拥有这两种。而其他每个阶段都可以共同拥有任意数量的接入通道和导出通道。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一个用来学习的例子&quot;&gt;一个用来学习的例子&lt;/h2&gt;
&lt;p&gt;下面我们将展开一个简单的管道例子，来阐述其中的思想和技术，后面会有实际的例子。&lt;/p&gt;
&lt;h3 id=&quot;平方函数&quot;&gt;平方函数&lt;/h3&gt;
&lt;p&gt;直接看代码中注释。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意goroutine是函数体内并发，有一个壳sandbox扣着它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 要想run，必须package main，默认是文件夹目录名，要更改一下
package main

import &quot;fmt&quot;

// 设想一个拥有三个阶段的管道

/*
 * First Stage: gen
 * params: 一个以逗号分隔的整数列表，数量不限
 * return: 一个通道，包含参数中整数列表的通道
 */
func gen(nums ... int) &amp;lt;-chan int {
    out := make(chan int)
    // 通过一个goroutine来将参数中的每个整数发送到通道中去。
    go func() {
        for _, n := range nums {
            out &amp;lt;- n
        }
        close(out) // close方法作为上面的for循环的终止条件，不能省略。
    }()
    return out
}

/*
 * Second Stage: sq
 * params: 一个包含参数中整数列表的通道
 * return: 一个包含将参数通道中每个整数平方后的列表的通道
 * note: 因为参数和返回值的类型都是相同的整型通道，所以可以反复嵌套该方法。
 */
func sq(in &amp;lt;-chan int) &amp;lt;-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out &amp;lt;- n * n // 平方
        }
        close(out)
    }()
    return out
}

/*
 * Final Stage: main
 * 是一个main函数，没有参数也没有返回值，它相当于客户端调用
 */
func main() {
    c := gen(2, 3) // 建立通道
    out := sq(c)   // 通道处理
    // 上面传入两个值2和3，那么这里就要对应的消费两次输出
    fmt.Println(&amp;lt;-out)
    fmt.Println(&amp;lt;-out)
    // 嵌套sq
    for n := range sq(sq(gen(1, 2, 4, 5))) {
        fmt.Println(n)
    }
}

// output:
//  4
//  9
//  1
//  16
//  256
//  625&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;fan-out和fan-in&quot;&gt;Fan-out和Fan-in&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Fan-out，扇出。多个函数可以读取同一个通道直到该通道关闭。可让一群工人并用CPU和IO&lt;/li&gt;
&lt;li&gt;Fan-in，扇入。一个函数可以读取多个输入，每个输入被多路复用到一个独立的通道上，当所有输入被关闭时，这个通道也会被关闭，同时它也会关掉这个函数的使用权。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们将运行连个sq函数的实例，都会读取同一个输入通道，我们将使用一个新函数，叫做merge，来扇入多个结果。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;向一个已关闭的通道发送值，会引起通道panic错误，所以引入了sync.WaitGroup功能来控制当所有发送行为结束以后关闭通道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;sync.waitgroup&quot;&gt;sync.WaitGroup&lt;/h4&gt;
&lt;p&gt;sync.WaitGroup像java的倒计时锁，首先我们定义它的Wait方法设置一个锁到某个并发程序中，然后通过Add方法定义计数器大小CounterSize，该大小为最多发送数据到通道的执行次数，每次执行结束要通过Done方法来使CounterSize减一，直到CounterSize为0，上面我们定义的Wait才会释放锁。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意，WaitGroup的计数器大小CounterSize在初始化时默认为1，也就是说没调用Add之前，需要一次Done方法执行以后，Wait锁才会释放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;merge函数&quot;&gt;merge函数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;func merge(cs ...&amp;lt;-chan int) &amp;lt;-chan int {
    var wg sync.WaitGroup
    // 定义一个独立通道out，将接收所有值
    out := make(chan int)

    // 将通道中所有值转到out
    output := func(c &amp;lt;-chan int) {
        for n := range c {
            out &amp;lt;- n
        }
        wg.Done()
    }

    wg.Add(len(cs))
    // 将merge参数中所有通道的值都合到唯一通道out上去
    for _, c := range cs {
        go output(c)
    }

    // 启动一个额外的goroutine（不会按照代码顺序执行，而是一进到merge就会启动）来等待直到所有通道Done以后关闭那个唯一通道out。
    go func() {
        wg.Wait()// 直到wg全都Done了才会继续执行。
        close(out)
    }()
    return out
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;go的包引用问题&quot;&gt;Go的包引用问题&lt;/h4&gt;
&lt;p&gt;当我们要使用其他Go文件内部的函数时，会有两种处理方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将函数绑定到某个type下，然后在调用时创建那个type的实例即可调用。&lt;/li&gt;
&lt;li&gt;将函数名首字母大写，我们就可以通过包名调用了。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上两种方法都会存在一个问题，就是包引用问题，如果你找不到源码位置，调用其函数就无从谈起，那么如何正确的引用包呢？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意，最容易引发混乱的是main函数，因为main函数是可执行Go文件的必须元素，同时必须是指定package也为main，因此我们尽量不要在main函数所在的Go文件中添加与main无关的内容，否则我们很难通过包名或者文件名定位函数的意思。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意，Go中最没用的就是Go文件名了，包引用都是通过package。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正确的引用包是：将被调用函数所在文件，声明package为其所在文件夹名字，&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意，所有的该文件夹下的Go文件的package声明必须为同一个，不能出现第二个值，对外部调用者来讲，这些文件好似在一起，都是从一个package读取，并无区分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后在调用函数的地方import进来被调用函数声明的package即可。&lt;/p&gt;
&lt;p&gt;所以总结一下，文件夹名即包名，文件夹内给Go文件起名要能够解释清楚文件内容，main函数文件指定到有意义的文件夹下，导入所需函数包。&lt;/p&gt;
&lt;h4 id=&quot;main函数&quot;&gt;main函数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    in := pipeline.Gen(2, 3)
    c1 := pipeline.Sq(in)
    c2 := pipeline.Sq(in)
    // 将c1和c2通道内的值合并到一起
    for n := range merge(c1, c2) {
        fmt.Println(n)
    }
}

// Output:
//  4
//  9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;out:= merge(c1,c2)
fmt.Println(&amp;lt;-out)
fmt.Println(&amp;lt;-out)
fmt.Println(&amp;lt;-out)// 第三次输出，通道已无值，输出零值，如果通道输出完毕时即关闭的话，这一行会报错
// Output:
//  4
//  9
//  0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;发现问题发送次数少于接收次数&quot;&gt;发现问题？发送次数少于接收次数&lt;/h3&gt;
&lt;p&gt;上面的管道函数有一个模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有的发送操作完成时，阶段会关闭他们的导出通道。&lt;/li&gt;
&lt;li&gt;阶段会一直从导入通道中接收值，直到那些通道被关闭。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个模式允许每个接收的阶段可以被作为一个range循环写入，并且保证一旦所有的值都已经成功发送下游，所有的goroutine退出。&lt;/p&gt;
&lt;p&gt;但是在真实的管道里，阶段不会总是能接收到所有的导入值。有时候这是由于一个设计：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接收者可能只需要一个值的子集来取得进展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更常见的是，一个阶段早早退出是因为一个导入值代表了一个更早阶段的error。在这两种情况下，接收方不应该等待其余值的到达，并且我们想要更早的阶段来停止那些后期阶段不需要的生产时期的值。&lt;/p&gt;
&lt;p&gt;在我们的例子中，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;out:= merge(c1,c2)
fmt.Println(&amp;lt;-out)
// Output:
//  4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上out通道中还有一个9没有被输出，通道的值此时没有被完全消费，这时goroutine就会不断尝试发送该值，并且会被无限期阻塞。&lt;/p&gt;
&lt;p&gt;这是一个资源泄露，goroutine消耗内存和运行时资源，并且在goroutine栈中的堆引用会一直防止数据被垃圾收集器回收。goroutine不可被垃圾收集，只能必须靠自己exit。&lt;/p&gt;
&lt;p&gt;所以，我们需要找到方式，能够在下游阶段接收所有导入值失败的时候，上游阶段的管道仍旧能够退出：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一种方式是改变导出通道让它又有一个buffer缓冲区，一个缓冲区能够持有一个固定数量的值，如果缓冲区内仍有空间，发送操作就立即完成。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缓冲区的内容我们在&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/go.html#channel%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%A6%82%E5%BF%B5&quot;&gt;前面的文章&lt;/a&gt;中有仔细介绍。&lt;/p&gt;
&lt;p&gt;总之就是可以释放goroutine的发送操作到缓冲区，不会被无限期阻塞。&lt;/p&gt;
&lt;p&gt;在我们的管道中，返回到被阻塞的goroutine，我们可能考虑到添加一个缓冲区到merge函数返回的导出通道：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;out := make(chan int, 1)// 增加一个缓冲区，可以存放通道中未发送的值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是问题仍在发生，我们这里是因为知道我们上面只写了一遍发送，而通道已知有两次接收值，所以我们可以这么干，但是这个代码是不好的，易碎的，一旦条件发生改变，就要对代码进行调整。&lt;/p&gt;
&lt;p&gt;因此，我们需要为下游阶段提供一种方式来象征发送者，来停止接收输入。&lt;/p&gt;
&lt;h3 id=&quot;明确的取消机制&quot;&gt;明确的取消机制&lt;/h3&gt;
&lt;p&gt;当main函数决定退出，而不再接收任何out通道的值的时候，它必须告诉上游的goroutine，放弃他们试图发送的值。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在一个通道中如此操作发送值，被称作done。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它发送两个值因为有两个潜在的阻塞发送者。&lt;/p&gt;
&lt;p&gt;我们修改merge，给它加入一个参数是struct{}结构体通道。然后修改merge中的output函数，将原来的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;out &amp;lt;- n:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;替换为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select {
case out &amp;lt;- n:
case &amp;lt;-done:
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;意思是：如果n还有未发送的值，就正常发送，如果done有未发送的值就发送done。然后我们再修改一下main函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;done := make(chan struct{}, 2)
out := merge(done, c1, c2)
fmt.Println(&amp;lt;-out)
done &amp;lt;- struct{}{}
done &amp;lt;- struct{}{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当out只被输出一次的时候，此时循环还剩两次（总共三次，因为merge函数的参数有三个通道，会循环三次），为了避免循环阻塞在out输出的位置，我们给done通道传入了结构体零值，merge函数中那个循环就会放弃发送out值，而去执行done的发送。&lt;/p&gt;
&lt;p&gt;但是问题仍在继续，这里仍旧是因为我们预知通道接收次数，以及发送放空次数，所以可以写出这个顺序和次数，这仍旧是易碎的，本质上除了让我们学习了一下这种写法，与上面发生的无异。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们需要一种方式，可以在未知goroutine数量，未知通道大小的情况下，随时按需阻止下游阶段发送未发送完毕的通道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为接收操作在一个封闭的通道可以总是立即执行，产生类元素的零值。&lt;/p&gt;
&lt;p&gt;这就意味着main函数能够对所有被done通道关闭的发送者解除阻塞。这实际上是一个广播信号发送者。我们扩展管道功能的each来接收done作为一个参数来安排通过defer来延迟关闭，以便所有的main函数的返回路径能够发送信号到管道阶段去退出。&lt;/p&gt;
&lt;p&gt;先看merge函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;defer wg.Done()
for n := range c {
    select {
    case out &amp;lt;- n:
    case &amp;lt;-done:
        return
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在for循环前面加入了一行sync.WaitGroup的Done的延迟方法，然后修改了select内部当done可被输出时，直接结束merge函数（更别提跳出循环了），直接执行defer的wg.Done去掉一次计数器数值。然后看main函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    done := make(chan struct{})
    defer close(done)
    in := pipeline.Gen(2, 3)
    c1 := pipeline.Sq(in)
    c2 := pipeline.Sq(in)
    out := merge(done, c1, c2)
    fmt.Println(&amp;lt;-out)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们去掉了done通道的缓冲区，加了一行关闭done通道的延迟操作。当代码执行玩fmt的一次输出以后，main函数执行完毕，会调用defer关闭done通道，回到merge函数中，done通道被关闭以后，&lt;em&gt;case -&amp;gt;done被执行&lt;/em&gt;merge函数执行完毕，执行wg.Done()。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文详细阐述了Go管道的概念，是有三组动作：生产通道，处理通道，使用通道，这三组动作实现了Go的管道。通过一个例子我们搞清楚了管道的含义，接着又介绍了Fan-out，是关于多个函数对同一个通道的操作，以及一个函数对多个通道的操作（例子中使用了merge，将多个通道合并为一个）。这期间，我们研究了sync.WaitGroup以及Go语言中的包引用特性。最后，我们在例子中发现了管道并发的问题，并循序渐进地找到了解决方法，在此期间，让我们加深了对defer，管道，通道，select的理解。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Go官方文档&lt;/li&gt;
&lt;/ul&gt;

</description>
<pubDate>Fri, 19 Jan 2018 11:02:00 +0000</pubDate>
<dc:creator>一面千人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Evsward/p/goPipeline.html</dc:identifier>
</item>
<item>
<title>物流一站式查询之顺丰接口篇 - 潇十一郎</title>
<link>http://www.cnblogs.com/zhangxiaoyong/p/8317229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxiaoyong/p/8317229.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;连载篇提前看&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/8229003.html&quot;&gt;物流一站式查询之TrackingMore篇&lt;/a&gt;&lt;/h3&gt;
&lt;h3 class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/8317229.html&quot;&gt;物流一站式查询之顺丰接口篇&lt;/a&gt;&lt;/h3&gt;
&lt;h3 class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/8317251.html&quot;&gt;物流一站式查询之快递100篇&lt;/a&gt;&lt;/h3&gt;
&lt;h2&gt;&lt;strong&gt;前情提要&lt;br/&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本篇内容承接上篇《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/8229003.html&quot;&gt;物流包裹一站式查询（TrackingMore）&lt;/a&gt; 文末所说，顺丰物流关闭了对第三方的物流接口，导致众多第三方物流平台查询不到顺丰快递的物流信息。但是问题终归是要解决滴，别家不行，咱就直接用顺丰自家的。&lt;/p&gt;
&lt;p&gt;原本网上找顺丰物流信息查询发现&lt;a href=&quot;https://open.sf-express.com/&quot; target=&quot;_blank&quot;&gt;顺丰开放平台 &lt;/a&gt; 看了下介绍，因为也是顺丰的平台，也没多想，看到流程还是比较清晰的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/762349/201801/762349-20180119154226412-718304213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本来想找在线客服咨询下，结果发现在线客服有的只是一个群号，而且还不能加人了，于是乎就按照接入流程开始操作，本地都开发的差不多了，后来意外联系到一个顺丰的IT人员，通过他得知，顺丰物流信息接口已经转到另一个部门和平台操作了，这个开放平台已经几乎没有人维护了。于是再他的协助下，我得到了最新的对接文档。按找新文档，之前的开发的全部得重写，请求接口不一样，数据传输和接收方式不一样，由开放平台的Json格式到现在用XML传输。这里贴一下接入规范文档的目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/762349/201801/762349-20180119154943240-483775484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顺便提一下 顺丰路由查询接口 就是 查询物流信息的接口，不过再顺丰平台使用此接口有个前提条件，就是必须是顺丰的月结用户。登陆 &lt;a href=&quot;https://i.sf-express.com/new/cn/sc/user/login.html%20&quot; target=&quot;_blank&quot;&gt;顺丰平台&lt;/a&gt; 可以查看到基本信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/762349/201801/762349-20180119155702146-1172462260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注：①不是顺丰月结卡 用户 或者企业，不能接入路由查询   ② 不是通过顺丰接口下单的运单号，不能接入路由推送接口，换而言之，如果是通过顺丰大客户发货系统或者其他方式进行的打单获取到的快递单号，无法对此单进行订阅推送操作。&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;开发篇&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;看完基本流程和接入规范之后，就可以按照文档规范进行编码。因为目前我只用到了标红的三个接口，所以接下来对这三个接口一一讲解。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;下单接口&lt;/strong&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;h2&gt;1.1. 功能描述&lt;/h2&gt;
&lt;p&gt;下订单接口根据客户需要，可提供以下三个功能：&lt;/p&gt;
&lt;p&gt;1)      客户系统向顺丰下发订单。&lt;/p&gt;
&lt;p&gt;2)      为订单分配运单号。&lt;/p&gt;
&lt;p&gt;3)      筛单（可选，具体商务沟通中双方约定，由顺丰内部为客户配置）。&lt;/p&gt;
&lt;p&gt;此接口也用于路由推送注册。客户的顺丰运单号不是通过此下订单接口获取，但却需要获取BSP的路由推送时，需要通过此接口对相应的顺丰运单进行注册以使用BSP的路由推送接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照接入文档所说 接口通信协议支持WEBSERVICE及HTTP/POST协议，以下我是采用HTTP/POST协议 开发&lt;/p&gt;
&lt;p&gt;其中 密匙生成规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先把XML报文与checkword前后连接。&lt;/li&gt;
&lt;li&gt;把连接后的字符串做MD5编码。&lt;/li&gt;
&lt;li&gt;把MD5编码后的数据进行Base64编码，此时编码后的字符串即为校验码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/762349/201801/762349-20180119160646553-901046857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;元素的请求和响应内容字段和描述比较多，这里就不一一贴出来了，文末会提供接口文档下载地址。&lt;/p&gt;
&lt;p&gt;① 编写下单操作实体类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2d396ce0-ca85-4a3e-a966-21374501be42')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_2d396ce0-ca85-4a3e-a966-21374501be42&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2d396ce0-ca85-4a3e-a966-21374501be42&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2d396ce0-ca85-4a3e-a966-21374501be42',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2d396ce0-ca85-4a3e-a966-21374501be42&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#region&lt;/span&gt; 下单操作实体

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderService
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     订单号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; orderid { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     运单号 顺丰运单号，一个订单只能有一个母单号，如果是子母单的情况，以半角逗号分隔，主单号在第一个位置，如 “755123456789,001123456789,002123456789” ，
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;     对于路由推送注册，此字段为必填。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; mailno { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     寄件方公司名称，如果需要 生成电子运单，则为必填。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; j_company { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     寄件方联系人，如果需要生成电子运单，则为必填。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; j_contact { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     寄件方联系电话，如果需要生成电子运单，则为必填。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; j_tel { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     寄件方手机
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; j_mobile { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     寄件方详细地址
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; j_address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     到件方公司名称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; d_company { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     收件方联系人
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; d_contact { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     收件人联系电话
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; d_tel { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     收件人手机
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; d_mobile { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     收件人详细地址
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; d_address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     包裹数(1个包裹对应一个运单号)
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; parcel_quantity { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     快件产品类别（只有再商务上与顺丰约定的类别方可使用）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; express_type { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     顺丰月结卡号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; custid { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     备注
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; remark { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     订单元素
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; OrderCargo OrderCargos { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderCargo
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     货物名称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;② 定义三个全局属性，因为再几个请求我们都会使用到这三个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开发环境URL(文档中有提供)&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Posturl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://bsp-ois.sit.sf-express.com:9080/bsp-ois/sfexpressService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开发环境编码(文档中有提供)&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Bianma = &lt;span&gt;&quot;&quot;&lt;/span&gt; + ConfigHelper.GetKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bianma&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开发环境密匙(文档中有提供)&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Checkword = &lt;span&gt;&quot;&quot;&lt;/span&gt; + ConfigHelper.GetKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;checkword&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 下单操作方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 下单操作方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;model&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;下单操作实体&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetHttpBack(OrderService model)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到下单XML请求体&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; xml =&lt;span&gt; Getxml(model);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成密匙&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; pass = Convert.ToBase64String(MD5(xml +&lt;span&gt; Checkword));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下单请求&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; str = GethttpBack(Posturl, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xml=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + xml + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;verifyCode=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; pass);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下单XML请求体如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4d74e99f-7c52-4bdd-b5a5-d3034c236038')&quot; readability=&quot;43.5&quot;&gt;&lt;img id=&quot;code_img_closed_4d74e99f-7c52-4bdd-b5a5-d3034c236038&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4d74e99f-7c52-4bdd-b5a5-d3034c236038&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4d74e99f-7c52-4bdd-b5a5-d3034c236038',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4d74e99f-7c52-4bdd-b5a5-d3034c236038&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构建下单XML请求体
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;model&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;下单操作实体&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Getxml(OrderService model)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] xmls =&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;Request service='OrderService' lang='zh-CN'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;Head&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + ConfigHelper.GetKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bianma&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Head&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;Body&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;Order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orderid='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.orderid + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;j_company='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.j_company + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;j_contact='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.j_contact + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;j_tel='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.j_tel + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;j_mobile='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.j_mobile + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;j_address='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.j_address + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d_company='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.d_company + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d_contact='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.d_contact + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d_tel='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.d_tel + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d_mobile='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.d_mobile + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d_address='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.d_address + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parcel_quantity='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.parcel_quantity + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;express_type='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.express_type + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;custid='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.custid + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;remark='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.remark + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;Cargo name='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.OrderCargos.name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&amp;gt;&amp;lt;/Cargo&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Order&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Body&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Request&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xml = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xmls)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xml == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
                    xml &lt;/span&gt;=&lt;span&gt; s;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    xml &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; s;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; xml;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;MD5编码方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] MD5(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; Encoding.UTF8.GetBytes(str);
            MD5 md5 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MD5CryptoServiceProvider();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; output =&lt;span&gt; md5.ComputeHash(result);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; output;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下单请求方法如下&lt;/p&gt;
&lt;p&gt;因为下单成功会返回订单号和运单号 以及筛单结果，所以我们先定义一个返回的响应报文模型容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('973ffeb5-0748-4da3-8594-73fff0a5aa97')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_973ffeb5-0748-4da3-8594-73fff0a5aa97&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_973ffeb5-0748-4da3-8594-73fff0a5aa97&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('973ffeb5-0748-4da3-8594-73fff0a5aa97',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_973ffeb5-0748-4da3-8594-73fff0a5aa97&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SfOrderResponse
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     订单号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; orderid { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     运单号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; mailno { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     筛单结果 1 人工确认 2 可收派 3 不可以收派
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; filter_result { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8f90e507-de61-4112-8383-6a94a79403c9')&quot; readability=&quot;43.5&quot;&gt;&lt;img id=&quot;code_img_closed_8f90e507-de61-4112-8383-6a94a79403c9&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8f90e507-de61-4112-8383-6a94a79403c9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8f90e507-de61-4112-8383-6a94a79403c9',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8f90e507-de61-4112-8383-6a94a79403c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GethttpBack(&lt;span&gt;string&lt;/span&gt; add, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; post)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; we = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebClient();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sMessage = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 下单
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                SfOrderResponse sfresponse;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (post != &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编码，尤其是汉字，事先要看下抓取网页的编码方式&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; postData =&lt;span&gt; Encoding.UTF8.GetBytes(post);
                    we.Headers.Clear();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;采取POST方式必须加的header，如果改为GET方式的话就去掉这句话即可&lt;/span&gt;
                    we.Headers.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    sMessage &lt;/span&gt;= Encoding.UTF8.GetString(we.UploadData(add, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, postData));
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取XML资源中的指定节点内容&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (Convert.ToString(GetNodeValue(sMessage, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Head&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        sMessage &lt;/span&gt;=&lt;span&gt; XElement.Parse(sMessage).Value;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        sfresponse &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SfOrderResponse
                        {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取xml中orderid、mailno、destcode等节点值&lt;/span&gt;
                            orderid = GetXmlNodeValue(sMessage, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderResponse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orderid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                            mailno &lt;/span&gt;= GetXmlNodeValue(sMessage, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderResponse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mailno&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                            filter_result &lt;/span&gt;= GetXmlNodeValue(sMessage, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderResponse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filter_result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        };
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    sMessage &lt;/span&gt;=&lt;span&gt; Encoding.UTF8.GetString(we.DownloadData(add));
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Convert.ToString(GetNodeValue(sMessage, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Head&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        sMessage &lt;/span&gt;=&lt;span&gt; XElement.Parse(sMessage).Value;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        sfresponse &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SfOrderResponse
                        {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取xml中orderid、mailno、destcode等节点值&lt;/span&gt;
                            orderid = GetXmlNodeValue(sMessage, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderResponse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orderid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                            mailno &lt;/span&gt;= GetXmlNodeValue(sMessage, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderResponse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mailno&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                            filter_result &lt;/span&gt;= GetXmlNodeValue(sMessage, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderResponse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;destcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        };
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sMessage.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;gt; &lt;span&gt;0&lt;/span&gt;) sMessage = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP未授权&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放资源&lt;/span&gt;
&lt;span&gt;            we.Dispose();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sMessage;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中读取XML资源中指定节点内容的方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1d25c725-b8a4-4255-8c1f-5ed2abd4de1f')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_1d25c725-b8a4-4255-8c1f-5ed2abd4de1f&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1d25c725-b8a4-4255-8c1f-5ed2abd4de1f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1d25c725-b8a4-4255-8c1f-5ed2abd4de1f',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1d25c725-b8a4-4255-8c1f-5ed2abd4de1f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     读取XML资源中的指定节点内容
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;source&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;XML资源&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;nodeName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;节点名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;节点内容&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; GetNodeValue(&lt;span&gt;string&lt;/span&gt; source, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; nodeName)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt; || nodeName == &lt;span&gt;null&lt;/span&gt; || source == &lt;span&gt;&quot;&quot;&lt;/span&gt; || nodeName == &lt;span&gt;&quot;&quot;&lt;/span&gt; ||&lt;span&gt;
                source.Length &lt;/span&gt;&amp;lt; nodeName.Length * &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; start = source.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + nodeName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + nodeName.Length + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; end = source.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + nodeName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (start == -&lt;span&gt;1&lt;/span&gt; || end == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (start &amp;gt;=&lt;span&gt; end)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; source.Substring(start, end -&lt;span&gt; start);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;获取XML任意节点中某个属性值的方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0d9f129c-9232-46d6-919f-fad409b35c91')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_0d9f129c-9232-46d6-919f-fad409b35c91&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0d9f129c-9232-46d6-919f-fad409b35c91&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0d9f129c-9232-46d6-919f-fad409b35c91',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0d9f129c-9232-46d6-919f-fad409b35c91&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  获取xml任意节点中某个属性值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;strXml&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;strNodeName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;节点名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;strValueName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;属性名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetXmlNodeValue(&lt;span&gt;string&lt;/span&gt; strXml, &lt;span&gt;string&lt;/span&gt; strNodeName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; strValueName)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xmlDoc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlDocument();
                xmlDoc.LoadXml(strXml);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xNode = xmlDoc.SelectSingleNode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + strNodeName + &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; strValue =&lt;span&gt; xNode.Attributes[strValueName].Value;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; strValue;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ex.Message;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这样我们就大概写完了下单的请求逻辑代码，现在我们可以写一条测试数据进行测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
   SfExpress.GetHttpBack(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderService()
            {
                orderid &lt;/span&gt;= ConfigHelper.GetKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orderID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                j_company &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;深圳市*******有限公司&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                j_contact &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;潇十一郎&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                j_mobile &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                j_address &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是发货地址&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                d_company &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收件公司名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                d_contact &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收件人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                d_tel &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;13237157517&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                d_mobile &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;78946561&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                d_address &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收货地址&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                parcel_quantity &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                express_type &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                custid &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9999999999&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                remark &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;下单测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                OrderCargos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; OrderCargo() { name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;显示屏&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请求过程全过程如下(若每个订单号只能下单一次，若重复下单则会返回Err 重复下单，下面演示中，第一次演示的是重复下单，后来修改了订单号重新跑了一次，就返回了OK,顺利拿到了运单号)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/762349/201801/762349-20180119170855131-636412040.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;路由查询&lt;/h3&gt;
&lt;p&gt;有了上一个下单作为铺垫，那我们路由查询就比较好处理了。&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;h2&gt;1.1. 功能描述&lt;/h2&gt;
&lt;p&gt;客户可通过此接口查询顺丰运单路由，BSP会在响应XML报文返回当时点要求的全部路由节点信息。&lt;/p&gt;
&lt;p&gt;此路由查询接口支持两类查询方式：&lt;/p&gt;
&lt;p&gt;1)      根据顺丰运单号查询：查询请求中提供接入编码与运单号，BSP将验证接入编码与所有请求运单号的归属关系，系统只返回具有正确归属关系的运单路由信息。&lt;/p&gt;
&lt;p&gt;2)      根据客户订单号查询：查询请求中提供接入编码与订单号，BSP将验证接入编码与所有请求订单号的归属关系，对于归属关系正确的订单号，找到对应的运单号，然后返回订单对应运单号的路由信息。适用于通过BSP下单的客户订单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;①编写请求对应的模型容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7b7e59c7-24b1-41ee-a400-545bebeaaa0b')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7b7e59c7-24b1-41ee-a400-545bebeaaa0b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7b7e59c7-24b1-41ee-a400-545bebeaaa0b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7b7e59c7-24b1-41ee-a400-545bebeaaa0b',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7b7e59c7-24b1-41ee-a400-545bebeaaa0b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     路由请求实体
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RotueSehachService
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     查询号类别 1运单号查询  2 订单号查询
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tracking_type { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     查询号 tracking_type=1 则此值是运单号 tracking_type为1=2 此值是订单号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; tracking_number { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     1 标准路由查询 2定制路由查询
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; method_type { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;②根据响应报文编写对应模型容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RouteResponse
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; mailno { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Route Route { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; failMessage { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Route
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; accept_time { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; accept_address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; remark { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; opcode { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③路由查询&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;RouteResponse&amp;gt;&lt;span&gt; GetHttpRotueSheach(RotueSehachService model)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回路由查询XML请求体&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; xml =&lt;span&gt; GetRoutexml(model);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MD5编码&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; pass = Convert.ToBase64String(MD5(xml +&lt;span&gt; Checkword));
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; strData = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xml=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + xml + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;verifyCode=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; pass;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = GetRouteack(Posturl, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xml=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + xml + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;verifyCode=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; pass);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，构建查询XML请求体方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('09ce8192-cc5f-4f55-a3a8-a094fe4c22a3')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_09ce8192-cc5f-4f55-a3a8-a094fe4c22a3&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_09ce8192-cc5f-4f55-a3a8-a094fe4c22a3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('09ce8192-cc5f-4f55-a3a8-a094fe4c22a3',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_09ce8192-cc5f-4f55-a3a8-a094fe4c22a3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构建路由查询XML请求体
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;model&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;路由查询请求模型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetRoutexml(RotueSehachService model)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] xmls =&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;Request service='RouteService' lang='zh-CN'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;Head&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + ConfigHelper.GetKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bianma&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Head&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;Body&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;RouteRequest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tracking_type='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.tracking_type + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;method_type='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.method_type + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tracking_number='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.tracking_number + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Body&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Request&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xml = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xmls)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xml == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
                    xml &lt;/span&gt;=&lt;span&gt; s;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    xml &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; s;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; xml;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;MD5方法下单请求中已经贴出，其中GetRouteack请求方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6c517d73-0dd2-45ca-95b6-29abb164715e')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_6c517d73-0dd2-45ca-95b6-29abb164715e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6c517d73-0dd2-45ca-95b6-29abb164715e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6c517d73-0dd2-45ca-95b6-29abb164715e',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6c517d73-0dd2-45ca-95b6-29abb164715e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 路由查询
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;add&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;URL地址&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;post&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;编码后的请求体&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;RouteResponse&amp;gt; GetRouteack(&lt;span&gt;string&lt;/span&gt; add, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; post)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebClient();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sXml = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rutoelist = &lt;span&gt;new&lt;/span&gt; List&amp;lt;RouteResponse&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编码，尤其是汉字，事先要看下抓取网页的编码方式&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; postData =&lt;span&gt; Encoding.UTF8.GetBytes(post);
                client.Headers.Clear();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;采取POST方式必须加的header，如果改为GET方式的话就去掉这句话即可&lt;/span&gt;
                client.Headers.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sXml = Encoding.UTF8.GetString(client.UploadData(add, &quot;POST&quot;, postData));&lt;/span&gt;
                sXml =
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;?xml version='1.0' encoding='UTF-8'?&amp;gt;&amp;lt;Response service='RouteService'&amp;gt;&amp;lt;Head&amp;gt;OK&amp;lt;/Head&amp;gt;&amp;lt;Body&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;RouteResponse mailno='444032636081'&amp;gt;&amp;lt;Route remark='顺丰速运 已达到武汉航空总站' accept_time='2018-01-19 06:50:55' accept_address='武汉市' opcode='50'/&amp;gt;&amp;lt;/RouteResponse&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;RouteResponse mailno='444032636081'&amp;gt;&amp;lt;Route remark='顺丰速运 快递正在发往武汉航空总站' accept_time='2018-01-18 18:18:55' accept_address='深圳市' opcode='50'/&amp;gt;&amp;lt;/RouteResponse&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;RouteResponse mailno='444032636081'&amp;gt;&amp;lt;Route remark='顺丰速运 快递达到深圳中转站' accept_time='2018-01-18 15:12:55' accept_address='深圳市' opcode='50'/&amp;gt;&amp;lt;/RouteResponse&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;RouteResponse mailno='444032636081'&amp;gt;&amp;lt;Route remark='顺丰速运 已收取快件' accept_time='2018-01-18 10:10:55' accept_address='深圳市' opcode='50'/&amp;gt;&amp;lt;/RouteResponse&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Body&amp;gt;&amp;lt;/Response&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断返回响应体是否是ERR&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (Convert.ToString(GetNodeValue(sXml, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Head&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    sXml &lt;/span&gt;=&lt;span&gt; XElement.Parse(sXml).Value;
                    rutoelist.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RouteResponse {failMessage =&lt;span&gt; XElement.Parse(sXml).Value});
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将xml字符串转换为XML文档&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; xmlDoc =&lt;span&gt; XDocument.Parse(sXml);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 文档中子代元素 RouteResponse 的所有集合&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; nodelist = xmlDoc.Descendants(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteResponse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nodelist != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取源集合中每个元素和子元素的集合&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; pieceareas =&lt;span&gt; nodelist.Elements();
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pieceareas)
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环添加到路由响应容器集合中&lt;/span&gt;
                        rutoelist.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RouteResponse
                        {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取XML mailno 属性值&lt;/span&gt;
                            mailno = GetXmlNodeValue(sXml, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteResponse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mailno&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                            Route &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Route
                            {
                                opcode &lt;/span&gt;= item.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;opcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value,
                                accept_address &lt;/span&gt;= item.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept_address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value,
                                accept_time &lt;/span&gt;= item.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept_time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value,
                                remark &lt;/span&gt;= item.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;remark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value
                            }
                        });
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                client.Dispose();
                rutoelist.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RouteResponse {failMessage =&lt;span&gt; XElement.Parse(sXml).Value});
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rutoelist;
            }

            client.Dispose();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rutoelist;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;因为开发测试环境，没有真实返回路由数据，所以我这里构造了几个返回数据，写到这里，我们路由查询的大部分逻辑已经完成，剩下就是调用和获取到路由返回集合，循环拼接输出我们想要的物流信息，具体操作可参考如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 　　　　　&lt;span&gt;#region&lt;/span&gt; 物流查询
            &lt;span&gt;var&lt;/span&gt; message = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺丰单独处理&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (companyNumber == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sf-express&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 获取顺丰物流信息
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先进行路由查询，若返回未下单则再进行下单操作。&lt;/span&gt;
                List&amp;lt;RouteResponse&amp;gt; result = SfExpress.GetHttpRotueSheach(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RotueSehachService()
                {
                    tracking_number &lt;/span&gt;= ConfigHelper.GetKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orderID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                });
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result.Count &amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环返回的路由集合&lt;/span&gt;
                    &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result)
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断错误信息不为空&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (item.failMessage == &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty)
                        {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将所有路由信息 按时间+路由地址拼接&lt;/span&gt;
                            message += item.Route.accept_time + &lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt; + item.Route.accept_address + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n &amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        {
                            message &lt;/span&gt;+= item.failMessage + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n &amp;lt;br/&amp;gt;  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Content(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;暂无物流信息,请稍后重试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }

            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请求全过程如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/762349/201801/762349-20180119180608553-84723130.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不知道大家留意看没，再请求成功后往集合里面添加了第一条数据后，我返到上面查看了下收到的数据，有一个opcode=50 的，顺便说下，这个opcode是返回的路由操作码，顺丰有个专门的文档记录这些返回操作码，那现在问题就来了，只是返回这个操作码，我们并不能马上知道操作码对应的文字描述。拿到操作码去官方文档上一个一个对，也不是我们程序员的思维。所以，此时我们应该想办法解决，当我们收到这个请求码的时候，就自动获取它的描述，这样就一目了然，方便我们后面操作。&lt;/p&gt;

&lt;h3&gt;单独处理路由操作码&lt;/h3&gt;
&lt;p&gt;其实改起来也不麻烦，我们需要把之前定义的Route 模型稍微改下 让它继承我们定义的操作码和对应的操作码描述类即可 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Route: SfErrorEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; accept_time { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; accept_address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; remark { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  public string opcode { get; set; }&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在SfErrorEntity 中，我们再去处理操作码和文字描述的问题。首先我们需要找到操作码，操作码模样如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/762349/201801/762349-20180119180944178-800031105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们可以再项目中新建一个资源文件，名字叫SFcode.resx,然后添加资源我们选择添加文本文件叫 sfResourse&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/762349/201801/762349-20180119181107943-1195578234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们把文档中的操作码和文字描述 复制进去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/762349/201801/762349-20180119181255021-1537701645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后一步 就是编写SfErrorEntity 类如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('09960ec7-1aeb-4658-b25f-a6fd76225bc0')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_09960ec7-1aeb-4658-b25f-a6fd76225bc0&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_09960ec7-1aeb-4658-b25f-a6fd76225bc0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('09960ec7-1aeb-4658-b25f-a6fd76225bc0',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_09960ec7-1aeb-4658-b25f-a6fd76225bc0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SfErrorEntity
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 定义一个字典存放操作码和对应描述
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; _errorDic;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 定一个操作码集合
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; ErrList
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取时先判断字典中是否存在数据，若存在则直接返回&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (_errorDic != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; _errorDic.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _errorDic;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不存在，首先实例化当前操作字典&lt;/span&gt;
                _errorDic = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取资源文件中的文本文件 先按行分隔&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; temp = SFCode.sfResourse.Split(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[] {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}, StringSplitOptions.RemoveEmptyEntries);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到所有行，再按空格分隔&lt;/span&gt;
                &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt; temp.Select(m =&amp;gt; m.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)))
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将对应的操作码和描述添加到当前字典中&lt;/span&gt;
                    _errorDic.Add(&lt;span&gt;int&lt;/span&gt;.Parse(result[&lt;span&gt;0&lt;/span&gt;]), result[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _errorDic;
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 存放操作码描述
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ErrDescription { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 操作码
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _opcode;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Opcode
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _opcode; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入操作码时，就拿当前写入的值和操作码集合中的数据做比较，同时返回对应的操作码描述&lt;/span&gt;
                _opcode =&lt;span&gt; value;
                ErrDescription &lt;/span&gt;= ErrList.FirstOrDefault(m =&amp;gt; m.Key ==&lt;span&gt; value).Value;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;最后的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/762349/201801/762349-20180119182633646-1422917823.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;路由推送&lt;/h3&gt;
&lt;p&gt;上文中也提到过，只有是通过顺丰接口下的订单，才能走路由推送这个接口，还是先看一下关于路由推送的描述&lt;/p&gt;
&lt;blockquote readability=&quot;17.660804020101&quot;&gt;
&lt;p&gt;1.1. 功能描述&lt;/p&gt;
&lt;p&gt;该接口用于当路由信息生产后向客户主动推送要求的顺丰运单路由信息。推送方式为增量推送，对于同一个顺丰运单的同一个路由节点，不重复推送。&lt;/p&gt;
&lt;p&gt;客户需提供一个符合以下规范的HTTP URL，以接收BSP推送的信息。&lt;/p&gt;
&lt;p&gt;1)      请求方法为：“application/x-www-form-urlencoded; charset=UTF-8”。&lt;/p&gt;
&lt;p&gt;Key:content&lt;/p&gt;
&lt;p&gt;2)      信息以URL编码（字符集为UTF-8）的XML格式，通过HTTP POST方式推送给客户。&lt;/p&gt;
&lt;p&gt;3)      客户在接收到信息后，需要先对其进行URL解码，得到相应的XML。&lt;/p&gt;
&lt;p&gt;4)      在客户处理XML信息后，向BSP返回响应XML报文，响应XML报文结果只能为OK/ERR（参见&lt;a href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/8317229.html#_XML报文说明&quot;&gt;XML报文说明&lt;/a&gt;），BSP将重新推送此次交易的所有信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;路由推送整体和上面两个类似，这个路有推送返回更简单，只有OK，或者Err。操作代码如下&lt;/p&gt;
&lt;p&gt;①定义推送模型容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('920401ca-3819-4b5b-b07c-1dacbedd351b')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_920401ca-3819-4b5b-b07c-1dacbedd351b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_920401ca-3819-4b5b-b07c-1dacbedd351b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('920401ca-3819-4b5b-b07c-1dacbedd351b',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_920401ca-3819-4b5b-b07c-1dacbedd351b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     路由推送模型
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RoutePushService:SfErrorEntity
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     路由节点信息编号，每一个id 代表一条不同的路由节点信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     顺丰运单号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; mailno { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     客户订单号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; orderid { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     路由节点产生的时间，格式：YYYY-MM-DDHH24:MM:SS
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime acceptTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     路由节点发生的城市
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; acceptAddress { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;深圳&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     路由节点具体描述
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; remark { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上门收件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;     路由节点操作码
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; public string opCode { get; set; } = &quot;50&quot;;&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;#region&lt;/span&gt; 路由推送
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; RoutePushService(RoutePushService model)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xml =&lt;span&gt; GetPushxml(model);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pass = Convert.ToBase64String(MD5(xml +&lt;span&gt; Checkword));
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; strData = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xml=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + xml + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;verifyCode=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; pass;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; strHeaders = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type: application/x-www-form-urlencoded\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bytePost =&lt;span&gt; Encoding.UTF8.GetBytes(strData);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; byteHeaders =&lt;span&gt; Encoding.UTF8.GetBytes(strHeaders);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = GetPushBack(Posturl, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xml=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + xml + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;verifyCode=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; pass);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构建路由推送XML
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;model&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;推送容器&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPushxml(RoutePushService model)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] xmls =&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;Request service='RouteService' lang='zh-CN'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;Body&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;WaybillRoute&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.id + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mailno='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.mailno + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;acceptTime='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.acceptTime.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm:ss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;acceptAddress='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.acceptAddress + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;remark='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.remark + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;opCode='50'/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orderid='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + model.orderid + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Body&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Request&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xml = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xmls)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xml == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
                    xml &lt;/span&gt;=&lt;span&gt; s;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    xml &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; s;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; xml;
        }

       &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 推送
       &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;add&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;post&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetPushBack(&lt;span&gt;string&lt;/span&gt; add, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; post)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pusthclient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebClient();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sXml = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编码，尤其是汉字，事先要看下抓取网页的编码方式&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; postData =&lt;span&gt; Encoding.UTF8.GetBytes(post);
                pusthclient.Headers.Clear();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;采取POST方式必须加的header，如果改为GET方式的话就去掉这句话即可&lt;/span&gt;
                pusthclient.Headers.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                sXml &lt;/span&gt;= Encoding.UTF8.GetString(pusthclient.UploadData(add, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, postData));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Head是否是ERR,若不是，直接返回OK&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (Convert.ToString(GetNodeValue(sXml, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Head&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    sXml &lt;/span&gt;=&lt;span&gt; XElement.Parse(sXml).Value;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    sXml &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                sXml &lt;/span&gt;=&lt;span&gt; e.Message;
            }
            pusthclient.Dispose();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sXml;
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个路由推送 ，可以写再服务里面，例如：客户下单了，是代发货状态，那么可以筛选出来，写一个服务，调用这个推送的接口，返回OK，则往数据库一个标示字段注明订阅成功，否则反。&lt;/p&gt;
&lt;p&gt;有了路由推送，然后就是回调了，推送成功之后，顺丰会根据当前物流单，若有物流信息发生改变，则会主动推向提前约定好的回调地址上，此时只需要再回调方法中做一些业务上的处理即可。&lt;/p&gt;

&lt;p&gt;关于顺丰接口大概就这么多。下一篇 关于快递100 物流接口详解。&lt;/p&gt;

</description>
<pubDate>Fri, 19 Jan 2018 10:38:00 +0000</pubDate>
<dc:creator>潇十一郎</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxiaoyong/p/8317229.html</dc:identifier>
</item>
<item>
<title>基于图像信息的搭配商品推荐 - 笨兔勿应</title>
<link>http://www.cnblogs.com/bentuwuying/p/8318267.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bentuwuying/p/8318267.html</guid>
<description>&lt;p&gt;《Learning Visual Clothing Style with Heterogeneous Dyadic Co-occurrences》论文阅读&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在推荐场景中，相似商品的i2i推荐一直是重要的基础数据，但只是推荐相似商品还是不够的，用户除了对相似商品的需求外还有对跨类目的搭配商品的需求。这篇文章介绍的就是基于商品图像的搭配推荐。&lt;/p&gt;
&lt;p&gt;本文的主要思想是通过学习一个feature transformation将商品的图像信息映射到latent space上，这个latent space就是用于表达搭配特性的。这个latent space即style space，即&lt;strong&gt;&lt;span&gt;本文的一个重要前提假设是将计算商品的搭配特性转化为计算商品的style信息，具有相同或相似style的商品是相互搭配的。&lt;/span&gt;&lt;/strong&gt;在这个style space上，搭配的商品即使不属于同一个类目，距离也很接近。&lt;/p&gt;
&lt;p&gt;1. feature transformation是使用的Siamese Convolutional Neural Network，training sample是搭配和不搭配的商品pair对。&lt;/p&gt;
&lt;p&gt;2. 对搭配特性建模的方式是使用了商品的co-occurrence信息，尤其是co-purchase信息。即&lt;strong&gt;&lt;span&gt;本文的另外一个重要假设：如果两个商品被用户同时购买（或者被同一个用户购买）的频率较高则说明他们搭配。即商品的共现信息决定了其在latent space上的分布情况。这是模型训练和评估时的主要思想。但这样做的主要问题在于数据的稀疏性和噪音。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3. 为了进行跨类目的搭配建模，sample时候的正样本pair对采样的是属于不同high-level categories的商品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Framework&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. input data包括商品的图像、类目、co-occurrence信息。&lt;/p&gt;
&lt;p&gt;2. 从input data中采样正样本，即不同类目下co-occurrence高的商品pair。&lt;/p&gt;
&lt;p&gt;3. 使用Siamese CNN去学习一个feature transformation将商品的图像信息映射到latent space上。&lt;/p&gt;
&lt;p&gt;4. 在预测时将商品图像transform到latent space上，找到nearest neighbors。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Related work&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要有两方面：&lt;/p&gt;
&lt;p&gt;1. CNN：Learning visual similarity for product design with convolutional neural networks&lt;/p&gt;
&lt;p&gt;2. Learning clothing style：Image-based Recommendations on Styles and Substitutes&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dataset&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用用户的行为数据，包括商品的图像、类目、co-occurrence信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;只使用了“衣服、鞋子、首饰”这三大类的商品。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;对商品的类目信息，选择high-level的，&lt;/span&gt;&lt;/strong&gt;优点一是high-level category是独立于style的，即避免类目划分过细时某些小类目跟style强相关对样本选择情况有影响；二是这样避免商品的类目变换较频繁。最后需要看一下类目的分布情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Generating the training set&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. training、validation、test data中的商品类目比例要成正比。&lt;/p&gt;
&lt;p&gt;2. negative sample随机采样，正负样本比例1：16。&lt;/p&gt;
&lt;p&gt;3. training data中的不同类目的商品数不能差距太大。&lt;/p&gt;
&lt;p&gt;4. strategy：CNN倾向于将图像相似的商品映射到相近的向量空间上，为了避免这个问题，强制使用不同high-level类目下的商品pair作为正样本，这样能够使得不同类目图像不相似但style相似的商品closer；负样本需要包含类目相同或不相同的pair，使得能够区分出那些类目相同图像相似但不属于相似style的商品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Training the Siamese network&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180119175417365-1415454230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180119175430303-888380935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Generating outfits&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在进行预测时，为了避免label noise，本文使用了一个robust nearest neighbor lookup method。&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180119175454256-1706966594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;即对于每个category，都聚类成若干个cluster，算最邻近时，先找最邻近的cluster center，再在这个cluster中找最邻近商品。&lt;/p&gt;

&lt;p&gt;最后，下图是一些style相似和不相似的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180119175507021-2098662577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 19 Jan 2018 09:58:00 +0000</pubDate>
<dc:creator>笨兔勿应</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bentuwuying/p/8318267.html</dc:identifier>
</item>
</channel>
</rss>