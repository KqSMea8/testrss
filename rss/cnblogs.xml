<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>OEMCC 13.2 集群版本安装部署 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9819091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9819091.html</guid>
<description>&lt;p&gt;之前测试部署过OEMCC 13.2单机，具体可参考之前随笔：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当时环境：&lt;/strong&gt;两台主机，系统RHEL 6.5，分别部署OMS和OMR：&lt;br/&gt;OMS，也就是OEMCC的服务端 IP：192.168.1.88 内存：12G+ 硬盘：100G+&lt;br/&gt;OMR，也就是OEM底层的资料库 IP：192.168.1.89 内存：8G+ 硬盘：100G+&lt;/p&gt;
&lt;p&gt;相当于OMS和OMR都是单机版，然后有些客户对监控系统的要求也很高，这就需要集群来提升高可用性。&lt;br/&gt;对于OMR来说，可以搭建对应版本的RAC来解决单点故障，那么对于OMS而言，又如何构建具备高可用性的集群呢？&lt;br/&gt;最近遇到某客户有这样的高可用需求，本文总结记录一下OEMCC集群版本的完整安装过程。&lt;/p&gt;

&lt;p&gt;客户要求部署OEMCC13.2集群，包括OMR的集群和OMS的集群，其中OMR的集群就是对应Oracle 12.1.0.2 RAC；OMS的集群要求Active-Active模式，并配合SLB实现负载均衡。&lt;/p&gt;

&lt;p&gt;使用两台虚拟机来实现部署。配置信息如下：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_pre-env-config.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要提前下载如下安装介质：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--oemcc13.2安装介质
em13200p1_linux64.bin
em13200p1_linux64-2.zip
em13200p1_linux64-3.zip
em13200p1_linux64-4.zip
em13200p1_linux64-5.zip
em13200p1_linux64-6.zip
em13200p1_linux64-7.zip
--oracle 12.1.0.2 RAC 安装介质：
p21419221_121020_Linux-x86-64_1of10.zip
p21419221_121020_Linux-x86-64_2of10.zip
p21419221_121020_Linux-x86-64_5of10.zip
p21419221_121020_Linux-x86-64_6of10.zip
--dbca针对oemcc13.2的建库模版：
12.1.0.2.0_Database_Template_for_EM13_2_0_0_0_Linux_x64.zip&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;OMR集群通过Oracle RAC来实现：OEMCC 13.2提供的模版，要求资料库（OMR）版本为12.1.0.2。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.1&quot;&gt;3.1 环境准备&lt;/h2&gt;
&lt;br/&gt;1) 配置yum源安装依赖rpm包：
&lt;pre&gt;
&lt;code&gt;yum install binutils compat-libcap1 compat-libstdc++-33 \
e2fsprogs e2fsprogs-libs glibc glibc-devel ksh libaio-devel libaio libgcc libstdc++ libstdc++-devel \
libxcb libX11 libXau libXi libXtst make \
net-tools nfs-utils smartmontools sysstat&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2) 各节点关闭防火墙、SELinux：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--各节点关闭防火墙:
service iptables stop
chkconfig iptables off

--各节点关闭SELinux:
getenforce
修改/etc/selinux/config SELINUX= disabled
--临时关闭SELinux
setenforce 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3) 配置 /etc/hosts文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#public ip
10.1.43.211 oemapp1
10.1.43.212 oemapp2
#virtual ip
10.1.43.208 oemapp1-vip
10.1.43.209 oemapp2-vip
#scan ip
10.1.43.210 oemapp-scan

#private ip
172.16.43.211 oemapp1-priv
172.16.43.212 oemapp2-priv&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4) 创建用户、组；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--创建group &amp;amp; user：
groupadd -g 54321 oinstall
groupadd -g 54322 dba
groupadd -g 54323 oper
groupadd -g 54324 backupdba
groupadd -g 54325 dgdba
groupadd -g 54326 kmdba  
groupadd -g 54327 asmdba  
groupadd -g 54328 asmoper  
groupadd -g 54329 asmadmin  
groupadd -g 54330 racdba  
  
useradd -u 54321 -g oinstall -G dba,asmdba,backupdba,dgdba,kmdba,racdba,oper oracle  
useradd -u 54322 -g oinstall -G asmadmin,asmdba,asmoper,dba grid  

--然后给oracle、grid设置密码：
passwd oracle 
passwd grid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5) 各节点创建安装目录(root用户)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /app/12.1.0.2/grid
mkdir -p /app/grid
mkdir -p /app/oracle
chown -R grid:oinstall /app
chown oracle:oinstall /app/oracle
chmod -R 775 /app&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6) 共享LUN规则配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi /etc/udev/rules.d/99-oracle-asmdevices.rules
KERNEL==&quot;sd*&quot;, BUS==&quot;scsi&quot;, PROGRAM==&quot;/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/$name&quot;, RESULT==&quot;36000c29ad39372db383c7903d31788d0&quot;, NAME=&quot;asm-data1&quot;, OWNER=&quot;grid&quot;, GROUP=&quot;asmadmin&quot;, MODE=&quot;0660&quot;
KERNEL==&quot;sd*&quot;, BUS==&quot;scsi&quot;, PROGRAM==&quot;/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/$name&quot;, RESULT==&quot;36000c298c085f4e57c1f9fcd7b3d1dbf&quot;, NAME=&quot;asm-data2&quot;, OWNER=&quot;grid&quot;, GROUP=&quot;asmadmin&quot;, MODE=&quot;0660&quot;
KERNEL==&quot;sd*&quot;, BUS==&quot;scsi&quot;, PROGRAM==&quot;/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/$name&quot;, RESULT==&quot;36000c290b495ab0b6c1b57536f4b3cf8&quot;, NAME=&quot;asm-ocr1&quot;, OWNER=&quot;grid&quot;, GROUP=&quot;asmadmin&quot;, MODE=&quot;0660&quot;
KERNEL==&quot;sd*&quot;, BUS==&quot;scsi&quot;, PROGRAM==&quot;/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/$name&quot;, RESULT==&quot;36000c29e7743dca47419aca041b88221&quot;, NAME=&quot;asm-ocr2&quot;, OWNER=&quot;grid&quot;, GROUP=&quot;asmadmin&quot;, MODE=&quot;0660&quot;
KERNEL==&quot;sd*&quot;, BUS==&quot;scsi&quot;, PROGRAM==&quot;/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/$name&quot;, RESULT==&quot;36000c29608a9ddb8b3168936d01a4f7b&quot;, NAME=&quot;asm-ocr3&quot;, OWNER=&quot;grid&quot;, GROUP=&quot;asmadmin&quot;, MODE=&quot;0660&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重载规则后确认共享LUN名称和权限属组：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@oemapp1 media]# udevadm control --reload-rules 
[root@oemapp1 media]# udevadm trigger
[root@oemapp1 media]# ls -l /dev/asm*
brw-rw----. 1 grid asmadmin 8, 16 Oct  9 12:27 /dev/asm-data1
brw-rw----. 1 grid asmadmin 8, 32 Oct  9 12:27 /dev/asm-data2
brw-rw----. 1 grid asmadmin 8, 48 Oct  9 12:27 /dev/asm-ocr1
brw-rw----. 1 grid asmadmin 8, 64 Oct  9 12:27 /dev/asm-ocr2
brw-rw----. 1 grid asmadmin 8, 80 Oct  9 12:27 /dev/asm-ocr3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7) 内核参数修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi /etc/sysctl.conf
# vi /etc/sysctl.conf  增加如下内容：
fs.file-max = 6815744  
kernel.sem = 250 32000 100 128  
kernel.shmmni = 4096  
kernel.shmall = 1073741824  
kernel.shmmax = 6597069766656
kernel.panic_on_oops = 1  
net.core.rmem_default = 262144  
net.core.rmem_max = 4194304  
net.core.wmem_default = 262144  
net.core.wmem_max = 1048576  
net.ipv4.conf.eth1.rp_filter = 2
net.ipv4.conf.eth0.rp_filter = 1  
fs.aio-max-nr = 1048576  
net.ipv4.ip_local_port_range = 9000 65500  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改生效：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# /sbin/sysctl –p&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8) 用户shell的限制：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi /etc/security/limits.conf
#在/etc/security/limits.conf 增加如下内容：
grid soft nproc 2047
grid hard nproc 16384
grid soft nofile 1024
grid hard nofile 65536
grid soft stack 10240
oracle soft nproc 2047
oracle hard nproc 16384
oracle soft nofile 1024
oracle hard nofile 65536
oracle soft stack 10240&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;9) 插入式认证模块配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi /etc/pam.d/login
--加载 pam_limits.so 模块
 使用 root 用户修改以下文件/etc/pam.d/login,增加如下内容：
session required pam_limits.so&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：limits.conf 文件实际是 Linux PAM（插入式认证模块，Pluggable Authentication Modules）中 pam_limits.so 的配置文件，而且只针对于单个会话。&lt;/p&gt;
&lt;p&gt;10) 各节点设置用户的环境变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--第1个节点grid用户：
export ORACLE_SID=+ASM1;
export ORACLE_BASE=/app/grid
export ORACLE_HOME=/app/12.1.0.2/grid; 
export PATH=$ORACLE_HOME/bin:$PATH;
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib; 
export CLASSPATH=$ORACLE_HOME/JRE:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib 

--第2个节点grid用户：
export ORACLE_SID=+ASM2;
export ORACLE_BASE=/app/grid
export ORACLE_HOME=/app/12.1.0.2/grid; 
export PATH=$ORACLE_HOME/bin:$PATH;
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib; 
export CLASSPATH=$ORACLE_HOME/JRE:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib;

--第1个节点oracle用户：
export ORACLE_SID=omr1; 
export ORACLE_BASE=/app/oracle;
export ORACLE_HOME=/app/oracle/product/12.1.0.2/db_1;
export ORACLE_HOSTNAME=;
export PATH=$ORACLE_HOME/bin:$PATH; 
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib; 
export CLASSPATH=$ORACLE_HOME/JRE:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib; 

--第2个节点oracle用户：
export ORACLE_SID=omr2; 
export ORACLE_BASE=/app/oracle;
export ORACLE_HOME=/app/oracle/product/12.1.0.2/db_1;
export ORACLE_HOSTNAME=;
export PATH=$ORACLE_HOME/bin:$PATH; 
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib; 
export CLASSPATH=$ORACLE_HOME/JRE:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3.2&quot;&gt;3.2 GI安装&lt;/h2&gt;
&lt;p&gt;解压安装介质：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unzip p21419221_121020_Linux-x86-64_5of10.zip
unzip p21419221_121020_Linux-x86-64_6of10.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置DISPLAY变量，调用图形界面安装GI：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[grid@oemapp1 grid]$ export DISPLAY=10.1.52.76:0.0
[grid@oemapp1 grid]$ ./runInstaller&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid05.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid06.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid07.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid08.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid09.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid10.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid11.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid12.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid13.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid14.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid15.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid16.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid17.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid18.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid19-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid19-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid19-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid20.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.3&quot;&gt;3.3 创建ASM磁盘组、ACFS集群文件系统&lt;/h2&gt;
&lt;p&gt;配置DISPLAY变量，调用图形界面创建ASM磁盘组、ACFS集群文件系统：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[grid@oemapp1 grid]$ export DISPLAY=10.1.52.76:0.0
[grid@oemapp1 grid]$ asmca&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建ASM磁盘组：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_asmca01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_asmca02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_asmca03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_asmca04.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建ACFS集群文件系统：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs05.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs06.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.4&quot;&gt;3.4 DB软件安装&lt;/h2&gt;
&lt;p&gt;解压安装介质：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unzip p21419221_121020_Linux-x86-64_1of10.zip
unzip p21419221_121020_Linux-x86-64_2of10.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置DISPLAY变量，调用图形界面安装DB软件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@oemapp1 database]$ export DISPLAY=10.1.52.76:0.0
[oracle@oemapp1 database]$ ./runInstaller&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装db软件：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db05.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db06.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db07.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db08.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db09.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db10.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db11-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db11-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db12.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.5&quot;&gt;3.5 DBCA使用模版建库&lt;/h2&gt;
&lt;p&gt;解压模版文件到模版目录下，之后dbca就可以从这些模版中选择使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@oemapp1 media]$ unzip 12.1.0.2.0_Database_Template_for_EM13_2_0_0_0_Linux_x64.zip -d /app/oracle/product/12.1.0.2/db_1/assistants/dbca/templates&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DBCA建库步骤：&lt;br/&gt;注意：数据库字符集强烈建议选择AL32UTF8，在后面配置OMS的时候会有对应提示。&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca05.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca06.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca07.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca08.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca09.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca10.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca11.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca12-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca12-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca13.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca14.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca15.PNG&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本次OMS的集群要求Active-Active模式，并配合SLB实现负载均衡。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4.1&quot;&gt;4.1 环境准备&lt;/h2&gt;
&lt;br/&gt;以下环境准备工作是对OMS的两个节点同步操作：&lt;br/&gt;oracle用户环境变量添加：
&lt;pre&gt;
&lt;code&gt;#OMS
export OMS_HOME=$ORACLE_BASE/oms_local/middleware
export AGENT_HOME=$ORACLE_BASE/oms_local/agent/agent_13.2.0.0.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;su - oracle
mkdir -p /app/oracle/oms_local/agent
mkdir -p /app/oracle/oms_local/middleware&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对/etc/hosts 修订，使符合oemcc对主机名称的要求（选做）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#public ip
10.1.43.211 oemapp1 oemapp1.oracle.com
10.1.43.212 oemapp2 oemapp2.oracle.com&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4.2&quot;&gt;4.2 安装主节点&lt;/h2&gt;
&lt;p&gt;开始安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;su - oracle
export DISPLAY=10.1.52.76:0.0
./em13200p1_linux64.bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装步骤：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc05.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc06.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc07.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc08.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc09.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc10.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc11.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc12-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc12-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc13-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc13-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc14.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4.3&quot;&gt;4.3 添加OMS节点&lt;/h2&gt;
&lt;p&gt;本节使用OEMCC来添加OMS节点，需要先添加agent，然后添加OMS节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;说明：
1./app/oracle/OMS是共享文件系统；
2./app/oracle/oms_local是各节点本地的文件系统；
3.OMR数据库的processes参数需要从默认300修改为600.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1) 添加agent&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent02-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent02-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent02-3.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent02-4.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent03-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent03-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent03-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent03-3.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_completed.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2) 添加OMS节点&lt;br/&gt;选择Enterprise menu -&amp;gt; Provisioning and Patching -&amp;gt; Procedure Library.&lt;br/&gt;找到Add Oracle Management Service，点击Launch。&lt;br/&gt;注意：OMS的相关端口，每个OMS节点尽可能保持一致，避免增加后续配置维护的复杂性。&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add02-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add02-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add02-3.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add03-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add03-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add03-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-3.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-4.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-5.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-6.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-7.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-8.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-9.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4.4&quot;&gt;4.4 测试OMS高可用性&lt;/h2&gt;
&lt;p&gt;分别使用节点1和节点2的IP地址均可以正常访问到OEMCC网页界面：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_211OK.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_212OK.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;且任意关掉某一节点，另外存活节点访问不受影响。&lt;br/&gt;附：操作oms启动／停止／查看状态的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--查看oms状态
$OMS_HOME/bin/emctl status oms
$OMS_HOME/bin/emctl status oms –details
--停止oms
$OMS_HOME/bin/emctl stop oms
$OMS_HOME/bin/emctl stop oms –all
--启动oms
$OMS_HOME/bin/emctl start oms&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;负载均衡使用的产品是radware，这部分需要负载均衡工程师进行配置。下面是根据Oracle官方文档结合本次需求整理出的配置要求，供参考：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_slb-config01.png&quot;/&gt;&lt;br/&gt;其他具体配置项，例如Monitors、Pools、Required Virtual Servers等都按此为基准结合官方文档进行规划设计即可，不再赘述。&lt;/p&gt;
&lt;p&gt;在/etc/hosts 添加负载均衡地址名称解析：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;10.1.44.207 myslb.oracle.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SLB配置后，OMS同步需要配置。&lt;/p&gt;
&lt;p&gt;配置OMS：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$OMS_HOME/bin/emctl secure oms -host myslb.oracle.com -secure_port 4903 -slb_port 4903 -slb_console_port 443 -slb_bip_https_port 5443 -slb_jvmd_https_port 7301 -lock_console -lock_upload&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置agent：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$AGENT_HOME/bin/emctl secure agent –emdWalletSrcUrl https://myslb.oracle.com:4903/em&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看oms状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@oemapp1 backup]$ $OMS_HOME/bin/emctl status oms -details
Oracle Enterprise Manager Cloud Control 13c Release 2  
Copyright (c) 1996, 2016 Oracle Corporation.  All rights reserved.
Enter Enterprise Manager Root (SYSMAN) Password : 
Console Server Host        : oemapp1.oracle.com
HTTP Console Port          : 7788
HTTPS Console Port         : 7802
HTTP Upload Port           : 4889
HTTPS Upload Port          : 4903
EM Instance Home           : /app/oracle/oms_local/gc_inst/em/EMGC_OMS1
OMS Log Directory Location : /app/oracle/oms_local/gc_inst/em/EMGC_OMS1/sysman/log
SLB or virtual hostname: myslb.oracle.com
HTTPS SLB Upload Port : 4903
HTTPS SLB Console Port : 443
HTTPS SLB JVMD Port : 7301
Agent Upload is locked.
OMS Console is locked.
Active CA ID: 1
Console URL: https://myslb.oracle.com:443/em
Upload URL: https://myslb.oracle.com:4903/empbs/upload

WLS Domain Information
Domain Name            : GCDomain
Admin Server Host      : oemapp1.oracle.com
Admin Server HTTPS Port: 7102
Admin Server is RUNNING

Oracle Management Server Information
Managed Server Instance Name: EMGC_OMS1
Oracle Management Server Instance Host: oemapp1.oracle.com
WebTier is Up
Oracle Management Server is Up
JVMD Engine is Up

BI Publisher Server Information
BI Publisher Managed Server Name: BIP
BI Publisher Server is Up

BI Publisher HTTP Managed Server Port   : 9701
BI Publisher HTTPS Managed Server Port  : 9803
BI Publisher HTTP OHS Port              : 9788
BI Publisher HTTPS OHS Port             : 9851
BI Publisher HTTPS SLB Port             : 5443
BI Publisher is locked.
BI Publisher Server named 'BIP' running at URL: https://myslb.oracle.com:5443/xmlpserver
BI Publisher Server Logs: /app/oracle/oms_local/gc_inst/user_projects/domains/GCDomain/servers/BIP/logs/
BI Publisher Log        : /app/oracle/oms_local/gc_inst/user_projects/domains/GCDomain/servers/BIP/logs/bipublisher/bipublisher.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看agent状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@oemapp1 backup]$ $AGENT_HOME/bin/emctl status agent
Oracle Enterprise Manager Cloud Control 13c Release 2  
Copyright (c) 1996, 2016 Oracle Corporation.  All rights reserved.
---------------------------------------------------------------
Agent Version          : 13.2.0.0.0
OMS Version            : 13.2.0.0.0
Protocol Version       : 12.1.0.1.0
Agent Home             : /app/oracle/oms_local/agent/agent_inst
Agent Log Directory    : /app/oracle/oms_local/agent/agent_inst/sysman/log
Agent Binaries         : /app/oracle/oms_local/agent/agent_13.2.0.0.0
Core JAR Location      : /app/oracle/oms_local/agent/agent_13.2.0.0.0/jlib
Agent Process ID       : 17263
Parent Process ID      : 17060
Agent URL              : https://oemapp1.oracle.com:3872/emd/main/
Local Agent URL in NAT : https://oemapp1.oracle.com:3872/emd/main/
Repository URL         : https://myslb.oracle.com:4903/empbs/upload
Started at             : 2018-10-12 15:49:58
Started by user        : oracle
Operating System       : Linux version 2.6.32-696.el6.x86_64 (amd64)
Number of Targets      : 34
Last Reload            : (none)
Last successful upload                       : 2018-10-12 15:50:53
Last attempted upload                        : 2018-10-12 15:50:53
Total Megabytes of XML files uploaded so far : 0.17
Number of XML files pending upload           : 19
Size of XML files pending upload(MB)         : 0.07
Available disk space on upload filesystem    : 63.80%
Collection Status                            : Collections enabled
Heartbeat Status                             : Ok
Last attempted heartbeat to OMS              : 2018-10-12 15:50:33
Last successful heartbeat to OMS             : 2018-10-12 15:50:33
Next scheduled heartbeat to OMS              : 2018-10-12 15:51:35

---------------------------------------------------------------
Agent is Running and Ready&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终测试，通过负载均衡地址10.1.44.207可以直接访问OEMCC，进行正常操作：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_all-complete.PNG&quot;/&gt;&lt;br/&gt;至此，OEMCC13.2集群安装已完成。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 14:51:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>之前测试部署过OEMCC 13.2单机，具体可参考之前随笔：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9819091.html</dc:identifier>
</item>
<item>
<title>借鉴Glide思想二次封装Fresco - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/9819009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/9819009.html</guid>
<description>&lt;p&gt;最近封装了个 Fresco 的组件库：&lt;a href=&quot;https://github.com/woshidasusu/base-module/tree/master/fresco&quot;&gt;DFresco&lt;/a&gt;，就顺便来讲讲。&lt;/p&gt;

&lt;p&gt;Fresco 图片库很强大，我们项目中就是使用的 Fresco，但有一点就是，不怎么好使用，略麻烦。不同项目中，多多少少都需要对 Fresco 进行一层封装才能在 ui 里快速使用。&lt;/p&gt;
&lt;p&gt;这就导致了，不同项目都根据自己的业务需求场景来进行封装，每次有新项目，复制粘贴时又得解决好多业务耦合的错误，麻烦，是真的麻烦~&lt;/p&gt;
&lt;p&gt;而且，首次接触 Fresco，接入上手的成本相比其他图片库，如 Glide，成本都要大很多。&lt;/p&gt;
&lt;p&gt;举个例子，假如你有这么个需求：加载一张网络上的 gif 图片，为了防止内存占用过多，需要设置分辨率压缩，最后显示到圆形控件上，同时，需要设置占位图，错误图，拉伸方式等。&lt;/p&gt;
&lt;p&gt;那么此时，你的代码可能就是这样的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ImageDecodeOptions imageDecodeOptions = ImageDecodeOptions.newBuilder()
        .setDecodePreviewFrame(true).build();
ImageRequestBuilder builder = ImageRequestBuilder.newBuilderWithSource(mUri)
        .setProgressiveRenderingEnabled(true)
        .setImageDecodeOptions(imageDecodeOptions);
if (mWidth &amp;gt; 0 &amp;amp;&amp;amp; mHeight &amp;gt; 0) {
    builder.setResizeOptions(new ResizeOptions(mWidth, mHeight));
}

ImageRequest request = builder.build();
AbstractDraweeController controller = Fresco.newDraweeControllerBuilder()
            .setImageRequest(request)
            .setControllerListener(listener)
            .setOldController(draweeView.getController())
            .setAutoPlayAnimations(true).build();
draweeView.setController(controller);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，你可能还需要在 xml 中对 SimpleDrawwView 控件进行占位图等等的配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;com.facebook.drawee.view.SimpleDraweeView
        android:id=&quot;@+id/sdv_fresco&quot;
        android:layout_width=&quot;500dp&quot;
        android:layout_height=&quot;500dp&quot;
        fresco:actualImageScaleType=&quot;centerCrop&quot;
        fresco:fadeDuration=&quot;3000&quot;
        fresco:failureImage=&quot;@mipmap/ic_launcher&quot;
        fresco:failureImageScaleType=&quot;centerCrop&quot;
        fresco:placeholderImage=&quot;@mipmap/ic_launcher&quot;
        fresco:placeholderImageScaleType=&quot;centerCrop&quot;
        fresco:progressBarAutoRotateInterval=&quot;1000&quot;
        fresco:progressBarImage=&quot;@drawable/ani_rotate&quot;
        fresco:progressBarImageScaleType=&quot;centerCrop&quot;
        fresco:retryImage=&quot;@mipmap/ic_launcher&quot;
        fresco:retryImageScaleType=&quot;centerCrop&quot;
        fresco:backgroundImage=&quot;@mipmap/ic_launcher&quot;
        fresco:overlayImage=&quot;@mipmap/ic_launcher&quot;
        fresco:pressedStateOverlayImage=&quot;@mipmap/ic_launcher&quot;
        fresco:roundAsCircle=&quot;false&quot;
        fresco:roundingBorderWidth=&quot;2dip&quot;
        fresco:roundingBorderColor=&quot;@color/colorPrimary&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果忘记了某个自定义属性名是什么的时候，还得到网上搜索下资料，是吧。&lt;/p&gt;
&lt;p&gt;小结一下，使用 Fresco，你的接入学习成本至少需要知道 Fresco 的如下信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SimpleDraweeView 的自定义属性&lt;/li&gt;
&lt;li&gt;ImageRequestBuilder 用法及大概用途&lt;/li&gt;
&lt;li&gt;AbstractDraweeController 用法及大概用途&lt;/li&gt;
&lt;li&gt;GenericDraweeHierarchy 用法及大概用途&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果涉及到一些网络下载监听，缓存之类的，那么你还要了解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Imagepipeline 用法及大概用途&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之，Fresco 强大是强大，但使用起来不方便，不得不封装一层。&lt;/p&gt;
&lt;p&gt;既然要封装，那么就直接借鉴 Glide 的使用思想来进行封装好了，如果有使用过 Glide 的应该很清楚，要实现以上功能，全程一个调用链即可。&lt;/p&gt;

&lt;p&gt;封装要达到的目的有两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用简洁、方便&lt;/li&gt;
&lt;li&gt;其他人接入直接上手的成本尽可能少，最好不用去看文档，去看源码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一点可以参考 Glide 的使用方式来设计，那么第二点我的想法是借助 AndroidStudio 的代码提示功能来实现。&lt;/p&gt;
&lt;p&gt;比如，你只需知道，组件的入口是 DFresco 即可，其他都通过 AndroidStudio 来给你提示，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a5f473375cac6cf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Dfresco入口.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当你在 AndroidStudio 上输入 &lt;code&gt;DFresco.&lt;/code&gt; 后，界面上会弹出你可用 api，这些就是我开放给你的入口，我将这个使用过程划分成几个步骤，每个步骤能做什么，该做什么，我都给你规定好了，你参照着提示，直接从方法命名上就能够知道该如何使用了，AndroidStudio 会一步步引导你。&lt;/p&gt;
&lt;p&gt;这里就两个入口，一个是用来初始化 Fresco 的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;init(Context)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个内部封装了一些默认的初始化配置，比如内存大小配置，内部日志配置等等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;init(Context, ImagePipelineConfig)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个是开放给你的自定义配置，如果你不想使用默认的配置的话。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;source(String url)&lt;/code&gt; ：加载网络上的图片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source(File localFile)&lt;/code&gt; ：加载磁盘上的图片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source(Context context, int resId)&lt;/code&gt; ：加载 res 内的 drawable 资源图片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source(Uri uri)&lt;/code&gt; ：通用的加载方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我将常用的几种图片来源单独封装出来使用，方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a0cfd99084357ca6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;DFresco第二步.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当调用了 &lt;code&gt;source()&lt;/code&gt; 后就进入了第二个步骤，这个步骤中，我将图片相关的配置设计到另外一个步骤中去，否则连同图片配置的 api 也都在这里的话，会搞得蛮乱的，可能让使用者到这里后不清楚该调用哪些接口了。&lt;/p&gt;
&lt;p&gt;所以，我会把控每个步骤的 api，尽量让每个步骤的 api 做的事都比较相近，比如这里：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;intoTarget(SimpleDraweeView)&lt;/code&gt; 加载图片显示到控件上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;intoTarget(SimpleDraweeView，ControllerListener)&lt;/code&gt; 加载图片显示到控件上，允许监听这个过程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;intoTarget(BaseBitmapDataSubscriber)&lt;/code&gt; 只加载图片到内存中，以 Bitmap 形式存在&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我的需求场景大概就是直接加载图片显示到控件上，或者有时候只是需要将图片加载到内存中，但不用显示到某个控件上，反而要取得图片的 Bitmap 对象，所以我将这些都封装起来了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;resize(int width, int height)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个实际上就是对 Fresco 中的 ResizeOptions 的一层封装而已，简化使用，不至于像以前那么麻烦。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;enterImageConfig()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你都使用默认配置的话，那么是不用再去调用那些各种配置的接口的，所以我才将图片配置封装到另外一个步骤中，这个步骤你可进，可不进，如果有需求，那么通过这个方法进入图片配置步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-849966a1a62a8598.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ImageConfig.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的配置项很多，也是因为这个原因，所以才不想让这些接口跟上一个步骤放一起，不然很容易让使用者懵掉。而进入了图片配置这个步骤后，这里提供的 api 其实就是对 GenericDraweeHierarchy 的用途进行了一层封装，或者说对 SimpleDraweeView 的自定义属性进行了一层封装。&lt;/p&gt;
&lt;p&gt;如果你不熟悉，没关系，其实就是一些常用的功能，如设置控件为圆形、圆角、边框，设置占位图、失败图、进度图、图片拉伸方式、淡入淡出动画时长等等。&lt;/p&gt;
&lt;p&gt;这样封装的目的在于，你可以通过一条调用链的形式就设置完所有的配置，就像 Glide 的使用一样，而不用再去 new 很多 Fresco 的类，再去拼接。&lt;/p&gt;
&lt;p&gt;进入图片配置步骤只是一个可选的步骤，进来之后当然就要出去，所以当完成了你的配置后，需要调用：&lt;code&gt;finishImageConfig()&lt;/code&gt;，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-1a196e6efa920365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;第三部.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就完成了图片配置，将流程切回主线了，就可以继续根据你的需要设置图片显示的目标了。&lt;/p&gt;
&lt;p&gt;当然，为了防止再次进入图片配置步骤这样造成之前的配置项失效的场景，我借鉴了 Fresco 的 &lt;code&gt;init&lt;/code&gt; 处理方法，即，如果一次使用过程中，重复进入图片配置步骤，那么程序会抛异常来提醒你不能这么做。&lt;/p&gt;
&lt;p&gt;以上，就是 DFresco 组件的封装思想，欢迎指点一下哈~&lt;/p&gt;
&lt;p&gt;另外，参考了 Glide 的一些处理，当你的 intoTarget 是传入了 SimpleDraweeView 控件时，DFresco 内部会自动根据控件的大小对图片进行一次分辨率压缩，降低图片占用内存，当然，如果你有手动调用了 &lt;code&gt;resize()&lt;/code&gt;，那么以你的为主。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;compile 'com.dasu.image:fresco:0.0.1'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用之前，需先初始化，建议在 Application 中进行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DFresco.init(this);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//加载 res 中的 drawable 图片到 SimpleDraweeView 控件上（默认支持 gif 图，并且会自动根据控件宽高进行分辨率压缩，降低内存占用
DFresco.source(mContext, R.drawable.weixin).intoTarget(mSimpleDraweeView);

//加载磁盘中的图片，手动设置分辨率的压缩，并获取 bitmap 对象，监听回调，手动显示到 ImageView 控件上
DFresco.source(new File(&quot;/mnt/sdcard/weixin.jpg&quot;))
        .resize(500, 500)
        .intoTarget(new BaseBitmapDataSubscriber() {
                @Override
                protected void onNewResultImpl(Bitmap bitmap) {
                    Log.w(&quot;!!!!!!&quot;, &quot;bitmap：ByteCount = &quot; + bitmap.getByteCount() + &quot;:::bitmap：AllocationByteCount = &quot; + bitmap.getAllocationByteCount());
                    Log.w(&quot;!!!!!!&quot;, &quot;width:&quot; + bitmap.getWidth() + &quot;:::height:&quot; + bitmap.getHeight());
                    mImageView.setImageBitmap(bitmap);
                }

                @Override
                protected void onFailureImpl(DataSource&amp;lt;CloseableReference&amp;lt;CloseableImage&amp;gt;&amp;gt; dataSource) {
                    Log.e(&quot;!!!!!!&quot;, &quot;onFailureImpl&quot;);
                }
            });

//加载网络图片，进行各种配置，如缩放方式，占位图，圆形，圆角，动画时长等等，最后自动显示到 SimpleDraweeView 控件上
DFresco.source(&quot;https://upload-images.jianshu.io/upload_images/1924341-9e528ee638e837a5.png&quot;)
                    .enterImageConfig() //进入配置步骤
                    .allFitXY()  //所有图片，包括占位图等等的拉伸方式
                    .animFade(3000) //淡入淡出动画时长
                    .placeholderScaleType(ScalingUtils.ScaleType.CENTER_INSIDE) //设置占位图的拉伸方式，后面设置的会覆盖前面的
                    .actualScaleType(ScalingUtils.ScaleType.CENTER)
//                    .asRound(50) //设置圆角，（圆角和圆形不能同时设置）
                    .asCircle() //设置控件显示为圆形控件
                    .roundBorderColor(Color.RED) //设置圆角或圆形的边框颜色
                    .roundBorderWidth(20)  //设置圆角或圆形的边框宽度
                    .failure(R.drawable.timg) //设置失败图
                    .progressBar(R.drawable.aaaa) //设置加载进度图
                    .retry(R.drawable.weixin) //设置重试时的图
                    .placeholder(R.drawable.image) //设置占位图
                    .finishImageConfig() //退出配置步骤
                    .intoTarget(mSimpleDraweeView);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/woshidasusu/base-module/tree/master/fresco&quot;&gt;DFresco：https://github.com/woshidasusu/base-module/tree/master/fresco&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 13:43:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<og:description>最近封装了个 Fresco 的组件库：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/9819009.html</dc:identifier>
</item>
<item>
<title>flex笔记 - 基础 - noobakong</title>
<link>http://www.cnblogs.com/noobakong/p/9818863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noobakong/p/9818863.html</guid>
<description>&lt;h2 id=&quot;flex笔记---基础&quot;&gt;flex笔记 - 基础&lt;/h2&gt;
&lt;p&gt;文章中的所有图示代码都放在了github上： &lt;a href=&quot;https://github.com/noobakong/notes/tree/master/02-CSS/01-Flex%E5%B8%83%E5%B1%80&quot;&gt;阮一峰flex博客跟学代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;传统的布局解决方案，基于&lt;strong&gt;盒模型&lt;/strong&gt;， 依赖 display, position, float属性来进行布局，有的时候很不方便，实现垂直居中就很不方便。&lt;/p&gt;
&lt;h3 id=&quot;一.-flex简介&quot;&gt;一. Flex简介&lt;/h3&gt;
&lt;p&gt;Flex 是 Flexible Box 的缩写，译为&lt;strong&gt;弹性布局&lt;/strong&gt;，用来为盒模型提供最大的灵活性。&lt;/p&gt;
&lt;p&gt;任何一个容器都可以使用 Flex 布局&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;元素设置为Flex布局后，子元素的 &lt;code&gt;float&lt;/code&gt;,&lt;code&gt;clear&lt;/code&gt;, &lt;code&gt;vertical-align&lt;/code&gt; 属性将失效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二.-基本概念&quot;&gt;二. 基本概念&lt;/h3&gt;
&lt;p&gt;采用Flex布局的元素，为Flex容器，它所有的子元素自动成为容器成员，成为Flex成员，（flex item）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png&quot; alt=&quot;Flex图解&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个flex布局存在两根轴，水平横轴，也叫主轴（即图中的 &lt;strong&gt;main axis&lt;/strong&gt;) 和 垂直纵轴 （&lt;strong&gt;cross axis&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;横轴的开始位置，也就是图中左边框上的点集合， 叫做&lt;code&gt;main start&lt;/code&gt;，结束位置，图中右边框的点集合，叫做&lt;code&gt;main end&lt;/code&gt;，垂直纵轴的开始位置（上边框的点）叫做&lt;code&gt;cross start&lt;/code&gt;，结束位置，下边框的点，叫做&lt;code&gt;cross end&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;每一个成员item的水平空间和垂直空间分别为 &lt;code&gt;main size&lt;/code&gt;和 &lt;code&gt;cross size&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;三.-容器属性&quot;&gt;三. 容器属性&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;接下来的展示demo github项目中的代码为了方便有些属性写在了item成员上，最正确的方式是些在flex容器上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;flex-direction&quot;&gt;1. flex-direction&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex-direction&lt;/code&gt;属性决定水平横轴的方向（即项目的排列方向）。&lt;/p&gt;
&lt;p&gt;它可取以下四个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;row&lt;/code&gt;（默认值）：主轴为水平方向，起点在左端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;row-reverse&lt;/code&gt;：主轴为水平方向，起点在右端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;column&lt;/code&gt;：主轴为垂直方向，起点在上沿。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;column-reverse&lt;/code&gt;：主轴为垂直方向，起点在下沿。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-flex-direction.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-wrap属性&quot;&gt;2. flex-wrap属性&lt;/h4&gt;
&lt;p&gt;默认情况下，项目都排在一条线（又称&quot;轴线&quot;）上。&lt;code&gt;flex-wrap&lt;/code&gt;属性定义，如果一条轴线排不下，如何换行。&lt;/p&gt;
&lt;p&gt;它可取三个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;nowrap&lt;/code&gt;（默认）：不换行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wrap&lt;/code&gt;：换行，第一行在上方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wrap-reverse&lt;/code&gt;：换行，第一行在下方&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如图我们可以发现，默认的nowrap属性的优先级是高于我们设置的width的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-flex-wrap.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-flow&quot;&gt;3. flex-flow&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex-flow&lt;/code&gt;属性是&lt;code&gt;flex-direction&lt;/code&gt;属性和&lt;code&gt;flex-wrap&lt;/code&gt;属性的简写形式，默认值为&lt;code&gt;row nowrap&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;justify-content属性&quot;&gt;4. justify-content属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;justify-content&lt;/code&gt;属性定义了项目在水平横轴上的对齐方式&lt;/p&gt;
&lt;p&gt;阮老师的博客图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;属性能取5个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;flex-start&lt;/code&gt;（默认值）：左对齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-end&lt;/code&gt;：右对齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;center&lt;/code&gt;： 居中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;space-between&lt;/code&gt;：两端对齐，项目之间的间隔都相等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;space-around&lt;/code&gt;：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-justify-content.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;align-items属性&quot;&gt;5. align-items属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;align-items&lt;/code&gt;属性定义项目在垂直纵轴上如何对齐。 和justify-content属性一块记忆比较容易。&lt;/p&gt;
&lt;p&gt;它可能取5个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;flex-start&lt;/code&gt;：交叉轴的起点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-end&lt;/code&gt;：交叉轴的终点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;center&lt;/code&gt;：交叉轴的中点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;baseline&lt;/code&gt;: 项目的第一行文字的基线对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stretch&lt;/code&gt;（默认值）：如果项目&lt;strong&gt;未设置高度&lt;/strong&gt;或设为auto，将占满整个容器的高度。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下图示例是的垂直纵轴方向是由上到下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-align-items.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;align-content属性&quot;&gt;6. align-content属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;align-content&lt;/code&gt;属性定义了多根轴线的对齐方式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;align-content&lt;/code&gt;只适用于&lt;strong&gt;多行&lt;/strong&gt; 的flex容器&lt;/p&gt;
&lt;p&gt;该属性可能取6个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;flex-start&lt;/code&gt;：与垂直轴的起点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-end&lt;/code&gt;：与垂直轴的终点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;center&lt;/code&gt;：与垂直轴的中点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;space-between&lt;/code&gt;：与垂直轴两端对齐，轴线之间的间隔平均分布。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;space-around&lt;/code&gt;：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stretch&lt;/code&gt;（默认值）：轴线占满整个垂直轴。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-align-content.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;四.-item成员的属性&quot;&gt;四. item成员的属性&lt;/h3&gt;
&lt;h4 id=&quot;order属性&quot;&gt;1. order属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;order&lt;/code&gt;属性定义项目的排列顺序。数值越小，排列越靠前，默认为0&lt;/p&gt;
&lt;h4 id=&quot;flex-grow属性&quot;&gt;2. flex-grow属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex-grow&lt;/code&gt;属性定义项目的放大比例，默认为&lt;code&gt;0&lt;/code&gt;，即如果存在剩余空间，也不放大。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果所有项目的&lt;code&gt;flex-grow&lt;/code&gt;属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的&lt;code&gt;flex-grow&lt;/code&gt;属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;flex-shrink属性&quot;&gt;3. flex-shrink属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex-shrink&lt;/code&gt;属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果所有项目的&lt;code&gt;flex-shrink&lt;/code&gt;属性都为1，当空间不足时，都将等比例缩小。如果一个项目的&lt;code&gt;flex-shrink&lt;/code&gt;属性为0，其他项目都为1，则空间不足时，前者不缩小。&lt;/p&gt;
&lt;p&gt;负值对该属性无效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;flex-basis属性&quot;&gt;4. flex-basis属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex-basis&lt;/code&gt;属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为&lt;code&gt;auto&lt;/code&gt;，即项目的本来大小。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;它可以设为跟&lt;code&gt;width&lt;/code&gt;或&lt;code&gt;height&lt;/code&gt;属性一样的值（比如350px），则项目将占据固定空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;flex属性&quot;&gt;5. flex属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex&lt;/code&gt;属性是&lt;code&gt;flex-grow&lt;/code&gt;, &lt;code&gt;flex-shrink&lt;/code&gt; 和 &lt;code&gt;flex-basis&lt;/code&gt;的简写，默认值为&lt;code&gt;0 1 auto&lt;/code&gt;。后两个属性可选。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;该属性有两个快捷值：&lt;code&gt;auto&lt;/code&gt; (&lt;code&gt;1 1 auto&lt;/code&gt;) 和 none (&lt;code&gt;0 0 auto&lt;/code&gt;)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;align-self属性&quot;&gt;6. align-self属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;align-self&lt;/code&gt;属性允许单个项目有与其他项目不一样的对齐方式，可覆盖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-item.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 13:14:00 +0000</pubDate>
<dc:creator>noobakong</dc:creator>
<og:description>flex笔记 基础 文章中的所有图示代码都放在了github上：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noobakong/p/9818863.html</dc:identifier>
</item>
<item>
<title>Java虚拟机性能监测工具Visual VM与OQL对象查询语言 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/9818491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/9818491.html</guid>
<description>&lt;p&gt;Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具，它集成了多种性能统计工具的功能，使用 Visual VM 可以代替jstat、jmap、jhat、jstack甚至是JConsole。在JDK 6 Update 7以后，Visual Vm便作为JDK的一部分发布，它完全免费。&lt;/p&gt;
&lt;p&gt;官方下载：&lt;a href=&quot;https://visualvm.github.io/download.html&quot; class=&quot;uri&quot;&gt;https://visualvm.github.io/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文汉化版：&lt;a href=&quot;https://download.csdn.net/download/yueshutong123/10729777&quot; class=&quot;uri&quot;&gt;https://download.csdn.net/download/yueshutong123/10729777&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual VM插件的安装非常容易，既可以通过离线下载插件*.nbm。然后在 PLugin 对话框的Downloaded页面下，添加已下载的插件。也可以在Availble Plugin页面下，在线安装插件，如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195349854-1273448410.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若是启动VisualVm.exe报错：Can'nt find java1.8 or or higher ,只需要编辑\etc\visualvm.conf文件，找到下面这行并重新指向本地Java路径即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;visualvm_jdkhome=&quot;D:\Java\jdk1.8.0&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;汉化版的插件地址已过时，点击“插件”-&amp;gt;“设置”-&amp;gt;“编辑”，更换URL为https://visualvm.github.io/archive/uc/release138/updates.xml.gz&lt;/p&gt;
&lt;p&gt;插件地址汇总：&lt;a href=&quot;https://visualvm.github.io/pluginscenters.html&quot; class=&quot;uri&quot;&gt;https://visualvm.github.io/pluginscenters.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;visual-vm连接应用程序&quot;&gt;1.1 Visual VM连接应用程序&lt;/h2&gt;
&lt;p&gt;1）Visual VM支持多种连接应用程序，最常见的就是本地连接。只要本地计算机内有Java应用程序正在执行，就可以监测到。如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195410417-1257919564.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）除了本地连接外，Visual VM也支持远程JMX连接。Java应用程序可以通过以下参数启动程序打开JMX端口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-Djava.rmi.server.hostname=127.0.0.1       #远程服务器的ip地址
-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=8888   #指定jmx监听的端口
-Dcom.sun.management.jmxremote.authenticate=false  #是否开启认证
-Dcom.sun.management.jmxremote.ssl=false   #是否开启ssl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加JMX连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195437788-1988961039.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加成功后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195453307-940304575.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3）添加远程主机。远程主机可以通过jstatd工具建立，如使用以下命令开启&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; jstatd -J-Djava.security.policy=c:\jstatd.all.policy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文本文件jstatd.all.policy的内容为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {
permission java.security.AllPermission;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着在Visual VM中添加远程主机，如图。正确填写计算机IP地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195509688-319265979.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;监控应用程序概况&quot;&gt;1.2 监控应用程序概况&lt;/h2&gt;
&lt;p&gt;通过Visual VM，可以查看应用程序的基本情况。比如，进程ID、Main Class、启动参数等。&lt;/p&gt;
&lt;p&gt;单机Tab页面的Monitor页面，即可监控应用程序的CPU、堆、永久区、类加载和线程数的总体情况。通过页面上的Perform GC 和 Heap Dump按钮还可以手工执行Full GC和生成堆快照。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195525092-1676606830.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;thread-dump和分析&quot;&gt;1.3 Thread Dump和分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195540985-452759335.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;性能分析&quot;&gt;1.4 性能分析&lt;/h2&gt;
&lt;p&gt;Visual VM有CPU和内存两个采样器。&lt;/p&gt;
&lt;p&gt;编写测试程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HProfTest {
    public void slowMethod(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void slowerMethod(){
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void fastMethod(){
        try {
            Thread.yield();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        while (true) {
            HProfTest hProfTest = new HProfTest();
            hProfTest.fastMethod();
            hProfTest.slowMethod();
            hProfTest.slowerMethod();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过Visual VM的采样功能，可以找到占用CPU时间最长的方法。如图slowerMethod()方法占用时间最长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195556939-1505328615.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Visual VM的默认统计信息中，不包含JDK内的函数调用统计，需要单击右上角的设置，手工配置。如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195614875-223850578.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;快照&quot;&gt;1.5 快照&lt;/h2&gt;
&lt;p&gt;选中java应用，单击应用程序，即可查看堆Dump，线程Dump等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195639494-1349795380.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右击dump快照，可另存为。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195717251-1656409003.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;内存快照分析&quot;&gt;1.6 内存快照分析&lt;/h2&gt;
&lt;p&gt;通过选中右键的堆Dump命令，可以立即获得当前应用程序的内存快照，如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195731900-378544401.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在类页面中，还可以对两个不同的内存快照文件进行比较。这个功能可以帮助开发者快速分析同一应用程序运行的不同时刻，内存数据产生的变化。&lt;/p&gt;
&lt;p&gt;在这个类展示的页面中，如果需要获取类的更多信息，可以单击右键，进入该类的实例页面；或者直接双击。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195754049-628848661.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实例页面中，将显示类的所有实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195807850-21279711.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mbean管理&quot;&gt;1.7 MBean管理&lt;/h2&gt;
&lt;p&gt;Visual VM可以通过插件，集成JConsole的MBean管理功能。&lt;br/&gt;关于JConsole MBean的使用请参考另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/yueshutong/p/9812464.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yueshutong/p/9812464.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;tda使用&quot;&gt;1.8 TDA使用&lt;/h2&gt;
&lt;p&gt;TDA 是Thread Dump Analyzer 的缩写，是一款线程快照分析工具。当使用jstack或者Visual VM等工具取得线程快照文件后，使用TDA可以帮助开发者分析导出的线程快照。TDA即是一款单独的软件，又是Visual VM的插件。当作为插件时，导出快照后，TDA会自启动。&lt;/p&gt;
&lt;h2 id=&quot;btrace介绍&quot;&gt;1.9 BTrace介绍&lt;/h2&gt;
&lt;p&gt;BTrace 通过字节码注入，动态监控系统的运行情况。它可以跟踪指定的方法调用、构造函数调用和系统内存等信息。在Visual VM中安装插件BTrace后，右击Java程序打开Trece application。如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195822601-1464749633.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;BTrace脚本示范：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@BTrace
public class TimeLogger {

  @TLS 
  private static long startTime = 0;

 @OnMethod(clazz=&quot;/.+/&quot;, //监控任意类
  method=&quot;/slowMethod/&quot;)    //监控slowMethod方法
  public static void startMethod(){
    startTime = timeMillis();
  }

  @OnMethod(clazz=&quot;/.+/&quot;,method=&quot;/slowMethod/&quot;,location=@Location(Kind.RETURN))//方法返回时触发
  public static void endMethod(){
    long time = timeMillis() - startTime;
    println(strcat(&quot;execute time(nanos): &quot;, str(time)));
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上脚本使用@OnMethod注释指定要监控的类和方法名称。@Location注释，可以指定程序运行到某一行代码时，触发某一行为。&lt;/p&gt;
&lt;p&gt;@OnMethod(clazz=&quot;/.+/&quot;, location=@Location(Kind.LINE, line=26))&lt;/p&gt;
&lt;p&gt;定时触发(ms)&lt;/p&gt;
&lt;p&gt;@OnMethod 更换为 @OnTimer(3000)&lt;/p&gt;
&lt;p&gt;监控参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public static void endMethod(@ProbeClassName String pcn, @ProbeMethodName String pmn, AnyType[]  args){
    //pcn 类名称

    //pmn 方法名称

    //args 参数

  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;监控文件&lt;/p&gt;
&lt;p&gt;method=&quot;&amp;lt;init&amp;gt;&quot; //监控构造函数&lt;/p&gt;

&lt;p&gt;上面我们学会了如何查看堆内存快照，但是，堆内存快照十分庞大，快照中的类数量也很多。Visual VM提供了对OQL（对象查询语言）的支持，以便于开发人员在庞大的堆内存数据中，快速定位所需的资源。&lt;/p&gt;
&lt;h2 id=&quot;visual-vm的oql基本语法&quot;&gt;2.1 Visual VM的OQL基本语法&lt;/h2&gt;
&lt;p&gt;OQL 语言是一种类似SQL的查询语言。基本语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select &amp;lt;JavaScript expression to select&amp;gt;
[ from [instanceof] &amp;lt;class name&amp;gt; &amp;lt;identifier&amp;gt;
[ where &amp;lt;JavaScript boolean expression to filter&amp;gt; ] ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OQL由3个部分组成：select 子句、from 子句和where 子句。select 子句指定查询结果要显示的内容；from 子句指定查询范围，可指定类名，如java.lang.String、char[]、[Ljava.io.File（File数组）;where 子句用于指定查询条件。&lt;/p&gt;
&lt;p&gt;select 子句和where 子句支持使用Javascript 语法处理较为复杂的查询逻辑；select 子句可以使用类似json的语法输出多个列；from子句中可以使用instanceof关键字，将给定类的子类也包括到输出列表中。&lt;/p&gt;
&lt;p&gt;在Visual VM的OQL中，可以直接访问对象的属性和部分方法。如下例中，直接使用了String对象的count属性，筛选出长度大于等于100的字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select s from java.lang.String s where s.count &amp;gt;= 100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;选取长度大于等于256的 int 数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select a from int[] a where a.length &amp;gt;= 256&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;筛选出表示两位数整数的字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select {instance: s, content: s.toString()} from java.lang.String s where /^\d{2}$/(s.toString())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中，select 子句使用了json语法，指定输出两列为String对象以及String.toString() 的输出。where 子句使用正则表达式，指定了符合/^\d{2}$/条件的字符串。&lt;/p&gt;
&lt;p&gt;下例使用 instance 关键字选取所有的ClassLoader，包括子类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select cl from instanceof java.lang.ClassLoader cl;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于在Java程序中，一个类可能会被多个ClassLoader同时载入，因此，这种情况下，可能需要使用Class的ID来指定Class。如下例，选出了所有ID为0x37A014D8的Class对象实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select s from 0x37A014D8 s;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Visual VM 的 OQL 语言支持Javascript作为子表达式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;内置heap对象&quot;&gt;2.2 内置heap对象&lt;/h2&gt;
&lt;p&gt;heap对象是 Visual VM OQL 的内置对象。通过 heap 对象可以实现一些强大的OQL功能。heap 对象的主要方法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;forEachClass()：对每一个Class对象执行一个回调操作。它的使用方法类似于 heap.forEachClass(callback)，其中 callback 为 Javascript 函数。&lt;/li&gt;
&lt;li&gt;findClass()：查找给定名称的类对象，返回类的方法和属性参考表6.3.它的调用方法类似 heap.findClass(className)。&lt;/li&gt;
&lt;li&gt;classes()：返回堆快照中所有的类集合。使用方法如 heap.classes()。&lt;/li&gt;
&lt;li&gt;objects()：返回堆快照中所有的对象集合。使用方法如 heap.objects(clazz,[includeSubtypes],[filter])，其中clazz指定类名称，includeSubtypes指定是否选出子类，filter 为过滤器，指定筛选规则。includeSubtypes 和 filter 可以省略。&lt;/li&gt;
&lt;li&gt;livepaths()：返回指定对象的存活路径。即，显示哪些对象直接或者间接引用了给定对象。它的使用方法如heap.livepaths(obj)。&lt;/li&gt;
&lt;li&gt;roots()：返回这个堆的根对象。使用方法如heap.roots()。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用findClass()返回的Class对象拥有的属性和方法 ：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;name：类名称&lt;/td&gt;
&lt;td&gt;isSubclassOf()：是否是指定类的子类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;superclass：父类&lt;/td&gt;
&lt;td&gt;isSuperclassOf()：是否是指定类的父类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;statics：类的静态变量的名称和值&lt;/td&gt;
&lt;td&gt;subclasses()：返回所有子类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;fields：类的域信息&lt;/td&gt;
&lt;td&gt;superclasses()：返回所有父类&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下例查找java.util.Vector类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.findClass(&quot;java.util.Vector&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找java.util.Vector的所有父类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.findClass(&quot;java.util.Vector&quot;).superclasses() &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.util.AbstractList  
java.util.AbstractCollection  
java.lang.Object &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找所有在java.io包下的对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select filter(heap.classes(), &quot;/java.io./(it.name)&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找字符串“56”的引用链：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.livepaths(s) from java.lang.String s where s.toString()=='56' &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下是一种可能的输出结果，其中java.lang.String#1600即字符串“56”。它显示了该字符串被一个WebPage对象持有。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.String#1600-&amp;gt;geym.zbase.ch7.heap.WebPage#57-&amp;gt;java.lang.Object[]#341-&amp;gt;java.util.Vector#11-&amp;gt;geym.zbase.ch7.heap.Student#3 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找这个堆的根对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.roots() &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例查找当前堆中所有java.io.File对象实例，参数true表示java.io.File的子类也需要被显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.objects(&quot;java.io.File&quot;,true) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例访问了TraceStudent类的静态成员webpages对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.findClass(&quot;geym.zbase.ch7.heap.TraceStudent&quot;).webpages &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对象函数&quot;&gt;2.3 对象函数&lt;/h2&gt;
&lt;p&gt;在Visual VM中，为OQL语言还提供了一组以对象为操作目标的内置函数。通过这些函数，可以获取目标对象的更多信息。本节主要介绍一些常用的对象函数。&lt;/p&gt;
&lt;h3 id=&quot;classof函数&quot;&gt;1．classof()函数&lt;/h3&gt;
&lt;p&gt;返回给定Java对象的类。调用方法形如classof(objname)。返回的类对象有以下属性。&lt;/p&gt;
&lt;p&gt;Class对象拥有以下方法。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;isSubclassOf()：是否是指定类的子类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;isSuperclassOf()：是否是指定类的父类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;subclasses()：返回所有子类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;superclasses()：返回所有父类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下例将返回所有Vector类以及子类的类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select classof(v) from instanceof java.util.Vector v &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一种可能的输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.util.Vector  
java.util.Vector  
java.util.Stack &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;objectid函数&quot;&gt;2．objectid()函数&lt;/h3&gt;
&lt;p&gt;objectid()函数返回对象的ID。使用方法如objectid(objname)。&lt;/p&gt;
&lt;p&gt;返回所有Vector对象（不包含子类）的ID：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select objectid(v) from  java.util.Vector v &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;reachables函数&quot;&gt;3．reachables()函数&lt;/h3&gt;
&lt;p&gt;reachables()函数返回给定对象的可达对象集合。使用方法如reachables(obj,[exclude])。obj为给定对象，exclude指定忽略给定对象中的某一字段的可达引用。&lt;/p&gt;
&lt;p&gt;下例返回'56'这个String对象的所有可达对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select reachables(s) from java.lang.String s where s.toString()=='56'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的部分输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;char[]#264&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的返回结果是 java.lang.String.value 域的引用对象。即，给定的 String 类型的 value 域指向对象 char[]#264。如果使用过滤，要求输出结果中不包含 java.lang.String.value 域的引用对象，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select reachables(s, &quot;java.lang.String.value&quot;) from java.lang.String s where s.toString()=='56'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上查询输出结果为空，因为String对象只有value包含对其它对象的引用。&lt;/p&gt;
&lt;h3 id=&quot;referrers函数&quot;&gt;4．referrers()函数&lt;/h3&gt;
&lt;p&gt;返回引用给定对象的对象集合。使用方法如：referrers(obj)。&lt;/p&gt;
&lt;p&gt;下例返回了引用“56”String对象的对象集合：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select referrers(s) from java.lang.String s where s.toString()=='56'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的输出可能如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.Object[]#1077
java.lang.Object[]#1055&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这说明一个Object数组引用了“56”这个字符串对象。在查询结果中单击 java.lang.Object[]#1077，可进一步找到引用 java.lang.Object[]#1077 对象的是一个ArrayList对象。如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195850014-339926264.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下例找出长度为2，并且至少被2个对象引用的字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select s.toString() from java.lang.String s where (s.count==2 &amp;amp;&amp;amp; count(referrers(s)) &amp;gt;=2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：where子句中使用的逻辑运算符是&amp;amp;&amp;amp;。这是JavaScript语法，不能像SQL一样使用AND操作符。&lt;/p&gt;
&lt;h3 id=&quot;referees函数&quot;&gt;5．referees()函数&lt;/h3&gt;
&lt;p&gt;referees()函数返回给定对象的直接引用对象集合，用法形如：referees(obj)。&lt;/p&gt;
&lt;p&gt;下例返回了File对象的静态成员引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select referees(heap.findClass(&quot;java.io.File&quot;)) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例返回长度为2，并且至少被2个对象引用的字符串的直接引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select referees(s) from java.lang.String s where (s.count==2 &amp;amp;&amp;amp; count(referrers(s)) &amp;gt;=2 )&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sizeof函数&quot;&gt;6．sizeof()函数&lt;/h3&gt;
&lt;p&gt;sizeof()函数返回指定对象的大小（不包括它的引用对象），即浅堆（Shallow Size）。&lt;/p&gt;
&lt;p&gt;注意：sizeof()函数返回对象的大小不包括对象的引用对象。因此，sizeof()的返回值由对象的类型决定，和对象的具体内容无关。&lt;/p&gt;
&lt;p&gt;下例返回所有int数组的大小以及对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select {size:sizeof(o),Object:o} from int[] o &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例返回所有Vector的大小以及对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select {size:sizeof(o),Object:o} from java.util.Vector o &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的输出可能为如下形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
size = 36,
Object = java.util.Vector#5
}
{
size = 36,
Object = java.util.Vector#6
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，不论Vector集合包含多少对象。Vector对象所占用的内存大小始终为36字节。这是由Vector本身的结构决定的，与其内容无关。sizeof()函数就是返回对象的固有大小。&lt;/p&gt;
&lt;h3 id=&quot;rsizeof函数&quot;&gt;7．rsizeof()函数&lt;/h3&gt;
&lt;p&gt;rsizeof()函数返回对象以及其引用对象的大小总和，即深堆（Retained Size）。这个数值不仅与类本身的结构有关，还与对象的当前数据内容有关。&lt;/p&gt;
&lt;p&gt;下例显示了所有Vector对象的Shallow Size以及Retained Size：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select {size:sizeof(o),rsize:rsizeof(o)} from java.util.Vector o &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部分输出可能如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
size = 36,
rsize = 572
}

{
size = 36,
rsize = 76
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：resizeof()取得对象以及其引用对象的大小总和。因此，它的返回值与对象的当前数据内容有关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8．toHtml()函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;toHtml()函数将对象转为HTML显示。&lt;/p&gt;
&lt;p&gt;下例将Vector对象的输出使用HTML进行加粗和斜体显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select &quot;&amp;lt;b&amp;gt;&amp;lt;em&amp;gt;&quot;+toHtml(o)+&quot;&amp;lt;/em&amp;gt;&amp;lt;/b&amp;gt;&quot; from java.util.Vector o &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出部分结果如图7.44所示。直接点击输出对象，可以展示实例页面中的对应对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195929957-420535711.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;集合统计函数&quot;&gt;2.4 集合/统计函数&lt;/h2&gt;
&lt;p&gt;Visual VM中还有一组用于集合操作和统计的函数。可以方便地对结果集进行后处理或者统计操作。集合/统计函数主要有contains()、count()、filter()、length()、map()、max()、min()、sort()、top()等。&lt;/p&gt;
&lt;h3 id=&quot;contains函数&quot;&gt;1．contains()函数&lt;/h3&gt;
&lt;p&gt;contains()函数判断给定集合是否包含满足给定表达式的对象。它的使用方法形如contains(set, boolexpression)。其中set为给定集合，boolexpression为表达式。在boolexpression中，可以使用如下contains()函数的内置对象。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;it：当前访问对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;index：当前对象索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;array：当前迭代的数组/集合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下例返回被 File 对象引用的 String 对象集合。首先通过 referrers(s) 得到所有引用String 对象的对象集合。使用 contains() 函数及其参数布尔等式表达式classof(it).name == 'java.io.File')，将 contains() 的筛选条件设置为类名是java.io.File 的对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select s.toString() from java.lang.String s where contains(referrers(s), &quot;classof(it).name == 'java.io.File'&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上查询的部分输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D:\Java\jdk1.8.0\jre\lib\ext\sunpkcs11.jar
D:\Java\jdk1.8.0\jre\lib\ext\sunec.jar
D:\Java\jdk1.8.0\jre\lib\ext\nashorn.jar
D:\Java\jdk1.8.0\jre\lib\ext\localedata.jar
D:\Java\jdk1.8.0\jre\lib\ext\zipfs.jar
D:\Java\jdk1.8.0\jre\lib\ext\jfxrt.jar
D:\Java\jdk1.8.0\jre\lib\ext\dnsns.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过该OQL，得到了当前堆中所有的File对象的文件名称。可以理解为当前Java程序通过java.io.File获得已打开或持有的所有文件。&lt;/p&gt;
&lt;h3 id=&quot;count函数&quot;&gt;2．count()函数&lt;/h3&gt;
&lt;p&gt;count()函数返回指定集合内满足给定布尔表达式的对象数量。它的基本使用方法如：count(set, [boolexpression])。参数set指定要统计总数的集合，boolexpression为布尔条件表达式，可以省略，但如果指定，count()函数只计算满足表达式的对象个数。在boolexpression表达式中，可以使用以下内置对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;it：当前访问对象。&lt;/li&gt;
&lt;li&gt;index：当前对象索引。&lt;/li&gt;
&lt;li&gt;array：当前迭代的数组/集合。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下例返回堆中所有java.io包中的类的数量，布尔表达式使用正则表达式表示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select count(heap.classes(), &quot;/java.io./(it.name)&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下列返回堆中所有类的数量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select count(heap.classes()) &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;filter函数&quot;&gt;3．filter()函数&lt;/h3&gt;
&lt;p&gt;filter()函数返回给定集合中，满足某一个布尔表达式的对象子集合。使用方法形如filter(set, boolexpression)。在boolexpression中，可以使用以下内置对象。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;it：当前访问对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;index：当前对象索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;array：当前迭代的数组/集合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下例返回所有java.io包中的类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select filter(heap.classes(), &quot;/java.io./(it.name)&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例返回了当前堆中，引用了java.io.File对象并且不在java.io包中的所有对象实例。首先使用referrers()函数得到所有引用java.io.File对象的实例，接着使用filter()函数进行过滤，只选取不在java.io包中的对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select filter(referrers(f), &quot;! /java.io./(classof(it).name)&quot;) from java.io.File f &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;length函数&quot;&gt;4．length()函数&lt;/h3&gt;
&lt;p&gt;length()函数返回给定集合的数量，使用方法形如length(set)。&lt;/p&gt;
&lt;p&gt;下例返回当前堆中所有类的数量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select length(heap.classes()) &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;map函数&quot;&gt;5．map()函数&lt;/h3&gt;
&lt;p&gt;map()函数将结果集中的每一个元素按照特定的规则进行转换，以方便输出显示。使用方法形如：map(set, transferCode)。set为目标集合，transferCode为转换代码。在transferCode中可以使用以下内置对象。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;it：当前访问对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;index：当前对象索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;array：当前迭代的数组/集合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下例将当前堆中的所有File对象进行格式化输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select map(heap.objects(&quot;java.io.File&quot;), &quot;index + '=' + it.path.toString()&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0=D:\tools\jdk1.7_40\jre\bin\zip.dll
1=D:\tools\jdk1.7_40\jre\bin\zip.dll
2=D:\tools\jdk1.7_40\jre\lib\ext
3=C:\Windows\Sun\Java\lib\ext
4=D:\tools\jdk1.7_40\jre\lib\ext\meta-index
5=D:\tools\jdk1.7_40\jre\lib\ext &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：map()函数可以用于输出结果的数据格式化。它可以将集合中每一个对象转成特定的输出格式。&lt;/p&gt;
&lt;h3 id=&quot;max函数&quot;&gt;6．max()函数&lt;/h3&gt;
&lt;p&gt;max()函数计算并得到给定集合的最大元素。使用方法为：max(set, [express])。其中set为给定集合，express为比较表达式，指定元素间的比较逻辑。参数express可以省略，若省略，则执行数值比较。参数express可以使用以下内置对象。&lt;/p&gt;
&lt;p&gt;下例显示了当前堆中最长的String长度。对于JDK 1.6得到的堆，首先使用heap.objects()函数得到所有String对象，接着，使用map()函数将String对象集合转为String对象的长度集合，最后，使用max()函数得到集合中的最大元素。对于JDK 1.7得到的堆，由于String结构发生变化，故通过String.value得到字符串长度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JDK 1.6导出的堆  
select max(map(heap.objects('java.lang.String', false), 'it.count'))   
JDK 1.7导出的堆  
select max(map(filter(heap.objects('java.lang.String', false),'it.value!=null'), 'it.value.length'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上OQL的输出为最大字符串长度，输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;734.0 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例取得当前堆的最长字符串。它在max()函数中设置了比较表达式，指定了集合中对象的比较逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JDK 1.6导出的堆  
select max(heap.objects('java.lang.String'), 'lhs.count &amp;gt; rhs.count')   
JDK 1.7导出的堆  
select max(filter(heap.objects('java.lang.String'),'it.value!=null'), 'lhs. value.length &amp;gt; rhs.value.length') &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与上例相比，它得到的是最大字符串对象，而非对象的长度：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.String#908 &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;min函数&quot;&gt;7．min()函数&lt;/h3&gt;
&lt;p&gt;min()函数计算并得到给定集合的最小元素。使用方法为：min(set, [expression])。其中set为给定集合，expression为比较表达式，指定元素间的比较逻辑。参数expression可以省略，若省略，则执行数值比较。参数expression可以使用以下内置对象：&lt;/p&gt;
&lt;p&gt;下例返回当前堆中数组长度最小的Vector对象的长度：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select min(map(heap.objects('java.util.Vector', false), 'it.elementData. length')) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例得到数组元素长度最长的一个Vector对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select min(heap.objects('java.util.Vector'), 'lhs.elementData.length &amp;gt; rhs.elementData.length') &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sort函数&quot;&gt;8．sort()函数&lt;/h3&gt;
&lt;p&gt;sort()函数对指定的集合进行排序。它的一般使用方法为：sort(set, expression)。其中，set为给定集合，expression为集合中对象的排序逻辑。在expression中可以使用以下内置对象：&lt;/p&gt;
&lt;p&gt;下例将当前堆中的所有Vector按照内部数组的大小进行排序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select sort(heap.objects('java.util.Vector'), 
'lhs.elementData.length - rhs.elementData.length') &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例将当前堆中的所有Vector类（包括子类），按照内部数据长度大小，从小到大排序，并输出Vector对象的实际大小以及对象本身。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select map(    sort(          
heap.objects('java.util.Vector'),       
'lhs.elementData.length - rhs.elementData.length' ), 
'{ size: rsizeof(it), obj: it }'    ) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述查询中，首先通过heap.objects()方法得到所有Vector及其子类的实例，接着，使用sort()函数，通过Vector内部数组长度进行排序，最后使用map()函数对排序后的集合进行格式化输出。&lt;/p&gt;
&lt;h3 id=&quot;top函数&quot;&gt;9．top()函数&lt;/h3&gt;
&lt;p&gt;top()函数返回在给定集合中，按照特定顺序排序的前几个对象。一般使用方法为：top(set, expression,num)。其中set为给定集合，expression为排序逻辑，num指定输出前几个对象。在expression中，可以使用以下内置对象。&lt;/p&gt;
&lt;p&gt;下例显示了长度最长的前5个字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JDK 1.6的堆  
select top(heap.objects('java.lang.String'), 'rhs.count - lhs.count', 5)   
JDK 1.7的堆  
select top(filter(heap.objects('java.lang.String'),'it.value!=null'), 'rhs. value.length - lhs.value.length', 5) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例显示长度最长的5个字符串，输出它们的长度与对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JDK 1.6的堆  
select map(top(heap.objects('java.lang.String'), 'rhs.count - lhs.count', 5), '{ length: it.count, obj: it }')  
JDK 1.7的堆  
select map(top(filter(heap.objects('java.lang.String'),'it.value!=null'), 'rhs.value.length - lhs.value.length', 5), '{ length: it.value.length, obj: it }') &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述查询的部分输出可能如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{  
length = 734.0, 
obj = java.lang.String#908  } 
{ 
length = 293.0, 
obj = java.lang.String#914  
} &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sum函数&quot;&gt;10．sum()函数&lt;/h3&gt;
&lt;p&gt;sum()函数用于计算集合的累计值。它的一般使用方法为：sum(set,[expression])。其中第一个参数set为给定集合，参数expression用于将当前对象映射到一个整数，以便用于求和。参数expression可以省略，如果省略，则可以使用map()函数作为替代。&lt;/p&gt;
&lt;p&gt;下例计算所有 java.util.Properties 对象的可达对象的总大小：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select sum(map(reachables(p), 'sizeof(it)')) from java.util.Properties p &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将使用 sum() 函数的第2个参数 expression 代替 map() 函数，实现相同的功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select sum(reachables(p), 'sizeof(it)') from java.util.Properties p &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;unique函数&quot;&gt;11．unique()函数&lt;/h3&gt;
&lt;p&gt;unique()函数将除去指定集合中的重复元素，返回不包含重复元素的集合。它的一般使用方法形如unique(set)。&lt;/p&gt;
&lt;p&gt;下例返回当前堆中，有多个不同的字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select count(unique(map(heap.objects('java.lang.String'), 'it.value'))) &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;程序化oql&quot;&gt;2.5 程序化OQL&lt;/h2&gt;
&lt;p&gt;Visual VM不仅支持在OQL控制台上执行OQL查询语言，也可以通过其OQL相关的JAR包，将OQL查询程序化，从而获得更加灵活的对象查询功能，实现堆快照分析的自动化。&lt;/p&gt;
&lt;p&gt;在进行OQL开发前，工程需要引用Visual VM安装目录下JAR包，如图7.45所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019200034314-1333959757.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里以分析Tomcat堆溢出文件为例，展示程序化OQL带来的便利。 对于给定的Tomcat堆溢出Dump文件，这里将展示如何通过程序，计算Tomcat平均每秒产生的session数量，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AveLoadTomcatOOM {
    public static final String dumpFilePath = &quot;d:/tmp/tomcat_oom/tomcat.hprof&quot;;

    public static void main(String args[]) throws Exception {
        OQLEngine engine;
        final List&amp;lt;Long&amp;gt; creationTimes = new ArrayList&amp;lt;Long&amp;gt;(000);
        engine = new OQLEngine(HeapFactory.createHeap(new File(dumpFilePath)));
        String query = &quot;select s.creationTime from org.apache.catalina. session.StandardSession s&quot;; //第8行
        engine.executeQuery(query, new OQLEngine.ObjectVisitor() {
            public boolean visit(Object obj) {
                creationTimes.add((Long) obj);
                return false;
            }
        });
        Collections.sort(creationTimes);
        long min = creationTimes.get(0) / 1000;//第18行
        long max = creationTimes.get(creationTimes.size() - 1) / 1000;
        System.out.println(&quot;平均压力：&quot; + creationTimes.size() * 1.0 / (max - min) + &quot;次/秒&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码第8行，通过OQL语句得到所有session的创建时间，在第18、19行获得所有session中最早创建和最晚创建的session时间，在第21行计算整个时间段内的平均session创建速度。&lt;/p&gt;
&lt;p&gt;运行上述代码，得到输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;平均压力：311.34375次/秒 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种方式可以做到堆转存文件的全自动化分析，并将结果导出到给定文件，当有多个堆转存文件需要分析时，有着重要的作用。&lt;/p&gt;
&lt;p&gt;除了使用以上方式外，Visual VM的OQL控制台也支持直接使用JavaScript代码进行编程，如下代码实现了相同功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var sessions=toArray(heap.objects(&quot;org.apache.catalina.session.StandardSession&quot;));  
var count=sessions.length;  
var createtimes=new Array();  
for(var i=0;i&amp;lt;count;i++){      createtimes[i]=sessions[i].creationTime;  
}  
createtimes.sort();  
var min=createtimes[0]/1000;  
var max=createtimes[count-1]/1000;  
count/(max-min)+&quot;次/秒&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图显示了在OQL控制台中，执行上述脚本以及输出结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019200319928-990945901.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;细心的读者可能会发现，这个结果和使用Java访问Dump文件时的结果有所差异，这是因为JavaScript是弱类型语言，在处理整数除法时和Java有所不同，读者可以自行研究，在此不予展开讨论。&lt;/p&gt;
&lt;p&gt;Visual VM的OQL是非常灵活的，除了上述使用JavaScript风格外，也可以使用如下函数式编程风格计算：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;count(heap.objects('org.apache.catalina.session.StandardSession'))/  (  
max(map(heap.objects('org.apache.catalina.session.StandardSession'),'it.creationTime'))/1000-  
min(map(heap.objects('org.apache.catalina.session.StandardSession'),'it.creationTime'))/1000  ) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码使用了count()、min()、max()、map()等函数，共同完成了平均值的计算。执行上述代码，输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;312.1240594043491 &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;因JDK版本问题，无法保证上述操作的有效性，仅供学习与参考。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 19 Oct 2018 12:03:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>1.Visual VM多合一工具 Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具，它集成了多种性能统计工具的功能，使用 Visual VM 可以代替jstat、jmap、jha</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/9818491.html</dc:identifier>
</item>
<item>
<title>保姆级教程——Ubuntu16.04 Server下深度学习环境搭建：安装CUDA8.0，cuDNN6.0，Bazel0.5.4，源码编译安装TensorFlow1.4.0(GPU版) - 同勉共进</title>
<link>http://www.cnblogs.com/zpcdbky/p/9757821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zpcdbky/p/9757821.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;写在前面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文叙述了在Ubuntu16.04 Server下安装CUDA8.0，cuDNN6.0以及源码编译安装TensorFlow1.4.0(GPU版)的亲身经历，包括遇到的问题及解决办法，也有一些自己的经验，希望能对读者有所帮助。期间参考了许多前人的文章，后文会一一附上链接，在此先行谢过。在下能力有限，经验不足，请大家多多指教。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：&lt;/strong&gt;Ubuntu16.04 Server   深度学习环境搭建   安装   显卡驱动   CUDA8.0   cuDNN6.0   Bazel   源码编译   TensorFlow1.4.0   GPU版   TensorFlow_gpu1.4.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统和硬件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.Ubuntu16.04 Server版&lt;/p&gt;
&lt;p&gt;2.GPU：NVIDIA Tesla P40 （一块）&lt;/p&gt;
&lt;p&gt;3.CPU：Intel Xeon Processor E5-2620 v4   20M Cache,2.10GHz   （两块）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件版本配置：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010091721914-1623579633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009215410498-696446925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.以上配置信息来自&lt;a title=&quot;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&quot; href=&quot;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&quot; target=&quot;_blank&quot;&gt;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&lt;/a&gt; ，这也是来自官网的TensorFlow安装教程，也是在下实际安装TensorFlow的过程中的主要参考资料。&lt;/p&gt;
&lt;p&gt;2.在下实际安装时使用的GCC版本为4.9而非4.8，但也没受到任何不良影响。&lt;/p&gt;
&lt;p&gt;3.Ubuntu16.04 Server和显卡驱动安装是由他人完成的，从CUDA8.0的安装开始，都是由在下亲手完成，所以本文重点叙述CUDA等深度学习相关软件库的安装。&lt;/p&gt;
&lt;p&gt;4.本文对其它版本配置的深度学习环境搭建也有一定借鉴意义，许多方法和技巧是通用的。比如：&lt;/p&gt;
&lt;p&gt;            &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#xkmc&quot;&gt;查询显卡名称&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;            &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;获取下载链接并使用wget命令下载文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.预警：很长很啰嗦（面向小白，保姆级教程）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title1&quot;&gt;一、安装Ubuntu16.04 Server版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title2&quot;&gt;二、安装显卡驱动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#xkmc&quot;&gt;I. 查看显卡名称&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#xzqd&quot;&gt; II. 下载对应驱动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#azqd&quot;&gt;III. 安装驱动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title3&quot;&gt;三、安装CUDA8.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#C_run&quot;&gt;I. 下载.run文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#C_az&quot;&gt;II. 安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#C_cs&quot;&gt;III. 测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title4&quot;&gt;四、安装cuDNN6.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#cu_xz&quot;&gt; I. 下载安装文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#cu_az&quot;&gt;II. 安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title5&quot;&gt;五、安装Bazel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#B_ck&quot;&gt;I. 查看/卸已有版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#B_xz&quot;&gt;II. 下载安装包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#B_az&quot;&gt;III. 安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#B_cs&quot;&gt;IV. 测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title6&quot;&gt;六、相关准备工作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#gcc&quot;&gt;I. gcc降级&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#qhbb&quot;&gt;II. 切换默认Python版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title7&quot;&gt;七、编译安装TensorFlow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#tf_xz&quot;&gt;I. 下载源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#tf_by&quot;&gt;II. 编译&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#tf_az&quot;&gt;III. 安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#tf_cs&quot;&gt;IV. 测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、安装Ubuntu16.04 Server版&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这一部分是其他人做的，在下只是在旁观摩，所以在这里只叙述个大概，详细安装方法请您自行Google。&lt;/p&gt;
&lt;p&gt;下载安装包，做成启动U盘，直接插在机箱上通过BIOS安装（原来机器上装有SentOS），谢天谢地，期间没有遇到什么问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、安装显卡驱动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显卡驱动也不是在下亲手安装的，这里只给出一些通用的方法和技巧，以及一些可能对您有用的链接，希望对您有所帮助，如有错误纰漏之处，恳请您不吝赐教。&lt;/p&gt;
&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;I. 查看显卡名称&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果您已知您的显卡信息，则略过该步骤。&lt;/p&gt;
&lt;p&gt;现在设想最坏的情况，您不知道您的显卡叫什么名字，也没办法打开机箱来看（比如远程的），问谁谁也不知道，机器上也没有旧的显卡驱动（没有比这更糟糕的了），那么，下面的办法不妨一试：&lt;/p&gt;
&lt;p&gt;step1：运行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
lshw -numeric -C display
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018195712701-1071547139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您使用的是GeForce系列的显卡，上面的命令可以直接输出显卡的名称，但如果您使用的是Tesla系列之类的专业级显卡，上面的命令并不能直接得到显卡名称（如上图所示），这时需要接着进行下面的操作。&lt;/p&gt;
&lt;p&gt;step2：查询显卡名称&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接Google关键字10DE:1b38或1A03:2000，第一条就是，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181008215858666-1991378829.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181008222023523-686825366.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181008221804987-1965415308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;注：使用必应搜索也可以，第三条就是。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;访问网址&lt;a title=&quot;https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids&quot; href=&quot;https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids&quot; target=&quot;_blank&quot;&gt;https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids &lt;/a&gt; ，Ctrl+F搜索关键字1b38或1a03（不要搜索10de或2000，这两项匹配的结果太多了），如下图。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181008222739347-1480483919.png&quot; alt=&quot;&quot;/&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181008222857227-448113638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;注：这个网页上几乎包含了世界上所有显卡（不光是NVIDIA的）的厂商和名称信息，非常全。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;strong&gt;方法三&lt;/strong&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;访问网址&lt;a title=&quot;https://pci-ids.ucw.cz/read/PC/&quot; href=&quot;https://pci-ids.ucw.cz/read/PC/&quot; target=&quot;_blank&quot;&gt;https://pci-ids.ucw.cz/read/PC/&lt;/a&gt;，如图&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009082733137-1325389963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;对10de:1b38而言，我们先找10de，10de以1开头，所以点击上图中的1（用红框圈起来的那个）。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;页面跳转后Ctrl+F查找关键字10de，如图&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009083131538-748492275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;点击10de，页面跳转后Ctrl+F查找关键字1b38，如图&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009083442098-1824826316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;注：&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;1.ASPEED Graphics Family（上文中1a03:2000对应的显卡名称）是ASPEED公司（信骅科技，台湾，全球第一大服务器管理芯片供应商）生产的一系列BMC（Baseboard Management Controller ，基板管理控制器）芯片的总称，一般兼做服务器的集显，提供最基础的显示功能。1a03:2000表示AST2000，是ASPEED Graphics Family系列的第一款。更多详情请见：&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;a title=&quot;https://pci-ids.ucw.cz/read/PC/1a03/2000&quot; href=&quot;https://pci-ids.ucw.cz/read/PC/1a03/2000&quot; target=&quot;_blank&quot;&gt;https://pci-ids.ucw.cz/read/PC/1a03/2000&lt;/a&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;a title=&quot;https://zhidao.baidu.com/question/504159607.html&quot; href=&quot;https://zhidao.baidu.com/question/504159607.html&quot; target=&quot;_blank&quot;&gt;https://zhidao.baidu.com/question/504159607.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;a title=&quot;https://zhidao.baidu.com/question/436858677675772444.html&quot; href=&quot;https://zhidao.baidu.com/question/436858677675772444.html&quot; target=&quot;_blank&quot;&gt;https://zhidao.baidu.com/question/436858677675772444.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;2.网络上的许多教程可能会给出下面一些命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
lspci | &lt;span&gt;grep&lt;/span&gt; -&lt;span&gt;i vga
lspci &lt;/span&gt;|&lt;span&gt;grep&lt;/span&gt; -&lt;span&gt;i nvidia
lspci &lt;/span&gt;-v -s &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt;     #使用上述两个命令后会输出02:&lt;span&gt;00&lt;/span&gt;.0或06:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;.0等字样
lspci &lt;/span&gt;-v -s &lt;span&gt;06&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt;&lt;span&gt;
lspci &lt;/span&gt;-vnn | &lt;span&gt;grep&lt;/span&gt; VGA -A &lt;span&gt;12&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-mce-=&quot;&quot;&gt;如果您的机器使用的是Tesla系列之类的专业级显卡，那么上述命令并不能显示出显卡的名称，但如果您使用的是GeForce系列的显卡，则上述命令可以打印出显卡名称。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;strong&gt;II. 下载对应驱动&lt;/strong&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;访问NVIDIA的官网，填写显卡、系统、CUDA版本等信息，便可下载相应驱动。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;地址：&lt;a title=&quot;https://www.nvidia.com/download/index.aspx&quot; href=&quot;https://www.nvidia.com/download/index.aspx&quot; target=&quot;_blank&quot;&gt;https://www.nvidia.com/download/index.aspx&lt;/a&gt; （English）&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;          &lt;a title=&quot;https://www.nvidia.com/Download/index.aspx?lang=cn&quot; href=&quot;https://www.nvidia.com/Download/index.aspx?lang=cn&quot; target=&quot;_blank&quot;&gt;https://www.nvidia.com/Download/index.aspx?lang=cn&lt;/a&gt;  （Chinese）&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009090021638-308237135.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009090456393-1548194644.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009090104479-1715660636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009095215721-266866512.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009095610541-553289554.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009100100955-223323926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.如果您的网络使用ivp6协议，那么在实际操作中可能会出现上面第一幅图中所示的下拉列表框点击不动的情况，此时您可能需要使用采用ipv4协议的网络来访问上面的下载地址。&lt;/p&gt;
&lt;p&gt;2.如果您是远程访问，在自己机器上下载好安装文件后还需要使用Xftp等工具将安装文件传输到目标机上，既麻烦又费时，下面介绍一种使用命令行在目标机上直接下载的方法（前提是目标机可以自由访问网络）。&lt;/p&gt;
&lt;p&gt;step1：在上图的绿色按钮（即“AGREE &amp;amp; DOWNLOAD”按钮）上右键，在弹出的菜单中选择“复制链接地址”，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181012110914344-1425242147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step2：在复制得到的地址前加上“wget”构成如下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt;  http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;us.download.nvidia.com/tesla/384.66/nvidia-diag-driver-local-repo-ubuntu1604-384.66_1.0-1_amd64.deb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用该命令便可直接在目标机上在线下载链接指向的文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;III. 安装驱动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;跳转到上一步下载的.deb文件所在的目录，依次执行下列命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; dpkg -i nvidia-diag-driver-local-repo-ubuntu1604-&lt;span&gt;384&lt;/span&gt;.66_1.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;1_amd64.deb   #这里需要更换为您自己下载的.deb文件的文件名
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-&lt;span&gt;get update
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get cuda-&lt;span&gt;drivers
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; reboot now   #安装后重启
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在安装过程中可能需要您手动回答yes或no（输入y或n），请您根据自己的情况决定（印象中全部选y，但在下没亲自试过）。&lt;/p&gt;
&lt;p&gt;参考网址：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/u011889952/article/details/77746668&quot; href=&quot;https://blog.csdn.net/u011889952/article/details/77746668&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u011889952/article/details/77746668&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://gist.github.com/jcjohnson/4976067b503d8d1ebafb5eb6f38f9aae&quot; href=&quot;https://gist.github.com/jcjohnson/4976067b503d8d1ebafb5eb6f38f9aae&quot; target=&quot;_blank&quot;&gt;https://gist.github.com/jcjohnson/4976067b503d8d1ebafb5eb6f38f9aae&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.第二个链接中提供了一个自动获取.deb文件并安装的脚本（如您要使用，请记着更改第一行命令中的地址以对应您所需的驱动版本，地址获取方法见上面&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;注2&lt;/a&gt;），其中的参数 --allow-unauthenticated 表示允许使用未通过验证的安装包，--assume-yes 表示对安装过程中的所有询问都回答yes。&lt;/p&gt;
&lt;p&gt;2.除上述方法外，安装驱动的方法还有.run文件、PPA源、apt-get等。有些文章提到用.deb文件安装会失败，此时可以考虑使用.run文件安装，要下载.run文件，只要将上面第一幅图中的Operating System选项选为Linux 64-bit即可，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009214234850-2125900075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装方法可参考以下链接：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.jianshu.com/p/1baf9848b7d7&quot; href=&quot;https://www.jianshu.com/p/1baf9848b7d7&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/1baf9848b7d7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.linuxidc.com/Linux/2016-12/138907.htm&quot; href=&quot;https://www.linuxidc.com/Linux/2016-12/138907.htm&quot; target=&quot;_blank&quot;&gt;https://www.linuxidc.com/Linux/2016-12/138907.htm&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.jianshu.com/p/b313625fbe61&quot; href=&quot;https://www.jianshu.com/p/b313625fbe61&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/b313625fbe61&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其它安装方法请读者自行探索，这里不再赘述。&lt;/p&gt;
&lt;p&gt;至此，显卡驱动安装完毕。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、安装CUDA8.0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I. 下载.run文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1：访问网址&lt;a title=&quot;https://developer.nvidia.com/cuda-downloads?&quot; href=&quot;https://developer.nvidia.com/cuda-downloads?&quot; target=&quot;_blank&quot;&gt;https://developer.nvidia.com/cuda-downloads?&lt;/a&gt; ，按图示操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010092052481-1871949925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：不要在上边选择选项，否则下载的将是10.0版本而非8.0版本。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010092314278-1444897836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step2：页面跳转后选择自己需要的版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010092554828-723784454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step3：页面跳转后再选择Operating System，Architecture，Distribution，Version，Installer Type等各项指标，其中Installer Type选择runfile(local)选项，选好后点击Download，如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010093543265-202085146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：右击上图所示的绿色下载按钮，在弹出的菜单中点击“复制链接地址”，在复制得到的地址前加上“wget”构成一条命令(如下)，使用该命令可直接在目标机上在线下载。详见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;第二节注2&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;developer.nvidia.com/compute/cuda/8.0/Prod2/local_installers/cuda_8.0.61_375.26_linux-run&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;II. 安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1：在目标机上跳转到.run文件所在目录，执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;sh&lt;/span&gt; cuda_8.&lt;span&gt;0&lt;/span&gt;.61_375.26_linux.run   #注意这里要使用您下载的.run文件的文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来的安装过程中会问您一系列问题，愚以为最佳回答如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;p&gt;  Do you accept the previously read EULA?&lt;br/&gt;  accept/decline/quit: accept&lt;/p&gt;
&lt;p&gt;  Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 375.26?&lt;br/&gt;  (y)es/(n)o/(q)uit: n   #&lt;span&gt;这里必须选n&lt;/span&gt;，不然会重新安装显卡驱动，这会覆盖掉原来的驱动&lt;/p&gt;
&lt;pre&gt;
&lt;br/&gt;Install the CUDA &lt;span&gt;8.0&lt;/span&gt; Toolkit?&lt;span&gt;
(y)es&lt;/span&gt;/(n)o/&lt;span&gt;(q)uit: y                #选y

Enter Toolkit Location
 [ &lt;/span&gt;&lt;span&gt;default is&lt;/span&gt; /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt; ]:    #&lt;span&gt;强烈建议您直接回车&lt;/span&gt;，即接受默认配置，将CUDA安装在&lt;/span&gt;/usr/local/cuda-8.0目录下&lt;span&gt;，这将会为后面TensorFlow的安装提供方便 &lt;/span&gt;/usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; not writable. &lt;br/&gt;Do you wish to run the installation with &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;?&lt;span&gt; &lt;br/&gt;(y)es&lt;/span&gt;/&lt;span&gt;(n)o: y&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;Please enter your password: &lt;br/&gt;Do you want to install a symbolic link at &lt;/span&gt;/usr/local/cuda?&lt;span&gt; &lt;br/&gt;(y)es&lt;/span&gt;/(n)o/&lt;span&gt;(q)uit: y         #&lt;span&gt;强烈建议选y&lt;/span&gt;，即建立一个符号链接/usr/local/cuda指向&lt;/span&gt;/usr/local/cuda-8.0，&lt;span&gt;这将会为后面TensorFlow的安装提供方便，也会为后续使用提供方便&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;Install the CUDA &lt;/span&gt;&lt;span&gt;8.0&lt;/span&gt; Samples?&lt;span&gt; (y)es&lt;/span&gt;/(n)o/&lt;span&gt;(q)uit: y Enter CUDA Samples Location &lt;br/&gt;[ &lt;/span&gt;&lt;span&gt;default &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;/home/xxx&lt;/span&gt; ]:      #这是问CUDA的测试用例安装在哪里，您可以选择默认，也可以按自己意愿键入其它目录
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果顺利安装的话，接下来还会有一大推输出，简单摘取如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Installing the CUDA Toolkit &lt;span&gt;in&lt;/span&gt; /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt; ...
Installing the CUDA Samples &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; /home/xxx&lt;span&gt; ...
Copying samples to &lt;/span&gt;/home/xxx/NVIDIA_CUDA-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.0_Samples now...
Finished copying samples.

&lt;/span&gt;===========
= Summary =
===========&lt;span&gt;

Driver:   Not Selected
Toolkit:  Installed &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt;
Samples:  Installed &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; /home/&lt;span&gt;jlu

Please make sure that        #&lt;span&gt;这个提示很重要，接下来必须照做
 &lt;/span&gt;&lt;/span&gt;-   PATH includes /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;/&lt;span&gt;bin
 &lt;/span&gt;-   LD_LIBRARY_PATH includes /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;/lib64, or, add /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;/lib64 to /etc/ld.so.conf and run ldconfig &lt;span&gt;as&lt;/span&gt; root
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step2：更改系统配置文件&lt;/p&gt;
&lt;p&gt;执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd ~&lt;span&gt;      #进入当前用户的主目录
vim &lt;/span&gt;~/.bashrc   #打开该用户的配置文件.bashrc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在打开的文件末尾添加如下指令&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export CUDA_HOME=/usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt;
export PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PATH:/usr/local/cuda-8.0/bin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
export LD_LIBRARY_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$LD_LIBRARY_PATH:/usr/local/cuda-8.0/lib64:/usr/local/cuda-8.0/extras/CUPTI/lib64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181011011817657-2059073068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存并退出文件，执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
source ~/.bashrc    #使配置文件立即生效  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.如果您想要使CUDA和后面的cuDNN对所有用户都可用，请对/etc/profile这个配置文件进行和上面相同的操作。&lt;/p&gt;
&lt;p&gt;2.CUPTI(CUDA Profiling Tools Interface)是一个针对CUDA应用程序的性能分析和跟踪工具，要安装TensorFlow，就必须将其地址&lt;span&gt; &lt;span&gt;/usr/local/cuda-8.0/extras/CUPTI/lib64&lt;/span&gt;&lt;/span&gt; 添加到环境变量中（如上图黄色框中的最后一句）。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;III. 测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依次执行下列命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.646153846154&quot;&gt;
&lt;pre&gt;
cd /home/xxx/NVIDIA_CUDA-&lt;span&gt;8&lt;/span&gt;.0_Samples/1_Utilities/&lt;span&gt;deviceQuery   #跳转到测试样例1所在的目录，如果您在安装过程中（见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#CUDA&quot;&gt;上文最后一段&lt;/a&gt;）将测试样例安装在其它位置，这里也要做出相应更改
&lt;/span&gt;&lt;span&gt;make&lt;/span&gt;&lt;span&gt;   #编译
.&lt;/span&gt;/deviceQuery   #执行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;见到类似下面的输出，表明安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181019173115189-1807399587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;至此，CUDA8.0安装完成。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;本小节参考资料：&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;a title=&quot;https://blog.csdn.net/weixin_41151963/article/details/79530722&quot; href=&quot;https://blog.csdn.net/weixin_41151963/article/details/79530722&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/weixin_41151963/article/details/79530722&lt;/a&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;a title=&quot;https://www.cnblogs.com/chay/p/8038251.html&quot; href=&quot;https://www.cnblogs.com/chay/p/8038251.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/chay/p/8038251.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;四、安装cuDNN6.0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;strong&gt;I. 下载安装文件&lt;/strong&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;访问网址&lt;a title=&quot;https://developer.nvidia.com/cudnn&quot; href=&quot;https://developer.nvidia.com/cudnn&quot; target=&quot;_blank&quot;&gt;https://developer.nvidia.com/cudnn&lt;/a&gt; ，点击Download cuDNN。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010204705256-482407822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面跳转后登录或注册。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010210807940-637657746.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010211033037-1906068037.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010205002822-1423033061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登陆后，按图示操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010211622242-530722595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                                          ▼&lt;/p&gt;
&lt;p&gt;                                                                                                                          ▼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010212444045-1798517881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010214118810-198379711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018221045376-2100399916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;                                                                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010215649754-48426630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：在上面倒数第二幅图绿色字“cuDNN v6.0 Library for Linux”上右击，在弹出的菜单中选择“复制链接地址”，在复制得到的地址前加上“wget”构成一条命令（如下），使用该命令可直接在目标机上在线下载安装包，详见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;第二节注2&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;developer.nvidia.com/compute/machine-learning/cudnn/secure/v6/prod/8.0_20170307/cudnn-8.0-linux-x64-v6.0-tgz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;II. 安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意到下载得到的文件有一个奇怪的后缀名(solitairetheme8,纸牌主题8，该文件在Windows下的图标就是纸牌)，所以首先要将文件重命名为.tgz文件。&lt;/p&gt;
&lt;p&gt;在.solitairetheme文件所在目录下依次执行下列命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cp&lt;/span&gt; cudnn-&lt;span&gt;8.0&lt;/span&gt;-linux-x64-v6.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.solitairetheme8   cudnn.tgz   #将文件重命名为cudnn.tgz
&lt;/span&gt;&lt;span&gt;tar&lt;/span&gt; -&lt;span&gt;zxvf cudnn.tgz   #解压
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; cuda/include/cudnn.h /usr/local/cuda/include/   #解压后会在当前目录下得到cuda/include目录，里面只有cudnn.h这一个文件，将其拷贝到CUDA安装目录下的include目录中，&lt;br/&gt;#如前所述，/usr/local/cuda是指向/usr/local/cuda-8.0(即CUDA安装目录)的符号链接
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; cuda/lib64/libcudnn* /usr/local/cuda/lib64/   #解压后会在当前目录下得到cuda/&lt;span&gt;include目录，里面有几个以libcudnn开头的文件，将这些文件全部拷贝到CUDA安装目录下的lib64目录下
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chmod&lt;/span&gt; a+r /usr/local/cuda/include/&lt;span&gt;cudnn.h   #使所有用户都具有read权限，这是以防万一，实际上在下发现解压后的文件本身就对所有用户具有read权限
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chmod&lt;/span&gt; a+r /usr/local/cuda/lib64/libcudnn*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;附：解压后的文件列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018221755597-2038061300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，cuDNN6.0安装完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、安装Bazel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;安装Bazel是为了编译TensorFlow做准备。如文章最开始的图片显示的那样，我们需要安装Bazel 0.5.4版本。&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong/&gt;&lt;strong&gt;I. 查看/卸载已有版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行命令&lt;/p&gt;

&lt;p&gt;若显示&lt;span&gt;bazel: command not found&lt;/span&gt; ，则说明目前系统上没有安装Bazel，直接转到&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#B_xz&quot;&gt;步骤II&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;若有如下输出，说明已安装Bazel0.5.4，直接进入“&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title6&quot;&gt;六、相关准备工作&lt;/a&gt;”小节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181011122550698-1573788519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若有不同于上述两种情况的输出（如显示安装的版本是0.17.2，并且有几个Warning），请按下述方法操作。&lt;/p&gt;
&lt;p&gt;执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;whereis&lt;/span&gt; bazel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181011220359896-888901798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;您将会看到类似上图中的输出，请使用rm -r命令将您看到的所有bazel目录及其子目录删除。然后再执行 &lt;span&gt;bazel &lt;/span&gt;命令，若看到&lt;span&gt;bazel: command not found&lt;/span&gt;，说明Bazel已卸载干净。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;II. 下载安装包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问网址&lt;a title=&quot;https://github.com/bazelbuild/bazel/releases?after=0.7.0&quot; href=&quot;https://github.com/bazelbuild/bazel/releases?after=0.7.0&quot; target=&quot;_blank&quot;&gt;https://github.com/bazelbuild/bazel/releases?after=0.7.0&lt;/a&gt; ，Ctrl+F搜索关键字&quot;0.5.4-installer-linux-x86_64.sh&quot;，如图，点击第一个下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181011223659197-645658904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.如果您在上述网址指向的网页中没有找到您想要的版本，请将页面拉至最底端，点击Previous或Next按钮（如下图）向前/后翻页，从0.17.2版本到0.1.0版本都能找到。&lt;/p&gt;
&lt;p&gt;                        &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181011224202385-1836196034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.在上面倒数第二幅图的下载链接（即蓝色字bazel-0.5.4-installer-linux-x86_64.sh）上右键，在弹出的菜单中选择“复制链接地址”，在复制得到的地址前加上“wget”构成一条命令(如下)，使用该命令可直接在目标机上在线下载安装包，详见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;第二节注2&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/bazelbuild/bazel/releases/download/0.5.4/bazel-0.5.4-installer-linux-x86_64.sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;III. 安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1：在bazel-0.5.4-installer-linux-x86_64.sh所在目录下依次执行如下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; &lt;span&gt;pkg-config zip g++ zlib1g-dev unzip&lt;/span&gt;&lt;span&gt; python   #安装依赖&lt;/span&gt;
&lt;span&gt;chmod&lt;/span&gt; +x bazel-&lt;span&gt;0.5&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-installer-linux-x86_64&lt;span&gt;.sh&lt;/span&gt;&lt;span&gt;   #增加执行权限
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; ./bazel-&lt;span&gt;0.5&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-installer-linux-x86_64.&lt;span&gt;sh&lt;/span&gt; --user   #安装      #The --user flag installs Bazel to the $HOME/bin(当前用户主目录/bin) directory on your system and sets the .bazelrc path to $HOME/.bazelrc.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step2：执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim ~/.bashrc   #打开当前用户的配置文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在打开的文件末尾添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
export PATH=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PATH:$HOME/bin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
source &lt;/span&gt;/root/.bazel/bin/bazel-complete.bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181019181537955-1805116599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存并退出文件，执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
source ~/.bashrc   #使配置文件立即生效
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：如果您想要使Bazel对所有用户都可用，请对/etc/profile这个配置文件进行和上面相同的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IV. 测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在任意目录下执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
bazel version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若有类似如下的输出，说明Bazel安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018200146587-1300346131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，Bazel安装完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、相关准备工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong/&gt;&lt;strong&gt;I. gcc降级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu安装时自带gcc，执行如下命令查看此gcc版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;gcc&lt;/span&gt; --version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如图 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181015222855564-277072422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译TensorFlow1.4.0需要gcc 4.x版本（如本文最开始的图片显示的那样，根据TensorFlow官网，需要4.8版本，但在下实测4.9版本也可以），如果您的系统的gcc版本是5.x或更高，需要降级到4.x版本（其实就是安装低版本的gcc并设置默认版本的过程）。由于在下没有实际做这一步工作，故不敢妄言，这里给出一些可能对您有用的链接：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.itread01.com/articles/1498658233.html&quot; href=&quot;https://www.itread01.com/articles/1498658233.html&quot; target=&quot;_blank&quot;&gt;https://www.itread01.com/articles/1498658233.html&lt;/a&gt; （推荐）&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.jianshu.com/p/f82a185f27d1&quot; href=&quot;https://www.jianshu.com/p/f82a185f27d1&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/f82a185f27d1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.cnblogs.com/in4ight/p/6626708.html&quot; href=&quot;https://www.cnblogs.com/in4ight/p/6626708.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/in4ight/p/6626708.html &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/u014696921/article/details/73770887&quot; href=&quot;https://blog.csdn.net/u014696921/article/details/73770887&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u014696921/article/details/73770887&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/ytusdc/article/details/77980915&quot; href=&quot;https://blog.csdn.net/ytusdc/article/details/77980915&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/ytusdc/article/details/77980915&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;II. 切换默认Python版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管TensorFlow官网表示TensorFlow1.4.0同时兼容python2和python3，但也有人表示，如果系统的默认python版本是python2，在编译TensorFlow时会出错（究竟会不会出错，在下并没有实践）。&lt;/p&gt;
&lt;p&gt;使用如下命令查询python默认版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
python --version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181019182411602-1381731669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您的系统的默认Python版本是2.7，您可以在编译TensorFlow前将默认版本切换到3.3~3.6(见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#bbpz&quot;&gt;软件版本配置&lt;/a&gt;)，或者等到发现使用Python2.7编译TensorFlow出错时再切换。由于在下的系统的默认Python版本是Python3.5，所以并没有执行切换默认Python版本的操作（很可能是之前其他人做了切换版本的工作），这里只给出一些可能对您有用的链接：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/CYM_LMY/article/details/78315139&quot; href=&quot;https://blog.csdn.net/CYM_LMY/article/details/78315139&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/CYM_LMY/article/details/78315139&lt;/a&gt;   （切换Python默认版本，下同）&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.jianshu.com/p/9d3033d1b26f&quot; href=&quot;https://www.jianshu.com/p/9d3033d1b26f&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/9d3033d1b26f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/fang_chuan/article/details/60958329&quot; href=&quot;https://blog.csdn.net/fang_chuan/article/details/60958329&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/fang_chuan/article/details/60958329&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/White_Idiot/article/details/78240298&quot; href=&quot;https://blog.csdn.net/White_Idiot/article/details/78240298&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/White_Idiot/article/details/78240298&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/u010426270/article/details/51059260&quot; href=&quot;https://blog.csdn.net/u010426270/article/details/51059260&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u010426270/article/details/51059260&lt;/a&gt;   （在线安装Python3.5并设置为默认）&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.python.org/downloads/source/&quot; href=&quot;https://www.python.org/downloads/source/&quot; target=&quot;_blank&quot;&gt;https://www.python.org/downloads/source/&lt;/a&gt;   （Python各版本安装包下载地址）&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://blog.51cto.com/4330156/1828604&quot; href=&quot;http://blog.51cto.com/4330156/1828604&quot; target=&quot;_blank&quot;&gt;http://blog.51cto.com/4330156/1828604&lt;/a&gt;   （编译安装Python）&lt;/p&gt;
&lt;p&gt;注：如果您是手动编译安装Python3（参考上面倒数第一个链接），在make前一定在安装包解压目录下使用如下命令将Python安装在/usr目录下（目的是为后边编译安装TensorFlow提供方便）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./configure --prefix=/usr
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装后，使用如下命令更新软连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rm&lt;/span&gt; /user/bin/&lt;span&gt;python
&lt;/span&gt;&lt;span&gt;ln&lt;/span&gt; -s /usr/bin/python3.&lt;span&gt;5&lt;/span&gt; /usr/bin/python
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，编译安装TensorFlow前的准备工作完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;七、编译安装TensorFlow&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I. 下载源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问网址 &lt;a title=&quot;https://github.com/tensorflow/tensorflow/releases?after=v1.7.0-rc1&quot; href=&quot;https://github.com/tensorflow/tensorflow/releases?after=v1.7.0-rc1&quot; target=&quot;_blank&quot;&gt;https://github.com/tensorflow/tensorflow/releases?after=v1.7.0-rc1&lt;/a&gt; ，页面跳转后Ctrl+F搜索关键字“TensorFlow 1.4.0”，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181017091536088-729912982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，可以点击第二个链接（划红线的）下载，也可以在链接上右击，在弹出的菜单中选择“复制链接地址”，在复制得到的地址前加上“wget”构成一条命令（如下），使用该命令可以直接在目标机上在线下载（参考&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;第二节注2&lt;/a&gt;）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/tensorflow/tensorflow/archive/v1.4.0.tar.gz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载后，将得到一个名为&lt;span&gt;v1.4.0.tar.gz&lt;/span&gt;的压缩文件，使用如下命令解压，解压后，将在解压目录下得到&lt;span&gt;tensorflow-1.4.0&lt;/span&gt;目录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tar&lt;/span&gt; -zxvf v&lt;span&gt;1&lt;/span&gt;.&lt;span&gt;4.0&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.如果您在上述网址指向的页面中没有找到您想要的版本，请将页面拉至最底端，点击&lt;span&gt;Previous&lt;/span&gt;或&lt;span&gt;Next&lt;/span&gt;按钮（如下图）向前/后翻页，翻页后在新页面查找。&lt;/p&gt;
&lt;p&gt;                                                                             &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181017100455559-1780028650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.TensorFlow官网教程（&lt;a title=&quot;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&quot; href=&quot;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&quot; target=&quot;_blank&quot;&gt;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&lt;/a&gt;）以及其它许多教程都使用git clone命令下载TensorFlow源码，这自然是可行的，但缺点是下载速度比wget方法至少慢一倍，所以这里不推荐。本人亲测，使用上述wget方法下载，解压后得到的源码和官网教程上使用git clone方法下载得到的源码完全一致。&lt;/p&gt;
&lt;p&gt;3.如果您使用wget方法下载源码，解压后将得到&lt;span&gt;tensorflow-1.4.0&lt;/span&gt;目录；如果使用git clone方法下载源码，将直接得到&lt;span&gt;tensorflow&lt;/span&gt;目录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;II. 编译&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1：安装TensorFlow Python依赖项&lt;/p&gt;
&lt;p&gt;根据您的Python版本执行下列命令之一&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; python-numpy python-dev python-pip python-wheel      #&lt;span&gt;for&lt;/span&gt; Python2.&lt;span&gt;7&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; python3-numpy python3-dev python3-pip python3-wheel      #&lt;span&gt;for&lt;/span&gt; Python3.x
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step2：其它准备&lt;/p&gt;
&lt;p&gt;在源码所在目录下执行下列命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd tensorflow           #如果您是用git clone方法下载的源码，使用该命令
#或
cd tensorflow&lt;/span&gt;-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;     #如果您是用wget方法下载，解压得到的源码，使用该命令
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; librdmacm-dev      #可选，在下实践发现，不加该命令，在编译源码时会报错，所以这里事先安装librdmacm-&lt;span&gt;dev安装包(简言之，librdmacm是一个通信接口，负责连接的建立和撤销)
bazel shutdown      #如果之前运行bazel而未关闭，在运行配置文件时会有警告“WARNING: Running Bazel server needs to be killed, because the startup options are different.”   
.&lt;/span&gt;/configure     #运行配置脚本
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step3：配置选项&lt;/p&gt;
&lt;p&gt;运行配置脚本后，会有一系列问题让您回答，下面逐条解释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.418436703483&quot;&gt;
&lt;pre&gt;
root@ubuntu-xxx:/usr/local/tensorflow# ./&lt;span&gt;configure
You have bazel &lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;&lt;span&gt; installed.
Please specify the location of python. [Default &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; /usr/bin/&lt;span&gt;python]:    &lt;span&gt;&lt;span&gt;#如果您是按照上面&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#qhbb&quot;&gt;&lt;span&gt;第六节II&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;进行操作的话，/usr/bin/python是一个指向系统默认版本的Python的软连接（见图3-7-1），所以这里&lt;span&gt;直接回车&lt;/span&gt;；&lt;/span&gt;&lt;/span&gt;
                                                                        #如果您的情况例外，请使用whereis python和ll命令查看python的安装位置（见图3-7-1）                                                                        

&lt;/span&gt;Found possible Python library paths:
  /usr/local/lib/python3.&lt;span&gt;5&lt;/span&gt;/dist-packages
  /usr/lib/python3/dist-packages
Please input the desired Python library path to use.  Default &lt;span&gt;is&lt;/span&gt; [/usr/local/lib/python3.&lt;span&gt;5&lt;/span&gt;/dist-packages]   &lt;span&gt;#上面两个目录都是Python库的位置，分别包含不同的库，在下&lt;span&gt;选的是第一个&lt;/span&gt;，理由参考&lt;/span&gt;&lt;a title=&quot;该网页&quot; href=&quot;https://stackoverflow.com/questions/122327/how-do-i-find-the-location-of-my-python-site-packages-directory&quot; target=&quot;_blank&quot;&gt;该网页&lt;/a&gt;上&lt;span&gt;David Hollander的回答（即第五个回答）&lt;/span&gt;
/usr/local/lib/python3.&lt;span&gt;5&lt;/span&gt;/dist-packages
Do you wish to build TensorFlow with jemalloc &lt;span&gt;as&lt;/span&gt; malloc support? [Y/n]: Y   &lt;span&gt;#jemalloc是个内存分配管理器，在下并不了解，见官网教程上选了Y，也就&lt;span&gt;选了Y&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;jemalloc as malloc support will be enabled for TensorFlow.&lt;/span&gt;

Do you wish to build TensorFlow with Google Cloud Platform support? [Y/n]: Y   &lt;span&gt;&lt;span&gt;#在下选Y只是为了测试选Y后影不影响后边的编译（实测选Y可以正常编译），如果您不需要该功能，&lt;/span&gt;建议选N&lt;/span&gt;
&lt;span&gt;Google Cloud Platform support will be enabled for TensorFlow.

Do you wish to build TensorFlow with Hadoop File System support? [Y/n]: Y   #同上
Hadoop File System support will be enabled for TensorFlow.

Do you wish to build TensorFlow with Amazon S3 File System support? [Y/n]: Y   #同上
Amazon S3 File System support will be enabled for TensorFlow.

Do you wish to build TensorFlow with XLA JIT support? [y/N]: Y   #同上
XLA JIT support will be enabled for TensorFlow.

Do you wish to build TensorFlow with GDR support? [y/N]: Y   #同上
GDR support will be enabled for TensorFlow.

Do you wish to build TensorFlow with VERBS support? [y/N]: Y   #同上
VERBS support will be enabled for TensorFlow.

Do you wish to build TensorFlow with OpenCL support? [y/N]: N   #这个&lt;span&gt;必须选N&lt;/span&gt;，否则会出错
No OpenCL support will be enabled for TensorFlow.

Do you wish to build TensorFlow with CUDA support? [y/N]: y   #这个&lt;span&gt;必须选y&lt;/span&gt;
CUDA support will be enabled for TensorFlow.
&lt;/span&gt;
&lt;span&gt;Please specify the CUDA SDK version you want to use, e.g. 7.0. [Leave empty to default to CUDA 8.0]:    #如果您的CUDA版本是8.0，请&lt;span&gt;直接回车&lt;/span&gt;，否则请输入您的CUDA版本


Please specify the location where CUDA 8.0 toolkit is installed. Refer to README.md for more details. [Default is /usr/local/cuda]:    #如果您是按本教程安装的CUDA，/usr/local/cuda是指向CUDA安装目录的软连接（见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#CUDA&quot;&gt;CUDA安装部分&lt;/a&gt;），所以这里&lt;span&gt;直接回车&lt;/span&gt;


Please specify the cuDNN version you want to use. [Leave empty to default to cuDNN 6.0]:    #如果您的cuDNN版本是6.0，请&lt;span&gt;直接回车&lt;/span&gt;，否则请输入您的cuDNN版本


Please specify the location where cuDNN 6 library is installed. Refer to README.md for more details. [Default is /usr/local/cuda]:   #如果您是按本教程安装的CUDA和cuDNN，请&lt;span&gt;直接回车
&lt;/span&gt;&lt;/span&gt;

Please specify a list of comma-separated Cuda compute capabilities you want to build with.
You can find the compute capability of your device at: &lt;a title=&quot;https://developer.nvidia.com/cuda-gpus&quot; href=&quot;https://developer.nvidia.com/cuda-gpus&quot; target=&quot;_blank&quot;&gt;https:&lt;span&gt;//&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;a title=&quot;https://developer.nvidia.com/cuda-gpus&quot; href=&quot;https://developer.nvidia.com/cuda-gpus&quot; target=&quot;_blank&quot;&gt;developer.nvidia.com/cuda-gpus&lt;/a&gt;.&lt;/span&gt;
Please note that each additional compute capability significantly increases your build time and binary size. [Default &lt;span&gt;is: 6.1&lt;/span&gt;]   #这个&lt;span&gt;一定要去上一行网址指向的网页去查&lt;/span&gt;您自己的GPU卡的计算能力，然后输入正确的数
                                                                                                                                 #在下之所以直接回车，是因为在下的GPU卡的计算能力恰好是6.1

Do you want to use clang &lt;span&gt;as&lt;/span&gt; CUDA compiler? [y/N]: N   #这个&lt;span&gt;必须选N&lt;/span&gt;，否则会出错
nvcc will be used &lt;span&gt;as&lt;/span&gt; CUDA compiler.

&lt;span&gt;Please specify which gcc should be used by nvcc as the host compiler. [Default is /usr/bin/gcc]:   #正常情况下，/usr/bin/gcc是一个指向gcc编译器的符号链接（见下图7-3-2），所以&lt;span&gt;直接回车&lt;/span&gt;
                                                                                                   #如果您的情况例外，请使用&lt;span&gt;whereis gcc&lt;/span&gt;和&lt;span&gt;ll&lt;/span&gt;命令查找您的gcc编译器的位置（见下图7-3-2）

Do you wish to build TensorFlow with MPI support? [y/N]: N   #这个&lt;span&gt;必须选N&lt;/span&gt;，否则会出错
No MPI support will be enabled for TensorFlow.&lt;/span&gt;

Please specify optimization flags to use during compilation when bazel option &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--config=opt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; specified [Default &lt;span&gt;is&lt;/span&gt; -march=native]:    #根据官网教程，&lt;span&gt;直接回车&lt;/span&gt;


Add &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--config=mkl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; to your bazel command to build with MKL support.
Please note that MKL on MacOS or windows &lt;span&gt;is &lt;/span&gt;still not supported.
If you would like to use a local MKL instead of downloading, please &lt;span&gt;set&lt;/span&gt; the environment variable &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TF_MKL_ROOT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; every time before build.
Configuration finished
root@ubuntu-xxx:/usr/local/tensorflow# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181017234739729-1719884841.png&quot; alt=&quot;&quot;/&gt;                     &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181017234928626-131335216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                  图7-3-1                                                                                                                                                                                              图7-3-2&lt;/p&gt;
&lt;p&gt;step4：正式编译&lt;/p&gt;
&lt;p&gt;在和上一步相同的目录下执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
bazel build --config=opt --config=cuda --copt=-mavx --copt=-msse4.&lt;span&gt;2&lt;/span&gt; --copt=-msse4.&lt;span&gt;1&lt;/span&gt; --copt=-msse3 --copt=-mavx2 --copt=-mfma &lt;span&gt;//&lt;/span&gt;&lt;span&gt;tensorflow/tools/pip_package:build_pip_package&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就进入漫长的编译过程，大概耗时15~30分钟，编译过程会占用大量的RAM，所以在编译时尽量不要运行其它程序。同时，编译过程中会输出大量语句，也会有许多Warning，但不要管，只有编译不停止，就没有问题。&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.上述编译命令比官网给的命令多出了许多参数，因为有资料显示使用这些选项编译安装的TensorFlow在运行TensorFlow程序时会加快CPU计算速度，实测表明加上这些参数并不会引起错误。更多详情请参考：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.xuite.net/abliou/linux/486757306-%E4%BD%BF%E7%94%A8tensorflow%E7%9A%84sse3+sse4.1+sse4.2%E6%8C%87%E4%BB%A4%E9%9B%86&quot; href=&quot;https://blog.xuite.net/abliou/linux/486757306-%E4%BD%BF%E7%94%A8tensorflow%E7%9A%84sse3+sse4.1+sse4.2%E6%8C%87%E4%BB%A4%E9%9B%86&quot; target=&quot;_blank&quot;&gt;https://blog.xuite.net/abliou/linux/486757306-%E4%BD%BF%E7%94%A8tensorflow%E7%9A%84sse3+sse4.1+sse4.2%E6%8C%87%E4%BB%A4%E9%9B%86&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/xxy0118/article/details/77731641&quot; href=&quot;https://blog.csdn.net/xxy0118/article/details/77731641&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/xxy0118/article/details/77731641&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://zhuanlan.zhihu.com/p/27286391&quot; href=&quot;https://zhuanlan.zhihu.com/p/27286391&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/27286391&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://pastebin.com/aQrxT4qZ&quot; href=&quot;https://pastebin.com/aQrxT4qZ&quot; target=&quot;_blank&quot;&gt;https://pastebin.com/aQrxT4qZ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.编译完成后会生成一个build_pip_package.sh文件，由当前目录下的符号链接&lt;span&gt;bazel-bin/tensorflow/tools/pip_package/build_pip_package&lt;/span&gt;指向，其中&lt;span&gt;bazel-bin&lt;/span&gt;也是一个符号链接，如图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018201453648-1125580995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;III. 安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1：构建安装包&lt;/p&gt;
&lt;p&gt;在和上一步相同的目录下执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg   #使用上一步生成的脚本构建安装文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该命令的执行不会花很多时间，该命令执行后会在&lt;span&gt;/tmp/tensorflow_pkg&lt;/span&gt;目录下生成一个.whl文件，请使用  &lt;span&gt;ls /tmp/tensorflow_pkg&lt;/span&gt;  命令查看文件的名称，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018111222420-1127872513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step2：正式安装&lt;/p&gt;
&lt;p&gt;在和上一步相同的目录下执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; pip &lt;span&gt;install&lt;/span&gt; /tmp/tensorflow_pkg/tensorflow-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-cp35-cp35m-linux_x86_64.whl   #这里的文件名要和上图中查到的文件名相同
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装过程也会持续一段时间，有时看着好像是卡住了，不要担心，过一会进度条就会往前走，请您耐心等待。&lt;/p&gt;
&lt;p&gt;IV&lt;strong&gt;. 测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在任意目录下依次执行下列命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;python
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里会输出python的版本信息，见下图&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; hello = tf.constant(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello, TensorFlow!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; sess =&lt;span&gt; tf.Session()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里会输出GPU的相关信息，表明TensorFlow是在GPU上运行的，见下图&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; sess.run(hello)
b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello, TensorFlow!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; a = tf.constant(10&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; b = tf.constant(22&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; sess.run(a+&lt;span&gt;b)
&lt;/span&gt;32
&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若有类似下图的输出，表明TensorFlow安装成功。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018194841050-529109670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，TensorFlow安装完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;写在后面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个环境搭建过程参考了许多资料，在上文中已一一附上链接，再次对各位前辈表示感谢！在下才疏学浅，能力有限，文中难免有错误疏漏之处，恳请您批评指正，您的批评是在下进步的源泉和动力！未尽事宜：2661048959@qq.com。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#ml&quot;&gt;回到目录&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 11:23:00 +0000</pubDate>
<dc:creator>同勉共进</dc:creator>
<og:description>本文是一篇保姆级教程，步骤非常详细，叙述了在Ubuntu16.04 Server下安装CUDA8.0，cuDNN6.0，Bazel0.5.4，以及源码编译安装TensorFlow1.4.0(GPU版)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zpcdbky/p/9757821.html</dc:identifier>
</item>
<item>
<title>.Net并行编程（一）-TPL之数据并行 - 范存威</title>
<link>http://www.cnblogs.com/fancunwei/p/9818244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9818244.html</guid>
<description>&lt;p&gt;许多个人计算机和工作站都有多个CPU核心，可以同时执行多个线程。利用硬件的特性，使用并行化代码以在多个处理器之间分配工作。&lt;br/&gt;&lt;img title=&quot;.NetFramework并行编程架构图&quot; src=&quot;https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/media/tpl-architecture.png&quot; alt=&quot;.NetFramework并行编程架构图&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;文件批量上传&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;并行上传单个文件。也可以把一个文件拆成几段分开上传，加快上传速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;数据分批计算&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如几百万数据可以拆成许多无关联的部分，并行计算处理。最后聚合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;数据推送&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;也是需要将数据拆解后，并行推送。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果在一个循环内在每次迭代只执行少量工作或者它没有运行多次迭代，那么并行化的开销可能会导致代码运行的更慢。使用并行之前，应该对线程（锁，死锁，竞争条件）应该有基本的了解。&lt;/p&gt;
&lt;h2 id=&quot;4&quot;&gt;Parallel.For&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;        &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从下图对比接口可以看出当循环体内方法执行时间很短时，并行时间反而更长。这块会有更细致的补充。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;FormalDirRun-----&lt;span class=&quot;hljs-number&quot;&gt;-20 files, &lt;span class=&quot;hljs-number&quot;&gt;255618 bytes,time:&lt;span class=&quot;hljs-number&quot;&gt;0,Dir:E:\LearnWall\orleans
ParallelForDirRun&lt;span class=&quot;hljs-number&quot;&gt;-20 files, &lt;span class=&quot;hljs-number&quot;&gt;255618 bytes,time:&lt;span class=&quot;hljs-number&quot;&gt;6,Dir:E:\LearnWall\orleans&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们追加一些延时操作如Thread.Sleep,但这应该不是好好例子...但我只想演示效果就行了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;1000);&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看结果得到，当方法内有阻塞延时一秒后，两者速度错了七倍。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;FormalDirRun-----&lt;span class=&quot;hljs-number&quot;&gt;-20 files, &lt;span class=&quot;hljs-number&quot;&gt;255618 bytes,time:&lt;span class=&quot;hljs-number&quot;&gt;20011,Dir:E:\LearnWall\orleans
ParallelForDirRun&lt;span class=&quot;hljs-number&quot;&gt;-20 files, &lt;span class=&quot;hljs-number&quot;&gt;255618 bytes,time:&lt;span class=&quot;hljs-number&quot;&gt;3007,Dir:E:\LearnWall\orleans&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/how-to-write-a-simple-parallel-for-loop#matrix-and-stopwatch-example&quot;&gt;矩阵和秒表示例&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5&quot;&gt;Parallel.ForEach&lt;/h2&gt;
&lt;p&gt;为了并行速度的最大化，我们应该尽量减少在并行内对共享资源的访问，如Console.Write,文件日志等...但这里为了显示效果，就用了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;ParallelForEachDirRun(&lt;span class=&quot;hljs-params&quot;&gt;)
        {
            &lt;span class=&quot;hljs-keyword&quot;&gt;long totalSize = &lt;span class=&quot;hljs-number&quot;&gt;0;
            &lt;span class=&quot;hljs-keyword&quot;&gt;var dir = &lt;span class=&quot;hljs-string&quot;&gt;@&quot;E:\LearnWall\orleans&quot;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;name:.gitignore
name:build.sh
.
.
.
name:TestAll.cmd
ParallelForEachDirRun&lt;span class=&quot;hljs-number&quot;&gt;-20 files, &lt;span class=&quot;hljs-number&quot;&gt;255618 bytes,Time:&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6&quot;&gt;Parallel.For 线程局部变量&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;ParallelForForThreadLocalVariables(&lt;span class=&quot;hljs-params&quot;&gt;)
        {
            &lt;span class=&quot;hljs-keyword&quot;&gt;int[] nums = Enumerable.Range(&lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;1000000).ToArray();
            &lt;span class=&quot;hljs-keyword&quot;&gt;long total = &lt;span class=&quot;hljs-number&quot;&gt;0;

            &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The total is 499,999,509,000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个For方法的前两个参数指定开始和结束迭代值。在此方法的重载中，第三个参数是初始化本地状态的位置。在此上下文中，本地状态表示一个变量，其生命周期从当前线程上的循环的第一次迭代之前延伸到最后一次迭代之后。&lt;/p&gt;
&lt;p&gt;第三个参数的类型是Func ，其中TResult是将存储线程本地状态的变量的类型。它的类型由调用泛型For （Int32，Int32，Func ，Func ，Action ）方法时提供的泛型类型参数定义，在这种情况下是Int64。type参数告诉编译器将用于存储线程局部状态的临时变量的类型。在此示例中，表达式() =&amp;gt; 0（或Function() 0在Visual Basic中）将线程局部变量初始化为零。如果泛型类型参数是引用类型或用户定义的值类型，则表达式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;() =&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new MyClass()  &lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这块内容比较繁琐，一句话来说：前两个参数是开始和结束值，第三个是根据For泛型而初始化的值。我其实也没看太懂这块。.net Framework源码如下,.netcore的不知道：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static ParallelLoopResult For&amp;lt;TLocal&amp;gt;(
            &lt;span class=&quot;hljs-keyword&quot;&gt;int fromInclusive, &lt;span class=&quot;hljs-keyword&quot;&gt;int toExclusive,
            Func&amp;lt;TLocal&amp;gt; localInit,
            Func&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int, ParallelLoopState, TLocal, TLocal&amp;gt; body,
            Action&amp;lt;TLocal&amp;gt; localFinally)
        {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (body == &lt;span class=&quot;hljs-literal&quot;&gt;null)
            {
                &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new ArgumentNullException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;body&quot;);
            }
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (localInit == &lt;span class=&quot;hljs-literal&quot;&gt;null)
            {
                &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new ArgumentNullException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;localInit&quot;);
            }
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (localFinally == &lt;span class=&quot;hljs-literal&quot;&gt;null)
            {
                &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new ArgumentNullException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;localFinally&quot;);
            }
 
            &lt;span class=&quot;hljs-keyword&quot;&gt;return ForWorker(
                fromInclusive, toExclusive, s_defaultParallelOptions,
                &lt;span class=&quot;hljs-literal&quot;&gt;null, &lt;span class=&quot;hljs-literal&quot;&gt;null, body, localInit, localFinally);
        }
        
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;7&quot;&gt;Parallel.ForEach线程局部变量&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;       &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ForEach的源码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;        &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;8&quot;&gt;取消 Parallel.ForEach或Parallel.For&lt;/h2&gt;
&lt;p&gt;通过CancellationTokenSource来获取token&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;CancellationTokenSource cts = new CancellationTokenSource();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过ParallelOptions.CancellationToken属性来控制取消状态。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;ParallelOptions po = new ParallelOptions();&lt;/p&gt;
&lt;p&gt;po.CancellationToken = cts.Token;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过Parallel.For或Foreach的ParallelOptions值来控制并行内方法的取消。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int[] nums = Enumerable.Range(&lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;10000000).ToArray();
            CancellationTokenSource cts = &lt;span class=&quot;hljs-keyword&quot;&gt;new CancellationTokenSource();

            &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下，键盘输入c时，并行取消。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1937.41838537782 on &lt;span class=&quot;hljs-number&quot;&gt;7
&lt;span class=&quot;hljs-number&quot;&gt;2739.95711645274 on &lt;span class=&quot;hljs-number&quot;&gt;8
&lt;span class=&quot;hljs-number&quot;&gt;2501.40660429287 on &lt;span class=&quot;hljs-number&quot;&gt;9
&lt;span class=&quot;hljs-number&quot;&gt;2958.47798707376 on &lt;span class=&quot;hljs-number&quot;&gt;10
.
.
.
press any key to exit111
The operation was canceled.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;9&quot;&gt;捕获并行体内的异常&lt;/h2&gt;
&lt;p&gt;示例方法采用ConcurrentQueue来接收异常集合，最后抛出一个聚合异常AggregateException。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;var exceptions = new ConcurrentQueue();&lt;/p&gt;
&lt;p&gt;exceptions.Enqueue(e);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;外部调用&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/system/AggregateException.cs,96eb05ad168f3513,references&quot;&gt;AggregateException.Flatten&lt;/a&gt;方法获取异常信息。&lt;/p&gt;
&lt;p&gt;这为我以后捕获异常提供了一个好思路。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;        &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;10&quot;&gt;对微小执行体提速&lt;/h2&gt;
&lt;p&gt;当Parallel.For循环有一个很快的执行体，它可能比同等顺序循环执行更慢。较慢的性能是由分区数据所涉及的开销和每次循环迭代调用委托的成本引起的。为了解决这种情况，Partitioner类提供了Partitioner.Create方法，该方法使您能够为委托主体提供顺序循环，以便每个分区仅调用一次委托，而不是每次迭代调用一次。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;var rangePartitioner = Partitioner.Create(0, source.Length);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;        &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fancunwei/CsharpFanDemo&quot;&gt;CsharpFanDemo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本篇文章沿着微软官方文档步骤熟悉了第一部分数据并行的用法。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Parallel.For和Parallel.ForEach实现并行。&lt;/p&gt;
&lt;p&gt;Parallel.For和Parallel.ForEach线程局部变量。&lt;/p&gt;
&lt;p&gt;取消并行ParallelOptions.CancellationToken&lt;/p&gt;
&lt;p&gt;捕捉异常ConcurrentQueue累加并行体内的异常，外部接收。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont655687.i1.644b374fqT9gMX&quot;&gt;加速Partitioner.Create&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont655687.i2.644b374fqT9gMX&quot;&gt;感谢观看！&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 11:10:00 +0000</pubDate>
<dc:creator>范存威</dc:creator>
<og:description>前言 许多个人计算机和工作站都有多个CPU核心，可以同时执行多个线程。利用硬件的特性，使用并行化代码以在多个处理器之间分配工作。 应用场景 文件批量上传 并行上传单个文件。也可以把一个文件拆成几段分开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9818244.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务系列基础文章索引（目录导航Final版） - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index_final.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index_final.html</guid>
<description>&lt;p&gt;　　&lt;img title=&quot;ASP.NET Core&quot; src=&quot;https://ask.qcloudimg.com/draft/2719971/z14qynhty7.png?imageView2/2/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　今年从原来的Team里面被抽出来加入了新的Team，开始做Java微服务的开发工作，接触了Spring Boot, Spring Cloud等技术栈，对微服务这种架构有了一个感性的认识。虽然只做了两个月的开发工作，但是对微服务架构的兴趣却没有结束，又因为自己的.NET背景（虽然对.NET的生态有点恨铁不成钢），想要探索一下在.NET平台下的微服务架构的可行性，也准备一些材料作为分享的素材。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://github.com/dncNew/dncNew/raw/master/img/gift1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　幸运的是，在&lt;a href=&quot;https://github.com/dncto/dnc/blob/master/README.md&quot; target=&quot;_blank&quot;&gt;.NET Core首届在线峰会&lt;/a&gt;上，看到了很多前辈的分享，也增强了自己要摸索和实践.NET Core微服务架构的决心。因此，站在各位前辈的肩膀上（详见第四部分的学习资料），我学习并总结了这个系列的文章，主要面向有.NET Web开发背景（本系列不会主要讲解.NET Core，不过不会阻碍你的阅读），没有接触过或者很少接触微服务架构的初级开发童鞋，文中介绍的开源技术也不一定是最佳的选择，事实上混合式架构（Linux+Windows+开源组合）与Docker+K8S的组合已经成了现在主流企业级和互联网项目的（默认）标准，重点是大家转变这个思路，拥抱Open Source，拥抱Cloud，也拥抱.NET Core，才会让.NET的生态好起来。鲁迅先生说，“&lt;strong&gt;&lt;em&gt;世上本无路，走的人多了也就成了路&lt;/em&gt;&lt;/strong&gt;”，对于.NET生态也一样，只有我们拥抱的人（这里主要指使用.NET相关开源技术的人）多了，也才会有好的生态，特与君共勉。当然，这里并不是说要抱死.NET，或者鼓吹.NET多么好，没有绝对好的技术栈，只有刚刚好的业务需求，爱.NET Core，也不排斥Java等其他技术栈，相互合作，共同构建，脱离微软（这里指广义上的老一代微软全家桶：ASP.NET+MSSQL+WindowsServer等），拥抱开源，任重而道远！&lt;/p&gt;
&lt;p&gt;　　此外，鉴于个人时间和精力有限，以及其他园友在特定领域已经取得的相关学习成果，我还会&lt;em&gt;&lt;strong&gt;不定期收集一些其他园友的系列文章放在这个索引里边&lt;/strong&gt;&lt;/em&gt;，方便大家快速定位查看学习。&lt;/p&gt;
&lt;p&gt;　　最后，由于个人的职业规划，我即将离开现在的公司（当然，并不是说现在的公司不好，而是个人对.NET的初恋情结）去一家新的公司去实践.NET Core，使用开源技术（有可能会给园子里的开源项目提Issue，也尽力积极提PR），实践微服务，实践架构设计，后续也会实践大数据，去经历一些之前经历不到的路程，也希望可以在后续分享一些&lt;strong&gt;&lt;em&gt;实践系列的文章&lt;/em&gt;&lt;/strong&gt;到博客园。如果有成都地区的园友想要来实践.NET Core的，也可以联系我，我司也在招聘优秀的.NET程序猿来&lt;strong&gt;&lt;span&gt;一起搞事情&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;2.1 服务发现&amp;amp;注册&amp;amp;通信&lt;/h2&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/9124985.html&quot; target=&quot;_blank&quot;&gt;基于Consul实现服务治理（Part 1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/9148034.html&quot; target=&quot;_blank&quot;&gt;基于Consul实现服务治理（Part 2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/microservice_communication_rest_and_rpc_foundation.html&quot; target=&quot;_blank&quot;&gt;服务间的通信调用方式（REST and RPC）&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2.2 熔断&amp;amp;降级&lt;/h2&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/9159644.html&quot; target=&quot;_blank&quot;&gt;基于Polly+AspectCore实现熔断与降级机制&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2.3 API网关&lt;/h2&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/api_gateway_ocelot_foundation_01.html&quot; target=&quot;_blank&quot;&gt;基于Ocelot实现API网关服务（Part 1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/api_gateway_ocelot_foundation_02.html&quot; target=&quot;_blank&quot;&gt;基于Ocelot实现API网关服务（Part 2）&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2.4 统一验证&amp;amp;授权&lt;/h2&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_01.html&quot; target=&quot;_blank&quot;&gt;基于IdentityServer实现授权与验证服务（Part 1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_02.html&quot; target=&quot;_blank&quot;&gt;基于IdentityServer实现授权与验证服务（Part 2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/integration_authentication-authorization_service_foundation.html&quot; target=&quot;_blank&quot;&gt;基于Ocelot+IdentityServer实现统一验证与授权服务&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;其他好文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/8119928.html&quot;&gt;IdentityServer4 中文文档与实战&lt;/a&gt;（from 晓晨Master 李志强）&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/aspnetcore-authentication.html&quot;&gt;ASP.NET Core 中的那些认证中间件及一些重要知识点&lt;/a&gt; （from savorboard 杨晓东）&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/cgzl/default.html?page=11&quot; target=&quot;_blank&quot;&gt;使用IdentityServer4建立AuthorizationServer系列文章&lt;/a&gt;（from 草根专栏 杨旭）&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/axzxs2001/p/9253495.html&quot;&gt;Swagger如何访问Ocelot中带权限验证的API&lt;/a&gt; （from axzxs2001 桂素伟）&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/axzxs2001/p/9250588.html&quot;&gt;Ocelot.JwtAuthorize：一个基于网关的Jwt验证包&lt;/a&gt; （from axzxs2001 桂素伟）&lt;/p&gt;
&lt;h2&gt;2.5 分布式追踪&amp;amp;日志&lt;/h2&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/ocelot_and_butterfly_tracing_foundation.html&quot; target=&quot;_blank&quot;&gt;基于Ocelot+Butterfly实现分布式追踪&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/exceptionless_foundation_and_quick_start.html&quot; target=&quot;_blank&quot;&gt;基于Exceptionless实现分布式日志记录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Skywalking：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/asp-net-core-skywalking.html&quot;&gt;在 ASP.NET Core 中集成 Skywalking APM&lt;/a&gt; （from savorboard 杨晓东）&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/liuhaoyang/p/skywalking-dotnet-v02-release.html&quot; target=&quot;_blank&quot;&gt;Apache SkyWalking 为.NET Core带来开箱即用的分布式追踪和应用性能监控&lt;/a&gt; （from Lemon 刘浩杨）&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/huangxincheng/p/9666930.html&quot;&gt;使用docker-compose 一键部署你的分布式调用链跟踪框架Skywalking&lt;/a&gt; （from 一线码农 黄星辰）&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;更多Skywalking分享&lt;/em&gt;：&lt;a href=&quot;https://github.com/OpenSkywalking/Community&quot; target=&quot;_blank&quot;&gt;https://github.com/OpenSkywalking/Community&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://camo.githubusercontent.com/4ac940361b7345156ff71aa21efdb42a449e67d7/68747470733a2f2f736b7977616c6b696e67746573742e6769746875622e696f2f706167652d7265736f75726365732f332e302f736b7977616c6b696e672e706e67&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.6 统一性能监控&lt;/h2&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/integrated_performance_monitoring_foundation.html&quot; target=&quot;_blank&quot;&gt;基于App.Metrics+InfluxDB+Grafana实现统一性能监控&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2.7 数据一致性&amp;amp;事件总线&lt;/h2&gt;
&lt;p&gt;　　&lt;a title=&quot;EasyNetQ&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/aspnetcore_easynetq_basicdemo_foundation.html&quot; target=&quot;_blank&quot;&gt;基于EasyNetQ使用RabbitMQ消息队列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;MassTransit-Part 1&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/dnc_microservice_masstransit_foundation_part1.html&quot; target=&quot;_blank&quot;&gt;基于MassTransit实现数据最终一致性（Part 1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;part 2&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/dnc_microservice_masstransit_foundation_part2.html&quot; target=&quot;_blank&quot;&gt;基于MassTransit实现数据最终一致性（Part 2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/9363244.html&quot; target=&quot;_blank&quot;&gt;基于开源项目CAP的初步使用与数据最终一致性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;CAP：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/cap-video-1.html&quot; target=&quot;_blank&quot;&gt;如何在你的项目中集成CAP（手把手视频教程）&lt;/a&gt;（from savorboard 杨晓东）&lt;/p&gt;
&lt;h2&gt;2.8 统一配置中心&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://github.com/ctripcorp/apollo/raw/master/apollo-portal/src/main/resources/static/img/logo-detail.png&quot; alt=&quot;&quot; width=&quot;2554&quot; height=&quot;674&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;Apollo&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/9419379.html&quot; target=&quot;_blank&quot;&gt;基于Apollo实现统一配置中心&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2.9 Docker &amp;amp; CI/CD&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726221105300-1650411740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;asp.net core on docker&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/aspnetcore_on_docker_foundation.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on Docker (部署ASP.NET Core到Docker)&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/CD_foundation_based_on_jenkins_and_docker.html&quot;&gt;基于Jenkins+Docker实现持续部署（Part 1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　基于Jenkins+Docker实现持续部署（Part 2）&lt;em&gt;（正在编写中ing...）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;其他好文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/8629165.html&quot;&gt;ASP.NET Core &amp;amp; Docker &amp;amp; Jenkins 零基础持续集成&lt;/a&gt;（from 晓晨Master 李志强）&lt;/p&gt;
&lt;h2&gt;2.10 与Spring Cloud的集成&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://camo.githubusercontent.com/59a8241f1fc23cbacab85418a54e1c8502297581/68747470733a2f2f7777772e636e626c6f67732e636f6d2f696d616765732f636e626c6f67735f636f6d2f656469736f6e63686f752f313236303836372f6f5f6c6f676f2d62616e6e65722e504e47&quot; alt=&quot;SteeltoeOSS&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/dotnet_core_microservice_integrate_with_springcloud_eureka.html&quot;&gt;基于Steeltoe使用Spring Cloud Eureka实现服务注册与发现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/dotnet_core_microservice_integrate_with_springcloud_zuul.html&quot;&gt;基于Steeltoe集成Spring Cloud Zuul实现统一API网关&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/dotnet_core_microservice_integrate_with_springcloud_hystrix.html&quot;&gt;基于Steeltoe使用Spring Cloud Hystrix熔断保护与可视化监控&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/dotnet_core_microservice_integrate_with_springcloud_config.html&quot; target=&quot;_blank&quot;&gt;基于Steeltoe使用Spring Cloud Config统一管理配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/dotnet_core_microservice_integrate_with_zipkin.html&quot; target=&quot;_blank&quot;&gt;基于Steeltoe使用Zipkin实现分布式追踪&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;示例代码：&lt;/em&gt;&lt;a href=&quot;https://github.com/Manulife-Chengdu/Microservice.PoC.Steeltoe&quot; target=&quot;_blank&quot;&gt;https://github.com/Manulife-Chengdu/Microservice.PoC.Steeltoe&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2.11 eShopOnContainers架构分析&lt;/h2&gt;
&lt;p&gt;　　《.NET微服务：容器化.NET应用架构指南》学习笔记&lt;em&gt;（正在编写中ing...）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　下面的系列文章来自一位朋友：&lt;a href=&quot;https://www.cnblogs.com/sheng-jie&quot; target=&quot;_blank&quot;&gt;圣杰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　①  &lt;a href=&quot;https://www.cnblogs.com/sheng-jie/p/9789180.html&quot;&gt;eShopOnContainers 知多少[1]：总体概览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　②  &lt;a href=&quot;https://www.cnblogs.com/sheng-jie/p/9795996.html&quot;&gt;eShopOnContainers 知多少[2]：Run起来&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2.12 其他&lt;/h2&gt;
&lt;p&gt;　　下面的系列文章来自一位园友：&lt;a href=&quot;https://www.cnblogs.com/malaoko&quot; target=&quot;_blank&quot;&gt;曹剑&lt;/a&gt;，这个系列文章把微服务的最重要的内容过了一遍。&lt;/p&gt;
&lt;p&gt;　　①  &lt;a href=&quot;https://www.cnblogs.com/malaoko/p/9279594.html&quot;&gt;微服务实战(一)：落地微服务架构到直销系统(什么是微服务)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　②  &lt;a href=&quot;https://www.cnblogs.com/malaoko/p/9316070.html&quot;&gt;微服务实战(二)：落地微服务架构到直销系统(构建消息总线框架接口)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　③  &lt;a href=&quot;https://www.cnblogs.com/malaoko/p/9355731.html&quot;&gt;微服务实战(三)：落地微服务架构到直销系统(构建基于RabbitMq的消息总线)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　④  &lt;a href=&quot;https://www.cnblogs.com/malaoko/p/9388833.html&quot;&gt;微服务实战(四)：落地微服务架构到直销系统(将生产者与消费者接入消息总线)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑤  &lt;a href=&quot;https://www.cnblogs.com/malaoko/p/9433083.html&quot;&gt;微服务实战(五)：落地微服务架构到直销系统(构建高性能大并发系统)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑥  &lt;a href=&quot;https://www.cnblogs.com/malaoko/p/9588623.html&quot;&gt;微服务实战(六)：落地微服务架构到直销系统(事件存储)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑦  &lt;a href=&quot;https://www.cnblogs.com/malaoko/p/9709801.html&quot;&gt;微服务实战(七)：落地微服务架构到直销系统(实现命令与命令处理器)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑧  &lt;a href=&quot;https://www.cnblogs.com/malaoko/p/9760322.html&quot;&gt;微服务实战(八)：落地微服务架构到直销系统(服务高可用性)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑨  &lt;a href=&quot;https://www.cnblogs.com/malaoko/p/9804222.html&quot;&gt;微服务实战(九)：落地微服务架构到直销系统(回顾总结)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里分享一些学习.NET Core与微服务的学习资料：&lt;/p&gt;
&lt;p&gt;　　①  杨中科，&lt;a href=&quot;https://www.rupeng.com/News/9/5522.shtml&quot; target=&quot;_blank&quot;&gt;.NET Core微服务基础课程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　②  张善友，&lt;a href=&quot;http://v.huya.com/play/30109053.html&quot; target=&quot;_blank&quot;&gt;NanoFabric简介（DNC在线峰会）&lt;/a&gt;，NanoFabric GitHub: &lt;a href=&quot;https://github.com/geffzhang/NanoFabric&quot; target=&quot;_blank&quot;&gt;https://github.com/geffzhang/NanoFabric&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　③  桂素伟，&lt;a href=&quot;http://edu.51cto.com/course/13342.html&quot; target=&quot;_blank&quot;&gt;.NET Core微服务课程&lt;/a&gt;，基于.NET Core的微服务示例 GitHub: &lt;a href=&quot;https://github.com/axzxs2001/HisMicroserviceSample&quot; target=&quot;_blank&quot;&gt;https://github.com/axzxs2001/HisMicroserviceSample&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　④  刘腾飞（Jesse），&lt;a href=&quot;http://video.jessetalk.cn/course/5&quot; target=&quot;_blank&quot;&gt;ASP.NET Core分布式项目实战课程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑤  杨波，极客时间课程-&lt;a href=&quot;https://time.geekbang.org/course/intro/84&quot; target=&quot;_blank&quot;&gt;微服务架构实战160讲&lt;/a&gt; （此课程主要以Java技术栈讲解，但可以学习很多通用的知识点和思想）&lt;/p&gt;
&lt;p&gt;　　⑥  Microsoft，&lt;a href=&quot;http://aka.ms/MicroservicesEbook&quot; target=&quot;_blank&quot;&gt;.NET微服务:容器化.NET应用架构指南&lt;/a&gt; （建议想要应用.NET Core微服务架构的童鞋&lt;strong&gt;必读&lt;/strong&gt;此书），示例项目eShopOnContainers GitHub: &lt;a href=&quot;https://github.com/dotnet-architecture/eShopOnContainers%20&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet-architecture/eShopOnContainers &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180628001326451-2034074258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　......&lt;/p&gt;
&lt;p&gt;　　除此之外，每篇文章后面都有参考资料，也都是值得学习的资料。&lt;/p&gt;

&lt;p&gt;下面列两个基于Java技术栈的微服务框架学习示例，都是由我完整学习过的示例总结：&lt;/p&gt;
&lt;p&gt;　　①  &lt;a title=&quot;Spring Boot&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/java_spring_boot_foundation_demos.html&quot; target=&quot;_blank&quot;&gt;Spring Boot 1.5.x 基础学习示例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　②  &lt;a title=&quot;spring cloud&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/java_spring_cloud_foundation_sample_list.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud 微服务架构基础学习笔记与示例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img title=&quot;Spring Cloud&quot; src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180822202553841-1217264857.jpg&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;&lt;em&gt;写在最后：&lt;/em&gt;&lt;/strong&gt;学习与码字不易，需要花费我很多的个人时间和精力，&lt;span&gt;如果你能点个&lt;strong&gt;赞&lt;/strong&gt;&lt;/span&gt;，可以更加激励我的学习和分享，谢谢！&lt;/h4&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 19 Oct 2018 10:31:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>一、为啥要总结和收集这个系列？ 今年从原来的Team里面被抽出来加入了新的Team，开始做Java微服务的开发工作，接触了Spring Boot, Spring Cloud等技术栈，对微服务这种架构有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index_final.html</dc:identifier>
</item>
<item>
<title>docker下使用selenium+testng实现web自动化 - 不能使用本名</title>
<link>http://www.cnblogs.com/CMFacebook/p/9817357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CMFacebook/p/9817357.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Windows下selenium+testng的web自动化环境搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;做过自动化的人，肯定对selenium web环境的搭建非常熟悉了，特别是selenium在java中的使用。&lt;/p&gt;
&lt;p&gt;先搭建好安装好JDK，配置好java开发环境（这个如果还是不知怎么操作的话可是要打PP了）。然后从官网下载对应selenium的jar包，加载到项目里；或者是使用maven，修改pom.xml文件直接加载selenium的依赖包即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
2 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.seleniumhq.selenium&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
3 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;selenium-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
4 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.14.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
5 &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着加上对应的浏览器驱动文件，就基本搞定环境了，可以开始自动化测试代码之路了。&lt;/p&gt;
&lt;p&gt;当然大家在编写代码的过程中也会用到现在流行的单元测试框架testng。如何在这基础上增加testng环境？其实这也不是什么难事，在testng的官网（https://testng.org/doc/index.html）提供了Eclipse、IEDA等编辑器下如何安装插件，比如Eclipse直接进入Market搜索testng安装即可，使用maven则需要在pom.xml中添加依赖包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;repositories&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
2 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;repository&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
3 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jcenter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
4 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;bintray&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
5 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://jcenter.bintray.com&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
6 &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;repository&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
7 &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;repositories&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
8 
9 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
10 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.testng&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
11 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;testng&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
12 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
13 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
14 &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;无脑等待下载安装完成，后续就是写代码了，然后就可以自由的挥洒了。&lt;br/&gt;但是今天要介绍的不是上面这些，这种环境的搭建非常简单，大多数人其实都会，坑也不多，只是个代码环境而已。&lt;/p&gt;
&lt;p&gt;我们这次要处理的麻烦事是什么呢？在现在日益发达的docker模式下，上述的编译环境没法在linux系统上跑了，没了代码编辑器、没了界面、也没了浏览器，那应该如何操作呢？让我们来看一看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker的安装与使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样的，还是需要java+selenium+testng，只不过环境从windows变成了linux。&lt;/p&gt;
&lt;p&gt;关于docker的使用这里稍稍给大家介绍一下安装、启动过程：&lt;/p&gt;
&lt;p&gt;直接使用yum install docker命令安装；&lt;/p&gt;
&lt;p&gt;service docker start启动docker服务；&lt;/p&gt;
&lt;p&gt;然后docker pull centos搞定centos版本下最基本的docker镜像；&lt;/p&gt;
&lt;p&gt;通过docker images命令可以列出当前所有镜像；&lt;/p&gt;
&lt;p&gt;查看到linux的镜像后，使用docker run -it -d 镜像名称，让linux的容器跑起来（注意-it -d的参数，如果没有容器一闪而过就挂起了）；&lt;/p&gt;
&lt;p&gt;进入容器可先通过docker ps查看当前所有运行的容器，如果查不到，说明容器并没有启动，或者已经关闭了,docker ps会列出容器的id;&lt;/p&gt;
&lt;p&gt;使用docker attach 容器id即可登录到容器中的linux了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker下java环境搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器里的linux其实和普通的linux操作是一样的了。&lt;/p&gt;
&lt;p&gt;首先是安装jdk：&lt;/p&gt;
&lt;p&gt;下载 jdk-8u181-linux-x64.tar.gz 包；&lt;/p&gt;
&lt;p&gt;tar -xzvf jdk-8u181-linux-x64.tar.gz 解压，得到jdk1.8.0_181 目录（假设存放为/root/java/ 目录）；&lt;/p&gt;
&lt;p&gt;配置java的环境变量：&lt;/p&gt;
&lt;p&gt;编辑环境变量文件：vi /etc/profile&lt;/p&gt;
&lt;p&gt;加入内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 export JAVA_HOME=/root/java/jdk1.8.0_181 
2 export JRE_HOME=${JAVA_HOME}/jre
3 export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib 
4 export PATH=${JAVA_HOME}/bin:$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;刷新环境变量配置：&lt;/p&gt;
&lt;p&gt;source /etc/profile&lt;/p&gt;
&lt;p&gt;确认java版本是否生效：&lt;/p&gt;
&lt;p&gt;java -version&lt;/p&gt;
&lt;p&gt;到这里java环境算是解决了，也没什么特别的难度，一步步来即可。&lt;/p&gt;
&lt;p&gt;Docker下testng环境配置&lt;/p&gt;
&lt;p&gt;接下来就是testng了，因为环境类似java而且也和环境变量有关系，所以优先解决：&lt;/p&gt;
&lt;p&gt;下载 testng-6.14.3.jar 包；&lt;/p&gt;
&lt;p&gt;tar -xzvf testng-6.14.3.jar解压得到testng目录（假设放在 /root/java/testng/ 目录下） ；&lt;/p&gt;
&lt;p&gt;继续编辑环境变量文件：&lt;/p&gt;
&lt;p&gt;vi /etc/profile&lt;/p&gt;
&lt;p&gt;加入内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export TESTNG_HOME=/root/java/testng
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH:$TESTNG_HOME/testng-6.14.3.jar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;刷新环境变量配置：&lt;/p&gt;
&lt;p&gt;source /etc/profile&lt;/p&gt;
&lt;p&gt;注意这里的testng环境变量，其中的 CLASSPATH 是在java环境的基础上追加的，如果大家是在windows上配置，分隔符要换成 ; 且环境变量的互相调用形式不同，这是有一些区别的。&lt;/p&gt;
&lt;p&gt;好了，可能有人会觉得，这不是很简单吗？&lt;br/&gt;但是，如果这时候继续去执行的话，会发现开始报错了，也就是深坑来了，这是因为脱离了整个开发环境。&lt;/p&gt;
&lt;p&gt;先提一下testng的执行步骤，假设自己写个test.java，记住要最简单的，别参合其他jar包之类的，其中包含包名为 simple ，类名为 test：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1&lt;span&gt; javac test.java
&lt;/span&gt;2 java org.testng.TestNG -testclass simple.test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;看似非常简单，但是执行起来，到处都是错误，执行javac test.java，常见错误为：&lt;/p&gt;
&lt;p&gt;java.lang.NoClassDefFoundError: com/beust/jcommander/&lt;/p&gt;
&lt;p&gt;这是缺少因为缺少编译时用到的jar包，需要下载 jcommander-1.72.jar，我们将它放置在testng的jar包一起（假设放置在/root/java/testng/目录）：&lt;/p&gt;
&lt;p&gt;环境变量的CLASSPATH需要追加 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH:$TESTNG_HOME/testng-6.14.3.jar:$TESTNG_HOME/jcommander-1.72.jar
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;继续刷新环境配置：&lt;/p&gt;
&lt;p&gt;source /etc/profile&lt;/p&gt;
&lt;p&gt;这之后一般就可以顺利编译，出现 test.class 文件了。&lt;/p&gt;
&lt;p&gt;如果出现其他错误，比如与testng相关的包不存在等等，请检查环境变量配置是否正确。&lt;/p&gt;
&lt;p&gt;最后就是运行的环节了，也是大家会遇到问题点最多的点了。&lt;/p&gt;
&lt;p&gt;先提一下结构，比如上面 simple.test 的类，那么需要建立文件夹 simple 里面存放test.java。&lt;/p&gt;
&lt;p&gt;CLASSPATH的环境变量里，需要有testng代码文件和包的顶级目录追加添加，假设为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 /root/java/testng/
2 /root/java/testng/simple/test.java&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有了这样的结构前提，就可以通过命令执行了：&lt;/p&gt;
&lt;p&gt;java org.testng.TestNG -testclass simple.test&lt;br/&gt;出现结果，意味着运行成功了：&lt;/p&gt;
&lt;p&gt;Total tests run: 1, Failures: 0, Skips: 0&lt;/p&gt;
&lt;p&gt;如果你的代码中有测试用例@Test，但run出现0的话，说明还是失败的，只是没有给明确的报错而已。&lt;/p&gt;
&lt;p&gt;当然到这里还没意味着结束。&lt;/p&gt;
&lt;p&gt;因为你可能还会遇到缺乏各种依赖的jar包的问题：&lt;/p&gt;
&lt;p&gt;可以通过参数将这些jar包都引入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 /root/java/testng/
2 /root/java/testng/simple/test.java&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;远程调用windows下浏览器&lt;/p&gt;
&lt;p&gt;以为这就搞定环境，万事大吉了么？再补一刀，浏览器呢？没有浏览器得问题应该怎么解决呢？&lt;/p&gt;
&lt;p&gt;请使用selenium自带的server部署到windows机器上。&lt;/p&gt;
&lt;p&gt;这个问题的解决反而是比较简单的：&lt;/p&gt;
&lt;p&gt;下载 selenium-server-standalone-3.14.0.jar 包；&lt;/p&gt;
&lt;p&gt;放在指定目录（比如放在C盘根目录）；&lt;/p&gt;
&lt;p&gt;cd到该目录下：cd C:\&lt;/p&gt;
&lt;p&gt;执行命令打开selenium remote服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
java -jar selenium-server-standalone-3.14.0.jar -port 6666
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;接下来有人会问怎么指定浏览器？&lt;/p&gt;
&lt;p&gt;只需要在java代码里，使用下面语句就可以对刚才在windows启动的服务进行调用了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
WebDriver driver = &lt;span&gt;new&lt;/span&gt; RemoteWebDriver(&quot;http://ip:6666/wd/hub/&quot;, DesiredCapabilities.chrome());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;另外注意服务器上还是需要浏览器的driver驱动文件，无脑一点就和jar包放一起就完事了，爱折腾的可以自己研究一把，区别只是启动服务时需要带上一些参数。&lt;/p&gt;
&lt;p&gt;整个docker下使用selenium+java远程调用widows下Chrome浏览器，实现web自动化的环境搭建完毕。&lt;/p&gt;
&lt;p&gt;后续关于docker下面使用selenium+testng实现web自动化代码的编写，我们将在后续进行更新，等待我们下一次更新哟~&lt;/p&gt;
&lt;p&gt;搭建环境如果遇到问题，或者是对web自动化有兴趣的同学可以加入我们的测试讨论群。&lt;/p&gt;

</description>
<pubDate>Fri, 19 Oct 2018 08:47:00 +0000</pubDate>
<dc:creator>不能使用本名</dc:creator>
<og:description>Windows下selenium+testng的web自动化环境搭建 做过自动化的人，肯定对selenium web环境的搭建非常熟悉了，特别是selenium在java中的使用。 先搭建好安装好JD</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CMFacebook/p/9817357.html</dc:identifier>
</item>
<item>
<title>.net core下使用FastHttpApi构建web聊天室 - smark</title>
<link>http://www.cnblogs.com/smark/p/9817205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smark/p/9817205.html</guid>
<description>&lt;p&gt;一般在&lt;code&gt;dotnet core&lt;/code&gt;下构建使用web服务应用都使用asp.net core,但通过&lt;code&gt;FastHttpApi&lt;/code&gt;组建也可以方便地构建web服务应用，在&lt;code&gt;FastHttpApi&lt;/code&gt;功能的支持下构建多人聊天室是件非常简单的事情，通过组件并不需要了解WebSocket知识即可简单构建，以下讲解一下通过FastHttpApi如何构建一个简单的多人聊室。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;创建项目&lt;/h2&gt;
&lt;p&gt;使用FastHttpApi构建一个WEB服务只需要创建一个普通&lt;code&gt;ConsoleApp( 控制台应用)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201810/254151-20181019175849894-1702382951.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建项目后需要在&lt;code&gt;Nuget&lt;/code&gt;中添加引用&lt;code&gt;FastHttpApi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201810/254151-20181019175923974-93517441.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只需要简单地引用&lt;code&gt;Beetlex.FastHttpApi&lt;/code&gt;即可构建基于&lt;code&gt;Http&lt;/code&gt;和&lt;code&gt;Websocket&lt;/code&gt;通讯应用。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;创建逻辑&lt;/h2&gt;
&lt;p&gt;FastHttpApi对类和方法没有太多规则约束，只需要在类上定义一个&lt;code&gt;Controller&lt;/code&gt;标签即可，接下来实现一个简单的web聊天室&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [Controller]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Controller
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户登陆&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Login(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; nickName, IHttpContext context)
        {
            context.Session.Name &lt;/span&gt;=&lt;span&gt; nickName;
            ActionResult result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActionResult();
            result.Data &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; { name = nickName, message = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, time = DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) };
            context.SendToWebSocket(result);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取在线用户&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; ListOnlines(IHttpContext context)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; r &lt;span&gt;in&lt;/span&gt;&lt;span&gt; context.Server.GetWebSockets()
                   &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; r.Session.Name != &lt;span&gt;null&lt;/span&gt;
                   &lt;span&gt;select&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; { r.Session.Name, IP =&lt;span&gt; r.Session.RemoteEndPoint.ToString() };
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送聊天信息&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Talk(&lt;span&gt;string&lt;/span&gt; nickName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; message, IHttpContext context)
        {
            ActionResult result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActionResult();
            result.Data &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; { name = nickName, message, type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;talk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, time = DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) };
            context.SendToWebSocket(result);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码分别定义登陆，获取在线用户和alk方法，方法的定义同样也是没有约束性，对于&lt;code&gt;IHttpContext&lt;/code&gt;这些参数都是根据自己需要定义，如果不需要则不用在方法中定义它。接下来的事情就是要在页面上调用它，大家知道在页面调用http或websocket 需要定义一些代码和指定相应的URL。但&lt;code&gt;Beetlex.FastHttpApi&lt;/code&gt;提供一个非常便利的方式，通过安装一个插件可以自动生成这些代码&lt;a href=&quot;http://www.ikende.com/Doc.html?id=4046464860e14d9590062ef9e000dc50&quot;&gt;&lt;strong&gt;插件安装介绍(暂只支持vs2017)&lt;/strong&gt;&lt;/a&gt;.当插件安装完成后只需要设置类文件的&lt;code&gt;自定义工具即可&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201810/254151-20181019175808083-1040337840.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插件会在当前类文下生成一个&lt;code&gt;js&lt;/code&gt;文件，文件里把调用方法的URL和参数都定义完成&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; $Login$url='/login'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; $Login(nickName,useHttp)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; api($Login$url,{nickName:nickName},useHttp).sync();
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; $Login$async(nickName,useHttp)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; api($Login$url,{nickName:nickName},useHttp);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; $ListOnlines$url='/listonlines'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; $ListOnlines(useHttp)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; api($ListOnlines$url,{},useHttp).sync();
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; $ListOnlines$async(useHttp)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; api($ListOnlines$url,{},useHttp);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; $Talk$url='/talk'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; $Talk(nickName,message,useHttp)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; api($Talk$url,{nickName:nickName,message:message},useHttp).sync();
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; $Talk$async(nickName,message,useHttp)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; api($Talk$url,{nickName:nickName,message:message},useHttp);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个文件非常简单，主要包括URL，同步方法和异步方法。这个&lt;code&gt;js&lt;/code&gt;文件需要依赖&lt;a href=&quot;https://github.com/IKende/FastHttpApi/blob/master/src/FastHttpApi.js&quot;&gt;FastHttpApi.js&lt;/a&gt;才能使用，所以在页面上必须把这个文件也引用上。接下来就是页面脚本的使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
   &amp;lt;script&amp;gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; receive(result) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result.Data.type == 'login' || result.Data.type == 'quit'&lt;span&gt;) {
                $ListOnlines$async().execute(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (result) {
                    listUserControl.Data &lt;/span&gt;=&lt;span&gt; result.Data;
                });
            }
            messages.push(result.Data);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objDiv = document.getElementById(&quot;lstTalk&quot;&lt;span&gt;);
            objDiv.scrollTop &lt;/span&gt;=&lt;span&gt; objDiv.scrollHeight;
        }

        async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sendMessage() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; msg = $('#talkMsg'&lt;span&gt;).val();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;msg) {
                alert(&lt;/span&gt;&quot;enter message&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; await $Talk(nickName, msg);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result.Code != 200&lt;span&gt;)
                alert(result.Error);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                $(&lt;/span&gt;'#talkMsg').val(''&lt;span&gt;);

        }
        async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; login() {
            nickName &lt;/span&gt;= $('#userName'&lt;span&gt;).val();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;nickName) {
                alert(&lt;/span&gt;&quot;enter you name!&quot;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; await $Login(nickName);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result.Code == 200&lt;span&gt;) {
                $(&lt;/span&gt;'#loginBar'&lt;span&gt;).hide();
                $(&lt;/span&gt;'#talkBar'&lt;span&gt;).show();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                alert(result.Error);
            }
        }
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引用脚本后，直接通过方法调用即可，这种明确的方法调用比传统的&lt;code&gt;jquery.post&lt;/code&gt;有着调用的明确性和便利性，让使用者不需要查看接口文档即可以知道方法的调用参数。如果控制器定了XML帮助注释，插件同样也会把注释生成到脚本中。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;静态文件存储&lt;/h2&gt;
&lt;p&gt;组件通过固定的目录来存放静太资源，因此项目需要创建一个&lt;code&gt;views&lt;/code&gt;目录来存储静态资源，&lt;code&gt;views&lt;/code&gt;目录是web服务的根目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/0GuEp53.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于静态文件默认情况是不会被编译处理，所以我们需要把文件设置成编译嵌入模式或复制到输出目录中。如果是复制到输出目录下，可以在项目生成事件中添加一段复制代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201810/254151-20181019180042759-1188275662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;启动服务&lt;/h2&gt;
&lt;p&gt;组件启动服务很简单，不过在启动前需要注册一下程序集，把控制器注册到HTTP服务中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            mApiServer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeetleX.FastHttpApi.HttpApiServer();
            mApiServer.Debug();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有在Debug模式下生产，把静态资源加载目录指向项目的views目录&lt;/span&gt;
            mApiServer.Register(&lt;span&gt;typeof&lt;/span&gt;(Program).Assembly);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载程序集中所有控制器信息和静态资源信息&lt;/span&gt;
&lt;span&gt;            mApiServer.Open();
            Console.Write(mApiServer.BaseServer);
            Console.Read();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;组件默认是不需要配置即可启动HTTP服务，默认端口是&lt;code&gt;9090&lt;/code&gt;.不过这些信息也是可以通过配置文件加载，只要程序目录存在&lt;code&gt;HttpConfig.json&lt;/code&gt;文件组件即会加载配置文件中的配置信息来运行服务。&lt;a href=&quot;http://www.ikende.com/Doc.html?id=b7475865dc8c42b0822f49b473817f29&quot;&gt;&lt;strong&gt;配置文件详解&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这样一个简单多人web聊天室就完成，运行效果如下： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201810/254151-20181019180007314-1008077603.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ikende.com/samples/SimpleChatRoom/index.html&quot;&gt;&lt;strong&gt;在线演示&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/IKende/FastHttpApi/tree/master/samples/HttpApiServer.SimpleChatRoom&quot;&gt;&lt;strong&gt;详细代码&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 08:31:00 +0000</pubDate>
<dc:creator>smark</dc:creator>
<og:description>一般在dotnet core下构建使用web服务应用都使用asp.net core,但通过FastHttpApi组建也可以方便地构建web服务应用，在FastHttpApi功能的支持下构建多人聊天室是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smark/p/9817205.html</dc:identifier>
</item>
<item>
<title>数据结构与算法学习笔记之如何分析一个排序算法？ - Dawnzhang</title>
<link>http://www.cnblogs.com/clwydjgs/p/9815690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clwydjgs/p/9815690.html</guid>
<description>&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;现在IT这块找工作，不会几个算法都不好意思出门，排序算法恰巧是其中最简单的，我接触的第一个算法就是它，但是你知道怎么分析一个排序算法么？有很多时间复杂度相同的排序算法，在实际编码中，那又如何选择呢？下面我们带着问题一起学习一下。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; 正文&lt;/span&gt;&lt;/h2&gt;
&lt;div readability=&quot;6.2125&quot;&gt;
&lt;h3&gt;一、常见经典的排序方法&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（图片来自于&lt;a href=&quot;https://www.cnblogs.com/onepixel/p/7674659.html&quot; target=&quot;_blank&quot;&gt;一像素&lt;/a&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;插入排序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181019142922491-1394600532.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;希尔排序（递减增量排序算法）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181019141046309-593308984.gif&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;344&quot;/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;归并排序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181019143053228-582279984.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;快速排序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181019162654166-1739791028.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;冒泡排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181019142805256-725120997.gif&quot; alt=&quot;&quot; width=&quot;826&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;选择排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181019142505841-692410474.gif&quot; alt=&quot;&quot; width=&quot;810&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;计数排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181019143321235-1641215511.gif&quot; alt=&quot;&quot; width=&quot;977&quot; height=&quot;538&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;计数排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181019143458182-321587292.gif&quot; alt=&quot;&quot; width=&quot;963&quot; height=&quot;546&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;堆排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181019142641060-744579962.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二、 按照时间复杂度归类&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;时间复杂度O（n&lt;sup&gt;2&lt;/sup&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;冒泡排序、插入排序、选择排序 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时间复杂度O(nlogn)：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;快速排序、归并排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时间复杂度O(n)：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;计数排序、基数排序、桶排序 &lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;三、如何分析一个“排序算法”？&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;从三个方面入手&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;a、算法的执行效率&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;1.&lt;/em&gt;最好、最坏、平均情况时间复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从算法的核心，复杂度入手，给出最好最坏，平均情况下的时间复杂度，便于分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;2. 时间复杂度的系数、常数和低阶。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时间复杂度表示的是规模很大的一种增涨趋势，很容易就忽略系数，低阶，常数等，实际开发中排序的规模都是像10.100.1000这种小规模&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;3. 比较次数，交换（或移动）次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;排序算法执行过程中，涉及两种操作，一种是元素比较大小，一种是元素交换或移动位置，所以比较次数，交换次数都得考虑进去。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;b、排序算法的内存消耗&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;算法消耗可以通过空间复杂度来衡量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原地排序算法：特指空间复杂度是O(1)的排序算法。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;h4&gt;c、排序算法的稳定性&lt;/h4&gt;
&lt;span&gt;1. 稳定性概念：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 稳定性重要性：可针对对象的多种属性进行有优先级的排序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 举例：给电商交易系统中的“订单”排序，按照金额大小对订单数据排序，对于相同金额的订单以下单时间早晚排序。用稳定排序算法可简洁地解决。先按照下单时间给订单排序，排序完成后用稳定排序算法按照订单金额重新排序。&lt;/span&gt;&lt;h3&gt;四、详解冒泡排序&lt;/h3&gt;
&lt;span&gt;冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;冒泡排序只涉及相邻数据的交换，只需要常量级的临时空间，所以它的空间复杂度未O（1）是原地排序算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;稳定性：当有相邻的两个元素大小相等时，不做交换，冒泡排序是稳定的排序算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引入两个概念：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;默认从小到大未有序&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;有序度：数组中具有有序关系的元素对的个数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;满有序度：完全有序的数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逆序度：数组中具有无序关系的元素对的个数。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;逆序度=满有序度-有序度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;排序的过程实际上就是增加有序度，减少逆序度的过程&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时间复杂度：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 最好情况（满有序度）：O(n)。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 最坏情况（满逆序度）：O(n^2)。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 平均情况：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“有序度”和“逆序度”：对于一个不完全有序的数组，如4，5，6，3，2，1，有序元素对为3个（4，5），（4，6），（5，6），有序度为3，逆序度为12；对于一个完全有序的数组，如1，2，3，4，5，6，有序度就是n*(n-1)/2，也就是15，称作满有序度；逆序度=满有序度-有序度；冒泡排序、插入排序交换（或移动）次数=逆序度。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;最好情况下初始有序度为n*(n-1)/2，最坏情况下初始有序度为0，则平均初始有序度为n*(n-1)/4，即交换次数为n*(n-1)/4，因交换次数&amp;lt;比较次数&amp;lt;最坏情况时间复杂度，所以平均时间复杂度为O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 冒泡排序，a 表示数组，n 表示数组大小&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bubbleSort(&lt;span&gt;int&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;lt;= &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
 
 &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提前退出冒泡循环的标志位&lt;/span&gt;
    boolean flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; n - i - &lt;span&gt;1&lt;/span&gt;; ++&lt;span&gt;j) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a[j] &amp;gt; a[j+&lt;span&gt;1&lt;/span&gt;]) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; tmp =&lt;span&gt; a[j];
        a[j] &lt;/span&gt;= a[j+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        a[j&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; tmp;
        flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示有数据交换      &lt;/span&gt;
&lt;span&gt;      }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!flag) &lt;span&gt;break&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有数据交换，提前退出&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;24&quot;&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;五、详解插入排序&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;将数据分为两个区间，已排序区间和未排序区间，初始已排序区间只有一个元素(即第一个数据)，我们取未排序区间的元素，在已排序的区间中找到合适的位置插入位置插入，并保证已排序区间数据一直有序，重复过程，直到未排序区间中没有元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行过程中看得出来，不需要额外的存储空间，所以空间复杂度为0（1），也是原地排序算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样值的元素，前后顺序保持不变，是稳定的排序算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时间复杂度：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最好时间复杂度为O(n)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最坏时间复杂度为O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;平均时间复杂度为O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入排序，a 表示数组，n 表示数组大小&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insertionSort(&lt;span&gt;int&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;lt;= &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; value =&lt;span&gt; a[i];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找插入的位置&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (; j &amp;gt;= &lt;span&gt;0&lt;/span&gt;; --&lt;span&gt;j) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a[j] &amp;gt;&lt;span&gt; value) {
        a[j&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] = a[j];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据移动&lt;/span&gt;
      } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      }
    }
    a[j&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] = value; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入数据&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;六、详解选择排序&lt;/h3&gt;
&lt;span&gt;选择排序将数组数据分成已排序区间和未排序区间。初始已排序区间只有一个元素，即数组第一个元素。在未排序区间找到最小的数据，将其放在已排序区间的末尾&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;空间复杂度为O(1)，选择排序是原地排序算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;未排序区间的元素和已排序区间的元素相同时，它可以放在已排序区间相同值的前或后，所以为不稳定的排序&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;br/&gt;&lt;span&gt;时间复杂度：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 最好情况：O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 最坏情况：O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 平均情况：O(n&lt;sup&gt;2&lt;/sup&gt;)（往数组中插入一个数的平均时间复杂度是O(n)，一共重复n次）。&lt;/span&gt;&lt;br/&gt;&lt;h3&gt;七、各种排序方法的汇总比较&lt;/h3&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416523/201810/1416523-20181019105241811-2140075087.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;h3&gt;八、选择排序和插入排序的时间复杂度相同，都是O(n^2)，在实际的软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序算法呢？&lt;/h3&gt;
&lt;span&gt;答：它们的元素比较次数以及交换元素的次数都是原始数据的逆序度，是一个固定值，但是从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个，他们 的时间复杂度上都是O(n&lt;sup&gt;2&lt;/sup&gt;)，但是为了追求极致的性能，所以首选插入排序算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;结尾&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;大家不妨试着分析一下其他的几种算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看再多遍都不如写一篇来得深刻，建议大家多敲。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;相关文章&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/clwydjgs/p/9790129.html&quot;&gt;数据结构与算法学习笔记之写链表代码的正确姿势（下）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/clwydjgs/p/9778394.html&quot;&gt;数据结构与算法学习笔记之 提高读取性能的链表（上）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/clwydjgs/p/9755971.html&quot;&gt;数据结构与算法学习笔记之 从0编号的数组&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/clwydjgs/p/9792256.html&quot;&gt;数据结构与算法学习笔记之后进先出的“桶”&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/clwydjgs/p/9809279.html&quot;&gt;数据结构与算法学习笔记之先进先出的队列&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/clwydjgs/p/9810969.html&quot;&gt;数据结构与算法学习笔记之高效、简洁的编码技巧“递归”&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上内容为个人的学习笔记，仅作为学习交流之用。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://www.cnblogs.com/clwydjgs/&quot;&gt;&lt;img src=&quot;https://files.cnblogs.com/files/clwydjgs/qrcode_for_gh_20d7688c890d_258.bmp&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎大家关注公众号，不定时干货，只做有价值的输出&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/clwydjgs/&quot; target=&quot;_blank&quot;&gt;Dawnzhang&lt;/a&gt; &lt;br/&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/clwydjgs/p/9815690.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/clwydjgs/p/9815690.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;版权：本文版权归作者&lt;br/&gt;转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 08:20:00 +0000</pubDate>
<dc:creator>Dawnzhang</dc:creator>
<og:description>前言 现在IT这块找工作，不会几个算法都不好意思出门，排序算法恰巧是其中最简单的，我接触的第一个算法就是它，但是你知道怎么分析一个排序算法么？有很多时间复杂度相同的排序算法，在实际编码中，那又如何选择</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clwydjgs/p/9815690.html</dc:identifier>
</item>
</channel>
</rss>