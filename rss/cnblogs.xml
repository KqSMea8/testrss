<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于epoll实现简单的web服务器 - coolblog.xyz</title>
<link>http://www.cnblogs.com/nullllun/p/8492884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nullllun/p/8492884.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;epoll 是 Linux 平台下特有的一种 I/O 复用模型实现，于 2002 年在 Linux kernel 2.5.44 中被引入。在 epoll 之前，Unix/Linux 平台下的 I/O 复用模型包含 select 和 poll 两个系统调用。随着因特网的发展，因特网的用户量越来越大，C10K 问题出现。基于 select 和 poll 编写的网络服务已经不能满足不能满足用户的需求了，业界迫切希望更高效的系统调用出现。在此背景下，FreeBSD 的 kqueue 和 Linux 的 epoll 被研发了出来。kqueue 和 epoll 的出现，终结了 C10K 问题，C10K 问题就此作古。&lt;/p&gt;
&lt;p&gt;因为 Linux 系统的广泛应用，所以大家在说 I/O 复用时，更多的是想到了 epoll，而不是 kqueue，本文也不例外。本篇文章不会涉及 kqueue，大家有兴趣可以自己看看。&lt;/p&gt;
&lt;h2 id=&quot;基于-epoll-实现-web-服务器&quot;&gt;2. 基于 epoll 实现 web 服务器&lt;/h2&gt;
&lt;p&gt;在 Linux 中，epoll 并不是一个系统调用，而是 epoll_create、epoll_ctl 和 epoll_wait 三个系统调用的统称。关于这三个系统调用的细节，这里就不说明了，大家可以自己去查 man-page。接下来，我们来直接看一个例子，这个例子基于 epoll 和 &lt;a href=&quot;https://sourceforge.net/projects/tinyhttpd/files/&quot;&gt;TinyHttpd&lt;/a&gt; 实现了一个 I/O 复用版的 HTTP Server。在上代码前，我们先来演示这个玩具版 HTTP Server 的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15199251690746.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面就是玩具版 HTTP Server 的运行效果了，看起来还行。在我第一次把它成功跑起来的时候，感觉很奇妙。好了，看完效果，接下来看代码吧，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;59&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;netinet/in.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;sys/sysinfo.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;sys/epoll.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;signal.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;fcntl.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &quot;httpd.h&quot;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define DEFAULT_PORT 8080&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define MAX_EVENT_NUM 1024&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define INFTIM -1&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; process(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;);

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; handle_subprocess_exit(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;);

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *argv[])  
{
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; sockaddr_in server_addr;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; listen_fd;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; cpu_core_num;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; on = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    
    listen_fd = socket(AF_INET, SOCK_STREAM, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
    fcntl(listen_fd, F_SETFL, O_NONBLOCK);    &lt;span class=&quot;co&quot;&gt;// 设置 listen_fd 为非阻塞&lt;/span&gt;
    setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;amp;on, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(on));

    bzero(&amp;amp;server_addr, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(DEFAULT_PORT);

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (bind(listen_fd, (&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;server_addr, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(server_addr)) == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
        perror(&lt;span class=&quot;st&quot;&gt;&quot;bind error, message: &quot;&lt;/span&gt;);
        exit(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (listen(listen_fd, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
        perror(&lt;span class=&quot;st&quot;&gt;&quot;listen error, message: &quot;&lt;/span&gt;);
        exit(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    }

    printf(&lt;span class=&quot;st&quot;&gt;&quot;listening 8080&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);

    signal(SIGCHLD, handle_subprocess_exit);

    cpu_core_num = get_nprocs();
    printf(&lt;span class=&quot;st&quot;&gt;&quot;cpu core num: %d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, cpu_core_num);
    &lt;span class=&quot;co&quot;&gt;// 根据 CPU 数量创建子进程，为了演示“惊群现象”，这里多创建一些子进程&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; cpu_core_num * &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;; i++) {
        pid_t pid = fork();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (pid == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {    &lt;span class=&quot;co&quot;&gt;// 子进程执行此条件分支&lt;/span&gt;
            process(listen_fd);
            exit(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
        }
    }

    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
        sleep(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; process(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; listen_fd) 
{
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; conn_fd;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ready_fd_num;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; sockaddr_in client_addr;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; client_addr_size = &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(client_addr);
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;dv&quot;&gt;128&lt;/span&gt;];

    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; epoll_event ev, events[MAX_EVENT_NUM];
    &lt;span class=&quot;co&quot;&gt;// 创建 epoll 实例，并返回 epoll 文件描述符&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; epoll_fd = epoll_create(MAX_EVENT_NUM);
    ev.data.fd = listen_fd;
    ev.events = EPOLLIN;

    &lt;span class=&quot;co&quot;&gt;// 将 listen_fd 注册到刚刚创建的 epoll 中&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &amp;amp;ev) == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
        perror(&lt;span class=&quot;st&quot;&gt;&quot;epoll_ctl error, message: &quot;&lt;/span&gt;);
        exit(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// 等待事件发生&lt;/span&gt;
        ready_fd_num = epoll_wait(epoll_fd, events, MAX_EVENT_NUM, INFTIM);
        printf(&lt;span class=&quot;st&quot;&gt;&quot;[pid %d] 😱 震惊！我又被唤醒了...&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, getpid());
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ready_fd_num == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
            perror(&lt;span class=&quot;st&quot;&gt;&quot;epoll_wait error, message: &quot;&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;
        }
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; ready_fd_num; i++) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (events[i].data.fd == listen_fd) { &lt;span class=&quot;co&quot;&gt;// 有新的连接&lt;/span&gt;
                conn_fd = accept(listen_fd, (&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;client_addr, &amp;amp;client_addr_size);
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (conn_fd == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
                    sprintf(buf, &lt;span class=&quot;st&quot;&gt;&quot;[pid %d] ❌ accept 出错了: &quot;&lt;/span&gt;, getpid());
                    perror(buf);
                    &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;
                }

                &lt;span class=&quot;co&quot;&gt;// 设置 conn_fd 为非阻塞&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (fcntl(conn_fd, F_SETFL, fcntl(conn_fd, F_GETFD, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) | O_NONBLOCK) == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
                    &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;
                }

                ev.data.fd = conn_fd;
                ev.events = EPOLLIN;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, conn_fd, &amp;amp;ev) == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
                    perror(&lt;span class=&quot;st&quot;&gt;&quot;epoll_ctl error, message: &quot;&lt;/span&gt;);
                    close(conn_fd);
                }
                printf(&lt;span class=&quot;st&quot;&gt;&quot;[pid %d] 📡 收到来自 %s:%d 的请求&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, getpid(), inet_ntoa(client_addr.sin_addr), client_addr.sin_port);
                
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (events[i].events &amp;amp; EPOLLIN) {    &lt;span class=&quot;co&quot;&gt;// 某个 socket 数据已准备好，可以读取了&lt;/span&gt;
                printf(&lt;span class=&quot;st&quot;&gt;&quot;[pid %d] ✅ 处理来自 %s:%d 的请求&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, getpid(), inet_ntoa(client_addr.sin_addr), client_addr.sin_port);
                conn_fd = events[i].data.fd;
                &lt;span class=&quot;co&quot;&gt;// 调用 TinyHttpd 的 accept_request 函数处理请求&lt;/span&gt;
                accept_request(conn_fd, &amp;amp;client_addr);
                close(conn_fd);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (events[i].events &amp;amp; EPOLLERR) {
                fprintf(stderr, &lt;span class=&quot;st&quot;&gt;&quot;epoll error&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
                close(conn_fd);
            }
        }
    }
}

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; handle_subprocess_exit(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; signo)
{
    printf(&lt;span class=&quot;st&quot;&gt;&quot;clean subprocess.&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; status;  
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(waitpid(-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &amp;amp;status, WNOHANG) &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码有点长，不过还好，基本上都是模板代码，没什么特别复杂的逻辑。希望大家耐心看一下。&lt;/p&gt;
&lt;p&gt;上面的代码基于&lt;code&gt;epoll + 多进程&lt;/code&gt;的方式实现，开始，主进程会通过系统调用获取 CPU 核心数，然后根据核心数创建子进程。为了演示“惊群现象”，这里多创建了一倍的子进程。关于惊群现象，下一章会讲到，大家先别急哈。创建好子进程后，主进程不需再做什么事了，核心逻辑都会在子线程中执行。首先，每个子进程都会调用 epoll_create 在内核创建 epoll 实例，然后再通过 epoll_ctl 将 listen_fd 注册到 epoll 实例中，由内核进行监控。最后，再调用 epoll_wait 等待感兴趣的事件发生。当 listen_fd 中有新的连接时，epoll_wait 会返回。此时子进程调用 accept 接受连接，并把客户端 socket 注册到 epoll 实例中，等待 EPOLLIN 事件发生。当该事件发生后，即可接受数据，并根据 HTTP 请求信息返回相应的页面了。&lt;/p&gt;
&lt;p&gt;这里说明一下，上面代码中处理 HTTP 请求的逻辑是写在 &lt;a href=&quot;https://sourceforge.net/projects/tinyhttpd/files/&quot;&gt;TinyHttpd&lt;/a&gt; 项目中的，TinyHttpd 是一个只有 500 行左右的超轻量型Http Server，很适合学习使用。为了适应需求，我对其源码进行了一定的修改，并添加了一些注释。本章的测试代码已经放到了 github 上，需要的同学自取，传送门 -&amp;gt; &lt;a href=&quot;https://github.com/code4wt/toyhttpd/blob/master/epoll_multiprocess_server.c&quot;&gt;epoll_multiprocess_server.c&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;惊群及演示&quot;&gt;3. 惊群及演示&lt;/h2&gt;
&lt;p&gt;“惊群现象”是指并发环境下，多线程或多进程等待同一个 socket 事件，当这个事件发生时，多线程/多进程被同时唤醒，这就是“惊群现象”。对应上面的代码，多个子进程通过调用 epoll_wait 等待 listen_fd 上某个事件发生。当有新连接进来时，多个进程会被同时唤醒去处理这个事件。但最终只有一个进程可以去处理事件，其他进程重新进入等待状态。使用上面的代码可以演示惊群现象，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15199689180907.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，当 listen_fd 上有新连接事件发生时，进程19571和19573被唤醒。但最终进程19573成功处理了新连接事件，进程19571则失败了。&lt;/p&gt;
&lt;p&gt;惊群现象会影响服务器性能，因为多个进程被唤醒，但最终只有一个进程可以成功处理事件。而 CPU 需要为一个事件的发生调度数个进程，因此会浪费 CPU 资源。&lt;/p&gt;
&lt;p&gt;对于惊群现象，处理的思路一般有两种。一种是像 Lighttpd 那样，无视惊群。另一种是像 Nginx 那样，使用全局锁避免惊群。简单起见，本文测试代码采用的是 Lighttpd 的处理方式，即无视惊群。对于这两种思路的细节，由于本人未读过两个开源软件的代码，这里就不多说了。如果大家有兴趣，可以参考网上的一些博文。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;epoll 是 I/O 复用模型重要的一个实现，性能优异，应用广泛。像 Linux 平台下的 JVM，NIO 部分就是基于 epoll 实现的。再如大名鼎鼎 Nginx 也是使用了 epoll。由此可以看出 epoll 的重要性，因此我们有很有必要去了解 epoll。本文通过一个测试程序简单演示了一个基于 epoll 的 HTTP Server，总体上也达到了学习 epoll 的目的。大家如果有兴趣，可以下载源码看看。当然，纸上学来终觉浅，还是要自己动手写才行。本文的测试代码是本人现学现卖写的，仅测试使用，写的不好的地方望谅解。&lt;/p&gt;
&lt;p&gt;好了，本文到此结束，谢谢阅读！&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;blockquote readability=&quot;5.2023121387283&quot;&gt;
&lt;p&gt;本文在知识共享许可协议 4.0 下发布，转载需在明显位置处注明出处&lt;br/&gt;作者：coolblog&lt;br/&gt;本文同步发布在我的个人博客：&lt;a href=&quot;http://www.coolblog.xyz/&quot; class=&quot;uri&quot;&gt;http://www.coolblog.xyz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot;&gt;&lt;img src=&quot;http://blog-pictures.oss-cn-shanghai.aliyuncs.com/cc.png&quot; alt=&quot;cc&quot;/&gt;&lt;/a&gt;&lt;br/&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot;&gt;知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
<pubDate>Fri, 02 Mar 2018 06:00:00 +0000</pubDate>
<dc:creator>coolblog.xyz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nullllun/p/8492884.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 2.1+的视图缓存(响应缓存) - 第一个少年</title>
<link>http://www.cnblogs.com/boxrice/p/8492508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boxrice/p/8492508.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span data-ttu-id=&quot;c715b-105&quot;&gt;响应缓存&lt;a href=&quot;https://github.com/aspnet/Mvc/issues/6437&quot; data-linktype=&quot;external&quot;&gt;Razor 页与 ASP.NET 核心 2.0 中不支持&lt;/a&gt;。 &lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-106&quot;&gt;此功能将支持&lt;a href=&quot;https://github.com/aspnet/Home/wiki/Roadmap&quot; data-linktype=&quot;external&quot;&gt;ASP.NET 核心 2.1 版本&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在老的版本的MVC里面，有一种可以缓存视图的特性(&lt;strong&gt;OutputCache&lt;/strong&gt;)，可以保持同一个参数的请求，在N段时间内，直接从mvc的缓存中读取，不去走视图的逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    [OutputCache(Duration =&lt;span&gt;20&lt;/span&gt;)]&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置过期时间为20秒  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ExampleCacheAction()  
    {  
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  time=DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy年MM月dd日 HH时mm分ss秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
        ViewBag.time&lt;/span&gt;=&lt;span&gt; time;  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();  
    }  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Asp.Net core 2.1中，官方文档上称：&lt;em&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-108&quot;&gt;响应缓存可减少客户端或代理对 web 服务器的请求数。 &lt;span data-ttu-id=&quot;c715b-109&quot;&gt;响应缓存还可减少量工作的 web 服务器执行程序生成响应。 &lt;span data-ttu-id=&quot;c715b-110&quot;&gt;响应缓存由标头，指定你希望客户端、 代理和缓存响应的中间件如何控制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-108&quot;&gt;&lt;span data-ttu-id=&quot;c715b-109&quot;&gt;&lt;span data-ttu-id=&quot;c715b-110&quot;&gt;在Asp.Net Core 2.1 中，没有了OutputCache，换成了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-108&quot;&gt;&lt;span data-ttu-id=&quot;c715b-109&quot;&gt;&lt;span data-ttu-id=&quot;c715b-110&quot;&gt;&lt;strong&gt;ResponseCache&lt;/strong&gt;，ResponseCache必须带一个参数:Duration 单位为秒，最少设置一秒钟&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 [ResponseCache(Duration = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult About()
        {

            ViewBag.time &lt;/span&gt;= DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy年MM月dd日 HH时mm分ss秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再浏览器请求这个视图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/653862/201803/653862-20180302113422433-561392776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在浏览器的响应头的Cache-Control 中出现max-age=5, Http协议对此的解释是&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-126&quot;&gt;客户端将不会接受其保留时间大于指定的秒数的响应。 &lt;span data-ttu-id=&quot;c715b-127&quot;&gt;示例： &lt;code&gt;max-age=60&lt;/code&gt; （60 秒）， &lt;code class=&quot;x-hidden-focus&quot;&gt;max-age=2592000&lt;/code&gt; （1 个月）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-108&quot;&gt;&lt;span data-ttu-id=&quot;c715b-109&quot;&gt;&lt;span data-ttu-id=&quot;c715b-110&quot;&gt;如果在浏览器中禁用缓存，那么&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-108&quot;&gt;&lt;span data-ttu-id=&quot;c715b-109&quot;&gt;&lt;span data-ttu-id=&quot;c715b-110&quot;&gt;&lt;strong&gt;ResponseCache&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;不会有任何效果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-108&quot;&gt;&lt;span data-ttu-id=&quot;c715b-109&quot;&gt;&lt;span data-ttu-id=&quot;c715b-110&quot;&gt;Vary过滤&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[ResponseCache(VaryByHeader = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Duration = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult About()
        {

            ViewBag.time &lt;/span&gt;= DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy年MM月dd日 HH时mm分ss秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/653862/201803/653862-20180302115458943-1891745643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-108&quot;&gt;&lt;span data-ttu-id=&quot;c715b-109&quot;&gt;&lt;span data-ttu-id=&quot;c715b-110&quot;&gt;关于vary在Http响应头的作用就是:告诉缓存服务器或者CDN，我还是同一个浏览器的请求，你给我缓存就行了，如果你换个浏览器去请求，那么vary的值肯定为空，那么缓存服务器就会认为你是一个新的请求，就会去读取最新的数据给浏览器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-108&quot;&gt;&lt;span data-ttu-id=&quot;c715b-109&quot;&gt;&lt;span data-ttu-id=&quot;c715b-110&quot;&gt;参考资料：&lt;a title=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&quot; href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&quot; target=&quot;_blank&quot;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 禁用缓存（&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-209&quot;&gt;NoStore 和 Location.None&lt;/span&gt;）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在Http中 ：no-store，请求和响应的信息都不应该被存储在对方的磁盘系统中；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[ResponseCache(Location = ResponseCacheLocation.None, NoStore = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult About()
        {

            ViewBag.time &lt;/span&gt;= DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy年MM月dd日 HH时mm分ss秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
ResponseCacheLocation.None是在Cache-Control设置一个no-cache属性，让浏览器不缓存当前这个URL&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&lt;code class=&quot;lang-csharp&quot; data-src=&quot;https://github.com/aspnet/Docs/blob/live/aspnetcore/performance/caching/response/sample/Startup.cs&quot;&gt;&lt;strong&gt;&lt;span&gt;缓存配置(&lt;/span&gt;&lt;/strong&gt;CacheProfiles)&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;code class=&quot;lang-csharp&quot; data-src=&quot;https://github.com/aspnet/Docs/blob/live/aspnetcore/performance/caching/response/sample/Startup.cs&quot;&gt;在一个正常的项目中，肯定有很多个控制器，但是不可能每个控制器的缓存策略都一样，这时候，我们就需要一个缓存的配置来灵活应对这个问题&lt;br/&gt;在mvc的服务注入的时候，我们可以在option里面注入进我们的缓存策略&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
services.AddMvc(option=&amp;gt;&lt;span&gt; {
                option.CacheProfiles.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CacheProfile()
                {
                    Duration &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
                });
                option.CacheProfiles.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CacheProfile()
                {
                    Location &lt;/span&gt;=&lt;span&gt; ResponseCacheLocation.None,
                    NoStore &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                });
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们在使用的时候，直接使用配置策略的名称就好了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[ResponseCache(CacheProfileName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult About()
        {

            ViewBag.time &lt;/span&gt;= DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy年MM月dd日 HH时mm分ss秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;这样我们就能和之前在特性后边配置一样了，而且代码看起来也清爽了不少&lt;/code&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;c715b-108&quot;&gt;&lt;span data-ttu-id=&quot;c715b-109&quot;&gt;&lt;span data-ttu-id=&quot;c715b-110&quot;&gt;总结：对于响应缓存，我个人的理解就是：MVC通过返回HTTP响应头，让浏览器在多少时间内，执行刷新操作的时候，不请求服务器，直接从缓存读取。。。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;如果对你有帮助，欢迎请我喝瓶水&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/653862/201803/653862-20180302131855788-1803869626.jpg&quot; alt=&quot;&quot; width=&quot;326&quot; height=&quot;442&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 02 Mar 2018 05:21:00 +0000</pubDate>
<dc:creator>第一个少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/boxrice/p/8492508.html</dc:identifier>
</item>
<item>
<title>Node.js入门（含NVM、NPM、NVM的安装） - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8492713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8492713.html</guid>
<description>&lt;blockquote readability=&quot;5.375&quot;&gt;
&lt;p&gt;本文最初发表于&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8492713.html&quot;&gt;博客园&lt;/a&gt;，并在&lt;a href=&quot;https://github.com/smyhvae/Web&quot;&gt;GitHub&lt;/a&gt;上持续更新&lt;strong&gt;前端的系列文章&lt;/strong&gt;。欢迎在GitHub上关注我，一起入门和进阶前端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;node.js的介绍&quot;&gt;Node.js的介绍&lt;/h2&gt;
&lt;h3 id=&quot;引擎&quot;&gt;引擎&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;引擎的特性&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;JS的内核即&lt;strong&gt;引擎&lt;/strong&gt;。因为引擎有以下特性：&lt;/p&gt;
&lt;p&gt;（1）转化的作用：&lt;/p&gt;
&lt;p&gt;（2）移植性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有哪些引擎&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180302_1258.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;备注：Node是用V8引擎去解析 js，此时，我们不用去考虑浏览器的兼容性问题。&lt;/p&gt;
&lt;h3 id=&quot;什么是-node.js&quot;&gt;什么是 Node.js&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、官方解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Node.js 是一个基于 &lt;strong&gt;Chrome V8&lt;/strong&gt; 引擎的 JavaScript 运行环境。 Node.js使用了一个&lt;strong&gt;事件驱动&lt;/strong&gt;、&lt;strong&gt;非阻塞式I/O&lt;/strong&gt;的模型（ Node.js的特性），使其轻量级又高效。 Node.js 的包管理器 nmp 是全球最大的开源库生态系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180301_1540.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、非官方解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Node.js&lt;/strong&gt;：是 JavaScript 语言在服务器端的运行环境（平台）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、运行环境（平台）的含义：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先，JavaScript 语言通过 Node 在服务器运行，在这个意义上，Node 有点像 JavaScript 虚拟机。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;其次，Node 提供大量工具库，使得 JavaScript 语言能与操作系统互动（比如读写文件、新建子进程），在这个意义上， Node 又是 JavaScript 的工具库。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Node.js 是一个 JavaScript 的运行环境（平台），不是一门语言，也不是 JavaScript 的框架。&lt;/p&gt;
&lt;h3 id=&quot;node-的历史&quot;&gt;Node 的历史&lt;/h3&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2008年左右，随着 AJAX 的逐渐普及，Web 开发逐渐走向复杂化，系统化；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2009年2月，Ryan Dahl 想要创建一个轻量级，适应现代 Web 开发的平台；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2009年5月，Ryan Dahl 在 GitHub 中开源了最初版本，同年11月，JSConf 就安排了 Node 讲座；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2010年底，Joyent 公司资助，Ryan Dahl 也加入了该公司，专门负责 Node 的开发；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2011年7月，在微软的支持下登陆 Windows 平台。PS：node 的生产环境基本是在 Linux 下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;据 Node.js 创始人 Ryan Dahl 回忆，他最初希望采用 Ruby，但是 Ruby 的虚拟机效率不行。&lt;/p&gt;
&lt;p&gt;注意：是 Node 选择了 JavaScript，不是 JavaScript 发展出来了一个 Node。&lt;/p&gt;
&lt;h3 id=&quot;国内外的应用情况&quot;&gt;国内外的应用情况&lt;/h3&gt;
&lt;p&gt;以下几个项目都用到了 Node：&lt;/p&gt;
&lt;p&gt;还有以下几个网站：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;LinkedIn移动版From RoR to Node.js, base on Joyent&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Paypal From Java to Node.js&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Twitter的队列：收集需要保存的Tweets，传给负责写入的进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;知乎的推送&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;网易、阿里、各种创业团队等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;node.js的主要应用领域&quot;&gt;Node.js的主要应用领域&lt;/h3&gt;
&lt;h3 id=&quot;知名度较高的node.js开源项目&quot;&gt;知名度较高的Node.js开源项目&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180301_2009.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;express：Node.js中最有名的web服务器框架。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PM2：node 本来是单进程的，PM2可以实现和管理多进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;jade：非常优秀的模板引擎，不仅限于 js 语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CoffeeScript：用简洁的方式展示 JavaScript 优秀的部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Atom：文本编辑器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;socket.io：实时通信框架。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;mocha：功能强大的 node.js 测试框架。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;node.js-的环境配置&quot;&gt;Node.js 的环境配置&lt;/h2&gt;
&lt;h3 id=&quot;node.js-安装包不推荐&quot;&gt;Node.js 安装包（不推荐）&lt;/h3&gt;
&lt;p&gt;去 Node.js 的&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;官网&lt;/a&gt;下载安装包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180301_1505.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们也可以在&lt;a href=&quot;https://nodejs.org/en/download/releases/&quot; class=&quot;uri&quot;&gt;https://nodejs.org/en/download/releases/&lt;/a&gt;上下载历史版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180301_1507.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，我们以一定要用偶数版（V4、V6等)，不要用奇数版（比如V5），因为奇数版不稳定。&lt;/p&gt;
&lt;p&gt;我们并不推荐直接采用 Node.js.msi 安装包进行安装，不方便 node 的更新，原因如下：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;以前版本安装的很多全局的工具包需要重新安装；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;无法回滚到之前的版本；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;无法在多个版本之间切换（很多时候我们要使用特定版本）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，我们暂时先不用安装 Node.js，稍后用 NVM 的方式来安装 Node.js。&lt;/p&gt;
&lt;h3 id=&quot;通过-nvm-安装node.js推荐&quot;&gt;通过 NVM 安装Node.js（推荐）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NVM&lt;/strong&gt;：node.js version manager，用来管理 node 的版本。安装的步骤如下。&lt;/p&gt;
&lt;p&gt;（1）我们去&lt;a href=&quot;https://github.com/coreybutler/nvm-windows/releases&quot;&gt;官网&lt;/a&gt;下载 NVM 的安装包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180301_1603.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载下来后，直接解压到 &lt;code&gt;D:\web&lt;/code&gt;目录下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180301_1610.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）在上面的目录中，新建一个&lt;code&gt;settings.txt&lt;/code&gt;文件，里面的内容填充如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;root&lt;/span&gt;: D:\web\nvm
&lt;span class=&quot;kw&quot;&gt;path&lt;/span&gt;: D:\web\nodejs
&lt;span class=&quot;kw&quot;&gt;arch&lt;/span&gt;: 64
&lt;span class=&quot;kw&quot;&gt;proxy&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上方内容的解释：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;root 配置为：当前 nvm.exe 所在的目录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;path 配置为：node 快捷方式所在的目录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;arch 配置为：当前操作系统的位数（32/64）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;proxy 不用配置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（3）配置环境变量：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;NVM_HOME&lt;/code&gt; = &lt;code&gt;D:\web\nvm&lt;/code&gt;（当前 nvm.exe 所在目录）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;NVM_SYMLINK&lt;/code&gt; = &lt;code&gt;D:\web\nodejs&lt;/code&gt; （node 快捷方式所在的目录）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PATH += &lt;code&gt;;%NVM_HOME%;%NVM_SYMLINK%&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置成功后，重启资源管理器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证：&lt;/strong&gt;(在 cmd 中输入命令)&lt;/p&gt;
&lt;p&gt;（1）输入&lt;code&gt;nvm&lt;/code&gt;命令查看环境变量是否配置成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180301_1645.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）输入 &lt;code&gt;nvm ls&lt;/code&gt;，查看已安装的所有 node 版本。&lt;/p&gt;
&lt;p&gt;（3）输入 &lt;code&gt;nvm -v&lt;/code&gt;，查看 已安装的 nvm 版本。&lt;/p&gt;
&lt;p&gt;（4）输入 &lt;code&gt;node -v&lt;/code&gt;，查看正在使用的 node 版本。&lt;/p&gt;
&lt;p&gt;如果 node 安装失败，可以参考上面这个链接。&lt;/p&gt;
&lt;h3 id=&quot;mac-下安装-nvm&quot;&gt;Mac 下安装 NVM&lt;/h3&gt;
&lt;p&gt;打开 终端.app，输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash

source ~/.nvm/nvm.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装以后，nvm的执行脚本，每次使用前都要激活，建议将其加入~/.bashrc文件（假定使用Bash）。激活后，就可以安装指定版本的Node。&lt;/p&gt;
&lt;p&gt;也可以使用 Homebrew 安装（更方便，维护更简单）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;brew install nvm&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;nvm-的常用命令&quot;&gt;NVM 的常用命令&lt;/h3&gt;
&lt;p&gt;安装指定版本的node：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nvm install 版本号 [arch]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如：&lt;code&gt;nvm install 4.2.2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;卸载指定版本node：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nvm uninstall 版本号&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切换使用指定版本的node：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nvm use 版本号 [arch]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看当前使用的 nvm 版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nvm -v&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看本地安装的所有的 node 版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nvm list|ls&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;node-的常用命令&quot;&gt;Node 的常用命令&lt;/h3&gt;
&lt;p&gt;在 查看 node 的版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node -v&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行脚本字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node -e 'console.log(&quot;Hello World&quot;)'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行脚本文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node index.js
$ node path/index.js
$ node path/index&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看帮助：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node --help
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;进入 REPL 环境：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;REPL 的全称：Read、Eval、 Print、Loop。类似于浏览器的控制台。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180301_1900.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果要退出 REPL 环境，可以输入&lt;code&gt;.exit&lt;/code&gt; 或 &lt;code&gt;process.exit()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 VS Code 里，我们可以在菜单栏选择“帮助-&amp;gt;切换开发人员工具”，打开console控制台。&lt;/p&gt;
&lt;h2 id=&quot;包和-npm&quot;&gt;包和 NPM&lt;/h2&gt;
&lt;h3 id=&quot;什么是包&quot;&gt;什么是包&lt;/h3&gt;
&lt;p&gt;由于 Node 是一套轻内核的平台，虽然提供了一系列的内置模块，但是不足以满足开发者的需求，于是乎出现了包（package）的概念：&lt;br/&gt;与核心模块类似，就是将一些预先设计好的功能或者说 API 封装到一个文件夹，提供给开发者使用。&lt;/p&gt;
&lt;p&gt;Node 本身并没有太多的功能性 API，所以市面上涌现出大量的第三方人员开发出来的 Package。&lt;/p&gt;
&lt;h3 id=&quot;包的加载机制&quot;&gt;包的加载机制&lt;/h3&gt;
&lt;p&gt;如果 Node中自带的包和第三方的包名冲突了，该怎么处理呢？原则是：&lt;/p&gt;
&lt;p&gt;比如说：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;requiere(`fs`)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那加载的肯定是系统的包。所以，我们尽量不要创建一些和现有的包重名的包。&lt;/p&gt;
&lt;h3 id=&quot;npm的概念&quot;&gt;NPM的概念&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;包的生态圈一旦繁荣起来，就必须有工具去来管理这些包。NPM 应运而生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;NPM&lt;/strong&gt;：Node Package Manager。官方链接： &lt;a href=&quot;https://www.npmjs.com/&quot; class=&quot;uri&quot;&gt;https://www.npmjs.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;随着时间的发展，NPM 出现了两层概念：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一层含义是 Node 的开放式模块登记和管理系统，亦可以说是一个生态圈，一个社区。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;另一层含义是 Node 默认的模块管理器，是一个命令行下的软件，用来安装和管理 Node 模块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;npm-的安装不需要单独安装&quot;&gt;NPM 的安装（不需要单独安装）&lt;/h3&gt;
&lt;p&gt;NPM 不需要单独安装。默认在安装 Node 的时候，会连带一起安装 NPM：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180302_1105.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NVM、Node、NPM 安装之后，目录分布如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180302_1134.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180302_1137.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180302_1138.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;npm -v&lt;/code&gt;，查看 npm 的版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180302_1139.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果上方命令无效，可能是之前的 node 并没有完全安装成功。解决办法：&lt;a href=&quot;https://segmentfault.com/a/1190000011114680&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/a/1190000011114680&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外，Node 附带的 NPM 可能不是最新版本，可以用下面的命令，更新到最新版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ npm install npm -g&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;nrm的安装&quot;&gt;NRM的安装&lt;/h3&gt;
&lt;p&gt;由于 NPM 的资源都在国外，有时候会被墙，导致无法下载或者很慢。此时可以用到NRM。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NRM&lt;/strong&gt;：Node Registry Manager。作用是：&lt;strong&gt;切换和管理包的镜像源&lt;/strong&gt;。项目地址：&lt;a href=&quot;https://www.npmjs.com/package/nrm&quot; class=&quot;uri&quot;&gt;https://www.npmjs.com/package/nrm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装 NRM：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    npm install -g nrm&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180302_1208.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NRM 的常用命令：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nrm ls  //显示全部的镜像

nrm use taobao  // 使用淘宝的镜像&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果入下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180302_1215.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推荐的国内加速镜像：&lt;a href=&quot;https://npm.taobao.org/&quot; class=&quot;uri&quot;&gt;https://npm.taobao.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;我的公众号&quot;&gt;我的公众号&lt;/h2&gt;
&lt;p&gt;想学习&lt;span&gt;&lt;strong&gt;代码之外的软技能&lt;/strong&gt;&lt;/span&gt;？不妨关注我的微信公众号：&lt;strong&gt;生命团队&lt;/strong&gt;（id：&lt;code&gt;vitateam&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 02 Mar 2018 05:21:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8492713.html</dc:identifier>
</item>
<item>
<title>高通Audio中ASOC的codec驱动 - yooooooo</title>
<link>http://www.cnblogs.com/linhaostudy/p/8425337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linhaostudy/p/8425337.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; msm8x16_wcd_spmi_probe(&lt;span&gt;struct&lt;/span&gt; spmi_device *&lt;span&gt;spmi)
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ret = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; msm8x16_wcd *msm8x16 =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; msm8x16_wcd_pdata *&lt;span&gt;pdata;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; resource *&lt;span&gt;wcd_resource;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; modem_state;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt;     dev_dbg(&amp;amp;spmi-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s(%d):slave ID = 0x%x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         __func__, __LINE__,  spmi-&amp;gt;&lt;span&gt;sid);
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt;     modem_state =&lt;span&gt; apr_get_modem_state();
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (modem_state !=&lt;span&gt; APR_SUBSYS_LOADED) {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         dev_dbg(&amp;amp;spmi-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Modem is not loaded yet %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;                modem_state);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EPROBE_DEFER;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;     wcd_resource = spmi_get_resource(spmi, NULL, IORESOURCE_MEM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;wcd_resource) {
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         dev_err(&amp;amp;spmi-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unable to get Tombak base address\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;ENXIO;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;switch&lt;/span&gt; (wcd_resource-&amp;gt;&lt;span&gt;start) {
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TOMBAK_CORE_0_SPMI_ADDR:
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         msm8x16_wcd_modules[&lt;span&gt;0&lt;/span&gt;].spmi =&lt;span&gt; spmi;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         msm8x16_wcd_modules[&lt;span&gt;0&lt;/span&gt;].&lt;span&gt;base&lt;/span&gt; = (spmi-&amp;gt;sid &amp;lt;&amp;lt; &lt;span&gt;16&lt;/span&gt;) +
&lt;span&gt; 29&lt;/span&gt;                         wcd_resource-&amp;gt;&lt;span&gt;start;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         wcd9xxx_spmi_set_dev(msm8x16_wcd_modules[&lt;span&gt;0&lt;/span&gt;].spmi, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         device_init_wakeup(&amp;amp;spmi-&amp;gt;dev, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TOMBAK_CORE_1_SPMI_ADDR:
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         msm8x16_wcd_modules[&lt;span&gt;1&lt;/span&gt;].spmi =&lt;span&gt; spmi;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         msm8x16_wcd_modules[&lt;span&gt;1&lt;/span&gt;].&lt;span&gt;base&lt;/span&gt; = (spmi-&amp;gt;sid &amp;lt;&amp;lt; &lt;span&gt;16&lt;/span&gt;) +
&lt;span&gt; 36&lt;/span&gt;                         wcd_resource-&amp;gt;&lt;span&gt;start;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         wcd9xxx_spmi_set_dev(msm8x16_wcd_modules[&lt;span&gt;1&lt;/span&gt;].spmi, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (wcd9xxx_spmi_irq_init()) {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         dev_err(&amp;amp;spmi-&amp;gt;&lt;span&gt;dev,
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s: irq initialization failed\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, __func__);
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         dev_dbg(&amp;amp;spmi-&amp;gt;&lt;span&gt;dev,
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s: irq initialization passed\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, __func__);
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; rtn;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         ret = -&lt;span&gt;EINVAL;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; rtn;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;     dev_dbg(&amp;amp;spmi-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s(%d):start addr = 0x%pa\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;         __func__, __LINE__,  &amp;amp;wcd_resource-&amp;gt;&lt;span&gt;start);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (wcd_resource-&amp;gt;start !=&lt;span&gt; TOMBAK_CORE_0_SPMI_ADDR)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; rtn;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt;     dev_set_name(&amp;amp;spmi-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, MSM8X16_CODEC_NAME);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (spmi-&amp;gt;&lt;span&gt;dev.of_node) {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         dev_dbg(&amp;amp;spmi-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s:Platform data from device tree\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;            __func__);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         pdata = msm8x16_wcd_populate_dt_pdata(&amp;amp;spmi-&amp;gt;&lt;span&gt;dev);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         spmi-&amp;gt;dev.platform_data =&lt;span&gt; pdata;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         dev_dbg(&amp;amp;spmi-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s:Platform data from board file\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;            __func__);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         pdata = spmi-&amp;gt;&lt;span&gt;dev.platform_data;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;     msm8x16 = kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; msm8x16_wcd), GFP_KERNEL);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (msm8x16 ==&lt;span&gt; NULL) {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         dev_err(&amp;amp;spmi-&amp;gt;&lt;span&gt;dev,
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s: error, allocation failed\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, __func__);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         ret = -&lt;span&gt;ENOMEM;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; rtn;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;     msm8x16-&amp;gt;dev = &amp;amp;spmi-&amp;gt;&lt;span&gt;dev;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     msm8x16-&amp;gt;read_dev =&lt;span&gt; __msm8x16_wcd_reg_read;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     msm8x16-&amp;gt;write_dev =&lt;span&gt; __msm8x16_wcd_reg_write;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     ret =&lt;span&gt; msm8x16_wcd_init_supplies(msm8x16, pdata);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret) {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         dev_err(&amp;amp;spmi-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s: Fail to enable Codec supplies\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            __func__);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; err_codec;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;     ret =&lt;span&gt; msm8x16_wcd_enable_static_supplies(msm8x16, pdata);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret) {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         dev_err(&amp;amp;spmi-&amp;gt;&lt;span&gt;dev,
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s: Fail to enable Codec pre-reset supplies\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;               __func__);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; err_codec;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     usleep_range(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;     ret =&lt;span&gt; msm8x16_wcd_device_init(msm8x16);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret) {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         dev_err(&amp;amp;spmi-&amp;gt;&lt;span&gt;dev,
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s:msm8x16_wcd_device_init failed with error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            __func__, ret);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; err_supplies;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     dev_set_drvdata(&amp;amp;spmi-&amp;gt;&lt;span&gt;dev, msm8x16);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;     ret = snd_soc_register_codec(&amp;amp;spmi-&amp;gt;dev, &amp;amp;&lt;span&gt;soc_codec_dev_msm8x16_wcd,
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                     msm8x16_wcd_i2s_dai,
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;                     ARRAY_SIZE(msm8x16_wcd_i2s_dai));
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret) {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         dev_err(&amp;amp;spmi-&amp;gt;&lt;span&gt;dev,
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s:snd_soc_register_codec failed with error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;            __func__, ret);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; rtn;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;err_supplies:
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;    msm8x16_wcd_disable_supplies(msm8x16, pdata);
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;err_codec:
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;    kfree(msm8x16);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;rtn:
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Fri, 02 Mar 2018 05:06:00 +0000</pubDate>
<dc:creator>yooooooo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linhaostudy/p/8425337.html</dc:identifier>
</item>
<item>
<title>《领域驱动设计》读书笔记 - 不如隐茶去</title>
<link>http://www.cnblogs.com/JacZhu/p/8492653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JacZhu/p/8492653.html</guid>
<description>&lt;p&gt;寒假快结束的时候，对软件架构设计感到了很多疑惑，微软的各种例子中虽然给出了样例代码，但是却没有一个总的指导纲领，只知道这些例子都是贯彻落实“领域驱动设计”这么一个概念的。那到底什么是领域驱动设计？如何实践领域驱动设计？领域驱动设计好处都有啥？带着这样的问题，我剁手买了一本书：《领域驱动设计：软件核心复杂性应对之道》并开始了阅读。&lt;/p&gt;
&lt;h2 id=&quot;模型驱动设计&quot;&gt;模型驱动设计&lt;/h2&gt;
&lt;p&gt;在平常，我们使用的最多的开发思路就是 CRUD，各种信息管理系统都可以看作是对数据库增删查改的封装，在应对小的项目的时候，CRUD 可真是神器，不管三七二十一，一把梭，第一期就完成了。但是随着客户需求的变更与增多，问题随之而来。为什么会导致这样的问题？作者给出的解释是，开发人员对业务没有深入的理解。就像是原来做一些很难的数学题一样，看到书后的参考答案（用户的最终目标），然后就开始尝试各种拼凑得出答案，虽然最后终于把答案拼装出来了，但是因为完全不懂原理，一旦题目做了一些变动，就会变得束手无策。作者在书中也举了很多类似的例子，例如开发团队一开始不太理解电子电路设计相关的知识，导致做出来的东西让对方感觉很奇怪，而且没法适应业务的变化。&lt;/p&gt;
&lt;p&gt;应对这个问题的解决方案就是对业务领域进行建模。在书中，作者反复提到了&lt;strong&gt;模型驱动设计（Model Driven Design）&lt;/strong&gt;这个名词，这里的模型，指的就是领域模型。构建领域模型需要一位对业务领域相当熟悉的专家跟开发团队共同努力。专家将自己的业务领域相关的知识拿出来与开发团队一起共享，这样开发团队才能正确认识到正在开发的东西要如何实现业务规则。&lt;/p&gt;
&lt;p&gt;那么如何描述这么一个领域模型呢？作者的建议是使用“&lt;strong&gt;统一的语言&lt;/strong&gt;”，这里的统一的语言主要是指开发团队要跟领域专家使用相同的术语指代同一个东西，这主要是为了避免交流过程中产生的理解上的障碍。就比如，大家在一起讨论地瓜这个东西怎么烹饪才好吃，结果每个人的说法都让对方感到非常奇怪，因为有的人认为地瓜指的是“沙葛”，有的人以为地瓜是说的“红薯”。&lt;/p&gt;
&lt;p&gt;将统一的语言跟模型绑定起来，在谈论领域模型的时候，都必须使用“统一的语言”进行描述，除此之外，在团队内部的交流中，更是应该始终坚持使用统一的语言进行交流，如果发现现有统一的语言用来讨论业务需求有些困难，就应该考虑是不是建模上面出现了偏差。作者强调：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;要认识到， UBIQUITOUS LANGUAGE 的更改就是对模型的更改。&lt;br/&gt;领域专家应该抵制不合适或无法充分表达领域理解的术语或结构，开发人员应该密切关注那些将会妨碍设计的有歧义和不一致的地方。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;领域模型还应该被文档化，作为口头交流和代码的补充。代码能够在很大程度上展现出模型的细节设计，但参与项目的人员还需要看到这个模型的全貌。开发团队内的交流可以帮助其他人理解模型的整体设计，在编码过程中起到指导作用，但是需要了解领域模型并不只是开发团队，所以，文档化的模型也是必要的。作者还建议，文档应该尽可能的少，主要用作口头交流跟代码的补充说明，同时还应该时时保持更新。当然了，最重要的是，文档同样应该使用前面提到的&lt;strong&gt;统一的语言&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;基于模型驱动设计的架构&quot;&gt;基于模型驱动设计的架构&lt;/h2&gt;
&lt;p&gt;领域模型最终还是要通过代码来进行实现，如果之前构建的模型跟代码脱节了，那这个模型驱动设计就变得名存实亡了。基于关注分离的这个原则，我们应该将代码中涉及到领域建模的部分分离出来。例如，一个医疗报销信息管理系统中，业务领域主要包括报销审批的流程控制、各部门预算管理，而像导出 Excel 报表之类的东西，并不是业务领域关注的重点，所以报销审批跟预算管理部分的代码应该与报表导出之类的代码分离。&lt;/p&gt;
&lt;p&gt;实现分离领域模型的技术我们非常的熟悉，就是&lt;strong&gt;分层架构&lt;/strong&gt;。作者建议，应该将项目代码按照“用户界面层”、“应用层”、“领域层（模型层）”、基础设施层进行划分。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;用户界面层&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;与客户端发生交互的地方，客户端可以是使用系统的人，还可以是其他调用本软件接口的系统&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;应用层&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;软件需要完成的与业务领域无关的工作在这里进行，例如信息管理系统打印报表的功能就属于应用层&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;领域层&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;整个业务软件的核心，负责表达业务相关的概念与规则&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;基础设施层&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;可以看作是整个系统的后勤部门，例如：为应用层提供打印能力，为领域层提供数据持久化的能力&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;各个层次内保持高内聚，各个层次间保持低耦合，而且耦合方向必须是高层依赖低层，例如上层调用下层的公共函数接口。只有做到这样，才能够帮助我们更好的集中注意力开发当前的层次，尤其是专注于领域层的设计，这将是领域驱动设计的精髓所在。&lt;/p&gt;
&lt;p&gt;当然，软件架构的技术不止分层一种，这里作者提到的只是最普遍的做法，只要能够达到将领域层分离的目的，使用其他的方式也是可以的。&lt;/p&gt;
&lt;h2 id=&quot;软件模型&quot;&gt;软件模型&lt;/h2&gt;
&lt;p&gt;当我们完成了领域建模部分的分离后，我们就应该全身心的专注于使用代码进行领域建模了。这里需要我们自己设计的模型主要分为下面几类：实体（Entity）、值对象（Value Object）、服务（Service）、模块（Module）。&lt;/p&gt;
&lt;h3 id=&quot;实体与值对象&quot;&gt;实体与值对象&lt;/h3&gt;
&lt;p&gt;模型驱动设计把业务对象分为两类：实体与值对象，区分一个对象在业务领域中到底属于实体还是值对象的方法非常简单——能否仅通过标识区别。这里标志类似于业务模型中的主键，可以是对象的某个属性，还可以是几个属性的组合，有时候，还可能是通过序列生成器生成的唯一 ID，一个对象是否拥有这样的标志，主要取决于我们的业务需要。&lt;/p&gt;
&lt;p&gt;举个例子，早餐店卖袋装豆浆，店铺不关心袋装豆浆的编号，只要有存货，就可以接着卖下去；而店内的座位则不同，因为店员需要知道订单要送到哪个座位上，这时候，我们的系统就不得不关注座位的编号。所以，在上面的系统中，座位应该被设计成实体，编号不同的座位应该加以区别。但是情况并不往往都是这样，假如上面的店铺店员不够用，店长决定改成让客人自己去餐台领餐的模式，这时候座位在我们的系统也就不需要跟订单关联，那么座位号也就会变得无关紧要，这时候再把座位设计为实体就会显得多余。&lt;/p&gt;
&lt;p&gt;那什么样的东西应该设计为值对象呢？考虑一个在学生信息管理系统中的名字类型：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Name
{
    &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; FirstName;
    &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; LastName;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据我们的常识，姓氏与名字一样的姓名应该是等价的，不管这个姓名对象我们手动 new 出来的，还是从数据库中读取并反序列化出来的，只要跟另一个姓名对象中的对应字段的值相等，那么这两个对象就是可以相互替换的。像这种情况，姓名对象在我们的领域模型中就应该是一个值对象。同时，值对象应该是不可变的，不包含标识，而且应该足够简单。再让我们回顾一下上面用 C# 代码定义的姓名类，可以发现他距离我们对值对象的定义还有些差距——没有重现比较规则、字段可变。与其去再去定义一堆重写的方法跟属性的访问控制器，不如尝试一下 .Net 家族中 F#，或者 JVM 系的 Kotlin。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode fs&quot;&gt;
&lt;code class=&quot;sourceCode fsharp&quot;&gt;//&lt;span class=&quot;co&quot;&gt; 使用 F# 定义姓名类&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; Name = { FirstName: &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;; LastName: &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;}

&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; nameA = { FirstName=&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;; LastName=&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt;}
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; nameB = { FirstName=&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;; LastName=&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt;}
printf &lt;span class=&quot;st&quot;&gt;&quot;%A&quot;&lt;/span&gt; (nameA = nameB)
//&lt;span class=&quot;co&quot;&gt; --&amp;gt; true&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;服务&quot;&gt;服务&lt;/h3&gt;
&lt;p&gt;在领域建模的过程中，往往需要封装一些操作和过程，这是时候就需要使用服务来表示这些操作。举个例子，在医疗报销信息管理系统中，&lt;strong&gt;员工&lt;/strong&gt;登记好的报销单需要&lt;strong&gt;提交&lt;/strong&gt;给相应的&lt;strong&gt;主管人员&lt;/strong&gt;审批才能生效。假设我们把提交这个操作作为员工实体的职责之一，但是这样做的话，员工对象可能还需要了解需要提交到哪位主任那里，如果我们的系统需要定义多种审核规则的话，那员工实体需要了解的东西就会变得很多。显然，将提交审核的操作封装为一个服务将会是一个更好的做法，员工实体只需要关注本年度自己的余额会被扣除就好了，而具体由哪位主任去审核，均由我们的&lt;strong&gt;报销单提交服务&lt;/strong&gt;负责处理。除了用来封装业务领域的操作，服务还可以用来封装领域层提供给上层（应用层）的接口，作为领域层的边界。&lt;/p&gt;
&lt;p&gt;但并不是所有的我们分析出来的服务都属于领域层。还是上面的例子，当审核提交成功的时候，需要给员工发个通知，我们可以在界面上弹个消息通知一下，或者使用短信通知一下，像这样的通知服务，就不属于业务领域的一部分。&lt;/p&gt;
&lt;p&gt;服务往往是使用一个动词来命名，而且，这个动词应该出现在“统一的语言&lt;br/&gt;中，服务的调用参数与返回结果也应该是领域对象。服务并不是把属于实体或值对象的职责据为己有的一个对象，而是对业务领域中一个有着重要作用的操作或者过程封装。同时，服务应该做到无状态，任何时候调用服务的任一个实例而不必关注服务实例的历史状态。&lt;/p&gt;
&lt;h3 id=&quot;模块&quot;&gt;模块&lt;/h3&gt;
&lt;p&gt;原文使用了 Module 这个词语，根据我的理解，这里 Module 对应到 C# 中指的是 NameSpace，在 Java 中指 package，在 Angular 中指 NgModule。模块不仅仅只是对代码的划分，同时还是对领域概念的划分。在对代码进行组织的时候，需要考虑到代码在领域层面的关联性。&lt;/p&gt;
&lt;h3 id=&quot;聚合&quot;&gt;聚合&lt;/h3&gt;
&lt;p&gt;上面提到了，使用模块可以将不同的领域概念划分，这仍然只是一个粗粒度的划分，在模块的内部我们还需要面对实体对象间错综复杂的联系（单向关联、双向关联）。具体的复杂性体现在，对一个对象的一些属性的修改，可能会导致新的对象的生成或者旧的对象的销毁，有时还可能伴随着对一些其他对象的修改。像这种牵一发而动全身的事情是我们在开发过程中最不希望看见的，那么应该如何知道，对一个对象修改的影响范围是从何处开始，又到哪里终止呢？聚合模式给出了一个解决方案。&lt;/p&gt;
&lt;p&gt;在聚合模式中，我们把几个关联度较高的对象划分成一个聚合，每个聚合中有一个小组长，我们把小组长叫做聚合根（Root），聚合的内部对象间可以相互引用，但要是想从聚合外引用里面的对象，这是不被允许的，从外部只能引用聚合根。如果要从外界访问聚合内部的实体，只能从聚合根那里获得一个不可变的引用，如果要访问聚合内部的值对象，也只能从聚合根那里获得值对象的一个拷贝。聚合内部的对象也只能由聚合根创建，一旦聚合根销毁，聚合内的全部实体跟值对象也都会一起被销毁。这也就是说，从聚合的外部不能随意的创建、删除或者修改属于某个聚合内部的对象，聚合变成了我们修改数据的最小单元。&lt;/p&gt;
&lt;p&gt;规则确实比较多，但是正是这些规则帮助我们简化了对对象生命周期的管理。在没有垃圾回收器的 Rust 语言中，也使用了类似的概念实现了对对象生命周期管理的能力。不过聚合除了管理对象生命周期之外还有贯彻落实业务规则的能力。比如在我们上面的学生信息管理系统中，&lt;strong&gt;姓名&lt;/strong&gt;很可能是属于&lt;strong&gt;学生&lt;/strong&gt;作为聚合根的聚合中的一个实体，所以&lt;strong&gt;姓名&lt;/strong&gt;对象的创建、修改操作由&lt;strong&gt;学生&lt;/strong&gt;来控制，这样的话，我们就可以把“姓名必须使用汉字”、“姓名长度不能超过 30 个汉字”这样的业务规则交由&lt;strong&gt;学生&lt;/strong&gt;来处理。&lt;/p&gt;
&lt;h3 id=&quot;工厂factory&quot;&gt;工厂（Factory）&lt;/h3&gt;
&lt;p&gt;正如上面所提到的，聚合根管理着整个聚合内对象的创建工作。这部分工作我们完全可以放在聚合根类型的构造函数中进行，然而一旦聚合内部的对象比较多，并且初始化过程比较复杂的话，这无疑会给构造函数带来很大压力——承担着一个初始化复杂对象集合的责任。而且这仅仅只是创建，别忘了聚合根还负责校验用来创建聚合内对象的数据是否符合业务规则的这一重任。如此想来，将创建聚合的工作交给其他的对象来做可能更好一些。注意到创建复杂对象并不是领域层中定义的业务的一部分，但这项工作确实又应该划入领域层，所以我们需要向领域层引入一个新的概念——工厂。工厂用来创建领域中复杂的对象。&lt;/p&gt;
&lt;p&gt;工厂的实现有很多种，在设计模式相关的书籍中提到了很多设计工厂的方法，如何设计工厂并不是模型驱动设计的关注点，我们更关注工厂能不能封装构建复杂对象的创建过程并且能够根据聚合的业务规则正确的创建一个聚合中的全部对象并返回聚合根。当然，我们设计的工厂应该尽可能的避免太复杂的依赖关系，否则这就打破了我们使用聚合的意义。举个例子，在我们的学生信息管理系统系统中，&lt;strong&gt;学生成绩单实体&lt;/strong&gt;的创建需要依赖&lt;strong&gt;学生实体&lt;/strong&gt;的相关信息，比如学生的联系方式跟姓名等信息。这时候我们就可以把学生成绩单工厂作为学生实体的一个方法，这样可以避免把学生实体中的一些信息提取到其他的地方。但是如果，学生成绩单的创建依赖一个序列生成服务，那么把这个工厂单独作为一个对象会更合适一些。&lt;/p&gt;
&lt;p&gt;除了创建全新的对象外，更加常见的场景是我们需要从数据库的数据中重建对象，尤其是重建实体，存入数据库前的实体跟从数据库中重建的实体如果标识相同的话，应该是同一个对象。为了应对这个场景，我们引入了一个新的领域设计模型——仓储（Repository）。&lt;/p&gt;
&lt;h3 id=&quot;仓储repository&quot;&gt;仓储（Repository）&lt;/h3&gt;
&lt;p&gt;数据持久化在大部分的项目中可以说是一个非常常见的操作了，但是这一操作往往涉及到对数据库相关软件包的依赖，这将极大的破坏领域模型的纯洁性。另一方面，如果允许开发人员随便的通过数据库驱动包直接从数据库中获取对象而无视聚合的规则，混乱的问题又将卷土重来。为此，我们将向领域层中引入新的模型——仓储。仓储的工作主要就是这些：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据持久化&lt;/li&gt;
&lt;li&gt;支持按照聚合的规则查询领域对象&lt;/li&gt;
&lt;li&gt;支持返回非领域对象的查询（比如数据库中的汇总查询）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在我看来，仓储的实现大多数情况下并不需要自己动手，在 Java 中，我们有 Hibernate，在 .Net 中，有 EF 跟 NHibernate。关于是否需要基于 EF 之上实现仓储模式的讨论已经有很多了，在这里我也不好给出一个肯定的结论。虽然 EF 并没有像 JPA 那样提供可选实现的接口，但是 EF Provider 本身就可以看作是一种提供给外部可供自由实现的接口，不过并不是所有的开发人员都能很轻松的实现这样的接口就是了。所以我个人认为基于 EF 之上重新实现一个仓储可能会更好一些。&lt;/p&gt;
&lt;h2 id=&quot;设计关联&quot;&gt;设计关联&lt;/h2&gt;
&lt;p&gt;写到这里，基本就把领域驱动设计中设计的几种模型都列举了出来，但是在我们的领域层中，领域对象之间的关联的设计也是非常重要的。用 UML 描述的话，就是类与类之间的关联关系。通常，双向关联往往在代码中意味着循环引用，而循环引用确实又不好处理。在书中，作者提出了一种使用查询来代替双向关联的做法，比如在我们的学生信息管理系统中，&lt;strong&gt;班级实体&lt;/strong&gt;中有个&lt;strong&gt;学生实体&lt;/strong&gt;列表，&lt;strong&gt;学生实体&lt;/strong&gt;有个&lt;strong&gt;班级&lt;/strong&gt;属性。如果在处理班级跟学生之间的双向关联感到了棘手的话，不妨把这个列表属性变成学生仓储的一个查询方法。这样，在我们的模型中，他们仍然可以保持双向关联的业务逻辑，但是在代码中，这种双向关联就变成了单向的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;领域驱动设计本质上就是模型驱动设计，我们使用实体、值对象、模块、聚合、服务、工厂、仓储这些元素设计我们的领域模型，在这个过程中，我们必须从始至终的使用“统一的语言”。在设计过程中，我们需要始终关注业务本身去设计模型，不断的去学习理解业务规则并保持领域层的纯洁性有助于我们构建出正确的符合业务原理的领域模型。&lt;/p&gt;
&lt;p&gt;另一方面，通过对这本书的阅读，我也终于能够理解工厂、服务、仓储这些概念出现的原因了，而不是上课老师给的代码里面的带着各种后缀的类名。&lt;/p&gt;
</description>
<pubDate>Fri, 02 Mar 2018 05:01:00 +0000</pubDate>
<dc:creator>不如隐茶去</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JacZhu/p/8492653.html</dc:identifier>
</item>
<item>
<title>使用 neon-wallet-db + neon-js + NEO-cli /rpc 搭建轻钱包服务端 - Yitim</title>
<link>http://www.cnblogs.com/yitim/p/how-to-connect-neon-js-tp-private-net.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yitim/p/how-to-connect-neon-js-tp-private-net.html</guid>
<description>&lt;p&gt;本文将搭建一个不具有任何功能的NEO轻钱包，所有的精力都仅集中于成功运行&lt;code&gt;neon-wallet-db&lt;/code&gt;项目并搭配全节点的&lt;code&gt;neo-cli /rpc&lt;/code&gt;接口为轻钱包客户端提供服务。&lt;br/&gt;首先需要准备几个项目：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/CityOfZion/neon-wallet-db&quot;&gt;neon-wallet-db&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CityOfZion/neon-js&quot;&gt;neon-js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/neo-project/neo-cli&quot;&gt;neo-cli&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后是劝退部分，即笔者完成壮举准备的环境：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;4台debian虚拟机，均运行共识节点&lt;/li&gt;
&lt;li&gt;4台虚拟机中一台作为&lt;code&gt;RPC&lt;/code&gt;节点运行提供&lt;code&gt;/rpc&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;4台虚拟机中另一台运行&lt;code&gt;neon-wallet-db&lt;/code&gt;项目&lt;/li&gt;
&lt;li&gt;运行&lt;code&gt;neon-wallet-db&lt;/code&gt;项目的前提如下：&lt;br/&gt;4.1 运行&lt;code&gt;mongodb&lt;/code&gt;服务端&lt;br/&gt;4.2 运行&lt;code&gt;redis&lt;/code&gt;服务端&lt;br/&gt;4.3 安装&lt;code&gt;python&lt;/code&gt;环境（笔者为 3.6.3）（建议搭配pyenv+virtualenv）&lt;br/&gt;4.4 安装&lt;code&gt;heroku cli&lt;/code&gt; 后续将使用&lt;code&gt;heroku local&lt;/code&gt;运行项目&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;neon-wallet-db-项目的必要性&quot;&gt;NEON-WALLET-DB 项目的必要性&lt;/h2&gt;
&lt;p&gt;neon社区维护的neon轻钱包项目实际上为一个 &lt;code&gt;react&lt;/code&gt; + &lt;code&gt;electron&lt;/code&gt; 的web项目，内部通过调用&lt;code&gt;neon-js&lt;/code&gt;提供的api实现与测试网乃至主网的交互。&lt;br/&gt;然后思考一下轻钱包是如何做到不同步全节点也能进行&lt;code&gt;transaction&lt;/code&gt;的。&lt;br/&gt;答案是不可能。这里的轻钱包不过是在远程调用&lt;code&gt;/rpc&lt;/code&gt;接口罢了，全节点由远程的&lt;code&gt;neo-cli&lt;/code&gt;来维护。&lt;br/&gt;那么问题来了，既然所有操作其实都是在调用&lt;code&gt;/rpc&lt;/code&gt;接口，那&lt;code&gt;neon-wallet-db&lt;/code&gt;项目又是用来做什么的？这还得从&lt;code&gt;nel-cli&lt;/code&gt;都提供了哪些接口说起：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4740306-eeded87466cdb4a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错就只有这么一些，而一个基于NEO的DAPP要做的事情就是用这么几个接口来搞事情。其中交易如何进行且不说，先关注如何查询交易记录(即区块链技术中广为流传的utxo)，毫无疑问这些utxo是包含在区块中并保存在全节点里的，那就需要一个接口来获取区块信息，也就是上面的&lt;code&gt;getblock&lt;/code&gt;接口：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4740306-1c68e52540a2a9eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示调用方法就是，拿区块索引来查区块信息，那如何实现查询一个地址的余额呢？用上面提供的&lt;code&gt;getbalance&lt;/code&gt;接口就想得太美了，此接口得前提是要打开钱包，也就是只能获取这个&lt;code&gt;neo-cli&lt;/code&gt;中打开的钱包的余额。真正做法是——遍历所有区块所有&lt;code&gt;utxo&lt;/code&gt;自己算。这就是为什么还需要&lt;code&gt;neon-wallet-db&lt;/code&gt;的原因，需要它来事先遍历、存储好uxto等数据，那么只要请求其提供的接口，就可以直接获取其处理过的方便使用的数据，而不需要遍历NEO全节点百万计(截至目前的测试网)的区块信息了。&lt;/p&gt;
&lt;h2 id=&quot;运行私链共识节点&quot;&gt;运行私链共识节点&lt;/h2&gt;
&lt;p&gt;私链的运行比较简单，下载官方的&lt;code&gt;neo-cli&lt;/code&gt;的&lt;code&gt;release&lt;/code&gt;就可以，运行若出现问题(可能性很大)需要积极浏览官方文档和&lt;code&gt;github README&lt;/code&gt;排查。&lt;/p&gt;
&lt;p&gt;4个共识节点的&lt;code&gt;protocol.json&lt;/code&gt;配置须保持一致，内容为节点ip地址和对应的共识地址公钥，这样才可能建立最小共识进而产生区块。&lt;/p&gt;
&lt;p&gt;其中还要选择一个共识节点运行&lt;code&gt;/rpc&lt;/code&gt;接口，命令为&lt;code&gt;dotnet neo-cli.dll /rpc&lt;/code&gt;，然后实际使用的rpc接口就是&lt;code&gt;http://192.168.1.x:20332&lt;/code&gt;(&lt;code&gt;rpc&lt;/code&gt;节点ip以及默认端口).&lt;/p&gt;
&lt;p&gt;官方的&lt;a href=&quot;http://docs.neo.org/zh-cn/node/private-chain.html&quot;&gt;私链搭建文档&lt;/a&gt;内容有些跳跃，让人搞不清何时用&lt;code&gt;neo-cli&lt;/code&gt;还是&lt;code&gt;neo-gui&lt;/code&gt;。其实回归字面共识的达成无非就是4个&lt;code&gt;neo-cli&lt;/code&gt;节点达成共识每隔15秒新增一个区块，没有&lt;code&gt;neo-gui&lt;/code&gt;什么事儿。实际上&lt;code&gt;NEO&lt;/code&gt;的测试网估计也是&lt;code&gt;protocol.json&lt;/code&gt;里那几个节点在跑&lt;code&gt;neo-cli&lt;/code&gt;，然后广大开发者用&lt;code&gt;cli&lt;/code&gt;或&lt;code&gt;gui&lt;/code&gt;去连接。那搭建私链也是一样，4台共识节点必不可少(什么共识后可以减为3台这种话直接忽略)。&lt;/p&gt;
&lt;p&gt;笔者这边就是捣鼓了4个linux虚拟机，然后在外部windows下连接上这个私链：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1107739/201803/1107739-20180302121955259-2074488173.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就只要保证四个节点的区块数据一致，&lt;code&gt;protocol.json&lt;/code&gt;配置一致，就可以任意连接到这个私链，甚至可以删掉全部的区块数据来重置这条私链。&lt;/p&gt;
&lt;h2 id=&quot;配置-neon-wallet-db-以及-neon-js&quot;&gt;配置 neon-wallet-db 以及 neon-js&lt;/h2&gt;
&lt;p&gt;共识节点的运行是整条私链的根本了，利用其提供的&lt;code&gt;/rpc&lt;/code&gt;接口可以做到所有事情，而&lt;code&gt;neon-wallet-db&lt;/code&gt;是用来缓存私链中的区块数据以免除某些需要遍历区块数据的操作(比如查询余额)。&lt;/p&gt;
&lt;p&gt;首先直接克隆这两个项目:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/CityOfZion/neon-js.git

git clone https://github.com/CityOfZion/neon-wallet-db.git&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;neon-js的修改&quot;&gt;neon-js的修改&lt;/h3&gt;
&lt;p&gt;neon-js默认会设置几个远程的&lt;code&gt;/rpc&lt;/code&gt;服务端以及运行着&lt;code&gt;neon-wallet-db&lt;/code&gt;的服务端。&lt;br/&gt;这里直接修改&lt;code&gt;src/api/neonDB.js&lt;/code&gt;以及&lt;code&gt;src/api/neoscan.js&lt;/code&gt;中的这个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1107739/201803/1107739-20180302122022793-1093824647.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个地址就是之后运行&lt;code&gt;neon-wallet-db&lt;/code&gt;项目的地址了。&lt;/p&gt;
&lt;h3 id=&quot;neon-wallet-db的修改&quot;&gt;neon-wallet-db的修改&lt;/h3&gt;
&lt;p&gt;neon-wallet-db 很厉害，使用&lt;code&gt;heroku&lt;/code&gt;来搭建，一个命令&lt;code&gt;heroku local&lt;/code&gt;搞定，然后就是要在一个干净的linux系统下解决报的错了。&lt;/p&gt;
&lt;p&gt;首先劝退，这东西在windows下安装比linux下要麻烦一些，因为涉及了&lt;code&gt;python&lt;/code&gt;、&lt;code&gt;heroku&lt;/code&gt;以及几个非关系型数据库。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;保证安装了&lt;code&gt;heroku cli&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装&lt;code&gt;MongoDB&lt;/code&gt;，全都使用默认配置，运行服务即可&lt;/li&gt;
&lt;li&gt;安装&lt;code&gt;Redis&lt;/code&gt;，使用默认配置，运行服务即可&lt;/li&gt;
&lt;li&gt;可以再安装&lt;code&gt;Memcache&lt;/code&gt;，不过笔者不想再挑战多一个数据库了，直接忽略也可以&lt;/li&gt;
&lt;li&gt;安装&lt;code&gt;python 3&lt;/code&gt;，笔者为&lt;code&gt;3.6.3&lt;/code&gt;，搭配了&lt;code&gt;pyenv + virtualenv&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;准备完毕后保证neon-wallet-db目录下的python环境为&lt;code&gt;3.6.3&lt;/code&gt;，然后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install -r requirements.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;api/util.py&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1107739/201803/1107739-20180302122038233-154326505.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;api/db.py&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1107739/201803/1107739-20180302122102549-321513454.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;禁用&lt;code&gt;memcache&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1107739/201803/1107739-20180302122117388-395817383.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;疑问:&lt;/p&gt;
&lt;p&gt;代码中涉及到&lt;code&gt;os.environ.get&lt;/code&gt;方法的操作会抛出异常，这受限于笔者对&lt;code&gt;python&lt;/code&gt;项目的理解不足，所以直接全都删掉，写死了配置。&lt;/p&gt;
&lt;p&gt;下一步操作是手动同步一下区块，新建一个&lt;code&gt;rebuild.py&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from apscheduler.schedulers.blocking import BlockingScheduler
from rq import Queue
from api import redis_db as conn
from api.blockchain import storeLatestBlockInDB, getBlockCount, blockchain_db, storeBlockInDB, checkSeeds, get_highest_node

for i in range(0,5) :
  storeBlockInDB(i)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的 &lt;code&gt;range(0, 5)&lt;/code&gt; 为想要遍历的高度，也就是，手动把 1~5 的区块数据给存储下来，直接执行&lt;code&gt;python rebuild.py&lt;/code&gt;即可。对于区块中又大量数据的，可以这么做先自行存储数据，然后运行整个项目时再从已存储高度继续。为了做到这一步还得把项目里几个地方的区块高度值都对应起来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1107739/201803/1107739-20180302122131524-2012573177.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;然后可以做什么&quot;&gt;然后可以做什么&lt;/h2&gt;
&lt;p&gt;一切顺利的情况下执行&lt;code&gt;heroku local&lt;/code&gt;，应该就会看见三种颜色的log在不停跳动了。然后确保log中没有错误，并尝试访问接口&lt;code&gt;/v2/block/height&lt;/code&gt;，如果高度跟私链中真实高度一致，那就完美了。&lt;/p&gt;
&lt;p&gt;至此我们拥有了三个神器：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;/rpc节点服务端(neo-cli)&lt;/li&gt;
&lt;li&gt;区块数据服务端(neon-wallet-db)&lt;/li&gt;
&lt;li&gt;neon-js&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;他们之间的关系用一张图来表达就是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1107739/201803/1107739-20180302122143811-1989885050.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中黄色部分为底层节点以及接口，绿色部分为定期从&lt;code&gt;/rpc&lt;/code&gt;更新数据的缓存接口，粉色部分就是轻钱包客户端，自身不保存区块数据，实则保存在缓存接口中。&lt;/p&gt;
&lt;p&gt;至于如何进行轻钱包开发，也就是用轻钱包做到交易转账、合约调用这些有实际意义的事情，还有很多篇幅可以讲 : )&lt;/p&gt;
</description>
<pubDate>Fri, 02 Mar 2018 04:23:00 +0000</pubDate>
<dc:creator>Yitim</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yitim/p/how-to-connect-neon-js-tp-private-net.html</dc:identifier>
</item>
<item>
<title>记录前端的面试日常(持续更新) - 房东家的猫</title>
<link>http://www.cnblogs.com/fangdongdemao/p/8492563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fangdongdemao/p/8492563.html</guid>
<description>&lt;h3 id=&quot;写在前面的话&quot;&gt;写在前面的话&lt;/h3&gt;
&lt;p&gt;又到了跳槽的季节,现在也该总结一下自己在前端积累这么多年的一点珍藏的货色了,注意了我主要总结是尽量用自己能表达的想法去说,所有可能没别人总结的那么客观,还有尽量用简短的话简单的思路去表达应该有的意思,方便记忆理解,还有这篇博文我会持续更新的&lt;/p&gt;
&lt;h3 id=&quot;什么叫优雅降级和渐进增强这个其实很多的但是我是不可能去背的所有尽量用少的话总结清楚&quot;&gt;什么叫优雅降级和渐进增强(这个其实很多的,但是我是不可能去背的,所有尽量用少的话,总结清楚)&lt;/h3&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code&gt;.transition{
  -webkit-transition: all .5s;
     -moz-transition: all .5s;
       -o-transition: all .5s;
          transition: all .5s;  
}//渐进增强
.transition{ 
     transition: all .5s;
  -o-transition: all .5s;
  -moz-transition: all .5s;
-webkit-transition: all .5s;
}//优雅降级&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优雅降级:一开始就构建完整的功能,然后再针对低版本浏览器进行兼容&lt;/p&gt;
&lt;p&gt;渐进增强:针对低版本浏览器进行构建页面,保证最基本的功能,然后再针对高级浏览器进行效果.交互等改进和追加功能达到最好的用户体验&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;jquery的实现原理&quot;&gt;jQuery的实现原理&lt;/h3&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;(functon(window,undefined){})(window)&lt;/p&gt;
&lt;p&gt;jQuery利用JS函数作用域的特性,采用立即调用表达式包裹了自身,解决命名空间和变量污染问题&lt;/p&gt;
&lt;p&gt;window.jQuery=window.$=jQuery&lt;/p&gt;
&lt;p&gt;在闭包当中将jQuery和$()绑定到window上,从而jQuery和$暴露为全局变量&lt;/p&gt;
&lt;p&gt;jQuery.fn的init方法返回的this就是jQuery对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;jquery-的属性拷贝extend的实现原理是什么如何实现深拷贝&quot;&gt;jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;浅拷贝(只复制一份原始对象的引用)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;var newObject=$.extend({},oldObject)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;深拷贝(对原始对象实行所引用的对象进行递归拷贝)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;var newObject=$.extend(true,{},oldObject)&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;清除浮动&quot;&gt;清除浮动&lt;/h3&gt;
&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;p&gt;第一种&lt;code&gt;overflow:hidden&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二种&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.clearfix&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;:after&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;content:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;.&quot;&lt;/span&gt;,
  diplay:&lt;span class=&quot;dt&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;hieght:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;clear:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;both&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;visibility:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;hidden&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;最快速的数组求最大值&quot;&gt;最快速的数组求最大值&lt;/h3&gt;
&lt;blockquote readability=&quot;12.75625&quot;&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;max&lt;/span&gt;(...&lt;span class=&quot;at&quot;&gt;arr&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//es6&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;math&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;max&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;arr)&lt;span class=&quot;co&quot;&gt;//es5 apply&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//for循环&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; max&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;arr[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  max&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;arr[i]&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;arr[i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;?&lt;/span&gt;arr[i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;]:arr[i]
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//数组sort()&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;sort&lt;/span&gt;((num1&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;num2)&lt;span class=&quot;op&quot;&gt;=&amp;gt;{&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; num1&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;num2&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;co&quot;&gt;//回忆a-b升序b-a降序,同理喔&lt;/span&gt;
arr[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]

&lt;span class=&quot;co&quot;&gt;//数组reduce&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//这个还是需要科普一下&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//aray的reduce()把一个函数作用在整个Array的[x1,x2,x3,x4...]上,这个必须接受两个&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//参数,reduce()把结果继续和序列的下一个元素做累计计算,怎么感觉有点像map&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//感觉没有解释清楚,下面给个地址&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;reduce&lt;/span&gt;((num1&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;num2)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; num1&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;num2&lt;span class=&quot;op&quot;&gt;?&lt;/span&gt;num1:num2&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001435119854495d29b9b3d7028477a96ed74db95032675000&quot;&gt;reduce科普&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数组去重&quot;&gt;数组去重&lt;/h3&gt;
&lt;blockquote readability=&quot;13.5&quot;&gt;
&lt;p&gt;&lt;code&gt;[... new Set([2,&quot;23&quot;,&quot;2&quot;,&quot;5&quot;,12,5,6,12])]&lt;/code&gt;最快速的方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最简单的方法&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;arr1&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; n&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;n&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;indexOf&lt;/span&gt;(arr[i])&lt;span class=&quot;op&quot;&gt;==-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;va&quot;&gt;n&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(arr[i])
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; n&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;cookie-.-sessionstorage-.-localstorage的区别资料&quot;&gt;cookie . sessionStorage . localStorage的区别&lt;a href=&quot;https://www.cnblogs.com/cencenyue/p/7604651.html&quot;&gt;资料&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;cookie是网站为了标识用户身份而存储在用户本地终端上的数据&lt;/p&gt;
&lt;p&gt;cookie数据使用在同源的http请求中携带,会在浏览器和服务器来回传递&lt;/p&gt;
&lt;p&gt;webStorage目的:克服cookie带来的一些限制,当数据需要被严格控制在客户端是,不需要持续的将数据发回服务器&lt;/p&gt;
&lt;p&gt;webstorage提供两种API:localstorage(本地存储)和sessionStorage&lt;/p&gt;
&lt;p&gt;生命周期:&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;sessionStorage(本地存储) &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;永久的,关闭网页也不会消失,除非主动删除数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;localStorage(会话存储)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据在当前浏览器窗口关闭后自动删除&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;cookie     设置的cookie过期时间之前一直有效,即使浏览器关闭&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;sessionStorage(本地存储)和localStoratge(会话存储)不会自动把数据发给服务器,仅仅本地保存&lt;/p&gt;
&lt;p&gt;存储大小:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cookie --&amp;gt;4k&lt;/li&gt;
&lt;li&gt;sessionStorage和localStorage --&amp;gt;5m或更大&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;javascript有几种类型的值&quot;&gt;javascript有几种类型的值&lt;/h3&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;:原始数据类型(undefined,null,Boolean,number,string)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;:引用数据类型(对象,数组,函数)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt;:存储位置不同&lt;/p&gt;
&lt;p&gt;原始类型数据直接存储在栈的简单数据段&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;占据空间小,大小固定,属于被平凡使用数据,所以放在栈中存储&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;引用数据类型存储在堆中的对象&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;占据空间大,大小不固定,如果存储在栈中,将会影响程序运行的性能&lt;/li&gt;
&lt;li&gt;引用数据类型在栈中存储了指针,该指针指向该实体的起始地址&lt;/li&gt;
&lt;li&gt;当解释器寻找引用值时,会首先检索在栈中的地址,取得地址后从堆中获取实体&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://p3vo2n0jj.bkt.clouddn.com/prefix_20180227220559.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;javascript如何实现继承&quot;&gt;javascript如何实现继承&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。
 
    function Parent(){
        this.name = 'wang';
    }

    function Child(){
        this.age = 28;
    }
    Child.prototype = new Parent();//继承了Parent，通过原型

    var demo = new Child();
    alert(demo.age);
    alert(demo.name);//得到被继承的属性&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;什么是doctype&quot;&gt;什么是doctype&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;DTD&lt;/strong&gt;就是告诉浏览器我是什么文档类型,用这个来判断我用什么来解析它渲染它&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;doctype&lt;/strong&gt;就是通知浏览器哪个DTD和文档类型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;!doctypehtml&amp;gt;&lt;/code&gt;---&amp;gt;HTML5&lt;/p&gt;
&lt;p&gt;HTML4.0有两个模式:严格模式和宽松模式&lt;/p&gt;
&lt;h3 id=&quot;内核的理解&quot;&gt;内核的理解&lt;/h3&gt;
&lt;p&gt;分为两个部分:渲染引擎和js引擎&lt;/p&gt;
&lt;p&gt;渲染引擎:负责取得网页的内容(html,css)&lt;/p&gt;
&lt;p&gt;js引擎:解析和执行javascript来实现网页的动态效果,但是后来js引擎越来越独立了(V8引擎)&lt;/p&gt;
&lt;h3 id=&quot;有一个长度100的数组算前10项的和&quot;&gt;有一个长度100的数组,算前10项的和&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; var a=[1,2,34,4,5,6,76,7,1,2,3,4,5,6,7]
      sun=null;
      sun=a.slice(0,10).reduce(function(pre,current){
        return pre+current;
      })
      console.log(sun);//reduce可以看前面最大值&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;javascript优化&quot;&gt;javascript&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/8006285.html&quot;&gt;优化&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;松耦合&lt;/strong&gt;:当修改一个组件而不需要改其他组件时,就做到松耦合&lt;/p&gt;
&lt;p&gt;将js从css中抽出,不要使用css表达式&lt;/p&gt;
&lt;p&gt;将css从js中抽出:通过js修改css样式时,使用className或classList&lt;/p&gt;
&lt;p&gt;将js从html抽离:从js外置文件&lt;/p&gt;
&lt;p&gt;将HTML从js中抽离:不要使用innerHTML使用字符串模板&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;零全局变量&lt;code&gt;(function(){})(window)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;单全局变量(jQuery)和命名空间&lt;/p&gt;
&lt;p&gt;模块&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;隔离应用逻辑(将应用逻辑和事件处理的代码拆分开)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; MyApplication &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;handleClick&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(event)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;showPopup&lt;/span&gt;(event)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;showPopup&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(event)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; popup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'popup'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;popup&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clientX&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'px'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;popup&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clientY&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'px'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;popup&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;className&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'reveal'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;addListener&lt;/span&gt;(element&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'click'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(event)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;MyApplication&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;handleClick&lt;/span&gt;(event)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不要分发事件对象&lt;/p&gt;
&lt;p&gt;让事件处理程序使用event对象来处理事件,然后拿到所有需要的数据传到应用逻辑&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//改进的做法
var MyApplication = {
  handleClick: function(event){
    this.showPopup(event.clientX,event.clientY);
  },
  showPopup: function(x,y){
    var popup = document.getElementById('popup');
    popup.style.left = x + 'px';
    popup.style.top = y + 'px';
    popup.className = 'reveal';
  }
};
addListener(element,'click',function(event){
  MyApplication.handleClick(event);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;记得在事件处理程序应当在进入应用逻辑之前针对event对象执行任何必要的操作,包括阻止时间冒泡,都应该包含在事件处理程序中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//改进的做法
var MyApplication = {
  handleClick: function(event){
    event.preventDefault();
    event.stopPropagation();
    this.showPopup(event.clientX,event.clientY);
  },
  showPopup: function(x,y){
    var popup = document.getElementById('popup');
    popup.style.left = x + 'px';
    popup.style.top = y + 'px';
    popup.className = 'reveal';
  }
};
addListener(element,'click',function(event){
  MyApplication.handleClick(event);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感觉这个需要日积月累,感觉前面是有无数的坑等着你踩&lt;code&gt;先完成功能然后再考虑优化的问题&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程和进程的区别&quot;&gt;线程和进程的&lt;a href=&quot;https://www.zhihu.com/question/25532384&quot;&gt;区别&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;node进程启动过后默认会创建一个线程,线程用于执行我们的代码&lt;/p&gt;
&lt;p&gt;一个进程可以有多个线程,所有进程与线程是包含与被包含的关系&lt;/p&gt;
&lt;p&gt;进程(程序):一个静态概念,一个class文件,一个exe文件&lt;/p&gt;
&lt;p&gt;线程:是一个程序里面不同的执行路径&lt;/p&gt;
&lt;h3 id=&quot;二叉树遍历&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/fly-me/p/wei-ti-jiaoer-cha-shu-de-si-zhong-bian-li-fang-fa.html&quot;&gt;二叉树遍历&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先序遍历:顺序&lt;code&gt;根左右&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;中序遍历:顺序&lt;code&gt;左根右&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;后序遍历:顺序&lt;code&gt;左右根&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;层序遍历:顺序&lt;code&gt;从上到下从左到右分层遍历&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前序遍历&lt;/strong&gt;:先访问根节点,然后前序遍历左子树,再前序遍历右子树(中左右)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3vo2n0jj.bkt.clouddn.com/prefix_20180301120234.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中序遍历&lt;/strong&gt;:从根节点开始(注意不是先访问根节点),中序遍历根节点的左子树,然后是访问根节点,左后遍历根节点的右子树(左中右)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3vo2n0jj.bkt.clouddn.com/prefix_20180301121646.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里还是要多罗嗦一些东西,因为我有时还是有点不太懂(这样是不是稍微清晰了一点)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3vo2n0jj.bkt.clouddn.com/prefix_20180301121847.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/soundwave_/article/details/53120766&quot;&gt;中序遍历&lt;/a&gt;：BDCAEHGKF&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后序遍历&lt;/strong&gt;:从左到右先叶子后节点的方式遍历访问根节点(左右中)//怎么有点像css遍历从上到下从右到左&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3vo2n0jj.bkt.clouddn.com/prefix_20180301120703.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;层序遍历&lt;/strong&gt;:从树的第一层,也就是根节点开始访问,从上到下逐层遍历,在同一层中,按从左到右的顺序结构访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3vo2n0jj.bkt.clouddn.com/prefix_20180301143846.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;浏览器的渲染原理&quot;&gt;浏览器的渲染原理&lt;/h3&gt;
&lt;p&gt;当浏览器获取html文件时,会&quot;自上而下&quot;加载,并在加载过程解析渲染&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/peteremperor/p/6285449.html&quot;&gt;&lt;strong&gt;解析&lt;/strong&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;浏览器会将HTML解析成一个DOM树,DOM树的构建过程是一个深度遍历过程:当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点&lt;/p&gt;
&lt;p&gt;将CSS解析成CSS Rule Tree&lt;/p&gt;
&lt;p&gt;根据DOM树和CSSOM树来构造Rendering Treen,注意:Rendering Tree渲染树并不等同于DOM树,因为一些想header或display:none的东西就没必要放在渲染树中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3vo2n0jj.bkt.clouddn.com/prefix_20180301154157.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了Render Tree,浏览器已经能知道网页中有哪些节点.各个节点的CSS定义以及他们的从属关系,下一步操作称之为Layout就是计算出每个节点在屏幕中的位置&lt;/p&gt;
&lt;p&gt;然后就进行绘制,遍历render树,并使用UI后端层绘制每一个节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;终于说到重点了,影响浏览器渲染主要有:reflow(回流)和repaint(重绘)&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;回流Reflow&lt;/strong&gt;(渲染机制类)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DOM结构中的各个元素都有自己的盒子模型,这些需要浏览器根据各种样式计算并根据计算结果将元素放在该出现的位置,这个过程称reflow&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;触发Reflow&lt;/p&gt;
&lt;p&gt;重绘Repaint&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;页面呈现的内容放在页面上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;触发Reqaint&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;DOM改动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSS改动&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;尽量避免reflow(回流)&lt;/p&gt;
&lt;p&gt;reflow想想怎么可能避免呢?那只能将reflow对性能的影响减到最小&lt;/p&gt;
&lt;blockquote readability=&quot;26&quot;&gt;
&lt;p&gt;比如需要改变元素的样式,不要通过父级元素影响子元素,最好直接加载子元素&lt;/p&gt;
&lt;p&gt;设置style属性改变样式的话,没设置一次都会导致一次reflow,最好就是设置class的方式&lt;/p&gt;
&lt;p&gt;避免不必要的复杂的css选择器,尤其是后代选择器(这里肯定会有人反驳了,我用的是less,就看看解析的时候,后代有多长,看着多怕,哥们要不你用sess或者sass,有个属性可以直接跳出选择器&lt;code&gt;@at-root&lt;/code&gt;less有没有我也不知道)&lt;/p&gt;
&lt;p&gt;还有就是不要用tables布局&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;es6&quot;&gt;&lt;a href=&quot;http://caibaojian.com/30-seconds-of-code.html&quot;&gt;ES6&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;从数组中移出falsey值&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;使用Array.filter()删选出falsey值(false,null,0,&quot;&quot;,undefined和NaN)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const compact=arr=&amp;gt;arr.filter(Boolean);
console.log(compact([0, 1, false, &quot;&quot;, 3, &quot;s&quot;,&quot;e&quot;*23,&quot;a&quot;, NaN]));&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;ajax&quot;&gt;Ajax&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;$.ajax({//jQuery
  url:&quot;http://www.baidu.com&quot;,//请求的url地址
  dataType:&quot;json&quot;,//返回的数据格式
  data:{} //参数
  type:&quot;GET&quot;
  success:function(data){
    //请求成功的请求
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  // 1.创建
            var ajax = new XMLHttpRequest();
            // 2设置
            ajax.open('get', 'Ajax_get.php');
            // 3.发送
            ajax.send(null);
            // 4.状态事件
            ajax.onreadystatechange = function() {
                        if (ajax.readyState == 4 &amp;amp;&amp;amp; ajax.status == 200) {
                                    // 5.使用返回的数据 修改页面的内容
                                    // responseText 返回的就是一个 字符串
                                    // 我们 在ajax 中 如果 是通过 ajax.responseText 获取到的 统统都是字符串
                                    console.log(ajax.responseText);
                        }
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;var ajax = new XMLHttpRequest();

        // 使用post请求
        ajax.open('post','ajax_post.php');

        // 如果 使用post发送数据 必须 设置 如下内容
        // 修改了 发送给 服务器的 请求报文的 内容
        // 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：
        ajax.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
        // 发送
        // post请求 发送的数据 写在 send方法中 
        // 格式 name=jack&amp;amp;age=18 字符串的格式
        ajax.send('name=jack&amp;amp;age=998');

        // 注册事件
        ajax.onreadystatechange = function () {
            if (ajax.readyState==4&amp;amp;&amp;amp;ajax.status==200) {
                console.log(ajax.responseText);
            }
        }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 02 Mar 2018 04:18:00 +0000</pubDate>
<dc:creator>房东家的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fangdongdemao/p/8492563.html</dc:identifier>
</item>
<item>
<title>Spring Boot 2.0(一)：【重磅】Spring Boot 2.0权威发布 - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/8492422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/8492422.html</guid>
<description>&lt;p&gt;就在昨天Spring Boot&lt;code&gt;2.0.0.RELEASE&lt;/code&gt;正式发布，今天早上在发布Spring Boot2.0的时候还出现一个小插曲，将Spring Boot2.0同步到Maven仓库的时候出现了错误，然后Spring Boot官方又赶紧把 GitHub 上发布的 v2.0.0.RELEASE 版本进行了撤回。到了下午将问题修复后，又重新进行了上传，至此Spring Boot2.0正式推出！&lt;/p&gt;
&lt;p&gt;要知道这是Spring Boot1.0发布4年之后第一次重大修订，因此有多的新功能和特性值得大家期待！在Spring Boot官方博客中我们了解到：Spring Boot2.0版本经历了 17 个月的开发，有 215 个不同的使用者提供了超过 6800 次的提交，并表示非常感谢提供贡献的每一位用户，和所有对这些里程碑版本提供重要反馈的早期采用者。&lt;/p&gt;
&lt;p&gt;熟悉Spring Boot/Cloud的技术者们都知道，Spring Boot依赖于Spring，而Spring Cloud又依赖于Spring Boot，因此Spring Boot2.0的发布正式整合了Spring5.0的很多特性，同样后面Spring Cloud最新版本的发布也需要整合最新的Spring Boot2.0内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2018/springboot/new.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新版本特性&quot;&gt;新版本特性&lt;/h2&gt;
&lt;p&gt;新版本值得关注的亮点有哪些：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于 Java 8，支持 Java 9&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是说Spring Boot2.0的最低版本要求为JDK8，据了解国内大部分的互联网公司系统都还跑在JDK1.6/7上，因此想要升级到Spring Boot2.0的同学们注意啦，同时支持了Java9，也仅仅是支持而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应式编程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 Spring WebFlux/WebFlux.fn提供响应式 Web 编程支持， Webflux 是一个全新的非堵塞的函数式 Reactive Web 框架，可以用来构建异步的、非堵塞的、事件驱动的服务，在伸缩性方面表现非常好，此功能来源于Spring5.0。&lt;/p&gt;
&lt;p&gt;Spring Boot2.0也提供对响应式编程的自动化配置，如：Reactive Spring Data、Reactive Spring Security 等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP/2支持&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Tomcat, Undertow 和 Jetty 中均已支持 HTTP/2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对Kotlin支持&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引入对 Kotlin 1.2.x 的支持，并提供了一个 runApplication 函数，让你通过惯用的 Kotlin 来运行 Spring Boot 应用程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全新的执行器架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全新的执行器架构，支持 Spring MVC, WebFlux 和 Jersey&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持 Quartz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot1.0并没有提供对 Quartz 的支持，之前出现了各种集成方案，Spring Boot2.0给出了最简单的集成方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Security&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大大的简化了安全自动配置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Metrics&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Metrics方面，Spring Boot 2引入了Micrometer，来统一metrics的规范，使得开发人员更好的理解和使用metrics的模块，而不需要关心对接的具体存储是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监控方面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot 2 增强了对 Micrometer 的集成。RabbitMQ、JVM 线程和垃圾收集指标会自动进行 instrument 监控，异步控制器(controller)也会自动添加到监控里。通过集成，还可以对 InfluxDB 服务器进行监控。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据方面&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;db方面，默认引入了HikariCP，替代了之前的tomcat-pool作为底层的数据库连接池， 对比于tomcat-pool， HikariCP拥有更好的性能，总而言之就是提高了db的访问速度&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;JOOQ的支持&lt;/li&gt;
&lt;li&gt;Redis方面， 默认引入了Lettuce, 替代了之前的jedis作为底层的redis链接方式&lt;/li&gt;
&lt;li&gt;MongoDB\Hibernate优化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Thymeleaf 3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot 2支持了Thymeleaf 3，Thymeleaf 3相对于Thymeleaf 2性能提升可不是一点点，因为2.0的性能确实不咋地，同时也使用了新的页面解析系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OAuth 2.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同时也加入了 对于OAuth 2.0的支持， 使得开发人员更加友好的使用spring-security来完成权限模块的开发&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖组件的更新&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Jetty 9.4&lt;/li&gt;
&lt;li&gt;Tomcat 8.5&lt;/li&gt;
&lt;li&gt;Flyway 5&lt;/li&gt;
&lt;li&gt;Hibernate 5.2&lt;/li&gt;
&lt;li&gt;Gradle 3.4&lt;/li&gt;
&lt;li&gt;Thymeleaf 3。0&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最后还有一个小彩蛋，Spring Boot2.0支持了动态gif的启动logo打印.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;技术名词解释&quot;&gt;技术名词解释&lt;/h2&gt;
&lt;p&gt;Spring 现在作为Java开源界的老大，它的一举一动都影响着行业的技术方向，在这次发布的 Release Notes中发现有很多的技术都还没有了解过，也分享出来：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WebFlux 是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WebFlux 模块的名称是 spring-webflux，名称中的 Flux 来源于 Reactor 中的类 Flux。Spring webflux 有一个全新的非堵塞的函数式 Reactive Web 框架，可以用来构建异步的、非堵塞的、事件驱动的服务，在伸缩性方面表现非常好。&lt;/p&gt;
&lt;p&gt;非阻塞的关键预期好处是能够以小的固定数量的线程和较少的内存进行扩展。在服务器端 WebFlux 支持2种不同的编程模型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于注解的 @Controller 和其他注解也支持 Spring MVC&lt;/li&gt;
&lt;li&gt;Functional 、Java 8 lambda 风格的路由和处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2018/springboot/webflux.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，Spring Boot 2使用Netty WebFlux，因为Netty在异步非阻塞空间中被广泛使用，异步非阻塞连接可以节省更多的资源，提供更高的响应度。通过比较Servlet 3.1非阻塞I / O没有太多的使用，因为使用它的成本比较高，Spring WebFlux打开了一条实用的通路。&lt;/p&gt;
&lt;p&gt;值得注意的是：支持reactive编程的数据库只有MongoDB, redis, Cassandra, Couchbase&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP/2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相比 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。&lt;/li&gt;
&lt;li&gt;HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。&lt;/li&gt;
&lt;li&gt;多路复用，直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。&lt;/li&gt;
&lt;li&gt;Server Push：服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;JOOQ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JOOQ 是基于Java访问关系型数据库的工具包。JOOQ 既吸取了传统ORM操作数据的简单性和安全性，又保留了原生sql的灵活性，它更像是介于 ORMS和JDBC的中间层。对于喜欢写sql的码农来说，JOOQ可以完全满足你控制欲，可以是用Java代码写出sql的感觉来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lettuce&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lettuce是一个可伸缩的线程安全的Redis客户端，用于同步，异步和反应使用。 多个线程可以共享同一个RedisConnection。它利用优秀netty NIO框架来高效地管理多个连接。 支持先进的Redis功能，如Sentinel，集群，流水线，自动重新连接和Redis数据模型。&lt;/p&gt;
&lt;p&gt;国内使用Jedis的居多，看来以后要多研究研究Lettuce了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HikariCP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HikariCP是一个高性能的JDBC连接池。Hikari是日语“光”的意思。可能是目前java业界最快的数据库连接池。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flyway&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flyway是独立于数据库的应用、管理并跟踪数据库变更的数据库版本管理工具。用通俗的话讲，Flyway可以像SVN管理不同人的代码那样，管理不同人的sql脚本，从而做到数据库同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gson&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Gson 是google解析Json的一个开源框架,同类的框架fastJson,JackJson等等&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;看完 Spring Boot 2.0 Release Notes ，发现又有很多不知道的新技术了，以后有的学了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;是否选择升级&quot;&gt;是否选择升级&lt;/h2&gt;
&lt;p&gt;通过以上内容可以看出Spring Boot2.0相对于1.0增加了很多新特性，并且最重要的是Spring Boot2.0依赖的JDK最低版本是1.8，估计国内大多互联网公司还么这么激进。另外一个新的重大版本更新之后，难免会有一些小Bug什么的，往往需要再发布几个小版本之后，才会慢慢稳定下来。&lt;/p&gt;
&lt;p&gt;因此我的建议是，如果不是特别想使用Spring Boot2.0上面提到的新特性，就尽量不要着急进行升级，等Spring Boot2.0彻底稳定下来后再使用。如果想要升级也请先从早期的版本升级到Spring Boot1.5X系列之后，再升级到Spring Boot2.0版本，Spring Boot2.0的很多配置内容和Spring Boot1.0不一致需要注意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot1.0发布之后给我们带来了全新的开发模式，Spring Boot2.0发布标志着Spring Boot已经走向成熟，对Java界带来的变革已经开启！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;前两天在看池建强老师文章时，发现老师刚好也介绍了Spring Boot2.0，其中有这么一个观点：Java 语言为什么能够长期占据编程兵器排行榜第一名的位置呢？因为命好。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Java 能长盛不衰，主要是命好。每当人们觉得 Java 不行了的时候，总会有英雄横刀救美。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最初 Java 开发出来不知道有什么用的时候，发现可以用 Applet 在网页上做动画。后来企业级软件开发时代 JavaEE 大行其道，开源社区 Spring 桃李满天下。等到了移动时代，人们觉得 Java 要完蛋了，Google 拍马救市，收购并开放了 Android 平台，当家语言就是 Java，于是 Java 再次焕发勃勃生机。目前大数据领域，Java 同样是当仁不让的好手。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;现在 Spring Framework 那套东西使用了十几年，正当大家被长达几千行的 ApplicationContext 配置文件折磨的死去活来的时候，Spring Boot 诞生了。什么是 Spring Boot？用来简化 Spring 应用程序开发的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;换句话说就是，当你觉得 Java 不好用的时候，我做了个轻量级的 S，让你好好用 Java。等你觉的 S 也不够轻了，我做了个 SB，让你觉得 S 还是挺轻的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从2002年Rod Johnson的&lt;code&gt;interface21&lt;/code&gt;到如今的&lt;code&gt;Spring Boot2.0&lt;/code&gt;，Spring 走过了16年的春秋，经历了N多的贡献者，Spring 也从一个小小的开源框架，发展成Java领域最成功的开源软件没有之一！同时做为一名Java开发从业者，也特别的感谢Spring这类的开源组织，为推动企业级开发做了巨大的贡献，全世界的Java开发者都是它的受益者！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2018/life/spring.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向Spring致敬，向开源致敬！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ityouknow.com/spring-boot.html&quot;&gt;点我了解更多Spring Boot系列文章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes&quot;&gt;Spring Boot 2.0 Release Notes&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://spring.io/blog/2018/03/01/spring-boot-2-0-goes-ga&quot;&gt;Spring Boot 2.0 goes GA&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.oschina.net/news/93772/spring-boot-2-0-released-not-yet&quot;&gt;​Spring Boot 2.0 同步至 Maven 仓库出错，已撤回……&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 02 Mar 2018 03:44:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ityouknow/p/8492422.html</dc:identifier>
</item>
<item>
<title>CSS 圣杯布局升级版---多个固定宽度一个自适应宽度 - 站住，别跑</title>
<link>http://www.cnblogs.com/zjjDaily/p/8492400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjjDaily/p/8492400.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.一个div固定，一个div自适应宽度。两种情况，固定在左或者在右。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1040666/201803/1040666-20180302094138128-1455515326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HTML：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        内容自适应宽度
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;aside&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        侧栏固定宽度
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种情况的HTML排版顺序都是一样的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CSS：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;右边固定宽度：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box1 &lt;/span&gt;{&lt;span&gt;
  clear&lt;/span&gt;:&lt;span&gt; both&lt;/span&gt;;&lt;span&gt;
  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
  padding-right&lt;/span&gt;:&lt;span&gt; 110px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是侧栏的right值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box1 .main &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; deepskyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
}&lt;span&gt;
.box1 .aside &lt;/span&gt;{&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-right&lt;/span&gt;:&lt;span&gt; -100px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是侧栏的宽度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; -10px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是自身离其它div的间隙，即10px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt; 左边固定宽度：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box2 &lt;/span&gt;{&lt;span&gt;
  clear&lt;/span&gt;:&lt;span&gt; both&lt;/span&gt;;&lt;span&gt;
  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
  padding-left&lt;/span&gt;:&lt;span&gt; 110px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是侧栏的left值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box2 .aside &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-left&lt;/span&gt;:&lt;span&gt; -100%&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，设置-100%就能和内容栏同一行并覆盖内容栏&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; -110px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，该值是自身宽度与间隙之和&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box2 .main &lt;/span&gt;{&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; deepskyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;总结&lt;/span&gt;：如果固定宽度div在左边，那么它就设置margin：-100%，left值就设置比它宽度大的值，比如上面的left：-110，这样就有10px的间隙，然后装它们的盒子设置padding-left，这个的值和固定宽度div的left值相等。内容栏除了浮动和宽度100%，其它的都不用设置。固定宽度的div在右边的时候，就把left，margin-left，padding-left改成right，margin-right，padding-right就可以了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.两个固定宽度，一个自适应宽度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1040666/201803/1040666-20180302095835707-1764165532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HTML：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        内容自适应宽度
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;aside1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        侧栏1固定宽度
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;aside2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        侧栏2固定宽度
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  这三种情况的HTML排版顺序也是一样的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CSS：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;两个固定宽度div都在右边：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box1 &lt;/span&gt;{&lt;span&gt;
  clear&lt;/span&gt;:&lt;span&gt; both&lt;/span&gt;;&lt;span&gt;
  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
  padding-right&lt;/span&gt;:&lt;span&gt; 240px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是两个侧栏宽度加每个的间隙的值，这里间隙每个是10px，所以100+120+10+10=240&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box1 .aside1 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-right&lt;/span&gt;:&lt;span&gt; -100px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是该div的宽度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; -10px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是自身间隙即10px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box1 .aside2 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-right&lt;/span&gt;:&lt;span&gt; -120px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是该div的宽度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; -120px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是该div左边的div的宽度与间隙，加上自身间隙的值，即100+10+10=120，不要理解为自身的宽度哦&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box1 .main &lt;/span&gt;{&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; deepskyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  两个固定宽度都在左边：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box2 &lt;/span&gt;{&lt;span&gt;
  clear&lt;/span&gt;:&lt;span&gt; both&lt;/span&gt;;&lt;span&gt;
  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
  padding-left&lt;/span&gt;:&lt;span&gt; 240px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是两个div宽度与间隙之和&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box2 .aside1 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-left&lt;/span&gt;:&lt;span&gt; -100%&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，设置-100%能让该div和内容块成一行并覆盖&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; -240px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是padding-left的值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box2 .aside2 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-left&lt;/span&gt;:&lt;span&gt; -100%&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，设置-100%能让该div和内容块成一行并覆盖&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; -130px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是padding-left减去最左边div宽度与间隙的值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box2 .main &lt;/span&gt;{&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; deepskyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;一个固定宽度在左，一个固定宽度在右。自适应宽度在中间。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box3 &lt;/span&gt;{&lt;span&gt;
  clear&lt;/span&gt;:&lt;span&gt; both&lt;/span&gt;;&lt;span&gt;
  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 0 130px 0 110px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是左右两边div的宽度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box3 .aside1 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-left&lt;/span&gt;:&lt;span&gt; -100%&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; -110px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是自身宽度加上间隙&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box3 .aside2 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-right&lt;/span&gt;:&lt;span&gt; -120px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是自身宽度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; -10px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，这个值是自身离其它div的间隙&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box3 .main &lt;/span&gt;{&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; deepskyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;总结&lt;/span&gt;：两个div固定宽度的情况，还是只操作固定宽度的div，自适应宽度的不管它。在左边的div就设置margi-left：-100%，left就是宽度与间隙的值；右边的就设置margin-right：负自身宽度，相对定位的right就是宽度与间隙的值。&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 3.多个固定宽度，一个自适应宽度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1040666/201803/1040666-20180302103522626-455761565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HTML：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        内容自适应宽度
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;aside1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        侧栏1固定宽度
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;aside2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        侧栏2固定宽度
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;aside3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        侧栏3固定宽度
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三种情况的HTML排版顺序也一样。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CSS：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三个固定宽度div在最右边，自适应宽度div在左边&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box1 &lt;/span&gt;{&lt;span&gt;
  clear&lt;/span&gt;:&lt;span&gt; both&lt;/span&gt;;&lt;span&gt;
  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
  padding-right&lt;/span&gt;:&lt;span&gt; 390px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，该值是每个div宽度与间隙之和&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box1 .aside1 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-right&lt;/span&gt;:&lt;span&gt; -100px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，该值是该div的宽度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; -10px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;该值是自身离其它div的间隙&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box1 .aside2 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-right&lt;/span&gt;:&lt;span&gt; -120px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，该值是该div的宽度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; -120px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;该值是该div的左边div宽度与间隙，加上自身间隙的值，即100+10+10=120&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box1 .aside3 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 140px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-right&lt;/span&gt;:&lt;span&gt; -140px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，该值是该div的宽度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; -250px&lt;/span&gt;;&lt;span&gt;/*该值是该div的左边div宽度与间隙，加上自身间隙的值，即100+10+120+10+10=250&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box1 .main &lt;/span&gt;{&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; deepskyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;两个固定宽度div在最左边，另一个在最右边，自适应宽度div在最中间&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box2 &lt;/span&gt;{&lt;span&gt;
  clear&lt;/span&gt;:&lt;span&gt; both&lt;/span&gt;;&lt;span&gt;
  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 0 150px 0 240px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，左边的padding是两个div的宽度与间隙之和，右边的是一个div宽度与间隙之和&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box2 .aside1 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-left&lt;/span&gt;:&lt;span&gt; -100%&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; -240px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，由于该div是在最左边的，所以left值是padding的left的值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box2 .aside2 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-left&lt;/span&gt;:&lt;span&gt; -100%&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; -130px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，该值是padding的left的值减去最左边的div宽度与间隙的值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box2 .aside3 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 140px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-right&lt;/span&gt;:&lt;span&gt; -140px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，该值是该div宽度与间隙的值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; -10px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，由于设置了margin-right之后，该div到了最右边，所以这里的right值是间隙值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box2 .main &lt;/span&gt;{&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; deepskyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一个固定宽度div在左边，另外两个在最右边，自适应宽度在中间&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box3 &lt;/span&gt;{&lt;span&gt;
  clear&lt;/span&gt;:&lt;span&gt; both&lt;/span&gt;;&lt;span&gt;
  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 0 280px 0 110px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，padding的right值是右边两个div宽度与间隙的和；padding的left值是左边的div宽度与间隙的和&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box3 .aside1 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-left&lt;/span&gt;:&lt;span&gt; -100%&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; -110px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，该值是该div宽度与间隙的值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box3 .aside2 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 120px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-right&lt;/span&gt;:&lt;span&gt; -120px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，该值是该div宽度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; -10px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，由于设置了margin-right，所以该值是间隙值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box3 .aside3 &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 140px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; skyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  margin-right&lt;/span&gt;:&lt;span&gt; -140px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，该值是该div宽度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; -140px&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重要属性，该值是它紧邻的左边的div的宽度与间隙还有自身与div间隙的和，即120+10+10=140&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;
.box3 .main &lt;/span&gt;{&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; deepskyblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;总结&lt;/span&gt;：多个div固定宽度，一个自适应的布局方式和两个固定宽度，一个自适应的布局方式也是同样的原理，只操作固定的div，自适应的不管，然后设置装它们的盒子的padding值。固定宽度div设置相对定位的left或者right值，设置margin-left或者margin-right的值。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;圣杯布局最终总结&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　1.HTML排版都是自适应div在最前面，然后是固定宽度div。&lt;/p&gt;
&lt;p&gt;　　2.都设置float：left。&lt;/p&gt;
&lt;p&gt;　　3.如果div在左边，则该div设置margin-left：-100%。如果div在右边，则该div设置margin-right：负自身宽度&lt;/p&gt;
&lt;p&gt;　　4.在左边的div设置相对定位的left值，该值是自身的间隙。如果左边是多个div，那么当前div的left值就是它右边所有的div的宽度与间隙的和再加上自身的间隙的值。&lt;/p&gt;
&lt;p&gt;　　5.在右边的div设置相对定位的right值，该值是自身的间隙。如果右边是多个div，那么当前div的right值就是它左边所有的div的宽度与间隙的和再加上自身的间隙的值。&lt;/p&gt;
&lt;p&gt;　　6.这些div的外层的大盒子设置padding值，这个值是左边或者右边div的宽度与间隙的和。例如左边一个固定宽度的div，宽度为50，间隙是15；然后右边两个固定宽度的div，宽度分别是80、100，间隙都是10.那么padding值就应该设置为padding：0 200px 0 65px;&lt;/p&gt;
&lt;p&gt;　　7.自适应div的宽度设置为100%，其它的都不用管。&lt;/p&gt;

</description>
<pubDate>Fri, 02 Mar 2018 03:41:00 +0000</pubDate>
<dc:creator>站住，别跑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjjDaily/p/8492400.html</dc:identifier>
</item>
<item>
<title>iOS微信内存监控 - 云加社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/8492369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/8492369.html</guid>
<description>&lt;p&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer&quot; target=&quot;_blank&quot;&gt;云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/p&gt;
&lt;blockquote readability=&quot;8.0434782608696&quot;&gt;
&lt;p&gt;作者：杨津，腾讯移动客户端开发 高级工程师&lt;/p&gt;
&lt;p&gt;由 &lt;a href=&quot;https://cloud.tencent.com/developer/user/467825&quot; target=&quot;_blank&quot;&gt;WeTest质量开放平台团队&lt;/a&gt; 发布在云+社区&lt;/p&gt;
&lt;p&gt;商业转载请联系腾讯WeTest获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://wetest.qq.com/lab/view/367.html?from=content_qcloud&quot; target=&quot;_blank&quot;&gt;http://wetest.qq.com/lab/view/367.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目前iOS主流的内存监控工具是Instruments的Allocations，但只能用于开发阶段。本文介绍如何实现离线化的内存监控工具，用于App上线后发现内存问题。&lt;/p&gt;
&lt;p&gt;FOOM（Foreground Out Of Memory），是指App在前台因消耗内存过多引起系统强杀。对用户而言，表现跟crash一样。Facebook早在2015年8月提出FOOM检测办法，大致原理是排除各种情况后，剩余的情况是FOOM，具体链接：&lt;a href=&quot;https://code.facebook.com/posts/1146930688654547/reducing-fooms-in-the-facebook-ios-app/&quot; target=&quot;_blank&quot;&gt;https://code.facebook.com/posts/1146930688654547/reducing-fooms-in-the-facebook-ios-app/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;微信自15年年底上线FOOM上报，从最初数据来看，每天FOOM次数与登录用户数比例接近3%，同期crash率1%不到。而16年年初某东老大反馈微信频繁闪退，在艰难拉取2G多日志后，才发现kv上报频繁打log引起FOOM。接着16年8月不少外部用户反馈微信启动不久后闪退，分析大量日志还是不能找到FOOM原因。微信急需一个有效的内存监控工具来发现问题。&lt;/p&gt;

&lt;p&gt;微信内存监控最初版本是使用Facebook的FBAllocationTracker工具监控OC对象分配，用fishhook工具hook malloc/free等接口监控堆内存分配，每隔1秒，把当前所有OC对象个数、TOP 200最大堆内存及其分配堆栈，用文本log输出到本地。该方案实现简单，一天内完成，通过给用户下发TestFlight，最终发现联系人模块因迁移DB加载大量联系人导致FOOM。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不过这方案有不少缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、监控粒度不够细，像大量分配小内存引起的质变无法监控，另外fishhook只能hook自身app的C接口调用，对系统库不起作用；&lt;/p&gt;
&lt;p&gt;2、打log间隔不好控制，间隔过长可能丢失中间峰值情况，间隔过短会引起耗电、io频繁等性能问题；&lt;/p&gt;
&lt;p&gt;3、上报的原始log靠人工分析，缺少好的页面工具展现和归类问题。&lt;/p&gt;
&lt;p&gt;所以二期版本以Instruments的Allocations为参考，着重四个方面优化，分别是数据收集、存储、上报及展现。&lt;/p&gt;
&lt;h2&gt;1.数据收集&lt;/h2&gt;
&lt;p&gt;16年9月底为了解决ios10 nano crash，研究了libmalloc源码，无意中发现这几个接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/pv0sxhklor.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;1.png&lt;/p&gt;
&lt;p&gt;当malloc_logger和__syscall_logger函数指针不为空时，malloc/free、vm_allocate/vm_deallocate等内存分配/释放通过这两个指针通知上层，这也是内存调试工具malloc stack的实现原理。有了这两个函数指针，我们很容易记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用backtrace函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表dsym解析符号。所以还要记录每个image加载时的偏移slide，这样符号表地址=堆栈地址-slide。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/cpcntdz50j.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;2.png&lt;/p&gt;
&lt;p&gt;另外为了更好的归类数据，每个内存对象应该有它所属的分类Category，如上图所示。对于堆内存对象，它的Category名是“Malloc ”+分配大小，如“Malloc 48.00KiB”；对于虚拟内存对象，调用vm_allocate创建时，最后的参数flags代表它是哪类虚拟内存，而这个flags正对应于上述函数指针__syscall_logger的第一个参数type，每个flag具体含义可以在头文件&amp;lt;mach/vm_statistics.h&amp;gt;找到；对于OC对象，它的Category名是OC类名，我们可以通过hook OC方法+NSObject alloc来获取：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/egwtcrp6e0.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;3.png&lt;/p&gt;
&lt;p&gt;但后来发现，NSData创建对象的类静态方法没有调用+NSObject alloc，里面实现是调用C方法NSAllocateObject来创建对象，也就是说这类方式创建的OC对象无法通过hook来获取OC类名。最后在苹果开源代码CF-1153.18找到了答案，当CFOASafe=true并且CFObjectAllocSetLastAllocEventNameFunction!=NULL时，CoreFoundation创建对象后通过这个函数指针告诉上层当前对象是什么类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/eb1ak5ysh7.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;4.png&lt;/p&gt;
&lt;p&gt;通过上面方式，我们的监控数据来源基本跟Allocations一样了，当然是借助了私有API。如果没有足够的“技巧”，私有API带不上Appstore，我们只能退而求其次。修改malloc_default_zone函数返回的malloc_zone_t结构体里的malloc、free等函数指针，也是可以监控堆内存分配，效果等同于malloc_logger；而虚拟内存分配只能通过fishhook方式。&lt;/p&gt;
&lt;h2&gt;2.数据存储&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;存活对象管理&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;APP在运行期间会大量申请/释放内存。以上图为例，微信启动10秒内，已经创建了80万对象，释放了50万，性能问题是个挑战。另外在存储过程中，也尽量减少内存申请/释放。所以放弃了sqlite，改用了更轻量级的平衡二叉树来存储。&lt;/p&gt;
&lt;p&gt;伸展树（Splay Tree），也叫分裂树，是一种二叉排序树，不保证树是平衡，但各种操作平均时间复杂度是O(logN)，可近似看作平衡二叉树。相比其他平衡二叉树（如红黑树），其内存占用较小，不需要存储额外信息。伸展树主要出发点是考虑到局部性原理（某个刚被访问的结点下次又被访问，或者访问次数多的结点下次可能被访问），为了使整个查找时间更少，被频繁查询的结点通过“伸展”操作搬移到离树根更近的地方。大部分情况下，内存申请很快又被释放，如autoreleased对象、临时变量等；而OC对象申请内存后紧接着会更新它所属Category。所以用伸展树管理最适合不过了。&lt;/p&gt;
&lt;p&gt;传统二叉树是用链表方式实现，每次添加/删除结点，都会申请/释放内存。为了减少内存操作，可以用数组实现二叉树。具体做法是父结点的左右孩子由以往的指针类型改成整数类型，代表孩子在数组的下标；删除结点时，被删除的结点存放上一个被释放的结点所在数组下标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/eas71q9ccv.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;5.png&lt;/p&gt;
&lt;h3&gt;堆栈存储&lt;/h3&gt;
&lt;p&gt;据统计，微信运行期间，backtrace的堆栈有成百万上千万种，在捕获最大栈长64情况下，平均栈长35。如果36bits存储一个地址（armv8最大虚拟内存地址48bits，实际上36bits够用了），一个堆栈平均存储长度157.5bytes，1M个堆栈需要157.5M存储空间。但通过断点观察，实际上大部分堆栈是有共同后缀，例如下面的两个堆栈后7个地址是一样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/wz30sqf9vn.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;6.png&lt;/p&gt;
&lt;p&gt;为此，可以用Hash Table来存储这些堆栈。思路是整个堆栈以链表的方式插入到table里，链表结点存放当前地址和上一个地址所在table的索引。每插入一个地址，先计算它的hash值，作为在table的索引，如果索引对应的slot没有存储数据，就记录这个链表结点；如果有存储数据，并且数据跟链表结点一致，hash命中，继续处理下一个地址；数据不一致，意味着hash冲突，需要重新计算hash值，直到满足存储条件。举个例子（简化了hash计算）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/bpdpexkn4.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;7.png&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Stack1的G、F、E、D、C、A、依次插入到Hash Table，索引1～6结点数据依次是(G, 0)、(F, 1)、(E, 2)、(D, 3)、(C, 4)、(A, 5)。Stack1索引入口是6&lt;/li&gt;
&lt;li&gt;轮到插入Stack2，由于G、F、E、D、C结点数据跟Stack1前5结点一致，hash命中；B插入新的7号位置，(B, 5)。Stack2索引入口是7&lt;/li&gt;
&lt;li&gt;最后插入Stack3，G、F、E、D结点hash命中；但由于Stack3的A的上一个地址D索引是4，而不是已有的(A, 5)，hash不命中，查找下一个空白位置8，插入结点(A, 4)；B上一个地址A索引是8，而不是已有的(B, 5)，hash不命中，查找下一个空白位置9，插入结点(B, 9)。Stack3索引入口是9&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经过这样的后缀压缩存储，平均栈长由原来的35缩短到5不到。而每个结点存储长度为64bits（36bits存储地址，28bits储存parent索引），hashTable空间利用率60%+，一个堆栈平均存储长度只需要66.7bytes，压缩率高达42%。&lt;/p&gt;
&lt;h3&gt;性能数据&lt;/h3&gt;
&lt;p&gt;经过上述优化，内存监控工具在iPhone6Plus运行占用CPU占用率13%不到，当然这是跟数据量有关，重度用户（如群过多、消息频繁等）可能占用率稍微偏高。而存储数据内存占用量20M左右，都用mmap方式把文件映射到内存。有关mmap好处可自行google之。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/dy0pvlbt1r.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;8.png&lt;/p&gt;
&lt;h2&gt;3.数据上报&lt;/h2&gt;
&lt;p&gt;由于内存监控是存储了当前所有存活对象的内存分配信息，数据量极大，所以当出现FOOM时，不可能全量上报，而是按某些规则有选择性的上报。&lt;/p&gt;
&lt;p&gt;首先把所有对象按Category进行归类，统计每个Category的对象数和分配内存大小。这列表数据很少，可以做全量上报。接着对Category下所有相同堆栈做合并，计算每种堆栈的对象数和内存大小。对于某些Category，如分配大小TOP N，或者UI相关的（如UIViewController、UIView之类的），它里面分配大小TOP M的堆栈才做上报。上报格式类似这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/11cq8qftqe.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;9.png&lt;/p&gt;
&lt;h2&gt;4.页面展现&lt;/h2&gt;
&lt;p&gt;页面展现参考了Allocations，可看出有哪些Category，每个Category分配大小和对象数，某些Category还能看分配堆栈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/ssmmnpcek5.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;10.png&lt;/p&gt;
&lt;p&gt;为了突出问题，提高解决问题效率，后台先根据规则找出可能引起FOOM的Category（如上面的Suspect Categories），规则有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UIViewController数量是否异常&lt;/li&gt;
&lt;li&gt;UIView数量是否异常&lt;/li&gt;
&lt;li&gt;UIImage数量是否异常&lt;/li&gt;
&lt;li&gt;其它Category分配大小是否异常，对象个数是否异常&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着对可疑的Category计算特征值，也就是OOM原因。特征值是由“Caller1”、“Caller2”和“Category, Reason”组成。Caller1是指申请内存点，Caller2是指具体场景或业务，它们都是从Category下分配大小第一的堆栈提取。Caller1提取尽量是有意义的，并不是分配函数的上一地址。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/dzvu49e57j.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;11.png&lt;/p&gt;
&lt;p&gt;所有report计算出特征值后，可以对它们进行归类了。一级分类可以是Caller1，也可以是Category，二级分类是与Caller1/Category有关的特征聚合。效果如下：&lt;/p&gt;
&lt;h3&gt;一级分类&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/qhwicfl99p.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;12.png&lt;/p&gt;
&lt;h3&gt;二级分类&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/sw001syi0b.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;13.png&lt;/p&gt;
&lt;h2&gt;5.运营策略&lt;/h2&gt;
&lt;p&gt;上面提到，内存监控会带来一定的性能损耗，同时上报的数据量每次大概300K左右，全量上报对后台有一定压力，所以对现网用户做抽样开启，灰度包用户/公司内部用户/白名单用户做100%开启。本地最多只保留最近三次数据。&lt;/p&gt;

&lt;p&gt;先回顾Facebook如何判定上一次启动是否出现FOOM：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/26i7dd40i1.jpg?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;14.jpg&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;App没有升级&lt;/li&gt;
&lt;li&gt;App没有调用exit()或abort()退出&lt;/li&gt;
&lt;li&gt;App没有出现crash&lt;/li&gt;
&lt;li&gt;用户没有强退App&lt;/li&gt;
&lt;li&gt;系统没有升级/重启&lt;/li&gt;
&lt;li&gt;App当时没有后台运行&lt;/li&gt;
&lt;li&gt;App出现FOOM&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;1、2、4、5比较容易判断，3依赖于自身CrashReport组件的crash回调，6、7依赖于ApplicationState和前后台切换通知。微信自上线FOOM数据上报以来，出现不少误判，主要情况有：&lt;/p&gt;
&lt;h3&gt;ApplicationState不准&lt;/h3&gt;
&lt;p&gt;部分系统会在后台短暂唤起app，ApplicationState是Active，但又不是BackgroundFetch；执行完didFinishLaunchingWithOptions就退出了，也有收到BecomeActive通知，但很快也退出；整个启动过程持续5～8秒不等。解决方法是收到BecomeActive通知一秒后，才认为这次启动是正常的前台启动。这方法只能减少误判概率，并不能彻底解决。&lt;/p&gt;
&lt;h3&gt;群控类外挂&lt;/h3&gt;
&lt;p&gt;这类外挂是可以远程控制iPhone的软件，通常一台电脑可以控制多台手机，电脑画面和手机屏幕实时同步操作，如开启微信，自动加好友，发朋友圈，强制退出微信，这一过程容易产生误判。解决方法只能通过安全后台打击才能减少这类误判。&lt;/p&gt;
&lt;h3&gt;CrashReport组件出现crash没有回调上层&lt;/h3&gt;
&lt;p&gt;微信曾经在17年5月底爆发大量GIF crash，该crash由内存越界引起，但收到crash信号写crashlog时，由于内存池损坏，组件无法正常写crashlog，甚至引起二次crash；上层也无法收到crash通知，因此误判为FOOM。目前改成不依赖crash回调，只要本地存在上一次crashlog（不管是否完整），就认为是crash引起的APP重启。&lt;/p&gt;
&lt;h3&gt;前台卡死引起系统watchdog强杀&lt;/h3&gt;
&lt;p&gt;也就是常见的0x8badf00d，通常原因是前台线程过多，死锁，或CPU使用率持续过高等，这类强杀无法被App捕获。为此我们结合了已有卡顿系统，当前台运行最后一刻有捕获到卡顿，我们认为这次启动是被watchdog强杀。同时我们从FOOM划分出新的重启原因叫“APP前台卡死导致重启”，列入重点关注。&lt;/p&gt;

&lt;p&gt;微信自2017年三月上线内存监控以来，解决了30多处大大小小内存问题，涉及到聊天、搜索、朋友圈等多个业务，FOOM率由17年年初3%，降到目前0.67%，而前台卡死率由0.6%下降到0.3%，效果特别明显。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/xmqgpueg85.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;15.png&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/tdvkjcqh2u.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;16.png&lt;/p&gt;

&lt;h3&gt;UIGraphicsEndImageContext&lt;/h3&gt;
&lt;p&gt;UIGraphicsBeginImageContext和UIGraphicsEndImageContext必须成双出现，不然会造成context泄漏。另外XCode的Analyze也能扫出这类问题。&lt;/p&gt;
&lt;h3&gt;UIWebView&lt;/h3&gt;
&lt;p&gt;无论是打开网页，还是执行一段简单的js代码，UIWebView都会占用APP大量内存。而WKWebView不仅有出色的渲染性能，而且它有自己独立进程，一些网页相关的内存消耗移到自身进程里，最适合取替UIWebView。&lt;/p&gt;
&lt;h3&gt;autoreleasepool&lt;/h3&gt;
&lt;p&gt;通常autoreleased对象是在runloop结束时才释放。如果在循环里产生大量autoreleased对象，内存峰值会猛涨，甚至出现OOM。适当的添加autoreleasepool能及时释放内存，降低峰值。&lt;/p&gt;
&lt;h3&gt;互相引用&lt;/h3&gt;
&lt;p&gt;比较容易出现互相引用的地方是block里使用了self，而self又持有这个block，只能通过代码规范来避免。另外NSTimer的target、CAAnimation的delegate，是对Obj强引用。目前微信通过自己实现的MMNoRetainTimer和MMDelegateCenter来规避这类问题。&lt;/p&gt;
&lt;h3&gt;大图片处理&lt;/h3&gt;
&lt;p&gt;举个例子，以往图片缩放接口是这样写的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/et772n2md6.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;17.png&lt;/p&gt;
&lt;p&gt;但处理大分辨率图片时，往往容易出现OOM，原因是-UIImage drawInRect:在绘制时，先解码图片，再生成原始分辨率大小的bitmap，这是很耗内存的。解决方法是使用更低层的ImageIO接口，避免中间bitmap产生：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/467825/crrvikw9c2.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;18.png&lt;/p&gt;
&lt;h3&gt;大视图&lt;/h3&gt;
&lt;p&gt;大视图是指View的size过大，自身包含要渲染的内容。超长文本是微信里常见的炸群消息，通常几千甚至几万行。如果把它绘制到同一个View里，那将会消耗大量内存，同时造成严重卡顿。最好做法是把文本划分成多个View绘制，利用TableView的复用机制，减少不必要的渲染和内存占用。&lt;/p&gt;
&lt;h2&gt;推荐文章&lt;/h2&gt;
&lt;p&gt;最后推荐几个iOS内存相关的链接：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Memory Usage Performance Guidelines&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/ManagingMemory.html#//apple_ref/doc/uid/10000160-SW1&quot; target=&quot;_blank&quot;&gt;https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/ManagingMemory.html#//apple_ref/doc/uid/10000160-SW1&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;No pressure, Mon!&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;http://www.newosxbook.com/articles/MemoryPressure.html&quot; target=&quot;_blank&quot;&gt;http://www.newosxbook.com/articles/MemoryPressure.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了提高IEG苹果审核通过率，腾讯专门成立了苹果审核测试团队，打造出iOS预审工具这款产品。经过1年半的内部运营，腾讯内部应用的iOS审核通过率从平均35%提升到90%+。&lt;/p&gt;
&lt;p&gt;现将腾讯内部产品的过审经验，以线上工具的形式共享给各位。在WeTest腾讯质量开放平台上可以在线使用。点击 &lt;a href=&quot;http://wetest.qq.com/product/ios?from=content_qcloud&quot; target=&quot;_blank&quot;&gt;http://wetest.qq.com/product/ios&lt;/a&gt; 即可立即体验！&lt;/p&gt;
&lt;p&gt;如果使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：800024531&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【扫描工具】&lt;/strong&gt;上传IPA包、图片、视频、应用描述即可进行测试； 多维度自动扫描提审材料的被拒风险；1小时内反馈全面的扫描报告。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【专家预审】&lt;/strong&gt;腾讯专家为您遍历App所有功能模块；全面暴露App内容被拒风险；跟进问题直至上线（需提供官方拒绝邮件）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【专家咨询】&lt;/strong&gt;资深预审专家一对一服务； 咨询时间灵活可选，按需购买；有的放矢解 决审核问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【ASO优化】&lt;/strong&gt;专业团队多维度深度剖析App的ASO现状；围绕App目标用户群筛选高 度关联的关键词；帮助提升App在苹果应用商店中的曝光率。&lt;/p&gt;

&lt;p&gt;&lt;span data-sheets-value=&quot;{&amp;quot;1&amp;quot;:2,&amp;quot;2&amp;quot;:&amp;quot;2017年数据库技术盘点&amp;quot;}&quot; data-sheets-userformat=&quot;{&amp;quot;2&amp;quot;:1,&amp;quot;3&amp;quot;:[null,0]}&quot;&gt;&lt;a class=&quot;in-cell-link&quot; href=&quot;https://cloud.tencent.com/developer/article/1047725&quot; target=&quot;_blank&quot;&gt;2017年数据库技术盘点&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-sheets-value=&quot;{&amp;quot;1&amp;quot;:2,&amp;quot;2&amp;quot;:&amp;quot;2017年数据库技术盘点&amp;quot;}&quot; data-sheets-userformat=&quot;{&amp;quot;2&amp;quot;:1,&amp;quot;3&amp;quot;:[null,0]}&quot;&gt;&lt;span data-sheets-value=&quot;{&amp;quot;1&amp;quot;:2,&amp;quot;2&amp;quot;:&amp;quot;机器学习算法之旅&amp;quot;}&quot; data-sheets-userformat=&quot;{&amp;quot;2&amp;quot;:8403713,&amp;quot;3&amp;quot;:[null,0],&amp;quot;11&amp;quot;:0,&amp;quot;12&amp;quot;:0,&amp;quot;14&amp;quot;:[null,2,42239],&amp;quot;15&amp;quot;:&amp;quot;PingFangSC-Light, \&amp;quot;hiragino sans gb\&amp;quot;, \&amp;quot;helvetica neue\&amp;quot;, \&amp;quot;microsoft yahei ui\&amp;quot;, \&amp;quot;microsoft yahei\&amp;quot;, simsun, arial, sans-serif&amp;quot;,&amp;quot;16&amp;quot;:10,&amp;quot;26&amp;quot;:400}&quot;&gt;&lt;a class=&quot;in-cell-link&quot; href=&quot;https://cloud.tencent.com/developer/article/1043104&quot; target=&quot;_blank&quot;&gt;机器学习算法之旅&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-sheets-value=&quot;{&amp;quot;1&amp;quot;:2,&amp;quot;2&amp;quot;:&amp;quot;Android图像处理 - 高斯模糊的原理及实现&amp;quot;}&quot; data-sheets-userformat=&quot;{&amp;quot;2&amp;quot;:8403713,&amp;quot;3&amp;quot;:[null,0],&amp;quot;11&amp;quot;:0,&amp;quot;12&amp;quot;:0,&amp;quot;14&amp;quot;:[null,2,42239],&amp;quot;15&amp;quot;:&amp;quot;PingFangSC-Light, \&amp;quot;hiragino sans gb\&amp;quot;, \&amp;quot;helvetica neue\&amp;quot;, \&amp;quot;microsoft yahei ui\&amp;quot;, \&amp;quot;microsoft yahei\&amp;quot;, simsun, arial, sans-serif&amp;quot;,&amp;quot;16&amp;quot;:10,&amp;quot;26&amp;quot;:400}&quot;&gt;&lt;a class=&quot;in-cell-link&quot; href=&quot;https://cloud.tencent.com/developer/article/1035563&quot; target=&quot;_blank&quot;&gt;Android图像处理 - 高斯模糊的原理及实现&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span data-sheets-value=&quot;{&amp;quot;1&amp;quot;:2,&amp;quot;2&amp;quot;:&amp;quot;Android图像处理 - 高斯模糊的原理及实现&amp;quot;}&quot; data-sheets-userformat=&quot;{&amp;quot;2&amp;quot;:8403713,&amp;quot;3&amp;quot;:[null,0],&amp;quot;11&amp;quot;:0,&amp;quot;12&amp;quot;:0,&amp;quot;14&amp;quot;:[null,2,42239],&amp;quot;15&amp;quot;:&amp;quot;PingFangSC-Light, \&amp;quot;hiragino sans gb\&amp;quot;, \&amp;quot;helvetica neue\&amp;quot;, \&amp;quot;microsoft yahei ui\&amp;quot;, \&amp;quot;microsoft yahei\&amp;quot;, simsun, arial, sans-serif&amp;quot;,&amp;quot;16&amp;quot;:10,&amp;quot;26&amp;quot;:400}&quot;&gt;此文已由作者授权云加社区发布，转载请注明&lt;a href=&quot;https://cloud.tencent.com/developer/article/1048715&quot; target=&quot;_blank&quot;&gt;文章出处&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 02 Mar 2018 03:36:00 +0000</pubDate>
<dc:creator>云加社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/8492369.html</dc:identifier>
</item>
</channel>
</rss>