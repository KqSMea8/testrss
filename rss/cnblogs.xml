<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>珂朵莉树(Chtholly Tree)学习笔记 - shremier</title>
<link>http://www.cnblogs.com/shes/p/9909501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shes/p/9909501.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;珂朵莉树原理&quot;&gt;珂朵莉树原理&lt;/h2&gt;
&lt;p&gt;其原理在于运用一颗树（set，treap，splay......）其中要求所有元素有序，并且支持基本的操作（删除，添加，查找......）来实现区间压缩。&lt;/p&gt;
&lt;p&gt;那么区间压缩的意义在于&lt;strong&gt;区间推平&lt;/strong&gt;这是珂朵莉树的&lt;strong&gt;核心&lt;/strong&gt;（如果没有这个操作实际上不一定需要这种算法）&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps：若保证有&lt;em&gt;连续相等&lt;/em&gt;甚至递增的区间，也可以的（吧？)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可想而知它的操作在于对区间的&lt;strong&gt;分裂&lt;/strong&gt;和&lt;strong&gt;合并&lt;/strong&gt;操作&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;（为什么？因为这样可以方便而快捷的&lt;em&gt;区间推平&lt;/em&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;珂朵莉树的实现&quot;&gt;珂朵莉树的实现&lt;/h2&gt;
&lt;p&gt;在众多树中因为set这个c++自带，所以决定选择它。&lt;/p&gt;
&lt;h3 id=&quot;结构&quot;&gt;结构&lt;/h3&gt;
&lt;p&gt;一个node结构体——把它叫区间(已&lt;code&gt;typedef long long LL&lt;/code&gt;)&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct node
{
    int l,r;LL v;//这里官方写法加了一个mutable，看个人写法
    node(int L,int R,LL V):l(L),r(R),v(V){}
    bool operator &amp;lt; (const node&amp;amp; o) const
    {
        return l&amp;lt;o.l;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;声明集合&quot;&gt;声明集合&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;set&amp;lt;node&amp;gt;s;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;for(int i=1;i&amp;lt;=n;++i)
    s.insert(i,i,val);
s.insert(n+1,n+1,0);//见下面中it!=s.end()的前提&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分裂&quot;&gt;分裂&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#define it_ set&amp;lt;node&amp;gt;::iterator
it_ split(int pos)
{
    it_ it=s.lower_bound(node(pos));
    if(it!=s.end()&amp;amp;&amp;amp; it-&amp;gt;l==pos) return it;
    --it;
    int ll=it-&amp;gt;l,rr=it-&amp;gt;r;
    LL vv=it-&amp;gt;v;
    s.erase(it);
    s.insert(node(ll,pos-1,vv));
    return s.insert(node(pos,rr,vv)).first;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;区间推平&quot;&gt;区间推平&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void assign(int l,int r,LL val=0)
{
    it_ itl=split(l),itr=split(r+1);
    s.erase(itl,itr);
    s.insert(node(l,r,val));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如上&quot;&gt;如上。&lt;/h3&gt;
&lt;hr/&gt;&lt;h2 id=&quot;栗例子&quot;&gt;&lt;del&gt;栗&lt;/del&gt;例子&lt;/h2&gt;
&lt;h3 id=&quot;见cf896c&quot;&gt;见cf896c&lt;/h3&gt;
&lt;p&gt;仅仅给出代码&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#define it_ set&amp;lt;node&amp;gt;::iterator
// #define swap(X,Y) {int (tmp)=(X),(X)=(Y),(Y)=(tmp);}
using namespace std;
typedef long long LL;
const int M7=1e9+7;
const int maxn=1e5+5;
int n,m;
LL seed,vmax;
LL a[maxn];
struct node
{
    int l,r;mutable LL v;
    node(int L,int R=-1,LL V=0):l(L),r(R),v(V){}
    bool operator &amp;lt; (const node&amp;amp; o) const
    {
        return l&amp;lt;o.l;
    }
};
set&amp;lt;node&amp;gt;s;
it_ split(int pos)
{
    it_ it=s.lower_bound(node(pos));
    if(it!=s.end()&amp;amp;&amp;amp; it-&amp;gt;l==pos) return it;
    --it;
    int ll=it-&amp;gt;l,rr=it-&amp;gt;r;
    LL vv=it-&amp;gt;v;
    s.erase(it);
    s.insert(node(ll,pos-1,vv));
    return s.insert(node(pos,rr,vv)).first;
}
void assign(int l,int r,LL val=0)
{
    it_ itl=split(l),itr=split(r+1);
    s.erase(itl,itr);
    s.insert(node(l,r,val));
}
void add(int l,int r,LL val=0)
{
    it_ itl=split(l),itr=split(r+1);
    for(it_ i=itl;i!=itr;++i)
    {
        i-&amp;gt;v+=val;
    }
}
LL so(int l,int r,int k)
{
    it_ itl=split(l),itr=split(r+1);
    vector&amp;lt;pair&amp;lt;LL,int&amp;gt;&amp;gt;v;
    v.clear();
    for(;itl!=itr;++itl)
    {
        v.push_back(pair&amp;lt;LL,int&amp;gt;(itl-&amp;gt;v,itl-&amp;gt;r-itl-&amp;gt;l+1));
    }
    sort(v.begin(),v.end());
    for(vector&amp;lt;pair&amp;lt;LL,int&amp;gt;&amp;gt;::iterator it=v.begin();it!=v.end();++it)
    {
        k-=it-&amp;gt;second;
        if(k&amp;lt;=0)return it-&amp;gt;first;
    }
}
LL pow(LL a,LL b,LL mod)
{
    LL ret=1;a%=mod;
    while(b)
    {
        if(b&amp;amp;1) ret=ret*a%mod;
        a=a*a%mod;
        b&amp;gt;&amp;gt;=1;
    }
    return ret%mod;
}
LL ok(int l,int r,LL k,LL mod)
{
    it_ itl=split(l),itr=split(r+1);
    LL ans=0;
    for(;itl!=itr;++itl)
    {
        ans+=(LL)(itl-&amp;gt;r-itl-&amp;gt;l+1)*pow(itl-&amp;gt;v,k,mod)%mod;
        ans%=mod;
    }
    return ans%mod;
}
LL rnd()
{
    LL ret=seed;
    seed=(seed*7+13)%M7;
    return ret;
}

int main(int argc, char const *argv[])
{
    ios::sync_with_stdio(0);
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;seed&amp;gt;&amp;gt;vmax;
    for(int i=1;i&amp;lt;=n;++i)
    {
        a[i]=(rnd()%vmax)+1;
        s.insert(node(i,i,a[i]));
    }
    s.insert(node(n+1,n+1,0));
    for(int i=1;i&amp;lt;=m;++i)
    {
        int op=(rnd()%4)+1,
        l=(rnd()%n)+1,
        r=(rnd()%n)+1;LL x,y;
        if(l&amp;gt;r)
            swap(l,r);
        if(op==3)
            x=(rnd()%(LL)(r-l+1))+1;
        else 
            x=(rnd()%vmax)+1;
        if(op==4)
            y=(rnd()%vmax)+1;
        if(op==1) add(l,r,x); 
        else if(op==2) assign(l,r,x);
        else if(op==3) cout&amp;lt;&amp;lt;so(l,r,x)&amp;lt;&amp;lt;endl;
        else if(op==4) cout&amp;lt;&amp;lt;ok(l,r,x,y)&amp;lt;&amp;lt;endl;
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 05 Nov 2018 07:45:00 +0000</pubDate>
<dc:creator>shremier</dc:creator>
<og:description>珂朵莉树(Chtholly Tree)学习笔记 珂朵莉树原理 其原理在于运用一颗树（set，treap，splay......）其中要求所有元素有序，并且支持基本的操作（删除，添加，查找......）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shes/p/9909501.html</dc:identifier>
</item>
<item>
<title>记录自己使用GitHub的点点滴滴 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/9901763.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/9901763.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;　　现在大多数开发者都有自己的GitHub账号，很多公司也会以是否有GitHub作为一项筛选简历以及人才的选项了，可见拥有一个GitHub账号的重要性，本文就从最基本的GitHub账号的注册到基本的使用进行学习记录，一方面方便自己，另一方面希望对你有所帮助~&lt;/p&gt;
&lt;p&gt;　　之前写过一篇文章，浅谈使用git 进行版本控制（博客链接：&lt;a href=&quot;https://www.cnblogs.com/wj-1314/p/7992543.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wj-1314/p/7992543.html&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;说实话，当时是学习可视化的时候，接触到git ，学了些皮毛，但是自己在实践中并没有真正的用到GitHub这个平台。那时候在大学，还无忧无虑的，但是一年后，也就是今天，我在家里写了代码，但是在公司也想写，才发现了GitHub的好处了，今天迫不及待的使用了这个东西，并且把一些笔记记录下来。&lt;/p&gt;
&lt;h3&gt;GitHub简介&lt;/h3&gt;
&lt;p&gt; 　　GitHub是用于版本控制和协作的代码托管平台，它可以让您和其他人在任何地方协同工作。GitHub 可以托管各种Git版本库，并提供一个web界面，但与其它像 SourceForge或Google Code这样的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。&lt;/p&gt;
&lt;p&gt; 　　为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码玩家的MySpace。&lt;/p&gt;
&lt;h2&gt; 一：创建新的Git仓库&lt;/h2&gt;
&lt;p&gt;　　本文将学习使用GitHub基本知识，如存储库，分支，提交和Pull请求，我将创建自己的hello world存储库并学习GitHub的Pull Request工作流，这是一种创建和检查代码的流行方法。&lt;/p&gt;
&lt;h3&gt;1：创建存储库&lt;/h3&gt;
&lt;p&gt;　　一个库通常用于举办单个项目，存储库可以包含文件夹和文件，图像，视频，电子表格和数据集等等，你的项目需要的任何内容，我们认为包括README或者包含项目信息的文件。GitHub可以在创建新存储库的同时轻松添加一个。&lt;/p&gt;
&lt;p&gt;　　如下图所示：我们可以添加一个新的仓库，并且添加描述，最后&lt;strong&gt;单击Create repository&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105093432636-213233665.png&quot; alt=&quot;&quot; width=&quot;775&quot; height=&quot;571&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2：创建一个分支（Create a Branch）&lt;/h3&gt;
&lt;p&gt;　　分支是一次处理不同版本的存储库的方法。&lt;/p&gt;
&lt;p&gt;　　默认情况下，我们的存储库有一个名为master的分支branch，该分支被认为是权威分支。我们在使用分支进行试验并在提交之前进行编辑master。&lt;/p&gt;
&lt;p&gt;　　当你在分支机构上创建master 分支时,我们正在制作该master时间点的副本或者快照，如果其他人master在我们的分支机构上工作时对branch做了更改，则可以提取这些更新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105095835079-195994854.png&quot; alt=&quot;&quot; width=&quot;696&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在GitHub，我们的开发人员，编写人员和设计人员使用分支来保持错误修复和功能工作与我们的master分支分开，当更改准备就绪时候，他们讲其分支合并到master。&lt;/p&gt;
&lt;h3&gt; 3：创建一个新分支&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1，转到新的仓库，也就是我们的仓库hello-world&lt;/li&gt;
&lt;li&gt;2，单击文件列表顶部的下拉列表：master&lt;/li&gt;
&lt;li&gt;3，在新分支文本框中输入分支名称readme-edits&lt;/li&gt;
&lt;li&gt;4，选择蓝色的创建分支框或者按键盘的Enter&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105100648094-1921460547.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　现在我们有两个分支，master和readme-edits，他们看起来一样，但是时间不会很长，接下来我们增加我们的改变在新的分支上。&lt;/p&gt;
&lt;h3&gt;4：制作并提交更改&lt;/h3&gt;
&lt;p&gt;　　现在我们在readme-edits分支的代码视图中，这是一个master的副本，让我们做一些修改吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1，单击该README.md文件&lt;/li&gt;
&lt;li&gt;2，点击要编辑的文件上糊涂右上角的铅笔图标&lt;/li&gt;
&lt;li&gt;3，在编译器中，写一点东西&lt;/li&gt;
&lt;li&gt;4，编写描述更改的提交消息&lt;/li&gt;
&lt;li&gt;5，单击提交按钮&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105101652126-1171917336.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;227&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105101713467-973949971.png&quot; alt=&quot;&quot; width=&quot;642&quot; height=&quot;217&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 5：打开Pull请求&lt;/h3&gt;
&lt;p&gt;　　Pull Requests是GitHub上合作的核心，当我们打开拉取请求时候，你提出了更改并请求某人审核并提取我们的贡献，并将其合并到他们的分支中，拉请求显示来自于两个分支的内容的差异。&lt;/p&gt;
&lt;h4&gt;5.1 点击Pull Requests&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105102411232-1430123760.gif&quot; alt=&quot;&quot; width=&quot;706&quot; height=&quot;190&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5.2 在Example Comparisons中比对代码&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105102557157-790100282.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;

&lt;h4&gt; 5.3 在比较页面查看差异，确保其是我们要提交的内容&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105102738029-667526968.png&quot; alt=&quot;&quot; width=&quot;641&quot; height=&quot;473&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5.4 如果是，点击Create pull request&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105102857092-1001709421.png&quot; alt=&quot;&quot; width=&quot;621&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5.5 为我们的拉取请求提供标题，并写下更改的简要说明&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105103031208-766721292.png&quot; alt=&quot;&quot; width=&quot;641&quot; height=&quot;338&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6：合并我们的Pull Requests&lt;/h3&gt;
&lt;p&gt;　　最后将我们的更改结合在一起，将我们的readme-edits分支合并到master分支上。&lt;/p&gt;
&lt;h4&gt;6.1 单击Merge pull request，然后单击Confirm merge&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105103336391-1006162014.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;458&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;6.2 Delete branch&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105103401188-2028744800.png&quot; alt=&quot;&quot; width=&quot;631&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;6.3 恢复的话点击Restore branch&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105103457742-778629450.png&quot; alt=&quot;&quot; width=&quot;630&quot; height=&quot;464&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二：如何一步步的在GitHub上传自己的项目&lt;/h2&gt;
&lt;h3&gt;1 创建一个新的项目，填写项目名称，描述等&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105112500442-122748843.png&quot; alt=&quot;&quot; width=&quot;643&quot; height=&quot;512&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2 创建完成后，跳转到下面页面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105112652691-726837378.png&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;543&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么请记住下面的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105112724399-2076884498.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3 我们需要下载Git，并安装。&lt;/h3&gt;
&lt;p&gt;　　如果没有安装，请查看windows的安装博客（这里不做详细介绍）：&lt;a href=&quot;https://www.cnblogs.com/wj-1314/p/7993819.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wj-1314/p/7993819.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4 进入Git Bash，出现如下界面&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105113154705-1602170318.png&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;358&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5 cd 进入到我们放项目的地址&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105113812789-1401415810.png&quot; alt=&quot;&quot; width=&quot;678&quot; height=&quot;403&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6 输入git init&lt;/h3&gt;
&lt;p&gt;　　在当前项目的目录中生成本地的git管理（我们会发现当前目录下多了一个.git文件夹）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105113933834-681022410.png&quot; alt=&quot;&quot; width=&quot;679&quot; height=&quot;406&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105113957127-38142511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7 输入git add .&lt;/h3&gt;
&lt;p&gt;　　这个是将项目上所有的文件添加到仓库中，如果只想添加某个特定的文件，只需要将.换成特定的名称即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（下面会报错，我们发现add 和.之间有空格）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105114311843-1428516204.png&quot; alt=&quot;&quot; width=&quot;694&quot; height=&quot;408&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;8 输入git commit -m &quot;first commit&quot;&lt;/h3&gt;
&lt;p&gt;　　表示我们对这次提交的注释，双引号里面的内容可以根据个人的需求改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105114920269-723803076.png&quot; alt=&quot;&quot; width=&quot;698&quot; height=&quot;410&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;9 出现上面的内容，我们需要输出自己的账号或者名字，再执行上面的代码就会成功&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105115400820-537476017.png&quot; alt=&quot;&quot; width=&quot;703&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;10 关联自己的仓库url地址&lt;/h3&gt;
&lt;p&gt;　　这里自己找自己的url地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
git remote add origin https://自己的仓库url地址
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　下面展示本人的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105112724399-2076884498.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 11 上传代码 输入 git push -u origin master（意思：上传到GitHub仓库）&lt;/h3&gt;
&lt;p&gt;　　执行完毕后，如果没有异常，会等待几秒，然后跳出一个让我们输入Username 和password的窗口，我们只需要输入个人的github登录账号和密码即可。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105115949224-518932132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105120000010-1740203213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　最后上传完毕&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105142642180-535052800.png&quot; alt=&quot;&quot; width=&quot;646&quot; height=&quot;312&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 12 上传成功，进入到GitHub中查看&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105143719600-545480697.png&quot; alt=&quot;&quot; width=&quot;648&quot; height=&quot;338&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;三：GitHub如何删除项目&lt;/h2&gt;
&lt;h3&gt;1，首先找到需要删除的项目，点开&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105110141041-1327293480.png&quot; alt=&quot;&quot; width=&quot;667&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2，找到settings，点开&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105110309312-995472273.png&quot; alt=&quot;&quot; width=&quot;661&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3，将滚动条滑到底部，找到Danger Zone下的Delete this repository&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105110418260-1541572434.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;360&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4，点击，会弹出一个警告框，将该项目名称输入进行确认&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105110600530-2119410269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5，这里会弹出账号重新进行确认，输入密码进行确认即可。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105110651464-1997332354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 6，删除成功后，会重新回到个人主界面提醒项目删除成功&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105110759389-1901254973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四，报错push declined due to email privacy restrictions的解决方法&lt;/h2&gt;
&lt;p&gt;　　当你上传代码到最后一步，发现无法push，并且会出现如下错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105143224114-646348731.png&quot; alt=&quot;&quot; width=&quot;695&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么如何解决呢？&lt;/p&gt;
&lt;h3&gt;1，进入GitHub主页，进入setting&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105143422480-976797979.png&quot; alt=&quot;&quot; width=&quot;697&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2，点击emails&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105143500843-112490969.png&quot; alt=&quot;&quot; width=&quot;714&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3，取消Block command line pushes that expose my email的勾即可&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201811/1226410-20181105143547535-1400218415.png&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;172&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 05 Nov 2018 07:40:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<og:description>前言 现在大多数开发者都有自己的GitHub账号，很多公司也会以是否有GitHub作为一项筛选简历以及人才的选项了，可见拥有一个GitHub账号的重要性，本文就从最基本的GitHub账号的注册到基本的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/9901763.html</dc:identifier>
</item>
<item>
<title>synchronized使用及原理解析 - little-sheep</title>
<link>http://www.cnblogs.com/little-sheep/p/9909111.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/little-sheep/p/9909111.html</guid>
<description>&lt;h2&gt;修饰静态方法、实例方法、代码块&lt;/h2&gt;
&lt;p&gt;Synchronized修饰静态方法，对类对象进行加锁，是类锁。&lt;/p&gt;
&lt;p&gt;Synchronized修饰实例方法，对方法所属对象进行加锁，是对象锁。&lt;/p&gt;
&lt;p&gt;Synchronized修饰代码块时，对一段代码块进行加锁，是对象锁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * synchronized示例
 * 1、修饰静态方法
 * 2、修饰实例方法
 * 3、修饰代码块
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SyncDemo2 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; num = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 修饰静态方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; count1() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000000; i++&lt;span&gt;) {
            num&lt;/span&gt;++&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 修饰实例方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; count2() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000000; i++&lt;span&gt;) {
            num&lt;/span&gt;++&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 修饰代码块
     * 效果与修饰静态方法相同
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; count3() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(SyncDemo2.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000000; i++&lt;span&gt;) {
                num&lt;/span&gt;++&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 修饰代码块
     * 效果与修饰实例方法相同
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; count4() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000000; i++&lt;span&gt;) {
                num&lt;/span&gt;++&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个线程运行一个类的两个对象，运行类的静态方法count1，
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;产生同步，num=200000000

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个线程运行一个类的两个对象，运行类的实例方法count2
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为调用的是不同的对象，并未产生同步，num&amp;lt;=200000000&lt;/span&gt;
        SyncDemo2 syncDemo1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SyncDemo2();
        SyncDemo2 syncDemo2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SyncDemo2();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个线程运行一个对象，运行类的实例方法count2
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为调用的是同一个对象，产生同步，num=200000000
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SyncDemo2 syncDemo3 = new SyncDemo2();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;syncDemo1 = syncDemo3;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;syncDemo2 = syncDemo3;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动两个线程进行运算&lt;/span&gt;
        Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadDemo(syncDemo1));
        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadDemo(syncDemo2));
        thread1.start();
        thread2.start();

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            thread1.join();
            thread2.join();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(SyncDemo2.num);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ThreadDemo &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    SyncDemo2 syncDemo2;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ThreadDemo(SyncDemo2 syncDemo2){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.syncDemo2 =&lt;span&gt; syncDemo2;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;syncDemo2.count1();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;syncDemo2.count2();&lt;/span&gt;
&lt;span&gt;        syncDemo2.count3();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;syncDemo2.count4();&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Synchronized底层实现原理&lt;/h2&gt;
&lt;p&gt;Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现，无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的。&lt;/p&gt;
&lt;p&gt;锁是加在对象上的，无论是类对象还是实例对象。每个对象主要由一个对象头、实例变量、填充数据三部分组成，结构如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1444941/201811/1444941-20181105144331578-482034522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成，其结构说明如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1444941/201811/1444941-20181105144403039-1406958190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等以下是32位JVM的Mark Word默认存储结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1444941/201811/1444941-20181105144438088-1761957300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1444941/201811/1444941-20181105144512891-308438144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Synchronized属于结构中的重量级锁，锁标识位为10，其中指针指向的是monitor对象的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ObjectMonitor() {
    _header       &lt;/span&gt;=&lt;span&gt; NULL;
    _count        &lt;/span&gt;= 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录个数&lt;/span&gt;
    _waiters      = 0&lt;span&gt;,
            _recursions   &lt;/span&gt;= 0&lt;span&gt;;
    _object       &lt;/span&gt;=&lt;span&gt; NULL;
    _owner        &lt;/span&gt;=&lt;span&gt; NULL;
    _WaitSet      &lt;/span&gt;= NULL; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处于wait状态的线程，会被加入到_WaitSet&lt;/span&gt;
    _WaitSetLock  = 0&lt;span&gt; ;
    _Responsible  &lt;/span&gt;=&lt;span&gt; NULL ;
    _succ         &lt;/span&gt;=&lt;span&gt; NULL ;
    _cxq          &lt;/span&gt;=&lt;span&gt; NULL ;
    FreeNext      &lt;/span&gt;=&lt;span&gt; NULL ;
    _EntryList    &lt;/span&gt;= NULL ; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处于等待锁block状态的线程，会被加入到该列表&lt;/span&gt;
    _SpinFreq     = 0&lt;span&gt; ;
    _SpinClock    &lt;/span&gt;= 0&lt;span&gt; ;
    OwnerIsThread &lt;/span&gt;= 0&lt;span&gt; ;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结构中几个重要的字段要关注，_count、_owner、_EntryList、_WaitSet。&lt;/p&gt;
&lt;p&gt;count用来记录线程进入加锁代码的次数。&lt;/p&gt;
&lt;p&gt;owner记录当前持有锁的线程,即持有ObjectMonitor对象的线程。&lt;/p&gt;
&lt;p&gt;EntryList是想要持有锁的线程的集合。&lt;/p&gt;
&lt;p&gt;WaitSet 是加锁对象调用wait（）方法后，等待被唤醒的线程的集合。&lt;/p&gt;
&lt;p&gt;每个等待锁的线程都会被封装成ObjectWaiter对象，当多个线程同时访问一段同步代码（临界区）时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程，_owner指向持有ObjectMonitor对象的线程。同时monitor中的计数器count加1。&lt;/p&gt;
&lt;p&gt;若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。&lt;/p&gt;
&lt;p&gt;若当前线程执行完毕也将释放monitor并复位变量的值，以便其他线程进入获取monitor(锁)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1444941/201811/1444941-20181105144610962-135487702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;（图摘自：https://blog.csdn.net/javazejian/article/details/72828483）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Synchronized在jvm字节码上的体现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们以之前的例子为例，使用javac编译代码，然后使用javap进行反编译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1444941/201811/1444941-20181105144647856-1421767454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反编译后部分片段如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1444941/201811/1444941-20181105144718737-1522746951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于使用synchronized修饰的方法，反编译后字节码中会有ACC_SYNCHRONIZED关键字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1444941/201811/1444941-20181105144753788-1518602906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而synchronized修饰的代码块中，在代码块的前后会有monitorenter、monitorexit关键字，此处的字节码中有两个monitorexit是因为我们有try-catch语句块，有两个出口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Synchronized与等待唤醒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;等待唤醒是指调用对象的wait、notify、notifyAll方法。调用这三个方法时，对象必须被synchronized修饰，因为这三个方法在执行时，必须获得当前对象的监视器monitor对象。&lt;/p&gt;
&lt;p&gt;另外，与sleep方法不同的是wait方法调用完成后，线程将被暂停，但wait方法将会释放当前持有的监视器锁(monitor)，直到有线程调用notify/notifyAll方法后方能继续执行。而sleep方法只让线程休眠并不释放锁。notify/notifyAll方法调用后，并不会马上释放监视器锁，而是在相应的synchronized代码块或synchronized方法执行结束后才自动释放锁。&lt;/p&gt;
&lt;h2&gt;Synchronized的可重入与中断&lt;/h2&gt;
&lt;p&gt;       &lt;strong&gt;重入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当多个线程请求同一个临界资源，执行到同一个临界区时会产生互斥，未获得资源的线程会阻塞。而当一个已获得临界资源的线程再次请求此资源时并不会发生阻塞，仍能获取到资源、进入临界区，这就是重入。Synchronized是可重入的。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;中断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在Thread类中与线程中断相关的方法有三个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Interrupt设置一个线程为中断状态
 * Interrupt操作的线程处于sleep,wait,join 阻塞等状态的时候，清除“中断”状态，抛出一个InterruptedException
 * Interrupt操作的线程在可中断通道上因调用某个阻塞的 I/O 操作(serverSocketChannel. accept()、socketChannel.connect、socketChannel.open、 
 * socketChannel.read、socketChannel.write、fileChannel.read、fileChannel.write)，会抛出一个ClosedByInterruptException
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interrupt();
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 判断线程是否处于“中断”状态，然后将“中断”状态清除
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; interrupted();
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 判断线程是否处于“中断”状态
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isInterrupted();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实际使用中，当线程正处于调用sleep、wait、join方法后，调用interrupt会清除线程中断状态，并抛出异常。而当线程已进入临界区、正在执行，则需要isInterrupted()或interrupted()与interrupt()配合使用中断执行中的线程。&lt;/p&gt;
&lt;p&gt;       Sychronized修饰的方法、代码块被多个线程请求时，调用中断。正在执行的线程响应中断。正在阻塞的线程、执行中的线程都会标记中断状态，但阻塞的线程不会立刻处理中断，而是在进入临界区后再响应。&lt;/p&gt;
&lt;p&gt;示例：中断对执行synchronized方法线程的影响&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 示例：中断对执行synchronized方法线程的影响
 * 正在执行的线程响应中断
 * 正在阻塞的线程、执行中的线程都会标记中断状态，
 * 但阻塞的线程不会立刻处理中断，而是在进入临界区后再响应。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SyncDemo3 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; m1() {
        System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; hold resource!&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (flag) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Thread.currentThread().isInterrupted()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不用sleep，因为sleep会对中断抛出异常&lt;/span&gt;
&lt;span&gt;                Thread.yield();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; interrupted and release !&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SyncDemo3 syncDemo1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SyncDemo3();
        SyncDemo3 syncDemo2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SyncDemo3();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动两个线程&lt;/span&gt;
        Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; ThreadDemo3(syncDemo1), &quot;thread1&quot;&lt;span&gt;);
        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; ThreadDemo3(syncDemo2), &quot;thread2&quot;&lt;span&gt;);
        thread1.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;休眠1秒，让thread1获取资源&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            TimeUnit.SECONDS.sleep(&lt;/span&gt;1&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }

        thread2.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;休眠1秒&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            TimeUnit.SECONDS.sleep(&lt;/span&gt;1&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;thread1中断&lt;/span&gt;
&lt;span&gt;        thread1.interrupt();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;thread2中断&lt;/span&gt;
&lt;span&gt;        thread2.interrupt();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (thread1.isInterrupted()) {
            System.out.println(&lt;/span&gt;&quot;thread1 interrupt!&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (thread2.isInterrupted()) {
            System.out.println(&lt;/span&gt;&quot;thread2 interrupt!&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;休眠1秒，让thread2获取资源&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            TimeUnit.SECONDS.sleep(&lt;/span&gt;1&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }


    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ThreadDemo3 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    SyncDemo3 syncDemo3;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ThreadDemo3(SyncDemo3 syncDemo3) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.syncDemo3 =&lt;span&gt; syncDemo3;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        syncDemo3.m1();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;JDK6对Synchronized的优化&lt;/h2&gt;
&lt;p&gt;在JDK6以前synchronized的性能并不高，但在之后进行了优化，我们在之前的Mark Word的结构中可以看到，锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段。经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。&lt;/p&gt;
&lt;p&gt;偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。&lt;/p&gt;
&lt;p&gt;所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失。但偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自旋锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁消除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁粗化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展到整个操作序列的外部，这样就只需要加锁一次就够了。&lt;/p&gt;



&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《实战Java高并发程序设计》 葛一鸣，郭超 著&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/javazejian/article/details/72828483&lt;/p&gt;
</description>
<pubDate>Mon, 05 Nov 2018 06:51:00 +0000</pubDate>
<dc:creator>little-sheep</dc:creator>
<og:description>修饰静态方法、实例方法、代码块 Synchronized修饰静态方法，对类对象进行加锁，是类锁。 Synchronized修饰实例方法，对方法所属对象进行加锁，是对象锁。 Synchronized修饰</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/little-sheep/p/9909111.html</dc:identifier>
</item>
<item>
<title>【JavaScript系列】JavaScript之数组 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/9892604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/9892604.html</guid>
<description>&lt;p&gt;&lt;span&gt; 一  概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     JavaScript数组同后端语言一样，具有它自己的数据结构，归根结底，这种数据结构，本质就是一种集合。&lt;/p&gt;
&lt;p&gt;     在后端语言中(如java,.net等)，数组是这样定义的：数组是用来存储相同数据类型的集合。这个定义，“相同数据类型”6个字限制了数据只能存储相同的数据类型，如int[]数组只能存储数字，而不能存储字符数字，如下定义方式，是错误的，因为string&lt;/p&gt;
&lt;p&gt;不属于整型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;[] arr = { 10, 20,&quot;string&quot; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   然而，在JavaScript中，数组的定义确实非常宽松的，这也决定了其能存储一切数据的特点。JavaScript数组具有如下特点&lt;/p&gt;
&lt;p&gt;   特点1：存储相同基本数据类型的数据；&lt;/p&gt;
&lt;p&gt;   特点2：存储不同基本数据类型的数据；&lt;/p&gt;
&lt;p&gt;   特点3：存储对象&lt;/p&gt;
&lt;p&gt;   这三个特点，我们可归结为一句话：JavaScript存储一切对象，而不像后端语言那样，只能存储相同数据类型。除此之外，JavaScript数组还提供了很多丰富的操作方法。如下为常用的操作方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201811/1066923-20181105144106288-396786453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 本篇文章将主要结合代码来论述JavaScript数组。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二  对数组的基本操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（一）创建数组&lt;/p&gt;
&lt;p&gt;第一种方式:构造函数方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   //&lt;/span&gt;&lt;span&gt;第一种创建数组的方式:构造函数方式&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; colors = &lt;span&gt;new&lt;/span&gt; Array();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未知数组长度&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var colors = new Array(4);//已知数组长度&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var colors = new Array('green', 'yellow', 'white', 'red');//创建数组同时，给数组赋值&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var colors = Array();//在创建时，可以省略new关键字&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种方式:字面量方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种创建数组方式：使用数组字面量&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; colors = ['green', 'yellow', 'white', 'red'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = [];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建空数组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（二）访问数组&lt;/p&gt;
&lt;p&gt;访问数组，通过数组的下标来访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   //&lt;/span&gt;&lt;span&gt;创建数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; colors = ['green', 'yellow', 'white', 'red'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出索引值&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; colors.length; i++&lt;span&gt;) {
        alert(colors[i]);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;green,yellow,white,red&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;提示：for...in...访问数组属性(索引)，而不是数组属性值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; colors = ['green', 'yellow', 'white', 'red'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出数组索引&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; propAttr &lt;span&gt;in&lt;/span&gt;&lt;span&gt; colors) {
        alert(propAttr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0,1,2,3&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（三）为数组添加元素&lt;/p&gt;
&lt;p&gt;第一种方式：栈方式(后进先出，从数组尾部加入数据)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; colors = ['green', 'yellow', 'white', 'red'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种方式：栈方式&lt;/span&gt;
    colors.push(&quot;orange&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; colors.length; i++&lt;span&gt;) {
        alert(colors[i]);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;green,yellow,white,red,orange&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种方式：队列方式(先进先除，从数组头部加入数据)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  colors.unshift('orange'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; colors.length; i++&lt;span&gt;) {
        alert(colors[i]);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;orange,green,yellow,white,red&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（四）移除数组元素&lt;/p&gt;
&lt;p&gt;第一种方式:栈方式(后进先出，从数组尾部移除数据)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; colors = ['green', 'yellow', 'white', 'red'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//从尾部&lt;/span&gt;&lt;span&gt;弹出数据&lt;/span&gt;
&lt;span&gt;    colors.pop();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; colors.length; i++&lt;span&gt;) {
        alert(colors[i]);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;green,yellow,white,red,orange&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种方式：队列方式(先进先出，从数据头部移除数据)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; colors = ['green', 'yellow', 'white', 'red'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从头部移除数据&lt;/span&gt;
&lt;span&gt;    colors.shift();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; colors.length; i++&lt;span&gt;) {
        alert(colors[i]);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;yellow,white,red&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三种方式：length方式(借助length属性可访问性来操作)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; colors = ['green', 'yellow', 'white', 'red'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从尾部移除数据，与pop()一样&lt;/span&gt;
    colors.length = 3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; colors.length; i++&lt;span&gt;) {
        alert(colors[i]);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;green,yellow,white&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;三  数组方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（一）检测方法&lt;/p&gt;
&lt;p&gt;数组检测方式，可通过typeof,instranceof和Array.isArray()来检测。&lt;/p&gt;
&lt;p&gt;（二）转换方法&lt;/p&gt;
&lt;p&gt;所有对象都具有toLocaleString(),toString()和valueOf()三个方法，数组也如此。&lt;/p&gt;
&lt;p&gt;1.toString()&lt;/p&gt;
&lt;p&gt;toString()将数据的每个属性值转化为对应的字符串，然后再输出转换后的字符串值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; colors = ['red','green','yellow'&lt;span&gt;];
    alert(colors.toString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;red,green,yellow&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而下列代码与如上代码是一样的，因为alert()接收的是字符串，所以会在后台调用toString()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; colors = ['red','green','yellow'&lt;span&gt;];
    alert(colors);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;red,green,yellow&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.valueOf()&lt;/p&gt;
&lt;p&gt;valueOf()方法同toString()方法一样，也是返回数组的字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; colors = ['red', 'green', 'yellow'&lt;span&gt;];
    alert(colors.valueOf());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;red,green,yellow&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.toLocaleString()&lt;/p&gt;
&lt;p&gt;toLocaleString()返回数组的字符串形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; colors = ['red', 'green', 'yellow'&lt;span&gt;];
    alert(colors.toLocaleString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;red,green,yellow&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4 三者之间关系&lt;/p&gt;
&lt;p&gt;关系1：当不显示指出调用哪个方法时(toString(),toLocaleString()和valueOf())，默认调用每个属性的toString()；&lt;/p&gt;
&lt;p&gt;关系2：当显示地指出调用哪个方法时，就调用每个属性的该方法；&lt;/p&gt;
&lt;p&gt;关系3：关于valueOf问题，暂留&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;var&lt;/span&gt; person1 =&lt;span&gt; {
        toString: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Alan&quot;&lt;span&gt;;
        },
        toLocaleString: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Alan_beijing&quot;&lt;span&gt;;
        },
        valueOf: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;valueOf1&quot;&lt;span&gt;;
        }
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 =&lt;span&gt; {
        toString: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Alan1&quot;&lt;span&gt;;
        },
        toLocaleString: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Alan_beijing1&quot;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; people =&lt;span&gt; [person1, person2];
    alert(people.toString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Alan,Alan1&lt;/span&gt;
    alert(people.toLocaleString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Alan_beijing,Alan_beijing1&lt;/span&gt;
    alert(people.valueOf());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Alan,Alan1&lt;/span&gt;
    alert(people);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Alan,Alan1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（三）栈方法&lt;/p&gt;
&lt;p&gt;栈是一种数据结构，其算法为:LIFO(Last input First out)后进先出，其两个核心方法为push()和pop();&lt;/p&gt;
&lt;p&gt;1.push()&lt;/p&gt;
&lt;p&gt;push()表示将数据压入栈中，且放在栈的最后位置，即从栈的尾部压入数据。对于数组，则在数组的尾部加入数据，操作的顺序为：先把数组length+1，再压入数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; arr = [10, 20, 30&lt;span&gt;];
    arr.push(&lt;/span&gt;'新加入的数据'&lt;span&gt;);
    alert(arr.toString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10,20,30,新加入的数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.pop()&lt;/p&gt;
&lt;p&gt;push()表示将数据从栈中弹出，且从栈的最后位置弹出。对于数组，则在数组的尾部弹出数据，操作的顺序为：先弹出数据，再数组length-1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; arr = [10, 20, 30&lt;span&gt;];
    arr.pop();
    alert(arr.toString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10,20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（四）队列&lt;/p&gt;
&lt;p&gt;栈是一种数据结构，其算法为:FIFO(First input First out)后进先出，其两个核心方法为unshift()()和shift();&lt;/p&gt;
&lt;p&gt;1.unshift()&lt;/p&gt;
&lt;p&gt;unshift()表示从队列头部加入数据。对于数组，则从数组索引最小位置加入数据，操作顺序为：先将数length+1,再将当前数组属性值往后移动1个位置，最后将新数据添加到索引0处。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; arr = [10, 20, 30&lt;span&gt;];
    arr.unshift(&lt;/span&gt;40&lt;span&gt;);
    alert(arr.toString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;40,10,20,30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.shift()&lt;/p&gt;
&lt;p&gt;shift()表示从队列头部移除数据。对于数组，则从数组索引最小位置移除数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; arr = [20, 30&lt;span&gt;];
    arr.shift();
    alert(arr.toString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（五）排序方法&lt;/p&gt;
&lt;p&gt;在js数组中，两个重要的重排序方法：reverse()和sort()&lt;/p&gt;
&lt;p&gt;1.reverse()&lt;/p&gt;
&lt;p&gt;reverse()，顾名思义，逆序方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; arr = [1,2,3,4,5&lt;span&gt;];
    alert(arr.reverse());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5,4,3,2,1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.sort()&lt;/p&gt;
&lt;p&gt;sort()是比较灵活的排序方法了，支持自定义排序规则，默认排序为升序&lt;/p&gt;
&lt;p&gt;默认为升序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; arr = [3, 1, 2, 5, 4&lt;span&gt;];
    alert(arr.sort());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,2,3,4,5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自定义排序规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; arr = [3, 1, 2, 5, 4&lt;span&gt;];
    alert(arr.sort(Compare));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,2,3,4,5&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义排序规则：正序&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Compare(value1, value2) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value1 &amp;gt;&lt;span&gt; value2) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (value1 &amp;lt;&lt;span&gt; value2) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （六）位置方法&lt;/p&gt;
&lt;p&gt;js数组提供了两个位置方法：indexof()和lastIndexOf()&lt;/p&gt;
&lt;p&gt;indexOf()表示首次满足条件的位置;而lastIndexOf()则表示最后满足条件的位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; arr = [20, 30,20,40,10&lt;span&gt;];
    alert(arr.indexOf(&lt;/span&gt;20)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
    alert(arr.lastIndexOf(20));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（七）迭代方法&lt;/p&gt;
&lt;p&gt;ECMAScript5提供了5个迭代方法：every(),filter(),forEach(),map()和some()&lt;/p&gt;
&lt;p&gt;这个五个方法，均接收2个参数。&lt;/p&gt;
&lt;p&gt;1.every()&lt;/p&gt;
&lt;p&gt;对数组中的每项运行给定函数，如果该函数对每一项都返回ture，则返回true，否则返回false.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;every&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; num = [1, 2, 3, 4, 5, 4, 3, 2, 1&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; everyResult = num.every(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item, index,array) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item&amp;gt;2&lt;span&gt;
    });

    alert(everyResult);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fasle&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.some&lt;/p&gt;
&lt;p&gt;对数组中的每项运行给定函数，如果该函数对任意一项返回ture，则返回true，否则返回false&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;some&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; num = [1, 2, 3, 4, 5, 4, 3, 2, 1&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; someResult = num.some(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item, index, array) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item &amp;gt; 2&lt;span&gt;;
    });

    alert(someResult);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.filter&lt;/p&gt;
&lt;p&gt;对数组中的每项运行给定函数,返回该函数会返回true的项组成的数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; num = [1, 2, 3, 4, 5, 4, 3, 2, 1&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; filterResult = num.filter(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item, index, array) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item &amp;gt; 2&lt;span&gt;;
    });

    alert(filterResult);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3,4,5,4,3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.map&lt;/p&gt;
&lt;p&gt;对数组中的每项运行给定函数，返回每次函数调用的结果组成的数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; num = [1, 2, 3, 4, 5, 4, 3, 2, 1&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mapResult = num.map(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item, index, array) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item * 2&lt;span&gt;;
    });

    alert(mapResult);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2,4,6,8,10,8,6,4,2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5.forEach&lt;/p&gt;
&lt;p&gt;对数组中的每项运行给定函数。注意，该方法没返回值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;forEach&lt;/span&gt;
    num.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item, index, array) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行想要执行的操作&lt;/span&gt;
    });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（八）求和方法&lt;/p&gt;
&lt;p&gt;ECMAScript提供了2个缩减方法：reduce()和reduceRight()&lt;/p&gt;
&lt;p&gt;reduce和reduceRight,相当于.net的斐波拉列数列，计算算法为：f(n)=f(n-1)+f(n-2);&lt;/p&gt;
&lt;p&gt;1.reduce&lt;/p&gt;
&lt;p&gt;reduce计算数组时，按照从左到右的顺序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; values = [1, 2, 3, 4, 5&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sum = values.reduce(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (prev, cur, index, array) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; prev +&lt;span&gt; cur;
    });

    alert(sum);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.reduceRight&lt;/p&gt;
&lt;p&gt;reduceTight计算数组时，从右到左顺序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; values = [1, 2, 3, 4, 5&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sum1 = values.reduceRight(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (prev, cur, index, array) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; prev +&lt;span&gt; cur;
    });

    alert(sum1);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(九)其他方法&lt;/p&gt;
&lt;p&gt;ECMAScript为数组操作提供了很多方法，如concat()和slice()&lt;/p&gt;
&lt;p&gt;1.concat()&lt;/p&gt;
&lt;p&gt;concat()方法是将两个对象合并，从而生成新对象，合并同时，不会改变原来对象的值，只是做简单的拷贝&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; color1 = ['red', 'green', 'yellow'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; color2 = ['white', 'blue'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; concatColor =&lt;span&gt; color1.concat(color2);
    alert(concatColor);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;red,green,yellow,white,blue&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加单个值&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; concatSingelColor = color1.concat('orange'&lt;span&gt;);
    alert(concatSingelColor);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;red,green,yellow,orange&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不添加值，只是简单copy&lt;/span&gt;

    &lt;span&gt;var&lt;/span&gt; concatColor1 =&lt;span&gt; color1.concat();
    alert(concatColor1);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;red,green,yellow&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.slice&lt;/p&gt;
&lt;p&gt;slice()方法用于从目标数据中截取新数据，不会改变被截取对象的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; color1 = ['red', 'green', 'yellow'&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不传递参数：表示截取整个数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; color2 =&lt;span&gt; color1.slice();
    alert(color2);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;red,green,yellow&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递一个参数：表示从该位置处开始截取数据，直到数组最后一个数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; color3 = color1.slice(1&lt;span&gt;);
    alert(color3);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;green,yellow&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递2个参数：第一个参数表示从该位置开始截取，第二个参数减1表示所截数据的最后位置&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; color4 = color1.slice(1&lt;span&gt;, color1.length);
    alert(color4);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;green,yellow&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 四  参考文献&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【01】JavaScript 高级程序设计(第三版)   （美）Nicholas C.Zakas 著       李松峰   曹力  译&lt;/p&gt;
&lt;p&gt;【02】JavaScript 权威指南 (第6版)    David  Flanagan 著&lt;/p&gt;
</description>
<pubDate>Mon, 05 Nov 2018 06:43:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<og:description>一 概述 JavaScript数组同后端语言一样，具有它自己的数据结构，归根结底，这种数据结构，本质就是一种集合。 在后端语言中(如java,.net等)，数组是这样定义的：数组是用来存储相同数据类型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/9892604.html</dc:identifier>
</item>
<item>
<title>责任链模式 - 白色的魂魄</title>
<link>http://www.cnblogs.com/Krloypower/p/9908992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Krloypower/p/9908992.html</guid>
<description>&lt;p&gt;​ 一直都想对设计模式有一个深刻的认识，这样对于阅读源码的时候就不会那么吃力了。于是有了想要记录下设计模式的笔记。打算从自己不怎么熟悉的设计模式开始写，里面穿插着一点自己的想法，希望自己写完后，会又一个更深刻的理解和流畅的表述。&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;​ 为请求创建了一个接受者的链，通常一个接收者包含下一个接受者的引用，如果该对象不能处理该请求，就传给下一个。依次类推，直到有处理的对象为止。&lt;/p&gt;
&lt;p&gt;应用实例：jsp servlet的Filter，js中的事件冒泡&lt;/p&gt;
&lt;h3 id=&quot;例子&quot;&gt;例子&lt;/h3&gt;
&lt;p&gt;​ 通过一个例子来深刻的认识他。以前古代女子都遵从着三从四德，三从：一从父亲，二从丈夫，三从儿子。&lt;/p&gt;
&lt;p&gt;也就是在家听父亲的，嫁人后，听丈夫的，丧夫后，听儿子的。&lt;/p&gt;
&lt;p&gt;​ 那么现在呢，人人平等，那么我就说以后吧，一步小心就是男子三从四德了，那么针对男子进行三从四德进行代码演练。一男子想买键盘，先从母亲开始问起，如果母亲不想理你 ，你就问你妻子，你妻子不理你，你就问你女儿，你女儿也不理，你就啥也不能买。&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;抽象未来男子人类&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * @ClassName Human
 * @Description 人类
 * @Author ouyangkang
 * @Date 2018-11-05 10:02
 **/
public abstract class Human {
    /**
     * @Author ouyangkang
     * @Description 发起请求
     * @Date 10:04 2018/11/5
     * @param
     * @return void
    **/
    public abstract void request();

    /**
     * @Author ouyangkang
     * @Description 获取请求的类型
     * @Date 10:05 2018/11/5
     * @param
     * @return java.lang.Integer
    **/
    public abstract Integer getType();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;具体实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * @ClassName Man
 * @Description 未来男子
 * @Author ouyangkang
 * @Date 2018-11-05 10:07
 **/
public class Man extends Human {

    /**
     * @Date 2018/11/5 10:09
     * @Description 请求
     **/
    private String request;


    /**
     * @Date 2018/11/5 10:14
     * @Description 1 为入赘 2 已入赘 3 丧妻
     **/
    private Integer type ;

    @Override
    public void request() {
        System.out.println(request);
    }

    @Override
    public Integer getType() {
        return this.type;
    }


    public Man(String request, Integer type){
        this.request = request;
        this.type = type;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;处理抽象链&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * @ClassName Handler
 * @Description  责任链
 * @Author ouyangkang
 * @Date 2018-11-05 10:15
 **/
public abstract class Handler {


    public static final Integer MOTHER_LEVEL = 1;

    public static final Integer WIFE_LEVEL = 2;

    public  static final Integer DAUGHTER_LEVEL = 3;

    public  Integer level;

    /**
     * @Date 2018/11/5 10:16
     * @Description 下一个处理者
     **/
    private Handler nexHandler;

    public Handler(Integer level){
        this.level = level;
    }


    /**
     * @Author ouyangkang
     * @Description 处理信息
     * @Date 10:27 2018/11/5
     * @param human
     * @return void
    **/
    public void handleMessage(Human human){
        if (this.level.equals(human.getType())){
            this.response(human);
        }else {
            if (nexHandler != null){
                //传递给下一个处理对象
                this.nexHandler.handleMessage(human);
            }else {
                System.out.println(&quot;---------------&quot;);
                human.request();
                System.out.println(&quot;没有处理的人了&quot;);
            }

        }
    }

    /**
     * @Author ouyangkang
     * @Description 回复未来男子的请求
     * @Date 10:18 2018/11/5
     * @param
     * @return void
    **/
    public abstract void response(Human human);


    public void setNexHandler(Handler nexHandler){
        this.nexHandler = nexHandler;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;具体实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @ClassName Mather
 * @Description 母亲
 * @Author ouyangkang
 * @Date 2018-11-05 10:28
 **/
public class Mather extends Handler {


    public Mather(){
        super(Handler.MOTHER_LEVEL);
    }

    @Override
    public void response(Human human) {
        System.out.println(&quot;-----------------&quot;);
        human.request();
        System.out.println(&quot;妈妈爱你 当然同意啦&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * @ClassName Wife
 * @Description TODO
 * @Author ouyangkang
 * @Date 2018-11-05 10:46
 **/
public class Wife extends Handler {

    public Wife() {
        super(Handler.WIFE_LEVEL);
    }

    @Override
    public void response(Human human) {
        System.out.println(&quot;-----------------&quot;);
        human.request();
        System.out.println(&quot;&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @ClassName Wife
 * @Description TODO
 * @Author ouyangkang
 * @Date 2018-11-05 10:46
 **/
public class Wife extends Handler {

    public Wife() {
        super(Handler.WIFE_LEVEL);
    }

    @Override
    public void response(Human human) {
        System.out.println(&quot;-----------------&quot;);
        human.request();
        System.out.println(&quot;上次你那个机械键盘不是还能用吗 不给买&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @ClassName Daughter
 * @Description TODO
 * @Author ouyangkang
 * @Date 2018-11-05 10:48
 **/
public class Daughter extends Handler {

    public Daughter() {
        super(Handler.DAUGHTER_LEVEL);
    }

    @Override
    public void response(Human human) {
        System.out.println(&quot;-----------------&quot;);
        human.request();
        System.out.println(&quot;给糖吃就同意&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @ClassName Main
 * @Description TODO
 * @Author ouyangkang
 * @Date 2018-11-05 10:49
 **/
public class Main {
    public static void main(String[] args) {
        Random random = new Random();
        for (int i = 0 ;i &amp;lt; 5;i++){
            Human human = new Man(&quot;我要买键盘&quot;, random.nextInt(4));
            Handler mather = new Mather();
            Handler wife = new Wife();
            Handler daughter = new Daughter();
            mather.setNexHandler(wife);
            wife.setNexHandler(daughter);
            mather.handleMessage(human);

        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;-----------------
我要买键盘
给糖吃就同意
-----------------
我要买键盘
上次你那个机械键盘不是还能用吗 不给买
-----------------
我要买键盘
上次你那个机械键盘不是还能用吗 不给买
-----------------
我要买键盘
妈妈爱你 当然同意啦
---------------
我要买键盘
没有处理的人了
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 05 Nov 2018 06:31:00 +0000</pubDate>
<dc:creator>白色的魂魄</dc:creator>
<og:description>​ 一直都想对设计模式有一个深刻的认识，这样对于阅读源码的时候就不会那么吃力了。于是有了想要记录下设计模式的笔记。打算从自己不怎么熟悉的设计模式开始写，里面穿插着一点自己的想法，希望自己写完后，会又一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Krloypower/p/9908992.html</dc:identifier>
</item>
<item>
<title>Laravel系列之环境搭建 —  VirtualBox+Vagrant+Homestead - 李天其</title>
<link>http://www.cnblogs.com/ltqTest/p/9908916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ltqTest/p/9908916.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　为了解决环境不统一问题，所以要搭建这么个玩意儿&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　 Laravel对环境有所要求（不使用Homestead情况下），具体参考&lt;a title=&quot;不使用Homestead的环境要求&quot; href=&quot;https://laravel.com/docs/5.7&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 使用Homestead步骤&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　1. Homestead、VirtualBox、Vagrant&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　摘要：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Laravel 致力于让整个 PHP 开发体验变得愉快， 包括你的本地开发环境。 Vagrant 提供了一种简单，优雅的方式来管理和配置虚拟机。 Laravel Homestead 是一个官方预封装的 Vagrant box，它为你提供了一个完美的开发环境，而无需在本地机器安装 PHP 、Web 服务器和其他服务器软件。不用担心会搞乱你的操作系统！Vagrant boxes 是一次性的。如果出现问题，你可以在几分钟内销毁并创建 Box! Homestead 可以运行在任何 Windows，Mac，或 Linux 系统，它包括了 Nginx web 服务器， PHP 7.2，PHP 7.1，PHP 7.0，PHP 5.6， MySQL，PostgreSQL，Redis，Memcached， Node，以及开发 Laravel 应用程序所需要的东西。——摘自后盾人向军大叔（网站升级中，后期补链接）&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;virtualbox&quot;&gt;&lt;span&gt;　　　1. 1 VirtualBox&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　VirtualBox 是 Oracle 公司的开源虚拟机软件。VirtualBox 号称是最强的免费虚拟机软件，它不仅功能齐全，而且性能也很优异！VirtualBox 支持大部分流行的系统，如：Mac, Windows, Linux 等。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;vagrant&quot;&gt;&lt;span&gt;　　　1.2 Vagrant&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　Vagrant 是用来管理虚拟机的工具，支持当前主流的虚拟机系统如 VirtualBox、VMware、AWS 等。Vagrant 的主要作用是提供一个可配置、可移植和复用的软件环境。Vagrant 让你通过编写一个 Vagrantfile 文件来控制虚拟机的启动、虚拟机网络环境的配置、虚拟机与主机间的文件共享，以及启动后自动执行一些配置脚本，如自动执行一个 Shell Script 来安装一些必备的开发工具，如安装配置MySQL、PHP，甚至是自动配置 Nginx 站点。这意味着，在一个多人开发的项目中，你只需要同步 Vagrantfile 文件，就可以保证参与项目的每个人各自的机器上拥有一致的开发环境。 可以在下面网站上搜索需要的vagrant box &lt;a href=&quot;https://app.vagrantup.com/boxes/search&quot;&gt;https://app.vagrantup.com/boxes/search&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;homestead-box&quot;&gt;&lt;span&gt;　　    1.3 Homestead box&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　Homestead是一个官方预封装的 Vagrant box，它为你提供了一个完美的开发环境，而无需在本地机器安装 PHP 、Web 服务器和其他服务器软件。不用担心会搞乱你的操作系统！Vagrant boxes 是一次性的。如果出现问题，你可以在几分钟内销毁并创建 Box!内置软件：Ubuntu 16.04、Git、PHP 7.2、PHP 7.1、Nginx、Apache (Optional)、MySQL ……&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　　1.4 联系&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　白话理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1. vagrant把带有各种各样内置软件的Laravel/Homestead box（还有其他的Homestead box）打包成一个文件夹成为了一个镜像box来进行管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2. 再把这个镜像box安装到VirtualBox这个虚拟主机当中，但因为它有可能有很多（vagrant box list来查看），所以需要对其中的具体的某一个进行标识，所以这就需要进行安装Homestead管理脚本，下载好之后呢，进入Homestead文件夹中，里面的Vagrantfile配置项就是决定着你使用的那个homestead box，但是开发作者呢，将是将这个文件引用另外一个文件来进行管理的，所以我们需要进行一步操作（看下面）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　　1.5  安装&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　Ⅰ 在线安装 Homestead Vagrant Box，这样安装下载会非常慢（我最快网速15M/S反正是中断啊），可以使用第二种本地文件安装方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot; hljs avrasm&quot;&gt;　　　　　　vagrant box &lt;span class=&quot;hljs-keyword&quot;&gt;add laravel/homestead&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Ⅱ 本地文件安装 先下载 &lt;a href=&quot;https://pan.baidu.com/s/1stTmSYoLrMpMcjOWVglo7Q&quot;&gt;离线 homestead.box&lt;/a&gt; ，然后执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot; hljs avrasm&quot;&gt;　　　　　　vagrant box &lt;span class=&quot;hljs-keyword&quot;&gt;add laravel/homestead d:/code/homestead&lt;span class=&quot;hljs-preprocessor&quot;&gt;.box&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot; hljs avrasm&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;　　　　　　解释：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot; hljs avrasm&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;　　　　　　　　依次执行箭头所指：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467167/201811/1467167-20181105121315975-1086945297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　如果这个盒子不想用，可以进行删除（vagrant box remove laravel/homestead） 其他的homestead box 只需要改名字就好啦~&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　 III 安装Homestead管理脚本&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; clone管理脚本&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意 切换到稳定版本，不是master哟（目前是7.18.0）&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; git &lt;span&gt;clone&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/laravel/homestead.git ~/Homestead&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进入家目录&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; cd Homestead/
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因为master不稳定所以切到稳定tag &lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; git checkout v7.18.0 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建 Homestead.yaml 配置文件（也就是Vagrantfile引用的文件），所以修改这个文件即可&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; ./init.&lt;span&gt;bat
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是本地安装的 homestead.box 则它的版本为0，所以需要修改下面步骤生成的配置文件 ~Homestead/scripts/homestead.rb 以下内容，不然的话启动homestead的时候会进行更新操作&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; config.vm.box_version = settings[&quot;version&quot;] ||= &quot;&amp;gt;= 0&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　  Ⅳ SSH秘钥登陆（把镜像box安装到VirtualBox后，难免要登陆到操作系统当中，所以需要这一步）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
第一步：修改 Homestead.yaml 文件
&lt;/pre&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
keys:
    - ~/.ssh/id_rsa
    - ~/.ssh/id_rsa.pub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　注意：进入cd .ssh/后这个文件夹中没有id_rsa（私钥） id_rsa.pub（公钥）这两个文件要进行下一步操作&lt;/p&gt;
&lt;p&gt;　　　　（第二步）执行 ssh-keygen -t rsa -C &lt;span class=&quot;hljs-string&quot;&gt;&quot;XXX&lt;span class=&quot;hljs-variable&quot;&gt;@qq.com&quot;（替换自己的邮箱），然后一路回车即可（中间有步骤让设置密码，因为是本地开发没必要设置，所以一路回车）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;　　    V  文件夹同步配置（我们不可能每次需要进入虚拟机来进行代码的书写，所以需要将本机和虚拟机进行连接来进行代码书写）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; map: 本机文件夹路径&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; to: 推送到的虚拟主机路径&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个过程是双向的&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ~代表家目录（我的电脑是c:/Users/Dumpling）&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; folders:
&lt;span&gt;6&lt;/span&gt;     - map: ~/&lt;span&gt;code
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;       to: /home/vagrant/code
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　    VI vagrant命令（此时需要进入Homestead/文件夹）并测试文件同步&lt;/p&gt;
&lt;p&gt;　　　　启动虚拟机 —— vagrant up（因为在Homestead.yaml文件中的provider: virtualbox所以会安装虚拟机会安装到这个里面）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动 如果加上 --provision 选项那么添加的新站点会发布到虚拟机上。&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; cd ~/Homestead &amp;amp;&amp;amp;&lt;span&gt; vagrant up
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;vagrant halt
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过 SSH 登录 vagrant（需要先启动 vagrant）&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;vagrant ssh
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看目前安装的box列表&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; vagrant box &lt;span&gt;list&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除box镜像&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; vagrant box remove laravel/&lt;span&gt;homestead
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看当前 Homestead 虚拟机的状态。&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; vagrant status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　进入虚拟机 —— vagrant ssh（界面如下）&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467167/201811/1467167-20181105133332126-196446640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　测试文件同步&lt;/p&gt;
&lt;p&gt;　　　　　　　　此时虚拟机的code目录是空的，那么进入到家目录的code中创建一个文件看虚拟机中是否同时生成一个文件&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467167/201811/1467167-20181105133549869-788694846.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　　　　　　　　　本机创建后，查看虚拟机情况如下&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467167/201811/1467167-20181105133923257-2048701170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　同步成功&lt;/p&gt;
&lt;p&gt;　　  VII 使用域名访问到homestead虚拟主机&lt;/p&gt;
&lt;p&gt;　　　　控制域名的地方在 Homestead.yaml文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; map:域名&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; to:域名指向的目录是虚拟机中的这个位置&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; sites:
&lt;span&gt;4&lt;/span&gt;     - map: homestead.&lt;span&gt;test
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;       to: /home/vagrant/code/&lt;span&gt;public&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　记得修改本机hosts文件哟（请按照自己的本本自行百度）&lt;/p&gt;
&lt;p&gt;　　Ⅷ homestead链接数据库&lt;/p&gt;
&lt;p&gt;　　　　就只有端口不一样而已~&lt;/p&gt;
&lt;p&gt;　　　　　　要从主机的数据库客户端连接到 MySQL，就连接到 127.0.0.1和端口 33060 (MySQL) 。账号密码分别是 homestead／secret。&lt;/p&gt;
&lt;p&gt;　　　　　　PHP代码连接（虚拟机中连接）端口为 3306&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467167/201811/1467167-20181105140021280-1627063456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Ⅸ 全局命令&lt;/p&gt;
&lt;p&gt;　　　　Mac/Linux：&lt;/p&gt;
&lt;p&gt;　　　　　　如果iTems没有使用风格包zshrc的话，就在家目录下创建bash_profile文件，如有有的话修改修改zshrc文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 其实就是创建一个函数把进入Homestead/文件夹的操作，以及vagrant命令进行了结合&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 函数名可以修改为自己的，我这里是为了方便记忆和区分&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; homestead(){
    ( cd &lt;/span&gt;~/Homestead &amp;amp;&amp;amp; vagrant $*&lt;span&gt; )
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　Windows：同上（我反正按照中文手册的操作是不行的~）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467167/201811/1467167-20181105141244943-1630520856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　至此呢，有关于homestead的配置就完成啦~ 如果有任何不足，请予以指出。&lt;/p&gt;
&lt;p&gt;　　　　最后呢 感谢一下&lt;a title=&quot;后盾网官网&quot; href=&quot;http://www.houdunwang.com/&quot; target=&quot;_blank&quot;&gt;后盾网&lt;/a&gt;~ 贼拉好的&lt;a title=&quot;后盾人学习~&quot; href=&quot;http://www.houdunren.com/&quot; target=&quot;_blank&quot;&gt;PHP学习&lt;/a&gt;，大家可以去看看哟&lt;/p&gt;
&lt;p&gt;　　　　谢谢观赏~&lt;/p&gt;
</description>
<pubDate>Mon, 05 Nov 2018 06:18:00 +0000</pubDate>
<dc:creator>李天其</dc:creator>
<og:description>一、为啥需要搭建环境 为了解决环境不统一问题，所以要搭建这么个玩意儿 二、步骤 Laravel对环境有所要求（不使用Homestead情况下），具体参考官网 使用Homestead步骤 1. Home</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ltqTest/p/9908916.html</dc:identifier>
</item>
<item>
<title>微信授权获取code - 骑码行天下</title>
<link>http://www.cnblogs.com/hejun26/p/9908887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hejun26/p/9908887.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;span&gt;最近在做h5支付，然后发现一个问题，微信自带浏览器不支持h5支付，然后后台又做了一个微信支付的接口，然后要传code参数，代码写好总结后，就发到这里记录一下；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;因为有两个支付接口，所以首先判断打开页面的是微信浏览器还是其他浏览器，代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(ua.match(/MicroMessenger/i) == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;micromessenger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;微信浏览器&lt;/span&gt;
 }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他浏览器            &lt;/span&gt;
 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;然后，请求接口实例如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;amp;redirect_uri=REDIRECT_URI&amp;amp;response_type=code&amp;amp;scope=SCOPE&amp;amp;state=STATE&amp;amp;connect_redirect=1#wechat_redirect&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;参数的意思为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244003/201811/1244003-20181105140224980-1532181252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接着我们要准备的就是，把我们支付的这个APPID与&lt;/span&gt;REDIRECT_URI&lt;span&gt;填写好，appid问产品要，然后redirect_url自己找到自己需要跳转的地址链接，然后需要获取code的页面通过上一个页面跳转链接传值获取code即可；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
window.location.href = 'https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx9cxxxxxxxxxx42c&amp;amp;redirect_uri=https://xxxxx.com/wap/payOrder.html&amp;amp;response_type=code&amp;amp;scope=snsapi_base&amp;amp;state=STATE#wechat_redirect';
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;随后，我们需要获取code的该页面地址链接就会变成：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;xxxxx.com/wap/payOrder.html/?code=abc677adaduiadi7838&amp;amp;state=STATE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;最后，我们通过获取链接取到code，传值给后台：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getQueryString(name){  
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg = &lt;span&gt;new&lt;/span&gt; RegExp(&quot;(^|&amp;amp;)&quot; + name + &quot;=([^&amp;amp;]*)(&amp;amp;|$)&quot;, &quot;i&quot;&lt;span&gt;);  
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; r = window.location.search.substr(1&lt;span&gt;).match(reg);  
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; unescape(r[2]); &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;              
}  
       
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; code = getQueryString(&quot;code&quot;);
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;&lt;span&gt;这样，我们就获取到code，希望对大家有用。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 05 Nov 2018 06:10:00 +0000</pubDate>
<dc:creator>骑码行天下</dc:creator>
<og:description>摘要：最近在做h5支付，然后发现一个问题，微信自带浏览器不支持h5支付，然后后台又做了一个微信支付的接口，然后要传code参数，代码写好总结后，就发到这里记录一下； 因为有两个支付接口，所以首先判断打</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hejun26/p/9908887.html</dc:identifier>
</item>
<item>
<title>【不做标题党，只做纯干货】HashMap在jdk1.7和1.8中的实现 - 夏雪冬日</title>
<link>http://www.cnblogs.com/heyonggang/p/9899908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heyonggang/p/9899908.html</guid>
<description>
&lt;p&gt;&lt;span&gt;Java集合类的源码是深入学习Java非常好的素材，源码里很多优雅的写法和思路，会让人叹为观止。HashMap的源码尤为经典，是非常值得去深入研究的，jdk1.8中HashMap发生了比较大的变化，这方面的东西也是各个公司高频的考点。网上也有很多应对面试的标准答案，我之前也写过类似的面试技巧（&lt;a href=&quot;http://www.yuanrengu.com/index.php/2017-01-17.html&quot; target=&quot;_blank&quot;&gt;面试必备：Hashtable、HashMap、ConcurrentHashMap的原理与区别&lt;/a&gt;），应付一般的面试应该是够了，但个人觉得这还是远远不够，毕竟我们不能只苟且于得到offer，更应去勇敢的追求诗和远方（源码）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jdk版本目前更新的相对频繁，好多小伙伴说jdk1.7才刚真正弄明白，1.8就出现了，1.8还用都没开始用，更高的jdk版本就又发布了。很多小伙伴大声疾呼：臣妾真的学不动啦！这也许就是技术的最大魅力吧，活到老学到老，没有人能说精通所有技术。不管jdk版本如何更新，目前jdk1.7和1.8还是各个公司的主力版本。不管是否学得动，难道各位小伙伴忘记了&lt;strong&gt;《倚天屠龙记》里九阳真经里的口诀：他强由他强，清风拂山岗；他横由他横，明月照大江。他自狠来他自恶，我自一口真气足。（原谅我插入广告缅怀金庸大师，年少时期读的最多的书就是金庸大师的，遍布侠骨柔情大义啊）。这里的“真气”就是先掌握好jdk1.7和1.8，其它学不动的版本以后再说。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;HashMap是应用更广泛的&lt;strong&gt;哈希表&lt;/strong&gt;实现，而且大部分情况下，都能在常数时间性能的情况下进行put和get操作。要掌握HashMap，主要从如下几点来把握：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;jdk1.7中底层是由&lt;strong&gt;数组（也有叫做“位桶”的）+链表&lt;/strong&gt;实现；jdk1.8中底层是由&lt;strong&gt;数组+链表/红黑树&lt;/strong&gt;实现&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可&lt;strong&gt;以存储null键和null值&lt;/strong&gt;，线程&lt;strong&gt;不安全&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;初始size为&lt;strong&gt;16&lt;/strong&gt;，扩容：newsize = oldsize*2，size一定为2的n次幂&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span data-spm-anchor-id=&quot;a2c4e.11153940.blogcont635578.i1.4bfe20c90SADP1&quot;&gt;为什么说HashMap是线程不安全的？在接近临界点时，若此时两个或者多个线程进行put操作，都会进行resize（扩容）和reHash（为key重新计算所在位置），而reHash在并发的情况下可能会形成链表环。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; HashMap底层维护的是数组+链表，我们可以通过一小段源码来看看：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    /**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16

    /**
     * The maximum capacity, used if a higher value is implicitly specified
     * by either of the constructors with arguments.
     * MUST be a power of two &amp;lt;= 1&amp;lt;&amp;lt;30.
     */
    static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;

    /**
     * The load factor used when none specified in constructor.
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * An empty table instance to share when the table is not inflated.
     */
    static final Entry&amp;lt;?,?&amp;gt;[] EMPTY_TABLE = {};

    /**
     * The table, resized as necessary. Length MUST Always be a power of two.
     */
    transient Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;通过以上代码可以看出初始容量（16）、负载因子以及对数组的说明。&lt;strong&gt;数组中的每一个元素其实就是Entry&amp;lt;K,V&amp;gt;[] table，Map中的key和value就是以Entry的形式存储的&lt;/strong&gt;。关于Entry&amp;lt;K,V&amp;gt;的具体定义参看如下源码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    static class Entry&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
        final K key;
        V value;
        Entry&amp;lt;K,V&amp;gt; next;
        int hash;

        Entry(int h, K k, V v, Entry&amp;lt;K,V&amp;gt; n) {
            value = v;
            next = n;
            key = k;
            hash = h;
        }

        public final K getKey() {
            return key;
        }

        public final V getValue() {
            return value;
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry e = (Map.Entry)o;
            Object k1 = getKey();
            Object k2 = e.getKey();
            if (k1 == k2 || (k1 != null &amp;amp;&amp;amp; k1.equals(k2))) {
                Object v1 = getValue();
                Object v2 = e.getValue();
                if (v1 == v2 || (v1 != null &amp;amp;&amp;amp; v1.equals(v2)))
                    return true;
            }
            return false;
        }

        public final int hashCode() {
            return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
        }

        public final String toString() {
            return getKey() + &quot;=&quot; + getValue();
        }

        /**
         * This method is invoked whenever the value in an entry is
         * overwritten by an invocation of put(k,v) for a key k that's already
         * in the HashMap.
         */
        void recordAccess(HashMap&amp;lt;K,V&amp;gt; m) {
        }

        /**
         * This method is invoked whenever the entry is
         * removed from the table.
         */
        void recordRemoval(HashMap&amp;lt;K,V&amp;gt; m) {
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当向 HashMap 中 put 一对键值时，它会根据 key的 hashCode 值计算出一个位置， 该位置就是此对象准备往数组中存放的位置。 该计算过程参看如下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
   transient int hashSeed = 0;
   final int hash(Object k) {
        int h = hashSeed;
        if (0 != h &amp;amp;&amp;amp; k instanceof String) {
            return sun.misc.Hashing.stringHash32((String) k);
        }

        h ^= k.hashCode();

        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
        h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
        return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
    }

    /**
     * Returns index for hash code h.
     */
    static int indexFor(int h, int length) {
        // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;
        return h &amp;amp; (length-1);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过hash计算出来的值将会使用indexFor方法找到它应该所在的table下标。&lt;/span&gt;&lt;span&gt;当两个key通过hashCode计算相同时，则发生了hash冲突(碰撞)，HashMap解决hash冲突的方式是用&lt;strong&gt;链表&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;当发生hash冲突时，则将存放在数组中的Entry设置为新值的next（这里要注意的是，比如A和B都hash后都映射到下标i中，之前已经有A了，当map.put(B)时，将B放到下标i中，A则为B的next，所以新值存放在数组中，旧值在新值的链表上）。&lt;strong&gt;即将新值作为此链表的头节点，为什么要这样操作？据说后插入的Entry被查找的可能性更大（因为get查询的时候会遍历整个链表），此处有待考究，如果有哪位大神知道，请留言告知。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果该位置没有对象存在，就将此对象直接放进数组当中；如果该位置已经有对象存在了，则顺着此存在的对象的链开始寻找(为了判断是否是否值相同，map不允许&amp;lt;key,value&amp;gt;键值对重复)， 如果此链上有对象的话，再去使用 equals方法进行比较，如果对此链上的每个对象的 equals 方法比较都为 false，则将该对象放到数组当中，然后将数组中该位置以前存在的那个对象链接到此对象的后面。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/478153/201811/478153-20181103161909175-957381358.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;图中，左边部分即代表哈希表，也称为哈希数组（默认数组大小是16，每对key-value键值对其实是存在map的内部类entry里的），数组的每个元素都是一个单链表的&lt;strong&gt;头节点&lt;/strong&gt;，跟着的蓝色链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;前面说过HashMap的key是允许为null的，当出现这种情况时，会放到table[0]中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    private V putForNullKey(V value) {
        for (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != null; e = e.next) {
            if (e.key == null) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }
        modCount++;
        addEntry(0, null, value, 0);
        return null;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当size&amp;gt;=threshold（ threshold等于“容量*负载因子”）时，会发生扩容。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (null != table[bucketIndex])) {
            resize(2 * table.length);
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;jdk1.7中resize，只有当 size&amp;gt;=threshold并且 table中的那个槽中已经有Entry时，才会发生resize。即有可能虽然size&amp;gt;=threshold，但是必须等到每个槽都至少有一个Entry时，才会扩容,可以通过上面的代码看到每次resize都会扩大一倍容量（2 * table.length）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在jdk1.8中HashMap的内部结构可以看作是数组(Node&amp;lt;K,V&amp;gt;[] table)和链表的复合结构，数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组中的寻址（哈希值相同的键值对，则以链表形式存储。有一点需要注意，&lt;strong&gt;如果链表大小超过阈值（TREEIFY_THRESHOLD,8），图中的链表就会被改造为树形（红黑树）结构&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
transient Node&amp;lt;K,V&amp;gt;[] table;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Entry的名字变成了Node，原因是和红黑树的实现TreeNode相关联。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在分析jdk1.7中HashMap的hash冲突时，不知大家是否有个疑问就是万一发生碰撞的节点非常多怎么版？如果说成百上千个节点在hash时发生碰撞，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费O(N)的查找时间，这将是多么大的性能损失。这个问题终于在JDK1.8中得到了解决，在最坏的情况下，&lt;strong&gt;链表查找的时间复杂度为O(n),而红黑树一直是O(logn),&lt;/strong&gt;这样会提高HashMap的效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jdk1.7中HashMap采用的是位桶+链表的方式，即我们常说的散列链表的方式，而jdk1.8中采用的是位桶+链表/红黑树的方式，也是非线程安全的。当某个位桶的链表的长度达到某个阀值的时候，这个链表就将转换成红黑树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;jdk1.8中，当同一个hash值的节点数不小于8时，将不再以单链表的形式存储了，会被调整成一颗红黑树（上图中null节点没画）。这就是jdk1.7与jdk1.8中HashMap实现的最大区别。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过分析put方法的源码，可以让这种区别更直观：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
static final int TREEIFY_THRESHOLD = 8;

public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
 }
 
 
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&amp;lt;K,V&amp;gt;[] tab;
    Node&amp;lt;K,V&amp;gt; p;
    int n, i;
    //如果当前map中无数据，执行resize方法。并且返回n
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
     //如果要插入的键值对要存放的这个位置刚好没有元素，那么把他封装成Node对象，放在这个位置上即可
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
    //否则的话，说明这上面有元素
        else {
            Node&amp;lt;K,V&amp;gt; e; K k;
        //如果这个元素的key与要插入的一样，那么就替换一下。
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                e = p;
        //1.如果当前节点是TreeNode类型的数据，执行putTreeVal方法
            else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
        //还是遍历这条链子上的数据，跟jdk7没什么区别
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
            //2.完成了操作后多做了一件事情，判断，并且可能执行treeifyBin方法
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null) //true || --
                    e.value = value;
           //3.
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
    //判断阈值，决定是否扩容
        if (++size &amp;gt; threshold)
            resize();
        //4.
        afterNodeInsertion(evict);
        return null;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上代码中的特别之处如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
        treeifyBin(tab, hash);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;treeifyBin()就是将链表转换成红黑树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;putVal方法处理的逻辑比较多，包括初始化、扩容、树化，近乎在这个方法中都能体现，针对源码简单讲解下几个关键点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果Node&amp;lt;K,V&amp;gt;[] table是null，resize方法会负责初始化，即如下代码：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;resize方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容（resize）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在放置新的键值对的过程中，如果发生下面条件，就会发生扩容。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
        if (++size &amp;gt; threshold)
            resize();
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;具体键值对在哈希表中的位置（数组index）取决于下面的位运算：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
i = (n - 1) &amp;amp; hash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;仔细观察哈希值的源头，会发现它并不是key本身的hashCode，而是来自于HashMap内部的另一个hash方法。为什么这里需要将高位数据移位到低位进行异或运算呢？&lt;strong&gt;这是因为有些数据计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在jdk1.8中取消了indefFor()方法，直接用(tab.length-1)&amp;amp;hash，所以看到这个，代表的就是数组的下角标。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;为什么HashMap为什么要树化？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前在极客时间的专栏里看到过一个解释。&lt;strong&gt;本质上这是个安全问题&lt;/strong&gt;。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务器端CPU大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四、分析Hashtable、HashMap、TreeMap的区别&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;HashMap是继承自&lt;span&gt;&lt;strong&gt;AbstractMap&lt;/strong&gt;&lt;/span&gt;类，而HashTable是继承自&lt;span&gt;&lt;strong&gt;Dictionary&lt;/strong&gt;&lt;/span&gt;类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。存储的内容是基于key-value的键值对映射，不能由重复的key，而且一个key只能映射一个value。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Hashtable的key、value都不能为null；HashMap的key、value可以为null，不过只能有一个key为null，但可以有多个null的value；TreeMap键、值都不能为null。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Hashtable、HashMap具有无序特性。&lt;strong&gt;TreeMap是利用红黑树实现的&lt;/strong&gt;（树中的每个节点的值都会大于或等于它的左子树中的所有节点的值，并且小于或等于它的右子树中的所有节点的值），实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需求排序的情况下首选TreeMap，&lt;strong&gt;默认按键的升序排序（深度优先搜索）&lt;/strong&gt;，也可以自定义实现Comparator接口实现排序方式。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;一般情况下我们选用HashMap，因为HashMap的键值对在取出时是随机的，其依据键的hashCode和键的equals方法存取数据，具有很快的访问速度，所以在Map中插入、删除及索引元素时其是效率最高的实现。而TreeMap的键值对在取出时是排过序的，所以效率会低点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TreeMap是基于红黑树的一种提供顺序访问的Map，与HashMap不同的是它的get、put、remove之类操作都是o(log(n))的时间复杂度，具体顺序可以由指定的Comparator来决定，或者根据键的自然顺序来判断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;对HashMap做下总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;HashMap基于哈希散列表实现 ，可以实现对数据的读写。将键值对传递给put方法时，它调用键对象的hashCode()方法来计算hashCode，然后找到相应的bucket位置（即数组）来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决hash冲突问题，当发生冲突了，对象将会储存在链表的头节点中。HashMap在每个链表节点中储存键值对对象，当两个不同的键对象的hashCode相同时，它们会储存在同一个bucket位置的链表中，如果链表大小超过阈值（TREEIFY_THRESHOLD,8），链表就会被改造为树形结构。&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 05 Nov 2018 05:56:00 +0000</pubDate>
<dc:creator>夏雪冬日</dc:creator>
<og:description>Java集合类的源码是深入学习Java非常好的素材，源码里很多优雅的写法和思路，会让人叹为观止。HashMap的源码尤为经典，是非常值得去深入研究的，jdk1.8中HashMap发生了比较大的变化，这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heyonggang/p/9899908.html</dc:identifier>
</item>
<item>
<title>初探系列 — Pharbers用于单点登录的权限架构 - 旻天clock</title>
<link>http://www.cnblogs.com/clockq/p/9908742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clockq/p/9908742.html</guid>
<description>&lt;h2 id=&quot;就职公司&quot;&gt;就职公司&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.pharbers.com&quot;&gt;法伯科技&lt;/a&gt;是一家以数据科技为驱动, 专注于医药健康领域的循证咨询公司. 以数据科学家身份, 赋能医药行业. 让每位客户都能享受数据带来的价值, 洞察业务, 不止于数据, 让决策更精彩。&lt;/p&gt;
&lt;p&gt;法伯拥有多套自主研发的数据分析工具, 为企业带来高效, 便捷, 实用的解决方案.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MAX © ：市场动态监测工具&lt;/li&gt;
&lt;li&gt;TMIST © ：铁马区域管理模拟平台&lt;/li&gt;
&lt;li&gt;PET © ：推广评估优化工具&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;适用人群&quot;&gt;适用人群&lt;/h2&gt;
&lt;p&gt;本篇文章, 所有实例代码, 均为Scala, 适用于以Scala系列技术栈和微服务架构的初期开发团队. 其他技术请自行斟酌修改.&lt;br/&gt;原文地址&lt;a href=&quot;https://www.cnblogs.com/clockq/p/9908742.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/clockq/p/9908742.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;软件架构作用&quot;&gt;软件架构作用&lt;/h2&gt;
&lt;p&gt;公司的每个产品都有各自应用的领域和范畴, 但都是医药业务扩展中的必经一换. 所以常常会有公司同时使用我们多个产品的情况. 而我们每个产品, 在一些数据和逻辑使用上, 有很大的相通性.&lt;br/&gt;而如何更好的保护客户数据, 怎样提供更好的用户体验, 就是本篇文章的重点内容了.&lt;/p&gt;
&lt;h3 id=&quot;加密安全&quot;&gt;加密安全&lt;/h3&gt;
&lt;p&gt;为了保障用户账号密码的安全性, 在前后端交互中, 所传输的密码, 均为RSA规范的非对称加密. 同时, 数据库中存储的用户密码, 也为MD5序列化的密文形式.&lt;/p&gt;
&lt;h3 id=&quot;公司独立秘钥&quot;&gt;公司独立秘钥&lt;/h3&gt;
&lt;p&gt;为每个公司, 生成单独的秘钥对, 每对秘钥有自己的过期时间, 过期时间为公司购买产品的使用时间.&lt;/p&gt;
&lt;h3 id=&quot;会话管理&quot;&gt;会话管理&lt;/h3&gt;
&lt;p&gt;在用户登录成功后, 会将该用户的所有权限信息存入Redis中, 同时生成一个ObjectId作为token返回给前端. 同时, token有自己的有效时间.&lt;/p&gt;
&lt;h3 id=&quot;开放授权单点登录&quot;&gt;开放授权(单点登录)&lt;/h3&gt;
&lt;p&gt;用户在任意位置登录法伯账号后, 在token有效期内, 可以不用输入账号密码, 直接登录该账号所拥有的其他产品中.&lt;/p&gt;
&lt;h3 id=&quot;视图组件&quot;&gt;视图组件&lt;/h3&gt;
&lt;p&gt;用户成功登录, 会根据用户当前的权限和角色, 前端决定渲染的组件和布局&lt;/p&gt;
&lt;h3 id=&quot;接口安全&quot;&gt;接口安全&lt;/h3&gt;
&lt;p&gt;后端暴露给前端的接口(登录, 注册等无须登录接口除外), 都需要有一个有效token才可以正确调用.&lt;/p&gt;

&lt;h2 id=&quot;cryptography加密部分&quot;&gt;Cryptography(加密部分)&lt;/h2&gt;
&lt;p&gt;加密算法, 使用的类库是java自带的&lt;code&gt;java.security&lt;/code&gt;库.&lt;br/&gt;Base64库使用的是&lt;code&gt;commons-codec&lt;/code&gt;, MVN如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-codec&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-codec&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;秘钥对创建&quot;&gt;秘钥对创建&lt;/h3&gt;
&lt;p&gt;公钥秘钥创建:&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// create by ClockQ
trait RSACryptogram extends PhCryptogram {
    val puk: String
    val prk: String
    val ALGORITHM_RSA: String
    val TRANSFORMS_RSA: String
    val CHARSET_NAME_UTF_8: String
    val KEY_SIZE: Int

    def createKey(): (String, String) = {
        val keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM_RSA)
        keyPairGenerator.initialize(KEY_SIZE, new SecureRandom())
        val keyPair = keyPairGenerator.generateKeyPair()

        val publicKey = Base64.encodeBase64String(keyPair.getPublic.getEncoded)
        val privateKey = Base64.encodeBase64String(keyPair.getPrivate.getEncoded)

        (publicKey, privateKey)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一段代码很简单:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实例化秘钥工厂;&lt;/li&gt;
&lt;li&gt;设置KEY_SIZE和随机码;&lt;/li&gt;
&lt;li&gt;生成秘钥;&lt;/li&gt;
&lt;li&gt;将公钥和秘钥按照Base64编码.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面的常量如下:&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;val ALGORITHM_RSA = &quot;RSA&quot;
val TRANSFORMS_RSA = &quot;RSA/ECB/PKCS1PADDING&quot;
val CHARSET_NAME_UTF_8 = &quot;UTF-8&quot;
val KEY_SIZE = 512&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;加密&quot;&gt;加密&lt;/h3&gt;
&lt;p&gt;加密流程:&lt;br/&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fwx3kam4xmj30rl0epq3w.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trait RSAEncryptTrait { this: RSACryptogram =&amp;gt;
    def encrypt(cleartext: String): String = {

        if(puk.isEmpty) throw new Exception(&quot;public key is empty&quot;)

        val originKey = Base64.decodeBase64(puk)
        val keySpec = new X509EncodedKeySpec(originKey)
        val publicKey = KeyFactory.getInstance(ALGORITHM_RSA).generatePublic(keySpec)

        val cipher = Cipher.getInstance(TRANSFORMS_RSA)
        cipher.init(Cipher.ENCRYPT_MODE, publicKey)

        val inputBytes = URLEncoder.encode(cleartext, CHARSET_NAME_UTF_8).getBytes(CHARSET_NAME_UTF_8)
        val inputLength = inputBytes.length

        val MAX_ENCRYPT_BLOCK = (KEY_SIZE &amp;gt;&amp;gt; 3) - 11
        var offset = 0
        var cache: Array[Byte] = Array()

        while (inputLength - offset &amp;gt; 0) {
            val tmp = if (inputLength - offset &amp;gt; MAX_ENCRYPT_BLOCK)
                cipher.doFinal(inputBytes, offset, MAX_ENCRYPT_BLOCK)
            else
                cipher.doFinal(inputBytes, offset, inputLength - offset)

            cache ++= tmp
            offset += MAX_ENCRYPT_BLOCK
        }

        Base64.encodeBase64String(cache)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解密&quot;&gt;解密&lt;/h3&gt;
&lt;p&gt;解密的过程与加密相反, 流程图就不画了, 代码如下:&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;trait RSADecryptTrait { this: RSACryptogram =&amp;gt;
    def decrypt(ciphertext: String): String = {

        if(prk.isEmpty) throw new Exception(&quot;private key is empty&quot;)

        val originKey = Base64.decodeBase64(prk)
        val keySpec = new PKCS8EncodedKeySpec(originKey)
        val privateKey = KeyFactory.getInstance(ALGORITHM_RSA).generatePrivate(keySpec)

        val cipher = Cipher.getInstance(TRANSFORMS_RSA)
        cipher.init(Cipher.DECRYPT_MODE, privateKey)

        val inputBytes = Base64.decodeBase64(ciphertext)
        val inputLength = inputBytes.length

        val MAX_DECRYPT_BLOCK = KEY_SIZE &amp;gt;&amp;gt; 3
        var offset = 0
        var cache: Array[Byte] = Array()

        while (inputLength - offset &amp;gt; 0) {
            val tmp = if (inputLength - offset &amp;gt; MAX_DECRYPT_BLOCK)
                cipher.doFinal(inputBytes, offset, MAX_DECRYPT_BLOCK)
            else
                cipher.doFinal(inputBytes, offset, inputLength - offset)

            cache ++= tmp
            offset += MAX_DECRYPT_BLOCK
        }

        URLDecoder.decode(new String(cache, CHARSET_NAME_UTF_8), CHARSET_NAME_UTF_8)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;上面代码中的&lt;code&gt;while&lt;/code&gt;循环, 是用来处理加密解密的内容过长时, 用来分段加密的. 但请记住, 由于RSA非对称加密的效率问题, 不建议加密过长的内容, 可以考虑采用对称加密, 然后对于对称加密的秘钥, 使用RSA加密, 然后将密文和之前对称加密的密文共同传输.&lt;/li&gt;
&lt;li&gt;对于RSA加密的明文长度计算公式, 假如我们的&lt;code&gt;KEY_SIZE = 512&lt;/code&gt;, 并且采用&lt;code&gt;RSA/ECB/PKCS1PADDING&lt;/code&gt;协议加密, 则我们的最大加密长度为&lt;code&gt;(KEY_SIZE &amp;gt;&amp;gt; 3) - 11&lt;/code&gt;, 为什么减11呢? 因为&lt;code&gt;RSA/ECB/PKCS1PADDING&lt;/code&gt;是一种加密协议, 它为了保证相同公钥加密相同内容, 出现密文一样, 所以在明文的中间部分, 加入了11位随机的混淆码.&lt;/li&gt;
&lt;li&gt;关于变态对接问题, 我在和Golang和Js联调的时候, 发现我的密文他们可以解析, 而他们的密文我无法解析, 原因在于, Java的解密库中, 只能使用&lt;code&gt;PKCS8&lt;/code&gt;解密协议.关于&lt;code&gt;PKCS&lt;/code&gt;的信息, 可以查看&lt;a href=&quot;https://baike.baidu.com/item/PKCS/1042350&quot;&gt;百度百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;公司独立秘钥-1&quot;&gt;公司独立秘钥&lt;/h2&gt;
&lt;p&gt;上面的代码中, 已经写了如何创建一对指定KEY_SIZE大小的秘钥对, 我们只需要将其存入MongoDB中, 并和Company关联即可. 为了实现每个秘钥对有自己的过期时间, 我想到了Redis的TTL, 庆幸MongoDB有类似的技术, 文章我就不抄了, 有兴趣的朋友可以查看这篇文章.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jianlong727/article/details/54631124&quot;&gt;MongoDB TTL索引技术自动删除过期数据&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;登录验证&quot;&gt;登录验证&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwly1fwx4llnoovj30ru0f5404.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开放授权&quot;&gt;开放授权&lt;/h2&gt;
&lt;p&gt;前端获得登录token后, 对之后的每次请求, 都将以下面形式写入Headers中,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;key&quot;:&quot;Authorization&quot;,
    &quot;value&quot;:&quot;bearer 5bc58327c8f5e406a2b57394&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后端验证token是否过期, 以及该用户token中所记录的权限, 决定本次请求的合法性和返回内容.&lt;/p&gt;

&lt;p&gt;以上就是我们&lt;a href=&quot;http://www.pharbers.com&quot;&gt;法伯科技&lt;/a&gt;的一个简单的权限管理系统, 通过OAuth的特性, 可以实现单点登录, 利用token在Redis中存放用户相关的角色和产品, 可以决定用户在登录某一产品时, 是否有进入权限, 进入产品后, 决定可以显示哪些组件, 可以使用哪些功能.&lt;/p&gt;

</description>
<pubDate>Mon, 05 Nov 2018 05:50:00 +0000</pubDate>
<dc:creator>旻天clock</dc:creator>
<og:description>一. 前言 就职公司</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clockq/p/9908742.html</dc:identifier>
</item>
<item>
<title>c# 与java base64 不一致解决方案 - ChnHonKer-小河</title>
<link>http://www.cnblogs.com/cnhonker/p/9908733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnhonker/p/9908733.html</guid>
<description>&lt;p&gt;不一致的问题不是编码的问题  而是json字符串的问题通常我们会json 嵌套  我们先来看连个字符串&lt;/p&gt;
&lt;p&gt;{&quot;contentType&quot;:&quot;&quot;,&quot;httpMethod&quot;:&quot;POST&quot;,&quot;paramMap&quot;:&quot;{\&quot;keyword\&quot;:\&quot;华为\&quot;}&quot;,&quot;url&quot;:&quot;https:\/\/bizapi.jd.com\/api\/search\/search&quot;}    --第一条&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;{&quot;contentType&quot;:&quot;&quot;,&quot;httpMethod&quot;:&quot;POST&quot;,&quot;paramMap&quot;:{&quot;keyword&quot;:&quot;华为&quot;},&quot;url&quot;:&quot;https://bizapi.jd.com/api/search/search&quot;}     ----第二条&lt;/p&gt;
&lt;p&gt;-----接下来我们看一下效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172746/201811/1172746-20181105133514514-14062371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看第二条的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172746/201811/1172746-20181105133558694-1130688563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一条情况：我们将json 字符串 转换为对象 直接使用 但是  paramMap的值是一个字符串  我们又要将 该值转换为json在使用的过程中  我们转换了两次&lt;/p&gt;
&lt;p&gt;第二条情况:直接转换为json对象 我们分别取不同key的value来使用      发生错误的问题 应该是有  反斜杠转移符&lt;/p&gt;
&lt;p&gt;我们上一下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Newtonsoft.Json;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Forms;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Base64
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Form1 : Form
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Form1()
        {
            InitializeComponent();
        }

        
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; dic = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
            dic.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); dic.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            JsonStr jsonstr&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; JsonStr(dic,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; JavaBase64(JsonConvert.SerializeObject(jsonstr));
        }


        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 实体类
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实体类
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JsonStr
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Method = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; param;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; JsonStr(Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; _param, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _url)
            {
                param &lt;/span&gt;= _param; url =&lt;span&gt; _url;
            }
        } 
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;


        &lt;span&gt;#region&lt;/span&gt; 转换为单字节  java base64
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 转换为单字节  java base64
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;str&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; JavaBase64(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
        {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] by =&lt;span&gt; Encoding.UTF8.GetBytes(str);
            &lt;/span&gt;&lt;span&gt;sbyte&lt;/span&gt;[] sby = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;sbyte&lt;/span&gt;&lt;span&gt;[by.Length];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; by.Length; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (by[i] &amp;gt; &lt;span&gt;127&lt;/span&gt;&lt;span&gt;)
                    sby[i] &lt;/span&gt;= (&lt;span&gt;sbyte&lt;/span&gt;)(by[i] - &lt;span&gt;256&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    sby[i] &lt;/span&gt;= (&lt;span&gt;sbyte&lt;/span&gt;&lt;span&gt;)by[i];
            }
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] newby = (&lt;span&gt;byte&lt;/span&gt;[])(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;)sby;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToBase64String(newby);
        } 
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;



    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个问题 近期在与第三方服务商 遇到json问题时处理的 &lt;/p&gt;
&lt;p&gt;一般c# json嵌套在对象重 再把整个对象转为json   是字符串一&lt;/p&gt;
&lt;p&gt;{&quot;contentType&quot;:&quot;&quot;,&quot;httpMethod&quot;:&quot;POST&quot;,&quot;paramMap&quot;:&quot;{\&quot;keyword\&quot;:\&quot;华为\&quot;}&quot;,&quot;url&quot;:&quot;https:\/\/bizapi.jd.com\/api\/search\/search&quot;}&lt;/p&gt;
&lt;p&gt;而上述字符串在第三方那里却解不开  随后按照代码里的方式  使字符串为json字符串  中间不含json嵌套的  因为嵌套会多出来很多  反斜杠转移符  所以导致  第三方那里解不开 &lt;/p&gt;
&lt;p&gt;如果想要知道c# java base64 为什么解不开&lt;/p&gt;
&lt;p&gt;首先了解  c# java  的byte   c# 0~255  java  -128~127  其次是我们的字符串    我们的字符串  base64  编码前对比  编码后对比  如果一致问题是可以解决的  剩下的思考问题就留给你遐想了&lt;/p&gt;
&lt;p&gt;QQ:35924908  附加信息：博客园看到的&lt;/p&gt;

</description>
<pubDate>Mon, 05 Nov 2018 05:48:00 +0000</pubDate>
<dc:creator>ChnHonKer-小河</dc:creator>
<og:description>不一致的问题不是编码的问题 而是json字符串的问题通常我们会json 嵌套 我们先来看连个字符串 {&quot;contentType&quot;:&quot;&quot;,&quot;h</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cnhonker/p/9908733.html</dc:identifier>
</item>
</channel>
</rss>