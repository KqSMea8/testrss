<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>为什么我的子线程更新了 UI 没报错？借此，纠正一些Android 程序员的一个知识误区 - 指尖下的幽灵</title>
<link>http://www.cnblogs.com/linguanh/p/7898996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linguanh/p/7898996.html</guid>
<description>&lt;h3 id=&quot;开门见山&quot;&gt;开门见山:&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这个误区是：子线程不能更新 UI ，其应该分类讨论，而不是绝对的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;半小时前，我的 XRecyclerView 群里面，一位群友私聊我，问题是：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么我的子线程更新了 UI 没报错？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;我叫他发下代码我看如下十分简单的代码&quot;&gt;我叫他发下代码我看，如下，十分简单的代码。&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(Bundle savedInstanceState) {
    &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(savedInstanceState);
    &lt;span class=&quot;fu&quot;&gt;setContentView&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;layout&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;activity_main&lt;/span&gt;);
    
    title = (TextView) &lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;title_tips&lt;/span&gt;);
    &lt;span class=&quot;fu&quot;&gt;doGet&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;http;//www.baidu.com&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Callback() {
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onFailure&lt;/span&gt;(Request request, IOException e) {
            
        }
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onResponse&lt;/span&gt;(Response response) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
            title.&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(response.&lt;span class=&quot;fu&quot;&gt;body&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;string&lt;/span&gt;()); &lt;span class=&quot;co&quot;&gt;// 这里在子线程更新了 text&lt;/span&gt;
        }
    });
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doGet&lt;/span&gt;(String url,Callback callback) {
    OkHttpClient client = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;OkHttpClient&lt;/span&gt;();
    
    Request.&lt;span class=&quot;fu&quot;&gt;Builder&lt;/span&gt; builder = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Request.&lt;span class=&quot;fu&quot;&gt;Builder&lt;/span&gt;();
    Request request = builder.&lt;span class=&quot;fu&quot;&gt;url&lt;/span&gt;(url).&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;();

    client.&lt;span class=&quot;fu&quot;&gt;newCall&lt;/span&gt;(request).&lt;span class=&quot;fu&quot;&gt;enqueue&lt;/span&gt;(callback);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单解析下。他用了 OkHttp 的异步 enqueue 的请求，并在成功后更新了 textView 的 text。&lt;/p&gt;
&lt;h4 id=&quot;明确一点&quot;&gt;明确一点：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;okhttp 的同步异步的回调都是在子线程里面的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么这样来说，&lt;strong&gt;按照我们被一直灌输的原理: 子线程不能刷新UI&lt;/strong&gt;，上面这段代码妥妥地爆错啊。&lt;/p&gt;
&lt;h4 id=&quot;而我要说的是&quot;&gt;而我要说的是:&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上面的代码不一定爆错，它还会稳稳的顺利执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;你十分怀疑了&quot;&gt;你十分怀疑了？&lt;/h4&gt;
&lt;p&gt;你可以尝试下。嫌麻烦，你可以运行下下面这段&lt;code&gt;通透&lt;/code&gt;的子线程更新UI代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestActivity &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Activity {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; TextView title;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(Bundle savedInstanceState) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(savedInstanceState);
        &lt;span class=&quot;fu&quot;&gt;setContentView&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;layout&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;activity_main&lt;/span&gt;);
        title = (TextView) &lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;title_tips&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(
                &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {
                    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
                        &lt;span class=&quot;co&quot;&gt;// 子线程更新UI&lt;/span&gt;
                        title.&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我 tm 妥妥地执行完毕&quot;&lt;/span&gt;);
                    }
                }
        ).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;试了的都知道，真 tm 执行了没爆错。&lt;/p&gt;
&lt;h4 id=&quot;颠覆了吗&quot;&gt;颠覆了吗？&lt;/h4&gt;
&lt;h2 id=&quot;原因&quot;&gt;原因&lt;/h2&gt;
&lt;p&gt;在看到他发给我的代码，&lt;code&gt;onCreate&lt;/code&gt; 里面的部分，一切已经明了，这也是我之前面试几年经验的人设过的坑。下面我直接讲原因，源码分析那些你们自己去看吧，&lt;code&gt;你应该去看&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;修改验证-----抛出错误&quot;&gt;修改验证 --- 抛出错误&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(Bundle savedInstanceState) {
    &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(savedInstanceState);
    &lt;span class=&quot;fu&quot;&gt;setContentView&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;layout&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;activity_main&lt;/span&gt;);
    title = (TextView) &lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;title_tips&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(
            &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {
                &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
                    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                        &lt;span class=&quot;co&quot;&gt;// 等待 onResume 执行完，让 viewRootImpl 初始化完成&lt;/span&gt;
                        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3000&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// ---------- 这里，看这里&lt;/span&gt;
                    } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
                        e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
                    }
                    title.&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我执行不了&quot;&lt;/span&gt;);
                }
            }
    ).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 26 Nov 2017 06:45:00 +0000</pubDate>
<dc:creator>指尖下的幽灵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linguanh/p/7898996.html</dc:identifier>
</item>
<item>
<title>JVM菜鸟进阶高手之路十四：分析篇 - 匠心零度</title>
<link>http://www.cnblogs.com/lirenzuo/p/7898973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lirenzuo/p/7898973.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;转载请注明原创出处，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目回顾&quot;&gt;题目回顾&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/a4585cfef43a&quot;&gt;JVM菜鸟进阶高手之路十三&lt;/a&gt;,问题现象就是相同的代码，jvm参数不一样，表现的现象不一样。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; _1MB = &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] all1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; * _1MB];
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] all2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; * _1MB];
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] all3 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; * _1MB];
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] all4 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; * _1MB];
        System.&lt;span class=&quot;fu&quot;&gt;in&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;jvm参数配置如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;-Xmx20m
-Xms20m
-Xmn10m
-XX:+UseParNewGC 
-XX:+UseConcMarkSweepGC 
-XX:+UseCMSInitiatingOccupancyOnly 
-XX:CMSInitiatingOccupancyFraction=&lt;span class=&quot;dv&quot;&gt;75&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过jstat命令，查看结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-7d4ec32bd5e7a735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;关于jstat命令详情可以参考：&lt;br/&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html&quot; class=&quot;uri&quot;&gt;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jvm参数调整如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;-Xmx20m
-Xms20m
-Xmn10m
-XX:+UseParNewGC &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过jstat命令，查看结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-c2998bc6cf44417d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;上面的题目仅仅是一个切入点而已，希望通过一个切入点把jvm的一些基础知识刚刚好说明下，顺便解答下上面的现象。&lt;/p&gt;
&lt;h2 id=&quot;内存相关简单说明&quot;&gt;内存相关简单说明&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-cfc49dfe0d610dc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;自己画的图，见谅！&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图中参数：&lt;/strong&gt;&lt;br/&gt;-Xms设置最小堆空间大小（一般建议和-Xmx一样）。&lt;br/&gt;-Xmx设置最大堆空间大小。&lt;br/&gt;-Xmn设置新生代大小。&lt;br/&gt;-XX:MetaspaceSize设置最小元数据空间大小。&lt;br/&gt;-XX:MaxMetaspaceSize设置最大元数据空间大小。&lt;br/&gt;-Xss设置每个线程的堆栈大小（这里有个故事，3年前用正则表达式，后续有空正则表达式再说）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;tenured空间就用减法操作即可明白，堆空间大小减去年轻代大小就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;说到这里，下面这个几个参数应该明白了。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;-Xmx20m
-Xms20m
-Xmn10m&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;参数-XX:SurvivorRatio用来表示s0、s1、eden之间的比例，默认情况下-XX:SurvivorRatio=8表示 s0:s1:eden=1:1:8。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;得出结论：eden=8M,s0=1M,s1=1M,tenured=10M。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;jvm垃圾回收期组合&quot;&gt;JVM垃圾回收期组合&lt;/h2&gt;
&lt;p&gt;还有一个问题需要解决，jvm垃圾回收器方面，下面这个图，我是我的&lt;a href=&quot;http://mp.weixin.qq.com/s/ZVZFBONZtFrEX4qbz72MlA&quot;&gt;JVM菜鸟进阶高手之路八（一些细节）&lt;/a&gt;，里面的，当时依稀记得这个图应该是飞哥发给我的。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-a2296ebe84fd3f20?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;JVM垃圾回收期组合&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于那个时候jdk9还没有出来，可以去看看我的&lt;a href=&quot;http://mp.weixin.qq.com/s/mdaOPsXZFVzhWuGdnFV17A&quot;&gt;JVM菜鸟进阶高手之路十二（jdk9、JVM方面变化， 蹭热度）&lt;/a&gt;，虽然有些有些稍微去掉了，但是整体的组合还是影响不大。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-9e5880d52a5c9e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;取截取于JVM菜鸟进阶高手之路十二&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于上面的2个jvm参数都是基于分代收集算法的（&lt;strong&gt;先不考虑G1&lt;/strong&gt;）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;依据对象的存活周期进行分为新生代，老年代。&lt;/li&gt;
&lt;li&gt;根据不同代的特点，选取合适的收集算法&lt;/li&gt;
&lt;li&gt;新生代，适合复制算法&lt;/li&gt;
&lt;li&gt;老年代，适合标记清理或者标记压缩&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;复制算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记清除&lt;/strong&gt;&lt;br/&gt;标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段，首先先找出根对象，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;java根对象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟机栈中引用的对象。&lt;/li&gt;
&lt;li&gt;方法区中类静态属性实体引用的对象。&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象。&lt;/li&gt;
&lt;li&gt;本地方法栈中JNI引用的对象。&lt;br/&gt;等等。&lt;br/&gt;标记清除算法&lt;strong&gt;缺点：&lt;/strong&gt;标记清除会产生不连续的内存碎片，如果空间内存碎片过多会导致，当程序在运行过程中需要分配空间时找不到足够的连续空间而不得不提前触发一次垃圾收集动作（根据算法不一样效果也不一样）。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;标记压缩&lt;/strong&gt;&lt;br/&gt;标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;这样带来的好处就是不会参数内存碎片问题了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上面已经说明了这么多了，我们可以继续说明上题中JVM的其他参数了。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;-XX:+UseParNewGC
-XX:+UseConcMarkSweepGC &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-XX:+UseParNewGC 表示新生代使用ParNew并行收集器，-XX:+UseConcMarkSweepGC 表示老年代使用CMS回收器（CMS收集器是基于“标记-清除”算法实现的，&lt;strong&gt;特别提醒由于CMS是标记清除算法实现的所以是存在碎片问题的&lt;/strong&gt;）。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-2ba694edfa2162ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;可以去看看我的&lt;a href=&quot;http://mp.weixin.qq.com/s/ltaUGepOPsMGU8YwyBV8bA&quot;&gt;JVM菜鸟进阶高手之路六（JVM每隔一小时执行一次Full GC）&lt;/a&gt;、以及&lt;a href=&quot;http://mp.weixin.qq.com/s/8qfFejOqY-CbwFUuCGi-IA&quot;&gt;JVM菜鸟进阶高手之路七（tomcat调优以及tomcat7、8性能对比）&lt;/a&gt;图片就取的这两篇里面的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;通过jstat -gcutil pid 查看的FGC这列的时候，CMS gc通常都是&lt;strong&gt;+2&lt;/strong&gt;一次的，由于CMS-initial-mark和CMS-remark会stop-the-world。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-7d4ec32bd5e7a735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;所以看到这个图的FGC应该没有什么问题了吧。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;-XX:+UseCMSInitiatingOccupancyOnly 
-XX:CMSInitiatingOccupancyFraction=&lt;span class=&quot;dv&quot;&gt;75&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有这2个参数关于cms的，-XX:+UseCMSInitiatingOccupancyOnly表示JVM不基于运行时收集的数据来启动CMS垃圾收集周期通过CMSInitiatingOccupancyFraction的值进行每一次CMS收集，-XX:CMSInitiatingOccupancyFraction=75 表示当老年代的使用率达到阈值75%时会触发CMS GC。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;jstat -gcutil可以看出上图的老年代的使用率才60.02%&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有最后一个参数解释:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;-XX:+UseParNewGC &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-XX:+UseParNewGC 表示新生代使用ParNew并行收集器，那么老年代呢？&lt;br/&gt;可以让同样参数修改代码执行一次old gc即可看日志有类似&lt;strong&gt;[Tenured:&lt;/strong&gt;说明老年代使用的是Serial Old&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;Serial Old使用的是标记压缩算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解题&quot;&gt;解题&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; _1MB = &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] all1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; * _1MB];
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] all2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; * _1MB];
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] all3 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; * _1MB];
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] all4 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; * _1MB];
        System.&lt;span class=&quot;fu&quot;&gt;in&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;最后System.in.read();这句可以忽略，只是为了让程序阻塞在那里，不结束，这样好看日志，好看现象而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;聪明如你&lt;/strong&gt;一下子应该可以看到问题本质:同一份代码，jvm参数堆设置啥的都一样，年轻代gc参数也一样，唯一不同的就在于老年代gc使用上面，而jstat -gcutil图表中FGC没变的应该是正常结果，变了的CMS那个就是意外结果，所以关键点就在CMS上面了。&lt;/p&gt;
&lt;p&gt;先来说说all1 、all12、all3、对象实例化开辟空间之后，eden空间都够，他们都在eden空间中，当all4过来的时候，eden空间不够了，需要执行ygc了。&lt;br/&gt;下面有2个问题需要说明，1、如果s0能存的下，可以看看&lt;a href=&quot;http://mp.weixin.qq.com/s/0O2NaWaMptu_Zt6cy-RWJw&quot;&gt;JVM菜鸟进阶高手之路三：MaxTenuringThreshold&lt;/a&gt;新生代的对象正常情况下&lt;strong&gt;最多&lt;/strong&gt;经过多少次YGC的过程会晋升到老生代（CMS情况下默认为6），说到这里可能还需要提一个参数：-XX:TargetSurvivorRatio，可以参考飞哥的：&lt;a href=&quot;http://www.jianshu.com/p/f91fde4628a5&quot;&gt;JVM Survivor行为一探究竟&lt;/a&gt; 2、如果s0存不下，就是我们这里的情况（由于我们这里s0就是1M而已）所以直接进入到old空间了，&lt;strong&gt;所以可以看出来jstat -gcutil 里面的老年代的比例都是60%几了吧&lt;/strong&gt;。&lt;br/&gt;ygc执行完成之后，all4就还可以在eden分配（空间够），&lt;strong&gt;所以可以看出来jstat -gcutil 里面的eden的比例都是89%几了吧&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;-XX:PretenureSizeThreshold参数来设置多大的对象直接进入老年代（这个参数其实只对串行回收器和ParNew有效，对ParallelGC无效）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果是-Xmx20m -Xms20m -Xmn10m -XX:+UseParNewGC 这套参数，那么结果就是如图可以解释了，并且每个参数比例啥的都可以理解了。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-c2998bc6cf44417d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面来好好解释下这个现象：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-7d4ec32bd5e7a735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;strong&gt;聪明如你&lt;/strong&gt;一下子应该可以看到一个问题，那么就是&lt;strong&gt;时间间隔是每隔2s执行一次&lt;/strong&gt;，没错就是2s执行一次。需要说道-XX:CMSWaitDuration(Time in milliseconds that CMS thread waits for young GC)默认值是2s，我们修改为-XX:CMSWaitDuration=5000看看效果：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-e35501d27075363e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;CMSWaitDuration变化&quot;/&gt;&lt;br/&gt;看到了吧，修改为5s就是5s执行一次变化了。那么至于为什么会执行呢？？&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-418d6cdaa5d23f89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;执行的CMS GC的3中情况&quot;/&gt;&lt;br/&gt;本题就是当前新生代的对象是否能够全部顺利的晋升到老年代，如果不能，会触发CMS GC。&lt;/p&gt;
&lt;p&gt;具体可以看看我比较崇拜的狼哥的分析，一个比我牛逼并且比我努力的大牛。&lt;a href=&quot;http://www.jianshu.com/p/a322309b1d90&quot;&gt;一个有意思的频繁CMS问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本人其他JVM菜鸟进阶高手之路相关文章或者其他系列文章可以关注公众号【匠心零度】获取更多！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果读完觉得有收获的话，欢迎点赞、关注、加公众号【匠心零度】。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;个人公众号，欢迎关注，查阅更多精彩历史！！！&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-5f48f1430e958383.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;匠心零度公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Nov 2017 06:35:00 +0000</pubDate>
<dc:creator>匠心零度</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lirenzuo/p/7898973.html</dc:identifier>
</item>
<item>
<title>容易被忽视的后端服务 chunked 性能问题 - 王清培</title>
<link>http://www.cnblogs.com/wangiqngpei557/p/7898730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangiqngpei557/p/7898730.html</guid>
<description>&lt;p&gt;标签（空格分隔）： springboot springmvc chunked&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;spring boot&lt;/strong&gt; 创建的默认 &lt;strong&gt;spring mvc&lt;/strong&gt; 项目&lt;/li&gt;
&lt;li&gt;集成 &lt;strong&gt;JAX-RS&lt;/strong&gt; 规范框架 &lt;strong&gt;Jersey&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;在之前的一次性能压测的时候我们发现一个细节问题，我们使用 &lt;strong&gt;spring boot&lt;/strong&gt; 创建的 &lt;strong&gt;web rest&lt;/strong&gt; 项目，使用默认 &lt;strong&gt;spring mvc&lt;/strong&gt; 作为 &lt;strong&gt;web rest&lt;/strong&gt; 框架。&lt;/p&gt;
&lt;p&gt;这在使用上没有太大问题，但是有一个影响性能的细节问题被发现了，说实话这个问题很难被发现。&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-创建的默认-spring-mvc-项目&quot;&gt;&lt;strong&gt;spring boot&lt;/strong&gt; 创建的默认 &lt;strong&gt;spring mvc&lt;/strong&gt; 项目&lt;/h2&gt;
&lt;p&gt;我们来看一个简单的 &lt;strong&gt;demo&lt;/strong&gt;，我使用 &lt;strong&gt;IDEA&lt;/strong&gt; 创建一个 &lt;strong&gt;spring boot&lt;/strong&gt; 项目，创建过程中没有什么特别的选项需要调整，一路 &lt;strong&gt;next&lt;/strong&gt; 。然后我们创建一个简单的 &lt;strong&gt;controller&lt;/strong&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package springboot.demo.controller;

import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import springboot.demo.model.User;

/**
 * Created by plen on 2017/11/25.
 */

@RestController
public class SpringMvcController {

    @RequestMapping(&quot;/user/{id}&quot;)
    public User hello(@PathVariable  Long id) {

        User user = new User();
        user.setID(id);
        user.setUserName(&quot;mvc.&quot;);

        return user;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再创建一个简单的 &lt;strong&gt;model&lt;/strong&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package springboot.demo.model;

import lombok.Data;
import lombok.EqualsAndHashCode;

/**
 * Created by plen on 2017/11/25.
 */
@Data
@EqualsAndHashCode
public class User {
    private Long ID;
    private String userName;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后启动访问这个 &lt;strong&gt;controller&lt;/strong&gt; ，注意看下返回的 &lt;strong&gt;http&lt;/strong&gt; 信息里多了一个 &lt;strong&gt;Transfer-Encoding:chunked&lt;/strong&gt; 。&lt;strong&gt;Transfer-Encoding:chunked&lt;/strong&gt; 在 &lt;strong&gt;HTTP&lt;/strong&gt; 协议里的意思是无法计算 &lt;strong&gt;Content-Length&lt;/strong&gt; 长度，需要分块传输。&lt;/p&gt;
&lt;p&gt;这是 &lt;strong&gt;spring mvc&lt;/strong&gt; 的默认 &lt;strong&gt;complex object&lt;/strong&gt; 传输方式，如果我们返回的是一个简单的对象就不会有这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Transfer-Encoding:chunked&lt;/strong&gt; 带来的性能问题就是访问一次数据需要不止一次的 &lt;strong&gt;http&lt;/strong&gt; 请求，而一次 &lt;strong&gt;http&lt;/strong&gt; 请求的成本也是比较大的。&lt;/p&gt;
&lt;p&gt;（我没有通过抓包工具来测试具体哪种对象大小需要访问几次，感兴趣的可以自己试下。）&lt;/p&gt;
&lt;h2 id=&quot;集成-jax-rs-规范框架-jersey&quot;&gt;集成 &lt;strong&gt;JAX-RS&lt;/strong&gt; 规范框架 &lt;strong&gt;Jersey&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;解决这个问题两个层面都可以，一种是采用比较粗暴的方式在 &lt;strong&gt;servlet&lt;/strong&gt; 容器层面解决，但是这个会带来一个后果就是当我们计算 &lt;strong&gt;complex object&lt;/strong&gt; 大小的时候会比较复杂而且容易出错，也会影响项目未来的分块传输功能，效果不太好。&lt;/p&gt;
&lt;p&gt;还有一种就是在应用层面解决，比较柔性也易于扩展，我们可以集成一个 &lt;strong&gt;rest&lt;/strong&gt; 框架，最好是符合 &lt;strong&gt;JAX-RS&lt;/strong&gt; 规范，本文我们集成 &lt;strong&gt;Jersey&lt;/strong&gt; 框架。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jersey&lt;/strong&gt; 集成如果通过 &lt;a href=&quot;mailto:__@Component_&quot;&gt;__@Component_&lt;/a&gt;_ 方式那么 &lt;strong&gt;jersey&lt;/strong&gt; 会默认接管所有的 &lt;strong&gt;web servlet&lt;/strong&gt; 请求处理，所以就需要我们手动的配置专门用来处理 &lt;strong&gt;jersey servlet&lt;/strong&gt; 的容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spring boot&lt;/strong&gt; 解决了以前 &lt;strong&gt;spring&lt;/strong&gt; 繁重的配置，提供了 &lt;strong&gt;auto config&lt;/strong&gt; 功能，原来通过 &lt;strong&gt;web.xml&lt;/strong&gt; 配置 &lt;strong&gt;servlet&lt;/strong&gt; 的，现在需要用代码来配置。&lt;strong&gt;spring boot&lt;/strong&gt; 提供了让我们手动注册 &lt;strong&gt;servlet bean&lt;/strong&gt; 的方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;org.springframework.boot.web.servlet.ServletRegistrationBean&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ServletRegistrationBean 可以让我们注册servlet，我们来看下完整代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package springboot.demo.config;

import org.glassfish.jersey.servlet.ServletContainer;
import org.glassfish.jersey.servlet.ServletProperties;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

/**
 * Created by plen on 2017/11/25.
 */
@Component
public class JerseyServletBeanConfig {

    @Bean
    public ServletRegistrationBean jerseyServlet() {

        ServletRegistrationBean registrationBean = new ServletRegistrationBean(new ServletContainer(), &quot;/rest/v1/*&quot;);
        registrationBean.addInitParameter(ServletProperties.JAXRS_APPLICATION_CLASS, JerseyResourceConfig.class.getName());

        return registrationBean;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这和原来在 &lt;strong&gt;web.xml&lt;/strong&gt; 配置的是一样的，设置 &lt;strong&gt;routing&lt;/strong&gt; 地址，设置 &lt;strong&gt;Init&lt;/strong&gt; 初始化参数，对应的 &lt;strong&gt;servlet class name&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;所有的 __&quot;rest/v1/*&quot;__ 请求都将被 &lt;strong&gt;ServletContainer jersey servlet&lt;/strong&gt; 容器接管。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package springboot.demo.config;

import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.server.spring.scope.RequestContextFilter;
import springboot.demo.controller.JerseyController;

/**
 * Created by plen on 2017/11/25.
 */
public class JerseyResourceConfig extends ResourceConfig {

    public JerseyResourceConfig() {
        register(JerseyController.class);
        register(RequestContextFilter.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ResourceConfig&lt;/strong&gt; 其实是一个 &lt;strong&gt;jersey Application&lt;/strong&gt; 类型。这是 __jersey 注册 &lt;strong&gt;servlet&lt;/strong&gt; 时规定的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package springboot.demo.controller;

import springboot.demo.model.User;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

/**
 * Created by plen on 2017/11/25.
 */

@Path(&quot;/user/&quot;)
public class JerseyController {

    @Path(&quot;{id}&quot;)
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public User hello(@PathParam(&quot;id&quot;) Long id) {

        User user = new User();
        user.setID(id);
        user.setUserName(&quot;jersey.&quot;);

        return user;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是我们应用代码 &lt;strong&gt;Controller&lt;/strong&gt; ，使用 &lt;strong&gt;JAX-RS&lt;/strong&gt; 规范的注解进行设置即可。&lt;/p&gt;
&lt;p&gt;这样就解决了 &lt;strong&gt;sprng mvc&lt;/strong&gt; 和 &lt;strong&gt;jersey rest&lt;/strong&gt; 共同存在的问题，我们也不需要将所有的返回 &lt;strong&gt;chunked&lt;/strong&gt; 的接口都改成 &lt;strong&gt;JAX-RS&lt;/strong&gt; 的 &lt;strong&gt;rest&lt;/strong&gt; 服务，只需要将有性能瓶颈的接口改造下即可。&lt;/p&gt;
</description>
<pubDate>Sun, 26 Nov 2017 04:29:00 +0000</pubDate>
<dc:creator>王清培</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangiqngpei557/p/7898730.html</dc:identifier>
</item>
<item>
<title>关于程序可维护性的一些想法 - 氢氦</title>
<link>http://www.cnblogs.com/hhelibeb/p/7891401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhelibeb/p/7891401.html</guid>
<description>&lt;p&gt;SAP系统作为企业的信息系统，其生命周期通常是漫长的，比单个程序员的在职时间要长得多。早期实施阶段花大力气开发的自定义程序，会交付给企业内部或外部的运维团队来维护——不管怎么样，一般不是最初的开发者了。即便是在运维阶段，程序的创建者与修改者也常常不是一个人。不同的开发者，其知识基础、技术水平、编码风格难免有所不同，最早创建的程序，经过若干个独一无二的开发者的修改，可能会变得面目全非，失去可维护性。这时的程序可以说已经接近于死亡...因此，作为程序的开发者，我们需要让自己的程序对修改有抵抗力，从而能在后人的维护下活的更久一些。&lt;/p&gt;
&lt;p&gt;当然，抵抗修改的意思，并不是指妨碍后人修改程序。企业的业务是多变的、人们对需求的理解是不断加深的，因而程序的修改也是&lt;strong&gt;必要&lt;/strong&gt;的。抵抗修改的目标应当是：在合理的需求变动发生时，尽量让修改变得容易，并减小修改带来的破坏，从而让程序能承受更多次的修改。&lt;/p&gt;
&lt;p&gt;我认为问题的关键在于减少耦合度、理清程序职责的分配，清晰的程序描述也很重要：&lt;/p&gt;
&lt;p&gt;耦合度即模块之间的关联强度。高耦合度的程序牵一发而动全身，只适合于需求十分稳定的程序。对于多变的ABAP程序来说，降低耦合度可以减少程序修改对其它部分的影响，是比较重要的。&lt;/p&gt;
&lt;p&gt;单纯的解耦工作有可能让我们陷入为解耦而解耦的陷阱。了解程序的职责分配可以让我们更加理性地运用技术，并且使程序对修改有更好的适应性。&lt;/p&gt;
&lt;p&gt;程序的描述包含命名、程序结构这种“自我描述”，也包括程序注释、技术文档，以及需求文档。这可能是最容易改善的一个方面。&lt;/p&gt;
&lt;p&gt;下面结合具体的ABAP开发技术来谈谈我对它们的想法，因为只是根据自己的一些经验的来写，可能不是系统全面的介绍。&lt;/p&gt;

&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 关于程序可维护性的一些想法&quot; href=&quot;http://www.cnblogs.com/hhelibeb/p/7891401.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hhelibeb/p/7891401.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创内容，转载请注明出处&lt;/p&gt;
&lt;h2&gt;CDS视图&lt;/h2&gt;
&lt;p&gt;SQL是让很多程序员感到头痛的东西。过去，由于内表的存在，大家会用简单的SQL取出较多的数据，然后在内表中处理它们，计算主要在应用服务器中进行。但在S4之后，SAP鼓励将更多的工作交给数据库服务器来做，也为ABAP的Open SQL提供了更强大的功能。可见日后的SQL将变得日益复杂。在复杂的SQL上进行修改可能会耗时较多、测试困难，有时也会不小心造成性能问题。&lt;a href=&quot;https://blogs.sap.com/2017/09/09/abap-core-data-services-introduction-abap-cds-view/#RCDS&quot; target=&quot;_blank&quot;&gt;ABAP CDS&lt;/a&gt;视图的引入可以较好的应对这些问题。如果早期的开发者能够利用CDS抽象出稳定的&lt;strong&gt;数据模型&lt;/strong&gt;，把经过若干SQL处理的数据当作已存在的数据来看，那么就能简化ABAP程序中的SQL复杂度，同时也降低后续的开发者和业务顾问的心智负担和沟通成本。&lt;/p&gt;
&lt;p&gt;（想一想我们是不是经常说这种冗长的话：XX属性是通过关联A表和B表，使它们的公司、业务编号和移动序号相等，在取消标识不等于'X'等情况下，获取它的某一属性，再到属性对应到的分配表C，获取有效期内的记录——看完并理解这么长一段话之后，也许交流的双方已经只顾着理解XX属性究竟怎样获取，忘记了自己在思考的其它东西。如果这种关联逻辑在公司的需求中是稳定的甚至常常出现的，我们完全可以为它造一个“新词”，即CDS视图。基于CDS视图，之后的沟通方式可以变为：到视图ZCDSXX中，根据取消标识不等于'X'，获取我们需要的XX属性）&lt;/p&gt;
&lt;h2&gt;硬编码与配置表&lt;/h2&gt;
&lt;p&gt;这二者的原理在于将对程序的修改变为“扩展”，在不干涉或较少干涉程序代码的情况，完成功能的变更。&lt;/p&gt;
&lt;h2&gt;动态技术&lt;/h2&gt;
&lt;p&gt;动态技术是双刃剑，Field Symbol和&lt;a href=&quot;https://wiki.scn.sap.com/wiki/pages/viewpage.action?pageId=42965&quot; target=&quot;_blank&quot;&gt;RTTS&lt;/a&gt;的使用可以使我们的程序变得十分灵活，但后果是程序的可读性通常不太好，而且对新手来说也绝对是很难修改的。因此，我建议尽量把它作为基础功能的实现，和配置表结合、或者是通过新建子类的方式来实现功能的扩展，并且附以文档，说明程序的扩展方法。尽可能避免让后人直接维护大量使用动态技术的程序。&lt;/p&gt;
&lt;h2&gt;中间层&lt;/h2&gt;
&lt;p&gt;在制作与其它系统对接的接口时，由于各方面的原因，会不时遇到对方希望变更接口的输入输出方式或者格式的情况。这时候，不是直接提供给对方包含业务处理逻辑的接口，而是建立一个外层接口，把原有的接口包装起来，专门用来应对对方的修改，是一个好办法。相似的思路也可以用在其它经常变动的地方。&lt;/p&gt;
&lt;h2&gt;写有意义的注释&lt;/h2&gt;
&lt;p&gt;据说写程序不写注释是一种很糟糕的习惯，也有开发规范约束人们：必须要写注释。注释当然是必要的，但是在实践中，大部分人的注释水平是不太好的，往往对阅读起不到什么正面作用，于是甚至催生了一种反叛的、矫枉过正的观点：好的程序从来不需要注释。&lt;/p&gt;
&lt;p&gt;最近见到的一个典型的不好的注释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;*&lt;/span&gt;&lt;span&gt;处理数据&lt;/span&gt;
&lt;span&gt;PERFORM&lt;/span&gt; frm_process_data.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码至少犯了3个错误。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;以文章来对比，FROM的名字即文章的标题，我们不应该在标题中写明标题是标题。显然，FRM的前缀是无用的，它给不了我们什么信息。&lt;/li&gt;
&lt;li&gt;“处理数据”似乎是对FORM功能的描述，这部分内容应该放在FORM的定义处，而不是调用位置。在调用位置的注释，需要写的是：为什么这个FORM需要在这里被调用？为什么不是调用其它一个看起来相似的FROM？&lt;/li&gt;
&lt;li&gt;在注释中写“处理数据”这种泛泛之辞通常产生不了什么意义，更不用说FORM名已经是process date（处理数据)了。这种重复有害无益。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样的注释过多，大概就是很多人反感注释的原因吧。好的注释需要出现在合理的位置，需要写“为什么”而不是“做了什么”。这还是挺考验写作者对程序的理解的，需要有“同理心”，预见读者的需求才可以。&lt;/p&gt;
&lt;p&gt;善用编辑器为自动生成的注释模板，比如：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201711/994049-20171126101939578-1149357605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是函数、或者类的话，还可以写专门的文档：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201711/994049-20171126101017421-595162012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;善用异常&lt;/h2&gt;
&lt;p&gt;异常是个很有用的东西，但是我很少看到有ABAP开发者用它。我见到的程序大部分是用错误码或者错误标识的方式来处理错误。以我的经验来看，错误码在单层的调用关系中是比较好用的，但是在多层的、复杂的情况下，异常比错误代码要更容易处理和维护。而且异常有着较好的自我描述能力，这在程序的维护中是很有意义的。而很多错误码，只有开发者本人知道是什么意思，后续维护的人在看到错误代码时，只能认识到这里有个错误...并不理解每个错误代码的涵义。&lt;/p&gt;
&lt;h2&gt;避免全局变量&lt;/h2&gt;
&lt;p&gt;全局变量不好，这是所有开发者的共识。之所以专门还要拿出它来作为一个小节，是因为我觉得这个问题实在普遍且严重。可能因为大部分ABAP二次开发程序都是内容较少的报表，最常用的ALV报表类（函数）则要求其输入的数据内表必须是全局变量，初入行的开发者通常是从全局变量写起的，而较简单的程序逻辑也让开发者没有承受全局变量带来的麻烦....这种惯性使得不少开发者在日后开发相对大型的程序时也会大量使用全局变量。而程序的维护者通常没有精力或能力来识别全局变量对程序的影响，从而在修改程序时造成了意料之外的结果。此外，不加释放的全局变量也会带来性能上的负担。所以我认为开发者应该经常思考是否可以用局部变量代替全局变量、用值传递代替引用传递，时时注意避免全局变量带来的麻烦。&lt;/p&gt;

&lt;p&gt;欢迎大家发表自己对可维护性的看法，或者对本文的内容进行指正。&lt;/p&gt;


</description>
<pubDate>Sun, 26 Nov 2017 02:43:00 +0000</pubDate>
<dc:creator>氢氦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhelibeb/p/7891401.html</dc:identifier>
</item>
<item>
<title>关于负载均衡的一切：总结与思考 - xybaby</title>
<link>http://www.cnblogs.com/xybaby/p/7867735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xybaby/p/7867735.html</guid>
<description>
&lt;p&gt;　　古人云，不患寡而患不均。&lt;/p&gt;
&lt;p&gt;　　在计算机的世界，这就是大家耳熟能详的负载均衡（&lt;a href=&quot;https://en.wikipedia.org/wiki/Load_balancing_(computing)&quot; target=&quot;_blank&quot;&gt;load balancing&lt;/a&gt;），所谓负载均衡，就是说如果一组计算机节点（或者一组进程）提供&lt;strong&gt;相同的（同质的）服务&lt;/strong&gt;，那么对服务的请求就应该均匀的分摊到这些节点上。负载均衡的前提一定是“provide a single Internet service from multiple servers”， 这些提供服务的节点被称之为server farm、server pool或者backend servers。&lt;/p&gt;
&lt;p&gt;　　这里的服务是广义的，可以是简单的计算，也可能是数据的读取或者存储。负载均衡也不是新事物，这种思想在多核CPU时代就有了，只不过在分布式系统中，负载均衡更是无处不在，这是分布式系统的天然特性决定的，分布式就是利用大量计算机节点完成单个计算机无法完成的计算、存储服务，既然有大量计算机节点，那么均衡的调度就非常重要。&lt;/p&gt;
&lt;p&gt;　　负载均衡的意义在于，让所有节点以最小的代价、最好的状态对外提供服务，这样系统吞吐量最大，性能更高，对于用户而言请求的时间也更小。而且，负载均衡增强了系统的可靠性，最大化降低了单个节点过载、甚至crash的概率。不难想象，如果一个系统绝大部分请求都落在同一个节点上，那么这些请求响应时间都很慢，而且万一节点降级或者崩溃，那么所有请求又会转移到下一个节点，造成雪崩。&lt;/p&gt;
&lt;p&gt;　　事实上，网上有很多文章介绍负载均衡的算法，大多都是大同小异。本文更多的是自己对这些算法的总结与思考。&lt;/p&gt;
&lt;p&gt;　　本文地址：&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/7867735.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/xybaby/p/7867735.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　本章节的标题和内容都来自&lt;a href=&quot;http://zhuanlan.51cto.com/art/201609/517313.htm&quot; target=&quot;_blank&quot;&gt;一分钟了解负载均衡的一切&lt;/a&gt;这一篇文章。当然，原文的标题是夸张了点，不过文中列出了在一个大型web网站中各层是如何用到负载均衡的，一目了然。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1089769/201711/1089769-20171120192059805-1325245000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　常见互联网分布式架构如上，分为客户端层、反向代理nginx层、站点层、服务层、数据层。可以看到，每一个下游都有多个上游调用，只需要做到，&lt;strong&gt;每一个上游都均匀访问每一个下游&lt;/strong&gt;，就能实现“将请求/数据【均匀】分摊到多个操作单元上执行”。&lt;/p&gt;
&lt;p&gt;　　(1)【客户端层】到【反向代理层】的负载均衡，是通过“DNS轮询”实现的&lt;br/&gt;　　(2)【反向代理层】到【站点层】的负载均衡，是通过“nginx”实现的&lt;br/&gt;　　(3)【站点层】到【服务层】的负载均衡，是通过“服务连接池”实现的&lt;br/&gt;　　(4)【数据层】的负载均衡，要考虑“数据的均衡”与“请求的均衡”两个点，常见的方式有“按照范围水平切分”与“hash水平切分”。&lt;/p&gt;
&lt;p&gt;　　数据层的负载均衡，在我之前的《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/7076731.html&quot; target=&quot;_blank&quot;&gt;带着问题学习分布式系统之数据分片&lt;/a&gt;》中有详细介绍。&lt;/p&gt;

&lt;p&gt;　　在我看来，当我们提到一个负载均衡算法，或者具体的应用场景时，应该考虑以下问题&lt;/p&gt;
&lt;p&gt;　　第一，是否意识到不同节点的服务能力是不一样的，比如CPU、内存、网络、地理位置&lt;/p&gt;
&lt;p&gt;　　第二，是否意识到节点的服务能力是动态变化的，高配的机器也有可能由于一些突发原因导致处理速度变得很慢&lt;/p&gt;
&lt;p&gt;　　第三，是否考虑将同一个客户端，或者说同样的请求分发到同一个处理节点，这对于“有状态”的服务非常重要，比如session，比如分布式存储&lt;/p&gt;
&lt;p&gt;　　第四，谁来负责负载均衡，即谁充当负载均衡器（load balancer），balancer本身是否会成为瓶颈&lt;/p&gt;
&lt;p&gt;　　下面会结合具体的算法来考虑这些问题&lt;/p&gt;

&lt;h2&gt;轮询算法（round-robin）&lt;/h2&gt;
&lt;p&gt;　　思想很简单，就是提供同质服务的节点逐个对外提供服务，这样能做到绝对的均衡。Python示例代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; SERVER_LIST =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.246.10.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.246.10.2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.246.10.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; round_robin(server_lst, cur =&lt;span&gt; [0]):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     length =&lt;span&gt; len(server_lst)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ret = server_lst[cur[0] %&lt;span&gt; length]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     cur[0] = (cur[0] + 1) %&lt;span&gt; length
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; ret
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，所有的节点都是以同样的概率提供服务，即没有考虑到节点的差异，也许同样数目的请求，高配的机器CPU才20%，低配的机器CPU已经80%了&lt;/p&gt;
&lt;h2&gt;加权轮询算法（weight round-robin）&lt;/h2&gt;
&lt;p&gt;　　加权轮训算法就是在轮训算法的基础上，考虑到机器的差异性，分配给机器不同的权重，能者多劳。注意，这个权重的分配依赖于请求的类型，比如计算密集型，那就考虑CPU、内存；如果是IO密集型，那就考虑磁盘性能。Python示例代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; WEIGHT_SERVER_LIST =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.246.10.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.246.10.2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.246.10.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; weight_round_robin(servers, cur =&lt;span&gt; [0]):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     weighted_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; servers.iteritems():
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         weighted_list.extend([k] *&lt;span&gt; v)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     length =&lt;span&gt; len(weighted_list)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     ret = weighted_list[cur[0] %&lt;span&gt; length]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     cur[0] = (cur[0] + 1) %&lt;span&gt; length
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; ret
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;随机算法（random）&lt;/h2&gt;
&lt;p&gt;　　这个就更好理解了，随机选择一个节点服务，按照概率，只要请求数量足够多，那么也能达到绝对均衡的效果。而且实现简单很多&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; random_choose(server_lst):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    random.seed()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; random.choice(server_lst)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;加权随机算法（random）&lt;/h2&gt;
&lt;p&gt;　　如同加权轮训算法至于轮训算法一样，也是在随机的时候引入不同节点的权重，实现也很类似。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; weight_random_choose(servers):
    &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
    random.seed()
    weighted_list &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; servers.iteritems():
        weighted_list.extend([k] &lt;/span&gt;*&lt;span&gt; v)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; random.choice(weighted_list)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　当然，如果节点列表以及权重变化不大，那么也可以对所有节点归一化，然后按概率区间选择&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; normalize_servers(servers):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     normalized_servers =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     total =&lt;span&gt; sum(servers.values())
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     cur_sum =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; servers.iteritems():
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         normalized_servers[k] = 1.0 * (cur_sum + v) /&lt;span&gt; total
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         cur_sum +=&lt;span&gt; v
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; normalized_servers
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; weight_random_choose_ex(normalized_servers):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random, operator
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    random.seed()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     rand =&lt;span&gt; random.random()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt; sorted(normalized_servers.iteritems(), key = operator.itemgetter(1&lt;span&gt;)):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; v &amp;gt;=&lt;span&gt; rand:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; k
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; False, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Error normalized_servers with rand %s &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % rand 
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;哈希法（hash）&lt;/h2&gt;
&lt;p&gt;　　根据客户端的IP，或者请求的“Key”，计算出一个hash值，然后对节点数目取模。好处就是，同一个请求能够分配到同样的服务节点，这对于“有状态”的服务很有必要&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; hash_choose(request_info, server_lst):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     hashed_request_info =&lt;span&gt; hash(request_info)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; server_lst[hashed_request_info % len(server_lst)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　只要hash结果足够分散，也是能做到绝对均衡的。&lt;/p&gt;
&lt;h2&gt;一致性哈希&lt;/h2&gt;
&lt;p&gt;　　哈希算法的缺陷也很明显，当节点的数目发生变化的时候，请求会大概率分配到其他的节点，引发到一系列问题，比如sticky session。而且在某些情况，比如分布式存储，是绝对的不允许的。&lt;/p&gt;
&lt;p&gt;　　为了解决这个哈希算法的问题，又引入了&lt;a href=&quot;https://en.wikipedia.org/wiki/Consistent_hashing&quot; target=&quot;_blank&quot;&gt;一致性哈希&lt;/a&gt;算法，简单来说，一个物理节点与多个虚拟节点映射，在hash的时候，使用虚拟节点数目而不是物理节点数目。当物理节点变化的时候，虚拟节点的数目无需变化，只涉及到虚拟节点的重新分配。而且，调整每个物理节点对应的虚拟节点数目，也就相当于每个物理节点有不同的权重&lt;/p&gt;
&lt;h2&gt;最少连接算法（least connection）&lt;/h2&gt;
&lt;p&gt;　　以上的诸多算法，要么没有考虑到节点间的差异（轮训、随机、哈希），要么节点间的权重是静态分配的（加权轮训、加权随机、一致性hash）。&lt;/p&gt;
&lt;p&gt;　　考虑这么一种情况，某台机器出现故障，无法及时处理请求，但新的请求还是会以一定的概率源源不断的分配到这个节点，造成请求的积压。因此，根据节点的真实负载，动态地调整节点的权重就非常重要。当然，要获得接节点的真实负载也不是一概而论的事情，如何定义负载，负载的收集是否及时，这都是需要考虑的问题。&lt;/p&gt;
&lt;p&gt;　　每个节点当前的连接数目是一个非常容易收集的指标，因此lease connection是最常被人提到的算法。也有一些侧重不同或者更复杂、更客观的指标，比如最小响应时间（least response time）、最小活跃数（least active）等等。&lt;/p&gt;

&lt;h2&gt;有状态的请求　　&lt;/h2&gt;
&lt;p&gt;　　首先来看看“算法衡量”中提到的第三个问题：同一个请求是否分发到同样的服务节点，同一个请求指的是同一个用户或者同样的唯一标示。什么时候同一请求最好（必须）分发到同样的服务节点呢？那就是有状态 -- 请求依赖某些存在于内存或者磁盘的数据，比如web请求的session，比如分布式存储。怎么实现呢，有以下几种办法：&lt;/p&gt;
&lt;p&gt;　　（1）请求分发的时候，保证同一个请求分发到同样的服务节点。&lt;/p&gt;
&lt;p&gt;　　这个依赖于负载均衡算法，比如简单的轮训，随机肯定是不行的，哈希法在节点增删的时候也会失效。可行的是一致性hash，以及分布式存储中的按范围分段（即记录哪些请求由哪个服务节点提供服务），代价是需要在load balancer中维护额外的数据。&lt;/p&gt;
&lt;p&gt;　　（2）状态数据在backend servers之间共享&lt;/p&gt;
&lt;p&gt;　　保证同一个请求分发到同样的服务节点，这个只是手段，目的是请求能使用到对应的状态数据。如果状态数据能够在服务节点之间共享，那么也能达到这个目的。比如服务节点连接到共享数据库，或者内存数据库如memcached&lt;/p&gt;
&lt;p&gt;　　（3）状态数据维护在客户端&lt;/p&gt;
&lt;p&gt;　　这个在web请求中也有使用，即cookie，不过要考虑安全性，需要加密。&lt;/p&gt;

&lt;h2&gt; 关于load balancer&lt;/h2&gt;
&lt;p&gt;　　接下来回答第四个问题：关于load balancer，其实就是说，在哪里做负载均衡，是客户端还是服务端，是请求的发起者还是请求的3。具体而言，要么是在客户端，根据服务节点的信息自行选择，然后将请求直接发送到选中的服务节点；要么是在服务节点集群之前放一个集中式代理（proxy），由代理负责请求求分发。不管哪一种，至少都需要知道当前的服务节点列表这一基础信息。&lt;/p&gt;
&lt;p&gt;　　如果在客户端实现负载均衡，客户端首先得知道服务器列表，要么是静态配置，要么有简单接口查询，但backend server的详细负载信息，就不适用通过客户端来查询。因此，客户端的负载均衡算法要么是比较简单的，比如轮训（加权轮训）、随机（加权随机）、哈希这几种算法，只要每个客户端足够随机，按照大数定理，服务节点的负载也是均衡的。要在客户端使用较为复杂的算法，比如根据backend的实际负载，那么就需要去额外的负载均衡服务（external load balancing service）查询到这些信息，在&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/load-balancing.md&quot; target=&quot;_blank&quot;&gt;grpc&lt;/a&gt;中，就是使用的这种办法&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1089769/201711/1089769-20171122184312133-330736567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，load balancer与grpc server通信，获得grpc server的负载等具体详细，然后grpc client从load balancer获取这些信息，最终grpc client直连到被选择的grpc server。&lt;/p&gt;
&lt;p&gt;　　而基于Proxy的方式是更为常见的，比如7层的Nginx，四层的F5、LVS，既有硬件路由，也有软件分发。集中式的特点在于方便控制，而且能容易实现一些更精密，更复杂的算法。但缺点也很明显，一来负载均衡器本身可能成为性能瓶颈；二来可能引入额外的延迟，请求一定先发到达负载均衡器，然后到达真正的服务节点。&lt;/p&gt;
&lt;p&gt;　　load balance proxy对于请求的响应（response），要么不经过proxy，如LVS；要么经过Proxy，如Nginx。下图是LVS示意图（来源见水印）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1089769/201711/1089769-20171122184710383-757965923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而如果response也是走load balancer proxy的话，那么整个服务过程对客户端而言就是完全透明的，也防止了客户端去尝试连接后台服务器，提供了一层安全保障！&lt;/p&gt;
&lt;p&gt;　　值得注意的是，&lt;strong&gt;load balancer proxy不能成为单点故障&lt;/strong&gt;（single point of failure），因此一般会设计为高可用的主从结构&lt;/p&gt;
&lt;h2&gt; 其他&lt;/h2&gt;
&lt;p&gt;　　在&lt;a href=&quot;http://www.cnblogs.com/data2value/p/6107653.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;中提到，负载均衡是一种推模型，一定会选出一个服务节点，然后把请求推送过来。而换一种思路，使用消息队列，就变成了拉模型：空闲的服务节点主动去拉取请求进行处理，各个节点的负载自然也是均衡的。消息队列相比负载均衡好处在于，服务节点不会被大量请求冲垮，同时增加服务节点更加容易；缺点也很明显，请求不是事实处理的。&lt;/p&gt;

&lt;p&gt;　　想到另外一个例子，比如在gunicorn这种pre-fork模型中，master（gunicorn 中Arbiter）会fork出指定数量的worker进程，worker进程在同样的端口上监听，谁先监听到网络连接请求，谁就提供服务，这也是worker进程之间的负载均衡。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Load_balancing_(computing)&quot; target=&quot;_blank&quot;&gt;wiki：Load balancing&lt;/a&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zhuanlan.51cto.com/art/201609/517313.htm&quot; target=&quot;_blank&quot;&gt;一分钟了解负载均衡的一切&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/load-balancing.md&quot; target=&quot;_blank&quot;&gt;grpc load-balancing.md&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Nov 2017 01:56:00 +0000</pubDate>
<dc:creator>xybaby</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xybaby/p/7867735.html</dc:identifier>
</item>
<item>
<title>病毒分析第二讲,分析病毒的主要功能 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7898188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7898188.html</guid>
<description>&lt;p&gt;---恢复内容开始---&lt;/p&gt;

&lt;p&gt;经过昨天病毒分析第一讲,得出一个被注入的DLL&lt;/p&gt;
&lt;p&gt;开始分析DLL主要功能&lt;/p&gt;
&lt;p&gt;PS: IDA中,DLL会有各种初始化的代码,和释放资源,所以不再看,只看重要的API&lt;/p&gt;
&lt;h2&gt;一丶行为分析(创建命名互斥体,防止病毒多开)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126020048859-969856804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入函数去看,从DLLmain入口点分析.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126020134171-2032316317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得出,第一步,病毒为了防止重复注入IE,创建命名互斥体.&lt;/p&gt;
&lt;p&gt;名字是:  &quot;KyUffThOkYwRRtgPP&quot;&lt;/p&gt;

&lt;h3&gt; 二丶拼接字符串,创建文件,写入系统当前时间&lt;/h3&gt;
&lt;p&gt;进入DLLmain第二个函数查看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126022138703-892492851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS:分析到哪里都已经改名字了,原名字不是Init,这个是根据分析里面的函数调用的出来的.&lt;/p&gt;
&lt;p&gt;点击进入,查看具体怎么做了&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126022448203-1633954423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 根据分析,可以分为四部分去看&lt;/p&gt;
&lt;p&gt;1.初始化各种数据&lt;/p&gt;
&lt;p&gt;2.经过一些列自己写的算法运算&lt;/p&gt;
&lt;p&gt;3.获取磁盘和驱动器的信息,并且处理文件&lt;/p&gt;
&lt;p&gt;4.写入系统时间(需要跟随大里面去看)&lt;/p&gt;
&lt;p&gt;虚拟机动态调试查看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126025017000-1286719423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一次,通过动态分析,得出会拼接一个字符串,为&lt;/p&gt;
&lt;p&gt;当前的: C:Documents and settings\Administrator\桌面\xxxx\dmiconf.data&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126025913000-62446975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 第二此分析,得出,在目录下面创建这个文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126030037031-1654538855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126030127796-1555788329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写入的内容是时间&lt;/p&gt;
&lt;p&gt;得出第二次行为:&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;创建文件dmlconf.dat在当前目录,并且写入文件内容为当前时间&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;15&quot;&gt;&lt;span&gt;三丶分析行为三,写入注册表,实现开机自启动&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;继续分析DLLmain下面的API&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126030424453-538551918.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击API进去查看.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126030613796-1913015776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面还有一层,进去查看.没有命名的函数都是无关紧要的,这些都是实现命名过了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126030756625-1413033055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进去一层则看到&lt;/p&gt;
&lt;p&gt;1.打开注册表&lt;/p&gt;
&lt;p&gt;2.遍历注册表的值&lt;/p&gt;
&lt;p&gt;3.修改注册表的值&lt;/p&gt;
&lt;p&gt;4.关闭注册表&lt;/p&gt;
&lt;p&gt;此时我们需要动态查看是进入是修改的那个注册表了.&lt;/p&gt;
&lt;h3&gt;1.找到线程回调&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126035741578-89190773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.线程回调进入下段点,并设置为新的EIP&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126035948109-390043155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置的快捷键是 Ctrl + * 键&lt;/p&gt;
&lt;h3&gt;3.进入Call查看 &lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126040156546-656773483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 4.查看注册表操作&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126040338015-1983090948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得出了要操作注册表&lt;/p&gt;
&lt;p&gt;HEEY_LOCAL_MACHINE Software\Microsoft\Windows NT\CurrentVersion\Winlogon&lt;/p&gt;
&lt;p&gt;这个正好是开机启动项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126040548218-1780985927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过上面和下面的分析,得出先获取注册表的值,然后申请内存&lt;/p&gt;
&lt;p&gt;写入我们的内容&lt;/p&gt;
&lt;p&gt;时间关系,不一步一不的跟了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126042003968-1717304317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实跟进去看的话她会设置自己的子体到里面,这样就会开机自启动了.&lt;/p&gt;
&lt;h2&gt;四丶网络相关&lt;/h2&gt;
&lt;p&gt; 此病毒还涉及到网络相关,但是现在这个病毒现在也链接不了服务器了.所以网络相关的掠过&lt;/p&gt;
&lt;p&gt;如果想明白原理,建议自己跟一下看下也可以.&lt;/p&gt;
&lt;h2&gt;五丶修改PE文件,修改Html&lt;/h2&gt;
&lt;p&gt;此功能昨天已经快速定位到了.&lt;/p&gt;
&lt;p&gt;鉴于时间关系不一步一步的分析了.此次样本分析完毕.&lt;/p&gt;

&lt;p&gt;得出行为:&lt;/p&gt;
&lt;p&gt;　　1.使用命名互斥体,防止多开&lt;/p&gt;
&lt;p&gt;　　2.创建文件在dmlconf.dat在C盘目录下,并写入时间&lt;/p&gt;
&lt;p&gt;　　3.写入注册表开机自动启动&lt;/p&gt;
&lt;p&gt;　　4.链接服务器,发送和接受数据&lt;/p&gt;
&lt;p&gt;　　5.修改PE,以及html&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 20:46:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7898188.html</dc:identifier>
</item>
<item>
<title>[OIDC in Action] 1. 基于OIDC（OpenID Connect）的SSO - Blackheart</title>
<link>http://www.cnblogs.com/linianhui/p/oidc-in-action-sso.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linianhui/p/oidc-in-action-sso.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/linianhui/category/929878.html&quot; target=&quot;_blank&quot;&gt;[认证授权]&lt;/a&gt;系列博客中，分别对OAuth2和OIDC在理论概念方面进行了解释说明，其间虽然我有写过一个完整的示例（&lt;a href=&quot;https://github.com/linianhui/oidc.example&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/oidc.example&lt;/a&gt;），但是却没有在实践方面做出过解释。在这里新开一个系列博客，来解释其各种不同的应用场景。因为OIDC是在OAuth2之上的协议，所以这其中也会包含OAuth2的一些内容。&lt;/p&gt;
&lt;p&gt;OIDC协议本身有很多的开源实现，这里选取的是基于.Net的开源实现基于&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4&quot; target=&quot;_blank&quot;&gt;IdentityServer4&lt;/a&gt;。本系列的源代码位于&lt;a href=&quot;https://github.com/linianhui/oidc.example&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/oidc.example&lt;/a&gt;。clone下来后用管理员身份运行build.ps1来部署整个系统，其中可能会弹出UAC警告（脚本会修改host文件，记得允许管理员读写这个文件先）。部署完后的样子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125200012234-991774929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125200054484-4142294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文中主要是关注一下SSO这部分的内容，主要是&lt;strong&gt;跨一级域&lt;/strong&gt;的&lt;strong&gt;单点登录&lt;/strong&gt;和&lt;strong&gt;统一登出&lt;/strong&gt;功能。其中涉及到的站点有一下4个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;oidc-server.dev：利用oidc实现的统一认证和授权中心，SSO站点。&lt;/li&gt;
&lt;li&gt;oidc-client-hybrid.dev：oidc的一个客户端，采用hybrid模式。&lt;/li&gt;
&lt;li&gt;oidc-client-implicit.dev：odic的另一个客户端，采用implicit模式。&lt;/li&gt;
&lt;li&gt;oidc-client-js.dev：oidc的又一个客户端，采用implicit模式，纯静态网站，只有js和html，无服务端代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常来讲，SSO包括&lt;strong&gt;统一的登录&lt;/strong&gt;和&lt;strong&gt;统一的登出&lt;/strong&gt;这两部分。基于OIDC实现的SSO主要是利用OIDC服务作为用户认证中心作为统一入口，使得所有的需要登录的地方都交给OIDC服务来做。更直白点说就是把需要进行用户认证的客户端中的用户认证这部分都剥离出来交给OIDC认证中心来做。具体的交互流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125203425109-653379399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中这三个客户端是完全独立的位于不同的域名之下，且没有任何依赖关系，三者均依赖oidc-server.dev这个站点进行认证和授权，通信协议为HTTP，那么下面则通过它们之间的HTTP消息来解释其具体的流程。这个过程中使用fiddler来进行监视其所有的请求。&lt;/p&gt;
&lt;h2&gt;第1步：OIDC-Client- 触发认证请求&lt;/h2&gt;
&lt;p&gt;在浏览器打开&lt;strong&gt;oidc-client-implicit.dev&lt;/strong&gt;这个站点，打开后如下（QQ这个先不管它，后面单独介绍）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125204918421-637260866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Oidc Login后，会触发一个302的重定向操作。具体的HTTP请求和响应信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125205416140-54770807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Request：Get后面的URL是我们点击Oidc Login的Url，这个URL包含一个参数，代表登录成功后所要回到的页面是哪里。&lt;/p&gt;
&lt;p&gt;Response：服务器返回了一个302重定向。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Location的Url指向了oidc-server.dev这个站点，其中还携带了一大堆参数（参数后面一小节介绍）；&lt;/li&gt;
&lt;li&gt;Set-Cookie设置了一个nonce的cookie，主要目的用于安全方面。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;第2步：OIDC-Client - 认证请求&lt;/h2&gt;
&lt;p&gt;紧接上一步，浏览器在接收到第1步的302响应后，会对Location所指定的URL发起一个Get请求。这个请求携带的参数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125210334625-999970810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中参数的含义在&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto_id_7&quot; target=&quot;_blank&quot;&gt;OIDC的认证请求&lt;/a&gt;有详细的解释（注：其中采用的认证类型不管是authorization code，或者implict，还是hybrid都无关紧要，它们的区别只是其适用场景的差异，并不影响整个流程）。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;client_id=implicit-client：发起认证请求的客户端的唯一标识，这个客户端事先已经在oidc-server.dev这个站点注册过了。&lt;/li&gt;
&lt;li&gt;reponse_mode=form_post：指示oidc服务器应该使用form表单的形式返回数据给客户端。&lt;/li&gt;
&lt;li&gt;response_type=id_token：区别于oauth2授权请求的一点，必须包含有id_token这一项。&lt;/li&gt;
&lt;li&gt;scope=openid profile：区别于oauth2授权请求的一点，必须包含有openid这一项。&lt;/li&gt;
&lt;li&gt;state：oauth2定义的一个状态字符串，这里的实现是加密保存了一些客户端的状态信息（用于记录客户端的一些状态，在登录成功后会有用处），oidc会在认证完成后原样返回这个参数。&lt;/li&gt;
&lt;li&gt;nonce：上一步中写入cookie的值，这字符串将来会包含在idtoken中原样返回给客户端。&lt;/li&gt;
&lt;li&gt;redirect_uri：认证成功后的回调地址，oidc-server.dev会把认证的信息发送给这个地址。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;第3步：OIDC-Server - 验证请求信息&lt;/h2&gt;
&lt;p&gt;oidc-server.dev站点会验证第2步中传递过来的信息，比如client_id是否有效，redircet_uri是否合法，其他的参数是否合法之类的验证。如果验证通过，则会进行下一步操作。&lt;/p&gt;
&lt;h2&gt;第4步：OIDC-Server - 打开登录页面&lt;/h2&gt;
&lt;p&gt;在oidc-server.dev站点验证完成后，&lt;strong&gt;如果没有从来没有客户端通过oidc-server.dev登陆过，那么第2步的请求会返回一个302重定向重定向到登录页面&lt;/strong&gt;。&lt;strong&gt;如果是已经登录，则会直接返回第5步中生产重定向地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125212816781-808682152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器会打开响应消息中Location指定的地址（登录页面）。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125214220078-1722927925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第5步：OIDC-Server - 完成用户登录，同时记录登录状态&lt;/h2&gt;
&lt;p&gt;在第四步输入账户密码点击提交后，会POST如下信息到服务器端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125214231171-1367563199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务器验证用户的账号密码，通过后会使用Set-cookie维持自身的登录状态。然后使用302重定向到下一个页面。&lt;/p&gt;
&lt;h2&gt;第6步：浏览器 - 打开上一步重定向的地址，同时自动发起一个post请求&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125214244468-1820768675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;form的地址是在第2步中设置的回调地址，form表单中包含（根据具体的认证方式authorization code，implict或者hybrid，其包含的信息会有一些差异，这个例子中是采用的implicit方式）如下信息：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;id_token：&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto_id_5&quot; target=&quot;_blank&quot;&gt;id_token&lt;/a&gt;即为认证的信息，OIDC的核心部分，采用&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/oauth2-extensions-protocol-and-json-web-token.html#auto_id_5&quot; target=&quot;_blank&quot;&gt;JWT格式&lt;/a&gt;包装的一个字符串。&lt;/li&gt;
&lt;li&gt;scope：用户允许访问的scope信息。&lt;/li&gt;
&lt;li&gt;state：第1步中发送的state，原样返回。&lt;/li&gt;
&lt;li&gt;session_state：会话状态。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto_id_5&quot; target=&quot;_blank&quot;&gt;id_token&lt;/a&gt;包含的具体的信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125220745625-1675189586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中包含认证的服务器信息iss，客户端的信息aud，时效信息nbf和exp，用户信息sub和nickname，会话信息sid，以及第1步中设置的nonce。还有其签名的信息alg=RS256，表示idtoken最后的一段信息（上图中浅蓝色的部分）是oidc-server.dev使用RSA256对id_token的header和payload部分所生产的数字签名。客户端需要使用oidc-server.dev提供的公钥来验证这个数字签名&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;第7步：OIDC-Client - 接收第6步POST过来的参数，构建自身的登录状态&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125222039390-1426574351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端验证id_token的有效性，其中验证所需的公钥来自&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-extension.html#auto_id_0&quot; target=&quot;_blank&quot;&gt;OIDC的发现服务&lt;/a&gt;中的jwk_uri，这个验证是必须的，目的时为了保证客户端得到的id_token是oidc-sercer.dev颁发的，并且没有被篡改过，以及id_token的有效时间验证。&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/security-based-toolbox.html#auto_id_16&quot; target=&quot;_blank&quot;&gt;数字签名&lt;/a&gt;的JWT可以保证id_token的不可否认性，认证和完整性，但是并不能保证其机密性，所以id_token中千万不要包含有机密性要求的敏感的数据。如果确实需要包含，则需要对其进行加密处理（比如JWE规范）。其中验证也包含对nonce（包含在id_token中）的验证（第1步设置的名为nonce的cookie）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在验证完成后，客户端就可以取出来其中包含的用户信息来构建自身的登录状态，比如上如中Set-Cookie=lnh.oidc这个cookie。然后清除第1步中设置的名为nonce的cookie。&lt;/p&gt;
&lt;p&gt;最后跳转到客户端指定的地址（这个地址信息被保存在第1步中传递给oidc-server.dev的state参数中，被oidc-server.dev原样返回了这个信息）。然后读取用户信息如下（这里读取的是id_token中的完整信息）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125222146859-1871035934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;其他的客户端登录&lt;/h2&gt;
&lt;p&gt;登录流程是和上面的步骤是一样的，一样会发起认证请求，区别在于已经登录的时候会在第4步直接返回post信息给客户端的地址，而不是打开一个登录页面，这里就不再详细介绍了。大家可以在本地运行一下，通过fiddler观察一下它们的请求流程。贴一下oidc-client-hybrid.dev这个客户端登录后的页面吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125231909609-2081337290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;退出的流程相比登录简单一些。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125233327093-1665849488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中核心部分在于利用浏览器作为中间的媒介，来逐一的通知已经登录的客户端退出登录。&lt;/p&gt;
&lt;h2&gt;第1步：OIDC-Client - 触发登出请求&lt;/h2&gt;
&lt;p&gt;点击Logout链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125231909609-2081337290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击退出后会触发一个GET请求，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125233853281-1409909241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图这个请求会返回一个302的响应，Location的地址指向oidc-server.dev的一个endsession的接口。同时会通过Set-Cookie来清除自身的cookie。&lt;/p&gt;
&lt;h2&gt;第2步：OIDC-Client - 登出请求&lt;/h2&gt;
&lt;p&gt;浏览器通过GET访问上一步中指定的Location地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125234624656-182330914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口地址定义在&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-extension.html#auto_id_0&quot; target=&quot;_blank&quot;&gt;OIDC的发现服务&lt;/a&gt;中的end_session_endpoint字段中，参数信息定义在&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-extension.html#auto_id_3&quot; target=&quot;_blank&quot;&gt;OIDC的Front-Channel-Logout规范&lt;/a&gt;中。&lt;/p&gt;
&lt;h2&gt;第3步：OIDC-Server - 验证登出请求&lt;/h2&gt;
&lt;p&gt;验证上图中传递的信息，如果信息无误则再一次重定向到一个地址（这里是IdentityServer4的实现机制，其实可以无需这个再次重定向的）。&lt;/p&gt;
&lt;h2&gt;第4步：OIDC-Server - 登出自身，返回包含IFrame的HTML&lt;/h2&gt;
&lt;p&gt;浏览器打开第3步中重定向的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125235243593-20753457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;响应中会通过Set-Cookie（idsrv和idsrv.session）清除oidc-server.dev自身的登录状态。然后包含一个HTML表单页面，上图中iframe指向的地址是IdentityServer4内部维持的一个地址。访问这个地址后的信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iframe &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='http://oidc-client-implicit.dev/oidc/front-channel-logout-callback?sid=b51ea235574807beb0deff7c6db6a381&amp;amp;iss=http%3A%2F%2Foidc-server.dev'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iframe &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='http://oidc-client-hybrid.dev/oidc/front-channel-logout-callback?sid=b51ea235574807beb0deff7c6db6a381&amp;amp;iss=http%3A%2F%2Foidc-server.dev'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中的iframe是真正的调用已经登录的客户端进行登出的地址（IdentityServer4会记录下来已经登录的客户端，没有登陆过的和没有配置启用Front-Channel-Logout的则不会出现在这里）。其中iframe指向的地址是OIDC客户端在oidc-server.dev中注册的时候配置的地址。参数则是动态附加上去的参数。&lt;/p&gt;
&lt;p&gt;最后页面中包含一个js脚本文件，在页面load完成后，跳转到第2步中指定的post_logout_redirect_uri指向的回调页面。&lt;/p&gt;
&lt;h2&gt;第5步：OIDC-Client - 处理登出回调通知&lt;/h2&gt;
&lt;p&gt;在浏览器访问上面代码中iframe指向的地址的时候，被动登出的OIDC客户端会接收到登出通知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171126000841453-1217915494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;响应中通过Set-Cookie（lnh.oidc）清除了需要被动登出的客户端的Cookie。至此，统一的登出完成。&lt;/p&gt;

&lt;p&gt;本文介绍了基于OIDC实现的SSO的工作原理和流程，但并未涉及到OIDC的具体实现IdentityServer4的是如何使用的（这部分通过读我提供的源码应该是很容易理解的），旨在解释一下如何用OIDC实现SSO，而非如何使用OIDC的某一个实现框架。OIDC是一个协议族，这些具体每一步怎么做都是有标准的规范的，所以侧重在了用HTTP来描述这个过程，这样这个流程也就可以用在java,php,nodejs等等开发平台上。&lt;/p&gt;

&lt;p&gt;本文源代码：&lt;a href=&quot;https://github.com/linianhui/oidc.example&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/oidc.example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;认证授权：&lt;a href=&quot;http://www.cnblogs.com/linianhui/category/929878.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/linianhui/category/929878.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Id Token：&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto_id_5&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto_id_5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JWT：&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/oauth2-extensions-protocol-and-json-web-token.html#auto_id_5&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/linianhui/p/oauth2-extensions-protocol-and-json-web-token.html#auto_id_5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数字签名：&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/security-based-toolbox.html#auto_id_16&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/linianhui/p/security-based-toolbox.html#auto_id_16&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OIDC：&lt;a href=&quot;http://openid.net/connect/&quot; target=&quot;_blank&quot;&gt;http://openid.net/connect/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IdentityServer4：&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4&quot; target=&quot;_blank&quot;&gt;https://github.com/IdentityServer/IdentityServer4&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 17:09:00 +0000</pubDate>
<dc:creator>Blackheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linianhui/p/oidc-in-action-sso.html</dc:identifier>
</item>
<item>
<title>源码剖析Django REST framework的认证方式及自定义认证 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/7897192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/7897192.html</guid>
<description>[unable to retrieve full-text content]源码剖析Django REST framework的认证方式 在前面说过,请求到达REST framework的时候,会对request进行二次封装,在封装的过程中会对客户端发送过来的request封装进认证,选择,解析等功能 request方法封装完成之后,执行initial方法时,又会再次对客户</description>
<pubDate>Sat, 25 Nov 2017 16:02:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/7897192.html</dc:identifier>
</item>
<item>
<title>Redis 快速入门 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/7897131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/7897131.html</guid>
<description>&lt;p&gt;谈到Redis，大家应该都不陌生。它是用c语言开发的一个高性能键值数据库，主要用于缓存领域。本章通过Redis的安装，Redis的五大数据类型，Redis的Java客户端，Redis与Spring 的整合 。来让读者对它有一个初步的了解。下一章再通过介绍配置文件来搭建Redis的主从模式和集群模式（配置大于编程，先从简单的编程入手）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果图&lt;/strong&gt;：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/806956/201711/806956-20171125214014703-1073380070.png&quot; alt=&quot;Redis 缓存项目效果图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：对商品类目进行Redis缓存处理&lt;br/&gt;&lt;strong&gt;技术&lt;/strong&gt;：Redis，Spring，SpringMVC，Mybatis，EasyUI&lt;br/&gt;&lt;strong&gt;说明&lt;/strong&gt;：EasyUI的树菜单上一章节有介绍，这里是为了方便展示效果。项目结构图中箭头所指的文件是需要重点学习的。若对EasyUI 树菜单感兴趣的可以访问：（该章节源码中提供商品类名的sql文件）&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/qq_19558705/article/details/78583888&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq_19558705/article/details/78583888&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;源码&lt;/strong&gt;：见文章底部&lt;br/&gt;&lt;strong&gt;项目结构&lt;/strong&gt;：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/806956/201711/806956-20171125215651906-382867536.png&quot; alt=&quot;项目结构图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis-安装&quot;&gt;Redis 安装&lt;/h2&gt;
&lt;p&gt;安装文档:&lt;br/&gt;&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/blob/master/Redis/Redis%E5%AE%89%E8%A3%85.md&quot;&gt;https://github.com/ITDragonBlog/daydayup/blob/master/Redis/Redis%E5%AE%89%E8%A3%85.md&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis-五大数据类型&quot;&gt;Redis 五大数据类型&lt;/h2&gt;
&lt;p&gt;Redis 五大数据类型有String 类型，Hash 类型，List 类型，Set 类型，Zset（Sortedset）类型。其中常用的是前三个。&lt;br/&gt;官方提供的操作手册：&lt;a href=&quot;http://redisdoc.com/&quot; class=&quot;uri&quot;&gt;http://redisdoc.com/&lt;/a&gt;&lt;br/&gt;在redis 自带的客户端中输入命令时，可以使用tab自动补齐，新手建议不要偷懒。&lt;/p&gt;
&lt;h3 id=&quot;string-类型&quot;&gt;String 类型&lt;/h3&gt;
&lt;p&gt;String 是 redis 最基本的类型，一个key对应一个value。&lt;br/&gt;赋值：set key value&lt;br/&gt;取值：get key&lt;br/&gt;批量赋值：mset key value ... keyN valueN&lt;br/&gt;批量取值：mget key ... keyN&lt;br/&gt;取值并赋值：getset key value&lt;br/&gt;删除key：del key ... keyN&lt;br/&gt;数值加一：incr key&lt;br/&gt;数值加N：incrby key n&lt;br/&gt;数值减一：decr key&lt;br/&gt;数值减N：decrby key n&lt;br/&gt;字符串追加：append key value&lt;br/&gt;字符串长度：strlen key&lt;br/&gt;注 形如&quot;key ... keyN&quot; 表示可以批量操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set key value
OK
127.0.0.1:6379&amp;gt; get key
&quot;value&quot;
127.0.0.1:6379&amp;gt; mset key1 1 key2 2 key3 3
OK
127.0.0.1:6379&amp;gt; mget key1 key3
1) &quot;1&quot;
2) &quot;3&quot;
127.0.0.1:6379&amp;gt; del key
(integer) 1
127.0.0.1:6379&amp;gt; incr count
(integer) 1
127.0.0.1:6379&amp;gt; incrby count 10
(integer) 11
127.0.0.1:6379&amp;gt; decr count
(integer) 10
127.0.0.1:6379&amp;gt; decrby count 5
(integer) 5
127.0.0.1:6379&amp;gt; set str itdragon
OK
127.0.0.1:6379&amp;gt; append str &quot; blog!&quot;
(integer) 14
127.0.0.1:6379&amp;gt; get str
&quot;itdragon blog!&quot;
127.0.0.1:6379&amp;gt; strlen str
(integer) 14&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hash-散列类型&quot;&gt;Hash 散列类型&lt;/h3&gt;
&lt;p&gt;Redis hash 是一个键值对集合，和Java 的HashMap 类似。&lt;br/&gt;Redis hash 是一个String 类型的 field 和 value 的映射表，hash特别适合用于存储对象（key 可以是对象+id，field 是对象属性，value则是属性值）。&lt;br/&gt;给一个字段赋值：hset key field value&lt;br/&gt;给多个字段赋值：hmset key field value ... fieldN valueN&lt;br/&gt;取一个字段的值：hget key field&lt;br/&gt;取多个字段的值：gmset key field ... fieldN&lt;br/&gt;取所有的字段名和值：hgetall key&lt;br/&gt;删除字段名和值：hdel key field ... fieldN&lt;br/&gt;判断字段是否存在：hexists key field&lt;br/&gt;获取key的所有field：hkeys key&lt;br/&gt;获取key的所有value：hvals key&lt;br/&gt;获取field个数：hlen key&lt;br/&gt;注：这里的field 就是 字段名，value 就是字段值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hset user name itdragon
(integer) 1
127.0.0.1:6379&amp;gt; hget user name
&quot;itdragon&quot;
127.0.0.1:6379&amp;gt; hmset user position java study redis
OK
127.0.0.1:6379&amp;gt; hmget user position study
1) &quot;java&quot;
2) &quot;redis&quot;
127.0.0.1:6379&amp;gt; hgetall user
1) &quot;name&quot;
2) &quot;itdragon&quot;
3) &quot;position&quot;
4) &quot;java&quot;
5) &quot;study&quot;
6) &quot;redis&quot;
127.0.0.1:6379&amp;gt; hdel user name 
(integer) 1
127.0.0.1:6379&amp;gt; hdel user position study
(integer) 2
127.0.0.1:6379&amp;gt; hexists user name
(integer) 1
127.0.0.1:6379&amp;gt; hexists user age
(integer) 0
127.0.0.1:6379&amp;gt; hkeys user
1) &quot;name&quot;
2) &quot;position&quot;
3) &quot;study&quot;
127.0.0.1:6379&amp;gt; hvals user
1) &quot;itdragon&quot;
2) &quot;java&quot;
3) &quot;redis&quot;
127.0.0.1:6379&amp;gt; hlen user
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;list-类型&quot;&gt;List 类型&lt;/h3&gt;
&lt;p&gt;Redis 列表是采用来链表来存储的简单字符串列表，按照插入顺序排序。添加元素一般从链表两端开始。&lt;br/&gt;向列表左侧加元素：lpush key value ... valueN&lt;br/&gt;向列表右侧加元素：rpush key value ... valueN&lt;br/&gt;遍历列表：lrange key startIndex endIndex&lt;br/&gt;获取List长度：llen key&lt;br/&gt;通过下标获取值：lindex key index&lt;br/&gt;通过下标设置值：lset key index value&lt;br/&gt;列表左侧移除第一个元素：lpop key&lt;br/&gt;列表右侧移除第一个元素：rpop key&lt;br/&gt;截取保留剩下的列表：ltrim key startIndex endIndex&lt;br/&gt;在制定元素插入值：linsert key after/before index value&lt;br/&gt;把集合第一个元素移到其他集合中：rpoplpush key otherListKey&lt;br/&gt;注：若endIndex=-1 表示最后一位；otherListKey 表示其他集合&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; lpush list 1 2
(integer) 2
127.0.0.1:6379&amp;gt; rpush list 3 4 
(integer) 4
127.0.0.1:6379&amp;gt; lrange list 0 -1
1) &quot;2&quot;
2) &quot;1&quot;
3) &quot;3&quot;
4) &quot;4&quot;
127.0.0.1:6379&amp;gt; lpop list
&quot;2&quot;
127.0.0.1:6379&amp;gt; rpop list
&quot;4&quot;
127.0.0.1:6379&amp;gt; llen list
(integer) 2
127.0.0.1:6379&amp;gt; lindex list 1
&quot;3&quot;
127.0.0.1:6379&amp;gt; linsert list after 1 2
(integer) 3
127.0.0.1:6379&amp;gt; linsert list before 3 4
(integer) 4
127.0.0.1:6379&amp;gt; ltrim list 0 1
OK
127.0.0.1:6379&amp;gt; rpoplpush list newlist
&quot;1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;set-类型&quot;&gt;Set 类型&lt;/h3&gt;
&lt;p&gt;Redis 的 Set 是String类型的无序集合。它是通过HashTable实现实现的，用法和 List 类型很相似。&lt;br/&gt;新增集合元素：sadd key value ... valueN&lt;br/&gt;删除集合元素：srem key value ... valueN&lt;br/&gt;获取集合所有元素：smembers key&lt;br/&gt;判断集合元素是否存在：sismember key value&lt;br/&gt;集合差集：sdiff key1 key2&lt;br/&gt;集合交集：sinter key1 key2&lt;br/&gt;集合并集：sunion key1 key2&lt;br/&gt;获取集合长度：scard key1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; sadd set a b c d
(integer) 4
127.0.0.1:6379&amp;gt; srem set a b c
(integer) 3
127.0.0.1:6379&amp;gt; smembers set
1) &quot;d&quot;
127.0.0.1:6379&amp;gt; sismember set a
(integer) 0
127.0.0.1:6379&amp;gt; sismember set d
(integer) 1
127.0.0.1:6379&amp;gt; sadd setA 1 2 3 
(integer) 3
127.0.0.1:6379&amp;gt; sadd setB 2 3 4
(integer) 3
127.0.0.1:6379&amp;gt; sdiff setA setB
1) &quot;1&quot;
127.0.0.1:6379&amp;gt; sdiff setB setA
1) &quot;4&quot;
127.0.0.1:6379&amp;gt; sinter setA setB
1) &quot;2&quot;
2) &quot;3&quot;
127.0.0.1:6379&amp;gt; sunion setA setB
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
127.0.0.1:6379&amp;gt; scard setA
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;zset-类型&quot;&gt;Zset 类型&lt;/h3&gt;
&lt;p&gt;Redis 的 zset（sorted set）和 set 一样也是string类型元素的集合,且不允许有重复的成员。不同的是 zset 的每个元素都会关联一个double类型的分数。zset正是通过分数来为集合中的成员进行排序。zset的成员是唯一的,但分数(score)却可以重复。&lt;br/&gt;新增集合元素：zadd key score value ... scoreN valueN&lt;br/&gt;获取元素分数：zscore key value&lt;br/&gt;按照分数从小到大排序：zrange key startIndex endIndex&lt;br/&gt;按照分数从大到小排序：zrevrange key startIndex endIndex&lt;br/&gt;遍历时显示分数：withscores&lt;br/&gt;统计分数比value少的个数：zrank key value&lt;br/&gt;统计分数比value高的个数：zrevrank key value&lt;br/&gt;输出分数在制定值内的元素：zrangebyscore key score1 score2&lt;br/&gt;给元素加分：zincrby key score value&lt;br/&gt;获取元素个数：zcard()&lt;br/&gt;统计分数内的个数：zcount key score1 score2&lt;br/&gt;删除制定排名内的元素：zremrangebyrank key no1 no2&lt;br/&gt;删除指定分数内的元素：zremrangebyscore key score1 score2&lt;br/&gt;删除指定元素：zrem key value&lt;br/&gt;注： zcount 统计分数内的个数，score1 &amp;lt;= keyScore =&amp;lt; score2；zremrangebyrank 的 no1 和 no2 表示排名的第几位。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zadd zset 65 A 67 C 66 B
(integer) 3
127.0.0.1:6379&amp;gt; zscore zset C
&quot;67&quot;
127.0.0.1:6379&amp;gt; zrange zset 0 -1
1) &quot;A&quot;
2) &quot;B&quot;
3) &quot;C&quot;
127.0.0.1:6379&amp;gt; zrevrange zset 0 -1
1) &quot;C&quot;
2) &quot;B&quot;
3) &quot;A&quot;
127.0.0.1:6379&amp;gt; zrevrange zset 0 -1 withscores
1) &quot;C&quot;
2) &quot;67&quot;
3) &quot;B&quot;
4) &quot;66&quot;
5) &quot;A&quot;
6) &quot;65&quot;
127.0.0.1:6379&amp;gt; zrank zset C
(integer) 2
127.0.0.1:6379&amp;gt; zrevrank zset C
(integer) 0
127.0.0.1:6379&amp;gt; zrangebyscore zset 65 66
1) &quot;A&quot;
2) &quot;B&quot;
127.0.0.1:6379&amp;gt; zrangebyscore zset 65 66 limit 1 2
1) &quot;B&quot;
127.0.0.1:6379&amp;gt; zincrby zset 10 A
&quot;75&quot;
127.0.0.1:6379&amp;gt; zcard zset
(integer) 3
127.0.0.1:6379&amp;gt; zcount zset 65 66
(integer) 1
127.0.0.1:6379&amp;gt; zremrangebyrank zset 0 1
(integer) 2
127.0.0.1:6379&amp;gt; zremrangebyscore zset 100 200
(integer) 0
127.0.0.1:6379&amp;gt; zrem zset A
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jedis客户端&quot;&gt;Jedis客户端&lt;/h2&gt;
&lt;p&gt;Jedis 是比较主流的 Redis Java 客户端。&lt;br/&gt;第一步：导入Jedis需要的jar&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- Redis客户端 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;redis.clients&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;jedis&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;jedis.version&amp;gt;&lt;/span&gt;2.7.2&lt;span class=&quot;kw&quot;&gt;&amp;lt;/jedis.version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步：单元测试类&lt;br/&gt;Jedis 的语法和 Redis 几乎一样，如果学好了Redis，Jedis也就没问题了，可谓是买一送一。建议使用连接池的方式。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itdragon.redis;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.HashMap;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Map;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.commons.pool2.impl.GenericObjectPoolConfig;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.junit.Test;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import redis.clients.jedis.Jedis;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import redis.clients.jedis.JedisPool;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestJedisOperate {
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String HOST = &lt;span class=&quot;st&quot;&gt;&quot;112.74.83.71&quot;&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; PORT = &lt;span class=&quot;dv&quot;&gt;6379&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * jedis 的语法和 redis 的语法几乎一致，比较常用的有Hash，String，List&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;jedisSignle&lt;/span&gt;() {
        Jedis jedis = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Jedis&lt;/span&gt;(HOST, PORT);
        jedis.&lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;account&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;itdragon&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;set , get 操作 : &quot;&lt;/span&gt; + jedis.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;account&quot;&lt;/span&gt;));
        jedis.&lt;span class=&quot;fu&quot;&gt;mset&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;account:01&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;itdragon01&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;account:02&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;itdragon02&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;mset , mget 操作 : &quot;&lt;/span&gt; + jedis.&lt;span class=&quot;fu&quot;&gt;mget&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;account:01&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;account:02&quot;&lt;/span&gt;));
        jedis.&lt;span class=&quot;fu&quot;&gt;hset&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;user&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;ITDragon&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hset , hget 操作 : &quot;&lt;/span&gt; + jedis.&lt;span class=&quot;fu&quot;&gt;hget&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;user&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;));
        Map&amp;lt;String, String&amp;gt; userMap = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
        userMap.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;);
        userMap.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;position&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Java&quot;&lt;/span&gt;);
        jedis.&lt;span class=&quot;fu&quot;&gt;hmset&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;user&quot;&lt;/span&gt;, userMap);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hmset , hmget 操作 : &quot;&lt;/span&gt; + jedis.&lt;span class=&quot;fu&quot;&gt;hmget&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;user&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;position&quot;&lt;/span&gt;));
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; == jedis.&lt;span class=&quot;fu&quot;&gt;llen&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userList&quot;&lt;/span&gt;)) {
            jedis.&lt;span class=&quot;fu&quot;&gt;lpush&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userList&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;2&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;3&quot;&lt;/span&gt;);
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;List 类型 lpush , lrange 操作 : &quot;&lt;/span&gt; + jedis.&lt;span class=&quot;fu&quot;&gt;lrange&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userList&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));
        jedis.&lt;span class=&quot;fu&quot;&gt;sadd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userSet&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;2&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;2&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Set 类型 sadd , smembers 操作 : &quot;&lt;/span&gt; + jedis.&lt;span class=&quot;fu&quot;&gt;smembers&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userSet&quot;&lt;/span&gt;));
        Map&amp;lt;String, Double&amp;gt; scoreMembers = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
        scoreMembers.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;65.0&lt;/span&gt;);
        scoreMembers.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;C&quot;&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;67.0&lt;/span&gt;);
        scoreMembers.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;66.0&lt;/span&gt;);
        jedis.&lt;span class=&quot;fu&quot;&gt;zadd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userScore&quot;&lt;/span&gt;, scoreMembers);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Set 类型 zadd , zrange 操作 : &quot;&lt;/span&gt; + jedis.&lt;span class=&quot;fu&quot;&gt;zrange&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userScore&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
    }
    
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;testJedisPool&lt;/span&gt;() {
        JedisPool pool = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;JedisPool&lt;/span&gt;(HOST, PORT);
        Jedis jedis = pool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;通过连接池获取 key 为 account 的值 : &quot;&lt;/span&gt; + jedis.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;account&quot;&lt;/span&gt;));
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        pool.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;spring-整合-redis&quot;&gt;Spring 整合 Redis&lt;/h2&gt;
&lt;p&gt;创建用于整合redis的文件 applicationContext-jedis.xml&lt;br/&gt;建议使用redis 默认配置（默认，让生活更美好）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:context=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:p=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:aop=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:tx=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 加载配置文件 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;context:property-placeholder&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; location=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;classpath:resource/*.properties&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接池配置 (可以用 redis 默认配置，效果可能会更好)--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jedisPoolConfig&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;redis.clients.jedis.JedisPoolConfig&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 最大连接数 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxTotal&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;30&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 最大空闲连接数 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxIdle&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 每次释放连接的最大数目 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;numTestsPerEvictionRun&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1024&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 释放连接的扫描间隔（毫秒） --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;timeBetweenEvictionRunsMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;30000&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接最小空闲时间 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;minEvictableIdleTimeMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1800000&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接空闲多久后释放, 当空闲时间&amp;gt;该值 且 空闲连接&amp;gt;最大空闲连接数 时直接释放 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;softMinEvictableIdleTimeMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10000&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxWaitMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1500&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 在获取连接的时候检查有效性, 默认false --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;testOnBorrow&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 在空闲时检查有效性, 默认false --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;testWhileIdle&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;blockWhenExhausted&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- jedis客户端单机版 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;redisClient&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;redis.clients.jedis.JedisPool&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;constructor-arg&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;host&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${redis.host}&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;constructor-arg&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;port&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${redis.ip}&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- &amp;lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot; /&amp;gt; --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jedisClient&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.itdragon.common.utils.JedisClientSingle&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单封装了Jedis 常用方法 JedisClientSingle.java&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itdragon.common.utils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import redis.clients.jedis.Jedis;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import redis.clients.jedis.JedisPool;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 单例的Redis 工具类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; JedisClientSingle {
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * connect timed out 问题： &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 1. 检查redis服务是否开启&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 2. 检查是否是因为防火墙的问题&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 3. 检查网络问题(如果在同一个局域网内几乎不会出现这个问题)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Jedis jedis =new Jedis(HOST,PORT,100000);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * JedisPool pool = new JedisPool(poolConfig, HOST, PORT, 100000);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; JedisPool jedisPool; 
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        String string = jedis.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; string;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(String key, String value) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        String string = jedis.&lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(key, value);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; string;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;hget&lt;/span&gt;(String hkey, String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        String string = jedis.&lt;span class=&quot;fu&quot;&gt;hget&lt;/span&gt;(hkey, key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; string;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hset&lt;/span&gt;(String hkey, String key, String value) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        Long result = jedis.&lt;span class=&quot;fu&quot;&gt;hset&lt;/span&gt;(hkey, key, value);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;del&lt;/span&gt;(String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        Long result = jedis.&lt;span class=&quot;fu&quot;&gt;del&lt;/span&gt;(key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hdel&lt;/span&gt;(String hkey, String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        Long result = jedis.&lt;span class=&quot;fu&quot;&gt;hdel&lt;/span&gt;(hkey, key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取商品类名接口实现类 ProductCategoryServiceImpl.java&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itdragon.service.impl;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Date;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.commons.lang3.StringUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Value;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.util.CollectionUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Service;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.transaction.annotation.Transactional;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.pojo.EUTreeNode;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.pojo.ResponseResult;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.utils.JedisClientSingle;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.utils.JsonUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.mapper.ProductCategoryMapper;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.pojo.ProductCategory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.pojo.ProductCategoryExample;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.pojo.ProductCategoryExample.Criteria;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.service.ProductCategoryService;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Service&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProductCategoryServiceImpl &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; ProductCategoryService {
    
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ProductCategoryMapper categoryMapper;
    
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; JedisClientSingle jedisClientSingle;
    
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${CATEGROY_ID_CACHE_REDIS_KEY}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String CATEGROY_ID_CACHE_REDIS_KEY;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;EUTreeNode&amp;gt; &lt;span class=&quot;fu&quot;&gt;getCategoryList&lt;/span&gt;(Long parentId) {
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; startTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
        List&amp;lt;EUTreeNode&amp;gt; resultList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
        &lt;span class=&quot;co&quot;&gt;// 从redis缓存中取内容&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            String cacheDatas = jedisClientSingle.&lt;span class=&quot;fu&quot;&gt;hget&lt;/span&gt;(CATEGROY_ID_CACHE_REDIS_KEY, parentId.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;());
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;isNotBlank&lt;/span&gt;(cacheDatas)) {
                List&amp;lt;ProductCategory&amp;gt; categories = JsonUtils.&lt;span class=&quot;fu&quot;&gt;jsonToList&lt;/span&gt;(cacheDatas, ProductCategory.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (ProductCategory category : categories) {
                    EUTreeNode node = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;EUTreeNode&lt;/span&gt;();
                    node.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;());
                    node.&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
                    node.&lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getIsParent&lt;/span&gt;()?&lt;span class=&quot;st&quot;&gt;&quot;closed&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;open&quot;&lt;/span&gt;);
                    resultList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(node);
                }
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;redis cache Time : &quot;&lt;/span&gt; + (System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - startTime));
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; resultList;
            }
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        ProductCategoryExample example = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProductCategoryExample&lt;/span&gt;();
        Criteria criteria = example.&lt;span class=&quot;fu&quot;&gt;createCriteria&lt;/span&gt;();
        criteria.&lt;span class=&quot;fu&quot;&gt;andStatusEqualTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        criteria.&lt;span class=&quot;fu&quot;&gt;andParentIdEqualTo&lt;/span&gt;(parentId); &lt;span class=&quot;co&quot;&gt;// 查询父节点下的所有子节点&lt;/span&gt;
        List&amp;lt;ProductCategory&amp;gt; productCategories = categoryMapper.&lt;span class=&quot;fu&quot;&gt;selectByExample&lt;/span&gt;(example);
        
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (ProductCategory category : productCategories) {
            EUTreeNode node = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;EUTreeNode&lt;/span&gt;();
            node.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;());
            node.&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
            node.&lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getIsParent&lt;/span&gt;()?&lt;span class=&quot;st&quot;&gt;&quot;closed&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;open&quot;&lt;/span&gt;);
            resultList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(node);
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;No redis cache Time : &quot;&lt;/span&gt; + (System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - startTime));
        &lt;span class=&quot;co&quot;&gt;// 向redis缓存中添加内容&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            jedisClientSingle.&lt;span class=&quot;fu&quot;&gt;hset&lt;/span&gt;(CATEGROY_ID_CACHE_REDIS_KEY, parentId.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;(), JsonUtils.&lt;span class=&quot;fu&quot;&gt;objectToJson&lt;/span&gt;(productCategories));
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; resultList;
    }

    &lt;span class=&quot;co&quot;&gt;// 后面的内容看源码...&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/tree/master/Redis&quot; class=&quot;uri&quot;&gt;https://github.com/ITDragonBlog/daydayup/tree/master/Redis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里，Redis 的快速入门就结束了。下一章节介绍Redis 的主从和集群。&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 15:42:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/7897131.html</dc:identifier>
</item>
<item>
<title>来手撸一个小小小小小&quot;3D引擎&quot; - assassinx</title>
<link>http://www.cnblogs.com/assassinx/p/7896478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/assassinx/p/7896478.html</guid>
<description>&lt;p&gt;开始的唠叨&lt;/p&gt;
&lt;p&gt;说是3D引擎确实有点过于博眼球了，其实就是实现了一个透视投影，当然也不是那么简单的。 此篇文章是纯粹给小白看的 高手请勿喷 。也称之为小向带你图形学入门基础 。 哇哈哈哈哈 一说到做一个3D画面的东东 一说总是到DirectX  OpenGL 这些玩意儿 我们这些菜鸟总是 想到哇擦擦 哇C++的   哇 计算机图形学好难。这玩意儿难度好大。其实就那么回事儿 ，DirectX OpenGL 只是工具 而已， 只要把原理搞懂了 你看我用low逼的GDI照样给你绘制一个3D物体 可以这样说即使不用GDI 其他任何能划线 画点的东西 ，我在安卓平台上照样给你实现这个效果。不要局限于工具 谁说做3D就只能用DirectX OpenGL了 ，谁说做3D只能用C++了  。&lt;/p&gt;

&lt;p&gt;顶点数据展现&lt;/p&gt;
&lt;p&gt;首先是3D编程中通用的数据展现 那就是顶点组成的网格数据 称之为mesh， 3个点为一组  组成的三角面片数据。三个点顺时针的方向那么 箭头方向为外表面 另一面为内表面 ，在绘制的时候 内表面不可见。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125215040562-1569414831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;好那么我们也以此方式来定义数据 ，我们定义的东西是一个 中心位置在( 0,0，-130)处的立方体。我们的观察点在(0, 0, 0)处 正对着立方体观察。 由于我们想让立方体一个面的颜色相同，所以是两个为一组定义的 ，当然三角形也是以同样的 两个为一组 组成一个正方形面。由此对物体表面空间点的描述数据就做好了。&lt;br/&gt;好 ，定义数据的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;93&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Marsh
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; List&amp;lt;Point3dF&amp;gt;&lt;span&gt; points;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Marsh()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 points = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Point3dF&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                 Point3dF pointA = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 Point3dF pointB = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 Point3dF pointC = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 Point3dF pointD = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 Point3dF pointE = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 Point3dF pointF = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 Point3dF pointG = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 Point3dF pointH = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                points.Add(pointA);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                points.Add(pointB);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                points.Add(pointC);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                points.Add(pointD);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                points.Add(pointE);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                points.Add(pointF);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                points.Add(pointG);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                points.Add(pointH);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;                 
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;                 path1 = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;() { 
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     &lt;span&gt;5&lt;/span&gt; ,&lt;span&gt;2&lt;/span&gt; ,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     &lt;span&gt;1&lt;/span&gt; ,&lt;span&gt;3&lt;/span&gt; ,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                     &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;7&lt;/span&gt; ,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                    ,
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                     &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; ,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                };
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;                 faceColors = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Brush&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 Random rdm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;6&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     Brush b= &lt;span&gt;new&lt;/span&gt; SolidBrush(Color.FromArgb(rdm.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;), rdm.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;), rdm.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Brush b = new SolidBrush(Color.FromArgb(266 / 6 * i, 266 / 6 * i, 266 / 6 * i));&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                    faceColors.Add(b);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                    faceColors.Add(b);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; List&amp;lt;Brush&amp;gt;&lt;span&gt; faceColors;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; path1;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于透视投影 和顶点绘制&lt;/p&gt;
&lt;p&gt;我数学底子差 在写这个例子之前参考了很多前辈的 图形学理论基础。最主要是透视投影 和3D旋转矩阵绕任意轴旋转 。甚至没完全搞懂 于是我就抄起代码开搞了。 不得不说这玩意儿真的很有意思。&lt;br/&gt;首先是透视投影：http://blog.csdn.net/popy007/article/details/1797121&lt;br/&gt;作者讲的很详细 其实我只看到一半 ，后面矩阵推导那些太难了 没有继续往下啃 。视线是一个发散的方式从一个点出去 （其实最后发现不用管什么视椎体不视椎体的）。 假设视点前面有一张半透明的纸张 视线上的点是怎么打到纸张上的？关于这个问题  你要粗暴点确实很简单 就是三角形 初中的知识。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125215710437-782610699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就如开始所述 视点在(0,0,0) 处看向 位于(0,0,-130) 的立方体  ，假设有一架摄像机  ，那么上图就是他的从空中看下去的俯视图。设p为(x,z)　　p'为(x' ,z') 。则x'=-N(x/z)  y'=-N(y/z)。为了方便 我们的数据定义也是跟示意图上差不多的。于是我们依葫芦画瓢 把所有的点绘制出来 包装成一个paint函数。&lt;br/&gt;需要注意的是平面坐标系 跟屏幕坐标之间的转换 ，其实不难 你其他计算应用数学公式 数学函数 还是一样该咋算咋算。  完成后我们平面坐标系的0,0  对应屏幕坐标的0,0   。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125220959171-520820594.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125221017593-296350008.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;看到没 x轴0左边也是负数 不用管  就只是y的符号不一样 变成-y就可以了。然后要让他显示在窗口中间  还要进行偏移 就是x加偏移， y加偏移  就这样就完成啦 。  哈哈哈哈哈。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; paint()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             Graphics gph = Graphics.FromHwnd(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Handle);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            gph.Clear(Color.Lavender);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行到屏幕坐标的映射(x y z)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p~ =(-n x/z       -n y/z      -n)&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             PointF screenLastPoint=&lt;span&gt; PointF.Empty;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; msh.path1.Count / &lt;span&gt;3&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (i &amp;gt;= 4)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 PointF screenPointA = &lt;span&gt;new&lt;/span&gt; PointF((&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]].x / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]].z)) , (&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]].y / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]].z))  );
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 PointF screenPointB = &lt;span&gt;new&lt;/span&gt; PointF((&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;]].x / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;]].z)) , (&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;]].y / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]].z))  );
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 PointF screenPointC = &lt;span&gt;new&lt;/span&gt; PointF((&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;]].x / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;]].z))  , (&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;]].y / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]].z))  );
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;                 screenPointA.Y = -&lt;span&gt;screenPointA.Y;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 screenPointB.Y = -&lt;span&gt;screenPointB.Y;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 screenPointC.Y = -&lt;span&gt;screenPointC.Y;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;                 screenPointA.Y=screenPointA.Y+&lt;span&gt;offsety;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 screenPointB.Y= screenPointB.Y+&lt;span&gt;offsety;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 screenPointC.Y = screenPointC.Y +&lt;span&gt; offsety;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;                 screenPointA.X = screenPointA.X +&lt;span&gt; offsetx;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 screenPointB.X = screenPointB.X +&lt;span&gt; offsetx;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 screenPointC.X = screenPointC.X +&lt;span&gt; offsetx;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;                 System.Drawing.Drawing2D.GraphicsPath ph = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Drawing.Drawing2D.GraphicsPath(
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PointF[] { screenPointA, screenPointB, screenPointC },
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                    System.Drawing.Drawing2D.FillMode.Winding);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---求法向量及夹角 如果为true 则渲染面&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算当前管线三角面片的法向量 是否朝着镜头 ，最终决定是否可见&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (angelCalc(msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]], msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;]], msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;]]) == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                    gph.FillPath(msh.faceColors[i], ph);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制边框&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             gph.DrawLine(Pens.Red, &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             gph.DrawLine(Pens.Red,  &lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;),&lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety + &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             gph.DrawLine(Pens.Red, &lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety +&lt;span&gt;36&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety + &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             gph.DrawLine(Pens.Red, &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety + &lt;span&gt;36&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/绘制网格线&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;screenLastPoint = PointF.Empty;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for (int i = 0; i &amp;lt; msh.path1.Count / 3; i++)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (i &amp;gt;= 4)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PointF screenPointA = new PointF((float)((-nearPlan) * (msh.points[msh.path1[i * 3]].x / msh.points[msh.path1[i * 3]].z)), (float)((-nearPlan) * (msh.points[msh.path1[i * 3]].y / msh.points[msh.path1[i * 3]].z)));
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PointF screenPointB = new PointF((float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 1]].x / msh.points[msh.path1[i * 3 + 1]].z)), (float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 1]].y / msh.points[msh.path1[i * 3 + 1]].z)));
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PointF screenPointC = new PointF((float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 2]].x / msh.points[msh.path1[i * 3 + 2]].z)), (float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 2]].y / msh.points[msh.path1[i * 3 + 2]].z)));
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointA.Y = -screenPointA.Y;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointB.Y = -screenPointB.Y;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointC.Y = -screenPointC.Y;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointA.Y = screenPointA.Y + offsety;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointB.Y = screenPointB.Y + offsety;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointC.Y = screenPointC.Y + offsety;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointA.X = screenPointA.X + offsetx;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointB.X = screenPointB.X + offsetx;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointC.X = screenPointC.X + offsetx;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    gph.DrawLine(Pens.Red, screenPointA, screenPointB);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    gph.DrawLine(Pens.Red, screenPointB, screenPointC);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    gph.DrawLine(Pens.Red, screenPointC, screenPointA);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;绕着坐标轴进行旋转  &lt;/p&gt;
&lt;p&gt;最开始我没有绘制面只是绘制的顶点线框而已 。然后我想做的是旋转  让他转起来，总共八个点连成线就是立方体了，哪怕是low逼的线条 只要转起来是不是就有立方体的样子了。  哇哈哈哈哈。最开始我想的很简单啊 立体的旋转也没啥不得了的啊 ，比如饶y轴旋转 我把他当成平面的不就得了么 y不变x和z变。 绕x轴旋转 同理。 我原来也写过平面的点进行旋转的计算。 为了符合图形学上的标准方式 最后我还是使用二维矩阵旋转的方式： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RotationTest2()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维空间旋转矩阵为 ： x是角度
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cos(x)  -sin(x)   (1-cos(x))tx+ty*sin(x))  x
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Sin(x) cos(x)     (1-cos(x))ty-tx*sin(x)) y
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2pi 等于360度
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绕y轴旋转
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;double xita = ((Math.PI * 2d) / 360d) * 2d;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; xita = ((Math.PI * 2d) / 360d) *&lt;span&gt; anglex;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cosx =&lt;span&gt; Math.Cos(xita);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; sinx =&lt;span&gt; Math.Sin(xita);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; xitay = ((Math.PI * 2d) / &lt;span&gt;360&lt;/span&gt;) *&lt;span&gt; angley;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cosy =&lt;span&gt; Math.Cos(xitay);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; siny =&lt;span&gt; Math.Sin(xitay);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; msh.points.Count; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF tmpPoint = new Point3dF(msh.points[i].x, msh.points[i].y, msh.points[i].z);&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 Point3dF tmpPoint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(mshSource.points[i].x, mshSource.points[i].y, mshSource.points[i].z);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 msh.points[i].x =
&lt;span&gt;24&lt;/span&gt;                     tmpPoint.x * cosx + ((-sinx) * tmpPoint.z) +
&lt;span&gt;25&lt;/span&gt;                 (((1d - cosx) * 0d) + ((-130d) *&lt;span&gt; sinx));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;                 msh.points[i].z =
&lt;span&gt;28&lt;/span&gt;                     tmpPoint.x * sinx + (cosx * tmpPoint.z) +
&lt;span&gt;29&lt;/span&gt;                     (((1d - cosx) * (-130d)) - ((0d) *&lt;span&gt; sinx));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;                 msh.points[i].y =&lt;span&gt; tmpPoint.y;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------------&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                 tmpPoint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(msh.points[i].x, msh.points[i].y, msh.points[i].z);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;                 msh.points[i].y = tmpPoint.y * cosy + ((-siny) * tmpPoint.z) +
&lt;span&gt;37&lt;/span&gt;                 (((1d - cosy) * 0d) + ((-130d) *&lt;span&gt; siny));
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;                 msh.points[i].z = tmpPoint.y * siny + (cosy * tmpPoint.z) +
&lt;span&gt;40&lt;/span&gt;                     (((1d - cosy) * (-130d)) - ((0d) *&lt;span&gt; siny));
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意了 绕着任意轴进行旋转&lt;/p&gt;
&lt;p&gt;现在我想做的是做一个跟踪球效果 。鼠标按下拖动的时候让物体 像烤肉串样绕着一根轴旋转。 网上跟踪球都是旋转相机 我们这里直接旋转物体坐标。绕着任意轴旋转啊绕着任意轴旋转的矩阵 说实话 3D旋转矩阵这个我搞不懂 ，我看不懂推导过程 但是我会看公式 哇哈哈哈哈。&lt;br/&gt;https://www.cnblogs.com/graphics/archive/2012/08/10/2627458.html&lt;br/&gt;其他的博文里贴出来的旋转矩阵也是这样 直接把他的代码抄下来之  ，c++的 我抄成c#的 没啥难的 我已经超过好些c++代码了。总之我们要做的就是 得出一个二维数组作为矩阵回传 让所有坐标根据此矩阵进行运算。注意有两个基本概念：  两个点相减 a-b  得出的是 b到a 的向量 (0,0) -(1,1)  =(-1,-1)  ，然后是向量归一化： 什么叫归一化， 就是 把向量的方向不变 长度变到单位长度 ，也就是1。问向量归一化怎么搞  。好 ，比如一个二维向量，计算原理就是通过距离计算公式&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125223044390-971885070.png&quot; alt=&quot;&quot;/&gt;得出距离。这个距离与1的比值等于 现x与归一化后x的比值：&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125223658468-749414512.png&quot; alt=&quot;&quot;/&gt;求归一化后y的值同理。当然这些都是基础的没什么特别说的。&lt;br/&gt;求旋转矩阵的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到旋转矩阵&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;double&lt;/span&gt;[,] RotateArbitraryLine(Point3dF v1, Point3dF v2, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; theta)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; a =&lt;span&gt; v1.x;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; b =&lt;span&gt; v1.y;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; c =&lt;span&gt; v1.z;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             Point3dF p = &lt;span&gt;new&lt;/span&gt; Point3dF(v2.x - v1.x, v2.y - v1.y, v2.z -&lt;span&gt; v1.z);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;v2归一化&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; x_p2 = p.x / Math.Sqrt(Math.Pow(p.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(p.y, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; y_p2 = p.y / Math.Sqrt(Math.Pow(p.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(p.y, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;.IsNaN(x_p2))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 x_p2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;.IsNaN(y_p2))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 y_p2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; u =&lt;span&gt; x_p2;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; v =&lt;span&gt; y_p2;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; w = 0d;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -130d;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0d;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; uu = u *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; uv = u *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; uw = u *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; vv = v *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; vw = v *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; ww = w *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; au = a *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; av = a *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; aw = a *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; bu = b *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; bv = b *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; bw = b *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cu = c *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cv = c *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cw = c *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; costheta =&lt;span&gt; Math.Cos(theta);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; sintheta =&lt;span&gt; Math.Sin(theta) ;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt;[,] pOut = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = uu + (vv + ww) *&lt;span&gt; costheta;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = uv * (&lt;span&gt;1&lt;/span&gt; - costheta) + w *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = uw * (&lt;span&gt;1&lt;/span&gt; - costheta) - v *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                   
&lt;span&gt;46&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = uv * (&lt;span&gt;1&lt;/span&gt; - costheta) - w *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = vv + (uu + ww) *&lt;span&gt; costheta;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = vw * (&lt;span&gt;1&lt;/span&gt; - costheta) + u *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                   
&lt;span&gt;51&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = uw * (&lt;span&gt;1&lt;/span&gt; - costheta) + v *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = vw * (&lt;span&gt;1&lt;/span&gt; - costheta) - u *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = ww + (uu + vv) *&lt;span&gt; costheta;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                   
&lt;span&gt;56&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = (a * (vv + ww) - u * (bv + cw)) * (&lt;span&gt;1&lt;/span&gt; - costheta) + (bw - cv) *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = (b * (uu + ww) - v * (au + cw)) * (&lt;span&gt;1&lt;/span&gt; - costheta) + (cu - aw) *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = (c * (uu + vv) - w * (au + bv)) * (&lt;span&gt;1&lt;/span&gt; - costheta) + (av - bu) *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pOut;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;函数写好了 矩阵也能得出了，还有个问题：函数的那几个参数 ，旋转的度数也好搞 按下的时候记录一个点 拖动的时候计算跟他的距离 距离作为度数 拖动50像素 旋转50度。 旋转的那根儿轴你怎么得出来，开始点容易 立方体的中心是0 0 -130  。按下的时候记录了按下开始点 鼠标的移动就已经是一个向量了 所以我们只需要对这个向量 绕z轴进行90度旋转 ，z也设成-130 就跟中心点平齐了 就是需要的烤肉串儿的旋转轴了。 好 原理讲完了 ，代码走起：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Form1_MouseMove(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, MouseEventArgs e)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须要得出旋转的轴才行&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pressed)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中心点 0,0,-130
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过拖动远近决定旋转角度，垂直向量 得到旋转轴
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得出鼠标拖动向量 &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;                 Point3dF dragJuli = &lt;span&gt;new&lt;/span&gt; Point3dF((e.Location.X - startPoint.X),( e.Location.Y - startPoint.Y),-&lt;span&gt;130d);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还要旋转90度才是真正的旋转轴
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cos(x)  -sin(x)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Sin(x) cos(x)  &lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;double&lt;/span&gt; cos90=&lt;span&gt;0d;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;double&lt;/span&gt; sin90=&lt;span&gt;1d;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; x = dragJuli.x * 0d + dragJuli.y *&lt;span&gt; 1d;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; y = dragJuli.x * 1d + dragJuli.y *&lt;span&gt; 0d;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;                 Point3dF dragJuli2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(x, y, dragJuli.z);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF dragJuli90=
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;x1 x2+y1 y2=0
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;double x2=(-dragJuli.y)/(dragJuli.x);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;垂直的旋转轴向量
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF roll = new Point3dF(x2, 1, -130);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拖动距离 拖动距离等于角度&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                 angelourua= Math.Sqrt(Math.Pow((e.Location.X - startPoint.X), &lt;span&gt;2&lt;/span&gt;) + Math.Pow((e.Location.Y - startPoint.Y), &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 angelourua = angelourua % &lt;span&gt;360&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 angelourua = ((Math.PI * 2d) / 360d) *&lt;span&gt; angelourua;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;double&lt;/span&gt;[,] roatMatarix= RotateArbitraryLine(&lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, -&lt;span&gt;130d), dragJuli2,angelourua);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                RotationTest(roatMatarix);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                paint();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好就这样 先进行3d空间的点旋转， 再进行平面坐标映射绘制 用线连起来。是不是就有点3D立体的样子了。哇哈哈哈哈&lt;/p&gt;
&lt;p&gt; 注意了 面绘制&lt;/p&gt;
&lt;p&gt;前面的都是有些挖的别人的，这个功能绝对是自己捣鼓出来的。开始那些不论是两两之间的线条绘制啥的都只能算是 点绘制  ，我们现在要进行面绘制。首先你要清楚的是我的顶点三角面片数据已经给出了， 3d坐标点打在半透明纸张上 的x，y 也已经得出了。 调用gdi的fillpath按ABC 的顺序连起来 就能绘制一个三角面片 是不是很简单。但是先别慌 还有两个问题需要处理，一个就是可见面判别。 就是两个三角面片 的位置 决定了 在透视投影的时候哪个在前哪个在后， 还有面相交的情况呢 ？ 是不是很复杂？其实根本不用管，即使要管 只要你使用z缓冲算法 也不是很复杂 zbuffer 。就是在求出屏幕x y过后把同xy的点z越靠近视点的放在前面 这样就达到目的了。这里我们先 不管这个zbuffer算法  下次有空闲了我们再来写。这里我们使用另外一种方式 通过判别正向面与后向面来达到目的。前面我们不是说了吗 ：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125215040562-1569414831.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们通过计算每个三角面片的法向量， 然后我们有一个视点到三角面片的向量 ，通过计算两向量的点积  &lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125225730328-262725811.png&quot; alt=&quot;&quot;/&gt;然后通过反余弦函数就可以得出两向量的夹角 。 如果夹角大于90度代表三角面片正向面朝着视点， 如果小于90度代表正向面背对了视点， 则不对这个三角面片进行渲染。如此一来 你仔细想想 我们的立方体至始至终不会存在一个面把另一个面遮挡的情况。&lt;br/&gt;好了原理讲至此 好下面 根据原理撸代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;平面是否面向摄像机的判别&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; angelCalc( Point3dF A,Point3dF B,Point3dF C)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;https://zhidao.baidu.com/question/810216091258785532.html&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AB、AC所在平面的法向量即AB×AC=(a,b,c),其中：
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a=(y2-y1)(z3-z1)-(z2-z1)(y3-y1)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b=(z2-z1)(x3-x1)-(z3-z1)(x2-x1)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;c=(x2-x1)(y3-y1)-(x3-x1)(y2-y1)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先得出点 对应的向量
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF AB = new Point3dF(B.x - A.x, B.y - A.y, B.z - A.z);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先求出法向量&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; a = ((B.y - A.y)*(C.z - A.z) - (B.z - A.z)*(C.y -&lt;span&gt; A.y));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; b = (B.z - A.z) * (C.x - A.x) - (C.z - A.z) * (B.x -&lt;span&gt; A.x);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; c = (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y -&lt;span&gt; A.y);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             Point3dF bb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(a, b, c);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;套公式 第二册 下b 39  通过两向量的cos函数 继而通过反余弦得出角度&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; angelPlan =&lt;span&gt;Math.Acos(
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 (A.x * bb.x + A.y * bb.y + A.z * bb.z) /&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                Math.Sqrt(Math.Pow(A.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(A.y, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(A.z, &lt;span&gt;2&lt;/span&gt;)) *
&lt;span&gt;22&lt;/span&gt;                Math.Sqrt(Math.Pow(bb.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(bb.y, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(bb.z, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;               )
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;               );
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (angelPlan &amp;gt; (Math.PI / &lt;span&gt;2&lt;/span&gt;))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;法向量与镜头的夹角大于90度 代表三角面片面向摄像机 则可见&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则不可见&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于光照&lt;/p&gt;
&lt;p&gt;光照这玩意儿还是 用到三角面片的法向量 ，三角面片正对着光 则表面亮度最高 ，垂直则变成黑暗。参照面绘制的原理就可以搞出来 我这里就每个面各用些五颜六色的颜色算了吧 懒得整了。&lt;/p&gt;
&lt;p&gt;其他的&lt;/p&gt;
&lt;p&gt;还有我的摄像机镜头是固定的 ，其实还有很多工作需要做  。 希望各位大大继续完善。看下效果 是不是有模有样：上个gif图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125232626546-2022770934.gif&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;你可以把平面面向摄像机判别函数返回的值反向一下看看什么效果，是不是看到内壁的那一面了 是不是很神奇哇哈哈哈哈&lt;br/&gt;是的你没看错就这么几百行核心部分就实现了  差不多都是数学知识 ，其他的都是添砖加瓦的事，原理都在这了。 好了 以后再看DirectX 啊OpenGL啊 图形学 变换矩阵啊那些的 别被唬住了 没那么难的。&lt;br/&gt;按说的话这些知识总体来说蛮难的 但是毕竟还是学过高中的向量  两向量垂直时点积等于零 这些之类的  ， 靠着摸着石头过河 把这些半懂不懂的知识 拼凑起来 加上各种度娘 和查资料 来实现 没想到竟然成功了。 意外意外  ，当然学习是要靠自己的  你想直接度娘给你出来个你要的效果 那是不可能的。&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 15:38:00 +0000</pubDate>
<dc:creator>assassinx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/assassinx/p/7896478.html</dc:identifier>
</item>
</channel>
</rss>