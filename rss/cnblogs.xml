<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java基础之反射 - 楚大校</title>
<link>http://www.cnblogs.com/zxx123/p/9584986.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxx123/p/9584986.html</guid>
<description>
&lt;p&gt;如何创建class对象呢？有两种方式：&lt;/p&gt;
&lt;p&gt;    class.forName(&quot;class名称&quot;);&lt;/p&gt;
&lt;p&gt;    Class a = a.class;&lt;/p&gt;
&lt;p&gt;    两者的区别在于：forName()会帮你初始化好静态变量；&lt;/p&gt;
&lt;p&gt;    而Class a = a.class这个要自己初始化静态变量；&lt;/p&gt;
&lt;p&gt;    反射，动态代理；&lt;/p&gt;
&lt;p&gt;    通过反射，你可以实现获得class的方法;也就是对象的方法；&lt;/p&gt;
&lt;p&gt;    使用一个newInstace；可以由class变成一个对象；&lt;/p&gt;
&lt;p&gt;    instanceof可以判断某个类是否是属于另一个类的，用于向下转型时的判断；&lt;/p&gt;

&lt;p&gt;通过class对象可以获取某个类中的：构造方法，成员变量，成员方法，并访问成员；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取构造方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    class.getConstructors()；获取公有的构造方法；&lt;/p&gt;
&lt;p&gt;    class.getDeclaredConstructors()；获取所有的构造方法；&lt;/p&gt;
&lt;p&gt;    class.getConstructor(null)；获取公有的，无参的构造方法；&lt;/p&gt;
&lt;p&gt;    这些方法返回的是一个Constructor con；构造函数的类对象；&lt;/p&gt;
&lt;p&gt;    可以通过con.newInstance(&quot;传参&quot;)的方式进行 对象的创建；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取成员变量：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    class.getFields()；获取所有的公有的字段；&lt;/p&gt;
&lt;p&gt;    class.getDeclaredFields()；获取所有的字段；&lt;/p&gt;
&lt;p&gt;    class.getField(&quot;name&quot;)；获取某一个公有特定字段(name)；&lt;/p&gt;
&lt;p&gt;    class.getDeclaredField(&quot;phoneNum&quot;)；获取某一私有字段phoneNum；&lt;/p&gt;
&lt;p&gt;    返回Field；用set的方式去设置我们的成员变量；&lt;/p&gt;
&lt;p&gt;    f.set(obj,&quot;刘德华&quot;);其中呢，我们的这个obj就是我们的用class产生的一个对象；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;获取成员方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    class.getMethods()；获取所有的公有方法；&lt;/p&gt;
&lt;p&gt;    class.getDeclaredMethods()；获取所有的方法；&lt;/p&gt;
&lt;p&gt;    class.getMethod(&quot;方法名&quot;,String.class);获得单个特定的方法；后面的String.class是指我们的方法形参；&lt;/p&gt;
&lt;p&gt;    返回的是一个Method对象；那我们要做的呢，就是个Field一样，先产生一个对象；&lt;/p&gt;
&lt;p&gt;    m.invoke(obj,20)；这个里面我们用到了方法的执行函数invoke（）,obj是对象，20是参数；&lt;/p&gt;
&lt;p&gt;甚至可以直接反射我们的main()方法；&lt;/p&gt;
&lt;p&gt;    class.getMethod(&quot;main&quot;,Stirng[].class)；&lt;/p&gt;
&lt;p&gt;通过反射，我们可以在原有的基础山实现，读取Properties来实现反射，去新建类，以及执行方法；&lt;/p&gt;
&lt;p&gt;用反射可以避掉泛型的检查：&lt;/p&gt;
&lt;p&gt;    我们甚至可以调用某一个容器的class文件，再去调用他的method方法，来达到逃避泛型检查的问题；&lt;/p&gt;

&lt;p&gt;另外，我们还可以通过反射来实现动态代理的模式：&lt;/p&gt;
&lt;div readability=&quot;17.2771560237&quot;&gt;　　
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Subject{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething();
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; RealSubject &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Subject{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething(){
        System.out.println(&lt;/span&gt;&quot;call doSomething()&quot;&lt;span&gt;);    
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ProxyHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object tar;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object bind(Object tar){
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tar =&lt;span&gt; tar;
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Proxy.newProxyInstance(tar.getClass().getClassLoader(),
                                      tar.getClass().getInterfaces(),
                                      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
     }
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method ,Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable{
         Object result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        result &lt;/span&gt;=&lt;span&gt; method.invoke(tar,args);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args[]){
        ProxyHandler proxy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyHandler();
        Subject sub &lt;/span&gt;= (Subject) proxy.bind(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RealSubject());
        sub.doSomething();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中就用到了一个ProxyHandler，实现自 InvocationHandler接口，通过传入一个真实对象，来的获取一个代理对象，需要的参数有：tar.getClass().getClassLoader()真实对象的类加载器，tar.getClass().getInterfaces()真实对象的接口，以及this，InvocationHandler本身，通过反射的机制，来获取一个代理对象， 同时在这个代理对象的方法执行函数中，写入我们的真实对象的方式执行。以便在之后的方法调用中先调用了我们的真实对象的方法；记得调用代理对象的bind 的时候要把对象向下转成真实对象的；&lt;/p&gt;
&lt;p&gt;根据反射获得构造函数，成员变量，成员方法的更多详细代码请参考博客：&lt;a href=&quot;https://blog.csdn.net/sinat_38259539/article/details/71799078&quot;&gt;https://blog.csdn.net/sinat_38259539/article/details/71799078&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Tue, 04 Sep 2018 08:00:00 +0000</pubDate>
<dc:creator>楚大校</dc:creator>
<og:description>如何创建class对象呢？有两种方式： class.forName(&quot;class名称&quot;); Class a = a.class; 两者的区别在于：forName()会帮你初始化好静</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zxx123/p/9584986.html</dc:identifier>
</item>
<item>
<title>如何把本地文件上传到gitlab上已存在的工程里 - 苹瑶</title>
<link>http://www.cnblogs.com/qpnets/p/9584975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qpnets/p/9584975.html</guid>
<description>&lt;p&gt;1、首先要求在gitlab服务器上已存在有该工程项目的文件夹（也许名称跟你本地建的文件夹名称不一致），没关系，选择一个磁盘文件夹，进入并右击，选择Git Bush Here,输入下面的指令&lt;/p&gt;
&lt;p&gt;2、git clone git@XXX:XXXX.git&lt;/p&gt;
&lt;p&gt;3、git@XXX:XXXX.git 直接在gitlab上对应的工程下，拷贝得到的&lt;/p&gt;
&lt;p&gt;3、上一步回车完成后，关闭指令窗口，会在该文件夹下发现gitlab的工程已经被下载下来了，里面含有.git（需要使能可见隐藏文件）&lt;/p&gt;
&lt;p&gt;4、接着，把自己本地编译调试好的工程文件拷贝到这个克隆的文件夹下面，无论是有新加的还是修改过的，然后，在这个克隆的文件夹里面，右击，选择Git Bush Here,输入下面的指令&lt;/p&gt;
&lt;p&gt;5、git add .&lt;/p&gt;
&lt;p&gt;6、git commit -m &quot;commit&quot;&lt;/p&gt;
&lt;p&gt;7、git push&lt;/p&gt;
&lt;p&gt;8、最后在gitlab网页端查看，发现该工程已经被update成功啦~说明关联本地跟gitlab仓库成功。&lt;/p&gt;
</description>
<pubDate>Tue, 04 Sep 2018 07:58:00 +0000</pubDate>
<dc:creator>苹瑶</dc:creator>
<og:description>1、首先要求在gitlab服务器上已存在有该工程项目的文件夹（也许名称跟你本地建的文件夹名称不一致），没关系，选择一个磁盘文件夹，进入并右击，选择Git Bush Here,输入下面的指令 2、git</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qpnets/p/9584975.html</dc:identifier>
</item>
<item>
<title>深度 | 朴素贝叶斯模型算法研究与实例分析 - 伏草惟存</title>
<link>http://www.cnblogs.com/baiboy/p/pybnc4-3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baiboy/p/pybnc4-3.html</guid>
<description>&lt;center&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc4-3.html&quot;&gt;深度 | 朴素贝叶斯模型算法研究与实例分析&lt;/a&gt;&lt;/span&gt;&lt;/center&gt;
&lt;center&gt;(&lt;a href=&quot;http://www.cnblogs.com/baiboy&quot;&gt;白宁超&lt;/a&gt;   2018年9月4日14:18:14)&lt;/center&gt;
&lt;blockquote readability=&quot;7.6190476190476&quot;&gt;
&lt;p&gt;&lt;strong&gt;导读&lt;/strong&gt;：朴素贝叶斯模型是机器学习常用的模型算法之一，其在文本分类方面简单易行，且取得不错的分类效果。所以很受欢迎，对于朴素贝叶斯的学习，本文首先介绍理论知识即朴素贝叶斯相关概念和公式推导，为了加深理解，采用一个维基百科上面性别分类例子进行形式化描述。然后通过编程实现朴素贝叶斯分类算法，并在屏蔽社区言论、垃圾邮件、个人广告中获取区域倾向等几个方面进行应用，包括创建数据集、数据预处理、词集模型和词袋模型、朴素贝叶斯模型训练和优化等。然后结合复旦大学新闻语料进行朴素贝叶斯的应用。最后，大家熟悉其原理和实现之后，采用机器学习sklearn包进行实现和优化。由于篇幅较长，采用理论理解、案例实现、sklearn优化三个部分进行学习。（本文原创，转载必须注明出处： &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc4-3.html&quot;&gt;朴素贝叶斯模型算法研究与实例分析&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/baiboy/p/pybnc4-1.html&quot;&gt;理论 | 朴素贝叶斯模型算法研究与实例分析&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/baiboy/p/pybnc4-2.html&quot;&gt;实现 | 朴素贝叶斯模型算法研究与实例分析&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc4-3.html&quot; target=&quot;_blank&quot;&gt;深度 | 朴素贝叶斯模型算法研究与实例分析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;复旦新闻语料：朴素贝叶斯中文文本分类&lt;/h2&gt;
&lt;h3 id=&quot;-&quot;&gt;项目概述&lt;/h3&gt;
&lt;p&gt;本节介绍朴素贝叶斯分类算法模型在中文领域中的应用。我们对新闻语料进行多文本分类操作，本文选择艺术、文学、教育、哲学、历史五个类别的训练文本，然后采用新的测试语料进行分类预测。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;收集数据&lt;/h3&gt;
&lt;p&gt;数据集是从复旦新闻语料库中抽取出来的，考虑学习使用，样本选择并不大。主要抽选艺术、文学、教育、哲学、历史五个类别各10篇文章。全部数据文档50篇。具体情况不同对收集数据要求不同，你也可以选择网络爬取，数据库导出等。这文档读取时候可能会遇到gbk，utf-8等格式共存的情况，这里建议采用&lt;a href=&quot;%E9%93%BE%E6%8E%A5:%20https://pan.baidu.com/s/1DcUFDbyUARSxeSfNjCXHbA%20%E5%AF%86%E7%A0%81:%20yi26&quot;&gt;BatUTF8Conv.exe&lt;/a&gt;（&lt;a href=&quot;%E9%93%BE%E6%8E%A5:%20https://pan.baidu.com/s/1DcUFDbyUARSxeSfNjCXHbA%20%E5%AF%86%E7%A0%81:%20yi26&quot;&gt;点击下载&lt;/a&gt;）工具，进行utf-8格式批量转化。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;准备数据&lt;/h3&gt;
&lt;p&gt;创建数据集代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'''创建数据集和类标签'''
def loadDataSet():
    docList = [];classList = [] # 文档列表、类别列表
    dirlist = ['C3-Art','C4-Literature','C5-Education','C6-Philosophy','C7-History']
    for j in range(5):
        for i in range(1, 11): # 总共10个文档
            # 切分，解析数据，并归类为 1 类别
            wordList = textParse(open('./fudan/%s/%d.txt' % (dirlist[j],i),encoding='UTF-8').read())
            docList.append(wordList)
            classList.append(j)
            # print(i,'\t','./fudan/%s/%d.txt' % (dirlist[j],i),'\t',j)
    return docList,classList

''' 利用jieba对文本进行分词，返回切词后的list '''
def textParse(str_doc):
    # 正则过滤掉特殊符号、标点、英文、数字等。
    import re
    r1 = '[a-zA-Z0-9’!&quot;#$%&amp;amp;\'()*+,-./:;&amp;lt;=&amp;gt;?@，。?★、…【】《》？“”‘’！[\\]^_`{|}~]+'
    str_doc=re.sub(r1, '', str_doc)

    # 创建停用词列表
    stwlist = set([line.strip() for line in open('./stopwords.txt', 'r', encoding='utf-8').readlines()])
    sent_list = str_doc.split('\n')
    # word_2dlist = [rm_tokens(jieba.cut(part), stwlist) for part in sent_list]  # 分词并去停用词
    word_2dlist = [rm_tokens([word+&quot;/&quot;+flag+&quot; &quot; for word, flag in pseg.cut(part) if flag in ['n','v','a','ns','nr','nt']], stwlist) for part in sent_list] # 带词性分词并去停用词
    word_list = list(itertools.chain(*word_2dlist)) # 合并列表
    return word_list



''' 去掉一些停用词、数字、特殊符号 '''
def rm_tokens(words, stwlist):
    words_list = list(words)
    for i in range(words_list.__len__())[::-1]:
        word = words_list[i]
        if word in stwlist:  # 去除停用词
            words_list.pop(i)
        elif len(word) == 1:  # 去除单个字符
            words_list.pop(i)
        elif word == &quot; &quot;:  # 去除空字符
            words_list.pop(i)
    return words_list
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码分析：loadDataSet()方法是遍历读取文件夹，并对每篇文档进行处理，最后返回全部文档集的列表和类标签。textParse()方法是对每篇文档字符串进行数据预处理，我们首选使用正则方法保留文本数据，然后进行带有词性的中文分词和词性选择，rm_tokens()是去掉一些停用词、数字、特殊符号。最终返回相对干净的数据集和标签集。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;分析数据&lt;/h3&gt;
&lt;p&gt;前面两篇文章都介绍了，我们需要把文档进行向量化表示，首先构建全部文章的单词集合，实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'''获取所有文档单词的集合'''
def createVocabList(dataSet):
    vocabSet = set([])
    for document in dataSet:
        vocabSet = vocabSet | set(document)  # 操作符 | 用于求两个集合的并集
    # print(len(vocabSet),len(set(vocabSet)))
    return list(vocabSet)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于文档模型的基础上，我们将特征向量转化为数据矩阵向量，这里使用的词袋模型，构造与实现方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'''文档词袋模型，创建矩阵数据'''
def bagOfWords2VecMN(vocabList, inputSet):
    returnVec = [0] * len(vocabList)
    for word in inputSet:
        if word in vocabList:
            returnVec[vocabList.index(word)] += 1
    return returnVec
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对矩阵数据可以采用可视化分析方法或者结合NLTK进行数据分析，检查数据分布情况和特征向量构成情况及其特征选择作为参考。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;训练算法&lt;/h3&gt;
&lt;p&gt;我们在前面两篇文章介绍了朴素贝叶斯模型训练方法，我们在该方法下稍微改动就得到如下实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'''朴素贝叶斯模型训练数据优化'''
def trainNB0(trainMatrix, trainCategory):
    numTrainDocs = len(trainMatrix) # 总文件数
    numWords = len(trainMatrix[0]) # 总单词数

    p1Num=p2Num=p3Num=p4Num=p5Num = ones(numWords) # 各类为1的矩阵
    p1Denom=p2Denom=p3Denom=p4Denom=p5Denom = 2.0 # 各类特征和
    num1=num2=num3=num4=num5 = 0 # 各类文档数目

    pNumlist=[p1Num,p2Num,p3Num,p4Num,p5Num]
    pDenomlist =[p1Denom,p2Denom,p3Denom,p4Denom,p5Denom]
    Numlist = [num1,num2,num3,num4,num5]

    for i in range(numTrainDocs): # 遍历每篇训练文档
        for j in range(5): # 遍历每个类别
            if trainCategory[i] == j: # 如果在类别下的文档
                pNumlist[j] += trainMatrix[i] # 增加词条计数值
                pDenomlist[j] += sum(trainMatrix[i]) # 增加该类下所有词条计数值
                Numlist[j] +=1 # 该类文档数目加1

    pVect,pi = [],[]
    for index in range(5):
        pVect.append(log(pNumlist[index] / pDenomlist[index]))
        pi.append(Numlist[index] / float(numTrainDocs))
    return pVect, pi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建分类函数，其优化后的代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'''朴素贝叶斯分类函数,将乘法转换为加法'''
def classifyNB(vec2Classify, pVect,pi):
    # 计算公式  log(P(F1|C))+log(P(F2|C))+....+log(P(Fn|C))+log(P(C))
    bnpi = [] # 文档分类到各类的概率值列表
    for x in range(5):
        bnpi.append(sum(vec2Classify * pVect[x]) + log(pi[x]))
    # print([bnp for bnp in bnpi])
    # 分类集合
    reslist = ['Art','Literature','Education','Philosophy','History']
    # 根据最大概率，选择索引值
    index = [bnpi.index(res) for res in bnpi if res==max(bnpi)]
    return reslist[index[0]] # 返回分类值
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;测试算法&lt;/h3&gt;
&lt;p&gt;我们加载构建的数据集方法，然后创建单词集合，集合词袋模型进行特征向量化，构建训练模型和分类方法，最终我们从复旦新闻语料中选择一篇未加入训练集的教育类文档，进行开放测试，具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'''朴素贝叶斯新闻分类应用'''
def testingNB():
    # 1. 加载数据集
    dataSet,Classlabels = loadDataSet()
    # 2. 创建单词集合
    myVocabList = createVocabList(dataSet)

    # 3. 计算单词是否出现并创建数据矩阵
    trainMat = []
    for postinDoc in dataSet:
        trainMat.append(bagOfWords2VecMN(myVocabList, postinDoc))
    with open('./word-bag.txt','w') as f:
        for i in trainMat:
            f.write(str(i)+'\r\n')
    # 4. 训练数据
    pVect,pi= trainNB0(array(trainMat), array(Classlabels))
    # 5. 测试数据
    testEntry = textParse(open('./fudan/test/C5-1.txt',encoding='UTF-8').read())
    thisDoc = array(bagOfWords2VecMN(myVocabList, testEntry))
    print(testEntry[:10], '分类结果是: ', classifyNB(thisDoc, pVect,pi))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Building prefix dict from the default dictionary ...
Loading model from cache C:\Users\ADMINI~1\AppData\Local\Temp\jieba.cache
Loading model cost 0.892 seconds.
Prefix dict has been built succesfully.
['全国/n ', '举办/v ', '电影/n ', '新华社/nt ', '北京/ns ', '国家教委/nt ', '广播电影电视部/nt ', '文化部/n ', '联合/v ', '决定/v '] 分类结果是:  Literature
耗时：29.4882 s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果分析：我们运行分类器得出结果易知，预测结果是文化类，且运行时间为29s。首先分析为什么预测错误，这里面主要是训练集样本比较少和特征选择的原因。运行时间是由于将特征矩阵存储本地后，后面直接读取文本，相当于加载缓存，大大缩短运行时间。但是这里还有值得优化的地方，比如每次运行都会加载训练模型，大大消耗时间，我们能不能训练模型加载一次，多次调用呢？当然是可以的，这个问题下文继续优化。我们重点关注下特征选择问题&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;特征选择问题讨论&lt;/h3&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;做文本分类的时候，遇到特征矩阵1.5w。在测试篇幅小的文章总是分类错误？这个时候如何做特征选择？是不是说去掉特征集中频率极高和极低的一部分，对结果有所提升？&lt;br/&gt;答：你说的这个情况是很普遍的现象，篇幅小的文章，特征小，所以模型更容易判断出错！去掉高频和低频通常是可以使得训练的模型泛化能力变强&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;比如：艺术，文化，历史，教育。界限本来就不明显，比如测试数据“我爱艺术，艺术是我的全部”。结果会分类为文化。其实这个里面还有就是不同特征词的权重问题，采用tf-idf优化下应该会好一些？&lt;/p&gt;
&lt;p&gt;答：我个人觉得做文本特征提取，还是需要自己去分析文本本身内容的文字特点，你可以把每一类的文本的实体提取出来，然后统计一下每个词在每一类上的数量，看看数量分布，也许可以发现一些数据特点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我就是按照这个思路做的，还有改进时候的停用词，其实可以分析特征文本，针对不同业务，使用自定义的停用词要比通用的好&lt;br/&gt;还有提前各类见最具表征性的词汇加权，凸显本类的权重是吧？&lt;br/&gt;答：比如，艺术类文章中，哪些词出现较多，哪些词出现少，再观察这些词的词性主要是哪些，这样可能会对你制定提取特征规则方式的时候提供一定的思路参考，我可以告诉你的是，有些词绝对会某一类文章出出现多，然后在其他类文章出现很少，这一类的词就是文章的特征词&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;那样的思路可以是：对某类文章单独构建类内的词汇表再进行选择。最后对类间词汇表叠加就ok了。&lt;br/&gt;答：词汇表有个缺点就是，不能很好的适应新词&lt;/li&gt;
&lt;li&gt;改进思路呢&lt;br/&gt;答：我给你一个改进思路：你只提取每个文本中的名词、动词、形容词、地名，用这些词的作为文本的特征来训练试一试，用文本分类用主题模型（LDA）来向量化文本，再训练模型试一试。如果效果还是不够好，再将文本向量用PCA进行一次特征降维，然后再训练模型试一试，按常理来说，效果应该会有提高&lt;/li&gt;
&lt;li&gt;还有我之前个人写的程序分类效果不理想，后来改用sklearn内置BN运行依旧不理想。适当改进了特征提取，还是不理想。估计每类10篇文章的训练数据太少了&lt;br/&gt;答：文本本身特征提取就相对难一些，再加上训练数据少，训练出来的模型效果可想而已，正常的&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;sklearn-&quot;&gt;sklearn：朴素贝叶斯分类调用&lt;/h2&gt;
&lt;h3 id=&quot;-&quot;&gt;数据准备和数据预处理&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;加载文档数据集和分类集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据准备和数据预处理上文已经介绍了，本节增加了一个全局变量存储词汇表，目的是写入到本地文本里，本地读取词汇集，避免每次都做特征向量时加载训练集，提高运行时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;myVocabList = [] # 设置词汇表的全局变量

'''创建数据集和类标签'''
def loadDataSet():
    docList = [];classList = []  # 文档列表、类别列表、文本特征
    dirlist = ['C3-Art','C4-Literature','C5-Education','C6-Philosophy','C7-History']
    for j in range(5):
        for i in range(1, 11): # 总共10个文档
            # 切分，解析数据，并归类为 1 类别
            wordList = textParse(open('./fudan/%s/%d.txt' % (dirlist[j],i),encoding='UTF-8').read())
            docList.append(wordList)
            classList.append(j)
            # print(i,'\t','./fudan/%s/%d.txt' % (dirlist[j],i),'\t',j)
    # print(len(docList),len(classList),len(fullText))
    global myVocabList
    myVocabList = createVocabList(docList)  # 创建单词集合
    return docList,classList,myVocabList



''' 利用jieba对文本进行分词，返回切词后的list '''
def textParse(str_doc): #与上文方法一致


''' 去掉一些停用词、数字、特殊符号 '''
def rm_tokens(words, stwlist):  #与上文方法一致
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文档数据集和分类集在本地读写操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;# 本地存储数据集和标签
def storedata():
    # 3. 计算单词是否出现并创建数据矩阵
    # trainMat =[[0,1,2,3],[2,3,1,5],[0,1,4,2]] # 训练集
    # classList = [0,1,2] #类标签
    docList,classList,myVocabList = loadDataSet()
    # 计算单词是否出现并创建数据矩阵
    trainMat = []
    for postinDoc in docList:
        trainMat.append(bagOfWords2VecMN(myVocabList, postinDoc))
    res = &quot;&quot;
    for i in range(len(trainMat)):
        res +=' '.join([str(x) for x in trainMat[i]])+' '+str(classList[i])+'\n'
    # print(res[:-1]) # 删除最后一个换行符
    with open('./word-bag.txt','w') as fw:
        fw.write(res[:-1])
    with open('./wordset.txt','w') as fw:
        fw.write(' '.join([str(v) for v in myVocabList]))


# 读取本地数据集和标签
    def grabdata():
        f = open('./word-bag.txt') # 读取本地文件
        arrayLines = f.readlines() # 行向量
        tzsize = len(arrayLines[0].split(' '))-1 # 列向量，特征个数减1即数据集
        returnMat = zeros((len(arrayLines),tzsize))    # 0矩阵数据集
        classLabelVactor = []                     # 标签集，特征最后一列

        index = 0
        for line in arrayLines: # 逐行读取
            listFromLine = line.strip().split(' ')    # 分析数据，空格处理
            # print(listFromLine)
            returnMat[index,:] = listFromLine[0:tzsize] # 数据集
            classLabelVactor.append(int(listFromLine[-1])) # 类别标签集
            index +=1
        # print(returnMat,classLabelVactor)
        myVocabList=writewordset()
        return returnMat,classLabelVactor,myVocabList

    def writewordset():
        f1 = open('./wordset.txt')
        myVocabList =f1.readline().split(' ')
        for w in myVocabList:
            if w=='':
                myVocabList.remove(w)
        return myVocabList
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;获取文档集合和构建词袋模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;'''获取所有文档单词的集合'''
def createVocabList(dataSet):
    vocabSet = set([])
    for document in dataSet:
        vocabSet = vocabSet | set(document)  # 操作符 | 用于求两个集合的并集
    # print(len(vocabSet),len(set(vocabSet)))
    return list(vocabSet)



'''文档词袋模型，创建矩阵数据'''
def bagOfWords2VecMN(vocabList, inputSet):
    returnVec = [0] * len(vocabList)
    for word in inputSet:
        if word in vocabList:
            returnVec[vocabList.index(word)] += 1
    return returnVec
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;高斯朴素贝叶斯&lt;/h3&gt;
&lt;p&gt;GaussianNB 实现了运用于分类的高斯朴素贝叶斯算法。特征的可能性(即概率)假设为高斯分布:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{120}&amp;amp;space;P(x_i&amp;amp;space;/mid&amp;amp;space;y)&amp;amp;space;=&amp;amp;space;/frac{1}{/sqrt{2/pi/sigma^2_y}}&amp;amp;space;/exp/left(-/frac{(x_i&amp;amp;space;-&amp;amp;space;/mu_y)^2}{2/sigma^2_y}/right)&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;P(x_i \mid y) = \frac{1}{\sqrt{2\pi\sigma^2_y}} \exp\left(-\frac{(x_i - \mu_y)^2}{2\sigma^2_y}\right)&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{120}&amp;amp;space;P(x_i&amp;amp;space;/mid&amp;amp;space;y)&amp;amp;space;=&amp;amp;space;/frac{1}{/sqrt{2/pi/sigma^2_y}}&amp;amp;space;/exp/left(-/frac{(x_i&amp;amp;space;-&amp;amp;space;/mu_y)^2}{2/sigma^2_y}/right)&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参数&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{120}&amp;amp;space;/sigma_y&amp;amp;space;,/mu_y&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;\sigma_y ,\mu_y&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{90}&amp;amp;space;/sigma_y&amp;amp;space;,/mu_y&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;使用最大似然法估计。&lt;/p&gt;
&lt;p&gt;高斯朴素贝叶斯实现方法代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'''高斯朴素贝叶斯'''
def MyGaussianNB(trainMat='',Classlabels='',testDoc=''):
    # -----sklearn GaussianNB-------
    # 训练数据
    X = np.array(trainMat)
    Y = np.array(Classlabels)
    # 高斯分布
    clf = GaussianNB()
    clf.fit(X, Y)
    # 测试预测结果
    index = clf.predict(testDoc) # 返回索引
    reslist = ['Art','Literature','Education','Philosophy','History']
    print(reslist[index[0]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;多项朴素贝叶斯&lt;/h3&gt;
&lt;p&gt;MultinomialNB 实现了服从多项分布数据的朴素贝叶斯算法，也是用于文本分类(这个领域中数据往往以词向量表示，尽管在实践中 tf-idf 向量在预测时表现良好)的两大经典朴素贝叶斯算法之一。 分布参数由每类 y 的 &lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{90}&amp;amp;space;/theta_y&amp;amp;space;=&amp;amp;space;(/theta_{y1},/ldots,/theta_{yn})&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;\theta_y = (\theta_{y1},\ldots,\theta_{yn})&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{90}&amp;amp;space;/theta_y&amp;amp;space;=&amp;amp;space;(/theta_{y1},/ldots,/theta_{yn})&quot; alt=&quot;&quot;/&gt;&lt;/a&gt; 向量决定， 式中 n 是特征的数量(对于文本分类，是词汇量的大小)&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{90}&amp;amp;space;/theta_{yi}&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;\theta_{yi}&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{90}&amp;amp;space;/theta_{yi}&quot; alt=&quot;&quot;/&gt;&lt;/a&gt; 是样本中属于类 y 中特征 i 概率&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{90}&amp;amp;space;P(x_i&amp;amp;space;/mid&amp;amp;space;y)&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;P(x_i \mid y)&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{90}&amp;amp;space;P(x_i&amp;amp;space;/mid&amp;amp;space;y)&quot; alt=&quot;&quot;/&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;参数 &lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{100}&amp;amp;space;/theta_y&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;\theta_y&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{90}&amp;amp;space;/theta_y&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;使用平滑过的最大似然估计法来估计，即相对频率计数:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{120}&amp;amp;space;/hat{/theta}_{yi}&amp;amp;space;=&amp;amp;space;/frac{&amp;amp;space;N_{yi}&amp;amp;space;+&amp;amp;space;/alpha}{N_y&amp;amp;space;+&amp;amp;space;/alpha&amp;amp;space;n}&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;\hat{\theta}_{yi} = \frac{ N_{yi} + \alpha}{N_y + \alpha n}&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{120}&amp;amp;space;/hat{/theta}_{yi}&amp;amp;space;=&amp;amp;space;/frac{&amp;amp;space;N_{yi}&amp;amp;space;+&amp;amp;space;/alpha}{N_y&amp;amp;space;+&amp;amp;space;/alpha&amp;amp;space;n}&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;式中&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{100}&amp;amp;space;N_{yi}&amp;amp;space;=&amp;amp;space;/sum_{x&amp;amp;space;/in&amp;amp;space;T}&amp;amp;space;x_i&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;N_{yi} = \sum_{x \in T} x_i&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{80}&amp;amp;space;N_{yi}&amp;amp;space;=&amp;amp;space;/sum_{x&amp;amp;space;/in&amp;amp;space;T}&amp;amp;space;x_i&quot; alt=&quot;&quot;/&gt;&lt;/a&gt; 是 训练集 T 中 特征 i 在类 y 中出现的次数，&lt;br/&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{100}&amp;amp;space;N_{y}&amp;amp;space;=&amp;amp;space;/sum_{i=1}^{|T|}&amp;amp;space;N_{yi}&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;N_{y} = \sum_{i=1}^{|T|} N_{yi}&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{80}&amp;amp;space;N_{y}&amp;amp;space;=&amp;amp;space;/sum_{i=1}^{|T|}&amp;amp;space;N_{yi}&quot; alt=&quot;&quot;/&gt;&lt;/a&gt; 是类 y 中出现所有特征的计数总和。&lt;br/&gt;先验平滑因子&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{100}&amp;amp;space;/alpha&amp;amp;space;/ge&amp;amp;space;0&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;\alpha \ge 0&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{100}&amp;amp;space;/alpha&amp;amp;space;/ge&amp;amp;space;0&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;应用于在学习样本中没有出现的特征，以防在将来的计算中出现0概率输出。 把 &lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{100}&amp;amp;space;/alpha&amp;amp;space;=&amp;amp;space;1&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;\alpha = 1&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{100}&amp;amp;space;/alpha&amp;amp;space;=&amp;amp;space;1&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;被称为拉普拉斯平滑(Lapalce smoothing)，而 &lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{100}&amp;amp;space;/alpha&amp;amp;space;%3C&amp;amp;space;1&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;\alpha &amp;lt; 1&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{100}&amp;amp;space;/alpha&amp;amp;space;%3C&amp;amp;space;1&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;被称为利德斯通(Lidstone smoothing)。&lt;/p&gt;
&lt;p&gt;多项朴素贝叶斯实现方法代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'''多项朴素贝叶斯'''
def MyMultinomialNB(trainMat='',Classlabels='',testDoc=''):
    # -----sklearn MultinomialNB-------
    # 训练数据
    X = np.array(trainMat)
    Y = np.array(Classlabels)
    # 多项朴素贝叶斯
    clf = MultinomialNB()
    clf.fit(X, Y)
    # 测试预测结果
    index = clf.predict(testDoc) # 返回索引
    reslist = ['Art','Literature','Education','Philosophy','History']
    print(reslist[index[0]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;伯努利朴素贝叶斯&lt;/h3&gt;
&lt;p&gt;BernoulliNB 实现了用于多重伯努利分布数据的朴素贝叶斯训练和分类算法，即有多个特征，但每个特征 都假设是一个二元 (Bernoulli, boolean) 变量。 因此，这类算法要求样本以二元值特征向量表示；如果样本含有其他类型的数据， 一个 BernoulliNB 实例会将其二值化(取决于 binarize 参数)。伯努利朴素贝叶斯的决策规则基于&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=/dpi{100}&amp;amp;space;P(x_i&amp;amp;space;/mid&amp;amp;space;y)&amp;amp;space;=&amp;amp;space;P(i&amp;amp;space;/mid&amp;amp;space;y)&amp;amp;space;x_i&amp;amp;space;+&amp;amp;space;(1&amp;amp;space;-&amp;amp;space;P(i&amp;amp;space;/mid&amp;amp;space;y))&amp;amp;space;(1&amp;amp;space;-&amp;amp;space;x_i)&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;P(x_i \mid y) = P(i \mid y) x_i + (1 - P(i \mid y)) (1 - x_i)&quot; src=&quot;http://latex.codecogs.com/gif.latex?/dpi{100}&amp;amp;space;P(x_i&amp;amp;space;/mid&amp;amp;space;y)&amp;amp;space;=&amp;amp;space;P(i&amp;amp;space;/mid&amp;amp;space;y)&amp;amp;space;x_i&amp;amp;space;+&amp;amp;space;(1&amp;amp;space;-&amp;amp;space;P(i&amp;amp;space;/mid&amp;amp;space;y))&amp;amp;space;(1&amp;amp;space;-&amp;amp;space;x_i)&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;与多项分布朴素贝叶斯的规则不同 伯努利朴素贝叶斯明确地惩罚类 y 中没有出现作为预测因子的特征 i ，而多项分布分布朴素贝叶斯只是简单地忽略没出现的特征。&lt;/p&gt;
&lt;p&gt;在文本分类的例子中，词频向量(word occurrence vectors)(而非词数向量(word count vectors))可能用于训练和用于这个分类器。 BernoulliNB 可能在一些数据集上可能表现得更好，特别是那些更短的文档。 如果时间允许，建议对两个模型都进行评估。&lt;/p&gt;
&lt;p&gt;伯努利朴素贝叶斯代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'''伯努利朴素贝叶斯'''
def MyBernoulliNB(trainMat='',Classlabels='',testDoc=''):
    # -----sklearn BernoulliNB-------
    # 训练数据
    X = np.array(trainMat)
    Y = np.array(Classlabels)
    # 多项朴素贝叶斯
    clf = BernoulliNB()
    clf.fit(X, Y)
    # 测试预测结果
    index = clf.predict(testDoc) # 返回索引
    reslist = ['Art','Literature','Education','Philosophy','History']
    print(reslist[index[0]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;各种贝叶斯模型分类测试&lt;/h3&gt;
&lt;p&gt;代码实现如下：&lt;br/&gt;def testingNB():&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 加载数据集和单词集合
trainMat,Classlabels,myVocabList = grabdata() # 读取训练结果
# 测试数据
testEntry = textParse(open('./fudan/test/C6-2.txt',encoding='UTF-8').read())
testDoc = np.array(bagOfWords2VecMN(myVocabList, testEntry)) # 测试数据
# 测试预测结果
MyGaussianNB(trainMat,Classlabels,testDoc)
MyMultinomialNB(trainMat,Classlabels,testDoc)
MyBernoulliNB(trainMat,Classlabels,testDoc)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Building prefix dict from the default dictionary ...
Loading model from cache C:\Users\ADMINI~1\AppData\Local\Temp\jieba.cache
Loading model cost 1.014 seconds.
Prefix dict has been built succesfully.
高斯朴素贝叶斯：Education
多项朴素贝叶斯分类结果：Art
伯努利朴素贝叶斯分类结果：Literature
耗时：2.3996 s
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;scikit中文社区：&lt;a href=&quot;http://sklearn.apachecn.org/cn/0.19.0/&quot;&gt;http://sklearn.apachecn.org/cn/0.19.0/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文维基百科：&lt;a href=&quot;https://zh.wikipedia.org/wiki/&quot;&gt;https://zh.wikipedia.org/wiki/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;文本分类特征选择：&lt;a href=&quot;https://www.cnblogs.com/june0507/p/7601001.html&quot;&gt;https://www.cnblogs.com/june0507/p/7601001.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub：&lt;a href=&quot;https://github.com/BaiNingchao/MachineLearning-1&quot;&gt;https://github.com/BaiNingchao/MachineLearning-1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;图书：《机器学习实战》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E6%88%98&quot;&gt;图书：《自然语言处理理论与实战》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;-&quot;&gt;完整代码下载&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;源码请进【机器学习和自然语言QQ群：436303759】文件下载：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/Fl1W5mB.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;
&lt;h2 id=&quot;-&quot;&gt;作者声明&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文版权归作者白宁超所有，本文原创，旨在学术和科研使用。文章同步如下：&lt;/p&gt;
&lt;/blockquote&gt;





</description>
<pubDate>Tue, 04 Sep 2018 07:47:00 +0000</pubDate>
<dc:creator>伏草惟存</dc:creator>
<og:description>朴素贝叶斯模型是机器学习常用的模型算法之一，其在文本分类方面简单易行，且取得不错的分类效果。所以很受欢迎，对于朴素贝叶斯的学习，本文首先介绍理论知识即朴素贝叶斯相关概念和公式推导，为了加深理解，采用一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baiboy/p/pybnc4-3.html</dc:identifier>
</item>
<item>
<title>SpringCloud Ribbon的分析 - XuMinzhe</title>
<link>http://www.cnblogs.com/xmzJava/p/9583991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xmzJava/p/9583991.html</guid>
<description>&lt;p&gt;　　Spring Cloud Ribbon主要用于客户端的负载均衡。最基本的用法便是使用RestTemplate进行动态的负载均衡。我们只需要加入如下的配置便能完成客户端的负载均衡。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RestConfiguration {
    @Bean
    &lt;strong&gt;@LoadBalanced
    &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;strong&gt;Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient&lt;/strong&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Spencer Gibb
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Qualifier
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; LoadBalanced {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里的&lt;code&gt;@LoadBalanced使得&lt;/code&gt;&lt;code&gt;RestTemplate&lt;/code&gt;可以使用&lt;code&gt;LoadBalancerClient，&lt;/code&gt;在&lt;code&gt;LoadBalancerClient&lt;/code&gt;在这个路劲下，还存在着&lt;code&gt;LoadBalancerAutoConfiguration&lt;/code&gt;这个配置类只要用于对&lt;code&gt;LoadBalancerClient&lt;/code&gt;做出配置。我们就以此为入口，开始分析ribbon&lt;/p&gt;

&lt;h3&gt;LoadBalancer的自动化配置&lt;/h3&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;@Configuration
&lt;strong&gt;@ConditionalOnClass(RestTemplate.&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ConditionalOnBean(LoadBalancerClient.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;)&lt;/strong&gt;
@EnableConfigurationProperties(LoadBalancerRetryProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoadBalancerAutoConfiguration {

    @LoadBalanced
    @Autowired(required &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;RestTemplate&amp;gt; restTemplates =&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; Collections.emptyList();&lt;/strong&gt;

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SmartInitializingSingleton loadBalancedRestTemplateInitializer(
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; List&amp;lt;RestTemplateCustomizer&amp;gt;&lt;span&gt; customizers) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SmartInitializingSingleton() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterSingletonsInstantiated() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (RestTemplate restTemplate : LoadBalancerAutoConfiguration.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.restTemplates) {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RestTemplateCustomizer customizer : customizers) {
                        customizer.customize(restTemplate);
                    }
                }
            }
        };
    }

    @Autowired(required &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;LoadBalancerRequestTransformer&amp;gt; transformers =&lt;span&gt; Collections.emptyList();

    @Bean
    @ConditionalOnMissingBean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerRequestFactory loadBalancerRequestFactory(
            LoadBalancerClient loadBalancerClient) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadBalancerRequestFactory(loadBalancerClient, transformers);
    }

    @Configuration
    @ConditionalOnMissingClass(&lt;/span&gt;&quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptorConfig {
        @Bean
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&lt;strong&gt; LoadBalancerInterceptor&lt;/strong&gt; ribbonInterceptor(
                LoadBalancerClient loadBalancerClient,
                LoadBalancerRequestFactory requestFactory) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor(loadBalancerClient, requestFactory);
        }

        @Bean
        @ConditionalOnMissingBean
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&lt;strong&gt; RestTemplateCustomizer&lt;/strong&gt; restTemplateCustomizer(
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt;&lt;strong&gt; LoadBalancerInterceptor&lt;/strong&gt; loadBalancerInterceptor) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplateCustomizer() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; customize(RestTemplate restTemplate) {
                    List&lt;/span&gt;&amp;lt;ClientHttpRequestInterceptor&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(
                            restTemplate.getInterceptors());
                    list.add(loadBalancerInterceptor);
                    restTemplate.setInterceptors(list);
                }
            };
        }
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个配置类主要做了以下几件事&lt;/p&gt;
&lt;p&gt;1.创建了一个&lt;code&gt;LoadBalancerInterceptor&lt;/code&gt;的bean，用于实现对客户端发起请求时进行拦截，以实现客户端负载均衡。&lt;/p&gt;
&lt;p&gt;2.创建了一个&lt;code&gt;RestTemplateCustomizer&lt;/code&gt;的bean，用于给RestTemplate增加&lt;code&gt;LoadBalancerInterceptor&lt;/code&gt;拦截器。&lt;/p&gt;
&lt;p&gt;3.维护一个&lt;code&gt;@LoadBalanced&lt;/code&gt;注解修饰的&lt;code&gt;RestTemplate&lt;/code&gt;对象列表，并在这里进行维护，通过调用&lt;code&gt;RestTemplateCustomizer&lt;/code&gt;的实例来给需要的客户端负载均衡的&lt;code&gt;RestTemplate&lt;/code&gt;增加&lt;code&gt;LoadBalancerInterceptor&lt;/code&gt;拦截器。&lt;/p&gt;

&lt;p&gt;现在我们看下 LoadBalancerInterceptor 的拦截，我们在这里打上断点，查看一个 RestTemplate 请求是怎么被拦截的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138295/201809/1138295-20180904142029144-510437236.png&quot; alt=&quot;&quot; width=&quot;855&quot; height=&quot;137&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138295/201809/1138295-20180904142247463-1072934389.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;221&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在 &lt;code&gt;org.springframework.http.client.InterceptingClientHttpRequest.InterceptingRequestExecution#execute&lt;/code&gt; 发现了如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator.hasNext()) {
                ClientHttpRequestInterceptor nextInterceptor &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator.next();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextInterceptor.intercept(request, body, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里和mybatis比较类似，都是通过责任链模式，一层层的拦截。最终就会到LoadBalancerInterceptor。现在再看LoadBalancerInterceptor的intercept方法&lt;/p&gt;
&lt;p&gt;前两步是分别获取这个request的请求地址和ServiceName,这里截图供参考&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138295/201809/1138295-20180904143612213-530677202.png&quot; alt=&quot;&quot; width=&quot;1089&quot; height=&quot;56&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最开始我们说过，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@LoadBalanced使得&lt;/code&gt;&lt;code&gt;RestTemplate&lt;/code&gt;可以使用&lt;code&gt;LoadBalancerClient，就是在这里使用LoadBalancerClient的executor方法，做出具体的负载均衡。由于这里的LoadBalancerClient是一个接口，他具体的实现类是&lt;/code&gt;RibbonLoadBalancerClient，我们在这里分析具体的execute方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T execute(String serviceId, LoadBalancerRequest&amp;lt;T&amp;gt; request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        ILoadBalancer loadBalancer &lt;/span&gt;=&lt;span&gt; getLoadBalancer(serviceId);
        &lt;strong&gt;Server server &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;=&lt;span&gt; getServer(loadBalancer);
        &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;if&lt;/span&gt; (server == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;No instances available for &quot; +&lt;span&gt; serviceId);
        }
        RibbonServer ribbonServer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonServer(serviceId, server, isSecure(server,
                serviceId), serverIntrospector(serviceId).getMetadata(server));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; execute(serviceId, ribbonServer, request);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第一步获取 loadBalancer,loadBalancer是定义软件负载均衡器操作的接口，有以下方法。默认配置的是使用 ZoneAwareLoadBalancer 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ILoadBalancer {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向负载均衡器中维护的实例列表增加服务实例&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addServers(List&amp;lt;Server&amp;gt;&lt;span&gt; newServers);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从负载均衡器中挑选出一个具体的服务实例&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Server chooseServer(Object key);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来通知和标记负载均衡器中的某个具体实例已经停止服务，不然负载均衡器在下一次获取服务实例清单前都会认为服务实例均是正常服务的。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; markServerDown(Server server);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前正常服务的实例列表&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;Server&amp;gt;&lt;span&gt; getReachableServers();

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有已知的服务实例列表，包括正常服务和停止服务实例。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;Server&amp;gt;&lt;span&gt; getAllServers();
}
&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二步是根据一定的算法去获取server，这一步也是整个ribbon的核心，关于具体的算法逻辑，我们后面分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Server getServer(ILoadBalancer loadBalancer) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loadBalancer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; loadBalancer.chooseServer(&quot;default&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: better handling of key&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步 在获取到Server后包装成一个 RibbonServer&lt;/p&gt;

&lt;p&gt;一个具体的server被选出来后，便可以接着请求，这时会将剩下的拦截器走完&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&amp;lt;T&amp;gt; request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        Server server &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(serviceInstance &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RibbonServer) {
            server &lt;/span&gt;=&lt;span&gt; ((RibbonServer)serviceInstance).getServer();
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (server == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;No instances available for &quot; +&lt;span&gt; serviceId);
        }
        RibbonLoadBalancerContext context &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientFactory
                .getLoadBalancerContext(serviceId);
        RibbonStatsRecorder statsRecorder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonStatsRecorder(context, server);
　　　   &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
           &lt;strong&gt; T returnVal &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; request.apply(serviceInstance);&lt;/strong&gt;
            statsRecorder.recordStats(returnVal);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnVal;
        }&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最终，创建出一个具体的请求并执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; ClientHttpResponse execute(HttpRequest request, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator.hasNext()) {
                ClientHttpRequestInterceptor nextInterceptor &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator.next();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextInterceptor.intercept(request, body, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
              &lt;strong&gt;  ClientHttpRequest delegate &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;=&lt;span&gt; requestFactory.createRequest(request.getURI(), request.getMethod());
                &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;&lt;span&gt; entry : request.getHeaders().entrySet()) {
                    List&lt;/span&gt;&amp;lt;String&amp;gt; values =&lt;span&gt; entry.getValue();
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String value : values) {
                        delegate.getHeaders().add(entry.getKey(), value);
                    }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (body.length &amp;gt; 0&lt;span&gt;) {
                    StreamUtils.copy(body, delegate.getBody());
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegate.execute();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上就是对ribbon大致流程的分析&lt;/p&gt;

</description>
<pubDate>Tue, 04 Sep 2018 07:30:00 +0000</pubDate>
<dc:creator>XuMinzhe</dc:creator>
<og:description>Spring Cloud Ribbon主要用于客户端的负载均衡。最基本的用法便是使用RestTemplate进行动态的负载均衡。我们只需要加入如下的配置便能完成客户端的负载均衡。 这里的@LoadBa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xmzJava/p/9583991.html</dc:identifier>
</item>
<item>
<title>Webpack4干货分享：第一部分，入口、输入和ES6模块 - 葡萄城技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/9584302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/9584302.html</guid>
<description>&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.grapecity.com.cn/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;葡萄城官网&lt;/a&gt;，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。&lt;/p&gt;
&lt;p&gt;原文出处：https://wanago.io/2018/07/16/webpack-4-course-part-one-entry-output-and-es6-modules/&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;你好！今天我们会开始一个 Webpack 4的入门教程。我们会以Webpack的基本概念开始，随着教程逐渐深入。这一次，我们将学习用ES6 modules进行模块化的基础知识。Webpack 4提供了默认配置，我们会逐步学习。让我们开始吧！&lt;/p&gt;
&lt;h2 id=&quot;articleHeader0&quot;&gt;Webpack 4教程开始 - 且慢，什么是Webpack？&lt;/h2&gt;
&lt;p&gt;在考虑使用任何工具之前，你需要问自己一个非常重要的问题：这个工具解决了你的什么问题。Webpack是一个模块打包器。这意味着，它的目的是（根据它们之间的依赖）合并一组模块。它的输出可能是一个或多个文件。除了打包模块，Webpack可以对你的文件做各种事情：例如，把SCSS转换为CSS，或者把Typescript转换为Javascript。它甚至可以压缩你所有的图像文件！但是，你究竟是为什么想要打包它们呢？&lt;/p&gt;
&lt;h3 id=&quot;articleHeader1&quot;&gt;打包的目的&lt;/h3&gt;
&lt;p&gt;在很久之前，除了使用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签，我们没有其他方法把浏览器使用的JavaScript拆分到多个文件。我们需要把用到的每一个JavaScript源文件链接放到HTML代码里。这样并不方便。社区找到了一些变通方案：CommonJS（在Node.js中实现了）和AMD。&lt;a href=&quot;https://auth0.com/blog/javascript-module-systems-showdown/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;有篇文章是关于它们的介绍。而最终，ES6推出了一套全新的 import/export 语法。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader2&quot;&gt;ES6 modules&lt;/h2&gt;
&lt;p&gt;ES6中定义了模块的语法。多亏了它，我们终于有了标准的模块形式，它成为了JavaScript语言规范的一部分。这并不意味着浏览器对此有很好的支持，不过&lt;a href=&quot;https://www.contentful.com/blog/2017/04/04/es6-modules-support-lands-in-browsers-is-it-time-to-rethink-bundling/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;这些正在改进&lt;/a&gt;。即使有了ES6模块的原生支持，你可能还是会想把你的多个模块打包成数量更少的文件。这个教程的目的是提供你开始使用Webpack时所需的所有知识，让我们简单地看看ES6模块的语法。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader3&quot;&gt;export&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;export&lt;/strong&gt;语法被用来创建JavaScript模块。你可以用它来导出对象（包括函数）和原始值（primitive values）。值得注意的是，导出的模块使用了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;严格模式&lt;/a&gt;。导出有两种类型：&lt;strong&gt;named&lt;/strong&gt;和&lt;strong&gt;default&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;Named导出&lt;/h4&gt;
&lt;p&gt;在一个模块中，你可以有多个named导出。&lt;/p&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;注意到，如果要在声明之后导出，你需要把它用花括号包起来，就像上面的例子中&lt;code&gt;divide&lt;/code&gt;函数一样。&lt;/p&gt;
&lt;h4&gt;Default导出&lt;/h4&gt;
&lt;p&gt;一个模块，只能有一个default导出。&lt;/p&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;/&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;articleHeader4&quot;&gt;import&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;import&lt;/strong&gt;语句用来导入其他模块。&lt;/p&gt;
&lt;h4&gt;整个导入&lt;/h4&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;你可以为导出的模块设置任意的名字。如果你整个导入一个含有default导出的模块，那么default导出的东西将会放在导入对象的一个&lt;strong&gt;default&lt;/strong&gt;属性上。&lt;/p&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;/&gt;
&lt;/pre&gt;
&lt;h4&gt;导入一个或多个named导出&lt;/h4&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意，相应的导入导出名字必须匹配。&lt;/p&gt;
&lt;h4&gt;导入一个default导出&lt;/h4&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;注意，defualt导出在导入时，可以用任意的名字。所以我们可以这样做：&lt;/p&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import Cat &lt;span class=&quot;hljs-keyword&quot;&gt;from &lt;span class=&quot;hljs-string&quot;&gt;'./dog.js';

&lt;span class=&quot;hljs-keyword&quot;&gt;const dog = &lt;span class=&quot;hljs-keyword&quot;&gt;new Cat();
dog.bark(); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ES6模块也支持动态导入，我们会在将来的部分讨论到。&lt;/p&gt;
&lt;p&gt;可查看MDN关于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;导出&lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;导入&lt;/a&gt;的文档。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader5&quot;&gt;Webpack的基本概念&lt;/h2&gt;
&lt;p&gt;从版本4开始，Webpack不需要任何配置也可使用。它有一组默认值。如果你想要创建一个配置文件，你可将它命名为&lt;code&gt;webpack.config.js&lt;/code&gt;。我们现在来效仿它的默认配置，对Webpack相关的基本概念做一些解释。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader6&quot;&gt;webpack.config.js&lt;/h3&gt;
&lt;p&gt;注意，我们使用Node.js环境编写Webpack的配置文件，所以它使用了CommonJS类型的模块。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;导出一个单独的对象。如果你通过命令运行Webpack，它将会去寻找并使用这个文件。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader7&quot;&gt;Entry&lt;/h3&gt;
&lt;p&gt;Webpack需要一个入口起点（entry point）。它指明了Webpack从哪一个模块开始打包。它的默认值如下：&lt;/p&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;module.exports = {
  &lt;span class=&quot;hljs-attr&quot;&gt;entry: &lt;span class=&quot;hljs-string&quot;&gt;'./src/index.js'
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它意味着Webpack会找到&lt;code&gt;'./src/index.js'&lt;/code&gt;这个文件，从它开始打包。你在&lt;code&gt;index.js&lt;/code&gt;中使用的任何导入，Webpack都会处理它们。&lt;/p&gt;
&lt;p&gt;你可以有超过一个的入口起点，但对于单页应用（single page applications），它通常只有一个入口。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader8&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;output是用来配置Webpack把你的包输出到哪儿的。它默认输出到&lt;code&gt;'./dist/main.js'&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;/&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;articleHeader9&quot;&gt;运行Webpack&lt;/h2&gt;
&lt;p&gt;在之前的小节，我们创建了&lt;code&gt;index.js&lt;/code&gt;，它导入了&lt;code&gt;lib.js&lt;/code&gt;里的函数。最后让我们运行Webpack吧！记得把这些文件放到&lt;code&gt;src&lt;/code&gt;文件夹下，这样才和默认的设置匹配。&lt;/p&gt;
&lt;p&gt;首先要做的是安装Webpack。我会使用&lt;a href=&quot;https://www.npmjs.com/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;npm&lt;/a&gt;来做它。打开你的终端然后输入:&lt;/p&gt;
&lt;pre class=&quot;bash hljs&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;npm init -y
nppm install webpack webpack-cli&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;译者注：截止到翻译时webpack版本是4.17.1。原文没有加后面的webpack-cli。但是在初次运行webpack时，仍然会提示需要安装webpack-cli或者webpack-command。所有这里选择webpack-cli提前进行安装。和之前再安装效果是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样会创建node_modules文件夹，里面包含Webpack。还有两个文件&lt;code&gt;package.json&lt;/code&gt;和&lt;code&gt;package-lock.json&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;3.8507462686567&quot;&gt;
&lt;p&gt;如你想要知道关于package-lock.json和npm中依赖的更多东西，可查看&lt;a href=&quot;https://wanago.io/2018/05/21/keeping-your-dependencies-in-order-when-using-npm/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Keeping you dependencies in order when using npm&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在打开&lt;code&gt;package.json&lt;/code&gt;文件然后修改它：&lt;/p&gt;
&lt;pre class=&quot;hljs xquery&quot;&gt;
&lt;code&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;scripts&quot;: {
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;build&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;webpack&quot;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于有了上面的修改，运行&lt;code&gt;npm run build&lt;/code&gt;将会使用&lt;code&gt;node_modules&lt;/code&gt;文件夹下的Webpack。&lt;/p&gt;
&lt;p&gt;你可以看到，一个&lt;code&gt;main.js&lt;/code&gt;文件在&lt;code&gt;dist&lt;/code&gt;文件夹下被创建出来。它包含了来自&lt;code&gt;index.js&lt;/code&gt;和&lt;code&gt;lib.js&lt;/code&gt;的所有代码。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader10&quot;&gt;多个入口起点&lt;/h2&gt;
&lt;p&gt;不需要任何配置，就可以实现上面介绍的功能。如果你想做得更多，现在就是时候创建配置文件了。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader11&quot;&gt;entries&lt;/h3&gt;
&lt;p&gt;配置文件里的入口属性，不一定必须是字符串。如果你想要有多个入口，你可以使用一个对象：&lt;/p&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;利用上面代码，我们创建了两个入口起点。如果你是在开发多页应用（multi-page application），可以需要它。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader12&quot;&gt;outputs&lt;/h3&gt;
&lt;p&gt;这有一个问题：默认情况下，只指定了一个输出。我们可以轻易地修改它：&lt;/p&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，我们表明了可以有多余一个的输出文件。现在，所有的输出文件将有各自独特的名字，这个例子中，是&lt;code&gt;first.bundle.js&lt;/code&gt;和&lt;code&gt;second.bundle.js&lt;/code&gt;，就像我们的入口起点。&lt;/p&gt;
&lt;p&gt;如果你按之前方法运行Webpack，它会去找&lt;code&gt;webpack.config.js&lt;/code&gt;文件，并且使用里面的配置。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader13&quot;&gt;Webpack的商业价值&lt;/h3&gt;
&lt;p&gt;目前为止，能跟上ES6和Webpack脚步的产品并不多，笔者了解的有&lt;a href=&quot;https://www.grapecity.com.cn/developer/spreadjs&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;SpreadJS&lt;/a&gt;、&lt;a href=&quot;https://www.grapecity.com.cn/developer/wijmojs&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Wijmo&lt;/a&gt;等，如果你还知道其他的，可以在文章下方留言。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader14&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天我们学习了使用Webpack对ES6模块进行打包的基础知识。Webpack4提供了默认的配置，我们在讨论&lt;strong&gt;entry&lt;/strong&gt;和&lt;strong&gt;output&lt;/strong&gt;概念时解释了其中的一部分。当然，Webpack能做的远比这些多。在接下来的教程里，我们会涉及到loaders，甚至我们自己写一个。敬请期待！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文是由葡萄城技术开发团队发布，转载请注明出处：&lt;a href=&quot;https://www.grapecity.com.cn/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;葡萄城官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本中提到的纯前端开发工具&lt;strong&gt;SpreadJS&lt;/strong&gt;和&lt;strong&gt;Wijmo&lt;/strong&gt;请点击下方深入了解，&lt;/p&gt;
&lt;p&gt;了解可嵌入您系统的在线 Excel，请前往 &lt;a href=&quot;https://www.grapecity.com.cn/developer/spreadjs&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;SpreadJS&lt;/a&gt;&lt;br/&gt;了解全面支持Angular、React和Vue的前端开发工具，请前往 &lt;a href=&quot;https://www.grapecity.com.cn/developer/wijmojs&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;WijmoJS&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 04 Sep 2018 06:40:00 +0000</pubDate>
<dc:creator>葡萄城技术团队</dc:creator>
<og:description>今天我们会开始一个 Webpack 4的入门教程。我们会以Webpack的基本概念开始，随着教程逐渐深入。这一次，我们将学习用ES6 modules进行模块化的基础知识。Webpack 4提供了默认配</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/powertoolsteam/p/9584302.html</dc:identifier>
</item>
<item>
<title>webpack中hash、chunkhash、contenthash区别 - 猴子猿</title>
<link>http://www.cnblogs.com/giggle/p/9583940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/giggle/p/9583940.html</guid>
<description>&lt;p&gt;webpack中对于输出文件名可以有三种hash值：&lt;/p&gt;
&lt;p&gt;1. hash&lt;/p&gt;
&lt;p&gt;2. chunkhash&lt;/p&gt;
&lt;p&gt;3. contenthash&lt;/p&gt;
&lt;p&gt;这三者有什么区别呢？&lt;/p&gt;
&lt;p&gt;如果都使用hash的话，因为这是工程级别的，即每次修改任何一个文件，所有文件名的hash至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/887360/201809/887360-20180904134123992-581664738.png&quot; alt=&quot;&quot; width=&quot;380&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以从上图清晰的看见每个压缩后的文件的hash值是一样的，所以对于没有改变的模块而言，这样做显然不恰当，因为缓存失效了嘛。此时，chunkhash的用途随之而来。&lt;/p&gt;
&lt;p&gt;chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响。并且webpack4中支持了异步import功能，固，chunkhash也作用于此，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/887360/201809/887360-20180904135805932-1678207702.png&quot; alt=&quot;&quot; width=&quot;421&quot; height=&quot;159&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们将各个模块的hash值 (除主干文件) 改为chunkhash，然后重新build一下，可得下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/887360/201809/887360-20180904140120087-728478633.png&quot; alt=&quot;&quot; width=&quot;417&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以清晰地看见每个chunk模块的hash是不一样的了。&lt;/p&gt;
&lt;p&gt;但是这样又有一个问题，因为我们是将样式作为模块import到JavaScript文件中的，所以它们的chunkhash是一致的，如test1.js和test1.css：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/887360/201809/887360-20180904140438870-871123820.png&quot; alt=&quot;&quot; width=&quot;380&quot; height=&quot;252&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就会有个问题，只要对应css或则js改变，与其关联的文件hash值也会改变，但其内容并没有改变呢，所以没有达到缓存意义。固contenthash的用途随之而来。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;contenthash&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;contenthash是针对文件内容级别的，只有你自己模块的内容变了，那么hash值才改变，所以我们可以通过contenthash解决上诉问题。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/887360/201809/887360-20180904141159855-1073612332.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;206&quot;/&gt;&lt;/p&gt;

&lt;p&gt;That's all~&lt;/p&gt;
</description>
<pubDate>Tue, 04 Sep 2018 06:28:00 +0000</pubDate>
<dc:creator>猴子猿</dc:creator>
<og:description>webpack中对于输出文件名可以有三种hash值: hash、chunkhash、contenthash这三者有什么区别呢？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/giggle/p/9583940.html</dc:identifier>
</item>
<item>
<title>Win32文件系统编程 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/9584218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/9584218.html</guid>
<description>&lt;h2&gt;一丶了解什么是文件系统&lt;/h2&gt;
&lt;p&gt;　　文件系统是抽象的.是windows在软件层面提供的一层虚拟的数据结构.&lt;/p&gt;
&lt;p&gt;文件系统分为NTFS 跟 FAT32. 具体看看两者的区别吧.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201809/1197364-20180904123526297-113651135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;磁盘分区容量. &lt;/p&gt;
&lt;p&gt;单个文件容量.  意思就是一个文件可以是多大的. NTFS 是可以4G以上的大文件. FAT32则不可以.&lt;/p&gt;
&lt;p&gt;EFS加密.  这个加密主要针对当前用户的(例如Admins 管理员账户)  具体可以 点击一个文件. 文件-&amp;gt;属性 -&amp;gt; 高级 -&amp;gt; 加密保护文件内容.&lt;/p&gt;
&lt;p&gt;如果在当前用户则不会有什么结果. 但是如果换了用户访问.则不可以访问这个加密文件了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201809/1197364-20180904123821725-1243680791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加密后的文件.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201809/1197364-20180904123852478-1523524577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文件颜色都会改变.&lt;/p&gt;

&lt;p&gt;磁盘配额  意思就是可以限制别的用户访问这个硬盘多少G内存. &lt;/p&gt;
&lt;p&gt;具体设置 xp下  盘符属性-&amp;gt; 配额 &lt;/p&gt;
&lt;p&gt;关于上面的讲解我们只需要了解即可.不深究.具体的的是学习API. API为我们封装好了.我们并不用关心NTFS 或者FAT32&lt;/p&gt;

&lt;h2&gt;二丶Windows提供的操作 &lt;span&gt;&quot;文件&quot;&lt;/span&gt; 的 API&lt;/h2&gt;
&lt;p&gt; 　　标题中文件为什么添加了引号. 意思是不光可以操作文件. 在windows系统中.一切东西都虚拟为了文件. 例如管道 等等.. 都可以使用这些API.&lt;/p&gt;
&lt;p&gt;api具体介绍&lt;/p&gt;
&lt;h3&gt;1.了解卷 文件 跟目录的关系. 卷API&lt;/h3&gt;
&lt;p&gt;　卷指的就是我们的的逻辑硬盘. 例如C盘.&lt;/p&gt;
&lt;p&gt;　目录则是C盘里面的文件夹. 文件夹里面可能还是以文件夹. 也可能是文件.&lt;/p&gt;
&lt;p&gt;卷操作API 很简单. 常用的就四个.&lt;/p&gt;
&lt;p&gt;DWORD GetLogIcalDrives()  获取卷    返回值是10进制.我们需要转化成16进制.然后转换成二进制查看.每一位为1代表有这个磁盘.否则则没有&lt;/p&gt;
&lt;p&gt;GetLogIcalDriveStrings(buffsize,buf) 获取一个卷的盘符的字符串 &lt;/p&gt;
&lt;p&gt;GetDriveType(&quot;&quot;目录名称&quot;) 获取卷的类型&lt;/p&gt;
&lt;p&gt;GetVolumeInformation() 获取卷的类型&lt;/p&gt;
&lt;p&gt;如以下代码例子:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A.cpp : 定义控制台应用程序的入口点。
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Windows.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取磁盘逻辑驱动卷&lt;/span&gt;
    DWORD dwGetDrives =&lt;span&gt; GetLogicalDrives();
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    例如我的返回值是 252 
    转化为16进制  FC
    转化为二进制 11111100   代表我们有六个磁盘.
    CDEFGH  而我的恰好就是 CDEFGH 盘.
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取磁盘卷字符串.&lt;/span&gt;
    TCHAR wszBuf[&lt;span&gt;1024&lt;/span&gt;] =&lt;span&gt; { NULL };
    DWORD dwSize &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;(TCHAR) * &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;
    GetLogicalDriveStringsW(dwSize, wszBuf);  
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        逻辑驱动器返回后会存在wszBuf里面. 自己做分割即可.
        例如 C:\ B:\
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.根据指定盘符获取它的类型. 可以移除的还是不可以移除的.&lt;/span&gt;
    DWORD dwDriveType = GetDriveTypeW(TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体返回值查询MSDN 注意从0开始

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.获取卷的详细信息.&lt;/span&gt;
    DWORD dwVolumneSerial = &lt;span&gt;0&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;驱动卷的序列号(不是硬盘序列号)&lt;/span&gt;
    DWORD dwFileMaxLen = &lt;span&gt;0&lt;/span&gt;;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;系统允许的最大文件名的长度&lt;/span&gt;
    DWORD dwFileSystem = &lt;span&gt;0&lt;/span&gt;;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件系统标识.&lt;/span&gt;
    TCHAR dwFileSystemBuffer[&lt;span&gt;255&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt; };  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件操作系统的名称&lt;/span&gt;
&lt;span&gt;    
    TCHAR szVolName[&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt; }; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回的卷的别名&lt;/span&gt;
&lt;span&gt;    GetVolumeInformationW(
        TEXT(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c:\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; IN参数 你要查看那个卷的信息&lt;/span&gt;
        szVolName,             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; OUT参数. 查询到的卷的别名会给你.例如你的别名是C&lt;/span&gt;
        &lt;span&gt;sizeof&lt;/span&gt;(TCHAR) * &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; IN参数. 上面缓冲区的大小.&lt;/span&gt;
        &amp;amp;dwVolumneSerial,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; OUT 驱动卷的序列号&lt;/span&gt;
        &amp;amp;dwFileMaxLen,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  OUT 写文件读文件等等文件名最大可以是多大.&lt;/span&gt;
        &amp;amp;dwFileSystem,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  OUT 文件操作系统标识.有多中宏组合,具体可以查询MSDN. 标识你这个文件是&lt;/span&gt;
        dwFileSystemBuffer, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;你当前系统是 NTFS 还是FAT32&lt;/span&gt;
        &lt;span&gt;sizeof&lt;/span&gt;(TCHAR) * &lt;span&gt;255&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上面缓冲区的大小.&lt;/span&gt;
&lt;span&gt;    );


    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.文件夹(目录) 操作的相关API&lt;/h3&gt;

&lt;p&gt;CreateDirectory();//创建目录&lt;br/&gt;RemoveDirectory();//删除目录&lt;br/&gt;MoveFile(); //修改目录名称.&lt;br/&gt;GetCurrentDirectory(); //获取进程当前目录&lt;br/&gt;SetCurrentDirectory(); //设置进程当前目录.&lt;/p&gt;
&lt;p&gt;具体代码例子:&lt;/p&gt;
&lt;p&gt;　　  main函数调用即可.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetDirectoryApi()
{
    CreateDirectory(TEXT(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),NULL);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建目录&lt;/span&gt;
    MoveFile(TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改目录名称.&lt;/span&gt;
    RemoveDirectory(TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除目录&lt;/span&gt;
    TCHAR szCurrentDirectoryBuffer[&lt;span&gt;255&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
    DWORD dwBuffsize &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;(TCHAR) * &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;

    GetCurrentDirectory(dwBuffsize, szCurrentDirectoryBuffer); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前目录&lt;/span&gt;
    SetCurrentDirectory(szCurrentDirectoryBuffer); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置当前目录.&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.文件操作相关API&lt;/h3&gt;
&lt;p&gt;CreateFile( ) 创建文件&lt;/p&gt;
&lt;p&gt;DeleteFile();  删除文件&lt;/p&gt;
&lt;p&gt;CloseHandle();  关闭文件句柄&lt;/p&gt;
&lt;p&gt;GetFileSize();  获取文件大小.&lt;/p&gt;
&lt;p&gt;ReadFile();    读文件&lt;/p&gt;
&lt;p&gt;WriteFile();    写文件&lt;/p&gt;
&lt;p&gt;CopyFile();   拷贝文件&lt;/p&gt;
&lt;p&gt;　　具体看如下代码详解参数意义.&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OptFileApi()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建文件&lt;/span&gt;
    HANDLE hFile =&lt;span&gt; CreateFile(
        TEXT(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\123.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;你要创建的文件名 &lt;/span&gt;
        GENERIC_READ | GENERIC_WRITE,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建的这个文件只读模式创建时只写模式创建还是读写都可以.如果只读则不可以写.&lt;/span&gt;
        &lt;span&gt;0&lt;/span&gt;,                                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件共享模式. 意思就是你这个文件创建完毕之后.当前读写只能有一个人在用,其他人不能操作. 为0就是排他. 或者说你可以设置为其他人可以读.&lt;/span&gt;
        NULL,                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  每个内核对象都有的SD安全属性&lt;/span&gt;
        OPEN_EXISTING,                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文件的信息. 你这个文件是文件不存在就创建 还是打开已经存在的. 还是总是创建新的.&lt;/span&gt;
        FILE_ATTRIBUTE_NORMAL,              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建的文件属性.  意思就是我创建的这个文件是隐藏文件啊 还是别的文件. 反正就是属性.&lt;/span&gt;
&lt;span&gt;        NULL
    );
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取文件大小&lt;/span&gt;
    DWORD dwLowSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    DWORD dwHighSize &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    dwLowSize &lt;/span&gt;= GetFileSize(hFile, &amp;amp;dwHighSize);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是32位系统.返回值存储了大小.如果是64位系统.则高32位也会存储. 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.写文件&lt;/span&gt;
    TCHAR szBuffer[&lt;span&gt;1024&lt;/span&gt;] =TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloFile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    DWORD dwSize &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;(TCHAR) * &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;
    DWORD OutSize &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    WriteFile(hFile,        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;往哪个文件中写&lt;/span&gt;
        szBuffer,           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入的Buffer数据&lt;/span&gt;
        dwSize,             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入的大小&lt;/span&gt;
        &amp;amp;OutSize,           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际写入的大小.操作系统返回给你&lt;/span&gt;
        NULL);              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步操作不需要
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.读文件
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.1设置File读取位置&lt;/span&gt;
    SetFilePointer(hFile,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取那个文件&lt;/span&gt;
        &lt;span&gt;1&lt;/span&gt;,                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;低32位的偏移.具体偏移 就是从文件开始位置 + 偏移位置读取. 如果是64位那么第三个参数也要使用.&lt;/span&gt;
        &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        FILE_BEGIN         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;偏移起始位置. 文件开始 文件结束. 还是文件中间&lt;/span&gt;
&lt;span&gt;    );
    ReadFile(hFile,            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读哪个&lt;/span&gt;
        szBuffer,           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读入的数据放到Buffer&lt;/span&gt;
        dwSize,             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Buffer大小&lt;/span&gt;
        &amp;amp;OutSize,           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际读入的大小.操作系统返回给你&lt;/span&gt;
        NULL);              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步操作不需要&lt;/span&gt;
&lt;span&gt;
    CloseHandle(hFile);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.拷贝文件&lt;/span&gt;
&lt;span&gt;    CopyFile(
        TEXT(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\123.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;源文件&lt;/span&gt;
        TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:\\123.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;目的文件&lt;/span&gt;
        TRUE                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否覆盖目的文件&lt;/span&gt;
&lt;span&gt;    );
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.关闭文件句柄
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.删除文件&lt;/span&gt;
    DeleteFile(TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d:\\123.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 04 Sep 2018 06:28:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>Win32文件系统编程 一丶了解什么是文件系统 文件系统是抽象的.是windows在软件层面提供的一层虚拟的数据结构. 文件系统分为NTFS 跟 FAT32. 具体看看两者的区别吧. 磁盘分区容量.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/9584218.html</dc:identifier>
</item>
<item>
<title>git revert 还有这个坑？ - 南尘</title>
<link>http://www.cnblogs.com/liushilin/p/9584045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liushilin/p/9584045.html</guid>
<description>&lt;p&gt;最近也是终于开启了代码编写之旅，我只能默默地说一句，写代码的感觉，简直不能再爽！&lt;/p&gt;
&lt;p&gt;不过也由于 git 的分支管理蛋疼懵逼很久，所以必须记录以及和大家分享一下本次坑爹的旅行。&lt;/p&gt;
&lt;h4&gt;写在前面&lt;/h4&gt;
&lt;p&gt;每个公司相比都有自己的 git 分支管理规范，在项目组中开发人员较多的时候，这个就显得尤为重要。所以我们必须得掌握 git 的分支管理。基本套路就是有一个主线，然后在迭代周期內，每个开发人员拉取自己的分支，待开发完毕后大家再 merge 回主线，发布版本。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-84b44e605cc6f095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3994917-84b44e605cc6f095.png&quot; data-original-width=&quot;1920&quot; data-original-height=&quot;1080&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;174093&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;流程图&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;2.8301886792453&quot;&gt;
&lt;p&gt;具体的 git 代码分支管理看这个好了：&lt;a href=&quot;https://nvie.com/posts/a-successful-git-branching-model/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;怎么回事？&lt;/h4&gt;
&lt;p&gt;到底怎么就被 git 版本回滚给坑了呢？不急，待我慢慢道来。&lt;/p&gt;
&lt;p&gt;在咕咚的项目组中，在一个新的需求评审完毕，进入开发状态时，大家会基于 develop 分支拉取自己的分支，命名为 feature/XXX，然后各自在自己的分支上进行开发。&lt;/p&gt;
&lt;p&gt;由于大家开发业务上的不同，所以在需求开发完毕，整合代码的时候，一般都不会出现冲突的情况，即使出现，那也应该是比较容易解决的。&lt;/p&gt;
&lt;p&gt;可在最近的一次 merge 中出现了一个比较奇怪的问题。&lt;/p&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;507&quot; data-height=&quot;141&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-99a77b6a80daccb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3994917-99a77b6a80daccb8.png&quot; data-original-width=&quot;507&quot; data-original-height=&quot;141&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;24366&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;1.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我当前所在的分支是 feature8.29.0_nanchen，该分支已经 merge 了 release8.28.0 分支上的最新代码，本地没有任何提交。现在由于一些原因，我需要把另外一位同事开发的 feature8.28_buyGifts 分支代码合并到我的分支上。进行开发。&lt;/p&gt;
&lt;p&gt;意外地出现了很多的冲突。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;858&quot; data-height=&quot;419&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-3f97377b56372b55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/858/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3994917-3f97377b56372b55.png&quot; data-original-width=&quot;858&quot; data-original-height=&quot;419&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;165865&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们使用 &lt;code&gt;git status&lt;/code&gt; 看看到底发生了什么。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;942&quot; data-height=&quot;517&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-6f8f78ce826c0184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/942/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3994917-6f8f78ce826c0184.png&quot; data-original-width=&quot;942&quot; data-original-height=&quot;517&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;134943&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3.png&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;从截图中可以看出，git 认为我们当前的分支 delete 了不少文件，而这些文件是在 &lt;code&gt;feature8.28_buyGifts&lt;/code&gt; 分支上存在的。&lt;/p&gt;
&lt;p&gt;我们 vim 查看文件情况。这里就选取第一个 MarketItemsInfo.java 做截图。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;564&quot; data-height=&quot;131&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-d81c108076f5f008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/564/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3994917-d81c108076f5f008.png&quot; data-original-width=&quot;564&quot; data-original-height=&quot;131&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;12177&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;4.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们查看其他冲突文件以后，发现全部是和 &lt;code&gt;Presents&lt;/code&gt; 这个类相关的冲突，而这些文件实际上是开发 &lt;code&gt;feature8.28_buyGifts&lt;/code&gt; 分支的小伙伴开发的，主分支不可能做干预，这里让人什么疑惑。&lt;/p&gt;
&lt;p&gt;为了验证自己的猜想，我们查看一下 MarketItemsInfo.java 的提交历史。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1077&quot; data-height=&quot;101&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-68dfd4434ab1ee10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3994917-68dfd4434ab1ee10.png&quot; data-original-width=&quot;1077&quot; data-original-height=&quot;101&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;42099&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;5.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;正如我们所想，确实在 7 个月内，都没有人动过这个文件。&lt;/p&gt;
&lt;p&gt;所以一个 7 个月都没有人动过的文件，怎么就会 merge 的时候出现了这个令人费解的冲突呢？&lt;/p&gt;
&lt;p&gt;查看一下当前分支所有的日志。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;997&quot; data-height=&quot;199&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-a50a59405d94f507.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/997/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3994917-a50a59405d94f507.png&quot; data-original-width=&quot;997&quot; data-original-height=&quot;199&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;79214&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;6.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;似乎发现了一点异常。这位小伙伴曾经往 release8.28.0 进行了 merge 操作，此后被告知未提测不能 merge 到主线的时候，他又对 release8.28.0 分支做了 revert 操作。所以可能因此让 git 认为 release8.28.0 上有了这样的文件修改，因为操作后面被 revert，所以用 &lt;code&gt;git lg &amp;lt;fileName&amp;gt;&lt;/code&gt; 的时候，也看不到最近对文件的改动记录。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我现在只能说可能是这个原因，如果大家有高见的还望留言指导。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果是这样，那么我们只要在此次 revert 操作之前进行 merge feature8.28_buyGifts 分支代码的话，应该是不会出问题的。&lt;/p&gt;
&lt;p&gt;为了验证，我们重新建立一个分支，然后 reset 到 revert 操作之前，再进行 merge，查看是否还会出现这样的情况。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1052&quot; data-height=&quot;845&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-dc1335523c989597.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3994917-dc1335523c989597.png&quot; data-original-width=&quot;1052&quot; data-original-height=&quot;845&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;264556&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;7.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;明显没有出现任务冲突。&lt;/p&gt;
&lt;p&gt;我们再试试，在 revert 后进行 merge 操作。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;903&quot; data-height=&quot;633&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-17a033a9581e6743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/903/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3994917-17a033a9581e6743.png&quot; data-original-width=&quot;903&quot; data-original-height=&quot;633&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;215317&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;8.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如我们所想，当我们 reset 到 revert 提交的时候，再进行 merge 直接发生了这个冲突。&lt;/p&gt;
&lt;p&gt;这样的话，一定意义上，已经印证了我们的想法。git 确实把这个文件当做修改了。&lt;/p&gt;
&lt;h4&gt;怎么处理？&lt;/h4&gt;
&lt;p&gt;遇到了这样的问题，直观上，肯定是将冲突的改动，全部以这位小伙伴的代码为准，因为主线上的代码，已经确认是没有人动过这几个文件的。&lt;/p&gt;
&lt;p&gt;最不济的方法，可能就是直接舍弃掉这个小伙伴的操作，然后强行把他后面写的代码，重新写一遍了（因为他后面的代码量很少）。&lt;/p&gt;
&lt;h4&gt;为什么会出现这个 revert 操作？&lt;/h4&gt;
&lt;p&gt;说到底还是此次 revert 惹的祸。&lt;/p&gt;
&lt;p&gt;我询问该小伙伴后，得知，他是在 release8.28.0 主分支上 merge 了自己的代码，并且 push 到服务器后，被告知未提测的代码不能 merge 到主分支后，希望遗弃 push 到服务器上的这个 merge 操作，所以才采用 revert 命令的。&lt;/p&gt;
&lt;h4&gt;正确的操作？&lt;/h4&gt;
&lt;p&gt;我写这个正确的操作题目，是真的不敢写的。不过还是斗胆写了一下。如果我想遗弃自己 push 到服务器上的提交的话，我一定会选择 reset 后再进行 push 操作的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;首先使用 git reset —hard &amp;lt;版本号&amp;gt; 让 HEAD 指针指向 merge 前的 commit ID。(注意，这是直接放弃之后所有的提交，采用 --hard，这里因为是没有别人提交别的代码)&lt;/li&gt;
&lt;li&gt;再使用 git push origin &amp;lt;分支名&amp;gt; —force 命令强行把提交 push 到服务器即可。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4&gt;写在最后&lt;/h4&gt;
&lt;p&gt;实际上，我自己对 git 的操作也有些模棱两可，不过还是希望能用本次教训给大家简单做下交流吧。&lt;/p&gt;
</description>
<pubDate>Tue, 04 Sep 2018 06:08:00 +0000</pubDate>
<dc:creator>南尘</dc:creator>
<og:description>最近也是终于开启了代码编写之旅，我只能默默地说一句，写代码的感觉，简直不能再爽！ 不过也由于 git 的分支管理蛋疼懵逼很久，所以必须记录以及和大家分享一下本次坑爹的旅行。 写在前面 每个公司相比都有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liushilin/p/9584045.html</dc:identifier>
</item>
<item>
<title>.Net Core应用框架Util介绍（一） - 何镇汐</title>
<link>http://www.cnblogs.com/xiadao521/p/Util-Introduction-1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiadao521/p/Util-Introduction-1.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　距离上次发文，已经过去了三年半，这几年技术更新节奏异常迅猛，.Net进入了跨平台时代，前端也被革命性的颠覆。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;回顾&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　2015年，正当我还沉迷于JQuery + EasyUi的封装时，突然意识到技术已经过时。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　JQuery在面对更加复杂的UI需求时显得力不从心，EasyUi虽然组件比较完善，但界面风格老旧，响应速度慢，且是收费商业产品，在一个商业产品上投入精力封装并不划算，所以我果断弃坑了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后开始封装JQuery + Bootstrap,在一个SPA（单页应用）项目里暴露出很多问题，让我认识到JQuery不适合做SPA，我开始寻找新的方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　AngularJs(ng 1.x)是谷歌出品的JS框架，几本书下肚以后，我开始琢磨着如何把AngularJs操作封装起来，为了封装成链式调用，甚至改了它的源码以支持服务定位器模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　正当我准备封装基于AngularJs的UI组件时，发现它也过时了。由于UI封装工作量巨大，而前端环境异常混乱，不再敢轻举妄动，直到前端三大框架浮出水面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2016年，.Net Core兴起，为了方便学习交流，Alexinea（刘怡）发起了.Net Core学习小组，Kiler(谢炀)、Lemon(刘浩杨)和我做为第一批成员加入了小组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　微软当时尚未提供.Net Core中文文档，为了方便国内.Net Core的学习和推广，.Net Core学习小组组织了一批.Net爱好者进行翻译，直到官方提供了中文文档为止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2017年，.Net Core学习小组决定发布开源项目以推动.Net Core的发展，.Net Core学习小组也正式改名为.NET Core Community（.Net Core中国社区），简称NCC。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最初加入的项目有Lemon的AOP框架AspectCore，Savorboard（杨晓东）的分布式事务解决方案CAP框架，以及我的应用框架Util。随后一些优秀的开源项目加入了NCC，包括爬虫解决方案DotnetSpider，分布式微服务框架Surging等。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Util产生的背景&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　我长期混迹于小型软件公司，小公司资源有限，人少事多，水平也参差不齐，如何降低团队的学习成本，如何提高项目的开发进度，如何降低Bug率，是我的主要关注点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Util应用框架是我在多年的项目实战中积累起来以解决上述问题的利器，实践证明，它在多个小型团队和多个中小项目上起到关键作用，甚至包括一些濒临流产的项目。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;中小项目的瓶颈在哪&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　对于中小项目，简单CRUD（增删改查）占据大量篇幅，核心模块包含复杂业务逻辑，报表包含复杂查询，另外还需要权限控制、流程控制等，不管模块再多，大体不出这个范围。&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前端UI体验变得越来越重要，工作量也越来越大。一个简单CRUD，服务端API开发半小时，UI可能需要折腾一天。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;如何打破瓶颈&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　如果能够迅速拿下CRUD，并且能有效减轻前端开发任务，那么就能将更多精力投入核心业务，从而提高项目交付能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于服务端CRUD，通过封装基类再配合代码生成就能很好解决，如何提升前端开发效率？&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;正确认识&quot;前后分离&quot;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　一些人鼓吹“&lt;strong&gt;前后分离&lt;/strong&gt;“原则，前端界面交给专业的前端人员，后端人员只负责提供API就好了，这似乎是提升前端开发效率的灵丹妙药。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　问题在于小公司资金预算有限，而专业前端人员薪资要求很高，以低价招聘的前端人员，往往只会HTML + CSS，JS耍得并不溜，最后还得服务端程序员上场。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另一方面，前端还有前台和后台之分，前台是面向终端用户的网站，比如门户网站，商城一类，前台偏重展示，规律性不强，后台是面向用户或管理员的表单系统，偏重功能，规律性比较强。大多公司的前端人员主要开发前台网站，而管理后台还是服务端程序员开发，前端人员顶多帮助界面布局，功能还是后端人员完成。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&quot;前后分离&quot;不一定是人员的分离，也不能降低工作量，主要是指前后端依赖关系的分离，如果前端技术或后端技术可随意替换，而不是绑定在一起，就认为分离成功，这提升了项目的可维护性。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Js框架的选择&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　为了降低前端开发难度，选择一个好的Js框架显得特别重要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于一个复杂界面操作，JQuery同样可以完成任务，但与现代主流的Js框架相比，JQuery操作Dom的方式更加复杂，效率低下，且难以维护。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现代前端三大Js框架是&lt;strong&gt;Angular&lt;/strong&gt;(ng 2+)，Vue和React。通过学习，发现Angular更符合我对开发效率的追求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　要提升开发效率，最关键的特性就是&lt;strong&gt;代码提示&lt;/strong&gt;。不相信？？请在记事本上用C#写几句试试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Angular是谷歌开发的Js框架，默认采用&lt;strong&gt;Typescript&lt;/strong&gt;(Ts)语言开发，Typescript语言是微软开发的强类型脚本语句，它是Js的超集，在VS或VSCode上具有代码提示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你可能会说，Js不也有代码提示？这完全不一样，Ts具有强类型的代码提示，你只能看见对象上明确定义的成员，提供了非常精确的提示，而Js的代码提示滚动条好几米长，和当前对象无关的信息也显示出来，这严重降低了代码提示的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　除了代码提示，Ts还填平了Js固有的一些设计缺陷。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　很多开发人员不选择Angular的原因是需要多学一门脚本语言，认为成本高，这其实是一种误解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Ts在语法上有点像Js + C# + Java的混合体，对于C#或Java程序员，上手成本非常低，开发起来让你爽不停。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　作为微软系.Net程序员的我们更应该大力支持。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;声明式编程&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　现在我们在开发服务端和前端脚本时都有了代码提示，工作效率得到提升，还能更进一步吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现代流行的前端框架都有组件或指令的概念，用来支持&lt;strong&gt;声明式编程&lt;/strong&gt;，它&lt;em&gt;通过扩展Html自定义标签或自定义属性的方式来调用Js&lt;/em&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种方式将Js隐藏在内部，将&lt;strong&gt;Js转化成了Html&lt;/strong&gt;，形成更好的封装性。毫无疑问，使用Html编写的页面，比使用Js具有更强的表现力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果文本框需要非空验证，只需要在标签上加个属性，就像下面这样，你并不需要调用任何Js就完成了验证工作，这相当酷。&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;input required=”true”&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;不过我发现很多团队并不使用声明式编程方式，更愿意使用Js，原因在于Html是弱类型标签，自定义属性并没有代码提示，这确实是个大问题。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;TagHelper - 编写Html的救命稻草&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　我在2012年学习Dwz这个前端框架时，接触到声明式编程的概念，也被Html无提示的问题所困扰，后面发现Asp.Net提供的HtmlHelper能够封装Html，提供强类型的代码提示，这正是我需要的特性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2015年用HtmlHelper封装了EasyUi，虽然只完成了一些基础工作，但使用过的人都认为它大量提升了开发效率，它现在甚至仍然是一些公司的主打技术。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　HtmlHelper也有缺陷，它看上去是C#代码，而不是标签，比如HtmlHelper封装的文本框长成这样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180904133336812-1545018602.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果需要前端同学来帮助你调整界面，这就不太友好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另外HtmlHelper与Html混在一起也让代码看上去不直观。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　微软发现了这个问题，在Asp.Net Core推出了TagHelper，TagHelper与HtmlHelper类似，也是用来封装Html的强类型工具，不过它用起来是个标签，如果你不注意，根本看不出这是Html，还是TagHelper，这对前后端人员配合完成Html页面具有重大意义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在TagHelper封装的文本框长成这样了。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41709/201809/41709-20180904133622182-555244766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;TagHelper与Angular结合的艰难之路&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　使用Angular或Vue框架，你通常不会从0开始工作，寻找现成的UI组件库是更明智的选择，比如Angular可以选择Angular Material或Ng-Zorro。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这些库都提供了大量组件和属性，如果直接使用Html编写，没有代码提示，你必须随时打开官网，四处翻上翻下以寻找你需要的属性，哪怕你曾经用过它，如果你记得不是十分精确，从官网复制粘贴会时刻伴随着你。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在好了，你知道TagHelper是救命稻草，可能已经迫不急待想要动手封装了，不就是把Html拼接出来输出到页面，这能有多难？别急，小伙子，将Angular组件封装成TagHelper可不是你想的这么简单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你关注过Asp.Net Core Angular这个模板项目，你会发现这个模板使用的依然是Html，而不是TagHelper，这是为什么？自家这么好的技术，你都不推广一下？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我凭借之前封装HtmlHelper所积累下来的经验，将Asp.Net Core 2.0 Angular这个模板项目改造成支持TagHelper，这是使用Angular提供的JIT编译特性做到的。JIT就是即时编译，会在运行时动态获取Html页面并编译成内部Js，我在Github上也发现国外有些人在使用这种方式，不过都处于Demo级别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我用TagHelper封装了Angular &lt;strong&gt;Material&lt;/strong&gt;组件库，并将它应用在项目上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　很快爆发了严重的性能问题，这时候项目上的页面也才上百个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从启动到看见登录页面，需要半分钟，F5刷新还需要这么久，这个速度是无法接受的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我观察到系统在启动时会请求所有页面，原来我虽然使用了Angular模块，但没有使用延迟加载，主模块直接引用了子模块，导致在启动时加载全部页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用延迟加载缓解了这个问题，启动能在三秒左右完成，进入子模块也需要几秒，虽然能勉强使用，但性能和AOT编译相去甚远。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　AOT编译是Angular提供的预编译，能在发布阶段把Html文件直接编译成Js，这样在运行时就不再访问Html页面，对性能具有极大的提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用了TagHelper以后，并没有Html文件，AOT编译无法访问服务端Url，所以没办法使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　鱼和熊掌都想兼得，如果能够得到TagHelper的编译时检查和代码提示功能，又能得到AOT编译的运行时性能，这该多好啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我当时寄希望于Asp.Net Core团队，希望他们能提供一点支持，在Github提了Issue之后，Asp.Net Core团队表示TagHelper与Angular这种Js框架水火不容，机制上的问题。我后面仔细想想，确实如此，TagHelper主要为服务端MVC提供支持，而使用了Angular这样的Js框架后，路由都走客户端，通过AOT编译后，服务端除了提供WEB API，真没它啥事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于TagHelper提高了我团队的开发效率，延迟加载能让这个机制勉强使用，我也就坚持了下来。直到有一天灵机一动，用TagHelper生成出Html文件不就好了吗，和玄冰同学折腾了一天，终于解决了这个问题。现在，TagHelper充当了代码生成器的角色，服务端MVC相关的特性被全部抛弃。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　前面介绍了Util的一些背景和动机，同时也解释了为何我花大把时间在UI封装的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　未完待续，下一篇介绍Util包含的主要功能，以及让你把TagHelper + Angular Material封装的Demo运行起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Util应用框架的下载地址为：https://github.com/dotnetcore/Util&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　写文需要动力，请大家多多支持，点下推荐，Github点下星星。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Util应用框架交流一群: 24791014&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 04 Sep 2018 06:06:00 +0000</pubDate>
<dc:creator>何镇汐</dc:creator>
<og:description>距离上次发文，已经过去了三年半，这几年技术更新节奏异常迅猛，.Net进入了跨平台时代，前端也被革命性的颠覆。 回顾 2015年，正当我还沉迷于JQuery + EasyUi的封装时，突然意识到技术已经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiadao521/p/Util-Introduction-1.html</dc:identifier>
</item>
<item>
<title>Java 中的泛型 - YJK923</title>
<link>http://www.cnblogs.com/YJK923/p/9584020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YJK923/p/9584020.html</guid>
<description>&lt;p&gt;先来看一下以下 2 段代码，然后再进一步引出我们的泛型。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
        list.add(&lt;/span&gt;&quot;123&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;456&lt;span&gt;);

        Iterator it &lt;/span&gt;=&lt;span&gt; list.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(it.hasNext()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Error : Integer cannot be cast to String&lt;/span&gt;
            String next =&lt;span&gt; (String)it.next();  
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面这段代码，会出现转化异常的情况，但是编译是没问题的，在输出转化的时候却出现了异常，有没有一种冲动想要把集合中的类型归一？下面就是很正常的一个求和的方法，然而我们只能求类型为 Integer 的参数的和。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer add(Integer a,Integer b){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于集合来说，我们若是能在编译时期指定该集合中存放数据的类型，这样在类型转化的时候就不会再出现错误了，同样的，在下面的求和方法中，这个方法我们只能求得类型为 Integer 的参数的和，我们能不能做到可以通用的求和呢？使用泛型，就可以做到。&lt;/p&gt;

&lt;p&gt;泛型的概念也就是 “ 数据类型参数化 ” 正是由于我们不确定集合中可以指定的类型有哪些，是 Integer 还是 String ？求和方法中参数的数据类型可以有哪些，是 Float 还是 Double ？那我们就可以使用泛型来把这个数据类型给参数化。&lt;/p&gt;

&lt;p&gt;泛型的应用有泛型接口，泛型类和泛型方法。下面定义一个泛型类，并演示使用方式。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Box &amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; T 是 Type 的简写,代表任意类型，注意是类，而不是基本数据类型。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也可以换成其它单词，这只是一个表示而已。&lt;/span&gt;
&lt;span&gt;    T t;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getT() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setT(T t) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.t =&lt;span&gt; t;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在下面的应用中，我们可以将 T 换成任意我们想要的类型&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Box&lt;/span&gt;&amp;lt;Integer&amp;gt; iBox = &lt;span&gt;new&lt;/span&gt; Box&amp;lt;Integer&amp;gt;&lt;span&gt;();
        Box&lt;/span&gt;&amp;lt;Double&amp;gt; dBox = &lt;span&gt;new&lt;/span&gt; Box&amp;lt;Double&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在 JDK1.7 及其以上版本可以利用 “类型推断” 这样写。&lt;/span&gt;
        Box&amp;lt;String&amp;gt; stringBox = &lt;span&gt;new&lt;/span&gt; Box&amp;lt;&amp;gt;&lt;span&gt;();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;泛型方法的定义只需要在方法的声明中添加 &amp;lt; T &amp;gt; 即可，或是添加一组泛型 &amp;lt;K ，V&amp;gt; 。 &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Util {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;K, V&amp;gt; &lt;span&gt;boolean&lt;/span&gt; compare(Pair&amp;lt;K, V&amp;gt; p1, Pair&amp;lt;K, V&amp;gt;&lt;span&gt; p2) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p1.getKey().equals(p2.getKey()) &amp;amp;&amp;amp;&lt;span&gt;
               p1.getValue().equals(p2.getValue());
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Pair&amp;lt;K, V&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; K key;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; V value;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Pair(K key, V value) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setKey(K key) { &lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setValue(V value) { &lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; K getKey()   { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; key; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; V getValue() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以这样来调用泛型方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
Pair&amp;lt;Integer, String&amp;gt; p1 = &lt;span&gt;new&lt;/span&gt; Pair&amp;lt;&amp;gt;(1, &quot;apple&quot;&lt;span&gt;);
Pair&lt;/span&gt;&amp;lt;Integer, String&amp;gt; p2 = &lt;span&gt;new&lt;/span&gt; Pair&amp;lt;&amp;gt;(2, &quot;pear&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; same = Util.&amp;lt;Integer, String&amp;gt;compare(p1, p2);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上也就是简单的应用，那我们还会遇到什么情况呢，下面看一看关于通配符的问题，为了演示效果，我写了一个实际用处不大的方法。&lt;/p&gt;
&lt;p&gt; &lt;code&gt;    &lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printSize(List&amp;lt;Object&amp;gt;&lt;span&gt; list){
        System.out.println(list.size());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; list1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        List&lt;/span&gt;&amp;lt;String&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();

        printSize(list1); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面我们已经知道，在集合中使用泛型可以使程序更加安全，易读，所以 Java 规范推荐我们使用泛型，那我们看一下上面这种情况，我该如何表示接收所有带有泛型的 List 集合呢。上面使用 LIst&amp;lt;Object&amp;gt; 是不行的。为什么不行？我们该使用何种方式接收参数呢？&lt;/p&gt;

&lt;p&gt;首先来解释一下为什么不行，先看一下简单的区别。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Object obj = &lt;span&gt;new&lt;/span&gt; Integer(1&lt;span&gt;);
ArrayList&lt;/span&gt;&amp;lt;Object&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;obj 可以赋值成功，是因为多态（往深了说是里氏替换原则），父类的引用指向了子类的实体，而下面的报错了，直观的理由说明，ArrayList&amp;lt;Object&amp;gt; 不是 ArrayList&amp;lt;Integer&amp;gt; 的父类。嗯，确实不是，为什么不是，一句话带过，是因为 Java 中正常的泛型是不变的，当然我们也可以使其改变。（不变，协变和逆变的概念可以自行百度）&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;传送门：https://www.cnblogs.com/keyi/p/6068921.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那我就是想让方法接收所有的带泛型的集合该怎么办呢？这时候通配符就出现了，我们可以使用 List&amp;lt;?&amp;gt; 代表所有的带泛型的 List ，这样也就是说可以使用 List&amp;lt;?&amp;gt; 来指向所有的带泛型的 LIst 。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printSize(List&amp;lt;?&amp;gt;&lt;span&gt; list){
        System.out.println(list.size());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; list1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        List&lt;/span&gt;&amp;lt;String&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();

        printSize(list1);
        printSize(list2);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好的，再次梳理一下逻辑，在 Java 中我们可以使用父类的引用指向子类的对象，而在泛型中，List&amp;lt;Object&amp;gt; 和 List&amp;lt;Integer&amp;gt; 不构成继承关系，原因是因为泛型是不可变的，然而我们又希望表示所有带有泛型的集合，这时就出现了 ？通配符。我们可以使用 List&amp;lt;?&amp;gt; 来引用其它带泛型的 List 。&lt;/p&gt;

&lt;p&gt;实际的效果就是这样&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
List&amp;lt;Object&amp;gt; list1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错&lt;/span&gt;
List&amp;lt;?&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那好，现在要求升级了，我希望我的 List 集合不要什么都可以指向，下面就看一下一些有限制条件的修饰符该如何表示。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通用修饰符&lt;/span&gt;
List&amp;lt;?&amp;gt; list1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;? extends T&amp;gt; 可用于表示 T 以及 T 的子类        &lt;/span&gt;
List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Number&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;&lt;span&gt;();
List&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Number&amp;gt; list3 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
List&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Number&amp;gt; list4 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;? super T&amp;gt; 可用于表示 T 以及 T 的父类        &lt;/span&gt;
List&amp;lt;? &lt;span&gt;super&lt;/span&gt; Number&amp;gt; list5 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;&lt;span&gt;();
List&lt;/span&gt;&amp;lt;? &lt;span&gt;super&lt;/span&gt; Number&amp;gt; list6 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;&lt;span&gt;();
List&lt;/span&gt;&amp;lt;? &lt;span&gt;super&lt;/span&gt; Number&amp;gt; list7 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于上面的 &amp;lt;? extends Number&amp;gt; 和 &amp;lt;? super Number&amp;gt; 该如何选择呢 ？先说结论：” Producer Extends，Consumer Super ” 简称 PECS 原则。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;“Producer Extends” – 如果你需要一个只读 List，用它来 produce T，那么使用&amp;lt; ? extends T &amp;gt; 。&lt;/p&gt;
&lt;p&gt;“Consumer Super” – 如果你需要一个只写 List，用它来 consume T，那么使用&amp;lt; ? super T &amp;gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果需要同时读取以及写入，那么我们就不能使用通配符了。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Number&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;&lt;span&gt;();
List&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Number&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
List&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Number&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Double&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不论具体的实例化是什么，我们 get 元素之后都是父类 Number
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以是 produce ，可以 get 得到很多的 T&lt;/span&gt;
Number number = list.get(0&lt;span&gt;);

list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Integer(1)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于以上的三种实例化方式都是允许的，那么假如我现在想从 list 中 get 一个实例，因为 list 指向的实例可能是 Animal ，Dog，或 Cat 实例的集合。所以返回的值会统一为其父类。而在 add 值的时候就会存在问题，我不能确定添加的元素具体是哪一个，除了 null ，所以会报错。&lt;/p&gt;

&lt;p&gt;同样的思路再来看&amp;lt; ? super T &amp;gt; 操作。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
List&amp;lt;? &lt;span&gt;super&lt;/span&gt; Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
List&lt;/span&gt;&amp;lt;? &lt;span&gt;super&lt;/span&gt; Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Number&amp;gt;&lt;span&gt;();
List&lt;/span&gt;&amp;lt;? &lt;span&gt;super&lt;/span&gt; Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不同的实例化，我们 get 元素之后返回的值不确定
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或是 Integer， Number， Object ……&lt;/span&gt;
list.get(0&lt;span&gt;); 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加数据的时候可以确定的添加是什么
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以 super 对应只写入的情况，即 consume T&lt;/span&gt;
list.add(&lt;span&gt;new&lt;/span&gt; Integer(1)); 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于泛型还要说明的是泛型是应用在编译时期的一项技术，而在运行期间是不存在泛型的。原因在于泛型类型擦除。为什么这么说，我们可以来看个示例&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
        list.add(&lt;/span&gt;456&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;123&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译报错&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;--------------------------------------------------
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {  
        List&lt;/span&gt;&amp;lt;String&amp;gt; l1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();   
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; l2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
        System.out.println(l1.getClass());
        System.out.println(l1.getClass().equals(l2.getClass()));  
    } 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; class java.util.ArrayList
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;究其原因，在于 Java 中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的 class 文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。&lt;/p&gt;

&lt;p&gt;在类型擦除之后，若是在代码中有相应的类型变量，遵循 &quot; 保留上界 &quot; 规则，会将相应的 T 替换成具体的类。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&amp;lt; ? &amp;gt; ---- &amp;gt; Object&lt;/p&gt;
&lt;p&gt;&amp;lt; ? extends T &amp;gt; ---- &amp;gt; T&lt;/p&gt;
&lt;p&gt;&amp;lt; ? super T &amp;gt; ----- &amp;gt; Object&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;补充说明一点，Java 中不允许直接创建泛型数组。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
List&amp;lt;Integer&amp;gt;[] lists = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错&lt;/span&gt;&lt;span&gt;

看以下演示代码

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Not really allowed.&lt;/span&gt;
List&amp;lt;String&amp;gt;[] lsa = &lt;span&gt;new&lt;/span&gt; List&amp;lt;String&amp;gt;[10];      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
Object o =&lt;span&gt; lsa;
Object[] oa &lt;/span&gt;=&lt;span&gt; (Object[]) o;
List&lt;/span&gt;&amp;lt;Integer&amp;gt; li = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
li.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Integer(3&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Unsound, but passes run time store check&lt;/span&gt;
oa[1] =&lt;span&gt; li;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Run-time error: ClassCastException.&lt;/span&gt;
String s = lsa[1].get(0); 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果允许泛型数组的存在（第 1 处代码编译通过），那么在第 2 处代码就会报出 ClassCastException，因为 lsa[1] 是 List&amp;lt;Integer&amp;gt; 。Java 设计者本着首要保证类型安全（type-safety）的原则，不允许泛型数组的存在，使得编译期就可以检查到这类错误。&lt;/p&gt;

&lt;p&gt;解决方案&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
List&amp;lt;?&amp;gt;[] lsa = &lt;span&gt;new&lt;/span&gt; List&amp;lt;?&amp;gt;[10];                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
Object o =&lt;span&gt; lsa;
Object[] oa &lt;/span&gt;=&lt;span&gt; (Object[]) o;
List&lt;/span&gt;&amp;lt;Integer&amp;gt; li = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
li.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Integer(3&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Correct.&lt;/span&gt;
oa[1] =&lt;span&gt; li;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Run time error, but cast is explicit.&lt;/span&gt;
String s = (String) lsa[1].get(0);              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在第 1 处，用 ? 取代了确定的参数类型。根据通配符的定义以及 Java 类型擦除的保留上界原则，在 2 处 lsa[1].get(0) 取出的将会是 Object，所以需要程序员做一次显式的类型转换。&lt;/p&gt;

&lt;p&gt;还有一种通过反射的方式来实现，使用 java.util.reflect.Array，可以不使用通配符，而达到泛型数组的效果。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
List&amp;lt;String&amp;gt;[] lsa = (List&amp;lt;String&amp;gt;[])Array.newInstance(ArrayList.&lt;span&gt;class&lt;/span&gt;, 4);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
Object o =&lt;span&gt; lsa;
Object[] oa &lt;/span&gt;=&lt;span&gt; (Object[]) o;
List&lt;/span&gt;&amp;lt;Integer&amp;gt; li = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
li.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Integer(3&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Correct.&lt;/span&gt;
oa[1] =&lt;span&gt; li;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Run time error, but cast is explicit.&lt;/span&gt;
String s = lsa[1].get(0);                                  //2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到，利用 Array.newInstance() 生成了泛型数组，这里没有使用任何通配符，在第 2 处也没有做显式的类型转换，但是在第 1 处，仍然存在显式类型转换。&lt;/p&gt;

&lt;p&gt;所以要想使用泛型数组，要求程序员必须执行一次显示的类型转换，也就是将类型检查的问题从编译器交给了程序员。但是呢，泛型的设计初衷就是编译器会帮助我们检查数据类型。你说矛盾不矛盾！&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;http://www.importnew.com/24029.html&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/sunxianghuang/article/details/51982979&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/wxw7blog/p/7517343.html&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/keyi/p/6068921.html&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/yi_Afly/article/details/52058708&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 04 Sep 2018 06:04:00 +0000</pubDate>
<dc:creator>YJK923</dc:creator>
<og:description>先来看一下以下 2 段代码，然后再进一步引出我们的泛型。 上面这段代码，会出现转化异常的情况，但是编译是没问题的，在输出转化的时候却出现了异常，有没有一种冲动想要把集合中的类型归一？下面就是很正常的一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YJK923/p/9584020.html</dc:identifier>
</item>
</channel>
</rss>