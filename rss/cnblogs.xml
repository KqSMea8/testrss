<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>为什么树莓派不会受到 Spectre 和 Meltdown 攻击 - 张高兴</title>
<link>http://www.cnblogs.com/zhanggaoxing/p/8242950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggaoxing/p/8242950.html</guid>
<description>&lt;p&gt;&lt;em&gt;最近爆出来的 Intel CPU 的底层漏洞可谓是影响巨大，过去20年的电脑都可能会受影响。前几天 Raspberry Pi 的官方 Twitter（&lt;a href=&quot;https://twitter.com/Raspberry_Pi&quot;&gt;@Raspberry_Pi&lt;/a&gt;） 转推了这篇文章，通过简单的 Python 程序分析了各种硬件术语和漏洞攻击模式，内容简单易懂，看后神清气爽。今天抽空将其翻译，分享给大家。本人英语也不算太好，对着百度磕磕绊绊的翻译了出来，如有错误请多多包涵。——2018年1月8日&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;*原文地址：&lt;a href=&quot;https://www.raspberrypi.org/blog/why-raspberry-pi-isnt-vulnerable-to-spectre-or-meltdown*&quot; class=&quot;uri&quot;&gt;https://www.raspberrypi.org/blog/why-raspberry-pi-isnt-vulnerable-to-spectre-or-meltdown*&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在过去的几天里，有许多关于一对叫 Spectre 和 Meltdown 的安全漏洞的讨论。这影响到所有近代的英特尔处理器，许多AMD处理器（在 Spectre 漏洞下）和 ARM 核心。 Spectre 允许攻击者绕过软件检查，去读取当前地址空间中任意位置的数据； Meltdown 允许攻击者去读取操作系统内核地址空间中（通常对用户程序不可访问）任意位置的数据。&lt;/p&gt;
&lt;p&gt;这两个漏洞利用许多现代处理器常见的性能特征（缓存和预测执行），通过所谓的侧信道攻击（side-channel attack）来泄漏数据。幸运的是，树莓派不会受到这些漏洞的影响，因为我们使用特别的（particular）ARM 内核。&lt;/p&gt;
&lt;p&gt;为了帮助我们理解为什么，这里有一点关于现代处理器设计中的一些概念。我们将使用像下面那样的简单的 Python 程序去说明这些概念：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;t &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;b
u &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; c&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;d
v &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; e&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;f
w &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; v&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;g
x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; h&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;i
y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; j&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;k&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然计算机中的处理器不直接执行 Python ，但这里的语句很简单，它们大致相当于一个机器指令。我们将详细介绍一些细节（尤其是流水线(pipelining)和寄存器重命名(register renaming)），这对于处理器设计者来说非常重要，但并不是理解 Spectre 和 Meltdown 所必须的。&lt;/p&gt;
&lt;p&gt;为了综合描述处理器设计和现代计算机体系结构的其他方面，你不能做得比 Hennessy and Patterson’s classic Computer 体系结构更好：一种定量方法。（&lt;em&gt;原文：you can’t do better than Hennessy and Patterson’s classic Computer Architecture: A Quantitative Approach.&lt;/em&gt;）&lt;/p&gt;
&lt;h2 id=&quot;什么是标量处理器&quot;&gt;什么是标量处理器&lt;/h2&gt;
&lt;p&gt;最简单的现代处理器每周期执行一条指令，我们称之为标量处理器（scalar processor）。上面的示例将在标量处理器上以六个周期执行。&lt;/p&gt;
&lt;p&gt;标量处理器的例子包括 Intel 486 和在 Raspberry Pi 1 与 Raspberry Pi Zero 上使用的 ARM1176 核心。&lt;/p&gt;
&lt;h2 id=&quot;什么是超标量处理器&quot;&gt;什么是超标量处理器&lt;/h2&gt;
&lt;p&gt;使标量处理器（实际上是任何处理器）运行得更快的明显方法是增加它的时钟速度（clock speed）。但是，我们很快达到了处理器内部逻辑门运行速度的极限。因此，处理器设计者开始寻找几种同时执行多个指令的方法。&lt;/p&gt;
&lt;p&gt;顺序（in-order）超标量处理器（superscalar processor）检查传入的指令流，并尝试在一个流水线（pipelines -&amp;gt; pipes）中同时执行多个指令流，但要遵守指令之间的依赖关系。依赖关系很重要：你可能认为双路（two-way）超标量处理器可以结对（dual-issue）六个指令，像下面的例子一样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;t, u &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;b, c&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;d
v, w &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; e&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;f, v&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;g
x, y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; h&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;i, j&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;k&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这没有意义：在计算 w 之前，我们必须计算 v ，所以第三和第四指令不能同时执行。我们的双路超标量处理器实际上不可能找到任何与第三指令相匹配的指令，所以我们的示例将以四个周期执行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;t, u &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;b, c&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;d
v    &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; e&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;f                   &lt;span class=&quot;co&quot;&gt;# second pipe does nothing here&lt;/span&gt;
w, x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; v&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;g, h&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;i
y    &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; j&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;k&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;超标量处理器的例子包括 Intel Pentium ，在 Raspberry Pi 2 与 Raspberry Pi 3 上使用的 ARM Cortex-A7 与 Cortex-A53 核心。 Raspberry Pi 3 的时钟速度只比 Raspberry Pi 2 快了 33% ，但性能近乎翻倍：额外性能的部分原因是 Cortex-A53 的指令结对能力比 Cortex-A7 具有更广泛的指令范围。&lt;/p&gt;
&lt;h2 id=&quot;什么是乱序处理器&quot;&gt;什么是乱序处理器&lt;/h2&gt;
&lt;p&gt;回到我们的例子，我们可以看到，虽然我们在 v 和 w 之间有一个依赖项，但是在程序的后面有其他的独立指令，我们或许可以在第二个周期中用来填充流水线。乱序（out-of-order）超标量处理器具有打乱即将到来的指令的能力（遵循依赖关系），以便提高流水线的效率。&lt;/p&gt;
&lt;p&gt;在我们的示例中，乱序处理器可能有效的交换 w 和 x 的定义：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;t &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;b
u &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; c&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;d
v &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; e&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;f
x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; h&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;i
w &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; v&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;g
y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; j&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;k&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将其以三个周期执行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;t, u &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;b, c&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;d
v, x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; e&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;f, h&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;i
w, y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; v&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;g, j&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;k&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;乱序处理器的例子包括 Intel Pentium 2 （绝大多数的 Intel 和 AMD x86 处理器，除了一些 Intel Atom 和 Intel Quark 设备），最新的 ARM 核心，像 Cortex-A9, -A15, -A17, and -A57 。&lt;/p&gt;
&lt;h2 id=&quot;什么是分支预测器&quot;&gt;什么是分支预测器&lt;/h2&gt;
&lt;p&gt;上面的例子是一段顺序代码。当然，真正的程序不是这样的：它们还包含向前分支（forward branches，用于实现条件操作，如if语句）和向后分支（backward branches，用于实现循环）。分支可能是无条件的（总是执行），或条件的（是否执行取决于计算值）。&lt;/p&gt;
&lt;p&gt;在获取指令时，处理器可能遇到依赖于尚未计算值的条件分支。为了避免停顿，处理器必须猜测下一个要取的指令：在内存中的一个指令（对应不执行分支），或分支目标中的一个（对应执行分支）。分支预测器（branch predictor）可帮助处理器对是否执行分支进行智能猜测。它通过收集有关过去特定分支的执行频率的统计数据来做到这一点。&lt;/p&gt;
&lt;p&gt;现代分支预测是非常复杂的，可以产生非常准确的预测。Raspberry Pi 3 的额外性能的部分原因是由于分支预测在 Cortex-A7 和 Cortex-A53 之间的改进。然而，通过执行精心编制的一系列分支，攻击者可以错误地训练分支预测器，从而做出糟糕的预测。&lt;/p&gt;
&lt;h2 id=&quot;什么是推测&quot;&gt;什么是推测&lt;/h2&gt;
&lt;p&gt;重排（reordering）顺序指令是使更多指令级并行的强有力方法，但是随着处理器变得更强大（能够将三或四个指令结对），要使所有这些流水线忙起来变得困难。因此，现代处理器推测（speculation）的能力也变得更强。推测执行允许我们发出可能不需要的指令（因为代码可能会存在分支），这会使流水线保持繁忙（使用或丢弃），如果结果表明该指令未被执行，我们就可以将其丢弃。&lt;/p&gt;
&lt;p&gt;推测执行不必要的指令（底层需要支持推测和重排）消耗额外的时间，但在许多情况下，这被认为是获得额外单线程性能的一个合算的折衷。分支预测器被用来选择程序最可能的路径，最大限度地提高推测的回报。&lt;/p&gt;
&lt;p&gt;为了演示推测的好处，让我们看看另一个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;t &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;b
u &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; t&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;c
v &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; u&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;d
&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; v:
   w &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; e&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;f
   x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; w&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;g
   y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; x&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;h&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们有了从 t 到 u 到 v ，从 w 到 x 到 y 的依赖关系，所以没有推测的双路乱序处理器永远不能填满它的第二个流水线。处理器花费三个周期计算 t 、 u 和 v ，之后将知道 if 语句的主体部分是否执行，在执行 if 语句主体的情况下，再花费三个周期计算 w 、 x 和 y 。假设 if 语句（由一个分支指令实现）需要一个周期，我们的示例将花费四个周期（如果 v 为 0）或七个周期（如果 v 为非 0）。&lt;/p&gt;
&lt;p&gt;如果分支预测器表明该 if 语句体可能执行，经推测有效地打乱后的程序是这样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;t &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;b
u &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; t&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;c
v &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; u&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;d
w_ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; e&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;f
x_ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; w_&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;g
y_ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; x_&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;h
&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; v:
   w, x, y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; w_, x_, y_&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此我们现在有了额外的指令并行来保持我们的流水线繁忙：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;t, w_ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;b, e&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;f
u, x_ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; t&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;c, w_&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;g
v, y_ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; u&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;d, x_&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;h
&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; v:
   w, x, y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; w_, x_, y_&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;循环计数在推测乱序处理器中定义不太好（&lt;em&gt;原文：Cycle counting becomes less well defined in speculative out-of-order processors&lt;/em&gt;），但 w 、 x 和 y 的分支和条件更新是大约不占用时间的，所以我们的示例大约在三个周期中执行。&lt;/p&gt;
&lt;h2 id=&quot;什么是缓存&quot;&gt;什么是缓存&lt;/h2&gt;
&lt;p&gt;在过去的好日子里，处理器的速度与内存访问速度匹配得很好。我的 BBC Micro 有 2MHz ，执行一条指令大约 2μs ，存储周期（memory cycle time）为 0.25μs 。在接下来的35年里，处理器已经变得很快，但内存还仅仅是那样。在 Raspberry Pi 3 中的一个 Cortex-A53 核心，执行一条指令大约 0.5ns ，但可能需要多达 100ns 去访问主存。&lt;/p&gt;
&lt;p&gt;乍一看，这听起来像一个灾难：我们每次访问内存，要等待 100ns 后才得到结果返回。下面这个例子需要花费 200ns ：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; mem[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; mem[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，在实际中，程序倾向于以相对可预测的方式去访问内存，同时显示时间局部性（temporal locality ，如果我访问一个位置，我很可能很快就会再次访问它）和空间局部性（spatial locality ，如果我访问一个位置，我很可能很快就会访问它附近的位置）。缓存利用了这些特性，以减少访问内存的平均成本。&lt;/p&gt;
&lt;p&gt;缓存是一个容量小的芯片存储器，靠近处理器，存储最近使用的地址（及其附近）的内容的副本，以便它们在后续访问中很快可用。有了缓存，上面的例子会执行一个多 100ns ：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; mem[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]    &lt;span class=&quot;co&quot;&gt;# 100ns delay, copies mem[0:15] into cache&lt;/span&gt;
b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; mem[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]    &lt;span class=&quot;co&quot;&gt;# mem[1] is in the cache&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从 Spectre 和 Meltdown 的角度来看，重要的一点是，如果能够计算内存访问的时间，就可以判定所访问的地址是否在缓存。&lt;/p&gt;
&lt;h2 id=&quot;什么是侧信道&quot;&gt;什么是侧信道&lt;/h2&gt;
&lt;p&gt;维基百科&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%97%81%E8%B7%AF%E6%94%BB%E5%87%BB&quot;&gt;zh-cn&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;侧信道攻击（英语：Side-channel attack）是一种攻击方式，它基于从密码系统的物理实现中获取的信息而非暴力破解法或是算法中的理论性弱点（较之密码分析）。例如：时间信息、功率消耗、电磁泄露或甚是声音可以提供额外的信息来源，这可被利用于进一步对系统的破解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spectre 和 Meltdown 是侧信道攻击, 它推断出内存位置的内容, 而内存位置通常不应使用定时来观察当前缓存中是否存在另一个可访问的位置。&lt;/p&gt;
&lt;h2 id=&quot;综上所述&quot;&gt;综上所述&lt;/h2&gt;
&lt;p&gt;现在让我们来看看推测和缓存是如何结合在一起去允许一个像 Meltdown 的对处理器的攻击。考虑下面的例子，这是一个用户程序，从一个非法（内核）地址读取，导致一个错误（崩溃）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;t &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;b
u &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; t&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;c
v &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; u&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;d
&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; v:
   w &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; kern_mem[address]   &lt;span class=&quot;co&quot;&gt;# if we get here, fault&lt;/span&gt;
   x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; w&lt;span class=&quot;op&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;0x100&lt;/span&gt;
   y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; user_mem[x]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，如果我们能训练分支预测器相信 v 可能是非 0 的，我们双路乱序超标量处理器将会这样打乱程序：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;t, w_ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;b, kern_mem[address]
u, x_ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; t&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;c, w_&lt;span class=&quot;op&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;0x100&lt;/span&gt;
v, y_ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; u&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;d, user_mem[x_]

&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; v:
   &lt;span class=&quot;co&quot;&gt;# fault&lt;/span&gt;
   w, x, y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; w_, x_, y_      &lt;span class=&quot;co&quot;&gt;# we never get here&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即使处理器总是从内核地址地读取, 它也必须延迟所产生的错误, 直到它知道 v 是非零的。从表面上看，这感觉很安全，因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;v 为零，因此非法读取的结果不会被提交到 w&lt;/li&gt;
&lt;li&gt;v 为非零，但在将读取提交到 w 之前发生故障&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，假设我们在执行代码之前清空缓存，并排列 a、b、c 和 d, 以便 v 实际上是零。现在，在第三周期中推测读取&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;v, y_ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; u&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;d, user_mem[x_]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将访问用户地址 0x000 或地址 0x100 ，具体取决于非法读取的结果的第八位，将该地址及其附近加载到缓存中。由于 v 为零，因此将丢弃推测性指令的结果，并继续执行。如果我们对其中一个地址进行后续访问, 我们就可以确定哪个地址在缓存中。恭喜你，你刚刚从内核的地址空间读取了一位!&lt;/p&gt;
&lt;p&gt;真正的 Meltdown 利用比这更为复杂（特别是为了避免错误地训练分支预测器，作者更愿意无条件地执行非法读取并处理结果异常），但原理是一样的。 Spectre 使用类似的方法来颠覆软件数组边界检查。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;现代处理器不遗余力地保持抽象，即它们是直接访问存储器的顺序的标量机器。而实际上使用许多技术，包括缓存、指令重排和推测，可以提供比简单处理器更高的性能。 Meltdown 和 Spectre 是我们在抽象的背景下对安全进行推理的例子，然后在抽象和现实之间遇到细微的差异。&lt;/p&gt;
&lt;p&gt;在 Raspberry Pi 中，ARM1176、Cortex-A7 和 Cortex-A53 核心的缺少推测功能使我们对这种类型的攻击免疫。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jan 2018 07:31:00 +0000</pubDate>
<dc:creator>张高兴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggaoxing/p/8242950.html</dc:identifier>
</item>
<item>
<title>Dotnet Core Windows Service - 留云</title>
<link>http://www.cnblogs.com/jfliuyun/p/8242945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jfliuyun/p/8242945.html</guid>
<description>&lt;p&gt;在dotnet 中有topshelf 可以很方便的写windows 服务并且安装也是很方便的，命令行 运行.exe install 就直接把exe 程序安装成windows 服务。当然&lt;/p&gt;
&lt;p&gt;代码也要做相应的修改，具体的可以参照例子。&lt;/p&gt;
&lt;p&gt;在dotnet core 2.0 中 我们也有一个很方便的dll 来试用 &lt;/p&gt;
&lt;p&gt;https://github.com/PeterKottas/DotNetCore.WindowsService&lt;/p&gt;
&lt;p&gt;通过Nuget来安装 Using nuget: Install-Package PeterKottas.DotNetCore.WindowsService&lt;/p&gt;
&lt;p&gt;方便多个服务我们先定义一个接口&lt;/p&gt;
&lt;p&gt;public interface IBaseService&lt;br/&gt;{&lt;br/&gt;void Start();&lt;br/&gt;void Stop();&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;具体的实现呢 我举个例子，在例子中我们试用了个Timer，定时的完成某些任务，这样 我们就可以同时写好几个service 只要继续 IBaseService 就行，也比较方面安装&lt;/p&gt;
&lt;p&gt;public class SyncService : IBaseService&lt;br/&gt;{&lt;br/&gt;private readonly System.Timers.Timer _timer;&lt;br/&gt;private readonly ILogger logger;&lt;br/&gt;public SyncService( ILoggerFactory loggerFactory)&lt;br/&gt;{&lt;/p&gt;
&lt;p&gt;_timer = new System.Timers.Timer(10000);&lt;br/&gt;_timer.Elapsed += new ElapsedEventHandler(OnTimedEvent);&lt;/p&gt;
&lt;p&gt;_timer.Interval = 2000;&lt;/p&gt;
&lt;p&gt;_timer.AutoReset = true;&lt;br/&gt;_timer.Enabled = false;&lt;br/&gt;logger = loggerFactory.CreateLogger&amp;lt;SyncService&amp;gt;();&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;private void OnTimedEvent(object source, ElapsedEventArgs e)&lt;br/&gt;{&lt;br/&gt;Console.WriteLine(string.Format(&quot;SyncService:{0:yyyy-MM-dd HH:mm:sss}&quot;, DateTime.Now));&lt;br/&gt;_timer.Enabled = false;&lt;/p&gt;
&lt;p&gt;try&lt;br/&gt;{&lt;br/&gt;//do some job;&lt;br/&gt;}&lt;br/&gt;catch (Exception ex)&lt;br/&gt;{&lt;br/&gt;logger.LogError(&quot;SyncService Error {0}:&quot;, ex.Message);&lt;br/&gt;}&lt;br/&gt;Console.WriteLine(string.Format(&quot;SyncService:{0:yyyy-MM-dd HH:mm:sss}&quot;, DateTime.Now));&lt;/p&gt;
&lt;p&gt;Thread.Sleep(5 * 60 * 1000);&lt;/p&gt;
&lt;p&gt;_timer.Enabled = true;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;private async Task&amp;lt;HttpResponseMessage&amp;gt; SyncData()&lt;br/&gt;{&lt;br/&gt;string url = configModel.DatabaseIncrementUrl;&lt;br/&gt;var httpClient = new HttpClient();&lt;br/&gt;return await httpClient.GetAsync(url);&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;public void Start()&lt;br/&gt;{&lt;br/&gt;_timer.Start();&lt;br/&gt;_timer.Enabled = true;&lt;br/&gt;}&lt;br/&gt;public void Stop()&lt;br/&gt;{&lt;br/&gt;_timer.Stop();&lt;br/&gt;_timer.Enabled = false;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;

&lt;p&gt;class Program&lt;br/&gt;{&lt;br/&gt;static void Main(string[] args)&lt;br/&gt;{&lt;/p&gt;
&lt;p&gt;IConfigurationRoot Configuration;&lt;br/&gt;// ILoggerFactory LoggerFactory;&lt;/p&gt;
&lt;p&gt;var builder = new ConfigurationBuilder()&lt;br/&gt;.SetBasePath(Path.Combine(AppContext.BaseDirectory))&lt;br/&gt;.AddJsonFile(&quot;appsettings.json&quot;)&lt;br/&gt;.AddEnvironmentVariables();&lt;/p&gt;
&lt;p&gt;Configuration = builder.Build();&lt;/p&gt;
&lt;p&gt;var services = new ServiceCollection();&lt;/p&gt;
&lt;p&gt;services.AddOptions();&lt;br/&gt;services.Configure&amp;lt;ConfigModel&amp;gt;(Configuration.GetSection(&quot;ConfigSetting&quot;));&lt;br/&gt;services.AddSingleton&amp;lt;IConfiguration&amp;gt;(Configuration);&lt;/p&gt;
&lt;p&gt;services.AddTransient&amp;lt;ILoggerFactory, LoggerFactory&amp;gt;();&lt;/p&gt;&lt;p&gt;services.AddTransient&amp;lt;IBaseService, SyncService&amp;gt;();&lt;br/&gt;services.AddTransient&amp;lt;IBaseService, CreateDBService&amp;gt;();&lt;br/&gt;services.AddTransient&amp;lt;IBaseService, OnLineOrderService&amp;gt;();&lt;/p&gt;
&lt;p&gt;var serviceProvider = services.BuildServiceProvider();&lt;/p&gt;
&lt;p&gt;ServiceRunner&amp;lt;ServiceFactory&amp;gt;.Run(config =&amp;gt;&lt;br/&gt;{&lt;br/&gt;var name = config.GetDefaultName();&lt;br/&gt;config.Service(serviceConfig =&amp;gt;&lt;br/&gt;{&lt;br/&gt;serviceConfig.ServiceFactory((extraArguments, controller) =&amp;gt;&lt;br/&gt;{&lt;br/&gt;return new ServiceFactory(serviceProvider.GetService&amp;lt;IEnumerable&amp;lt;IBaseService&amp;gt;&amp;gt;(), controller);&lt;br/&gt;});&lt;br/&gt;serviceConfig.OnStart((service, extraArguments) =&amp;gt;&lt;br/&gt;{&lt;br/&gt;Console.WriteLine(&quot;Service {0} started&quot;, name);&lt;br/&gt;service.Start();&lt;br/&gt;});&lt;/p&gt;
&lt;p&gt;serviceConfig.OnStop(service =&amp;gt;&lt;br/&gt;{&lt;br/&gt;Console.WriteLine(&quot;Service {0} stopped&quot;, name);&lt;br/&gt;service.Stop();&lt;br/&gt;});&lt;/p&gt;
&lt;p&gt;serviceConfig.OnError(e =&amp;gt;&lt;br/&gt;{&lt;br/&gt;Console.WriteLine(&quot;Service {0} errored with exception : {1}&quot;, name, e.Message);&lt;br/&gt;});&lt;br/&gt;});&lt;/p&gt;
&lt;p&gt;config.SetName(&quot;SAASService&quot;);&lt;br/&gt;config.SetDescription(&quot;SAAS Service For All Saas Client&quot;);&lt;br/&gt;config.SetDisplayName(&quot;SAAS Service&quot;);&lt;br/&gt;});&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jan 2018 07:29:00 +0000</pubDate>
<dc:creator>留云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jfliuyun/p/8242945.html</dc:identifier>
</item>
<item>
<title>从初识Maven到使用Maven进行依赖管理和项目构建 - MindMrWang</title>
<link>http://www.cnblogs.com/MindMrWang/p/8242559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MindMrWang/p/8242559.html</guid>
<description>&lt;p&gt;前些天就安装了Maven，以备自己以后整合项目用，尤其是我们的ssh，ssm项目。想必好多人在开始的时候并不清楚Maven是什么，它能够帮助我们干什么。&lt;br/&gt;所以在学习Maven之前我们一定要知道它是什么，并且知道它能够帮助我们干什么！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maven是什么：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171218213520742?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;这里博主就偷个懒，引用了百度百科上面的解释，它的解释可能不一定完全描述这个Maven，但是对于初学者我们知道这个就行了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maven能够帮助我们干什么：&lt;/strong&gt;&lt;br/&gt;它的主要两个功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;依赖管理（jar包管理）&lt;/li&gt;
&lt;li&gt;构建项目&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;①我们知道java项目（web）在开发的过程中需要大量的jar包，这个导致我们的项目会非常的庞大，通过Maven，我们web项目再也不用导jar包了，我们只需要在Maven的主配置文件中添加相应jar包的标识（标识：公司或者组织名+项目名+版本号）就好了。&lt;/p&gt;
&lt;p&gt;②项目的构建，我们可以通过Maven构建Maven项目，它开创了一套目录结构，对各种文件的分类更加的细致。&lt;/p&gt;
&lt;p&gt;简单的介绍就到这里，更深入的我们后面慢慢提及。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;一下载安装&quot;&gt;（一）下载安装&lt;/h2&gt;
&lt;p&gt;废话少说，接下来我们到官网上下载Maven：&lt;a href=&quot;http://maven.apache.org/&quot; class=&quot;uri&quot;&gt;http://maven.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171218214322240?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载你想要的版本，然后解压到你的本地磁盘（路径不能有中文），最后就是配置环境变量（Maven的工作环境要有jdk，即要使用Maven就要有jdk环境），关于配置环境变量：前些天我碰到个小问题在也在我的一篇博文中简单描述了一下：&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/qq_39266910/article/details/78708412&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq_39266910/article/details/78708412&lt;/a&gt;&lt;br/&gt;有兴趣的同学可以去看看！&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;二maven仓库分类及配置&quot;&gt;（二）Maven仓库分类及配置&lt;/h2&gt;
&lt;p&gt;解压Maven过后就要配置Maven本地仓库，在说本地仓库前，我们先了解下Maven的分类：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219140909362?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;（图片来自网络）&lt;/p&gt;
&lt;p&gt;这个就是Maven仓库的三种类型，一个是我们程序员本地计算机上的本地仓库，默认目录为：&lt;strong&gt;C:\Users\john.m2\repository&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然我们可以修改这个路径，也就是配置我们的本地仓库了：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219141247526?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再涂鸦的路径下的setting文件下，找到&lt;code&gt;&amp;lt;localRepository&amp;gt;&lt;/code&gt;标签（原来在注释中，需要我们将它复制出来），并填上你想要的本地仓库路径。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三在eclipse中创建maven项目&quot;&gt;（三）在eclipse中创建Maven项目&lt;/h2&gt;
&lt;p&gt;和我们通常创建项目一样，我们可以在File→new→&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219145345501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;填写工作组，项目名，就可以完成创建Maven项目了。&lt;/p&gt;
&lt;p&gt;下面我们来看看Maven项目的目录结构：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219150724454?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四maven常用的命令&quot;&gt;（四）Maven常用的命令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;以下所有的命令都要在项目的根目录下进行。&lt;/strong&gt;&lt;br/&gt;Maven提供了一套命令，我们可以在dos小黑窗中使用，当对Maven项目使用这些命令的时候我们应该切换到该项目的根目录下。&lt;br/&gt;命令一：&lt;br/&gt;&lt;strong&gt;mvn clean&lt;/strong&gt;&lt;br/&gt;这个命令可以清除我们的target文件夹（这个文件夹存放编译后的.class文件）&lt;/p&gt;
&lt;p&gt;命令二：&lt;br/&gt;&lt;strong&gt;mvn compile&lt;/strong&gt;&lt;br/&gt;和上面的命令相反，这个命令是编译一个项目的，前提是我们当前命令行位置为该项目的根目录下。&lt;/p&gt;
&lt;p&gt;命令三：&lt;br/&gt;&lt;strong&gt;mvn test&lt;/strong&gt;&lt;br/&gt;这个命令可以进行单元测试，测试test文件夹下的方法（test文件夹下的java文件格式名为：XxxTest.java）&lt;/p&gt;
&lt;p&gt;命令四：&lt;br/&gt;&lt;strong&gt;mvn package&lt;/strong&gt;&lt;br/&gt;将项目打包，如果是java项目就打包为.jar文件，如果是web项目及打包成.war文件。&lt;/p&gt;
&lt;p&gt;命令五：&lt;br/&gt;&lt;strong&gt;mvn install&lt;/strong&gt;&lt;br/&gt;将一个项目打包放在本地仓库中，以便多个项目使用。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;五在eclipse中配置maven&quot;&gt;（五）在eclipse中配置Maven&lt;/h2&gt;
&lt;p&gt;我们之前在eclipse中创建了项目，那个使用eclipse中自带的Maven插件，我们想要用自己安装的Maven，需要在eclipse中配置：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219153314747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在首选项的Maven中安装，add→directory中选择自己安装的目录。&lt;br/&gt;然后别忘了勾选我们自己的Maven。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我们还需要指定我们Maven的仓库位置，也就是让eclipse知道我们的仓库在哪，我们只要将Maven中已经设置好的setting.xml指定给它就行，因为里面已经含有我们自定义仓库的位置，设置后下面就会自动出现我本地仓库的位置。&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219153659418?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成上面的操作后，我们还需要重构索引，即将仓库中的内容让eclipse加载一下：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219154224531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就能在eclipse local Repository中查看我们本地仓库的内容了。&lt;/p&gt;
&lt;p&gt;如果你完成了上述的操作，那么恭喜你，你的eclipse就完全支持maven操作了！&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;六创建maven项目容易出现的问题&quot;&gt;（六）创建Maven项目容易出现的问题&lt;/h2&gt;
&lt;p&gt;在创建好Maven项目后老是会出现一些问题：&lt;br/&gt;①jdk版本出错&lt;br/&gt;Maven（我的这个版本）默认是使用jdk1.5，如果你想要使用自己的jdk的话需要右击项目，build path ，edit一下当前项目使用的jdk就ok了。&lt;/p&gt;
&lt;p&gt;②缺少web.xml&lt;br/&gt;当我们创建好项目的时候可能缺少web.xml,这个时候我们需要自己手动的添加。&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219190502593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③刷新项目，jdk版本又返回jdk1.5&lt;br/&gt;我们在做项目的时候，依赖在不断的增加，所以需要刷新项目来使得eclipse知道我们的jar包在哪，所以需要更新Maven项目：&lt;br/&gt;右击项目→Maven→Update Project，然后我们的jdk会返回jdk1.5（因为项目默认jdk1.5），所以需要我们手动添加对jdk的约束：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置全局的jdk，在setting.xml文件中的profiles元素下添加如下profile元素：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;profile&amp;gt;  
    &amp;lt;id&amp;gt;jdk17&amp;lt;/id&amp;gt;  
    &amp;lt;activation&amp;gt;  
        &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt;  
        &amp;lt;jdk&amp;gt;1.8&amp;lt;/jdk&amp;gt;  
    &amp;lt;/activation&amp;gt;  
    &amp;lt;properties&amp;gt;  
        &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;  
        &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;  
        &amp;lt;maven.compiler.compilerVersion&amp;gt;1.8&amp;lt;/maven.compiler.compilerVersion&amp;gt;  
    &amp;lt;/properties&amp;gt;   
&amp;lt;/profile&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;设置局部的jdk，在项目的pom,xml文件中添加如下build元素：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;build&amp;gt;  
    &amp;lt;plugins&amp;gt;  
        &amp;lt;plugin&amp;gt;  
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;  
            &amp;lt;configuration&amp;gt;  
                &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;  
                &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
                &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;  
            &amp;lt;/configuration&amp;gt;  
        &amp;lt;/plugin&amp;gt;  
    &amp;lt;/plugins&amp;gt;  
&amp;lt;/build&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;七添加依赖&quot;&gt;（七）添加依赖&lt;/h2&gt;
&lt;p&gt;做了那么多准备工作，下面我们就来试试Maven怎么进行依赖管理。&lt;br/&gt;我们在Maven项目中创建一个Servlet，我们需要导入servlet-api.jar,只要在pom.xml 的dependencies视图下进行add就好了，如下图：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219214336778?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;在涂鸦的搜索栏里搜索你想要的jar包，然后update Maven项目就ok了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;容易出现的问题：&lt;/strong&gt;&lt;br/&gt;搜索不出结果，试着做如下操作：&lt;br/&gt;首选项→Maven→勾选涂鸦的选项&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219214555510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219214758071?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就会帮你下载一些常用jar包，过程有点慢，等待片刻！&lt;br/&gt;最后Update Index 就ok了！&lt;/p&gt;
&lt;p&gt;这样就可以放心的添加依赖了。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;八依赖范围&quot;&gt;（八）依赖范围&lt;/h2&gt;
&lt;p&gt;在我们设置依赖的时候，会有一项Scope，里面有：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219215122713?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;compile，provided，runtime，test，system五项。&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171219215242189?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;（图片来自网络）&lt;/p&gt;
&lt;p&gt;Maven默认的是compile，即对于编译classpath，测试classpath，运行时classpath 都需要这个jar包。&lt;br/&gt;&lt;strong&gt;尤其值得注意的是provided，这个就像servlet-api那样，我们编译测试都需要这个jar包，但是当上传到服务器的时候就不再需要了（Tomcat的lib下有），如果这里我们默认compile，那么当程序在服务器上运行的时候将出现jar包的冲突！&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;九使用maven运行web项目&quot;&gt;（九）使用Maven运行web项目&lt;/h2&gt;
&lt;p&gt;在eclipse中，我们是直接打开Tomcat，并将项目添加到Tomcat上，Maven也可以直接启动Tomcat而不需要借助Eclipse，具体的步骤：&lt;br/&gt;&lt;strong&gt;右击项目→Run As→Maven Build ...&lt;/strong&gt;&lt;br/&gt;然后在Goals中输入：&lt;br/&gt;&lt;strong&gt;tomcat：run&lt;/strong&gt;，这样我们就将这个项目发布到服务器上了。&lt;/p&gt;
&lt;p&gt;Debug：&lt;br/&gt;&lt;strong&gt;右击项目→Debug As→Maven Build ...&lt;/strong&gt;&lt;br/&gt;然后在Goals中输入：&lt;br/&gt;&lt;strong&gt;tomcat:run&lt;/strong&gt;,和发布不同的是，我们需要将项目的源码关联进来！&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171220083949417?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;过程：点击Source→add→Project→你想Debug的项目。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;十依赖冲突解决&quot;&gt;（十）依赖冲突解决&lt;/h2&gt;
&lt;p&gt;什么叫依赖冲突，在介绍它和解决它之前，我们先来了解下什么事传递依赖：&lt;br/&gt;在一个Maven项目中，我们导入一个包后，Maven会帮你把它的依赖包全部导入进来，例如：你导入Struts2-core-2.3.5.jar，它会帮你把Struts2工程所需要的包全部导入进来，如果导入进来的jar包又依赖其他jar包，Maven会继续导入这个其他jar包。&lt;/p&gt;
&lt;p&gt;所以就会产生这样一个状况：&lt;br/&gt;A依赖B，B依赖C，A依赖C，这样叫一个传递依赖。&lt;/p&gt;
&lt;p&gt;在上述的情况下，如果这个时候导入依赖D，D依赖C，这个时候就可能出现两个C，就会产生依赖冲突！&lt;/p&gt;
&lt;p&gt;解决方案：&lt;br/&gt;其实Maven不会让这两个jar包冲突，它有一套默认的调节原则：&lt;br/&gt;&lt;strong&gt;①声明优先原则：&lt;/strong&gt;&lt;br/&gt;如果B依赖的C和D依赖的C冲突，那么使用B依赖的C jar包，因为B提前导入。&lt;br/&gt;&lt;strong&gt;②最短路径原则：&lt;/strong&gt;&lt;br/&gt;如果我们就是想要使用D依赖的C jar包，我们只需要自己手动add依赖即可，Maven优先使用我们手动添加的依赖！&lt;/p&gt;
&lt;p&gt;除了上面的两种方案，还有两种叫分别叫做&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①依赖排除&lt;/strong&gt;&lt;br/&gt;具体的实在pom.xml的依赖层次视图下进行：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171220101247698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;这样就可以手动的排除你不想使用的依赖jar包了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②版本锁定（推荐使用）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&amp;lt;/version&amp;gt;             
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
  &amp;lt;/dependencyManagement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在配置文件里添加上面这个依赖管理，就可以指定我们想要的jar包版本，同时我们还可以使用ognl表达式来管理版本（当版本更新的时候）&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171220102948419?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171220103044541?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们版本需要更新的时候，不必一个个去更换，只需要更换properties中的版本信息就Ok了！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;总结：&lt;br/&gt;Maven给我们构建项目和依赖管理带来了很大的便利，再也不需要我们苦恼导入jar包，和jar包版本冲突，并且提供了一套从编译到发布的方法，大大提高和加快了我们项目的项目进度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本章主要就Maven的一些简单用法做出了一点介绍，希望给大家一点启发，如果错误，不吝赐教，万分感激！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jan 2018 06:35:00 +0000</pubDate>
<dc:creator>MindMrWang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MindMrWang/p/8242559.html</dc:identifier>
</item>
<item>
<title>(五)：C++分布式实时应用框架——微服务架构的演进 - smartguy</title>
<link>http://www.cnblogs.com/cdap/p/8204569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cdap/p/8204569.html</guid>
<description>&lt;h2&gt;C++分布式实时应用框架——微服务架构的演进&lt;/h2&gt;

&lt;p&gt;上一篇：&lt;a title=&quot;发布于2017-12-14 09:45&quot; href=&quot;http://www.cnblogs.com/cdap/p/8032851.html&quot;&gt;(四)：C++分布式实时应用框架——状态中心模块&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;版权声明:本文版权及所用技术归属smartguys团队所有，对于抄袭，非经同意转载等行为保留法律追究的权利！&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;OCS(online charging system，在线计费系统)在进行云化改造的过程中，从实用主义角度出发，微服务架构并不是我们的目标。虽然我们也对系统进行了容器化改造(Docker)，并根据业务进程的功能将系统分成了好几类的容器，但这一切多是出于对系统中的某些处理节点进行动态扩缩容的需要，跟微服务半点关系没有。随着系统改造 的深入，系统的通讯关系复杂程度开始超过我们之前的估计。如果说数量众多的功能节点还有人可以勉强掌握，这些节点间错综复杂的通讯关系连线已超过程序员可以驾驭的范畴。在讨论如何简化程序员实现整个系统各类节点的通讯关系的配置过程中，节点微服务化的理念渐渐进入我们的脑海之中……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面先给大家介绍下我们所面临的困境，下面的图是我们系统一部分节点的通讯关系总图(注意，只是其中一部分):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1271768/201801/1271768-20180105152721674-1023018472.jpg&quot; alt=&quot;&quot; width=&quot;1087&quot; height=&quot;1219&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;还记得第二篇《基于ZeroMQ的实时通讯平台》中那个我们引以为傲的通讯配置文件吗，就是程序中所有的通讯连接关系不再是写死在代码中，而是通过AppInit.json配置文件进行配置，程序启动的时候再由CDRAF进行实时加载。当初酷炫的功能，现在却成我们的恶梦。此时AppInit.json这个文件已到达1700多行，你没看错，一个配置文件1700多行，并且还不是全部，还会继续变大。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OLC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AUTO_START&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YES&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ENDPOINTS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : [
         {  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于与SmartMonitor建立心跳&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MonitorSUB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,   
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CONNECT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ZMQ的连接模式&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZMQ_SUB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ZMQ的通讯模式&lt;/span&gt;
&lt;span&gt;         },
         {　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下发消息给OCDis，这边存在转发功能，支持业务实现按条件转发&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;downstream&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis2OLC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NE2OLC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据这个名字在业务代码中实现转发&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BIND&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZMQ_STREAM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
         },
         {　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; OLC到OCDis的链路&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis2OLC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;statistics_on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CONNECT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZMQ_DEALER&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
         },
         {　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; OCDis回OLC的链路，之所以来去分开，主要用于实现优雅启停功能（启停节点保证不丢消息）&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis2OLC_Backway&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;statistics_on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CONNECT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZMQ_DEALER&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;backway_pair&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis2OLC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
         },
         {　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于与SmartMonitor的命令消息链路&lt;/span&gt;
            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OLC2Monitor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CONNECT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZMQ_DEALER&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
         },
      ],
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ENDPOINT_TO_MONITOR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OLC2Monitor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSTANCE_GROUP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : [
         {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;instance_endpoints_address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : [
               {
                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;endpoint_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NE2OLC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp://*:6701&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
               },
               {
                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;endpoint_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis2OLC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : [
                     &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp://127.0.0.1:7201&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跨机的IP地址与端口，配合状态中心可实现自动管理，无需人工参与配置&lt;/span&gt;
&lt;span&gt;                  ]
               },
               {
                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;endpoint_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis2OLC_Backway&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : [
                     &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp://127.0.0.1:7202&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                  ]
               },
               {
                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;endpoint_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OLC2Monitor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ipc://Monitor2Business_IPC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
               },
               {
                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;endpoint_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MonitorSUB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zmq_socket_address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ipc://MonitorPUB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
               }
            ],
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;instance_group_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
         }
      ]
   },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;一个业务程序员如果要调整系统中某个程序的通讯连接，一定得盯着上面那副图研究半天，并且要搞明白“CONNECT”、“BIND&quot;、”ZMQ_ROUTER&quot;、“ZMQ_DEALER&quot;等等这些zeromq专业词汇的含义，才可能进行准确配置，我们隐隐感到这已是一个mission impossible。如何简化这个配置文件，如何对系统的复杂度进行分层，让不同层级的人员仅仅只需关注自身层级情况，再通过我们的CDRAF最终将这些散落的配置、代码组成一个完成可运行的系统才是我们现在亟需解决的问题。相信这也是每个系统架构师所面临的问题，当一个系统的复杂度超过单个人可承受能力范围，就要对这个系统进行适当分层，分模块。让每个人去管理一小部分复杂点，并且大家只需实现好自己的模块，无需去关心别的模块的实现细节。通过事先设计好的接口，各个模块可以相互协作，整体系统是可以依此完美地运行的。这里CDARF正是起这么一个不同模块的桥梁(接口)的作用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　一、节点间通讯模式的统一&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　原来节点内的应用程序都是通讯全能应用程序，所谓全能是指应用程序既可以跟节点内的进程进行通讯也可以跟节点外的任意进程进行通讯。这样乍看起来没啥问题，但一旦节点数和进程数变多后，通讯关系将是一个指数级增长的过程。如下图，如果再增加一个CDR节点，或者OCS节点，连接数都将增加非常多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1271768/201801/1271768-20180105161505612-1984112449.png&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;506&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;我们的解决办法是统一节点的通讯模式，每个节点内都有一个Dis进程，统一对外负责跟其他节点进行通讯。在收到外部发给节点的消息后，根据功能和负载转发给内部业务处理进程。业务进程如果有消息需要发往别的节点，就直接发给Dis进程，由它进行转发。统一通讯模式带来的好处除了在节点和进程增多后，通讯关系不会变得太复杂以外。由于模式统一， CDARF可以替业务程序员完成很多工作，直接的好处就是业务程序员不再需要配置很多与业务无关的配置。最大化的将通讯模块的复杂度留给CDRAF去处理，业务程序员将更加专注于自身的业务逻辑。下面的图中其实系统开始已经有微服务的样子，但我们希望做到的不仅是从系统架构上是微服务架构，在程序员开发程序的时候，也应该是带着微服务思维的，我们的CDRAF应该提供这么一种能力来支持这种开发模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1271768/201801/1271768-20180105162240815-421919794.png&quot; alt=&quot;&quot; width=&quot;788&quot; height=&quot;478&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;　　二、配置文件的简化&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;通讯模式统一后，我们对通讯配置文件进行了一次较大的简化，从原来1700行减少到了200行左右。这当中省去了很多冗余的配置项，通讯配置文件不再是对系统通讯简单直接的对应，而更多的是对节点通讯能力的一种表述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　应用程序分为Dis和非Dis两类，Dis类程序主要承担节点间的通讯和节点内的消息转发，非Dis类程序就是普通的业务处理进程。从下面的文件中可以看到“OCDis”进程中分为“&lt;/span&gt;&lt;span&gt;InterContainerEndpoints”和“InnerContainerEndpoints”两大类，分别表示节点间的通讯和节点内的通讯。对于节点间的通讯，每个服务端口只要写上相应的“服务名字”就可以以了，配置中的“OCDisCDRDis”表示OCSDis与CDRDis的通讯，“OLCDisOLCProxy”、“OCDis_SyDis_SNR”也是类似。当业务侧程序需要对外提供一个服务（或者说与外部进行通讯），只需要写一个服务名字，而如：端口、机器的IP地址、服务端还是客户端、通讯模式等等都完全不需要去关心，这是多大一种便利。配置中的注释部分是不需要业务程序员去填的，而是由CDRAF的状态中心，根据集群节点的实时情况自动生成，并进行连接和维护。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MaxInstanceGroupNum&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InterContainerEndpoints&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDisCDRDis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 
      {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;Port&quot;: [6001, 6002, 6003],
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;Cluster&quot;: [&quot;10.45.4.10:6001&quot;, &quot;10.45.4.10:6001&quot;]&lt;/span&gt;
&lt;span&gt;      },

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDisOLCProxy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 
      {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;Port&quot;: [6101, 6102, 6103],&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownStreams&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis2IN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis2PS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis2SMS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis2ISMP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis2IMS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      },
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis_SyDis_SNR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 
      { 
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;Peer&quot;: &quot;ZSmartSyDis.OCDis_SyDis_SNR&quot; &lt;/span&gt;
&lt;span&gt;      }
    },

    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InnerContainerEndpoints&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCPro_OCDis_CDR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownStreams&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDisCDRDis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] },
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCPro_OCDis_SNR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownStreams&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis_SyDis_SNR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] },
    }
  },

  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCPro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Groups&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SMS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IMS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ISMP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InnerContainerEndpoints&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCPro2OCDis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PeerMap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis.OCDis2IN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis.OCDis2PS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis.OCDis2SMS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis.OCDis2ISMP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis.OCDis2IMS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        ]
      },
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCPro_OCDis_SNR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Peer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis.OCPro_OCDis_SNR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCPro_OCDis_CDR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Peer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
    }
  },

  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CDRDis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InterContainerEndpoints&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OCDisCDRDis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : 
      {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownStreams&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CDRDisCDR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;Peer&quot;: &quot;OCDis&quot;&lt;/span&gt;
&lt;span&gt;      }
    }
  },

  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CDR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InnerContainerEndpoints&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CDRDisCDR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Peer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CDRDis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
    }
  }
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;想像一下，对于每一个业务节点，开发人员仅需考虑节点内的业务实现逻辑，并为本节点对外所提供的服务起个名字，而不再需要关心这个服务到底是提供给谁，更不用操心谁会来连我的进程，怎么连。这是多么精妙的事情！我们不仅是从架构上做到了微服务架构，程序员在开发业务程序的时候，不需要去关心除了自身模块以外的其它复杂信息，从此可以轻装上阵，而不再需要负重前行。这应该就是CDRAF对微服务架构提供的最直接、最好的支持了，帮助业务程序员从传统的开发模式转变，进而适应微服务的思维方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1271768/201801/1271768-20180108134755832-1566822746.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;　　三、节点间的通讯关系配置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　上面我们提到配置文件只定义了节点的服务名，那么这么多的微服务节点是如何组合起来工作的？一个业务应用系统会由许多的微服务一起协同提供服务，这些服务对于每个不同的现场可能功能是不一样的，或者说微服务集合是不一样的。那么，对这些微服务的组合的过程就像一个“编排”的过程。通过“编排”，选择合适的微服务进行搭配组合提供服务，而编排的过程就是我们通讯建立的过程。下面我们就来看一下CDRAF是如何做到“编排”功能的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1271768/201801/1271768-20180108140243144-1842439441.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1271768/201801/1271768-20180108140301379-1308423585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;上面的第一张表，描述了所有的微服务列表，所有节点服务要向外通讯都必须到这张表中增加相应的服务名，这里的服务名是与前面配置文件中的服务名相对应的。第二张表描述了这些微服务名之间的通讯关系，比如第二条记录表达的是OCDis程序的OCDis2CDRDis到CDRDis的OCDis2CDRDis之间会有一个通讯关系。只要通过这个简单的配置，就可以完成两个节点间的通讯关系的建立。这样的设计会带来几个好处。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、对于一个复杂的系统，可能有几十类微服务节点，运行实例可能有上百个，如果有上面的表二，就可以容器的从上面的数据中画出整个集群的实时拓扑图，这个对于系统的监控是十分重要的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、集群通讯关系的设计上升了一个等级，业务程序员只需要根据模块接口设计提供相应的微服务节点，而不需要关心与其它微服务是如何协调工作的。而这些微服务如何“编排”提升到了架构师的工作范围的层级。这显然是对复杂度进行分层隔离很好的一个范例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、运维或者管理人员，通过表二的配置可以很容易地操作集群里的某个微服务下线或者上线。在一个庞大的集群里面，如果某类微服务出故障，而CDARF提供了这么一种手段可以去让这类故障微服务下线，将给系统的稳定性带来极大的可靠保证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.、原来集群所有的通讯都配置在一个文件中，在分布式系统中就涉及文件的全局一致性的问题。解决的方案可能是，如果要上线一个新类型的配置文件（新增节点、删除节点、通讯关系改变等等），就要去更新所有在网节点的配置文件。但此时如果新的配置文件有bug，那么可能导致整个集群的故障，并且为了升级某个功能去升级整个集群所有节点的配置也是极不合理的。在新的方案中，节点的配置只定义节点内的通讯和对外提供的微服务名。那么如果要新增某种类型的微服务，不再需要去更新其它节点的配置，只需要将新节点上线，然后在上面的表一新增微服务名，表二增加连接关系就可以了。真正做到了增量升级!&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　未完待续……&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 08 Jan 2018 06:28:00 +0000</pubDate>
<dc:creator>smartguy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cdap/p/8204569.html</dc:identifier>
</item>
<item>
<title>多线程编程学习笔记——使用并发集合（二） - DotNet菜园</title>
<link>http://www.cnblogs.com/chillsrc/p/8242502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chillsrc/p/8242502.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;接上文 &lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/8177807.html&quot;&gt;&lt;span&gt;多线程编程学习笔记——使用并发集合（一）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、   使用ConcurrentQueue来实现异步处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本示例将学习如何创建一个能被多个线程异步处理的一组任务的例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 一、程序示例代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Concurrent;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading; 

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ThreadCollectionDemo
{

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; item = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dict Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; CurrentItem;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; time1;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----  ConcurrentQueue 操作----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

            Task task &lt;/span&gt;=&lt;span&gt; TaskRun1();
            task.Wait();

            Console.Read();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task TaskRun1()
        {

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; queue = &lt;span&gt;new&lt;/span&gt; ConcurrentQueue&amp;lt;CustomTask&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cts = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationTokenSource();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; taskSrc = Task.Run(() =&amp;gt;&lt;span&gt; TaskProduct(queue));
            Task[] process &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Task[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; processId =&lt;span&gt; i.ToString();
                process[i &lt;/span&gt;- &lt;span&gt;1&lt;/span&gt;] = Task.Run(() =&amp;gt; TaskProcess(queue, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Processer &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; processId, cts.Token));
            }
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; taskSrc;
            cts.CancelAfter(TimeSpan.FromSeconds(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.WhenAll(process);
        }
 

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task TaskProduct(ConcurrentQueue&amp;lt;CustomTask&amp;gt;&lt;span&gt; queue)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; workitem = &lt;span&gt;new&lt;/span&gt; CustomTask { Id =&lt;span&gt; i };
                queue.Enqueue(workitem);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;把{0} 元素添加到ConcurrentQueue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,workitem.Id));
            }
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task TaskProcess(ConcurrentQueue&amp;lt;CustomTask&amp;gt; queue,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name,CancellationToken token)
        {
            CustomTask workitem;
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; dequeueSuccesfl = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; GetRandomDely();
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
            {
                dequeueSuccesfl &lt;/span&gt;= queue.TryDequeue(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; workitem);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dequeueSuccesfl)
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;元素 {0} 从ConcurrentQueue中取出 ，名称：{1} &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, workitem.Id, name));

                }

                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; GetRandomDely();
            }

            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;token.IsCancellationRequested);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; Task GetRandomDely()
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dely = &lt;span&gt;new&lt;/span&gt; Random(DateTime.Now.Millisecond).Next(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.Delay(dely);
        }
 
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomTask
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 2.程序运行结果如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/10343/201801/10343-20180108142412597-2090739747.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      当程序运行时，我们使用ConcurrentQueue集合实现创建了一个任务队列。然后创建了一个取消标志，它是用来在我们将任务放入队列后停止工作 的。接下来启动了一个单独的工作线程来将任务放入任务队列中。这部分分为异步处理产生了工作 量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       现在定义这个程序中消费任务的部分。我们创建了四个工作 线程，它们会随机等待一段时间，然后从任务队列中获取一个任务，处理这个任务，一直重复整个过程直到我们发出取消标志信号。最后，我们启动产生任务的线程，等待这个线程完成。然后使用取消标志给消费发信号 我们完成了工作。最后一步将等待所有的消费完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       我们看到队列中的任务按从前到后的顺序被 处理，但一个后面的任务是有可能会比前面的任务先处理的，因为我们有四个工作 线程独立地运行，而且任务处理时间并不是恒定的。我们看到 访问这个队列是线程安全的，没有一个元素会被提取两次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、   改变ConcurrentStack异步处理顺序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      本示例是对上一面的示例的修改版。我们又一次创建了被多个工作线程异步处理的一组任务，但是这次使用ConcurrentStack来实现，我们来看看这两个示例会有什么不同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1. 程序的代码如下图。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Concurrent;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading; 

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ThreadCollectionDemo
{

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {       

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----  ConcurrentStack 操作----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            Task task &lt;/span&gt;=&lt;span&gt; TaskStack();
            task.Wait();
            Console.Read();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task TaskStack()
        { 

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stack = &lt;span&gt;new&lt;/span&gt; ConcurrentStack&amp;lt;CustomTask&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cts = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationTokenSource();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; taskSrc = Task.Run(() =&amp;gt;&lt;span&gt; TaskProduct(stack));
            Task[] process &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Task[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; processId =&lt;span&gt; i.ToString();
                process[i &lt;/span&gt;- &lt;span&gt;1&lt;/span&gt;] = Task.Run(() =&amp;gt; TaskProcess(stack, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Processer &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; processId, cts.Token));
            }

            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; taskSrc;
            cts.CancelAfter(TimeSpan.FromSeconds(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.WhenAll(process);
        }
 

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task TaskProduct(ConcurrentStack&amp;lt;CustomTask&amp;gt;&lt;span&gt; stack)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; workitem = &lt;span&gt;new&lt;/span&gt; CustomTask { Id =&lt;span&gt; i };
                stack.Push(workitem);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;把{0} 元素添加到ConcurrentStack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,workitem.Id));
            }
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task TaskProcess(ConcurrentStack&amp;lt;CustomTask&amp;gt; stack,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name,CancellationToken token)
        {

            CustomTask workitem;
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; popSuccesful = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; GetRandomDely();
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
            {
                popSuccesful &lt;/span&gt;= stack.TryPop(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; workitem);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (popSuccesful)
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;元素 {0} ConcurrentStack  取出 ，名称：{1} &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, workitem.Id, name));
                }
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; GetRandomDely();
            }
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;token.IsCancellationRequested);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; Task GetRandomDely()
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dely = &lt;span&gt;new&lt;/span&gt; Random(DateTime.Now.Millisecond).Next(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.Delay(dely);
        } 
    } 
}

 

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 2.程序的运行结果如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/10343/201801/10343-20180108142446644-930062161.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        当程序运行时，我们创建了一个ConcurrentStack集合的实例。其余的代码与前一示例几乎一样，唯一不同之年是我们对并发堆栈使用了Push和TryPop方法，而对并发队列使用Enqueue和TryDequeue方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       从上图结果中可以扯到任务处理的顺序被改变了。堆栈是一个LIFO集合，工作线程先处理最近的任务。在并发队列中，任务被处理的顺序与被添加的顺序几乎一样。这说明根据工作线程的数量，我们将在一定时间内处理先被创建的任务。而在堆栈中，早先创建的任务具有较低的优先级，而且直到生产者停止向堆栈中放入更多任务后，这个任务才有可能被处理。这行为是确定 的，最好在这种场景下使用队列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 08 Jan 2018 06:26:00 +0000</pubDate>
<dc:creator>DotNet菜园</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chillsrc/p/8242502.html</dc:identifier>
</item>
<item>
<title>C#设计模式之二十三解释器模式（Interpreter Pattern）【行为型】 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/8242238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/8242238.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   今天我们开始讲“行为型”设计模式的第十一个模式，也是面向对象设计模式的最后一个模式，先要说明一下，其实这个模式不是最后一个模式（按Gof的排序来讲），为什么把它放在最后呢？因为我们在业务系统中写一个解释器的机会并不是很多，实践比较少，理解和应用该模式就有些困难，所以就放在最后来说。该模式就是【解释器模式】，英文名称是：Interpreter Pattern。按老规矩，先从名称上来看看这个模式，个人的最初理解“解释器”和Google的中英翻译功能类似。如果有一天你去国外旅游去了，比如去美国吧，美国人是讲英语的，我们是讲汉语的，如果英语听不懂，讲不好，估计沟通就完蛋了，不能沟通，估计玩的就很难尽兴了，因为有很多景点的解说你可能不明白（没有中文翻译的情况下，一般情况会有的）。所以我们需要一个软件，可以把中英文互译，那彼此就可以更好的理解对方的意思，我感觉翻译软件也可以称得上是解释器，把你不懂的解释成你能理解的。我们写代码，需要编译器把我们写的代码编译成机器可以理解的机器语言，从这方面来讲，C#的编译器也是一种解释器。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、解释器模式的详细介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1、动机（Motivate）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   在软件构建过程中，如果某一特定领域的问题比较复杂，类似的模式不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2、意图（Intent）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。　　　　　　                                ——《设计模式》GoF&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.3、结构图（Structure）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img src=&quot;https://images2017.cnblogs.com/blog/1048776/201801/1048776-20180108133321191-127249853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.4、模式的组成&lt;/strong&gt;&lt;br/&gt;    &lt;br/&gt;    可以看出，在解释器模式的结构图有以下角色：&lt;br/&gt; &lt;br/&gt;    &lt;strong&gt;（1）、抽象表达式(AbstractExpression)&lt;/strong&gt;：定义解释器的接口，约定解释器的解释操作。其中的Interpret接口，正如其名字那样，它是专门用来解释该解释器所要实现的功能。&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;（2）、终结符表达式(Terminal Expression)&lt;/strong&gt;：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;（3）、非终结符表达式(Nonterminal Expression)&lt;/strong&gt;：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;（4）、环境角色(Context)&lt;/strong&gt;：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;（5）、客户端（Client）：&lt;/strong&gt;指的是使用解释器的客户端，通常在这里将按照语言的语法做的表达式转换成使用解释器对象描述的抽象语法树，然后调用解释操作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.5、解释器模式的代码实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    在很多场合都需要把数字转换成中文，我们就可以使用解释器来实现该功能，把给定的数字解释成符合语法规范的汉字表示法。实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; InterpreterPattern
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抽象表达式&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Expression
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&amp;gt; table=&lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Expression()
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;           table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;           table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;二&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;           table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;           table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;           table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;五&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;           table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;六&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;           table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;七&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;           table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;八&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;           table.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;九&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         
&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; vritual &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Interpreter(Context context)
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt;(context.Statement.Length==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;           {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;               &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt;            &lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; table.Keys)
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;           {
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;              &lt;span&gt;int&lt;/span&gt; value=&lt;span&gt;table[key];
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt;(context.Statement.EndWidth(key+&lt;span&gt;GetPostFix()))
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;             {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                context.Data+=value*&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Multiplier();
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                context.Statement=context.Statement.Substring(&lt;span&gt;0&lt;/span&gt;,Statement.Length-&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetLength());
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;             }
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt;(context.Statement.EndWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;零&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;             {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                context.Statement=context.Statement.Substring(&lt;span&gt;0&lt;/span&gt;,Statement.Length-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;             }
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix();
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier();
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个可以通用，但是对于个位数字例外，所以用虚方法&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetLength()
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.GetPostFix().Length+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;  
&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;个位表达式&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeExpression:Expression
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetLength()
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;  
&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;十位表达式&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShiExpression:Expression
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;十&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;百位表达式&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaiExpression:Expression
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;百&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;千位表达式&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QianExpression:Expression
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;千&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;  
&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;万位表达式&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WanExpression:Expression
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;万&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Interpreter(Context context)
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt;(context.Statement.Length==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;           {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;              &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;            ArrayList tree=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; 
&lt;span&gt;138&lt;/span&gt;            tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GeExpression());
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;            tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShiExpression());
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;            tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaiExpression());
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;            tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QianExpression());
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;            &lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; table.Keys)
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;           {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(context.Statement.EndWith(GetPostFix()))
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;              {
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;context.Data;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                 context.Data=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt;                 context.Statement=context.Statement.Substring(&lt;span&gt;0&lt;/span&gt;,context.Statement.Length-&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetLength());
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt;(Expression exp &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tree)
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;                   exp.Interpreter(context);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;                 context.Data=temp+context.Data*&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Multiplier();
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; 
&lt;span&gt;162&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;亿位表达式&lt;/span&gt;
&lt;span&gt;163&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; YiExpression:Expression
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetPostFix()
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;亿&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; 
&lt;span&gt;170&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Multiplier()
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;100000000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; 
&lt;span&gt;175&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Interpreter(Context context)
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;            ArrayList tree=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; 
&lt;span&gt;179&lt;/span&gt;            tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GeExpression());
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;            tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShiExpression());
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;            tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaiExpression());
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;            tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QianExpression());
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; 
&lt;span&gt;184&lt;/span&gt;            &lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; table.Keys)
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;           {
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(context.Statement.EndWith(GetPostFix()))
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;              {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;context.Data;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;                 context.Data=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;                 context.Statement=context.Statement.Substring(&lt;span&gt;0&lt;/span&gt;,Statement.Length-&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetLength());
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; 
&lt;span&gt;192&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt;(Expression exp &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tree)
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;                   exp.Interpreter(context);
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;                 context.Data=temp+context.Data*&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Multiplier();
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;  
&lt;span&gt;202&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;环境上下文&lt;/span&gt;
&lt;span&gt;203&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Context
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _statement;
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _data;
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; Context(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; statement)
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;       {
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;            &lt;span&gt;this&lt;/span&gt;._statement=&lt;span&gt;statement;
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; 
&lt;span&gt;213&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Statement
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt;       {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;           &lt;span&gt;get&lt;/span&gt;{&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._statement;}
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;           &lt;span&gt;set&lt;/span&gt;{&lt;span&gt;this&lt;/span&gt;._statement=&lt;span&gt;value;}
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt; 
&lt;span&gt;219&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Data
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; &lt;span&gt;       {
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;            &lt;span&gt;get&lt;/span&gt;{&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._data;}
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;            &lt;span&gt;set&lt;/span&gt;{&lt;span&gt;this&lt;/span&gt;._data=&lt;span&gt;value;}
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; 
&lt;span&gt;226&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; roman=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;五亿七千三百零二万六千四百五十二&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分解：((五)亿)((七千)(三百)(零)(二)万)
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;((六千)(四百)(五十)(二))&lt;/span&gt;
&lt;span&gt;233&lt;/span&gt; 
&lt;span&gt;234&lt;/span&gt;             Context context=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Context(roman);
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;             ArrayList tree=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; 
&lt;span&gt;237&lt;/span&gt;             tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GeExpression());
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;             tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShiExpression());
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;             tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaiExpression());
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;             tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QianExpression());
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;             tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WanExpression());
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;             tree.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; YiExpression());
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; 
&lt;span&gt;244&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt;(Expression exp &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tree)
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt; &lt;span&gt;              exp.Interpreter(context);
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;  
&lt;span&gt;249&lt;/span&gt; &lt;span&gt;            Console.Write(context.Data);
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt; 
&lt;span&gt;251&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;三、解释器模式的实现要点：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧方便地“扩展”文法。&lt;/p&gt;&lt;p&gt;　　Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。&lt;/p&gt;&lt;p&gt;    &lt;span&gt;&lt;strong&gt;（1）、解释器模式的主要优点有：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        1】、易于改变和扩展文法。&lt;/p&gt;&lt;p&gt;        2】、每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。&lt;/p&gt;&lt;p&gt;        3】、实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。&lt;/p&gt;&lt;p&gt;        4】、增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”&lt;/p&gt;&lt;p&gt;　&lt;span&gt;&lt;strong&gt;（2）、解释器模式的主要缺点有：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        1】、对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。&lt;/p&gt;&lt;p&gt;        2】、执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。&lt;/p&gt;&lt;p&gt;    &lt;span&gt;&lt;strong&gt;（3）、在下面的情况下可以考虑使用解释器模式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        Interpreter模式的应用场合是Interpreter模式应用中的难点，只有满足“业务规则频繁变化，且类似的模式不断重复出现，并且容易抽象为语法规则的问题”才适合使用Interpreter模式。&lt;/p&gt;&lt;p&gt;        1】、当一个语言需要解释执行，并可以将该语言中的句子表示为一个抽象语法树的时候，可以考虑使用解释器模式（如XML文档解释、正则表达式等领域）&lt;/p&gt;&lt;p&gt;        2】、一些重复出现的问题可以用一种简单的语言来进行表达。&lt;/p&gt;&lt;p&gt;        3】、一个语言的文法较为简单.&lt;/p&gt;&lt;p&gt;        4】、当执行效率不是关键和主要关心的问题时可考虑解释器模式（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;四、.NET 解释器模式的实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     正则表达式就是一个典型的解释器。ASP.NET中，把aspx文件转化为dll时，会对html语言进行处理，这个处理过程也包含了解释器的模式在里面。Interpreter模式其实有Composite模式的影子，但它们解决的问题是不一样的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    今天就写到这里了，23种设计模式都写完了，有时间了，再写一篇文章，为这个系列做一个总结，同时也做一个设计模式的目录，方便大家浏览和学习。解释器模式可以和其他模式混合使用，具体的使用方法和解决的问题我列出了一个表，大家好好了解一下，或许对大家有些帮助。列表如下：&lt;/p&gt;&lt;p&gt;     &lt;span&gt;&lt;strong&gt;（1）解释器和组合模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;          这两种可以组合使用，一般非终结符解释器相当于组合模式中的组合对象，终结符解释器相当于叶子对象。&lt;/p&gt;&lt;p&gt;     &lt;span&gt;&lt;strong&gt;（2）解释器模式和迭代器模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;          由于解释器模式通常使用组合模式来实现，因此在遍历整个对象结构时，可以使用迭代器模式。&lt;/p&gt;&lt;p&gt;     &lt;span&gt;&lt;strong&gt;（3）解释器模式和享元模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;          在使用解释器模式的时候，可能会造成多个细粒度对象，如各式各样的终结符解释器，而这些终结符解释器对不同的表达式来说是一样的，是可以共用的，因此可以引入享元模式来共享这些对象。&lt;/p&gt;&lt;p&gt;     &lt;span&gt;&lt;strong&gt;（4）解释器模式和访问者模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;         在解释器模式中，语法规则和解释器对象是有对应关系的。语法规则的变动意味着功能的变化。自然会导致使用不同的解释器对象；而且一个语法规由可以被不同的解释器解释执行。因此在构建抽象语法树的时候，如果每个节点所对应的解释器对象是固定的，这意味着该节点对应的功能是固定的，那么就不得不根据需要来构建不同的抽象语法树。为了让构建的抽象语法树较为通用，那就要求解释器的功能不要那么固定，要能很方便地改变解释器的功能，这个时候就变成了如何能够很方便地更改树形结构中节点对象的功能了，访问者模式可以很好的实现这个功能。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jan 2018 05:34:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/8242238.html</dc:identifier>
</item>
<item>
<title>软件测试人员如何测试需求频繁变动的项目 - 资深Tester_王豆豆</title>
<link>http://www.cnblogs.com/evangline/p/8242177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evangline/p/8242177.html</guid>
<description>&lt;p&gt;王豆豆最近一直在加班，天天都加班到九点多，项目大多是紧急上线，但其实每天的工作量并不算多，按理说应该在上班时间就能完成，但每天到了下班时间却走不了，不得不留下来继续做。&lt;/p&gt;
&lt;p&gt;留下来加班的原因无非二种：1，项目需要上线；2，测试任务没有完成&lt;/p&gt;
&lt;p&gt;测试任务没有完成的情况比较少，常态是每天临近下班的时候，开发要不就在这个时候转测，要不就是临时有一个小功能修改完要上线，又或者是紧急安排了一个需求会议，又或者是联测等。&lt;/p&gt;
&lt;p&gt;什么是紧急项目呢？&lt;/p&gt;
&lt;p&gt;紧急项目是那类上线时间很紧急的项目，比如今天转测，就要求今天或明天就能上线的项目，这类项目就是属于紧急上线的项目，这类项目有一个特点就是需求不明确；测试时间短。&lt;/p&gt;
&lt;p&gt;测试人员基本都是临到转测时，才知道有这样一个测试需求，但又因为从接到这个类测试任务之时到上线的时间间隔都很短。&lt;/p&gt;
&lt;p&gt;正是因为该类项目的特点，这类项目测试结果没有保障，基本都是测试完主要流程，就匆匆上线了。还有一类项目是这类项目的加强版，是紧急项目的同时需求不断变动。&lt;/p&gt;
&lt;p&gt;王豆豆最近做了几个这类的项目，从接到项目的同时才知道测试功能和上线时间。&lt;/p&gt;
&lt;p&gt;接到这类项目基本不会编写测试计划，测试用例等文档，接到项目就开始理解需求，与开发沟通改动范围和测试范围，然后开始测试，如果是运气比较好的时候，还没开始测试就能发现以前的结构设计不对，需要改；运气不好的时候，基本都已经测试完成了，才发现需求设计不对，需要重新修改。&lt;/p&gt;
&lt;p&gt;有时改动范围不大，可能是表的数据修改了几个字段，有时改动范围大，是整体的流程都有所变化。&lt;/p&gt;
&lt;p&gt;对于测试人员来说根本没有什么改动范围不大之说，就是只改了表的几个存储字段值，也需要回归以前所有的功能。&lt;/p&gt;
&lt;p&gt;如果你觉得上面的项目已经很难了，那还有更倒霉的，测试人员明明是加班加点测试出来的项目，临到上线的却说此功能或者此版本不上了，当然这些对测试人员来说都是常态。&lt;/p&gt;
&lt;p&gt;正是因为这些事情在无形之中给测试人员增加测试时间，增加测试难度，导致测试人员对自己测试的结果不放心。&lt;/p&gt;
&lt;p&gt;那如果是你碰到这类项目，应该会怎么做呢？欢迎大家留言探讨。&lt;/p&gt;
&lt;p&gt;下面王豆豆针对做完这几个的项目后与组内成员讨论之后的应对之策：&lt;/p&gt;

&lt;p&gt;需求是源头，项目变动的原因就是需求不明确，又或者是需求改动频繁，那为什么会出现这样的问题？&lt;/p&gt;
&lt;p&gt;出现这样的问题大多都是开发人员对需求把控不够，刚开始计划是只改动一点点，也有可能是觉得自己的代码不改，兄弟方修改就行，后面等到测试过程中，测试人员提出BUG，发现需要修改代码，而且修改的范围还很大。&lt;/p&gt;
&lt;p&gt;其实出现这样的问题本质上来说是因为没有遵循测试应该尽早介入的原则。&lt;/p&gt;
&lt;p&gt;应对之策：测试人员在接到项目时，先不急于开展测试工作，可以先与相对应的需求人员和开发人员沟通，可以从先从业务流程方面与需求人员、开发人员沟通，同时知晓开发人员修改思路，代码设计结构等&lt;/p&gt;
&lt;p&gt;这不仅是测试人员在了解需求，同时也能起开发人员反思自己的代码设计，如果是设计方面的问题，大多能在此时发现，不会出现测试到一半时才发现，浪费了测试时间。&lt;/p&gt;
&lt;p&gt;但这个方法对测试人员要求极高，需要测试人员熟悉业务、熟悉场景设计、业务流程等，同时还需求测试人员对代码有一定的了解，如果讨论之前就知道整个代码的设计框架会特别有帮助。&lt;/p&gt;

&lt;p&gt;因为是紧急上线的项目，测试时间都很短，那么测试人员需要把大量的时间花测试功能上面，而不是将时间浪费在环境上面。&lt;/p&gt;
&lt;p&gt;在项目中遇到这样一种情况：&lt;/p&gt;
&lt;p&gt;当开发人员转测的当天，测试人员和开发人员当天都会花费很多时间在调试环境上面。测试环境和开发环境是相对独立的环境，这也导致了有些配置不同的地方，开发人员在转测邮件中需要明确列清本次项目需要修改的配置，那么测试人员在配置环境的时候才能配置完善。&lt;/p&gt;
&lt;p&gt;如果前面都做很好，那可以避免环境的bug，但由于某些原因，测试人员在测试过程中还是会遇到一些环境bug。&lt;/p&gt;
&lt;p&gt;测试人员在测试过程中遇到BUG时，&lt;/p&gt;
&lt;p&gt;第一，先去看BUG日志；&lt;/p&gt;
&lt;p&gt;第二，根据BUG日志定位BUG错误的原因，是环境问题还是编码问题，又或者其它问题；&lt;/p&gt;
&lt;p&gt;第三，根据分析的结果，能解决的问题尽量自己解决，比如是操作不当某个配置未配；&lt;/p&gt;
&lt;p&gt;第四，如果是编码问题，则反馈给开发人员，提交bug，如果测试人员能定位出是什么原因的导致的更好&lt;/p&gt;
&lt;p&gt;在这里并不提倡遇到某些bug，测试人员不懂，但使劲钻研，这样反而会影响效率，主要是解决环境类，接口类，因配置或操作而引起的非bug问题。&lt;/p&gt;
&lt;p&gt;同时不提倡测试人中一遇到bug不看不管，直接扔给开发人员解决，建议看bug日志，分析bug出现的原因，以便下次遇到类似bug。&lt;/p&gt;
&lt;p&gt;下面是王豆豆与群里小伙伴们一起讨论需求变动频繁，各自的所面临的困难与解决方案：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/128111/201801/128111-20180108130738972-1104825923.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/128111/201801/128111-20180108130756754-1619944888.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/128111/201801/128111-20180108130814222-1261858834.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/128111/201801/128111-20180108130830769-1148457465.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;欢迎关注微信公众号：资深Tester，了解更多的测试好文。。。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jan 2018 05:13:00 +0000</pubDate>
<dc:creator>资深Tester_王豆豆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evangline/p/8242177.html</dc:identifier>
</item>
<item>
<title>跟我一起读postgresql源码(八)——Executor(查询执行模块之——可优化语句的执行) - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/8192790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/8192790.html</guid>
<description>&lt;p&gt;可优化语句的共同特点是它们被查询编译器处理后都会生成査询计划树，这一类语句由执行器(Executor)处理。该模块对外提供了三个接口： ExecutorStart、ExecutorRun 和 ExecutorEnd,其输入是包含査询计划树的数据结构QueryDesc,输出则是相关执行信息或结果数据。如果希望执行某个计划树，仅需构造包含此计划树的QueryDesc,并依次调用ExecutorStart、ExecutorRun、ExecutorEnd 3个过程即能完成相应的处理过程。从我之前的文章&lt;a href=&quot;http://www.cnblogs.com/flying-tiger/p/6100794.html&quot;&gt;跟我一起读postgresql源码(六)——Executor(查询执行模块之——查询执行策略)&lt;/a&gt;中可以看到，执行器的三个接口函数都是在Portal的相关函数中调用的，分别负责执行器的初始化、执行和清理工作，Portal在处理时也使用了同样的方式，这样可以把资源分配回收工作与执行过程独立开，能够简化执行过程，更是一种很好的资源管理方式。&lt;/p&gt;
&lt;p&gt;执行器对于査询计划树的处理，最终被转换为针对计划树上每一个节点的处理。每种节点表示一种物理代数(Physical Algebra)操作，PostgreSQL会依次对其进行初始化、处理和清理。节点的处理被设计为demand-driven模式，父节点使用子节点提供的数据作为输入，并向其上层节点返回处理结果。实际执行时，从根节点开始处理，每个节点的执行过程会根据需求自动调用子节点的执行过程来获取输入数据(一般为元组)，从而层层递归执行，实现整个计划树的遍历执行过程。初始化和清理也采用相同的设计模式，这种设计模式使得节点处理的代码结构简洁统一、语义明确，且实现方式简单有效。&lt;/p&gt;
&lt;p&gt;接下来将会对执行器部分的各种原理、实现做进一步的介绍。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;处理模式&quot;&gt;2.1处理模式&lt;/h2&gt;
&lt;p&gt;PostgreSQL中的计划节点被定义为有0~2个输入和一个输出，这是为了在实现中能够对应二叉树结构。所以你知道了：所有的计划节点都被组织为二叉树结构。&lt;/p&gt;
&lt;p&gt;每一个计划节点对应于树中的一个节点，下层节点的输出作为上层节点输入。数据(元组)从底层节点向上层节点流动，直至根节点，而根节点的输出即为整个査询的结果。&lt;/p&gt;
&lt;p&gt;例如有这么一个查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select a.q,b.w,c.e from a join b join c order by a.q limit 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么计划节点可能如下所示(其实说实话你explain一条查询就能看到各个节点直接的关系)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        limit
          ^
          |
         sort
          ^
          |
         join
          ^^
         /  \
     join   scan
     ^^
    /  \
scan    scan&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在PostgreSQL的实现中，上层函数通过ExecInitNode、ExecProcNode、ExecEndNode二个接口函数来统一对节点进行初始化、执行和清理，这三个函数会根据所处理节点的实际类型调用相应的初始化、执行、清理函数(可见我这&lt;a href=&quot;http://www.cnblogs.com/flying-tiger/p/8120046.html&quot;&gt;这篇文章&lt;/a&gt;的末尾)。&lt;/p&gt;
&lt;p&gt;由此可见，査询计划树上的节点就构成了物理元组到执行结果的管道，因此査询计划树的执行过程可以看成是拉动元组穿过管道的过程。PostgreSQL采用了一次一元组的执行模式，每个节点被执行一次仅向上层节点返回一条元组。因此，对于整个査询计划树的执行也是一次一元组的模式。这种模式有很多的优点：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;减少了返回元组的延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于某些操作(例如游标、LIMIT子句等)不需要一次性获取所有的元组，节省了开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;减少了实现过程中缓存结果带来的代码复杂性和执行过程中临时存储的开销。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;计划节点的数据结构&quot;&gt;2.2计划节点的数据结构&lt;/h2&gt;
&lt;p&gt;从前面的介绍我们已经看到査询计划树是由各种计划节点构成，那么在PostgreSQL中是如何存储和表示各类节点的呢？下图给出了Hash类型节点的数据结构表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180107224558518-1773452805.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有计划节点节点的数据结构都以一个Plan类型的字段开头，这有点像类的继承：把Plan看成一个父类，其他计划节点节点都是它的直接或者间接子类。浓浓的面向对象的味道。&lt;/p&gt;
&lt;p&gt;如上图所示，Join节点是Plan的子类，从Plan中继承了左右子树指针(lefttree, rightlree)、节点类型(type)、选择表达式(qual)、投影链表(targedisO等公共字段，并有自己的扩展字段连接类型(jointype)和连接条件(joinqual); Hashjoin节点则是Join节点的子类，有自己的扩展字段hashclauses。&lt;/p&gt;
&lt;p&gt;PostgreSQL系统中将所有的计划节点按功能分为四类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;控制节点(control node)
扫描节点(scan node)
连接节点(join node)
物化节点(materialization node)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并分别为扫描、连接节点类型定义了公共父类Scan、Join。Hash连接属于连接节点，因此Hash连接继承于Join节点。连接节点类型的公共父类定义了连接的类型以及连接的条件。作为Hash连接节点，需要使用Hash函数，所以Hashjoin节点扩展定义了hashclauses字段来存储相关信息，其中包括需要做Hash的属性以及使用的Hash函数等。&lt;/p&gt;
&lt;p&gt;Plan的众多子类节点通过lefttree和righttree字段构成了整个査询计划树，其根节点指针被保存在PlannedStmt类型的数据结构中，其中包含了语句的类型(commandType)、査询计划树根节点(planTrce)、査询涉及的范围表(rtable)、结果关系表(resultRelation )PlannedStmt 结构则被放在QueryDesc中，QueryDesc结构的基本定义如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180107224720893-472346694.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作为执行器的输入，QueryDesc中包含査询计划树(plannedstmt字段)、功能语句相关执行计划(utilitystmt字段)、执行器全局状态(estate字段)以及计划节点执行状态(planstate字段)等。从上图可以看出，执行器全局状态estate中保存了査询涉及的范围表(es_range_table)、Estate所在的内存上下文(es_query_cxt，也是执行过程中一直保持的内存上下文)、用于在节点间传递元组的全局元组表(es_TupleTable)和每获取一个元组就会回收的内存上下文(es_per_tuple_exprContext) 。&lt;/p&gt;
&lt;p&gt;执行器初始化时，ExecutorStart会根据査询计划树构造执行器全局状态(estate)以及计划节点执行状态(planstate)。在査询计划树的执行过程中，执行器将使用planstate来记录计划节点执行状态和数据，并使用全局状态记录中的es_tupleTable字段在节点间传递结果元组。执行器的清理函数ExecutorEnd将回收执行器全局状态和计划节点执行状态。&lt;/p&gt;
&lt;p&gt;下图给出了PostgreSQL中用于计划节点执行状态记录的数据结构与计划节点之间的对应关系。PostgreSQL为每种计划节点定义了一种状态节点。所有的状态节点均继承于PlanState节点，其中包含辅助计划节点指针(Plan)、执行器全局状态结构指针(state)、投影运算相关信息(targetlist)、选择运算相关条件(qual),以及左右子状态节点指针(lefttree、righttree)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180107224914221-720467113.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;状态节点之间通过lefttree和righttree指针组织成和査询计划树结构类似的状态节点树，同时，每个状态节点都保存了指向其对应的计划节点的指针(PlanState类型中的Plan字段)。下图(计划节点和节点执行状态)中展示了连接节点状态的公共父类JoinStale,它继承于PlanState,扩展了连接类型(jointype)和连接条件(joinqual)属性。而HashJoinState继承于JoinState并扩展了更多的属性，包括Hash函数相关内容(hashclauses、hj_HashTable、hj_OuterHashKeys、hj_InnerHashKeys、hj_HashOperators)、左子节点返回元组指针(hj_OuterTupleSlot)、右子节点返回元组指针(hj_HashTupleSlot)等。&lt;/p&gt;
&lt;p&gt;至此，执行器执行过程中涉及的主要各种数据结构已经介绍完毕。执行器的输入是QueryDesc,它包含了存储査询计划树根节点指针的PlannedStmt结构。执行器执行时，首先构造全局状态记录Estate结构，并为每个计划节点(Plan)构造对应的状态节点(PlanState),然后在执行中使用相关结构存储执行状态，执行完毕后释放相关的数据结构。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;执行器的运行&quot;&gt;2.3执行器的运行&lt;/h2&gt;
&lt;p&gt;在PostgreSQL中提供了三个接口函数用于调用执行器，分别为ExecutorStart、ExecutorRun和ExecutorEnd。当需要使用执行器来处理査询计划时，仅需依次调用三个函数即可完成执行器的整个执&lt;br/&gt;行过程。&lt;/p&gt;
&lt;p&gt;执行器运行时的函数调用关系如下图所示，ExecutorStart通过调用standard_ExecutorStart对执行器进行必要的初始化，主要工作包括构造EState结构和査询计划树的初始化(即构造对应的PlanState树，由InitPlan函数完成)。ExecutorRun的功能由standard_ExecutorRun实现，在执行过程中会调用ExecutePlan完成査询计划的执行。ExecutorEnd由standard_ExecutorEnd函数完成，通过调用ExecEndPlan处理执行状态树根节点释放已分配的资源，最后释放执行器全局状态EState完成整个执行过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180107225042487-1825160024.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1) 初始化査询计划树&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行器中对査询计划树的初始化都是从其根节点开始，并递归地对其子节点进行初始化。计划节点的初始化过程一般都会经历如下图所示的几个基本步骤，该过程在完成计划节点的初始化之后会输出与该计划节点对应的PlanSute结构指针，计划节点的PlanState结构也会按照査询计划树的结构组织成计划节点执行状态树。对计划节点初始化的主要工作是根据计划节点中定义的相关信息，构造对应的PlanStale结构并对相关字段赋值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180107225126924-449699816.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计划节点的初始化由函数ExecInitNode完成，该函数以要初始化的计划节点为输入，并返回该计划节点所对应的PlanState结构指针。在ExecInitNode中，通过判断计划节点的类型来调用相应的处理过程，每一种计划节点都有专门的初始化函数，且都以“ExecInit节点类型”的形式命名。例如，NestLoop节点的初始化函数为ExecInitNestLoop。在计划节点的初始化过程中，如果该节点还有下层的子节点，则会递归地调用子节点的初始化函数来对子节点进行初始化。ExecInitNode函数会根据计划节点的类型(T_NestLoop)调用该类型节点的初始化函数(ExecInitNestLoop)。由于NestLoop节点有两个子节点，因此ExecInitNestLoop会先调用ExecInitNode对其左子节点进行初始化，并将其返回的PlanState结构指针存放在为NestLoop构造的NestLoopState结构的lefttree字段中；然后以同样的方式初始化右子节点，将返回的PlanState结构指针存放于NestLoopState的righttree字段中。同样，如果左右子节点还有下层节点，初始化过程将以完全相同的方式递归下去，直到到达査询计划树的叶子节点。而在初始化过程中构造的树也会层层返回给上层节点，并被链接在上层节点的PlanState结构中，最终构造出完整的PlanState树。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(2) 查询计划执行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;査询计划的实际执行由函数ExecutePlan完成，该函数的主体部分是一个大的循环，每一次循环都通过ExecProcNode函数从计划节点状态树中获取一个元组，然后对该元组进行相应的处理(增删查改)，然后返回处理的结果。当ExecProcNode从计划节点状态树中再也取不到有效的元组时结束循环过程。&lt;/p&gt;
&lt;p&gt;ExecProoNode的执行过程也和ExecInitNode类似：从计划节点状态树的根节点获取数据，上层节点为了能够完成自己的处理将会递归调用ExecProcNode从下层节点获取输入数据(一般为元组)，然后根据输入数据进行上层节点对应的处理，最后进行选择条件的运算和投影运算，并向更上层的节点返回结果元组的指针。同ExecInitNode 一样，ExecProcNode 也是一个选择函数，它会根据要处理的节点的类型调用对应的处理函数。例如，对于NestLoop类型的节点，其处理函数为ExecNestLoop。ExecNestLoop函数同样会对NestLoop类型的两个子节点调用ExecProcNode以获取输入数据。如果其子节点还有下层节点，则以同样的方式递归调用ExecProcNode进行处理，直到到达叶子节点。每一个节点被ExecProcNode处理之后都会返回一个结果元组，这些结果元组作为上层节点的输入被处理形成上层节点的结果元组，最终根节点将返回结果元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每当通过ExecProcNode从计划节点状态树中获得一个结果元组后，ExecutePlan函数将根据整个语句的操作类型调用相应的函数进行最后的处理。对于不扫描表的简单查询(例如select 1)，调用的是Result节点，通过ExecResult函数直接输出“査询”结果。对于需要扫描表的查询(例如select xx from tablexx这种)，系统在扫描完节点后直接返回结果，而对于增删改查询，情况特殊，有一个专门的ModifyTable节点来处理它：主要调用了ExecInsert、ExecDelete、ExecUpdate这三个函数进行处理。对于插入语句，则首先需要调用ExecConstraints对即将插入的元组进行约束检査，如果满足要求，ExecInsert会调用函数heap_insert将元组存储到存储系统。对于删除和更新，则分别由 ExecDelete 和 ExecUpdate 调用 heap_delete 和 heap_update 完成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于其他的特殊情况，也有特殊的节点去处理，这在Postgresql里面称为控制节点。读者们可以查看ExecProcNode函数获取详情。(这部分代码9.5.4和8.x版本差异较大)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(3)执行器清理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当执行器处理完所有能够获得的元组之后，由执行器清理函数ExecutorEnd负责善后工作。该函数调用ExecEndPlan对计划节点执行状态树进行清理。对计划节点执行状态树的清理和执行状态树的初始化、执行相类似：从根节点开始递归调用ExecEndNode对每一个计划节点的执行状态节点进行清理。同样，ExecEndNode只是一个选择函数，针对不同类型的节点有相应的淸理函数。例如，NestLoop节点的清理函数是ExecEndNestLoop。如下图所示，清理过程的任务主要是回收初始化过程中分配的资源、投影和选择结构的内存、结果元组存储空间等，计划节点执行状态树清理完之后，ExecutorEnd还将调用FreeExecutorState清理执行器全局状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201801/579102-20180107225438331-1593733639.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：本文中的图文大量参考了彭煜玮老师《Postgresql数据库内核分析》一书，在此鸣谢。&lt;/p&gt;
&lt;p&gt;后面开始讲讲查询执行所涉及到的各种计划节点吧。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jan 2018 04:53:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/8192790.html</dc:identifier>
</item>
<item>
<title>项目实战10.1—企业级自动化运维工具应用实战-ansible - 阿龙along</title>
<link>http://www.cnblogs.com/along21/p/8241542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/along21/p/8241542.html</guid>
<description>&lt;p&gt;  &lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104757332-626769419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实战环境：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　公司计划在年底做一次大型市场促销活动，全面冲刺下交易额，为明年的上市做准备。公司要求各业务组对年底大促做准备，运维部要求所有业务容量进行三倍的扩容，并搭建出多套环境可以共开发和测试人员做测试，运维老大为了在年底有所表现，要求运维部门同事尽快实现，当你接到这个任务时，有没有更快的解决方式？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　项目实战系列，总架构图&lt;/strong&gt; &lt;a href=&quot;http://www.cnblogs.com/along21/p/8000812.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/along21/p/8000812.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一、简单介绍&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　ansible是新出现的自动化运维工具，&lt;span&gt;&lt;strong&gt;基于Python开发&lt;/strong&gt;&lt;/span&gt;，集合了众多运维工具（puppet、chef、func、fabric）的优点，实现了&lt;strong&gt;批量系统配置、批量程序部署、批量运行命令&lt;/strong&gt;等功能。&lt;/p&gt;
&lt;p&gt;　　ansible是基于 paramiko（框架） 开发的,并且基于&lt;strong&gt;模块化&lt;/strong&gt;工作，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。ansible&lt;strong&gt;不需要在远程主机上安装client/agents&lt;/strong&gt;，因为它们是&lt;span&gt;&lt;strong&gt;基于ssh&lt;/strong&gt;&lt;/span&gt;来和远程主机通讯的。ansible目前已经&lt;strong&gt;已经被红帽官方收购&lt;/strong&gt;，是自动化运维工具中大家认可度最高的，并且上手容易，学习简单。是每位运维工程师必须掌握的技能之一。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、ansible 特点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;① 部署简单，&lt;strong&gt;只需在&lt;span&gt;主控端&lt;/span&gt;部署Ansible环境&lt;/strong&gt;，被控端无需做任何操作，没有agent；&lt;/p&gt;
&lt;p&gt;② 默认使用&lt;strong&gt;SSH协议&lt;/strong&gt;对设备进行管理；&lt;/p&gt;
&lt;p&gt;③ 有大量常规运维操作模块，可实现日常绝大部分操作。&lt;/p&gt;
&lt;p&gt;④ 配置简单、功能强大、扩展性强；&lt;/p&gt;
&lt;p&gt;⑤ 支持API及自定义模块，可通过Python轻松扩展；&lt;/p&gt;
&lt;p&gt;⑥ 通过Playbooks（剧本）来定制强大的配置、状态管理；&lt;/p&gt;
&lt;p&gt;⑦ &lt;strong&gt;轻量级&lt;/strong&gt;，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；&lt;/p&gt;
&lt;p&gt;⑧ 提供一个功能强大、操作性强的Web管理界面和REST API接口——AWX平台。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、ansible 任务执行模式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Ansible系统由控制主机对被管节点的操作方式可分为两类，即ad-hoc和playbook：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　·ad-hoc（点对点）模式&lt;/span&gt;：&lt;/strong&gt;使用单个模块，支持批量执行单条命令。 ad-hoc 命令是一种可以快速输入的命令，而且不需要保存起来的命令。就相当于bash中的一句话shell。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　·playbook（剧本）模式：&lt;/strong&gt;&lt;/span&gt;是Ansible主要管理方式，也是Ansible功能强大的关键所在。playbook通过&lt;strong&gt;多个task集合&lt;/strong&gt;完成一类功能，如Web服务的安装部署、数据库服务器的批量备份等。可以简单地把playbook理解为通过组合多条ad-hoc操作作的配置文件。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;4、Ansible命令执行过程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;① 加载自己的配置文件 默认&lt;strong&gt;/etc/ansible/ansible.cfg&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;② 查找对应的&lt;strong&gt;主机配置文件&lt;/strong&gt;，找到要执行的主机或者组&lt;/p&gt;
&lt;p&gt;③ 加载自己对应的&lt;strong&gt;模块文件&lt;/strong&gt;，如command&lt;/p&gt;
&lt;p&gt;④ 通过ansible将模块或命令生成对应的&lt;strong&gt;临时py文件&lt;/strong&gt;，并将该文件传输至远程服务器端&lt;/p&gt;
&lt;p&gt;⑤ 对应执行用户的家目录的.ansible/tmp/XXX/XXX.PY文件&lt;/p&gt;
&lt;p&gt;⑥ 给文件+x执行&lt;/p&gt;
&lt;p&gt;⑦ 执行并返回结果&lt;/p&gt;
&lt;p&gt;⑧ &lt;strong&gt;删除临时py文件，sleep 0退出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104758597-8222271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;实战一：安装ansible 及指令讲解&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、安装ansible&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;ansible安装常用两种方式，yum安装和pip程序安装&lt;/p&gt;
&lt;p&gt;这里提供二种安装方式,任选一种即可&lt;/p&gt;
&lt;p&gt;（1）使用yum 安装&lt;/p&gt;
&lt;p&gt;yum install epel-release -y&lt;/p&gt;
&lt;p&gt;yum install &lt;strong&gt;ansible&lt;/strong&gt; –y&lt;/p&gt;
&lt;p&gt;（2）使用pip （python 的包管理模块）安装&lt;/p&gt;
&lt;p&gt;pip install ansible   如果没pip,需先安装pip.yum可直接安装：&lt;/p&gt;
&lt;p&gt;yum install python-pip&lt;/p&gt;
&lt;p&gt;pip install ansible&lt;/p&gt;

&lt;h3&gt;2、Ansible配置文件&lt;/h3&gt;
&lt;p&gt;① sudo_user：&lt;/p&gt;
&lt;p&gt;这是设置默认执行命令的用户，也可以在playbook中重新设置这个参数。配置实例如下：&lt;/p&gt;
&lt;p&gt;　　sudo_user = root&lt;/p&gt;
&lt;p&gt;② remote_port：&lt;/p&gt;
&lt;p&gt;这是指定连接被管节点的管理端口，默认是22。除非设置了特殊的SSH端口，不然这个参数一般是 不需要修改的。配置实例如下：&lt;/p&gt;
&lt;p&gt;　　remote_port = 22&lt;/p&gt;
&lt;p&gt;③ host_key_checking：&lt;/p&gt;
&lt;p&gt;这是设置是否检查SSH主机的密钥。可以设置为True或False，关闭后第一次连接没有提示配置实例&lt;/p&gt;
&lt;p&gt;　　host_key_checking = False&lt;/p&gt;
&lt;p&gt;④ timeout：&lt;/p&gt;
&lt;p&gt;这是设置SSH连接的超时间隔，单位是秒。配置实例如下：&lt;/p&gt;
&lt;p&gt;　　timeout = 60&lt;/p&gt;
&lt;p&gt;⑤ log_path：Ansible系统默认是不记录日志的，如果想把Ansible系统的输出记录到日志文件中，需要设置log_path 来指定一个存储Ansible日志的文件。配置实例如下：&lt;/p&gt;
&lt;p&gt;　　log_path = /var/log/ansible.log&lt;/p&gt;
&lt;p&gt;　　另外需要注意，执行Ansible的用户需要有写入日志的权限，模块将会调用被管节点的syslog来记录&lt;/p&gt;

&lt;h3&gt;3、ansible 命令&lt;/h3&gt;
&lt;p&gt;（1）Ansible命令集&lt;/p&gt;
&lt;p&gt;/usr/bin/&lt;strong&gt;ansible&lt;/strong&gt; #Ansibe AD-Hoc 　　#临时命令执行工具，常用于临时命令的执行&lt;/p&gt;
&lt;p&gt;/usr/bin/&lt;strong&gt;ansible-doc&lt;/strong&gt; #Ansible 　　#模块功能查看工具&lt;/p&gt;
&lt;p&gt;/usr/bin/ansible-galaxy 　　#下载/上传优秀代码或Roles模块的官网平台，基于网络的，也可以去github 上找自己想要的模板&lt;/p&gt;
&lt;p&gt;/usr/bin/&lt;strong&gt;ansible-playbook&lt;/strong&gt; 　　#Ansible定制自动化的任务集编排工具，执行playbook剧本&lt;/p&gt;
&lt;p&gt;/usr/bin/ansible-pull 　　#Ansible远程执行命令的工具，拉取配置而非推送配置（使用较少，海量机器时使用，对运维的架构能力要求较高）&lt;/p&gt;
&lt;p&gt;/usr/bin/ansible-vault 　　#Ansible文件加密工具&lt;/p&gt;
&lt;p&gt;/usr/bin/ansible-console 　　#Ansible基于Linux Consoble界面可与用户交互的命令执行工具&lt;/p&gt;

&lt;p&gt;（2）命令格式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ansible&lt;/strong&gt; &amp;lt;&lt;strong&gt;host-pattern&lt;/strong&gt;&amp;gt; [&lt;span&gt;&lt;strong&gt;-f forks&lt;/strong&gt;&lt;/span&gt;] [&lt;span&gt;&lt;strong&gt;-m module_name&lt;/strong&gt;&lt;/span&gt;] [&lt;span&gt;&lt;strong&gt;-a args&lt;/strong&gt;&lt;/span&gt;]&lt;/p&gt;
&lt;p&gt;我们可以通过 ansible -h查看帮助&lt;/p&gt;
&lt;p&gt;Usage: ansible &amp;lt;host-pattern&amp;gt; [options] Options:&lt;/p&gt;
&lt;p&gt;　　① -a MODULE_ARGS, --args=MODULE_ARGS    模块的参数,如果执行默认COMMAND的模块，即是命令参数,如：&quot;date&quot;,&quot;pwd&quot;等等 module arguments 模块参数&lt;/p&gt;
&lt;p&gt;　　② -C, --check don't make any changes; instead, try to predict some of the changes that may occur    只是测试一下会改变什么内容，不会真正去执行;相反,试图预测一些可能发生的变化&lt;/p&gt;
&lt;h3&gt;4、ansible 使用前配置&lt;/h3&gt;
&lt;p&gt;（1）Ansible配置公私钥&lt;/p&gt;
&lt;p&gt;配置ansible 使用公钥验证&lt;/p&gt;
&lt;p&gt;虽然ansible支持其他主机认证方式，但是我们最常用的的还是基于秘钥的认证：&lt;/p&gt;
&lt;p&gt;① 首先生成秘钥&lt;/p&gt;
&lt;p&gt;ssh-keygen -t rsa -P ''&lt;/p&gt;
&lt;p&gt;② 然后向主机分发秘钥：&lt;/p&gt;
&lt;p&gt;ssh-copy-id root@ 　　#@后面跟主机名或者IP地址3、如果出现以下情况：&lt;/p&gt;
&lt;p&gt;# ssh-copy-id -i ~/.ssh/id_rsa.pub 10.1.6.72&lt;/p&gt;
&lt;p&gt;-bash: ssh-copy-id: command not found&lt;/p&gt;
&lt;p&gt;请尝试： yum -y install openssh-clientsansible&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;实战二：ad-hoc（点对点）模块的使用&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、设置hosts 远程被控制主机&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;vim /etc/ansible/hosts&lt;/p&gt;
&lt;p&gt;[web]&lt;/p&gt;
&lt;p&gt;192.168.30.7&lt;/p&gt;
&lt;p&gt;192.168.30.2&lt;/p&gt;
&lt;p&gt;定义hosts 有3类：&lt;/p&gt;
&lt;p&gt;① Ex 1：未分组的主机，在任何组头之前指定&lt;/p&gt;
&lt;p&gt;② Ex 2：有组的主机，一组属于&quot;webservers&quot;组的主机&lt;/p&gt;
&lt;p&gt;③ Ex 3：和数据库有关的，&quot;dbservers&quot;组中的数据库服务器集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104759738-1098845432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、ping 模块，主机连通性测试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;# ansible all &lt;strong&gt;-m ping&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104800035-1338068665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、Command 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;命令模块接受命令名称，后面是空格分隔的列表参数。给定的命令将在所有选定的节点上执行。&lt;/p&gt;
&lt;p&gt;它&lt;strong&gt;不会通过shell进行处理&lt;/strong&gt;，比如$HOME和操作如&quot;小于&quot;&amp;lt;&quot;,&quot;&amp;gt;&quot;, &lt;span&gt;&lt;strong&gt;&quot;|&quot;&lt;/strong&gt;&lt;/span&gt;, &quot;;&quot;,&quot;&amp;amp;&quot;' 工作(需要使用(shell)模块实现这些功能)。&lt;/p&gt;

&lt;p&gt;（2）选项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;chdir      # 在执行命令之前，先切换到该目录
creates  # 一个文件名，当这个文件存在，则该命令不执行，可以用来做判断
removes       # 一个文件名，这个文件不存在，则该命令不执行，与creates相反的判断
executable   # 切换shell来执行命令，需要使用命令的绝对路径（不常用，常用下面shell 模块）
free_form    # 要执行的Linux指令，一般使用Ansible的&lt;/span&gt;-a参数代替（不常用，常用下面shell 模块） 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）实例&lt;/p&gt;
&lt;p&gt;ansible web &lt;strong&gt;-m command&lt;/strong&gt; -a '&lt;strong&gt;chdir=/app&lt;/strong&gt; ls'&lt;/p&gt;
&lt;p&gt;ansible web -m command -a '&lt;strong&gt;creates=&lt;/strong&gt;/app/f1 touch /app/f2'&lt;/p&gt;
&lt;p&gt;ansible web -m command -a '&lt;strong&gt;removes=&lt;/strong&gt;/app/f1 touch /app/f2'&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104800504-1642266847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;4、shell 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;shell模块在远程主机上调用shell解释器运行命令，支持shell的各种功能，例如管道等&lt;/p&gt;
&lt;p&gt;（1）实例：&lt;/p&gt;
&lt;p&gt;ansible web -m shell -a 'cat /etc/passwd |grep root'&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104800816-1325669102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;5、copy 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;copy：复制文件到远程主机，可以改权限等&lt;/p&gt;
&lt;p&gt;（1）用法：&lt;/p&gt;
&lt;p&gt;① 复制文件&lt;/p&gt;
&lt;p&gt;-a &quot;&lt;strong&gt;src= dest=&lt;/strong&gt; &quot;&lt;/p&gt;
&lt;p&gt;② 给定内容生成文件&lt;/p&gt;
&lt;p&gt;-a &quot;&lt;strong&gt;content= dest=&lt;/strong&gt; &quot;&lt;/p&gt;

&lt;p&gt;（2）相关选项如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
① &lt;span&gt;&lt;strong&gt;src：源&lt;/strong&gt;&lt;/span&gt;，被复制到远程主机的本地文件，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用“/”来结尾，则只复制目录里的内容，如果没有使用“/&lt;span&gt;”来结尾，则包含目录在内的整个内容全部复制，类似于rsync。
② &lt;span&gt;&lt;strong&gt;dest：目标&lt;/strong&gt;&lt;/span&gt;，必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录
③ &lt;span&gt;&lt;strong&gt;backup&lt;/strong&gt;&lt;/span&gt;：被管理的远程主机已经有文件了，在覆盖之前，将源文件备份，备份文件包含时间信息。有两个选项：yes&lt;/span&gt;|&lt;span&gt;no
④ &lt;span&gt;&lt;strong&gt;content&lt;/strong&gt;&lt;/span&gt;：用于替代“src”，可以直接设定指定文件的值
⑤ directory_mode：递归设定目录的权限，默认为系统默认权限
⑥ force：如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes
⑦ others：所有的file模块里的选项都可以在这里使用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）实例&lt;/p&gt;
&lt;p&gt;① ansible web &lt;strong&gt;-m copy&lt;/strong&gt; -a &quot;&lt;strong&gt;src=/root/f3 dest=/app&lt;/strong&gt;&quot;&lt;/p&gt;
&lt;p&gt;分析：把控制端/root/f3 文件，copy 到了被控制端的/app 下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104801582-1386388128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;② ansible web -m copy -a &quot;&lt;strong&gt;content=&lt;/strong&gt;'hello' &lt;strong&gt;dest=&lt;/strong&gt;/app/f3 &lt;strong&gt;mode=&lt;/strong&gt;222 &lt;strong&gt;backup=&lt;/strong&gt;yes&quot;&lt;/p&gt;
&lt;p&gt;分析：在控制端/app/f3 写hello 内容，且设置权限为222，并做备份&lt;/p&gt;
&lt;p&gt;注意：因为修改了/app/f3 的内容，使其去原来不同，才会备份&lt;/p&gt;
&lt;p&gt;192.168.30.2 上本已有了f3 文件，且内容是hello ，没有发生修改，所以是&quot;绿色&quot;，且没有备份&lt;/p&gt;
&lt;p&gt;192.168.30.7 修改了f3 文件，发生修改，所以是&quot;黄色&quot;，且发生了备份&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104802254-2022640410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;192.168.30.7 上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104802738-800319155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;192.168.30.2 上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104803191-1650855193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;6、file 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;设置文件属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建&lt;strong&gt;目录&lt;/strong&gt;：-a &quot;path= &lt;strong&gt;state=directory&lt;/strong&gt;&quot;&lt;/p&gt;
&lt;p&gt;创建链接文件：-a &quot;path= src= &lt;strong&gt;state=link&lt;/strong&gt;&quot;&lt;/p&gt;
&lt;p&gt;删除文件：-a &quot;path= &lt;strong&gt;state=absent&lt;/strong&gt;&quot;&lt;/p&gt;

&lt;p&gt;（1）选项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
① force：需要在两种情况下强制创建软链接，一种是源文件不存在，但之后会建立的情况下；另一种是目标软链接已存在，需要先取消之前的软链，然后创建新的软链，有两个选项：yes|&lt;span&gt;no
② group：定义文件&lt;/span&gt;/目录的属组 mode：定义文件/&lt;span&gt;目录的权限
③ owner：定义文件&lt;/span&gt;/目录的属主 path：必选项，定义文件/&lt;span&gt;目录的路径
④ recurse：递归设置文件的属性，只对目录有效 src：被链接的源文件路径，只应用于state&lt;/span&gt;=&lt;span&gt;link的情况
⑤ dest：被链接到的路径，只应用于state&lt;/span&gt;=&lt;span&gt;link的情况
⑥ state&lt;/span&gt;=&lt;span&gt;：
　　directory：如果目录不存在，就创建目录
　　file：即使文件不存在，也不会被创建
　　link：创建软链接
　　hard：创建硬链接
　　touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间
　　absent：删除目录、文件或者取消链接文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）实例：&lt;/p&gt;
&lt;p&gt;① ansible web -m file -a &quot;path=/app/f4 state=directory&quot; 在被控制端，创建f4 目录&lt;/p&gt;
&lt;p&gt;ansible web -m command -a &quot;chdir=/app ls&quot; 查看/app 目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104803972-578515187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;② 创建软连接&lt;/p&gt;
&lt;p&gt;ansible web -m file -a &quot;&lt;strong&gt;path=/app/f12 src=/app/f1&lt;/strong&gt; state=&lt;strong&gt;link&lt;/strong&gt;&quot;&lt;/p&gt;
&lt;p&gt;ansible web -m file -a &quot;&lt;strong&gt;src=/app/f1 dest=/app/f11&lt;/strong&gt; state=&lt;strong&gt;link&lt;/strong&gt;&quot; 创建软连接f11，连接f1&lt;/p&gt;
&lt;p&gt;ansible web -m shell -a &quot;ls -l /app&quot; 查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104804863-1887203802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;7、fetch 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从远程&lt;/strong&gt;某主机&lt;strong&gt;获取&lt;/strong&gt;文件&lt;strong&gt;到本地&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;dest：用来&lt;strong&gt;存放文件的目录&lt;/strong&gt;，例如存放目录为backup，源文件名称为/etc/profile&lt;/p&gt;
&lt;p&gt;　　在主机pythonserver中，那么保存为/backup/pythonserver/etc/profile&lt;/p&gt;
&lt;p&gt;Src：在远程&lt;strong&gt;拉取的文件&lt;/strong&gt;，并且&lt;strong&gt;必须是一个file，不能是目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;从远程获取到本地的文件，会保存到&lt;strong&gt;以远程主机的IP 为名的目录&lt;/strong&gt;中，且&lt;strong&gt;保存目录结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（3）实例&lt;/p&gt;
&lt;p&gt;ansible web -m fetch -a &quot;src=/app/f1 dest=/app/&quot;&lt;/p&gt;
&lt;p&gt;分析：拉取远程的/app/f1 文件，保存到本地的/app 目录下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104805504-481720861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;8、cron 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;管理cron计划任务；&lt;/strong&gt;-a &quot;&quot;: 设置管理节点生成定时任务&lt;/p&gt;
&lt;p&gt;（1）选项：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;① action: 
cron backup&lt;/span&gt;=   #如果设置，创建一个crontab备份 【yes|&lt;span&gt;no】
cron_file&lt;/span&gt;=&lt;span&gt;    #如果指定, 使用这个文件cron.d，而不是单个用户
② crontab
　　day&lt;/span&gt;=     #日应该运行的工作( &lt;span&gt;1&lt;/span&gt;-&lt;span&gt;31&lt;/span&gt;, *, */&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, )
　　hour&lt;/span&gt;=   # 小时 ( &lt;span&gt;0&lt;/span&gt;-&lt;span&gt;23&lt;/span&gt;, *, */&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, )
　　minute&lt;/span&gt;=    #分钟( &lt;span&gt;0&lt;/span&gt;-&lt;span&gt;59&lt;/span&gt;, *, */&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, )
　　month&lt;/span&gt;=     #月( &lt;span&gt;1&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;, *, /&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, )
　　weekday   # 周 ( &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;6&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; Sunday-&lt;span&gt;Saturday,, )
　　job&lt;/span&gt;=&lt;span&gt;       #指明运行的命令是什么
　　name&lt;/span&gt;=&lt;span&gt;   #定时任务描述
　　reboot    # 任务在重启时运行，不建议使用，建议使用special_time
　　special_time   #特殊的时间范围，参数：reboot（重启时）,annually（每年）,monthly（每月）,weekly（每周）,daily（每天）,hourly（每小时）
　　state   #指定状态，present表示添加定时任务，也是默认设置，absent表示删除定时任务
　　user    #以哪个用户的身份执行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）实例&lt;/p&gt;
&lt;p&gt;在远程主机上，定义每5分钟，清空一次防火墙&lt;/p&gt;
&lt;p&gt;① ansible web -m cron -a &quot;name='Clear the iptable' &lt;strong&gt;minute=*/5&lt;/strong&gt; job='&lt;strong&gt;/sbin/iptables -F&lt;/strong&gt;'&quot;&lt;/p&gt;
&lt;p&gt;ansible web -m shell -a &quot;&lt;strong&gt;crontab -l&lt;/strong&gt;&quot; 查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104806472-706053950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② ansible web -m cron -a '&lt;strong&gt;name=&quot;Clear the iptable&quot;&lt;/strong&gt; minute=*/2 job=&quot;&lt;strong&gt;/sbin/ntpdate 172.17.0.1 &amp;amp;&amp;gt; /dev/null&lt;/strong&gt;&quot;' 每2分，更新一次时间，输出结果导入/dec/null 中&lt;/p&gt;
&lt;p&gt;注意：若定义的名字没有修改，会把前一次定义的计划任务覆盖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104807207-573312228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;③ ansible web -m cron -a &quot;name='Clear the iptable' minute=*/5 job='/sbin/iptables -F' &lt;strong&gt;state=absent&lt;/strong&gt;&quot; 删除计划任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104807660-1886772498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;④ ansible web -m cron -a 'name=&quot;list df every hour&quot; special_time=hourly job=&quot;/bin/df -lh &amp;gt;&amp;gt; /app/disk_total &amp;amp;&amp;gt; /dev/null&quot;' 每小时，把df -lh 的结果追加到/app/disk_total 下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104808285-1194519175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;9、yum 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）选项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;conf_file    #设定远程yum安装时所依赖的配置文件。如配置文件没有在默认的位置。
disable_gpg_check   #是否禁止GPG checking，只用于`present‘ or `latest’。
disablerepo   #临时禁止使用yum库。 只用于安装或更新时。
enablerepo   #临时使用的yum库。只用于安装或更新时。
&lt;span&gt;&lt;strong&gt;name&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;    #所安装的包的名称&lt;/strong&gt;
&lt;strong&gt;state&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;     #present安装， latest安装最新的, absent 卸载软件。&lt;/strong&gt;&lt;/span&gt;
update_cache    #强制更新yum的缓存。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）实例&lt;/p&gt;
&lt;p&gt;①i安装dstat 包，忽略gpg_check&lt;/p&gt;
&lt;p&gt;ansible web &lt;strong&gt;-m yum&lt;/strong&gt; -a &quot;name=&lt;strong&gt;dstat&lt;/strong&gt; state=&lt;strong&gt;present&lt;/strong&gt; &lt;strong&gt;disable_gpg_check=&lt;/strong&gt;yes&quot;&lt;/p&gt;
&lt;p&gt;卸载dstat 包&lt;/p&gt;
&lt;p&gt;ansible web -m yum -a &quot;name=dstat state=&lt;strong&gt;absent&lt;/strong&gt;&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104808957-880962997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;② 把控制端的安装包发到被控制端，再安装&lt;/p&gt;
&lt;p&gt;ansible web -m &lt;strong&gt;copy&lt;/strong&gt; -a &quot;src=/root/&lt;strong&gt;zabbix-release-3.4-2.el7.noarch.rpm&lt;/strong&gt; dest=/app&quot;&lt;/p&gt;
&lt;p&gt;ansible web -m yum -a &quot;name=&lt;strong&gt;/app/zabbix-release-3.4-2.el7.noarch.rpm&lt;/strong&gt; state=&lt;strong&gt;present&lt;/strong&gt; disable_gpg_check=yes&quot;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;10、service 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;服务程序管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）选项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;arguments   #命令行提供额外的参数
enabled   #设置开机启动。
&lt;strong&gt;name&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;     #服务名称&lt;/strong&gt;
runlevel    #开机启动的级别，一般不用指定。
sleep    #在重启服务的过程中，是否等待。如在服务关闭以后等待2秒再启动。
&lt;strong&gt;state     #started启动服务， stopped停止服务， restarted重启服务， reloaded重载配置&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）实例&lt;/p&gt;
&lt;p&gt;① 在远程被控制端安装nginx&lt;/p&gt;
&lt;p&gt;ansible web -m &lt;strong&gt;yum&lt;/strong&gt; -a &quot;name=&lt;strong&gt;nginx&lt;/strong&gt; state=&lt;strong&gt;present&lt;/strong&gt; disable_gpg_check=yes&quot;&lt;/p&gt;
&lt;p&gt;② 把控制端的nginx 配置文件发送，到被控制的2台机器&lt;/p&gt;
&lt;p&gt;cp /etc/nginx/nginx.conf /app&lt;/p&gt;
&lt;p&gt;vim /app/nginx.conf 把端口修改为8888，为了一会验证实验结果&lt;/p&gt;
&lt;p&gt;ansible web -m &lt;strong&gt;copy&lt;/strong&gt; -a &quot;src=&lt;strong&gt;/app/nginx.conf&lt;/strong&gt; dest=&lt;strong&gt;/etc/nginx&lt;/strong&gt;&quot;&lt;/p&gt;
&lt;p&gt;③ 开启远程被控制端的nginx 服务&lt;/p&gt;
&lt;p&gt;ansible web -m &lt;strong&gt;service&lt;/strong&gt; -a &quot;name=&lt;strong&gt;nginx&lt;/strong&gt; state=&lt;strong&gt;started&lt;/strong&gt;&quot;&lt;/p&gt;
&lt;p&gt;④ 查询远程的8888 端口&lt;/p&gt;
&lt;p&gt;ansible web -m &lt;strong&gt;shell&lt;/strong&gt; -a &quot;ss -nutlp |&lt;strong&gt;grep 8888&lt;/strong&gt;&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104809519-382784027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑤ 关闭远程的nginx 服务&lt;/p&gt;
&lt;p&gt;ansible web -m service -a &quot;name=nginx state=&lt;strong&gt;stopped&lt;/strong&gt;&quot;&lt;/p&gt;
&lt;p&gt;⑥ 查询，失败，没有8888端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104809816-1495686149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;11、user 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;用户模块,管理用户帐号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）选项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;comment        # 用户的描述信息
createhome    # 是否创建家目录
force      # 在使用state&lt;/span&gt;=absent是, 行为与userdel -&lt;span&gt;force一致.
group     # 指定基本组
groups   # 指定附加组，如果指定为(groups&lt;/span&gt;=&lt;span&gt;)表示删除所有组
home     # 指定用户家目录
move_home    # 如果设置为home&lt;/span&gt;=&lt;span&gt;时, 试图将用户主目录移动到指定的目录
name     # 指定用户名
non_unique     # 该选项允许改变非唯一的用户ID值
password       # 指定用户密码，若指定的是明文密码，是不能用的，需用md5加密过后的密码
remove   # 在使用state&lt;/span&gt;=absent时, 行为是与userdel -&lt;span&gt;remove一致
shell      # 指定默认shell
state      # 设置帐号状态，不指定为创建，指定值为absent表示删除
system  # 当创建一个用户，设置这个用户是系统用户。这个设置不能更改现有用户
uid     # 指定用户的uid
update_password    # 更新用户密码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）实例&lt;/p&gt;
&lt;p&gt;创建用户along01，uid=1111，家目录在/app/along01 下&lt;/p&gt;
&lt;p&gt;ansible web &lt;strong&gt;-m user&lt;/strong&gt; -a '&lt;strong&gt;name=along01&lt;/strong&gt; comment=&quot;along01 is along&quot; uid=1111 group=along shell=/bin/bash home=/app/along01'&lt;/p&gt;
&lt;p&gt;ansible web -m &lt;strong&gt;shell&lt;/strong&gt; -a &quot;cat /etc/passwd |&lt;strong&gt;grep along01&lt;/strong&gt;&quot; 查看&lt;/p&gt;
&lt;p&gt;ansible web -m &lt;strong&gt;user&lt;/strong&gt; -a &quot;name=along01 state=&lt;strong&gt;absent&lt;/strong&gt;&quot; 删除用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104810269-641968063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;12、group 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;用户组模块,添加或删除组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）选项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;gid         # 设置组的GID号
name&lt;/span&gt;=&lt;span&gt;  # 管理组的名称
state     # 指定组状态，默认为创建，设置值为absent为删除
system  # 设置值为yes，表示为创建系统组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）实例&lt;/p&gt;
&lt;p&gt;ansible web -m group -a 'name=tom state=present'&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;13、script 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在指定节点运行服务端的脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）示例&lt;/p&gt;
&lt;p&gt;[root@Ansible ~]#vim test.sh&lt;/p&gt;
&lt;p&gt;#/bin/bash&lt;/p&gt;
&lt;p&gt;touch /tmp/test.sh.log  #创建/tmp/test.sh.log&lt;/p&gt;
&lt;p&gt;echo &quot;hello&quot; &amp;gt;&amp;gt; /tmp/test.sh.log   #将echo命令结果输出到/tmp/test.sh.log&lt;/p&gt;

&lt;p&gt;（2）实例：&lt;/p&gt;
&lt;p&gt;① 在控制端随便写个脚本&lt;/p&gt;
&lt;p&gt;vim /app/test.sh&lt;/p&gt;
&lt;p&gt;#!/bin/bash&lt;/p&gt;
&lt;p&gt;date &amp;gt;&amp;gt; /app/disk_total.log&lt;/p&gt;
&lt;p&gt;df -lh &amp;gt;&amp;gt; /app/disk_total.log&lt;/p&gt;
&lt;p&gt;② ansible web -m script -a '/app/test.sh' 在远程被控制的机器执行脚本&lt;/p&gt;
&lt;p&gt;ansible web -m command -a &quot;chdir=/app ls&quot; 查看文件生成&lt;/p&gt;
&lt;p&gt;ansible web -m shell -a &quot;cat /app/disk_total.log&quot; 查看文件内容正确&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104810785-99723300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上都是ad-hoc 的模块！&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;14、setup 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;查机器的所有facts信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;① facts 组件是Ansible 用于采集&lt;strong&gt;被管机器设备信息&lt;/strong&gt;的一个功能，我们可以使用&lt;strong&gt;setup 模块查机器的所有facts信息&lt;/strong&gt;，可以使用filter来查看指定信息。整个facts信息被包装在一个JSON格式的数据结构中，ansible_facts是最上层的值。&lt;/p&gt;
&lt;p&gt;② facts就是变量，&lt;strong&gt;内建变量&lt;/strong&gt; 。&lt;strong&gt;每个主机的各种信息，cpu颗数、内存大小等&lt;/strong&gt;。会存在facts中的某个变量中。调用后返回很多对应主机的信息，在后面的操作中可以根据不同的信息来做不同的操作。如redhat系列用yum安装，而debian系列用apt来安装软件。&lt;/p&gt;
&lt;p&gt;③ setup模块，主要用于&lt;strong&gt;获取主机信息&lt;/strong&gt;，在playbooks里经常会用到的一个参数gather_facts就与该模块相关。&lt;/p&gt;
&lt;p&gt;④ setup模块下经常使用的一个参数是&lt;span&gt;&lt;strong&gt;filter 参数&lt;/strong&gt;&lt;/span&gt;，查询的是全部信息，很多，filter 相当于匹配筛选。&lt;/p&gt;

&lt;p&gt;（2）实例：&lt;/p&gt;
&lt;p&gt;① ansible 192.168.30.7 -m setup 查询全部信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104811129-1437911293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② ansible web -m setup -a &quot;&lt;strong&gt;filter='*mem*'&lt;/strong&gt;&quot; 查看内存的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104811519-2054397096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ ansible all -m setup --tree /tmp/facts 将所有主机的信息输入到/tmp/facts目录下，每台主机的信息输入到主机名文件中（/etc/ansible/hosts里的主机名）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104811738-1086166356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;实验三：Ansible playbook 的使用&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1、介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）理解&lt;/p&gt;
&lt;p&gt;① playbook是ansible用于配置，部署，和管理被控节点的剧本。&lt;/p&gt;
&lt;p&gt;② 通过playbook的详细描述，执行其中的&lt;strong&gt;一系列tasks&lt;/strong&gt;，可以让远端主机达到预期的状态。playbook就像Ansible控制器给被控节点列出的的一系列to-do-list，而被控节点必须要完成。&lt;/p&gt;
&lt;p&gt;③ 也可以这么理解，playbook 字面意思，即剧本，现实中由演员按照剧本表演，在Ansible中，这次由计算机进行表演，由计算机安装，部署应用，提供对外服务，以及组织计算机处理各种各样的事情&lt;/p&gt;

&lt;p&gt;（2）Ansible playbook 使用场景&lt;/p&gt;
&lt;p&gt;① 执行一些简单的任务，使用ad-hoc命令可以方便的解决问题，但是有时一个设施过于复杂，需要大量的操作时候，执行的ad-hoc命令是不适合的，这时最好使用playbook。&lt;/p&gt;
&lt;p&gt;② 就像执行shell命令与写shell脚本一样，也可以理解为&lt;strong&gt;批处理任务&lt;/strong&gt;，不过playbook有自己的语法格式。&lt;/p&gt;
&lt;p&gt;③ 使用playbook你可以方便的重用这些代码，可以移植到不同的机器上面，像函数一样，最大化的利用代码。在你使用Ansible的过程中，你也会发现，你所处理的大部分操作都是编写playbook。可以把常见的应用都编写成playbook，之后管理服务器会变得十分简单。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、Ansible playbook 格式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;① playbook由&lt;strong&gt;YMAL语言&lt;/strong&gt;编写。YAML( /ˈjæməl/ )参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822，Clark Evans在2001年5月在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。&lt;/p&gt;
&lt;p&gt;② YMAL格式是类似于JSON的文件格式，便于人理解和阅读，同时便于书写。首先学习了解一下YMAL的格式，对我们后面书写playbook很有帮助。以下为playbook常用到的YMAL格式。&lt;/p&gt;

&lt;p&gt;（2）语法介绍&lt;/p&gt;
&lt;p&gt;① 文件的&lt;strong&gt;第一行&lt;/strong&gt;应该以 &quot;&lt;span&gt;&lt;strong&gt;---&lt;/strong&gt;&lt;/span&gt;&quot; (三个连字符)开始，表明YMAL文件的开始。&lt;/p&gt;
&lt;p&gt;② 在同一行中，&lt;strong&gt;#&lt;/strong&gt;之后的内容&lt;strong&gt;表示注释&lt;/strong&gt;，类似于shell，python和ruby。&lt;/p&gt;
&lt;p&gt;③ YMAL中的列表元素以&quot;&lt;span&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/span&gt;&quot;开头然后紧跟着&lt;span&gt;&lt;strong&gt;一个空格&lt;/strong&gt;&lt;/span&gt;，后面为元素内容。就像这样&lt;/p&gt;
&lt;p&gt;- apple - banana - orange 等价于JSON的这种格式&lt;/p&gt;
&lt;p&gt;[ &quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot; ]&lt;/p&gt;
&lt;p&gt;④ &lt;strong&gt;同一个列表中的元素应该保持&lt;span&gt;相同的缩进&lt;/span&gt;&lt;/strong&gt;。否则会被当做错误处理。&lt;/p&gt;
&lt;p&gt;⑤ play中hosts，variables，roles，tasks等对象的表示方法都是键值中间以&quot;&lt;span&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/span&gt;&quot;分隔表示,&quot;:&quot;后面还要增加&lt;span&gt;&lt;strong&gt;一个空格&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;（3）Playbooks 配置文件的基础组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① &lt;span&gt;hosts：&lt;/span&gt;&lt;/strong&gt;运行指定任务的目标主机；使用hosts指示使用哪个主机或主机组来运行下面的tasks，&lt;strong&gt;每个playbook都必须指定hosts&lt;/strong&gt;，hosts也可以使用通配符格式。主机或主机组在inventory清单中指定，可以使用系统默认的/etc/ansible/hosts，也可以自己编辑，在运行的时候加上-i选项，指定清单的位置即可。在运行清单文件的时候，-list-hosts选项会显示那些主机将会参与执行task的过程中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② &lt;span&gt;remoute_user:&lt;/span&gt;&lt;/strong&gt; 在远程主机上执行任务的用户；指定远端主机中的哪个用户来登录远端系统，在远端系统执行task的用户，可以任意指定，也可以使用sudo，但是用户必须要有执行相应task的权限。&lt;/p&gt;
&lt;p&gt;③ sudo_user：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;④ &lt;span&gt;tasks：&lt;/span&gt;任务列表；&lt;/strong&gt;指定远端主机将要执行的一系列动作。tasks的核心为ansible的模块，前面已经提到模块的用法。&lt;/p&gt;
&lt;p&gt;　　tasks：包含&lt;strong&gt;name&lt;/strong&gt;和要&lt;strong&gt;执行的模块&lt;/strong&gt;，&lt;strong&gt;name是可选的，只是为了便于用户阅读&lt;/strong&gt;，不过还是建议加上去，&lt;strong&gt;模块是必须的&lt;/strong&gt;，同时也要给予&lt;strong&gt;模块相应的参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;⑤ &lt;strong&gt;templates：&lt;/strong&gt;包含了&lt;strong&gt;模板&lt;/strong&gt;语法的文本文件；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⑥ variables 变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⑦ &lt;strong&gt;handlers：&lt;/strong&gt;由特定条件&lt;strong&gt;触发的任务&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;（4）注意：shell和command模块后面直接跟命令，而非key=value类的参数列表；&lt;/p&gt;
&lt;p&gt;① 某任务的状态在运行后为changed时，可通过&quot;&lt;span&gt;&lt;strong&gt;notify&lt;/strong&gt;&lt;/span&gt;&quot;通知给相应的&lt;strong&gt;handlers&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;② 任务可以通过&quot;&lt;span&gt;&lt;strong&gt;tags&lt;/strong&gt;&lt;/span&gt;&quot;打标签，而后可在ansible-playbook命令上使用&lt;strong&gt;-t 标签名，&lt;/strong&gt;指定进行调用；&lt;/p&gt;

&lt;p&gt;（5）variables 变量的定义：&lt;/p&gt;
&lt;p&gt;① facts：可直接调用；&lt;/p&gt;
&lt;p&gt;注意：可使用&lt;strong&gt;setup模块&lt;/strong&gt;直接获取目标主机的facters；&lt;/p&gt;
&lt;p&gt;② 用户自定义变量：&lt;/p&gt;
&lt;p&gt;(a) ansible-playbook命令的命令行中的&lt;/p&gt;
&lt;p&gt;　　-e VARS, --extra-vars=VARS&lt;/p&gt;
&lt;p&gt;(b) 在playbook中定义变量的方法：&lt;/p&gt;
&lt;p&gt;vars:&lt;/p&gt;
&lt;p&gt;　　 - var1: value1&lt;/p&gt;
&lt;p&gt;　　 var2: value2&lt;/p&gt;

&lt;p&gt;（6）执行playbook剧本&lt;/p&gt;
&lt;p&gt;使用&lt;span&gt;&lt;strong&gt;ansible-playbook&lt;/strong&gt;&lt;/span&gt;运行playbook文件，得到如下输出信息，输出内容为JSON格式。并且由不同颜色组成，便于识别。一般而言&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;l 绿色&lt;/strong&gt;&lt;/span&gt;代表执行成功，系统保持原样&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;l 黄色&lt;/strong&gt;&lt;/span&gt;代表系统代表系统状态发生改变&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;l 红色&lt;/strong&gt;&lt;/span&gt;代表执行失败，显示错误输出。&lt;/p&gt;
&lt;p&gt;执行有三个步骤：&lt;/p&gt;
&lt;p&gt;① 收集facts&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104812238-788109924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 执行tasks&lt;/p&gt;
&lt;p&gt;③ 报告结果&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、剧本的书写，和执行&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）写一个简单剧本&lt;/p&gt;
&lt;p&gt;vim /etc/ansible/web.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;---
- hosts: web
  remote_user: root
  tasks:
        - name: yum install nginx
          yum: name=nginx state=latest
        - name: copy nginx.conf
          copy: src=/app/nginx.cong dest=/etc/nginx/nginx.conf backup=yes
          tags: reloadnginx
        - name: start service
          service: name=nginx state=started
          tags: startnginx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104812519-819511166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析：安装nginx；把配置文件copy 到远程被控制的主机上；开启服务&lt;/p&gt;

&lt;p&gt;（2）在剧本中加入&lt;strong&gt;handlers 触发任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前提背景：如playbook 中有一系列tasks，但有时只需改动少个task 就要触发另一个操作；若再把剧本执行一遍，浪费资源和时间；此时可以设置handlers 触发任务&lt;/p&gt;
&lt;p&gt;vim /etc/ansible/web.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
---
-&lt;span&gt; hosts: web
  remote_user: root
  tasks:
        &lt;/span&gt;-&lt;span&gt; name: yum install samba
          yum: name&lt;/span&gt;=samba state=&lt;span&gt;latest
        &lt;/span&gt;-&lt;span&gt; name: copy nginx.conf
          copy: src&lt;/span&gt;=/app/nginx.cong dest=/etc/nginx/nginx.conf backup=&lt;span&gt;yes
         &lt;span&gt;&lt;strong&gt; notify&lt;/strong&gt;&lt;/span&gt;: reload
          tags: reloadnginx
        &lt;/span&gt;-&lt;span&gt; name: start service
          service: name&lt;/span&gt;=smb state=&lt;span&gt;started
          tags: startsmb
 &lt;span&gt;&lt;strong&gt; handlers&lt;/strong&gt;&lt;/span&gt;:
        &lt;/span&gt;-&lt;span&gt; name: reload
          service: name&lt;/span&gt;=nignx state=restarted
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104812832-615989233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析：notify 和handler 一起使用，当notify 标记的task 发生变化，&lt;/p&gt;

&lt;p&gt;（3）在剧本中加入variables 变量&lt;/p&gt;
&lt;p&gt;a) 变量可以不定义在playbook 中，直接在命令行给出&lt;/p&gt;
&lt;p&gt;① vim /etc/ansible/web.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
---
-&lt;span&gt; hosts: web
  remote_user: root
  tasks:
        &lt;/span&gt;-&lt;span&gt; name: yum install nginx
          yum: name&lt;/span&gt;=nginx state=&lt;span&gt;latest
        &lt;/span&gt;-&lt;span&gt; name: copy nginx.conf
          copy: src&lt;/span&gt;=/app/nginx.conf dest=/etc/nginx/nginx.conf backup=&lt;span&gt;yes
          notify: reload
          tags: reloadnginx
        &lt;/span&gt;-&lt;span&gt; name: start service
          service: name&lt;/span&gt;=&lt;strong&gt;{{ servername }}&lt;/strong&gt; state=&lt;span&gt;started
          tags: start&lt;strong&gt;{{ servername }}&lt;/strong&gt;
  handlers:
        &lt;/span&gt;-&lt;span&gt; name: reload
          service: name&lt;/span&gt;=nginx state=restarted
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② ansible-playbook web.yml &lt;span&gt;&lt;strong&gt;-e servername=httpd&lt;/strong&gt;&lt;/span&gt; -t starthttpd&lt;/p&gt;
&lt;p&gt;分析：-e servername=httpd 指定变量的值为httpd&lt;/p&gt;
&lt;p&gt;-t starthttpd 执行这个标签的操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104813176-815716527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;b) 也可以直接定义在playbook 中&lt;/p&gt;
&lt;p&gt;小提示：可以使用vim 中的s 替换： &lt;strong&gt;% s/nginx/\{\{\ servername\ \}\}/g&lt;/strong&gt; ，可以全局把nginx替换为{{ servername }}&lt;/p&gt;
&lt;p&gt;① vim /etc/ansible/web.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
---
-&lt;span&gt; hosts: web
  remote_user: root
  &lt;span&gt;&lt;strong&gt;vars:
        &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; rpmname: httpd&lt;/strong&gt;&lt;/span&gt;
  tasks:
        &lt;/span&gt;-&lt;span&gt; name: yum install {{ servername }}
          yum: name&lt;/span&gt;={{ servername }} state=&lt;span&gt;latest
        &lt;/span&gt;- name: copy {{ servername }}.conf          copy: src=/app/{{ servername }}.conf dest=/etc/httpd/conf/{{ servername }}.conf backup=&lt;span&gt;yes
          notify: reload
          tags: reload{{ servername }}
        &lt;/span&gt;-&lt;span&gt; name: start service
          service: name&lt;/span&gt;={{ servername }} state=&lt;span&gt;started
          tags: start{{ servername }}
  handlers:
        &lt;/span&gt;- name: reload
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104813488-2073330010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接执行剧本playbook&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104813832-1813936262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;4、在剧本中加入模板 templates&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;模板：templates&lt;/p&gt;
&lt;p&gt;文本文件，嵌套有脚本（使用模板编程语言编写）&lt;/p&gt;
&lt;p&gt;Jin&lt;strong&gt;ja2&lt;/strong&gt;：Jinja2是python的一种模板语言，以Django的模板语言为原本&lt;/p&gt;
&lt;p&gt;支持：&lt;/p&gt;
&lt;p&gt;　　字符串：使用单引号或双引号；&lt;/p&gt;
&lt;p&gt;　　数字：整数，浮点数；&lt;/p&gt;
&lt;p&gt;　　列表：[item1, item2, ...]&lt;/p&gt;
&lt;p&gt;　　元组：(item1, item2, ...)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　字典&lt;/strong&gt;：{key1:value1, key2:value2, ...}&lt;/p&gt;
&lt;p&gt;　　布尔型：true/false&lt;/p&gt;
&lt;p&gt;　　算术运算：+, -, *, /, //, %, **&lt;/p&gt;
&lt;p&gt;　　比较操作：==, !=, &amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=&lt;/p&gt;
&lt;p&gt;　　逻辑运算：and, or, not&lt;/p&gt;

&lt;p&gt;（2）先创建一个模板文件，以&lt;strong&gt;.j2&lt;/strong&gt; 结尾&lt;/p&gt;
&lt;p&gt;cp /etc/nginx/nginx.conf /app/nginx.conf.j2&lt;/p&gt;
&lt;p&gt;vim /app/nginx.conf.j2&lt;/p&gt;
&lt;p&gt;worker_processes {{ ansible_processor_vcpus }}; #该变量是setup 模块查看CPU核数的变量&lt;/p&gt;
&lt;p&gt;listen {{ nginxport }}; #自定义在playbook 中的变量&lt;/p&gt;

&lt;p&gt;（3）在剧本中加入模板&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
---
-&lt;span&gt; hosts: web
  remote_user: root
  vars:
        &lt;/span&gt;-&lt;span&gt; servername: nginx
          nginxport: &lt;/span&gt;8888&lt;span&gt;
  tasks:
        &lt;/span&gt;-&lt;span&gt; name: yum install {{ servername }}
          yum: name&lt;/span&gt;={{ servername }} state=&lt;span&gt;latest
        &lt;/span&gt;-&lt;span&gt; name: copy {{ servername }}.conf
         &lt;span&gt;&lt;strong&gt; templates:&lt;/strong&gt;&lt;/span&gt; src&lt;/span&gt;=/app/{{ servername }}.conf dest=/etc/nginx/{{ servername }}.conf backup=&lt;span&gt;yes
          notify: reload
          tags: reload{{ servername }}
        &lt;/span&gt;-&lt;span&gt; name: start service
          service: name&lt;/span&gt;={{ servername }} state=&lt;span&gt;started
          tags: start{{ servername }}
  handlers:
        &lt;/span&gt;-&lt;span&gt; name: reload
          service: name&lt;/span&gt;={{ servername }} state=restarted
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（4）执行剧本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104814254-1195984085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;实验四：角色定制 roles&lt;/h2&gt;
&lt;h3&gt;1、介绍&lt;/h3&gt;
&lt;p&gt;（2）定义&lt;/p&gt;
&lt;p&gt;　　对于以上所有的方式有个弊端就是无法实现复用假设在同时部署Web、db、ha 时或不同服务器组合不同的应用就需要写多个yml文件。很难实现灵活的调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　roles 用于层次性、结构化地组织playbook&lt;/strong&gt;。roles 能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将&lt;strong&gt;变量(vars)、文件(file)、任务(tasks)、模块(modules)及处理器(handlers)放置于单独的目录中&lt;/strong&gt;，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。&lt;/p&gt;

&lt;p&gt;（2）角色集合示例：&lt;/p&gt;
&lt;p&gt;roles/&lt;/p&gt;
&lt;p&gt;mysql/&lt;/p&gt;
&lt;p&gt;httpd/&lt;/p&gt;
&lt;p&gt;nginx/&lt;/p&gt;
&lt;p&gt;files/：存储由copy或script等模块调用的文件；&lt;/p&gt;
&lt;p&gt;tasks/：此目录中至少应该有一个名为main.yml的文件，用于定义各task；其它的文件需要main.yml进行&quot;包含&quot;调用；&lt;/p&gt;
&lt;p&gt;handlers/：此目录中至少应该有一个名为main.yml的文件，用于定义各handler；其它的文件需要由main.yml进行&quot;包含&quot;调用；&lt;/p&gt;
&lt;p&gt;vars/：此目录中至少应该有一个名为main.yml的文件，用于定义各variable；其它的文件需要由main.yml进行&quot;包含&quot;调用；&lt;/p&gt;
&lt;p&gt;templates/：存储由template模块调用的模板文本；&lt;/p&gt;
&lt;p&gt;meta/：此目录中至少应该有一个名为main.yml的文件，定义当前角色的特殊设定及其依赖关系；其它的文件需要由main.yml进行&quot;包含&quot;调用；&lt;/p&gt;
&lt;p&gt;default/：此目录中至少应该有一个名为main.yml的文件，用于设定默认变量；&lt;/p&gt;

&lt;h3&gt;2、实现&lt;/h3&gt;
&lt;p&gt;（1）先创建目录结构&lt;/p&gt;
&lt;p&gt;cd /etc/ansible/roles&lt;/p&gt;
&lt;p&gt;mkdir -pv ./{nginx,mysql,tomcat}/{files,templates,vars,tasks,handlers,meta,default}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104814582-1285223762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以nginx 为例，cd /etc/ansible/roles/nginx&lt;/p&gt;
&lt;p&gt;（2）编辑tasks&lt;/p&gt;
&lt;p&gt;vim tasks/main.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
-&lt;span&gt; name: copy
  copy: src&lt;/span&gt;=nginx-1.10.2-1.el7.ngx.x86_64.rpm dest=/tmp/nginx-1.10.2-1&lt;span&gt;.el7.ngx.x86_64.rpm

&lt;/span&gt;-&lt;span&gt; name: install
  yum: name&lt;/span&gt;=/tmp/nginx-1.10.2-1.el7.ngx.x86_64.rpm state=&lt;span&gt;latest

&lt;/span&gt;-&lt;span&gt; name: conf
  template: src&lt;/span&gt;=nginx.conf.j2 dest=/etc/nginx/nginx.conf backup=&lt;span&gt;yes
  notify: reload
  tags: nginxconf

&lt;/span&gt;-&lt;span&gt; name: start service
  service: name&lt;/span&gt;=nginx state=started
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）因为要copy，所以把源放到files 目录下&lt;/p&gt;
&lt;p&gt;cp /root/nginx-1.10.2-1.el7.ngx.x86_64.rpm files&lt;/p&gt;

&lt;p&gt;（4）因为有complete 模板，需把模板放到templates 目录&lt;/p&gt;
&lt;p&gt;cp /app/nginx.conf.j2 templates&lt;/p&gt;

&lt;p&gt;（5）因为有notify ，所以需在handlers 目录下定义触发任务&lt;/p&gt;
&lt;p&gt;vim handlers/main.yml&lt;/p&gt;
&lt;p&gt;- name: reload&lt;/p&gt;
&lt;p&gt; service: name=nginx state=reloade&lt;/p&gt;

&lt;p&gt;（6）因为模板里用了变量，所以在vars 定义变量&lt;/p&gt;
&lt;p&gt;vim vars/main.yml&lt;/p&gt;
&lt;p&gt;nginxport: 1234&lt;/p&gt;
&lt;p&gt;最后的目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104814801-968535303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（7）在/etc/ansible 下定义剧本playbook&lt;/p&gt;
&lt;p&gt;vim /etc/ansible/role.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-&lt;span&gt; hosts: web
  remote_user: root
  roles:
        &lt;/span&gt;- { role: nginx,nginxport=1234 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（8）执行剧本 role.yml&lt;/p&gt;
&lt;p&gt;ansible-playbook role.yml&lt;/p&gt;
&lt;p&gt;ansible web -m shell -a &quot;ss -nutl |grep 1234&quot; 查看端口，实验成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1216496/201801/1216496-20180108104815347-1975158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 08 Jan 2018 04:36:00 +0000</pubDate>
<dc:creator>阿龙along</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/along21/p/8241542.html</dc:identifier>
</item>
<item>
<title>基于2-channel network的图片相似度判别 - 笨兔勿应</title>
<link>http://www.cnblogs.com/bentuwuying/p/8242090.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bentuwuying/p/8242090.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、相关理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     本篇博文主要讲解2015年CVPR的一篇关于图像相似度计算的文章：《Learning to Compare Image Patches via Convolutional Neural Networks》，本篇文章对经典的算法Siamese Networks 做了改进。学习这篇paper的算法，需要熟悉Siamese Networks（经典老文献《Signature Verification Using a Siamese Time Delay Neural Network》）、以及大神何凯明提出来的空间金字塔池化（2015年CVPR 文献《Spatial Pyramid Pooling in Deep ConvolutionalNetworks for Visual Recognition》），因为文献基本上是在 Siamese Networks的基础上做修改，然后也要借助于空间金字塔池化实现不同大小图片的输入网络。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122159957-159375027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络总结构&lt;/p&gt;

&lt;p&gt;       如上图所示，我们的目的是比较两幅图片是否相似，或者说相似度是多少，因此我们构建的卷积神经网络模型的输入就是：两幅图片，然后网络的输出是一个相似度数值。其实我觉得，用“计算相似度”这个词有点不合适，我觉得应该翻译为匹配程度。因为文献所采用的训练数据中，如果两张图片匹配，输出值标注为y=1，如果两张图片不匹配，那么训练数据标注为y=-1，也就是说，这个训练数据的标注方法，根本就不是一个相似度数值，而是一个是否匹配的数值。我们打个比方，有三样物体：钢笔、铅笔、书包，那么在训练数据中，就把钢笔和铅笔标注为y=1，而不是用一个相似度数值来衡量，比我钢笔和铅笔的相似度我们把它标注为y=0.9……，所以说用于用相似度这个词有点不合理，即使我们最后计算出来的值是一个-1~1之间的数……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;paper主要创新点：&lt;/strong&gt;在创新点方面，我觉得主要是把Siamese 网络的双分支，合在一起，从而提高了精度，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122218801-1094872795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Siamese 网络&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122227488-1799665499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;paper算法2-channel 网络&lt;/p&gt;

&lt;p&gt;先在这里解释下为什么作者要把它称之为：2-channel networks。理解了2-channel这个词，有助于我们后面理解算法。从上面Siamese 网络，我们可以看到这个网络有两个分支组成，因为我们是要比较两张图片patch1、patch2的相似度，所以Siamese 网络的大体思路，就是让patch1、patch2分别经过网络，进行提取特征向量，然后在最后一层对两个两个特征向量做一个相似度损失函数，进行网络训练，这个后面在给进行比较详细的讲解，总的来说Siamese 对于两张图片patch1、patch2的特征提取过程是相互独立的，我们也可以把Siamese 网络称之为“2-branches networks”。那么paper所提出的算法：2-channel networks 又是什么意思呢？本来patch1、patch2是两张单通道灰度图像、它们各不相干，于是作者的想法就是把patch1、patch2合在一起，把这两张图片，看成是一张双通道的图像。也就是把两个(1，64，64)单通道的数据，放在一起，成为了(2，64，64)的双通道矩阵，然后把这个矩阵数据作为网络的输入，这就是所谓的：2-channel。&lt;/p&gt;
&lt;p&gt;      OK，这就是文献的主要创新点，懂得了这个，后面看paper就容易多了，可以说已经把paper的总思路领悟了一半了，是不是感觉貌似很简单的样子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、Siamese网络相关理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本部分是为了了解经典的Siamese网络，如果已经知道Siamese网络的结构的，请跳过这一部分。&lt;/p&gt;
&lt;p&gt;1、《Learning a similarity metric discriminatively, with application to face verification》&lt;/p&gt;
&lt;p&gt;Siamese网络:这个是一个曾经用于签字认证识别的网络，也就是我们平时说笔迹识别。这个算法可以用于判断签名笔迹，n年前的一个算法。算法的原理利用神经网络提取描述算子，得到特征向量，然后利用两个图片的特征向量判断相似度，这个有点像sift，只不过是利用CNN进行提取特征，并且用特征向量进行构造损失函数，进行网络训练。下面引用2005年CVPR上的一篇文献《Learning a similarity metric discriminatively, with application to face verification》，进行简单讲解，这篇paper主要是利用Siamese网络做人脸相似度判别，可以用于人脸识别哦，因为我觉得这篇文献的网络结构图画的比较漂亮，比较容易看懂，所以就用这一篇文章，简单讲解Siamese网络的思想。其网络如下图所示，有两个分支分别输入图片x1、x2（须知：这两个分支其实是相同的，同一个cnn模型，同样的参数，文献只是为了方便阅读，所以才画成两个分支，因为他们采用的是权重共享），包含卷积、池化等相关运算。双分支有点难理解，我们还是用单分支来理解吧，说的简单一点把，siamese 网络分成前半部分、后半部分。前半部分用于特征提取，我们可以让两张图片，分别输入我们这个网络的前半部分，然后分别得到一个输出特征向量Gw(x1)、Gw(x2)，接着我们构造两个特征向量距离度量，作为两张图片的相似度计算函数（如公式1所示）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122300816-1399131135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Siamese网络 &lt;/p&gt;

&lt;p&gt;如上图所示，我们要判断图片X1和X2是否相似，于是我们构建了一个网络映射函数Gw(x)，然后把x1、x2分别作为参数自变量，我们可以得到Gw(x1)、Gw(x2)，也就是得到用于评价X1、X2是否相似的特征向量。然后我们的目的就是要使得函数：&lt;/p&gt;
&lt;p&gt; &lt;img alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122312613-1762897700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后利用这个损失函数，对网络进行训练，就可以判别两张人脸的相似度了。上面过程中网络的两个分支所用的是同一个函数，也就是权值、网络结构是同一个，我们完全可以把Gw(x)看成是一个特征提取器，因此siamese network网络其实就是一个提取一直图片的特征算子的过程，然后再网络的最后一层，是用于定义了特征向量间相似度的损失函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、Siamese网络&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OK，我们回到本篇博文的主题，下面是paper所用的Siamese网络（shared  weights）。在网络的最后顶层，由线性全连接和ReLU激活函数，构成输出层。在paper中，采用的最后是包含两个全连接层，每个隐层包含512个神经元。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122322269-1152305757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了Siamese网络，文献还提了另外一种Pseudo-siamese网络，这个网络与siamese network网络最大的区别在于两个分支是权值不共享的，是真正的双分支网络模型。Pseudo-siamese在网络的两个分支上，每个分支是不同的映射函数，也就是说它们提取特征的结构是不一样的，左右两个分支，有不同的权值、或者不同的网络层数等，两个函数互不相关，只是在最后的全连接层，将他们连接在一起了。这个网络相当于训练参数比Siamese网络的训练参数多了将近一倍，当然它比Siamese网络更加灵活。&lt;/p&gt;
&lt;p&gt;其实到了这里，我们提到了原始的Siamese、以及Pseudo-siamese，都只是为了衬托后面作者所提出的算法：2-channel networks，因为最后我们要做算法精度对比，所以作者就啰嗦了这么多。这一部分我觉得啰嗦的太多反而会乱掉，所以还是不细讲，以为这个不是重点。下面要讲解的2-channel 网络才是paper的主要创新点，所以才是我们需要好好细读的部分。因为paper的讲解方法，是根据一步一步改进网络的，所以我就根据文献的思路进行讲解，以siamese network为基础：paper首先提出了把siamese 改成2-channel ，这个是第一次对算法的进化，提高了精度。接着提出Central-surround two-stream network，这个算法只是在网络的输入上做了改变，没有改变网络的结构，可以与2-channel、siamese 结合在一起，提高精度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、第一次进化，从siamese 到2-channel （创新点1）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络总体结构，&lt;/strong&gt;2-channel：与前面讲的Siamese网络、Pseudo-siamese网络本质上每个分支就相当于一个特征提取的过程，然后最后一层就相当计算特征向量相似度的函数一样。于是接着作者提出了2-channel网络结构，跳过了分支的显式的特征提取过程，而是直接学习相似度评价函数。双通道网络结构，就相当于把输入的两张灰度图片看成是一张双通道的图片一样。&lt;/p&gt;
&lt;p&gt; &lt;img alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122334160-1279393582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样算法的最后一层直接是全连接层，输出神经元个数直接为1，直接表示两张图片的相似度。直接用双通道图片进行训练会比较快，比较方便，当然CNN，如果输入的是双通道图片，也就是相当于网络的输入的是2个feature map，经过第一层的卷积后网，两张图片的像素就进行了相关的加权组合并映射，这也就是说，用2-channel的方法，经过了第一次的卷积后，两张输入图片就不分你我了。而Siamese网络是到了最后全连接的时候，两张图片的相关神经元才联系在一起，这就是2-channel 与Siamese给我感觉最大的区别。这个作者后面通过试验，验证了从第一层开始，就把两张图片关联在一起的好处，作者的原话：This is something that indicates that it is important to jointly use information from both &lt;/p&gt;
&lt;p&gt;patches right from the first layer of the network.&lt;/p&gt;
&lt;p&gt;这边顺便提一下文献的一个网络架构细节，&lt;strong&gt;卷积核大小&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;Paper所有的卷积核大小都是采用3*3的，因为在《Very Deep Convolutional Networks for Large-Scale Image Recognition》文献中提到，对于小的卷积核来说，比大尺寸的卷积核有更多的非线性，效果更牛逼，总之就是以后遇到CNN，建议用卷积核比较小的，好处多多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、第二次进化，结合Central-surround two-stream network（创新点2）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个创新点，需要对上面的网络结构稍作修改。假设我们输入的是大小为64*64的一张图片，那么Central-surround two-stream network的意思就是把图片64*64的图片，处理成两张32*32图片，然后再输入网络，那么这两张32*32的图片是怎么计算得到的？这就是Central-surround方法，也就是第一张图片是通过以图片中心，进行裁剪出32*32的图片，也就是下图的浅蓝色区域的图片。&lt;/p&gt;
&lt;p&gt; &lt;img alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122344894-929083712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么第二张图片是怎么计算的：这张图片是直接通过对整张图片下采样的方法得到的，也就是说直接把64*64的图片进行下采样得到32*32的图片。那么作者为什么要把一张64*64的图片，拆分成两张32*32的图片。其实这个就像多尺度一样，在图片处理领域经常采用多分辨率、多尺度，比如什么sift、还有什么高斯金字塔什么的，总之作者说了，多分辨率可以提高两张图片的match效果。这个Central-surround two-stream network可以和上面提到的2-channel、Siamese结合在一起，提高精度。下面就是Siamese和Central-surround two-stream network结合在一起的网络结构：&lt;/p&gt;
&lt;p&gt; &lt;img alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122355113-1052539189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是Siamese网络模型，利用Central-surround two-stream network构建新的网络模型，就是在网络输入部分，把输入图片改成多尺度输入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、第三次进化，结合空间金字塔池化SPP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     空间金字塔池化采样：这个又称之为SPP(Spatial pyramid pooling)池化，这个又什么用呢？这个跟上面的有点类似，这个其实就类似于多图片多尺度处理，我们知道现有的卷积神经网络中，输入层的图片的大小一般都是固定的，这也是我之前所理解的一个神经网络。直到知道SPP，感觉视觉又开阔了许多，菜鸟又长见识了。我们知道现在的很多算法中，讲到的训练数据图片的大小，都是什么32*32,96*96,227*227等大小，也就是说训练数据必须归一化到同样的大小，那么假设我的训练数据是各种各样的图片大小呢？我是否一定要把它裁剪成全部一样大小的图片才可以进入卷积神经网络训练呢？这就是SPP算法所要解决的问题，训练数据图片不需要归一化，而且江湖传说，效果比传统的方法的效果还好。下面是Siamese和SPP结合在一起的网络结构：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122408160-12592147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是在全连接层的前面加了个SPP层。&lt;/p&gt;
&lt;p&gt;     关于SPP池化方法，大牛何凯明发表了好几篇文章《Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition》、《Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition》，SSP的相关实现以后再进行讲解，一篇博文一口气如果讲的太多，看着也会觉得累。&lt;/p&gt;
&lt;p&gt;总之这一步是为了使得网络可以输入各种大小的图片，提高网络的实用性，鲁棒性等。&lt;/p&gt;
&lt;p&gt;OK，经过上面的三次进化，网络最后的结构，也就是精度最高，paper最后的算法就是：2-channel+Central-surround two-stream+SPP 的网络结构，因为文献没有把这个网络的结构图画出来，我也懒得画，所以不能给大家提供最后的网络结构图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、网络训练&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先paper采用了如下损失函数：&lt;/p&gt;
&lt;p&gt; &lt;img alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122418832-506098628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公式第一部分就是正则项，采用L2正则项。第二部分误差损失部分&lt;img alt=&quot;&quot;/&gt;是网络第i对训练图片的输出神经元，然后yi的取值是-1或1，当输入图片是matching的时候，为1，当non-matching的时候是-1。&lt;/p&gt;
&lt;p&gt;参数训练更新方法采用ASGD，其学习率恒为1.0，动量参数选择0.9，然后权重衰减大小选择：&lt;/p&gt;
&lt;p&gt; &lt;img alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/995611/201801/995611-20180108122428879-1377117199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;训练的min-batch大小选择128。权重采用随机初始化方法。&lt;/p&gt;
&lt;p&gt;OK，上面是一些网络参数设置。接着就是数据处理部分了，一般就是数据扩充，也就是给图片加上旋转、镜像、等操作。Paper采用的数据扩充，包含水平翻转、垂直翻转、还有就是旋转，包含90、180、270角度的旋转。训练迭代终止的方法不是采用什么early stop，而是启动让电脑跑个几天的时间，等到闲的时候，回来看结果，做对比（ps：这个有点low）。如果你是刚入门CNN的，还没听过数据扩充，可以看看：http://blog.csdn.net/tanhongguang1/article/details/46279991。Paper也是采用了训练过程中，随机数据的扩充的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文献：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、《Learning to Compare Image Patches via Convolutional Neural Networks》&lt;/p&gt;
&lt;p&gt;2、《Discriminative Learning of Local Image Descriptors》&lt;/p&gt;
&lt;p&gt;3、《signature verification using a siamese time delay neural network_bromley》&lt;/p&gt;
&lt;p&gt;4、《Learning visual similarity for product design with convolutional neural networks》&lt;/p&gt;
&lt;p&gt;5、《Learning a similarity metric discriminatively, with application to face verification》&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jan 2018 04:25:00 +0000</pubDate>
<dc:creator>笨兔勿应</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bentuwuying/p/8242090.html</dc:identifier>
</item>
</channel>
</rss>