<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C#中字段、属性、只读、构造函数赋值、反射赋值的相关 - GetPower</title>
<link>http://www.cnblogs.com/gdpw/p/9463145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gdpw/p/9463145.html</guid>
<description>&lt;h2&gt;C#中字段、属性和构造函数赋值的问题&lt;/h2&gt;
&lt;h3&gt;提出问题&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先提出几个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、如何实现自己的注入框架？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、字段和自动属性的区别是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、字段和自动属性声明时的直接赋值和构造函数赋值有什么区别？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、为什么只读字段和只读自动属性（只有get没有set访问器）都可以在构造函数中进行赋值？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、反射可以给只读字段或者只读属性进行赋值吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、自动属性和普通属性的区别？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些问题是我在试着写自己的注入实现时遇到的问题。这些问题应该在学习C#时的第一节课就应该学到了，我看网上还有人分享说他在面试时遇到面试官问为什么只读字段和只读自动属性可以在构造函数中进行赋值，他没有回答上来，然后他写文章探讨这个问题，却没有得出一个明显的答案，实在可惜。&lt;span&gt;网上关于只读属性有些是写ReadOnly特性的，读到这些文章直接跳过吧&lt;/span&gt;，老版本的C#现在看也没什么帮助。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;给出答案&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、&lt;/strong&gt;属性比字段多了get/set访问器；字段是在内存中声明的一个内存空间，可以实实在在的存储值；属性像字段一样使用，却可以有自己的代码段，能赋值取值，是因为访问属性就是调用属性的get/set方法对字段进行取值赋值（或者不操作字段）；在MSDN上，&lt;span&gt;建议字段作为类的私有变量使用private/protected修饰，属性则往往作为共有属性使用public修饰；字段的读取和操作都是直接操作内存，属性是调用get/set访问器，所以字段比属性快&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、&lt;/strong&gt;准确来说，没有区别。区别仅仅是直接赋值先执行，构造函数赋值后执行。在生成的IL中间语言（C#代码先编译成IL代码，然后才编译成汇编语言）中，&lt;span&gt;字段直接赋值和构造函数赋值是在同一个代码段中&lt;/span&gt;（构造函数中）的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、&lt;/strong&gt;这个问题可以和上面的问题联合起来回答。构造函数作为实例化一个类的入口，是最先访问的。字段的直接赋值其实也是放在构造函数中执行的，所以才说直接赋值和构造函数赋值没有区别。“只读”的限制只是由C#编译器（CLR）维护的，我觉得全名应该叫做“除构造函数外只读”更加准确，这是C#语法的规则记住就行（这是当然，直接赋值其实是放在构造函数中进行赋值的，如果构造函数不能赋值那只读字段没有值和没有声明一样）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、&lt;/strong&gt;这个问题又可以和上面的问题联系起来一起回答。通过反射可以给自读字段赋值但是无法给只读属性进行赋值（不相信的可以试一下）。对只读字段的赋值是因为绕过了C#编译器（CLR）的只读显示，对只读属性赋值的话是还是调用set访问器对字段进行赋值，因为没有set访问器所以允许后会报错。那么问题来了，那为什么只读自动属性没有set访问器还可以在构造函数中赋值呢？&lt;span&gt;其实只读自动属性在构造函数中进行赋值，实质上是对字段进行赋值&lt;/span&gt;，和属性的get/set访问器没有关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、&lt;/strong&gt;区别是什么？上面一直强调自动属性，是因为自动属性和普通属性不一样，比如只读普通属性（没有set访问器）无法在构造函数中赋值。在没有自动属性之前，普通属性使用步骤是首先声明一个字段如_id，然后声明一个属性Id，在get和set访问器中做一些操作，这些操作大多数是对字段_id的操作，但是有时候和字段没有关系。&lt;/span&gt;&lt;span&gt;普通属性可以像字段一样通过“.”的方式调用，但又像方法一样具有代码段（&lt;span&gt;普通属性从来不开辟内存空间&lt;/span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是C#3.0之后引入了自动属性，声明方式如public int id { get; set; }，C#6.0之后又有了public string FirstName { get; set; } = &quot;Jane&quot;。&lt;span&gt;自动属性肯定开辟了内存空间&lt;/span&gt;然后才有了自动属性的直接赋值。其实在类中声明自动属性会在编译成IL中间语言中&lt;span&gt;声明一个隐藏字段，然后生成隐藏字段的get/set方法，然后生成get/set访问器&lt;/span&gt;。这里可以解释为什么只读普通属性无法在构造函数中赋值（和直接赋值）而只读自动属性可以在构造函数中赋值（和直接赋值），因为不论直接赋值还是在构造函数中赋值，生成的IL代码中的构造函数中，操作的都是隐藏字段，并没有访问属性的set访问器。（注意这里只是说的类中的自动属性，接口中也是可以有自动属性的，但是接口的自动属性并不会生成隐藏字段只是定义get/set访问器）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;开始解释&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;通过C#生成的IL中间语言代码可以知道的更清楚&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User()
        {
            id &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            age &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1261060/201808/1261060-20180812145223343-693715619.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1261060/201808/1261060-20180812145234972-1695309657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，自动属性会生成一个名称为 &lt;span&gt;'&amp;lt;age&amp;gt;k__BackingField'&lt;/span&gt; 的隐藏私有字段+私有字段的get/set方法+属性代码段；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到IL代码生成了User的构造函数 &lt;span&gt;.ctor&lt;/span&gt;，ctor是构造函数（Constructor）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;不论直接赋值还是构造函数赋值，都是在.ctor中执行的，并且操作的都是字段，自动属性的赋值操作的是隐藏字段&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUser
  {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1261060/201808/1261060-20180812150506636-1737628269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，&lt;span&gt;接口中的自动属性并没有生成隐藏字段&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;其他说明&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、上文中提到“&lt;span&gt;反射可以给只读字段进行赋值但是无法给只读属性进行赋值&lt;/span&gt;”。无法给只读属性进行赋值是因为没有set访问器。但是我们已经知道了可以给字段赋值，并且只读属性会生成隐藏字段，那我们是不是可以通过给隐藏字段进行赋值间接达到给自动属性赋值的目的呢？&lt;span&gt;答案是可以的！&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义User的只读自动属性&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age { &lt;span&gt;get&lt;/span&gt;;  } = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User()
        {
            age &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;控制台的反射赋值代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; { &lt;span&gt;typeof&lt;/span&gt;(User).GetProperty(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).SetValue(user, &lt;span&gt;9&lt;/span&gt;&lt;span&gt;); }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;{    Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;只读属性赋值失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);}
            &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(User).GetField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;age&amp;gt;k__BackingField&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, BindingFlags.Instance | BindingFlags.NonPublic).SetValue(user,&lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(user.age);
            Console.Read();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1261060/201808/1261060-20180812152543362-418265928.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、因为隐藏字段是私有的，所以取到隐藏字段需要 &lt;span&gt; BindingFlags.NonPublic&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、只读自动属性说明不想被访问到那为什么还要给它赋值呢？这个问题……做着玩，项目中我觉得也没有什么用到的机会……&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 07:27:00 +0000</pubDate>
<dc:creator>GetPower</dc:creator>
<og:description>C#中字段、属性和构造函数赋值的问题 提出问题 首先提出几个问题： 1、如何实现自己的注入框架？ 2、字段和自动属性的区别是什么？ 3、字段和自动属性声明时的直接赋值和构造函数赋值有什么区别？ 4、为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gdpw/p/9463145.html</dc:identifier>
</item>
<item>
<title>讲讲断点续传那点儿事 - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/9463141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/9463141.html</guid>
<description>&lt;p&gt;这次想来讲讲断点续传，以前没相关需求，所以一直没去接触，近阶段了解了之后，其实并不复杂，那么也便来写一篇记录一下，分享给大伙，也方便自己后续查阅。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q1：如果你的 app 需要下载大文件，那么是否有方法可以缩短下载耗时？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2：如果你的 app 在下载大文件时，程序因各种原因被迫中断了，那么下次再重启时，文件是否还需要重头开始下载？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q3：你的 app 下载大文件时，支持暂停并恢复下载么？即使这两个操作分布在程序进程被杀前后。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;讲之前，先来通俗的解释下什么是&lt;strong&gt;断点续传&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;说得白一点，其实也就是下载文件时，不必重头开始下载，而是从指定的位置继续下载，这样的功能就叫做断点续传。&lt;/p&gt;
&lt;p&gt;既然如此，那么要实现断点续传的关键点其实也就是两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;如何告知服务端，从指定的位置下载&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何知道客户端想要的指定位置是多少&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;是吧，理论上来讲，当这两点都可以做到的时候，自然就可以实现断点续传了。那么，要如何做到呢？&lt;/p&gt;
&lt;p&gt;其实，也很简单，并不需要我们自己去写一些什么，HTTP 协议本身就支持断点续传了，所以借助它就可以实现告知服务端，从指定位置下载的功能了。&lt;/p&gt;
&lt;p&gt;而另一点，就更简单了，文件是下载到客户端设备上的，那么只要获取到这份下载到一半的文件，看一下它目前的大小，也就知道需要让服务端从哪开始继续下载了。&lt;/p&gt;
&lt;p&gt;那么，下面就介绍一下涉及到的相关理论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Range &amp;amp; Content-Length &amp;amp; Content-Range &amp;amp; If-Range&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些都是 HTTP 包中 Header 头部的一些字段信息，其中 Range 和 If-Range 是请求头中的字段，Content-Length 和 Content-Range 是响应头中的字段。&lt;/p&gt;
&lt;h3 id=&quot;range&quot;&gt;Range&lt;/h3&gt;
&lt;p&gt;当请求头中出现 Range 字段时，表示告知服务端，客户端下载该文件想要从指定的位置开始下载，至于 Range 字段属性值的格式有以下几种：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Range:bytes=0-500&lt;/td&gt;
&lt;td&gt;表示下载从0到500字节的文件，即头500个字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Range:bytes=501-1000&lt;/td&gt;
&lt;td&gt;表示下载从500到1000这部分的文件，单位字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Range:bytes=-500&lt;/td&gt;
&lt;td&gt;表示下载最后的500个字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Range:bytes=500-&lt;/td&gt;
&lt;td&gt;表示下载从500开始到文件结束这部分的内容&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当 app 想实现缩短大文件的下载耗时，可以开启多个下载线程，每个线程只负责文件的一部分下载，当所有线程下载结束后，将每个线程下载的文件按顺序拼接成一个完整的文件，这样就可以达到缩短下载大文件的耗时目的了。&lt;/p&gt;
&lt;p&gt;那么，此时，就可以使用 &lt;code&gt;Range:bytes=501-1000&lt;/code&gt; 这种格式了，每个线程在各自的请求头字段中，以这种格式加入相对应的信息即可达到目的了。&lt;/p&gt;
&lt;p&gt;如果 app 想实现断点续传，文件下载到一半被迫中断，下次启动还可以继续接着上次进度下载时，那么此时可以使用 &lt;code&gt;Range:bytes=500-&lt;/code&gt; 这种格式了，只要先获取本地那份文件目前的大小，通过在请求头中加入 Range 字段信息即可。&lt;/p&gt;
&lt;h3 id=&quot;content-length&quot;&gt;Content-Length&lt;/h3&gt;
&lt;p&gt;Content-Length 字段出现在响应头中，用于告知客户端此次下载的文件大小。&lt;/p&gt;
&lt;p&gt;一般，如果客户端需要实现下载进度实时更新时，就需要知道文件的总大小和目前下载的大小，后者可以通过对本地文件的操作得知，前者一般就是通过响应头中的 Content-Length 字段得知。&lt;/p&gt;
&lt;p&gt;另外，如果想要实现多线程同时分段下载大文件功能时，显然在下载前，客户端需要先知道文件总大小，才可以做到动态进行分段，因此一般在下载前都会先发送一个不需要携带 body 信息请求，用于先获取响应头中的 Content-Length 字段来得知文件总大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但有一点需要注意：Content-Length 只表示此链接中下载的文件大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么意思，也就是说，如果这条链接是一次性将整个文件下载下来的，那么 Content-Length 就表示这个文件的总大小。&lt;/p&gt;
&lt;p&gt;但，如果这条链接指定了 Range，表明了只是下载文件的指定部分的内容，那么此时 Content-Length 表示的就只是这一部分的大小。&lt;/p&gt;
&lt;p&gt;所以，如果客户端实现了下载进度实时更新功能时，需要注意一下。因为如果文件是断点续传的，那么进度条的分母就不能用每次 HTTP 链接中的 Content-Length。要么下载前先发一条获取用于文件总大小的请求，然后一直维护着这个数据，要么就使用 Content-Range 字段。&lt;/p&gt;
&lt;h3 id=&quot;content-range&quot;&gt;Content-Range&lt;/h3&gt;
&lt;p&gt;Content-Range 字段也是出现在响应头中，用于告知客户端此链接下载的文件是哪个部分的，以及文件的总大小。&lt;/p&gt;
&lt;p&gt;比如，当客户端在请求头中指定了 &lt;code&gt;Range:bayes=501-1000&lt;/code&gt; 来下载一个总大小为 2000 字节文件的中间一部分内容时，此时，响应头中的 Content-Range 字段信息如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Content-Range:bytes 501-1000/2000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;斜杠前表示此链接下载的文件是哪一部分，斜杠后表示文件的总大小。&lt;/p&gt;
&lt;h3 id=&quot;if-range&quot;&gt;If-Range&lt;/h3&gt;
&lt;p&gt;断点续传，说白点也就是分多次下载，既然不是一次性下载，那么就无法保证多次下载的间隔。&lt;/p&gt;
&lt;p&gt;也就是说，有可能出现这种场景，这次由于某些原因只下载的一部分，而下次重启继续下载，但可能等到过了很多天后才重启去继续下载，如果在这期间，服务端的这份文件更新了怎么办？&lt;/p&gt;
&lt;p&gt;只要不是一次性下载的，那么就有可能会出现这种场景，显然，这时候，就不希望断点续传了，而是要让客户端直接重头开始下载，毕竟文件都已经发生更新了，不是同一份了，再继续恢复下载也没有什么意义。&lt;/p&gt;
&lt;p&gt;那么，客户端要如何知道服务端的文件是否发生变化，要重头下载呢？&lt;/p&gt;
&lt;p&gt;这时就可以结合 If-Range 字段来实现了，这个也是在请求头中的字段，跟 Range 字段一起使用，它的作用是给 Range 字段生效设置了一些条件，只有满足这些条件，Range 才能生效。&lt;/p&gt;
&lt;p&gt;也就是说，只有先满足 If-Range，那么才能通过 Range 来实现断点续传。&lt;/p&gt;
&lt;p&gt;那它的条件值可以设置为哪些呢？有两种，Last-Modified 或者 ETag，这两个也都是响应头中的字段。&lt;/p&gt;
&lt;p&gt;具体可以参考这篇文章：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range&quot;&gt;MDN If-Range&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;抓包示例&quot;&gt;抓包示例&lt;/h3&gt;
&lt;p&gt;以上就是断点续传相关的理论基础，下面抓个包，看看请求头和响应头中的信息，来总结一下理论基础。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-e01bee6c8b81e0e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;断点续传.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先先发起一个请求，设置了不携带 BODY 信息，这样就可以在下载前先获取到文件的总大小。至于怎么设置不携带 BODY 信息，不同的网络框架不同，具体下节代码示例中说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-91495ddefb8b2eb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;断点续传2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是下载中断后，重启想要继续下载时发起的请求信息，请求头中指定了 &lt;code&gt;Range:bytes=12341380-&lt;/code&gt; 表示本地已经下载了这么多，需要从这里开始继续往下下载。&lt;/p&gt;
&lt;p&gt;响应头中返回了这部分的内容，并在 Content-Length 和 Content-Range 字段中给出了相关信息。&lt;/p&gt;

&lt;p&gt;理论基础掌握了，那么下面就是来看看代码怎么实现。不管用什么语言，使用了什么网络框架，要写的代码都有两个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件处理操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;添加请求头信息操作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文件处理操作有两个关键点，一是获取文件大小，二是以追加的方式写文件。添加请求头的操作则是参考各自网络框架的指示即可。&lt;/p&gt;
&lt;p&gt;下面介绍了三种示例，分别是 C++&amp;amp;libcurl，Android&amp;amp;HttpURLConnection，Android&amp;amp;OkHttp。&amp;amp;前面是语言，后面是所使用的网络框架。&lt;/p&gt;
&lt;h3 id=&quot;clibcurl&quot;&gt;C++&amp;amp;libcurl&lt;/h3&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;//引入libcurl库
#include &amp;lt;curl\curl.h&amp;gt;
#pragma comment(lib,&quot;libcurl.lib&quot;) 
//文件操作库
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fstream&amp;gt;

char* mLocalFilePath;//下载到本地的文件

//获取已下载部分的大小，如果没有则返回0
curl_off_t getLocalFileLength()
{
    curl_off_t ret = 0;
    struct stat fileStat;
    ret = stat(mLocalFilePath, &amp;amp;fileStat);
    if (ret == 0)
    {
        return fileStat.st_size;//返回本地文件已下载的大小
    }
    else
    {
        return 0;
    }
}

//下载前先发送一次请求，获取文件的总大小
double getDownloadFileLength()
{
    double rel = 0, downloadFileLenth = 0;
    CURL *handle = curl_easy_init();
    curl_easy_setopt(handle, CURLOPT_URL, mDownloadFileUrl);
    curl_easy_setopt(handle, CURLOPT_HEADER, 1);    //只需要header头
    curl_easy_setopt(handle, CURLOPT_NOBODY, 1);    //不需要body
    if (curl_easy_perform(handle) == CURLE_OK) {
        curl_easy_getinfo(handle, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &amp;amp;downloadFileLenth);
    }
    else {
        downloadFileLenth = -1;
    }
    rel = downloadFileLenth;
    curl_easy_cleanup(handle);
    return rel;
}

//文件下载
CURLcode downloadInternal()
{
    //1. 获取本地已下载的大小，有则断点续传
    curl_off_t localFileLenth = getLocalFileLength();
    //2. 以追加的方式写入文件
    FILE *file = fopen(mLocalFilePath, &quot;ab+&quot;);
    CURL* mHandler = curl_easy_init();
    if (mHandler &amp;amp;&amp;amp; file)
    {
         //3. 设置url
        curl_easy_setopt(mHandler, CURLOPT_URL, mDownloadFileUrl);
        //4. 设置请求头 Range 字段信息，localFileLength 不等于0时，值大小就表示从哪开始下载 
        curl_easy_setopt(mHandler, CURLOPT_RESUME_FROM_LARGE, localFileLenth);
        
        //5. 设置接收数据的处理函数和存放变量
        curl_easy_setopt(mHandler, CURLOPT_WRITEFUNCTION, writeFile);
        curl_easy_setopt(mHandler, CURLOPT_WRITEDATA, file);
        // 6. 发起请求
        CURLcode rel = curl_easy_perform(mHandler);
        fclose(file);
        return rel;
    }
    curl_easy_cleanup(mHandler);
    return CURLE_FAILED_INIT;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;writeFile 函数和下载进度通知的函数我都没贴，用过 libcurl 的应该都知道怎么写，或者网上搜一下，资料很多。上面就是将断点续传的几个关键函数贴出来，理清楚了即可。&lt;/p&gt;
&lt;h3 id=&quot;androidhttpurlconnection&quot;&gt;Android&amp;amp;HttpURLConnection&lt;/h3&gt;
&lt;h3 id=&quot;androidokhttp&quot;&gt;Android&amp;amp;OkHttp&lt;/h3&gt;
&lt;p&gt;由于最近都在忙 C++ 的项目了，Android 暂时还没时间自己写个 demo 测试一下，所以先给几篇网上找的链接占个坑，后续抽个时间自己再来写个 demo。&lt;/p&gt;
&lt;p&gt;之所以列了这两点，是因为感觉目前 Android 中网络框架大多都是用的 OkHttp 了，而下载文件还有很多都是用的 HttpURLConnection，所以这两个都想研究一下，怎么写断点续传。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/2b82db0a5181&quot;&gt;Android多线程断点续传下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/cfy137000/article/details/54838608&quot;&gt;Android使用OKHttp3实现下载(断点续传、显示进度)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;两篇我都有大概过了下，其实断点续传原理不难，真的蛮简单的，所以实现上基本也大同小异，就是不同的网络框架的 api 用法不同而已。以及，如何维护本地已下载文件的大小的思路，有的是直接去获取文件对象查看，有的则是手动自己建个数据库维护。&lt;br/&gt;***&lt;br/&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 07:21:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<og:description>**Q1：如果你的 app 需要下载大文件，那么是否有方法可以缩短下载耗时？** **Q2：如果你的 app 在下载大文件时，程序因各种原因被迫中断了，那么下次再重启时，文件是否还需要重头开始下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/9463141.html</dc:identifier>
</item>
<item>
<title>java-并发编程 - 嗜血蚂蚁</title>
<link>http://www.cnblogs.com/shixiemayi/p/9460141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shixiemayi/p/9460141.html</guid>
<description>&lt;p&gt;1、并发编程&lt;/p&gt;
&lt;p&gt;　　并发通常能提高单处理器的程序性能。可是，看到这句话有些违背直觉。多线程的运行增加了线程间切换的开销，仅仅从这个角度看，单线程运行总比多线程的性能好。但是，程序的阻塞会使得结果不一样，当某个线程阻塞时候，其它线程仍然可以执行，因此程序仍保持运行。充分利用cpu的时间提高的性能远大于线程间的切换带来的性能下降。&lt;/p&gt;
&lt;p&gt;何为阻塞：程序中某个线程由于在不满足某些条件的情况下而导致不能够继续执行的现象&lt;/p&gt;
&lt;p&gt;2、基本线程机制：&lt;/p&gt;
&lt;p&gt;　　一个程序可以分为多个独立运行任务，每个独立任务由线程驱动执行。线程并发执行，表面看起来是同时执行，好像各自都有一个自己的CPU一样。实际上，底层机制是CPU将时间片分给各个线程，一个时间只能有一个线程获得CPU的时间片，也就是线程独占CPU资源。&lt;/p&gt;
&lt;p&gt;3、定义任务类、定义线程类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义任务&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.duoxiancheng;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutorService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;2; i++&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LiftOff()).start();
        }
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; LiftOff &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; countDown=3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; taskCount=0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id=taskCount++&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (countDown--&amp;gt;0&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;#id=&quot; + id + &quot; countDown=&quot;+(countDown &amp;gt; 0 ? countDown : &quot;LiftOff!&quot;&lt;span&gt;));
            Thread.yield();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#id=0 countDown=2&lt;span&gt;
#id&lt;/span&gt;=1 countDown=2&lt;span&gt;
#id&lt;/span&gt;=0 countDown=1&lt;span&gt;
#id&lt;/span&gt;=1 countDown=1&lt;span&gt;
#id&lt;/span&gt;=0 countDown=LiftOff!&lt;span&gt;
#id&lt;/span&gt;=1 countDown=LiftOff!
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;定义线程类&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.duoxiancheng;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;2; i++&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LiftOff().start();
        }
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; LiftOff &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; countDown=3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; taskCount=0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id=taskCount++&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (countDown--&amp;gt;0&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;#id=&quot; + id + &quot; countDown=&quot;+(countDown &amp;gt; 0 ? countDown : &quot;LiftOff!&quot;&lt;span&gt;));
            Thread.yield();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、线程池&lt;/p&gt;
&lt;p&gt;待续...&lt;/p&gt;
&lt;p&gt;5、从任务中产生返回值---Callable&amp;lt;T&amp;gt;接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.duoxiancheng;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main1 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{

        ExecutorService executorService&lt;/span&gt;=&lt;span&gt; Executors.newCachedThreadPool();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;50;i++&lt;span&gt;){
            Future future &lt;/span&gt;= executorService.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TaskWithResult(i));
            Object result &lt;/span&gt;=&lt;span&gt; future.get();
            System.out.println(result);
        }
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; TaskWithResult &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Callable{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id=0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TaskWithResult(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id=&lt;span&gt;id;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;span&gt;future.get()&lt;/span&gt;是阻塞的方法；如果想想立即阻塞任务的等待，则可以使用 &lt;tt&gt;result = exec.submit(aCallable).get();&lt;/tt&gt; 形式&lt;/p&gt;
&lt;p&gt;6、常用方法&lt;/p&gt;
&lt;p&gt;休眠---sleep()&lt;/p&gt;
&lt;p&gt;让步---yield()&lt;/p&gt;
&lt;p&gt;加入一个线程---join()&lt;/p&gt;
&lt;p&gt;优先级--setPriority()/getPriority()&lt;/p&gt;
&lt;p&gt;后台线程--setDaemon()/isDaemon()&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;7、捕获线程中的异常&lt;/p&gt;
&lt;p&gt;线程中抛出异常，会传播到控制台，除非采用特殊手段。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在run()方法内部try-catch-finally捕获异常&lt;/li&gt;
&lt;li&gt;使用异常处理器捕获异常--异常处理器实现Thread.UncaughtExceptionHandler接口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下分析自定义异常处理器：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;为线程设置异常处理器。具体做法可以是以下几种：&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;（1）Thread.setUncaughtExceptionHandler设置当前线程的异常处理器；&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;（2）Thread.setDefaultUncaughtExceptionHandler为整个程序设置默认的异常处理器；&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;如果当前线程有异常处理器（默认没有），则优先使用该UncaughtExceptionHandler类；否则，如果当前线程所属的线程组有异常处理器，则使用线程组的&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;UncaughtExceptionHandler；否则，使用全局默认的DefaultUncaughtExceptionHandler；如果都没有的话，子线程就会退出&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.duoxiancheng;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ThreadFactory;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main2 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        Thread thread&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExceptionThread());
        thread.setUncaughtExceptionHandler(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyExceptionHandler());
        thread.start();
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 任务类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; ExceptionThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        Thread t &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
        System.out.println(&lt;/span&gt;&quot;ExceptionThread 当前线程信息：&quot;+&lt;span&gt;t.toString());
        System.out.println(&lt;/span&gt;&quot;当前线程ExceptionThread的异常处理器&quot;
                +&lt;span&gt;t.getUncaughtExceptionHandler());
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException();
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 线程异常处理器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; MyExceptionHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Thread.UncaughtExceptionHandler {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; uncaughtException(Thread t, Throwable e) {
        System.out.println(&lt;/span&gt;&quot;抛出的异常是：&quot;+&lt;span&gt;e);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 8、共享资源&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共享资源竞争：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　导致线程安全问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解决思想：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　多人（线程）都希望单独使用浴室（共享资源）。为了使用浴室，一个人先敲门，看能不能使用。如果没人回话，他就进入浴室并锁上门（获得锁）。这时候，其它人想使用浴室的话，就会被阻挡在外面（不能获取锁），直到浴室可以使用。浴室外面的人没有排队，浴室门打开（前一个人释放锁），离门最近的人优先进入使用（获得锁，设置优先级和yield方法可以建议某个优先使用）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解决方式：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　Synchronized&lt;/span&gt; 、Lock锁同步以及Voliate修饰符和原子类&lt;/p&gt;
&lt;p&gt;　　线程本地存储---ThreadLocal&lt;/p&gt;
&lt;p&gt;9、线程之间协作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生产者与消费者&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.duoxiancheng;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Condition;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *  生产者-消费者
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main3 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[ ] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Restaurant restaurant&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Restaurant();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProductorThread(restaurant)).start();
        Thread.sleep(&lt;/span&gt;20&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConsumerThread(restaurant)).start();
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Restaurant {

    Lock lock&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;锁&lt;/span&gt;
    Condition condition1=lock.newCondition();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;条件1&lt;/span&gt;
    Condition condition2=lock.newCondition();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;条件2&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已做好的餐&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count2;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 消费者方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; comsumer(){
        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count==0&lt;span&gt;) {
                System.out.println(Thread.currentThread().getId()&lt;/span&gt;+&quot;客户 想要一份快餐！&quot;&lt;span&gt;);
                condition2.signalAll();
                System.out.println(Thread.currentThread().getId()&lt;/span&gt;+&quot;客户 等待一份快餐！&quot;&lt;span&gt;);
                condition1.await();
            }
            count&lt;/span&gt;--&lt;span&gt;;
            System.out.println(Thread.currentThread().getId()&lt;/span&gt;+ &quot;客户 消费了一份快餐！&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 生产者方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; productor(){
        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            condition2.await();
            count&lt;/span&gt;++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生产一份快餐&lt;/span&gt;
            System.out.println(Thread.currentThread().getId()+ &quot;厨师 制作了一份快餐！&quot;&lt;span&gt;);
            condition1.signalAll();
            System.out.println(Thread.currentThread().getId()&lt;/span&gt;+&quot;厨师 通知客户使用&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e){
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 消费者
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; ConsumerThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Restaurant restaurant;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConsumerThread(Restaurant restaurant){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.restaurant=&lt;span&gt;restaurant;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        restaurant.comsumer();
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 生产者
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; ProductorThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Restaurant restaurant;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ProductorThread(Restaurant restaurant){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.restaurant=&lt;span&gt;restaurant;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        restaurant.productor();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;11客户 想要一份快餐！
11客户 等待一份快餐！
10厨师 制作了一份快餐！
10厨师 通知客户使用
11客户 消费了一份快餐！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;生产者与消费者 和 队列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　使用wait()、notifyAll() 是一种解决任务互操作问题非常低级的方式。使用同步队列来解决任务协作问题，同步队列在任何时刻只允许一个任务插入或移除。&lt;/p&gt;
&lt;p&gt;java.util.concurrent.BlockingQueue接口提供了这个同步队列，其有大量的实现。通常可以使用LinkedBlockingDeque（无界队列) 和 ArrayBlockingDeque（固定尺寸队列）。&lt;/p&gt;
&lt;p&gt;消费者任务试图从队列中获取对象，而该队列此时为空，那这些队列还可以挂起消费者任务（阻塞）；当有更多元素可用时恢复消费者任务。阻塞队列可以解决非常大量的问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.duoxiancheng;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutorService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.LinkedBlockingDeque;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 生产者-消费者与队列
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main4 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        ExecutorService executorService&lt;/span&gt;=&lt;span&gt; Executors.newCachedThreadPool();

        LinkedBlockingDeque&lt;/span&gt;&amp;lt;Toast&amp;gt; toastQueue=&lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;&lt;span&gt;();
        LinkedBlockingDeque&lt;/span&gt;&amp;lt;Toast&amp;gt; butteredQueue=&lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;&lt;span&gt;();
        LinkedBlockingDeque&lt;/span&gt;&amp;lt;Toast&amp;gt; jammedQueue=&lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;&lt;span&gt;();

        executorService.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Toaster(toastQueue));
        executorService.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Butterer(toastQueue, butteredQueue));
        executorService.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Jammed(butteredQueue, jammedQueue));
        executorService.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Eater(jammedQueue));

    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Toast{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Status status=&lt;span&gt;Status.DRY;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Toast(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Status getStatus() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addButtered(){
        status&lt;/span&gt;=&lt;span&gt;Status.BUTTERED;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addJammed(){
        status&lt;/span&gt;=&lt;span&gt;Status.JAMMED;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Toast &quot;+id+&quot; : &quot;+&lt;span&gt;status;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 枚举类型
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Status{
        DRY,BUTTERED,JAMMED
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 制作吐司
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Toaster &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LinkedBlockingDeque&amp;lt;Toast&amp;gt;&lt;span&gt; toastQueue;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Toaster(LinkedBlockingDeque toastQueue){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.toastQueue=&lt;span&gt;toastQueue;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
                Toast toast &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Toast(count++&lt;span&gt;);
                System.out.println(toast);
                toastQueue.put(toast);
                Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 添加黄油
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Butterer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LinkedBlockingDeque&amp;lt;Toast&amp;gt;&lt;span&gt; toastQueue;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LinkedBlockingDeque&amp;lt;Toast&amp;gt;&lt;span&gt; butteredQueue;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Butterer(LinkedBlockingDeque toastQueue,LinkedBlockingDeque butteredQueue){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.toastQueue=&lt;span&gt;toastQueue;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.butteredQueue=&lt;span&gt;butteredQueue;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
                Toast toast &lt;/span&gt;=&lt;span&gt; toastQueue.take();
                toast.addButtered();
                System.out.println(&lt;/span&gt;&quot;添加黄油, &quot; +&lt;span&gt; toast);
                butteredQueue.put(toast);
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e){
            e.printStackTrace();
        }
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 添加果酱
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Jammed &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LinkedBlockingDeque&amp;lt;Toast&amp;gt;&lt;span&gt; butteredQueue;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LinkedBlockingDeque&amp;lt;Toast&amp;gt;&lt;span&gt; jammedQueue;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Jammed(LinkedBlockingDeque butteredQueue, LinkedBlockingDeque jammedQueue){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.butteredQueue=&lt;span&gt;butteredQueue;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.jammedQueue=&lt;span&gt;jammedQueue;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
                Toast toast &lt;/span&gt;=&lt;span&gt; butteredQueue.take();
                toast.addJammed();
                System.out.println(&lt;/span&gt;&quot;添加果酱, &quot; +&lt;span&gt; toast);
                jammedQueue.put(toast);
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e){
            e.printStackTrace();
        }
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 消费吐司
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Eater &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LinkedBlockingDeque&amp;lt;Toast&amp;gt;&lt;span&gt; jammedQueue;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Eater(LinkedBlockingDeque jammedQueue){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.jammedQueue=&lt;span&gt;jammedQueue;
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; counter;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
                Toast toast &lt;/span&gt;=&lt;span&gt; jammedQueue.take();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (toast.getStatus() !=&lt;span&gt; Toast.Status.JAMMED) {
                    System.out.println(&lt;/span&gt;&quot;=====ERROR=====&quot;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    System.out.println(&lt;/span&gt;&quot;消费了一个吐司&quot;&lt;span&gt;);
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;10、死锁&lt;/p&gt;
&lt;p&gt;某个线程在等待另一个线程释放锁，而后者又在等别的线程的所，这样一直下去，直到整个链条上的线程又在等第一个线程释放锁。这样线程之间的相互等待的连续循环，导致没有哪个线程能继续执行的现象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;死锁四大条件：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;请求与保持&lt;/p&gt;
&lt;p&gt;不可剥夺&lt;/p&gt;
&lt;p&gt;互斥条件&lt;/p&gt;
&lt;p&gt;循环等待&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;防止死锁：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;发生死锁必须全部满足四大条件，要避免死锁，只需破坏其中一个即可。&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 07:02:00 +0000</pubDate>
<dc:creator>嗜血蚂蚁</dc:creator>
<og:description>1、并发编程 并发通常能提高单处理器的程序性能。可是，看到这句话有些违背直觉。多线程的运行增加了线程间切换的开销，仅仅从这个角度看，单线程运行总比多线程的性能好。但是，程序的阻塞会使得结果不一样，当某</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shixiemayi/p/9460141.html</dc:identifier>
</item>
<item>
<title>Windows Community Toolkit 3.0 - InfiniteCanvas - shaomeng</title>
<link>http://www.cnblogs.com/shaomeng/p/9281065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shaomeng/p/9281065.html</guid>
<description>&lt;p&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;InfiniteCanvas 是一个 Canvas 控件，它支持无限画布的滚动，支持 Ink，文本，格式文本，画布缩放操作，撤销重做操作，导入和导出数据。&lt;/p&gt;
&lt;p&gt;这是一个非常实用的控件，在“来画视频” UWP 应用的绘画功能中，也用到了这个控件，它对不同画笔的选择，橡皮擦，直尺和圆形尺，文字输入和字体选择等都提供了很便捷的支持，而且支持导入和导出数据，可以很方便的创作绘画作品，并能导出和分享给别人。 &lt;/p&gt;
&lt;p&gt;下面是 Windows Community Toolkit Sample App 的示例截图和 code/doc 地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201808/306530-20180811171258913-989231043.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/communitytoolkit/controls/infinitecanvas&quot; target=&quot;_blank&quot;&gt;Windows Community Toolkit Doc - InfiniteCanvas&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/WindowsCommunityToolkit/tree/master/Microsoft.Toolkit.Uwp.UI.Controls/InfiniteCanvas&quot; target=&quot;_blank&quot;&gt;Windows Community Toolkit Source Code - InfiniteCanvas&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Namespace: &lt;strong&gt;&lt;em&gt;Microsoft.Toolkit.Uwp.UI.Controls;&lt;/em&gt;&lt;/strong&gt; Nuget: &lt;em&gt;&lt;strong&gt;Microsoft.Toolkit.Uwp.UI.Controls&lt;/strong&gt;&lt;/em&gt;;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;开发过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码结构分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先来看 InfiniteCanvas 的代码结构，组成如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Commands - InfiniteCanvas 对应的所有命令，包括 redo/undo，Ink，Text 等，如上面示例图中 Toolbar 上所示；&lt;/li&gt;
&lt;li&gt;Controls - InfiniteCanvas 的主要控件都在这个文件夹里；&lt;/li&gt;
&lt;li&gt;Drawables - Text 和 Ink 主要的绘制功能在这个文件夹里；&lt;/li&gt;
&lt;li&gt;JsonConverters - 序列化和反序列化的主要功能，以及自定义的 Ink 属性等；&lt;/li&gt;
&lt;li&gt;InfiniteCanvas.Events.cs - InfiniteCanvas 的主要事件处理逻辑；&lt;/li&gt;
&lt;li&gt;InfiniteCanvas.TextBox.cs - InfiniteCanvas 添加文字的文本框控件处理逻辑；&lt;/li&gt;
&lt;li&gt;InfiniteCanvas.cs - InfiniteCanvas 控件的主要处理逻辑；&lt;/li&gt;
&lt;li&gt;InfiniteCanvas.xaml - InfiniteCanvas 控件的 XAML 样式文件；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201808/306530-20180811171855445-415594321.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt; &lt;/p&gt;
&lt;p&gt;InfiniteCanvas 整体类结构很清晰，每个类的功能也很明确，下面我们选取几个重要的类来做分析。&lt;/p&gt;
&lt;p&gt;1.  InfiniteCanvasCreateInkCommand&lt;/p&gt;
&lt;p&gt;Command 文件夹的每一个类都比较简单，我们找一个创建 Ink 命令看一下；该类实现了 IInfiniteCanvasCommand 这个接口，实现了 Execute() 和 Undo() 两个方法；Command 初始化也很简单，创建一个 InkDrawable 对象，初始化 drawableList 对象，执行创建时加入该 drawable，撤销时把它从 drawableList 中去掉。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InfiniteCanvasCreateInkCommand : IInfiniteCanvasCommand
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;IDrawable&amp;gt;&lt;span&gt; _drawableList;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; InkDrawable _drawable;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; InfiniteCanvasCreateInkCommand(List&amp;lt;IDrawable&amp;gt; drawableList, IReadOnlyList&amp;lt;InkStroke&amp;gt;&lt;span&gt; strokes)
    {
        _drawable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InkDrawable(strokes);
        _drawableList &lt;/span&gt;=&lt;span&gt; drawableList;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Execute()
    {
        _drawableList.Add(_drawable);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Undo()
    {
        _drawableList.Remove(_drawable);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. InfiniteCanvasTextBox&lt;/p&gt;
&lt;p&gt;用于 InfiniteCanvas 的文本框控件，从下图的结构中可以看到完整的文本框属性定义方法，包括设置文字，设置编辑区域尺寸，文字变化的处理，光标位置的限制等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201808/306530-20180811174546150-52715363.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来看一下判断光标能够下移一行的 CannotGoDown() 方法，按照换行符来切割文字行，如果只有一行则不可下移；当前选择的结束，在最后一行时，也不可下移，其他情况都可以下移；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CannotGoDown()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lines = _editZone.Text.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lines.Count() == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lastLine = lines.ElementAt(lines.Length - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((_editZone.Text.Length - lastLine.Length) &amp;lt;= (_editZone.SelectionStart +&lt;span&gt; _editZone.SelectionLength))
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. InfiniteCanvasVirtualDrawingSurface&lt;/p&gt;
&lt;p&gt;用于渲染 Ink 和 Text 的虚拟 drawing surface，它有几个部分类组成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201808/306530-20180811180118243-1371562783.png&quot; alt=&quot;&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要的处理逻辑，是利用 Commands 来操作 Ink 和 Text 的渲染执行和撤销操作，计算渲染的尺寸空间，组织渲染的内容。&lt;/p&gt;
&lt;p&gt;4. InkDrawable 和 TextDrawable&lt;/p&gt;
&lt;p&gt;Ink 和 Text 可绘画元素的绘画逻辑，分别来看一下两个类的组成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201808/306530-20180811180910395-987903195.png&quot; alt=&quot;&quot; height=&quot;250&quot;/&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201808/306530-20180811180916901-500216093.png&quot; alt=&quot;&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看一下两个类的 Draw 方法：&lt;/p&gt;
&lt;p&gt;Draw() - InkDrawable:&lt;/p&gt;
&lt;p&gt;获得 Strokes 中每个线条的每个点，加入到集合中，从点集合创建线条，最后生成新的 Stroke 列表；遍历完成后，把新的 Stroke 列表用于 drawingSession 的 DrawInk 方法来实现绘制； &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Draw(CanvasDrawingSession drawingSession, Rect sessionBounds)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; finalStrokeList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;InkStroke&amp;gt;&lt;span&gt;(Strokes.Count);

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; stroke &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Strokes)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; points =&lt;span&gt; stroke.GetInkPoints();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; finalPointList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;InkPoint&amp;gt;&lt;span&gt;(points.Count);
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; point &lt;span&gt;in&lt;/span&gt;&lt;span&gt; points)
        {
            finalPointList.Add(MapPointToToSessionBounds(point, sessionBounds));
        }

        StrokeBuilder.SetDefaultDrawingAttributes(stroke.DrawingAttributes);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newStroke =&lt;span&gt; StrokeBuilder.CreateStrokeFromInkPoints(finalPointList, stroke.PointTransform);
        finalStrokeList.Add(newStroke);
    }

    drawingSession.DrawInk(finalStrokeList);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Draw() - TextDrawble:&lt;/p&gt;
&lt;p&gt;设置 Canvas 中文本的格式，使用文本和格式设置的 textLayout 来用于 drawingSession 的 DrawTextLayout 方法实现绘制；根据字体大小设置横向偏移 HorizontalMarginBasedOnFont，固定的纵向偏移 verticalMargin；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Draw(CanvasDrawingSession drawingSession, Rect sessionBounds)
{
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; verticalMargin = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
    CanvasTextFormat format &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CanvasTextFormat
    {
        FontSize &lt;/span&gt;=&lt;span&gt; FontSize,
        WordWrapping &lt;/span&gt;=&lt;span&gt; CanvasWordWrapping.NoWrap,
        FontWeight &lt;/span&gt;= IsBold ?&lt;span&gt; FontWeights.Bold : FontWeights.Normal,
        FontStyle &lt;/span&gt;= IsItalic ?&lt;span&gt; FontStyle.Italic : FontStyle.Normal
    };

    CanvasTextLayout textLayout &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CanvasTextLayout(drawingSession, Text, format, &lt;span&gt;0.0f&lt;/span&gt;, &lt;span&gt;0.0f&lt;/span&gt;&lt;span&gt;);

    drawingSession.DrawTextLayout(textLayout, (&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;)(Bounds.X - sessionBounds.X + HorizontalMarginBasedOnFont), (&lt;span&gt;float&lt;/span&gt;)(Bounds.Y - sessionBounds.Y +&lt;span&gt; verticalMargin), TextColor);
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5. InfiniteCanvas&lt;/p&gt;
&lt;p&gt;InfiniteCanvas 是主要逻辑处理，由 InfiniteCanvas.cs，InfiniteCanvas.Events.cs，InfiniteCanvas.TextBox.cs 三个部分类组成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其中 InfiniteCanvas.cs 这个类中主要是实现 OnApplyTemplate()，DependencyProperty 处理，控件的定义，事件注册，Canvas 的基础事件处理等，InfiniteCanvas 中实现了一个 InkCanvas 所以可以实现各种笔触的笔迹绘制；&lt;/li&gt;
&lt;li&gt;InfiniteCanvas.Events.cs 主要是 Canvas 中的各种按钮点击等事件处理；&lt;/li&gt;
&lt;li&gt;InfiniteCanvas.TextBox.cs 主要是 Canvas 中 TextBox 控件对应的控件定义和事件处理；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;调用示例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;InfiniteCanvas 控件的调用非常简单，下面看看 XAML 中的调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Page &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&lt;/span&gt;&lt;span&gt;
      xmlns:x&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&lt;/span&gt;&lt;span&gt;
      xmlns:controls&lt;/span&gt;&lt;span&gt;=&quot;using:Microsoft.Toolkit.Uwp.UI.Controls&quot;&lt;/span&gt;&lt;span&gt;
      xmlns:d&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;&lt;/span&gt;&lt;span&gt;
      xmlns:mc&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;&lt;/span&gt;&lt;span&gt;
      mc:Ignorable&lt;/span&gt;&lt;span&gt;=&quot;d&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:InfiniteCanvas &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;canvas&quot;&lt;/span&gt;&lt;span&gt; IsToolbarVisible&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到这里我们就把 Windows Community Toolkit 3.0 中的 InfiniteCanvas 的源代码实现过程讲解完成了，希望能对大家更好的理解和使用这个功能有所帮助。InfiniteCanvas 控件在绘画类场景中有非常多的应用，控件默认实现了多种笔触的绘画，橡皮，文字，redo undo 等重要功能，开发者也可以根据 InfiniteCanvas 的实现自定义 Toolbar 的样式和更多的绘画笔触，不同的笔画保存方式等。&lt;/p&gt;
&lt;p&gt;最后，再跟大家安利一下 WindowsCommunityToolkit 的官方微博：&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;https://weibo.com/u/6506046490&quot; target=&quot;_blank&quot;&gt;https://weibo.com/u/6506046490&lt;/a&gt;, &lt;/strong&gt;&lt;/em&gt;大家可以通过微博关注最新动态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;衷心感谢 WindowsCommunityToolkit 的作者们杰出的工作，感谢每一位贡献者，Thank you so much, ALL WindowsCommunityToolkit AUTHORS !!!&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 06:47:00 +0000</pubDate>
<dc:creator>shaomeng</dc:creator>
<og:description>概述 InfiniteCanvas 是一个 Canvas 控件，它支持无限画布的滚动，支持 Ink，文本，格式文本，画布缩放操作，撤销重做操作，导入和导出数据。 这是一个非常实用的控件，在“来画视频”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shaomeng/p/9281065.html</dc:identifier>
</item>
<item>
<title>10.vue框架 - 飞刀还问情</title>
<link>http://www.cnblogs.com/zhongchao666/p/9462991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhongchao666/p/9462991.html</guid>
<description>&lt;p&gt;vue框架&lt;br/&gt;易用、灵活、高效&lt;/p&gt;
&lt;p&gt;https://cn.vuejs.org/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mvc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;M model 数据 模型&lt;/p&gt;
&lt;p&gt;V view 视图 dom操作&lt;/p&gt;
&lt;p&gt;C controller 控制器 路由&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;oBtn.onclick = function(){
        $.ajax(...
        
            success:function(data){//data M
            
                    //DOM操作  V
                
            }
        );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;mvc mvvm mvp mv*&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;指令&quot;&gt;指令&lt;/h4&gt;
&lt;p&gt;v-开头的自定义属性&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;v-model 数据&lt;br/&gt;v-text 纯文本 简写 {{数据}}&lt;br/&gt;v-html 会转义html标签&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;exp：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;无标题文档&amp;lt;/title&amp;gt;
&amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;

window.onload = function(){
    var vm = new Vue({
        el:&quot;#div1&quot;, //选择器
        data:{
            a:&quot;abc&quot; //定义
        }
    });
};

&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;div1&quot;&amp;gt;
    &amp;lt;input v-model=&quot;a&quot; type=&quot;text&quot; value=&quot;&quot;/&amp;gt;&amp;lt;br /&amp;gt;
    &amp;lt;span v-text=&quot;a&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;br /&amp;gt;
     &amp;lt;span v-html=&quot;a&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;br /&amp;gt;
    {{a}}
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;v-text区别&quot;&gt;v-text/{{}}区别&lt;/h6&gt;
&lt;p&gt;{{}} 如果使用过程中出现错误，会显示花括号， v-text不会显&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;想要不想显示{{}}&lt;br/&gt;1、把所有的{{}}——&amp;gt; v-text 不推荐&lt;br/&gt;2、v-cloak 需要和样式进行配合&lt;br/&gt;外层div设置[v-cloak]{display:none;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网络延迟的问题也会显示 {{}}&lt;/p&gt;
&lt;p&gt;如果在使用vue的过程中没有出现错误，vue会把v-cloak给删除&lt;/p&gt;
&lt;p&gt;推荐用花括号 {{xxx}}&lt;/p&gt;
&lt;hr/&gt;&lt;h5 id=&quot;v-bind-操纵属性&quot;&gt;v-bind 操纵属性&lt;/h5&gt;
&lt;h6 id=&quot;注意-el不能选择body或者html&quot;&gt;注意： el不能选择body或者html&lt;/h6&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;v-bind:&lt;br/&gt;属性名称=&quot;值&quot; 简写 :属性名称=&quot;值&quot;&lt;br/&gt;跟对象:v-bind=&quot;对象&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;data:{
    a:&quot;width:200px; heigth:200px;background:red&quot;
}

v-bind:style=&quot;a&quot;
v-bind:style=&quot;'width:200px; heigth:200px;background:red'&quot;

json

v-bind:style=&quot;{width:'200px', heigth:'200px',;background:'red'}&quot;


数组

data:{
    width:{width:&quot;200px&quot;},
    heigth:{heigth:&quot;200px&quot;},
    background:{background:&quot;200px&quot;},
}
v-bind:style=&quot;[width,height,background]&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;class&quot;&gt;class&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;data:{
    a:&quot;box1 box2 box3&quot;
}

v-bind:class=&quot;a&quot;
v-bind:class=&quot;'box1 box2 box3'&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;json-必须跟布尔值&quot;&gt;json: 必须跟布尔值&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;data:{
    box1:true,
    box2:false,
    box3:&quot;dsafsa&quot;
}
v-bind:class=&quot;{box1:box1,box2:box2,box3:box3}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;数组元素是变量名&quot;&gt;数组,元素是变量名&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;data:{
    box1:&quot;box1&quot;,
    box2:&quot;box2&quot;,
    box3:&quot;abc&quot;
}
v-bind:class=&quot;[box1,box2,box3]&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;方法&quot;&gt;方法：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;methods:{
        方法名(){
        
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;事件&quot;&gt;事件：&lt;/h4&gt;
&lt;p&gt;v-on:click=&quot;方法名&quot; 简写 @click=&quot;方法名&quot;&lt;/p&gt;
&lt;h6 id=&quot;显示隐藏&quot;&gt;显示隐藏:&lt;/h6&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;v-show: 控制的是style:none/block&lt;br/&gt;v-if: 控制的真实dom节点的创建和删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h6 id=&quot;v-if-条件判断&quot;&gt;v-if 条件判断&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;v-if&lt;br/&gt;v-else-if&lt;br/&gt;v-else&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;exp:&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;无标题文档&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
#div1{width:200px; height:200px; background:#ccc;}
&amp;lt;/style&amp;gt;
&amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;span v-if=&quot;a==1&quot;&amp;gt;1&amp;lt;/span&amp;gt;
    &amp;lt;span v-else-if=&quot;a==2&quot;&amp;gt;2&amp;lt;/span&amp;gt;
    &amp;lt;span v-else&amp;gt;其他&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
var vm = new Vue({
    el:&quot;#app&quot;,
    data:{
        a:1
    }   
});
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;p&gt;循环：v-for/v-of&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;数组&quot;&gt;数组&lt;/h6&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;v-for=&quot;item in arr&quot;&lt;br/&gt;v-for=&quot;(v,k) in arr&quot;&lt;br/&gt;v-for=&quot;v,k in arr&quot;&lt;br/&gt;&lt;em&gt;exp:&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;无标题文档&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
#div1{width:200px; height:200px; background:#ccc;}
&amp;lt;/style&amp;gt;
&amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
/*
for in
for of
*/
window.onload = function(){
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            arr:[&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]
        }
    });
}; 

&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li v-for=&quot;item in arr&quot;&amp;gt;{{item}}&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li v-for=&quot;item of arr&quot;&amp;gt;{{item}}&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;res:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12200279-f7d259606ea6d66a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;对象&quot;&gt;对象&lt;/h6&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;v-for=&quot;item in json&quot;&lt;br/&gt;v-for=&quot;(v,k,i) in json&quot;&lt;br/&gt;v-for=&quot;v,k,i in json&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;exp:&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;无标题文档&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
#div1{width:200px; height:200px; background:#ccc;}
&amp;lt;/style&amp;gt;
&amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
/*
for in
for of
*/
window.onload = function(){
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{
            json:{
                name:&quot;翠花&quot;,
                age:18,
                sex:0   
            }
        }
    });
}; 

&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li v-for=&quot;item in json&quot;&amp;gt;{{item}}&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li v-for=&quot;v,k,i of json&quot;&amp;gt;{{v}}----{{k}}----{{i}}&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
     
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;res:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12200279-538fc5a6c0b3988d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h6 id=&quot;数据更新&quot;&gt;数据更新&lt;/h6&gt;
&lt;p&gt;数组&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;arr.push/pop/shift/unshift/splice....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接操纵索引 无效 vm.arr[index] = xxxx;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;vm.$set(vm.arr/json,index/key,value);&lt;br/&gt;Vue.set(vm.arr/json,index/key,value);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;vm.arr[index] = xxxx; 无效&lt;br/&gt;强制更新:&lt;br/&gt;vm.$forceUpdate();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对象&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;必须先定义 再修改！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h5 id=&quot;事件对象&quot;&gt;事件对象&lt;/h5&gt;
&lt;p&gt;@click=&quot;函数名&quot; 事件函数的第一个参数就是事件对象ev&lt;br/&gt;@click=&quot;函数名($event)&quot; 在函数里面可以直接使用ev&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;exp:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;无标题文档&amp;lt;/title&amp;gt;
&amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
window.onload = function(){
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{},
        methods:{
            show(ev){
                alert(ev.clientX);  
            }   
        }
        
    });
};
&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;input @click=&quot;show($event)&quot; type=&quot;button&quot; value=&quot;按钮&quot; /&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;原生&quot;&gt;原生&lt;/h5&gt;
&lt;p&gt;onclick=&quot;show(event)&quot;&lt;/p&gt;
&lt;hr/&gt;&lt;h5 id=&quot;冒泡&quot;&gt;冒泡：&lt;/h5&gt;
&lt;p&gt;子元素的事件可以传播到父元素上，最终传播到document&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var oEvent = ev || event;
oEvent.cancelBubble = true;
oEvent.stopPropagation();&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;vue阻止事件冒泡&quot;&gt;vue阻止事件冒泡:&lt;/h6&gt;
&lt;p&gt;@click.stop=&quot;btn&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;无标题文档&amp;lt;/title&amp;gt;
&amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
window.onload = function(){
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{},
        methods:{
            div(){
                alert(&quot;div&quot;);   
            },
            btn(){
                //var oEvent = ev || event;
                //oEvent.cancelBubble = true;
                //oEvent.stopPropagation();
                alert(&quot;btn&quot;);
            }   
        }   
    }); 
};
&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;div id=&quot;div1&quot; @click=&quot;div&quot; &amp;gt;
        div1
        &amp;lt;input @click.stop=&quot;btn&quot; type=&quot;button&quot; value=&quot;按钮&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;默认事件&quot;&gt;默认事件&lt;/h5&gt;
&lt;p&gt;浏览器自带的行为就是默认事件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;原生:
ev.preventDefault();
//return false;

vue:
(原生和.prevent都可以)
@click.prevent=&quot;show&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;vue阻止默认事件&quot;&gt;vue阻止默认事件:&lt;/h6&gt;
&lt;p&gt;@click.prevent=&quot;show&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;无标题文档&amp;lt;/title&amp;gt;
&amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
window.onload = function(){
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{},
        methods:{
            show(ev){
                alert(1);
                //ev.preventDefault();
                //return false;
            } 
        }   
    }); 
};
&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
&amp;lt;!--vue阻止默认事件--&amp;gt;
    &amp;lt;a @click.prevent=&quot;show&quot; href=&quot;http://www.baidu.com/&quot;&amp;gt;百度&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;事件修饰符&quot;&gt;事件修饰符：&lt;/h5&gt;
&lt;p&gt;https://cn.vuejs.org/v2/guide/events.html&lt;/p&gt;
&lt;p&gt;&lt;em&gt;exp:&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;无标题文档&amp;lt;/title&amp;gt;
&amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
Vue.config.keyCodes.enter = 37;将将回车设成37
window.onload = function(){
    var vm = new Vue({
        el:&quot;#app&quot;,
        data:{},
        methods:{
            left(){
                 alert(&quot;left&quot;);
            },
            right(){
                 alert(&quot;right&quot;);
            } 
        }   
    }); 
};
&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
     &amp;lt;!--
     @click.left鼠标左键,
     @click.right鼠标右键,
     @click.right.prevent阻止右键默认事件
     --&amp;gt;
    &amp;lt;input @click.left=&quot;left&quot; type=&quot;button&quot; value=&quot;left&quot; /&amp;gt;
    &amp;lt;input @click.right.prevent=&quot;right&quot; type=&quot;button&quot; value=&quot;right&quot; /&amp;gt;
   
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h5 id=&quot;模板template&quot;&gt;模板：template&lt;/h5&gt;
&lt;p&gt;==模板里面只能有一个根节点，不能有兄弟节点==&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new Vue({
    template:&quot; 选择器&quot;、oTmp
});

&amp;lt;div id=&quot;tmp&quot; style=&quot;display:none&quot;&amp;gt;
    模板内容
&amp;lt;/div&amp;gt;

&amp;lt;template id=&quot;tmp&quot; &amp;gt;
    模板内容
&amp;lt;/template&amp;gt;



type=&quot;text/x-template&quot; 
type=&quot;x-template&quot; 

&amp;lt;script id=&quot;tmp&quot; type=&quot;text/x-template&quot; &amp;gt;
    模板内容
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h5 id=&quot;生命周期-createdmountedupdateddestroyed&quot;&gt;生命周期 【created/mounted】/updated/destroyed&lt;/h5&gt;
&lt;p&gt;https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA&lt;/p&gt;
&lt;p&gt;8 个函数&lt;/p&gt;
&lt;h6 id=&quot;初始化&quot;&gt;1、初始化&lt;/h6&gt;
&lt;p&gt;vm.beforeCreate 没有 $el/$data&lt;br/&gt;vm.created 没有 $el 有 $data&lt;/p&gt;
&lt;h6 id=&quot;挂载&quot;&gt;2、挂载&lt;/h6&gt;
&lt;p&gt;vm.beforeMount 有 $el 原始dom 有 $data&lt;br/&gt;vm.mounted 有 $el 虚拟dom 有 $data&lt;/p&gt;
&lt;h6 id=&quot;数据更新-1&quot;&gt;3、数据更新&lt;/h6&gt;
&lt;p&gt;vm.beforeUpdate&lt;br/&gt;vm.updated&lt;/p&gt;
&lt;h6 id=&quot;销毁&quot;&gt;4、销毁&lt;/h6&gt;
&lt;p&gt;vm.beforeDestroy&lt;br/&gt;vm.destroyed&lt;/p&gt;
&lt;h4 id=&quot;生命周期图示&quot;&gt;生命周期图示&lt;/h4&gt;
&lt;p&gt;下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12200279-ea3f74e1addcf414.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;exp:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;无标题文档&amp;lt;/title&amp;gt;
&amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
     
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
var vm = new Vue({
    //el:&quot;#app&quot;,
    data:{a:12,b:5},
    template:`&amp;lt;span&amp;gt; {{a}}---{{b}}&amp;lt;/span&amp;gt;`,
    beforeCreate(){// undefined   undefined
        console.log(&quot;beforeCreate&quot;,this.$el,this.$data);    
    },
    created(){//undefined {数据}
        console.log(&quot;created&quot;,this.$el,this.$data); 
    },
    beforeMount(){ //原始dom  {数据}  
        console.log(&quot;beforeMount&quot;,this.$el,this.$data); 
    },
    mounted(){//虚拟dom {数据} 
        console.log(&quot;mounted&quot;,this.$el,this.$data); 
    },
    //vm.a = xxxx;
    beforeUpdate(){
        console.log(&quot;beforeUpdate&quot;);    
    },
    updated(){
        console.log(&quot;updated&quot;); 
    },
    ////vm.$destroy();
    beforeDestroy(){
        console.log(&quot;beforeDestroy&quot;);   
    },
    destroyed(){
        console.log(&quot;destroyed&quot;);   
    },

});

vm.$mount(&quot;#app&quot;);
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 12 Aug 2018 06:41:00 +0000</pubDate>
<dc:creator>飞刀还问情</dc:creator>
<og:description>vue框架 易用、灵活、高效 https://cn.vuejs.org/ mvc M model 数据 模型 V view 视图 dom操作 C controller 控制器 路由 C mvc mvv</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhongchao666/p/9462991.html</dc:identifier>
</item>
<item>
<title>HBase查询优化之Short-Circuit Local Reads - 哥不是小萝莉</title>
<link>http://www.cnblogs.com/smartloli/p/9462835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartloli/p/9462835.html</guid>
<description>&lt;p&gt;在《&lt;a id=&quot;homepage1_HomePageDays_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/smartloli/p/9425343.html&quot;&gt;HBase查询优化&lt;/a&gt;》一文中，介绍了基于HBase层面的读取优化。由于HBase的实际数据是以HFile的形式，存储在HDFS上。那么，HDFS层面也有它自己的优化点，即：Short-Circuit Local Reads。本篇博客笔者将从HDFS层面来进行优化，从而间接的提升HBase的查询性能。&lt;a id=&quot;homepage1_HomePageDays_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/smartloli/p/9425343.html&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hadoop系统在设计之初，遵循一个原则，那就是移动计算的代价比移动数据要小。故Hadoop在做计算的时候，通常是在本地节点上的数据中进行计算。即计算和数据本地化。流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201808/666745-20180812121602028-746569334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在最开始的时候，短回路本地化读取和跨节点的读取的处理方式是一样的，流程都是先从DataNode读取数据，然后通过RPC服务把数据传输给DFSClient，这样处理虽然流程比较简单，但是读取性能会受到影响，因为跨节点读取数据，需要经过网络将一个DataNode的数据传输到另外一个DataNode节点（一般来说，HDFS有3个副本，所以，本地取不到数据，会到其他DataNode节点去取数据）。&lt;/p&gt;
&lt;h2&gt; 2.1 方案一：客户端直接读取DataNode文件&lt;/h2&gt;
&lt;p&gt;短回路本地化读取的核心思想是，由于客户端和数据在同一个节点上，所以DataNode不需要在数据路径中。相反，客户端本身可以简单地读取来自本地磁盘的数据。这种性能优化集成在CDH的Hadoop相关项目中，实现如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201808/666745-20180812122258855-991357695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种短回路本地化读取的思路虽然很好，但是配置问题比较麻烦。系统管理员必须更改DataNode数据目录的权限，以便客户端有权限能够打开相关文件。这样就不得不专门为那些能够使用短回路本地化读取的用户提供白名单，不允许其他用户使用。通常，这些用也必须被放置在一个特殊的UNIX组中。&lt;/p&gt;
&lt;p&gt;另外，这种本地化短回路读取的思路还存在另外一个安全问题，客户端在读取DataNode数据目录时打开了一些权限，这样意味着，拥有这个目录的权限，那么其目录下的子目录中的数据也可以被访问，比如HBase用户。由于存在这种安全风险，所以这个实现思路已经不建议使用了。&lt;/p&gt;
&lt;h2&gt;2.2 短回路本地化安全读取&lt;/h2&gt;
&lt;p&gt;为了解决上述问题，在实际读取中需要非常小心的选择文件。在UNIX中有这样一种机制，叫做“文件描述符传递”。使用这种机制来实现安全的短回路本地读取，而不是通过目录名称的客户端，DataNode打开Block文件和元数据文件，将它们直接给客户端。因为文件描述符是只读的，用户不能修改文件。由于它没有进入Block目录本身，它无法读取任何不应该访问的目录。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;现有两个用户hbase1和hbase2，hbase1拥有访问HDFS目录上/appdata/hbase1文件的权限，而hbase2用户没有改权限，但是hbase2用户又需要访问这个文件，那么可以借助这种“文件描述符传递”的机制，可以让hbase1用户打开文件得到一个文件描述符，然后把文件描述符传递给hbase2用户，那么hbase2用户就可以读取文件里面的内容了，即使hbase2用户没有权限。这种关系映射到HDFS中，可以把DataNode看作hbase1用户，客户端DFSClient看作hbase2用户，需要读取的文件就是DataNode目录中的/appdata/hbase1文件。实现如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201808/666745-20180812130631594-623601309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.3 缓存文件描述&lt;/h2&gt;
&lt;p&gt;HDFS客户端可能会有经常读取相同Block文件的场景，为了提升这种读取性能，旧的短回路本地读取实现具有Block路径的高速缓存。该缓存允许客户端重新打开其最近已读取的Block文件，而不需要再去访问DataNode路径读取。&lt;/p&gt;
&lt;p&gt;新的短回路本地读取实现不是一个路径缓存，而是一个名为FileInputStreamCache的文件描述符缓存。这样比路径缓存要更好一些，因为它不需要客户端重新打开文件来重新读取Block，这种读取方式比就的短回路本地读取方式在读性能上有更好的表现。&lt;/p&gt;
&lt;p&gt;缓存的大小可以通过dfs.client.read.shortcircuit.streams.cache.size属性来进行调整，默认是256，缓存超时可以通过dfs.client.read.shortcircuit.streams.cache.expiry.ms属性来进行控制，默认是300000，也可以将其设置为0来将其进行关闭，这两个属性均在hdfs-site.xml文件中可以配置。&lt;/p&gt;
&lt;h2&gt;2.4 如何配置&lt;/h2&gt;
&lt;p&gt;为了配置短回路本地化读取，需要启用libhadoop.so，一般来说所使用Hadoop通常都是包含这些包的，可以通过以下命令来检测是否有安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 $ hadoop checknative -&lt;span&gt;a&lt;/span&gt;&lt;span&gt;
   Native library checking:
   hadoop: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; /home/ozawa/hadoop/lib/native/libhadoop.so.&lt;span&gt;1.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   zlib:   &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; /lib/x86_64-linux-gnu/libz.so.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
   snappy: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; /usr/lib/libsnappy.so.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
   lz4:    &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; revision:&lt;span&gt;99&lt;/span&gt;
   &lt;span&gt;bzip2&lt;/span&gt;:  &lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;短回路本地化读取利用UNIX的域套接字（UNIX domain socket），它在文件系统中有一个特定的路径，允许客户端和DataNode进行通信。在使用的时候需要设置这个路径到Socket中，同时DataNode需要能够创建这个路径。另外，这个路径应该不可能被除了hdfs用户或root用户之外的任何用户创建。因此，在实际创建时，通常会使用/var/run或者/var/lib路径。&lt;/p&gt;
&lt;p&gt;短回路本地化读取在DataNode和客户端都需要配置，配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.client.read.shortcircuit&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/value&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.domain.socket.path&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;/var/lib/hadoop-hdfs/dn_socket&amp;lt;/value&amp;gt;
  &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，配置dfs.client.read.shortcircuit属性是打开这个功能的开关，dfs.domain.socket.path属性是DataNode和客户端之间进行通信的Socket路径地址，核心指标配置参数如下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr&gt;&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;dfs.client.read.shortcircuit&lt;/td&gt;
&lt;td&gt;打开短回路本地化读取，默认false&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;dfs.client.read.shortcircuit.skip.checksum&lt;/td&gt;
&lt;td&gt;如果配置这个参数，短回路本地化读取将会跳过checksum，默认false&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;dfs.client.read.shortcircuit.streams.cache.size&lt;/td&gt;
&lt;td&gt;客户端维护一个最近打开文件的描述符缓存，默认256&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dfs.domain.socket.path&lt;/td&gt;
&lt;td&gt;DataNode和客户端DFSClient通信的Socket地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;dfs.client.read.shortcircuit.streams.cache.expiry.ms&lt;/td&gt;
&lt;td&gt;设置超时时间，用来设置文件描述符可以被放进FileInputStreamCache的最小时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;dfs.client.domain.socket.data.traffic&lt;/td&gt;
&lt;td&gt;通过UNIX域套接字传输正常的数据流量，默认false&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;短回路本地化读取能够从HDFS层面来提升读取性能，如果HBase场景中，有涉及到读多写少的场景，在除了从HBase服务端和客户端层面优化外，还可以尝试从HDFS层面来进行优化。&lt;/p&gt;

&lt;p&gt;这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！&lt;/p&gt;
&lt;p&gt;另外，博主出书了《Hadoop大数据挖掘从入门到进阶实战》，喜欢的朋友或同学， 可以在公告栏那里点击购买链接购买博主的书进行学习，在此感谢大家的支持。&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 05:45:00 +0000</pubDate>
<dc:creator>哥不是小萝莉</dc:creator>
<og:description>1.概述 在《HBase查询优化》一文中，介绍了基于HBase层面的读取优化。由于HBase的实际数据是以HFile的形式，存储在HDFS上。那么，HDFS层面也有它自己的优化点，即：Short-Ci</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smartloli/p/9462835.html</dc:identifier>
</item>
<item>
<title>MATLAB安装libsvm工具箱的方法 - 东聃</title>
<link>http://www.cnblogs.com/Ran-Chen/p/9462825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ran-Chen/p/9462825.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;支持向量机（support vector machine，SVM）是机器学习中一种流行的学习算法，在分类与回归分析中发挥着重要作用。基于SVM算法开发的工具箱有很多种，下面我们要安装的是十分受欢迎的libsvm工具箱。&lt;/p&gt;
&lt;h2 id=&quot;libsvm简介&quot;&gt;libsvm简介&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;LIBSVM 是台湾大学林智仁(Lin Chih-Jen)副教授等开发设计的一个简单、易于使用和快速有效的 SVM 模式识别与回归的软件包，它不仅提供了编译好的可在 Windows 系列系统的执行文件，还提供了源代码，方便改进、修改以及在其它操作系统上应用； 该软件还有一个特点，就是对 SVM 所涉及的参数调节相对比较少，提供了很多的默认参数，利用这些默认参数就可以解决很多问题；并且提供了交互检验(Cross-SVM回归等问题，包括基于一对一算法的多类模式识别问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;libsvm与matlab自带的svm工具箱的区别&quot;&gt;libsvm与MATLAB自带的svm工具箱的区别&lt;/h2&gt;
&lt;p&gt;在MATLAB中，同样自带了一个svm工具箱，不过相比于libsvm，在功能性和易用性方面有一些差距。具体差别表现在：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MATLAB自带的svm实现函数仅支持分类问题，不支持回归问题；而libsvm不仅支持分类问题，亦支持回归问题&lt;/li&gt;
&lt;li&gt;MATLAB自带的svm实现函数仅支持二分类问题，多分类问题需按照&lt;strong&gt;多分类的相应算法&lt;/strong&gt;编程实现；而libsvm采用&lt;strong&gt;一对一方法&lt;/strong&gt;支持多分类&lt;/li&gt;
&lt;li&gt;MATLAB自带的svm工具箱无法改变高斯核函数中的参数，而libsvm可以&lt;/li&gt;
&lt;li&gt;MATLAB自带的svm工具箱也有一些优点，比如在解决二次规划问题时，可选三种方法（经典二次方法；SMO；最小二乘），而libsvm只能是SMO。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常见的扩展为多分类的方法有：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;一对一（one-versus-one）方法&lt;/strong&gt;，训练时对于任意两类样本都会训练一个二分类器，最终得到k(k-1)/2个二分类器，共同组成k分类器。对未知样本分类时，使用所有的k(k-1)/2个分类器进行分类，将出现最多的那个类别作为该样本最终的分类结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;一对多（one-versus-rest）方法&lt;/strong&gt;：训练时依次把k类样本中的某个类别归为一类，其它剩下的归为另一类，使用二分类的SVM训练处一个二分类器，最后把得到的k个二分类器组成k分类器。对未知样本分类时，分别用这k个二分类器进行分类，将分类结果中出现最多的那个类别作为最终的分类结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;libsvm的下载&quot;&gt;libsvm的下载&lt;/h2&gt;
&lt;p&gt;在libsvm的&lt;strong&gt;&lt;a href=&quot;https://www.csie.ntu.edu.tw/~cjlin/libsvm/&quot;&gt;官方主页&lt;/a&gt;&lt;/strong&gt;上可以下载libsvm的扩展包，支持MATLAB、Java、Python等多种语言，这里我们选择MATLAB版本，下载zip文件即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180812133640840-1216826177.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180812133656461-2105871065.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者直接下载我分享的文件包，&lt;a href=&quot;https://share.weiyun.com/5MYZRR5&quot;&gt;点击这里下载&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;注意&quot;&gt;注意&lt;/h4&gt;
&lt;p&gt;如果是从官方主页上下载，需要再下载一个数据集&lt;strong&gt;[heart_scale.mat]&lt;/strong&gt;，方便之后的测试，&lt;a href=&quot;https://share.weiyun.com/5LGqTGa&quot;&gt;点击这里下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果是下载我分享的文件包，里面已经包含了这个数据集.mat文件，就不需要再下载了。&lt;/p&gt;
&lt;h2 id=&quot;libsvm的安装&quot;&gt;libsvm的安装&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;\libsvm-3.23\matlab&lt;/code&gt;目录下，有一个README文件，详细说明了安装方法。&lt;/p&gt;
&lt;p&gt;如果是windows 64位系统，预编译的二进制文件已经提供，在&lt;code&gt;\libsvm-3.23\windows&lt;/code&gt;文件下，可以看到4个文件，分别是libsvmread.mexw64、libsvmwrite.mexw64、svmtrain.mexw64、svmpredict.mexw64。&lt;/p&gt;
&lt;p&gt;这样可以跳过下面第一步的编译步骤。&lt;/p&gt;
&lt;h4 id=&quot;编译&quot;&gt;1.编译&lt;/h4&gt;
&lt;p&gt;如果是win32位系统，需要自己重新编译c文件，生成MATLAB可识别的mexw32文件。编译方法在上述的README文件也有说明。&lt;/p&gt;
&lt;p&gt;将MATLAB的工作文件夹调整到&lt;code&gt;\libsvm-3.23\matlab&lt;/code&gt;目录下，在MATLAB的命令行窗口输入&amp;gt;&amp;gt; mex -setup，然后选择编译器如VS2010，最后输入指令&amp;gt;&amp;gt;make。编译完成后，当前路径下会生成对应的mexw32（32位系统）mexw64（64位系统）文件。&lt;/p&gt;
&lt;p&gt;过程如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;matlab&amp;gt;&amp;gt; mex -setup&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Would you like mex to locate installed compilers [y]/n? y&lt;br/&gt;Select a compiler:&lt;br/&gt;[1] Microsoft Visual C/C++ version 7.1 in C:\Program Files\Microsoft Visual Studio&lt;br/&gt;[0] None&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Compiler: 1&lt;br/&gt;Please verify your choices:&lt;br/&gt;Compiler: Microsoft Visual C/C++ 7.1&lt;br/&gt;Location: C:\Program Files\Microsoft Visual Studio&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Are these correct?([y]/n): y&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;matlab&amp;gt;&amp;gt; make&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;我的操作系统是win7 64位，原先安装的是MATLAB2014a和VS2015，发现并不支持libsvm工具包中提供好的mexw64文件，原因是MATLAB的版本过低。&lt;/p&gt;
&lt;p&gt;随后我考虑重新编译生成适合自己版本的mexw64文件，结果发现MATLAB2014a不支持识别VS2015,最高支持到VS2013。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180812133700994-2016460476.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以解决方法有两种，一种是给给VS降级，一种是给MATLAB升级。由于前者涉及很多.net和c++库文件，比较繁琐，所以最方便的做法是安装新版本的MATLAB，新老版本的MATLAB只要不安装在一个文件夹下，一般不会出现干扰情况。&lt;/p&gt;
&lt;p&gt;安装MATLAB2016及以上版本就可以支持以上的mexw64文件，同时也能识别更新的c/c++编译器。&lt;/p&gt;
&lt;p&gt;MATLAB 2016b的下载、安装、激活方法，可以参考&lt;a href=&quot;https://blog.csdn.net/qq_38386316/article/details/78302147&quot;&gt;这个链接&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;重命名函数&quot;&gt;2.重命名函数&lt;/h4&gt;
&lt;p&gt;在得到libsvmread.mexw64、libsvmwrite.mexw64、svmtrain.mexw64、svmpredict.mexw64这4个文件后，为了避免和svm内置的函数冲突，最好将svmtrain.mexw64、svmpredict.mexw64这两个文件重命名为libsvmtrain.mexw64、libsvmpredict.mexw64。&lt;/p&gt;
&lt;h4 id=&quot;添加到toolbox&quot;&gt;3.添加到toolbox&lt;/h4&gt;
&lt;p&gt;将libsvm-3.23文件夹放置到&lt;code&gt;\MATLAB R2016b\toolbox&lt;/code&gt;目录下；&lt;/p&gt;
&lt;p&gt;主页&amp;gt; 设置路径&amp;gt; 添加文件夹&amp;gt; 选择libsvm-3.23文件夹；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180812133705649-496255811.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加并包含子文件夹&amp;gt; 选择libsvm-3.23文件夹；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180812133710886-526828574.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主页&amp;gt; 预设&amp;gt; 常规&amp;gt; 更新工具箱缓存&amp;gt; 确定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180812133715713-1689399629.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;在MATLAB命令行窗口输入一下指令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;load heart_scale
model = libsvmtrain(heart_scale_label, heart_scale_inst, '-c 1 -g     0.07');
[predict_label, accuracy, dec_values] = libsvmpredict(heart_scale_label, heart_scale_inst, model);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若出现以下结果，说明安装正确。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180812133719783-1220421992.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更详细的关于libsvm的使用方法可以参考libsvm文件夹下的README文件或者是官方主页的说明。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
</description>
<pubDate>Sun, 12 Aug 2018 05:41:00 +0000</pubDate>
<dc:creator>东聃</dc:creator>
<og:description>支持向量机（support vector machine，SVM）是机器学习中一种流行的学习算法，在分类与回归分析中发挥着重要作用。基于SVM算法开发的工具箱有很多种，下面我们要安装的是十分受欢迎的l</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ran-Chen/p/9462825.html</dc:identifier>
</item>
<item>
<title>大前端的自动化工厂（2）—— SB Family - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9460722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9460722.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/09/5b9c83ad196b6819163432387a9fd4a8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;br/&gt;原文链接：https://bbs.huaweicloud.com/blogs/53c0c3509b7a11e89fc57ca23e93a89f&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我坦白我是标题党，SB只是&lt;code&gt;SCSS-Bourbon&lt;/code&gt;的简写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一.-sassscss&quot;&gt;一. SASS/SCSS&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SASS&lt;/code&gt;，也称为&lt;code&gt;SCSS&lt;/code&gt;，是CSS预编译语言的一种，常见的预编译语言还包括&lt;code&gt;LESS&lt;/code&gt;,&lt;code&gt;Stylus&lt;/code&gt;，除了语法风格之外它们之间没有什么太大的区别，从一种语言迁移到另一种语言只需要花半天通读一下文档就可以了。预编译语言为CSS提供了&lt;code&gt;变量定义&lt;/code&gt;,&lt;code&gt;函数定义&lt;/code&gt;,&lt;code&gt;层级嵌套&lt;/code&gt;等等一系列扩展功能，使开发者更容易编写和管理项目中的CSS代码。笔者使用的是&lt;code&gt;SCSS/SASS&lt;/code&gt;，因为相关工具库更全面一些，尽管名称偶尔会带来一些瑕疵（建议使用&lt;code&gt;SCSS&lt;/code&gt;）。&lt;code&gt;LESS&lt;/code&gt;在和&lt;code&gt;Sublime&lt;/code&gt;集成时有一些小问题，可能是版本问题，&lt;code&gt;stylus&lt;/code&gt;是新兴起的，开发生态并不完善。&lt;/p&gt;
&lt;h2 id=&quot;二.-scss-bourbon-family&quot;&gt;二. SCSS-Bourbon Family&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/09/9a6974f992f090cb9d0092b00d5f5048.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;SCSS&lt;/code&gt;最初使用&lt;code&gt;Ruby on Rails&lt;/code&gt;编写的，所以&lt;code&gt;github&lt;/code&gt;上提供的安装方式几乎都是通过&lt;code&gt;gem install&lt;/code&gt;安装的，但实际上在&lt;code&gt;npm&lt;/code&gt;仓库里也可以找到对应的项目。另一方面，&lt;code&gt;SCSS&lt;/code&gt;辅助工具库中的工具都是以&lt;code&gt;_&lt;/code&gt;开头的，也就是说定义&lt;code&gt;mixin&lt;/code&gt;的代码并不会被编译到产出的&lt;code&gt;CSS&lt;/code&gt;文件中，可以放心使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【Bourbon】&lt;/strong&gt;是笔者非常喜欢的工具包，首先它很符合&lt;code&gt;渐进式开发&lt;/code&gt;的思想，每个插件只实现一个特定的功能，同时，它的所有插件都是自己开发的（&lt;code&gt;ThoughtBot&lt;/code&gt;在收购后维护着整个Bourbon工具链），这又保证了工具的质量。&lt;/p&gt;
&lt;h3 id=&quot;bourbon函数库&quot;&gt;bourbon——函数库&lt;/h3&gt;
&lt;p&gt;♒ 通过&lt;code&gt;npm install -g bourbon&lt;/code&gt;安装.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bourbon&lt;/code&gt;已经更新至&lt;code&gt;5.1.0&lt;/code&gt;版本，官方文档对许多&lt;code&gt;mixin&lt;/code&gt;并没有提供说明，建议使用前通读一下&lt;code&gt;library&lt;/code&gt;目录里每一个独立的文件，其中的注释部分标明了该函数的用法。例如实用&lt;code&gt;triangle( )&lt;/code&gt;函数来生成一个类，使其伪类包含一个指定尺寸和方向的三角形,又或者是使用&lt;code&gt;tint( )&lt;/code&gt;或&lt;code&gt;shade( )&lt;/code&gt;方法让颜色按照半分比变亮或变暗，当然你也可以自行去扩展&lt;code&gt;bourbon&lt;/code&gt;的基础功能。&lt;/p&gt;
&lt;p&gt;SCSS代码为：&lt;/p&gt;
&lt;pre class=&quot;scss&quot;&gt;
&lt;code&gt;@import &quot;bourbon&quot;;
.triangle-down {
    &amp;amp;::after{
     content:'';   
     @include triangle(&quot;down&quot;, 2rem, 1rem, #b25c9c);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译后的代码:&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.triangle-down::after {
  content: '';
  border-style: solid;
  height: 0;
  width: 0;
  border-color: #b25c9c transparent transparent;
  border-width: 1rem 1rem 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;纯&lt;code&gt;CSS&lt;/code&gt;是可以诸如六边形等很多形状的，你完全可以在网上学习它们的实现方法，然后将其编写为扩展的&lt;code&gt;mixin&lt;/code&gt;加入到自己的常用工具箱中。&lt;/p&gt;
&lt;h3 id=&quot;bitters脚手架&quot;&gt;Bitters——脚手架&lt;/h3&gt;
&lt;p&gt;♒ 通过&lt;code&gt;npm install -g bourbon-bitters&lt;/code&gt;安装&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Bitters&lt;/code&gt;是Bourbon工具家族里的脚手架，它将你的基础样式分拆为*_bass* , *_buttons* , *_forms* , *_layout* , *_lists* , *_media* , *_tables* , *_typography* , *_variables* 等几个不同的文件并提供一些初始样式，开发中可以将与基础模块相关的样式扩展写在这些文件中，这样的做法可以在一定程度上降低项目的维护难度。&lt;/p&gt;
&lt;p&gt;当然你也可以直接引入&lt;code&gt;normolize.css&lt;/code&gt;来对项目进行样式的重置。&lt;/p&gt;
&lt;h3 id=&quot;neat网格工具&quot;&gt;Neat——网格工具&lt;/h3&gt;
&lt;p&gt;♒ 通过&lt;code&gt;npm install -g bourbon-neat&lt;/code&gt;安装.&lt;/p&gt;
&lt;p&gt;我们使用的第三方UI框架中，几乎都使用经典的12列布局，但总有些产品经理会提出希望将某一列的宽度扩展到1.5倍这种需求，或者有些场景下你希望对整个网页的布局进行更精细的控制，这个时候轻量级的网格工具&lt;code&gt;Neat&lt;/code&gt;就派上用场了，轻量，强大，易用，轻松实现&lt;strong&gt;网格划分,网格嵌套,响应式布局&lt;/strong&gt;等复杂的功能。具体的使用文档可以访问其官方网站&lt;a href=&quot;http://neat.bourbon.io/&quot;&gt;Neat官方网址&lt;/a&gt;查看文档。&lt;/p&gt;
&lt;p&gt;使用示例：&lt;/p&gt;
&lt;p&gt;下面简单的几行代码编译为CSS后，就可以实现将页面分为间距为&lt;em&gt;20px&lt;/em&gt;的10列，左侧边栏占2列，右侧内容区占8列；然后又将右侧内容区分为间距为&lt;em&gt;10px&lt;/em&gt;的6列，每个表格项占1列。&lt;/p&gt;
&lt;pre class=&quot;scss&quot;&gt;
&lt;code&gt;@import &quot;neat&quot;;
/*定义网格*/
$sidebar-layout:(
    columns: 10,
    gutter: 20px
);

$list-layout: (
    columns: 6,
    gutter: 10px
);
/*使用网格*/
.sidebar-layout{
    @include grid-container;
}
.sidebar-layout__sidebar{
    @include grid-column(2,$sidebar-layout);
}

.sidebar-layout__content{
    @include grid-column(8,$sidebar-layout);
}

.list-layout{
    @include grid-container;
    @include grid-collapse($list-layout);
}

.list-item{
    @include grid-column(1, $list-layout);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;coolor自动化配色工具&quot;&gt;Coolor——自动化配色工具&lt;/h3&gt;
&lt;p&gt;♒ 访问&lt;code&gt;http://coolor.co&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/09/febc214c4db4e19be4a52879a9a11800.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://coolor.co/&quot;&gt;Coolor.co&lt;/a&gt;其实并不是&lt;code&gt;Bourbon&lt;/code&gt;家族的成员，但你应该会喜欢它，这是一个免费的网站（移动端是收费的），在你指定一个主题色后，它会为你返回一组漂亮的包含5个颜色的配色方案，如果不满意直接一键切换就可以了，从此冒充&lt;strong&gt;设计师&lt;/strong&gt;看谁还敢拦着你~&lt;/p&gt;
&lt;h2 id=&quot;三.-css-evolution&quot;&gt;三. CSS Evolution&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/09/f94edfb59906ba87ea9db1ea0c68a89e.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着前端构建工具的兴起，&lt;code&gt;CSS&lt;/code&gt;的开发也进入了一个全新的阶段，自动化构建工具(例如&lt;code&gt;webpack&lt;/code&gt;)带来了新的开发方式，&lt;code&gt;SASS&lt;/code&gt;和&lt;code&gt;BEM&lt;/code&gt;的年代，还只能通过限制命名规则的方式来避免CSS冲突和相互覆盖。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CSS Modules&lt;/code&gt;借助构建工具实现了真正的模块化，&lt;code&gt;webpack4&lt;/code&gt;中在&lt;em&gt;css-loader&lt;/em&gt;配置项中就可以直接启用&lt;strong&gt;CSS模块化&lt;/strong&gt;功能，使用起来非常方便。其原理就是通过构建工具将文件中的&lt;strong&gt;类名&lt;/strong&gt;直接替换为&lt;strong&gt;Hash&lt;/strong&gt;来实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Styled Components&lt;/code&gt;，实际上就是炒的火热的&lt;strong&gt;CSS-In-Js&lt;/strong&gt;的一种实现。新事物总是褒贬不一的，有人说它是大势所趋，也有人说它很难用，笔者的建议是：继续观望。&lt;code&gt;Styled Components&lt;/code&gt;概念的兴起很有可能是&lt;code&gt;React&lt;/code&gt;团队的炒作行为，&lt;code&gt;JSX&lt;/code&gt;已经将&lt;code&gt;HTML&lt;/code&gt;和&lt;code&gt;JS&lt;/code&gt;代码放在一起编写，使用起来感觉还不错，如果又加上&lt;code&gt;CSS-In-JS&lt;/code&gt; , 那么相当于使用&lt;code&gt;JSX&lt;/code&gt;同时编写&lt;strong&gt;HTML+CSS+JS&lt;/strong&gt;，你说这种鼓吹没有私心谁信？以前使用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;标签把代码都写在&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;中，你们叫嚣着&quot;结构，样式，行为三者分离&quot;，现在大伙把代码分离了，你们又忽悠着大家把结构样式行为混在一起写到&lt;code&gt;JSX&lt;/code&gt;里去，细思极恐。&lt;/p&gt;
&lt;p&gt;上图只是形象地描述了&lt;code&gt;CSS&lt;/code&gt;技术的进化方向，并不代表后出现的就一定更好。如果在你的项目组里通过命名规则约定就可以避免冲突，那真的没必要为了炫技或者赶潮流就去把代码全部改成&lt;code&gt;CSS Modules&lt;/code&gt;或者 &lt;code&gt;Styled Components&lt;/code&gt;的方式。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;工具是为了让工作变得更轻松，而不是变得更复杂。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 12 Aug 2018 05:40:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>原文链接：https://bbs.huaweicloud.com/blogs/53c0c3509b7a11e89fc57ca23e93a89f 我坦白我是标题党，SB只是 的简写。 一. SASS/S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9460722.html</dc:identifier>
</item>
<item>
<title>吴恩达深度学习笔记 course3 week2 机器学习 策略(2) - Dar_Alpha</title>
<link>http://www.cnblogs.com/Dar-/p/9462622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dar-/p/9462622.html</guid>
<description>&lt;p&gt;1.Carrying out error analysis&lt;/p&gt;
&lt;p&gt;例:当我们在训练一个模型的时候,我们的准确率是90%,bayes optimized bias是0%,这个时候错误率达到了10%,那么我们如何分析是哪错了,并且快速改正,如果我们分析发现误将狗识别为猫,那我们是否又应该加入一些狗的图片,增强模型对负样本的训练?&lt;/p&gt;
&lt;p&gt;这个时候就引入了误差分析&lt;/p&gt;
&lt;p&gt;分析过程:&lt;/p&gt;
&lt;p&gt;这里吴恩达老师是取出100张被错误标记的图片,观察其中把狗标记为猫的例子,假设:有5张是狗标记为猫的例子,那么在总共的错误中,把狗标记为猫只占了5%,我们不需要耗费大量成本加入一些狗的图片,对模型就行一个重新的训练,因为这样我们最多只能把错误率降低到9.5%.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809114026179-1087291143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种错误分析可以同时评估多个影响模型性能的因素,若某因素所占的比重越大,则影响越大,越应该花费时间精力解决这个问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809114525560-1920169840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.Cleaning up Incorrectly labeled data&lt;/h3&gt;
&lt;p&gt;监督学习的过程中,可能存在着样本标签标记错误的情况(Incorrectly labeled examples),如果只是随机的,由于深度学习算法比较健壮,将不会产生什么影响,可以忽略;如果是系统的,那么会对DL 的算法造成影响.&lt;/p&gt;
&lt;p&gt;例:假设我们做一个猫的分类器,但标记的时候误将一只白狗标记为猫,如果有少数的其他的不同的狗标记为猫,可能不会产生什么影响;但也误将其他的白狗标记为猫,可能会对DL 算法造成很大影响&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809115733448-652974083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上是指的训练集的Incorrect labeled example,如果是dev/test set 又该怎么办?&lt;/p&gt;

&lt;p&gt;可以用第一节所学的error analysis,对incorrect labeled example进行一个分析,根据它所占的比重来判断是否对其进行一个手动修正.下图中它占得比重小,就算全部修改过来,也只能改正0.6%的准确率.&lt;/p&gt;
&lt;p&gt;可以不进行修改.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809134520563-663337328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dev set 的作用是用来帮助选出错误率最低的模型,如果各个算法的错误率比较接近,又存在incorrect labeled example,我们需要对其进行一个修正&lt;/p&gt;

&lt;p&gt;对于纠正dev set 上的incorrect labeled example,这儿有一些原则:&lt;/p&gt;
&lt;p&gt;test set 也应该与dev set 一样保持相同的进程,确保他们来自相同的分布,即修正dev set 的incorrect labeled example时,也要修正test set的.&lt;/p&gt;
&lt;p&gt;同时考虑算法得到的错误例子与正确例子,修正那些标签可能会导致算法会得到错误结果,不过通常不会那么做,因为如果你的分类器比较准确,那么你所得到的错误个数比正确的少的多,分析那些错误的很容易看出来哪错了,但去考虑正确的,比较难(这里不是太明白..)&lt;/p&gt;
&lt;p&gt;train 和dev/test set可以来自轻微的不同分布;之前说过不去修正train set也没太大影响,如果incorrect labeled example不是系统的话,(train set 太大修改也很耗费精力)所以修改dev /test set会与train set有轻微的不同&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809141042118-731486051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.Building your first system quickly ,then iterate&lt;/h3&gt;
&lt;p&gt; 如何建立所需要的模型,我们可以建立第一个简单的模型,然后不停的迭代优化&lt;/p&gt;
&lt;p&gt;1.设置dev/test set和metric&lt;/p&gt;
&lt;p&gt;2.初始化模型&lt;/p&gt;
&lt;p&gt;3.分析bias/vias和erro analysis来确定下一步干什么&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809164127477-1462444525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.Training and testing on different distribution&lt;/h3&gt;
&lt;p&gt;当train set 与dev/test set 分布不同时如何处理?&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;p&gt;做一个猫的分类器,假设总共有210,000样本,其中200,000来源于webpage,比较清晰,专业,   而10,000样本来源于用户,拍摄的不清晰,不专业,假设train set 的大小为200,000,dev/test set size为5000,如何分配&lt;/p&gt;
&lt;p&gt;第一种方法是将train set和dev/test set完全混合，然后在随机选择一部分作为train set，另一部分作为dev/test set。例如，混合210000例样本，然后随机选择205000例样本作为train set，2500例作为dev set，2500例作为test set。然而我们实际上是要验证用户拍下的照片,而这样分配实际webpage所占的比重仍然很大,用户图片所占的比重小,不能起到很好的验证效果.&lt;/p&gt;
&lt;p&gt;第二种方法是将200000例webpages图片和5000例用户图片组合成train set，剩下的2500例用户图片作为dev set，2500例用户图片作为test set。其关键在于dev/test set全部来自于用户。这样保证了验证集最接近实际应用场合。这种方法较为常用，而且性能表现比较好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809173118710-1191322748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.Bias and Variance with dismatched data distributions&lt;/p&gt;
&lt;p&gt;之前我们讲过关于train set与dev/test set 同分布下的bias 和varience&lt;/p&gt;
&lt;p&gt;当train set 与dev/test set不同分布的时候,varience可能来自于本就不同的分布,或者算法本身&lt;/p&gt;
&lt;p&gt;这种train set 与dev/test set分布不同的情况,我们要求得varience的方法是设立train-dev set,它的分布与train set的分布相同,但并不用于训练&lt;/p&gt;
&lt;p&gt;这样就存在如下error:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809174727242-403531071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809174937357-186353895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一般情况下，human-level error、training error、training-dev error、dev error以及test error的数值是递增的，但是也会出现dev error和test error下降的情况。&lt;strong&gt;这主要可能是因为训练样本比验证/测试样本更加复杂，难以训练。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;6.addressing data dismatch&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;处理train set 与dev /test set 分布不同的问题,有两条建议:&lt;/p&gt;
&lt;p&gt;1.人为的分析train set 和dev/test set的不同  例:一个有噪音,一个没噪音&lt;/p&gt;
&lt;p&gt;2.使train set数据与dev/test set数据更加的相似 例:人工合成噪音加入没有噪音的背景中,需要注意的是，我们不能给每段语音都增加同一段背景噪声，这样会出现对背景噪音的过拟合，效果不佳。这就是人工数据合成需要注意的地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809175635920-525663411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809191914182-771235553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7.Transfer learning&lt;/h3&gt;
&lt;p&gt;深度学习非常强大的一个功能之一就是有时候你可以将已经训练好的一部分知识(网络结构)应用到另外一个类似的模型中去,这样的学习叫深度学习.&lt;/p&gt;
&lt;p&gt;例如:我们已经训练好了一个猫的模型,那我们可以将这个模型的一部分网络结构应用到使用X光片预测疾病的模型中去.&lt;/p&gt;
&lt;p&gt;如下:我们可以将NN的前(L-1)层保持不变,更改输出层的参数w[l],b[l]不变,只改变输入X,输出Y,重新训练输出层的w[L],b[L],   当然,我们也可以在后面加几层&lt;/p&gt;
&lt;p&gt;如果样本足够多的话,我们可以只保留网络结构,重新训练所有层的参数w[l],b[l],这样模型会更加精确,样本对模型的影响大.  选择哪种方法通常由样本的数量决定&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180809203003478-908623700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如果重新训练所有的参数w[l],b[l],初始的w[l],b[l]是由之前的模型得到的,这一过程称之为pre-training&lt;/p&gt;
&lt;p&gt;不断调试,优化w[l],b[l]的过程称之为fine-tuning&lt;/p&gt;
&lt;p&gt;迁移学习之所以可以的原因是:神经网络的浅层能够检测图片的许多固有特征,如图像边缘,曲线等,使用之前已经训练好的网络可以帮助我们更快,更准确的提取X光片的特征,二者处理的都是图片，而图片处理是有相同的地方，第一个训练好的神经网络已经帮我们实现如何提取图片有用特征了。 因此，即便是即将训练的第二个神经网络样本数目少，仍然可以根据第一个神经网络结构和权重系数得到健壮性好的模型&lt;/p&gt;
&lt;p&gt;什么情况下使用Transfer learning&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180812112544497-2128717895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;8.Multi-task learning&lt;/h3&gt;
&lt;p&gt;多任务学习即利用一个神经网络同时执行多个任务,类似于将多个神经网络融合在一起,用一个神经网络实现多种任务.&lt;/p&gt;
&lt;p&gt;如:无人驾驶问题,同时检测行人,车,停车标志,交通灯,如下左图,可以表示为如下右图形式,输出层为Y,如下图&lt;/p&gt;
&lt;p&gt;与softmax regression不同的是,softmax regression 中只有一个为1,即y={0,0,1,0}&lt;sup&gt;T&lt;/sup&gt;,而multi-task learning 可以有多个标签为1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180812114036386-759519179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 多任务学习的cost function 为&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180812114356226-2036805623.png&quot; alt=&quot;&quot;/&gt;,c为任务个数&lt;/p&gt;
&lt;p&gt;其中&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180812114421882-735686133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;多任务学习(mutil-task learning)中,可以出现某个标签为空的情况.在计算cost function时,只会计算0/1标签的loss function和&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180812114747203-1352495062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多任务学习是使用单个神经网络模型来实现多个任务。&lt;/p&gt;
&lt;p&gt;实际上，也可以分别构建多个神经网络来实现。但是，如果各个任务之间是相似问题（例如都是图片类别检测），则可以使用多任务学习模型。&lt;/p&gt;
&lt;p&gt;什么时候多任务学习有用:&lt;/p&gt;
&lt;p&gt;每个任务的低层次特征差不多,例如都是图片.&lt;/p&gt;
&lt;h3&gt;每个任务的样本差不多&lt;/h3&gt;
&lt;p&gt;可以训练一个足够大的神经网络来完成所有的任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180812115228045-528545957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;9.what is end-to-end deep learning&lt;/h3&gt;
&lt;p&gt;什么是端到端深度学习?&lt;/p&gt;
&lt;p&gt;以一个语音识别为例:传统的语音识别如下:&lt;/p&gt;
&lt;p&gt;输入音频-找特征-识别音节-识别单词-生成文字&lt;/p&gt;
&lt;p&gt;端到端学习则一步到位,将所有不同阶段的数据处理系统或学习系统模块组合在一起，用一个单一的神经网络模型来实现所有的功能。&lt;/p&gt;

&lt;p&gt;如果训练样本足够大，神经网络模型足够复杂，那么end-to-end模型性能比传统机器学习分块模型更好。实际上，end-to-end让神经网络模型内部去自我训练模型特征，自我调节，增加了模型整体契合度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180812115835834-261426675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;10.whether to use end-to-end deep learning&lt;/h3&gt;
&lt;p&gt;端到端学习(end-to-end deep learning)优点:&lt;/p&gt;
&lt;p&gt;1.能让NN自己去找特征进行一个学习&lt;/p&gt;
&lt;p&gt;2.对人为设计的组件需求度更低&lt;/p&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;p&gt;1.可能需要非常多的数据&lt;/p&gt;
&lt;p&gt;2.一些人为设计的组件是很有用的,但端到端学习会将这个取消.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180812120624458-1017350461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180812121221393-1158954490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 12 Aug 2018 04:13:00 +0000</pubDate>
<dc:creator>Dar_Alpha</dc:creator>
<og:description>1.Carrying out error analysis 例:当我们在训练一个模型的时候,我们的准确率是90%,bayes optimized bias是0%,这个时候错误率达到了10%,那么我们如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dar-/p/9462622.html</dc:identifier>
</item>
<item>
<title>有限域(2)——理想和商环 - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/9438343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/9438343.html</guid>
<description>&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　http://www.cnblogs.com/Colin-Cai/p/9438343.html 

　　作者：窗户

　　QQ：6679072

　　E-mail：6679072@qq.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们上一节介绍了环(ring)、域(field)的概念，并给了一些环、域的实例。比如我们知道整数环、方阵环、有理数域、实数域等。我们知道，域是环的一个种。最后，我们讲了素域，并讲了有限素域的构造。&lt;/p&gt;
&lt;p&gt;　　接着上一节所讲，我们继续。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;子环&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　环的一个非空子集，如果在加法和乘法上依然是个环，那么就称这个环是原来的环的子环。&lt;/p&gt;

&lt;p&gt;　　我们依旧举几个例子，比如：&lt;/p&gt;
&lt;p&gt;　　对于有理数域（当然也是一个环），整数环就是它的一个子环；&lt;/p&gt;
&lt;p&gt;　　对于整数环，所有偶数依然在加法、乘法下构成一个环（因为任何两个偶数通过加、减、乘得到的还是偶数，对于加、减、乘是封闭的，所以依然是一个环），这个偶数环是整数环的一个子环；&lt;/p&gt;
&lt;p&gt;　　对于n阶实数矩阵环，其所有的非对角线上的值全为0的n阶矩阵在矩阵加法、矩阵乘法上也构成了原矩阵环的一个子环，很明显，对于a、b两个矩阵，如果非对角线上为0，那么无论加法、减法还是乘法，得到的结果非对角线上都为0。&lt;/p&gt;


&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;理想&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　理想(ideal)是一种特殊的子环，在子环的基础上，理想还要满足如下条件：&lt;/p&gt;
&lt;p&gt;　　如果B是A的一个理想，那么对于任何a∈A，b∈B，有ab∈B且ba∈B。&lt;/p&gt;
&lt;p&gt;　　其中ab和ba是a,b顺序不同的乘法结果（&lt;span&gt;乘法未必可以交换&lt;/span&gt;）。&lt;/p&gt;

&lt;p&gt;　　理想要满足ab∈B和ba∈B。&lt;/p&gt;
&lt;p&gt;　　另外引申两个概念：如果满足ab∈B，叫&lt;span&gt;左理想&lt;/span&gt;；如果满足ba∈B，叫&lt;span&gt;右理想&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　很明显，每个环至少有两个理想：一个理想是单个0元所组成的环，因为任何一个元与0元的乘都为0元；另一个是这个环本身。&lt;/p&gt;
&lt;p&gt;　　既然这两个理想对于每个环都有，不具有什么研究意义，我们称之为平凡理想。&lt;/p&gt;
&lt;p&gt;　　只有非平凡的理想对于我们才有研究意义。&lt;/p&gt;

&lt;p&gt;　　我们还是先以整数环举例，对于整数环，显然，所有偶数组成的子环是一个理想，因为任何整数和偶数的乘积还是偶数。&lt;/p&gt;

&lt;p&gt;　　我们再去思考实数上的n阶矩阵环有没有非平凡理想：&lt;/p&gt;
&lt;p&gt;　　实际上，假如该矩阵环中有一个理想，这个理想中存在一个秩为m(0&amp;lt;m&amp;lt;n)的方阵M，按照线性代数知识，存在X和Y两个满秩方阵，使得&lt;/p&gt;
&lt;p&gt;　　XMY =   I&lt;sub&gt;m     &lt;/sub&gt;       0&lt;sub&gt;mx(n-m)&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;                     0&lt;sub&gt;(n-m)xm&lt;/sub&gt;  0&lt;sub&gt;(n-m)x(n-m)&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;       I&lt;sub&gt;1&lt;/sub&gt;  0     *    I&lt;sub&gt;m&lt;/sub&gt; 0    =   I&lt;sub&gt;1&lt;/sub&gt;  0 &lt;/p&gt;
&lt;p&gt;       0   0          0  0         0   0&lt;/p&gt;
&lt;p&gt;　　这里的I是&lt;span&gt;单位方阵&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;       有了这个方阵，则可以通过行变换、列变换变换到任何只有一个元素不为0的方阵，&lt;/p&gt;
&lt;p&gt;　　再通过加法，可以得到所有的n阶方阵。&lt;/p&gt;
&lt;p&gt;　　从而该理想其实包含该环中所有方阵。&lt;/p&gt;
&lt;p&gt;　　于是实数域上的矩阵环是不存在非平凡理想的。不存在非平凡理想的环叫&lt;span&gt;单环&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　其实实数域矩阵环是存在非平凡的左理想和右理想的：&lt;/p&gt;
&lt;p&gt;　　比如第一行之外其他行全为0的方阵构成一个左理想，第一列之外其他行全为0的方阵构成一个右理想。&lt;/p&gt;
&lt;p&gt;　　甚至，我们可以深入研究下去，从而可以搞清楚实数域矩阵环的所有的非平凡左理想和非平凡右理想，这里并不展开此问题。&lt;/p&gt;

&lt;p&gt;　　再来看看域的理想：&lt;/p&gt;
&lt;p&gt;　　对于任何一个域，因为域除了0元外，其他元在乘法上构成一个群，所以域的理想如果包含了任何一个非0元，那么必然扩充到整个域。从而，域没有平凡理想，所以也是单环。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;生成元&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　抽象代数里，我们很多时候研究方法都是采用生成元的方法。&lt;/p&gt;
&lt;p&gt;　　在这里，我们研究环的理想的方法也是采用生成元，上面的分析中其实已经蕴含了这样的思想。&lt;/p&gt;
&lt;p&gt;　　我们说一个理想是用某几个元生成的（也就是说这几个元是该理想的生成元），意思是指包含了这几个元的最小理想。&lt;/p&gt;

&lt;p&gt;　　我们之前提到所有偶数构成的环是整数环的理想，其实也可以看作是以2或-2为生成元的生成理想。&lt;/p&gt;
&lt;p&gt;　　同理、以3、4、5、6.....各自为生成元，都可以产生整数环的一个非平凡理想。其实，利用数论里的知识也可以证明，整数环的任何非平凡理想都可以用一个元生成。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;商环&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　有了环的理想，我们可以构造一个神奇的东西——商环。&lt;/p&gt;

&lt;p&gt;　　我们先定义一下&lt;span&gt;分划&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　A的一个分划是指A的一个非空子集的集合，并且满足A上所有元素有且只在其中一个非空子集上。&lt;/p&gt;
&lt;p&gt;　　比如{1,2,3,4}分划有：&lt;/p&gt;
&lt;p&gt;　　{{1,2},{3,4}}，&lt;/p&gt;
&lt;p&gt;　　{{1},{2},{3},{4}}，&lt;/p&gt;
&lt;p&gt;　　{{1},{2,3,4}}...&lt;/p&gt;
&lt;p&gt;　　也就是把一个集合“分成任意块”，分划内的任意一个元素（原集的一个非空子集),我们称之为&lt;span&gt;类&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　我们这样定义环R对于理想I的商环Q：&lt;/p&gt;
&lt;p&gt;　　商环Q是R的一个&lt;span&gt;分划&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;　　R里任何两个元x和y，在Q的同一个&lt;span&gt;类&lt;/span&gt;里的充要条件是x-y∈I；&lt;/p&gt;
&lt;p&gt;　　商环上定义的加法为：商环里的两个类A和B，A+B的结果是A上的一个元素a和B上的一个元素b做加法得的a+b所在的类；&lt;/p&gt;
&lt;p&gt;　　商环上定义的乘法为：商环里的两个类A和B，A+B的结果是A上的一个元素a和B上的一个元素b做乘法所得的ab所在的类。&lt;/p&gt;

&lt;p&gt;　　我们来证明以上加法、乘法定义是合理的，换句话说，加法、乘法的唯一性，用数学语言来说如下：&lt;/p&gt;
&lt;p&gt;　　对于任意Q内的A和B，对于任意a&lt;sub&gt;1&lt;/sub&gt;,a&lt;sub&gt;2&lt;/sub&gt;∈A, b&lt;sub&gt;1&lt;/sub&gt;,b&lt;sub&gt;2&lt;/sub&gt;∈B,存在一个Q内的C和D，使得&lt;/p&gt;
&lt;p&gt;　　a&lt;sub&gt;1&lt;/sub&gt;+b&lt;sub&gt;1&lt;/sub&gt;∈C,&lt;/p&gt;
&lt;p&gt;　　a&lt;sub&gt;2&lt;/sub&gt;+b&lt;sub&gt;2&lt;/sub&gt;∈C,&lt;/p&gt;
&lt;p&gt;　　a&lt;sub&gt;1&lt;/sub&gt;b&lt;sub&gt;1&lt;/sub&gt;∈C,&lt;/p&gt;
&lt;p&gt;　　a&lt;sub&gt;2&lt;/sub&gt;b&lt;sub&gt;2&lt;/sub&gt;∈C.&lt;/p&gt;
&lt;p&gt;　　稍微转换一下，就是&lt;/p&gt;
&lt;p&gt;　　a&lt;sub&gt;1&lt;/sub&gt;-a&lt;sub&gt;2&lt;/sub&gt;∈I /\ b&lt;sub&gt;1&lt;/sub&gt;-b&lt;sub&gt;2&lt;/sub&gt;∈I -&amp;gt; (a&lt;sub&gt;1&lt;/sub&gt;+b&lt;sub&gt;1&lt;/sub&gt;)-(a&lt;sub&gt;2&lt;/sub&gt;+b&lt;sub&gt;2&lt;/sub&gt;)∈I /\ a&lt;sub&gt;1&lt;/sub&gt;b&lt;sub&gt;1&lt;/sub&gt; - a&lt;sub&gt;2&lt;/sub&gt;b&lt;sub&gt;2&lt;/sub&gt; ∈I&lt;/p&gt;

&lt;p&gt;　　证明起来不难，&lt;/p&gt;
&lt;p&gt;　　(a&lt;sub&gt;1&lt;/sub&gt;+b&lt;sub&gt;1&lt;/sub&gt;)-(a&lt;sub&gt;2&lt;/sub&gt;+b&lt;sub&gt;2&lt;/sub&gt;) = (a&lt;sub&gt;1&lt;/sub&gt;-a&lt;sub&gt;2&lt;/sub&gt;)+(b&lt;sub&gt;1&lt;/sub&gt;-b&lt;sub&gt;2&lt;/sub&gt;)&lt;/p&gt;
&lt;p&gt;　　a&lt;sub&gt;1&lt;/sub&gt;-a&lt;sub&gt;2&lt;/sub&gt;和b&lt;sub&gt;1&lt;/sub&gt;-b&lt;sub&gt;2&lt;/sub&gt;都在I里，两者的和当然也在I里。&lt;/p&gt;
&lt;p&gt;　　我们假设a&lt;sub&gt;1&lt;/sub&gt;-a&lt;sub&gt;2&lt;/sub&gt;=i1, b&lt;sub&gt;1&lt;/sub&gt;-b&lt;sub&gt;2&lt;/sub&gt;=i&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　当然，i&lt;sub&gt;1&lt;/sub&gt;和i&lt;sub&gt;2&lt;/sub&gt;都是I里的元，&lt;/p&gt;
&lt;p&gt;　　a&lt;sub&gt;1&lt;/sub&gt;b&lt;sub&gt;1&lt;/sub&gt; - a&lt;sub&gt;2&lt;/sub&gt;b&lt;sub&gt;2&lt;/sub&gt; = (a&lt;sub&gt;2&lt;/sub&gt;+i&lt;sub&gt;1&lt;/sub&gt;)(b&lt;sub&gt;2&lt;/sub&gt;+i&lt;sub&gt;2&lt;/sub&gt;) - a&lt;sub&gt;2&lt;/sub&gt;b&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;                           = a&lt;sub&gt;2&lt;/sub&gt;b&lt;sub&gt;2&lt;/sub&gt; + i&lt;sub&gt;1&lt;/sub&gt;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;2&lt;/sub&gt;i&lt;sub&gt;2&lt;/sub&gt; + i&lt;sub&gt;1&lt;/sub&gt;i&lt;sub&gt;2&lt;/sub&gt; - a&lt;sub&gt;2&lt;/sub&gt;b&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;                           = i&lt;sub&gt;1&lt;/sub&gt;b&lt;sub&gt;2&lt;/sub&gt; + a&lt;sub&gt;2&lt;/sub&gt;i&lt;sub&gt;2&lt;/sub&gt; + i&lt;sub&gt;1&lt;/sub&gt;i&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　因为I是理想，所以i&lt;sub&gt;1&lt;/sub&gt;b&lt;sub&gt;2&lt;/sub&gt;、a&lt;sub&gt;2&lt;/sub&gt;i&lt;sub&gt;2&lt;/sub&gt;、i&lt;sub&gt;1&lt;/sub&gt;i&lt;sub&gt;2&lt;/sub&gt;都在I里，所以三者的和叶在I里。&lt;/p&gt;
&lt;p&gt;　　得证。&lt;/p&gt;
&lt;p&gt;　　唯一性得证后，加法和乘法的合理性得证。加法、乘法其他性质继承环R，从而商环的确是一个环。&lt;/p&gt;
&lt;p&gt;　　商环的&lt;span&gt;0元&lt;/span&gt;是&lt;span&gt;理想&lt;/span&gt;！&lt;/p&gt;

&lt;p&gt;　　我们来看看整数环的商环，我们知道所有的偶数构成的子环是其理想。&lt;/p&gt;
&lt;p&gt;　　那么商环为{{偶数},{奇数}}&lt;/p&gt;
&lt;p&gt;　　四则运算如下：&lt;/p&gt;
&lt;p&gt;　　{偶数} + {偶数} = {偶数} {偶数} - {偶数} = {偶数}   {偶数} * {偶数} = {偶数}　　&lt;/p&gt;
&lt;p&gt;　　{偶数} + {奇数} = {奇数} {偶数} - {奇数} = {奇数}   {偶数} * {奇数} = {偶数}  {偶数} / {奇数} = {偶数}&lt;/p&gt;
&lt;p&gt;　　{奇数} + {偶数} = {奇数} {奇数} - {偶数} = {奇数}   {奇数} * {偶数} = {偶数}&lt;/p&gt;
&lt;p&gt;　　{奇数} + {奇数} = {偶数} {奇数} - {奇数} = {偶数}   {奇数} * {奇数} = {奇数}  {奇数} / {奇数} = {奇数}&lt;/p&gt;
&lt;p&gt;　　显然，这个商环其实是一个2元域。&lt;/p&gt;

&lt;p&gt;　　实际上，对于任何质数p,&lt;span&gt;{x|x是p的整数倍}&lt;/span&gt;都是整数环的一个理想，所得商环都是一个&lt;span&gt;p阶素域&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　我们的主题是有限域。那么，我们会想，用整数环的商环可以构造任意阶有限域吗？&lt;/p&gt;
&lt;p&gt;　　实际上不行，比如对于{x|x是4的整数倍}这个理想，&lt;/p&gt;
&lt;p&gt;　　商环如下：&lt;/p&gt;
&lt;p&gt;　　{{x|x=4*a, a是整数}, {x|x=4*a+1, a是整数}, {x|x=4*a+2, a是整数}, {x|x=4*a+3, a是整数}}&lt;/p&gt;
&lt;p&gt;　　其中，{x|x=4*a, a是整数}是0元。&lt;/p&gt;
&lt;p&gt;　　 {x|x=4*a+2, a是整数} * {x|x=4*a+2, a是整数} = {x|x=4*a, a是整数}&lt;/p&gt;
&lt;p&gt;　　所有这个商环存在零因子，当然不是域。&lt;/p&gt;

&lt;p&gt;　　看来，我们需要别的方法来构造有限域，这个在之后的章节里讲述。&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 04:12:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<og:description>我们上一节介绍了环(ring)、域(field)的概念，并给了一些环、域的实例。比如我们知道整数环、方阵环、有理数域、实数域等。我们知道，域是环的一个种。最后，我们讲了素域，并讲了有限素域的构造。 接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/9438343.html</dc:identifier>
</item>
</channel>
</rss>