<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>NavMesh--导航网格寻路 - 张三疯_1998</title>
<link>http://www.cnblogs.com/zhh19981104/p/8062515.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhh19981104/p/8062515.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、概述：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NavMesh是3D游戏世界中用于实现动态物体自动寻路的一种技术，他将游戏场景中复杂的结构组织关系简化为带有一定信息的网格，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进而在这些网格的基础上通过一些列的计算来实现自动寻路。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、简单的应用;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、在场景中搭建以下模型;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171218225852209-825923767.jpg&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;327&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、选中这三个物体，在Inspector面板中的右上角的Static旁的小三角中选中Navigation Static，切记，一定要选择这个，不然不能正确的渲染导航网格。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171218230146334-1696003572.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、接下来打开Navigation视图（Window--&amp;gt;Navigaion），单击Navigation视图中右下角的Back按钮来进行导航网格的生成，其中蓝色的便是生成的导航网格。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171218230557521-64983581.jpg&quot; alt=&quot;&quot; width=&quot;444&quot; height=&quot;360&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4、这样我们的导航网格就完工了，那么接下来我们添加一个主角，并为其添加导航组件（Nav Mesh Agent），这时在在主角上会出现绿色的包围圈。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5、再在场景中添加一个Target物体，让我们的主角来朝向其运动，来观察导航是如何实现的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171218231149943-93197028.jpg&quot; alt=&quot;&quot; width=&quot;520&quot; height=&quot;448&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6、在主角的物体上添加以下脚本，用来控制其向Target的运动。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine.AI;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Run : MonoBehaviour
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Transform target;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         GetComponent&amp;lt;NavMeshAgent&amp;gt;().destination =&lt;span&gt; target.position;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;7、将Target物体拖动到脚本中的属性中，完成赋值。点击运行游戏，既可以看到主角在朝向Target运动了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;8、如果想要主角可以从底下通过，以最少的路径找到Target,则可以设置主角的Navigation--&amp;gt;Bake--&amp;gt;Agent Height的值，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果通过Bake可以在桥底下看到有蓝色的显示，则运行游戏主角就可以从桥底穿过了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;9、如果想要主角可以从上面直接跳下来的话，则需要选中所有的用作寻路导航的静态物体，在Navigation--&amp;gt;Object--&amp;gt;选中Generation OffMeahLinks，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后在设置Bake中的Drop height的值即可。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、使用Off-Mesh-Link组件：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;通俗的说，就是一个用来进行隔空传送的通道，当两个寻航网格不在同一的平面上时，就可以使用这个来解决，可以方便的进行传送。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、创建以下场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171219001634146-986369152.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;340&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、选择其中的一个关键点，为其添加Off Meah Link组件，然后将两个关键点赋值到相关的属性中。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、然后再进行Bake，这时就会在两个关键点之间有一条线进行连接了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4、为起始位置添加Run脚本，就是上篇的脚本，然后将重点位置进行真确的赋值。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5、运行游戏，则可以看到起始位置的球通过关键路径移动到终点位置。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171219002957615-1726008711.jpg&quot; alt=&quot;&quot; width=&quot;488&quot; height=&quot;246&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、为网格分层：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建以下场景：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171219003837381-127011853.jpg&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;为中间的两个桥分别设置其的网格层为：Navigation--&amp;gt;Areas--&amp;gt;User 3 =Bridge1/Bridge2.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171219003954693-246150454.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;然后进行Bake，则场景中的寻航导路的显示如图;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171219004049334-79484688.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来为其添加起始和开始位置的显示，并按上面的步骤为起始主角添加Nav Mesh Agent和Run脚本，并进行相应的配置，重复的就不说了，这里的重点是：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171219004514350-526238473.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;area Mask：这个选项用来控制那些寻路网格的使用，具体的效果可以修改这个Bridge1和Bridge2的选中状态就可以看到效果了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、Navmesh Obstacle组件：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;该组件比较适合处理动态路障的问题。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建以下场景;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171219005948850-644613524.jpg&quot; alt=&quot;&quot; width=&quot;723&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;场景中的两个红快分别是起始位置和终止位置，按照前面的步骤为桥面进行寻航网格的Bake，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时为起始角色添加Run 脚本和Nav Mesh Agent，并完成相应的赋值。&lt;/span&gt;&lt;span&gt;接下来为桥面附加Nav Mesh Obstacle组件，并未其附加Bridger脚本;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bridger : MonoBehaviour {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        StartCoroutine(Init());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    IEnumerator Init()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;        GetComponent&amp;lt;Renderer&amp;gt;().enabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitForSeconds(1f);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         GetComponent&amp;lt;NavMeshObstacle&amp;gt;().enabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         GetComponent&amp;lt;Renderer&amp;gt;().enabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;此时预览游戏，既可以发现，只有当中间的桥出来的时候，玩家角色才开始向终点位置移动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六、参数解释;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、Object(物体)参数面板：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171219011149834-1395923816.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;Navitation Static :旋中该复选框，则表示该游戏对象将参与导航网格的烘焙。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Generate OffMeshLinks:选中该复选框，可以自动根据Drop height和JumpDIstance的参数设置用关系线来连接分离的网格。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Navitation Area；导航区域设置&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、Bake(烘焙)面板;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171219011520568-852412402.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Agent Radius:具有代表性的物体半径，其半径越小，生成网格的面积越大，越精确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Agent Height；具有代表性的物体高度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Max Slope:最大可行进的斜坡角度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Step height：可行走的台阶高度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Drop Height：允许下落的最大下落距离&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Advanced:高度参数调节;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; Manual Voxel Size:选中手动输入像素值     &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Voxel Size :输入像素值　　　　　　　　　　　　【注意;值越小，烘焙的越精确但是烘焙的时间会增多，要慎用】&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Min Region Area :网格面积小于该面积的。将不生成寻航网格&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Heiht Mesh:选中该参数，会保存高度信息，但是会损失性能，要慎用&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、Nav Mesh Agent(导航组件)面板;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171219012241615-1447238946.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Agent SIze；尺寸控制&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; Radius:物体的半径&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Height:物体的高度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Base Offset：偏移量&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Steeing :行动控制&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Speed：物体的行进最大速度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Angular Speed：行进过程中的转向的角速度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Acceleration;物体的行进加速度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Stopping Distance：距离目标点小于多远距离后边停止行进&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Auto Braking:选中后自动制动，类似于缓慢刹车的效果&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Obstacle Avoidance:躲避障碍参数：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Quality：质量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Priority：优先级&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Path Finding：路径寻找&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　2017-12-19、01:34:44&lt;/p&gt;
</description>
<pubDate>Mon, 18 Dec 2017 17:35:00 +0000</pubDate>
<dc:creator>张三疯_1998</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhh19981104/p/8062515.html</dc:identifier>
</item>
<item>
<title>京东最新点击率预估模型论文学习和分享 - 笨兔勿应</title>
<link>http://www.cnblogs.com/bentuwuying/p/8061493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bentuwuying/p/8061493.html</guid>
<description>&lt;p&gt;最近看了京东算法团队最新发表的一篇点击率预估模型的paper &lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1709.00300&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Telepath: Understanding Users from a Human Vision Perspective in Large-Scale Recommender Systems&lt;/a&gt;，在这里分享一下。&lt;/p&gt;
&lt;p&gt;这篇paper的创新点主要体现在尝试从用户视觉的角度来反映图片/文字等信息对CTR的影响。从用户视觉的角度来看，有两个关键方面会影响用户的行为：一是商品的吸引力；二是商品与当前用户兴趣的匹配度。而paper中介绍的Telepath模型是融合了CNN、RNN、DNN这三种不同的神经网络模型的结果。其中CNN是用于模拟用户的视觉系统从而提取出体现商品吸引力的关键的视觉信号（key vision signal）；而RNN和DNN则是基于用户的浏览商品行为来模拟其兴趣信息。这样一个模型在京东的推荐系统和广告系统中中得到应用，并取得了效果提升。&lt;/p&gt;
&lt;p&gt;首先看一下Telepath模型的框架图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/995611/201712/995611-20171219002405787-372663962.png&quot; alt=&quot;&quot; width=&quot;373&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vision Extraction Module&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入数据是用户最近浏览过的N个商品，以及待预估商品的图像信息，该module用于模拟用户的视觉系统从而提取出体现商品吸引力的关键的视觉信号（key vision signal），并表示成向量用于后续处理。相比于传统的item-to-vector方法，其对于展现次数较少的长尾商品的拟合更好，能够更好地解决物品冷启动问题，并具有更好的特征表达能力（可以表达例如颜色等信息）。使用CNN是因为其适用于处理图像信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interest Understanding Module&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于上述Vision Extraction Module产出的体现商品吸引力的关键的视觉信号信息，可以使用用户最近浏览的商品的这些信息来得到用户的兴趣偏好，故使用了RNN这样一个适用于处理序列信息（用户浏览商品序列）的模型；而DNN适用于处理序列中隐藏的用户偏好信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scoring Module&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在可以使用的特征包括：待预估商品的图像信息；用户的偏好信息；用户和商品的统计类信息。前两者是使用Vision Extraction Module和Interest Understanding Module得到的；而第三种信息则是一使用wide&amp;amp;deep model得到的特征向量，wide部分用于学习特征交叉的记忆类信息，deep部分用于学习隐藏的特征组合信息。最后将这三种特征组合进行打分预测。&lt;/p&gt;

</description>
<pubDate>Mon, 18 Dec 2017 16:52:00 +0000</pubDate>
<dc:creator>笨兔勿应</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bentuwuying/p/8061493.html</dc:identifier>
</item>
<item>
<title>【Java入门提高篇】Day8 Java内部类——匿名内部类 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/8059861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/8059861.html</guid>
<description>&lt;p&gt;　　今天来看看另一个更加神奇的类——匿名内部类。&lt;/p&gt;
&lt;p&gt;　　就像它的名字表示的那样，这个类是匿名的，用完之后，深藏功与名，就像扫地僧那样默默潜藏于深山之中。匿名内部类不仅没有名字，连class关键字都省掉了，而且匿名内部类必须继承于某个类或者实现某个接口，长的就像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt; 父类（参数列表）|&lt;span&gt;实现接口（） {    
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;匿名内部类的内部定义&lt;/span&gt;
        }  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　来看一个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Human {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; walk();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一个抽象类，如果使用匿名内部类来继承的话是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnonymousTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Human human &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Human(){
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; walk(){
                System.out.println(&lt;/span&gt;&quot;AnonymousHuman can walk.&quot;&lt;span&gt;);
            };
        };
        human.walk();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　简单粗暴，看起来就像局部内部类的简化版。如果不使用匿名内部类，会是怎样呢？&lt;/p&gt;
&lt;p&gt;　　我们需要先创建一个类来继承这抽象类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Man &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Human {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; walk() {
        System.out.println(&lt;/span&gt;&quot;Man can walk.&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后再来使用这个类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnonymousTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Human human &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Man();
        human.walk();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为一个单独的类往往放在一个单独的文件中，如果这个类只需要创建一个对象，那未免有些大材小用了，从上面的栗子可以比较出匿名内部类的一个优势：在类只需要创建一个对象的情况下更加简单方便。&lt;/p&gt;
&lt;p&gt;　　再举一个实际一点的栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnonymousTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        sleep(&lt;/span&gt;1000&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(i);
                }
            }
        };
        t.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里创建了一个继承于Thread的匿名内部类，覆盖了其中的 run方法，并创建了一个实例返回给了t，然后再调用run方法，可以看到，匿名内部类只能存在一个实例对象，因为new过一次就无法再创建了，也许会觉得局部内部类已经很局限了，为什么要出现比局部内部类适用范围更小的匿名内部类？、&lt;/p&gt;
&lt;p&gt;　　这你就不懂了吧，在Java的实际使用中，匿名内部类大有用处，为什么要使用匿名内部类呢？&lt;/p&gt;
&lt;p&gt;　　有时候，我们创建的类只需要一个实例，比如说在多线程中，要使用多线程，一般先继承Thread类或者实现Runnable接口，然后再去调用它的方法，而每个任务一般都不一样，每次都新建一个类显然会很难管理，因为每个类只用一次就丢掉了，这个时候使用匿名内部类就很方便了，不仅不需要管理一堆一次性类，而且创建起来简单粗暴。就像上述栗子，还能简化成这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnonymousTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        sleep(&lt;/span&gt;1000&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(i);
                }
            }
        }.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建实例后直接调用run方法，简单粗暴。&lt;/p&gt;
&lt;p&gt;　　匿名内部类不仅可以继承于类，也可以实现于接口，比如说这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnonymousTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        sleep(&lt;/span&gt;1000&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(i);
                }
            }
        }).start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　当然，还有些不得不用内部类的情况，类只能继承于一个类，如果一个类需要使用到另一个包中的另一个类的一个protected方法，却已经继承于另一个类，那么这个时候就不得不用内部类来解决了。&lt;/p&gt;
&lt;p&gt;　　比如说，还有一个Woman（女人）类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Woman {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dance(){
        System.out.println(&lt;/span&gt;&quot;Woman can dance.&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个时候，如果Man（男人）也难不住寂寞，想要dance（跳舞）一下，那该怎么办呢？继承Woman类？显然不合乎逻辑，而且也无法实现，因为已经继承于Human类了，但就是想要dance，该怎么办？&lt;/p&gt;
&lt;p&gt;　　内部类的出现让这个问题变得很简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Man &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Human {&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; walk() {
        System.out.println(&lt;/span&gt;&quot;Man can walk.&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dance(){
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Woman(){
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; manDance(){
                &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dance();
            }
        }.manDance();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为在不同的包下，不能直接使用Woman的dance方法，但是可以用内部类来继承，从而调用protected方法，然后再放入Man的方法中，这样，Man也能像Woman一样dance了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnonymousTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Man human &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Man();
        human.walk();
        human.dance();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然，使用匿名内部类还是有很多限制的：&lt;/p&gt;
&lt;p&gt;　　1、匿名内部类必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。&lt;/p&gt;
&lt;p&gt;       2、匿名内部类不能定义构造函数。&lt;/p&gt;
&lt;p&gt;       3、匿名内部类中不能存在任何的静态成员变量和静态方法。&lt;/p&gt;
&lt;p&gt;       4、匿名内部类是特殊的局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。&lt;/p&gt;
&lt;p&gt;       5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。&lt;/p&gt;
&lt;p&gt;　　那么问题来了，怎样初始化一个匿名内部类呢？毕竟匿名内部类是不能有构造器的。&lt;/p&gt;
&lt;p&gt;　　当然，首先，还是可以使用初始化块来实现的，就像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnonymousTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Human human &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Human() {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
            {
                name &lt;/span&gt;= &quot;human&quot;&lt;span&gt;;
            }
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; walk() {
                System.out.println(name &lt;/span&gt;+ &quot; walk.&quot;&lt;span&gt;);
            }
        };
        human.walk();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是这样显然就比较呆板，不够灵活，无法接受外部参数，那么怎样灵活使用呢？不要心急，方法总比问题多，还是有办法解决的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnonymousTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Human human &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AnonymousTest().getHumanInstance(&quot;Frank&quot;&lt;span&gt;);
        human.walk();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Human getHumanInstance(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String name){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Human() {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String nameA;
            {
                nameA &lt;/span&gt;=&lt;span&gt; name;
            }
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; walk() {
                System.out.println(nameA &lt;/span&gt;+ &quot; walk.&quot;&lt;span&gt;);
            }
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里利用初始化块来对匿名内部类进行初始化，注意，如果匿名内部类需要使用外部的参数或者变量，那么必须使用final修饰，因为内部类使用的其实是参数的拷贝，并不是参数本身，为了更明显的表明参数不可变，编译器会要求使用final关键字来修饰需要使用的变量。&lt;/p&gt;
&lt;p&gt;　　至此，匿名内部类讲解完毕，欢迎大家继续关注！&lt;/p&gt;



</description>
<pubDate>Mon, 18 Dec 2017 16:48:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/8059861.html</dc:identifier>
</item>
<item>
<title>AspNet Core Api Restful 实现微服务之旅 （一） - 乐途</title>
<link>http://www.cnblogs.com/szlblog/p/8061114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/szlblog/p/8061114.html</guid>
<description>&lt;p&gt;（一）了解微服务（二）搭建VS项目框架  （三）创建AspNet Core Api &lt;/p&gt;
&lt;p&gt;VS2017 安装包   链接：https://pan.baidu.com/s/1hsjGuJq 密码：ug59&lt;/p&gt;
&lt;p&gt;创建 Core Api&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219000625053-821324497.png&quot; alt=&quot;&quot; width=&quot;492&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219000750553-1072526389.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;217&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219000904771-1750026574.png&quot; alt=&quot;&quot; width=&quot;413&quot; height=&quot;151&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.Properties：项目的启动配置信息&lt;/p&gt;
&lt;p&gt;2.wwwroot :是一个存放项目静态内容的文件夹，存放了诸如css，js，img&lt;/p&gt;
&lt;p&gt;3依赖项：&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219002404600-2092950803.png&quot; alt=&quot;&quot; width=&quot;403&quot; height=&quot;46&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.Controllers：Api 控制器&lt;/p&gt;
&lt;p&gt;5.appsettings.json:项目配置文件 类似于Config 文件&lt;/p&gt;
&lt;p&gt;6.Program：为静态文件提供服务&lt;/p&gt;
&lt;p&gt;7.Startup ：文件提供程序，是ASP.NET Core的启动入口文件&lt;/p&gt;
&lt;p&gt;这就是一个 Core Api 项目模板&lt;/p&gt;

&lt;p&gt;下一章 发布到IIS 以及注意事项&lt;/p&gt;

</description>
<pubDate>Mon, 18 Dec 2017 16:41:00 +0000</pubDate>
<dc:creator>乐途</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/szlblog/p/8061114.html</dc:identifier>
</item>
<item>
<title>框架原理第一讲,熟悉常用的设计方式.(以MFC框架讲解) - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/8060759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/8060759.html</guid>
<description>&lt;h2&gt;一丶什么是框架,以及框架的作用&lt;/h2&gt;
&lt;h3&gt;什么是框架?&lt;/h3&gt;
&lt;p&gt;　　框架,简而言之就是把东西封装好了,使用框架开发可以快速开发程序,例如MFC程序的双击写代码.&lt;/p&gt;
&lt;h2&gt;为什么讲解框架原理&lt;/h2&gt;
&lt;p&gt;1.熟悉框架可以跟随时代脚步,因为框架万变不离其宗&lt;/p&gt;
&lt;p&gt;2.熟悉框架,可以更快更好的逆向.&lt;/p&gt;
&lt;p&gt;比如现在我们知道的QQ界面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171218213029662-11278611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;界面就是DUILIB框架写的.我们要通过逆向找到关键的内容必须熟悉框架.如果不熟悉框架,你就算会逆向也不知道从哪里入手.&lt;/p&gt;

&lt;h2&gt;二丶通过MFC但文档,理解其设计方式.&lt;/h2&gt;
&lt;p&gt;因为是第一讲,所以从头讲起.&lt;/p&gt;
&lt;p&gt;MFC单文档框架其底层是封装的SDK的消息循环&lt;/p&gt;
&lt;p&gt;首先我们要实现自己的框架,就要封装类了.怎么封装,或者说哪里比较困难?&lt;/p&gt;
&lt;p&gt;1. API调用困难,所以封装&lt;/p&gt;
&lt;p&gt;2. API参数多,所以封装.&lt;/p&gt;
&lt;p&gt;3. 处理消息回调.&lt;/p&gt;
&lt;p&gt;API调用困难,我们可以封装成一个类&lt;/p&gt;
&lt;p&gt;处理消息回调.我们也可以封装成一个类,&lt;/p&gt;
&lt;p&gt;既然封装成类,那么就要使用虚函数进行操作了.&lt;/p&gt;
&lt;p&gt;1.首先封装WMain函数&lt;/p&gt;
&lt;p&gt;2.每个类都要有一个公公的父类,这样可以添加公共接口.但是注意,一旦添加了就不好删除了.&lt;/p&gt;

&lt;p&gt;三丶类代码设计.&lt;/p&gt;
&lt;p&gt;根据MFC单文档框架可以得出继承关系图.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171218214416771-80224075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从最基础的框架看起,只有一个三个类&lt;/p&gt;
&lt;p&gt;1.公共父类CObject　　&lt;/p&gt;
&lt;p&gt;2.消息处理类,CcmdTarGet　　响应消息&lt;/p&gt;
&lt;p&gt;　　2.1 CWinThread    消息处理&lt;/p&gt;
&lt;p&gt;　　2.2 CWinApp　　   应用程序初始化,显示窗口&lt;/p&gt;
&lt;p&gt;代码实现.&lt;/p&gt;
&lt;h3&gt;一丶实现类的关系图继承&lt;/h3&gt;
&lt;p&gt;首先按照继承关系图.添加类&lt;/p&gt;
&lt;p&gt;父类 CMyObject  消息处理类CMycmdTarGet 消息回调类 CMyWinThread 应用程序初始化类  CMyWinApp&lt;/p&gt;
&lt;p&gt;以及用户新建的类 CTestWinApp,前面几个类只是模拟MFC框架,自己定义的类,当我们用应用程序向导建立类的时候.则会生成自己的类(CTestWinApp)并且继承自CMyWinAPP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171218223159350-1023055679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二丶封装WMain函数&lt;/h3&gt;
&lt;p&gt;按照MFC但文档的框架&lt;/p&gt;
&lt;p&gt;1.封装WinMain&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171218234137678-1348557076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.自己的WMain中执行初始化代码.初始化用户的全局对象&lt;/p&gt;
&lt;p&gt;因为我们显示窗口或者注册窗口的时候,需要调用用户的InitInstance进行初始化.&lt;/p&gt;
&lt;p&gt;所以用户的类定义为全局变量.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171218234351350-644250625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;,MyWmain里面执行用户的InitInstance&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171219000057553-807290181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.用户的InITinstance里面执行注册窗口类,显示窗口类.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171219000829959-1405565574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加的时候会遇到的问题&lt;/p&gt;
&lt;p&gt;1.窗口过程函数没有.这个需要封装,但是因为是第一讲,所以暂时不封装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171219000930068-1987718364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.实例句柄没有,这个时候我们需要保存一下实例句柄&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171219000954740-465750442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义一个接口即可.&lt;/p&gt;
&lt;p&gt;注意: 窗口过程回调函数一定是要又默认的回调.不然不管你怎么注册窗口类,更新窗口类都会出错的.&lt;/p&gt;
&lt;p&gt;现在我们的工程已经支持显示一个窗口了.但是并没有消息循环.&lt;/p&gt;
&lt;h3&gt;4.添加消息循环,响应消息&lt;/h3&gt;
&lt;p&gt;消息循环我们要添加到我们自己封装的Wmain中,当执行用户的Inininstance成功创建窗口的时候.&lt;/p&gt;
&lt;p&gt;此时就该进行消息循环了.&lt;/p&gt;
&lt;p&gt;4.1添加虚函数在消息类中.并实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171219001324975-1381583516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4,2 自己封装的wmain进行调用.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171219001519756-661383252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们最基础的框架已经搭建完成.&lt;/p&gt;

&lt;p&gt;完整代码下载:&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1pKVViZp&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1pKVViZp&lt;/a&gt; 密码：2rsz&lt;/p&gt;

</description>
<pubDate>Mon, 18 Dec 2017 16:29:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/8060759.html</dc:identifier>
</item>
<item>
<title>从setTimeout看js函数执行 - 鲁小胖</title>
<link>http://www.cnblogs.com/lpggo/p/8059056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lpggo/p/8059056.html</guid>
<description>&lt;p&gt;　　老实说，写这篇文章的时候心里是有点压抑的，因为受到打击了,为什么？就 因为喜欢折腾不小心看到了这个&quot;简单&quot;的函数：&lt;/p&gt;
&lt;div readability=&quot;43.5&quot;&gt;
&lt;p&gt;       &lt;strong&gt;for (var i = 0; i &amp;lt; 5; i++) {&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            setTimeout(function () {&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                console.log(i)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            }, i * 1000);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        }&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        console.log(i);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　什么？这不就是我很久之前看到的先打印一个5，再打印一个5，之后每隔一秒就打印一个5，直到打印完6个5的实现方法吗？那么问题来了，如果我要依次打印0,1,2,3,4，5的话我该怎么办，其实在这之前我就知道有这两个方法：一个是这样：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;function log(i){&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　setTimeout(function(){&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　console.log(i)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　},i*1000)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　};&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;37&quot;&gt;　　
&lt;p&gt;　　&lt;strong&gt;for (var i = 0; i &amp;lt; 5; i++) {&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            log(i)&lt;/strong&gt;&lt;strong&gt;;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        }&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        console.log(i);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt;还有一个是这样：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;for(var i=0;i&amp;lt;5;i++){&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　(function(e){&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　setTimeout(function(){&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　console.log(e)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　},i*1000);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　})(i);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　};&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　console.log(i);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;不怕笑话，在这之前我是没搞懂这两个函数真正意义上的作用是用来干嘛的，只强迫自己这样记住这样修改就可以了，但是现在不行啊，我有强迫症啊！于是，我慢慢分析了一下，发现上面那段代码可以分离成这样：&lt;/p&gt;
&lt;p&gt;　　i=0时；满足条件；&lt;/p&gt;
&lt;p&gt;　　setTimeout(function(){&lt;/p&gt;
&lt;p&gt;　　　　console.log(i)&lt;/p&gt;
&lt;p&gt;　　　　},0*1000)；&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;　　
&lt;p&gt;　　i=1时；满足条件；&lt;/p&gt;
&lt;p&gt;　　setTimeout(function(){&lt;/p&gt;
&lt;p&gt;　　　　console.log(i)&lt;/p&gt;
&lt;p&gt;　　　　},1*1000)；&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;　　
&lt;p&gt;i=2时；满足条件；&lt;/p&gt;
&lt;p&gt;　　setTimeout(function(){&lt;/p&gt;
&lt;p&gt;　　　　console.log(i)&lt;/p&gt;
&lt;p&gt;　　　　},2*1000)；&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;　　
&lt;p&gt;i=3时；满足条件；&lt;/p&gt;
&lt;p&gt;　　setTimeout(function(){&lt;/p&gt;
&lt;p&gt;　　　　console.log(i)&lt;/p&gt;
&lt;p&gt;　　　　},3*1000)；&lt;/p&gt;
&lt;div readability=&quot;39.5&quot;&gt;
&lt;p&gt;i=4时；满足条件；&lt;/p&gt;
&lt;p&gt;　　setTimeout(function(){&lt;/p&gt;
&lt;p&gt;　　　　console.log(i)&lt;/p&gt;
&lt;p&gt;　　　　},4*1000);&lt;/p&gt;
&lt;p&gt;i=5时，不满足条件，跳出循环，接着执行for循环后面的console.log(i),打印5；最后依次每秒打印5；&lt;/p&gt;
&lt;p&gt;　　真有意思，为什么setTimeout里面的console.log会是后于for循环外面的console.log执行呢？直到我认识到了这个单词=&amp;gt;&quot;队列&quot;,&lt;span&gt;队列又有宏任务队列(Macro Task)以及微任务队列(Micro Task)之分&lt;/span&gt;,在javascript中:&lt;/p&gt;
&lt;div readability=&quot;46&quot;&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;macro-task包括：script(整体代码), &lt;span&gt;setTimeout&lt;/span&gt;, setInterval, setImmediate, I/O, UI rendering。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;micro-task包括：process.nextTick, &lt;span&gt;Promises&lt;/span&gt;, Object.observe, MutationObserver&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;上面函数的setTimeout就属于宏任务&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在js中，事件循环的顺序是从script开始第一次循环，随后全局上下文进入函数调用栈，碰到macro-task就将其交给处理它的模块处理完之后将回调函数放进macro-task的队列之中，碰到micro-task也是将其回调函数放进micro-task的队列之中。直到函数调用栈清空只剩全局执行上下文，然后开始执行所有的micro-task。&lt;span&gt;当所有可执行的micro-task执行完毕之后。循环再次执行macro-task中的一个任务队列&lt;/span&gt;，执行完之后再执行所有的micro-task，就这样一直循环。&lt;/p&gt;
&lt;p&gt; 这就是为什么setTimeout里面的console.log会是后于for循环外面的console.log执行，在函数执行上下文中，seiTimeout函数会被放到处理他的macro-task的队列之中，所以循环的时候setTimeout里面的function是不会被执行的，而是等到所有整体代码（非队列）跑完之后才会执行队列中的函数；写到这里，可能会有点懵逼，其实我也有点懵逼，哈哈哈！！&lt;/p&gt;
&lt;p&gt;　　为了加深理解，还可以试试在里面加入Promise，于是就有了这个：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;strong&gt;(function copy() {
    setTimeout(function() {console.log(4)}, 0);
    new Promise(function executor(resolve) {
        console.log(1);
        for( var i=0 ; i&amp;lt;10000 ; i++ )&lt;/strong&gt; {
&lt;strong&gt;            i == 9999 &amp;amp;&amp;amp; resolve();
        }
        console.log(2);
    }).then(function() {
        console.log(5);
    });
    console.log(3);
})()&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;解释一下=&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.首先，script任务源先执行，全局上下文入栈。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.script任务源的代码在执行时遇到setTimeout,作为一个macro-task，将其回调函数放入自己的队列之中。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.script任务源的代码在执行时遇到Promise实例。Promise构造函数中的第一个参数是在当前任务直接执行不会被放入队列之中，因此此时输出 1 。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.在for循环里面遇到resolve函数，函数入栈执行之后出栈，此时Promise的状态变成Fulfilled。代码接着执行遇到console.log(2),输出2。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.接着执行，代码遇到then方法，其回调函数作为micro-task入栈，进入Promise的任务队列之中,此时Promise的then 里面的function回调函数跟setTimeout里面的function&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;code class=&quot;language-text&quot;&gt;回调函数有着异曲同工之意，都会被放到各自的任务队列中，&lt;br/&gt;　直到函数上下文即script中所有的非队列代码执行完毕后再执行,而且微任务队列优先于宏任务队列被处理，&lt;br/&gt;&lt;span&gt;总体顺序为:上下文非队列代码&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;code class=&quot;language-text&quot;&gt;微任务队列回调函数代码&amp;gt;&lt;/code&gt;&lt;code class=&quot;language-text&quot;&gt;宏任务队列回调函数代码&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;6.代码接着执行，此时遇到console.log(3),输出3。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7.输出3之后第一个宏任务script的代码执行完毕，这时候开始开始执行所有在队列之中的micro-task。then的回调函数入栈执行完毕之后出栈，这时候输出5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8.这时候所有的micro-task执行完毕，第一轮循环结束。第二轮循环从setTimeout的任务队列开始，setTimeout的回调函数入栈执行完毕之后出栈，此时输出4。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;最后，为了加深理解，再上一段代码：&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;console.log('golb1');&lt;br/&gt;setTimeout(function() {&lt;br/&gt;console.log('timeout1');&lt;br/&gt;new Promise(function(resolve) {
        console.log('timeout1_promise');
        resolve();&lt;br/&gt;　　　　setTimeout(function(){&lt;br/&gt;　　　　　　console.log('time_timeout')&lt;br/&gt;　　　　});　　
    }).then(function() {
        console.log('timeout1_then')
    })&lt;br/&gt;setTimeout(function() {
        console.log('timeout1_timeout1');
    });
})
new Promise(function(resolve) {
    console.log('glob1_promise');
    resolve();&lt;br/&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;　　setTimeout(function(){&lt;br/&gt;　　　　　console.log('prp_timeout')&lt;br/&gt;　　　　});&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;strong&gt;}).then(function() { console.log('glob1_then') })&lt;/strong&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果你的执行结果是:golb1=&amp;gt;glob1_promise=&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;code class=&quot;language-text&quot;&gt;glob1_then=&amp;gt;timeout1=&amp;gt;timeout1_promise=&amp;gt;timeout1_then=&amp;gt;prp_timeout=&amp;gt;time_timeout=&amp;gt;timeout1_timeout1,&lt;br/&gt;可能异步队列算是入门了吧！~~上面的代码看起来有点杂乱，&lt;br/&gt;可能用asyns搭配await改造一下会更好，但是这或多或少是鄙人从setTimeout中得到的见解吧，有啥不对之处望指正：&lt;br/&gt;另外，参考了一下别人的文章：https://zhuanlan.zhihu.com/p/26238030写的确实不错&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;


&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 18 Dec 2017 16:06:00 +0000</pubDate>
<dc:creator>鲁小胖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lpggo/p/8059056.html</dc:identifier>
</item>
<item>
<title>高效管理http连接 - kingszelda</title>
<link>http://www.cnblogs.com/kingszelda/p/8040935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingszelda/p/8040935.html</guid>
<description>&lt;h2&gt;1.Http连接基础&lt;/h2&gt;
&lt;p&gt;  Http协议承载了互联网上的主要流量，然而说到传输，还要回归到最基本的网络分层模型TCP/IP。TCP/IP是全球计算机及网络设备都在使用的一种常用的分组交互网络分层协议集。客户端可以打开一条TCP/IP连接，与世界上的任何服务器进行数据交换，并且交换的数据永远不会丢失，受损或失序。&lt;/p&gt;
&lt;p&gt;  下面是常见的TCP/IP分层协议，分为安全与非安全版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196330/201712/1196330-20171215004339138-1340548200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  由图可知，HTTP的整个传输过程可以描述为“HTTP over TCP over IP”。TCP是可靠地传输协议，就好像一条管道，从TCP连接一段填入的字节会从另外一端以原有的顺序，正确的传送出来。&lt;/p&gt;
&lt;p&gt;  TCP层与IP层都有自己的协议，他们对数据的关注点不同。总的来说，TCP段包含了目的端口与源端口，用来建立程序之间的连接。IP段包含了目的IP与源IP，用来进行网络寻址，最终建立机器之间的连接。而一条TCP连接正是根据这四点唯一对应的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;源IP地址，源端口号，目的IP地址，目的端口号&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  不同的连接不可以拥有完全相同的四个属性。对于一般功能而言，自己发起的连接中源端口号是随机生成的。&lt;/p&gt;
&lt;h2&gt;2.http连接性能&lt;/h2&gt;
&lt;p&gt;  由于http数据是通过TCP传输的，http连接的性能很大程度上取决于TCP通道的性能。我们先分析一个正常的http事务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196330/201712/1196330-20171215011426498-1295824265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端如果拿到的是域名，则需要先从DNS服务器中解析获得服务器IP地址，这个过程称为“DNS查询”，需要花费一定的时间。&lt;/li&gt;
&lt;li&gt;客户端与服务器进行三次握手建立连接。&lt;/li&gt;
&lt;li&gt;建立连接后，客户端会发送有真正含义的请求报文。&lt;/li&gt;
&lt;li&gt;服务器接收到请求后开始处理。&lt;/li&gt;
&lt;li&gt;服务器处理完毕后，发送响应给客户端。&lt;/li&gt;
&lt;li&gt;客户端收到响应后，与服务器进行四次挥手，断开连接。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  从上面的流程可以看出来，真正的有业务意义的阶段是“请求-处理-响应”，其他阶段时间消耗都是与业务无关的。因此可以从这上面思考如何优化TCP性能。&lt;/p&gt;
&lt;h2&gt;3.TCP连接性能聚焦&lt;/h2&gt;
&lt;p&gt;TCP连接的性能通常从下面5个方面考虑：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;TCP建立握手&lt;/li&gt;
&lt;li&gt;捎带确认的TCP延迟确认算法&lt;/li&gt;
&lt;li&gt;TCP慢启动的拥塞控制&lt;/li&gt;
&lt;li&gt;数据聚集的Nagle算法&lt;/li&gt;
&lt;li&gt;TIME_WAIT时延与端口耗尽&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;3.1 TCP建立握手&lt;/h3&gt;
&lt;p&gt;  从上面的图中可以看出，一次正常的交互需要经过DNS查询、握手、挥手等与数据传输无关的操作。如果每次传输的数据都很少，那么这种操作所占用的比例就会增加，这将大大降低HTTP的性能。由于HTTP是建立在TCP连接的基础上的，所以握手的过程是对HTTP不可见的，HTTP只能看到建立连接发生了时延。三次握手的过程这里不做赘述，感兴趣的请查阅相关资料。&lt;/p&gt;
&lt;p&gt;  三次握手简单来说是建立连接前的三次交互来确认连接可以建立，有SYN,ACK+SYN,ACK三次报文通信。对于一些小的HTTP事务，比如握手后告知页面304了，这种事务中在TCP建立上可能会法费一半甚至更多的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  解决方案：我们可以通过重用TCP连接来减少这种性能上的损失，比如持久连接。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;3.2 延迟确认&lt;/h3&gt;
&lt;p&gt;  因特网是无法保证数据可靠传输的，因为在网络路由超负荷的情况下，允许丢弃任意网络分组。所以，TCP实现了一套自己的确认机制来保障数据可靠传输。&lt;/p&gt;
&lt;p&gt;  每个TCP段都有一个序号和数据校验和，接受者在接受完整之后会向发送者送回确认分组，这样保证了这个分组的可靠传输。如果发送者在一定时间窗口内没有接收到响应的确认分组，则认为这个分组已经丢失，对该分组进行重发。&lt;/p&gt;
&lt;p&gt;  由于确认报文很小，所以TCP允许在发往相同方向的数据分组中对其进行“捎带”，就是这种捎带出了问题。TCP将返回确认信息与输出信息集合在一起，可以有效的利用网络连接。因此为了找到相同方向的数据分组来进行捎带，很多TCP栈实现了一种“延时确认”的算法。这种算法将确认信息放入缓冲区，在一定的时间窗口内（一般是100-200毫秒）找不到输出分组，则对确认数据进行单独发送。&lt;/p&gt;
&lt;p&gt;  如果请求响应并没有较多的数据传输过程，则满足捎带确认的可能性就很低。通常，延迟确认算法会引入相当大的时延。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;解决方案：根据操作系统的不容，可以调整或禁止延迟确认算法。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.3 慢启动与拥塞控制&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;  TCP传输过程有慢启动与拥塞控制的概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196330/201712/1196330-20171218233005709-2044028511.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  TCP在建立连接开始的时候，会进行慢启动，数据窗口会逐渐指数变大，在达到阈值后会线性增长。当发生某次超时之后，会迅速减小窗口到最小，重新开始慢启动，通知减小之前的阈值。&lt;/p&gt;
&lt;p&gt;  在这种机制的保障下，一个TCP连接是会进行自我调整的，因此一个新的连接的传输效率是不如老连接的。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;解决方案：我们通过重用连接，可以使得传输效率提升，比如持久连接。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.4 Nagle算法与TCP_NODELAY&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt; Nagle算法与延时确认算法有些类似。不过Nagle算法关注的是发送方，为了保证不大量发送小的数据报文造成3.1的问题。该算法鼓励每次发送大的数据组，如果数据分组不够大，则放在缓存区等待与其他数据分组结合起来达到上限后一起发送，或者其他分组被确认后发送。&lt;/p&gt;
&lt;p&gt;  而对于一些小的数据分组而言，可能很多个也无法攒够一次发送的数量。当这时接收端也采用延时确认算法之后，事情就变得恐怖了。对于发送端而言，很多小的数据分组没有成功发送，因为第一个分组发送之后，服务端进行了延时确认200ms，在这段时间过去之后发送端的第二个分组才会被发送，这样的排队阻塞简直是噩梦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  解决方案：可以在协议栈中设置TCP_NODELAY来禁用Nagle算法。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.5 TIME_WAIT时延与端口耗尽&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;  当一个TCP连接完成四次挥手关闭之后，会进入TIME_WAIT状态，在等待2MSL之后会释放该TCP连接。因为TCP的分组可能不是按照顺序到达的，我们假设一个分组在网络中最多存货1MSL，则2MSL之后基本上就可以认为确实结束了。如果在2MSL之间服务端没有接收到LAST_ACK发送的FIN对应的响应，则TIME_WAIT会再次发送ACK。&lt;/p&gt;
&lt;p&gt;  之前有说过，一个TCP可以通过下面四个属性来确认。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;源IP地址，源端口号，目的IP地址，目的端口号&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　而对于一个服务来说，之后源端口是不确定的，因为每次源端口都是随机生成的。但是源端口是有数量限制的，比如60000个端口，MSL是60秒。则连接速率就被限制在60000/120=500次/秒。如果不进行相关的优化，操作系统就无法发起更多的连接。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;解决方案：可以增加请求端机器，通过负载均衡的方法降低端口耗尽的可能性，或者在服务端使用几个虚拟IP增加连接的组合。&lt;/strong&gt;　&lt;/p&gt;
&lt;h2&gt;4 总结&lt;/h2&gt;
&lt;p&gt;  HTTP建立在TCP的基础上，如果我们在工作中发现HTTP建立连接的效率很低，可以考虑从上面的五个角度分析是否达到了相关的瓶颈，并通过推荐方案解决问题。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Dec 2017 15:59:00 +0000</pubDate>
<dc:creator>kingszelda</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingszelda/p/8040935.html</dc:identifier>
</item>
<item>
<title>Python笔记·第一章—— Python基础（一） - 人生不如戏</title>
<link>http://www.cnblogs.com/fu-yong/p/8060188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fu-yong/p/8060188.html</guid>
<description>&lt;h2&gt;1、Python的由来与版本&lt;/h2&gt;
&lt;h3&gt;1.1 &lt;strong&gt;python的由来&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;python的创始人为吉多·范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，吉多·范罗苏姆（中文名字：龟叔）为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。  &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.2  python版本&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　目前Python的主要版本为Python2.7与Python3.6 。&lt;/p&gt;
&lt;p&gt;　　Python2版本到2020年就不再维护。&lt;/p&gt;
&lt;h2&gt;2、Python是什么样的语言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;编程语言主要从以下几个角度为进行分类，编译型和解释型、静态语言和动态语言、强类型定义语言和弱类型定义语言，每个分类代表什么意思呢，我们一起来看一下。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;2.1 编译型语言和解释型语言&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;编译型语言&lt;/strong&gt;：当用户写完一段代码需要执行的时候，由编译器先把整段代码一次性编译成计算机能看懂的二进制文件，然后再执行。这个过程中，如果用户写的代码出错了，编译器就得整段从头开始编译，只是几行或者几页代码的情况下还感觉不出来，但是如果代码由成千上万行甚至上亿行，可想而知，会浪费很多时间，导致开发速度慢。而且，他不是跨平台的，编译过后的代码在不同操作系统上就无法执行。他的优点是运行快，因为一旦编译成功，每次调用只需直接执行即可&lt;/p&gt;
&lt;p&gt;　　编译型语言的代表：C语言、C++语言&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;解释型语言：&lt;/strong&gt;当用户写完一段代码需要执行的时候，由解释器一段一段的解释成计算机能看懂的二进制文件，然后直接执行。与编译型语言不同的是，如果用户写的代码出错了，解释器不需要从头开始，这就会大大节省了开发时间。而且他是可以移植的，不同操作系统由不同的解释器可以解释他。他的缺点是执行速度慢，每次执行都需要一行一行的解释。&lt;/p&gt;
&lt;p&gt;　　解释型语言的代表：JavaScript、PHP、Python&lt;/p&gt;

&lt;h3&gt;2.2 动态语言与静态语言&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;动态语言&lt;/strong&gt;：动态语言是指在运行的时候才去检查一个变量的数据类型，写程序的时候不需要先给一个变量指定类型。当第一次给变量赋值的时候，该语言会将该变量的数据类型存到内存当中。Python和Ruby就是典型的动态语言的代表。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;静态语言&lt;/strong&gt;：静态语言是指程序在编译的时候就要首先检查每个变量的数据类型，所以用户在写程序之前就要首先声明每个变量的数据类型。Java、C、C++都是静态语言的代表。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.3 强类型定义语言和弱类型定义语言&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　强类型定义语言：&lt;/strong&gt;一旦一个变量被赋值为一个数据类型，那么它将永远为该数据类型，除非它被强制转换（int()、str()）。比如说 a = 1 那么之后在给 a 赋值的时候也必须为整形。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;弱类型定义语言：&lt;/strong&gt;一个变量可以在不同的时候被赋予不同数据类型的值。所以，一个变量的数据类型可以被忽略。&lt;/p&gt;

&lt;h3&gt;综上所述，Python是一种动态解释型的强类型定义语言。&lt;/h3&gt;

&lt;h2&gt;3、Python的优缺点&lt;/h2&gt;
&lt;p&gt;　&lt;strong&gt;　  优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　▷ 优雅、明确、简洁&lt;/p&gt;
&lt;p&gt;　　　　▷ 可移植、可拓展、可潜入&lt;/p&gt;
&lt;p&gt;　　　　▷ 开发效率高&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;  缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;▷ 运行速度慢 &lt;/p&gt;
&lt;p&gt;　　　　▷ 代码不能加密&lt;/p&gt;
&lt;p&gt;　　　　▷ 不能多线程&lt;/p&gt;
&lt;h2&gt;4、Python的种类&lt;/h2&gt;
&lt;p&gt;　　 &lt;strong&gt;CPython&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　当我们从&lt;a href=&quot;https://www.python.org/&quot;&gt;Python官方网站&lt;/a&gt;下载并安装好Python 3.6后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行&lt;code&gt;python&lt;/code&gt;就是启动CPython解释器。&lt;/p&gt;
&lt;p&gt;　　　　CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　IPython&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调                 用了IE。&lt;/p&gt;
&lt;p&gt;　　　　CPython用&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;作为提示符，而IPython用&lt;code&gt;In [&lt;/code&gt;&lt;code&gt;序号&lt;/code&gt;&lt;code&gt;]:&lt;/code&gt;作为提示符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　 PyPy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用&lt;a href=&quot;http://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;JIT技术&lt;/a&gt;，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。&lt;/p&gt;
&lt;p&gt;               绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Jython&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　IronPython&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　 IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　小结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。&lt;/p&gt;

&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
　　
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;、下载安装包
    https://www.python.org/downloads/
2&lt;span&gt;、安装
    默认安装路径：C:\python27
3&lt;span&gt;、配置环境变量
    【右键计算机】--》【属性】--》【高级系统设置】--》【高级】--》【环境变量】--》【在第二个内容框中找到 变量名为Path 的一行，双击】 --&amp;gt;&lt;span&gt; 【Python安装目录追加到变值值中，用 ； 分割】
    如：原来的值;C:\python27，切记前面要有英文输入法状态下的分号&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1、编写以及运行Python代码的方法&lt;/h2&gt;
&lt;p&gt;　　▷ 在E盘创建一个文件名为test.py的文件，编写代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
print(&quot;Hello World!&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　▷ 按快捷键win+R打开运行窗口，然后输入cmd打开命令行窗口。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1299859/201712/1299859-20171214191131420-733103242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　▷在命令行窗口里输入 python e:/test.py&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1299859/201712/1299859-20171214191320420-105454220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　上图可以看出，以及成功运行该文件代码并且打印出“Hello World！”&lt;/p&gt;

&lt;h2&gt;2、内容编码&lt;/h2&gt;
&lt;p&gt;　　解释器在执行代码的时候，需要将代码编译成机器能读懂的二进制码（由1和0组成），而python2版本在编译的时候默认以ASCII码的格式进行转换（也可以指定编码格式），而python3版本在编译的时候默认为utf-8格式进行转换。&lt;/p&gt;
&lt;p&gt;　　ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，其最多只能用 8 位来表示（一个字节），即：2**8 = 256，所以，ASCII码最多只能表示 256 个符号。&lt;/p&gt;
&lt;p&gt;　　然而，世界上的语言以及符号远远不止256个，所以当计算机传入世界各国的时候ASCII码已经不能满足大家的使用了，于是出现了Unicode（统一码、万国码、单一码），Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，规定虽有的字符和符号最少由 16 位来表示（2个字节），即：2 **16 = 65536，&lt;br data-filtered=&quot;filtered&quot;/&gt;
注：此处说的的是最少2个字节，可能更多&lt;/p&gt;
&lt;p&gt;　　但是问题来了，友谊Unicode至少2个字节，也就是16位，但是英文字母以及有些符号根本不需要这么多字节，所以统一用Unicode码的话会大大浪费宝贵的内存空间，于是又出现了一种新的编码：UTF-8.该编码格式是对Unicode编码的压缩和优化，他不再使用最少使用2个字节，而是将所有的字符和符号进行分类：ascii码中的内容用1个字节保存、欧洲的字符用2个字节保存，东亚的字符用3个字节保存...&lt;/p&gt;
&lt;p&gt;　　所以，python解释器在加载 .py 文件中的代码时，会对内容进行编码（默认ascill），如果是如下代码的话：&lt;/p&gt;
&lt;p&gt;报错：ascii码无法表示中文&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
print('你好，世界！')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决方法是，在代码的首行加入以下代码，用来指定编码格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#-*- ecoding:utf-8 -*-&lt;br/&gt;#这样，就能成功执行并打印出中文“你好，世界！”了。
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3、注释&lt;/h2&gt;
&lt;p&gt; 　　　　单行注释：# 被注释内容&lt;/p&gt;
&lt;p&gt;　　　　 多行注释：'''被注释内容'''，或者&quot;&quot;&quot;被注释内容&quot;&quot;&quot;&lt;/p&gt;
&lt;h2&gt;4、变量&lt;/h2&gt;
&lt;p&gt;　　　　&lt;em&gt;变量就是把程序运行的中间结果，存到内存中，以待调用&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　▷&lt;strong&gt;声明变量&lt;/strong&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 # -*- coding: utf-8 -*-
2   
3 name = &quot;fuyong&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码声明了一个变量，变量名为： name，变量name的值为：&quot;fuyong&quot;&lt;/p&gt;
&lt;p&gt;变量的作用：昵称，其代指内存里某个地址中保存的内容&lt;/p&gt;


&lt;p&gt;▷变量的命名规则&lt;/p&gt;
&lt;p&gt;　　　1、由字母、下划线、数字组成&lt;/p&gt;
&lt;p&gt;　　　2、首字母不能是数字&lt;/p&gt;
&lt;p&gt;　　　3、不能是python中的关键字（以下为python关键字）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
 ['and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'exec', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try', 'while', 'with', 'yield']
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;▷变量的赋值&lt;/p&gt;
&lt;p&gt;变量的赋值其实是在内存中开辟一块数据，然后将该数据指向变量名，这样在调用变量名的时候就能找到该变量所对应的值。&lt;/p&gt;

&lt;p&gt;而如果将一个变量的值赋予给另一个变量，那么内存中还是只有一个数据值，只是将该数据指向了不同的两个变量而已&lt;/p&gt;

&lt;h2&gt;5、常量　　&lt;/h2&gt;
&lt;p&gt;　　　　常量即指不变的量，如pai 3.141592653..., 或在程序运行过程中不会改变的量&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;lang-py&quot;&gt;　　　　：Bir_of_China = &lt;span class=&quot;hljs-number&quot;&gt;1949　　　　　　　　　 &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;6、用户交互（input）&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1 # -*- coding: utf-8 -*-
2   
3 # 将用户输入的内容赋值给 name 变量
4 name = input(&quot;请输入用户名：&quot;&lt;span&gt;)
5 
6 # 打印输入的内容
7 print(name,age)&lt;br/&gt;#执行脚本就会发现，程序会等待你输入姓名后再往下继续走。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;7、基础数据类型&lt;/h2&gt;
&lt;pre readability=&quot;9.5&quot;&gt;
&lt;code class=&quot;lang-py&quot; readability=&quot;13&quot;&gt;　　　　　　　▷ int  整形&lt;br/&gt;　　　　　　　　在32位的机器上，int的长度为32为，范围为 -2**31 -- 2**31-1 &lt;br/&gt;　　　　　　　　在64位的机器上，int的长度为64位，范围为 -2**63 -- 2**63-1&lt;p&gt;　　　　　　　▷ long 长整型 （python3版本已经没有该类型了，不管多长的数，全部为int类型）&lt;br/&gt;　　　　　　　　跟C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。&lt;br/&gt;　　　　　　　　该类型不用用户特别定义，当一个数字大到超过int数据类型的范围后将自动转化为long长整形。&lt;br/&gt;　　　　　　　　注意：python3版本没有long型了，全部为int类型&lt;/p&gt;&lt;p&gt;　　　　　　　▷ bool 布尔类型（True False）&lt;br/&gt;　　　　　　　　True ：1 、 1==1 、 2&amp;gt;1 、type（'a'） == str 的结果均为True&lt;br/&gt;　　　　　　　　False：0 、 1!=1 、 2&amp;gt;3 等等的结果均为False&lt;/p&gt;&lt;p&gt;　　　　　　　▷ str 字符串类型&lt;br/&gt;　　　　　　　　简单一句话，在python中，加了引号的字符都被认为是字符串，哪怕他是一个数字（‘123’）&lt;br/&gt;　　　　　　　　&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1 &amp;gt;&amp;gt;&amp;gt; name = &quot;Alex Li&quot; #双引号
2 &amp;gt;&amp;gt;&amp;gt; age = &quot;22&quot;       #只要加引号就是字符串
3 &amp;gt;&amp;gt;&amp;gt; age2 = 22          #int
4 &amp;gt;&amp;gt;&amp;gt; 
5 &amp;gt;&amp;gt;&amp;gt; msg = '''My name is Alex, I am 22 years old!'''  #我擦，3个引号也可以
6 &amp;gt;&amp;gt;&amp;gt; 
7 &amp;gt;&amp;gt;&amp;gt; hometown = 'ShanDong'   #单引号也可以
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　单引号双引号以及三引号都可以表示字符串&lt;/p&gt;
&lt;p&gt;　双引号和单引号可以搭配使用，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
msg = &quot;I'm a small birld&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三引号可以将一大段代码赋值给一个变量，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 msg = '''
2 今天我想写首小诗，
3 歌颂我的同桌，
4 你看他那乌黑的短发，
5 好像一只炸毛鸡。
6 '''
7 print(msg)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;code class=&quot;lang-py&quot;&gt;字符串可以用 + 拼接，但是两者必须都为字符串类型。如：&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 a = 'hello'
2 b = 'xiaomi'
3 c = a +&lt;span&gt; b
4 print(c)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果即为“helloxiaomi”&lt;/p&gt;
&lt;p&gt;字符串也可以与一个数字相乘，结果是将该字符串连续输入N遍，如：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
print('xyz' * 3)&lt;p&gt;#输出结果为‘xyzxyzxyz’
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;8、格式化输出&lt;/h2&gt;
&lt;p&gt;现有一练习需求，问用户的姓名、年龄、工作、爱好 ，然后打印成以下格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
------------ info of fuyong -----------&lt;span&gt;
Name  : fuyong
Age   : 29&lt;span&gt;
job   : none
Hobbie: girl
------------- end -----------------&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;
&lt;code class=&quot;lang-py&quot;&gt;　　　　&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 1 name = input(&quot;请输入您的姓名：&quot;&lt;span&gt;)
 2 age =  input(&quot;请输入您的年龄：&quot;&lt;span&gt;)
 3 job = input(&quot;请输入您的工作:&quot;&lt;span&gt;)
 4 hobbie = input(&quot;请输入您的爱好：&quot;&lt;span&gt;)
 5 
 6 info = ''' 
 7     ------------ info of %s ----------- #给一个占位符，等待传入name的值
 8     
 9     Name:%s  #给一个占位符，等待传入name的值
10 
11     Age :%s  #给一个占位符，等待传入age的值
12 
13     Job :%s  #给一个占位符，等待传入job的值
14 
15     Hobbie:%s #给一个占位符，等待传入hobbie的值
16 
17     ------------- end -----------------
18 
19 ''' %(name,name,age,job,hobbie) # 符号%后的括号里的值与上面的几个占为符号一一对应，将值分别传入
20 
21 print(info)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：如果字符串里需要出现‘%’的时候，需要用转义符号来实现，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
msg = &quot;我是%s,年龄%d,目前学习进度为80%%&quot;%('金鑫',18&lt;span&gt;)
print(msg)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　PS ：&lt;/p&gt;
&lt;p&gt;　　▷查看数据类型的方法为type()              如type(1) 的结果为int   type('a')的结果为str&lt;/p&gt;
&lt;p&gt;　　　　　　　▷如果一个变量位阿拉伯数字，则该数据可以在int类型与str类型之间互相转换&lt;/p&gt;
&lt;h2&gt;9.基本运算符&lt;/h2&gt;
&lt;p&gt;　　　　　　▷算数运算&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-py&quot;&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1299859/201712/1299859-20171214210129342-1778413248.png&quot; alt=&quot;&quot;/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 　　　　　　▷比较运算&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-py&quot;&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1299859/201712/1299859-20171214210149529-1498691280.png&quot; alt=&quot;&quot;/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 　　　　　　▷赋值运算&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-py&quot;&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1299859/201712/1299859-20171214210202435-1998858016.png&quot; alt=&quot;&quot;/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 　　　　　　▷逻辑运算&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-py&quot;&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1299859/201712/1299859-20171214210214388-2068054688.png&quot; alt=&quot;&quot;/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　注意：在没有()的情况下，not的优先级大于and，and的优先级大于or。即 () &amp;gt; not &amp;gt; and &amp;gt; or 优先级相同的情况下从左向右计算&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1299859/201712/1299859-20171214211344404-373311729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;10、流程控制之判断&lt;/h2&gt;
&lt;p&gt;在现实中，我们往往由很多种选择，比如说走路遇到分叉口，我们只能选择走一条路，程序也是一样，如果遇到分支，就用if语句控制流程&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
if&lt;span readability=&quot;1.5&quot;&gt; 条件判断:   #条件判断可以是比较运算，逻辑运算，以及布尔运算   
    执行语句
else&lt;span readability=&quot;3&quot;&gt;:
    执行语句&lt;p&gt;#注意：if  以及else 后都由一个分号 ':'&lt;br/&gt;#　　　if 以及else 下面的一段执行语句必须缩进&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
name = input('请输入用户名：'&lt;span&gt;)
password = input('请输入您的密码'&lt;span&gt;)
    if name == 'fuyong' and password == '123'&lt;span&gt;:
        print('恭喜您，登录成功'&lt;span&gt;)
    else&lt;span&gt;:
        print('抱歉，用户名或者密码错误！')&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　if语句可以嵌套使用，如上面的代码可以改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
name = input('请输入用户名：'&lt;span&gt;)
password = input('请输入您的密码'&lt;span&gt;)
    if name == 'fuyong'&lt;span&gt; :
            if password == '123'
                print('恭喜您，登录成功'&lt;span&gt;)
    else&lt;span&gt;:
        print('抱歉，用户名或者密码错误！')        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　if else也可以由多个分支判断，用elif表示，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
num = input('请输入一个数字'&lt;span&gt;):

if num == 1&lt;span&gt;:
    
    print(&quot;您选择的是1号&quot;&lt;span&gt;)

elif  num == 2&lt;span&gt;:
    
    print(&quot;您选择的是2号&quot;&lt;span&gt;)

elif num == 3&lt;span&gt;:
    
    print('您选择的是3号'&lt;span&gt;)

else&lt;span&gt;:
       print('输入有误，请在1、2、3中选择')&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;code class=&quot;lang-py&quot;&gt; 　　11、流程控制之循环　　　　&lt;br/&gt;&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;hljs-number&quot;&gt;　　 　　在写程序的过程中，有时候我们需要一段代码反复执行许多次，如果每次都重复写很多次，代码不但会占用很多篇幅，而且会变得非常不美观，这不符合python的‘优雅、明确、简洁’的宗旨，这个时候我们只需要用一个循环语句即可解决问题。格式为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
while&lt;span&gt; 判断条件: #与判断语句if一样，判断条件可以是比较运算，逻辑运算，以及布尔运算   &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　循环体 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们通过判断条件控制循环的次数，如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
n =&lt;span&gt; 0
while n &amp;lt; 3
    print(&quot;这段话将被执行3次&quot;&lt;span&gt;)
    n = n+1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以通过关键字break 、continue来终止循环&lt;/p&gt;
&lt;p&gt;　　break是跳出整个循环，直接执行循环体外面的代码&lt;/p&gt;
&lt;p&gt;　　continue是跳出本次循环，重新返回循环的开头&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
count =&lt;span&gt; 0

while&lt;span&gt; True:
    print(&quot;如果不是count，我就会一直打印下去，直到你的电脑爆炸为止&quot;&lt;span&gt;)
    
    if count == 5&lt;span&gt;:
        break&lt;span&gt;
    
    count = count + 1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的例子可以看到，只要出现break，不管判断条件是否依然为True，循环都要立即终止&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 1 n =&lt;span&gt; 0
 2 
 3 while n &amp;lt; 10&lt;span&gt;:
 4 
 5     n = n+1
 6 
 7     if n == 4&lt;span&gt; :
 8 
 9         continue
10         
11     print(n,&quot;就是不愿意打印'4'&quot;&lt;span&gt;)
12 
13     
14         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码执行结果为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 1 1 就是不愿意打印'4'
 2 2 就是不愿意打印'4'
 3 3 就是不愿意打印'4'
 4 5 就是不愿意打印'4'
 5 6 就是不愿意打印'4'
 6 7 就是不愿意打印'4'
 7 8 就是不愿意打印'4'
 8 9 就是不愿意打印'4'
 9 10 就是不愿意打印'4'
10 &amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的例子可以看出，出现了continue，就会跳出本次循环，但是还会跳到循环体的第一句，来判断条件是否为True&lt;/p&gt;

&lt;p&gt;　　其他的语言中的else一般只与if搭配，而python中，else还可以搭配while，格式为：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 while&lt;span&gt; 条件判断:
2 
3 &lt;span&gt;　　　　循环体
4 else&lt;span&gt;:
5 
6 　　　　如果循环正常执行完毕，没有被break终止，则会执行本段代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;h2&gt;1、使用while循环输入 1 2 3 4 5 6     8 9 10&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 1 count =&lt;span&gt; 0
 2 
 3 while count &amp;lt; 10&lt;span&gt;:
 4 
 5     count = count + 1
 6     
 7     if count == 7&lt;span&gt;:
 8         continue
 9     
10     print(count)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2、求1-100的所有数的和&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 1 count =&lt;span&gt; 0
 2 
 3 sum =&lt;span&gt; 0
 4 
 5 while count &amp;lt; 100&lt;span&gt;:
 6 
 7     count = count + 1
 8 
 9     sum = sum +&lt;span&gt; count
10 
11 print(sum)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3、输出 1-100 内的所有奇数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 1 count =&lt;span&gt; 0
 2 
 3 
 4 while count &amp;lt; 100&lt;span&gt;:
 5 
 6     count = count + 1
 7 
 8     if count % 2 == 1&lt;span&gt;:
 9         print&lt;span&gt;(count)
10         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4、输出 1-100 内的所有偶数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 1 count =&lt;span&gt; 0
 2 
 3 
 4 while count &amp;lt; 100&lt;span&gt;:
 5 
 6     count = count + 1
 7 
 8     if count % 2 ==&lt;span&gt; 0:
 9         print&lt;span&gt;(count)
10         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5、求1-2+3-4+5 ... 99的所有数的和&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 1 count =&lt;span&gt; 0
 2 sum =&lt;span&gt; 0
 3 
 4 while count &amp;lt; 99&lt;span&gt;:
 5 
 6     count = count + 1
 7 
 8     if count % 2 == 0: #如果是偶数的话，运算符号即为+
 9         sum = sum-&lt;span&gt;count
10 
11     else&lt;span&gt;:
12         sum = sum + count#如果是奇数的话，运算符号即为-
13 
14 print&lt;span&gt;(sum)
15         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;6、用户登陆（三次机会重试）&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 count =&lt;span&gt; 0
 2 
 3 while&lt;span&gt; True:
 4 
 5     name = input('请输入您的用户名：'&lt;span&gt;)
 6     password = input('请输入您的密码：'&lt;span&gt;)
 7 
 8     if name == 'fuyong' and password == '123'&lt;span&gt;:
 9         print('恭喜您，登录成功！'&lt;span&gt;)
10 
11         break
12 
13     else&lt;span&gt;:
14         print('用户名或者密码错误，请重新输入：'&lt;span&gt;)
15 
16         count = count + 1
17 
18     if count == 3&lt;span&gt;:
19         print('对不起，您以及输入错误3次，登录程序终止'&lt;span&gt;)
20 
21         break&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 18 Dec 2017 14:56:00 +0000</pubDate>
<dc:creator>人生不如戏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fu-yong/p/8060188.html</dc:identifier>
</item>
<item>
<title>讲讲共线性问题 - JSong</title>
<link>http://www.cnblogs.com/gasongjian/p/8060086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gasongjian/p/8060086.html</guid>
<description>&lt;p&gt;作者：JSong，时间：2017.12.18，公众号：JSong老师&lt;/p&gt;
&lt;p&gt;多重共线性是使用线性回归算法时经常要面对的一个问题。在其他算法中，例如决策树和贝叶斯，前者的建模过程是逐步递进，每次拆分只有一个变量参与，这种建模机制含有抗多重共线性干扰的功能；后者干脆假定变量之间是相互独立的，因此从表面上看，也没有多重共线性的问题。但是对于回归算法，不论是一般回归，逻辑回归，或存活分析，都要同时考虑多个预测因子，因此多重共线性是不可避免需要面对的，在很多时候，多重共线性是一个普遍的现象。在构造预测模型时如何处理多重共线性是一个比较微妙的议题。既不能不加控制，又不能一刀切，认为凡是多重共线性就应该消除。&lt;/p&gt;
&lt;h2 id=&quot;共线性的原理&quot;&gt;1、共线性的原理&lt;/h2&gt;
&lt;p&gt;假设有k个自变量的多元线性回归模型：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[y=\theta_0+\theta_1x_1+\cdots+\theta_kx_k+\varepsilon=X\theta+\varepsilon\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中误差项是一个期望值为0且服从正态分布的随机变量：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\varepsilon\sim\mathcal{N}(0,\sigma^2)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则利用最小二乘法可得参数的估计值为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\theta}=X^{\dagger}y=(X^TX)^{-1}X^Ty\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该求解公式唯一的条件是矩阵X是列满秩的，不然会有无穷多解：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\theta}=X^{\dagger}y+(I-X^{\dagger}X)\xi\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当各变量之间存在共线性问题，即各变量之间存在部分线性相关时，例如：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[x_3=x_2+x_1+\varepsilon\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;易知此时X近乎是不满秩的（实际情况很难完全共线性），X^TX近乎是奇异的，X的最小奇异值会非常小，那它的影响到底有多大呢？我们先从&lt;strong&gt;矩阵计算&lt;/strong&gt;的角度来看。&lt;/p&gt;
&lt;h3 id=&quot;扰动分析&quot;&gt;1.1 扰动分析&lt;/h3&gt;
&lt;p&gt;对于一个方程或者系统而言，当输入有一个非常微小的扰动时，我们希望方程或系统的输出变化也非常微小，如果输出的变化非常大，且不能被控制，那这个系统的预测就无效了，蝴蝶效应讲的就是这个。在矩阵计算中，这叫做&lt;strong&gt;扰动分析&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;【&lt;strong&gt;扰动分析定理&lt;/strong&gt;】设非奇异方阵A满足方程&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Ax=y\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;它的精确解为 &lt;span class=&quot;math inline&quot;&gt;\(x^{*}\)&lt;/span&gt;，当A存在一个小扰动时，假设 &lt;span class=&quot;math inline&quot;&gt;\(\hat{x}\)&lt;/span&gt; 是新方程的解：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(A+\delta\,A)\hat{x}=y\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以证明 &lt;span class=&quot;math inline&quot;&gt;\(x^*\)&lt;/span&gt; 的扰动满足：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{||\delta\,x||}{||\hat{x}||}\leq\kappa(A)\frac{||\delta\,A||}{||A||}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看到矩阵的条件数越大，扰动就越大，即x的求解值会变得非常不准确。回到上面讲的线性回归问题，容易证明最小二乘法的解满足下面的正定方程：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[X^{T}X\hat{\theta}=X^{T}y\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\kappa(X^{T}X)=\frac{\lambda_{max}(X^{T}X)}{\lambda_{min}(X^{T}X)}=\frac{\sigma^2_{max}(X)}{\sigma^2_{min}(X)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当方程有共线性问题时，X的最小特征值非常小，相应的，上述的条件数会非常大。也就是说机器学习中的共线性问题实际上就是矩阵计算中的条件数问题。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从实际应用的角度，一般若K&amp;lt;100，则认为多重共线性的程度很小，若是100&amp;lt;=K&amp;lt;=1000，则认为存在一般程度上的多重共线性，若是K&amp;gt;1000，则就认为存在严重的多重共线性。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;方差分析&quot;&gt;1.2 方差分析&lt;/h3&gt;
&lt;p&gt;再从统计学的角度来看共线性。可以证明参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;的协方差矩阵为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Var(\hat{\theta})=Var(\hat{\theta}-\theta)=Var[(X^TX)^{-1}X^T\varepsilon]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;又对任意的常数矩阵A和随机变量x有&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Var(Ax)=A\cdot\,Var(x)\cdot\,A^T\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代入上式即可得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Var(\hat{\theta})=\sigma^2(X^{T}X)^{-1}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;具体到每个参数，有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Var(\hat{\theta_i})=\frac{\sigma^2}{(n-1)Var(x_j)}\cdot\frac{1}{1-R_i^2}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(R_i^2\)&lt;/span&gt;是将第i个变量&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;作为因变量，其他k-1个变量作为自变量进行线性回归获得的&lt;span class=&quot;math inline&quot;&gt;\(R^2\)&lt;/span&gt;，且令&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\text{VIF}_i=\frac{1}{1-R_i^2}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为&lt;strong&gt;方差膨胀因子&lt;/strong&gt;(variance inflation factor，VIF)。当&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[R_i^2\longrightarrow\,1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;时，即当第i个变量和其他变量之间存在线性关系时，VIF趋于无穷大。所以 VIF 的大小反应了变量的共线性程度。一般地，当VIF大于5或10时，认为模型存在严重的共线性问题。&lt;/p&gt;
&lt;p&gt;同时考虑参数显著性检验的 &lt;strong&gt;t 统计量&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[t=\frac{\hat{\theta_i}}{std(\hat{\theta_i})}\sim\,t(n-k-1)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当存在共线性时，参数的标准差偏大，相应的 &lt;strong&gt;t 统计量&lt;/strong&gt; 会偏小，这样容易淘汰一些不应淘汰的解释变量，使统计检验的结果失去可靠性。&lt;/p&gt;
&lt;p&gt;另外考虑线性回归的残差&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\varepsilon}=y-X\hat{\theta}=M\varepsilon\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中M是一个投影矩阵，且满足&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[M=I-X(X^{T}X)^{-1}X^{T}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;易证明&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[||\hat{\varepsilon}||_{2}^{2}=\varepsilon^{T}M\varepsilon\leq||M||_F^2\cdot||\varepsilon||_2^2=(n-k)||\varepsilon||_2^2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而矩阵M的范数与X的条件数毫无关系，于是可以得出&lt;strong&gt;共线性并不影响模型的训练精度&lt;/strong&gt;。但是对于泛化精度，由于参数的估计已经不准确啦，所以泛化误差肯定要差些，具体差多少，我还很难用公式表示出来。&lt;/p&gt;
&lt;p&gt;总结一下，共线性问题对线性回归模型有如下影响：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参数的方差增大；&lt;/li&gt;
&lt;li&gt;难以区分每个解释变量的单独影响；&lt;/li&gt;
&lt;li&gt;变量的显著性检验失去意义；&lt;/li&gt;
&lt;li&gt;回归模型缺乏稳定性。样本的微小扰动都可能带来参数很大的变化；&lt;/li&gt;
&lt;li&gt;影响模型的泛化误差。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;共线性问题的解决方法&quot;&gt;2、共线性问题的解决方法&lt;/h2&gt;
&lt;p&gt;根据上一节的描述，共线性问题有如下几种检验方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;相关性分析&lt;/strong&gt;。检验变量之间的相关系数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方差膨胀因子VIF&lt;/strong&gt;。当VIF大于5或10时，代表模型存在严重的共线性问题；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;条件数检验&lt;/strong&gt;。当条件数大于100、1000时，代表模型存在严重的共线性问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当变量数不多，样本数不是很大时，上述的方法是没问题的，检验某个变量有共线性问题时，可以结合实际业务考虑直接剔除该变量。但是有的时候变量数大到有上千个，VIF的计算需要建立上千个回归模型（条件数仅能判定是否存在共线性，但不能找到对应的变量），这将耗费很长时间。&lt;/p&gt;
&lt;p&gt;事实上我们可以从模型角度来直接规避共线性问题。&lt;/p&gt;
&lt;h3 id=&quot;pca等降维法&quot;&gt;2.1 PCA等降维法&lt;/h3&gt;
&lt;p&gt;主成分分析法作为多元统计分析的一种常用方法在处理多变量问题时具有其一定的优越性，其降维的优势是明显的，主成分回归方法对于一般的多重共线性问题还是适用的，尤其是对共线性较强的变量之间。当采取主成分提取了新的变量后，往往这些变量间的组内差异小而组间差异大，起到了消除共线性的问题。&lt;/p&gt;
&lt;h3 id=&quot;逐步回归法&quot;&gt;2.2 逐步回归法&lt;/h3&gt;
&lt;p&gt;逐步回归（Stepwise Regression）是一种常用的消除多重共线性、选取“最优”回归方程的方法。其做法是将逐个引入自变量，引入的条件是该自变量经F检验是显著的，每引入一个自变量后，对已选入的变量进行逐个检验，如果原来引入的变量由于后面变量的引入而变得不再显著，那么就将其剔除。引入一个变量或从回归方程中剔除一个变量，为逐步回归的一步，每一步都要进行F 检验，以确保每次引入新变量之前回归方程中只包含显著的变量。这个过程反复进行，直到既没有不显著的自变量选入回归方程，也没有显著自变量从回归方程中剔除为止。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第一&lt;/strong&gt;：建立全部变量的回归方程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二&lt;/strong&gt;：分别建立单独的回归方程，依照t检验和拟合度依次加入各变量来构建回归方程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三&lt;/strong&gt;：判断新引入的变量，对于之前的系数影响是否显著，是否符合实际以及对于拟合度的变量，来选择是否将变量引入模型中。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;岭回归l2正则化ridge-regression&quot;&gt;2.3 岭回归、L2正则化(ridge regression)&lt;/h3&gt;
&lt;p&gt;岭回归是一种可用于共线性数据分析的有偏估计回归方法，它是一种改良的最小二乘估计法，通过放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价获得回归系数更为符合实际、更可靠的回归方法，对条件数很大（病态数据）的拟合要强于最小二乘法。&lt;/p&gt;
&lt;p&gt;在线性回归问题中，最小二乘法实际上是最小化问题：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\theta}=\arg_{\theta}\min||X\theta-y||^2_2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而岭回归则是加入了L2惩罚项：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\theta}=\arg_{\theta}\min||X\theta-y||^2_2+C||\theta||^2_2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样参数的方差不会过大，且随着惩罚项系数C的增大，共线性的影响将越来也小。在这个过程中，可以记录 &lt;span class=&quot;math inline&quot;&gt;\(\theta(k)\)&lt;/span&gt; (岭迹)的变化情况，通过对岭迹的波动来判断我们是否要剔除该变量。&lt;/p&gt;
&lt;p&gt;那为什么说岭回归能解决共线性问题呢？从矩阵计算的角度来看，L2正则化下方程的解为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\theta}=(X^{T}X+CI)^{-1}X^{T}y\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在上一节我们讲到共线性代表正定矩阵X^T^X的条件数很大:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\kappa(X^{T}X)=\frac{\lambda_{max}(X^{T}X)}{\lambda_{min}(X^{T}X)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而当条件数很大时，矩阵的逆的数值计算也是非常不准确的，但是当我们给矩阵加上一个单位矩阵时，奇异性（不可逆）问题就完全没有啦。&lt;/p&gt;
&lt;p&gt;进一步考虑对惩罚项对奇异值的影响，假设X的奇异值（SVD）分解为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[X=U\Sigma\,V^{T}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则容易证明&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\theta}=(X^{T}X+CI)^{-1}X^{T}y=VDU^{T}y\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中D是对角矩阵，且满足&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[D_{ii}=\frac{\sigma_i}{\sigma_i^2+C}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其反应了惩罚项是如何影响到条件数的。&lt;/p&gt;
&lt;h3 id=&quot;lasso回归&quot;&gt;2.4 LASSO回归&lt;/h3&gt;
&lt;p&gt;LASSO回归和岭回归类似，只不过将惩罚项由L2范数改为了L1范数&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\theta}=\arg_{\theta}\min||X\theta-y||^2_2+C||\theta||^2_1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;L1范数没有L2范数那么圆润，毕竟存在不可导点，而且在L1范数下LASSO回归也给不出解析解啦，但是相对于岭回归，LASSO估计的参数能更容易收敛到0&lt;/p&gt;
&lt;h3 id=&quot;elasticnet回归等&quot;&gt;2.5 ElasticNet回归等&lt;/h3&gt;
&lt;p&gt;ElasticNet回归同时兼顾了L1和L2惩罚项：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\theta}=\arg_{\theta}\min||X\theta-y||^2_2+C_1||\theta||^2_1+C_2||\theta||^2_2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当许多变量是相关的时候，Elastic-net是有用的。Lasso一般会随机选择其中一个，而Elastic-net则会选在两个。&lt;/p&gt;
&lt;p&gt;除此之外，还有L0范数（非零元的个数）、L1/2范数等。&lt;/p&gt;
&lt;h2 id=&quot;python实践&quot;&gt;3、Python实践&lt;/h2&gt;
&lt;p&gt;首先捏造一份好的数据，样本量为100，特征数为8，且满足方程：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[y=5x_0+6x_1+7x_2+8x_3+9x_4+10x_5+11x_6+12x_7+\varepsilon\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中误差项是期望为0，标准差为1.5的正态分布随机变量。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;30&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; np
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; sklearn.linear_model &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; LinearRegression
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; sklearn &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; cross_validation

coef0&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;np.array([&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;])
X1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;np.random.rand(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)
y&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;np.dot(X1,coef0)&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;np.random.normal(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;1.5&lt;/span&gt;,size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)
training&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;np.random.choice([&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;,&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;],p&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;fl&quot;&gt;0.8&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;],size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)
lr1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;LinearRegression()
lr1.fit(X1[training],y[training])
&lt;span class=&quot;co&quot;&gt;# 系数的均方误差MSE&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(((lr1.coef_&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;coef0)&lt;span class=&quot;op&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;).&lt;span class=&quot;bu&quot;&gt;sum&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;# 测试集准确率（R2）&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(lr1.score(X1[&lt;span class=&quot;op&quot;&gt;~&lt;/span&gt;training],y[&lt;span class=&quot;op&quot;&gt;~&lt;/span&gt;training]))
&lt;span class=&quot;co&quot;&gt;# 平均测试集准确率&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(cross_validation.cross_val_score(lr1,X1,y,cv&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;).mean())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时平均准确率为0.934955，拟合的系数MSE为0.203657&lt;/p&gt;
&lt;p&gt;然后我们基于这份数据另外构造出两份数据，第二份数据增加两个随机的特征用作对比，第一份数据则增加两个共线性特征：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[x_8=x_0+x_1+\varepsilon\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[x_9=x_1+x_2+x_3+\varepsilon\]&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;27&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;X2&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;np.column_stack([X1,np.dot(X1[:,[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]],np.array([&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]))&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;np.random.normal(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;0.05&lt;/span&gt;,size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)])
X2&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;np.column_stack([X2,np.dot(X2[:,[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]],np.array([&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]))&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;np.random.normal(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;0.05&lt;/span&gt;,size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)])
X3&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;np.column_stack([X1,np.random.rand(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先来看下它们的条件数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(np.linalg.cond(X1))
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(np.linalg.cond(X2))
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(np.linalg.cond(X3))
&lt;span class=&quot;fl&quot;&gt;6.29077685383&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;110.930612408&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;7.25066276479&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到X2的条件数很搭，最小奇异值为0.213，此时还不至于完全共线性。&lt;/p&gt;
&lt;p&gt;拿这两份数据重新用线性回归拟合模型。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;lr2&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;LinearRegression()
lr2.fit(X2[training],y[training])
&lt;span class=&quot;co&quot;&gt;# 系数的均方误差MSE&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(((lr2.coef_[:&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;coef0)&lt;span class=&quot;op&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;).&lt;span class=&quot;bu&quot;&gt;sum&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;# 测试集准确率（R2）&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(lr2.score(X2[&lt;span class=&quot;op&quot;&gt;~&lt;/span&gt;training],y[&lt;span class=&quot;op&quot;&gt;~&lt;/span&gt;training]))
&lt;span class=&quot;co&quot;&gt;# 平均测试集准确率&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(cross_validation.cross_val_score(lr2,X2,y,cv&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;).mean())


lr3&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;LinearRegression()
lr3.fit(X3[training],y[training])
&lt;span class=&quot;co&quot;&gt;# 系数的均方误差MSE&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(((lr3.coef_[:&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;coef0)&lt;span class=&quot;op&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;).&lt;span class=&quot;bu&quot;&gt;sum&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;# 测试集准确率（R2）&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(lr3.score(X3[&lt;span class=&quot;op&quot;&gt;~&lt;/span&gt;training],y[&lt;span class=&quot;op&quot;&gt;~&lt;/span&gt;training]))
&lt;span class=&quot;co&quot;&gt;# 平均测试集准确率&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(cross_validation.cross_val_score(lr3,X3,y,cv&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;).mean())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于第二份共线性构造数据X2，有平均测试集准确率为0.932070，拟合的参数MSE为7.697837。可以看到MSE增加了很多，准确率也下降了0.2%，测试拟合的系数为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(lr2.coef_)
[ &lt;span class=&quot;fl&quot;&gt;10.506618&lt;/span&gt;    &lt;span class=&quot;fl&quot;&gt;11.467777&lt;/span&gt;     &lt;span class=&quot;fl&quot;&gt;6.35562175&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;7.56698262&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;9.44509206&lt;/span&gt;
   &lt;span class=&quot;fl&quot;&gt;9.81032939&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;11.66187822&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;12.29728702&lt;/span&gt;  &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;5.07439399&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.02649089&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在来看对比用的数据X3，其平均测试集准确率为0.934952，参数MSE为0.171651，与X1无异。&lt;/p&gt;
&lt;p&gt;以上是直接的结果，我们再来看VIF&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; plt
clf&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;LinearRegression()
vif2&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;np.zeros((&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;):
    tmp&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[k &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;) &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; k&lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt;i]
    clf.fit(X2[:,tmp],X2[:,i])
    vifi&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;clf.score(X2[:,tmp],X2[:,i]))
    vif2[i]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;vifi

vif3&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;np.zeros((&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;):
    tmp&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[k &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;) &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; k&lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt;i]
    clf.fit(X3[:,tmp],X3[:,i])
    vifi&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;clf.score(X3[:,tmp],X3[:,i]))
    vif3[i]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;vifi  
plt.figure()
ax &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; plt.gca()
ax.plot(vif2)
ax.plot(vif3)
plt.xlabel(&lt;span class=&quot;st&quot;&gt;'feature'&lt;/span&gt;)
plt.ylabel(&lt;span class=&quot;st&quot;&gt;'VIF'&lt;/span&gt;)
plt.title(&lt;span class=&quot;st&quot;&gt;'VIF coefficients of the features'&lt;/span&gt;)
plt.axis(&lt;span class=&quot;st&quot;&gt;'tight'&lt;/span&gt;)
plt.show()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到第0、1、2、3、8、9个特征的VIF都过高。且可以看出第1个特征相对第0、2、3个特征的VIF较高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/802399/201712/802399-20171218222933521-648044465.png&quot; alt=&quot;10个特征的VIF&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们试着用模型的方法来检测共线性问题&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; sklearn.linear_model &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Ridge
plt.figure()
n_alphas &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;
alphas &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.logspace(&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,num&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;n_alphas)
coefs &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; a &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; alphas:
    ridge &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Ridge(alpha&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;a, fit_intercept&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;)
    ridge.fit(X2, y)
    coefs.append(ridge.coef_)
ax &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; plt.gca()
ax.plot(alphas, coefs)
ax.set_xscale(&lt;span class=&quot;st&quot;&gt;'log'&lt;/span&gt;)
handles, labels &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; ax.get_legend_handles_labels()
plt.legend(labels&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;])
plt.xlabel(&lt;span class=&quot;st&quot;&gt;'alpha'&lt;/span&gt;)
plt.ylabel(&lt;span class=&quot;st&quot;&gt;'weights'&lt;/span&gt;)
plt.title(&lt;span class=&quot;st&quot;&gt;'Ridge coefficients as a function of the regularization'&lt;/span&gt;)
plt.axis(&lt;span class=&quot;st&quot;&gt;'tight'&lt;/span&gt;)
plt.show()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/802399/201712/802399-20171218223003084-1662665008.png&quot; alt=&quot;岭回归各个系数的岭迹&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中当alpha取0.1时，岭回归估计的系数分别为&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(coefs[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;])
[  &lt;span class=&quot;fl&quot;&gt;2.70748655&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.95748918&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;3.53687372&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;5.2073456&lt;/span&gt;    &lt;span class=&quot;fl&quot;&gt;8.70186695&lt;/span&gt;
   &lt;span class=&quot;fl&quot;&gt;9.84484102&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;10.67351759&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;11.74614246&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;2.46502016&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;3.19919212&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到第0、1、2、3、8、9个变量都出现了波动，代表它们之间存在一定的共线性。观察岭迹，我们可以考虑剔除其中波动比较大的第1、8、9个变量。&lt;/p&gt;
&lt;p&gt;另外Lasso回归类似，可以用sklearn中的linear_model.Lasso来学习，这里就不展示了。最后对于逻辑回归任务，sklearn函数内部提供了L1或L2正则化方案，通过它们也可以去检测共线性问题。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;[1]. &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance_inflation_factor&quot;&gt;variance inflation factor&lt;/a&gt;&lt;br/&gt;[2]. &lt;a href=&quot;http://blog.csdn.net/liunian920305/article/details/73456741&quot;&gt;多重共线性的解决方法之——岭回归与LASSO&lt;/a&gt;&lt;br/&gt;[3]. &lt;a href=&quot;https://en.wikipedia.org/wiki/Tikhonov_regularization&quot;&gt;[ridge regression](https://en.wikipedia.org/wiki/Tikhonov_regularization)&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/802399/201712/802399-20171218223237084-1902603738.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Dec 2017 14:31:00 +0000</pubDate>
<dc:creator>JSong</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gasongjian/p/8060086.html</dc:identifier>
</item>
<item>
<title>Scala入门系列（十一）：模式匹配 - 小丑进场</title>
<link>http://www.cnblogs.com/LiCheng-/p/8060059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LiCheng-/p/8060059.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-8048&quot; readability=&quot;15&quot;&gt;
&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;模式匹配是Scala中非常有特色，非常强大的一种功能。&lt;/p&gt;
&lt;p&gt;类似于Java中的switch case语法，但是模式匹配的功能要比它强大得多，switch只能对值进行匹配，但是&lt;strong&gt;Scala的模式匹配除了可以对值进行匹配之外，还可以对类型进行匹配、对Array和List的元素情况进行匹配、对case class进行匹配甚至对有值或没值(Option)进行匹配&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而且在Spark源码中也大量地使用了模式匹配功能。因此为了更好地编写Scala程序，并且更加通畅地看懂Spark源码，学好模式匹配是非常重要的。&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8049&quot; readability=&quot;10&quot;&gt;
&lt;h2&gt;基础语法&lt;/h2&gt;
&lt;p&gt;match case的语法如下：&lt;code&gt;变量 match { case 值 =&amp;gt; 代码}&lt;/code&gt;。如果值为下划线，则代表不满足以上所有情况下的默认情况如何处理。此外，match case中，只要一个case分支满足并处理了，就不会继续判断下一个case分支了。（这一点与java不同，java的switch case需要用break阻止）&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;
&lt;h3&gt;对变量值进行匹配&lt;/h3&gt;
&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-8051&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 案例：成绩评价&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;judgeGrade&lt;/span&gt;&lt;/span&gt;(grade: &lt;span&gt;String&lt;/span&gt;) {&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;grade &lt;span&gt;match&lt;/span&gt; {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;A&quot;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Excellent&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;B&quot;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Good&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;C&quot;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Just so so&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt; println(&lt;span&gt;&quot;you need work harder&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;judgeGrade: (grade: &lt;span&gt;String&lt;/span&gt;)&lt;span&gt;Unit&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;scala&amp;gt; judgeGrade(&lt;span&gt;&quot;E&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;you need work harder&lt;/p&gt;

&lt;p&gt;scala&amp;gt; judgeGrade(&lt;span&gt;&quot;B&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Good&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;
&lt;h3&gt;在模式匹配中使用if守卫&lt;/h3&gt;
&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-8053&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 案例：成绩评价（升级版）&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;def &lt;span&gt;judgeGrade&lt;/span&gt;&lt;span&gt;(name: String, grade: String)&lt;/span&gt;&lt;/span&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;grade match {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;A&quot;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Excellent&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;B&quot;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Good&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;C&quot;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Just so so&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; _ &lt;span&gt;if&lt;/span&gt; name == &lt;span&gt;&quot;leo&quot;&lt;/span&gt; =&amp;gt; println(name + &lt;span&gt;&quot;, you are a good boy, come on&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt; println(&lt;span&gt;&quot;you need to work harder&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;judgeGrade: (name: String, grade: String)Unit&lt;/p&gt;

&lt;p&gt;scala&amp;gt; judgeGrade(&lt;span&gt;&quot;leo&quot;&lt;/span&gt;, &lt;span&gt;&quot;E&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;leo, you are a good boy, come on&lt;/p&gt;

&lt;p&gt;scala&amp;gt; judgeGrade(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;, &lt;span&gt;&quot;E&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;you need to work harder&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8054&quot; readability=&quot;9&quot;&gt;
&lt;h3&gt;在模式匹配中进行变量赋值&lt;/h3&gt;
&lt;p&gt;模式匹配中可以将默认情况即下划线替换为一个变量名，这样模式匹配语法就会将要匹配的值赋值给这个变量，从而可以在后面的处理语句中使用要匹配的值。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8055&quot; readability=&quot;29&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 案例：成绩评价（升级版）&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;judgeGrade&lt;/span&gt;&lt;/span&gt;(grade: &lt;span&gt;String&lt;/span&gt;){&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;grade &lt;span&gt;match&lt;/span&gt; {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;A&quot;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;you got A grade, excellent!&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;B&quot;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;you got B grade, good&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;C&quot;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;you got C grade, so so&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; badGrade =&amp;gt; println(&lt;span&gt;&quot;you got &quot;&lt;/span&gt; + badGrade + &lt;span&gt;&quot;grade, i hope that you can get C next time&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;judgeGrade: (grade: &lt;span&gt;String&lt;/span&gt;)&lt;span&gt;Unit&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;scala&amp;gt; judgeGrade(&lt;span&gt;&quot;E&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;you got &lt;span&gt;Egrade&lt;/span&gt;, i hope that you can get &lt;span&gt;C&lt;/span&gt; next time&lt;/p&gt;

&lt;p&gt;scala&amp;gt; judgeGrade(&lt;span&gt;&quot;F&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;you got &lt;span&gt;Fgrade&lt;/span&gt;, i hope that you can get &lt;span&gt;C&lt;/span&gt; next time&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8056&quot; readability=&quot;10&quot;&gt;
&lt;h2&gt;类型匹配&lt;/h2&gt;
&lt;p&gt;Scala的模式匹配强大之处就在于可以直接匹配类型而不仅仅是值，这也是Java中switch case绝对做不到的。&lt;/p&gt;
&lt;p&gt;匹配类型的语法为&lt;code&gt;case 变量 : 类型 =&amp;gt; 代码&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8057&quot; readability=&quot;29&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 案例：异常处理&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.io._&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;processException&lt;/span&gt;&lt;/span&gt;(e: &lt;span&gt;Exception&lt;/span&gt;){&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;e &lt;span&gt;match&lt;/span&gt; {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; e1:&lt;span&gt;IllegalArgumentException&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;you passed illegal argument, exception is : &quot;&lt;/span&gt; +e1)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; e2:&lt;span&gt;IOException&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;you got an error while doing IO operation!&quot;&lt;/span&gt; + e2)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; _:&lt;span&gt;Exception&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;cannot know which exception you have&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;processException: (e: &lt;span&gt;Exception&lt;/span&gt;)&lt;span&gt;Unit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 测试能否匹配类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; processException(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalArgumentException&lt;/span&gt;(&lt;span&gt;&quot;expect two arguments, but found only one&quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;you passed illegal argument, exception is : java.lang.&lt;span&gt;IllegalArgumentException&lt;/span&gt;: expect two arguments&lt;/p&gt;
&lt;p&gt;, but found only one&lt;/p&gt;

&lt;p&gt;scala&amp;gt; processException(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayIndexOutOfBoundsException&lt;/span&gt;(&lt;span&gt;&quot;array is null.&quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;cannot know which exception you have&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8058&quot; readability=&quot;8&quot;&gt;
&lt;h2&gt;对Array和List的元素进行匹配&lt;/h2&gt;
&lt;p&gt;对Array进行模式匹配，分别可以匹配带有指定元素的数组、带有指定个数的数组、以某元素打头的数组。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8059&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;def &lt;span&gt;greeting&lt;/span&gt;&lt;span&gt;(arr: Array[String])&lt;/span&gt;&lt;/span&gt; {&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;arr match {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;Leo&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Hi, Leo!&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&lt;span&gt;(girl1,girl2,girl3)&lt;/span&gt;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Hi, girls, may I know you name? &quot;&lt;/span&gt;+girl1+&lt;span&gt;&quot; &quot;&lt;/span&gt;+girl2+&lt;span&gt;&quot; &quot;&lt;/span&gt;+&lt;/p&gt;
&lt;p&gt;girl3)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;Leo&quot;&lt;/span&gt;, _*)&lt;/span&gt;&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Hi, leo, please introduce your friends to me.&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt; println(&lt;span&gt;&quot;hey, who are you?&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;greeting: (arr: Array[String])Unit&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; greeting(Array(&lt;span&gt;&quot;Leo&quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;Hi, Leo!&lt;/p&gt;

&lt;p&gt;scala&amp;gt; greeting(Array(&lt;span&gt;&quot;jen&quot;&lt;/span&gt;, &lt;span&gt;&quot;Alice&quot;&lt;/span&gt;, &lt;span&gt;&quot;lory&quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;Hi, girls, may I know you name? jen Alice lory&lt;/p&gt;

&lt;p&gt;scala&amp;gt; greeting(Array(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;hey, who are you?&lt;/p&gt;
&lt;p&gt;  &lt;br/&gt;对List进行模式匹配，与Array类似，但是需要使用List特有的 &lt;code&gt;::&lt;/code&gt; 操作符。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8060&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;greeting&lt;/span&gt;&lt;/span&gt;(list: &lt;span&gt;List&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;]){&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;list &lt;span&gt;match&lt;/span&gt; {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;Leo&quot;&lt;/span&gt; :: &lt;span&gt;Nil&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Hi, Leo!&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; girl1 :: girl2 :: girl3 ::&lt;span&gt;Nil&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Hi, girls, nice to meet you.&quot;&lt;/span&gt; + girl1 + &lt;span&gt;&quot; &quot;&lt;/span&gt; + gir&lt;/p&gt;
&lt;p&gt;l2 + &lt;span&gt;&quot; &quot;&lt;/span&gt; + girl3)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;Leo&quot;&lt;/span&gt; :: tail =&amp;gt; println(&lt;span&gt;&quot;Hi, Leo, please introduce your friends to me.&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt; println(&lt;span&gt;&quot;hey, who are you?&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;greeting: (list: &lt;span&gt;List&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;])&lt;span&gt;Unit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; greeting(&lt;span&gt;List&lt;/span&gt;(&lt;span&gt;&quot;Leo&quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hi&lt;/span&gt;, &lt;span&gt;Leo&lt;/span&gt;!&lt;/p&gt;

&lt;p&gt;scala&amp;gt; greeting(&lt;span&gt;List&lt;/span&gt;(&lt;span&gt;&quot;Marry&quot;&lt;/span&gt;, &lt;span&gt;&quot;Alice&quot;&lt;/span&gt;, &lt;span&gt;&quot;lory&quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hi&lt;/span&gt;, girls, nice to meet you.&lt;span&gt;Marry&lt;/span&gt; &lt;span&gt;Alice&lt;/span&gt; lory&lt;/p&gt;

&lt;p&gt;scala&amp;gt; greeting(&lt;span&gt;List&lt;/span&gt;(&lt;span&gt;&quot;Sparks&quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;hey, who are you?&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8061&quot; readability=&quot;15&quot;&gt;
&lt;h2&gt;case class匹配&lt;/h2&gt;
&lt;p&gt;Scala中提供了一种特殊的类，用case class进行声明，中文也可以称作样例类。&lt;strong&gt;case class其实有点类似于Java中的JavaBean的概念。即只定义field，并且由Scala编译时自动提供getter和setter方法，但是没有method&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;case class的主构造函数接收的参数通常不需要使用val或var修饰，Scala自动就会使用val修饰（但是如果你自己使用var修饰，那么还是会按照var来定义）&lt;/p&gt;
&lt;p&gt;Scala自动为case class定义了伴生对象，也就是object，并且定义了apply()方法，该方法接收主构造函数中相同的参数，并返回case class对象。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8062&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 定义case class&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Teacher&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;String&lt;/span&gt;, subject: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;) &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;String&lt;/span&gt;, classroom: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;) &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Worker&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;) &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 案例：学校门禁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;judgeIdentify&lt;/span&gt;&lt;/span&gt;(p: &lt;span&gt;Person&lt;/span&gt;) {&lt;/p&gt;
&lt;p&gt;p &lt;span&gt;match&lt;/span&gt; {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;Teacher&lt;/span&gt;(name, subject) =&amp;gt; println(&lt;span&gt;&quot;Teacher, name is &quot;&lt;/span&gt; +name+ &lt;span&gt;&quot;,subject is &quot;&lt;/span&gt; + subject)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;(name, classroom) =&amp;gt; println(&lt;span&gt;&quot;Student, name is&quot;&lt;/span&gt; + name + &lt;span&gt;&quot;, classroom is &quot;&lt;/span&gt; + classro&lt;/p&gt;
&lt;p&gt;om)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt; println(&lt;span&gt;&quot;Illegal access, please go out of the school&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Teacher&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Worker&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;judgeIdentify: (p: &lt;span&gt;Person&lt;/span&gt;)&lt;span&gt;Unit&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 测试匹配效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; leo: &lt;span&gt;Person&lt;/span&gt; = &lt;span&gt;Student&lt;/span&gt;(&lt;span&gt;&quot;leo&quot;&lt;/span&gt;, &lt;span&gt;&quot;class1&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;leo: &lt;span&gt;Person&lt;/span&gt; = &lt;span&gt;Student&lt;/span&gt;(leo,class1)&lt;/p&gt;

&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; tom: &lt;span&gt;Person&lt;/span&gt; = &lt;span&gt;Teacher&lt;/span&gt;(&lt;span&gt;&quot;tom&quot;&lt;/span&gt;, &lt;span&gt;&quot;Math&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;tom: &lt;span&gt;Person&lt;/span&gt; = &lt;span&gt;Teacher&lt;/span&gt;(tom,&lt;span&gt;Math&lt;/span&gt;)&lt;/p&gt;

&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; jack: &lt;span&gt;Person&lt;/span&gt; = &lt;span&gt;Worker&lt;/span&gt;(&lt;span&gt;&quot;jack&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;jack: &lt;span&gt;Person&lt;/span&gt; = &lt;span&gt;Worker&lt;/span&gt;(jack)&lt;/p&gt;

&lt;p&gt;scala&amp;gt; judgeIdentify(leo)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Student&lt;/span&gt;, name isleo, classroom is class1&lt;/p&gt;

&lt;p&gt;scala&amp;gt; judgeIdentify(tom)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Teacher&lt;/span&gt;, name is tom,subject is &lt;span&gt;Math&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;scala&amp;gt; judgeIdentify(jack)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Illegal&lt;/span&gt; access, please go out of the school&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8063&quot; readability=&quot;13&quot;&gt;
&lt;h2&gt;Option匹配&lt;/h2&gt;
&lt;p&gt;Scala中有一种特殊的类型，叫做Option。Option有两种值，一种是Some，表示有值，一种是None，表示没有值。&lt;/p&gt;
&lt;p&gt;Option通常会用于模式匹配中，用于判断某个变量是有值还是没有值，这比null来的更加简洁明了。&lt;/p&gt;
&lt;p&gt;Spark源码中大量地使用了Option，比如Some(a)、None这种语法。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8064&quot; readability=&quot;30&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 案例：成绩查询&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; grades = &lt;span&gt;Map&lt;/span&gt;(&lt;span&gt;&quot;Leo&quot;&lt;/span&gt; -&amp;gt; &lt;span&gt;&quot;A&quot;&lt;/span&gt;, &lt;span&gt;&quot;Jack&quot;&lt;/span&gt; -&amp;gt; &lt;span&gt;&quot;B&quot;&lt;/span&gt;, &lt;span&gt;&quot;Sparks&quot;&lt;/span&gt; -&amp;gt; &lt;span&gt;&quot;C&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;getGrade&lt;/span&gt;&lt;/span&gt;(name: &lt;span&gt;String&lt;/span&gt;) {&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;val&lt;/span&gt; grade = grades.get(name)&lt;/p&gt;
&lt;p&gt;grade &lt;span&gt;match&lt;/span&gt; {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;Some&lt;/span&gt;(grade) =&amp;gt; println(&lt;span&gt;&quot;your grade is &quot;&lt;/span&gt; + grade)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;None&lt;/span&gt; =&amp;gt; println(&lt;span&gt;&quot;Sorry, your grade information is not in the system&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}、&lt;/p&gt;

&lt;p&gt;grades: scala.collection.immutable.&lt;span&gt;Map&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;,&lt;span&gt;String&lt;/span&gt;] = &lt;span&gt;Map&lt;/span&gt;(&lt;span&gt;Leo&lt;/span&gt; -&amp;gt; &lt;span&gt;A&lt;/span&gt;, &lt;span&gt;Jack&lt;/span&gt; -&amp;gt; &lt;span&gt;B&lt;/span&gt;, &lt;span&gt;Sparks&lt;/span&gt; -&amp;gt; &lt;span&gt;C&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;getGrade: (name: &lt;span&gt;String&lt;/span&gt;)&lt;span&gt;Unit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; getGrade(&lt;span&gt;&quot;Leo&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;your grade is &lt;span&gt;A&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;scala&amp;gt; getGrade(&lt;span&gt;&quot;Sparks&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;your grade is &lt;span&gt;C&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;scala&amp;gt; getGrade(&lt;span&gt;&quot;haha&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Sorry&lt;/span&gt;, your grade information is not in the system&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 18 Dec 2017 14:25:00 +0000</pubDate>
<dc:creator>小丑进场</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LiCheng-/p/8060059.html</dc:identifier>
</item>
</channel>
</rss>