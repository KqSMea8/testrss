<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java面试题：小白不得不懂的斐波那契数列 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/9967217.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/9967217.html</guid>
<description>&lt;p&gt;很长一段时间里，我都非常疑惑：“我写的技术文章不差啊，有内容的同时还很有趣，不至于每篇只有区区几十个人读啊？为什么有些内容简单到只有一行注册码的文章浏览量反而轻松破万？”这样的疑惑如鲠在喉啊！写技术博客做分享的人，有几个真心实意的说只写给自己看的？这无非是写出来后没人看的自我安慰（不好意思，我就属于这种人，/(ㄒoㄒ)/~~）。&lt;/p&gt;
&lt;p&gt;但就在昨天晚上，我终于恍然大悟；技术交流群里有一个叫涛涛的小伙伴用几句通俗易懂的道理就点醒了我：“&lt;strong&gt;高深的文章，看懂的人少，适合高层；像只有注册码的文章，反而是大众所需，浏览量非常高，因为只要是初学编程的，几乎都用得着！&lt;/strong&gt; 就像买房子一样，普通商品房买的人最多，复式套房要少一些，别墅就更少了——而你这样的‘专家’写出来的文章就相当于在卖别墅。”&lt;/p&gt;
&lt;p&gt;哦，有一种醍醐灌顶的感觉，有没有？假如把编程也看做是金字塔的话，那咱真心实意的说，咱的水平顶多也就处在中层偏下的水平，强装专家写出来的文章注定会“高不成低不就”——造成这种局面真的非常尴尬，在乎高品质文章的读者就会吐槽：“这货就是一个逗比”，然后笑一笑走了；不在乎高品质想找干货的读者也会不满意：“这货写出来的文章有点‘高深’，我都看不懂啊”，然后呵呵一声也走了。想一想，真是尴尬极了！&lt;/p&gt;
&lt;p&gt;像我这种写不出来高端文章，又想要点浏览量来安慰自己的写作者，怎么办呢？&lt;/p&gt;
&lt;p&gt;还是写一些有趣的、入门级的干货内容吧！比如说今天这篇《Java面试题：小白不得不懂的斐波那契数列》。&lt;/p&gt;
&lt;p&gt;Java中涉及控制执行流程的关键字有&lt;code&gt;if-else&lt;/code&gt;、&lt;code&gt;while-do-while&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;switch&lt;/code&gt;、&lt;code&gt;return&lt;/code&gt;、&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt;等等；我们来挑几个来说道说道。&lt;/p&gt;
&lt;h3 id=&quot;h1&quot;&gt;1、要么生，要么死&lt;/h3&gt;
&lt;p&gt;在网络上看到这么一句话：“&lt;strong&gt;人生不过三条路，要么生，要么死，要么生不如死&lt;/strong&gt;”，经典啊！这句话套用在&lt;code&gt;if-else&lt;/code&gt;语句上也非常的贴切，不信你看：&lt;/p&gt;
&lt;p&gt;只有一个if语句&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (布尔表达式) {&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者一个if语句加上一个else语句&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (布尔表达式) {&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者一个if语句加上一个else if语句，再加一个else语句&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (布尔表达式) {&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h2&quot;&gt;2、想清楚再走，还是先走一步再说&lt;/h3&gt;
&lt;p&gt;while和do-while语句常用来控制不确定次数的循环语句，除了形式上稍显不同之外，do-while会比while多执行一次（同等条件下哦）；其格式如下：&lt;/p&gt;
&lt;p&gt;while&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while(布尔表达式) {&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;do-while&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;do {&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h3for&quot;&gt;3、次数确定请用for&lt;/h3&gt;
&lt;p&gt;for循环有两种形式，分别如下：&lt;/p&gt;
&lt;p&gt;①、创建int变量的形式（可以主动指定循环次数，比如说可以把&lt;code&gt;i &amp;lt; strs.length()&lt;/code&gt;改为&lt;code&gt;i &amp;lt; 3&lt;/code&gt;，这样就只循环3次而不是4次）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;String [] strs = {&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;默&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;王&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;二&quot;};&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for(&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; strs.length(); i++) {&lt;br/&gt;String str = strs[i];&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;稍微解释一下：第一次循环之前要进行变量初始化&lt;code&gt;int i = 0&lt;/code&gt;，随后进行条件测试&lt;code&gt;i &amp;lt; strs.length()&lt;/code&gt;，然后执行语句&lt;code&gt;String str = strs[i];&lt;/code&gt;，语句结束后进行“步进”&lt;code&gt;i++&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;②、俗称“foreach”的形式（不必指定下标就能取出元素）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;String [] strs = {&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;默&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;王&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;二&quot;};&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (String str : strs) {&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也稍微解释一下：冒号&lt;code&gt;:&lt;/code&gt;之前声明了String类型的变量&lt;code&gt;str&lt;/code&gt;；冒号&lt;code&gt;:&lt;/code&gt;之后是数组&lt;code&gt;strs&lt;/code&gt;；在执行循环的时候，Java内部会依次取出数组&lt;code&gt;strs&lt;/code&gt;中的每一个元素，然后赋值给变量&lt;code&gt;str&lt;/code&gt;，直到最后一个元素。&lt;/p&gt;
&lt;h3 id=&quot;h4switch&quot;&gt;4、可以switch字符串了&lt;/h3&gt;
&lt;p&gt;当if-else的条件超出三个以上时（看起来有点臃肿），可使用&lt;code&gt;switch&lt;/code&gt;语句来进行替代。switch语句的形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;switch(condition) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case calue1 :&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用switch语句时需要特别注意的就是&lt;strong&gt;break关键字，该用的地方一定不要忘记！&lt;/strong&gt; 否则，switch语句就会触发下一个case分支，而忽略掉没有break关键字的当前分支。&lt;/p&gt;
&lt;p&gt;从Java SE 7 开始，switch语句支持字符串形式的条件了；在这之前，switch只支持类型为char、byte、short或int的常量表达式，以及枚举常量。&lt;/p&gt;
&lt;h3 id=&quot;h5&quot;&gt;5、斐波那契数列&lt;/h3&gt;
&lt;p&gt;斐波那契数列几乎是每一个学习编程的人都绕不开的一道笔试题；斐波那契数列是“斐波那契”（伟大的数学家）在养兔子时候发现的非常有意思的数列：&lt;/p&gt;
&lt;p&gt;第一个月小兔子没有繁殖能力，所以还是一对；&lt;br/&gt;两个月后，生下一对小兔总数共有两对；&lt;br/&gt;三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对；&lt;br/&gt;……依次类推可以列出下表：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;在这里插入图片描述&quot; src=&quot;https://img-blog.csdnimg.cn/20181114091053625.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;在这里插入图片描述&lt;/p&gt;
&lt;p&gt;人们发现自然规律的能力好强，有没有？怎么使用Java实现斐波那契数列呢？&lt;/p&gt;
&lt;p&gt;规律：第一个数+第二个数=第三个数，第二个数+第三个数=第四个数，第三个数+第四个数=第五个数，以此类推&lt;/p&gt;
&lt;p&gt;具体代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;4.5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;9&quot;&gt;package com.cmower.java_demo;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Fibonacci {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;main&lt;span class=&quot;hljs-params&quot;&gt;(String[] args) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int start = &lt;span class=&quot;hljs-number&quot;&gt;1;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int next = &lt;span class=&quot;hljs-number&quot;&gt;1;&lt;br/&gt;System.out.print(start + &lt;span class=&quot;hljs-string&quot;&gt;&quot;、&quot; + next + &lt;span class=&quot;hljs-string&quot;&gt;&quot;、&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;start = next;&lt;br/&gt;next = last;&lt;br/&gt;}&lt;br/&gt;System.out.println();&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;getFibonacci&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int index) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (index == &lt;span class=&quot;hljs-number&quot;&gt;1 || index == &lt;span class=&quot;hljs-number&quot;&gt;2) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-number&quot;&gt;1;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return getFibonacci(index - &lt;span class=&quot;hljs-number&quot;&gt;1) + getFibonacci(index - &lt;span class=&quot;hljs-number&quot;&gt;2);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;思路1：先指定前两个数，然后在for循环中计算接下来的数，然后用后一个数替换前一个。&lt;br/&gt;思路2：通过迭代完成，下标是1或者2的时候返回1，其余的数等于前一个数和前前一个数的和。&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Thu, 15 Nov 2018 23:19:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>斐波那契数列几乎是每一个学习编程的人都绕不开的一道笔试题；斐波那契数列是“斐波那契”（伟大的数学家）在养兔子时候发现的非常有意思的数列： 第一个月小兔子没有繁殖能力，所以还是一对； 两个月后，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing-gee/p/9967217.html</dc:identifier>
</item>
<item>
<title>Linux 桌面玩家指南：14. 数值计算和符号计算 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop014.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop014.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;不知道经常需要做科学计算的朋友们有没有这样的好奇：在 Linux 系统下使用什么工具呢？说到科学计算，首先想到的肯定是 Matlab，如果再说到符号计算，那就非 Mathematica 不可了。可惜，以上两款软件都是商业软件。虽然破解版满天飞，但是这不符合开源世界的逻辑。在 Linux 系统下，也有非常不错的科学计算工具，包括符号计算的也有。下面我就来隆重向大家推荐几款。&lt;/p&gt;
&lt;h2 id=&quot;octave&quot;&gt;Octave&lt;/h2&gt;
&lt;p&gt;这款软件是 GNU 出品，在 GNU 的在线文档网站上可以下载到它的完整的帮助文档，我喜欢 pdf 版，可以一口气从头读到尾，很舒服。从语法角度讲，Octave 和 matlib 完全兼容。下面是其运行效果图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/071539205939127.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它也有 GUI 界面的包装，那就是 QtOctave，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/071540089068535.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Ubuntu 下该软件的安装非常简单，使用如下命令即可：&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;sudo apt-get install octave
sudo apt-get install qtoctave&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;maxima&quot;&gt;Maxima&lt;/h2&gt;
&lt;p&gt;数值计算使用 Octave，那么符号计算就少不了 Maxima 了。由于符号计算中，数学公式的显示也是非常重要的一环，所以我喜欢用它的 GUI 封装 wxMaxima，该软件使用如下命令安装：&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;sudo apt-get install wxmaxima&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是它的运行效果图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/071544365155978.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了 GUI 的封装，我们的学习曲线都要简单很多，因为它的功能都在它的菜单栏中体现出来了。Maxima 也自带完善的文档，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/071547023126370.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;符号运算不仅能对各种数学公式进行运行、变形、化简，也可以直接对函数作图，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/071548065005593.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是以上介绍的都不是重点。下面的工具才是我这篇随笔的重量级嘉宾。它就是：&lt;/p&gt;
&lt;h2 id=&quot;ipython-notebook&quot;&gt;IPython-Notebook&lt;/h2&gt;
&lt;p&gt;使用 python 进行科学计算最近几年很火，主要得益于 python 语言和Numpy、SciPy、pandas、matplotlib、SymPy 等库。另外一个大杀器就是 ipython-notebook，它可以说是提供了在数学方面读写算加画图一条龙的服务了。Ubuntu 对 Python 的支持真心不错，先使用下面的命令将以上库全部安装：&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;sudo apt-get install pandas
sudo apt-get install sympy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不是说全部安装吗？怎么只有两个命令？因为安装 pandas 时 NumPy、SciPy、matplotlib 都作为依赖项自动安装了，只有符号计算库 SymPy 需要另外安装。然后，使用如下命令安装 ipython-notebook：&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;sudo apt-get install ipython-notebook&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理，IPython 也作为依赖项自动安装了。然后使用如下命令启动 ipython-notebook：&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;ipython notebook --pylab=inline&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后 ipython-notebook 就在浏览器中启动了。不错，这是一个 B/S 应用，我们启动它时会在我们的机器上建立一个简单的服务器，然后用浏览器访问这个服务器就可以使用 ipython-notebook 了，远程访问也行。下面是运行效果：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/071601562187476.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建一个笔记后，就会给我们一个输入代码的提示。ipython-notebook 中的内容是由一个一个的输入区域组成的，称为 Cell。每一个 Cell 除了可以输入代码，还可以输入 Markdown、rawtext、heading，如上图中的选项所示。下面是输入 Markdown 的效果图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/071605209217738.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按 Shift+Enter 即可结束该区域的输入，并执行和显示效果。如果以后要重新编辑里面的内容，双击该区域即可。Markdown 区域也是支持 MathJax 的哦，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/071610416717014.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面看看使用 NumPy 来进行数值计算和绘图的效果：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/071611255313182.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 pandas 进行数据分析并绘图的效果：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/071611510935305.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，看看使用 SymPy 进行符号计算的效果：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/071612231561011.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，SymPy 的 latex 函数可以把输出的数学公式转换成 LaTeX 代码，不过该代码有点问题，它里面每个反斜杠都变成了双反斜杠。将该 LaTeX 代码复制、修改后，输入 Markdown 区域就可以看到完美的数学公式了。&lt;/p&gt;
&lt;p&gt;我们在 IPython-Notebook 中建立的笔记是可以保存的，而且保存的是纯文本的 JSON 格式，所以可以非常方便地把它放到 GitHub 进行分享。从 IPython-Notebook 的帮助菜单可以很方便地导航到 NumPy、SciPy、matplotlib、pandas、SymPy 的帮助文档。在 matplotlib 的官网中，还专门有一个 gallary 页面，里面有各种图表的缩略图和代码，对我们的学习真的是很有帮助哦。&lt;/p&gt;
&lt;h2 id=&quot;适合数值计算的语言需要具备什么样的特色&quot;&gt;适合数值计算的语言需要具备什么样的特色&lt;/h2&gt;
&lt;p&gt;前面搞了不少工具论，下面再来讨论一下编程语言。这段时间，我继续徜徉在数值计算的世界。为了广泛学习数值计算方面的知识，我抽空看了 Python 科学计算和数值分析方面的书，也仔细研读了 Octave 的用户手册，甚至连古老的 Fortran、新兴的 R 语言我都去逐一了解。对于数值计算的库，我了解了一下 Boost 的 uBLAS，以前也用过 OpenCV，当然，了解最多的还是 Python 中的 NumPy、SciPy 和 pandas。今天谈的内容是我对适合做数值计算的编程语言的一些看法，主要是一些思路方面的东西，不评论具体语言的优劣。另外，我是想到哪儿写到哪儿，如果有什么不对的地方欢迎大家指正。&lt;/p&gt;
&lt;h3 id=&quot;一元组和数组&quot;&gt;一、元组和数组&lt;/h3&gt;
&lt;p&gt;如果数值计算仅仅只是两个标量之间的加减乘除，那就不需要我在这里浪费口舌了。向量啊、矩阵啊、多维数组啊什么，才是数值计算真正的主角。所以，适合做数值计算的编程语言必须有一个好的方式表示数组，特别是多维数组。哪种方式好呢？是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int a[m][n][k];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int a[m,n,k];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看似没有什么差别，但是如果你想获取数组 a 的形状呢？比如这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;？ = a.shape();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者再更进一步，想改变数组 a 的形状呢？比如这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a.reshape(?);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，“?”究竟应该用什么代替呢？&lt;/p&gt;
&lt;p&gt;如果让我给出答案，我会说：要用元组。很多编程语言中都有元组的概念，比如 Python。元组就是用逗号隔开的几个值，可以加圆括号，也可以不加。我觉得加上圆括号后可读性更好。比如 &lt;code&gt;(a,b)&lt;/code&gt; 是元组，&lt;code&gt;(3,4,5)&lt;/code&gt; 也是元组。如果写成 &lt;code&gt;[3,4,5]&lt;/code&gt; 那就是数组了，在 Python 中，也称之为列表。不过 Python 的列表功能比数组要强大，因为数组只能保存同一种数据类型的值，而列表可以保存任何对象。数组一般情况下不能动态改变长度，而列表可以。Octave 语言中使用 cell array 这个术语来表示可以保存不同类型对象的容器。Octave 中的数组和矩阵是可以动态改变长度的。C 语言的数组没有动态改变长度这个功能，而如果使用 C++ 的话，则必须使用 &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; 模板类。&lt;/p&gt;
&lt;p&gt;我认为，一个好的编程语言必须要有“元组”这个一个概念，必须能够用好大括号、中括号和小括号。在有没有元组这个问题上，很多语言做得不好，C 语言没有，C++ 也没有，Java 没有，C# 这个有很多新功能的语言也没有，不要告诉我有 &lt;code&gt;Tuple&amp;lt;&amp;gt;&lt;/code&gt; 模板类可以用，那个真的没有语言内置的元组功能好。在能不能用好大中小括号这个问题上，C 语言就做得不好。你看它不管是初始化数组，还是初始化 struct，都是用大括号。而 Python 和 JSON 就做得很好嘛，初始化数组用中括号，初始化对象或字典的时候采用大括号。如果加上小括号表示元组，那就齐活儿了。&lt;/p&gt;
&lt;p&gt;数值计算可以针对标量、一维数组、二维数组以及n维数组进行。数组可以如下组织，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/182127338868164.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;元组最大的用途就是可以用来表示数组的形状了。比如一维数组的形状为 &lt;code&gt;(n,)&lt;/code&gt;，请注意其中的逗号不能省略。二维数组的形状 &lt;code&gt;(m,n)&lt;/code&gt;，三维数组的形状 &lt;code&gt;(m,n,k)&lt;/code&gt;，依次类推。另外，元组可以用来对数组中的元素进行索引。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = [ [1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16] ];
b = a[2,3,3];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;元组还有一个很大的用途，那就是可以让一个函数返回多个值。C 语言在这个方面是做得比较丑陋的，如果一个函数要返回多个值，只能给这个函数传指针或者多重指针作为参数，C++ 可以传引用，C# 更加画蛇添足，专门有一个&lt;code&gt;out&lt;/code&gt;关键字用来修饰函数的参数。微软你真是的，你既然能想到&lt;code&gt;out&lt;/code&gt;，你就不能想到元组吗？常见的例子，比如&lt;code&gt;meshgrid()&lt;/code&gt;函数可以同时初始化两个数组，&lt;code&gt;peak()&lt;/code&gt;函数可以同时初始化三个数组。你看它们用元组多方便：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(xx, yy) = meshgrid(x, y);
(xx, yy, zz) = peak();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，元组还可以这样用，比如交换两个变量的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(a,b) = (b,a);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二数组初始化&quot;&gt;二、数组初始化&lt;/h3&gt;
&lt;p&gt;在数值计算中，数组的初始化也是非常重要的一环。如果像 C 语言这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int a[100] = {1, 2, 3, 4, ... , 100};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;估计很多人是要骂娘的。这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for(int i=0; i&amp;lt;100; i++){
    a[i] = i+1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也不优雅。我只是想初始化一个数组而已，怎么就非得要写一个循环呢？如果是二维数组呢，就得两层循环，三维数组就得三层。真的是太闹心了。&lt;/p&gt;
&lt;p&gt;另外，如前所述，我也不喜欢在初始化数组的时候用大括号。我觉得中括号就是为数组而生。比如这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = [1, 2, 3, 4];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是一个一维数组，但是如果这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = [ [1, 2, 3, 4] ];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是一个行向量。如果写成这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = [ [1], [2], [3], [4] ];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这就是一个列向量，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/182128193708227.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，上面的示例只有四个数字，这么写一写无可厚非。如果是很多数字呢？或者很多维的数组呢？这时就必须得用到很多初始化函数了，而且这些初始化函数最好能接受元组作为参数来决定数组的形状。比如这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = xrange( 1, 60, (3,4,5) );  //用1到60的数字初始化一个3*4*5的数组
b = randn ( (3, 4, 5) ); //用随机数初始化一个3*4*5的数组&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它的初始化函数还有 &lt;code&gt;linspace()&lt;/code&gt;、&lt;code&gt;logspace()&lt;/code&gt;、&lt;code&gt;ones()&lt;/code&gt;、&lt;code&gt;zeros()&lt;/code&gt;、&lt;code&gt;eyes()&lt;/code&gt; 等等。这些函数还可以配合 &lt;code&gt;reshape()&lt;/code&gt;使用，比如这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;c = linspace(0, 2*pi, 60).reshape(3, 4, 5);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在所有的这些初始化中，元组都是重要的组成部分。&lt;/p&gt;
&lt;h3 id=&quot;三range-和切片&quot;&gt;三、range 和切片&lt;/h3&gt;
&lt;p&gt;其实，range 除了可以是一个函数，还可以更省点儿事，像这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;r = 0:10:2;  //0,2,4,6,8,10
s = 11:0:-3; //11,8,5,2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在某些语言中，也把这个功能叫切片。其实就是&lt;code&gt;:&lt;/code&gt;的灵活运用，有标点符号可以用当然不能浪费嘛。使用切片，只需要指定起始值、终止值和步长，就可以获得一个数字序列。&lt;/p&gt;
&lt;p&gt;但是，&lt;code&gt;:&lt;/code&gt;最大的用途并不是用来对数组进行初始化，而是对数组进行索引。比如，&lt;code&gt;a&lt;/code&gt; 是一个三维数组，可以通过切片来获取其中的一部分数据。见下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = range(1, 60).reshape(3, 4, 5); // a是一个三维数组
b = a[1, 2:3, 1:4]; // b是一个二维数组，其值为[ [12, 13, 14, 15], [17, 18, 19, 20]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切片除了可以指定起始值和终止值外，也可以指定步长。当然，也可以只用一个单独的&lt;code&gt;:&lt;/code&gt;，代表取这一整个轴。关于轴的概念，可以看我前面的图片。见下面这样的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = range(1, 60).reshape(3, 4, 5); // a是一个三维数组
b = a[1, :, :]; // b的值为二维数组[[1,2,3,4,5], [6,7,8,9,10],  [11,12, 13, 14, 15], [16,17, 18, 19, 20]]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四不写循环&quot;&gt;四、不写循环&lt;/h3&gt;
&lt;p&gt;在对多维数组进行加减乘除的时候，如果使用传统的像 C 这样的语言，则避免不了要写循环。比如要计算两个多维数组的加法，不得不写这样的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;m = 10;
n = 20;
k = 30;
a = randn(m, n, k); //形状为(m, n, k)的三维数组，初始化为随机值
b = randn(m, n, k); //形状为(m, n, k)的三维数组，初始化为随机值
for(int i=0; i&amp;lt;m; i++){
    for(int j=0; j&amp;lt;n; j++){
        for(int p=0; p&amp;lt;k; p++){
            c[i, j, p] = a[i, j, p] + b[i, j, p];
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码当然远不如下面这样的代码简洁：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C = A + B;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以不写循环基本上就成了所有数值计算语言的标准配置。Matlab 和 Octave 是这样，NumPy 是这样，R 语言也是这样。C++ 也在追求这样，因为 C++ 中有运算符重载的功能，所以可以对矩阵类重载加减乘除运算符。但是 C++ 中运算符的基础设施有缺陷，比如它没有乘方运算符（幂运算符），在 Octave 和 NumPy 中，都可以这样计算 $ x^y $：x**y。但是在 C++ 中，只有使用函数 &lt;code&gt;power(x, y)&lt;/code&gt;。不要想 &lt;code&gt;^&lt;/code&gt; 运算符，它是一个位运算符，所以取幂只有使用 &lt;code&gt;**&lt;/code&gt; 了。另外，多维数组运算还有特例，比如二维数组之间加减乘除，既可以是逐元素的加减乘除，也可以是矩阵的加减乘除。向量计算也有特例，既可以是逐元素加减乘除，也可能是向量内积（点乘）。如果正好是长度为 3 的向量，还可以计算叉乘。这些运算符都需要重新定义，所以虽然 C++ 有重载运算符的机制，但是因为这些运算符完全超越了 C++ 的基础设施，所以 C++ 也没有办法写得很优雅。&lt;/p&gt;
&lt;p&gt;不写循环还有一个优点，那就是可以对运算速度进行优化。优化是编译器或解释器的责任，写数值计算程序的人可以完全不用费心。编译器或解释器可采取的优化方式有可能是利用 SSE 等多媒体指令集，也可能是发挥多核 CPU 的多线程优势，甚至是使用 GPGPU 计算都有可能。如果用户非要写成 C 语言那样的循环，而他又不会内联汇编或 OpenMP 的话，那么就谈不上什么运算速度的优化了。&lt;/p&gt;
&lt;h3 id=&quot;五广播&quot;&gt;五、广播&lt;/h3&gt;
&lt;p&gt;不写循环，直接把两个多维数组进行加减乘除当然省事。但是如果两个数组的形状不一样呢？比如一个二维数组加一个行向量，或一个二维数组加一个列向量，甚至是数组加减乘除一个标量，会出现什么情况呢？&lt;/p&gt;
&lt;p&gt;不用担心，在面向数值计算的语言中，一般都有“广播”这样一个特性。当两个数组的形状不一样时，形状比较小的那个往往可以在长度为 1 的维度上进行广播。如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/182128556982226.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;六奇异索引&quot;&gt;六、奇异索引&lt;/h3&gt;
&lt;p&gt;Fancy indexing，有的书上翻译成花式索引，但我认为叫奇异索引比较好。它就是指一个低维的数组，可以使用高维的数组进行索引，最后得到的结果是一个高维的数组。如果索引中含有切片，可能会得到一个更高维度的数组作为结果。&lt;/p&gt;
&lt;p&gt;这个概念理解起来比较难。特别是再配合切片使用，更加增加其复杂性。所谓一图胜千言，先看普通索引的情况：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/211034555471945.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面提到，对多维数组进行索引的时候需要用到元组，元组的长度等同于数组的维数。对于普通索引而言，元组的各个部分要么是整数，要么是切片。而对于奇异索引而言，索引元组的各个组成部分都可能是多维数组或者切片。如果是多维数组，则最后得到的数组的形状和索引数组的形状相同，如果配合切片，则可能得到更高维的数组。如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201501/211035075001295.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;七函数调用&quot;&gt;七、函数调用&lt;/h3&gt;
&lt;p&gt;编程语言发展这么多年，一直在进化，也一直在相互靠拢。对于一个编程语言来说，是应该面向过程还是面向对象？是静态类型还是动态类型？这些都是值得思考的地方。但是在函数调用方面，有一些思想倒是可以学习。&lt;/p&gt;
&lt;p&gt;在 C 语言这样比较古老的语言中，对于函数的参数来说，只有位置参数一种。也就是说，像一个函数传递参数的时候，只能正确的参数放到正确的位置，而且参数的个数必须和函数定义的相同。这是最原始的函数调用思想。&lt;/p&gt;
&lt;p&gt;紧接着，在某些编程语言如 Java、C# 中，有了可选参数这个概念。但是可选参数要放到参数列表的最后面，而且必须提供默认值。当调用函数时如果指定了这个参数，则使用调用时指定的值，否则使用默认值。&lt;/p&gt;
&lt;p&gt;但是我觉得适合数值计算的语言必须还得更进一步，提供关键字参数的功能。什么是关键字参数呢？比如对数据进行绘图的时候，需要指定线型、标签、标题等各种属性，可以这样调用函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;plot(x, y, marker=&quot;*&quot;, color=&quot;r&quot;, linestyle=&quot;-&quot;, title=&quot;...&quot;, legend=&quot;...&quot;, xlabel=&quot;...&quot;, ylabel=&quot;...&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每一个参数调用的时候都可以指定它的名字，这样我们就不用去死记各个参数的位置，是不是很方便呢？&lt;/p&gt;
&lt;h3 id=&quot;八生态环境&quot;&gt;八、生态环境&lt;/h3&gt;
&lt;p&gt;对于一门编程语言而言，生态坏境很重要。在数值计算领域更是如此。因为很多数值计算的库都是专业的人士写给专业人士看的，比如物理专业的写物理领域的算法，气象专业的写气象专业的算法，所以不大可能有一个全面的官方的，像 C 或 C++ 这样一个由 ANSI 定义的库。&lt;/p&gt;
&lt;p&gt;广泛接受开源社区的贡献是一个比较好的办法。Perl 是这样，Python 也是这样，新兴的 R 语言也是这样。Perl 有 CPAN，Python 有 PyPI，R 语言也有 CRAN。至于 Matlab，那更是有各种各样的工具包。&lt;/p&gt;
&lt;p&gt;OK，就写这么多吧，还有其它的一些什么特色，我想到后再随时更新此文。&lt;/p&gt;
&lt;p&gt;另外，本文中所有的图片都是在 Ubuntu 中使用 Inkscape 矢量图软件绘制而成。&lt;/p&gt;
&lt;h2 id=&quot;求打赏&quot;&gt;求打赏&lt;/h2&gt;
&lt;p&gt;我对这次写的这个系列要求是非常高的：首先内容要有意义、够充实，信息量要足够丰富；其次是每一个知识点要讲透彻，不能模棱两可含糊不清；最后是包含丰富的截图，让那些不想装 Linux 系统的朋友们也可以领略到 Linux 桌面的风采。如果我的努力得到大家的认可，可以扫下面的二维码打赏一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180831154735325-1276475036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2018年11月16日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 22:52:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop014.html</dc:identifier>
</item>
<item>
<title>一份来自28岁老程序员的自白 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9966945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9966945.html</guid>
<description>&lt;blockquote readability=&quot;2.125&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9966945.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9966945.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;很幸运，28岁的我头发还没有掉光，更幸运的是28岁的我开始了博客园的写作生活！这样的技术分享经历让我拓展了自己的朋友圈！有幸结识了像张善友张队（连续13年的微软MVP），大石头(NewLife团队)，nicye（CSRedisCore作者）等圈内大牛！真的感觉自己很幸运！最近看了很多人写自己的程序员生活，所以趁着今天出差的空隙也想给28岁的自己做个叙述！于是就有了这篇文章！&lt;/p&gt;
&lt;h2 id=&quot;毕业实习的半年&quot;&gt;毕业实习的半年&lt;/h2&gt;
&lt;p&gt;不知道大家是否跟我一样，在大学过着虚度光阴的生活。那时候CF比较火，所以在大学的时候除了会打CF以外，别无收获（至今，还时不时的玩着这款游戏，都8年了）！因此大四的后半年的时候很沮丧，可是有一次去人才市场应聘的时候，居然被一家公司给“录取了”！为什么录取了加双引号呢，因为，这家公司打着招聘的幌子，让我交了两千多块钱上了他们的培训班！你没看错，我就这样稀里糊涂的交了两千多块钱上了他们的培训课，而且是网络课程！之后经过一个月的培训后经介绍到了杭州的一家网络公司做实习生。然后就在那家公司呆了六七个月！做的工作也都是跟路由器，交换机相关的工作，配置各种网络环境！这时候还没用上.net.&lt;/p&gt;
&lt;h2 id=&quot;第一次与.net结缘及苦学经历&quot;&gt;第一次与.net结缘及苦学经历&lt;/h2&gt;
&lt;p&gt;由于实习的时候是在杭州，而我的女朋友（现在已经是我老婆了）是在合肥，异地的感觉真不好受，所以在十一国庆节后就开始思考着回合肥了！毕竟当时我女朋友也在合肥工作，而且合肥距离我老家淮北以及我女朋友的老家安庆太湖都很近！所以就在网上搜了下合肥的招聘信息，结果发现网络的工作好少啊，又看了下软件开发，发现软件开发的工作好多啊，于是乎想转软件开发，那时候比较火的就是.net与java了！经左手跟右手的剪刀石子布，选择了.net。既然决定了，那就得开始学习了！记得12年那时候传智播客很火，所以在网上down了传智播客关于.net的基础以及进阶教程（好像是石坤的）开始了每天晚上苦学的生活！说实在的，高考都没那么用心学过一样技术，而且是从零开始！经过一个多月的学习，我在合肥投了两份简历，后跟两家公司约好了面试时间，然后趁着面试前的几天在网上又down了C#面试一百题的面试题，然后全背下来了！就风尘仆仆的回合肥面试了！结果有一家公司的面试题居然跟我从网上down的一毛一样，可想而知，我答得又多么好了！后来我就以三千块钱一个月的工资进了第一家公司，在这家公司一待就待了近五年，当然这都是后话。&lt;/p&gt;
&lt;h2 id=&quot;第一份正式工作的经历&quot;&gt;第一份正式工作的经历&lt;/h2&gt;
&lt;p&gt;上面也说了，我面试的时候是幸运的，就因为面试题刚好是我从网上down的C#面试一百题，所以我都会！但是入职了后，肯定是要露馅的啊！可能由于刚毕业的原因，所以那时候的同事给了我很多的帮助，再次很感谢他们！在这里我能给大家爆一下吗，我刚进公司的时候，连vs2010怎么连接数据库的都不会，还是同事教我的呢！但是我用了一个月就上手了，然后就能独立的完成经理交给我的任务了！我究竟是怎么做到的呢？入职的第二天我就买了一个小册子，然后我把vs连接数据库的字符串给写到小册子上面，在操作数据库过程中使用到的数据库连接对象，等等我不熟悉的概念也全部百度下，再把意思及用全部写到小册子上面！回去又看了一遍传智播客的教程，也用小册子做了笔记！当好我当时上下班都需要做一个小时左右的公交车！因此公交车上就成了我充电的地方，坐上公交车以后就把小册子拿出来从第一页浏览到最后一页，刚开始就是死记硬背，一遍又一边的记忆！可能我的记忆力比较差，所以我都不记得看了多少遍了！反正足足过了一个多月的这种公交车充电的生活！记得很清楚的是入职后一个多月的时候，经历交给我一个任务，把一个数据库的数据同步到另一个数据库里面去！而且要可视化的操作！然后我花了一个星期的时间就独立完成了！那时候真的感觉满满的成就感！&lt;/p&gt;
&lt;h2 id=&quot;入职后第二年第一次提离职&quot;&gt;入职后第二年第一次提离职&lt;/h2&gt;
&lt;p&gt;第二年的时候我跟老总提了一次离职，原因是一年了公司还没有给我加工资，而且我在外面投了简历，别人给我开了五千的工资，而我所在的公司给我的还是三千的工资！但是老总给说什么自己现在有难处，留下来再帮帮他，等公司项目验收了会给我项目奖金，他现在很不容易，很困难，让我一定再留下来帮帮他！身为程序员的我，本就不喜欢讲话，再加上老总声情并茂的诉苦，结果单纯的我就信以为真，然后傻傻地又留下来了，留下来了！工资给主动的加了五百！第一次提离职以失败而告终！不过后来我自学silverlight在工作之余接了一点私活来补贴家用！当然这都是后话了！&lt;/p&gt;
&lt;h2 id=&quot;老板主动给我加薪并提拔为技术合伙人&quot;&gt;老板主动给我加薪并提拔为技术合伙人&lt;/h2&gt;
&lt;p&gt;转眼到了第三年，有一次老总找到了我跟我谈了很久说给我加工资（从3500加到7000），而且这次加工资后以后就不要跟他提加工资的事情了！而且，后面公司准备成立一个分公司（公司名字里都有我的名字）让我技术入股当合伙人！跟其他几个公司一个准备包装起来再成立一家集团公司搞上市！反正说了一大堆！结果我同意了，而且我也更加认真的工作了！又经过两年多的发展,从开始的十几个人，发展到六七十个人！公司也引进了一批科大的高材生！业务，也拓展了很多，发展势头也很好，都在准备上市的事情了！&lt;/p&gt;
&lt;h2 id=&quot;从第一家公司毅然决然的离职&quot;&gt;从第一家公司毅然决然的离职&lt;/h2&gt;
&lt;p&gt;结果在15年的时候公司进来一个总经理，一个让人跟他对话都感觉他心里在算计你的一个人！天天把老总抬得高高的，然后跟老总分工，老总主外，他主内，管理整个公司的大小事务，然后在公司里胡搞拔搞，上下一片怨言。更甚至在我们工作的地方装起了摄像头，有事没事的监控我们，感觉很不爽，再加上在这个所谓的总经理的带领下公司的业务变得越来越差，再加上融资困难，感觉上市无望的我又经过了一年多的煎熬后于17年五月份的时候毅然决然的提出了离职！这一次老总又一次声情并茂的挽留我，但是我已不是初出茅庐的单纯少年了！所以这次我成功的离职了！现在回想起来还好当时提前离职了，因为前几天更之前的同事聊天，听他们说公司倒闭了，老板还欠了他们的工资没发呢！现在真的很庆幸！&lt;/p&gt;
&lt;h2 id=&quot;第二家公司的经历&quot;&gt;第二家公司的经历&lt;/h2&gt;
&lt;p&gt;第二家公司呆了差不多一年的时间，说起第二家公司是做视频监控的跟我之前的工作毫不相关，但是好在离我家很近，只有四五公里左右，开车的话十分钟左右就能到！在这家公司虽然呆的时间不长，但是我也机缘巧合的认识了一些朋友，也学习并使用了很多新技术，比如说：第一次使用了Linux系统，Hadoop,Zokeeper,Elasticsearch等等大数据技术以及视频结构化相关的技术！并进行相应的落地！转眼到了18年随着.NET Core2.0的发布，我觉得是时候回归.net的了！因为对比之下我发现自己更适合进行.NET的开发！而且利用闲余时间用.NET Core做了一个cms系统后，感觉很多无处不在的依赖注入，以及全新的开发方式感觉虽然有点不适应，但是开发起来很爽！所以就想着换一家.net的公司进行工作了！当时我老婆也有点反对，毕竟离家很近，而且基本不加班，周六周日又能在家陪小孩！&lt;/p&gt;
&lt;h2 id=&quot;目前公司的求职及工作情况&quot;&gt;目前公司的求职及工作情况&lt;/h2&gt;
&lt;p&gt;但是我还是私下投了简历，然后就进了我现在的公司，为什么选择这个公司呢，说实在话这个公司的薪水不是很高！而我看中的就是这家公司积极使用新技术，勇于尝试新技术的活力！再者说就是这家公司已经开始使用.NET Core了！刚好我又对.NET Core感兴趣，所以就进了现在的公司！而这时候已经是18年的5月20日了，在这一天我开始了新公司的工作！进公司后就利用.NET Core相关的技术进行一些后台的开发！然后几天后完成了第一个后台服务的开发，这时候在进行测试的时候发现异步进行数据库新增的时候如果并发比较大的时候出现重复数据的问题，最后得以解决。后就想着记录一下吧！所以就在博客园注册了账号进行了记录，这也是我的第一篇文章！由于那时候对NET Core了解的还不是很透彻所以就到博客园看那些大牛的文章，然后每天上下班做地铁的二十分钟天天看他们的文章，不知不觉自己的技术就得到了提升，再加上我们的技术经理也很喜欢.NET Core，所以有事没事我们就一起交流些心德，互相提升.NET Core技术！我们聊得最多的就是今天.NET Core做了哪些更新，明天哪个开源项目又升级了！张队的公众号又更新的什么技术文章！目前我们也天天在讨论这些！感觉对.NET Core有聊不完的话题。再后来就是我开始了自己的第一篇正式的用心的分享技术的文章&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9193723.html&quot;&gt;asp.Net Core免费开源分布式异常日志收集框架Exceptionless安装配置以及简单使用图文教程&lt;/a&gt; 没想到这篇文章居然会有这么多阅读量，最重要的是被张队转载到了公众号。感觉自己从吃瓜群众转身一变成了主角！所以一发不可收拾谢了持续很多文章！在这里非常感谢读者朋友！是你们让我有了继续写下去的动力！再后来就认识了像张善友张队（连续13年的微软MVP），大石头(NewLife团队)，nicye（CSRedisCore作者）等圈内大牛。&lt;/p&gt;
&lt;h2 id=&quot;目前的状况以及接下来的计划&quot;&gt;目前的状况以及接下来的计划&lt;/h2&gt;
&lt;p&gt;目前我们已经把.NET Core应用到我们的所有新项目。并准备对老项目进行.NET Core的升级改造！而且封装了一套基于Ocelot进行改造升级后的统一认证平台！当然，我也写了一系列Ocelot的教程有兴趣的朋友可以看下！而且随着.NET Core的越来越成熟，所以有必要为.NET Core做一次宣传，为.NET Core社区做一次贡献！为了帮助更多新手朋友们了解.NET Core以及入门.NET Core!所以我计划写一个.NET Core实战项目的教程！这个教程以一个CMS系统为例为大家介绍如何使用.NET Core从零开始开发并进行相关的部署！为了方便.NET Core实战项目的交流，我特意建了一个QQ群，群号是637326624！有兴趣的朋友可以提前加一下！而且我另一个朋友也已经开了一个.NET Core项目实战的系列文章https://www.cnblogs.com/jackcao/p/9928879.html也统一的在这个群里进行交流！希望能对大家学习.NET Core有所帮助！在这里在这里再一次感谢大家的阅读！&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 15:56:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>作者：依乐祝 原文链接：https://www.cnblogs.com/yilezhu/p/9966945.html 写在前面 很幸运，28岁的我头发还没有掉光，更幸运的是28岁的我开始了博客园的写作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9966945.html</dc:identifier>
</item>
<item>
<title>论程序员加班的害处 - 锋哥程序十年</title>
<link>http://www.cnblogs.com/bianchengniuren/p/9966946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengniuren/p/9966946.html</guid>
<description>&lt;p&gt;一&lt;/p&gt;
&lt;p&gt;明仔在大学的时候，是一个快乐外向的男孩。&lt;/p&gt;
&lt;p&gt;今年7月份校招会上，明仔找到了一份北京中关村的程序员工作。带着第一天上班的新鲜感，明仔马不停蹄的忙碌了一天。时间很快来到傍晚6点。女朋友发来信息约明仔去吃饭，说要庆祝一下他的第一天入职。&lt;/p&gt;
&lt;p&gt;明仔悄悄回信息说：公司的气氛好像有点不对，下班了没有一个人有要走的意思。让女朋友等他一下。&lt;/p&gt;
&lt;p&gt;和明仔一起进公司的，有四个新来的员工。明仔悄悄的看了他们一眼，发现他们也没有要走的意思。&lt;/p&gt;
&lt;p&gt;明仔感觉有点不对劲。心想：好吧，那把明天要做的事情整理一下，晚点再说。&lt;/p&gt;
&lt;p&gt;时间很快来到19点，明仔计算了一下时间，路上还要花费一个小时，回到家里都8点多了，女朋友还在等着吃饭庆祝呢。心想：不管了，哪怕是地雷阵，也要先撤了。要不家里的领导不好交代。&lt;/p&gt;
&lt;p&gt;没想到明仔前脚刚打卡，其他的同事也都纷纷收拾东西打卡下班。&lt;/p&gt;
&lt;p&gt;第二天上班，先是明仔的直属领导过来过问工作的完成情况，然后又被老板请到办公室喝茶。那些在他后面打卡下班的同事就一点事都没有。&lt;/p&gt;
&lt;p&gt;明仔终于明白了，枪打出头鸟。说啥也不能做这个最早下班的“&lt;strong&gt;出头鸟&lt;/strong&gt;”了。&lt;/p&gt;
&lt;p&gt;时间很快来到下班的时间，公司没有任何人下班。明仔发现公司几个老员工，仿佛刚睡醒一样，忽然变得生龙活虎的忙碌起来。&lt;/p&gt;
&lt;p&gt;到了晚上21：00点，还是没有人下班。这群大尾巴狼啊，明仔心里暗暗骂了一句。你们不走，我也不走，明仔做好了长期抗战的打算。&lt;/p&gt;
&lt;p&gt;第二天，明仔在公司的微信群，被领导表扬了，说他的工作完成的很出色。但是明仔昨晚从下班到加完班回家，心里一直在嘀咕，啥正经事都没干。&lt;/p&gt;
&lt;p&gt;明仔总结了一下：&lt;/p&gt;
&lt;p&gt;公司的老员工，上班一条虫，下班一条龙。把公司的工作，留到加班来完成，给领导制造一种错觉，让人感觉到他永远有完不成的工作。&lt;/p&gt;
&lt;p&gt;公司的新员工，上班的时间工作效率普遍很高，很快按时完成任务。晚上加班的时候都在装忙，然后做自己的事情。&lt;/p&gt;
&lt;p&gt;公司从来不强求加班。但是明仔却在不知不觉中，被动加入了加班的队伍。&lt;/p&gt;
&lt;p&gt;从此，明仔变得有点内向了，内心经常快乐不起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;周日，明仔起床打开微信，看到公司老板在朋友圈发心灵鸡汤，号召员工All In才能成功。明仔忍不住骂了一句：“QNMBD~~”，然后在老板的朋友圈留言：“老板英明，下午去加班！”。&lt;/p&gt;
&lt;p&gt;无休止的加班，彻底扼杀了明仔的创造性和积极性。让明仔从脑力劳动变成了无休止的体力劳动，美名其曰：出卖体力赚钱。&lt;/p&gt;
&lt;p&gt;明仔学会了一项绝技，白天解bug，晚上写bug。于是明仔变得忙碌起来，绩效也开始节节攀升。&lt;/p&gt;
&lt;p&gt;然而，这样的意义何在？&lt;/p&gt;
&lt;p&gt;对于明仔来说，意义就在于，工资挣到手了，而且越挣越多。但是这样挣钱真的很累。把自己的时间、体力和健康换成微博的薪水，而且进步缓慢。&lt;/p&gt;
&lt;p&gt;对于明仔的领导来说，因为管理的团队兢兢业业的表现，获取了升迁的资本。哪管它是否虚假的繁荣。&lt;/p&gt;
&lt;p&gt;对于公司来说，团队的努力工作，让其可以在业绩不理想的时候，向投资人有交待。&lt;/p&gt;
&lt;p&gt;本位主义，各取所需，让这畸形变态的加班变得理所当然。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前段时间，某大V发了一篇文章《年轻人，你凭什么不加班》。这篇文章主要陈述两个观点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 你在将来成功之后，一定会感谢当年加班苦逼的自己。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;牺牲健康，牺牲与家人相伴的时间来加班，给公司创造财富。先不论将来会不会成功，只想先问一句：加班费公司给了吗？就一盒加班便当把我们打发来加班？&lt;/p&gt;
&lt;p&gt;对于公司来说，员工生病了不适合工作了可以换。对员工来说，牺牲健康来加班，上了年纪之后无法工作了，谁来养？对于家人来说，家里一个主要劳动力的坍塌意味着一个家庭的坍塌，家庭收入没了靠什么生存？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.老板还在加班，你凭什么下班？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这明显就是偷换角色、改梁换柱。老板挣老板的钱，员工挣老板的钱。老板挣的钱和员工挣的钱能一样吗？员工是靠出卖劳动力挣薪水，老板靠股份挣取分红。老板可以凭股份发家致富，到达人生巅峰，员工还不是苦逼的员工？老板可以加班，员工凭什么免费给你加班，嗯？！&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 15:52:00 +0000</pubDate>
<dc:creator>锋哥程序十年</dc:creator>
<og:description>一 明仔在大学的时候，是一个快乐外向的男孩。 今年7月份校招会上，明仔找到了一份北京中关村的程序员工作。带着第一天上班的新鲜感，明仔马不停蹄的忙碌了一天。时间很快来到傍晚6点。女朋友发来信息约明仔去吃</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengniuren/p/9966946.html</dc:identifier>
</item>
<item>
<title>ElasticSearch+Logstash+Filebeat+Kibana集群日志管理分析平台搭建 - readygood</title>
<link>http://www.cnblogs.com/readygood/p/9955533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/readygood/p/9955533.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;在使用搜索引擎是你可能会觉得很简单方便，只需要在搜索栏输入想要的关键字就能显示出想要的结果。但在这简单的操作背后是搜索引擎复杂的逻辑和许多组件协同工作的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　搜索引擎的组件一般可分为两大类：索引组件和搜索组件。在搜索之前搜索引擎必须把可搜索的所有数据做整合处理并构建索引（倒排索引），将所有数据构建成能被搜索的格式并存储起来，这就成为索引组件；能根据用户搜索并能从索引组件构建的索引中查询出用户想要的结果的组件称为搜索组件。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ElasticSearch就属于搜索组件的一种，并且它是一个分布式搜索服务器，在搭建ElasticSearch集群时最好有三台以上的服务器，因为它的数据都是分片存储的。Lucene是Apache提供的开源项目，是一个完全用Java编写的搜索引擎库。ElasticSearch使用Lucene作为内部的搜索索引构建库，使ElasticSearch集成了搜索引擎的两大核心组件。虽然用这两个组件可以完成索引构建并进行搜索操作，但成为完善的搜索引擎是不够的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于集群日志分析平台来说，还需要对大量应用服务的日志数据进行采集，并按需要的格式进行划分、存储、分析，这就要用到Logstash和Filebeat组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Filebeat是一个非常轻量化的日志采集组件，Filebeat 内置的多种模块（auditd、Apache、NGINX、System 和 MySQL）可实现对常见日志格式的一键收集、解析和可视化。而Logstash是一个开源的服务器端数据处理管道，它可以同时从多个源中提取数据，对其进行转换，然后输出到指定位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在解决上面一系列问题后，搜索引擎还需要提供一个友善的用户界面来展示给用户，使用户能够进行傻瓜式的搜索操作，并且还能将搜索结果通过各种直观的方式展示在用户面前。这是就要用到Kibana组件。Kibana可以让ElasticSearch数据极为丰富的展现出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面提到的组件除了Lucene库意外其他的都属于Elastic Stack家族的产品，在普遍的企业中都是采用这些组件构建成集群来分析处理大量的日志数据的。更多组件可访问&lt;a href=&quot;https://www.elastic.co/&quot; target=&quot;_blank&quot;&gt;Elastic官网站点&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1.基本架构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在本文示例中，以下面的结构来进行演示，图1：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181114224313761-497888189.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在上图所示的架构的工作逻辑：Kibana将ElasticSearch集群提供的搜索内容进行可视化处理，并用多种方式展现给用户；ElasticSearch集群和其集成的Lucene用来完成对所有采集到的数据进行分析构建索引并提供搜索；而数据的来源则是通过Logstash和FileBeat采集自Nginx日志，Logstash将来自FileBeat的数据过滤并输出给ElasticSearch集群。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在集群达到一定规模后，大量的后端应用通过FileBeat采集到数据输出到Logstash会使Logstash Server称为性能瓶颈，因为Logstash是用Java程序开发的，很消耗内存，当数据处理量大后性能会大打折扣；所以可以在Logstash和FileBeat之间增加Redis，Redis专门用来做队列数据库，将在FieBeat中采集的数据平缓的输出到Logstash。如图2：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181114123051765-1059190329.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;287&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;span&gt;2.搭建ElasticSearch集群&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Linux版本：CentOS7.2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ElasticSearch：5.5.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面先用图1的架构示例来构建集群，完成后再引入Redis来进行演示，当集群没有达到很庞大规模时引入Redis不会对集群性能有实质性的提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;由于ElasticSearch是用Java开发的，运行时依赖JDK环境，ElasticSearch集群所有节点上都需要装上JDK。在n2~n4节点上安装ElasticSearch和JDK：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y java-&lt;span&gt;1.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-openjdk java-&lt;span&gt;1.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-openjdk-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　在官网下载ElasticSearch，我这里安装的是ElasticSearch5.5.1版本，在官网下载rpm包直接安装：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -ivh elasticsearch-&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　ElasticSearch5的程序环境：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; /etc/elasticsearch/&lt;span&gt;elasticsearch.yml #主程序配置文件
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; /etc/elasticsearch/&lt;span&gt;jvm.options #java配置文件
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; /etc/elasticsearch/log4j2.properties #日志配置文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;主配合文件配置段：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;Cluster #集群配置段，需要设置ElasticSearch集群名称
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;Node #各节点配置段，要设置当前主机的主机名
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Paths #各类路径配置段 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;Memory #内存配置段 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;Network #网络配置段 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;Discovery #
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;Gateway 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; Various
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_097a6630-5c2e-4c36-a552-71d1935f9b77&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_097a6630-5c2e-4c36-a552-71d1935f9b77&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_097a6630-5c2e-4c36-a552-71d1935f9b77&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # ---------------------------------- Cluster -----------------------------------
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; # Use a descriptive name &lt;span&gt;for&lt;/span&gt;&lt;span&gt; your cluster:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; #cluster.name: my-&lt;span&gt;application
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;cluster.name: myels #集群名称，ElasticSearch是基于集群名和主机名来识别集群成员的
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; # ------------------------------------ Node ------------------------------------
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; # Use a descriptive name &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the node:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; #node.name: node-&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;node.name: n2 #本节点名
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;# Add custom attributes to the node:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#node.attr.rack: r1
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; # ----------------------------------- Paths ------------------------------------
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;# Path to directory where to store the data (separate multiple locations by comma):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; #path.data: /path/to/&lt;span&gt;data
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; path.data: /els/&lt;span&gt;data #查询索引数据存放路径
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;# Path to log files:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; path.data: /els/&lt;span&gt;logs #日志路径
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; #path.logs: /path/to/&lt;span&gt;logs
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; # ----------------------------------- Memory -----------------------------------
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;# Lock the memory on startup:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; #bootstrap.memory_lock: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; #是否开启时就划用所有内存
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;# Make sure that the heap size is set to about half the memory available
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;# on the system and that the owner of the process is allowed to use this
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;# limit.
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;# Elasticsearch performs poorly when the system is swapping the memory.
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; # ---------------------------------- Network -----------------------------------
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;# Set the bind address to a specific IP (IPv4 or IPv6):
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; #network.host: &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; network.host: &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.102&lt;/span&gt;&lt;span&gt; #监听地址，默认是本地
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; # Set a custom port &lt;span&gt;for&lt;/span&gt;&lt;span&gt; HTTP:
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; #http.port: &lt;span&gt;9200&lt;/span&gt;&lt;span&gt; #监听端口
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; # For &lt;span&gt;more&lt;/span&gt;&lt;span&gt; information, consult the network module documentation.
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; # --------------------------------- Discovery ----------------------------------
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;# Pass an initial list of hosts to perform discovery when new node is started:
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; # The default list of hosts is [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[::1]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; discovery.zen.&lt;span&gt;ping&lt;/span&gt;.unicast.hosts: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] #为了安全起见，尽量将ElasticSearch节点的解析名配置进来（画圈圈）
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; # Prevent the &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;split brain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; by configuring the majority of nodes (total number of master-eligible nodes / &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; discovery.zen.minimum_master_nodes: &lt;span&gt;2&lt;/span&gt;&lt;span&gt; #脑裂预防选项
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; # For &lt;span&gt;more&lt;/span&gt;&lt;span&gt; information, consult the zen discovery module documentation.
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; # ---------------------------------- Gateway -----------------------------------
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; # Block initial recovery after a full cluster restart &lt;span&gt;until&lt;/span&gt;&lt;span&gt; N nodes are started:
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; #gateway.recover_after_nodes: &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; # For &lt;span&gt;more&lt;/span&gt;&lt;span&gt; information, consult the gateway module documentation.
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; # ---------------------------------- Various -----------------------------------
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;# Require explicit names when deleting indices:
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; #action.destructive_requires_name: &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ElasticSearch主配置&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　创建数据和日志目录并修改目录权限并启动ElasticSearch：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mkdir&lt;/span&gt; -pv /els/&lt;span&gt;{data,logs}
&lt;/span&gt;&lt;span&gt;chown&lt;/span&gt; -R elasticsearch.elasticsearch /els/&lt;br/&gt;systemctl start elasticsearch
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　启动时发生了错误：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115135322402-1195431643.png&quot; alt=&quot;&quot; width=&quot;661&quot; height=&quot;148&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　查看 &lt;span class=&quot;cnblogs_code&quot;&gt;/var/log/messages&lt;/span&gt; 发现一条警告信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
elasticsearch: OpenJDK &lt;span&gt;64&lt;/span&gt;-Bit Server VM warning: If the number of processors is expected to increase from one, &lt;span&gt;then&lt;/span&gt; you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;这是因为JVM中的 &lt;span class=&quot;cnblogs_code&quot;&gt;ParallelGCThreads&lt;/span&gt; 参数未设置正确导致的，我修改了虚拟机的线程数后又出现了新的报错：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
elasticsearch: Exception &lt;span&gt;in&lt;/span&gt; thread &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ElasticsearchParseException[duplicate settings key [path.data] found at line number [&lt;span&gt;36&lt;/span&gt;], column number [&lt;span&gt;12&lt;/span&gt;], previous value [/els/data], current value [/els/logs]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　这个的大致意思就是路径冲突了，后来发现在主配置文件中我将 &lt;span class=&quot;cnblogs_code&quot;&gt;path.logs: /els/logs&lt;/span&gt; 写成了 &lt;span class=&quot;cnblogs_code&quot;&gt;path.data: /els/logs&lt;/span&gt; ，导致路径冲突。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;启动完成后可以看到9200和9300端口被监听：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115143618935-1424569981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;至此ElasticSearch集群就已经工作起来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115150020262-1371755066.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.安装Kibana&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在n1上安装Kibana：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -ivh kibana-&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;修改Kibana配置文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/kibana/kibana.yml
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_f93173d9-56f3-48de-821d-79198f0bcfcd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f93173d9-56f3-48de-821d-79198f0bcfcd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f93173d9-56f3-48de-821d-79198f0bcfcd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;# Kibana is served by a back end server. This setting specifies the port to use.
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; #server.port: &lt;span&gt;5601&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; server.port: &lt;span&gt;5601&lt;/span&gt;&lt;span&gt; #监听端口
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; # Specifies the address to &lt;span&gt;which&lt;/span&gt;&lt;span&gt; the Kibana server will bind. IP addresses and host names are both valid values.
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; # The default is &lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;which&lt;/span&gt;&lt;span&gt; usually means remote machines will not be able to connect.
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; # To allow connections from remote users, set this parameter to a non-&lt;span&gt;loopback address.
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; #server.host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; server.host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.29.101&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; #监听地址
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; # Enables you to specify a path to &lt;span&gt;mount&lt;/span&gt; Kibana at &lt;span&gt;if&lt;/span&gt;&lt;span&gt; you are running behind a proxy. This only affects
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;# the URLs generated by Kibana, your proxy is expected to remove the basePath value before forwarding requests
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; # to Kibana. This setting cannot end &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a slash.
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; #server.basePath: &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; # The maximum payload size &lt;span&gt;in&lt;/span&gt; bytes &lt;span&gt;for&lt;/span&gt;&lt;span&gt; incoming server requests.
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; #server.maxPayloadBytes: &lt;span&gt;1048576&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; # The Kibana server&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s name.  This is used for display purposes.&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; #server.name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;your-hostname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; server.name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; #主机名
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; # The URL of the Elasticsearch instance to use &lt;span&gt;for&lt;/span&gt;&lt;span&gt; all your queries.
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; #elasticsearch.url: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://n2:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; elasticsearch.url: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://n2:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; #ElasticSearch地址
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; # When this setting&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s value is true Kibana uses the hostname specified in the server.host&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt; # setting. When the value of this setting is &lt;span&gt;false&lt;/span&gt;, Kibana uses the &lt;span&gt;hostname&lt;/span&gt;&lt;span&gt; of the host
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;# that connects to this Kibana instance.
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; #elasticsearch.preserveHost: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; # Kibana uses an index &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Elasticsearch to store saved searches, visualizations and
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; # dashboards. Kibana creates a new index &lt;span&gt;if&lt;/span&gt; the index doesn&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t already exist.&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; #kibana.index: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.kibana&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;# The default application to load.
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; #kibana.defaultAppId: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;discover&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;# If your Elasticsearch is protected with basic authentication, these settings provide
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;# the username and password that the Kibana server uses to perform maintenance on the Kibana
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; # index at startup. Your Kibana users still need to authenticate with Elasticsearch, &lt;span&gt;which&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;# is proxied through the Kibana server.
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; #elasticsearch.username: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; #可以设置登录认证用户和密码
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; #elasticsearch.password: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; # Enables SSL and paths to the PEM-&lt;span&gt;format SSL certificate and SSL key files, respectively.
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; # These settings enable SSL &lt;span&gt;for&lt;/span&gt;&lt;span&gt; outgoing requests from the Kibana server to the browser.
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; #server.ssl.enabled: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; #server.ssl.certificate: /path/to/your/&lt;span&gt;server.crt
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; #server.ssl.key: /path/to/your/&lt;span&gt;server.key
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; # Optional settings that provide the paths to the PEM-&lt;span&gt;format SSL certificate and key files.
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;# These files validate that your Elasticsearch backend uses the same key files.
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; #elasticsearch.ssl.certificate: /path/to/your/&lt;span&gt;client.crt
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; #elasticsearch.ssl.key: /path/to/your/&lt;span&gt;client.key
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; # Optional setting that enables you to specify a path to the PEM &lt;span&gt;file&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the certificate
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; # authority &lt;span&gt;for&lt;/span&gt;&lt;span&gt; your Elasticsearch instance.
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; #elasticsearch.ssl.certificateAuthorities: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/path/to/your/CA.pem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; # To disregard the validity of SSL certificates, change this setting&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s value to &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;none&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;#elasticsearch.ssl.verificationMode: full
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt; # Time &lt;span&gt;in&lt;/span&gt; milliseconds to &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; Elasticsearch to respond to pings. Defaults to the value of
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;# the elasticsearch.requestTimeout setting.
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; #elasticsearch.pingTimeout: &lt;span&gt;1500&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; # Time &lt;span&gt;in&lt;/span&gt; milliseconds to &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; responses from the back end or Elasticsearch. This value
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;# must be a positive integer.
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; #elasticsearch.requestTimeout: &lt;span&gt;30000&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt; # List of Kibana client-side headers to send to Elasticsearch. To send *no* client-&lt;span&gt;side
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;# headers, set this value to [] (an empty list).
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;#elasticsearch.requestHeadersWhitelist: [ authorization ]
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;# Header names and values that are sent to Elasticsearch. Any custom headers cannot be overwritten
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; # by client-&lt;span&gt;side headers, regardless of the elasticsearch.requestHeadersWhitelist configuration.
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;#elasticsearch.customHeaders: {}
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt; # Time &lt;span&gt;in&lt;/span&gt; milliseconds &lt;span&gt;for&lt;/span&gt; Elasticsearch to &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; responses from shards. Set to &lt;span&gt;0&lt;/span&gt;&lt;span&gt; to disable.
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; #elasticsearch.shardTimeout: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; # Time &lt;span&gt;in&lt;/span&gt; milliseconds to &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; Elasticsearch at Kibana startup before retrying.
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; #elasticsearch.startupTimeout: &lt;span&gt;5000&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt; # Specifies the path where Kibana creates the process ID &lt;span&gt;file&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; #pid.&lt;span&gt;file&lt;/span&gt;: /var/run/&lt;span&gt;kibana.pid
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt; # Enables you specify a &lt;span&gt;file&lt;/span&gt;&lt;span&gt; where Kibana stores log output.
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;#logging.dest: stdout
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt; # Set the value of this setting to &lt;span&gt;true&lt;/span&gt;&lt;span&gt; to suppress all logging output.
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; #logging.silent: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt; # Set the value of this setting to &lt;span&gt;true&lt;/span&gt;&lt;span&gt; to suppress all logging output other than error messages.
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; #logging.quiet: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; # Set the value of this setting to &lt;span&gt;true&lt;/span&gt;&lt;span&gt; to log all events, including system usage information
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;# and all requests.
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; #logging.verbose: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt; # Set the interval &lt;span&gt;in&lt;/span&gt;&lt;span&gt; milliseconds to sample system and process performance
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; # metrics. Minimum is 100ms. Defaults to &lt;span&gt;5000&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; #ops.interval: &lt;span&gt;5000&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt; # The default locale. This locale can be used &lt;span&gt;in&lt;/span&gt;&lt;span&gt; certain circumstances to substitute any missing
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;# translations.
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; #i18n.defaultLocale: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;浏览器访问http://192.168.29.101:5601，显示如下，说明Kibana已经安装成功:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115153608579-1754462410.png&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.在n6上安装Nginx和Filebeat&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　前面已经将ElasticSearch搜索引擎最重要的部分搭建完成了，可以进行搜索和构建索引了。下面来部署数据采集的部分。我这里用Nginx来做演示，用Filebeat将Nginx的日志搜集并输出给ElasticSearch并构建索引提供搜索。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在n6节点安装Nginx和Filebeat：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -ivh filebeat-&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;x86_64.rpm
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　配置Filebeat并启动：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/filebeat/filebeat.yml
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_3280cc06-0fcc-4c50-b85e-19d79dd17042&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3280cc06-0fcc-4c50-b85e-19d79dd17042&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3280cc06-0fcc-4c50-b85e-19d79dd17042&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #=========================== Filebeat prospectors =============================
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;filebeat.prospectors:
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; # Each -&lt;span&gt; is a prospector. Most options can be set at the prospector level, so
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; # you can use different prospectors &lt;span&gt;for&lt;/span&gt;&lt;span&gt; various configurations.
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;# Below are the prospector specific configurations.
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; -&lt;span&gt; input_type: log
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;  # Paths that should be crawled and fetched. Glob based paths.
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;  paths:
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     #- /var/log&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.log
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;    - /var/log/nginx/access.log #指定要采集的日志文件路径
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;    #- c:\programdata\elasticsearch\logs\*
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;  # Exclude lines. A list of regular expressions to match. It drops the lines that are
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;  # matching any regular expression from the list.
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;  #exclude_lines: [&quot;^DBG&quot;]
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;  # Include lines. A list of regular expressions to match. It exports the lines that are
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;  # matching any regular expression from the list.
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;  #include_lines: [&quot;^ERR&quot;, &quot;^WARN&quot;]
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;  # Exclude files. A list of regular expressions to match. Filebeat drops the files that
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;  # are matching any regular expression from the list. By default, no files are dropped.
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;  #exclude_files: [&quot;.gz$&quot;]
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;  # Optional additional fields. These field can be freely picked
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;  # to add additional information to the crawled log files for filtering
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;  #fields:
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;  #  level: debug
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;  #  review: 1
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;  ### Multiline options
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;  # Mutiline can be used for log messages spanning multiple lines. This is common
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;  # for Java Stack Traces or C-Line Continuation
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;  #multiline.pattern: ^\[
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;  # Defines if the pattern set under pattern should be negated or not. Default is false.
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;  #multiline.negate: false
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;  #multiline.match: after
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;#================================ General =====================================
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;# The name of the shipper that publishes the network data. It can be used to group
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;# all the transactions sent by a single shipper in the web interface.
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;#name:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;# The tags of the shipper are included in their own field with each
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;# transaction published.
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;#tags: [&quot;service-X&quot;, &quot;web-tier&quot;]
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;# Optional fields that you can specify to add additional information to the
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;# output.
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;#fields:
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;#  env: staging
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;#================================ Outputs =====================================
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;# Configure what outputs to use when sending the data collected by the beat.
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;# Multiple outputs may be used.
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;#-------------------------- Elasticsearch output ------------------------------
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;output.elasticsearch:
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;  # Array of hosts to connect to.
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;  hosts: [&quot;n2:9200&quot;] #数据输出到ElasticSearch，填写集群其中的一个即可
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;  # Optional protocol and basic auth credentials.
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;  #protocol: &quot;https&quot;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;  #username: &quot;elastic&quot;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;  #password: &quot;changeme&quot;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;#----------------------------- Logstash output --------------------------------
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;#output.logstash:
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;  # The Logstash hosts
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;  #hosts: [&quot;localhost:5044&quot;]
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;  # Optional SSL. By default is off.
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;  # List of root certificates for HTTPS server verifications
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;  #ssl.certificate_authorities: [&quot;/etc/pki/root/ca.pem&quot;]
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;  # Certificate for SSL client authentication
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;  #ssl.certificate: &quot;/etc/pki/client/cert.pem&quot;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;  # Client Certificate Key
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;  #ssl.key: &quot;/etc/pki/client/cert.key&quot;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;#================================ Logging =====================================
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;# Sets log level. The default log level is info.
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;# Available log levels are: critical, error, warning, info, debug
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;#logging.level: debug
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;# At debug level, you can selectively enable logging only for some components.
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;# To enable all selectors use [&quot;*&quot;]. Examples of other selectors are &quot;beat&quot;,
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;# &quot;publish&quot;, &quot;service&quot;.
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;#logging.selectors: [&quot;*&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
systemctl start filebeat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;在浏览器上访问n6节点，使Nginx生成日志文件，触发Filebeat将数据输出给ElasticSearch，然后访问n1节点的Kibana，配置索引模式构建索引。在Nginx被访问后会自动生成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115165351748-1701705537.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115170744999-1040493079.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.安装并配置Logstash&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在n5节点上安装Logstash，Logstash的运行依赖JDK环境，所以也需要安装JDK：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y java-&lt;span&gt;1.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-openjdk java-&lt;span&gt;1.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-openjdk-&lt;span&gt;devel
rpm &lt;/span&gt;-ivh logstash-&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　Logstash的组件结构分为输入组件(Input plugin)、输出组件(Output plugin)、过滤组件(Filter plugin)，图示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115173951449-890144058.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　测试Logstash是否能正常运行时，为避免与root发生权限冲突，需要切换至logstash用户尝试启动Logstash：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;su&lt;/span&gt; - logstash -s /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;主配置文件为： &lt;span class=&quot;cnblogs_code&quot;&gt;/etc/logstash/logstash.yml&lt;/span&gt; ，基本上不需要做修改，但要修改n6节点上的Filebeat配置文件，将Filebeat的输出从ElasticSearch修改成向Logstash输出：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_dab0d82a-cb16-41d8-87ed-336f9f3dd5b7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dab0d82a-cb16-41d8-87ed-336f9f3dd5b7&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dab0d82a-cb16-41d8-87ed-336f9f3dd5b7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
#----------------------------- Logstash output --------------------------------&lt;span&gt;
output.logstash:
  # The Logstash hosts
  #hosts: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:5044&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  hosts: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n5:5044&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　在n5节点上编写Logstash过滤模块：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_cab72f3b-b359-4038-833f-6a84e965e9d8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cab72f3b-b359-4038-833f-6a84e965e9d8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cab72f3b-b359-4038-833f-6a84e965e9d8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;input { #定义数据输入来源，这里定义的是从Filebeat输入
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        beats {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 host =&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  #监听地址
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 port =&amp;gt; &lt;span&gt;5044&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;filter { #过滤模块，将输入的数据按某种定义的格式做处理切割
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   grok { #由grok模块来过滤
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       match =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{IPORHOST:clientip}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; #切割源message的格式                                                     
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;output { #将过滤后的数据输出到ElasticSearch
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        elasticsearch {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 hosts =&amp;gt; [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n2:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n2:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n2:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 index =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logstash-nginxlog-%{+YYYY.MM.dd}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;在Kibana上重新查找便能看出已经将 &lt;span class=&quot;cnblogs_code&quot;&gt;clientip&lt;/span&gt; 切割出来了，这种的切割功能用Filebeat是没办法实现的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115221001042-1290412814.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;104&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 14:13:00 +0000</pubDate>
<dc:creator>readygood</dc:creator>
<og:description>一、ELK搜索引擎原理介绍 在使用搜索引擎是你可能会觉得很简单方便，只需要在搜索栏输入想要的关键字就能显示出想要的结果。但在这简单的操作背后是搜索引擎复杂的逻辑和许多组件协同工作的结果。 搜索引擎的组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/readygood/p/9955533.html</dc:identifier>
</item>
<item>
<title>标准化和归一化对机器学习经典模型的影响 - SongHL</title>
<link>http://www.cnblogs.com/songorz/p/9966397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songorz/p/9966397.html</guid>
<description>&lt;h2&gt;归一化&lt;/h2&gt;
&lt;p&gt;归一化也称标准化，是处理数据挖掘的一项基础工作,使用归一化的原因大体如下：&lt;/p&gt;
&lt;p&gt;数据存在不同的评价指标，其量纲或量纲单位不同，处于不同的数量级。解决特征指标之间的可比性，经过归一化处理后，各指标处于同一数量级，便于综合对比。求最优解的过程会变得平缓，更容易正确收敛。即能提高梯度下降求最优解时的速度。提高计算精度。适合进行综合对比评价。&lt;/p&gt;
&lt;h3&gt;MinMaxScaler&lt;/h3&gt;
&lt;p&gt;线性归一化，也称为离差标准化，是对原始数据的线性变换，MinMax标准化方法的缺陷在当有新数据加入时，可能会导致X.max和X.min的值发生变化，需要重新计算。其转换函数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171013084706198&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;StandardScaler&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;标准差归一化&lt;/strong&gt;，也叫Z-score标准化，这种方法给予原始数据的均值（mean，μ）和标准差（standard deviation，σ）进行数据的标准化。经过处理后的数据符合标准正态分布，即均值为0，标准差为1，转化函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171013085253015&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;MaxAbsScaler&lt;/h3&gt;
&lt;p&gt;原理与MinMaxScaler很像，只是数据会被规模化到[-1,1]之间。也就是特征中，所有数据都会除以最大值。这个方法对那些已经中心化均值维0或者稀疏的数据有意义。&lt;/p&gt;
&lt;h2&gt;模型&lt;/h2&gt;
&lt;p&gt;本次实验使用了5个模型，分别为Lasso、Redige、SVR、RandomForest、XGBoost。&lt;/p&gt;
&lt;h2&gt;方法：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;以不同方式划分数据集和测试集&lt;/li&gt;
&lt;li&gt;使用不同的归一化（标准化）方式&lt;/li&gt;
&lt;li&gt;使用不同的模型&lt;/li&gt;
&lt;li&gt;通过比较MSE（均方误差，mean-square error）的大小来得出结论&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;部分代码及结果&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#data = pd.read_csv('路径')

data = data.sort_values(by='time',ascending=True)
data.reset_index(inplace=True,drop=True)

target = data['T1AOMW_AV']
del data['T1AOMW_AV']&lt;br/&gt;　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;数据处理&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;   去除缺失值&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 没有缺失值
All_NaN = pd.DataFrame(data.isnull().sum()).reset_index()
All_NaN.columns = ['name','times']
All_NaN.describe()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181115215848181-626177738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所有数据中，干掉 方差小于1的属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
feature_describe_T = data.describe().T
std_feature = feature_describe_T[feature_describe_T['std']&amp;lt;1].index
feature = [column for column in data.columns if column not in std_feature]  # 筛选方差大于1的属性 
data = data[feature]

del data['time']
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
test_data = data[:5000]

data1 = data[5000:16060]
target1 = target[5000:16060]
data2 = data[16060:]
target2 = target[16060:]

import scipy.stats as stats
dict_corr = {
    'spearman' : [],
    'pearson' : [],
    'kendall' : [],
    'columns' : []
}

for i in data.columns:
    corr_pear,pval = stats.pearsonr(data[i],target)
    corr_spear,pval = stats.spearmanr(data[i],target)
    corr_kendall,pval = stats.kendalltau(data[i],target)
    
    dict_corr['pearson'].append(abs(corr_pear))
    dict_corr['spearman'].append(abs(corr_spear))
    dict_corr['kendall'].append(abs(corr_kendall))
    
    dict_corr['columns'].append(i)
    
# 筛选新属性  
dict_corr =pd.DataFrame(dict_corr)
new_fea = list(dict_corr[(dict_corr['pearson']&amp;gt;0.32) &amp;amp; (dict_corr['spearman']&amp;gt;0.48) &amp;amp; (dict_corr['kendall']&amp;gt;0.44)]['columns'].values)
# 选取原则，选取25%分位数 以上的相关性系数
dict_corr.describe()
len(new_fea)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181115215927866-553298576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;各种模型的测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;81&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from sklearn.linear_model import LinearRegression,Lasso,Ridge
from sklearn.preprocessing import MinMaxScaler,StandardScaler,MaxAbsScaler
from sklearn.metrics import mean_squared_error as mse
from sklearn.svm import SVR

mm = MinMaxScaler()
lr = Lasso(alpha=0.5)

lr.fit(mm.fit_transform(data1[new_fea]), target1)
lr_ans = lr.predict(mm.transform(data2[new_fea]))

print(&quot;LR : &quot;, mse(lr_ans,target2) )##lr
ridge = Ridge(alpha=0.5)
ridge.fit(mm.fit_transform(data1[new_fea]),target1)
ridge_ans = ridge.predict(mm.transform(data2[new_fea]))

print(&quot;ridge : &quot;,mse(ridge_ans,target2 ))#ridge
svr = SVR(kernel='rbf',C=100,epsilon=0.1).fit(mm.fit_transform(data1[new_fea]),target1)
svr_ans = svr.predict(mm.transform(data2[new_fea]))
print(&quot;svr : &quot;,mse(svr_ans,target2) )#svr
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(data[new_fea],target,test_size=0.25,random_state=12345)

ss = MaxAbsScaler()
ss_x_train = ss.fit_transform(X_train)
ss_x_test = ss.transform(X_test)

estimator_lr = Lasso(alpha=0.5).fit(ss_x_train,y_train)
predict_lr = estimator_lr.predict(ss_x_test)
print('Lssao:',mse(predict_lr,y_test))

estimator_rg = Ridge(alpha=0.5).fit(ss_x_train,y_train)
predict_rg = estimator_rg.predict(ss_x_test)
print('Ridge:',mse(predict_rg,y_test))

estimator_svr = SVR(kernel='rbf',C=100,epsilon=0.1).fit(ss_x_train,y_train)
predict_svr = estimator_svr.predict(ss_x_test)
print('SVR:',mse(predict_svr,y_test))

estimator_RF = RandomForestRegressor().fit(ss_x_train,y_train)
predict_RF = estimator_RF.predict(ss_x_test)
print('RF:',mse(predict_RF,y_test))

predict_XG  = xgb.XGBRegressor(learn_rate=0.1,n_estimators = 550,max_depth = 4,min_child_weight = 5,seed=0,subsample=0.7,gamma=0.1,reg_alpha=1,reg_lambda=1)
predict_XG.fit(ss_x_train,y_train)
predict_XG_ans=predict_XG.predict(ss_x_test)
print(&quot;predict_XG : &quot;, mse(predict_XG_ans,y_test))&lt;br/&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　结果：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181115215718784-1692907952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于Lasso模型，使用MaxAbsScaler方式时，mse增大十分明显，且归一化后结果高于不进行归一化时;&lt;/li&gt;
&lt;li&gt;对于Redige模型，归一化结果也明显高于不归一化时的结果;&lt;/li&gt;
&lt;li&gt;对于SVR模型，不进行归一化时，其MSE会非常大;&lt;/li&gt;
&lt;li&gt;对于RandomForest和XGBoost来说，是否进行归一化对结果影响不大;&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Thu, 15 Nov 2018 14:04:00 +0000</pubDate>
<dc:creator>SongHL</dc:creator>
<og:description>归一化 归一化也称标准化，是处理数据挖掘的一项基础工作,使用归一化的原因大体如下： 数据存在不同的评价指标，其量纲或量纲单位不同，处于不同的数量级。解决特征指标之间的可比性，经过归一化处理后，各指标处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songorz/p/9966397.html</dc:identifier>
</item>
<item>
<title>我与时间管理的故事 - 追梦子</title>
<link>http://www.cnblogs.com/pssp/p/9966121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pssp/p/9966121.html</guid>
<description>&lt;p&gt;这是上家公司，在团队做的分享，还是挺有意思的，特此分享。&lt;/p&gt;
&lt;h2 id=&quot;初识树状文档&quot;&gt;初识树状文档&lt;/h2&gt;
&lt;p&gt;记得刚来团队那会, 每天早上有个站会, 站会的任务就是把今天要做的事情写到树状文档里面, 刚开始这样做我是不太认同的, 因为在以前的公司并没有这么做过, 在之前的公司最多也就是写写周报, 然而对于周报而言,当时我也是比较反感的, 因为那时觉得写这些东西根本没有多少意义,写这个就是为了给领导看的, 然而之前写了也没人给反馈, 所以导致那时我对写这些东西是十分的不认同&lt;/p&gt;
&lt;p&gt;然而不管认不认同吧, 既然团队有这个要求,也只好按照要求去写了, 记录的方式倒是很简单, 就是把要做的事情写到文档里面, 然后记录下这件事的状态, 一般用的状态是todo,done和cancel&lt;/p&gt;
&lt;p&gt;在我按照团队的要求记录了一段时间后就感到现在的记录方式和之前公司写周报的方式是很不一样的, 之前是每周五下班前把本周做的工作和下周的工作计划用微信发送给我们的Leader, 然后Leader汇总后发送给管理层, 而现在我们团队的做法让我觉得记录这些并不是为了给谁看而写, 而是为了帮我更好的理清我要做的事, 以及不会把要做的事情忘记&lt;/p&gt;
&lt;p&gt;当然, 让我能够在短时间内认同这一点, 还要感谢团队和亮哥开发的树状文档工具, 因为它的记录方式让我觉得是非常友好和方便的&lt;/p&gt;
&lt;p&gt;这样做的时间越久, 我就越坚信每天把要做的事情记录下来是很有意义的, 因为有了这些记录的内容,我们以后就可以很方便的进行查看, 尽管现在可能没有什么用, 但以后就说不定了&lt;/p&gt;
&lt;p&gt;比如: 前段时间亮哥code view了我半年前的一个项目代码, 里面有一段很难理解的代码, 然后亮哥问我那段代码是怎么回事, 然而由于时间太久, 导致现在让我去想我也想不出当时为什么那样写的, 然后我只好去查git, 但是当时git一次提交的内容太多了, 导致提交的信息也没能很好的解释清楚那段代码到底是做什么的, 后来通过拿git的提交时间, 在当时的任务列表里面找到了那段代码相关的解释, 不过可惜的是, 当时写的信息比较少, 所以也只是知道那段代码是为了解决某个bug才那样去写的&lt;/p&gt;
&lt;p&gt;所以说记录是很有必要的, 不过把内容记录的详细点也是很重要的, 不然就有可能发生像我前面说的那样&lt;/p&gt;
&lt;p&gt;另外因为每天记录了当天做的事情, 因此当团队需要写周报的话, 那基本上就不需要花多少时间去回忆做过的事情了,只需要把之前记录下来的整理和修改一下就可以了&lt;/p&gt;
&lt;h2 id=&quot;todo与四象限&quot;&gt;Todo与四象限&lt;/h2&gt;
&lt;p&gt;当你有过一段时间这样的记录后, 你会发现其实记录不仅仅是为了防止忘记还有什么事情没做, 更是为了让你知道你现在做到了哪&lt;/p&gt;
&lt;p&gt;想起某次分享会上, 亮哥对GTD也就是任务管理做了一次分享, 在那次分享之后, 我对记录和知识管理更加着迷, 那之后不久, 很偶然的, 我学了四象限, 它是用来区分任务的紧急程度的&lt;/p&gt;
&lt;p&gt;记得当时我做过一次关于四象限的分享, 那时我以为我会将四象限用上很长一段时间, 但那之后的一段时间里, 我发现在实际的工作中,我更多的是在自我挑选任务, 而不是根据任务的紧急程度去做事,因此我在使用四象限的过程中, 常常将所有事情都给放在了重要且紧急,或者不紧急但重要里面, 最后的结果就是, 我的四象限与Todo列表基本上没有什么区别了, 然后我就在想, 既然这样,那干脆还是使用原来的方式做个Todo列表好了, 于是四象限就这样被我抛弃了&lt;/p&gt;
&lt;p&gt;在放弃四象限后,我得出了几点, 很多时候你是无法控制住自己先去做哪些事情, 然后再去做哪些事情的, 尽管你可能知道某件事相对于另一件事来说更重要一些, 但是四象限根本就没有办法控制你不去做某件事情, 或者去做某件事, 也就是说如果一个人能够控制住自己, 那么就算是使用最简单的Todo列表也能很好的根据自己的价值观做出选择并加以执行, 相反如果不能控制住自己, 那么就算有四象限也将是一个虚设&lt;/p&gt;
&lt;p&gt;尽管我说我抛弃了四象限, 但这么说也不全对, 因为在某些情况下, 我还是会按照四象限推崇的以任务的重要程度来区分先后顺序, 只不过是我没有再去将任务分为4块, 对比使用四象限和现在的区别就在于, 现在使用任务的重要程度来区分先后顺序的比例减少了, 更多的是由自己当下发挥&lt;/p&gt;
&lt;p&gt;现在我使用任务的重要程度来区分先后顺序的常见惯例是, 我正在做某件事, 突然接到一个新任务, 那么这时我就会按照任务的重要和紧急程度来决定是否要放下手上的这件事而去做新接的任务&lt;/p&gt;
&lt;p&gt;不过我, 除了考虑任务的重要和紧急程度, 还会去想的一个问题就是, 如果现在不做这件事, 是否会影响之后任务的执行, 另外如果新接的这个任务能够在几分钟内完成或者这件事并不需要我来完成, 而是需要我转告给另一个同事, 那么这时我也会放下当前正在做的事情, 去做新接的任务&lt;/p&gt;
&lt;p&gt;不过当你真正做任务管理的时候, 你会发现我们除了考虑任务的重要紧急程度以外, 还有很多其他的方案可以选择, 并且如果你真的完全按照任务的重要和紧急程度去做, 也不见得就好, 因为任务的重要程度是会变化的, 也许某件事对于今年来说是重要的, 但有可能后来因为某些原因导致那件变得没有多少必要了, 所以留有一定的自由选择也是很有意义的&lt;/p&gt;
&lt;p&gt;在任务管理方面我主要使用的方法是, 收集, 记录, 整理, 执行, 当然, 如果要做的那件事很够在1,2分钟内就完成, 那么我就不会去记录, 而是直接把它做完&lt;/p&gt;
&lt;h2 id=&quot;时间记录法&quot;&gt;时间记录法&lt;/h2&gt;
&lt;p&gt;其实, 我除了每天会去写任务列表外, 还有一件比较重要的就是, 我会把每件事花费的时间记录下来&lt;/p&gt;
&lt;p&gt;记录的方式是参考的柳比歇夫的时间记录法, 柳比歇夫是一位苏联的昆虫学家, 但大多数人认识他的原因并不是因为他是昆虫学家, 而是因为他的时间记录法, 有本书叫做&amp;lt;奇特的一生&amp;gt;, 里面讲述了柳比歇夫56年如一日的通过记录每天的时间花费情况做统计, 然后将统计后的结果进行分析, 最后根据分析的结果去安排自己的时间&lt;/p&gt;
&lt;p&gt;时间记录法的规则很简单, 就是将每天做的事情和花费的时间记录下来, 这些记录下来的会被作为下一次计划任务时的一个参考, 如果是按照柳比歇夫的做法, 那么我们还需要定期对这些做过的事做一次回顾&lt;/p&gt;
&lt;p&gt;在使用时间记录法的一段时间后, 我通过记录的这些数据了解到自己在哪些方面浪费的时间比较多, 以及每天真正花在做事的时间上有多少, 当有一定的数据后, 我就可以算出平均每天有多少时间是有效的, 有效时间, 指的是, 抛除那些不可工作后的时间, 比如走路,喝水, 等&lt;/p&gt;
&lt;p&gt;当我知道了自己每天有多少有效时间后, 我就可以拿当天记录的数据与有效时间做个比较, 看是多了还是少了, 如果是少了, 那么就应该去看是在哪些地方花费的时间比较多, 并做好总结避免下次再出现这种情况&lt;/p&gt;
&lt;p&gt;通过时间记录法, 我们还可以了解到某类事情需要花费多少时间,比如之前我看某种类型的书籍需要花费3小时, 那么在下一次我要看类似书籍的时候就能够估计出一个大概的时间了, 如果我之前没有做过这方面的记录, 那么我就只能是瞎猜&lt;/p&gt;
&lt;p&gt;有了数据后, 我可以更合理的去安排下一次计划, 不至于将一天安排的过多或过少, 之所以可以更合理的去安排下一次的计划, 就在于我之前做过类似的事情, 并有相关的记录, 因此现在再去做类似的事情心里肯定是有个大体的数的&lt;/p&gt;
&lt;p&gt;时间记录法还有一个好处, 那就是你能够分析出, 你对某类事情的兴趣增减情况&lt;/p&gt;
&lt;h2 id=&quot;番茄工作法&quot;&gt;番茄工作法&lt;/h2&gt;
&lt;p&gt;在工作中, 我们常常会因为无法专注的去做某件事而苦恼, 那么这时可以考虑番茄工作法&lt;/p&gt;
&lt;p&gt;番茄工作法是一套工作流, 其目的是提高专注力, 以及合理的安排休息时间, 番茄工作法的原理是将一天分为多个番茄, 一般每个番茄为25分钟, 每做完一个番茄就休息5分钟, 一旦开始某个番茄, 就不能被中断, 如果被中断, 那么这个番茄将被作废, 需要重新开始, 在你准备使用番茄时, 需要确保你的时间不会被他人打扰, 如果无法确定那么就不要使用了&lt;/p&gt;
&lt;p&gt;不过在实际情况中, 往往25分钟是不可能的, 比如我在编程中, 往往一写就是几个小时, 比如5月1号的下午, 我从4点左右开始写某个东西, 结果一写就到晚上7点左右了, 当然长时间做电脑旁是不太好的, 但往往就控制不住自己, 比如写到一半多的时候, 就想着都快写完了, 干脆写完好了, 反正很多时候就是这样&lt;/p&gt;
&lt;p&gt;尽管说番茄工作法的时间分配并不适合我, 但是我依然喜欢番茄工作法, 因为虽然我可以长时间的去做某件事, 但是并不代表我可以始终专一的去做那件事, 时常在做那件事时, 做着做着就去弄了和它不相关的东西, 正因为有这一点, 我才认为说, 番茄工作法对我依然是有益的, 只是它和四象限一样我不需要完全去按照官方推荐的做法去执行而已&lt;/p&gt;
&lt;p&gt;另外它推荐的休息时间, 也是比较不错的, 因为长时间的工作真的不是太好, 尽管我现在还没有做到, 但我现在也在开始准备往这方面去考虑, 怎么安排会比较合适&lt;/p&gt;
&lt;p&gt;在你刚开始使用番茄工作法时, 可能会产生一些焦虑感, 容易让你去想现在还剩多少时间, 不过在你使用一段时间后, 焦虑感会逐渐消失, 当然这也可能是我个人情况, 如果你没有产生自然是好的, 如果产生了也不必惊慌&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;有一天你会发现, 不管我们如何做时间管理, 我们永远都不可能会有将任务做完的一天, 甚至会让你的事情变得越来越多,所以在装进杯子里面之前, 看看装进去的是什么, 不要为了装满杯子, 而把什么都往里面塞&lt;/p&gt;
&lt;p&gt;然后问问自己,需要那么多时间做什么, 因为如果你不知道你为什么要那么多时间, 那就是给你很多空闲的时间, 那也只会是浪费&lt;/p&gt;
&lt;p&gt;关于时间的分享就到这了, 最后我还想说的是:&lt;/p&gt;
&lt;p&gt;有时我们容易过早的去拒绝一些新鲜的事物, 但这样做的结果就是, 我们少了一种新的可能性, 在没有实际用过它之前, 我们往往不知道它到底有什么用, 或者说用还是不用它,对我们有什么改善, 然而如果你没有去用它, 是不太可能想明白的, 理性的做法是自己试验一段时间，看看是否真的有效&lt;/p&gt;
&lt;p&gt;给它一个公平的机会, 也给自己一个改变自己的机会, 不管现在你认为它是好的还是坏的&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 13:19:00 +0000</pubDate>
<dc:creator>追梦子</dc:creator>
<og:description>这是上家公司，在团队做的分享，还是挺有意思的，特此分享。 初识树状文档 记得刚来团队那会, 每天早上有个站会, 站会的任务就是把今天要做的事情写到树状文档里面, 刚开始这样做我是不太认同的, 因为在以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pssp/p/9966121.html</dc:identifier>
</item>
<item>
<title>详解C#泛型（二） - Minotauros</title>
<link>http://www.cnblogs.com/minotauros/p/9965997.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minotauros/p/9965997.html</guid>
<description>&lt;p&gt;　　一、自定义泛型方法（Generic Method），将类型参数用作参数列表或返回值的类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; MyFunc&amp;lt;T&amp;gt;() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明具有一个类型参数的泛型方法&lt;/span&gt;
&lt;span&gt;{
    Type genericType &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;(T); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在泛型方法体内部获取类型参数的类型信息
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用泛型方法&lt;/span&gt;
MyFunc&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.声明泛型方法时，可以在参数列表中使用这个类型参数：void MyFunc&amp;lt;T&amp;gt;(T obj) { }；此时在调用该泛型方法时可以省略类型参数的指定由编译器推断其类型，例如：MyFunc&amp;lt;int&amp;gt;(myNum)与MyFunc(myNum)完全等效；&lt;/p&gt;
&lt;p&gt;　　2.声明泛型方法时，可以在返回值类型中使用这个类型参数：T MyFunc&amp;lt;T&amp;gt;() { return default(T); }；编译器的类型推断功能不适用于仅在返回值类型中使用类型参数的情况，此种情况在调用时必须显式指定类型参数；&lt;/p&gt;
&lt;p&gt;　　3.声明泛型方法时，方法的参数列表和返回值可以指定相同或不相同的类型参数，如果不相同则一般参数列表的类型参数在前，返回值的类型参数在后：U MyFunc&amp;lt;T, U&amp;gt;(T obj) { return default(U); }，此时依然不能使用编译器的类型推断功能；如果相同，则在调用时可以使用编译器的类型推断功能省略类型参数的显式指定；&lt;br/&gt;类型参数数量的不同，可以构成重载方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MyFunc() { }
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc&amp;lt;T&amp;gt;&lt;span&gt;() { }
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc&amp;lt;T, U&amp;gt;() { }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.泛型方法中的类型参数也可以指定约束；&lt;/p&gt;
&lt;p&gt;　　5.在泛型类中声明的方法，方法的参数列表和返回值可以使用泛型类的类型参数作为类型；泛型方法可出现在泛型或具体类型中，只有当方法有属于自己的类型参数时才是泛型方法，在泛型类中声明泛型方法时，二者类型参数的占位符不可以相同：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; MyClass&amp;lt;T&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个泛型类，类型参数占位符为T&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc(T obj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个非泛型方法，使用泛型类的类型参数T作为参数类型&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能声明泛型方法void MyFunc&amp;lt;T&amp;gt;，泛型方法的类型参数占位符不能与类的类型参数占位符相同&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; MyFunc&amp;lt;U&amp;gt;(T obj1, U obj2) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个泛型方法，类型参数占位符为U&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyClass &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个具体类&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc&amp;lt;T&amp;gt;(T obj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个泛型方法&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;    }
}            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　二、自定义泛型接口（Generic Interface），将类型参数用作参数列表或返回值的类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt; IMyInterface&amp;lt;T&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义具有一个类型参数的泛型接口&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc(T obj); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明参数为T的方法&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明泛型类继承自泛型接口&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyClass&amp;lt;T&amp;gt; : IMyInterface&amp;lt;T&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; MyFunc(T obj)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定类型参数为string类型，创角泛型类的实例赋值给泛型接口的变量&lt;/span&gt;
IMyInterface&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; iMyInterface = &lt;span&gt;new&lt;/span&gt; MyClass&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.适用于泛型类的规则基本也适用于泛型接口；&lt;/p&gt;
&lt;p&gt;　　三、自定义泛型委托（Generic Delegate），将类型参数用作参数列表或返回值的类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MyDelegate&amp;lt;T&amp;gt;(T obj); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义具有一个类型参数的泛型委托，参数列表中有一个参数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; MyGenericFunc&amp;lt;T&amp;gt;(T obj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个泛型方法，参数列表中有一个参数&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明泛型委托的实例，指定类型参数为string类型，此时可匹配的方法签名为void myFunc(string str)&lt;/span&gt;
MyDelegate&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; myDelegate;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;赋值一个指定类型参数为string的泛型方法&lt;/span&gt;
myDelegate = MyGenericFunc&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个参数列表为string类型的具体方法&lt;/span&gt;
myDelegate += MyFunc;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.泛型委托同泛型类一样，需要在实例化时指定类型参数的类型；&lt;/p&gt;
&lt;p&gt;　　2.泛型委托的实例同具体委托的实例一样，只需要方法的参数列表和返回值类型相同即可进行匹配，因此不管目标方法是指定了符合要求类型的泛型方法还是具体方法都可以进行匹配；　&lt;/p&gt;
&lt;p&gt;　　四、反射中的泛型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Type myType = &lt;span&gt;typeof&lt;/span&gt;(MyClass&amp;lt;&amp;gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取未指定任何类型参数的开放式构造类的类型信息，多个类型参数时添加,：typeof(MyClass&amp;lt;,&amp;gt;)&lt;/span&gt;
myType = myType.MakeGenericType(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过类型信息的实例方法MakeGenericType()构建指定所有类型参数的封闭式构造类的类型信息，如未指定所有类型参数会抛出异常ArgumentException
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以直接获取封闭式构造类的类型信息，当类型参数在一开始就确定时推荐使用此种方式
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;myType = typeof(MyClass&amp;lt;int&amp;gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多个类型参数时需要同时指定：typeof(MyClass&amp;lt;int, string&amp;gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.通过反射只可以获取未指定任何类型参数的开放式构造类的类型信息和指定所有类型参数的封闭式构造类的类型信息，即无法获取MyClass&amp;lt;int, &amp;gt;的类型信息；&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“推荐”按钮，您的认可是我写作的最大动力！&lt;/p&gt;
&lt;p&gt;作者：&lt;a title=&quot;Minotauros&quot; href=&quot;https://www.cnblogs.com/minotauros/&quot; target=&quot;_blank&quot;&gt;Minotauros&lt;/a&gt;&lt;br/&gt;出处：&lt;a title=&quot;https://www.cnblogs.com/minotauros/&quot; href=&quot;https://www.cnblogs.com/minotauros/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/minotauros/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/p&gt;

</description>
<pubDate>Thu, 15 Nov 2018 12:54:00 +0000</pubDate>
<dc:creator>Minotauros</dc:creator>
<og:description>一、自定义泛型方法（Generic Method），将类型参数用作参数列表或返回值的类型： 1.声明泛型方法时，可以在参数列表中使用这个类型参数：void MyFunc&lt;T&gt;(T obj)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minotauros/p/9965997.html</dc:identifier>
</item>
<item>
<title>【安卓本卓】Android系统源码篇之（二）Source Insight - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/9965714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/9965714.html</guid>
<description>&lt;p&gt; &lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        &lt;/strong&gt;“Source Insight（以下简称SI）是世界上最好的编辑器”，说这句话不知道会不会出门被打呢？-_- 中国古话说得好，“文无第一，武无第二”，所以不敢说SI是最好的，但是说是“最好的之一”绝对是妥妥的。它以丰富的语言支持、便捷的功能、快速的源码导航、实时的上下文显示、独立的符号数据库等众多优点，在全世界范围内广受程序员们的欢迎。本文将结合笔者的实际操作和学习，基于SI3.5做一些使用记录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、SI简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       SI是一款面向项目开发的程序编辑器和代码浏览器，它提供了一个视图将分散在各个地方的代码汇合在一起形成一个虚拟的整体，供开发者方便地阅读和编辑，如下图所示。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181113185535538-682678704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;Body&quot;&gt;        Source Insight was designed to enhance your ability to understand and modify your program. Our company mission is to increase programming team productivity by clarifying source code, presenting information in a useful way, and allowing programmers to modify software in large, complex projects. ……Source Insight acts as an information server that surrounds your project’s source code. With it, you can have instant access to symbolic and textual information in your program.&lt;/p&gt;
&lt;p class=&quot;Body&quot;&gt;       该段英文摘自SI官方帮助文档，从这里可以看出SI的设计主旨是方便开发者查看和修改源码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、SI的优势&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        SI是如今最好用的语言编辑器之一，具有很多其他编辑器无法比拟的优点，比如下面几点。&lt;/p&gt;
&lt;p&gt;  1、支持语言种类多。&lt;/p&gt;
&lt;p&gt;        SI几乎支持所有的语言，如C、C++、C#、JAVA\、ASM、PAS、ASP、HTML等，而其它编辑器往往只支持其中某类或某几种语言，丰富性远不及SI。&lt;/p&gt;
&lt;p&gt;  2、拥有自己的数据库。&lt;/p&gt;
&lt;p&gt;        SI自动传创建并维护他自己高性能的符号数据库，包括函数、method、全局变量、结构、类、注释和功能源文件里定义的其它类型的符号等。我们可以通俗地理解为缓存，当需要再次查找某个符号时，就可以直接从数据库中查找，而不用在整个源码库中搜索，极大提高了效率。&lt;/p&gt;
&lt;p&gt;  3、显示丰富的程序相关信息。&lt;/p&gt;
&lt;p&gt;       SI提供了丰富多彩的窗口，为被选中的代码提供丰富的信息，如reference trees、class inheritance diagrams、call tress，symbol windows等。后面会专门介绍这些窗口的使用。&lt;/p&gt;
&lt;p&gt;  4、实时显示上下文信息。&lt;/p&gt;
&lt;p&gt;       SI提供了Context Window，当鼠标选择代码中的某个符号时，该window会实时显示选中符号的上下文信息。在下文中的Context Window会详细讲到。甚至在你编辑的时候，SI同时分析你的源码，提供实时的信息并进行分析。 &lt;/p&gt;
&lt;p&gt;  5、快速。&lt;/p&gt;
&lt;p&gt;        提供了快速和革新的访问源代码和源信息的能力，能以最快的速度对源代码导航和提供任何程序编辑器的源信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、创建项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        &lt;/strong&gt;在SI窗口的顶部工具栏上依次点击 Project &amp;gt; New Project，即可开始创建一个新的项目了。之所以要特别介绍项目的创建过程，除了这是一个极常用的操作外，还有就是创建过程中有一些注意事项需要留心，笔者在使用过程中就曾经走过不少弯路。&lt;/p&gt;
&lt;p&gt;  1、项目命名及设置项目存储路径&lt;/p&gt;
&lt;p&gt;       这里需要注意的是，选择项目数据文件存储路径的时候，要选择你的源码所在的盘符，因为在后面添加源文件的时候，只能从这里设置的盘符中添加（不知道其它用户有没有碰到这个情况，笔者在两台机器上操作过，都是如此）。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114215934809-765846843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  2、项目设置&lt;/p&gt;
&lt;p&gt;        这里就按照默认的选择就可以了，笔者就是这么做的。当然，这个要根据用户自己需要来选择了，看个人喜好。&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114220037784-1823060746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  3、添加/删除项目文件&lt;/p&gt;
&lt;p&gt;       在这个界面上，可以看到左侧“Directory”这一栏的根节点，就是第一步中咱们选择的存储项目的盘符，如果你要添加的源文件不在这个盘符，就没法找到了。在该盘符下选择想要添加的文件，如蓝色部分“Android-8.0.0_r1”，这是Android 系统源码根目录，因为这里选择的是文件夹，所以点击右边的“Add Tree”来添加整个目录。如果选择的是文件，多个文件就选择“Add All”，单个文件就选择“Add”&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114220334280-829319168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       添加时会给出对话框，表示正在添加。笔者添加的源码目录有4G以上，所以这时需要等待好几分钟的时间。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114220434437-231551695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       添加完成以后，可以看到对话框提示，点击“确定”即可，此时可以继续添加项目文件。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114221351408-1110464047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  4、完成项目创建&lt;/p&gt;
&lt;p&gt;      当不需要再添加文件了，点击“Close”按钮关闭该界面，即完成了项目的创建。此时显示的界面如下，左下区域显示的就是新建的项目，列表显示了项目中文件。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181115193743389-665289277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       持续更新中......&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://baike.baidu.com/item/source%20insight/1833181&quot; target=&quot;_blank&quot;&gt;Source Insight 百度百科&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 11:54:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>Source Insight是当前世界上最好的程序编辑器之一，几乎支持所有的语言，拥有丰富且便捷的功能，快递的源码导航能力，实时显示的上下文信息，独立的符号数据库等特点，使得它在世界范围内广受程序员和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/9965714.html</dc:identifier>
</item>
<item>
<title>浅析微信支付：(余额提现)企业付款到微信用户零钱或银行卡账户 - YClimb</title>
<link>http://www.cnblogs.com/yclimb/p/9965698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yclimb/p/9965698.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文是【浅析微信支付】系列文章的第十二篇，主要讲解在商户存在的提现、商户付款到微信用户零钱或者银行卡需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;浅析微信支付系列已经更新十二篇了哟～，没有看过的朋友们可以看一下哦。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YESU2V5byxfM8z9YQXgnuA&quot;&gt;浅析微信支付：支付验收示例和验收指引&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/WmnsCnIrhN9STbvrNTQOiA&quot;&gt;浅析微信支付：如何使用沙箱环境测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/XCR1Ts-uabuC573_vLb3Qg&quot;&gt;浅析微信支付：下载对账单和资金账单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/IyWjWB__-VsqKO8SL0DL3Q&quot;&gt;浅析微信支付：申请退款、退款回调接口、查询退款&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是做电商或者某些有福利返利的系统，基本上会遇到诸如 &lt;code&gt;余额提现&lt;/code&gt; 这类需求，主要就是平台向用户返利现金，积累到某一个门槛，可以领取到自己的余额账号、银行卡；或者是使用为用户发送现金红包的方式。&lt;/p&gt;
&lt;p&gt;接下来的两篇文章，会为大家描述在微信支付中，像用户付款的以上三种方式。&lt;/p&gt;
&lt;p&gt;以下为三种付款方式的必要条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;商户号（或同主体其他非服务商商户号）已入驻90日&lt;/li&gt;
&lt;li&gt;商户号（或同主体其他非服务商商户号）有30天连续正常交易&lt;/li&gt;
&lt;li&gt;登录微信支付商户平台-产品中心，开通企业付款。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;企业付款到微信用户零钱&quot;&gt;企业付款到微信用户零钱&lt;/h3&gt;
&lt;p&gt;企业付款提供由商户直接付钱至用户微信零钱的能力，支持平台操作及接口调用两种方式，资金到账速度快，使用及查询方便。主要用来解决合理的商户对用户付款需求，比如：保险理赔、彩票兑换等等。&lt;/p&gt;
&lt;p&gt;如何开通？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;入驻成为商户：在线提交营业执照、身份证、银行账户等基本信息，快速提交申请；&lt;/li&gt;
&lt;li&gt;超级管理员开通：前往商户平台-产品中心-企业付款到零钱-申请开通；&lt;/li&gt;
&lt;li&gt;特殊要求：交易资金是即时入账到商户号基本户的商户，需要满足以下要求：需入驻满90天，连续交易30天。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所需资料：开通企业付款到零钱功能无需提供额外的材料。&lt;br/&gt;费用：试用期间免费使用。&lt;/p&gt;
&lt;h4 id=&quot;应用场景&quot;&gt;应用场景&lt;/h4&gt;
&lt;p&gt;企业付款为企业提供付款至用户零钱的能力，支持通过API接口付款，或通过微信支付商户平台（pay.weixin.qq.com）网页操作付款。&lt;/p&gt;
&lt;p&gt;以下为官方的解释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抓重点，首先需要知道的是，开通了&lt;code&gt;运营账户&lt;/code&gt;的商户，付款时会从运营账户余额中扣除，这个一定要注意，以免金额不足时付款失败（可以使用主账户为运营账户充值，参考[交易中心]-[充值/转入]）。&lt;/p&gt;
&lt;p&gt;以下为特别需要注意的地方，为大家标记出来，设计系统时一定要参考一下，以免入坑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181115194658528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lDbGltYg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;企业付款到余额-1&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;接口链接&quot;&gt;接口链接&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;是否需要证书&quot;&gt;是否需要证书&lt;/h4&gt;
&lt;p&gt;请求需要双向证书。&lt;/p&gt;
&lt;h4 id=&quot;调用接口&quot;&gt;调用接口&lt;/h4&gt;
&lt;p&gt;注意事项：&lt;br/&gt;◆ 当返回错误码为“SYSTEMERROR”时，请不要更换商户订单号，一定要使用原商户订单号重试，否则可能造成重复支付等资金风险。&lt;br/&gt;◆ XML具有可扩展性，因此返回参数可能会有新增，而且顺序可能不完全遵循此文档规范，如果在解析回包的时候发生错误，请商户务必不要换单重试，请商户联系客服确认付款情况。如果有新回包字段，会更新到此API文档中。&lt;br/&gt;◆ 因为错误代码字段err_code的值后续可能会增加，所以商户如果遇到回包返回新的错误码，请商户务必不要换单重试，请商户联系客服确认付款情况。如果有新的错误码，会更新到此API文档中。&lt;br/&gt;◆ 错误代码描述字段err_code_des只供人工定位问题时做参考，系统实现时请不要依赖这个字段来做自动化处理。&lt;/p&gt;
&lt;p&gt;PS：目前支持向指定微信用户的openid付款。&lt;/p&gt;
&lt;p&gt;官方文档如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的传入参数，这里就不一一列举了，请大家参考一下官方文档，下面贴上具体的实现源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * [微信支付提现接口] - 保存调用的相关记录
 * @param payment 支付对象
 * @param wxPayConfig 微信支付单例对象
 * @return map
 *
 * @author yclimb
 * @date 2018/7/30
 */
public Map&amp;lt;String, String&amp;gt; saveWxPayTransfers(Payment payment, WXPayConfig wxPayConfig) throws Exception {
    // 支付前验证

    // 微信支付对象
    // WXPay wxPay = new WXPay(WXPayConfigImpl.getInstance());
    WXPay wxPay = new WXPay(wxPayConfig);

    // 微信退款接口
    Map&amp;lt;String, String&amp;gt; resultMap = wxPay.transfers(...);
    logger.info(&quot;saveWxPayTransfers:resultMap:&quot; + resultMap.toString());

    // 下单失败，进行处理
    if (WXPayConstants.FAIL.equals(resultMap.get(WXPayConstants.RETURN_CODE)) || WXPayConstants.FAIL.equals(resultMap.get(WXPayConstants.RESULT_CODE))) {

        // 处理结果返回，无需继续执行

        // 余额不足提醒
        if (WXPayCodeEnum.ERR_CODE_NOTENOUGH.getCode().equals(resultMap.get(WXPayConstants.ERR_CODE))) {
            // 发送余额不足的消息提醒
            
        }
    }

    // 付款记录修改 &amp;amp; 记录付款日志
    
    return resultMap;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上为调用的应用方法，下面为大家贴出微信接口调用代码 &lt;code&gt;imall.weixin.sdk.WXPay&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 作用：企业向微信用户个人付款&amp;lt;br&amp;gt;
 * 场景：企业付款为企业提供付款至用户零钱的能力，支持通过API接口付款，或通过微信支付商户平台（pay.weixin.qq.com）网页操作付款。
 * 接口文档地址：https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2
 *
 * @param partner_trade_no 商户订单号
 * @param openid           用户openid
 * @param amount           企业付款金额
 * @param desc             企业付款描述信息
 * @param spbill_create_ip 该IP可传用户端或者服务端的IP
 * @return API返回数据
 * @throws Exception e
 */
public Map&amp;lt;String, String&amp;gt; transfers(String partner_trade_no, String openid, String amount, String desc, String spbill_create_ip) throws Exception {

    /** 构造请求参数数据 **/
    Map&amp;lt;String, String&amp;gt; data = new HashMap&amp;lt;&amp;gt;();

    // 商户订单号    partner_trade_no    是   10000098201411111234567890  String  商户订单号，需保持唯一性(只能是字母或者数字，不能包含有符号)
    data.put(&quot;partner_trade_no&quot;, partner_trade_no);
    // 用户openid openid  是   oxTWIuGaIt6gTKsQRLau2M0yL16E    String  商户appid下，某用户的openid
    data.put(&quot;openid&quot;, openid);
    // 校验用户姓名选项 check_name  是   FORCE_CHECK String  NO_CHECK：不校验真实姓名,FORCE_CHECK：强校验真实姓名
    data.put(&quot;check_name&quot;, &quot;NO_CHECK&quot;);
    // 金额   amount  是   10099   int 企业付款金额，单位为分
    data.put(&quot;amount&quot;, String.valueOf(new BigDecimal(amount).multiply(new BigDecimal(100)).setScale(2, BigDecimal.ROUND_HALF_UP).intValue()));
    // 企业付款描述信息 desc    是   理赔  String  企业付款操作说明信息。必填。
    data.put(&quot;desc&quot;, desc);
    // Ip地址 spbill_create_ip    是   192.168.0.1 String(32)  该IP同在商户平台设置的IP白名单中的IP没有关联，该IP可传用户端或者服务端的IP。
    data.put(&quot;spbill_create_ip&quot;, spbill_create_ip);

    /** 以下参数为非必填参数 **/

    /*// 设备号    device_info 否   013467007045764 String(32)  微信支付分配的终端设备号
    data.put(&quot;device_info&quot;, &quot;xxx&quot;);
    // 收款用户姓名   re_user_name    可选  王小王 String  收款用户真实姓名。(如果check_name设置为FORCE_CHECK，则必填用户真实姓名)
    data.put(&quot;re_user_name&quot;, &quot;xxx&quot;);*/

    // 微信调用接口
    Map&amp;lt;String, String&amp;gt; resultMap = this.transfers(data);

    WXPayUtil.getLogger().info(&quot;wxPay.transfers:&quot; + resultMap);

    return resultMap;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：推荐数据库中对于金额存储为数值单位，以分为单位来存储，1.1元可以储存为101，这样和微信对应，会方便很多。&lt;/p&gt;
&lt;p&gt;对于企业付款查询的接口，这里就不详细描述了，以下为具体的官方文档链接：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要的朋友，根据文档进行接口查询即可，非高频接口。&lt;/p&gt;
&lt;h3 id=&quot;企业付款到银行卡&quot;&gt;企业付款到银行卡&lt;/h3&gt;
&lt;p&gt;企业付款到银行卡提供由商户直接付钱至指定银行卡账户的能力，支持平台操作及接口调用两种方式，资金到账速度快，使用及查询方便。主要用来解决合理的商户对用户付款需求，比如：保险理赔、彩票兑换等等。&lt;/p&gt;
&lt;p&gt;开通流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;入驻成为商户：在线提交营业执照、身份证、银行账户等基本信息，快速提交申请；&lt;/li&gt;
&lt;li&gt;超级管理员开通：前往商户平台-产品中心-企业付款到银行卡-申请开通；&lt;/li&gt;
&lt;li&gt;特殊要求：交易资金是即时入账到商户号基本户的商户，需要满足以下要求：需入驻满90天，连续交易30天。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所需资料：开通企业付款到银行卡功能无需提供额外的材料。&lt;br/&gt;费用：此功能需收取手续费，按照单笔金额收取，每笔收取0.1%,最低1元，最高25元。&lt;/p&gt;
&lt;h4 id=&quot;应用场景-1&quot;&gt;应用场景&lt;/h4&gt;
&lt;p&gt;微信支付已上线企业付款至银行卡功能。商户可以将商户号余额付款至指定的收款银行账户。通过指定收款银行账户户名、卡号，以及收款银行信息即可实现付款。&lt;/p&gt;
&lt;p&gt;官方文档地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=24_1&amp;amp;index=1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;功能说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;企业付款至银行卡只支持新资金流类型账户&lt;/li&gt;
&lt;li&gt;目前企业付款到银行卡支持17家银行，更多银行逐步开放中&lt;/li&gt;
&lt;li&gt;付款到账实效为1-3日，最快次日到账&lt;/li&gt;
&lt;li&gt;每笔按付款金额收取手续费，按金额0.1%收取，最低1元，最高25元,如果商户开通了运营账户，手续费和付款的金额都从运营账户出。如果没有开通，则都从基本户出。&lt;/li&gt;
&lt;li&gt;每个商户号每天可以出款100万，单商户给同一银行卡付款每天限额5万&lt;/li&gt;
&lt;li&gt;发票：在账户中心-发票信息页面申请开票的商户会按月收到发票（已申请的无需重复申请）。&lt;br/&gt;企业付款到银行卡发票与交易手续费发票为拆分单独开具。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;需要注意的是，微信支持的银行有限，具体的支持银行见如下链接：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=24_4&amp;amp;index=5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以肯定会出现不支持的银行，小伙伴们在开发的时候，可以在前后端控制用户选择提现银行来解决。&lt;/p&gt;
&lt;p&gt;平台上手动付款流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在产品中心，开通企业付款到个人银行卡功能&lt;/li&gt;
&lt;li&gt;进入交易中心-企业付款到银行卡页面进行付款&lt;/li&gt;
&lt;li&gt;指定收款银行账号、户名、收款方开户行，及付款金额信息，即可实现付款&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;接口链接-1&quot;&gt;接口链接&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;https://api.mch.weixin.qq.com/mmpaysptrans/pay_bank&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;是否需要证书-1&quot;&gt;是否需要证书&lt;/h4&gt;
&lt;p&gt;请求需要双向证书。&lt;/p&gt;
&lt;h4 id=&quot;调用接口-1&quot;&gt;调用接口&lt;/h4&gt;
&lt;p&gt;接口介绍：&lt;br/&gt;用于企业向微信用户银行卡付款&lt;br/&gt;目前支持接口API的方式向指定微信用户的银行卡付款。&lt;/p&gt;
&lt;p&gt;接口调用规则：&lt;br/&gt;◆ 单商户日限额——单日100w&lt;br/&gt;◆ 单次限额——单次5w&lt;br/&gt;◆ 单商户给同一银行卡单日限额——单日5w&lt;/p&gt;
&lt;p&gt;注意：重点来了，首先，收款方银行卡号&lt;code&gt;enc_bank_no&lt;/code&gt;、收款方用户名&lt;code&gt;enc_true_name&lt;/code&gt; 这两个入参是需要 &lt;code&gt;采用标准RSA算法，公钥由微信侧提供&lt;/code&gt; 得到的，所以还需要先拿到这个密钥，下面是官方文档地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=24_7&amp;amp;index=4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上文档详细介绍了如何得到具体的密钥方式，如果有看不明白的小伙伴，可以直接百度 &lt;code&gt;获取RSA加密公钥API&lt;/code&gt;，可以得到很多示例，这里我就不讲了。&lt;/p&gt;
&lt;p&gt;除入参和&lt;code&gt;企业付款到微信用户零钱&lt;/code&gt;有所不一致之外，其他方面都差不多，小伙伴们可以参考上面付款到零钱的接口来实现付款到银行卡接口。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;以上为&lt;code&gt;微信余额提现&lt;/code&gt;相关的解释和源码，小伙伴们一定要注意看看官方文档哦，具体的源码可以看作者的github，里面对每个方法有详细的注释。&lt;/p&gt;
&lt;p&gt;如果小伙伴有遇到解决不了的问题，可以关注作者微信公众号，加入讨论群中发出疑问，和小伙伴们一起解决哦～&lt;/p&gt;
&lt;p&gt;预告：下一篇文章会讲发放奖励的另一种方式 &lt;code&gt;商户平台-现金红包&lt;/code&gt;，敬请期待！！！&lt;/p&gt;
&lt;p&gt;​如果想要提前一览源码的小伙伴，可以先看看我的 github，地址如下：&lt;br/&gt;​&lt;br/&gt;​&lt;code&gt;​https://github.com/YClimb/wxpay-sdk/blob/master/README.md ​&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关注作者微信公众号，点击下方&lt;code&gt;讨论群&lt;/code&gt;，扫码即可加入&lt;code&gt;微信支付讨论群&lt;/code&gt;与小伙伴一起探讨哦～&lt;/p&gt;
&lt;p&gt;到此本文就结束了，关注公众号查看更多推送！！！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180130111432962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWUNsaW1i/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;关注我的公众号&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Thu, 15 Nov 2018 11:50:00 +0000</pubDate>
<dc:creator>YClimb</dc:creator>
<og:description>本文是【浅析微信支付】系列文章的第十二篇，主要讲解在商户存在的提现、商户付款到微信用户零钱或者银行卡需求。 浅析微信支付系列已经更新十二篇了哟～，没有看过的朋友们可以看一下哦。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yclimb/p/9965698.html</dc:identifier>
</item>
</channel>
</rss>