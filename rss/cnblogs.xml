<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java简单工厂模式以及来自lambda的优化 - 祈求者-</title>
<link>http://www.cnblogs.com/invoker-/p/7684913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/invoker-/p/7684913.html</guid>
<description>&lt;p&gt;   设计模式是软件工程中一些问题的统一解决方案的模型,它的出现是为了解决一些普遍存在的,却不能被语言特性直接解决的问题,随着软件工程的发展,设计模式也会不断的进行更新,本文介绍的是经典设计模式-简单工厂模式以及来自java8的lambda的对它的优化。&lt;/p&gt;

&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;定义一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简单理解&quot;&gt;简单理解&lt;/h3&gt;
&lt;p&gt;  我的理解是工厂模式好比一个容器,里面装了有许多共同特征的对象,通提供过工厂对外提供的方法向外提供实例化子类的功能,和现实的中的工厂很像。简明点说,是许多对象的集合,根据需求对外提供不同的对象。&lt;/p&gt;

&lt;h2 id=&quot;场景描述&quot;&gt;场景描述&lt;/h2&gt;
&lt;p&gt;在写了几个设计模式的博客之后我发现每次都要虚构一个不存在的例子很费脑筋，于是我决定后面的例子用我平常喜欢玩的一些游戏来描述，感觉会更有意思:)&lt;br/&gt;在一片古老的魔法大陆上，有许多隐世的秘宝等待探险者去挖掘，可这样的机会往往也伴随着危险，所以探险者们往往需要结伴而行，一般来说，一个不会在野外直接当掉的队伍至少需要保证三种类型的职业(坦克,输出,治疗,俗称'铁三角')。因此，在这样的需求下，久而久之，魔法大路上诞生了一家'冒险者雇佣兵工厂'，没有人知道这家工厂是何时诞生，也不知道里面究竟有怎样的实力...只是知道，你给它钱，和你需要的职业，它就会提供一个对应职业的雇佣兵助你完成这次冒险....&lt;br/&gt;有一天,有一个战士(坦克)阿呆收到消息，有一个叫做'火焰洞窟'里面可能有好东西，可他身边没有伙伴一个人显然是不能去送死的，于是为了快速凑到伙伴，他想到了雇佣兵工厂...他需要一个能够释放冰霜法术的法师(输出)(冰属性可以克制火焰洞窟里的怪物)和一个能够疗伤的牧师(治疗)这两个职业,下面在客户端中模拟场景&lt;/p&gt;
&lt;h2 id=&quot;传统实现&quot;&gt;传统实现&lt;/h2&gt;
&lt;p&gt;首页抽象坦克,输出,治疗为探险者接口,提供一个战斗的技能的方法&lt;br/&gt;探险者接口&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; adventurer {
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 使用战斗技能&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;useBattleSkill&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;战士,冰霜法师,牧师实现探险者接口,作为子类提供不同的战斗技能实现&lt;br/&gt;战士类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; warrior &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; adventurer {
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;useBattleSkill&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;盾牌格挡!&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;冰霜法师类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; frostMage &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; adventurer {
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;useBattleSkill&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;寒冰箭!&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;牧师类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; priests &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; adventurer {
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;useBattleSkill&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;快速治疗!&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;冒险者工厂类,根据不同的职业需求实例化不同的冒险者给客户端&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; adventFactory {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; adventurer &lt;span class=&quot;fu&quot;&gt;createAdventurer&lt;/span&gt;(String professionType) {
        adventurer adventurer;
        &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; (professionType) {
            &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;战士&quot;&lt;/span&gt;:
                adventurer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;warrior&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;冰霜法师&quot;&lt;/span&gt;:
                adventurer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;frostMage&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;牧师&quot;&lt;/span&gt;:
                adventurer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;priests&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;我们没这种职业!&quot;&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; adventurer;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端类,模拟三个职业进入火焰洞窟并使用各自的技能&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Client {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        &lt;span class=&quot;co&quot;&gt;//通过冒险者工厂实例化出战士,冰霜法师,牧师&lt;/span&gt;
        adventurer warrior = adventFactory.&lt;span class=&quot;fu&quot;&gt;createAdventurer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;战士&quot;&lt;/span&gt;);
        adventurer frostMage = adventFactory.&lt;span class=&quot;fu&quot;&gt;createAdventurer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;冰霜法师&quot;&lt;/span&gt;);
        adventurer priest = adventFactory.&lt;span class=&quot;fu&quot;&gt;createAdventurer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;牧师&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;//进入火焰洞窟&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;================进入火焰洞窟================&quot;&lt;/span&gt;);
        warrior.&lt;span class=&quot;fu&quot;&gt;useBattleSkill&lt;/span&gt;();
        frostMage.&lt;span class=&quot;fu&quot;&gt;useBattleSkill&lt;/span&gt;();
        priest.&lt;span class=&quot;fu&quot;&gt;useBattleSkill&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;================进入火焰洞窟================
盾牌格挡!
寒冰箭!
快速治疗!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如同上文所讲,雇佣兵工厂通过switch语句根据不同的输出实例化不同的对象给客户端调用,这样客户端只需要和工厂打交道,有什么需求提供给工厂,工厂实例化出对应对象返回,所以工厂可以理解为是对象实例化的集合。&lt;/p&gt;
&lt;h2 id=&quot;总结与思考&quot;&gt;总结与思考&lt;/h2&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;为了增加趣味性(主要是我自己的..编例子很无聊T_T),本文使用了MMORPG游戏的铁三角的组队进副本的例子,冒险者工厂为冒险者提供不同职业的冒险者,冒险者不需要与具体的同伴沟通,通过工厂就可以完成需求,可以说是将需求者与雇佣兵这两类人给解耦了,通过冒险工厂来交互。从封装角度来说，之前写的命令模式，策略模式都是对行为的封装，而工厂模式是对对象构造器的封装，这一点也为后面的lambda的优化选择接口提供了依据。&lt;br/&gt;下面是uml图&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xhyrzldf/design-patterns/master/simple-factory-mode/src/resources/images/simple-factory-mode.jpg&quot; alt=&quot;simple-factory-mode&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;解耦,将需求类与实现类分离开了，通过工厂类进行交互&lt;/li&gt;
&lt;li&gt;无论是添加，修改还是删除新的子类，都十分的容易，不会影响到其他的类&lt;/li&gt;
&lt;li&gt;复用，子类可以多次复用，而不是每次都需要复制原先的代码&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;可优化点&quot;&gt;可优化点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;依旧是针对switch语句的优化&lt;/li&gt;
&lt;li&gt;违背了开闭原则,即增加新的子类之后,原先的工厂类的代码还需要做改动,开放了修改&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;优化思路&quot;&gt;优化思路&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;传统使用反射来完成修改的关闭,这里我不想使用反射来完成,试试lambda能否完成它的职责&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用lambda进行优化&quot;&gt;使用lambda进行优化&lt;/h2&gt;
&lt;p&gt;前面提到简单工厂模式的封装模式是对对象的构造进行封装,那么如果采用函数接口替换switch语句的话,选择的函数应该是&lt;code&gt;Supplier&amp;lt;T&amp;gt;&lt;/code&gt;(无参构造函数) 或者&lt;code&gt;Funtion&amp;lt;T,R&amp;gt;&lt;/code&gt;(有参构造函数),这里我们选择无参构造函数来进行优化,使用Map存储这些构造方法,并利用函数语言的懒加载特性,使得直到真正调用实例化对象的某一方法时,才真正调用构造函数,代码如下。&lt;/p&gt;
&lt;p&gt;使用supplier封装构造器优化后的Factory类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; adventFactory {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Map&amp;lt;String, Optional&amp;lt;Supplier&amp;lt;adventurer&amp;gt;&amp;gt;&amp;gt; MAP = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();

    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; {
        MAP.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;战士&quot;&lt;/span&gt;, Optional.&lt;span class=&quot;fu&quot;&gt;of&lt;/span&gt;(warrior::&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;));
        MAP.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;冰霜法师&quot;&lt;/span&gt;, Optional.&lt;span class=&quot;fu&quot;&gt;of&lt;/span&gt;(frostMage::&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;));
        MAP.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;牧师&quot;&lt;/span&gt;, Optional.&lt;span class=&quot;fu&quot;&gt;of&lt;/span&gt;(priests::&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;));
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; adventurer &lt;span class=&quot;fu&quot;&gt;createAdventurer&lt;/span&gt;(String professionType) {
        &lt;span class=&quot;co&quot;&gt;//get(professionType)获得optional对象,orElseThrow用于防止或者异常参数,get()及早求值,执行对象的实例化,直到这一步函数才真正的执行&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; MAP.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(professionType)
                .&lt;span class=&quot;fu&quot;&gt;orElseThrow&lt;/span&gt;(() -&amp;gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;我们工厂没这种职业!&quot;&lt;/span&gt;))
                .&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端代码与原先一模一样，这里就不显示了，下面说明一下这个Factory类。&lt;br/&gt;使用supplier函数接口将构造器封装,并存储在MAP中，注意这里与传统的直接存实例好的对象进去不同，这里存储的只是构造过程，并不会真正的占用空间，除非客户端调用create方法需要这个对象了,才会实例化出来，这里利用了函数的懒加载特性。同时为了防止可恶的空指针异常或者是需求并不存在的类,在supplier的基础上使用了optional类进行包装,避免了各类if判断,可以看出使用了lambda优化之后,已经不存在任何的条件判断语句(switch,if)了，将面向对象与函数语言特性相结合，感觉很不错。&lt;/p&gt;
&lt;h2 id=&quot;枚举的进一步优化&quot;&gt;枚举的进一步优化&lt;/h2&gt;
&lt;p&gt;前面提到可优化点的时候提到了简单工厂方法违背了开闭原则，然而经过lambda优化之后的方式虽然消除了switch与if分支,但是似乎并没有克服这个问题,工厂类依旧是违背这个原则的,那么可不可能再次优化呢？我认为这种需要传入魔法值来做一些事情的方法或者设计模式,枚举都是一个不错的选择，下面尝试使用枚举。&lt;/p&gt;
&lt;p&gt;使用枚举变量封装这些构造器,这样不仅可以使得工厂可以将修改关闭,同时也省去了optional类的包装,因为你传入的参数只能是枚举变量已经定义好的。下面是代码。&lt;/p&gt;
&lt;p&gt;枚举类,内部存一个supplier对象,存放各大职业的构造器,对外暴露getConstructor方法进行实例化&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;enum&lt;/span&gt; adventEnum {
    &lt;span class=&quot;fu&quot;&gt;WARRIOR&lt;/span&gt;(warrior::&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;),
    &lt;span class=&quot;fu&quot;&gt;MAGE_FROST&lt;/span&gt;(frostMage::&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;),
    &lt;span class=&quot;fu&quot;&gt;PRIESTS&lt;/span&gt;(priests::&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;);

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Supplier&amp;lt;adventurer&amp;gt; constructor;

    &lt;span class=&quot;fu&quot;&gt;adventEnum&lt;/span&gt;(Supplier&amp;lt;adventurer&amp;gt; constructor) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt; = constructor;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Supplier&amp;lt;adventurer&amp;gt; &lt;span class=&quot;fu&quot;&gt;getConstructor&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; constructor;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;工厂类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; adventFactory {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; adventurer &lt;span class=&quot;fu&quot;&gt;createAdventurer&lt;/span&gt;(adventEnum adventEnum) {
        adventEnum.&lt;span class=&quot;fu&quot;&gt;getConstructor&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;工厂类十分简洁,然而不仅简洁,还完美继承了上面的所有优势,并且克服了劣势。&lt;/p&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import static com.lambda.enums.adventEnum.*;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Client {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        &lt;span class=&quot;co&quot;&gt;//通过冒险者工厂实例化出战士,冰霜法师,牧师&lt;/span&gt;
        adventurer warrior = adventFactory.&lt;span class=&quot;fu&quot;&gt;createAdventurer&lt;/span&gt;(WARRIOR);
        adventurer frostMage = adventFactory.&lt;span class=&quot;fu&quot;&gt;createAdventurer&lt;/span&gt;(MAGE_FROST);
        adventurer priest = adventFactory.&lt;span class=&quot;fu&quot;&gt;createAdventurer&lt;/span&gt;(PRIESTS);
        &lt;span class=&quot;co&quot;&gt;//进入火焰洞窟&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;================进入火焰洞窟================&quot;&lt;/span&gt;);
        warrior.&lt;span class=&quot;fu&quot;&gt;useBattleSkill&lt;/span&gt;();
        frostMage.&lt;span class=&quot;fu&quot;&gt;useBattleSkill&lt;/span&gt;();
        priest.&lt;span class=&quot;fu&quot;&gt;useBattleSkill&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端的调用参数变成了枚举类,这里静态导入枚举类,我一直觉得使用枚举变量的代码拥有一种自注释的特性,即不需写注释就可以看的很明了。&lt;/p&gt;

&lt;p&gt;麻雀虽小，五脏俱全，例子很简单，但是最后的成果是&lt;code&gt;面向对象语言+函数式语言+枚举&lt;/code&gt;的结合，可以看到这种组合效果是十分棒的，代码不仅简洁易用性高同时还保持了健壮性与可扩展性，希望大家可以多尝试，我认为多种语言范式的组合的语言可能是第三代语言或者更新的语言发展的趋势吧(Scala，C#等)^_^，大家下篇再见。&lt;/p&gt;

&lt;p&gt;本文的代码与md文章同步更新在&lt;a href=&quot;https://github.com/xhyrzldf/design-patterns&quot;&gt;github&lt;/a&gt;中的&lt;a href=&quot;https://github.com/xhyrzldf/design-patterns/blob/master/simple-factory-mode/simple-factory-mode.md&quot;&gt;simple-factory-mode&lt;/a&gt;模块下,欢迎fork :)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/invoker-/p/7675320.html&quot;&gt;上一篇:java策略模式以及来自lambda的优化&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Oct 2017 23:47:00 +0000</pubDate>
<dc:creator>祈求者-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/invoker-/p/7684913.html</dc:identifier>
</item>
<item>
<title>数据收集利器 cAdvisor - 每天5分钟玩转 Docker 容器技术（82） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/7683190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/7683190.html</guid>
<description>&lt;p&gt;cAdvisor 是 google 开发的容器监控工具，我们来看看 cAdvisor 有什么能耐。&lt;/p&gt;
&lt;p&gt;在 host 中运行 cAdvisor 容器。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;docker run \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  --volume=/:/rootfs:ro \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  --volume=/var/run:/var/run:rw \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  --volume=/sys:/sys:ro \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  --volume=/var/lib/docker/:/var/lib/docker:ro \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  --publish=8080:8080 \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  --detach=true \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  --name=cadvisor \&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  google/cadvisor:latest&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;http://[Host_IP]:8080 访问 cAdvisor。&lt;/p&gt;
&lt;h4 id=&quot;-docker-host&quot;&gt;&lt;strong&gt;&lt;span&gt;监控 Docker Host&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;cAdvisor 会显示当前 host 的资源使用情况，包括 CPU、内存、网络、文件系统等。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614274039064.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614274039064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614054057092.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614054057092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614241025348.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614241025348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614335000641.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614335000641.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;监控容器&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;Docker Containers&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;链接。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614517097182.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614517097182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示容器列表。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234615277044863.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234615277044863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击某个容器，比如&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;sysdig&lt;/span&gt;&lt;/code&gt;，进入该容器的监控页面。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614698024869.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614698024869.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614883020430.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614883020430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614978012809.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234614978012809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234615124080188.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171017-1508234615124080188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;以上就是 cAdvisor 的主要功能，总结起来主要两点：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;展示 Host 和容器两个层次的监控数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;展示历史变化数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于 cAdvisor 提供的操作界面略显简陋，而且需要在不同页面之间跳转，并且只能监控一个 host，这不免会让人质疑它的实用性。但 cAdvisor 的一个亮点是它可以将监控到的数据导出给第三方工具，由这些工具进一步加工处理。&lt;/p&gt;
&lt;p&gt;我们可以把 cAdvisor 定位为一个监控数据收集器，收集和导出数据是它的强项，而非展示数据。&lt;/p&gt;
&lt;p&gt;cAdvisor 支持很多第三方工具，其中就包括下一节要重点学习的 Prometheus。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627732322012171.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627732322012171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Oct 2017 23:24:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/7683190.html</dc:identifier>
</item>
<item>
<title>PE格式第六讲,导出表 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7684858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7684858.html</guid>
<description>&lt;p&gt;请注意,下方字数比较多,其实结构挺简单,但是你如果把博客内容弄明白了,对你受益匪浅,千万不要看到字数多就懵了,其实字数多代表它重要.特别是第五步,&lt;/p&gt;
&lt;p&gt;各种表中之间的关系.&lt;/p&gt;
&lt;p&gt;作者：IBinary&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/iBinary/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/iBinary/&lt;/a&gt;&lt;br/&gt;版权所有，欢迎保留原文链接进行转载：)&lt;/p&gt;
&lt;h2&gt;一丶浅谈导入表&lt;/h2&gt;
&lt;p&gt;首先,导出表我们已经学过了,作用就是在程序加载的时候,把自己要调用的API的地址,不断地填写到IAT表中&lt;/p&gt;
&lt;p&gt;不过我们要知道三个概念,&lt;/p&gt;
&lt;p&gt;1.程序运行的时候,导入表直接把调用的API地址填写到IAT表格中&lt;/p&gt;
&lt;p&gt;2.程序运行的时候,用到那个API,才会填写到IAT表中(延时加载技术,下面讲解)&lt;/p&gt;
&lt;p&gt;3.程序还没运行的时候,在PE中函数的地址就已经写死了.&lt;/p&gt;
&lt;p&gt;何为延时加载&lt;/p&gt;
&lt;p&gt;我们知道,如果你写的API有几万个,那么一开始就填写到IAT表格中,那么你的程序会很慢.&lt;/p&gt;
&lt;p&gt;那么就会使用延时加载表(也是数据目录中的)那么用到那个,才填写.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171018003259568-1842455669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以查看结构体(数据目录的结构体)下面可以找到这个表格.这个就是延时加载表&lt;/p&gt;

&lt;h2&gt;二丶何为导出表?&lt;/h2&gt;
&lt;p&gt;导出表,作用就是我们写的DLL或者EXE导出的函数,那么会记载这些函数.作用就是这个&lt;/p&gt;
&lt;p&gt;那么是你自己设计导出表,你要怎么设计.&lt;/p&gt;
&lt;p&gt;按照我的思路:&lt;/p&gt;
&lt;p&gt;1.我会设计一个  入口地址表(RVA存贮,用来计算模块 + 入口地址的RVA等于函数地址)&lt;/p&gt;
&lt;p&gt;2.我还会设计一个 保存函数名字的表&lt;/p&gt;
&lt;p&gt;3.我还会设计一个,保存序号的表&lt;/p&gt;
&lt;p&gt;大体就怎么多.&lt;/p&gt;
&lt;p&gt;因为你想,我们如果要保存一个导出函数,并且还有调用它,是不是需要保存函数名字,但是因为导出的时候还要有序号导出,那么是不是要保存序号,不光保存序号,我们是不是还要通过一定手段让模块地址+偏移寻到函数位置.&lt;/p&gt;
&lt;p&gt;表格设计大体流程&lt;/p&gt;
&lt;p&gt;EntryPoint  里面保存RVA(入口地址表)&lt;/p&gt;

&lt;p&gt;order　　　序号表格保存序号的&lt;/p&gt;

&lt;p&gt;FunctionName  函数名称表&lt;/p&gt;
&lt;p&gt;当然,函数导出的时候可能还会有记录个数的&lt;/p&gt;
&lt;p&gt;那么看下具体的结构体是怎么样子的吧.&lt;/p&gt;
&lt;p&gt;不出意外就会和我们的表设计的差不多.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;　　　　　//标志,未用
    DWORD   TimeDateStamp;　　　　　　//时间
    WORD    MajorVersion;　　　　　   //主版本
    WORD    MinorVersion;　　　　　　  //副版本
    DWORD   Name;　　　　　　　　　　   //指向导出表文件名的字符串
    DWORD   Base;　　　　　　　　　　　　//导出函数的起始序号
    DWORD   NumberOfFunctions;　　　　//所有导出函数的个数
    DWORD   NumberOfNames;　　　　　　//以函数名导出的函数个数
    DWORD   AddressOfFunctions;     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导出函数地址表RVA(入口地址)&lt;/span&gt;
    DWORD   AddressOfNames;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数名称地址表RVA(名称表)&lt;/span&gt;
    DWORD   AddressOfNameOrdinals;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数序号地址表(序号表)&lt;/span&gt;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出,确实是差不多的.&lt;/p&gt;
&lt;p&gt;那么看下这里的重要成员&lt;/p&gt;
&lt;p&gt;1.执行导出表文件名的字符串&lt;/p&gt;
&lt;p&gt;2.base 导出函数的起始序号&lt;/p&gt;
&lt;p&gt;3.导出函数地址表RVA&lt;/p&gt;
&lt;p&gt;4.函数名称地址表RVA&lt;/p&gt;
&lt;p&gt;5.函数序号地址表&lt;/p&gt;
&lt;p&gt;这里我们随便找个DLL,使用010模版,看下结构到底怎么存储的(先要定位)&lt;/p&gt;
&lt;h2&gt;三丶定位导出表&lt;/h2&gt;
&lt;h3&gt;1.找出导出表RVA偏移&lt;/h3&gt;
&lt;p&gt;首先,我们要在数据目录里面查看DLL的第一项,也就是导出表的地址的RVA偏移是多少.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171018005234365-173985497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,是4820的RVA偏移,大小是84个字节&lt;/p&gt;
&lt;h3&gt;2.判断属于哪一个节&lt;/h3&gt;
&lt;p&gt;既然知道是4820了,那么节中的虚拟地址肯定是40开头的.小于50的  因为4820 &amp;gt; 40开头, &amp;lt; 50开头&lt;/p&gt;
&lt;p&gt;首先第一个节.text&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171018005502959-1198749336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4096代表了1000h,肯定不是,相差太远.&lt;/p&gt;
&lt;p&gt;第二个节.radata&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171018005603709-1094393773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是40开头的,那么就是了&lt;/p&gt;
&lt;h3&gt;3.算出FOA位置&lt;/h3&gt;
&lt;p&gt;既然知道是.radata节中的,那么直接算出FOA(简称FA)的位置即可&lt;/p&gt;
&lt;p&gt;RVA = 4820&lt;/p&gt;
&lt;p&gt;FA = RVA - 节虚拟地址(上面找的4000h) + 上面找的节的文件偏移大小&lt;/p&gt;
&lt;p&gt;文件偏移截图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171018005807287-1717377065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公式代入得到:&lt;/p&gt;
&lt;p&gt;FA = 4820 - 4000 + 4000&lt;/p&gt;
&lt;p&gt;FA = 4820&lt;/p&gt;
&lt;p&gt;通过计算,我们发现还是4820的位置,为什么这么巧?&lt;/p&gt;
&lt;p&gt;原因是虚拟地址和文件偏移位置存储都是一样的.所以记录的RVA则是在文件中的位置.&lt;/p&gt;

&lt;p&gt;4.通过FA找到导出表位置&lt;/p&gt;
&lt;p&gt;我们得到FA是4820,那么我们使用010 Editer中的ctrl + G的功能,快速定位位置.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171018010022287-1299725110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171018010106990-318300725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们选中了84个字节,那么这84个字节则是导出表的大小了,在数据目录中有记录导出表的大小,所以直接定位即可.&lt;/p&gt;
&lt;h3&gt;四丶导出表的存储方式&lt;/h3&gt;
&lt;h3&gt;1.第一部分讲解&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171018012601865-1568888552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;截图一下截取太多,不好讲解,这里截取一部分,下面接着截取4840下面的&lt;/p&gt;
&lt;p&gt;首先,黑色方块中的无用不重要,所以不讲解.&lt;/p&gt;
&lt;p&gt;红色方块第一个: 成员NAME  这个是一个RVA的偏移,指向了DLL的名称,可以的同学,可以看下4860(因为RVA是4860,但是虚拟地址和文件偏移是一样的,所以现在的情况是FA = RVA,不用转换了)的位置,是不是DLL的名称,以0结尾&lt;/p&gt;
&lt;p&gt;红色方块第二个,base成员,起始的导出序号,这个很重要,一会讲解&lt;/p&gt;
&lt;p&gt;红色方块第三个,这个我直接把两个4字节弄在一起来,要分开来看,  第一个四个字节,3,表示了所有导出函数是3个(函数名字,或者序号导出都计算)&lt;/p&gt;
&lt;p&gt;第二个四个字节: 显示2,表示了按照名字导出的函数有两个.&lt;/p&gt;
&lt;p&gt;红色方块第四个: 这个重要了.存放的是函数的地址表.&lt;/p&gt;
&lt;p&gt;如果会看FA位置的同学请看. 存放的00001000 第一个函数地址偏移 第二个函数地址偏移  00001020  第三个函数地址偏移00001040&lt;/p&gt;
&lt;p&gt;为什么存放的是函数地址偏移,因为这个是个DLL,加载到程序的时候,DLL模块不固定,所以比如存放偏移&lt;/p&gt;
&lt;p&gt;这样就可以通过  ImageBase + 偏移,定位导出函数的地址了.&lt;/p&gt;
&lt;p&gt;所以现在大家应该知道为什么GetprocAddress(模块,函数名)为什么要给模块了吗? 就是要通过模块+偏移的位置定位导出函数地址调用&lt;/p&gt;
&lt;h3&gt;2.第二部分讲解&lt;/h3&gt;
&lt;p&gt;首先,讲解第二部分之前,我们要把第一部分的存储信息截图下来,方便对照查看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171018013528881-528603635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二部分截图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171018013939162-7229677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,我画了4个颜色的方框&lt;/p&gt;
&lt;p&gt;看法: 黄色对应着橘黄色&lt;/p&gt;
&lt;p&gt;深红色,对应着绿色&lt;/p&gt;
&lt;p&gt;首先黄色方块: 代表的函数名称的表,指向函数名称的字符串位置 RVA,通过转化(FA = RVA)得出4854的位置是指向字符串的位置.&lt;/p&gt;
&lt;p&gt;那么就会指导橘黄色的开头位置了,也就是4854的位置,但是注意一下,因为导出的函数,函数名字是不固定的,那么其实函数名称表执行的这个区域还是一个偏移.&lt;/p&gt;
&lt;p&gt;而这个偏移,才真正的指向了函数名称的字符串(注意,0结尾)可边长的.&lt;/p&gt;
&lt;p&gt;那么486A的位置就是 导出函数的名称了.  也就是fun1&lt;/p&gt;
&lt;p&gt;橘黄色有两个4字节,第一个RVA偏移,是指向了fun1的函数名字,那么第二个就是指向了fun2的名字,那么由此可以得出,按照名字导出,我们总共得到了两个字符串.(fun1,和fun2)&lt;/p&gt;

&lt;p&gt;深红色位置:&lt;/p&gt;
&lt;p&gt;深红色位置指向了一个偏移,这个偏移也就是绿色方框的开头,分为2个字节2个字节&lt;/p&gt;
&lt;p&gt;那么绿色是2个2个字节.&lt;/p&gt;
&lt;p&gt;这个深红色位置,就是序号表的RVA偏移,我们知道DLL导出可以是序号导出,那么这个地方就是存储的是序号.&lt;/p&gt;
&lt;p&gt;导出函数的时候,默认不写序号,则对应的是从0开始,0 1 2 3顺序排列,这里导出了2个函数,那么对应就有两个序号,分别是0和1&lt;/p&gt;
&lt;p&gt;通过上面讲解,基本了解了导出表的存储格式,但是下面的讲解,才会真正的重要.&lt;/p&gt;
&lt;h3&gt;五丶BASE成员,导出序号,函数导出,以及函数地址表之间的关系&lt;/h3&gt;
&lt;h3&gt;1.函数名称,序号表,以及和函数地址表中的关系&lt;/h3&gt;
&lt;p&gt;首先我们要知道,DLL的导出函数可以按照序号导出,也可以按照函数名字导出,但是怎么和函数地址表关联起来那?&lt;/p&gt;
&lt;p&gt;首先,我们先看不按照序号导出,按照函数名字来获取函数的地址(函数地址表中)&lt;/p&gt;
&lt;p&gt;上面我们分析过了&lt;/p&gt;
&lt;p&gt;我们会需要函数名字,入口地址,以及序号,而下面的结构体也正好应验了.&lt;/p&gt;
&lt;p&gt;那么重新写一下&lt;/p&gt;
&lt;p&gt;EntryPoint (可以理解为函数地址表,存放的是导出函数的地址)&lt;/p&gt;
&lt;p&gt;那么刚才我们看了,有三个&lt;/p&gt;
&lt;p&gt;00001000  fun1的偏移&lt;/p&gt;
&lt;p&gt;00001020  fun2的偏移&lt;/p&gt;
&lt;p&gt;00001040  fun3的偏移,只不过没有名字&lt;/p&gt;
&lt;p&gt;Order  序号表格&lt;/p&gt;
&lt;p&gt;0　　　　　　fun1的默认序号&lt;/p&gt;
&lt;p&gt;1　　　　　　fun2的默认序号&lt;/p&gt;
&lt;p&gt;FunctionName (函数名称表格)&lt;/p&gt;
&lt;p&gt;fun1&lt;/p&gt;
&lt;p&gt;fun2&lt;/p&gt;
&lt;p&gt;首先关系是这样的,我们通过fun1的字符串,去查找序号表,通过序号表则找到偏移了.&lt;/p&gt;
&lt;p&gt;比如我们要加载 fun1,那么fun1的序号表中默认是0位置,所以找到的序号0了,也就是第一项(注意,序号表可以理解为Switch(序号))然后0位置存放的就是函数地址表,也就是000010000&lt;/p&gt;
&lt;p&gt;那么就得出了fun1的RVA偏移了&lt;/p&gt;
&lt;p&gt;那么现在知道一个完整的GetprocAddress(模块,函数名)是怎么运行的了吧&lt;/p&gt;
&lt;p&gt;首先,模块肯定是要知道的,&lt;/p&gt;
&lt;p&gt;函数名字给了,那么去序号表中看是第几项,找到序号表中的对应第几项,那么就去函数地址表中寻得第几项,那么正好就得出偏移了&lt;/p&gt;
&lt;p&gt;那么现在模块 + 偏移,正好找出导出函数 fun1的地址了.&lt;/p&gt;
&lt;p&gt;2.Base,序号表之间的关系&lt;/p&gt;
&lt;p&gt;首先我们重新编译下DLL,这次是按照序号导出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171018022122709-614946018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,我们默认指定的fun1的序号是1,fun2是2,fun3是3&lt;/p&gt;
&lt;p&gt;那么为什么序号表中是0 1 2 那?&lt;/p&gt;
&lt;p&gt;原因是这样的&lt;/p&gt;
&lt;p&gt;1.如果我们通过函数名字查找,比如找fun1,那么序号就是0,也就是第一项,那么通过0就可以找到fun1的偏移了&lt;/p&gt;
&lt;p&gt;2.如果我们通过序号查找,比如我们输入3,我们要调用fun3了,那么这个时候,序号表中根本就没有3,怎么办?&lt;/p&gt;
&lt;p&gt;此时Base成员的作用就来了,它默认是1,那么我们输入3序号的时候,会减去base的值,得出的下标,再去序号表中查找.&lt;/p&gt;
&lt;p&gt;那么3 - 1 = 2,2当做下标去序号表中查找,找到了第三项,也就是02了,通过02找fun3的偏移,也是对的.&lt;/p&gt;
&lt;p&gt;所以现在是由两种方式,&lt;/p&gt;
&lt;p&gt;第一种就是名字导入,fun1默认不加序号就是从0开始的,去序号表中查0就能找到偏移.&lt;/p&gt;
&lt;p&gt;第二种就是专门按照序号导入的,那么此时你输入的序号-base才真正的是函数的偏移了.&lt;/p&gt;

&lt;p&gt; 作者：IBinary&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/iBinary/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/iBinary/&lt;/a&gt;&lt;br/&gt;版权所有，欢迎保留原文链接进行转载：)&lt;/p&gt;
</description>
<pubDate>Tue, 17 Oct 2017 18:28:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7684858.html</dc:identifier>
</item>
<item>
<title>nginx的反向代理功能和缓存功能 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/7684732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/7684732.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog1&quot;&gt;&lt;span&gt;1. nginx的反向代理功能&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog1.1&quot;&gt;&lt;span&gt;1.1 正向代理和反向代理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog1.2&quot;&gt;&lt;span&gt;1.2 配置简单的反代实验&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog1.3&quot;&gt;&lt;span&gt;1.3 使用upstream模块实现分组反向代理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog1.4&quot;&gt;&lt;span&gt;1.4 ngx_http_proxy_module模块&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog1.4.1&quot;&gt;&lt;span&gt;1.4.1 指令及其意义&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog1.4.2&quot;&gt;&lt;span&gt;1.4.2 proxy_pass&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog1.4.3&quot;&gt;&lt;span&gt;1.4.3 proxy_set_header&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog1.5&quot;&gt;&lt;span&gt;1.5 ngx_http_upstream_module模块&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog1.6&quot;&gt;&lt;span&gt;1.6 反向代理的各种情况&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog1.6&quot;&gt;&lt;span&gt;1.7 nginx代理memcached&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html#blog2&quot;&gt;&lt;span&gt;2. nginx自带的缓存功能&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h2 id=&quot;1-1-&quot;&gt;1.1 正向代理和反向代理&lt;/h2&gt;
&lt;p&gt;正向代理是众多内网客户机上网访问互联网上的网站时，将所有的请求交给内网前面处于公网上的&quot;管家&quot;服务器，由&quot;管家&quot;服务器代为请求想要访问的web服务器，然后将得到的结果缓存下来并提供给客户端，这是正向代理。&quot;管家&quot;服务器称为正向代理服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171017222056771-1666571618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反向代理是客户端访问web服务器时，请求发送到真实的web服务器的前端&quot;助手&quot;服务器上，由&quot;助手&quot;服务器决定将此请求转发给哪个真实的web服务器，外界客户端以为&quot;助手&quot;服务器就是真实的web服务器，而实际上它不是，也不需要安装任何web程序。&quot;助手&quot;服务器称为反向代理服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171017222119959-1335404489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;nginx是一个优秀的反向代理服务程序，通过反向代理可以实现负载均衡的效果。因为是通过反向代理实现的负载均衡，所以nginx实现的是七层负载均衡。它能够识别http协议，根据http报文将不同类型的请求转发到不同的后端web服务器上。后端的web服务器称为&quot;上游服务器&quot;，即upstream服务器。&lt;/p&gt;
&lt;p&gt;实际上，nginx和php-fpm结合的时候，指令fastcgi_pass实现的也是反向代理的功能，只不过这种代理功能是特定的功能，只能转发给php-fpm。&lt;/p&gt;
&lt;p&gt;nginx的反向代理有几种实现方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;仅使用模块ngx_http_proxy_module实现简单的反向代理。指令为proxy_pass。&lt;/li&gt;
&lt;li&gt;使用fastcgi模块提供的功能，反向代理动态内容。指令为fastcgi_pass。&lt;/li&gt;
&lt;li&gt;使用ngx_http_memcached_module模块提供的功能，反向代理memcached缓存内容，指令为memcached_pass。&lt;/li&gt;
&lt;li&gt;结合upstream模块实现更人性化的分组反向代理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-2-&quot;&gt;1.2 配置简单的反代实验&lt;/h2&gt;
&lt;p&gt;实验环境如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171017222157459-1520894003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反向代理服务器nginx-proxy(192.168.100.29)的配置。由于是做代理，所以配置文件的location段不再需要root、index等指令，只需几个和代理相关的指令即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; {
    &lt;span class=&quot;hljs-title&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server_name&lt;/span&gt;  www.longshuai.com;
    &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;hljs-regexp&quot;&gt;~ \.(png|jpg|jpeg|bmp|gif)$&lt;/span&gt; {
        &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://192.168.100.28:80&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; / {
        &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://192.168.100.30:80/&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;hljs-regexp&quot;&gt;~ \.(php|php5)$&lt;/span&gt; {
        &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://192.168.100.25:80&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-title&quot;&gt;error_page&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;502&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;503&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;504&lt;/span&gt;  /50x.html;
    &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; = /50x.html {
        &lt;span class=&quot;hljs-title&quot;&gt;root&lt;/span&gt;   html;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提供动态服务的nginx服务器(192.168.100.25)的配置如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; {
    &lt;span class=&quot;hljs-title&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server_name&lt;/span&gt;  www.longshuai.com;
    &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; / {
        &lt;span class=&quot;hljs-title&quot;&gt;root&lt;/span&gt;    /www/longshuai/;
        &lt;span class=&quot;hljs-title&quot;&gt;index&lt;/span&gt;   index.php index.html index.htm;
    }
    &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;hljs-regexp&quot;&gt;~ \.php$&lt;/span&gt; {
        &lt;span class=&quot;hljs-title&quot;&gt;root&lt;/span&gt; /php/;
        &lt;span class=&quot;hljs-title&quot;&gt;fastcgi_pass&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.27:9000&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;fastcgi_index&lt;/span&gt;   test.php;
        &lt;span class=&quot;hljs-title&quot;&gt;include&lt;/span&gt;         fastcgi.conf;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中php-fpm服务器(192.168.100.27)上的/www/longshuai/index.php内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;page from php-fpm&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php&lt;/span&gt;
phpinfo();
&lt;span class=&quot;hljs-preprocessor&quot;&gt;?&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LB1(192.168.100.28)和LB2(192.168.100.30)的web程序都是httpd。其中作为一般静态web服务器的LB2的配置文件没有任何修改，它的/var/www/html/index.html的内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;h1&amp;gt;&lt;span class=&quot;hljs-constant&quot;&gt;LB2&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:static&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为图片服务器的LB1在配置文件中添加了如下几行。且其/var/www/html/下有一个图片文件a.png。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Files ~ &quot;\.(png|jpeg|jpg|bmp|gif)&quot;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;Order&lt;/span&gt;&lt;/span&gt; allow,deny
        &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;Allow&lt;/span&gt;&lt;/span&gt; from &lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Files&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过以上的配置，可以实现如下图的功能。当访问www.longshuai.com的时候，任意以php结尾的文件请求都转发给nginx再由nginx交由php-fpm处理；任意以图片格式结尾(png/jpg/jpeg/bmp/gif)的请求都转发给LB1；任意非以上两种格式的请求都转发给LB2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171017222238318-1335581188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重载nginx-proxy/nginx/LB1/LB2上的nginx或者httpd。然后进行测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171017221859881-1564743739.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171017222002287-514913025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-3-upstream-&quot;&gt;1.3 使用upstream模块实现分组反向代理&lt;/h2&gt;
&lt;p&gt;前面只使用了ngx_http_proxy_module来实现反向代理，但是其缺陷在于在nginx-proxy上定义的每条代理规则都只能转发到后台的某一台服务器上，即后端服务器无法分组。例如当图片服务器压力太大，添加一台服务器想要减轻图片服务器压力，但是仅使用proxy模块无法实现此类负载均衡到多台图片服务器上。&lt;/p&gt;
&lt;p&gt;这时需要借助ngx_http_upstream_module模块，该模块用于定义后端服务器池，后端服务器也称为上游服务器(upstream)，可以为每一种类型的后端服务器分一个组。然后在结合proxy_pass或其他代理指令将相应的请求转发到池内。&lt;/p&gt;
&lt;p&gt;服务器池可以有多台服务器，多台服务器如何实现负载均衡和算法有关，默认是指定权重的加权均衡算法，还可以指定ip_hash算法实现同一个客户端IP发起的请求总是转发到同一台服务器上。还有一些其它算法，如最小连接数算法。最常用的还是加权算法，然后通过session共享的方式实现同一个客户端IP发起的请求转发到同一服务器上。&lt;/p&gt;
&lt;p&gt;例如，下图描述的需求。当请求图片服务器时，可以将请求均衡到IP3和IP4两台服务器上，当请求其他静态内容，可以将请求均衡到IP5和IP6两台服务器上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171017222647302-344519376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要实现这样的功能，nginx-proxy上的nginx配置文件内容大致如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;http&lt;/span&gt; {
    &lt;span class=&quot;hljs-title&quot;&gt;include&lt;/span&gt; mime.types;
    &lt;span class=&quot;hljs-title&quot;&gt;default_type&lt;/span&gt; application/octet-stream;
    &lt;span class=&quot;hljs-title&quot;&gt;sendfile&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;on&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;keepalive_timeout&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;;

    
    &lt;span class=&quot;hljs-title&quot;&gt;upstream&lt;/span&gt; dynamic_pool {
        &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; IP1:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-title&quot;&gt;upstream&lt;/span&gt; pic_pool {
        &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; IP3:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; weight=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; IP4:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; weight=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-title&quot;&gt;upstream&lt;/span&gt; static_pool {
        &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; IP5:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; weight=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; IP6:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; weight=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
    }

    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; {
        &lt;span class=&quot;hljs-title&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;server_name&lt;/span&gt; www.longshuai.com;

        
        &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;hljs-regexp&quot;&gt;~ \.(php|php5)$&lt;/span&gt; {
            &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://dynamic_pool&lt;/span&gt;;
        }
        &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;hljs-regexp&quot;&gt;~ \.(png|jpeg|jpg|bmp|gif)$&lt;/span&gt; {
            &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://pic_pool&lt;/span&gt;;
        }
        &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; / {
            &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://static_pool&lt;/span&gt;;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;1-4-ngx-_http-_proxy-_module-&quot;&gt;1.4 ngx_http_proxy_module模块&lt;/h2&gt;

&lt;h3 id=&quot;1-4-1-&quot;&gt;1.4.1 指令及其意义&lt;/h3&gt;
&lt;p&gt;该模块默认安装。以下是相关指令的说明。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;指令意义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;proxy_pass&lt;/td&gt;
&lt;td&gt;定义代理到哪台服务器或哪个upstream池&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;proxy_set_header&lt;/td&gt;
&lt;td&gt;在代理服务器上设置http报头信息。如加上真实客户端地址&quot;proxy_set_header X_Forwarded_For $remote_addr&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;proxy_connect_timeout&lt;/td&gt;
&lt;td&gt;反向代理连接上游服务器节点的超时时间。发起方是proxy方，即等待握手成功的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;proxy_send_timeout&lt;/td&gt;
&lt;td&gt;上游服务器节点数据传给代理服务器的超时时间。即此时间段内，后端节点需要传完数据给代理服务器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;proxy_read_timeout&lt;/td&gt;
&lt;td&gt;定义代理服务器何时关闭和后端服务器连接的超时时长，默认为60秒，表示某次后端传输完数据给代理服务器后，如果60秒内代理服务器和后端服务器没有任何传输，则关闭此次连接。目的是避免代理服务器和后端服务器一直保持连接不断开而占用资源&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;1-4-2-proxy-_pass&quot;&gt;1.4.2 proxy_pass&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;proxy_pass http[s]&lt;span class=&quot;hljs-symbol&quot;&gt;://&lt;/span&gt;{ [&lt;span class=&quot;hljs-constant&quot;&gt;IP&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:PORT/uri/&lt;/span&gt;] | upstream_pool };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该指令在前文示例中已经演示过了。此处只说明注意点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当proxy_pass所在的location中使用了正则匹配时，则proxy_pass(包括fastcgi_pass和memcached_pass)定义的转发路径都不能包含任何URI信息。另外，location中使用了尾随斜线，那么proxy_pass定义的转发路径也必须使用斜线，或者都不加尾随斜线。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如下面的配置方式是允许的。当访问www.longshuai.com/forum/时将被转发到http://192.168.100.25:8080/bbs/上。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;server_name&lt;/span&gt; www.longshuai.com;
&lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; /forum/ {
    &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://192.168.100.25:8080/bbs/&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果使用了正则匹配，将是不允许的。如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;server_name&lt;/span&gt; www.longshuai.com;
&lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;hljs-regexp&quot;&gt;~ ^/forum/&lt;/span&gt; {
    &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://192.168.100.25:8080/bbs/&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只能修改转发路径使其不包含URI。如下。此时请求www.longshuai.com/forum/将转发到http://192.168.100.25:8080/forum/。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;server_name&lt;/span&gt; www.longshuai.com;
&lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;hljs-regexp&quot;&gt;~ ^/forum/&lt;/span&gt; {
    &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://192.168.100.25:8080/&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;可以在nginx配置文件中的http段、server段或location段设置proxy_set_header指令。设置该指令后，传输给上游服务器的报文首部将包含相关的信息，如设置客户端的真实IP地址。设置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; {
    &lt;span class=&quot;hljs-title&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server_name&lt;/span&gt;  www.longshuai.com;
    &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;hljs-regexp&quot;&gt;~ \.(png|jpg|jpeg|bmp|gif)$&lt;/span&gt; {
        &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://192.168.100.28:80&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;proxy_set_header&lt;/span&gt; X-Forwarded-For &lt;span class=&quot;hljs-variable&quot;&gt;$remote_addr&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; / {
        &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://192.168.100.30:80/&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;proxy_set_header&lt;/span&gt; X-Forwarded-For &lt;span class=&quot;hljs-variable&quot;&gt;$remote_addr&lt;/span&gt;;

    }
    &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;hljs-regexp&quot;&gt;~ \.(php|php5)$&lt;/span&gt; {
        &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://192.168.100.25:80&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;proxy_set_header&lt;/span&gt; X-Forwarded-For &lt;span class=&quot;hljs-variable&quot;&gt;$remote_addr&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-title&quot;&gt;error_page&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;502&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;503&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;504&lt;/span&gt;  /50x.html;
    &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; = /50x.html {
        &lt;span class=&quot;hljs-title&quot;&gt;root&lt;/span&gt;   html;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅在代理服务器上设置了该头部字段后还不够，因为后端服务器仅仅只是获取到它，默认并没有将其记录下来。所以需要在后端的服务的日志格式设置上记录此项或者在其他有需求的地方设置它。nginx的日志格式和apache的日志设置格式不同，以下分别是两种web程序的设置方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&lt;span class=&quot;hljs-title&quot;&gt;log_format&lt;/span&gt;  main  &lt;span class=&quot;hljs-string&quot;&gt;'&lt;span class=&quot;hljs-variable&quot;&gt;$remote_addr&lt;/span&gt; - &lt;span class=&quot;hljs-variable&quot;&gt;$remote_user&lt;/span&gt; [&lt;span class=&quot;hljs-variable&quot;&gt;$time_local&lt;/span&gt;] &quot;&lt;span class=&quot;hljs-variable&quot;&gt;$request&lt;/span&gt;&quot; '&lt;/span&gt;
              &lt;span class=&quot;hljs-string&quot;&gt;'&lt;span class=&quot;hljs-variable&quot;&gt;$status&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$body_bytes_sent&lt;/span&gt; &quot;&lt;span class=&quot;hljs-variable&quot;&gt;$http_referer&lt;/span&gt;&quot; '&lt;/span&gt;
              &lt;span class=&quot;hljs-string&quot;&gt;'&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$http_user_agent&lt;/span&gt;&quot; &quot;&lt;span class=&quot;hljs-variable&quot;&gt;$http_x_forwarded_for&lt;/span&gt;&quot; '&lt;/span&gt;;
&lt;span class=&quot;hljs-title&quot;&gt;access_log&lt;/span&gt; logs/access.log main;


&lt;span class=&quot;hljs-title&quot;&gt;LogFormat&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;%{X-Forwarded-For}i %h %l %u %t \&quot;%r\&quot; %&amp;gt;s %b \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot;&lt;/span&gt; combined
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是nginx日志上记录的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; nginx]
&lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.29&lt;/span&gt; - - [&lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;/Apr/&lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;35&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt; +080&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;hljs-string&quot;&gt;&quot;GET /index.php HTTP/1.0&quot;&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;76990&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;-&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.100.1&quot;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是apache日志中记录的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; ~]
&lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.29&lt;/span&gt; - - [&lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;/Apr/&lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;52&lt;/span&gt; +080&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;hljs-string&quot;&gt;&quot;GET /a.png HTTP/1.0&quot;&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2653&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;-&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36&quot;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;1-5-ngx-_http-_upstream-_module-&quot;&gt;1.5 ngx_http_upstream_module模块&lt;/h2&gt;
&lt;p&gt;upstream模块定义上游服务器组。主要的指令有&quot;upstream&quot;、&quot;server&quot;、&quot;ip_hash&quot;。upstream指令必须定义在server段外面。&lt;/p&gt;
&lt;p&gt;以下是一个综合示例定义方法，并非正确，只是放在一起方便比较用法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;upstream backend {
    server 192.168.100.25;
    server 192.168.100.26:80;
    server www.longshuai.com;
    server www.xiaofang.com:8080;
    server 192.168.100.27 weight=2 max_fails=2 fail_timeout=2s;
    server 192.168.100.28 down;
    server 192.168.100.29 &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;backup&lt;/span&gt;;&lt;/span&gt;
    ip_hash;   # 定义此项后，前面的server附加项weight和&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;backup&lt;/span&gt;功能失效。
}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认使用加权均衡算法，使用ip_hash指令可设置为ip_hash算法，但使用ip_hash指令后，如果server指令中使用了weight和backup选项，这两个功能将会失效。&lt;/p&gt;
&lt;p&gt;其中server指令后可以跟的附加选项有:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;weight&lt;/code&gt;:定义该后端服务器在组中的权重，默认为1，权重越大，代理转发到此服务器次数越多。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_fails和fail_timeout&lt;/code&gt;:定义代理服务器联系后端服务器的失败重联系次数和失败后重试等待时间。默认为1和10，如果设置为2和3，则表示只尝试联系2次，每次失败等待3秒后进行下一次重试，也就是说6秒后就能判定此后端服务器无法联系上，将负载均衡到下一台服务器上。常会配合proxy_next_upstream或者fastcgi_next_upstream或者memcached_next_upstream来指定失败时如何处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;down&lt;/code&gt;:将此后端服务器定义为离线状态。此功能不同于直接在配置文件中删除此服务器配置或注释它。常用于ip_hash均衡算法。当使用ip_hash算法时，如果某台服务器坏了需要将其从服务器组中排除，直接从配置文件中直接删除该服务器将会导致此前分配到此后端服务器的客户端重新计算IP_HASH值，而使用down则不会。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backup&lt;/code&gt;:指定当其他非backup的server都联系不上时，将返回backup所定义的服务器内容。常用于显示sorry page。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当server指定后端服务器时使用的是主机名的方式时，需要在代理服务器上添加域名解析记录，如放到/etc/hosts中。&lt;/p&gt;
&lt;p&gt;以下是一个配置示例。只定义了一个upstream组，所有请求都代理，权重为2比1，当192.168.100.28和192.168.100.30都断开联系时，将返回代理服务器本身配置的sorrypage。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;http&lt;/span&gt; {
    &lt;span class=&quot;hljs-title&quot;&gt;include&lt;/span&gt;       mime.types;
    &lt;span class=&quot;hljs-title&quot;&gt;default_type&lt;/span&gt;  application/octet-stream;
    &lt;span class=&quot;hljs-title&quot;&gt;sendfile&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;on&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;keepalive_timeout&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;;

    &lt;span class=&quot;hljs-title&quot;&gt;upstream&lt;/span&gt; web_group {
        &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.28&lt;/span&gt; weight=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; max_fails=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; fail_timeout=&lt;span class=&quot;hljs-number&quot;&gt;2s&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.30&lt;/span&gt; weight=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; max_fails=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; fail_timeout=&lt;span class=&quot;hljs-number&quot;&gt;2s&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:80&lt;/span&gt; backup;
    }
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; {
        &lt;span class=&quot;hljs-title&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:80&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;root&lt;/span&gt; /www/longshuai/;
        &lt;span class=&quot;hljs-title&quot;&gt;index&lt;/span&gt; index.html;
    }
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; {
        &lt;span class=&quot;hljs-title&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;server_name&lt;/span&gt;  www.longshuai.com;
        &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; / {
                &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://web_group&lt;/span&gt;;
        }
        &lt;span class=&quot;hljs-title&quot;&gt;error_page&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;502&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;503&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;504&lt;/span&gt;  /50x.html;
        &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; = /50x.html {
                &lt;span class=&quot;hljs-title&quot;&gt;root&lt;/span&gt;   html;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在反向代理服务器上创建/www/longshuai/目录，并向目录下的index.html文件中写入&quot;sorry....&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /www/longshuai/
echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;h1&amp;gt;sorry pages...&amp;lt;/h1&amp;gt;&quot;&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/www/&lt;/span&gt;longshuai/index.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重载代理服务器。在浏览器上输入www.longshuai.com并不断刷新，结果应该是2:1的返回权重。再依次测试停掉某一台后端服务器和两台后端都停掉的情况。&lt;/p&gt;

&lt;h2 id=&quot;1-6-&quot;&gt;1.6 反向代理的各种情况&lt;/h2&gt;
&lt;p&gt;反向代理时，可以根据uri的后缀来代理，也可以根据uri中的目录来代理，还可以根据客户端浏览器类型来代理。例如手机访问网站时转发到某个后端服务器组，IE浏览器访问的转发到某一个后端服务器组等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
location ~ \.(jpeg|jpg|png|bmp|gif)&lt;span class=&quot;hljs-variable&quot;&gt;$ &lt;/span&gt;{
    proxy_pass ...
}


location ~ &lt;span class=&quot;hljs-regexp&quot;&gt;/forum/&lt;/span&gt; {
    proxy_pass ...
}


location / {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-variable&quot;&gt;$http_user_agent&lt;/span&gt; ~ &lt;span class=&quot;hljs-string&quot;&gt;&quot;MSIE&quot;&lt;/span&gt;) {
        proxy_pass...
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-variable&quot;&gt;$http_user_agent&lt;/span&gt; ~ &lt;span class=&quot;hljs-string&quot;&gt;&quot;Chrome&quot;&lt;/span&gt;) {
        proxy_pass...
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;1-7-nginx-memcached&quot;&gt;1.7 nginx代理memcached&lt;/h2&gt;
&lt;p&gt;该模块可以从将请求代理至memcached server上，并立即从server上获取响应数据。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; / {
                &lt;span class=&quot;hljs-title&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$memcached_key&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$uri&lt;/span&gt;?&lt;span class=&quot;hljs-variable&quot;&gt;$args&lt;/span&gt;&quot;&lt;/span&gt;;
                &lt;span class=&quot;hljs-title&quot;&gt;memcached_pass&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11211&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nginx代理memcached时，需要以变量$memcached_key作为key去访问memcached server上的数据。例如此处将$uri$args变量赋值给$memcached_key变量作为key去访问memcached服务器上对应的数据。&lt;/p&gt;
&lt;p&gt;但这样的代理显然不符合真正的需求：没有实现memcached的分布式功能。当memcached server宕机时，nginx将无法从中获取任何数据。所以应该使用上游服务器组。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;upstream&lt;/span&gt; memcached {
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11211&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11212&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11213&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11214&lt;/span&gt;;
}

&lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; {
    &lt;span class=&quot;hljs-title&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server_name&lt;/span&gt;  dev.hwtrip.com;

    &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt; ^~&lt;/span&gt; /cache/ {
        &lt;span class=&quot;hljs-title&quot;&gt;set&lt;/span&gt;            &lt;span class=&quot;hljs-variable&quot;&gt;$memcached_key&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$uri&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$args&lt;/span&gt;&quot;&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;memcached_pass&lt;/span&gt; memcached;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这也不适合，因为memcached是基于一致性哈希算法的，而upstream模块默认并不支持一致性哈希算法。可以通过upstream模块的&lt;span&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#hash&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;hash&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;指令或者另外使用一个第三方模块&lt;span&gt;&lt;a href=&quot;https://www.nginx.com/resources/wiki/modules/consistent_hash/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;ngx_http_upstream_consistent_hash&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果使用的是upstream模块的hash指令，配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;upstream&lt;/span&gt; memcached {
    &lt;span class=&quot;hljs-title&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$uri&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$args&lt;/span&gt;&quot;&lt;/span&gt; consistent;
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11211&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11212&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11213&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11214&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，各上游主机就通过hash一致性的算法进行负载均衡。&lt;/p&gt;
&lt;p&gt;如果使用的是第三方模块ngx_http_upstream_consistent_hash，则在模块添加成功后如下配置upstream组：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;upstream&lt;/span&gt; memcached {
    &lt;span class=&quot;hljs-title&quot;&gt;consistent_hash&lt;/span&gt; consistent;
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11211&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11212&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11213&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:11214&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;nginx的ngx_http_proxy_module自带了缓存功能。有几种缓存：网页内容缓存，日志缓存，打开文件缓存，fastcgi缓存。fastcgi缓存功能应慎用，因为动态程序的前后逻辑可能改变了，缓存后的结果可能并非实际所需结果。&lt;/p&gt;
&lt;p&gt;在说明nginx自带的缓存功能之前，需说明其缺陷。&lt;span&gt;&lt;strong&gt;nginx的缓存功能主要用于缓存体积较小的页面资源，当数据较大时很容易出现瓶颈。在页面资源的缓存功能上，它属于业余玩家。而squid是科班出身，功能最全面，可以缓存大量数据，但架构太老，性能一般。varnish则是此类缓存的新贵，架构较新，内存管理完全交由操作系统内核，性能是squid的几倍之强，但缓存的内容不足squid&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;本节所讲的主要是nginx自带缓存的网页内容缓存。&lt;/span&gt;&lt;strong&gt;当实现网页内容缓存时，作为web服务程序，它可以缓存自身返回给客户端的数据，包括读取的图片、文件等；作为代理，它可以缓存来自后端的数据&lt;/strong&gt;。&lt;/span&gt;缓存后的数据在内存中有，也会放在设定的目录下。这样以后客户端继续请求相同资源时，可以直接从内存中或者自身的磁盘中获取并返回给客户端。当缓存超出指定的空间大小时，将会有一个专门的线程cache_manager来清理缓存。&lt;/p&gt;
&lt;p&gt;定义的相关指令主要有3个：proxy_cache_path、proxy_cache、proxy_cache_valid。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;&lt;code&gt;proxy_cache_path&lt;/code&gt;：它的语法比较复杂，但用起来很简单。
&lt;pre&gt;
&lt;code&gt;proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=&lt;span class=&quot;hljs-keyword&quot;&gt;time&lt;/span&gt;] [max_size=size] [manager_files=number] [manager_sleep=&lt;span class=&quot;hljs-keyword&quot;&gt;time&lt;/span&gt;] [manager_threshold=&lt;span class=&quot;hljs-keyword&quot;&gt;time&lt;/span&gt;] [loader_files=number] [loader_sleep=&lt;span class=&quot;hljs-keyword&quot;&gt;time&lt;/span&gt;] [loader_threshold=&lt;span class=&quot;hljs-keyword&quot;&gt;time&lt;/span&gt;] [purger=on|off] [purger_files=number] [purger_sleep=&lt;span class=&quot;hljs-keyword&quot;&gt;time&lt;/span&gt;] [purger_threshold=&lt;span class=&quot;hljs-keyword&quot;&gt;time&lt;/span&gt;];
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中&lt;code&gt;proxy_cache_path path [levels=levels] keys_zone=name:size [max_size=size]&lt;/code&gt;这几项是一般使用的选项和必需项。以下为一示例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;proxy_cache_path /usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/nginx/cache_dir levels=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; keys_zone=cache_one:&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;m&lt;/span&gt; max_size=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;g;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;path&lt;/code&gt;:定义缓存放在磁盘的哪个目录下。此处表示定义在/usr/local/nginx/cache_dir目录下。目录不存在会自动创建。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;levels&lt;/code&gt;:定义缓存目录的级别，同时定义缓存目录名称的字符数。例如&lt;code&gt;levels=1:2:2&lt;/code&gt;表示3级目录，且第一级目录名1个字符，第二级目录2个字符，第三级目录2个字符。目录最多3级，目录名最多为2个字符。例如上例中&quot;levels=1:2&quot;产生的缓存文件路径可能是这样的&quot;/usr/local/nginx/cache_dir/d/f1/50a3269acaa7774c02d4da0968124f1d&quot;，注意其中加粗的字体。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keys_zone&lt;/code&gt;:定义缓存标识名称和内存中缓存的最大空间。name部分必须唯一，在后面会引用name来表示使用该缓存方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_size&lt;/code&gt;:定义磁盘中缓存目录的最大空间。即path定义的文件最大空间。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该指令定义后只是定义了一种缓存方法，并非开启了缓存。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;proxy_cache&lt;/code&gt;：定义要使用哪个缓存方法。使用&lt;code&gt;proxy_cache_path&lt;/code&gt;中的name来引用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如引用上例定义的cache_one。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;proxy_cache&lt;/span&gt; cache_cache;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;proxy_cache_valid&lt;/code&gt;：根据状态码来指定缓存有效期。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，下面的表示状态码为200和302的状态缓存1小时，状态码为404时即page not found的缓存只有1分钟，防止客户端请求一直错误，状态码为其他的则缓存5分钟。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;proxy_cache_valid&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;302&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1h&lt;/span&gt;;
&lt;span class=&quot;hljs-title&quot;&gt;proxy_cache_valid&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;404&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1m&lt;/span&gt;;
&lt;span class=&quot;hljs-title&quot;&gt;proxy_cache_valid&lt;/span&gt; any &lt;span class=&quot;hljs-number&quot;&gt;5m&lt;/span&gt;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不指定状态码，只指定时间，则默认只缓存状态码200、301、302各5分钟，其他的状态码不缓存。&lt;/p&gt;
&lt;p&gt;以下是代理服务器192.168.100.29上定义的缓存示例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;http&lt;/span&gt; {
    &lt;span class=&quot;hljs-title&quot;&gt;include&lt;/span&gt;       mime.types;
    &lt;span class=&quot;hljs-title&quot;&gt;default_type&lt;/span&gt;  application/octet-stream;
    &lt;span class=&quot;hljs-title&quot;&gt;sendfile&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;on&lt;/span&gt;;
    &lt;span class=&quot;hljs-title&quot;&gt;keepalive_timeout&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;;

        &lt;span class=&quot;hljs-title&quot;&gt;upstream&lt;/span&gt; web_group {
                &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.28&lt;/span&gt; weight=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; max_fails=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; fail_timeout=&lt;span class=&quot;hljs-number&quot;&gt;2s&lt;/span&gt;;
                &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.30&lt;/span&gt; weight=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; max_fails=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; fail_timeout=&lt;span class=&quot;hljs-number&quot;&gt;2s&lt;/span&gt;;
                &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:80&lt;/span&gt; backup;
        }
        &lt;span class=&quot;hljs-title&quot;&gt;proxy_cache_path&lt;/span&gt; /usr/local/nginx/cache_dir levels=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; keys_zone=cache_one:&lt;span class=&quot;hljs-number&quot;&gt;20m&lt;/span&gt; max_size=&lt;span class=&quot;hljs-number&quot;&gt;1g&lt;/span&gt;;
        &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; {
                &lt;span class=&quot;hljs-title&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:80&lt;/span&gt;;
                &lt;span class=&quot;hljs-title&quot;&gt;root&lt;/span&gt; /www/longshuai/;
                &lt;span class=&quot;hljs-title&quot;&gt;index&lt;/span&gt; index.html;
        }
        &lt;span class=&quot;hljs-title&quot;&gt;server&lt;/span&gt; {
                &lt;span class=&quot;hljs-title&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;
                &lt;span class=&quot;hljs-title&quot;&gt;server_name&lt;/span&gt;  www.longshuai.com;
              
                &lt;span class=&quot;hljs-title&quot;&gt;add_header&lt;/span&gt; X-Cache &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$upstream_cache_status&lt;/span&gt; from &lt;span class=&quot;hljs-variable&quot;&gt;$server_addr&lt;/span&gt;&quot;&lt;/span&gt;;
                &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; / {
                        &lt;span class=&quot;hljs-title&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://web_group&lt;/span&gt;;
                        &lt;span class=&quot;hljs-title&quot;&gt;proxy_cache&lt;/span&gt; cache_one;
                        &lt;span class=&quot;hljs-title&quot;&gt;proxy_cache_valid&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1h&lt;/span&gt;;
                        &lt;span class=&quot;hljs-title&quot;&gt;proxy_cache_valid&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;404&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1m&lt;/span&gt;;
                        &lt;span class=&quot;hljs-title&quot;&gt;proxy_cache_valid&lt;/span&gt; any &lt;span class=&quot;hljs-number&quot;&gt;5m&lt;/span&gt;;
                }

        &lt;span class=&quot;hljs-title&quot;&gt;error_page&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;502&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;503&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;504&lt;/span&gt;  /50x.html;
        &lt;span class=&quot;hljs-title&quot;&gt;location&lt;/span&gt; = /50x.html {
            &lt;span class=&quot;hljs-title&quot;&gt;root&lt;/span&gt;   html;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中添加的一行&quot;add_header X-Cache &quot;$upstream_cache_status from $server_addr&quot;;&quot;表示在响应报文的头部加上一字段X-Cache，其值为是否命中缓存的状态($upstream_cache_status)，从哪台服务器上($server_addr)取得的缓存。 重载代理服务器的配置文件后，在客户端打开&quot;开发者工具&quot;进行测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171017234329834-233619318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于是第一次提供缓存功能，所以结果是未命中缓存。此时已经将缓存保存下来了。 再进行测试，结果将命中缓存是&quot;hit from 192.168.100.29&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171017234356302-1458720572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看缓存目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; nginx]
/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/nginx/cache_dir/
├── &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;
│   └── &lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;
│       └── &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;abcc5796b407cf3db2716539d256263
└── d
    └── f1
        └── &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;b37290aabefe7369a4680875f763f1d
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要删除缓存，只需删除对应的目录即可。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7684732.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/7684732.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/h3&gt;
</description>
<pubDate>Tue, 17 Oct 2017 15:56:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/7684732.html</dc:identifier>
</item>
<item>
<title>RoportNG报表显示中文乱码和TestNG显示中文乱码实力解决办法 - 温一壶清酒</title>
<link>http://www.cnblogs.com/hong-fithing/p/7684712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hong-fithing/p/7684712.html</guid>
<description>&lt;p&gt;最近在进军测试自动化框架学习阶段，但无意间总是会伴随小问题的困扰，比如中文乱码，而导致显示总是不舒服，个人觉得，就一定要解决，似乎有点点强迫症。所以遇到RoportNG报表显示中文乱码和TestNG显示中文乱码，自己苦寻解决办法，终于得到解决。可能这是最基础的问题，但还是想记录下，也希望能让以后的朋友少走弯路，少些烦恼。&lt;/p&gt;

&lt;p&gt;Maven是一个采用纯Java编写的软件项目管理和综合工具。Maven采用了一种被称之为project object model (POM)概念来管理项目， 所有的项目配置信息都被定义在一个叫做pom.xml的文件中，通过该文件，Maven可以管理项目的整个声明周期，包括编译，构建，测试，发布，报告等等。目前Apache下绝大多数项目都已经采用Maven进行管理， 而Maven本身还支持多种插件，可以方便更灵活的控制项目。&lt;/p&gt;
&lt;h2&gt;Maven安装&lt;/h2&gt;
&lt;p&gt;Maven下载地址：&lt;/p&gt;
&lt;p&gt;打开&lt;a href=&quot;http://maven.apache.org/download.cgi&quot;&gt;http://maven.apache.org/download.cgi&lt;/a&gt;，下载apache-maven-3.5.0-bin.zip，将下载的zip包解压在本地硬盘， 如C盘。&lt;/p&gt;
&lt;p&gt;环境变量配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MAVEN_HOME: C:\apache-maven-3.3.9&lt;span&gt;
MAVEN: &lt;/span&gt;%MAVEN_HOME%&lt;span&gt;\bin
MAVEN_OPTS: &lt;/span&gt;-Xms256m -&lt;span&gt;Xmx512m
在path最前面加上： &lt;/span&gt;%MAVEN%;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置好环境变量后，验证maven是否安装成功，输入mvn -version验证，出现如下所示表示成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017225507068-2135023965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;fontstyle0&quot;&gt;Maven&lt;span class=&quot;fontstyle1&quot;&gt;配置：&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;给&lt;span class=&quot;fontstyle0&quot;&gt;Maven&lt;span class=&quot;fontstyle1&quot;&gt;添加本地仓库，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;在&lt;span class=&quot;fontstyle0&quot;&gt;Maven&lt;span class=&quot;fontstyle1&quot;&gt;的安装路径中的&lt;span class=&quot;fontstyle0&quot;&gt;conf&lt;span class=&quot;fontstyle1&quot;&gt;文件夹中配置&lt;span class=&quot;fontstyle0&quot;&gt;settings.xml：&lt;span class=&quot;fontstyle1&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017225759287-106327086.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;在文中找到&lt;span class=&quot;fontstyle0&quot;&gt;localRepository&lt;span class=&quot;fontstyle1&quot;&gt;注释行并添加如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&amp;lt;localRepository&amp;gt;F:\maven-dependcies&amp;lt;/localRepository&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017225851537-1135580599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;备注： F:\maven-dependcies&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;为手动建立， 配置好该项后， 以后&lt;span class=&quot;fontstyle2&quot;&gt;Maven&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;用到的所有资源文件都会存储到该目录， 相当于本地仓库。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;fontstyle1&quot;&gt;Maven&lt;span class=&quot;fontstyle0&quot;&gt;配置&lt;span class=&quot;fontstyle1&quot;&gt;mirror&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;mirror&lt;span class=&quot;fontstyle0&quot;&gt;就是镜像， 主要提供一个方便地切换远程仓库地址的途径。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;在&lt;span class=&quot;fontstyle1&quot;&gt;Maven&lt;span class=&quot;fontstyle0&quot;&gt;的安装路径中的&lt;span class=&quot;fontstyle1&quot;&gt;conf&lt;span class=&quot;fontstyle0&quot;&gt;文件夹中配置&lt;span class=&quot;fontstyle1&quot;&gt;settings.xml&lt;span class=&quot;fontstyle0&quot;&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;在文中找到&lt;span class=&quot;fontstyle1&quot;&gt;&amp;lt;mirrors&amp;gt;&lt;span class=&quot;fontstyle0&quot;&gt;行并在其中添加如下： &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017230137724-375402630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;国内OSChina提供的镜像：
&lt;/span&gt;&amp;lt;mirror&amp;gt;
&amp;lt;id&amp;gt;CN&amp;lt;/id&amp;gt;
&amp;lt;name&amp;gt;OSChina Central&amp;lt;/name&amp;gt;
&amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.oschina.net/content/groups/public/&amp;lt;/url&amp;gt;&lt;/span&gt;
&amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
&amp;lt;/mirror&amp;gt;&lt;span&gt;
aliyun阿里云提供的镜像：
&lt;/span&gt;&amp;lt;mirror&amp;gt;
&amp;lt;id&amp;gt;nexus-aliyun&amp;lt;/id&amp;gt;
&amp;lt;mirrorOf&amp;gt;*&amp;lt;/mirrorOf&amp;gt;
&amp;lt;name&amp;gt;Nexus aliyun&amp;lt;/name&amp;gt;
&amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.aliyun.com/nexus/content/groups/public&amp;lt;/url&amp;gt;&lt;/span&gt;
&amp;lt;/mirror&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;备注： 配置这两者中的其中一个即可， 如果不配置mirror， 将会使用默认国外的mirror， jar包下载很慢，建议配置阿里云镜像。&lt;/p&gt;
&lt;h3&gt;Eclipse中安装Maven插件&lt;/h3&gt;
&lt;p&gt;1.&lt;span class=&quot;fontstyle0&quot;&gt;打开&lt;span class=&quot;fontstyle1&quot;&gt;Eclipse,&lt;span class=&quot;fontstyle0&quot;&gt;进入&lt;span class=&quot;fontstyle1&quot;&gt;help -- &amp;gt;Install New Software...，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;点&lt;span class=&quot;fontstyle1&quot;&gt;Add&lt;span class=&quot;fontstyle0&quot;&gt;按钮输入：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;m2e，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;http://download.eclipse.org/technology/m2e/releases，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;然后点击&lt;span class=&quot;fontstyle1&quot;&gt;next&lt;span class=&quot;fontstyle0&quot;&gt;直到安装完成。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017230430427-942178933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017230606287-1567733515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span class=&quot;fontstyle0&quot;&gt;设置&lt;span class=&quot;fontstyle1&quot;&gt;Maven&lt;span class=&quot;fontstyle0&quot;&gt;插件所关联的&lt;span class=&quot;fontstyle1&quot;&gt;Maven&lt;span class=&quot;fontstyle0&quot;&gt;程序 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;选择&lt;span class=&quot;fontstyle1&quot;&gt;Eclipse&lt;span class=&quot;fontstyle0&quot;&gt;菜单栏的&lt;span class=&quot;fontstyle1&quot;&gt;Window--&amp;gt;Preferences--&amp;gt;Maven--Installations&lt;span class=&quot;fontstyle0&quot;&gt;菜单项， 点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;击&lt;span class=&quot;fontstyle1&quot;&gt;add,&lt;span class=&quot;fontstyle0&quot;&gt;选择&lt;span class=&quot;fontstyle1&quot;&gt;Maven&lt;span class=&quot;fontstyle0&quot;&gt;的具体安装目录 ，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017230733537-953619559.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;span class=&quot;fontstyle0&quot;&gt;设置自定义的本地仓库 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;选择&lt;span class=&quot;fontstyle1&quot;&gt;Eclipse&lt;span class=&quot;fontstyle0&quot;&gt;菜单栏的&lt;span class=&quot;fontstyle1&quot;&gt;Window--&amp;gt;Preferences--&amp;gt;Maven--UserSettings&lt;span class=&quot;fontstyle0&quot;&gt;菜单项， 修&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;改为我们自定义仓库位置下的&lt;span class=&quot;fontstyle1&quot;&gt;settings.xml&lt;span class=&quot;fontstyle0&quot;&gt;文件， 修改好后点击&lt;span class=&quot;fontstyle1&quot;&gt;OK&lt;span class=&quot;fontstyle0&quot;&gt;按钮。 如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017230919381-199186105.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;新建Maven工程&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;打开&lt;span class=&quot;fontstyle1&quot;&gt;eclipse&lt;span class=&quot;fontstyle0&quot;&gt;， 右击左边空白处&lt;span class=&quot;fontstyle1&quot;&gt;--new--Other...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;在弹出的对话框中， 选择&lt;span class=&quot;fontstyle1&quot;&gt;Maven&lt;span class=&quot;fontstyle0&quot;&gt;文件夹下的第三个&lt;span class=&quot;fontstyle1&quot;&gt;Maven Project&lt;span class=&quot;fontstyle0&quot;&gt;， 点击&lt;span class=&quot;fontstyle1&quot;&gt;Next，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;下一个对话框页面选择， 点击&lt;span class=&quot;fontstyle1&quot;&gt;Next，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;下一个对话框中填入&lt;span class=&quot;fontstyle1&quot;&gt;groupid&lt;span class=&quot;fontstyle0&quot;&gt;、 &lt;span class=&quot;fontstyle1&quot;&gt;Artifactid&lt;span class=&quot;fontstyle0&quot;&gt;、 &lt;span class=&quot;fontstyle1&quot;&gt;name &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017231111193-244331293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017231248318-2082249534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;建出来的工程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017231327224-594570096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说了这么多，Maven终于搭好，因为后续工作是建立在Maven的基础上，所以啰嗦了些。&lt;/p&gt;

&lt;p&gt;要使用RoportNG报表，需要依赖如下三个jar包，velocity-dep-1.4.jar，reportng-1.1.4.jar，guice-4.0.jar，需要在Maven工程下pom.xml文件下配置，配置如下。至于如何得到这些配置信息，就不再啰嗦了，可看这篇随笔，里面介绍很详细：&lt;a href=&quot;http://www.cnblogs.com/hong-fithing/p/7622215.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hong-fithing/p/7622215.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017231500349-1956352017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存pom.xml文件即可，自动下载。&lt;/p&gt;
&lt;p&gt;回归正题，在testng.xml文件下配置如下信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE suite SYSTEM &quot;http://beust.com/testng/testng-1.0.dtd&quot; &amp;gt;
&amp;lt;suite name=&quot;suite1&quot;&amp;gt;
    &amp;lt;test name=&quot;test1&quot;&amp;gt;
        &amp;lt;classes&amp;gt;
            &amp;lt;&lt;span&gt;class&lt;/span&gt; name=&quot;com.selenium.model_datadriver.baiduSearchTest&quot; /&amp;gt;
        &amp;lt;/classes&amp;gt;
    &amp;lt;/test&amp;gt;
  &lt;span&gt;  &amp;lt;listeners&amp;gt;
      &amp;lt;listener class-name=&quot;org.uncommons.reportng.HTMLReporter&quot; /&amp;gt; 
      &amp;lt;listener class-name=&quot;org.uncommons.reportng.JUnitXMLReporter&quot; /&amp;gt;
    &amp;lt;/listeners&amp;gt;&lt;/span&gt;
&amp;lt;/suite&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存，右键运行该testng.xml文件，由于是在该文件中配置的，所以需要运行该文件即可。在工程路径下，查看如下文件夹下信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017232302318-366636618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开index.html文件，就是刚生成的报表，如果没有配置上述代码，是不会生成html文件夹的。打开index.html文件即可查看报表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017232411365-99044257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很无奈的是，用例全通过，但有中文乱码，很是伤心，这样看起来也很是不爽，解决办法是：更改roportng.jar包信息，这样也麻烦，我找到了一个已经修改好了的jar包，下载地址如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://pan.baidu.com/s/1pLdZdt5&quot;&gt;http://pan.baidu.com/s/1pLdZdt5&lt;/a&gt;，密码：fctu。下载后，&lt;span&gt;替换掉&lt;/span&gt;之前的reportng-1.1.4.jar包即可。&lt;/p&gt;
&lt;p&gt;如何找到reportng-1.1.4.jar路径，如下所示即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017232733990-32338874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;替换好后，再次执行testng.xml文件，去查看报表，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017232835990-938913364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样是不是好看多了，个人觉得看着就舒服。为何不使用testng自动生成的报表呢，首先还是roportng产生的报表还是有优势些，还可以自己给日志添加css样式，让报表更加漂亮。比如，用例出错，提示信息就很完美。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017233040396-1044133801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在报表中加自定义日志，首先在java文件中导入该包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; org.testng.Reporter;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在想写入日志信息的地方输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Reporter.log(&quot;启动谷歌浏览器&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Reporter.log就表示日志信息。&lt;/p&gt;
&lt;p&gt;刚才说的，还可以添加css样式，如何添加呢？一起来看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
System.setProperty(&quot;org.uncommons.reportng.escape-output&quot;, &quot;false&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在java文件中的方法中添加如上代码，就可以添加样式了，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Reporter.log(&quot;&amp;lt;span style=\&quot;color:#16A05D\&quot;&amp;gt;谷歌浏览器驱动路径是：&quot;+path+&quot;&amp;lt;/span&amp;gt;&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;去查看报表中的日志信息，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017233805771-1150045544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样是不是就很好区分信息了，个人觉得还是很方便的。如果不添加org.testng.Reporter包的话，报表中是不会有Log Output信息的。&lt;/p&gt;

&lt;p&gt;TestNG显示中文乱码的问题很好解决，首先先来看用例执行完后的显示结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017234054756-59415910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样看起来是真的丑，而且还是很别扭，我是实在受不了。解决办法是在eclipse的根目录下，有个eclipse.ini配置文件，加上该信息即可：-Dfile.encoding=UTF-8。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017234218896-1017221960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017234224506-778633021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加好后，&lt;span&gt;重启eclipse&lt;/span&gt;，再次运行代码，再次查看结果，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171017234302381-517709950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人觉得是美观多了，这样是不是更有动力敲代码呢？&lt;/p&gt;
&lt;p&gt;很弱的问题，困扰了自己大半天，希望能对以后的朋友有所帮助。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;29.483394833948&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;本文仅代表作者观点，系作者@温一壶清酒发表。&lt;br/&gt;欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;br/&gt;文章出处：&lt;a href=&quot;http://www.cnblogs.com/hong-fithing/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hong-fithing/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 17 Oct 2017 15:47:00 +0000</pubDate>
<dc:creator>温一壶清酒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hong-fithing/p/7684712.html</dc:identifier>
</item>
<item>
<title>Hadoop（七）HDFS容错机制详解 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7681146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7681146.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;　　HDFS（Hadoop Distributed File System）是一个分布式文件系统。它具有高容错性并提供了高吞吐量的数据访问，非常适合大规模数据集上的应用，它提供了一个高度容错性和高吞吐量的海量数据存储解决方案。&lt;/p&gt;
&lt;p&gt;　　优点是：&lt;/p&gt;
&lt;p&gt;　　　　高吞吐量访问：HDFS的每个Block分布在不同的Rack上，在用户访问时，HDFS会计算使用最近和访问量最小的服务器给用户提供。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　   由于Block在不同的Rack上都有备份，所以不再是单数据访问，所以速度和效率是非常快的。另外HDFS可以并行从服务器集群中读写，增加了文件读写的访问带宽。&lt;br/&gt;　　　　高容错性：系统故障是不可避免的，如何做到故障之后的数据恢复和容错处理是至关重要的。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　HDFS通过多方面保证数据的可靠性，多份复制并且分布到物理位置的不同服务器上，数据校验功能、后台的连续自检数据一致性功能都为高容错提供了可能。&lt;br/&gt;　　　　线性扩展：因为HDFS的Block信息存放到NameNode上，文件的Block分布到DataNode上，当扩充的时候仅仅添加DataNode数量，系统可以在不停止服务的情况下做扩充，不需要人工干预。　&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017122446256-986617333.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.1、故障类型（三类故障）&lt;/h2&gt;
&lt;p&gt;　　1）节点失败&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017122553084-1740967680.png&quot; alt=&quot;&quot; width=&quot;303&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）网络故障&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017122619193-864269184.png&quot; alt=&quot;&quot; width=&quot;306&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）数据损坏（脏数据）&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017122653584-1139165689.png&quot; alt=&quot;&quot; width=&quot;349&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.2、故障检测机制&lt;/h2&gt;
&lt;p&gt;　　1）节点失败检测机制&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017122749099-1557704034.png&quot; alt=&quot;&quot; width=&quot;331&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017122812224-54117187.png&quot; alt=&quot;&quot; width=&quot;337&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017122843943-1794497033.png&quot; alt=&quot;&quot; width=&quot;334&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）通信故障检测机制&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017122925740-1631174388.png&quot; alt=&quot;&quot; width=&quot;324&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）数据错误检测机制&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017123007568-1855708205.png&quot; alt=&quot;&quot; width=&quot;353&quot; height=&quot;257&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017123031771-571051692.png&quot; alt=&quot;&quot; width=&quot;351&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017123101521-744260452.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.3、回复：心跳信息和数据块报告&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017123250349-1081070131.png&quot; alt=&quot;&quot; width=&quot;506&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　HDFS存储理念是以最少的钱买最烂的机器并实现最安全、难度高的分布式文件系统(高容错性低成本)。&lt;/p&gt;
&lt;p&gt;　　从上可以看出，HDFS认为机器故障是种常态，所以在设计时充分考虑到单个机器故障，单个磁盘故障，单个文件丢失等情况。&lt;/p&gt;
&lt;h2&gt;1.4、读写容错&lt;/h2&gt;
&lt;p&gt;　　1）写容错&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017130736881-877914479.png&quot; alt=&quot;&quot; width=&quot;403&quot; height=&quot;221&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017130808068-50225562.png&quot; alt=&quot;&quot; width=&quot;412&quot; height=&quot;206&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017130834943-531887290.png&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017130905115-722450396.png&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）读容错&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131002240-947110555.png&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;257&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131028146-1208044573.png&quot; alt=&quot;&quot; width=&quot;397&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.5、数据节点（DN）失效&lt;/h2&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131124943-1832701263.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131157302-65849177.png&quot; alt=&quot;&quot; width=&quot;366&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131243052-65338856.png&quot; alt=&quot;&quot; width=&quot;216&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131305427-9457110.png&quot; alt=&quot;&quot; width=&quot;220&quot; height=&quot;273&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131338849-810055510.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131413021-2060816792.png&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;260&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131523709-813940191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1）机架与数据节点&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131556459-888588387.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）副本放置策略&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131631068-1860658653.png&quot; alt=&quot;&quot; width=&quot;355&quot; height=&quot;165&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　　　数据块的第一个副本优先放在写入数据块的客户端所在的节点上，但是如果这个客户端上的数据节点空间不足或者是当前负载过重，则应该从该数据节点所在的机架中选择一个合适的数据节点作为本地节点。&lt;br/&gt;　　　　如果客户端上没有一个数据节点的话，则从整个集群中随机选择一个合适的数据节点作为此时这个数据块的本地节点。&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131724177-1419783064.png&quot; alt=&quot;&quot; width=&quot;395&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　HDFS的存放策略是将一个副本存放在本地机架节点上，另外两个副本放在不同机架的不同节点上。&lt;br/&gt;　　　　这样集群可在完全失去某一机架的情况下还能存活。同时，这种策略减少了机架间的数据传输，提高了写操作的效率，因为数据块只存放在两个不同的机架上，&lt;/p&gt;
&lt;p&gt;　　　　　　减少了读取数据时需要的网络传输总带宽。这样在一定程度上兼顾了数据安全和网络传输的开销。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131825334-291096645.png&quot; alt=&quot;&quot; width=&quot;323&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017131851052-1687834576.png&quot; alt=&quot;&quot; width=&quot;317&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 17 Oct 2017 15:37:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7681146.html</dc:identifier>
</item>
<item>
<title>JAVA提高五：注解Annotation - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/7679315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/7679315.html</guid>
<description>&lt;p&gt;&lt;span&gt;今天我们学习JDK5.0中一个非常重要的特性，叫做注解。是现在非常流行的一种方式，可以说因为配置XML 比较麻烦或者比容易查找出错误，现在越来越多的框架开始支持注解方式，比如注明的Spring 框架，常用的注解：&lt;a class=&quot;link&quot; title=&quot;5.9.1 @Required&quot;&gt;@Required&lt;/a&gt;， @Autowired, @PostConstruct, @PreDestory；可见注解的重要性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、什么是注解（Annotation）和 元数据（metadata）？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Annotation（注解）就是Java提供了一种为程序元素关联任何信息或任何元数据（metadata）的途径和方法&lt;/span&gt;。&lt;/strong&gt;Annotion(注解)是一个接口，程序可以通过反射来获取指定程序元素的Annotion对象，然后通过Annotion对象来获取注解里面的元数据。&lt;span&gt;简单一点说：就是为程序打上了某种标记，可以加在类，包，字段 ，方法，方法的参数及局部变量上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Annotation的成员在Annotation类型中以无参数的方法的形式被声明（比如：String color() default &quot;blue&quot;;）。&lt;strong&gt;其方法名和返回值定义了该成员的名字和类型&lt;/strong&gt;。在此有一个特定的默认语法：允许声明任何Annotation成员的默认值。一个Annotation可以将name=value对作为没有定义默认值的Annotation成员的值，当然也可以使用name=value对来覆盖其它成员默认值。这一点有些近似类的继承特性，父类的构造函数可以作为子类的默认构造函数，但是也可以被子类覆盖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面讲了这么多概念，我们来看一个实际的例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;This is String Representation of current object.&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的代码中，我重写了&lt;code&gt;toString()&lt;/code&gt;方法并使用了&lt;code&gt;@Override&lt;/code&gt;注解。但是，即使我不使用&lt;code&gt;@Override注解标记代码，程序也能够正常执行。那么加上与不加上又有什么区别呢？&lt;/code&gt;事实上，&lt;/span&gt;@Override&lt;code&gt;告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果我不小心拼写错误，例如将toString()&lt;/code&gt;写成了&lt;code&gt;toStrring(){double r}&lt;/code&gt;，而且我也没有使用&lt;code&gt;@Override&lt;/code&gt;注解，那程序依然能编译运行。但运行结果会和我期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于阅读程序。也理解了注解实际上就是在源程序上面加上了标签。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;元数据从metadata一词译来，就是“关于数据的数据”的意思。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在Java中元数据以标签的形式存在于Java代码中，元数据标签的存在并不影响程序代码的编译和执行，&lt;strong&gt;它只是被用来生成其它的文件或在运行时获取被运行代码的描述信息&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、注解的分类（JDK内置系统注解、元注解、自定义注解）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;在学习注解的分类之前，我们先了解下 &lt;strong&gt;Annotation和Annotation类型。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Annotation：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Annotation使用了在java5.0所带来的新语法，它的行为十分类似public、final这样的修饰符。每个Annotation具有一个名字和成员个数&amp;gt;=0。每个Annotation的成员具有被称为name=value对的名字和值（就像javabean一样），name=value装载了Annotation的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：&lt;/span&gt;@Override&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Annotation类型：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;Annotation类型定义了Annotation的名字、类型、成员默认值。&lt;strong&gt;一个Annotation类型可以说是一个特殊的java接口，它的成员变量是受限制的，而声明Annotation类型时需要使用新语法。当我们通过java反射api访问Annotation时，返回值将是一个实现了该annotation类型接口的对象，通过访问这个对象我们能方便的访问到其Annotation成员。&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：Override&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Override {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注解的分类：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据注解参数的个数，我们可以将注解分为三类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1.标记注解：一个没有成员定义的Annotation类型被称为标记注解。这种Annotation类型仅使用自身的存在与否来为我们提供信息。比如后面的系统注解@Override;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　2.单值注解&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　3.完整注解　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据注解使用方法和用途，我们可以将Annotation分为三类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1.JDK内置系统注解&lt;br/&gt;　　　　2.元注解&lt;br/&gt;　　　　3.自定义注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.JDK内置系统注解：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注解的语法比较简单，除了@符号的使用外，他基本与Java固有的语法一致，JavaSE中内置三个标准注解，定义在java.lang中：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　@Override：用于修饰此方法覆盖了父类的方法；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　@Deprecated：用于修饰已经过时的方法；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　@SuppressWarnnings:用于通知java编译器禁止特定的编译警告。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面我们依次看看三个内置标准注解的作用和使用场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们最熟悉的应该是：@Override, 它的定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Indicates that a method declaration is intended to override a
 * method declaration in a supertype. If a method is annotated with
 * this annotation type compilers are required to generate an error
 * message unless at least one of the following conditions hold:
 * The method does override or implement a method declared in a
 * supertype.
 * The method has a signature that is override-equivalent to that of
 * any public method declared in Object.
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;  Peter von der Ah&amp;amp;eacute;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;  Joshua Bloch
 * @jls 9.6.1.4 @Override
 * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.5
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Override {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从注释，我们可以看出，@Override的作用是，提示编译器，使用了@Override注解的方法必须override父类或者java.lang.Object中的一个同名方法。我们看到@Override的定义中使用到了 @Target, @Retention，它们就是所谓的“&lt;strong&gt;元注解&lt;/strong&gt;”——就是定义注解的注解。我们看下&lt;strong&gt;@Retention&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Indicates how long annotations with the annotated type are to
 * be retained.  If no Retention annotation is present on
 * an annotation type declaration, the retention policy defaults to
 * RetentionPolicy.CLASS.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Retention {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns the retention policy.
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the retention policy
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    RetentionPolicy value();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;@Retention用于提示注解被保留多长时间（简单点说就是生命周期），有三种取值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; RetentionPolicy {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Annotations are to be discarded by the compiler.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    SOURCE,
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    CLASS,
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; java.lang.reflect.AnnotatedElement
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    RUNTIME
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;RetentionPolicy.SOURCE 保留在源码级别，被编译器抛弃(@Override就是此类)； RetentionPolicy.CLASS被编译器保留在编译后的类文件级别，但是被虚拟机丢弃；&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;RetentionPolicy.RUNTIME保留至运行时，可以被反射读取。&lt;br/&gt;再看 &lt;strong&gt;@Target&lt;/strong&gt;:&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; java.lang.annotation;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Indicates the contexts in which an annotation type is applicable. The
 * declaration contexts and type contexts in which an annotation type may be
 * applicable are specified in JLS 9.6.4.1, and denoted in source code by enum
 * constants of java.lang.annotation.ElementType
 * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.5
 * @jls 9.6.4.1 @Target
 * @jls 9.7.4 Where Annotations May Appear
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Target {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns an array of the kinds of elements an annotation type
     * can be applied to.
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; an array of the kinds of elements an annotation type
     * can be applied to
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ElementType[] value();
}
复制代码
 @Target用于提示该注解使用的地方，取值有：

复制代码
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; ElementType {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Class, interface (including annotation type), or enum declaration &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    TYPE,
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Field declaration (includes enum constants) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    FIELD,
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Method declaration &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    METHOD,
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Formal parameter declaration &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    PARAMETER,
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Constructor declaration &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    CONSTRUCTOR,
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Local variable declaration &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    LOCAL_VARIABLE,
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Annotation type declaration &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ANNOTATION_TYPE,
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Package declaration &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    PACKAGE,
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Type parameter declaration
     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.8
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    TYPE_PARAMETER,
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Use of a type
     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.8
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    TYPE_USE
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;分别表示该注解可以被使用的地方：1)类,接口，注解，enum; 2)属性域；3）方法；4）参数；5）构造函数；6）局部变量；7）注解类型；8）包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Override {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;表示 @Override 只能使用在方法上，保留在源码级别，被编译器处理，然后抛弃掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;@Override 是一个标记注解类型，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种Annotation在一个没有覆盖父类方法的方法时，java编译器将以一个编译错误来警示。这个annotaton常常在我们试图覆盖父类方法而又写错了方法名时发挥威力。使用方法极其简单：在使用此annotation时只要在被修饰的方法前面加上@Override即可。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;@Deprecated，标记已过时：同 样Deprecated也是一个标记注解。当一个类型或者类型成员使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。而且这种修饰具有一定的 “延续性”：&lt;/strong&gt;如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为 @Deprecated，但编译器仍然要报警。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;@SuppressWarnnings，抑制编译器警告：&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@SuppressWarnings 被用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告。在java5.0，sun提供的javac编译器为我们提供了-Xlint选项来使编译器对合法的程序代码提出警告，此种警告从某种程度上代表了程序错误。例如当我们使用一个generic collection类而又没有提供它的类型时，编译器将提示出&quot;unchecked warning&quot;的警告。通常当这种情况发生时，我们就需要查找引起警告的代码。如果它真的表示错误，我们就需要纠正它。例如如果警告信息表明我们代码中的switch语句没有覆盖所有可能的case，那么我们就应增加一个默认的case来避免这种警告。&lt;br/&gt;有时我们无法避免这种警告，例如，我们使用必须和非generic的旧代码交互的generic collection类时，我们不能避免这个unchecked warning。此时@SuppressWarning就要派上用场了，在调用的方法前增加@SuppressWarnings修饰，告诉编译器停止对此方法的警告。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;@SuppressWarning不是一个标记注解。它有一个类型为String[]的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对@SuppressWarings有效，同时编译器忽略掉无法识别的警告名。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;annotation语法允许在annotation名后跟括号，括号中是使用逗号分割的name=value对用于为annotation的成员赋值。实例如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.javaenhance;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FruitService {
    @SuppressWarnings(value &lt;/span&gt;= { &quot;rawtypes&quot;, &quot;unchecked&quot;&lt;span&gt; })
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getFruitList() {
        List&lt;/span&gt;&amp;lt;String&amp;gt; fruitList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fruitList;
    }

    @SuppressWarnings( { &lt;/span&gt;&quot;rawtypes&quot;, &quot;unchecked&quot;&lt;span&gt; })
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getFruit() {
        List&lt;/span&gt;&amp;lt;String&amp;gt; fruitList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fruitList;
    }

    @SuppressWarnings(&lt;/span&gt;&quot;unused&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;String&amp;gt; strList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在这个例子中SuppressWarnings annotation类型只定义了一个单一的成员，所以只有一个简单的value={...}作为name=value对。又由于成员值是一个数组，故使用大括号来声明数组值。&lt;strong&gt;注意：我们可以在下面的情况中缩写annotation：当annotation只有单一成员，并成员命名为&quot;value=&quot;。这时可以省去&quot;value=&quot;。比如将上面方法getFruit()的SuppressWarnings annotation就是缩写的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SuppressWarnings注解的常见参数值的简单说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1. deprecation：使用了不赞成使用的类或方法时的警告；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　2. unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　3. fallthrough：当switch程序块直接通往下一种情况而没有 Break 时的警告;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　4. path：在类路径、源文件路径等中有不存在的路径时的警告; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　5. serial：当在可序列化的类上缺少serialVersionUID定义时的警告; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　6. finally：任何finally子句不能正常完成时的警告; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　7. all：关于以上所有情况的警告。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.元注解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;元注解的作用就是负责注解其他注解（注解的注解）。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它annotation类型作说明。&lt;/strong&gt;Java5.0定义的元注解：&lt;strong&gt;@Target,@Retention,@Documented,@Inherited&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;@Target：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;取值(ElementType)有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.CONSTRUCTOR：用于描述构造器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.FIELD：用于描述域&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.LOCAL_VARIABLE：用于描述局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.METHOD：用于描述方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.PACKAGE：用于描述包&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6.PARAMETER：用于描述参数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7.TYPE：用于描述类、接口(包括注解类型) 或enum声明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;@Retention：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;@Retention&lt;/strong&gt;定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;取值（RetentionPoicy）有：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.SOURCE：在源文件中有效（即源文件保留）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.CLASS：在class文件中有效（即class保留）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.RUNTIME：在运行时有效（即运行时保留）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;@Documented:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;@&lt;/strong&gt;&lt;/strong&gt;Documented用于描述其它的annotation类型应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。简单一点说：表示注解是否能被 javadoc 处理并保留在文档中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;@Inherited：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。&lt;strong&gt;如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：@Inherited annotation类型会被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.自定义注解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本小节也是最重要的，我们通过会自己定义注解用于去为源程序打上标签，比如toString 方法我们想要过滤掉某些敏感信息不打印，那么我们可以加上注解然后识别到这个注解的信息，我们就不去打印这个信息等等用途。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口（单继承特性）。&lt;strong&gt;@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定义注解格式：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　public @interface 注解名 {定义体}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注解参数的可支持数据类型：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1. 所有基本数据类型（int,float,boolean,byte,double,char,long,short)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　2. String类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　3. Class类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　4. enum类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　5. Annotation类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　6. 以上所有类型的数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Annotation类型里面的参数该怎么设定：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　第一, &lt;strong&gt;只能用public或默认(default)这两个访问权修饰。&lt;/strong&gt;例如，String value();这里把方法设为defaul默认类型；　 　&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　第二, 参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String, Enum, Class, annotations等数据类型，以及这一些类型的数组。例如String value();这里的参数成员就为String；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　第三, &lt;strong&gt;如果只有一个参数成员，最好把参数名称设为&quot;value&quot;，后加小括号。&lt;/strong&gt;例如下面的例子FruitName注解就只有一个参数成员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单的自定义注解和使用注解实例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.javaenhance;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FruitName 
{
    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.javaenhance;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FruitColor
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Color
    {
        BULE,RED,GREEN;
    }
    
    Color fruitColor() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; Color.BULE;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.javaenhance;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

@Target(ElementType.FIELD)  
@Retention(RetentionPolicy.RUNTIME)  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FruitProvider
{
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
     * 供应商编号 
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt; 
     &lt;span&gt;*/&lt;/span&gt;  
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id() &lt;span&gt;default&lt;/span&gt; -1&lt;span&gt;;  
      
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
     * 供应商名称 
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt; 
     &lt;span&gt;*/&lt;/span&gt;  
    &lt;span&gt;public&lt;/span&gt; String name() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;  
      
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
     * 供应商地址 
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt; 
     &lt;span&gt;*/&lt;/span&gt;  
    &lt;span&gt;public&lt;/span&gt; String address() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.注解元素的默认值：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此，使用空字符串或0作为默认值是一种常用的做法。&lt;/strong&gt;这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，以表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.注解用处：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义了注解，并在需要的时候给相关类，类属性加上注解信息，如果没有响应的注解信息处理流程，注解可以说是没有实用价值。如何让注解真真的发挥作用，主要就在于注解处理方法，下一步我们将学习注解信息的获取和处理！&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员快速的构造自定义注解处理器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.&lt;strong&gt;注解处理器类库(java.lang.reflect.AnnotatedElement)：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Class：类定义    AccessibleObject：访问控制   Constructor：构造器定义　　Field：类的成员变量定义&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　Method：类的方法定义&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　Package：类的包定义&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201710/401339-20171017225942802-437523743.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;java.lang.reflect 包下主要包含一些实现反射功能的工具类，实际上，java.lang.reflect 包所有提供的反射API扩充了读取运行时Annotation信息的能力。当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201710/401339-20171017230129974-1356891868.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;案例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.javaenhance;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FruitInfoUtil 
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getFruitInfo(Class&amp;lt;?&amp;gt;&lt;span&gt; clazz) {
        String strFruitName &lt;/span&gt;= &quot; 水果名称：&quot;&lt;span&gt;;
        String strFruitColor &lt;/span&gt;= &quot; 水果颜色：&quot;&lt;span&gt;;
        String strFruitProvicer &lt;/span&gt;= &quot;供应商信息：&quot;&lt;span&gt;;
        Field[] fileds &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Field field : fileds) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (field.isAnnotationPresent(FruitName.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                FruitName fruitName &lt;/span&gt;=&lt;span&gt; (FruitName) field
                        .getAnnotation(FruitName.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                strFruitName &lt;/span&gt;= strFruitName + fruitName.value(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到注解的参数值&lt;/span&gt;
&lt;span&gt;                System.out.println(strFruitName);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (field.isAnnotationPresent(FruitColor.&lt;span&gt;class&lt;/span&gt;)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取FruitColor注解&lt;/span&gt;
                FruitColor fruitColor =&lt;span&gt; (FruitColor) field
                        .getAnnotation(FruitColor.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                strFruitColor &lt;/span&gt;=&lt;span&gt; strFruitColor
                        &lt;/span&gt;+&lt;span&gt; fruitColor.fruitColor().toString();
                System.out.println(strFruitColor);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (field.isAnnotationPresent(FruitProvider.&lt;span&gt;class&lt;/span&gt;)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取FruitProvider注解&lt;/span&gt;
                FruitProvider fruitProvider =&lt;span&gt; (FruitProvider) field
                        .getAnnotation(FruitProvider.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                strFruitProvicer &lt;/span&gt;= &quot; 供应商编号：&quot; + fruitProvider.id() + &quot; 供应商名称：&quot;
                        + fruitProvider.name() + &quot; 供应商地址：&quot;
                        +&lt;span&gt; fruitProvider.address();
                System.out.println(strFruitProvicer);
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、为什么使用注解？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 在JAVA应用中，我们常遇到一些需要使用模版代码。例如，为了编写一个JAX-RPC web service，我们必须提供一对接口和实现作为模版代码。如果使用annotation对远程访问的方法代码进行修饰的话，这个模版就能够使用工具自动生成。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;另外，一些API需要使用与程序代码同时维护的附属文件。例如，JavaBeans需要一个BeanInfo Class与一个Bean同时使用/维护，而EJB则同样需要一个部署描述符。此时在程序中使用annotation来维护这些附属文件的信息将十分便利而且减少了错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、注解的工作方式和使用方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在5.0版之前的Java平台已经具有了一些ad hocannotation(即时注解)机制。比如，使用transient修饰符来标识一个成员变量在序列化子系统中应被忽略。而@deprecated这个javadoc tag也是一个ad hocannotation用来说明一个方法已过时。从Java5.0版发布以来，&lt;strong&gt;5.0平台提供了一个正式的annotation功能：允许开发者定义、使用自己的annoatation类型。此功能由一个定义annotation类型的语法和一个描述annotation声明的语法，读取annotaion的API，一个使用annotation修饰的class文件，一个annotation处理工具（apt）组成。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;annotation并不直接影响代码语义，但是它能够工作的方式被看作类似程序的工具或者类库，它会反过来对正在运行的程序语义有所影响。annotation可以从源文件、class文件或者以在运行时反射的多种方式被读取。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当然annotation在某种程度上使javadoc tag更加完整。一般情况下，如果这个标记对java文档产生影响或者用于生成java文档的话，它应该作为一个javadoc tag；否则将作为一个annotation。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Annotation使用方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、类型声明方式：&lt;br/&gt;　　通常，应用程序并不是必须定义annotation类型，但是定义annotation类型并非难事。Annotation类型声明于一般的接口声明极为类似，区别只在于它在interface关键字前面使用“@”符号。&lt;br/&gt;　　annotation类型的每个方法声明定义了一个annotation类型成员，但方法声明不必有参数或者异常声明；方法返回值的类型被限制在以下的范围：primitives、String、Class、enums、annotation和前面类型的数组；方法可以有默认值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RequestForEnhancement {  
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;    id();  
    String synopsis();  
    String engineer() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;[unassigned]&quot;&lt;span&gt;;   
    String date();    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;[unimplemented]&quot;&lt;span&gt;;   
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2、annotation使用时候声明方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;annotation是一种修饰符，能够如其它修饰符（如public、static、final）一般使用。习惯用法是annotaions用在其它的修饰符前面。&lt;strong&gt;annotations由“@+annotation类型+带有括号的成员-值列表”组成。这些成员的值必须是编译时常量（即在运行时不变）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@RequestForEnhancement( id= 2868724, synopsis = &quot;Enable time-travel&quot;, engineer = &quot;Mr. Peabody&quot;,  date     = &quot;4/1/3007&quot;&lt;span&gt; )  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; travelThroughTime(Date destination) 
{
    ... 

} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当声明一个没有成员的annotation类型声明时，可使用以下方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
 * Indicates that the specification of the annotated API element 
 * is preliminary and subject to change. 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; Preliminary { }  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;如果在annotations中只有唯一一个成员，则该成员应命名为value：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Copyright {  
    String value();  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更为方便的是对于具有唯一成员且成员名为value的annotation（如上文），在其使用时可以忽略掉成员名和赋值号（=）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Copyright(&quot;2002 Yoyodyne Propulsion Systems&quot;&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OscillationOverthruster { ... }  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是一个复杂的Annotataion类型声明，其成员是Annotation类型的数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.lang.annotation.*&lt;span&gt;;  
          
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
 * Reviews annotation类型只有一个成员， 
 * 由Review annotation组成的数组 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
@Retention(RetentionPolicy.RUNTIME)  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Reviews {  
    Review[] value();  
}  
  
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
 * Review annotation类型有3个成员：  
 * 枚举类型成员grade 
 * 表示Review名称的字符串类型成员Reviewer 
 * 具有默认值的字符串类型成员Comment。 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Review {  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内嵌的枚举类型  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Grade { EXCELLENT, SATISFACTORY, UNSATISFACTORY };  
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面的方法定义了annotation的成员  &lt;/span&gt;
&lt;span&gt;    Grade grade();                  
    String reviewer();            
    String comment() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;    
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Reviews annotation类型只有一个成员，但是这个成员的类型是复杂的：由Review annotation组成的数组。Review annotation类型有3个成员：枚举类型成员grade、表示Review名称的字符串类型成员Reviewer、具有默认值的字符串类型成员Comment。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Annotation类型的成员不能是generic。只有返回值类型是Class的方法可以在annotation类型中使用generic，因为此方法能够用类转换将各种类型转换为Class。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，我们来定义一个annotation方法用于罗列出类运行中所有的unchecked异常（这种情况不一定是错误）。这个annotation类型将一个数组作为了唯一的成员。数组中的每个元素都是异常类。为了加强对未检查的异常（此类异常都是在运行时抛出）进行报告，我们可以在代码中对异常的类型进行限制：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、注解A&lt;strong&gt;nnotation实例分析&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;结合上面所讲的，我们在这里建立一个简单的基于annotation测试框架。首先我们需要一个annotation类型来表示某个方法是一个应该被测试工具运行的测试方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.lang.annotation.*&lt;span&gt;;  
  
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
 * Indicates that the annotated method is a test method. 
 * This annotation should be used only on parameterless static methods. 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
@Retention(RetentionPolicy.RUNTIME)  
@Target(ElementType.METHOD)  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; Test { }  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;值得注意的是annotaion类型声明是可以标注自己的，这样的annotation被称为“meta-annotations”。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在上面的代码中，@Retention(RetentionPolicy.RUNTIME)这个meta-annotation表示了此类型的annotation将被虚拟机保留使其能够在运行时通过反射被读取。而@Target(ElementType.METHOD)表示此类型的annotation只能用于修饰方法声明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是一个简单的程序，其中部分方法被上面的annotation所标注：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo {  
    
@Test 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; m1() { }  
      
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; m2() { }  
      
    @Test 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; m3() {  
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;Boom&quot;&lt;span&gt;);  
    }  
      
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; m4() { }  
      
    @Test
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; m5() { }  
      
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; m6() { }  
      
    @Test 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; m7() {  
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;Crash&quot;&lt;span&gt;);  
    }  
      
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; m8() { }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.lang.reflect.*&lt;span&gt;;  
  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RunTests {  
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {  
      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; passed = 0, failed = 0&lt;span&gt;;  
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Method m : Class.forName(args[0&lt;span&gt;]).getMethods()) {  
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (m.isAnnotationPresent(Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {  
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {  
               m.invoke(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);  
               passed&lt;/span&gt;++&lt;span&gt;;  
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {  
               System.out.printf(&lt;/span&gt;&quot;Test %s failed: %s %n&quot;&lt;span&gt;, m, ex.getCause());  
               failed&lt;/span&gt;++&lt;span&gt;;  
            }  
         }  
      }  
      System.out.printf(&lt;/span&gt;&quot;Passed: %d, Failed %d%n&quot;&lt;span&gt;, passed, failed);  
   }  
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个程序从命令行参数中取出类名，并且遍历此类的所有方法，尝试调用其中被上面的测试annotation类型标注过的方法。在此过程中为了找出哪些方法被annotation类型标注过，需要使用反射的方式执行此查询。如果在调用方法时抛出异常，此方法被认为已经失败，并打印一个失败报告。最后，打印运行通过/失败的方法数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注解在很多框架、类库中有广泛的应用。如JUnit测试框架, Spring, Hibernate, EJB等等。这也是开发人员所常常用到的一种方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的介绍说明了annotation的使用方法、定义方式、分类。初学者可以通过以上的说明制作简单的annotation程序，但是对于一些高级的annotation应用（例如使用自定义annotation生成javabean映射xml文件）还需要进一步的研究和探讨。同时，&lt;strong&gt;annotation运行存在两种方式：运行时、编译时。上文中讨论的都是在运行时的annotation应用，但在编译时的annotation应用还没有涉及，因为编译时的annotation要使用annotation processing tool(APT)&lt;/strong&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;annotation本身使用时十分简便。例如一个本地变量可以被一个以NonNull命名的annotation类型所标注，来作为对这个本地变量不能被赋予null值的断言。而我们可以编写与之配套的一个annotation代码分析工具，使用它来对具有前面变量的代码进行解析，并且尝试验证这个断言。当然这些代码并不必自己编写。在JDK安装后，在JDK/bin目录中可以找到名为“apt”的工具，它提供了处理annotation的框架：它启动后扫描源代码中的annotation，并调用我们定义好的annotation处理器完成我们所要完成的工作（比如验证前面例子中的断言）。说到这里，annotation的强大功能似乎可以替代XDoclet这类的工具了，随着我们的深入，大家会更加坚信这一点。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;注：详细描述请参看JSR 250规范 &lt;a href=&quot;http://www.jcp.org/aboutJava/communityprocess/pfd/jsr250/&quot; target=&quot;_blank&quot;&gt;http://www.jcp.org/aboutJava/communityprocess/pfd/jsr250/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;七、总结&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用网上的一张图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140623132746640&quot; alt=&quot;注解总结&quot; width=&quot;1418&quot; height=&quot;1339&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://blog.csdn.net/zhoudaxia/article/details/33456147&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://blog.csdn.net/zhoudaxia/article/details/33731583&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Oct 2017 15:36:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/7679315.html</dc:identifier>
</item>
<item>
<title>MyServer - 沉迷学习，日渐消瘦</title>
<link>http://www.cnblogs.com/lyrand/p/7684669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyrand/p/7684669.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1113952/201710/1113952-20171017232431881-1964387056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; //一、设置一个8089端口的本地IP服务器&lt;br/&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; myserver;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ServerSocket;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyServer {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyServer() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             ServerSocket socket = &lt;span&gt;new&lt;/span&gt; ServerSocket(8089&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 Socket s =&lt;span&gt; socket.accept();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketThread(s);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyServer();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; //二、多线程监听客户端连接&lt;br/&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; myserver;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStream;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SocketThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Socket socket;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SocketThread(Socket socket) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.socket =&lt;span&gt; socket;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt;         Thread th = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        th.start();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         InputStream in = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         OutputStream out = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             in = socket.getInputStream();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取文件读取流&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             out = socket.getOutputStream();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取文件写入流&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             Response response = &lt;span&gt;new&lt;/span&gt; Response(out);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相应数据到浏览器&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             Request request = &lt;span&gt;new&lt;/span&gt; Request(in);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从网页获取数据&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             System.out.println(&quot;********&quot;+&lt;span&gt;request);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             String url = request.getUrl();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取URL路径
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;response.sendMessage(&quot;hello&quot;);&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            response.sendFile(url);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            out.flush();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                out.close();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                in.close();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                socket.close();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }    
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; //三、请求相应处理&lt;br/&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; myserver;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileNotFoundException;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStream;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Response {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; OutputStream out;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Response(OutputStream out) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.out =&lt;span&gt; out;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送消息到浏览器&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendMessage(String msg) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            out.write(msg.getBytes());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendFile(String filePath) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         File f = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(filePath);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (f.exists() == &lt;span&gt;false&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断文件是否存在&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         InputStream in = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             in = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(filePath);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] by = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; len = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; ((len=in.read(by)) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 out.write(by, 0, len);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取1024字节并写入到浏览器&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            in.close();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//接受客户端请求&lt;br/&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; myserver;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Request {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String url;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装表单数据&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,String&amp;gt; paramMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String,String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Request(InputStream in) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] by = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            in.read(by);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             String str = &lt;span&gt;new&lt;/span&gt; String(by).trim();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去掉两边空格&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            System.out.println(str);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (str.startsWith(&quot;GET&quot;)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GET开头的流数据&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getGet(str);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;POST开头的流数据&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getPOST(str);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        } 
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getPOST(String str) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取POST的URL和表单数据&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         String[] s = str.split(&quot;\\s+&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按空格割分字符串为字符串数组&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.url = s[1].substring(1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表单的POST提交&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         getMap(s[s.length-1]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取表单数据&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getGet(String str) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取GET的URL和表单数据&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         String[] s = str.split(&quot;\\s+&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按空格割分字符串为字符串数组&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (s[1].indexOf(&quot;?&quot;) == -1&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.url = s[1].substring(1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本的GET提交&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             String s1 = s[1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表单的GET提交&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.url = s1.split(&quot;[?]&quot;)[0].substring(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.getMap(s1.split(&quot;[?]&quot;)[1]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取表单数据&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;GET /url    POST|GET /url?userName=&quot;&quot;&amp;amp;pwd=&quot;&quot;&amp;amp;age=&quot;&quot;&amp;amp;sex=&quot;&quot;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,String&amp;gt; getMap(String string) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取表单数据&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         String[] s = string.split(&quot;[&amp;amp;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String str : s) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.paramMap.put(str.split(&quot;[=]&quot;)[0], str.split(&quot;[=]&quot;)[1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.paramMap;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUrl() {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.url;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Request [url=&quot; + url + &quot;, paramMap=&quot; + paramMap + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; //模拟GET，POST请求表单提交的登录界面&lt;br/&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;login&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;1.jpg&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;1.jpg&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;智商不够，努力来凑&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;PUT&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;userName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;pwd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;登录&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相应的数据流信息如下：&lt;/p&gt;
&lt;p&gt;GET /login.html HTTP/1.1&lt;br/&gt;Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*&lt;br/&gt;Accept-Language: zh-CN&lt;br/&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64; Trident/4.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C)&lt;br/&gt;UA-CPU: AMD64&lt;br/&gt;Accept-Encoding: gzip, deflate&lt;br/&gt;Host: localhost:8089&lt;br/&gt;Connection: Keep-Alive&lt;br/&gt;********Request [url=login.html, paramMap={}]&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;GET /1.jpg HTTP/1.1&lt;br/&gt;Accept: */*&lt;br/&gt;Referer: http://localhost:8089/login.html&lt;br/&gt;Accept-Language: zh-CN&lt;br/&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64; Trident/4.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C)&lt;br/&gt;UA-CPU: AMD64&lt;br/&gt;Accept-Encoding: gzip, deflate&lt;br/&gt;Host: localhost:8089&lt;br/&gt;Connection: Keep-Alive&lt;br/&gt;********Request [url=1.jpg, paramMap={}]&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;GET /login?userName=123&amp;amp;pwd=123 HTTP/1.1&lt;br/&gt;Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*&lt;br/&gt;Referer: http://localhost:8089/login.html&lt;br/&gt;Accept-Language: zh-CN&lt;br/&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64; Trident/4.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C)&lt;br/&gt;UA-CPU: AMD64&lt;br/&gt;Accept-Encoding: gzip, deflate&lt;br/&gt;Host: localhost:8089&lt;br/&gt;Connection: Keep-Alive&lt;br/&gt;********Request [url=login, paramMap={userName=123, pwd=123}]&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;GET /login?userName=123&amp;amp;pwd=123 HTTP/1.1&lt;br/&gt;Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*&lt;br/&gt;Accept-Language: zh-CN&lt;br/&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64; Trident/4.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C)&lt;br/&gt;UA-CPU: AMD64&lt;br/&gt;Accept-Encoding: gzip, deflate&lt;br/&gt;Host: localhost:8089&lt;br/&gt;Connection: Keep-Alive&lt;br/&gt;********Request [url=login, paramMap={userName=123, pwd=123}]&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;GET /a.txt HTTP/1.1&lt;br/&gt;Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*&lt;br/&gt;Accept-Language: zh-CN&lt;br/&gt;Cache-Control: no-cache&lt;br/&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64; Trident/4.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C)&lt;br/&gt;UA-CPU: AMD64&lt;br/&gt;Accept-Encoding: gzip, deflate&lt;br/&gt;Host: localhost:8089&lt;br/&gt;Connection: Keep-Alive&lt;br/&gt;********Request [url=a.txt, paramMap={}]&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;GET /1.jpg HTTP/1.1&lt;br/&gt;Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*&lt;br/&gt;Accept-Language: zh-CN&lt;br/&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64; Trident/4.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C)&lt;br/&gt;UA-CPU: AMD64&lt;br/&gt;Accept-Encoding: gzip, deflate&lt;br/&gt;Host: localhost:8089&lt;br/&gt;Connection: Keep-Alive&lt;br/&gt;********Request [url=1.jpg, paramMap={}]&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;GET / HTTP/1.1&lt;br/&gt;Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*&lt;br/&gt;Accept-Language: zh-CN&lt;br/&gt;Cache-Control: no-cache&lt;br/&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64; Trident/4.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C)&lt;br/&gt;UA-CPU: AMD64&lt;br/&gt;Accept-Encoding: gzip, deflate&lt;br/&gt;Host: localhost:8089&lt;br/&gt;Connection: Keep-Alive&lt;br/&gt;********Request [url=, paramMap={}]&lt;/p&gt;

&lt;p&gt;总结：以上是用代码模拟实现的一个tomcat。&lt;/p&gt;

</description>
<pubDate>Tue, 17 Oct 2017 15:35:00 +0000</pubDate>
<dc:creator>沉迷学习，日渐消瘦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyrand/p/7684669.html</dc:identifier>
</item>
<item>
<title>JAVA基础-反射 - 阿拉巴洞</title>
<link>http://www.cnblogs.com/0813lichenyu/p/7684573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0813lichenyu/p/7684573.html</guid>
<description>&lt;p&gt;一、反射的介绍&lt;/p&gt;
&lt;p&gt;    JAVA反射机制是在运行状态中,能够获取任意一个类的所有属性和方法，对于任意一个对象,都能够调用它的任意&lt;br/&gt;一个方法。这种动态获取的以及动态调用对象的方法的功能称为java语言的反射机制。JAVA编译时是先获取到类，然&lt;br/&gt;后才是类里边的属性和方法，而反射则和编译相反，他是先获取类里边的对象和方法然后在告诉他是哪个类里的。简单&lt;br/&gt;来说, 就可以把.class文件比做动物的尸体, 而反射技术就是对尸体的一种解剖.通过反射技术, 我们可以拿到该字节码&lt;br/&gt;文件中所有的东西, 例如成员变量, 成员方法, 构造方法, 而且还包括私有。想要反射首先要获取到程序的“尸体”也就&lt;br/&gt;是.class文件。&lt;/p&gt;
&lt;p&gt;二、字节码文件的获取 &lt;/p&gt;
&lt;p&gt;    获取字节码对象有3种方式：&lt;br/&gt;1、类名.class - 这是一个静态的属性, 只要知道类名, 就可以获取&lt;br/&gt;2、对象名.getClass() - Object类里的getClass()方法，对象已经存在的情况下, 可以使用这种方式&lt;br/&gt;3、Claire.forName(&quot;类的全类名(包名+类名)&quot;) - 通过Class类里的静态方法forName来获取节码对象&lt;br/&gt;  举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Object的getClass()方法获取，必须要有对象&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; Student s = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; Class clazz =&lt;span&gt; s.getClass();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过类名获取字节码对象&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; Class clazz2 = Student.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Class类里的静态方法forName来获取节码对象&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; Class clazz3 = Class.forName(&quot;com.fanshe.Student&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; System.out.println(clazz ==&lt;span&gt; clazz2);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; System.out.println(clazz ==&lt;span&gt; clazz3);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;System.out.println(clazz);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    字节码文件其实就是描述.class文件的对象。&lt;/p&gt;
&lt;p&gt;三、对构造方法的操作&lt;/p&gt;
&lt;p&gt;    *通过反射获取公有构造方法的两种方式：&lt;br/&gt;1、返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法，可以获取无参构造也可以&lt;br/&gt;根据传入的类型来匹配对应的构造方法：getConstructor(Class&amp;lt;?&amp;gt;... parameterTypes)&lt;br/&gt;2、返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法：&lt;br/&gt;                                                               getConstructors()&lt;br/&gt;3、创建此 Class 对象所表示的类的一个新实例：&lt;br/&gt;                                                               newInstance()&lt;/p&gt;&lt;p&gt;    *暴力获取（可以获取全部权限的）：&lt;br/&gt;1、返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法：&lt;br/&gt;                                 getDeclaredConstructor(Class&amp;lt;?&amp;gt;... parameterTypes)&lt;br/&gt;2、返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法：&lt;br/&gt;                                 getDeclaredConstructors()&lt;br/&gt;  举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ReflectiveOperationException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Class.forName()获取字节码对象&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; Class&amp;lt;?&amp;gt; forName = Class.forName(&quot;com.fanshe.Student&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取所有公共构造方法&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; Constructor&amp;lt;?&amp;gt;[] constructors =&lt;span&gt; forName.getConstructors();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (Constructor&amp;lt;?&amp;gt;&lt;span&gt; constructor : constructors) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印结果&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;System.out.println(constructor);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; System.out.println(&quot;--------------------------------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暴力获取，可以获取所有的构造方法（包括私有的）&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; Constructor&amp;lt;?&amp;gt; c1 =&lt;span&gt; forName.getDeclaredConstructor();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; c1.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;System.out.println(c1);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取有参构造&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; Constructor&amp;lt;?&amp;gt; c2 = forName.getConstructor(String.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;System.out.println(c2);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、对成员变量和方法的操作&lt;/p&gt;
&lt;p&gt;    *公有成员变量获取方法：&lt;br/&gt;1、返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段：&lt;br/&gt;                          getField(String name) - 参数为要返回的变量名&lt;br/&gt;2、返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段：&lt;br/&gt;                          getFields() - 参数为要返回的变量名&lt;/p&gt;&lt;p&gt;    *任意成员变量获取方法：&lt;br/&gt;1、返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段：&lt;br/&gt;                          getDeclaredField(String name) - 参数为要返回的变量名&lt;br/&gt;2、返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段：&lt;br/&gt;                         getDeclaredFields() - 参数为要返回的变量名&lt;br/&gt; &lt;br/&gt;    *获取公有的方法：&lt;br/&gt;1、返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法：&lt;br/&gt;                         getMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes) - name 方法名、parameterTypes 参数列表&lt;br/&gt;2、返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口&lt;br/&gt;声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法：&lt;br/&gt;                         getMethods()&lt;/p&gt;&lt;p&gt;    *暴力获取方法：&lt;br/&gt;1、 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法：&lt;br/&gt;                         getDeclaredMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes) - name 方法名、parameterTypes&lt;br/&gt;参数列表&lt;br/&gt;2、返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、&lt;br/&gt;默认（包）访问和私有方法，但不包括继承的方法：&lt;br/&gt;                        getDeclaredMethods()&lt;br/&gt;    需要注意的是想要获取私有的变量或者方法时应使用AccessibleObject类里的setAccessible(boolean flag)方法 - 参数&lt;br/&gt;值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问&lt;br/&gt;检查。&lt;br/&gt;    Constructor, Field, Method都是AccessibleObject的子类所以可以直接使用父类的setAccessible(boolean flag)方法。&lt;/p&gt;&lt;p&gt;    **通过反射获得变量的流程：&lt;br/&gt;1. 通过反射获取该类的字节码对象&lt;br/&gt;2. 创建该类对象&lt;br/&gt;3. 获取该类中需要操作的字段(成员变量) &lt;br/&gt;4. 通过字段对象中的方法修改属性值&lt;/p&gt;
&lt;p&gt;    **通过反射执行方法的流程&lt;br/&gt;1. 通过反射获取该类的字节码对象&lt;br/&gt;2. 创建该类对象&lt;br/&gt;3. 调用getMethod方法获取Method对象, 方法形参接受方法的名字&lt;br/&gt;4. 调用Method方法中的invoke()将方法运行&lt;br/&gt;  举例：&lt;br/&gt;*被反射的学生01类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student01 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student01() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Student01(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; name() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; System.out.println(&quot;测试&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; mane1() {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; System.out.println(&quot;这是个萌萌哒私有的&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &quot;Student01 [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  *对学生01类进行反射&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ReflectiveOperationException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取字节码对象&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; Class&amp;lt;?&amp;gt; clazz = Class.forName(&quot;com.fanshe.Student01&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建该类的对象&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; Object stu =&lt;span&gt; clazz.newInstance();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; System.out.println(stu);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取学生类的name变量&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; Field f1 = clazz.getField(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;* set将指定对象变量上此 Field 对象表示的字段设置为指定的新值。
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;* 为stu对象里的name变量赋值
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; f1.set(stu, &quot;李四&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get()返回指定对象上此 Field 表示的字段的值。&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; Object name =&lt;span&gt; f1.get(stu);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暴力获取age字段&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; Field f2 = clazz.getDeclaredField(&quot;age&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;System.out.println(f2);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让jvm不检查权限&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; f2.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为其赋值&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; f2.set(stu, 24&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取stu对象的f2字段的值&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; Object age =&lt;span&gt; f2.get(stu);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;System.out.println(name);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;System.out.println(age);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 公有无参无返回值，name()&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; Method method = clazz.getMethod(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用Method类的invoke方法执行name方法&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;method.invoke(stu);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 公有代参无返回值,参数为String类型&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; Method m2 = clazz.getMethod(&quot;setName&quot;, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行stu对象的setName方法，传入参数&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; m2.invoke(stu, &quot;李晨宇&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 公有无参有返回值&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; Method m3 = clazz.getMethod(&quot;getName&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回值为invoke&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; Object invoke =&lt;span&gt; m3.invoke(stu);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;System.out.println(invoke);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; Method m4 = clazz.getDeclaredMethod(&quot;mane1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让jvm不检查权限&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; m4.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行stu对象的mane1方法&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;m4.invoke(stu);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    需要注意的是，反射无参构造时被反射的类一定要有无参构造方法，默认生成的也算。&lt;br/&gt;五、反射的应用&lt;/p&gt;
&lt;p&gt;    我们在开发的时候，由于要考虑到代码的重用性，就会用反射来处理一些问题。而JAVA的一些常用jar包和主流框架的配置&lt;br/&gt;都用到了反射的原理，学习反射有助于我们对源码的阅读和理解。BeanUtils工具类（Apache开发的便于操作JavaBeen的工具类）&lt;br/&gt;就用到了反射的方法。&lt;br/&gt;  *BeanUtils的部分实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyBeanUtils {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为是工具类，不需要实例化。所以私有构造方法&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; MyBeanUtils() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;* 给对象中的属性赋值 传入类的对象类型，和要修改的属性的值不确定所以用Object类型，属性名用String类型
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setProrerty(Object object, String name, Object values)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ReflectiveOperationException, SecurityException {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取传入对象的字节码文件&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; Class clazz =&lt;span&gt; object.getClass();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据传入的属性获取Field对象，因为不确定属性的权限，用的暴力反射&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; Field field =&lt;span&gt; clazz.getDeclaredField(name);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让jvm不检查权限&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; field.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为object对象里的name属性赋值&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;field.set(object, values);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取对象中的属性&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getProrerty(Object object, String name)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ReflectiveOperationException, SecurityException {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取传入对象的字节码文件&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; Class clazz =&lt;span&gt; object.getClass();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据传入的属性获取Field对象，因为不确定属性的权限，用的暴力反射&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; Field field =&lt;span&gt; clazz.getDeclaredField(name);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让jvm不检查权限&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; field.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取name属性的值&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; Object object2 =&lt;span&gt; field.get(object);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; System.out.println(object);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将值返回&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; object2.toString();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给对象中的属性赋值(通过Map的方式)，Map里key存的是属性名，value存的是要赋的值&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; populat(Object object, Map map) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ReflectiveOperationException, SecurityException {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取传入对象的字节码文件&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; Class clazz =&lt;span&gt; object.getClass();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回此集合中的key集合&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; Set keySet =&lt;span&gt; map.keySet();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历key&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object object2 : keySet) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得value值&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; Object value =&lt;span&gt; map.get(object2);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据传入的key(属性)获取Field对象，因为不确定属性的权限，用的暴力反射&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; Field field =&lt;span&gt; clazz.getDeclaredField(object2.toString());
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让jvm不检查权限&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; field.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 赋值&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;field.set(object, value);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchFieldException e) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出现异常，给出友好型提示&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; System.out.println(&quot;Mdzz,属性都记不住&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  *测试工具类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RuntimeException, ReflectiveOperationException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建学生01对象&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; Student01 s1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student01();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用MyBeanUtils工具类为学生01对象赋值&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; MyBeanUtils.setProrerty(s1, &quot;name&quot;, &quot;啦啦&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; MyBeanUtils.setProrerty(s1, &quot;age&quot;, 15&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用MyBeanUtils工具类为学生01对象取值&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; String name = MyBeanUtils.getProrerty(s1, &quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; String age = MyBeanUtils.getProrerty(s1, &quot;age&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印出来&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;System.out.println(name);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;System.out.println(age);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; System.out.println(&quot;------------------------------------ &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建HashMap作为数据源&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt; hashMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为HashMap赋值&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; hashMap.put(&quot;qqqqq&quot;, &quot;大大的&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 属性不存在会给出友好型提示&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; hashMap.put(&quot;name&quot;, &quot;大大的&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; hashMap.put(&quot;age&quot;, 110&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用MyBeanUtils工具类为学生01对象赋值&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;MyBeanUtils.populat(s1, hashMap);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;System.out.println(s1);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 17 Oct 2017 15:25:00 +0000</pubDate>
<dc:creator>阿拉巴洞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0813lichenyu/p/7684573.html</dc:identifier>
</item>
<item>
<title>爱剪辑初使用 - 卡卡真的很卡</title>
<link>http://www.cnblogs.com/orchidbaby/p/7684566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/orchidbaby/p/7684566.html</guid>
<description>&lt;p&gt;清晨时候做了个美梦，梦到了欢欢 ~ ~&lt;br/&gt;入住博客园第三天。 醒来时候发现微信好几条信息，一条是我姐让我写外国游记，一条是我堂哥问我要PPT模板，以及将一部BGM视频转高清。先是用狸窝将视频质量调高了点，但距离高清还差得远。于是想着将视频中出现的曲目，用网易云将MV下载下来，然后选择所要部分，剪切合并。由于没有剪辑的经验，所以抛弃Adobe的Pr选择了便捷上手的爱剪辑。道路是曲折的。以下是初设步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下载全部曲目MV&lt;/li&gt;
&lt;li&gt;各自剪裁&lt;/li&gt;
&lt;li&gt;各自去水印&lt;/li&gt;
&lt;li&gt;各自加歌曲信息&lt;/li&gt;
&lt;li&gt;设置转场动画&lt;/li&gt;
&lt;li&gt;合并各个片段&lt;/li&gt;
&lt;li&gt;片头片尾过渡&lt;/li&gt;
&lt;li&gt;剪掉自带的片头片尾&lt;/li&gt;
&lt;li&gt;导出视频&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;下载全部曲目MV：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;下载1080pMV要积分。&lt;/li&gt;
&lt;li&gt;有些曲目网易云没有资源。&lt;/li&gt;
&lt;li&gt;有些曲目没有MV&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;积分是什么？反正能下的都下了，确实画质很棒。找不到资源的，我是用西林街搜索，找到了The Dawn的原画MV。至于有些没MV的，就只能找类似的替代了，后面会提到。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;各自剪裁：&lt;/strong&gt;&lt;br/&gt;打开爱剪辑，可以了解大概用法，就是将几部视频拼凑输出，本身自带一分钟黑白幕布。双击添加MV，然后可以进行初步大概剪裁&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/CgRSCGg.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击播放进行预览，走到你想开始剪的地方，点击下面开始时间后面的圆形箭头按钮，就能标记。同理，结束点也一样。然后点击播放所选片段可预览，并通过前进后退按钮进行微调。剪错也没事，后面还可以编辑。勾上淡入淡出，不然承接会显得突兀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TAJKzyL.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各自去水印：&lt;/strong&gt;&lt;br/&gt;点击上方菜单栏的叠加素材，选择侧栏的去水印，添加水印区域，由于水印不是一直存在，所以选择第二个，可设置时间，第一个是一整段都覆盖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Np9xqhy.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各自加歌曲信息：&lt;/strong&gt;&lt;br/&gt;选择最上方菜单的字幕，然后在右侧播放视频，找到合适时间暂停，双击进行插入字幕，然后可以设置字幕的出现，持续，消失时间长度，调整位置，并设置效果参数。最上方的好莱坞特效只允许8个字，包括字母。不然会被截断。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/m3Cd0c0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置转场动画：&lt;/strong&gt;&lt;br/&gt;转场指的是后一部视频承接上一部视频，所以第一部设置不了转场。点击某一部视频，然后点击上方的转场特效。以及相关的效果参数，2-5秒内为佳。收起可以看全部分类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合并各个片段：&lt;/strong&gt;&lt;br/&gt;这步骤就不需要了，因为软件自带结构就是这样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;片头片尾过渡：&lt;/strong&gt;&lt;br/&gt;添加两端黑幕，各自剪裁5秒钟，分别拖到开头和结尾。同时设置转场及勾上淡入淡出。最好首尾视频（非黑幕）的开头结尾都取声音平缓微弱，作为过渡效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;剪掉自带的片头片尾：&lt;/strong&gt;&lt;br/&gt;这里我使用视频编辑专家，缺点是精确度不够高，但还凑合。其他软件没尝试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;导出视频：&lt;/strong&gt;&lt;br/&gt;不说。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;特殊操作&quot;&gt;特殊操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;给图片加动态：&lt;/strong&gt;&lt;br/&gt;有一首Victory是只有封面图的，所以给它加上动态。点击最上方菜单的画面风格，选择侧栏动景，选额效果，设置时间就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/vVvV5ps.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给音乐换MV：&lt;/strong&gt;&lt;br/&gt;两首歌是没有MV的，所以找了其他类似的MV，混剪进去。先将MV添加进去，然后使用音轨设置为“原片无音轨”，然后在最上方音频添加两首歌。根据MV截的长度进行适应，最好音频和mv长度一致。过长会与下一首歌重叠，过短就是部分MV无声音。然后设置音频的起止时间（对应各自MV的起止时间）。&lt;br/&gt;&lt;strong&gt;添加图片：&lt;/strong&gt;&lt;br/&gt;如果想像上面那样播放一张图片，只需先播放视频，在想插入位置暂停，然后点击菜单栏叠加素材，选择添加贴图，找到本地目标图片，添加进去，调整覆盖设置起止时间。如果想另开一段，则先添加一段视频，设置无声，直接用白色幕布，重复操作即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/hYFbI8u.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这是我最终作品的链接：&lt;a href=&quot;https://www.bilibili.com/video/av15484129/&quot; class=&quot;uri&quot; title=&quot;燃の殿堂级BGM合集&quot;&gt;https://www.bilibili.com/video/av15484129/&lt;/a&gt;&lt;br/&gt;已经上传到B站了，超清无广告。先给AB站点个赞，竟然连嗅探也屏蔽了，非常强调版权，以及对投稿者的尊重。包括整个网站的架构，界面，体验，运行机制都很人性化（除了升级VIP答题）。&lt;br/&gt;对于爱剪辑这个软件，应该说“麻雀虽小，五脏俱全”。自然是比不过pr,但是处理简单-中等的编辑还是游刃有余的。毕竟草榴（外网）上面的很多视频也是用爱剪辑加工的。（懂的人自然懂）而且由于社区资源的不断扩大，能够直接使用的轮子和特效也越来越丰富，闲暇之余玩一玩挺不错的。&lt;br/&gt;明天还会不会做梦？&lt;/p&gt;
</description>
<pubDate>Tue, 17 Oct 2017 15:23:00 +0000</pubDate>
<dc:creator>卡卡真的很卡</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/orchidbaby/p/7684566.html</dc:identifier>
</item>
</channel>
</rss>