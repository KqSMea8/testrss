<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET Core跨平台的奥秘[中篇]：复用之殇 - Artech</title>
<link>http://www.cnblogs.com/artech/p/how-to-cross-platform-02.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/how-to-cross-platform-02.html</guid>
<description>&lt;p&gt;在《&lt;a href=&quot;http://www.cnblogs.com/artech/p/how-to-cross-platform-01.html&quot;&gt;.NET Core跨平台的奥秘[上篇]：历史的枷锁&lt;/a&gt;》中我们谈到：由于.NET是建立在CLI这一标准的规范之上，所以它天生就具有了“跨平台”的基因。在微软发布了第一个针对桌面和服务器平台的.NET Framework之后，它开始 “乐此不疲” 地对这个完整版的.NET Framework进行不同范围和层次的 “阉割” ，进而造就了像Windows Phone、Windows Store、Silverlight和.NET Micro Framework的压缩版的.NET Framework。从这个意义上讲，Mono和它们并没有本质的区别，唯一不同的是Mono真正突破了Windows平台的藩篱。包括Mono在内的这些分支促成了.NET的繁荣，但我们都知道这仅仅是一种虚假的繁荣而已。虽然都是.NET Framework的子集，但是由于它们采用完全独立的运行时和基础类库，这使我们很难开发一个支持多种设备的“可移植（Portable）”应用，这些分支反而成为制约.NET发展的一道道枷锁。至于为什么“可移植（Portable）”.NET应用的开发如此繁琐呢？&lt;/p&gt;
&lt;p&gt;所谓由于目标框架的独立性，意味着不仅仅是作为虚拟机的Runtime是根据具体平台特性设计的，作为编程基础的&lt;span&gt;BCL&lt;/span&gt;也不能跨平台共享，它为开发者带来的一个最大的问题就是：很难编写能够在各个目标框架复用的代码。比较极端的场景就是：当我们需要为一个现有的桌面应用提供针对移动设备的支持时，我们不得不从头到尾开发一个全新的应用，现有的代码难以被新的应用所复用用。 “代码复用”是软件设计一项最为根本的目标，在不考虑跨平台的前提下，我们可以应用相应的设计模式和编程技巧来实现代码的重用，但是平台之间的差异导致了跨平台代码重用确实具有不小的困难。虽然作得不算非常的理想，但是微软在这方面确实做出了很多尝试，我们不妨先来聊聊目前我们都有哪些跨平台代码复用的解决方案。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、源代码复用&lt;br/&gt;    源文件共享&lt;br/&gt;    文件链接&lt;br/&gt;    共享项目&lt;br/&gt;二、程序集复用&lt;br/&gt;    程序集一致性&lt;br/&gt;    Retargetable程序集&lt;br/&gt;    类型的转移&lt;br/&gt;三、可移植类库（PCL）&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;对于包括Mono在内的各个.NET Framework平台的BCL来说，虽然在API定义层面上存在一些共同之处，但是由于它们定义在不同的程序集之中，所以在&lt;span&gt;PCL（Portal Class Library）&lt;/span&gt;推出之前，针对程序集的共享是不可能实现的，我们只能在源代码层面实现共享。源代码的共享通过在不同项目之间共享源文件的方式来实现，至于具体采用的方式，我们有三种不同的方案供你选择。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;源文件共享&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;对于一个能够多个针对不同目标框架的项目共享的源文件，定义其中的代码也有不少是针对具体某个目标框架的。对于这种代码，我们需要按照如下的方式进行编写，相应的项目以添加编译的方式选择与自身平台相匹配的代码编译道生成的程序集中。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;9&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; #&lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt; WINDOWS
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt;     &amp;lt;&amp;lt;针对Windows Desktop&amp;gt;&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt; #elif SILVERLIGHT
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;     &amp;lt;&amp;lt;针对 Silverlight&amp;gt;&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt; #elif WINDOWS_PHONE
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum6&quot; class=&quot;lnum&quot;&gt;   6:&lt;/span&gt;     &amp;lt;&amp;lt;针对Windows Phone&amp;gt;&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum7&quot; class=&quot;lnum&quot;&gt;   7:&lt;/span&gt; &lt;span class=&quot;preproc&quot;&gt;#else&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum8&quot; class=&quot;lnum&quot;&gt;   8:&lt;/span&gt;     &amp;lt;&amp;lt;针对其他平台&amp;gt;&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum9&quot; class=&quot;lnum&quot;&gt;   9:&lt;/span&gt; &lt;span class=&quot;preproc&quot;&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果多个针对不同.NET Framework平台的项目文件存在于同一个物理目录下，存在于相同目录下的源文件可以同时包含到这些项目中以实现共享的目的。如下图所示，两个分别针对&lt;span&gt;Silverlight&lt;/span&gt;和&lt;span&gt;WPF&lt;/span&gt;的项目共享相同的目录，与两个项目文件同在一个目录下的C#文件Shared.cs可以同时被包含到这两个项目之中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073639013-1766858859.png&quot;&gt;&lt;img title=&quot;2-9_thumb[2]&quot; border=&quot;0&quot; alt=&quot;2-9_thumb[2]&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073639200-951848970.png&quot; width=&quot;349&quot; height=&quot;176&quot;/&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;文件链接&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当我们采用默认的方式将一个现有的文件添加到当前项目之中的时候，Visual Studio会将目标文件拷贝到项目本地的目录下，所以根本起不到共享的目的。但是针对现有文件的添加支持一种叫做“&lt;span&gt;链接&lt;/span&gt;”的方式使添加到项目中的文件指向的依然是原来的地址，我们可以为多个项目添加针对同一个文件的链接以实现源文件跨项目共享。同样还是上面演示分别针对Silverlight和WPF的两个项目，不论项目文件和需要被共享的文件存在于哪个目录下面，我们都可以采用如下图所示的添加文件链接的方式分享这个Shared.cs文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073639341-2088985083.png&quot;&gt;&lt;img title=&quot;2-10_thumb[2]&quot; border=&quot;0&quot; alt=&quot;2-10_thumb[2]&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073639544-591944846.png&quot; width=&quot;348&quot; height=&quot;187&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;共享项目（Shared Project）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;普通项目的目的都是组织源文件和其他相关资源并将它们最终编译成一个可被部署的程序集。但是&lt;span&gt;Shared Project&lt;/span&gt;这种项目类型则比较特别，它只有对源文件进行组织的功能，却不能通过编译生成程序集，它存在的目的就是为了实现源文件的共享。对于上面我们介绍的两种源代码的共享方式来说，它们都是针对某个单一文件的共享，而Shared Project则可以对多个源文件进行打包以实现批量共享。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073639700-189314490.png&quot;&gt;&lt;img title=&quot;2-11_thumb[2]&quot; border=&quot;0&quot; alt=&quot;2-11_thumb[2]&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073639872-1369795801.png&quot; width=&quot;345&quot; height=&quot;236&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，我们可以创建一个Shared Project类型的项目&lt;span&gt;Shared.shproj&lt;/span&gt;，并将需要共享的三个C#文件（Foo.cs、Bar.cs和Baz.cs）添加进来。我们将针对这个项目的引用同时添加到一个Silverlight项目（SilverlightApp.csproj）和Windows Phone项目（WinPhoneApp.csproj）之中，当我们对这两个项目实施编译的时候，包含在项目Shared.shproj中的三个C#文件会自动作为当前项目的源文件参与编译。  &lt;/p&gt;

&lt;p&gt;我们采用C#、VB.NET这样的编程语言编写的源文件经过编译会生成有IL代码和元数据构成的托管模块，一个或者多个托管模块合并生成一个程序集。程序集的文件名、版本、语言文化和签名的公钥令牌共同组成了它的唯一标识，我们将该标识称为程序集有效名称（Assembly Qualified Name）。除了包含必要的托管模块之外，我们还可以将其他文件作为资源内嵌到程序集中，程序集的文件构成一个“清单（Manifest）”文件来描述，这个清单文件包含在某个托管模块中。&lt;/p&gt;
&lt;p&gt;除了作为描述程序集文件构造清单之外，描述程序集的元数据也包含在这个清单文件中。程序集使程序集成为一个自描述性（Self-Describing）的部署单元，除了描述定义在本程序集中所有类型之外，这些元数据还包括对引用自外部程序集的描述。包含在元数据中针对外部程序集的描述是由&lt;span&gt;编译时引用的程序集决定的&lt;/span&gt;，引用程序集的名称（包含文件名、版本和签名的公钥令牌）会直接体现在当前程序集的元数据中。针对程序集引用的元数据采用如下的形式（“&lt;span&gt;.assembly extern&lt;/span&gt;”）被记录在清单文件中，我们可以看出被记录下来的不仅包含被引用的程序集文件名（“Foo”和“Bar”），还包括程序集的版本，对于签名的程序集（“Foo”）来说，公钥令牌也一并包含其中。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; .assembly &lt;span class=&quot;kwrd&quot;&gt;extern&lt;/span&gt; Foo
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;   .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;   .ver 1:0:0:0
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt; }
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum6&quot; class=&quot;lnum&quot;&gt;   6:&lt;/span&gt; .assembly &lt;span class=&quot;kwrd&quot;&gt;extern&lt;/span&gt; Bar
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum7&quot; class=&quot;lnum&quot;&gt;   7:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum8&quot; class=&quot;lnum&quot;&gt;   8:&lt;/span&gt;   .ver 1:0:0:0
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum9&quot; class=&quot;lnum&quot;&gt;   9:&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;包含在当前程序集清单文件中针对引用程序集的元数据是CLR加载目标程序集的依据。在默认的情况下，CLR要求加载与程序集引用元数据完全一致的程序集。具体来说，如果引用的是一个未签名的程序集（“Bar”），那么只要求被加载的程序集具有一致的文件名和版本；如果引用的是一个经过签名的程序集，那么还要求被加载的程序集具有一致的公钥令牌。&lt;/p&gt;
&lt;p&gt;在回到《&lt;a href=&quot;http://www.cnblogs.com/artech/p/how-to-cross-platform-01.html&quot;&gt;.NET Core跨平台的奥秘[上篇]：历史的枷锁&lt;/a&gt;》关于.NET多目标框架独立性的问题。虽然不同的目标框架的BCL在API层面具有很多交集，但是这些API实际上被定义在&lt;span&gt;不同的程序集中&lt;/span&gt;，这就导致了在不同的目标框架下共享同一个程序集几乎成了不可能的事情。如果要使跨目标平台程序集复用成为现实，就必须要求CLR在加载程序集时&lt;span&gt;放宽“完全匹配”的限制&lt;/span&gt;，因为针对当前程序集清单文件中描述的某个引用程序集来说，在不同的目标框架下可能指向不同的程序集。实际上确实存在这样的一些机制或者策略让CLR加载一个与引用元数据的描述不一致的程序集，我们现在就来聊聊这些策略。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;程序集一致性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们都知道.NET Framework是向后兼容的，也就是说原来针对低版本.NET Framework编译生成的程序集是可以直接在高版本CLR下运行的。我们试想一下这么一个问题：就一个针对.NET Framework 2.0编译生成的程序集自身来说，所有引用的基础程序集的版本在元数据描述中都应该是2.0，如果这个程序集在NET Framework 4.0环境下执行，CLR在决定加载它所依赖程序集的时候，应该选择2.0还是4.0呢？&lt;/p&gt;
&lt;p&gt;我们不妨通过实验来获得这个问题的答案。我们利用Visual Studio创建一个针对&lt;span&gt;.NET Framework 2.0&lt;/span&gt;的控制台应用（命名为App），并在作为程序入口的Main方法上编写如下一段代码。如下面代码片断所示，我们在控制台上输出了三个基本类型（Int32、XmlDocument和DataSet）所在程序集的全名。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;8&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Program
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;     &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; Main()
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;     {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt;         Console.WriteLine(&lt;span class=&quot;kwrd&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;kwrd&quot;&gt;int&lt;/span&gt;).Assembly.FullName);
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum6&quot; class=&quot;lnum&quot;&gt;   6:&lt;/span&gt;         Console.WriteLine(&lt;span class=&quot;kwrd&quot;&gt;typeof&lt;/span&gt;(XmlDocument).Assembly.FullName);
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum7&quot; class=&quot;lnum&quot;&gt;   7:&lt;/span&gt;         Console.WriteLine(&lt;span class=&quot;kwrd&quot;&gt;typeof&lt;/span&gt;(DataSet).Assembly.FullName);
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum8&quot; class=&quot;lnum&quot;&gt;   8:&lt;/span&gt;     }
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum9&quot; class=&quot;lnum&quot;&gt;   9:&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;直接运行这段程序使之在默认版本的CLR（2.0）下运行会在控制台上输出如下的结果，我们会发现上述三个基本类型所在程序集的版本都是2.0.0.0。也就说在这种情况下，运行时加载的程序集和编译时引用的程序集是一致的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073640013-333061392.png&quot;&gt;&lt;img title=&quot;2-11_thumb4&quot; border=&quot;0&quot; alt=&quot;2-11_thumb4&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073644466-458398257.png&quot; width=&quot;465&quot; height=&quot;101&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在我们在目录“\bin\debug”直接找到以Debug模式编译生成的程序集App.exe，并按照如下的形式修改对应的配置文件（App.exe.config），该配置的目的在于将启动应用时采用的运行时（CLR）版本从默认的2.0切换到4.0。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt;   &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;     &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;supportedRuntime&lt;/span&gt;&amp;amp;&lt;span class=&quot;attr&quot;&gt;nbsp&lt;/span&gt;;&lt;span class=&quot;attr&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;=&quot;&lt;span&gt;v4.0&lt;/span&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;   &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt;   &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;     &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;requiredRuntime&lt;/span&gt;&amp;amp;&lt;span class=&quot;attr&quot;&gt;nbsp&lt;/span&gt;;&lt;span class=&quot;attr&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;=&quot;&lt;span&gt;v4.0&lt;/span&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;   &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在&lt;span&gt;无需重新编译（&lt;/span&gt;确保运行的依然是同一个程序集）直接运行App.exe，我们会在控制台上得到如下图所示的输出结果，可以看到三个程序集的版本全部变成了&lt;span&gt;4.0.0.0&lt;/span&gt;，也就说真正被CLR加载的这些基础程序集是与当前CLR的版本相匹配的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073644653-1301166680.png&quot;&gt;&lt;img title=&quot;2-12_thumb2&quot; border=&quot;0&quot; alt=&quot;2-12_thumb2&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073644903-1923524726.png&quot; width=&quot;438&quot; height=&quot;104&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个简单的实例体现了这么一个特征：&lt;span&gt;运行过程中加载的.NET Framework程序集（承载FCL的程序集）是由当前运行时（CLR）决定的，这些程序集的版本总是与CLR的版本相匹配&lt;/span&gt;。包含在元数据中的程序集信息提供目标程序集的名称，而版本则由当前运行的CLR来决定，我们将这个重要的机制称为“程序集一致性（Assembly Unification）”，下图很清晰地揭示了这个特性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073645059-1098109565.png&quot;&gt;&lt;img title=&quot;2-13png_thumb[3]&quot; border=&quot;0&quot; alt=&quot;2-13png_thumb[3]&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073645184-314466424.png&quot; width=&quot;394&quot; height=&quot;217&quot;/&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Retargetable程序集&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在默认情况下，如果某个程序集引用了另一个具有强签名的程序集，CLR在执行的时候总是会根据程序集文件名、版本和公钥令牌去定位目标程序集。如果无法找到一个与之完全匹配的程序集，一般情况下会抛出一个FileNotFoundException类型的异常。如果当前引用的是一个&lt;span&gt;Retargetable&lt;/span&gt;程序集，则意味着CLR在定位目标程序集的时候可以 “&lt;span&gt;放宽&lt;/span&gt;” 匹配的要求，即指要求目标程序集具有相同的&lt;span&gt;文件名&lt;/span&gt;即可。&lt;/p&gt;
&lt;p&gt;如下图所示，我们的应用程序（App）引用了具有强签名的程序集“&lt;span&gt;Foobar&lt;/span&gt;, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a”，所以对于编译后生成的程序集App.exe来说，对应的程序集引用将包含目标程序集的文件名、版本和公钥令牌。如果在运行的时候只提供了一个有效名称为“&lt;span&gt;Foobar&lt;/span&gt;, Version=2.0.0.0, Culture=neutral, PublicKeyToken=d7fg7asdf7asd7aer”的程序集，除了文件名，后者的版本号和公钥令牌都与程序集引用元数据描述的都不一样。在默认情况下，系统此时总是会抛出一个FileNotFoundException类型的异常，倘若Foobar是一个&lt;span&gt;Retargetable&lt;/span&gt;程序集，我们提供的将作为目标程序集被加载并使用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073645309-778761442.png&quot;&gt;&lt;img title=&quot;2-14_thumb[2]&quot; border=&quot;0&quot; alt=&quot;2-14_thumb[2]&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073645450-1948691623.png&quot; width=&quot;373&quot; height=&quot;143&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了定义程序集的元数据多了如下一个retargetable标记之外，Retargetable程序集与普通程序集并没有本质区别。&lt;/p&gt;
&lt;p&gt;普通程序集：  &lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
.assembly Foobar
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Retargetable程序集： &lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
.assembly &lt;span&gt;retargetable&lt;/span&gt; Foobar
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样一个&lt;span&gt;retargetable&lt;/span&gt;标记可以通过按照如下所示的方式在程序集上应用&lt;span&gt;AssemblyFlagsAttribute&lt;/span&gt;特性来添加。不过这样的重定向仅仅是针对&lt;span&gt;.NET Framework自身提供的基础程序集&lt;/span&gt;有效，虽然我们也可以通过使用AssemblyFlagsAttribute特性为自定义的程序集添加这样一个retargetable标记，但是CLR并不会赋予它重定向的能力。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
[assembly:AssemblyFlags(AssemblyNameFlags.Retargetable)] 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果某个程序集引用了一个Retargetable程序集，自身清单文件针对该程序集的引用元数据同样具有如下所示的&lt;span&gt;retargetable&lt;/span&gt;标记。CLR正式利用这个标记确定它引用的是否是一个Retargetable程序集，进而确定针对该程序集的加载策略，即采用针对文件名、版本和公钥令牌的完全匹配策略，还是采用只针对文件名的降级匹配策略。&lt;/p&gt;
&lt;p&gt;针对普通程序集的引用：&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;8&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; 针对普通程序集的引用
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt; .assembly &lt;span class=&quot;kwrd&quot;&gt;extern&lt;/span&gt; Foobar
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;   .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt;   .ver 1:0:0:0
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum6&quot; class=&quot;lnum&quot;&gt;   6:&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;针对Retargetable程序集的引用：&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;7&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; .assembly &lt;span class=&quot;kwrd&quot;&gt;extern&lt;/span&gt; &lt;span&gt;retargetable&lt;/span&gt; Foobar
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;   .publickeytoken = (B7 7A 5C 56 19 34 E0 89)                         
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;   .ver 1:0:0:0
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;类型的转移&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在进行框架或者产品升级过程，我们经常会遇到针对&lt;span&gt;程序集的合并和拆分&lt;/span&gt;的场景，比如在新版本中需要对现有的API进行从新规划，可能会将定义在程序集A中定义的类型转移到程序集B中。但是即使发生了这样的情况，我们依然需要为新框架或者产品提供向后兼容的能力，这就需要使用到所谓“&lt;span&gt;类型转移（Type Forwarding）&lt;/span&gt;”的特性。&lt;/p&gt;
&lt;p&gt;为了让读者朋友们对类型转移这个重要的特性具有一个大体的认识，我们来作一个简单的实例演示。我们利用Visual Studio创建一个针对&lt;span&gt;.NET Framework 3.5&lt;/span&gt;的控制台应用App，并在作为程序入口的Main方法中编写了如下两行代码将两个常用的类型（&lt;span&gt;String&lt;/span&gt;和&lt;span&gt;Func&amp;lt;&amp;gt;）&lt;/span&gt;所在的程序集名打印出来。程序编译之后会在 “\bin\Debug” 目录下生成可执行文件App.exe和对应的配置文件App.exe.config。从如下给出的配置文件内容可以看出.NET Framework 3.5采用的运行时（CLR）版本为 “v2.0.50727” 。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;7&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Program
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;     &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; Main()
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;     {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt;         Console.WriteLine(&lt;span class=&quot;kwrd&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt;).Assembly.FullName);
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum6&quot; class=&quot;lnum&quot;&gt;   6:&lt;/span&gt;         Console.WriteLine(&lt;span class=&quot;kwrd&quot;&gt;typeof&lt;/span&gt;(Func&amp;lt;&amp;gt;).Assembly.FullName);
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum7&quot; class=&quot;lnum&quot;&gt;   7:&lt;/span&gt;     }
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum8&quot; class=&quot;lnum&quot;&gt;   8:&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;App.exe.config&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt;   &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;     &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;supportedRuntime&lt;/span&gt;&amp;amp;&lt;span class=&quot;attr&quot;&gt;nbsp&lt;/span&gt;;&lt;span class=&quot;attr&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;=&quot;&lt;span&gt;v2.0.50727&lt;/span&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;   &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;现在我们直接以命令行的执行执行编译生成的App.exe后会在控制台上得到如下图所示的输出结果。可以看出对于我们给出的这两个基础类型（String和Func&amp;lt;&amp;gt;），只有String类型被定义在程序集&lt;span&gt;mscorlib.dll&lt;/span&gt;之中，而类型Func&amp;lt;&amp;gt;其实被定义在另一个叫做&lt;span&gt;System.Core.dll&lt;/span&gt;的程序集之中。其实Framework 2.0、3.0和3.5不仅仅共享相同的运行时（CLR 2.0），对于提供基础类型的核心程序集&lt;span&gt;mscorlib.dll&lt;/span&gt;也是共享的，下图输出的版本信息已经说明了这一点。也就是说，.NET Framework 2.0发布时提供的程序集&lt;span&gt;mscorlib.dll&lt;/span&gt;在.NET Framework 3.x时代就没有升级过。Func&amp;lt;&amp;gt;类型是在.NET Framework 3.5发布时提供的一个基础类型，所以不得不将它定义在一个另一个程序集中，微软将这个程序集命令为&lt;span&gt;System.Core.dll&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073645606-1613010339.png&quot;&gt;&lt;img title=&quot;2-15_thumb2&quot; border=&quot;0&quot; alt=&quot;2-15_thumb2&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073645794-1213408730.png&quot; width=&quot;400&quot; height=&quot;95&quot;/&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;现在我们看看.NET Framework 4.0（CLR 4.0）环境下运行同一个应用程序（App.exe）是否会有不同的输出结果。为此我们在不对项目做重新编译情况下直接修改配置文件App.exe.config，并按照如下所示的方式将运行时版本设置为4.0。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt;   &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;     &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;supportedRuntime&lt;/span&gt;&amp;amp;&lt;span class=&quot;attr&quot;&gt;nbsp&lt;/span&gt;;&lt;span class=&quot;attr&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;=&quot;&lt;span&gt;v4.0&lt;/span&gt;&quot;&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;   &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;下图是同一个App.exe在.NET Framework 4.0环境下的输出结果，可以看出我们提供的两个基础类型所在的程序集都是&lt;span&gt;mscorlib.dll&lt;/span&gt;。也就是当.NET Framework升级到4.0之后，不仅仅运行时升级到了全新的CLR 4.0，微软同时也对承载基础类型的mscorelib.dll程序集进行了重新规划，所以定义在&lt;span&gt;System.Core.dll&lt;/span&gt;程序集中的基础类型也基本上又重新回到了&lt;span&gt;mscorlib.dll&lt;/span&gt;这个本应该属于它的程序集中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073645934-1372936452.png&quot;&gt;&lt;img title=&quot;2-16_thumb2&quot; border=&quot;0&quot; alt=&quot;2-16_thumb2&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073646356-392969532.png&quot; width=&quot;398&quot; height=&quot;88&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们来继续分析上面演示的这个程序。由于App.exe这个程序集最初是针对目标框架.NET Framework 3.5编译生成的，所以它的清单文件将包含针对mscorlib.dll（&lt;span&gt;2.0.0.0&lt;/span&gt;）和System.Core.dll（&lt;span&gt;3.5.0.0&lt;/span&gt;）的程序集引用。下面的代码片段展示了针对这两个程序集引用的元数据的定义。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;9&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; .assembly extern mscorlib
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;   .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;   .ver &lt;span&gt;2:0:0:0&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt; }
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum6&quot; class=&quot;lnum&quot;&gt;   6:&lt;/span&gt; .assembly extern System.Core
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum7&quot; class=&quot;lnum&quot;&gt;   7:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum8&quot; class=&quot;lnum&quot;&gt;   8:&lt;/span&gt;   .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum9&quot; class=&quot;lnum&quot;&gt;   9:&lt;/span&gt;   .ver &lt;span&gt;3:5:0:0&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum10&quot; class=&quot;lnum&quot;&gt;  10:&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当App.exe在.NET Framework 4.0环境中运行时，由于它的元数据提供的是针对System.Core.dll程序集的引用，所以CLR总是试图加载该程序集并从中定位目标类型（比如我们演示实例中的类型Func&amp;lt;&amp;gt;）。如果当前运行环境无法提供这个程序集，那么毫无疑问，一个FileNotFoundException类型的异常会被抛出来。也就是，虽然类型Func&amp;lt;&amp;gt;在.NET Framework 4.0中已经转移到了新的程序集mscorlib.dll中，当前环境依然会提供一个文件名为&lt;span&gt;System.Core.dll&lt;/span&gt;的程序集。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System.Core.dll存在的目的是告诉CLR它需要加载的类型已经发生转移，并将该类型所在的新的程序集名称告诉它&lt;/span&gt;，那么.NET Framework 4.0环境中的System.Core.dll是如何描述类型Func&amp;lt;&amp;gt;已经转移到程序集mscorelib.dll之中了呢？如果分析程序集System.Core.dll中的元数据，我们可以看到如下一段于此相关的代码。在程序集的清单文件中，每一个被转移的类型都对应这个这么一个 “&lt;span&gt;.class extern forwarder&lt;/span&gt;” 指令。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;7&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; .class extern &lt;span&gt;forwarder&lt;/span&gt; System.Func`1
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;   .assembly extern mscorlib
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;不同于上面介绍的Retargetable程序集，类型的转移并不是只针对.NET Framework提供的基础程序集，如果我们自己开发的项目也需要提供类似的向后兼容性，也可以使用这个特性。针对类型转移类型的编程只涉及到一个类型为&lt;span&gt;TypeForwardedToAttribute&lt;/span&gt;的特性，接下来我们通过一个简单的实例来演示一下如何利用这个特性将某个类型转移到一个新的程序集中。&lt;/p&gt;
&lt;p&gt;我们利用Visual Studio创建了如下图所示的解决方案，它演示了这样一个场景：控制台应用使用到了V1版本的类库Lib（v1\Lib），其中涉及到一个核心类型Foobar。该类库升级到V2版本时，我们选择将所有的核心类型统一定义在新的程序集Lib.Core中，所以类型Foobar需要转移到Lib.Core中。作为类库的发布者，我们希望使用到V1版本的应用能够直接升级到V2版本，也就是升级的应用不需要在引用新的Lib.Core程序集情况下对源代码进行重新编译，而是直接部署V2版本的两个程序集（Lib.dll和Lib.Core）就可以了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073646528-1073742375.png&quot;&gt;&lt;img title=&quot;2-17_thumb2&quot; border=&quot;0&quot; alt=&quot;2-17_thumb2&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073646684-1182345611.png&quot; width=&quot;382&quot; height=&quot;380&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上图中的虚线箭头和实线箭头分别代表项目之间的引用关系，我们从中可以看出v2目录下的Lib项目具有对Lib.Core项目的引用，因为它需要引用转移到Lib.Core项目中的类型。为了完成针对类型Foobar的转移，我们只需要在v2\Lib中定义如下一行简单的代码就可以了，我们将这行代码定义在AssemblyInfo.cs文件中。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;  &lt;/span&gt; [assembly: System.Runtime.CompilerServices.TypeForwardedTo(&lt;span class=&quot;kwrd&quot;&gt;typeof&lt;/span&gt;(Lib.Foobar))] 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;为了检验针对Foobar类型的转移是否成功，我们在控制台应用App中定义了如下一段程序，它负责将Foobar类型当前所在程序集的名称输出到控制台上。接下来我们只需要编译（以Debug模式）整个解决方案，那么V2版本的两个程序集（Lib.dll和Lib.Core.dll）将保存到\v2\lib\bin\debug\目录下。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Program
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;     &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; Main()
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt;     {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt;         Console.WriteLine(&lt;span class=&quot;kwrd&quot;&gt;typeof&lt;/span&gt;(Foobar).Assembly.FullName); 
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum6&quot; class=&quot;lnum&quot;&gt;   6:&lt;/span&gt;     }
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum7&quot; class=&quot;lnum&quot;&gt;   7:&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;接下来我们采用命令行的形式来运行控制台程序App.exe。如下图所示，我们将当前目录切换到App.exe所在的目录（\app\bin\debug）下并执行App.exe，输出的结果表明Foobar类型当前所在的程序集为Lib.dll。接下来我们将针对V2版本的两个程序集拷贝进来后再次执行App.exe，我们发现此时的Foobar类型已经是从新的程序集Lib.Core.dll中加载的了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073646825-805899003.png&quot;&gt;&lt;img title=&quot;2-18_thumb2&quot; border=&quot;0&quot; alt=&quot;2-18_thumb2&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073647013-1633359224.png&quot; width=&quot;412&quot; height=&quot;191&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们顺便来查看一下V2版本程序集Lib.dll的清单文件的内容。如下面的代码片段所示，在源代码中通过使用TypeForwardedToAttribute特性定义的类型转移在编译之后被转换成了一个“&lt;span&gt;.class extern forwarder&lt;/span&gt;”指令。&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; class=&quot;csharpcode-wrapper&quot; readability=&quot;8&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; class=&quot;csharpcode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum1&quot; class=&quot;lnum&quot;&gt;   1:&lt;/span&gt; .assembly &lt;span class=&quot;kwrd&quot;&gt;extern&lt;/span&gt; Lib.Core
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum2&quot; class=&quot;lnum&quot;&gt;   2:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum3&quot; class=&quot;lnum&quot;&gt;   3:&lt;/span&gt;   .ver 1:0:0:0
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum4&quot; class=&quot;lnum&quot;&gt;   4:&lt;/span&gt; }
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum5&quot; class=&quot;lnum&quot;&gt;   5:&lt;/span&gt; .&lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;extern&lt;/span&gt; &lt;span&gt;forwarder&lt;/span&gt; Lib.Foobar
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum6&quot; class=&quot;lnum&quot;&gt;   6:&lt;/span&gt; {
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum7&quot; class=&quot;lnum&quot;&gt;   7:&lt;/span&gt;   .assembly &lt;span class=&quot;kwrd&quot;&gt;extern&lt;/span&gt; Lib.Core
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum8&quot; class=&quot;lnum&quot;&gt;   8:&lt;/span&gt; }
&lt;/pre&gt;
&lt;pre class=&quot;alteven&quot;&gt;
&lt;span id=&quot;lnum9&quot; class=&quot;lnum&quot;&gt;   9:&lt;/span&gt; …
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在.NET Framework的时代，创建可移植类库（PCL：Portable Class Library）是实现跨多个目标框架程序集共享的&lt;span&gt;唯一途径&lt;/span&gt;。上面介绍的内容都是在为PCL做铺垫，只有充分理解了&lt;span&gt;Retargetable程序集&lt;/span&gt;和&lt;span&gt;类型转移&lt;/span&gt;的前提下才可能了解PCL的实现原理有正确的理解。考虑到很多读者朋友并没有使用PCL的经历，所以我们先来介绍一下如何创建一个PCL项目。 当我们采用Visualization Studio的Class Library（Portal）项目模板创建一个PCL项目的时候，需要在如下图所示的对话框中选择支持的目标框架及其版本。Visual Studio会为新建的项目添加一个名为 “.NET” 的引用，这个引用指向一个&lt;span&gt;由选定目标框架决定的程序集列表&lt;/span&gt;。由于这些程序集提供的API能够兼容所有选择的平台，我们在此基础编写的程序自然也具有平台兼容性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073647169-148271719.png&quot;&gt;&lt;img title=&quot;2-20_thumb[2]&quot; border=&quot;0&quot; alt=&quot;2-20_thumb[2]&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073647325-117861910.png&quot; width=&quot;404&quot; height=&quot;303&quot;/&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;如果查看这个特殊的.NET引用所在的地址，我们会发现它指向目录“%&lt;span&gt;ProgramFiles%\Reference Assemblies\Microsoft\Framework\.NETPortable\{version}\Profile\ProfileX&lt;/span&gt;”。如果查看 “%ProgramFiles%\Reference Assemblies\Microsoft\Framework\.NETPortable” 目录，我们会发现它具有如下图所示的结构。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073647497-1893348574.png&quot;&gt;&lt;img title=&quot;2-21_thumb[2]&quot; border=&quot;0&quot; alt=&quot;2-21_thumb[2]&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073647669-615624783.png&quot; width=&quot;396&quot; height=&quot;348&quot;/&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;如上图所示，本机所在目录“%ProgramFiles%\Reference Assemblies\Microsoft\Framework\.NETPortable”下具有三个代表.NET Framework版本的子目录（v4.0、v4.5和v4.6）。具体到针对某个.NET Framework版本的目录（比如v4.6），其子目录Profile下具有一系列以 “Profile” + “数字” （比如Profile31、Profile32和Profile44等）命名的子目录，实际上&lt;span&gt;PCL项目引用的就是存储在这些目录下的程序集&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于两个不同平台的.NET Framework来说，它们的BCL在API的定义上存在交集，从理论上来说，建立在这个交集基础上的程序是可以被这两个平台中共享的。如下图所示，如果我们编写的代码需要分别对Windows Desktop/Phone、Windows Phone/Store和Windows Store/Desktop平台提供支持，那么这样的代码依赖的部分仅限于两两的交集A+B、A+C和A+D。如果要求这部分代码能够运行在Windows Desktop/Phone/Store三个平台上，那么它们只能建立在三者之间的交集A上。  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073647903-1187963400.png&quot;&gt;&lt;img title=&quot;2-22_thumb[1]&quot; border=&quot;0&quot; alt=&quot;2-22_thumb[1]&quot; src=&quot;http://images2017.cnblogs.com/blog/19327/201711/19327-20171108073648059-1752868467.png&quot; width=&quot;240&quot; height=&quot;217&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;针对所有可能的目标框架（包括版本）的组合，微软会将作为两者交集的API提取出来并定义在相应的程序集中。比如说所有的目标框架都包含一个核心的程序集mscorlib.dll，虽然定义其中的类型及其成员在各个目标框架不尽相同，但是它们之间肯定存在交集，微软针对不同的目标框架组合将这些交集提取出来并定义在一系列同名程序集中，并同样命名为mscorlib.dll。 微软按照这样的方式创建了其他针对不同.NET Framework平台组合的基础程序集，这些针对某个组合的所有程序集构成一系列的Profile，并定义在上面我们提到过的目录下。值得一提的是，所有这些针对某个Profile的程序集均为&lt;span&gt;Retargetable&lt;/span&gt;程序集。&lt;/p&gt;
&lt;p&gt;当我们创建一个PCL项目的时候，第一个必需的步骤是选择兼容的目标框架（和版本），Visual Studio会根据我们的选择确定一个具体的Profile，并为创建的项目添加针对该Profile的程序集引用。由于所有引用的程序集是根据我们选择的目标框架组合 “度身定制” 的，所以定义在PCL项目的代码才具有可移植的能力。&lt;/p&gt;
&lt;p&gt;上面我们仅仅从开发的角度解释了定义在PCL项目的代码本身为什么能够确保是与目标.NET Framework平台兼容的，但是在运行的角度来看这个问题，却存在额外两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;元数据描述的引用程序集与真实加载的程序集不一致&lt;/span&gt;，比如我们创建一个兼容.NET Framework 4.5和Silverlight 5.0的PCL项目，被引用的程序集mscorlib.dll的版本为&lt;span&gt;2.0.5.0&lt;/span&gt;，但是Silverlight 5.0运行时环境中的程序集mscorlib.dll的版本则为&lt;span&gt;5.0.5.0&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;元数据描述的引用程序集的类型定义与运行时加载程序集类型定义不一致&lt;/span&gt;，比如引用程序集中的某个类型被转移到了另一个程序集中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于PCL项目在编译时引用的均为&lt;span&gt;Retargetable&lt;/span&gt;程序集，所以程序集的重定向机制帮助我们解决了第一个问题。因为在CLR在加载某个Retargetable程序集的时候，如果找不到一个与引用程序集在文件名、版本、语言文化和公钥令牌完全匹配的程序集，则会只考虑文件名的一致性。至于第二个问题，自然可以通过上面我们介绍的&lt;span&gt;类型转移机制&lt;/span&gt;来解决。&lt;/p&gt;

&lt;p&gt;综上所述，虽然微软在针对多个目标框架的代码复用上面为我们提供了一些解决方案。在源代码共享方面，我们可以采用共享项目，虽然共享项目能够做到将一组源文件进行打包复用，但是我个人基本上不怎么用它，因为如果我们在其中定义一些公有类型，那么引用该共享项目的项目之间会造成命名冲突。从另一方面讲，我们真正需要的是程序集层面的复用，但是在这方面微软只为我们提供了PCL。PCL这种采用提取目标框架API交集的方式注定了只能是一种临时的解决方案，试着想一下：如果目标框架由10种，每种有3个版本，我们需要为多少种组合创建相应的Profile。对于开发者来说，如果目标框架（包括版本），我们在创建PCL项目进行兼容框架的选择都会成问题。所以我们针对希望的是能够提供给全平台支持的BCL，你可以已经知道了，这就是Net Standard，那么Net Standard是如何能够在多个目标框架中复用的呢？请求关注本系列终结篇《&lt;a href=&quot;http://www.cnblogs.com/artech/p/how-to-cross-platform-03.html&quot;&gt;.NET Core跨平台的奥秘[下篇]：全新的布局&lt;/a&gt;》。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/artech/p/how-to-cross-platform-01.html&quot;&gt;.NET Core跨平台的奥秘[上篇]：历史的枷锁&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/artech/p/how-to-cross-platform-02.html&quot;&gt;.NET Core跨平台的奥秘[中篇]：复用之殇&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/artech/p/how-to-cross-platform-03.html&quot;&gt;.NET Core跨平台的奥秘[下篇]：全新的布局&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Nov 2017 23:35:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/artech/p/how-to-cross-platform-02.html</dc:identifier>
</item>
<item>
<title>从一个实例谈谈postgresql索引锁 - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/7087522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/7087522.html</guid>
<description>&lt;p&gt;最近客户在使用我司开发的数据库时，报告了如下问题(也不能算是问题，就是疑惑吧)，环境如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;OS : Red Hat Enterprise Linux Server release 6.7 (Santiago) 
Kernel : 2.6.32-573.el6.x86_64
PostgreSQL : PostgreSQL 9.6.2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行准备工作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# create table test (id int, data text); 
CREATE TABLE
postgres=# insert into test select a, 'Test data No ' || a from
generate_series(1,10000000) as a;
INSERT 0 10000000
postgres=# create index on test (id);
CREATE INDEX
postgres=# vacuum analyze verbose test;
......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，开启一个事务，在该事务中查询test表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# begin ;
BEGIN
postgres=# select data from test where data = 'Test data No 1';
      data
----------------
 Test data No 1
(1 row)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在开另一个psql console，查询锁的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# select c.oid, c.relname, l.locktype, l.pid, l.mode ,a.query 
from (pg_class as c inner join pg_locks as l on (c.oid = l.relation)) 
inner join pg_stat_activity as a on (l.pid = a.pid) where relname like 'test%'
order by pid;
  oid  |   relname   | locktype |  pid  |      mode       |
            query
-------+-------------+----------+-------+-----------------+----------
---
-------+-------------+----------+-------+-----------------+----------
---
-------+-------------+----------+-------+-----------------+----------
---
-------+-------------+----------+-------+-----------------+----------
---
-------+-------------+----------+-------+-----------------+--
 19412 | test_id_idx | relation | 27612 | AccessShareLock | select data 
from test where data = 'Test data No 1';
 19405 | test        | relation | 27612 | AccessShareLock | select
data from test where data = 'Test data No 1';
(2 rows)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现在执行select期间对表上的所有的索引都加上了AccessShareLock锁，但是查询并没有走索引。这让客户非常奇怪。&lt;/p&gt;
&lt;p&gt;没办法，带着这个问题调查了一番。大概有了以下的两点粗浅的认识和理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.在执行一条select文时，数据库后端会对select文进行查询分析，查询重写，查询规划和查询执行四个阶段。在查询规划阶段，需要生成一个RelOptInfo结构存储优化的查询路径，该结构中存储了表上的索引信息。此处调用get_relation_info函数打开并锁定表上所有的索引，并将索引的信息写入到RelOptInfo结构体中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体到代码里，我们可以看到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct RelOptInfo
{
    NodeTag     type;

    RelOptKind  reloptkind;

    /* all relations included in this RelOptInfo */
    Relids      relids;         /* set of base relids (rangetable indexes) */
    .
    .
    .
    List       *indexlist;      /* list of IndexOptInfo */                                    &amp;lt;-------  here
    .
    .
    .
    bool        has_eclass_joins;       /* T means joininfo is incomplete */
} RelOptInfo;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里indexlist就是查询的表上的所有的index的列表；&lt;/p&gt;
&lt;p&gt;我们再看看get_relation_info函数，它获取该表上的“catalog information”，详情可以看看这段注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
##############################################################
src/backend/optimizer/util/plancat.c:

/*
 * get_relation_info -
 *    Retrieves catalog information for a given relation.
 *
 * Given the Oid of the relation, return the following info into fields
 * of the RelOptInfo struct:
 *
 *  min_attr    lowest valid AttrNumber
 *  max_attr    highest valid AttrNumber
 *  indexlist   list of IndexOptInfos for relation's indexes
 *  serverid    if it's a foreign table, the server OID
 *  fdwroutine  if it's a foreign table, the FDW function pointers
 *  pages       number of pages
 *  tuples      number of tuples
 *
 * Also, initialize the attr_needed[] and attr_widths[] arrays.  In most
 * cases these are left as zeroes, but sometimes we need to compute attr
 * widths here, and we may as well cache the results for costsize.c.
 *
 * If inhparent is true, all we need to do is set up the attr arrays:
 * the RelOptInfo actually represents the appendrel formed by an inheritance
 * tree, and so the parent rel's physical size and index information isn't
 * important for it.
 */
void
get_relation_info(PlannerInfo *root, Oid relationObjectId, bool inhparent,
                  RelOptInfo *rel)


###################################################################&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而由于该查询是放在一个事务中的，我们发现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.一个事务内申请的锁会在事务结束时调用函数LockReleaseAll统一释放，在事务结束之前，该事务仍然保持对锁的持有。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;src/backend/storage/lmgr/lock.c:

/*
 * LockRelease -- look up 'locktag' and release one 'lockmode' lock on it.
 *      Release a session lock if 'sessionLock' is true, else release a
 *      regular transaction lock.
 *
 * Side Effects: find any waiting processes that are now wakable,
 *      grant them their requested locks and awaken them.
 *      (We have to grant the lock here to avoid a race between
 *      the waking process and any new process to
 *      come along and request the lock.)
 */
bool
LockRelease(const LOCKTAG *locktag, LOCKMODE lockmode, bool sessionLock)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们打开lock log，再模拟下客户现场。贴一下执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# begin;
BEGIN
postgres=# select data from test where data = 'Test data No 1';
LOG:  LockAcquire: lock [12373,16386] AccessShareLock at character 18
STATEMENT:  select data from test where data = 'Test data No 1';
LOG:  LockAcquire: lock [12373,16392] AccessShareLock
STATEMENT:  select data from test where data = 'Test data No 1';
LOG:  LockAcquire: lock [12373,16386] AccessShareLock
STATEMENT:  select data from test where data = 'Test data No 1';
      data
----------------
 Test data No 1
(1 row)


postgres=# end;
LOG:  LockReleaseAll: lockmethod=1
STATEMENT:  end;
LOG:  LockReleaseAll done
STATEMENT:  end;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;果然，锁是在事务最后释放的。&lt;/p&gt;
&lt;p&gt;综合1，2两点，我们向客户解释了这个问题是PostgreSQL的式样，不是bug。&lt;/p&gt;
&lt;p&gt;Over~&lt;/p&gt;
</description>
<pubDate>Tue, 07 Nov 2017 23:25:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/7087522.html</dc:identifier>
</item>
<item>
<title>记录我发现的第一个关于 Google 的 Bug - iOS122</title>
<link>http://www.cnblogs.com/ios122/p/7802152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ios122/p/7802152.html</guid>
<description>&lt;p&gt;先贴上 Bug 链接: &lt;a href=&quot;https://issuetracker.google.com/issues/68969655&quot; class=&quot;uri&quot;&gt;https://issuetracker.google.com/issues/68969655&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1081577-baac6ad1b99e663f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;bug-preview.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Bug 本身是很简单的,就是 Google 的 Android 在线参考文档中,有一处示例代码,有一个很严重的错误, 会引起整个章节的代码都无法有效执行.&lt;/p&gt;
&lt;p&gt;对 Android 的 Service 服务有所了解的,可以来这里看下,看能不能发现那个错误: &lt;a href=&quot;https://developer.android.com/training/connect-devices-wirelessly/nsd.html#discover&quot; class=&quot;uri&quot;&gt;https://developer.android.com/training/connect-devices-wirelessly/nsd.html#discover&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1081577-d802cd4c40f41fd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;bug.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于文章所谓代码,每次注册服务,都会失败,错误码是0.其实这里,还有另一处错误,就是服务类型的格式,必须是以点符号 (.) 结尾,因为在各个回调里,如果注册服务成功,你拿到的 service type 都会被自动加上点符号了.关于 errcode 为0的细节讨论,可以看看 &lt;a href=&quot;https://stackoverflow.com/questions/36232339/while-using-network-service-discovery-registration-fails-with-error-code-0&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/36232339/while-using-network-service-discovery-registration-fails-with-error-code-0&lt;/a&gt;,被采纳的答案的评论区,有大彩蛋,呼哈哈~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1081577-3cbeb29fd75bc983.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;stack.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有,就是提 Bug 时,我还顺便截了下 Google 的 Bug 自动提交系统的图,留作以后自己看:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1081577-1eae90394a25c675.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;submit-0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1081577-b37c382723a2bf55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;submit-1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我想说的是: 我还是觉得这种文档性质的东西,放到特定仓库里,直接 fork 修改发 PR 更方便,快捷.不管怎样, Google 的 Bug 系统,也沾染上我的痕迹了,比想象中要容易呀~~&lt;/p&gt;
</description>
<pubDate>Tue, 07 Nov 2017 18:32:00 +0000</pubDate>
<dc:creator>iOS122</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ios122/p/7802152.html</dc:identifier>
</item>
<item>
<title>Fiddler手机抓包图文教程 - lovesoo</title>
<link>http://www.cnblogs.com/lovesoo/p/7802113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovesoo/p/7802113.html</guid>
<description>&lt;p&gt;上篇&lt;a href=&quot;http://www.cnblogs.com/lovesoo/p/7754067.html&quot; target=&quot;_blank&quot;&gt;Fiddler教程&lt;/a&gt;，我们教了大家Fiddler安装配置及如何使用Fiddler进行基本的Http抓包及模拟请求，今天给大家介绍下如何使用Fiddler进行手机抓包。&lt;/p&gt;
&lt;p&gt;运行环境为Windows 10，使用手机为iPhone 7，iOS11系统。&lt;/p&gt;

&lt;p&gt;首先需要确保手机及电脑在同一个局域网内，如连接了同一个无线路由器。&lt;/p&gt;

&lt;p&gt;1. 运行Fiddler后打开配置项：Tools –&amp;gt; Options&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201711/445074-20171107230609966-350173704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 打开配置项HTTPS，勾选“Capture HTTPS CONNECTs”，同时勾选“Decrypt HTTPS traffic”，弹出的安装证书对话框时选择“是”。如果需要监听不可信的证书的HTTPS请求的话，需要勾选“Ignore server certificate errors (unsafe)”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201711/445074-20171107230629216-577558959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 选择Connections选项卡，选中&quot;Allow remote computers to connect&quot;：允许远程机器（pc/手机）连接Fiddler作为代理（这也是为什么Fiddler可以抓取手机请求的原因），默认使用端口号为8888&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201711/445074-20171107231013325-1909159361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 保存配置后，重启Fiddler&lt;/p&gt;

&lt;h2&gt;2.1 获取Fiddler所在机器ip地址&lt;/h2&gt;
&lt;p&gt;使用ipconfig命令查看即可，如我们这里是192.168.2.177&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201711/445074-20171108005627872-1633088375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.2 配置iPhone无线局域网代理&lt;/h2&gt;
&lt;p&gt;1) 打开iPhone设置 -&amp;gt; 无线局域网，选择并点击我们已连接的无线网，进入无线网详情页面；下拉至最下方，选择HTTP代理 -&amp;gt; 配置代理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201711/445074-20171108010252731-1882766792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2) 选择手动，填入服务器IP及端口号后点击“存储”保存即可，如这里我们填入192.168.2.177及8888&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201711/445074-20171108011609247-415630437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.3 安装手机证书&lt;/h2&gt;
&lt;p&gt;这一步配置是为了Fiddler可以抓取手机上的HTTPS请求。如果你只需抓取HTTP请求，可以忽略这一步。&lt;/p&gt;
&lt;p&gt;1) 在iPhone Safiri浏览器中打开http://192.168.2.177:8888，其中ip地址为Fiddler所在机器ip，8888为配置的Fiddler代理端口号&lt;/p&gt;
&lt;p&gt;2) 点击&quot;FiddlerRoot certificate&quot;下载证书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201711/445074-20171108012648216-1287137215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3) 在打开的“安装描述文件”界面，点击右上角“安装”按钮，输入密码后，选择安装即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201711/445074-20171108013056716-213064440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1. 我们在Safiri浏览器中打开任意网址，如我的博客地址：http://www.cnblogs.com/lovesoo/，在Fiddler中可以看到本次HTTPS请求，其中UA是iphone&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201711/445074-20171108013735794-438486800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 我们打开任意APP，如手机QQ，在Fiddler中同样可以看到QQ本次访问的所有HTTP及HTTPS请求消息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201711/445074-20171108014225450-280877123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理，Android手机也是相同的操作步骤，在配置无线局域网代理及安装证书后，就可以通过Fiddler抓取手机浏览器，APP等发出的HTTP或HTTPS类型请求了，恕不赘述。&lt;/p&gt;
</description>
<pubDate>Tue, 07 Nov 2017 17:44:00 +0000</pubDate>
<dc:creator>lovesoo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovesoo/p/7802113.html</dc:identifier>
</item>
<item>
<title>Webpack打包构建太慢了？试试几个方法 - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/7801973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/7801973.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Webpack是个很流行的打包工具，但其打包速度却一直被吐槽着&lt;/p&gt;
&lt;p&gt;如果不用上一些打包的优化建议，单单打包两三个文件就能花上好几秒，放上几十个入口文件依赖几百上千个包的话，几分钟十几分钟妥妥的&lt;/p&gt;
&lt;p&gt;本文整理了常见的一些方法，部分使用之后就看到了很大改善，部分没什么明显的变化，也可能是项目规模还不够大，先记录一下方法也好&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;span&gt;一、使用监听模式或热更新热替换&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;webpack支持监听模式，此时需要重新编译时就可以进行增量构建，增量构建是很快的，基本不到一秒或几秒之内就能重新编译好&lt;/p&gt;
&lt;p&gt;注意区分一下开发环境和线上环境，开发环境启用热更新替换&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开发环境设置本地服务器，实现热更新&lt;/span&gt;
&lt;span&gt;    devServer: {
        contentBase: path.resolve(__dirname, &lt;/span&gt;'static'&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提供给外部访问&lt;/span&gt;
        host: '0.0.0.0'&lt;span&gt;,
        port: &lt;/span&gt;8388&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 允许开发服务器访问本地服务器的包JSON文件，防止跨域&lt;/span&gt;
&lt;span&gt;        headers: {
            &lt;/span&gt;'Access-Control-Allow-Origin': '*'&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置热替换&lt;/span&gt;
        hot: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置页面引入&lt;/span&gt;
        inline: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件输出配置&lt;/span&gt;
&lt;span&gt;    output: {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置路径，防止访问本地服务器相关资源时，被开发服务器认为是相对其的路径&lt;/span&gt;
        publicPath: 'http://localhost:8188/dist/js/'&lt;span&gt;,
    },


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插件配置&lt;/span&gt;
&lt;span&gt;    plugins: [
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 热更新替换&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.HotModuleReplacementPlugin()
    ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;线上环境的编译，加个 &lt;span&gt;--watch&lt;/span&gt; 参数就可以了&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、开发环境不做无意义的操作&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;很多配置，在开发阶段是不需要去做的，我们可以区分出开发和线上的两套配置，这样在需要上线的时候再全量编译即可&lt;/p&gt;
&lt;p&gt;比如说 代码压缩、目录内容清理、计算文件hash、提取CSS文件等&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、选择一个合适的devtool属性值&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;配置devtool可以支持使用&lt;span&gt;sourceMap&lt;/span&gt;，但有些是耗时严重的，这个得多试试&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;四、代码压缩用ParallelUglifyPlugin代替自带的 UglifyJsPlugin插件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;自带的JS压缩插件是单线程执行的，而&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/gdborton/webpack-parallel-uglify-plugin&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;webpack-parallel-uglify-plugin&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;可以并行的执行，在我的小demo中使用后，速度直接从25s变成了14s&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.UglifyJsPlugin({
            sourceMap: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            compress: {
                warnings: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            }
        }),



ParallelUglifyPlugin &lt;/span&gt;= require('webpack-parallel-uglify-plugin'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParallelUglifyPlugin({
           cacheDir: &lt;/span&gt;'.cache/'&lt;span&gt;,
           uglifyJS:{
             output: {
               comments: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
             },
             compress: {
               warnings: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
             }
           }
         }),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;五、css-loader使用0.15.0以下的版本&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;听闻这个版本以上的速度会慢许多，不过在我的小demo中还没看到明显变化&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;六、使用fast-sass-loader代替sass-loader&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/yibn2008/fast-sass-loader&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;fast-sass-loader&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;可以并行地处理sass,在提交构建之前会先组织好代码，速度也会快一些&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;七、babel-loader开启缓存&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;babel-loader在执行的时候，可能会产生一些运行期间重复的公共文件，造成代码体积大冗余，同时也会减慢编译效率&lt;/p&gt;
&lt;p&gt;可以加上&lt;span&gt;cacheDirectory&lt;/span&gt;参数或使用 &lt;span&gt;transform-runtime &lt;/span&gt;插件试试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; webpack.config.js&lt;/span&gt;
&lt;span&gt;use: [{
                loader: &lt;/span&gt;'babel-loader'&lt;span&gt;,
                options: {
                    cacheDirectory: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                }]


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; .bablerc&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;presets&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;env&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;react&quot;&lt;span&gt;
    ],
    &lt;/span&gt;&quot;plugins&quot;: [&quot;transform-runtime&quot;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;八、不需要打包编译的插件库换成全局&amp;lt;script&amp;gt;标签引入的方式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;比如jQuery插件，react, react-dom等，代码量是很多的，打包起来可能会很耗时&lt;/p&gt;
&lt;p&gt;可以直接用标签引入，然后在webpack配置里使用 &lt;span&gt;expose-loader&lt;/span&gt;  或 &lt;span&gt;externals&lt;/span&gt; 或 &lt;span&gt;ProvidePlugin&lt;/span&gt;  提供给模块内部使用相应的变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @1&lt;/span&gt;
&lt;span&gt;use: [{
                loader: &lt;/span&gt;'expose-loader'&lt;span&gt;,
                options: &lt;/span&gt;'$'&lt;span&gt;
            }, {
                loader: &lt;/span&gt;'expose-loader'&lt;span&gt;,
                options: &lt;/span&gt;'jQuery'&lt;span&gt;
            }]


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @2&lt;/span&gt;
&lt;span&gt;externals: {
        jquery: &lt;/span&gt;'jQuery'&lt;span&gt;
    },


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @3&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.ProvidePlugin({
            $: &lt;/span&gt;'jquery'&lt;span&gt;,
            jQuery: &lt;/span&gt;'jquery'&lt;span&gt;,
            &lt;/span&gt;'window.jQuery': 'jquery'&lt;span&gt;
        }),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;九、使用 DllPlugin 和 DllReferencePlugin &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这种方式其实和externals是类似的，主要用于有些模块没有可以在&amp;lt;script&amp;gt;标签中引入的资源（纯npm包）&lt;/p&gt;
&lt;p&gt;Dll是动态链接库的意思，实际上就是将这些npm打包生成一个JSON文件，这个文件里包含了npm包的路径对应信息&lt;/p&gt;
&lt;p&gt;这两个插件要一起用&lt;/p&gt;
&lt;p&gt;首先，新建一个&lt;span&gt;dll.config.js&lt;/span&gt;配置文件，先用webpack来打包这个文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
const webpack = require('webpack'&lt;span&gt;);
const path &lt;/span&gt;= require('path'&lt;span&gt;);

module.exports &lt;/span&gt;=&lt;span&gt; {
    output: {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将会生成./ddl/lib.js文件&lt;/span&gt;
        path: path.resolve(__dirname, 'ddl'&lt;span&gt;),
        filename: &lt;/span&gt;'[name].js'&lt;span&gt;,
        library: &lt;/span&gt;'[name]'&lt;span&gt;,
    },
    entry: {
        &lt;/span&gt;&quot;lib&quot;&lt;span&gt;: [
            &lt;/span&gt;'react'&lt;span&gt;,
            &lt;/span&gt;'react-dom'&lt;span&gt;,
            &lt;/span&gt;'jquery'
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...其它库&lt;/span&gt;
&lt;span&gt;        ],
    },
    plugins: [
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DllPlugin({
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成的映射关系文件&lt;/span&gt;
            path: 'manifest.json'&lt;span&gt;,
            name: &lt;/span&gt;'[name]'&lt;span&gt;,
            context: __dirname,
        }),
    ],
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/688270/201711/688270-20171107224022778-1120250935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;span&gt;manifest.json&lt;/span&gt;文件中就是相应的包对应的信息&lt;/p&gt;
&lt;p&gt;然后在我们的项目配置文件中配置&lt;span&gt;DllReferencePlugin&lt;/span&gt; 使用这个清单文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插件配置&lt;/span&gt;
&lt;span&gt;    plugins: [
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DllReferencePlugin({
            context: __dirname,
            manifest: require(&lt;/span&gt;'./manifest.json'&lt;span&gt;)
        }),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;十、提取公共代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;使用CommonsChunkPlugin提取公共的模块，可以减少文件体积，也有助于浏览器层的文件缓存，还是比较推荐的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取公共模块文件&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.CommonsChunkPlugin({
            chunks: [&lt;/span&gt;'home', 'detail'&lt;span&gt;],
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开发环境下需要使用热更新替换，而此时common用chunkhash会出错，可以直接不用hash&lt;/span&gt;
            filename: '[name].js' + (isProduction ? '?[chunkhash:8]' : ''&lt;span&gt;),
            name: &lt;/span&gt;'common'&lt;span&gt;
        }),




&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 切合公共模块的提取规则，有时后你需要明确指定默认放到公共文件的模块&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 文件入口配置&lt;/span&gt;
&lt;span&gt;    entry: {
        home: &lt;/span&gt;'./src/js/home'&lt;span&gt;,
        detail: &lt;/span&gt;'./src/js/detail'&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取jquery入公共文件&lt;/span&gt;
        common: ['jquery', 'react', 'react-dom'&lt;span&gt;]
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;十一、使用HappyPack来加速构建&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/amireh/happypack&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;HappyPack&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;会采用多进程去打包构建，使用方式还是蛮简单的，但并不是支持所有的loader&lt;/p&gt;
&lt;p&gt;首先引入，定义一下这个插件所开启的线程，推荐是四个，其实也可以直接使用默认的就行了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HappyPack = require('happypack'&lt;span&gt;),
    os &lt;/span&gt;= require('os'&lt;span&gt;),
    happyThreadPool &lt;/span&gt;= HappyPack.ThreadPool({ size: os.cpus().length });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在module的规则里改动一下，引入它，其中 &lt;span&gt;id&lt;/span&gt;是一个标识符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
            test: &lt;/span&gt;/\.jsx?$/&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译js或jsx文件，使用babel-loader转换es6为es5&lt;/span&gt;
            exclude: /node_modules/&lt;span&gt;,
            loader: &lt;/span&gt;'HappyPack/loader?id=js'
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use: [{&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     loader: 'babel-loader',&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     options: {&lt;/span&gt;

            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; }]&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们调用插件，设置匹配的id，然后相关的配置可以直接把use：的规则部分套在loaders上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
            id: &lt;/span&gt;'js'&lt;span&gt;,
            loaders: [{
                loader: &lt;/span&gt;'babel-loader'&lt;span&gt;,
                options: {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cacheDirectory: true&lt;/span&gt;
&lt;span&gt;                }
            }]
        }),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;要注意的第一点是&lt;/strong&gt;，它对&lt;span&gt;file-loader&lt;/span&gt;和&lt;span&gt;url-loader&lt;/span&gt;支持不好，所以这两个loader就不需要换成happypack了，其他loader可以类似地换一下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要注意的第二点是&lt;/strong&gt;，使用&lt;span&gt;ExtractTextWebpackPlugin&lt;/span&gt;提取css文件也不是完全就能转换过来，所以需要小小的改动一下，比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module: {
        rules: [{
            test: &lt;/span&gt;/\.css$/&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; loader: 'HappyPack/loader?id=css'&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取CSS文件&lt;/span&gt;
&lt;span&gt;            use: cssExtractor.extract({
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果配置成不提取，则此类文件使用style-loader插入到&amp;lt;head&amp;gt;标签中&lt;/span&gt;
                fallback: 'style-loader'&lt;span&gt;,
                use: &lt;/span&gt;'HappyPack/loader?id=css'
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use: [{&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         loader: 'css-loader',&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         options: {&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;             // url: false,&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;             minimize: true&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         }&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     },&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     // 'postcss-loader'&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ]&lt;/span&gt;
&lt;span&gt;            })
        }, {
            test: &lt;/span&gt;/\.scss$/&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; loader: 'HappyPack/loader?id=scss'&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译Sass文件 提取CSS文件&lt;/span&gt;
&lt;span&gt;            use: sassExtractor.extract({
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果配置成不提取，则此类文件使用style-loader插入到&amp;lt;head&amp;gt;标签中&lt;/span&gt;
                fallback: 'style-loader'&lt;span&gt;,
                use: &lt;/span&gt;'HappyPack/loader?id=scss'
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use: [&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     'css-loader',&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     // 'postcss-loader',&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     {&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         loader: 'sass-loader',&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         options: {&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;             sourceMap: true,&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;             outputStyle: 'compressed'&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         }&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ]&lt;/span&gt;
&lt;span&gt;            })
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为它是直接函数调用的，我们就放到里层的use规则就行了，然后配置插件即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;plugins: [
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
            id: &lt;/span&gt;'css'&lt;span&gt;,
            loaders: [{
                loader: &lt;/span&gt;'css-loader'&lt;span&gt;,
                options: {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; url: false,&lt;/span&gt;
                    minimize: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                }
            }]
        }),
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
            id: &lt;/span&gt;'scss'&lt;span&gt;,
            loaders: [{
                &lt;/span&gt;'loader': 'css-loader'&lt;span&gt;
            }, {
                loader: &lt;/span&gt;'fast-sass-loader'&lt;span&gt;,
                options: {
                    sourceMap: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    outputStyle: &lt;/span&gt;'compressed'&lt;span&gt;
                }
            }]
        }),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;十二、优化构建时的搜索路径&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在webpack打包时，会有各种各样的路径要去查询搜索，我们可以加上一些配置，让它搜索地更快&lt;/p&gt;
&lt;p&gt;比如说，方便改成绝对路径的模块路径就改一下，以纯模块名来引入的可以加上一些目录路径&lt;/p&gt;
&lt;p&gt;还可以善于用下&lt;span&gt;resolve&lt;/span&gt; &lt;span&gt;alias&lt;/span&gt;别名 这个字段来配置&lt;/p&gt;
&lt;p&gt;还有&lt;span&gt;exclude&lt;/span&gt;等的配置，避免多余查找的文件，比如使用babel别忘了剔除不需要遍历的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
            test: &lt;/span&gt;/\.jsx?$/&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译js或jsx文件，使用babel-loader转换es6为es5&lt;/span&gt;
            exclude: /node_modules/&lt;span&gt;,
             use: [{
                 loader: &lt;/span&gt;'babel-loader'&lt;span&gt;,
                 options: {

                 }
             }]
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span&gt;十三、（导出编译JSON文件）理一下打包构建涉及的模块，分析看有哪些包是不需要打包的，只打包需要的模块&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;检查一下代码，看看是不是有不需要引入的模块出现在代码里&lt;/p&gt;
&lt;p&gt;webpack编译时加上参数 &lt;span&gt;--json &amp;gt; stat.json&lt;/span&gt; 后，可以上传到 &lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://webpack.github.io/analyse/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;webpack-analyse&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; 、&lt;span&gt;&lt;a href=&quot;https://chrisbateman.github.io/webpack-visualizer/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;webpack-visualizer&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; 等分析站点上，看看打包的模块信息&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;十四、使用ModuleConcatenationPlugin插件来加快JS执行速度&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这是webpack3的新特性（&lt;span&gt;Scope Hoisting&lt;/span&gt;），其实是借鉴了Rollup打包工具来的，它将一些有联系的模块，放到一个闭包函数里面去，通过减少闭包函数数量从而加快JS的执行速度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.ModuleConcatenationPlugin({

        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;十五、使用noParse&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;webpack打包的时候，有时不需要解析某些模块的依赖（这些模块并没有依赖，或者并根本就没有模块化），我们可以直接加上这个参数，直接跳过这种解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module: {
    noParse: &lt;/span&gt;/node_modules\/(jquey\.js)/&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;十六、使用异步的模块加载&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这个算是可以减小模块的体积吧，在一定程度上也是为用户考虑的，使用&lt;span&gt;require.ensure&lt;/span&gt;来设置哪些模块需要异步加载，webpack会将它打包到一个独立的chunk中，&lt;/p&gt;
&lt;p&gt;在某个时刻（比如用户点击了查看）才异步地加载这个模块来执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$('.bg-input').click(() =&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'clicked, loading async.js'&lt;span&gt;)

    require.ensure([], require &lt;/span&gt;=&amp;gt;&lt;span&gt; {

        require(&lt;/span&gt;'./components/async2'&lt;span&gt;).log();
        require(&lt;/span&gt;'./components/async1'&lt;span&gt;).log();
        console.log(&lt;/span&gt;'loading async.js done'&lt;span&gt;);
    });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;十七、以模块化来引入&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;有些模块是可以以模块化来引入的，就是说可以只引入其中的一部分，比如说lodash&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原来的引入方式&lt;/span&gt;
 import {debounce} from 'lodash'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按模块化的引入方式&lt;/span&gt;
import debounce from 'lodash/debounce';
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 主要是整理过来的，试用了几个方法，首次编译的速度可以从之前半分多钟减小到十秒左右了，当然，开启了热更新替换后简直美不可言&lt;/p&gt;
&lt;p&gt;当然还有很多方法没整理出，这些方法是有使用场景的，并不是每个都需要用，需要在自己的项目中尝试，结合配置它的复杂性和带来的效应来权衡。&lt;/p&gt;
</description>
<pubDate>Tue, 07 Nov 2017 15:37:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/7801973.html</dc:identifier>
</item>
<item>
<title>密码学那些事———SHA-512及其C++实现 - coding==1？</title>
<link>http://www.cnblogs.com/jake9402/p/7801969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jake9402/p/7801969.html</guid>
<description>&lt;p&gt;&lt;span&gt;转载请注明出处&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;一、引言&lt;/h3&gt;
&lt;p&gt;　　相信大家对于哈希压缩加密算法应该不陌生，在我们用微信或者支付宝接口的时候经常会遇到用这类算法加密，以验证数据的完整性。可以说这类算法无处不在，那这些算法的原理是什么呢？&lt;/p&gt;
&lt;p&gt;今天我们以SHA-512为例来说明。&lt;/p&gt;
&lt;h3&gt;二、简单介绍&lt;/h3&gt;
&lt;p&gt;　　SHA (Secure Hash Algorithm，译作&lt;a href=&quot;https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;安全散列算法&lt;/a&gt;) 是美国国家安全局 (NSA) 设计，美国国家标准与技术研究院 (NIST) 发布的一系列密码散列函数。我们将要介绍的SHA-512就是SHA2系列的一种，到目前为止，SHA系列已经发展到SHA3，&lt;/p&gt;
&lt;p&gt;其中SHA1早在2005年就被证明是不安全的，已经有了破解的办法，谷歌也在很多年前就不再使用SHA1，当前主流的是SHA2。&lt;/p&gt;
&lt;p&gt;下图是一些简单的介绍。（转自维基）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171107223115403-1144649886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;公式:&lt;/h3&gt;
&lt;h3&gt;h = Hash（message）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Hash&lt;/strong&gt;:哈希函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;message&lt;/strong&gt;:不超过最大消息长度的任意长度消息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;h&lt;/strong&gt;: 相应位数的密文&lt;/p&gt;
&lt;p&gt;安全哈希算法是一种超损压缩：将一个非常大的数据压缩到固定位长的数据，因而这是一个不可逆的算法。&lt;/p&gt;
&lt;p&gt;为什么不可逆?&lt;/p&gt;
&lt;p&gt;　　在不知算法具体流程的情况下，我们来考虑类似的问题。&lt;/p&gt;
&lt;p&gt;　　123456789abc  =&amp;gt; 123 请问给你123，你怎么推出原字符是什么？&lt;/p&gt;
&lt;p&gt;　　同时你会说一个函数那我们找它逆函数，再映射回去不就好了？那么好我告诉你我们的原函数是:截断后面的bits,只留下开头的3个。那么你现在可以帮我找到原消息了吗？&lt;/p&gt;
&lt;p&gt;　　显然这样有2^n种可能。因而我们认为安全哈希函数是不可逆的。这也就可以保证我们的安全行了。&lt;/p&gt;

&lt;h3&gt;三、算法描述&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;一、处理原文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1、消息bits（二进制）化，将消息化为二进制（不一定直接一次性转为二进制，在后面我贴的代码里是动态转换的）。&lt;/p&gt;
&lt;p&gt;　　　　2、填充字长：&lt;/p&gt;
&lt;p&gt;　　　　　　（在我们后面的处理过程中，都是以1024bits（512B）为一次操作的最小单位的，因而消息得满足512B对齐）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;896&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;= &lt;span&gt;length(message)%1024&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;　　　　 　　 &lt;/strong&gt; 也就是&lt;/span&gt;满足填充后消息长度（bits)除1024取余数等于896（1024-128=896）&lt;/p&gt;
&lt;p&gt;　　　　3、填充&lt;/p&gt;
&lt;p&gt;　　　　　　　第一位填充1，其他位填充0,满足除余为896后，还剩下128bits.这个用于存消息长度。（SHA512中为128位,因而此算法最长消息为2^128-1)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;二、设置初始值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;SHA512算法的结果长度为512位，按每组64位分成8组，这8组结果是由8个初始值A,B,C,D,E,F,G,H经过不断演变得到的。这8个初始值是:&lt;/p&gt;
&lt;p&gt;　　　　    A = 0x6a09e667f3bcc908ULL;&lt;br/&gt;    　　　　B = 0xbb67ae8584caa73bULL;&lt;br/&gt;   　　　　 C = 0x3c6ef372fe94f82bULL;&lt;br/&gt;   　　　　 D = 0xa54ff53a5f1d36f1ULL;&lt;br/&gt;   　　　　 E = 0x510e527fade682d1ULL;&lt;br/&gt;   　　　　 F = 0x9b05688c2b3e6c1fULL;&lt;br/&gt;   　　　　 G = 0x1f83d9abfb41bd6bULL;&lt;br/&gt;   　　　　 H = 0x5be0cd19137e2179ULL;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;三、循环加工&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;（这就是算法最核心的地方,我们形象的把它称为哈希工厂)&lt;/p&gt;
&lt;p&gt;　　　　　下面我们看图说话&lt;/p&gt;
&lt;p&gt;　　　　 &lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171107231325419-1028415318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　图中A-H哈希的8个分组，每次循环从旧的中产生新的，一共得循环多少次呢？&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;主循环次数&lt;/span&gt; = 消息长度/1024&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;每次主循环中又保存80次子循环&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;span&gt;上图就是表达了单次子循环的流程&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;strong&gt;主要操作&lt;/strong&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171107231857247-1516136813.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171107231940575-429187946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171107231950013-608594124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171107232021059-1083169241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&amp;gt;&amp;gt;&amp;gt;表示循环右移&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;span&gt;田：&lt;span&gt;加法&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;⊞ {\displaystyle \color {red}\boxplus } &lt;img class=&quot;mwe-math-fallback-image-inline&quot; src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/234b9f9d061d7f499f6ba215b2cec330613cd332&quot; alt=&quot;\color {red}\boxplus &quot;/&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;mwe-math-element&quot;&gt;&lt;span class=&quot;mwe-math-mathml-inline mwe-math-mathml-a11y&quot;&gt;⊞ {\displaystyle \color {red}\boxplus } &lt;img class=&quot;mwe-math-fallback-image-inline&quot; src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/234b9f9d061d7f499f6ba215b2cec330613cd332&quot; alt=&quot;\color {red}\boxplus &quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　对应C语言表达式子:&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　#define Ch( x, y, z )     (z ^ (x &amp;amp; (y ^ z)))&lt;br/&gt;　　　　　　　　　　#define Maj(x, y, z )     (((x | y) &amp;amp; z) | (x &amp;amp; y))&lt;br/&gt;　　　　　　　　　　#define S( x, n )         ROR64( x, n )&lt;br/&gt;　　　　　　　　　　#define R( x, n )         (((x)&amp;amp;0xFFFFFFFFFFFFFFFFULL)&amp;gt;&amp;gt;((unsigned long long)n))&lt;br/&gt;　　　　　　　　　　#define Sigma0( x )       (S(x, 28) ^ S(x, 34) ^ S(x, 39))&lt;br/&gt;　　　　　　　　　　#define Sigma1( x )       (S(x, 14) ^ S(x, 18) ^ S(x, 41))&lt;br/&gt;　　　　　　　　　　#define Gamma0( x )       (S(x, 1) ^ S(x, 8) ^ R(x, 7))&lt;br/&gt;　　　　　　　　　　#define Gamma1( x )       (S(x, 19) ^ S(x, 61) ^ R(x, 6))&lt;/p&gt;
&lt;p&gt;　　　　　　W，K是两个常量&lt;/p&gt;
&lt;p&gt;　　　　　　其中W是计算出的，具体计算看代码。&lt;/p&gt;
&lt;p&gt;　　　　　　K：预先给出的80个常量&lt;/p&gt;
&lt;p&gt;　　　　　　相信大家有了上图后已经明白了核心操作。要是还不明白建议根据附录中的代码进一步理解。　　　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　四、拼接结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　&lt;/strong&gt;将最后的8个常量一次拼接则得到结果。&lt;/p&gt;

&lt;p&gt;C语言实现（C++)&lt;/p&gt;
&lt;p&gt;SHA512.h&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;252&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef SHA512_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; SHA512_H

&lt;span&gt;/////////////////////////////////////////////////////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SHA512_CB(control block)                             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SHA512_CB:SHA512控制块,包含算法运算过程中将用到的信息&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; count[2]:记录128位的数字长度（两个64位）             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; state[8]:A-H八个初始常量(64bit)                      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; buffer[128]:用于每次运算的1024bit                      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;                                                      &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;/////////////////////////////////////////////////////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt;
{
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; count[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; state[&lt;span&gt;8&lt;/span&gt;&lt;span&gt;];
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buffer[&lt;span&gt;128&lt;/span&gt;&lt;span&gt;];
} SHA512_CB;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于补齐的数,最多补128字节也就是1024bit&lt;/span&gt;
unsigned &lt;span&gt;char&lt;/span&gt; PADDING[] =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;0x80&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次子循环中用到的常量
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后面加ULL表示long long&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; K[&lt;span&gt;80&lt;/span&gt;] =&lt;span&gt; {
    0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL, 0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
    0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL, 0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
    0xd807aa98a3030242ULL, 0x12835b0145706fbeULL, 0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
    0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL, 0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
    0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL, 0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
    0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL, 0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
    0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL, 0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
    0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL, 0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
    0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL, 0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
    0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL, 0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
    0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL, 0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
    0xd192e819d6ef5218ULL, 0xd69906245565a910ULL, 0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
    0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL, 0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
    0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL, 0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
    0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL, 0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
    0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL, 0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
    0xca273eceea26619cULL, 0xd186b8c721c0c207ULL, 0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
    0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL, 0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
    0x28db77f523047d84ULL, 0x32caab7b40c72493ULL, 0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
    0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL, 0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化函数，初始化SHA_CB的各个值&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; SHA512Init(SHA512_CB *&lt;span&gt;context);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将数据加入&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; SHA512Update(SHA512_CB *context, unsigned &lt;span&gt;char&lt;/span&gt; *input, unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; inputlen);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理完最后再调用，这个处理尾数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; SHA512Final(SHA512_CB *context, unsigned &lt;span&gt;char&lt;/span&gt; digest[&lt;span&gt;32&lt;/span&gt;&lt;span&gt;]);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加密处理函数：Hash加密的核心工厂&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; SHA512Transform(unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; state[&lt;span&gt;8&lt;/span&gt;], unsigned &lt;span&gt;char&lt;/span&gt; block[&lt;span&gt;128&lt;/span&gt;&lt;span&gt;]);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编码函数：将整型编码转为字符&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; SHA512Encode(unsigned &lt;span&gt;char&lt;/span&gt; *output, unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; *input, unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; len);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解码函数:将字符数组保存的编码转为整型&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; SHA512Decode(unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; *output, unsigned &lt;span&gt;char&lt;/span&gt; *input, unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; len);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;SHA512.c&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;177&quot;&gt;
&lt;pre&gt;
#include &amp;lt;memory.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SHA512.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;



&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环右移(64位)&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ROR64( value, bits ) (((value) &amp;gt;&amp;gt; (bits)) | ((value) &amp;lt;&amp;lt; (64 - (bits))))

&lt;span&gt;//////////////////////////////////////////////////////
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;                                                    &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ch,:Maj操作                                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; S:循环右移    R:同2**128除余右移                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sigma0:Sigma0函数                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sigma1:Sigma2函数                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Gamma0:Gamma0函数                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Gamma1:Gamma1函数                                &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;//////////////////////////////////////////////////////
&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; Ch( x, y, z )     (z ^ (x &amp;amp; (y ^ z)))
&lt;span&gt;#define&lt;/span&gt; Maj(x, y, z )     (((x | y) &amp;amp; z) | (x &amp;amp; y))
&lt;span&gt;#define&lt;/span&gt; S( x, n )         ROR64( x, n )
&lt;span&gt;#define&lt;/span&gt; R( x, n )         (((x)&amp;amp;0xFFFFFFFFFFFFFFFFULL)&amp;gt;&amp;gt;((unsigned long long)n))
&lt;span&gt;#define&lt;/span&gt; Sigma0( x )       (S(x, 28) ^ S(x, 34) ^ S(x, 39))
&lt;span&gt;#define&lt;/span&gt; Sigma1( x )       (S(x, 14) ^ S(x, 18) ^ S(x, 41))
&lt;span&gt;#define&lt;/span&gt; Gamma0( x )       (S(x, 1) ^ S(x, 8) ^ R(x, 7))
&lt;span&gt;#define&lt;/span&gt; Gamma1( x )       (S(x, 19) ^ S(x, 61) ^ R(x, 6))

&lt;span&gt;#define&lt;/span&gt; Sha512Round( a, b, c, d, e, f, g, h, i )       \&lt;span&gt;
     t0 &lt;/span&gt;= h + Sigma1(e) + Ch(e, f, g) + K[i] +&lt;span&gt; W[i];   \
     t1 &lt;/span&gt;= Sigma0(a) +&lt;span&gt; Maj(a, b, c);                    \
     d &lt;/span&gt;+=&lt;span&gt; t0;                                          \
     h  &lt;/span&gt;= t0 +&lt;span&gt; t1;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SHA512Init(SHA512_CB *&lt;span&gt;context) {
    context&lt;/span&gt;-&amp;gt;count[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    context&lt;/span&gt;-&amp;gt;count[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    context&lt;/span&gt;-&amp;gt;state[&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; 0x6a09e667f3bcc908ULL;
    context&lt;/span&gt;-&amp;gt;state[&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; 0xbb67ae8584caa73bULL;
    context&lt;/span&gt;-&amp;gt;state[&lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; 0x3c6ef372fe94f82bULL;
    context&lt;/span&gt;-&amp;gt;state[&lt;span&gt;3&lt;/span&gt;] =&lt;span&gt; 0xa54ff53a5f1d36f1ULL;
    context&lt;/span&gt;-&amp;gt;state[&lt;span&gt;4&lt;/span&gt;] =&lt;span&gt; 0x510e527fade682d1ULL;
    context&lt;/span&gt;-&amp;gt;state[&lt;span&gt;5&lt;/span&gt;] =&lt;span&gt; 0x9b05688c2b3e6c1fULL;
    context&lt;/span&gt;-&amp;gt;state[&lt;span&gt;6&lt;/span&gt;] =&lt;span&gt; 0x1f83d9abfb41bd6bULL;
    context&lt;/span&gt;-&amp;gt;state[&lt;span&gt;7&lt;/span&gt;] =&lt;span&gt; 0x5be0cd19137e2179ULL;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SHA512Update(SHA512_CB *context, unsigned &lt;span&gt;char&lt;/span&gt; *input, unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; inputlen) {
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;, partlen = &lt;span&gt;0&lt;/span&gt;, i = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i记录input的当前位置（初始为0）&lt;/span&gt;
    index = (context-&amp;gt;count[&lt;span&gt;1&lt;/span&gt;] &amp;gt;&amp;gt; &lt;span&gt;3&lt;/span&gt;) &amp;amp; &lt;span&gt;0x7F&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;index:总字长除127(11111111)取余后的余数&lt;/span&gt;
    partlen = &lt;span&gt;128&lt;/span&gt; - index;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;partlen:同128相差的长度&lt;/span&gt;
    context-&amp;gt;count[&lt;span&gt;1&lt;/span&gt;] += inputlen &amp;lt;&amp;lt; &lt;span&gt;3&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新count

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 统计字符的bit长度，如果小于说明类型溢出了(64bit)无法装下了
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于最后留下128bit填充字符长度，因而必须引入count[1]保存
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 64bit+64bit=128bit&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (context-&amp;gt;count[&lt;span&gt;1&lt;/span&gt;] &amp;lt; (inputlen &amp;lt;&amp;lt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;))
        context&lt;/span&gt;-&amp;gt;count[&lt;span&gt;0&lt;/span&gt;]++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右移动61位后就是count[0]应该记录的值。（左移3位，溢出的就是右移动61位的）&lt;/span&gt;
    context-&amp;gt;count[&lt;span&gt;0&lt;/span&gt;] += inputlen &amp;gt;&amp;gt; &lt;span&gt;61&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/////////////////////////////////////////////////////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;                                                        &lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     如果此次更新的长度，大于原长度同128做差的值，    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     .ie. 加上刚更新的长度满足了128Bytes(1024位)      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     因而可以进行一次加密循环                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;                                                        &lt;span&gt;//
&lt;/span&gt;    &lt;span&gt;/////////////////////////////////////////////////////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (inputlen &amp;gt;=&lt;span&gt; partlen)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将缺的partlen个字节数据加入缓冲区&lt;/span&gt;
        memcpy(&amp;amp;context-&amp;gt;&lt;span&gt;buffer[index], input, partlen);
        SHA512Transform(context&lt;/span&gt;-&amp;gt;state, context-&amp;gt;&lt;span&gt;buffer);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果输入的字，还可以进行（还有整128字的）就继续进行一次加密循环&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; (i = partlen; i + &lt;span&gt;128&lt;/span&gt; &amp;lt;= inputlen; i += &lt;span&gt;128&lt;/span&gt;&lt;span&gt;)
            SHA512Transform(context&lt;/span&gt;-&amp;gt;state, &amp;amp;&lt;span&gt;input[i]);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前位置设为0&lt;/span&gt;
        index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        i &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新设置buffer区（处理过的字被覆盖成新字）&lt;/span&gt;
    memcpy(&amp;amp;context-&amp;gt;buffer[index], &amp;amp;input[i], inputlen -&lt;span&gt; i);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SHA512Final(SHA512_CB *context, unsigned &lt;span&gt;char&lt;/span&gt; digest[&lt;span&gt;64&lt;/span&gt;&lt;span&gt;]) {
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;, padlen = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; bits[&lt;span&gt;16&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录字长信息&lt;/span&gt;
    index = (context-&amp;gt;count[&lt;span&gt;1&lt;/span&gt;] &amp;gt;&amp;gt; &lt;span&gt;3&lt;/span&gt;) &amp;amp; &lt;span&gt;0x7F&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字长除127(11111111)取余长度&lt;/span&gt;
    padlen = (index &amp;lt; &lt;span&gt;112&lt;/span&gt;) ? (&lt;span&gt;112&lt;/span&gt; - index) : (&lt;span&gt;240&lt;/span&gt; - index); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 补齐的字长&lt;/span&gt;
    SHA512Encode(bits, context-&amp;gt;count, &lt;span&gt;16&lt;/span&gt;&lt;span&gt;);
    SHA512Update(context, PADDING, padlen);
    SHA512Update(context, bits, &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;);
    SHA512Encode(digest, context&lt;/span&gt;-&amp;gt;state, &lt;span&gt;64&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SHA512Encode(unsigned &lt;span&gt;char&lt;/span&gt; *output, unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; *input, unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; len) {
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (j &amp;lt;&lt;span&gt; len)
    {
        output[j&lt;/span&gt;+&lt;span&gt;7&lt;/span&gt;] = input[i] &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;;
        output[j &lt;/span&gt;+ &lt;span&gt;6&lt;/span&gt;] = (input[i] &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0xFF:11111111&lt;/span&gt;
        output[j + &lt;span&gt;5&lt;/span&gt;] = (input[i] &amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;;
        output[j &lt;/span&gt;+ &lt;span&gt;4&lt;/span&gt;] = (input[i] &amp;gt;&amp;gt; &lt;span&gt;24&lt;/span&gt;) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;;
        output[j &lt;/span&gt;+ &lt;span&gt;3&lt;/span&gt;] = (input[i] &amp;gt;&amp;gt; &lt;span&gt;32&lt;/span&gt;) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;;
        output[j &lt;/span&gt;+ &lt;span&gt;2&lt;/span&gt;] = (input[i] &amp;gt;&amp;gt; &lt;span&gt;40&lt;/span&gt;) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;;
        output[j &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;] = (input[i] &amp;gt;&amp;gt; &lt;span&gt;48&lt;/span&gt;) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;;
        output[j] &lt;/span&gt;= (input[i] &amp;gt;&amp;gt; &lt;span&gt;56&lt;/span&gt;) &amp;amp; &lt;span&gt;0xFF&lt;/span&gt;&lt;span&gt;;
        i&lt;/span&gt;++&lt;span&gt;;
        j &lt;/span&gt;+= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
    }
}


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SHA512Decode(unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; *output, unsigned &lt;span&gt;char&lt;/span&gt; *input, unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; len) {
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (j &amp;lt;&lt;span&gt; len)
    {
        output[i] &lt;/span&gt;= ((unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)input[j+&lt;span&gt;7&lt;/span&gt;]) |&lt;span&gt;
                    ((unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)input[j + &lt;span&gt;6&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt;) |&lt;span&gt;
                    ((unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)input[j + &lt;span&gt;5&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;16&lt;/span&gt;) |&lt;span&gt;
                    ((unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)input[j + &lt;span&gt;4&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;) |&lt;span&gt;
                    ((unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)input[j + &lt;span&gt;3&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;32&lt;/span&gt;) |&lt;span&gt;
                    ((unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)input[j + &lt;span&gt;2&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;40&lt;/span&gt;) |&lt;span&gt;
                    ((unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)input[j + &lt;span&gt;1&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;48&lt;/span&gt;) |&lt;span&gt;
                    ((unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)input[j] &amp;lt;&amp;lt; &lt;span&gt;56&lt;/span&gt;&lt;span&gt;);
        i&lt;/span&gt;++&lt;span&gt;;
        j &lt;/span&gt;+= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SHA512Transform(unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; state[&lt;span&gt;8&lt;/span&gt;], unsigned &lt;span&gt;char&lt;/span&gt; block[&lt;span&gt;128&lt;/span&gt;&lt;span&gt;]) {
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; S[&lt;span&gt;8&lt;/span&gt;&lt;span&gt;];
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; W[&lt;span&gt;80&lt;/span&gt;&lt;span&gt;];
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; t0;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; t1;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n填充后(1024bits):\n0x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; index=&lt;span&gt;0&lt;/span&gt;;index&amp;lt;&lt;span&gt;128&lt;/span&gt;;index++&lt;span&gt;){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%02x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, block[index]);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把state的值复制给S&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;8&lt;/span&gt;; i++&lt;span&gt; )
    {
        S[i] &lt;/span&gt;=&lt;span&gt; state[i];
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将字符数组保存的编码转为unsigned long long&lt;/span&gt;
    SHA512Decode(W, block, &lt;span&gt;128&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;16&lt;/span&gt;; i &amp;lt; &lt;span&gt;80&lt;/span&gt;; i++&lt;span&gt; )
    {
        W[i] &lt;/span&gt;= Gamma1(W[i - &lt;span&gt;2&lt;/span&gt;]) + W[i - &lt;span&gt;7&lt;/span&gt;] + Gamma0(W[i - &lt;span&gt;15&lt;/span&gt;]) + W[i - &lt;span&gt;16&lt;/span&gt;&lt;span&gt;];
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;80&lt;/span&gt;; i += &lt;span&gt;8&lt;/span&gt;&lt;span&gt; )
    {
        Sha512Round(S[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;], S[&lt;span&gt;1&lt;/span&gt;], S[&lt;span&gt;2&lt;/span&gt;], S[&lt;span&gt;3&lt;/span&gt;], S[&lt;span&gt;4&lt;/span&gt;], S[&lt;span&gt;5&lt;/span&gt;], S[&lt;span&gt;6&lt;/span&gt;], S[&lt;span&gt;7&lt;/span&gt;], i + &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        Sha512Round(S[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;], S[&lt;span&gt;0&lt;/span&gt;], S[&lt;span&gt;1&lt;/span&gt;], S[&lt;span&gt;2&lt;/span&gt;], S[&lt;span&gt;3&lt;/span&gt;], S[&lt;span&gt;4&lt;/span&gt;], S[&lt;span&gt;5&lt;/span&gt;], S[&lt;span&gt;6&lt;/span&gt;], i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        Sha512Round(S[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;], S[&lt;span&gt;7&lt;/span&gt;], S[&lt;span&gt;0&lt;/span&gt;], S[&lt;span&gt;1&lt;/span&gt;], S[&lt;span&gt;2&lt;/span&gt;], S[&lt;span&gt;3&lt;/span&gt;], S[&lt;span&gt;4&lt;/span&gt;], S[&lt;span&gt;5&lt;/span&gt;], i + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
        Sha512Round(S[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;], S[&lt;span&gt;6&lt;/span&gt;], S[&lt;span&gt;7&lt;/span&gt;], S[&lt;span&gt;0&lt;/span&gt;], S[&lt;span&gt;1&lt;/span&gt;], S[&lt;span&gt;2&lt;/span&gt;], S[&lt;span&gt;3&lt;/span&gt;], S[&lt;span&gt;4&lt;/span&gt;], i + &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        Sha512Round(S[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;], S[&lt;span&gt;5&lt;/span&gt;], S[&lt;span&gt;6&lt;/span&gt;], S[&lt;span&gt;7&lt;/span&gt;], S[&lt;span&gt;0&lt;/span&gt;], S[&lt;span&gt;1&lt;/span&gt;], S[&lt;span&gt;2&lt;/span&gt;], S[&lt;span&gt;3&lt;/span&gt;], i + &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
        Sha512Round(S[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;], S[&lt;span&gt;4&lt;/span&gt;], S[&lt;span&gt;5&lt;/span&gt;], S[&lt;span&gt;6&lt;/span&gt;], S[&lt;span&gt;7&lt;/span&gt;], S[&lt;span&gt;0&lt;/span&gt;], S[&lt;span&gt;1&lt;/span&gt;], S[&lt;span&gt;2&lt;/span&gt;], i + &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
        Sha512Round(S[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;], S[&lt;span&gt;3&lt;/span&gt;], S[&lt;span&gt;4&lt;/span&gt;], S[&lt;span&gt;5&lt;/span&gt;], S[&lt;span&gt;6&lt;/span&gt;], S[&lt;span&gt;7&lt;/span&gt;], S[&lt;span&gt;0&lt;/span&gt;], S[&lt;span&gt;1&lt;/span&gt;], i + &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
        Sha512Round(S[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;], S[&lt;span&gt;2&lt;/span&gt;], S[&lt;span&gt;3&lt;/span&gt;], S[&lt;span&gt;4&lt;/span&gt;], S[&lt;span&gt;5&lt;/span&gt;], S[&lt;span&gt;6&lt;/span&gt;], S[&lt;span&gt;7&lt;/span&gt;], S[&lt;span&gt;0&lt;/span&gt;], i + &lt;span&gt;7&lt;/span&gt;&lt;span&gt;);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A:%I64u\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, S[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B:%I64u\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, S[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:%I64u\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, S[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:%I64u\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, S[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:%I64u\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, S[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:%I64u\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, S[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G:%I64u\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, S[&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;H:%I64u\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, S[&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Feedback&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;8&lt;/span&gt;; i++&lt;span&gt; )
    {
        state[i] &lt;/span&gt;= state[i] +&lt;span&gt; S[i];
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; input[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入字符串的十六进制: 0x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(unsigned &lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;strlen((&lt;span&gt;char&lt;/span&gt;*)input);i++&lt;span&gt;){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%02x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, input[i]);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; sha512Code[&lt;span&gt;64&lt;/span&gt;&lt;span&gt;];

    SHA512_CB sha512;

    SHA512Init(&lt;/span&gt;&amp;amp;&lt;span&gt;sha512);
    SHA512Update(&lt;/span&gt;&amp;amp;sha512, input, strlen((&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;)input));
    SHA512Final(&lt;/span&gt;&amp;amp;&lt;span&gt;sha512, sha512Code);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Md5加密后的32位结果&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n加密前:%s\n加密后128位:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, input);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;64&lt;/span&gt;; i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%02x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sha512Code[i]);
    }

    getchar();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 转载请注明出处。&lt;/p&gt;

</description>
<pubDate>Tue, 07 Nov 2017 15:35:00 +0000</pubDate>
<dc:creator>coding==1？</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jake9402/p/7801969.html</dc:identifier>
</item>
<item>
<title>React Native填坑之旅 -- 使用react-navigation代替Navigator - Mr 布鲁斯</title>
<link>http://www.cnblogs.com/sunshine-anycall/p/7801671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-anycall/p/7801671.html</guid>
<description>&lt;p&gt;&lt;code&gt;Navigator&lt;/code&gt;已经被React Native废弃了。也许你可以在另外的一个依赖库里&lt;a href=&quot;https://www.npmjs.com/package/react-native-deprecated-custom-components&quot;&gt;&lt;code&gt;react-native-deprecated-custom-components&lt;/code&gt;&lt;/a&gt;里找到。不过既然官方推荐的是&lt;a href=&quot;https://reactnavigation.org/&quot;&gt;&lt;code&gt;react-navigation&lt;/code&gt;&lt;/a&gt;那我们就来看看这个东西到底有什么好的，值不值得用。&lt;/p&gt;
&lt;p&gt;一句话概括的话，&lt;code&gt;react-navigation&lt;/code&gt;非常值得用。之前配置一个&lt;code&gt;Navigator&lt;/code&gt;非常的繁琐，但是使用&lt;code&gt;react-navigation&lt;/code&gt;的任何一个导航组件都非常简单。项目的github地址在&lt;a href=&quot;https://github.com/futurechallenger/react-native-tutorial&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;react-navigation&lt;/code&gt;包括下面三个Navigator：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;StackNavigator&lt;/code&gt;: 这个组件是用来代替之前的&lt;code&gt;Navigator&lt;/code&gt;的。凡是维持一种“先进后厨”的栈式导航的话就可以用这个。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TabNavigator&lt;/code&gt;：这个组件和iOS的`TabBarController。看起来是这样的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DrawerNavigator&lt;/code&gt;：这个组件就是抽屉式的导航菜单。在React Native里只有Android才有：&lt;code&gt;DrawerLayoutAndroid&lt;/code&gt;，在iOS里是没有的。有了&lt;code&gt;DrawerNavigator&lt;/code&gt;，两个平台都可以用了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我会在下文里主要介绍&lt;code&gt;StackNavigator&lt;/code&gt;和&lt;code&gt;DrawerNavigator&lt;/code&gt;。对于&lt;code&gt;TabNavigatgor&lt;/code&gt;它的使用非常简单，当你回了前面的两种的时候你就自然可以搞定它了。&lt;/p&gt;
&lt;h2 id=&quot;stack-navigator&quot;&gt;Stack Navigator&lt;/h2&gt;
&lt;p&gt;在&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;react-native init AwesomeProject&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令后生成的默认项目里，查看&lt;em&gt;index.js&lt;/em&gt;文件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; AppRegistry &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react-native'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; App &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./App'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;AppRegistry&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;registerComponent&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'AwesomeProject'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; App)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;APP开始执行后运行的就是&lt;code&gt;App&lt;/code&gt;组件。也就是&lt;em&gt;App.js&lt;/em&gt;文件export的是什么组件，App就运行什么组件。&lt;/p&gt;
&lt;p&gt;在&lt;em&gt;App.js&lt;/em&gt;文件中，去掉&lt;code&gt;export default&lt;/code&gt;。就如我们的demo做的一样，添加一个&lt;em&gt;MessageContainer.js&lt;/em&gt;文件，并添加demo中的内容。这样在其中我们已经有了&lt;code&gt;App&lt;/code&gt;、&lt;code&gt;MessageContainer&lt;/code&gt;两个组件。&lt;/p&gt;
&lt;p&gt;下面看下如何配置。&lt;/p&gt;
&lt;p&gt;最简单的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; NavHome &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;StackNavigator&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;Home&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; NavApp&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; MessageContainer&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导出&lt;code&gt;StackNavigator&lt;/code&gt;方法生成的组件&lt;code&gt;NavHome&lt;/code&gt;。运行起来之后，理论上就可以导航了。但是会有问题，因为这时还没有能够跳转的触发点。所以，我们还要做如下的修改。&lt;/p&gt;
&lt;p&gt;修改&lt;em&gt;App.js&lt;/em&gt;文件的内容。在其中添加一个按钮，点击之后可以进入到&lt;code&gt;MessageContainer&lt;/code&gt;组件。修改&lt;em&gt;MessageContainer.js&lt;/em&gt;文件，在里面添加一个按钮返回。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//App.js&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Button onPress&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;navigation&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;navigate&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Message'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; title&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'To message'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;//MessageContainer.js&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;Button onPress={this.props.navigation.goBack&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;} title={'Go Back'} /&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，这样还是demo的水平，离真正的产品级使用还差很多。一般的App，在push到下一个页面的时候会点击navigation bar的回退按钮返回上一页。我们就来实现这个功能。&lt;/p&gt;
&lt;p&gt;使我们首先看一下&lt;code&gt;StackNavigator&lt;/code&gt;的API：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;StackNavigator&lt;/span&gt;(RouteConfigs&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; StackNavigatorConfig)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过查看文档，要实现这个功能需要在&lt;code&gt;RouteConfigs&lt;/code&gt;里面增加&lt;code&gt;navigationOptions&lt;/code&gt;来达到。如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; NavHome &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;StackNavigator&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;Home&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; App&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;navigationOptions&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;navigation&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Home'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;headerLeft&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Button onPress&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;navigation&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;navigate&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'DrawerToggle'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; title&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'User'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;      headerRight: &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&amp;lt;Button onPress={&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; =&amp;gt; navigation.navigate&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'Message'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;} title={'Message'} /&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; MessageContainer&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;navigationOptions&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;navigation&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Message&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;headerLeft&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Button title&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'Back'&lt;/span&gt; onPress&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;navigation&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;goBack&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;}}&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    }&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  },&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细看一下&lt;code&gt;navigationOptions&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;title：是导航栏上显示的title。&lt;/li&gt;
&lt;li&gt;headerLeft： 是导航栏左侧的组件。我这里放了一个按钮。更好的是放置一个&lt;code&gt;TouchableOpacity&lt;/code&gt;组件。因为按钮在iOS上还好，但是在Android上就是一个明晃晃的按钮啊，各种边框和阴影。&lt;/li&gt;
&lt;li&gt;headerRight: 是导航栏右侧的组件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在&lt;code&gt;MessageContainer&lt;/code&gt;的导航栏上就只需要一个“返回”按钮，所以只有一个&lt;code&gt;headerLeft&lt;/code&gt;就足够了。在首页上的导航栏的&lt;code&gt;headerLeft&lt;/code&gt;是用来触发稍后讲到的&lt;code&gt;DrawerNavigator&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;这样，这个靠谱的导航就完成了。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;drawer-navigator&quot;&gt;Drawer Navigator&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DrawerNavigator&lt;/code&gt;和&lt;code&gt;StackNavigator&lt;/code&gt;的配置很类似。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; NavApp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;DrawerNavigator&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;Home&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; App&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;MyWallet&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; MyWalletView&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;MyVoucher&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; MyVoucherView&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候看起来是这样的：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1453913-3b4e4d4a2f3937ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400&quot; alt=&quot;normal_drawer_nav_top.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是我想要的效果是这样的：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1453913-be945d8e3daa02d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400&quot; alt=&quot;drawer_top.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，文档里提供的一些简单的定制是不能完成这样的效果的。于是，我们查看文档，发现有办法直接替换掉默认的Drawer实现，非常简单：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; NavApp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;DrawerNavigator&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;Home&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; App&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; UserContainer&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;MyWallet&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; MyWalletView&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;MyVoucher&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; MyVoucherView&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;dt&quot;&gt;contentComponent&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; props &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;UserDrawer items&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;props&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看下API：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;DrawerNavigator&lt;/span&gt;(RouteConfigs&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; DrawerNavigatorConfig)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只要叫上&lt;code&gt;DrawerNavigatorConfig&lt;/code&gt;配置里的&lt;code&gt;contentComponent&lt;/code&gt;配置。也就是上面配置的第二个参数。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;dt&quot;&gt;contentComponent&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; props &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;UserDrawer items&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;props&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;contentComponent&lt;/code&gt;就是drawer的内容组件。这里我们用的是&lt;code&gt;UserDrawer&lt;/code&gt;组件，并把props传递了进去。&lt;/p&gt;
&lt;p&gt;这样我们想要的抽屉式菜单就实现了。&lt;/p&gt;
&lt;h2 id=&quot;stacknavigator和drawernavigator结合使用&quot;&gt;StackNavigator和DrawerNavigator结合使用&lt;/h2&gt;
&lt;p&gt;现在把这两个组件结合在一起使用。在首页上的导航栏里的两个按钮，左侧的开启drawer导航，右侧的是“message”按钮，使用StackNavigator组件导航。&lt;/p&gt;
&lt;p&gt;如果是在drawer导航里使用&lt;code&gt;StackNavigator&lt;/code&gt;的话，那么只要这样配置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; NavHome &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;StackNavigator&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;Home&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; NavApp&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;navigationOptions&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;navigation&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Home'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;headerLeft&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Button onPress&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;navigation&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;navigate&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'DrawerToggle'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; title&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'User'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;      headerRight: &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&amp;lt;Button onPress={&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; =&amp;gt; navigation.navigate&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'Message'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;} title={'Message'} /&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; MessageContainer&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;navigationOptions&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;navigation&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Message&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;headerLeft&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Button title&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'Back'&lt;/span&gt; onPress&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;navigation&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;goBack&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;}}&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    }&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  },&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;export default NavApp = DrawerNavigator&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  Home: {&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    screen: NavHome, // &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;***&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  },&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  MyWallet: {&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    screen: MyWalletView,&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  },&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  MyVoucher: {&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    screen: MyVoucherView,&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  }&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;}, {&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;   contentComponent: props =&amp;gt; &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&amp;lt;UserDrawer items={props} /&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要在Drawer导航里用stack导航，那么就在drawer导航里的某个路由选项里加上&lt;code&gt;screen: NavHome&lt;/code&gt;。这个&lt;code&gt;NavHome&lt;/code&gt;就是stack导航。反之，则是在stack导航里的某个route选项的screen上指定drawer导航。&lt;/p&gt;
&lt;p&gt;但是在使用上还是有一点区别的。如果drawer导航里包含stack导航。那么drawer导航菜单的最高点是在屏幕的最高点。反之，如果drawer导航被stack导航包含的话，drawer导航菜单的最高点是在导航栏的下方的。如图：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1453913-e68d4547d28393ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400&quot; alt=&quot;drawer导航包含stack导航&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1453913-9f3d95ef956724a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400&quot; alt=&quot;drawer导航被stack导航包含&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到正题。从drawer导航菜单跳转到任何的页面后如何跳转回来呢？还是老方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyWalletView &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;TouchableOpacity 
        style&lt;span class=&quot;op&quot;&gt;={{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;flex&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;justifyContent&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'center'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;alignItems&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'center'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}}&lt;/span&gt;
        onPress&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;navigation&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;goBack&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Text&lt;span class=&quot;op&quot;&gt;&amp;gt;{&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'My Wallet'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/Text&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;      &amp;lt;/TouchableOpacity&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
    )&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用props传入的navigation的方法来实现返回：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;navigation&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;goBack&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;更多请看代码吧。留下来&lt;code&gt;TabNavigator&lt;/code&gt;来给各位读者朋友实践一下练练手吧。其实配置的简单程度比早前React Native里的Navigator已经降低了很多了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StackNavigator&lt;/code&gt;里还有除了&lt;code&gt;navigate()&lt;/code&gt;和&lt;code&gt;goBack()&lt;/code&gt;两个方法之外，还有其他的一些方法可以调用。实际的App交互中也并不是只有导航到某一页，然后再从那一页跳转回来这么简单。后面有机会会讲到这方面的内容。&lt;/p&gt;
</description>
<pubDate>Tue, 07 Nov 2017 14:55:00 +0000</pubDate>
<dc:creator>Mr 布鲁斯</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-anycall/p/7801671.html</dc:identifier>
</item>
<item>
<title>python正则表达式 - 小破孩92</title>
<link>http://www.cnblogs.com/miqi1992/p/7801662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miqi1992/p/7801662.html</guid>
<description>&lt;blockquote readability=&quot;3.5&quot;&gt;
&lt;p&gt;本篇将介绍python正则表达式，更多内容请参考：&lt;a href=&quot;http://www.cnblogs.com/miqi1992/p/7801662.html&quot;&gt;【python正则表达式】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是正则表达式&quot;&gt;什么是正则表达式&lt;/h3&gt;
&lt;p&gt;正则表达式，又称规则表达式，通常被用来检索、替换那些符合某个模式（规则）的文本。&lt;br/&gt;正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一些过滤逻辑。&lt;br/&gt;&lt;strong&gt;给定一个正则表达式和另一个字符串，我们可以达到如下的目的：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给定的字符串是否符合正则表达式的过滤逻辑(“匹配”)&lt;/li&gt;
&lt;li&gt;通过正则表达式，从文本字符串中获取到我们想要的特定部分（“过滤”）&lt;br/&gt;&lt;img src=&quot;http://oyl9rg5dr.bkt.clouddn.com//image/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%87%E7%A8%8B.png&quot; alt=&quot;正则表达式过程&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;正则表达式匹配规则&quot;&gt;正则表达式匹配规则&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://oyl9rg5dr.bkt.clouddn.com//image/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99.png&quot; alt=&quot;正则表达式匹配规则&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;python的re模块&quot;&gt;Python的re模块&lt;/h3&gt;
&lt;p&gt;在python中，我们可以使用内置的re模块来使用正则表达式。&lt;br/&gt;有一点需要特别注意的是，正则表达式使用对特殊字符进行转义，所以如果我们要使用原始字符串，只需要一个r前缀，示例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;r'chuanzhiboke\t\.\tpython'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;re模块的一般使用步骤如下&quot;&gt;re模块的一般使用步骤如下：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;compile()&lt;/code&gt;函数将正则表达式的字符串形式编译为一个&lt;code&gt;Pattern&lt;/code&gt;对象&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Pattern&lt;/code&gt;对象提供的一系列方法将文本进行匹配查找，获得匹配结果(一个Match对象)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;最后使用&lt;code&gt;Match&lt;/code&gt;对象提供的属性和方法获得信息，根据需要进行其他的操作。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;compile对象&quot;&gt;compile对象&lt;/h4&gt;
&lt;p&gt;compile函数用于编译正则表达式，生成一个Pattern对象，它的一般使用形式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re

&lt;span class=&quot;co&quot;&gt;#将正则表达式编译为Pattern对象&lt;/span&gt;
pattern &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'\d+'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面，我们已将一个正则表达式编译成Pattern对象，接下来，我们就可以利用pattern的一系列方法对文本进行匹配查找了。&lt;br/&gt;Pattern对象的一些常用方法主要有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;match对象：从起始位置开始查找，一次匹配。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;search对象：从任何位置开始查找，一次匹配。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;findall()对象：全部匹配，返回列表。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;finditer()对象：全部匹配，返回迭代器。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;spilt()对象：分割字符串，返回列表&lt;/li&gt;
&lt;li&gt;sub()对象：替换&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;match 方法&lt;/strong&gt;&lt;br/&gt;match方法用于查找字符串的头部(也可以指定起始位置)，它是一次匹配，只要找到了一个匹配的结果返回，而不是查找所有匹配的结果，它的一般使用形式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;match(string[, pos[, endpos]])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，string是待匹配的字符串，pos和endpos是可选参数，指定字符串的起始和终点位置，默认值分别是0和len(字符串长度)。因此，当你不指定pos和endpos时，match方法默认匹配字符串的头部。&lt;/p&gt;
&lt;p&gt;当匹配成功时，返回一个Match对象，如果没有匹配上，则返回None。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;pattern &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'\d+'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;#用于匹配至少一个数字&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.match(&lt;span class=&quot;st&quot;&gt;'one12twothree34four'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;#查找头部，没有匹配&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(m) &lt;span class=&quot;co&quot;&gt;#如果没有匹配上，就什么也不输出&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.match(&lt;span class=&quot;st&quot;&gt;'one12twothree34four'&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;#从'e'的位置开始匹配，没有匹配到&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(m)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.match(&lt;span class=&quot;st&quot;&gt;'one12twothree34four'&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;#从'1' 的位置开始匹配，正好匹配上&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(m)
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;_sre.SRE_Match &lt;span class=&quot;bu&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;bn&quot;&gt;0x10a42aac0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.group(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;#可忽略0&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;'12'&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.start(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;#可忽略0&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.end(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)    &lt;span class=&quot;co&quot;&gt;#可忽略0&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.span(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;#可忽略0&lt;/span&gt;
(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面，当匹配成功时返回一个Match对象，其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;group([group1,...])方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配字符串的子串时，可直接使用group()或group(0);&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;start([group])方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引）,参数默认值为0；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;end([group])方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1）,参数默认值是0&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;span([group])方法返回(start[group], end(group))&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;pattern &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'([a-z]+) （[a-z]+)'&lt;/span&gt;, re.I) &lt;span class=&quot;co&quot;&gt;#表示忽略大小写&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.match(&lt;span class=&quot;st&quot;&gt;'hello world wide web'&lt;/span&gt;)

&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(m)  &lt;span class=&quot;co&quot;&gt;#匹配成功，返回一个Match对象&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;_sre.SRE_Match &lt;span class=&quot;bu&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;bn&quot;&gt;0x10bea83e8&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.group(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;#返回匹配成功的整个子串&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;'Hello World'&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.span(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;#返回匹配成功的整个子串&lt;/span&gt;
(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;)

&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.group(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;#返回第一个分组匹配成功的子串&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;'Hello'&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.span(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;#返回第一个分组匹配成功&lt;/span&gt;
(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)

&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.group(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;#返回第2个分组匹配成功的子串&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;'World'&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.span(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)     &lt;span class=&quot;co&quot;&gt;#返回第2个分组匹配成功的子串的位置&lt;/span&gt;
(&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;)

&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.groups()   &lt;span class=&quot;co&quot;&gt;#等价于(m.group(1), m.group(2), ...)&lt;/span&gt;
(&lt;span class=&quot;st&quot;&gt;'Hello'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'World'&lt;/span&gt;)

&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.group(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;#不存在第3个分组&lt;/span&gt;
Traceback (most recent call last):
  File &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;module&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;pp&quot;&gt;IndexError&lt;/span&gt;: no such group&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;search方法&lt;/strong&gt;&lt;br/&gt;search方法用于查找字符串的任何位置，它也是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果，它的一般使用形式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;search[string[, pos[, endpos]]]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，string是待匹配的字符串，pos和endpos是可选参数，指定字符串的起始和终点位置，默认值分别是0和len(字符串长度)。&lt;br/&gt;当匹配成功时，返回一个Match对象，如果没有匹配上，则返回None。&lt;br/&gt;让我们看看例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;pattern &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'\d+'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.search(&lt;span class=&quot;st&quot;&gt;'one12twothree34four'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;#这里如果使用match方法则不匹配&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;_sre.SRE_Match &lt;span class=&quot;bu&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;bn&quot;&gt;0x10cc03ac0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.group()
&lt;span class=&quot;co&quot;&gt;'12'&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.search(&lt;span class=&quot;st&quot;&gt;'one12twothree34four'&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;#指定字符串区间  &lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;_sre.SRE_Match &lt;span class=&quot;bu&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;bn&quot;&gt;0x10cc03b28&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.group()
&lt;span class=&quot;co&quot;&gt;'34'&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;m.span()
(&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在看一个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# coding:utf-8&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
&lt;span class=&quot;co&quot;&gt;#将正则表达式编译成Pattern对象&lt;/span&gt;
pattern &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'\d+'&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;#使用search()方法查找匹配的字符串，不存在匹配的子串时将不返回&lt;/span&gt;
m &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.search(&lt;span class=&quot;st&quot;&gt;'hello 123456 789'&lt;/span&gt;)
&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; m:
    &lt;span class=&quot;co&quot;&gt;#使用Match获得分组信息&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'matching string：'&lt;/span&gt;,m.group())
    &lt;span class=&quot;co&quot;&gt;#起始位置和结束位置&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'position: '&lt;/span&gt;,m.span())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;matching string: &lt;span class=&quot;dv&quot;&gt;123456&lt;/span&gt;
position:(&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;findall 方法&lt;/strong&gt;&lt;br/&gt;上面的match和search方法都是一次匹配，只要找到了一个匹配的结果就返回。然而，在大多数时候，我们需要搜索整个字符串，获得所有匹配的结果。&lt;br/&gt;findall方法的使用形式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;findall(string[, pos[, endpos]])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，string是待匹配的字符串，pos和endpos是可选参数，指定字符串的起始和终点位置分别是0和len(字符串长度)。&lt;br/&gt;findall是以列表形式返回全部能匹配到的子串，如果没有匹配，则返回一个空列表。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
pattern &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'\d+'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;#查找数字&lt;/span&gt;

result1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.findall(&lt;span class=&quot;st&quot;&gt;'hello 123456 789'&lt;/span&gt;)
result2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.findall(&lt;span class=&quot;st&quot;&gt;'one1two2three3four4'&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)

&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(result1)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;[&lt;span class=&quot;st&quot;&gt;'123456'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'789'&lt;/span&gt;]
[&lt;span class=&quot;st&quot;&gt;'1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'2'&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看一个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
&lt;span class=&quot;co&quot;&gt;#re模块提供一个方法叫compile提供，提供我们输入一个匹配的规则&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#然后返回一个pattern实例，我们根据这个规则去匹配字符串&lt;/span&gt;
pattern &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'd+\.\d*'&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;#通过pattern.findall()方法能够全部匹配到我们得到的字符串&lt;/span&gt;
result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.findall(&lt;span class=&quot;st&quot;&gt;&quot;123.141593, 'bigcat', 232312, 3.15&quot;&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;#findall以列表形式 返回全部能匹配到的子串给result&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; result:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(item)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;fl&quot;&gt;123.141593&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;3.15&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;finditer方法&lt;/strong&gt;&lt;br/&gt;finditer方法的行为跟findall的行为类似，也是搜索整个字符串，获得所有匹配的结果。但它返回一个顺序访问每一个匹配结果(Match对象)的迭代器。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;#coding:utf-8&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re

pattern &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'\d+'&lt;/span&gt;)

result1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.finditer(&lt;span class=&quot;st&quot;&gt;'hello 123456 789'&lt;/span&gt;)
result2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.finditer(&lt;span class=&quot;st&quot;&gt;'one1two2three3four4'&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(result1)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(result2)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'result1....'&lt;/span&gt;)
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; m1 &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; result1:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;matching string:{} position:{}&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(m1.group(), m1.span()))

&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'result2....'&lt;/span&gt;)
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; m2 &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; result2:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;matching string:{} position:{}&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(m2.group(), m2.span()))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'callable-iterator'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'callable-iterator'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
result1.
matching string: &lt;span class=&quot;dv&quot;&gt;123456&lt;/span&gt;, position: (&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;)
matching string: &lt;span class=&quot;dv&quot;&gt;789&lt;/span&gt;, position: (&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)
result2
matching string: &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, position: (&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)
matching string: &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, position: (&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;split 方法&lt;/strong&gt;&lt;br/&gt;split方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;split(string[, maxsplit])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，maxsplit用于指导最大分割次数，不知道静全部分割。&lt;br/&gt;看看例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
p &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'[\s\,;]+'&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(p.split(&lt;span class=&quot;st&quot;&gt;'a,b;;c   d'&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;[&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'c'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'d'&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;sub方法&lt;/strong&gt;&lt;br/&gt;sub方法用于替换。它的使用形式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;sub(repl, string[, count])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，repl可以是字符串也可以是一函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果repl是字符串，则会使用repl去替换字符串每一个匹配的子串，并返回替换后的字符串，repl还可以使用id的形式来引用过分组，但不能使用编号0；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果repl是函数，这个方法应当只接受一个参数(Match对象)，并返回一个字符串用于替换(返回的字符串中不能再引用分组)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;count用于指导最多替换次数，不指定时全部替换。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看看例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
p &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;r'(\w+) (\w+)'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;#\w=[A-Za-z0-9]&lt;/span&gt;
s &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'hello 123, hello 456'&lt;/span&gt;

&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(p.sub(&lt;span class=&quot;vs&quot;&gt;r'hello world'&lt;/span&gt;, s))   &lt;span class=&quot;co&quot;&gt;#使用'hello world'替换'hello 123'和'hello 456'&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(p.sub(&lt;span class=&quot;vs&quot;&gt;r'\2 \1'&lt;/span&gt;, s))

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; func(m):
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'hi'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;' '&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; m.group(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)

&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(p.sub(func, s))
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(p.sub(func, s, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;hello world, hello world
&lt;span class=&quot;dv&quot;&gt;123&lt;/span&gt; hello, &lt;span class=&quot;dv&quot;&gt;456&lt;/span&gt; hello
hi &lt;span class=&quot;dv&quot;&gt;123&lt;/span&gt;, hi &lt;span class=&quot;dv&quot;&gt;456&lt;/span&gt;
hi &lt;span class=&quot;dv&quot;&gt;123&lt;/span&gt;, hello &lt;span class=&quot;dv&quot;&gt;456&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;匹配中文&lt;/strong&gt;&lt;br/&gt;在某些情况下，我们想要匹配文本中的汉字，有一点需要注意的是，中文的unicode编码范围主要在[u4e00-u9fa5]，这里说主要是因为这个范围并不完整，比如没有包括全角(中文)标点，不过，在大部分情况下，应该是够用的。&lt;br/&gt;假设现在想把字符串title=u'你好，hello，世界'中的中文提取出来，可以这么做：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
title &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;u'你好，hello，世界'&lt;/span&gt;
pattern &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;u'[\u4e00-\u9fa5]+'&lt;/span&gt;)
result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pattern.findall(title)

&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(result)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到，我们在正则表达式前面加上了前缀u，u表示unicode字符串。&lt;br/&gt;执行结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;[&lt;span class=&quot;st&quot;&gt;'你好'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'世界'&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：贪婪模式与非贪婪模式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;贪婪模式：在整个表达式匹配成功的前提下，尽可能多的匹配(*);&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;非贪婪模式：在整个表达式匹配成功的前提下，尽可能少的匹配(?);&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python里数量词默认是贪婪的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;实例一源字符串abbbc&quot;&gt;实例一：源字符串：&lt;code&gt;abbbc&lt;/code&gt;&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用贪婪的数量词的正则表达式&lt;code&gt;ab+&lt;/code&gt;,匹配结果：abbb。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;*决定了尽可能多匹配b，所以a后面所有的b都出现了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;使用非贪婪的数量词的正则表达式&lt;code&gt;ab*?&lt;/code&gt;，匹配结果：a。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;即使前面有&lt;code&gt;*&lt;/code&gt;,但是&lt;code&gt;?&lt;/code&gt;决定了尽可能少匹配b，所以没有b。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;实例二源字符串aadivtest1divbbdivtest2divcc&quot;&gt;实例二：源字符串：&lt;code&gt;aa&amp;lt;div&amp;gt;test1&amp;lt;/div&amp;gt;bb&amp;lt;div&amp;gt;test2&amp;lt;/div&amp;gt;cc&lt;/code&gt;&lt;/h4&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://tool.oschina.net/regex/&quot;&gt;正则表达式测试网址&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143193331387014ccd1040c814dee8b2164bb4f064cff000&quot;&gt;廖雪峰-正则表达式&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/silence2015/article/details/60321873&quot;&gt;Python正则匹配中文与编码总结&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 07 Nov 2017 14:53:00 +0000</pubDate>
<dc:creator>小破孩92</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/miqi1992/p/7801662.html</dc:identifier>
</item>
<item>
<title>让盒子两端对齐小技巧 =&gt; inline-block - queen_live</title>
<link>http://www.cnblogs.com/queen-live/p/7795727.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/queen-live/p/7795727.html</guid>
<description>&lt;div readability=&quot;43&quot;&gt;
&lt;pre&gt;
今天在项目中碰到了设计盒子两端对齐的栗子，咱们用inline-block方法轻松的解决了，下面是我的经验：&lt;br/&gt;　　原理： 利用文字text-align：justify; 操纵inline-block盒子，能够实现盒子两端对齐。&lt;br/&gt;&lt;/pre&gt;
&lt;pre&gt;
　　说明： inline-block元素 会按照基线对齐的方式两列，给这个元素的父盒子设置一个text-align：justify； 即可实现两端对齐的功能
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;盒子两端对齐&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        * &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        html,body &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        .box &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置元素两端对齐 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; justify&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里的伪元素一定要加上，不然span元素不能两端对齐 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        .box:after &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &quot;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; inline-block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            overflow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; hidden&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        .box span &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置盒子为行内块 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; inline-block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; skyblue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置盒子内元素水平居中 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置盒子内容垂直居中 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;br/&gt;　　　&lt;br/&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt; 
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;&amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;盒子两端对齐&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;&lt;br/&gt;* {&lt;br/&gt;margin: 0;&lt;br/&gt;padding: 0;&lt;br/&gt;}&lt;br/&gt;html,body {&lt;br/&gt;width: 100%;&lt;br/&gt;height: 100%;&lt;br/&gt;}&lt;br/&gt;.box {&lt;br/&gt;width: 100%;&lt;br/&gt;height: 100%;&lt;br/&gt;/* 设置元素两端对齐 */&lt;br/&gt;text-align: justify;&lt;br/&gt;}&lt;br/&gt;/* 这里的伪元素一定要加上，不然span元素不能两端对齐 */&lt;br/&gt;.box:after {&lt;br/&gt;content: &quot;&quot;;&lt;br/&gt;display: inline-block;&lt;br/&gt;overflow: hidden;&lt;br/&gt;width: 100%;&lt;br/&gt;}&lt;br/&gt;.box span {&lt;br/&gt;width: 50px;&lt;br/&gt;height: 50px;&lt;br/&gt;/* 设置盒子为行内块 */&lt;br/&gt;display: inline-block;&lt;br/&gt;background-color: skyblue;&lt;br/&gt;/* 设置盒子内元素水平居中 */&lt;br/&gt;text-align: center;&lt;br/&gt;/* 设置盒子内容垂直居中 */&lt;br/&gt;line-height: 50px;&lt;br/&gt;}&lt;br/&gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&lt;br/&gt;&amp;lt;span&amp;gt;1&amp;lt;/span&amp;gt;&lt;br/&gt;&amp;lt;span&amp;gt;2&amp;lt;/span&amp;gt;&lt;br/&gt;&amp;lt;span&amp;gt;3&amp;lt;/span&amp;gt;&lt;br/&gt;&amp;lt;span&amp;gt;4&amp;lt;/span&amp;gt;&lt;br/&gt;&amp;lt;span&amp;gt;5&amp;lt;/span&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
 
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 从小就喜欢看科幻片，特别是电影里面几行代码就能够获得，然后解救全世界的神秘的人，当然最感兴趣的就是代码本身了&lt;/p&gt;</description>
<pubDate>Tue, 07 Nov 2017 14:21:00 +0000</pubDate>
<dc:creator>queen_live</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/queen-live/p/7795727.html</dc:identifier>
</item>
<item>
<title>hook in PostgreSQL初探 - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/7801258.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/7801258.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;众所周知，PostgreSQL具有很好的扩展性，是一个可以&quot;开发&quot;的数据库。在PostgreSQL里面，你可以定制你自己的Types、Function、Operation，支持各种过程语言等等。还可以依据自己的喜好修改源码增加新功能。为方便扩展，PostgreSQL提供了很多有用的API、头文件扩展文件夹等等。然而其中一个很重要hook机制却不是特别为人所知，今天我们就来学习下PostgreSQL的hook机制。&lt;/p&gt;
&lt;p&gt;hook机制来源于Windows平台。钩子(Hook)，是Windows消息处理机制的一个平台,应用程序可以在上面设置子程以监视指定窗口的某种消息，当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;常用的hook&quot;&gt;1.常用的hook&lt;/h2&gt;
&lt;p&gt;PostgreSQL中提供了很多种hook，与上面提到的类似，但是更多的是中断和替换操作。更重要的是该机制提供了一种修改PostgreSQL内核功能却不必修改内核代码的手段，且可以轻松的加载和还原。&lt;br/&gt;首先我们还是看下PostgreSQL中都有哪些常用的hook吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/579102/201711/579102-20171107215123981-1661015772.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他的还有这些：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/579102/201711/579102-20171107215210466-1434757530.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;内部机制&quot;&gt;2.内部机制&lt;/h2&gt;
&lt;p&gt;所有的hook都和一个全局函数指针相关。在初始时该函数指针被设置为NULL，表示hook未被使用，当PostgreSQL执行到hook处的时候，如果hook为NULL它什么额外的事情也不做，但是如果hook被设置为某个函数的地址时(当然是你增加的那个函数了，通常是做成一个共享库咯)，程序就开始转向你的新增函数中，执行你所期望的各种新功能啦。&lt;/p&gt;
&lt;p&gt;那么问题来了，如何设置hook连接到你设置的共享库呢？PostgreSQL的配置文件中给出了shared_preload_libraries参数来加载你的共享库(当然了，设置完是需要重启的)。那么问题就又回到了：如何写一个被PostgreSQL所接受的共享库呢？&lt;/p&gt;
&lt;p&gt;你至少要实现这三个函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_PG_init()
your_hook_function()
_PG_fini()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们慢慢说。&lt;/p&gt;
&lt;p&gt;首先，当PostgreSQL加载共享库(create extension xxxx)时，它需要把共享库加载到内存中。这时需要你写一个_PG_init函数，这种函数你在PostgreSQL源码的contrib目录下很容易找到，大概就像下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_PG_init()
{
    prev_ExecutorRun_hook = ExecutorRun_hook;
    ExecutorRun_hook = your_function_hook;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存当前的hook值(保证你移除修改后能够还原)，并将你的hook挂在到PostgreSQL的hook函数指针上。&lt;/p&gt;
&lt;p&gt;那么与之相对应的，你要写一个_PG_fini函数在卸载(drop extension xxxx)的时候使用,也就是移除你的hook并且把它重置为之前的指针值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_PG_fini()
{
    ExecutorRun_hook = prev_ExecutorRun_hook;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个函数加上你的hook函数（your_hook_function()）就构成了最基础的PostgreSQL的hook了。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;举例说明&quot;&gt;3.举例说明&lt;/h2&gt;
&lt;p&gt;下面我们以上面提到的ClientAuthentication_hook举例说明吧。&lt;br/&gt;这个hook的作用是帮助你在client得到验证之后并且服务端还未给client反馈的时候运行你的代码(contrib目录下的auth_delay和sepgsql使用了这个hook)。&lt;br/&gt;首先，这个hook指针声明在&lt;br/&gt;src/include/libpq/auth.h, line 27&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* Hook for plugins to get control in ClientAuthentication() */
typedef void (*ClientAuthentication_hook_type) (Port *, int);
extern PGDLLIMPORT ClientAuthentication_hook_type ClientAuthentication_hook;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的调用点，也就是hook所在的位置是：&lt;/p&gt;
&lt;p&gt;src/backend/libpq/auth.c, line 215&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
* This hook allows plugins to get control following client authentication,
* but before the user has been informed about the results. It could be used
* to record login events, insert a delay after failed authentication, etc.
*/
ClientAuthentication_hook_type ClientAuthentication_hook = NULL;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到该hook初始化为NULL。具体到函数里，它出现在：&lt;/p&gt;
&lt;p&gt;src/backend/libpq/auth.c, line 580&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (ClientAuthentication_hook)
 (*ClientAuthentication_hook) (port, status);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这很明显，就是如果你写好了一个ClientAuthentication_hook并且通过我们上面提到的方法把它挂到了ClientAuthentication_hook上，那么你的hook就会在这里被调用。&lt;/p&gt;
&lt;p&gt;对于ClientAuthentication_hook，我们看到他有两个入参，分别是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;port  PostGreSQL内部的一个Port结构体(定义在include/libpq/libpq-be.h)
Status  是PostgreSQL内部的状态码：STATUS_ERROR, STATUS_OK&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们写一个完整的extension吧，它的作用是 will deny connections if a specific file is present。&lt;/p&gt;
&lt;p&gt;首先写一个初始化函数初始化hook。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static ClientAuthentication_hook_type next_client_auth_hook = NULL;
/* Module entry point */
void
_PG_init(void)
{
 next_client_auth_hook = ClientAuthentication_hook;
 ClientAuthentication_hook = my_client_auth;
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很简单，我们先保存之前的hook值，在设置上我们自己的hook函数。&lt;br/&gt;记住，初始化必须要在_PG_init函数里面做，该函数在PostgreSQL加载你的共享库的时候被调用。&lt;/p&gt;
&lt;p&gt;然后就是咱们的hook函数，在这里你自由发挥，写下你想干的事儿，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void my_client_auth(Port *port, int status)
{
 struct stat buf;
 if (next_client_auth_hook)
    (*next_client_auth_hook) (port, status);
 if (status != STATUS_OK)
    return;
 if(!stat(&quot;/tmp/connection.stopped&quot;, &amp;amp;buf))
    ereport(FATAL, (errcode(ERRCODE_INTERNAL_ERROR),
        errmsg(&quot;Connection not authorized!!&quot;)));
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，如果之前已经设置过ClientAuthentication_hook的话，我们不妨大方的先让他做完好了，然后如果Client的Authentication都不OK的话(都没通过验证),那我们后面的deny操作不是多余么，那就return吧。最后，我们再做我们事：如果不存在connection.stopped文件，我们拒绝connection。Wow，很cool很上帝。&lt;/p&gt;
&lt;p&gt;最后，你再写一个_PG_fini咯：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_PG_fini(void)
{
 ClientAuthentication_hook = next_client_auth_hook;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自此，c文件里面的活我们干完了。剩下的我们写这几个文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Makefile
your_extension--1.0.control
your_extension--1.0.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，对于Makefile我们知道是用来编译c程序的。它大概是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MODULE_big = your_hook
OBJS = your_hook.o
ifdef USE_PGXS
PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
else
subdir = contrib/your_hook
top_builddir = ../..
include $(top_builddir)/src/Makefile.global
include $(top_srcdir)/contrib/contrib-global.mk
endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常你是要在PostgreSQL的源码目录结构中编译它，这样你就要在contrib目录下建立你自己的&lt;br/&gt;目录(这一点可以参考该目录下的其他extension)，然后make。如果你不想在PostgreSQL的源码目录结构中&lt;br/&gt;编译它，of course，你可以使用PGXS选项，它定义在PostgreSQL的pg_config命令里。然后你就执行make USE_PGXS=1 吧。&lt;br/&gt;当然，你需要设置pg_config到你的PATH里面。&lt;br/&gt;编译完了之后，你就make install吧，把你的共享库装载到PostgreSQL的lib目录中去。&lt;/p&gt;
&lt;p&gt;而对于剩下的两个文件最后会被安装到PostgreSQL的share/extension目录下。&lt;/p&gt;
&lt;p&gt;your_extension--1.0.control里面主要是写一些控制信息，&lt;/p&gt;
&lt;p&gt;your_extension--1.0.sql用于创建一些你需要的数据库对象，比如表，触发器，函数等等。&lt;/p&gt;
&lt;p&gt;而这两个文件在这个简单的例子里暂时用不到。我们后面再细说。&lt;/p&gt;
&lt;p&gt;在这之后把你的共享库加入到Postgreql.conf文件的shared_preload_libraries中,重启数据库。&lt;/p&gt;
&lt;p&gt;然后你就尽情的用起来吧。&lt;/p&gt;
&lt;p&gt;这里说的比较简单，敬请期待第二部进阶版+_+&lt;/p&gt;
&lt;p&gt;参考文献：&lt;a href=&quot;http://wiki.postgresql.org/images/e/e3/Hooks_in_postgresql.pdf&quot; class=&quot;uri&quot;&gt;http://wiki.postgresql.org/images/e/e3/Hooks_in_postgresql.pdf&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Nov 2017 14:21:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/7801258.html</dc:identifier>
</item>
</channel>
</rss>