<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>apache ignite系列（五）：分布式计算 - 堕落门徒</title>
<link>http://www.cnblogs.com/cord/p/9431867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cord/p/9431867.html</guid>
<description>&lt;h3 id=&quot;ignite分布式计算&quot;&gt;ignite分布式计算&lt;/h3&gt;
&lt;p&gt;在ignite中，有传统的MapReduce模型的分布式计算，也有基于分布式存储的并置计算，当数据分散到不同的节点上时，根据提供的并置键，计算会传播到数据所在的节点进行计算，再结合数据并置，相关联的数据存储在相同节点，这样可以避免在计算过程中涉及到大量的数据移动，有效保证计算的性能。&lt;/p&gt;
&lt;p&gt;ignite分布式计算的主要特点如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;自动部署&lt;/td&gt;
&lt;td&gt;计算用到的类可以自动传播，而不需要在每个节点都部署相关的类，这个可以通过配置&lt;code&gt;peerClassLoadingEnabled&lt;/code&gt;选项开启计算类的自动传播，但是缓存的实体类是无法自动传播的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;平衡加载&lt;/td&gt;
&lt;td&gt;数据在加载之后会在集群中进行一个再平衡的过程，保证数据均匀分布在各个节点，当有计算在集群中执行的时候，可以根据提供的并置键定位到数据所在节点进行计算，也就是并置计算。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;故障转移&lt;/td&gt;
&lt;td&gt;当节点出现故障或者其它计算的时候，任务会自动转移到集群中的其他节点执行&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;分布式闭包&quot;&gt;1.分布式闭包:&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Ignite计算网格可以对集群或者集群组内的任何闭包进行广播和负载平衡，包括纯Java的&lt;code&gt;runnables&lt;/code&gt;和&lt;code&gt;callables&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;broadcast&lt;/td&gt;
&lt;td&gt;将任务传播到部分指定节点或者全部节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;call/run&lt;/td&gt;
&lt;td&gt;执行单个任务或者任务集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;apply&lt;/td&gt;
&lt;td&gt;apply接收一个闭包和一个集合作为参数，生成与参数数量等量的任务，每个任务分别是将闭包应用在其中一个参数上，并且会返回结果集。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;ComputeTestController.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    /** broadCast测试*/
    @RequestMapping(&quot;/broadcast&quot;)
    String broadcastTest(HttpServletRequest request, HttpServletResponse response) {
//        IgniteCompute compute = ignite.compute(ignite.cluster().forRemotes());  //只传播远程节点
        IgniteCompute compute = ignite.compute();
        compute.broadcast(() -&amp;gt; System.out.println(&quot;Hello Node: &quot; + ignite.cluster().localNode().id()));
        return &quot;all executed.&quot;;
    }

    /** call和run测试 */
    @RequestMapping(&quot;/call&quot;)
    public @ResponseBody
    String callTest(HttpServletRequest request, HttpServletResponse response) {
        Collection&amp;lt;IgniteCallable&amp;lt;Integer&amp;gt;&amp;gt; calls = new ArrayList&amp;lt;&amp;gt;();

        /** call */
        System.out.println(&quot;-----------call-----------&quot;);
        for(String word : &quot;How many characters&quot;.split(&quot; &quot;)) {
            calls.add(word::length);
//            calls.add(() -&amp;gt; word.length());
        }
        Collection&amp;lt;Integer&amp;gt; res = ignite.compute().call(calls);
        int total = res.stream().mapToInt(Integer::intValue).sum();
        System.out.println(String.format(&quot;the total lengths of all words is [%s].&quot;, total));

        /** run */
        System.out.println(&quot;-----------run-----------&quot;);
        for (String word : &quot;Print words on different cluster nodes&quot;.split(&quot; &quot;)) {
            ignite.compute().run(() -&amp;gt; System.out.println(word));
        }

        /** async call */
        System.out.println(&quot;-----------async call-----------&quot;);
        IgniteCompute asyncCompute =  ignite.compute().withAsync();
        asyncCompute.call(calls);
        asyncCompute.future().listen(fut -&amp;gt; {
            Collection&amp;lt;Integer&amp;gt; result = (Collection&amp;lt;Integer&amp;gt;)fut.get();
            int t = result.stream().mapToInt(Integer::intValue).sum();
            System.out.println(&quot;Total number of characters: &quot; + total);
        });

        /** async run */
        System.out.println(&quot;-----------async run-----------&quot;);
        Collection&amp;lt;ComputeTaskFuture&amp;lt;?&amp;gt;&amp;gt; futs = new ArrayList&amp;lt;&amp;gt;();
        asyncCompute = ignite.compute().withAsync();
        for (String word : &quot;Print words on different cluster nodes&quot;.split(&quot; &quot;)) {
            asyncCompute.run(() -&amp;gt; System.out.println(word));
            futs.add(asyncCompute.future());
        }
        futs.stream().forEach(ComputeTaskFuture::get);

        return &quot;all executed.&quot;;
    }

    /** apply测试 */
    @RequestMapping(&quot;/apply&quot;)
    public @ResponseBody
    String applyTest(HttpServletRequest request, HttpServletResponse response) {
        /** apply */
        System.out.println(&quot;-----------apply-----------&quot;);
        IgniteCompute compute = ignite.compute();
        Collection&amp;lt;Integer&amp;gt; res = compute.apply(
                String::length,
                Arrays.asList(&quot;How many characters&quot;.split(&quot; &quot;))
        );
        int total = res.stream().mapToInt(Integer::intValue).sum();
        System.out.println(String.format(&quot;the total lengths of all words is [%s].&quot;, total));

        /** async apply */
        IgniteCompute asyncCompute = ignite.compute().withAsync();
        res = asyncCompute.apply(
                String::length,
                Arrays.asList(&quot;How many characters&quot;.split(&quot; &quot;))
        );
        asyncCompute.future().listen(fut -&amp;gt; {
            int t = ((Collection&amp;lt;Integer&amp;gt;)fut.get()).stream().mapToInt(Integer::intValue).sum();
            System.out.println(String.format(&quot;Total number of characters: &quot; + total));
        });

        return &quot;all executed.&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mapreduce&quot;&gt;2. MapReduce:&lt;/h4&gt;
&lt;p&gt;在ignite中MapReduce的实现是&lt;code&gt;ComputeTask&lt;/code&gt;，其主要方法是map()和reduce()，map()可以控制任务映射到节点的过程，而reduce()则是对最终计算结果集的一个处理。&lt;code&gt;ComputeTask&lt;/code&gt;有两个主要实现&lt;code&gt;ComputeTaskAdapter&lt;/code&gt;和&lt;code&gt;ComputeTaskSplitAdapter&lt;/code&gt;, 主要的区别在于&lt;code&gt;ComputeTaskAdapter&lt;/code&gt;需要手动实现map()方法，而&lt;code&gt;ComputeTaskSplitAdapter&lt;/code&gt;可以自动映射任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ComputeTaskAdapter&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**ComputeTaskAdapter*/
    @RequestMapping(&quot;/taskMap&quot;)
    public @ResponseBody
    String taskMapTest(HttpServletRequest request, HttpServletResponse response) {
        /**ComputeTaskMap*/
        int cnt = ignite.compute().execute(MapExampleCharacterCountTask.class, &quot;Hello Ignite Enable World!&quot;);

        System.out.println(String.format(&quot;&amp;gt;&amp;gt;&amp;gt; Total number of characters in the phrase is %s.&quot;, cnt));

        return &quot;all executed.&quot;;
    }

    private static class MapExampleCharacterCountTask extends ComputeTaskAdapter&amp;lt;String, Integer&amp;gt; {
        /**节点映射*/
        @Override
        public Map&amp;lt;? extends ComputeJob, ClusterNode&amp;gt; map(List&amp;lt;ClusterNode&amp;gt; nodes, String arg) throws IgniteException {
            Map&amp;lt;ComputeJob, ClusterNode&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            Iterator&amp;lt;ClusterNode&amp;gt; it = nodes.iterator();
            for (final String word : arg.split(&quot; &quot;)) {
                // If we used all nodes, restart the iterator.
                if (!it.hasNext()) {
                    it = nodes.iterator();
                }
                ClusterNode node = it.next();
                map.put(new ComputeJobAdapter() {
                    @Override
                    public Object execute() throws IgniteException {
                        System.out.println(&quot;-------------------------------------&quot;);
                        System.out.println(String.format(&quot;&amp;gt;&amp;gt;&amp;gt; Printing [%s] on this node from ignite job.&quot;, word));
                        return word.length();
                    }
                }, node);
            }
            return map;
        }
        /**结果汇总*/
        @Override
        public Integer reduce(List&amp;lt;ComputeJobResult&amp;gt; results) throws IgniteException {
            int sum = 0;
            for (ComputeJobResult res : results) {
                sum += res.&amp;lt;Integer&amp;gt;getData();
            }
            return sum;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-------------------------------------
&amp;gt;&amp;gt;&amp;gt; Printing [Ignite] on this node from ignite job.
-------------------------------------
&amp;gt;&amp;gt;&amp;gt; Printing [World!] on this node from ignite job.
&amp;gt;&amp;gt;&amp;gt; Total number of characters in the phrase is 23.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ComputeTaskSplitAdapter&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**ComputeTaskSplitAdapter*/
    @RequestMapping(&quot;/taskSplit&quot;)
    public @ResponseBody
    String taskSplitTest(HttpServletRequest request, HttpServletResponse response) {
        /**ComputeTaskSplitAdapter(自动映射) */
        int result = ignite.compute().execute(SplitExampleDistributedCompute.class, null);
        System.out.println(String.format(&quot;&amp;gt;&amp;gt;&amp;gt; result: [%s]&quot;, result));

        return &quot;all executed.&quot;;
    }

    private static class SplitExampleDistributedCompute extends ComputeTaskSplitAdapter&amp;lt;String, Integer&amp;gt; {

        @Override
        protected Collection&amp;lt;? extends ComputeJob&amp;gt; split(int gridSize, String arg) throws IgniteException {
            Collection&amp;lt;ComputeJob&amp;gt; jobs = new LinkedList&amp;lt;&amp;gt;();
            jobs.add(new ComputeJobAdapter() {
                @Override
                public Object execute() throws IgniteException {
//                    IgniteCache&amp;lt;Long, Student&amp;gt; cache = Ignition.ignite().cache(CacheKeyConstant.STUDENT);
                    IgniteCache&amp;lt;Long, BinaryObject&amp;gt; cache = Ignition.ignite().cache(CacheKeyConstant.STUDENT).withKeepBinary();
                    /**普通查询*/
                    String sql_query = &quot;name = ? and email = ?&quot;;
//                    SqlQuery&amp;lt;Long, Student&amp;gt; cSqlQuery = new SqlQuery&amp;lt;&amp;gt;(Student.class, sql_query);
                    SqlQuery&amp;lt;Long, BinaryObject&amp;gt; cSqlQuery = new SqlQuery&amp;lt;&amp;gt;(Student.class, sql_query);
                    cSqlQuery.setReplicatedOnly(true).setArgs(&quot;student_54&quot;, &quot;student_54gmail.com&quot;);
//                  List&amp;lt;Cache.Entry&amp;lt;Long, Student&amp;gt;&amp;gt; result = cache.query(cSqlQuery).getAll();
                    List&amp;lt;Cache.Entry&amp;lt;Long, BinaryObject&amp;gt;&amp;gt; result = cache.query(cSqlQuery).getAll();
                    System.out.println(&quot;--------------------&quot;);
                    result.stream().map(x -&amp;gt; {
                        Integer studId = x.getValue().field(&quot;studId&quot;);
                        String name = x.getValue().field(&quot;name&quot;);
                        return String.format(&quot;name=[%s], studId=[%s].&quot;, name, studId);
                    }).forEach(System.out::println);
                    System.out.println(String.format(&quot;the query size is [%s].&quot;, result.size()));
                    return result.size();
                }
            });
            return jobs;
        }

        @Override
        public Integer reduce(List&amp;lt;ComputeJobResult&amp;gt; results) throws IgniteException {
            int sum = results.stream().mapToInt(x -&amp;gt; x.&amp;lt;Integer&amp;gt;getData()).sum();
            return sum;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;--------------------
name=[student_54], studId=[54].
the query size is [1].
&amp;gt;&amp;gt;&amp;gt; result: [1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MapReduce的局限性:&lt;/p&gt;
&lt;p&gt;MapReduce适合解决并行和批处理的场景，不适合串行，迭代和递归一类无法并行和分割任务的场景。&lt;/p&gt;
&lt;h5 id=&quot;分布式计算存在的问题以及注意点&quot;&gt;分布式计算存在的问题以及注意点&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;   在使用ignite的分布式计算功能的时候，如果用到了缓存, 并且缓存value不是平台类型(java基础类型)，则需要考虑反序列化的问题。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现有两种解决方案:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;em&gt;部署缓存实体类包到ignite节点&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缓存实体类得实现Serializable接口，&lt;u&gt;并且得指定serialVersionUID&lt;/u&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;serialVersionUID表示实体类的当前版本，每个实现Serializable接口的类都有，如果没有的设置该值，java序列化机制会帮你默认生成一个。最好在使用serializable接口时，设定serialVersionUID为某个值，不然当在传输的某一端修改实体类时，serialVersionUID会被虚拟机设置成一个新的值，造成两端的serialVersionUID不一致会发生异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Student implements Serializable {

    private static final long serialVersionUID = -5941489737545326242L;
    ....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将实体类打包成普通jar包，并放在$IGNITE_HOME/libs/路径下面:&lt;/p&gt;
&lt;p&gt;&lt;u&gt;注意：打包的时候不能打包成spring-boot的可执行包，要打包成普通jar包，这样相关类才能正常加载。当然如果集群里的节点均为应用节点，则可以不用考虑这个问题。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/564309/201808/564309-20180823232807163-1113327437.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; IgniteCache&amp;lt;Long, BinaryObject&amp;gt; cache = ignite.cache(&quot;student&quot;).withKeepBinary();
 BinaryObject obj = cache.get(k);  //获取二进制对象
 String name = obj.&amp;lt;String&amp;gt;field(&quot;name&quot;);  //读取二进制对象属性值&amp;lt;使用field方法&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;并置计算&quot;&gt;3.并置计算：&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;affinityCall(...)&lt;/code&gt;和&lt;code&gt;affinityRun(...)&lt;/code&gt;方法使作业和缓存着数据的节点位于一处，换句话说，给定缓存名字和关系键，这些方法会试图在指定的缓存中定位键所在的节点，然后在那里执行作业。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并置的两种类型以及区别:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;数据并置&lt;/td&gt;
&lt;td&gt;将相关的缓存数据并置到一起，确保其所有键会缓存在同一个节点上，避免节点间数据移动产生的网络开销。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;计算并置&lt;/td&gt;
&lt;td&gt;根据关系键和缓存名称，定位关系键所在节点，并在该节点执行作业单元。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/564309/201808/564309-20180823232826330-1445768498.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ComputeTestController.class&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**并置计算测试*/
    @RequestMapping(&quot;/affinity&quot;)
    public @ResponseBody
    String affinityTest(HttpServletRequest request, HttpServletResponse response) {

        /** affinityRun call */
        System.out.println(&quot;-----------affinityRun call-----------&quot;);
        IgniteCompute compute = ignite.compute();
//        IgniteCompute compute = ignite.compute(ignite.cluster().forRemotes());
        for(int key = 0; key &amp;lt; 100; key++) {
//            final long k = key;
            //生成随机k值
            final long k = IntStream.generate(() -&amp;gt; (int)(System.nanoTime() % 100)).limit(1).findFirst().getAsInt();
            compute.affinityRun(CacheKeyConstant.STUDENT, k, () -&amp;gt; {
                IgniteCache&amp;lt;Long, BinaryObject&amp;gt; cache = ignite.cache(CacheKeyConstant.STUDENT).withKeepBinary();
                BinaryObject obj = cache.get(k);
                if(obj!=null) {
                    System.out.println(String.format(&quot;Co-located[key= %s, value= %s]&quot;, k, obj.&amp;lt;String&amp;gt;field(&quot;name&quot;)));
                }
            });
        }

        IgniteCache&amp;lt;Long, BinaryObject&amp;gt; cache = ignite.cache(CacheKeyConstant.STUDENT).withKeepBinary();
        cache.forEach(lo -&amp;gt; compute.affinityRun(CacheKeyConstant.STUDENT, lo.getKey(), () -&amp;gt; {
            System.out.println(lo.getValue().&amp;lt;String&amp;gt;field(&quot;name&quot;));
        }));

        return &quot;all executed.&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;-----------affinityRun call-----------
student_495
student_496
student_498
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，ignite分布式计算完毕。&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 15:29:00 +0000</pubDate>
<dc:creator>堕落门徒</dc:creator>
<og:description>ignite分布式计算 在ignite中，有传统的MapReduce模型的分布式计算，也有基于分布式存储的并置计算，当数据分散到不同的节点上时，根据提供的并置键，计算会传播到数据所在的节点进行计算，再</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cord/p/9431867.html</dc:identifier>
</item>
<item>
<title>Java 多线程(二）之 Thread 优先级 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9527226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9527226.html</guid>
<description>&lt;h2 id=&quot;thread-中线程优先级相关属性&quot;&gt;Thread 中线程优先级相关属性&lt;/h2&gt;
&lt;p&gt;每个线程均有优先级，在 Thread 中， 与优先级对应的属性如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 线程的优先级属性
 */
private int priority;
/**
 * 线程所能拥有的最大优先级.
 */
public final static int MIN_PRIORITY = 1;

/**
 * 线程默认的优先级.
 */
public final static int NORM_PRIORITY = 5;

/**
 * 线程所能拥有的最大优先级.
 */
public final static int MAX_PRIORITY = 10;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;相关函数&quot;&gt;相关函数&lt;/h2&gt;
&lt;p&gt;在此只讨论 Thread 类中的。&lt;/p&gt;
&lt;h3 id=&quot;优先级初始化&quot;&gt;优先级初始化&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc) {
    // ....
    this.priority = parent.getPriority();
    setPriority(priority);
   // ....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;init() 函数对优先级进行了初始化。并调用 setPriority(priority) 函数进行设置。从中得知， 线程的优先级是继承于创建它的线程的。&lt;/p&gt;
&lt;h3 id=&quot;设置优先级&quot;&gt;设置优先级&lt;/h3&gt;
&lt;p&gt;在 init() 中， 除了给 this.priority 赋值， 还调用了 setPriority(priority) 函数， 因为在该函数内部还调用了一个 native 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final void setPriority(int newPriority) {
    ThreadGroup g;
    checkAccess();
    // 不能大于最大优先级 MAX_PRIORITY
    if (newPriority &amp;gt; MAX_PRIORITY || newPriority &amp;lt; MIN_PRIORITY) {
        throw new IllegalArgumentException();
    }
    if((g = getThreadGroup()) != null) {
        // 如比所属线程组的最大优先级还大， 则取线程组的最大优先级
        if (newPriority &amp;gt; g.getMaxPriority()) {
            newPriority = g.getMaxPriority();
        }
        setPriority0(priority = newPriority);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由代码可知， 设置的优先级不能大于最大优先级，也不能大于所在线程组的最高优先级&lt;/p&gt;
&lt;h3 id=&quot;获取优先级&quot;&gt;获取优先级&lt;/h3&gt;
&lt;p&gt;获取当前的优先级， 其实就是返回 priority 属性的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final int getPriority() {
    return priority;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上可知， 在 Thread 中， 线程的优先级有如下特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Java 线程的优先级从 1~10；&lt;/li&gt;
&lt;li&gt;Java 线程默认优先级是 5；&lt;/li&gt;
&lt;li&gt;Java 线程的优先级继承于创建它的线程。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;是不是感觉 2 和 3 有所矛盾呢？可以在后面的代码和结果中找答案。&lt;/p&gt;
&lt;h2 id=&quot;默认优先级&quot;&gt;默认优先级&lt;/h2&gt;
&lt;p&gt;先上代码来感受一下线程优先级的作用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadPriorityTest {
    class PrimeRun implements Runnable {
        public void run() {
            System.out.println(Thread.currentThread().getName() +&quot;::&quot;+
                    Thread.currentThread().getPriority());
            System.out.println(Thread.currentThread().getName() + &quot; Run begin&quot;);
            for (int i = 0; i &amp;lt; 10; i++) {
                System.out.println(Thread.currentThread().getName()+&quot;::&quot;+i);
            }
            System.out.println(Thread.currentThread().getName() + &quot; Run end&quot;);
        }
    }

    public void test(){
        System.out.println(Thread.currentThread().getName()+&quot; begin&quot;);
        Thread p4 = new Thread(new PrimeRun());
        Thread p6 = new Thread(new PrimeRun());
        p4.setName(&quot;P4&quot;);
        p6.setName(&quot;P6&quot;);
        p4.start();
        p6.start();
        System.out.println(Thread.currentThread().getName()+&quot; end&quot;);
    }

    public static void main(String[] args) {
        new ThreadPriorityTest().test();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 PrimeRun 类的 run() 方法中， 只是对 0 到 10 进行输出， 前面加上线程名字以识别。没有对线程进行设置， 按以上分析的 init() 方法可知， 优先级继承于 ThreadPriorityTest 中的优先级， 没进行设置优先级默认为 5。 输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180823231537178?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;输出&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 p4 和 p6 的线程优先级都是 5， 输出是无序的， P4 和 P6 交叉输出， 因此每次的结果都不一样。&lt;/p&gt;

&lt;p&gt;将线程中的优先级改一下， test() 函数变成如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void test(){
    System.out.println(Thread.currentThread().getName()+&quot; begin&quot;);
    Thread p4 = new Thread(new PrimeRun());
    Thread p6 = new Thread(new PrimeRun());
    p4.setName(&quot;P4&quot;);
    p4.setPriority(4);
    p6.setName(&quot;P6&quot;);
    p6.setPriority(6);
    p4.start();
    p6.start();
    System.out.println(Thread.currentThread().getName()+&quot; end&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在运行之后的输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018082323161222?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;设置优先级后输出&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到， P6 先于 P4 运行完。&lt;/p&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;但是（一般 「但是」 后面的东西都要注意）&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;优先级和操作系统及虚拟机版本相关。&lt;br/&gt;++优先级只是代表告知了 「线程调度器」该线程的重要度有多大。如果有大量线程都被堵塞，都在等候运&lt;br/&gt;行，调试程序会首先运行具有最高优先级的那个线程。然而，这并不表示优先级较低的线程不会运行（换言之，不会因为存在优先级而导致死锁）。若线程的优先级较低，只不过表示它被准许运行的机会小一些而已。++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此， 在实际的编码时， 认为高优先级一定先于低优先级的线程执行， 最后会出问题的。&lt;/p&gt;
&lt;h2 id=&quot;优先级继承&quot;&gt;优先级继承&lt;/h2&gt;
&lt;p&gt;而关于特点 2 和 3 的区别， 我们在第一次 test() 时， P4 和 P6 的优先级都是 5， 我们将函数改一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public void test(){
    Thread.currentThread().setPriority(10);
    System.out.println(Thread.currentThread().getName()+&quot; begin&quot;);
    Thread p4 = new Thread(new PrimeRun());
    Thread p6 = new Thread(new PrimeRun());
    p4.setName(&quot;P4&quot;);
    p6.setName(&quot;P6&quot;);
    p4.start();
    p6.start();
    System.out.println(Thread.currentThread().getName()+&quot; end&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在创建 P4 和 P6 之前将当前线程的优先级设置为 10， 并在 run() 中去掉一些无关的输出， 最后输入如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180823231643934?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;继承优先级&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 15:23:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>介绍了 Thread 类相关的优先级</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9527226.html</dc:identifier>
</item>
<item>
<title>参考KOA，5步手写一款粗糙的web框架 - cherryvsun</title>
<link>http://www.cnblogs.com/cherryvenus/p/9527211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cherryvenus/p/9527211.html</guid>
<description>&lt;p&gt;我经常在网上看到类似于&lt;code&gt;KOA VS express&lt;/code&gt;的文章，大家都在讨论哪一个好，哪一个更好。作为小白，我真心看不出他两who更胜一筹。我只知道，我只会跟着官方文档的start做一个DEMO，然后我就会宣称我会用KOA或者express框架了。但是几个礼拜后，我就全忘了。web框架就相当于一个工具，要使用起来，那是分分钟的事。毕竟人家写这个框架就是为了方便大家上手使用。但是这种生硬的照搬模式，不适合我这种理解能力极差的使用者。因此我决定扒一扒源码，通过官方API，自己写一个web框架，其实就相当于“抄”一遍源码，加上自己的理解，从而加深影响。不仅需要知其然，还要需要知其所以然。&lt;/p&gt;
&lt;p&gt;我这里选择KOA作为参考范本，只有一个原因！他非常的精简！核心只有4个js文件！基本上就是对createServer的一个封装。&lt;/p&gt;
&lt;p&gt;在开始解刨KOA之前，createServer的用法还是需要回顾下的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const http = require('http');
let app=http.createServer((req, res) =&amp;gt; {
    //此处省略其他操作
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.body=&quot;我是createServer&quot;;
    res.end('okay');
});
app.listen(3000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回顾了createServer，接下来就是解刨KOA的那4个文件了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;application.js
&lt;ul&gt;&lt;li&gt;这个js主要就是对createServer的封装，其中一个最主要的目的就是将他的callback分离出来，让我们可以通过&lt;code&gt;app.use(callback);&lt;/code&gt;来调用，其中&lt;code&gt;callback&lt;/code&gt;大概就是令大家闻风丧胆的中间件（middleWare）了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;request.js
&lt;ul&gt;&lt;li&gt;封装createServer中返回的req，主要用于读写属性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;response.js
&lt;ul&gt;&lt;li&gt;封装createServer中返回的res，主要用于读写属性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;context.js
&lt;ul&gt;&lt;li&gt;这个文件就很重要了，它主要是封装了request和response，用于框架和中间件的沟通。所以他叫上下文，也是有道理的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了～开始写框架咯～&lt;/p&gt;
&lt;p&gt;&lt;em&gt;仅分析大概思路，分析KOA的原理，所以并不是100%重现KOA。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文github地址：&lt;a href=&quot;https://github.com/nanaSun/myHTTP&quot;&gt;点我&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;step1-封装http.createserver&quot;&gt;step1 封装&lt;code&gt;http.createServer&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;先写一个初始版的&lt;code&gt;application&lt;/code&gt;，让程序先跑起来。这里我们仅仅实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;封装&lt;code&gt;http.createServer&lt;/code&gt;到myhttp的类&lt;/li&gt;
&lt;li&gt;将回调独立出来&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen&lt;/code&gt;方法可以直接用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;step1/application.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let http=require(&quot;http&quot;)
class myhttp{
    handleRequest(req,res){
        console.log(req,res)
    }
    listen(...args){
        // 起一个服务
        let server = http.createServer(this.handleRequest.bind(this));
        server.listen(...args)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这边的&lt;code&gt;listen&lt;/code&gt;完全和&lt;code&gt;server.listen&lt;/code&gt;的用法一摸一样，就是传递了下参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;友情链接&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://nodejs.cn/api/http.html#http_server_listen&quot;&gt;&lt;code&gt;server.listen&lt;/code&gt;的API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6解构赋值&lt;code&gt;...&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step1/testhttp.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let myhttp=require(&quot;./application&quot;)
let app= new myhttp()
app.listen(3000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;testhttp.js&lt;/code&gt;，结果打印出了&lt;code&gt;req&lt;/code&gt;和&lt;code&gt;res&lt;/code&gt;就成功了~&lt;/p&gt;
&lt;h2 id=&quot;step2-封装原生req和res&quot;&gt;step2 封装原生req和res&lt;/h2&gt;
&lt;p&gt;这里我们需要做的封装，所需只有两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取（get）req和res的内容&lt;/li&gt;
&lt;li&gt;修改（set）res的内容&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;step2/request.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let request={
    get url(){
        return this.req.url
    }
}
module.exports=request&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;step2/response.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let response={
    get body(){
        return this.res.body
    },
    set body(value){
        this.res.body=value
    }
}
module.exports=response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果po上代码，就是这么简单，需要的属性可以自己加上去。那么问题来这个&lt;code&gt;this&lt;/code&gt;指向哪里？？代码是很简单，但是这个指向，并不简单。&lt;/p&gt;
&lt;p&gt;回到我们的&lt;code&gt;application.js&lt;/code&gt;，让这个&lt;code&gt;this&lt;/code&gt;指向我们的myhttp的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step2/application.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class myhttp{
    constructor(){
        this.request=Object.create(request)
        this.response=Object.create(response)
    }
    handleRequest(req,res){
        let request=Object.create(this.request)
        let response=Object.create(this.response)
        request.req=req
        request.request=request
        response.req=req
        response.response=response
        console.log(request.headers.host,request.req.headers.host,req.headers.host)
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处，我们用&lt;code&gt;Object.create&lt;/code&gt;拷贝了一个副本，然后把request和response分别挂上，我们可以通过最后的一个测试看到，我们可以直接通过&lt;code&gt;request.headers.host&lt;/code&gt;访问我们需要的信息，而可以不用通过&lt;code&gt;request.req.headers.host&lt;/code&gt;这么长的一个指令。这为我们下一步，将&lt;code&gt;request&lt;/code&gt;和&lt;code&gt;response&lt;/code&gt;挂到&lt;code&gt;context&lt;/code&gt;打了基础。&lt;/p&gt;
&lt;h2 id=&quot;step3-context闪亮登场&quot;&gt;step3 &lt;code&gt;context&lt;/code&gt;闪亮登场&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;context&lt;/code&gt;的功能，我对他没有其他要求，就可以直接&lt;code&gt;context.headers.host&lt;/code&gt;，而不用&lt;code&gt;context.request.headers.host&lt;/code&gt;,但是我不可能每次新增需要的属性，都去写一个get/set吧？于是&lt;code&gt;Object.defineProperty&lt;/code&gt;这个神操作来了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step3/content.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let context = {
}
//可读可写
function access(target,property){
   Object.defineProperty(context,property,{
        get(){
            return this[target][property]
        },
        set(value){
            this[target][property]=value
        }
   })
}
//只可读
function getter(target,property){
   Object.defineProperty(context,property,{
        get(){
            return this[target][property]
        }
   })
}
getter('request','headers')
access('response','body')
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就可以方便地进行定义数据了，不过需要注意地是，&lt;code&gt;Object.defineProperty&lt;/code&gt;地对象只能定义一次，不能多次定义，会报错滴。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step3/application.js&lt;/strong&gt;&lt;br/&gt;接下来就是连接&lt;code&gt;context&lt;/code&gt;和&lt;code&gt;request&lt;/code&gt;和&lt;code&gt;response&lt;/code&gt;了，新建一个&lt;code&gt;createContext&lt;/code&gt;，将&lt;code&gt;response&lt;/code&gt;和&lt;code&gt;request&lt;/code&gt;颠来倒去地挂到&lt;code&gt;context&lt;/code&gt;就可了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class myhttp{
    constructor(){
        this.context=Object.create(context)
        ...
    }
    createContext(req,res){
        let ctx=Object.create(this.context)
        let request=Object.create(this.request)
        let response=Object.create(this.response)
        ctx.request=request
        ctx.response=response
        ctx.request.req=ctx.req=req
        ctx.response.res=ctx.res=res
        return ctx
    }
    handleRequest(req,res){
        let ctx=this.createContext(req,res)
        console.log(ctx.headers)
        ctx.body=&quot;text&quot;
        console.log(ctx.body,res.body)
        res.end(ctx.body);
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上3步终于把准备工作做好了，接下来进入正题。😭&lt;br/&gt;&lt;em&gt;友情链接：&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;step4-实现use&quot;&gt;step4 实现&lt;code&gt;use&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;这里我需要完成两个功能点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;use&lt;/code&gt;可以多次调用，中间件middleWare按顺序执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use&lt;/code&gt;中传入&lt;code&gt;ctx&lt;/code&gt;上下文，供中间件middleWare调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;想要多个中间件执行，那么就建一个数组，将所有地方法都保存在里头，然后等到执行的地时候forEach一下，逐个执行。传入的&lt;code&gt;ctx&lt;/code&gt;就在执行的时候传入即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step4/application.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class myhttp{
    constructor(){
        this.middleWares=[]
        ...
    }
    use(callback){
        this.middleWares.push(callback)
        return this;
    }
    ...
    handleRequest(req,res){
        ...
        this.middleWares.forEach(m=&amp;gt;{
            m(ctx)
        })
        ...
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处在&lt;code&gt;use&lt;/code&gt;中加了一个小功能，就是让use可以实现链式调用，直接返回&lt;code&gt;this&lt;/code&gt;即可，因为&lt;code&gt;this&lt;/code&gt;就指代了&lt;code&gt;myhttp&lt;/code&gt;的实例&lt;code&gt;app&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step4/testhttp.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
app.use(ctx=&amp;gt;{
    console.log(1)
}).use(ctx=&amp;gt;{
    console.log(2)
})
app.use(ctx=&amp;gt;{
    console.log(3)
})
...&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;step5-实现中间件的异步执行&quot;&gt;&lt;strong&gt;step5 实现中间件的异步执行&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;任何程序只要加上了异步之后，感觉难度就蹭蹭蹭往上涨。&lt;/p&gt;
&lt;p&gt;这里要分两点来处理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;use&lt;/code&gt;中中间件的异步执行&lt;/li&gt;
&lt;li&gt;中间件的异步完成后&lt;code&gt;compose&lt;/code&gt;的异步执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;首先是&lt;code&gt;use&lt;/code&gt;中的异步&lt;/em&gt;&lt;br/&gt;如果我需要中间件是异步的，那么我们可以利用async/await这么写，返回一个promise&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.use(async (ctx,next)=&amp;gt;{
    await next()//等待下方完成后再继续执行
    ctx.body=&quot;aaa&quot;
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是promise，那么我就不能按照普通的程序foreach执行了，我们需要一个完成之后在执行另一个，那么这边我们就需要将这些函数组合放入另一个方法&lt;code&gt;compose&lt;/code&gt;中进行处理，然后返回一个promise，最后来一个&lt;code&gt;then&lt;/code&gt;，告诉程序我执行完了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;handleRequest(req,res){
    ....
    this.compose(ctx,this.middleWares).then(()=&amp;gt;{
        res.end(ctx.body)
    }).catch(err=&amp;gt;{
        console.log(err)
    })
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么compose怎么写呢？&lt;/p&gt;
&lt;p&gt;首先这个middlewares需要一个执行完之后再进行下一个的执行，也就是回调。其次compose需要返回一个promise，为了告诉最后我执行完毕了。&lt;/p&gt;
&lt;p&gt;第一版本compose，简易的回调，像这样。不过这个和&lt;code&gt;foreach&lt;/code&gt;并无差别。这里的&lt;code&gt;fn&lt;/code&gt;就是我们的中间件，&lt;code&gt;()=&amp;gt;dispatch(index+1)&lt;/code&gt;就是&lt;code&gt;next&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;compose(ctx,middlewares){
    function dispatch(index){
        console.log(index)
        if(index===middlewares.length) return;
        let fn=middlewares[index]
        fn(ctx,()=&amp;gt;dispatch(index+1));
    }
    dispatch(0)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二版本compose，我们加上async/await，并返回promise，像这样。不过这个和&lt;code&gt;foreach&lt;/code&gt;并无差别。&lt;code&gt;dispatch&lt;/code&gt;一定要返回一个promise。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;compose(ctx,middlewares){
    async function dispatch(index){
        console.log(index)
        if(index===middlewares.length) return;
        let fn=middlewares[index]
        return await fn(ctx,()=&amp;gt;dispatch(index+1));
    }
    return dispatch(0)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;return await fn(ctx,()=&amp;gt;dispatch(index+1));&lt;/code&gt;注意此处，这就是为什么我们需要在&lt;code&gt;next&lt;/code&gt;前面加上await才能生效？作为promise的&lt;code&gt;fn&lt;/code&gt;已经执行完毕了，如果不等待后方的promise，那么就直接&lt;code&gt;then&lt;/code&gt;了，后方的&lt;code&gt;next&lt;/code&gt;就自生自灭了。所以如果是异步的，我们就需要在中间件上加上&lt;code&gt;async/await&lt;/code&gt;以保证&lt;code&gt;next&lt;/code&gt;执行完之后再返回上一个&lt;code&gt;promise&lt;/code&gt;。无法理解？😷了？我们看几个例子。&lt;/p&gt;
&lt;p&gt;具体操作如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function makeAPromise(ctx){
    return new Promise((rs,rj)=&amp;gt;{
        setTimeout(()=&amp;gt;{
            ctx.body=&quot;bbb&quot;
            rs()
        },1000)
    })
}
//如果下方有需要执行的异步操作
app.use(async (ctx,next)=&amp;gt;{
    await next()//等待下方完成后再继续执行
    ctx.body=&quot;aaa&quot;
})
app.use(async (ctx,next)=&amp;gt;{
    await makeAPromise(ctx).then(()=&amp;gt;{next()})
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码先执行&lt;code&gt;ctx.body=&quot;bbb&quot;&lt;/code&gt;再执行&lt;code&gt;ctx.body=&quot;aaa&quot;&lt;/code&gt;，因此打印出来是&lt;code&gt;aaa&lt;/code&gt;。如果我们反一反：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.use(async (ctx,next)=&amp;gt;{
    ctx.body=&quot;aaa&quot;
    await next()//等待下方代码完成
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么上述代码就先执行&lt;code&gt;ctx.body=&quot;aaa&quot;&lt;/code&gt;再执行&lt;code&gt;ctx.body=&quot;bb&quot;&lt;/code&gt;，因此打印出来是&lt;code&gt;bbb&lt;/code&gt;。&lt;br/&gt;这个时候我们会想，既然我这个中间件不是异步的，那么是不是就可以不用加上async/await了呢？实践出真理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.use((ctx,next)=&amp;gt;{
    ctx.body=&quot;aaa&quot;
    next()//不等了
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么程序就不会等后面的异步结束就先结束了。因此如果有异步的需求，尤其是需要靠异步执行再进行下一步的的操作，就算本中间件没有异步需求，也要加上async/await。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;终于写完了，感觉脑细胞死了不少，接下来我去研究router和ejs，等这一块加入我的web框架之后，就很完美了~&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 15:16:00 +0000</pubDate>
<dc:creator>cherryvsun</dc:creator>
<og:description>我经常在网上看到类似于 的文章，大家都在讨论哪一个好，哪一个更好。作为小白，我真心看不出他两who更胜一筹。我只知道，我只会跟着官方文档的start做一个DEMO，然后我就会宣称我会用KOA或者exp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cherryvenus/p/9527211.html</dc:identifier>
</item>
<item>
<title>我读《2017软件测试行业调查报告》 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/9527132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/9527132.html</guid>
<description>&lt;p&gt;该报告由51Testing 发布，他们会在每年年中发布会一份测试行业调查报告，今年是在6月份发布的，相信有同学已经看过了，不过，我这里会挑自己感兴趣的统计结果和大家分享。&lt;br/&gt;说明：该报告收集问卷两千余份，来自全国不同的城市。首先，这个统计量相比全国测试人员来说并不大（其实，我也不知道中国到底有多少测试从业人员，但肯定远远大于两千人）。其次，全国不同的城市薪资和技能要求会有一定的差距，大家合理看待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201808/311516-20180823225252485-998104892.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统测试依然是主要测试手段，虽然，测试行业经历了这么多年的发展，各种自动化测试工具层出不穷，但依然无法替代系统测试。并且我认为它会长期是软件测试的主要手段。除非，出现颠覆性的技术。因为，软件技术更新太了，软件业务也涉及到各行各业，有些业务则非常复杂，这种情况下只有人才能快速适应这种变化，做好系统测试才能保证软件质量和体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201808/311516-20180823225302939-826214726.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201808/311516-20180823225309765-1234781061.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里罗列的自动化测试工具，相信大家都不陌生，但实际在项目中应用到什么程度就有很大差别了。我在面试的时候会问你写了多少条用例，毕竟一个几百条用例的自动化测试项目和一个几条用例的demo区别还是很大的。&lt;br/&gt;建议大家深入学习和适用一到两款自动化测式工具，毕竟是在面试中的加分项。不过，我认为学好一门编程语言远比多会两个工具的收益要大。这里就不展开解释了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201808/311516-20180823225320077-1868388838.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以前是LoadRunner一家独大，现在JMeter已经与其持平了。未来的占比应该会反超。从身边的人也能感受到JMeter越来越主流。JMeter是我们需要花时间学习和掌握的一个测试工具。主要用它来完成接口自动化，以及性能测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201808/311516-20180823225327798-1425817890.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里JUnit的使用占比如此高我其实是有疑问的，难道混入了Java开发人员？大多数测试使用单元测试框架主要用来做UI自动化测试，而在Java语言中TestNG更适合来做UI自动化测试。&lt;br/&gt;其次，用Python语言的测试人员也非常多，PyUnit的占比并不高。pyunit是unittest的前身；如果想学好Selenium/appium的话，单元测试框架是绕不开的技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201808/311516-20180823225639436-1134260046.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;90后~95后的占比越来越高，侧面印证“程序员是吃青春饭”，或者说年龄大的要么转行了，要么升管理了，我还能坚持几年？哈哈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201808/311516-20180823225340048-2079412120.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本科是主力，测试的门槛也在不断提高，专科历年的占比在递减，越来越难踏入这个行业了。&lt;br/&gt;前两天有同学这跟我抱怨，他一直想加入的某公司卡他学历，我问为什么想加入某公司，他说离家近、测试团队强，能学到东西。这明显因果倒置了，公司招聘一个员工考虑的是你能为公司带来什么？很强的技术和能力？如果不是拔尖的优秀，那就用学历把你卡掉！&lt;br/&gt;所以，要么提升学历，要么提升能力。或者加入个创业团队也挺好，说不定就像拼多多一样很快就上市了呢！...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201808/311516-20180823225501447-1187135382.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大多公司的“自动化测试”和“性能测试”都是由测试/高级测试工程师担任，单独设立这两个岗位的公司并不多，而且，它们和测试的业务密切相关，本来就应该是测试人员必备的技能之一，单独划分有些不妥，所以，看到占比很低。&lt;br/&gt;其实，这里只是一个职称，不同的公司的划分的标准也不一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201808/311516-20180823225448344-1693955923.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这应该是大家喜闻乐见的了。看看你属于哪个范围？不过，这是全国的统计结果，一线城市的小伙伴明显感觉偏低了。&lt;br/&gt;所以，薪资偏低的小伙伴一方面可能受到所在城市的局限，比如，你在二三线城市，另一方面受到自身技能的局限。&lt;br/&gt;比如，今天下午我面试的一个测试，工作五年的经验和两三年没什么明显区别。并不是说不满足要求，而是这会预示着你未来个人提升空间。因为公司的发展和员工个人的发展是分不开的。想想，你是不是掉队了，或者你的技能是否匹配你的工龄。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201808/311516-20180823225426562-330077642.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个人每个阶段都会有迷茫，又何止是测试呢！&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 14:58:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>该报告由51Testing 发布，他们会在每年年中发布会一份测试行业调查报告。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/9527132.html</dc:identifier>
</item>
<item>
<title>CAP带你轻松玩转Asp.Net Core消息队列 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/9527012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/9527012.html</guid>
<description>&lt;p&gt;CAP是由我们园子里的杨晓东大神开发出来的一套分布式事务的决绝方案，是.Net Core Community中的第一个千星项目（目前已经1656 Start），具有轻量级、易使用、高性能等特点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/452505edb71d41f2c1bd18907275b76291621e46/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3235303431372f3230313730372f3235303431372d32303137303730353137353832373132382d313230333239313436392e706e67&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/dotnetcore/CAP&quot; href=&quot;https://github.com/dotnetcore/CAP&quot;&gt;https://github.com/dotnetcore/CAP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本博客主要针对易用性这一点，展开叙述，一起看看CAP如何结合EF Core和RabbitMQ带领小白轻松走入分布式消息队列的世界。&lt;img class=&quot;wlEmoticon wlEmoticon-ninja&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223217112-1299271687.png&quot; alt=&quot;忍者&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先，你需要搭建一套RabbitMQ系统，搭建过程在此不再叙述，如果大家觉得麻烦，可以用我搭好的。&lt;/p&gt;
&lt;p&gt;HostName: &lt;strong&gt;&lt;span&gt;coderayu.cn&lt;/span&gt;&lt;/strong&gt;  UserName:guest Password:guest  (仅仅可用作实验，数据丢失不负责)&lt;/p&gt;
&lt;p&gt;创建Asp.Net Core 项目，并引入Nuget包&lt;/p&gt;
&lt;p&gt;你可以运行以下下命令在你的项目中安装 CAP。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PM&amp;gt; Install-Package DotNetCore.CAP
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你的消息队列使用的是 Kafka 的话，你可以：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PM&amp;gt; Install-Package DotNetCore.CAP.Kafka
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你的消息队列使用的是 RabbitMQ 的话，你可以：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PM&amp;gt; Install-Package DotNetCore.CAP.RabbitMQ
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CAP 提供了 Sql Server, MySql, PostgreSQL 的扩展作为数据库存储：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按需选择安装你正在使用的数据库&lt;/span&gt;
PM&amp;gt; Install-&lt;span&gt;Package DotNetCore.CAP.SqlServer
PM&lt;/span&gt;&amp;gt; Install-&lt;span&gt;Package DotNetCore.CAP.MySql
PM&lt;/span&gt;&amp;gt; Install-Package DotNetCore.CAP.PostgreSql
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为我采用的是EF Core，所以首先要创建一个DbContext上下文，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CapDbContext:DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CapDbContext(DbContextOptions options) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options)
        {
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先需要在ConfigureServices函数中进行相关服务的注入，对应的操作和功能解释如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入DbContext上下文，如果用的是Mysql可能还需要添加Pomelo.EntityFrameworkCore.MySql这个Nuget包&lt;/span&gt;
            services.AddDbContext&amp;lt;CapDbContext&amp;gt;(options =&amp;gt;&lt;span&gt;
                options.UseMySql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Server=127.0.0.1;Database=testcap;UserId=root;Password=123456;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置CAP&lt;/span&gt;
            services.AddCap(x =&amp;gt;&lt;span&gt;
            {
                x.UseEntityFramework&lt;/span&gt;&amp;lt;CapDbContext&amp;gt;&lt;span&gt;();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启用操作面板&lt;/span&gt;
&lt;span&gt;                x.UseDashboard();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用RabbitMQ&lt;/span&gt;
                x.UseRabbitMQ(rb =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq服务器地址&lt;/span&gt;
                    rb.HostName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;coderayu.cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    rb.UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    rb.Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定Topic exchange名称，不指定的话会用默认的&lt;/span&gt;
                    rb.ExchangeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cap.text.exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                });

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置处理成功的数据在数据库中保存的时间（秒），为保证系统新能，数据会定期清理。&lt;/span&gt;
                x.SucceedMessageExpiredAfter = &lt;span&gt;24&lt;/span&gt; * &lt;span&gt;3600&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置失败重试次数&lt;/span&gt;
                x.FailedRetryCount = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
            });

            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后还要再Congiure中启用CAP中间件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启用cap中间件&lt;/span&gt;
&lt;span&gt;            app.UseCap();

            app.UseMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再程序包管理控制台中依此输入以下命令行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
PM&amp;gt; Add-Migration Init
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
PM&amp;gt; update-database
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果成成功执行，那么打开数据库，就可以看到用来存储CAP发送和接收数据的表格了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223218169-1774047530.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223220086-1005431922.png&quot; alt=&quot;image&quot; width=&quot;598&quot; height=&quot;247&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表格中每列的含义如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223221133-501501519.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223222169-1257462300.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;117&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;我们直接在ValuesController的基础上进行改造。&lt;/p&gt;
&lt;p&gt;在 Controller 中注入 &lt;code&gt;ICapPublisher&lt;/code&gt; 然后使用 &lt;code&gt;ICapPublisher&lt;/code&gt; 进行消息发送&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ICapPublisher _publisher;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(ICapPublisher publisher)
        {
            _publisher &lt;/span&gt;=&lt;span&gt; publisher;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; message)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;cap.test.queue&quot;是发送的消息RouteKey，可以理解为消息管道的名称&lt;/span&gt;
            _publisher.Publish(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cap.test.queue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,message);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发送成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;订阅消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;       //&lt;/span&gt;&lt;span&gt;&quot;cap.test.queue&quot;为发送消息时的RauteKey，也可以模糊匹配
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;详情https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.rabbitmq.com/tutorials/tutorial-four-dotnet.html&lt;/span&gt;
        [CapSubscribe(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cap.test.queue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HandleMessage(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; message)
        {
            Console.Write(DateTime.Now.ToString()&lt;/span&gt;+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到消息:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;message);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动程序后，首先看到CAP启动成功&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223223141-1167108160.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223223408-363283128.png&quot; alt=&quot;image&quot; width=&quot;765&quot; height=&quot;499&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;紧随其后，消费者也就是我们的订阅方法在RabbitMQ服务器上注册成功。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223224104-2142746154.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223224377-1308092235.png&quot; alt=&quot;image&quot; width=&quot;777&quot; height=&quot;78&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发送消息，发送成功，如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223225024-1567260376.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223225288-706638154.png&quot; alt=&quot;image&quot; width=&quot;760&quot; height=&quot;155&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发送后，立即在控制台看到了订阅方法输出的结果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223226090-1389439519.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223226319-699234549.png&quot; alt=&quot;image&quot; width=&quot;768&quot; height=&quot;163&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;在订阅方法中，如果抛出异常，那么CAP就会认为该条消息处理失败，会自动进行重试，重试次数在前方已经进行了配置。&lt;/p&gt;
&lt;p&gt;我们把订阅方法做一个改动，打印接收的信息到控制台中，并抛出异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;cap.test.queue&quot;为发送消息时的RauteKey，也可以模糊匹配
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;详情https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.rabbitmq.com/tutorials/tutorial-four-dotnet.html&lt;/span&gt;
        [CapSubscribe(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cap.test.queue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HandleMessage(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; message)
        {
            Console.WriteLine(DateTime.Now.ToString()&lt;/span&gt;+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到消息:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;message);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试失败重试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到，立即进行了三次重试&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223226541-1906064604.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223227080-989110196.png&quot; alt=&quot;image&quot; width=&quot;753&quot; height=&quot;160&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可是在前面，我们设置的失败重试次数是5次，为什么这里只重试三次吗？是不是要叫晓东过来改BUG了呢&lt;img class=&quot;wlEmoticon wlEmoticon-eyerollingsmile&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223227322-812043582.png&quot; alt=&quot;转动眼睛&quot;/&gt;？当然不是。&lt;/p&gt;
&lt;p&gt;观察发现，CAP重试的前三次是立即进行的，而后面的重试，是每隔一段时间进行的，当在分布式通讯的过程中，可能出现了问题确实不会立即修复解决，可能过了一定时间，系统就自动恢复了，如网络抖动。&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223227573-1757949775.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223227905-1506383649.png&quot; alt=&quot;image&quot; width=&quot;752&quot; height=&quot;450&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发送成功了五条消息，成功接收处理了三条，两条处理失败，处理失败的任务，我们可以直接在面板中进行重新消费，可谓非常方便。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223228230-913920982.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223228489-1386462518.png&quot; alt=&quot;image&quot; width=&quot;774&quot; height=&quot;196&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时，处理失败的消息，点击消息的编号后，可以查看到消息的内容和异常原因。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223229128-864642936.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223230027-560616924.png&quot; alt=&quot;image&quot; width=&quot;617&quot; height=&quot;395&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CAP如此强大，让消息队列这种高大上产品操作So Easy，学会了CAP,也可以吹牛说，我也懂分布式任务处理啦&lt;img class=&quot;wlEmoticon wlEmoticon-laughingoutloud&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180823223230254-900629696.png&quot; alt=&quot;大声笑&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;感谢晓东开发出如此强大的项目，同时感谢.Net Core Community。&lt;/p&gt;
&lt;p&gt;参考 CAP Github wiki&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/dotnetcore/CAP/wiki&quot; href=&quot;https://github.com/dotnetcore/CAP/wiki&quot;&gt;https://github.com/dotnetcore/CAP/wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本博客Demo代码&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/liuzhenyulive/CAP.Demo&quot; href=&quot;https://github.com/liuzhenyulive/CAP.Demo&quot;&gt;https://github.com/liuzhenyulive/CAP.Demo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 14:33:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>CAP是什么？ CAP是由我们园子里的杨晓东大神开发出来的一套分布式事务的决绝方案，是.Net Core Community中的第一个千星项目（目前已经1656 Start），具有轻量级、易使用、高性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/9527012.html</dc:identifier>
</item>
<item>
<title>Git中的&quot;pull request&quot;真正比较的是什么？ - xiaoxi666</title>
<link>http://www.cnblogs.com/xiaoxi666/p/9526896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxi666/p/9526896.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;利用git版本控制工具时，我们通常会从主分支拉出新分支进行开发，开发完成后创建pr（也就是pull request），让其他小伙伴帮忙review，确定代码没有问题后再将新分支合并到主分支上。但是，你真的理解pull request中比较的两个分支到底是谁吗？&lt;/p&gt;
&lt;p&gt;下面以一个虚拟案例进行说明：假设主分支名为“Master”，拉出来的新分支名为“developBrance1”。&lt;/p&gt;
&lt;h2&gt;首先看最简单的情况&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/609124/201808/609124-20180823213030984-1343936089.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，我们从主分支Master的m1提交点拉出新分支developBranch1，然后在developBranch1分支上开发（开发过程中产生了d1、d2、d3共3个提交），开发完成后创建pr，然后经过Review后将其合并到主分支上形成新的提交点N。自然而然地，我们创建pr时选择的源和目标为：&lt;/p&gt;
&lt;p&gt;src[&lt;strong&gt;developBranch1&lt;/strong&gt;] -&amp;gt; dest[&lt;strong&gt;Master&lt;/strong&gt;]&lt;/p&gt;
&lt;p&gt;我们期望pr比较的是developBranch1和Master这两个分支的最新提交点，pr实际比较的也是&lt;span&gt;developBranch1的&lt;span&gt;d3提交点&lt;/span&gt;&lt;/span&gt;和&lt;span&gt;Master分支的&lt;span&gt;m1提交点&lt;/span&gt;&lt;/span&gt;之间的差异。&lt;/p&gt;
&lt;h2&gt;增加一点复杂度&lt;/h2&gt;
&lt;p&gt;假设现在有其他小伙伴和你一同工作（这才是工作中的场景），另外一名小伙伴也从Master分支的m1提交点拉出分支developBranch2进行开发，并产生了若干提交，而且在我们开发完成之前已经合并到了Master分支上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/609124/201808/609124-20180823215957286-1745046739.png&quot; alt=&quot;&quot; width=&quot;606&quot; height=&quot;328&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们创建pr时，源和目标自然还是：&lt;/p&gt;
&lt;p&gt;src[&lt;strong&gt;developBranch1&lt;/strong&gt;] -&amp;gt; dest[&lt;strong&gt;Master&lt;/strong&gt;]&lt;/p&gt;
&lt;p&gt;但此时pr实际比较的是developBranch1和Master这两个分支的最新提交点吗（ &lt;span&gt;developBranch1的&lt;/span&gt;&lt;span&gt;d3提交点&lt;/span&gt;和&lt;span&gt;Master分支的&lt;/span&gt;&lt;span&gt;m2提交点&lt;/span&gt;之间的差异）？&lt;/p&gt;
&lt;p&gt;答案：不是的。现在pr比较的其实是&lt;span&gt;developBranch1的&lt;/span&gt;&lt;span&gt;d3提交点&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Master分支的&lt;/span&gt;m1提交点&lt;span&gt;，和上面的情况完全没有差异！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;其实pr的底层这样实现非常有道理：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们创建pr时，两个分支比较的差异只是自己开发的内容。试想，如果合作开发情况下比较developBranch1的d3提交点和Master分支的m2提交点之间的差异，那我们会同时看到其他小伙伴的开发内容，你会想，这不是反应了“最新工作进度”吗？不就是多看一个小伙伴的代码吗？&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;好，再试想如果同时有很多人开发，我们提交自己的代码时，夹杂了许多其他小伙伴的代码，你会不会因找不到自己开发的代码而发疯？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;“最新工作进度”的疑惑还在吧？下面来解答。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;git是如何反映最新工作进度的？&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 其实，git合并不同分支时，会自动取它们的&lt;strong&gt;并集&lt;/strong&gt;，以保持最终工作进度。就拿上图说，如果developBranch1的d3提交点和developBranch2的o2提交点之间不存在冲突，两者的开发工作最终都会在m3中体现（当然，有冲突了就需要手动解决）。&lt;/p&gt;
&lt;h2&gt;现在还有一个问题，pr比较的原理是什么？&lt;/h2&gt;
&lt;p&gt;pr比较的是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;源分支的最近提交点&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;源分支和目标分支的最近公共父提交节点&lt;/strong&gt;&lt;/span&gt;之间的差异。在文中第二张图中，可以看到源分支是developBranch1，目标分支是Master，两个分支的最近公共父提交节点是m1；所以最终比较的就是&lt;span&gt;源分支的最近提交点d3&lt;/span&gt;和&lt;span&gt;m1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;探索欲强的读者也可以试试把不同分支分别作为pr的源和目标，看看git diff的输出，以加深印象。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;其他更为复杂的分支pr原理类似，只是需要结合更为复杂的合并策略进行分析。文中若有疏漏，欢迎指正补充。&lt;/p&gt;
&lt;p&gt;好了，该去复习复习寻找两节点最近公共父节点的原理了^_^&lt;/p&gt;

&lt;h2&gt;比较好的文章推荐&lt;/h2&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a title=&quot;知乎——Git由浅入深之分支管理&quot; href=&quot;https://zhuanlan.zhihu.com/p/26227256&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/26227256&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Thu, 23 Aug 2018 14:21:00 +0000</pubDate>
<dc:creator>xiaoxi666</dc:creator>
<og:description>前言 利用git版本控制工具时，我们通常会从主分支拉出新分支进行开发，开发完成后创建pr（也就是pull request），让其他小伙伴帮忙review，确定代码没有问题后再将新分支合并到主分支上。但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxi666/p/9526896.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Config 分布式配置中心【Finchley 版】 - Jreey</title>
<link>http://www.cnblogs.com/JreeyQi/p/9526850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JreeyQi/p/9526850.html</guid>
<description>&lt;h2 id=&quot;一-介绍&quot;&gt;一、 介绍&lt;/h2&gt;
&lt;h4 id=&quot;为什么需要配置中心&quot;&gt;1，为什么需要配置中心？&lt;/h4&gt;
&lt;p&gt;当服务部署的越来越多，规模越来越大，对应的机器数量也越来越庞大，靠人工来管理和维护服务的配置信息，变得困难，容易出错。&lt;br/&gt;因此，需要一个能够动态注册和获取服务信息的地方，来统一管理服务名称和其对应的服务器列表信息，称之为服务配置中心。服务提供者在启动时，将其提供的服务名称、服务器地址注册到服务配置中心。服务消费者通过服务配置中心来获得需要调用的服务，通过相应的负载均衡算法，选择其中一台服务器开始调用。&lt;/p&gt;
&lt;h4 id=&quot;什么是-spring-cloud-config&quot;&gt;2，什么是 Spring Cloud Config&lt;/h4&gt;
&lt;p&gt;spring cloud config 是 spring cloud 中的一个组件，分布式配置中心组件，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。&lt;/p&gt;
&lt;h2 id=&quot;二-spring-cloud-config-实战&quot;&gt;二、 Spring Cloud Config 实战&lt;/h2&gt;
&lt;h3 id=&quot;构建config-server&quot;&gt;2.1，构建Config Server&lt;/h3&gt;
&lt;h4 id=&quot;创建一个名为config-server-的-spring-boot项目pom.xml依赖如下-注意组件版本我用的是-spring-boot-2.0.x&quot;&gt;2.1.1，创建一个名为config-server 的 spring-boot项目，pom.xml依赖如下: 注意组件版本我用的是 &lt;code&gt;Spring Boot 2.0.x&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.0.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Finchley.RELEASE&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在入口类configserverapplication-添加注解-enableconfigserver开启config配置中心服务端&quot;&gt;2.2，在入口类ConfigServerApplication 添加注解 &lt;code&gt;@EnableConfigServer&lt;/code&gt;,开启Config配置中心服务端&lt;/h4&gt;
&lt;h4 id=&quot;在根目录新建的配置文件-config-dev.yml并提交到git仓库实例是mysql的数据原本配置信息提交的github中配置文件如下&quot;&gt;2.3，在根目录新建的配置文件 &lt;code&gt;config-dev.yml&lt;/code&gt;，并提交到git仓库，实例是mysql的数据原本配置信息，提交的github中，配置文件如下：&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://192.168.10.100:3306/spring?useSSL=false
    username: test
    password: 123456&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置-application.yml-配置如下&quot;&gt;2.4，配置 application.yml ,配置如下：&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: https://github.com/jarvisqi/spring-cloud-microservice
          search-paths: config-server
          username:
          password:
          default-label: master
server:
  port: 9400
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;spring.cloud.config.server.git.url :指定git的仓库地址，改成你自己的&lt;/li&gt;
&lt;li&gt;spring.cloud.config.server.git.search-paths :指定你的配置文件所在的目录&lt;/li&gt;
&lt;li&gt;username，password 如果是github公开的就不用添加，自己的私有仓库自己添加&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;启动config-server并访问httplocalhost9400configdev-地址看到如下信息说明服务端正常运行&quot;&gt;2.4，启动Config-Server，并访问：&lt;code&gt;http://localhost:9400/config/dev&lt;/code&gt; 地址，看到如下信息，说明服务端正常运行：&lt;/h4&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;name&quot;: &quot;config&quot;,
    &quot;profiles&quot;: [
        &quot;dev&quot;
    ],
    &quot;label&quot;: null,
    &quot;version&quot;: &quot;e64289cb775e2ac7db7494c07d7e8c4933163daf&quot;,
    &quot;state&quot;: null,
    &quot;propertySources&quot;: [
        {
            &quot;name&quot;: &quot;https://github.com/jarvisqi/spring-cloud-microservice/config-server/config-dev.yml&quot;,
            &quot;source&quot;: {
                &quot;spring.datasource.driver-class-name&quot;: &quot;com.mysql.jdbc.Driver&quot;,
                &quot;spring.datasource.url&quot;: &quot;jdbc:mysql://192.168.10.100:3306/spring?useSSL=false&quot;,
                &quot;spring.datasource.username&quot;: &quot;test&quot;,
                &quot;spring.datasource.password&quot;: 123456
            }
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;source 下面的key就是配置的信息，http请求地址和资源文件映射如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构建config-client&quot;&gt;2.2，构建Config Client&lt;/h3&gt;
&lt;h4 id=&quot;创建一个名为config-client-的-spring-boot项目pom.xml依赖如下-注意组件版本我用的是-spring-boot-2.0.x&quot;&gt;2.2.1，创建一个名为config-client 的 spring-boot项目，pom.xml依赖如下: 注意组件版本我用的是 &lt;code&gt;Spring Boot 2.0.x&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.0.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Finchley.RELEASE&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置-application.yml-配置如下-1&quot;&gt;2.2.2，配置 application.yml ,配置如下：&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;spring:
  application:
    name: config-client
  cloud:
    config:
      uri: http://localhost:9400
      name: config
      profile: dev
      label: master
server:
  port: 9410
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;spring.cloud.config.uri : 指定config-server 服务端地址，注意并不是git仓库地址&lt;/li&gt;
&lt;li&gt;spring.cloud.config.name：&lt;code&gt;注意&lt;/code&gt; 如果&lt;code&gt;name&lt;/code&gt;值不写，会默认取 &lt;code&gt;spring.application.name&lt;/code&gt;的值，资源文件名就变成了 &lt;code&gt;config-client-dev&lt;/code&gt;，根据http请求地址和资源文件映射，肯定找不到，会报错，无法启动&lt;/li&gt;
&lt;li&gt;spring.cloud.config.profile：一般就是 dev ,test ,prd,你自定义也行，因为我提交的文件写的是 dev&lt;/li&gt;
&lt;li&gt;spring.cloud.config.label ：git的分支&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;配置-boostrap.yml-配置如下&quot;&gt;2.2.3，配置 boostrap.yml ,配置如下：&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    config:
      uri: http://localhost:9400&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;，此处有坑，如果你不添加 &lt;code&gt;boostrap.yml&lt;/code&gt;文件并重新指定指定 &lt;code&gt;spring.cloud.config.uri&lt;/code&gt;,启动客户端会报错，会默认指定 端口：8888，不是自定义的端口，无法启动会报错，当然你可以直接用 &lt;code&gt;boostrap.yml&lt;/code&gt; ，我看那此处很多人遇到问题，遇到问题就说降低版本到1.5.X就正确，这也能算解决方案？&lt;/p&gt;
&lt;h4 id=&quot;添加-configcontroller-接口并获取配置信息代码如下&quot;&gt;2.2.4，添加 ConfigController 接口，并获取配置信息，代码如下：&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class ConfigController {

    @Value(&quot;${spring.datasource.driver-class-name}&quot;)
    private String driverClassName;

    @Value(&quot;${spring.datasource.url}&quot;)
    private String url;

    @Value(&quot;${spring.datasource.username}&quot;)
    private String username;

    @Value(&quot;${spring.datasource.password}&quot;)
    private String password;

    @RequestMapping(&quot;/dataconfig&quot;)
    public DataConfig getDataConfig() {
        DataConfig config = new DataConfig(driverClassName, url, username, password);
        return config;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;首先启动config-server保证运行正常再启动-config-client并请求地址-httplocalhost9410dataconfig得到如下结果说明配置中心完成&quot;&gt;2.2.5，首先启动config-server,保证运行正常，再启动 config-client,并请求地址 &lt;code&gt;http://localhost:9410/dataconfig&lt;/code&gt;,得到如下结果，说明配置中心完成：&lt;/h4&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;driverClassName&quot;: &quot;com.mysql.jdbc.Driver&quot;,
    &quot;url&quot;: &quot;jdbc:mysql://192.168.10.100:3306/spring?useSSL=false&quot;,
    &quot;username&quot;: &quot;test&quot;,
    &quot;password&quot;: &quot;123456&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上，就可以单独部署配置中心，配置信息值需要git提交到指定的目录，微服务各个独立的服务应用都能获取。&lt;/p&gt;
&lt;p&gt;附上源码：&lt;a href=&quot;https://github.com/jarvisqi/spring-cloud-microservice.git&quot; class=&quot;uri&quot;&gt;https://github.com/jarvisqi/spring-cloud-microservice.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;http://cloud.spring.io/spring-cloud-config/spring-cloud-config.html&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 23 Aug 2018 14:15:00 +0000</pubDate>
<dc:creator>Jreey</dc:creator>
<og:description>一、 介绍 1，为什么需要配置中心？ 当服务部署的越来越多，规模越来越大，对应的机器数量也越来越庞大，靠人工来管理和维护服务的配置信息，变得困难，容易出错。 因此，需要一个能够动态注册和获取服务信息的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JreeyQi/p/9526850.html</dc:identifier>
</item>
<item>
<title>java导出Excel文件 - 烦嚣的人</title>
<link>http://www.cnblogs.com/wuyoucao/p/9526620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyoucao/p/9526620.html</guid>
<description>&lt;h2 id=&quot;一背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;  最近在java上做了一个EXCEL的导出功能，写了一个通用类，在这里分享分享，该类支持多sheet，且无需手动进行复杂的类型转换，只需提供三个参数即可：&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;code&gt;fileName&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;excel文件名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;HasMap&amp;lt;String,List&amp;lt;?&amp;gt;&amp;gt; data&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具体的数据，每个List代表一张表的数据，？表示可为任意的自定义对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;LinkedHashMap&amp;lt;String,String[][]&amp;gt; headers&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stirng&lt;/code&gt;代表sheet名。每个&lt;code&gt;String[][]&lt;/code&gt;代表一个sheet的定义，举个例子如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String[][] header = {
    {&quot;field1&quot;,&quot;参数1&quot;}
    ，{&quot;field2&quot;,&quot;参数2&quot;}
    ，{&quot;field3&quot;,&quot;参数3&quot;}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的field1，field2，field3为对象中的属性名，参数1，参数2，参数3为列名，实际上这个指定了列的名称和这个列用到数据对象的哪个属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二怎么用&quot;&gt;二、怎么用&lt;/h2&gt;
&lt;p&gt;  以一个例子来说明怎么用，假设有两个类A和B定义如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class A{
    private String name;
    private String address;
}
public class B{
    private int id;
    private double sum;
    private String cat;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们通过查询数据库获得了A和B的两个列表：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;A&amp;gt; dataA = .....;
List&amp;lt;B&amp;gt; dataB = .....;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将这两个导出到excel中，首先需要定义sheet：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String[][] sheetA = {
    {&quot;name&quot;,&quot;姓名&quot;}
    ,{&quot;address&quot;,&quot;住址&quot;}
}
String[][] sheetB = {
    {&quot;id&quot;,&quot;ID&quot;}
    ,{&quot;sum&quot;,&quot;余额&quot;}
    ,{&quot;cat&quot;,&quot;猫的名字&quot;}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将数据汇总构造一个ExcelUtil：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String fileName = &quot;测试Excel&quot;;
HashMap&amp;lt;String,List&amp;lt;?&amp;gt;&amp;gt; data = new HashMap&amp;lt;&amp;gt;();
//ASheet为表名，后面headers里的key要跟这里一致
data.put(&quot;ASheet&quot;,dataA);
data.put(&quot;BSheet&quot;,dataB);
LinkedHashMap&amp;lt;String,String[][]&amp;gt; headers = new LinkedHashMap&amp;lt;&amp;gt;();
headers.put(&quot;ASheet&quot;,sheetA);
headers.put(&quot;BSheet&quot;,sheetB);
ExcelUtil excelUtil = new ExcelUtil(fileName,data,headers);
//获取表格对象
HSSFWorkbook workbook = excelUtil.createExcel();
//这里内置了一个写到response的方法（判断浏览器类型设置合适的参数），如果想写到文件也是类似的
workbook.writeToResponse(workbook,request,response);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然通常数据是通过数据库查询的，这里为了演示方便没有从数据库查找。&lt;/p&gt;
&lt;h2 id=&quot;三实现原理&quot;&gt;三、实现原理&lt;/h2&gt;
&lt;p&gt;  这里简单说明下实现过程，从调用&lt;code&gt;createExcel()&lt;/code&gt;这里开始&lt;/p&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public HSSFWorkbook createExcel() throws Exception {
        try {
            HSSFWorkbook workbook = new HSSFWorkbook();
            //遍历headers创建表格
            for (String key : headers.keySet()) {
                this.createSheet(workbook, key, headers.get(key), this.data.get(key));
            }
            return workbook;
        } catch (Exception e) {
            log.error(&quot;创建表格失败:{}&quot;, e.getMessage());
            throw e;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将workbook，sheet名，表头数据，行数据传入crateSheet方法中创建sheet。&lt;/p&gt;
&lt;h4 id=&quot;创建表头&quot;&gt;2、创建表头&lt;/h4&gt;
&lt;p&gt;  表头也就是一个表格的第一行，通常用来对列进行说明&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        HSSFSheet sheet = workbook.createSheet(sheetName);
        // 列数
        int cellNum = header.length;
        // 单元行，单元格
        HSSFRow row;
        HSSFCell cell;
        // 表头单元格样式
        HSSFCellStyle columnTopStyle = this.getColumnTopStyle(workbook);
        // 设置表头
        row = sheet.createRow(0);
        for (int i = 0; i &amp;lt; cellNum; i++) {
            cell = row.createCell(i);
            cell.setCellStyle(columnTopStyle);
            String str = header[i][1];
            cell.setCellValue(str);
            // 设置列宽为表头的文字宽度+6个半角符号宽度
            sheet.setColumnWidth(i, (str.getBytes(&quot;utf-8&quot;).length + 6) * 256);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;插入行数据&quot;&gt;3、插入行数据&lt;/h4&gt;
&lt;p&gt;  这里是最重要的部分，首先通过数据的类对象获取它的反射属性Field类，然后将属性名和Field做一个hash映射，避免循环查找，提高插入速度，接着通过一个switch语句，根据属性类别设值，主要代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 设置单元格,根据fieldName获取对应的Field类，使用反射得到值
 *
 * @param cell 单元格实例
 * @param obj 存有属性的对象实例
 * @param fieldMap  属性名与Field的映射
 * @param fieldName 属性名
 */
private void setCell(HSSFCell cell, Object obj, Map&amp;lt;String, Field&amp;gt; fieldMap, String fieldName) throws Exception {
    //获取该属性的Field对象
    Field field = fieldMap.get(fieldName);
    //通过反射获取属性的值，由于不能确定该值的类型，用下面的判断语句进行合适的转型
    Object value = field.get(obj);
    if (value == null) {
        cell.setCellValue(&quot;&quot;);
    } else {
        switch (field.getGenericType().getTypeName()) {
        case &quot;java.lang.String&quot;:
            cell.setCellValue((String) value);
            break;
        case &quot;java.lang.Integer&quot;:
        case &quot;int&quot;:
            cell.setCellValue((int) value);
            break;
        case &quot;java.lang.Double&quot;:
        case &quot;double&quot;:
            cell.setCellValue((double) value);
            break;
        case &quot;java.util.Date&quot;:
            cell.setCellValue(this.dateFormat.format((Date) value));
            break;
        default:
            cell.setCellValue(obj.toString());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整代码可以到github上查看下载，这里就不列出来了。&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/FleyX/demo-project/blob/master/excel%E5%AF%BC%E5%87%BA.java&quot;&gt;点击跳转&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 13:46:00 +0000</pubDate>
<dc:creator>烦嚣的人</dc:creator>
<og:description>一、背景   最近在java上做了一个EXCEL的导出功能，写了一个通用类，在这里分享分享，该类支持多sheet，且无需手动进行复杂的类型转换，只需提供三个参数即可： excel文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyoucao/p/9526620.html</dc:identifier>
</item>
<item>
<title>scala的多种集合的使用(3)之遍历集合的方法 - IoT慧智星</title>
<link>http://www.cnblogs.com/zhaohadoopone/p/9525317.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaohadoopone/p/9525317.html</guid>
<description>&lt;h3&gt;&lt;span&gt;&lt;span&gt;遍历集合的方法&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h2&gt;&lt;span&gt;1.用foreach循环遍历一个集合&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;foreach接收一个函数作为参数。定义的函数应该接收一个元素作为输入参数，然后不要返回任何的东西。输入的参数的类型应该匹配集合中的类型。随着foreach的执行，它每次都会把一个元素传给你的函数，直到集合中最后一个元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;foreach常用的就是输出信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val x = Vector(1,2,3)
x: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)

scala&amp;gt; x.foreach((i:Int) =&amp;gt; println(i))
1
2
3
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于表达式，还有其他写法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;x.foreach(i =&amp;gt; println(i))

x.foreach(println(_))

x.foreach(println)　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于最后一种表达式，情况是一个只有一条语句组成并且接受一个参数的函数可以简写成这种形式。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.用for循环遍历一个集合&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;可以用for循环遍历任意一种Traversable的类型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val fruits = Traversable(&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;)
fruits: Traversable[String] = List(apple, orange, banana)

scala&amp;gt; for(i &amp;lt;- fruits) println(i)
apple
orange
banana&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果算法很长，可以在for循环的代码块里执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面展示了for循环里使用计数器的几种方式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val fruits = Array(&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;)
fruits: Array[String] = Array(apple, banana, orange)

scala&amp;gt; for(i &amp;lt;- 0 until fruits.size) println(s&quot;$i is ${fruits(i)}&quot;)
0 is apple
1 is banana
2 is orange
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val fruits = Array(&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;)
fruits: Array[String] = Array(apple, banana, orange)

scala&amp;gt; for((elem,count) &amp;lt;- fruits.zipWithIndex){
     | println(s&quot;$count is $elem&quot;)
     | }
0 is apple
1 is banana
2 is orange
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val fruits = Array(&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;)
fruits: Array[String] = Array(apple, banana, orange)

scala&amp;gt; for((elem,count) &amp;lt;- fruits.zip(Stream from 1)){
     | println(s&quot;$count is $elem&quot;)
     | }
1 is apple
2 is banana
3 is orange&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;3.用zipWithIndex创建循环计数器&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; (1)以foreach的形式遍历集合&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val days = Array(&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tusday&quot;,&quot;Wednsday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;)
days: Array[String] = Array(Sunday, Monday, Tusday, Wednsday, Thursday, Friday,Saturday)

scala&amp;gt; days.zipWithIndex.foreach{
         | case(day,count) =&amp;gt; println(s&quot;${count+1} is $day&quot;)
         | }
1 is Sunday
2 is Monday
3 is Tusday
4 is Wednsday
5 is Thursday
6 is Friday
7 is Saturday&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　另外的一种表示方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val days = Array(&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tusday&quot;,&quot;Wednsday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;)
days: Array[String] = Array(Sunday, Monday, Tusday, Wednsday, Thursday, Friday,Saturday)

scala&amp;gt; days.zipWithIndex.foreach{ d=&amp;gt;
         | println(s&quot;${d._2+1} is ${d._1}&quot;)
         | }
1 is Sunday
2 is Monday
3 is Tusday
4 is Wednsday
5 is Thursday
6 is Friday
7 is Saturday&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;(2) 以for的形式循环遍历&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val days = Array(&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tusday&quot;,&quot;Wednsday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;)
days: Array[String] = Array(Sunday, Monday, Tusday, Wednsday, Thursday, Friday,Saturday)

scala&amp;gt; for ((day,count) &amp;lt;- days.zipWithIndex){
         | println(s&quot;${count+1} is $day&quot;)
         | }
1 is Sunday
2 is Monday
3 is Tusday
4 is Wednsday
5 is Thursday
6 is Friday
7 is Saturday&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;4.用zip创建循环计数器&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 在zip中使用Stream是一种生存计数器的方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val days = Array(&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tusday&quot;,&quot;Wednsday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;)
days: Array[String] = Array(Sunday, Monday, Tusday, Wednsday, Thursday, Friday,Saturday)

scala&amp;gt; for ((day,count) &amp;lt;- days.zip(Stream from 1)){
         | println(s&quot;$count is $day&quot;)
         | }
1 is Sunday
2 is Monday
3 is Tusday
4 is Wednsday
5 is Thursday
6 is Friday
7 is Saturday&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;5.range循环计数器&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 如果只是需要重复做某事多次，可以用range。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val fruits = Array(&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;)
fruits: Array[String] = Array(apple, banana, orange)

scala&amp;gt; for(i &amp;lt;- 0 until fruits.size) {
         | println(s&quot;$i is ${fruits(i)}&quot;)}
0 is apple
1 is banana
2 is orange&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;6.用reduce方法遍历集合&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用reduceLeft和reduceRight方法来遍历序列中的元素，把相邻的元素传给你的函数成成一个新的结果，之后和序列的下一个元素比较在生成新的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;reduceLeft方法是从左到右遍历一个序列，在算法中首先会对前两个元素进行比较，然后返回一个结果。该结果会与第三个元素进行比较，比较之后在产生一个新结果，接着在于第四个元素比较，以此类推&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val a = Array(12,3,4,5,67)
a: Array[Int] = Array(12, 3, 4, 5, 67)

scala&amp;gt; a.reduceLeft(_ + _)
res4: Int = 91

scala&amp;gt; a.reduceLeft(_ min _)
res5: Int = 3

scala&amp;gt; a.reduceLeft(_ max _)
res6: Int = 67&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里面的两个下划线，它们代表传给函数的两个参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;reduceRight与reduceLeft同理的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;7.用fold方法遍历集合&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; foldLeft方法如同reduceLeft，它会设置一个种子值用于第一个元素。foldLeft接收两个参数列表。第一个列表有一个字段，种子值。第二个列表是要运行的代码块。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;scala&amp;gt; val a = Array(12,3,4,5,67)
a: Array[Int] = Array(12, 3, 4, 5, 67)

scala&amp;gt; a.reduceLeft(_ + _)
res8: Int = 91

scala&amp;gt; a.foldLeft(20)(_ + _)
res9: Int = 111&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 23 Aug 2018 13:02:00 +0000</pubDate>
<dc:creator>IoT慧智星</dc:creator>
<og:description>遍历集合的方法 1.用foreach循环遍历一个集合 foreach接收一个函数作为参数。定义的函数应该接收一个元素作为输入参数，然后不要返回任何的东西。输入的参数的类型应该匹配集合中的类型。随着fo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaohadoopone/p/9525317.html</dc:identifier>
</item>
<item>
<title>珍惜相聚，亦珍惜离别 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/9526246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/9526246.html</guid>
<description>&lt;p&gt;生命就是一场经历。既然是经历，就没有好坏，没有输赢；没有正义和邪恶，没有真实和虚伪；没有真和假，也没有对和错。当然，也没有相聚和离别。每一次的离别，都是为了下一次的相聚。&lt;/p&gt;
&lt;p&gt;车站、机场，每天都在上演着一场场的接送的微电影，有欢笑，亦有泪水。我们都喜欢去车站、机场迎接盼望已久的人。原来自己也是那个被眷顾的人啊。回首、发现回想很多。再回首、发现失落更多。生命中走过的每一个中央，每一个人，也都成为了驿站、成为了过客。一向喜欢回想、喜欢回忆，喜欢不遗忘。曾经习气了这样的波涛不惊，纵容着漫无边沿的寂寥。&lt;/p&gt;
&lt;p&gt;有些人就是如此的刻在我们心底的记忆里。即便遗忘了她的声音，遗忘了她的笑容，遗忘了她的脸庞。但是每当想起她的时候，那种感觉是永远也不会改变的，即便是光阴的无情冲刷，亦雷打不动。&lt;/p&gt;
&lt;p&gt;回想起夏令营的点点滴滴，从报名到参加选拔赛，短短地二十天，我为这一刻疯狂的准备着，刷了很多很多水题，也学到了不少新姿势，我也许是那个被上帝眷顾的孩子，我很顺利地苟活进入了南开大学学习，喜悦之感难以言表！QAQ&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/23/5b7e71e61d943.png&quot; alt=&quot;5b7e71e61d943&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这也是我人生第一次，一个人开始了漫长的北漂之旅。(父母一直都很担心我，毕竟儿行千里母担忧啊)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/23/5b7e72ec8ca3b.jpeg&quot; alt=&quot;5b7e72ec8ca3b&quot;/&gt;&lt;/p&gt;
&lt;p&gt;博客真是个好东西呢！我发了一条我到天津来学习的消息到朋友圈，立马有博客园的粉丝回复我，还不远千里到天津南站来接应我，并且送我去南开大学，认识你们真好！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/23/5b7e76da5e43f.jpeg&quot; alt=&quot;5b7e76da5e43f&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回想起在南开学习的点点滴滴，我很高兴我第一次为自己的人生做了一次选择。过去的日子里，我觉得我只是活在身边人的期望中，有父母的期望，师长的期望，虽然看上去我也不负他们所望，但我却不快乐，我觉得唯独忽略了我自己。我自卑，我低调，我想融入大众中，因为我觉得这样有安全感。我比较在意别人的看法，我努力去迎合别人的想法，去做别人眼中的自己，总之，过的很累，不洒脱。而来到了这里，我能够和一群完全不认识的人打成了一片，我在这里能够和来自不同高校的大师傅们一起交流学习，能够谈笑风生，至少我在这里变得更加自信了！！！&lt;/p&gt;
&lt;p&gt;和队友在一起并肩作战的感觉真好，一起打比赛，一起做题，一起讨论技术知识，相互学习，笑谈人生未来，第一次活出了真实的自我，原来这就是伙伴，这就是团队啊，这种感觉真好！！！&lt;/p&gt;
&lt;p&gt;手指飞跃在键盘上，我不知道我在敲击着那个字母，也许只是随心而动吧，我只喜欢跟着心走。放纵着自由，放纵着自己。我喜欢这种感觉，喜欢放飞自由的我，喜欢和朋友们在一起。&lt;/p&gt;
&lt;p&gt;在南开学习的这段时间里，我接触到了太多太多以前没有接触到的知识点，来到这里我才发现我啥都不会，啥都不懂，就是一只菜鸟，最突出的一个问题就是知识面太窄了，知道的东西太少了，花的时间还不够多。来到这里，我才知道，比你优秀的人比你还努力。我也见证了大师傅们早上早起占座位，白天认真听讲，晚上点灯熬夜的在做题。再对比对比自己，简直是又懒又菜，大师傅们都那么强还这么努力，我又何尝不通宵学习呢？&lt;/p&gt;
&lt;p&gt;在南开学习的这段时间里，我把我学到的一些姿势总结成了文章，得到了梅子酒师傅和小西师傅以及在场各位的认可，文章还被一位大师傅转载到公众号上去了，我开心到飞起来了，因为我知道，我还是个可塑之人，我有做这一行的潜力和信心。&lt;/p&gt;
&lt;p&gt;在南开学习的这段时间里，我接触到了许多国内知名战队的大师傅们，比如Blue-Lotus战队的小西师傅，刘师傅等等，同时在这里也刷新了我的一个观念：这些代表国内顶尖水平的大师傅们，为人都挺和善的，提倡开源共享，从来没有那种瞧不起弱者之类的，打心底里为他们点个赞，我也在一直努力着成为像他们一样的大师傅。&lt;/p&gt;
&lt;p&gt;在南开学习的这段时间里，我最感谢的是我并肩作战的三位队友，他们不离不弃，非常耐心细致地指导我，教会了我许多东西，让我对未来有了更周全的考虑，我在追梦的道路上必将走的更远。&lt;/p&gt;
&lt;p&gt;回想在营地呆过的那些日子，这里给我留下了太多宝贵的回忆：第一次体验到了团队的力量，第一次坐飞机，第一次尝试了一下天津的狗不理包子(既然来到了天津肯定是要来玩的)，第一次参加国家安全会议，第一次去企业参观(360和华为，念念不忘360的饭菜)，第一次零距离和大师傅们谈笑风生，第一次认识到了这么多志同道合的小伙伴们，第一次参加线下的攻防赛，体验了被大师傅们吊打的感觉......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/23/5b7ea738ccd0d.jpg&quot; alt=&quot;5b7ea738ccd0d&quot;/&gt;&lt;/p&gt;
&lt;p&gt;细想这些年一个人孤单走过的光阴，有过很屡次的错过。走的也是有一些困难，有一些疲惫，更多的是执着。年龄在增长，心态也日趋平和，不能说悟透生命，却懂得了珍惜，看着身边有很多人在寻寻觅觅，寻觅快乐，寻觅幸福，寻觅自我的位置，寻觅人生的价值。即便沿途中有风雨雷电，沟沟坎坎，却仍然不知疲倦的单独上路。自己又何尝不是如此呢。&lt;/p&gt;
&lt;p&gt;每当发现自己的能力驾驭不了自己的目标时，心情总是会十分的低落，可这又能怪得了谁呢？只能怪自己太愚蠢？怪自己不够努力？与其自我封闭，生闷气，还不如把发牢骚的时间拿来查漏补缺，毕竟我们不是天才，我们只是一个普通人，只要足够努力了，结果其实并不会太差，当你足够优秀的时候，你想要的都会来找你。&lt;/p&gt;
&lt;p&gt;”长亭外，古道边，芳草碧连天。晚风拂柳笛声残，夕阳山外山......“，耳边又回响起童年时候的歌谣。一次次的离别，让我了解了相聚和离别只是人生的一种常态。有相聚，就有离别；有离别，才会相聚。相聚离开，都有时候。离别时，心中怀着相聚的期盼，离别就不会太伤感；相聚时，心中怀着珍惜的情愫，相聚就更令人怀念！原来，离别也只有等到相聚了，才得以圆满！这一次的离别是为了下一次的相聚。我们该珍惜每一次的相聚，亦珍惜每一次的离别！&lt;/p&gt;
&lt;p&gt;一切又恢复到了往常的宁静，此刻，深夜来临，很喜欢这样静谧的光阴，静静的坐在电脑前。合上的门窗，隔绝这个城市的喧嚣与酷暑的侵袭。在岁月的长河中，相守一份温情、一份了解、一份宽容、一份默契。&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 12:51:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<og:description>珍惜相聚，亦珍惜离别 生命就是一场经历。既然是经历，就没有好坏，没有输赢；没有正义和邪恶，没有真实和虚伪；没有真和假，也没有对和错。当然，也没有相聚和离别。每一次的离别，都是为了下一次的相聚。 车站、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/9526246.html</dc:identifier>
</item>
</channel>
</rss>