<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>angularjs学习第五天笔记（第二篇：表单验证升级篇） - 猴子哥</title>
<link>http://www.cnblogs.com/xiaoXuZhi/p/angularjs_formCheck_ngMessages.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoXuZhi/p/angularjs_formCheck_ngMessages.html</guid>
<description>&lt;p&gt;您好，我是一名后端开发工程师，由于工作需要，现在系统的从0开始学习前端js框架之angular，每天把学习的一些心得分享出来，如果有什么说的不对的地方，请多多指正，多多包涵我这个前端菜鸟，欢迎大家的点评与赐教。谢谢！&lt;/p&gt;
&lt;p&gt;　　第五天，昨天学习了简单的表单验证，在昨天的基础上，今天主要对表单验证进一步学习研究。&lt;/p&gt;
&lt;p&gt;　　今天主要学习一下几点：文本框失去焦点后验证、表单验证提示信息显示处理优化&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第一、文本框失去焦点后验证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　文本框失去焦点验证效果：文本框失去焦点后对其合法性验证&lt;/p&gt;
&lt;p&gt;　　　　文本框失去焦点验证实现方式：定义一个指令（指令后续专门研究）当文本框失去焦点是设置focused=true,获得焦点为false&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　提示显示信息添加并列显示条件（focused）&lt;/p&gt;
&lt;p&gt;　　　　举一个具体的练习实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        .oneCount &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1000px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 60px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 60px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            border-bottom&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1px solid blue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

            .oneCount .titleCount &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
                float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
                width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 150px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
                text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; right&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

            .oneCount .valueCount &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
                float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
                width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 300px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
                text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; right&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

                .oneCount .valueCount input &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
                    width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 300px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

            .oneCount .alertCount &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
                float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
                width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 520px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
                margin-left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

                .oneCount .alertCount span &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
                    float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
                    margin-left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
                    color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #ff0000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .success &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #19e1cf !important&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        input .ng-pristine &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #808080&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            border-bottom&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1px solid #ff0000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        input .ng-dirty &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #000000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        input .ng-valid &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #000000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        input .ng-invalid &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #ff0000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;ng-app&lt;/span&gt;&lt;span&gt;=&quot;myApp&quot;&lt;/span&gt;&lt;span&gt; ng-controller&lt;/span&gt;&lt;span&gt;=&quot;myContro&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;loginForm&quot;&lt;/span&gt;&lt;span&gt; novalidate ng-submit&lt;/span&gt;&lt;span&gt;=&quot;submitForm()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;oneCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;titleCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;账号：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;valueCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;acount&quot;&lt;/span&gt;&lt;span&gt; ng-model&lt;/span&gt;&lt;span&gt;=&quot;user.acount&quot;&lt;/span&gt;&lt;span&gt;
                       placeholder&lt;/span&gt;&lt;span&gt;=&quot;必填：账号必须由数字字母组合，长度在6-20&quot;&lt;/span&gt;&lt;span&gt;
                       required&lt;/span&gt;&lt;span&gt;=&quot;required&quot;&lt;/span&gt;&lt;span&gt; ng-minlength&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt; ng-maxlength&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt;&lt;span&gt;
                       ng-pattern&lt;/span&gt;&lt;span&gt;=&quot;/^[0-9a-zA-Z]+$/&quot;&lt;/span&gt;&lt;span&gt;
                       ng-focus &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;alertCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt;
                     ng-show&lt;/span&gt;&lt;span&gt;=&quot;loginForm.acount.$invalid &amp;amp;&amp;amp; ((!loginForm.acount.$focused &amp;amp;&amp;amp; loginForm.acount.$dirty) || loginForm.submitted )&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt;
                          ng-show&lt;/span&gt;&lt;span&gt;=&quot;loginForm.acount.$error.required&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;acount必填&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt;
                          ng-show&lt;/span&gt;&lt;span&gt;=&quot;loginForm.acount.$error.minlength&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;最少长度为6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt;
                          ng-show&lt;/span&gt;&lt;span&gt;=&quot;loginForm.acount.$error.maxlength&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;最大长度为20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt;
                          ng-show&lt;/span&gt;&lt;span&gt;=&quot;loginForm.acount.$error.pattern&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;账号格式不符合要求（只能由数字和字母组成）&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;success&quot;&lt;/span&gt;&lt;span&gt;
                      ng-show&lt;/span&gt;&lt;span&gt;=&quot;!loginForm.acount.$focused &amp;amp;&amp;amp;loginForm.acount.$valid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;账号输入正确&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;oneCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;titleCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;valueCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; ng-model&lt;/span&gt;&lt;span&gt;=&quot;user.name&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入姓名&quot;&lt;/span&gt;&lt;span&gt; ng-maxlength&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt;&lt;span&gt;
                       ng-focus &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;alertCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt; ng-show&lt;/span&gt;&lt;span&gt;=&quot;!loginForm.name.$focused &amp;amp;&amp;amp; loginForm.name.$error.maxlength&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名最大长度为20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;success&quot;&lt;/span&gt;&lt;span&gt; ng-show&lt;/span&gt;&lt;span&gt;=&quot;!loginForm.name.$focused &amp;amp;&amp;amp; loginForm.name.$dirty &amp;amp;&amp;amp; loginForm.name.$valid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名输入正确&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;oneCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;titleCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;valueCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width:40px;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;Scripts/angular.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; angular.module(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myApp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, []);
    app.controller(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myContro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ($scope) {
        $scope.user &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
            acount: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w额外&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            name: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
            age: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
            pass: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
            rePass: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        };

        $scope.submitted &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交表单接受函数&lt;/span&gt;
&lt;span&gt;        $scope.submitForm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ($scope.loginForm.$valid) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;// 表单数据真实提交逻辑&lt;/span&gt;
&lt;span&gt;            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                $scope.loginForm.submitted &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
    });

    app.directive(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ngFocus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; FOCUS_CLASS &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ng-focused&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            restrict: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            require: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ngModel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            link: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (scope, element, attrs, ctrl) {
                ctrl.$focused &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                element.bind(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;focus&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (evt) {
                    element.addClass(FOCUS_CLASS);
                    scope.$apply(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                        ctrl.$focused &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    });
                }).bind(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blur&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    element.removeClass(FOCUS_CLASS);
                    scope.$apply(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                        ctrl.$focused &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    })
                })
            }
        }
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　　第二、表单验证提示信息显示处理优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;上面的表单验证的提示信息在体验上不是很友好，同一个文本框有可能同时显示多个提示信息&lt;/p&gt;
&lt;p&gt;　　　　新版本的angularjs中，引入了ngMessages指令，用于更加友好的处理方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　&lt;/strong&gt;　ngmessages同时指出提示模板引入，通过ng-messges-include 来加载外部提示模板&lt;/p&gt;
&lt;p&gt;　　直接上练习例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;ng-app&lt;/span&gt;&lt;span&gt;=&quot;myApp&quot;&lt;/span&gt;&lt;span&gt; ng-controller&lt;/span&gt;&lt;span&gt;=&quot;myContro&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;loginForm&quot;&lt;/span&gt;&lt;span&gt; novalidate ng-submit&lt;/span&gt;&lt;span&gt;=&quot;submitForm()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;oneCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;titleCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;账号：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;valueCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;acount&quot;&lt;/span&gt;&lt;span&gt; ng-model&lt;/span&gt;&lt;span&gt;=&quot;user.acount&quot;&lt;/span&gt;&lt;span&gt;
                       placeholder&lt;/span&gt;&lt;span&gt;=&quot;必填：账号必须由数字字母组合，长度在6-20&quot;&lt;/span&gt;&lt;span&gt;
                       required&lt;/span&gt;&lt;span&gt;=&quot;required&quot;&lt;/span&gt;&lt;span&gt; ng-minlength&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt; ng-maxlength&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt;&lt;span&gt;
                       ng-pattern&lt;/span&gt;&lt;span&gt;=&quot;/^[0-9a-zA-Z]+$/&quot;&lt;/span&gt;&lt;span&gt;
                       ng-focus &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;alertCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt; ng-messages&lt;/span&gt;&lt;span&gt;=&quot;loginForm.acount.$error&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-messages-include &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;template/required.html&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-messages-include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt;
                          ng-message&lt;/span&gt;&lt;span&gt;=&quot;minlength&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;该项最少长度为6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;warning&quot;&lt;/span&gt;&lt;span&gt;
                          ng-message&lt;/span&gt;&lt;span&gt;=&quot;maxlength&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;该项最大长度为20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-messages-include&lt;/span&gt;&lt;span&gt;=&quot;template/numberAndZhiMu.html&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;oneCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;titleCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;valueCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width:40px;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;Scripts/angular.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;Scripts/angular-messages.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; angular.module(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myApp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ngMessages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
    app.controller(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myContro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ($scope) {
        $scope.user &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
            acount: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        };

        $scope.submitted &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交表单接受函数&lt;/span&gt;
&lt;span&gt;        $scope.submitForm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ($scope.loginForm.$valid) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;// 表单数据真实提交逻辑&lt;/span&gt;
&lt;span&gt;            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                $scope.loginForm.submitted &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;时间不早了，明天在仔细研究该问题&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;今天就到此为止，明天继续研究表单验证，明天学习包括如下几点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;表单验证继续研究&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　指令简单了解学习&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Fri, 24 Aug 2018 15:58:00 +0000</pubDate>
<dc:creator>猴子哥</dc:creator>
<og:description>angularjs表单验证继续学习，主要内容包括，失去焦点验证、ngMessages</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoXuZhi/p/angularjs_formCheck_ngMessages.html</dc:identifier>
</item>
<item>
<title>springboot下的dubbo、zookeeper 结合使用 - zhyonk</title>
<link>http://www.cnblogs.com/zhyonk/p/9532499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhyonk/p/9532499.html</guid>
<description>&lt;p&gt;近期在研究dubbo框架&lt;/p&gt;
&lt;p&gt;相信看到这篇博客的，dubbo的基础应该都有了&lt;/p&gt;
&lt;p&gt;zookeeper的搭建走了点弯路，配置起来各种麻烦，妈的搞的好烦。&lt;/p&gt;
&lt;p&gt;正好一直想用一下docker，但对docker只是有个简单的概念。&lt;/p&gt;
&lt;p&gt;用了一晚上去研究docker，之后发现真的好用&lt;/p&gt;
&lt;p&gt;搭建个zookeeper就跟玩似的。&lt;/p&gt;
&lt;p&gt;这里记录一下遇到的一些坑！&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1、springboot引入dubbo的配置文件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;网上搜索了一下，大概的两种方式&lt;/p&gt;
&lt;p&gt;1、 这种方式是通过 ClassPathXmlApplicationContext 加载xml来获取上下文Context启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WreserveApplication {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;          ClassPathXmlApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;dubbo-provider.xml&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;         context.start();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;          System.in.read(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; press any key to exit&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、通过 @ImportResource({ &quot;classpath:dubbo-provider.xml&quot; }) 加载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @ImportResource({ &quot;classpath:dubbo-provider.xml&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WreserveApplication {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CountDownLatch closeLatch() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CountDownLatch(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         ConfigurableApplicationContext context = SpringApplication.run(WreserveApplication.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         CountDownLatch closeLatch = context.getBean(CountDownLatch.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        closeLatch.await();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、dubbo-provider.xml和dubbo-consumer.xml中需要注意的一些问题&lt;/h2&gt;
&lt;p&gt;dubbo-provider.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xmlns:dubbo&lt;/span&gt;&lt;span&gt;=&quot;http://code.alibabatech.com/schema/dubbo&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:application &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;demo-provider&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; use multicast registry center to export service &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:registry &lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;=&quot;zookeeper://192.168.99.100:2181&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; use dubbo protocol to export service on port 20880 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:protocol &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dubbo&quot;&lt;/span&gt;&lt;span&gt; port&lt;/span&gt;&lt;span&gt;=&quot;20880&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; service implementation, as same as regular local bean &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;helloService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.zhyonk.service.Impl.HelloServiceImpl&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; declare the service interface to be exported &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:service &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;=&quot;com.zhyonk.service.HelloService&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;helloService&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dubbo-consumer.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:dubbo&lt;/span&gt;&lt;span&gt;=&quot;http://code.alibabatech.com/schema/dubbo&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:application &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;wreserve-wechat&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dubbo:application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;zookeeper注册中心 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:registry
        &lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;=&quot;zookeeper://192.168.99.100:2181&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dubbo:registry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:consumer &lt;/span&gt;&lt;span&gt;check&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; timeout&lt;/span&gt;&lt;span&gt;=&quot;60000&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 生成远程服务代理，可以和本地bean一样使用demoService &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:reference &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;helloService&quot;&lt;/span&gt;&lt;span&gt;
        interface&lt;/span&gt;&lt;span&gt;=&quot;com.zhyonk.wreserve.service.HelloService&quot;&lt;/span&gt;&lt;span&gt; protocol&lt;/span&gt;&lt;span&gt;=&quot;dubbo&quot;&lt;/span&gt;&lt;span&gt;
        timeout&lt;/span&gt;&lt;span&gt;=&quot;15000&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1、消费者要访问提供者，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:reference &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;helloService&quot;&lt;/span&gt;&lt;span&gt;
        interface&lt;/span&gt;&lt;span&gt;=&quot;com.zhyonk.wreserve.service.HelloService&quot;&lt;/span&gt;&lt;span&gt; protocol&lt;/span&gt;&lt;span&gt;=&quot;dubbo&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; service implementation, as same as regular local bean &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;helloService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.zhyonk.service.Impl.HelloServiceImpl&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; declare the service interface to be exported &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:service &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;=&quot;com.zhyonk.service.HelloService&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;helloService&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的interface必须要求同一个路径之下，不然对应不上，会出现下面的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1081162/201808/1081162-20180824233951236-1750875628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正常情况下dubbo-admin中会显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1081162/201808/1081162-20180824234324888-620834878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、如果嫌自己搭建麻烦的话可以直接用用网站自动生成 http://start.dubbo.io/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1081162/201808/1081162-20180824234614168-1050868722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就先到这，睡了&lt;/p&gt;

</description>
<pubDate>Fri, 24 Aug 2018 15:47:00 +0000</pubDate>
<dc:creator>zhyonk</dc:creator>
<og:description>近期在研究dubbo框架 相信看到这篇博客的，dubbo的基础应该都有了 zookeeper的搭建走了点弯路，配置起来各种麻烦，妈的搞的好烦。 正好一直想用一下docker，但对docker只是有个简</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhyonk/p/9532499.html</dc:identifier>
</item>
<item>
<title>深入理解：HTML元素特性attribute 和 DOM元素节点对象属性property区别 以及DOM元素样式操作总结 - 无退路只能勇往直前</title>
<link>http://www.cnblogs.com/webxu20180730/p/9532442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/webxu20180730/p/9532442.html</guid>
<description>&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　查一下英语单词解释，两个都可以表示属性。但&lt;/span&gt;attribute&lt;span&gt;倾向于解释为特质，而&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;倾向于解释私有的。这个&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;的私有解释可以更方便我们下面的理解。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;第一部分：区别点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　&lt;strong&gt;第一点： &lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　特性&lt;/span&gt;attribute&lt;span&gt;主要是面向&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;元素来理解的，所以说主要是表现在&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;文件中，写在元素开始标签内。&lt;/span&gt;特性在CSS&lt;span&gt;中的表现&lt;/span&gt;常被用来作选择器&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　属性&lt;/span&gt;property&lt;span&gt;主要是面向&lt;/span&gt;&lt;span&gt;DOM&lt;/span&gt;&lt;span&gt;节点对象来理解的，作为对象的私有属性，不对外显示的。&lt;/span&gt;属性在CSS&lt;span&gt;中表现就是&lt;/span&gt;&lt;span&gt;{  }&lt;/span&gt;&lt;span&gt;内的内容。&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE &amp;lt;!DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document Example&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        #myId&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 16px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里的名值对是属性 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;= &quot;myId&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;myClass&quot;&lt;/span&gt;&lt;span&gt; data-zdy&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;color:red;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Text&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 这里标签内的名值对都是特性 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt;  　　&lt;strong&gt;第二点：　&lt;/strong&gt;　&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　在引擎渲染&lt;/span&gt;HTML&lt;span&gt;结构成&lt;/span&gt;&lt;span&gt;DOM&lt;/span&gt;&lt;span&gt;树状模型的时候，&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;元素中公认的标准特性(非自定义的特性）会被添加&lt;/span&gt;&lt;span&gt;DOM&lt;/span&gt;&lt;span&gt;节点对象的属性中，并且是一对一映射，任何一方的改变都会影响到另一方。所以对&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;元素标准特性的读写都可以通过元素对象的属性方式进行操作，即点&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt;。&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; node &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementsByTagName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]; 
    node.id &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; myNewId &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标签内的元素特性ID，一对一映射到DOM里的P对象里，通过对象属性的获取方式读写元素的特性名&lt;/span&gt;
&lt;span&gt;    console.log(node.id);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象里的属性改变，浏览器视图中DOM树中p节点特性值也改变  &lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1453557/201808/1453557-20180824220917805-699111144.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt; &lt;span&gt;　　&lt;/span&gt;&lt;span&gt;在引擎渲染&lt;/span&gt;HTML&lt;span&gt;结构成&lt;/span&gt;&lt;span&gt;DOM&lt;/span&gt;&lt;span&gt;树状模型的时候，&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;元素中的特性会作为元素的&lt;/span&gt;&lt;span&gt;Attr&lt;/span&gt;&lt;span&gt;属性节点被保存在对应&lt;/span&gt;&lt;span&gt;DOM&lt;/span&gt;&lt;span&gt;元素节点对象的&lt;/span&gt;&lt;span&gt;attribute&lt;/span&gt;&lt;span&gt;属性的&lt;/span&gt;&lt;span&gt;NamedNodeMap&lt;/span&gt;&lt;span&gt;属性对象中，包括自定义特性。但自定义特性不被显示在DOM渲染的树中。可以通过元素的&lt;/span&gt;&lt;span&gt;attribute&lt;/span&gt;&lt;span&gt;属性对象访问属性节点，就是访问元素特性。&lt;/span&gt;（JS&lt;span&gt;高程&lt;/span&gt;p266 p276 &lt;span&gt;页）&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; node &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementsByTagName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]; 
    console.log(node.childNodes);  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p标签里的id/class/标签特性作为DOM树中的Atrr节点 ，但style作为特殊性质和自定义特性不能渲染成特性节点&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; p &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementsByTagName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    console.log(p.attributes[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过p对象的attributes属性对象读取标准特性节点&lt;/span&gt;
&lt;span&gt;    console.log(p.attributes[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data-zdy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过p对象的attributes属性对象读取自定义节点,&lt;span&gt;写全拼，包括data- 返回节点字符串&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;    console.log(p.attributes[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data-zdy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].value); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过p对象的attributes属性对象读取自定义节点&lt;/span&gt;
&lt;span&gt;    console.log(p.attributes[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data-zdy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].nodeValue); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过p对象的attributes属性对象读取自定义节点&lt;/span&gt;
&lt;span&gt;    console.log(p.dataset); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过自定义属性专有的方法读取自定义特性,&lt;span&gt;返回DOMStringMap对象&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;    console.log(p.dataset.zdy); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过自定义属性专有的方法读取自定义特性，&lt;span&gt;不包括data-&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1453557/201808/1453557-20180824222535881-2099733773.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　&lt;strong&gt;第三点：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　特性在DOM&lt;span&gt;中&lt;/span&gt;&lt;span&gt;可以通过&lt;/span&gt;Attr&lt;span&gt;节点方式访问&lt;/span&gt;：ele.getAttributeNode( ).value/nodeValue&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　在&lt;/span&gt;DOM&lt;span&gt;元素对象也定义了专属的方法对特性进行读写：&lt;/span&gt;&lt;span&gt;getAttribute()/setAttribute()/removeAttribute() P264&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; node &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementsByTagName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]; 
    console.log(node.getAttributeNode(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Attr节点的方法获取id&lt;/span&gt;
&lt;span&gt;    console.log(node.getAttributeNode(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).nodeValue);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Attr节点的方法读取节点值&lt;/span&gt;
&lt;span&gt;    console.log(node.getAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取calss的值&lt;/span&gt;
&lt;span&gt;    node.removeAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除class&lt;/span&gt;
&lt;span&gt;    console.log(node.getAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再读取class返回null&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1453557/201808/1453557-20180824230211017-2107403818.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;　　第四点：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　特性和属性都可以自定义，自定义的特性和&lt;/span&gt;&lt;span&gt;自定义的属性不能在&lt;/span&gt;&lt;span&gt;DOM&lt;/span&gt;&lt;span&gt;结构中体现，只能通过对象自身调用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　HTML5&lt;span&gt;规定可以为元素添加非标准的特性，即自定义特性，但是要求添加&lt;/span&gt;&lt;span&gt;data-&lt;/span&gt;&lt;span&gt;前缀。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　可以手动在&lt;/span&gt;HTML&lt;span&gt;元素开始标签内添加，也可以在&lt;/span&gt;&lt;span&gt;JS&lt;/span&gt;&lt;span&gt;代码中通过元素&lt;/span&gt;&lt;span&gt;dataset&lt;/span&gt;&lt;span&gt;属性来读写自定义属性。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　通过&lt;/span&gt;dataset&lt;span&gt;属性读写时属性名时不需要加&lt;/span&gt;&lt;span&gt;data-&lt;/span&gt;&lt;span&gt;前缀。但是这样自定义的属性通过&lt;/span&gt;对象&lt;span&gt;方法&lt;/span&gt;get/set/removeAttribute&lt;span&gt;读写时需要加上&lt;/span&gt;&lt;span&gt;data-,&lt;/span&gt;&lt;span&gt;用全称表示 （JS高程&lt;/span&gt;&lt;span&gt;p293页）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　&lt;strong&gt;（例子见上面第二点第二条）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;第二部分：标准特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;　　公认的标准元素特性没几个，主要有：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　所有元素都有的特性：&lt;/span&gt;id / class / title / lang / dir / style / onclick&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　表单元素专有的部分特性：&lt;/span&gt;type / name / value&lt;span&gt;等&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　&lt;span&gt;有两类特殊的特性，它们虽然在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;DOM&lt;span&gt;对象中也有映射对应的属性名，但是通过特性专属的方式&lt;/span&gt;&lt;span&gt;getAttribute()&lt;/span&gt;&lt;span&gt;和对象属性点&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt;操作返回的值是不一样的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　&lt;span&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;用于&lt;/span&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;span&gt;方式为元素指定样式，通过&lt;/span&gt;&lt;span&gt;getAttribute&lt;/span&gt;&lt;span&gt;（）返回的是整个&lt;/span&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;span&gt;文本字符串，而通过对象&lt;/span&gt;&lt;span&gt;ele.style&lt;/span&gt;&lt;span&gt;返回的包含对象&lt;/span&gt;&lt;span&gt;css&lt;/span&gt;&lt;span&gt;样式的&lt;/span&gt;&lt;span&gt;CSSStyleDeclaration&lt;/span&gt;&lt;span&gt;对象。但映射关系成立，仍然可以通过　　&lt;/span&gt;&lt;span&gt;setAttribute&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;&quot;style&quot;,&quot;&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;）来设置修改元素样式&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; node &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementsByTagName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]; 
    console.log(node.style); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取style特性，返回的是CSSStyleDeclaration对象&lt;/span&gt;
&lt;span&gt;    console.log(node.getAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回style样式的字符串文本&lt;/span&gt;
&lt;span&gt;    node.setAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:#000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过对象特性修改字体颜色可以有映射关系&lt;/span&gt;
&lt;span&gt;    console.log(node.attributes[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].value);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象方法修改字体行内样式，体现在元素节点特性也映射改变&lt;/span&gt;
&lt;span&gt;    node.style.color &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象属性方式修改行内样式&lt;/span&gt;
&lt;span&gt;    console.log(node.attributes[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].value);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象属性修改字体行内样式，体现在元素节点特性也映射改变&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1453557/201808/1453557-20180824225839481-739292358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;onclick&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;属性也是一样，当用&lt;/span&gt;&lt;span&gt;getAttribute(&quot;onclick&quot;)&lt;/span&gt;&lt;span&gt;读取时，返回的整段&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;span&gt;代码字符串，而通过对象属性&lt;/span&gt;&lt;span&gt;ele.onclick&lt;/span&gt;&lt;span&gt;返回是&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;strong&gt;第二部分：操作特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　所以当我们平常操作时，读写元素属性时，先区分下到底是读写元素特性还是对象属性，以便选择对应的操作代码方式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;　　读写一个元素的特性：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　W3C&lt;span&gt;规范的已有特性节点访问方式：&lt;/span&gt;&lt;span&gt;　　　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ele.attritubes[&quot;特性名&quot;].value或.nodeVlue   写入： = &quot;特性值&quot;&lt;br/&gt;如果新增特性：
var newAttr = document.createAttribute(&quot;myAttr&quot;)  //创建新的特性节点：
newAttr.value = &quot;newValue&quot; //新节点赋值
ele.setAttributeNode(newAttr)  //对元素设置新特性节点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt;  　&lt;strong&gt;　但一般不用上面的繁琐的方法，常用下面的简单操作：&lt;/strong&gt; &lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1、对象的特性操作方法：
　　读：ele.getAttribute(&quot;attrName&quot;)
　　写：ele.setAttribute(&quot;attrName&quot;,&quot;value&quot;)
　　删：ele.removeAttribute(&quot;attrName&quot;)

2、作为对象属性的操作方法：ele.attrName   ele[&quot;attrName&quot;]

3、如果是自定义属性，也可以是：
读：ele.dataset.attrName    写：ele.dataset.attrName = “value”  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt; 　　很多教材上并没有严格区分特性和属性，只是在《javascript高级程序设计里》有区分这两个概念，但里面也提到一句”所有特性都是属性“，所以在平时并不需要严格去区分它们。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;我也只是在JS学习中，对如何读写元素样式的很多方法上容易搞蒙圈，所以就理解这两个概念，可以很好的区分读写样式的一些方法，思路会清晰很多。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　元素CSS操作的样式基本都是DOM对象的属性，在JS中只通过一种方式来读写操作，就是全通过style对象。在渲染过程中style特性会转变成元素的style属性，这是一个对象属性，拥有自己操作样式的属性和方法。比如&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　行内样式的属性直接通过style对象的点. 和[ ] 操作即可，也可以用style对象的方法：ele.style.cssText/item(index)/getPropertyValue()/setProperty(name,value)/removeProperty()。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　　在内嵌和外部样式中，获取到样式表目标样式表&amp;gt;样式规则&amp;gt;具体样式：stylesheet[ i ].cssRule[ i ].style的各种操作。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;　&lt;strong&gt;&lt;span&gt;　总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;p&quot;&gt;&lt;span&gt;　　JS中行内元素的特性读写操作：1、通过元素对象的自身的属性方法读写；   2、通过DOM中特性节点读写  3、自定义特性专属的方法dataset&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;p&quot;&gt;&lt;span&gt;　　JS中对象属性的新式读写操作：style对象的属性和方法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Fri, 24 Aug 2018 15:23:00 +0000</pubDate>
<dc:creator>无退路只能勇往直前</dc:creator>
<og:description>查一下英语单词解释，两个都可以表示属性。但attribute倾向于解释为特质，而property倾向于解释私有的。这个property的私有解释可以更方便我们下面的理解。 第一部分：区别点 第一点：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/webxu20180730/p/9532442.html</dc:identifier>
</item>
<item>
<title>Mysql优化之索引 - 不做空指针</title>
<link>http://www.cnblogs.com/onlylikelearn/p/9523899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onlylikelearn/p/9523899.html</guid>
<description>&lt;p&gt;　　这几天抽了个时间将《高性能Mysql》看了一下忽觉索引非常之重要，习之然后总结巩固知识。本文索引使用的是InnoDB存储引擎。因为本文并不是说用索引的好处，所以并不会书写QPS之类的测试结果请大家见谅。我的mysql版本是8.0.11。&lt;/p&gt;

&lt;p&gt;　　（一）索引使用优化&lt;/p&gt;
&lt;p&gt;　　　　　 ①独立的列&lt;/p&gt;
&lt;p&gt;                  ②覆盖索引&lt;/p&gt;
&lt;p&gt;                  ③索引匹配&lt;/p&gt;
&lt;p&gt;　　（二）索引创建优化&lt;/p&gt;
&lt;p&gt;　　　　　 ①前缀索引和索引选择性&lt;/p&gt;
&lt;p&gt;                   ②选择合适的索引顺序&lt;/p&gt;
&lt;p&gt;                   ③不创建冗余和重复索引&lt;/p&gt;

&lt;p&gt;　　我们有时候虽然创建了合适的索引但是使用不当依然会使索引失效，所以我将书上的索引使用大致总结了一下。在这之前我先介绍一下EXPLAIN生成结果中字段type和Extra的意义,先说一下type常出现的结果。&lt;/p&gt;
&lt;p&gt;　　（1）const 表中最多只有一行用于主键和唯一索引的匹配&lt;/p&gt;
&lt;p&gt;　　（2）all全表扫描&lt;/p&gt;
&lt;p&gt;　　（3）ref使用索引并符合最左匹配&lt;/p&gt;
&lt;p&gt;　　（4）index ：❶&lt;/p&gt;
&lt;p&gt;　　　　　　a.当查询是索引覆盖的，即所有数据均可从索引树获取的时候（Extra中有Using Index）；&lt;/p&gt;
&lt;p&gt;　　　　　　b.以索引顺序从索引中查找数据行的全表扫描（无 Using Index）；&lt;/p&gt;
&lt;p&gt;　　　　　　c.如果Extra中Using Index与Using Where同时出现的话，则是利用索引查找键值的意思；&lt;/p&gt;
&lt;p&gt;　　　　　　d.如单独出现，则是用读索引来代替读行，但不用于查找&lt;/p&gt;
&lt;p&gt;　　接下来我们解释一下Extra出现的结果：&lt;/p&gt;
&lt;p&gt;　　 （1）using index 使用覆盖索引。&lt;/p&gt;
&lt;p&gt;　　 （2）using where 条件语句中部分条件使用的是索引，其他条件需要去表中筛选。&lt;/p&gt;
&lt;p&gt;　　 （3）using inex condition 条件语句中所有条件都在索引中，但是所需要的数据不在索引中。&lt;/p&gt;
&lt;p&gt;　　 （4）using where;using index 条件和所需数据都在索引中。&lt;/p&gt;
&lt;h2&gt;　独立的列&lt;/h2&gt;
&lt;p&gt;　　独立的列一眼上看去以为是针对于一个单独的列创建索引但是实际上并不是这样的。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数❷。这句话的前面一句话在书上是：如果使用独立的列则mysql不会使用索引。这句话有点模棱两可，“不会使用索引”到底是包括索引全扫描还是不包括索引全扫描，如果包括的话则与实验结果不相符，如果不包括的话那就没问题了。废话不多说还是用结果来证明吧。首先我的数据库表结构是这样子的，如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1418506/201808/1418506-20180822153952668-981979634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我创建了两个单独列的索引用来测试表达式和函数如下图所示:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1418506/201808/1418506-20180822154931727-401035018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/1418506/201808/1418506-20180823213130430-19903967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　测试sql: explain select age  from user where age =2;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1418506/201808/1418506-20180822155258984-1184667843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从测试结果中我们可以看到type为ref(使用BTree索引),Extra为Using index(使用了覆盖索引)&lt;/p&gt;
&lt;p&gt;　　如果我们把sql语句改为： explain select age from user where age+1=2;解释结果如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1418506/201808/1418506-20180823213346648-1971278128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到这条查询语句是使用了索引的，不过是扫描索引的全部数据。接下来测试一下如果条件语句中使用了函数是否会使用索引我的sql语是：EXPLAIN SELECT id from user where TO_DAYS(birthday) &amp;gt;= 50000000;测试结果如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1418506/201808/1418506-20180823214112321-1477149846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　OK，结果也是index。至于书上那句话是对是错我就不得而知了，不过大家可以自己去测试一下。&lt;/p&gt;


&lt;h2&gt;　覆盖索引&lt;/h2&gt;
&lt;p&gt; 　如果把使用索引比作你开了一辆五菱宏光的话，那么你使用覆盖索引就是开了一辆兰博基尼（兰博基尼的性能是由你自己来决定的）。覆盖索引简单的来讲就是你所要查询的字段和条件语句都在一条索引中。接下来又是证明的过程，我创建一个新的索引如下图所示:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1418506/201808/1418506-20180823232856180-790037017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后我使用这条sql语句 EXPLAIN SELECT first_name,age from user where  first_name='张' and age &amp;gt;0，在这条sql语句中我查询两个不同索引中的列查询结果如下所示;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1418506/201808/1418506-20180823233618918-1687993418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在这条sql语句中我使用了两个索引idx_fk_name和idx_fk_age，查询的列和查询条件都是在这两个索引中，测试的结果为using where(需要回表查询所需要的数据)。接下来我们使用这个sql语句 EXPLAIN SELECT last_name FROM user where first_name = '张',使用结果如下图所示：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1418506/201808/1418506-20180824173331350-1748020297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　如果我们书写的sql语句符合索引匹配原则，那么我们就可以不进行索引的全部数据扫描，结果就是我们的查询效率又变高了。那么索引匹配原则是啥？我就简略的总结一下吧。&lt;/p&gt;
&lt;h3&gt;　   全值匹配&lt;/h3&gt;
&lt;p&gt;　　全值匹配就是查询条件和索引中的所有列进行匹配。如我上面创建的idx_fx_name索引。select * from user where first_name='张' 和 last_name = '三' 这条sql语句就是全值匹配。注意如果写成last_name='三' and first_name='张'也是全值匹配&lt;/p&gt;
&lt;h3&gt;　　最左匹配&lt;/h3&gt;
&lt;p&gt;　　 我把书中匹配最左前缀和匹配列前缀都划分为最左匹配，因为我觉得它都是从最左边开始匹配的，好像网上也是这么说的。&lt;/p&gt;
&lt;p&gt;　　最左前缀就是你写的条件查询语句针对于某个索引来说它符合从左边一个一个进行匹配的方式（经过实测条件语句的顺序不影响最左匹配的原则）,再拿我的idx_fx_name索引来举个例子。如select * from user where last_name = '三'和 select * from user where first_name = '张' 这两个sql语句查询索引的方式都不一样，前者是扫描索引所有数据，第二个就只扫描了索引的部分数据。测试结果如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1418506/201808/1418506-20180824211003790-906373429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1418506/201808/1418506-20180824211121079-1380678200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　匹配范围值&lt;/h3&gt;
&lt;p&gt;　　 在符合最左匹配的基础上可以使用范围进行查询。&lt;/p&gt;
&lt;h3&gt;　　 精确匹配加范围匹配&lt;/h3&gt;
&lt;p&gt;　　  在符合最左匹配的基础上最后一个查询条件可以记性范围查询。&lt;/p&gt;


&lt;h2&gt;　　前缀索引和索引选择性&lt;/h2&gt;
&lt;p&gt;　　　我们先说说索引的选择性吧。索引的选择性是指不重复的索引值（也称为基数,cardinality）和数据表的记录总数（#T）的比值,范围从1/#T到1之间❸。这句话通俗的理解就是你选择作为索引（当然是只能选择某个字段，字段的全部或者部分）的数据在表中这个字段列中重复率越低越好，因为这样可以过滤更多的数据行。前缀索引就是可以拿某个字段的前缀作为索引之所以把前缀所以和索引选择性放到一起说是为了解决当我们选择一个特别长的字段作为索引时首先会很浪费空间其次是查询的时候速度肯定会比较慢。&lt;/p&gt;
&lt;p&gt;　　  那么我们怎么计算索引选择性的高低呢？这个有方法的，方法就是通过关键字DISTINCT 和 Count来计算索引的选择性。如我计算first_name的选择性高低可以这样计算：&lt;/p&gt;
&lt;p&gt;　　 select count(DISTINCT first_name) / count(1) as a1 from user;&lt;/p&gt;
&lt;p&gt;　　 如果我要计算以first_name前三个字符作为索引的话计算选择性可以这样写：&lt;/p&gt;
&lt;p&gt;　　 select count(DISTINCT LEFT(first_name,3)) / count(1) as a1 from user;&lt;/p&gt;
&lt;p&gt;　　 通过不断的修改所包含的前缀的大小我们就能找到选择性高的索引。&lt;/p&gt;
&lt;h2&gt;　  选择合适的索引序列&lt;/h2&gt;
&lt;p&gt;　　  其实选择合适的索引序列我觉得根据实际情况来做分析。不过一般来说我们都把选择性高的放在前面，其他的就是要根据where子句中的排序、分组和范围条件等其他因素来选择索引的序列&lt;/p&gt;
&lt;h2&gt;　  不创建冗余和重复的索引&lt;/h2&gt;
&lt;p&gt;　　  这里有两个问题摆在我们的面前什么是冗余的索引？什么是重复索引？&lt;/p&gt;
&lt;p&gt;　　 重复索引：具有相同列的索引就是重复索引。如(A,B)和(B,A)就是重复索引。&lt;/p&gt;
&lt;p&gt;　　 冗余索引：一个索引的子集就是冗余索引。如(A,B,C) 和(A,B) (B,C)就是冗余索引。&lt;/p&gt;
&lt;p&gt;　　 从一般情况来说就是尽量不创建重复索引和冗余索引，但是在特殊的情况下我们可以创建冗余索引。&lt;/p&gt;


&lt;p&gt;　　以上就是我学习《高性能mysql》书籍的总结。如果有什么问题请大家及时反馈给我毕竟互相交流才能促进学习。&lt;/p&gt;

&lt;p&gt;❶http://blog.51cto.com/lijianjun/1881208&lt;/p&gt;
&lt;p&gt;❷《高性能mysql》第五章第三节&lt;/p&gt;
&lt;p&gt;❸《高性能msql》第五章第三节第二小节&lt;/p&gt;
</description>
<pubDate>Fri, 24 Aug 2018 15:02:00 +0000</pubDate>
<dc:creator>不做空指针</dc:creator>
<og:description>前言 这几天抽了个时间将《高性能Mysql》看了一下忽觉索引非常之重要，习之然后总结巩固知识。本文索引使用的是InnoDB存储引擎。因为本文并不是说用索引的好处，所以并不会书写QPS之类的测试结果请大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/onlylikelearn/p/9523899.html</dc:identifier>
</item>
<item>
<title>Java文件操作类效率对比 - xiaoxi666</title>
<link>http://www.cnblogs.com/xiaoxi666/p/9531893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxi666/p/9531893.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;众所周知，Java中有多种针对文件的操作类，以面向字节流和字符流可分为两大类，这里以写入为例：&lt;/p&gt;
&lt;p&gt;面向字节流的：FileOutputStream 和 BufferedOutputStream&lt;/p&gt;
&lt;p&gt;面向字符流的：FileWriter 和 BufferedWriter&lt;/p&gt;
&lt;p&gt;近年来发展出New I/O ，也叫NIO，里面又包装了两个类：NewOutputStream 和 NewBufferedWriter&lt;/p&gt;
&lt;p&gt;现在，我们建立测试程序，比较这些类写入文件的性能。&lt;/p&gt;
&lt;h2&gt;机器配置&lt;/h2&gt;
&lt;ul&gt;&lt;li class=&quot;p1&quot;&gt;  &lt;span&gt;Processor Name: &lt;span class=&quot;Apple-tab-span&quot;&gt;Intel Core i7&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  Processor Speed: &lt;span class=&quot;Apple-tab-span&quot;&gt;2.2 GHz&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  Number of Processors: &lt;span class=&quot;Apple-tab-span&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  Total Number of Cores: &lt;span class=&quot;Apple-tab-span&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  L2 Cache (per Core): &lt;span class=&quot;Apple-tab-span&quot;&gt;256 KB&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  L3 Cache: &lt;span class=&quot;Apple-tab-span&quot;&gt;6 MB&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  Memory: &lt;span class=&quot;Apple-tab-span&quot;&gt;16 GB&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;测试程序&lt;/h2&gt;
&lt;p&gt;纵向比较：几种文件操作类向文件中写入相同行数的内容（每行内容均为“写入文件Data\n”），比较其耗费时间&lt;/p&gt;
&lt;p&gt;横向比较：对于同一个文件操作类，比较写入不同行数内容情况下所耗费时间；本文以2的次方指数级增长行数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileOutputStream;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.file.Files;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.file.Paths;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; testFileIO {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testDriver () &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; maxlineNum = 100000001;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入文件的最大行数&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; startlineNum = 1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入文件的行数&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; Multiplying = 2;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;行数增长倍率&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; begin = 0L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; end = 0L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将时间统计写入文件Result.txt中&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;         FileWriter fileWriter = &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;./Result.txt&quot;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;         BufferedWriter bufferedWriter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedWriter(fileWriter);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;         System.out.println(&quot;Test FileOutputStream begin.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; lineNum = startlineNum; lineNum &amp;lt; maxlineNum; lineNum *=&lt;span&gt; Multiplying) {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             begin =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;            testFileOutputStream(lineNum);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             end =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; timeElapse_FileOutputStream = end -&lt;span&gt; begin;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             bufferedWriter.write(String.valueOf(timeElapse_FileOutputStream)+&quot;\t&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         System.out.println(&quot;Test FileOutputStream end.\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;         System.out.println(&quot;Test BufferedOutputStream begin.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         bufferedWriter.write(&quot;\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; lineNum = startlineNum; lineNum &amp;lt; maxlineNum; lineNum *=&lt;span&gt; Multiplying) {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;             begin =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;            testBufferedOutputStream(lineNum);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             end =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; timeElapse_BufferedOutputStream = end -&lt;span&gt; begin;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             bufferedWriter.write(String.valueOf(timeElapse_BufferedOutputStream)+&quot;\t&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         System.out.println(&quot;Test BufferedOutputStream end.\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;         System.out.println(&quot;Test FileWriter begin.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         bufferedWriter.write(&quot;\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; lineNum = startlineNum; lineNum &amp;lt; maxlineNum; lineNum *=&lt;span&gt; Multiplying) {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             begin =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;            testFileWriter(lineNum);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             end =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; timeElapse_FileWriter = end -&lt;span&gt; begin;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             bufferedWriter.write(String.valueOf(timeElapse_FileWriter)+&quot;\t&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         System.out.println(&quot;Test FileWriter end.\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;         System.out.println(&quot;Test BufferedWriter begin.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         bufferedWriter.write(&quot;\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; lineNum = startlineNum; lineNum &amp;lt; maxlineNum; lineNum *=&lt;span&gt; Multiplying) {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             begin =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;            testBufferedWriter(lineNum);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             end =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; timeElapse_BufferedWriter = end -&lt;span&gt; begin;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             bufferedWriter.write(String.valueOf(timeElapse_BufferedWriter)+&quot;\t&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         System.out.println(&quot;Test BufferedWriter end.\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt;         System.out.println(&quot;Test NewOutputStream begin.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         bufferedWriter.write(&quot;\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; lineNum = startlineNum; lineNum &amp;lt; maxlineNum; lineNum *=&lt;span&gt; Multiplying) {
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;             begin =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;            testNewOutputStream(lineNum);
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             end =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; timeElapse_NewOutputStream = end -&lt;span&gt; begin;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             bufferedWriter.write(String.valueOf(timeElapse_NewOutputStream)+&quot;\t&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         System.out.println(&quot;Test NewOutputStream end.\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;         System.out.println(&quot;Test NewBufferedWriter begin.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         bufferedWriter.write(&quot;\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; lineNum = startlineNum; lineNum &amp;lt; maxlineNum; lineNum *=&lt;span&gt; Multiplying) {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             begin =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;            testNewBufferedWriter(lineNum);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             end =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; timeElapse_NewBufferedWriter = end -&lt;span&gt; begin;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             bufferedWriter.write(String.valueOf(timeElapse_NewBufferedWriter)+&quot;\t&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;         System.out.println(&quot;Test NewOutputStream end.\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        bufferedWriter.close();
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;************************ I/O ****************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;面向字节&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testFileOutputStream (&lt;span&gt;int&lt;/span&gt; lineNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         FileOutputStream fileOutputStream = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&lt;span&gt;new&lt;/span&gt; File(&quot;./testFileOutputStream.txt&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (--lineNum &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             fileOutputStream.write(&quot;写入文件Data\n&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;        fileOutputStream.close();
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testBufferedOutputStream (&lt;span&gt;int&lt;/span&gt; lineNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         FileOutputStream fileOutputStream = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&lt;span&gt;new&lt;/span&gt; File(&quot;./testBufferedOutputStream.txt&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;         BufferedOutputStream bufferedOutputStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedOutputStream(fileOutputStream);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (--lineNum &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             bufferedOutputStream.write(&quot;写入文件Data\n&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;        bufferedOutputStream.close();
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;面向字符&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testFileWriter (&lt;span&gt;int&lt;/span&gt; lineNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         FileWriter fileWriter = &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;./testFileWriter.txt&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (--lineNum &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;             fileWriter.write(&quot;写入文件Data\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        fileWriter.close();
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testBufferedWriter (&lt;span&gt;int&lt;/span&gt; lineNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;         FileWriter fileWriter = &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;./testBufferedWriter.txt&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         BufferedWriter bufferedWriter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedWriter(fileWriter);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (--lineNum &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             bufferedWriter.write(&quot;写入文件Data\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;        bufferedWriter.close();
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;************************ NIO ***************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testNewOutputStream (&lt;span&gt;int&lt;/span&gt; lineNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         OutputStream outputStream = Files.newOutputStream(Paths.get(&quot;./testNewOutputStream.txt&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (--lineNum &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             outputStream.write(&quot;写入文件Data\n&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;        outputStream.close();
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testNewBufferedWriter (&lt;span&gt;int&lt;/span&gt; lineNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;         BufferedWriter newBufferedReader = Files.newBufferedWriter(Paths.get(&quot;./testNewBufferedWriter.txt&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (--lineNum &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             newBufferedReader.write(&quot;写入文件Data\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;        newBufferedReader.close();
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; 
&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main (String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;多次测试时可清空result.txt文件&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt;         FileWriter fileWriter = &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;./Result.txt&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;        testDriver();
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;测试结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/609124/201808/609124-20180824204619486-720079896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，写入行数超过20W以上时，FileOutputStream和NewOutputStream耗费时间远远超出其他4个类。为了清晰，让我们放大其他4个类的图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/609124/201808/609124-20180824210252410-2139283594.png&quot; alt=&quot;&quot; width=&quot;763&quot; height=&quot;426&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，这4个类中，BufferWriter和NewBufferedWriter所耗费时间更少，但总体差别不是很大。&lt;/p&gt;
&lt;p&gt;让我们再来看看，写入26W行数据以下时的情况：&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/609124/201808/609124-20180824210305736-863532696.png&quot; alt=&quot;&quot; width=&quot;719&quot; height=&quot;427&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 可以看出，在数据量较小的情况下，这4个类所耗费时间的差异并不是很大，在更小的数据量下，它们的效率几乎没有差别。&lt;/p&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;从以上分析可知（注意横坐标写入行数是指数级增加的），各个类的时间复杂度大致为O(1/kn)，其中不同的类的k不同，导致了最终巨大的差异。&lt;/p&gt;
&lt;p&gt;这里只给出了测试结果，并未分析其底层实现原理，欢迎评论区留言。&lt;/p&gt;
&lt;p&gt;另外，我没有在其他机器测试，有兴趣的小伙伴可以将自己的测试结果发出来，共同进步^_^&lt;/p&gt;
&lt;h2&gt;附件&lt;/h2&gt;
&lt;p&gt;本次测试数据结果(若看不清，可以下载到本地看)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/609124/201808/609124-20180824214613073-650515128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 24 Aug 2018 13:48:00 +0000</pubDate>
<dc:creator>xiaoxi666</dc:creator>
<og:description>前言 众所周知，Java中有多种针对文件的操作类，以面向字节流和字符流可分为两大类，这里以写入为例： 面向字节流的：FileOutputStream 和 BufferedOutputStre</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxi666/p/9531893.html</dc:identifier>
</item>
<item>
<title>Spring之Bean的作用域与生命周期 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/9532057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/9532057.html</guid>
<description>&lt;p&gt;在前面博客中提到容器启动获得BeanDefinition对象中有一个scope 属性。该属性控制着bean对象的作用域。本章节介绍Bean的作用域及生命周期，了解bean是怎么来的又怎么没的。&lt;/p&gt;
&lt;p&gt;一、Bean的作用域&lt;br/&gt;在Bean容器启动会读取bean的xml配置文件，然后将xml中每个bean元素分别转换成BeanDefinition对象。在BeanDefinition对象中有scope 属性，就是它控制着bean的作用域。&lt;br/&gt;Spring框架支持5种作用域，有三种作用域是当开发者使用基于web的ApplicationContext的时候才生效的。下面就是Spring直接支持的作用域了，当然开发者也可以自己定制作用域。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;作用域&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;
&lt;p align=&quot;center&quot;&gt;单例&lt;span&gt;(singleton)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;283&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;（默认）每一个&lt;span&gt;Spring IoC&lt;/span&gt;&lt;span&gt;容器都拥有唯一的一个实例对象&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;
&lt;p align=&quot;center&quot;&gt;原型（&lt;span&gt;prototype&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;283&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;一个&lt;span&gt;Bean&lt;/span&gt;&lt;span&gt;定义，任意多个对象&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;
&lt;p align=&quot;center&quot;&gt;请求（&lt;span&gt;request&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;283&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;center&quot;&gt;一个&lt;span&gt;HTTP&lt;/span&gt;&lt;span&gt;请求会产生一个&lt;/span&gt;&lt;span&gt;Bean&lt;/span&gt;&lt;span&gt;对象，也就是说，每一个&lt;/span&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;span&gt;请求都有自己的&lt;/span&gt;&lt;span&gt;Bean&lt;/span&gt;&lt;span&gt;实例。只在基于&lt;/span&gt;&lt;span&gt;web&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Spring ApplicationContext&lt;/span&gt;&lt;span&gt;中可用&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;
&lt;p align=&quot;center&quot;&gt;会话（&lt;span&gt;session&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;283&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;center&quot;&gt;限定一个&lt;span&gt;Bean&lt;/span&gt;&lt;span&gt;的作用域为&lt;/span&gt;&lt;span&gt;HTTPsession&lt;/span&gt;&lt;span&gt;的生命周期。同样，只有基于&lt;/span&gt;&lt;span&gt;web&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Spring ApplicationContext&lt;/span&gt;&lt;span&gt;才能使用&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;全局会话（&lt;span&gt;global session&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;283&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;center&quot;&gt;限定一个&lt;span&gt;Bean&lt;/span&gt;&lt;span&gt;的作用域为全局&lt;/span&gt;&lt;span&gt;HTTPSession&lt;/span&gt;&lt;span&gt;的生命周期。通常用于门户网站场景，同样，只有基于&lt;/span&gt;&lt;span&gt;web&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Spring ApplicationContext&lt;/span&gt;&lt;span&gt;可用&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们可以以XMLInstance类为基础演示一下singleton和prototype作用域。&lt;br/&gt;这里使用通过BeanFactory的getBean方法获取两次bean对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        XMLInstance instance=(XMLInstance)factory.getBean(&quot;xmlinstance&quot;&lt;span&gt;);
        instance.setName(&lt;/span&gt;&quot;123&quot;&lt;span&gt;);
        instance.Breath();
        instance&lt;/span&gt;=(XMLInstance)factory.getBean(&quot;xmlinstance&quot;&lt;span&gt;);
        instance.Breath();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们采用bean默认的作用域singleton，如下配置，则两个getbean获取的对象是一致的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &amp;lt;bean id=&quot;xmlinstance&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.demo.model.XMLInstance&quot; scope=&quot;singleton&quot;&amp;gt;
      &amp;lt;property name=&quot;air&quot; ref=&quot;CleanAir&quot;&amp;gt;&amp;lt;/property&amp;gt;
      &amp;lt;property name=&quot;name&quot; value=&quot;abc&quot;&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
输出结果:
Name:123;Air:CleanAir
Name:123;Air:CleanAir
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果我们采用&lt;/span&gt;bean&lt;span&gt;默认的作用域&lt;/span&gt;&lt;span&gt;singleton&lt;/span&gt;&lt;span&gt;，如下配置，则两个&lt;/span&gt;&lt;span&gt;getbean&lt;/span&gt;&lt;span&gt;获取的对象是不一致的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &amp;lt;bean id=&quot;xmlinstance&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.demo.model.XMLInstance&quot; scope=&quot;prototype&quot;&amp;gt;
      &amp;lt;property name=&quot;air&quot; ref=&quot;CleanAir&quot;&amp;gt;&amp;lt;/property&amp;gt;
      &amp;lt;property name=&quot;name&quot; value=&quot;abc&quot;&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
输出结果:
Name:123;Air:CleanAir
Name:abc;Air:CleanAir
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、Bean的生命周期&lt;br/&gt;前面章节介绍了bean容器以及bean的配置与注入，本章节学习bean的生命周期，了解bean是怎么来的又是怎么没的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201808/733213-20180824211814432-2024157371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ApplicationContext容器中，Bean的生命周期流程如上图所示，流程大致如下：&lt;br/&gt;1.首先容器启动后，会对scope为singleton且非懒加载的bean进行实例化，&lt;br/&gt;2.按照Bean定义信息配置信息，注入所有的属性，&lt;br/&gt;3.如果Bean实现了BeanNameAware接口，会回调该接口的setBeanName()方法，传入该Bean的id，此时该Bean就获得了自己在配置文件中的id，&lt;br/&gt;4.如果Bean实现了BeanFactoryAware接口,会回调该接口的setBeanFactory()方法，传入该Bean的BeanFactory，这样该Bean就获得了自己所在的BeanFactory，&lt;br/&gt;5.如果Bean实现了ApplicationContextAware接口,会回调该接口的setApplicationContext()方法，传入该Bean的ApplicationContext，这样该Bean就获得了自己所在的ApplicationContext，&lt;br/&gt;6.如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessBeforeInitialzation()方法，&lt;br/&gt;7.如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法，&lt;br/&gt;8.如果Bean配置了init-method方法，则会执行init-method配置的方法，&lt;br/&gt;9.如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法，&lt;br/&gt;10.经过流程9之后，就可以正式使用该Bean了,对于scope为singleton的Bean,Spring的ioc容器中会缓存一份该bean的实例，而对于scope为prototype的Bean,每次被调用都会new一个新的对象，期生命周期就交给调用方管理了，不再是Spring容器进行管理了&lt;br/&gt;11.容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法，&lt;br/&gt;12.如果Bean配置了destroy-method方法，则会执行destroy-method配置的方法，至此，整个Bean的生命周期结束。&lt;/p&gt;
&lt;p&gt;这里在UserBean类基础上进行改造，增加了name属性并实现了ApplicationContextAware接口。&lt;/p&gt;
&lt;div readability=&quot;21.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_caf21919-143e-4285-aaa8-0b303a350fd3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_caf21919-143e-4285-aaa8-0b303a350fd3&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_caf21919-143e-4285-aaa8-0b303a350fd3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.BeansException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactoryAware;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanNameAware;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.DisposableBean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.InitializingBean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContextAware;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserBean &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanNameAware,BeanFactoryAware,InitializingBean,DisposableBean,ApplicationContextAware {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        System.out.println(&lt;/span&gt;&quot;set方法被调用&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserBean() {
         System.out.println(&lt;/span&gt;&quot;UserBean类构造方法&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String name) {
        System.out.println(&lt;/span&gt;&quot;BeanNameAware被调用&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBeanFactory(BeanFactory beanFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        System.out.println(&lt;/span&gt;&quot;BeanFactoryAware被调用&quot;&lt;span&gt;);    
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterPropertiesSet() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot;InitializingBean被调用&quot;&lt;span&gt;);    
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; destroy() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot;DisposableBean被调用&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义的初始化函数 &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; myInit() { 
        System.out.println(&lt;/span&gt;&quot;myInit被调用&quot;&lt;span&gt;);
    } 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义的销毁方法 &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; myDestroy() {
        System.out.println(&lt;/span&gt;&quot;myDestroy被调用&quot;&lt;span&gt;); 
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setApplicationContext(ApplicationContext applicationContext) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        System.out.println(&lt;/span&gt;&quot;setApplicationContext被调用&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;定义了后置处理器CusBeanPostProcessor 实现了BeanPostProcessor 接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.BeansException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.config.BeanPostProcessor;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CusBeanPostProcessor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanPostProcessor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessBeforeInitialization(Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        System.out.println(&lt;/span&gt;&quot;postProcessBeforeInitialization被调用&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessAfterInitialization(Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        System.out.println(&lt;/span&gt;&quot;postProcessAfterInitialization被调用&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在xml中配置bean和BeanPostProcessor。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.UserBean&quot;&lt;/span&gt;&lt;span&gt; destroy-method&lt;/span&gt;&lt;span&gt;=&quot;myDestroy&quot;&lt;/span&gt;&lt;span&gt; init-method&lt;/span&gt;&lt;span&gt;=&quot;myInit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;abc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;postProcessor&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.CusBeanPostProcessor&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        ApplicationContext context=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;applicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        UserBean user&lt;/span&gt;=(UserBean)context.getBean(&quot;user&quot;&lt;span&gt;);
        ((ClassPathXmlApplicationContext)context).close();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;br/&gt;UserBean类构造方法&lt;br/&gt;set方法被调用&lt;br/&gt;BeanNameAware被调用&lt;br/&gt;BeanFactoryAware被调用&lt;br/&gt;setApplicationContext被调用&lt;br/&gt;postProcessBeforeInitialization被调用&lt;br/&gt;InitializingBean被调用&lt;br/&gt;myInit被调用&lt;br/&gt;postProcessAfterInitialization被调用&lt;br/&gt;DisposableBean被调用&lt;br/&gt;myDestroy被调用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201808/733213-20180824212112337-744902454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;

</description>
<pubDate>Fri, 24 Aug 2018 13:22:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>在前面博客中提到容器启动获得BeanDefinition对象中有一个scope 属性。该属性控制着bean对象的作用域。本章节介绍Bean的作用域及生命周期，了解bean是怎么来的又怎么没的。 一、B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/9532057.html</dc:identifier>
</item>
<item>
<title>maven-坐标与依赖 - 嗜血蚂蚁</title>
<link>http://www.cnblogs.com/shixiemayi/p/9527488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shixiemayi/p/9527488.html</guid>
<description>&lt;p&gt;1、坐标-找到项目依赖的重要依据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;groupId&amp;gt;cmbc.com.cn&amp;lt;/groupId&amp;gt;    
&amp;lt;artifactId&amp;gt;myapp&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：a、groupId、artifactId、version必须配置，packaging为可选配置，未配置则默认为jar&lt;/p&gt;
&lt;p&gt;　　　b、项目构件名称与坐标相对应，通常为artifactId-version.packaging，上述坐标对应构件名称为&lt;/p&gt;
&lt;p&gt;　　　　  myapp-1.0-SNAPSHOT&lt;/p&gt;
&lt;p&gt;2、依赖配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;project&amp;gt; 

  &amp;lt;dependencies&amp;gt;  可以包含多个&amp;lt;dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;...&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;...&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;...&amp;lt;/version&amp;gt;
      &amp;lt;type&amp;gt;...&amp;lt;/type&amp;gt;    坐标类型，对应项目坐标定义的packing
      &amp;lt;scope&amp;gt;...&amp;lt;/scope&amp;gt;  依赖范围
      &amp;lt;optional&amp;gt;...&amp;lt;/optional&amp;gt;　标记依赖是否可选
      &amp;lt;exclusions&amp;gt;　　排除传递性依赖&lt;span&gt;
        ...
      &lt;/span&gt;&amp;lt;/exclusions&amp;gt;
    &amp;lt;/dependency&amp;gt;

 &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3、依赖详述&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;依赖范围&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;a、依赖范围种类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot; width=&quot;437&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b、依赖范围的作用&lt;/p&gt;
&lt;p&gt;　　Maven有编译、测试、运行classpath，依赖范围用于控制依赖与三种classpath的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1452390/201808/1452390-20180824202800208-902565031.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传递性依赖&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;a、项目A依赖于B，B依赖于C，则C是A的传递性依赖。Maven会将必要的间接依赖以传递式依赖的形式引入到项目。&lt;/p&gt;
&lt;p&gt;b、确定传递性依赖范围&lt;/p&gt;
&lt;p&gt;　　项目A依赖于B，B依赖于C，则B是A的第一直接依赖，C是B的第二直接依赖，C是A的传递性依赖。第一和第二直接依赖的范围决定了传递性依赖的范围，如下所示，左边为第一直接依赖范围，上面为第二直接依赖范围，中间为传递性依赖范围：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1452390/201808/1452390-20180824203540142-1722925512.png&quot; alt=&quot;&quot; width=&quot;597&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;依赖调解&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　当项目多个直接依赖在其自己的依赖路径中分别依赖了同一个其它依赖，那么该引入哪一个路径上的依赖呢？&lt;/p&gt;
&lt;p&gt;规则：不同路径长度，路径最短优先；相同路径长度，第一申明优先&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可选依赖&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　假设A依赖于B，B依赖于C（可选），D（可选）（在B项目中的pom.xml文件依赖C和D，申明&amp;lt;dependency&amp;gt;中均添加&amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;）。可选依赖不具备传递性，因此A项目中不能引入C或D的依赖，如果需要使用C或D需要在A项目中直接依赖C或D&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;排除依赖&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　传递性依赖会隐式的引入很多依赖，极大简化了项目依赖的管理。但在以下情形需要使用&amp;lt;exclusions&amp;gt;排除依赖：&lt;/p&gt;
&lt;p&gt;a、A依赖B，B依赖C，C（快照版本）不稳定可能会影响项目A。此时需要排除C而引入引入C的稳定版本。&lt;/p&gt;
&lt;p&gt;b、可能由于版权原因，C（稳定版本）不在中央仓库，而D项目是一个可替代的实现。此时需要排除C而引入D&lt;/p&gt;
</description>
<pubDate>Fri, 24 Aug 2018 13:05:00 +0000</pubDate>
<dc:creator>嗜血蚂蚁</dc:creator>
<og:description>1、坐标-找到项目依赖的重要依据 说明：a、groupId、artifactId、version必须配置，packaging为可选配置，未配置则默认为jar b、项目构件名称与坐标相对应，通常为art</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shixiemayi/p/9527488.html</dc:identifier>
</item>
<item>
<title>后缀自动机详解 - baka</title>
<link>http://www.cnblogs.com/TheRoadToAu/p/Suffix-Automata.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TheRoadToAu/p/Suffix-Automata.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文译自博文 &lt;a href=&quot;http://e-maxx.ru/algo/suffix_automata&quot;&gt;Суффиксный автомат&lt;/a&gt; 与其英文翻译版 &lt;a href=&quot;https://cp-algorithms.com/string/suffix-automaton.html&quot;&gt;Suffix Automaton&lt;/a&gt; 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文版权协议为 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh&quot;&gt;CC-BY-SA 4.0&lt;/a&gt; 及未来（如果有）的更新版本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载时，请务必遵守以上版权协议，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://loj.ac/article/746&quot;&gt;LibreOJ 题库维护组&lt;/a&gt; / &lt;a href=&quot;https://github.com/MingqiHuang&quot;&gt;MingqiHuang @ GitHub&lt;/a&gt; / &lt;a href=&quot;https://loj.ac/user/1180&quot;&gt;Mingqi_H @ LibreOJ&lt;/a&gt; / QQ 号：742745308&lt;br/&gt;2018 年 8 月 23 日&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FBI Warning: 全文约 20000 字，阅读全文约需要 1 小时。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后缀自动机&lt;/strong&gt;是一个能解决许多字符串相关问题的有力的数据结构。&lt;/p&gt;
&lt;p&gt;举个例子，字符串问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在另一个字符串中搜索一个字符串的所有出现位置。&lt;/li&gt;
&lt;li&gt;计算给定的字符串中有多少个不同的子串。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上问题都可以在线性的时间复杂度内通过后缀自动机来实现。&lt;/p&gt;
&lt;p&gt;直观上，字符串的后缀自动机可以理解为给定字符串的&lt;strong&gt;所有子串&lt;/strong&gt;的压缩形式。值得注意的事实是，后缀自动机将所有的这些信息以高度压缩的形式储存。对于一个长度为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 的字符串，它的空间复杂度仅为 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;。此外，构造后缀自动机的时间复杂度仅为 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;（这里我们将字符集的大小 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 看作常数，否则时间复杂度和空间复杂度均为 &lt;span class=&quot;math inline&quot;&gt;\(O(n\log k)\)&lt;/span&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;后缀自动机的定义&quot;&gt;后缀自动机的定义&lt;/h2&gt;
&lt;p&gt;给定字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的后缀自动机是一个接受所有字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的后缀的最小 &lt;strong&gt;DFA&lt;/strong&gt;（确定性有限自动机或确定性有限状态自动机）。&lt;/p&gt;
&lt;p&gt;换句话说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;后缀自动机是一张有向无环图。顶点被称作&lt;strong&gt;状态&lt;/strong&gt;，边被称作状态间的&lt;strong&gt;转移&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;一个状态 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 为&lt;strong&gt;初始状态&lt;/strong&gt;，它必定为这张图的源点（其它各点均与 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 联通）。&lt;/li&gt;
&lt;li&gt;每个&lt;strong&gt;转移&lt;/strong&gt;都标有一些字母。从一个顶点出发的所有转移均&lt;strong&gt;不同&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;一个或多个状态为&lt;strong&gt;终止状态&lt;/strong&gt;。如果我们从初始状态 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 出发，最终转移到了一个终止状态，则路径上的所有转移连接起来一定是字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的一个后缀。 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的每个后缀均可用一条从 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 到一个终止状态的路径构成。&lt;/li&gt;
&lt;li&gt;后缀自动机是所有满足上述条件的自动机中顶点数最少的一个。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;子串的性质&quot;&gt;子串的性质&lt;/h3&gt;
&lt;p&gt;后缀自动机最简单和最重要的性质是，它包含关于字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的所有子串的信息。任意从初始状态 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 开始的路径，如果我们将转移路径上的标号写下来，都会形成 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的一个&lt;strong&gt;子串&lt;/strong&gt;。反之每个 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的子串对应于从 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 开始的某条路径。&lt;/p&gt;
&lt;p&gt;为了简化表达，我们将会说子串&lt;strong&gt;对应于&lt;/strong&gt;一条路径（从 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 开始且一些标号构成这个子串）。反过来我们说任意一条路径&lt;strong&gt;对应于&lt;/strong&gt;它的标号构成的字符串。&lt;/p&gt;
&lt;p&gt;一条或多条路径可以到达一个状态，因此我们说一个状态对应于字符串的集合，这也对应于那些路径。&lt;/p&gt;
&lt;h3 id=&quot;构造后缀自动机的实例&quot;&gt;构造后缀自动机的实例&lt;/h3&gt;
&lt;p&gt;我们将会在这里展示一些简单的字符串的后缀自动机。&lt;/p&gt;
&lt;p&gt;我们用蓝色表示初始状态，用绿色表示终止状态。&lt;/p&gt;
&lt;p&gt;对于字符串 &lt;span class=&quot;math inline&quot;&gt;\(s=``&quot;\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mingqihuang/pics/raw/master/SA.pdf.svg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于字符串 &lt;span class=&quot;math inline&quot;&gt;\(s=``a\!&quot;\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mingqihuang/pics/raw/master/SAa.pdf.svg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于字符串 &lt;span class=&quot;math inline&quot;&gt;\(s=``aa\!&quot;\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mingqihuang/pics/raw/master/SAaa.pdf.svg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于字符串 &lt;span class=&quot;math inline&quot;&gt;\(s=``ab\!&quot;\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mingqihuang/pics/raw/master/SAab.pdf.svg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于字符串 &lt;span class=&quot;math inline&quot;&gt;\(s=``abb\!&quot;\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mingqihuang/pics/raw/master/SAabb.pdf.svg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于字符串 &lt;span class=&quot;math inline&quot;&gt;\(s=``abbb\!&quot;\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mingqihuang/pics/raw/master/SAabbb.pdf.svg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在线性时间内构造后缀自动机&quot;&gt;在线性时间内构造后缀自动机&lt;/h2&gt;
&lt;p&gt;在我们描述线性时间内构造后缀自动机的算法之前，我们需要引入几个对理解构造过程非常重要的新概念并简单证明。&lt;/p&gt;
&lt;h3 id=&quot;结束位置-endpos&quot;&gt;结束位置 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;考虑字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的任意非空子串 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;，我们记 &lt;span class=&quot;math inline&quot;&gt;\(endpos(t)\)&lt;/span&gt; 为在字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 中 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 的所有结束位置。例如，对于字符串 &lt;span class=&quot;math inline&quot;&gt;\(``abcbc\!&quot;\)&lt;/span&gt;，我们有 &lt;span class=&quot;math inline&quot;&gt;\(endpos(``bc\!&quot;)=2,\,4\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;当两个子串 &lt;span class=&quot;math inline&quot;&gt;\(t_1\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(t_2\)&lt;/span&gt; 的末尾集合相等时我们称它们是 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 等价的：即 &lt;span class=&quot;math inline&quot;&gt;\(endpos(t_1)=endpos(t_2)\)&lt;/span&gt;。这样所有字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的非空子串都可以根据它们的&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt;&lt;/strong&gt; 集合被分为几个&lt;strong&gt;等价类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;显然，在后缀自动机中的每个状态对应于一个或多个 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 相同的子串。换句话说，后缀自动机中的状态数等于所有子串的等价类的个数，加上初始状态。后缀自动机的状态个数等价于 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 相同的一个或多个子串。&lt;/p&gt;
&lt;p&gt;我们稍后将会用这个假设介绍构造后缀自动机的算法。在那时我们将会发现，后缀自动机需要满足的所有性质，除了最小性以外都满足了。由 Nerode 定理我们可以得出最小性（这篇文章不会证明后缀自动机的最小性）。&lt;/p&gt;
&lt;p&gt;由 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 的值我们可以得到一些重要结论：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;引理 1：&lt;/strong&gt;当且仅当字符串 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 以 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的一个后缀的形式出现在字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 中时，两个非空子串 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;（假设 &lt;span class=&quot;math inline&quot;&gt;\(length(u)\le length(w)\)&lt;/span&gt;）是 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 等价的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引理显然成立。如果 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 相同，则 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的一个后缀，且只以 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 中的一个 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的后缀的形式出现。且根据定义，如果 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的一个后缀，且只以后缀的形式在 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 中出现时，两个子串的 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 值相等。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;引理 2：&lt;/strong&gt;考虑两个非空子串 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;（假设 &lt;span class=&quot;math inline&quot;&gt;\(length(u)\le length(w)\)&lt;/span&gt;）。则它们的 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 构成的集合要么完全没有交集，要么 &lt;span class=&quot;math inline&quot;&gt;\(endpos(w)\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(endpos(u)\)&lt;/span&gt; 的一个子集。并且这依赖于 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 是否为 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的一个后缀。即：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{cases} endpos(w)\subseteq endpos(u)&amp;amp;\text{若 $u$ 为 $w$ 的一个后缀}\\ endpos(w)\cap endpos(u)=\emptyset&amp;amp;\text{另一种情况}\\ \end{cases} \]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明：如果集合 &lt;span class=&quot;math inline&quot;&gt;\(endpos(u)\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(endpos(w)\)&lt;/span&gt; 有至少一个公共元素，那么由于字符串 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 都在一个位置结束，即 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的一个后缀。但是如果如此在每次 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 出现的位置子串 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 也会出现，这意味着 &lt;span class=&quot;math inline&quot;&gt;\(endpos(w)\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(endpos(u)\)&lt;/span&gt; 的一个子集。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;引理 3：&lt;/strong&gt;考虑一个 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 等价类。将类中的所有子串按长度非递增的顺序排序。即每个子串都会比它前一个子串短，与此同时每个子串也是它前一个子串的一个后缀。换句话说，同一等价类中的所有子串均互为后缀，且子串的长度恰好覆盖整个区间 &lt;span class=&quot;math inline&quot;&gt;\([x,\,y]\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明：固定一些 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 等价类。如果等价类中只包含一个子串，引理显然成立。现在我们来讨论子串元素个数大于 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的等价类。&lt;/p&gt;
&lt;p&gt;由引理 1，两个不同的 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 等价字符串中较短的一个总是较长的一个的真后缀。因此，等价类中不可能有两个等长的字符串。&lt;/p&gt;
&lt;p&gt;记 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 为等价类中最长的字符串，类似地，记 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 为等价类中最短的字符串。由引理1，字符串 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 是字符串 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的真后缀。现在考虑长度在区间 &lt;span class=&quot;math inline&quot;&gt;\([length(u),\,length(w)]\)&lt;/span&gt; 中的 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的任意后缀。容易看出，这个后缀也在同一等价类中。因为这个后缀只能在字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 中以 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的一个后缀的形式存在（也因为较短的后缀 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 中只以 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的后缀的形式存在）。因此，由引理 1，这个后缀与字符串 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 等价。&lt;/p&gt;
&lt;h3 id=&quot;后缀链接-link&quot;&gt;后缀链接 &lt;span class=&quot;math inline&quot;&gt;\(link\)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;考虑后缀自动机中满足 &lt;span class=&quot;math inline&quot;&gt;\(v\ne t_0\)&lt;/span&gt; 的一些状态。我们已经知道，状态 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 对应于具有相同 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 的等价类。我们如果定义 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 为这些字符串中最长的一个，则所有其它的字符串都是 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的后缀。&lt;/p&gt;
&lt;p&gt;我们还知道字符串 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的前几个后缀（如果我们用长度降序考虑这些后缀）在这个等价类中全部被包含，且所有其它后缀（至少一个—空后缀）在其它的等价类中。我们记 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 为最大的这样的后缀，然后用后缀链接连到 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 上。&lt;/p&gt;
&lt;p&gt;换句话说，一个&lt;strong&gt;后缀链接&lt;/strong&gt; &lt;span class=&quot;math inline&quot;&gt;\(link(v)\)&lt;/span&gt; 连接到对应于 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的最长后缀的另一个 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 等价类的状态。&lt;/p&gt;
&lt;p&gt;以下我们假设初始状态 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 对应于它自己这个等价类（只包含一个空字符串），为了方便我们规定 &lt;span class=&quot;math inline&quot;&gt;\(endpos(t)=\{-1,\,0,\,\ldots,\,length(s)-1\}\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;引理 4：&lt;/strong&gt;所有后缀链接构成一棵根节点为 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 的树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明：考虑任意满足 &lt;span class=&quot;math inline&quot;&gt;\(v\ne t_0\)&lt;/span&gt; 的状态，一个后缀链接 &lt;span class=&quot;math inline&quot;&gt;\(link(v)\)&lt;/span&gt; 连接到的状态对应于严格更短的字符串（根据后缀链接的定义和引理 3）。因此，通过在后缀链接上移动，我们早晚会到达对应空串的初始状态 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;引理 5：&lt;/strong&gt;如果我们使用集合 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 构造一棵树（所有子节点的集合为父节点的子集），则这个结构由后缀链接连接起来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明：由引理 2，我们可以用 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 集合构造一棵树（因为两个集合要么完全没有交集要么互为子集）。&lt;/p&gt;
&lt;p&gt;我们现在考虑任意满足 &lt;span class=&quot;math inline&quot;&gt;\(v\ne t_0\)&lt;/span&gt; 的状态和它的后缀链接 &lt;span class=&quot;math inline&quot;&gt;\(link(v)\)&lt;/span&gt;，由后缀链接和引理 2，我们可以得到&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[endpos(v)\subseteq endpos(link(v))\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;，这与前面的引理证明了以下断言成立：后缀链接构成的树本质上是 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 集合构成的一棵树。&lt;/p&gt;
&lt;p&gt;以下是对于字符串 &lt;span class=&quot;math inline&quot;&gt;\(``abcbc\!&quot;\)&lt;/span&gt; 构造后缀自动机时产生的后缀链接树的一个&lt;strong&gt;例子&lt;/strong&gt;，节点被标记为对应等价类中最长的子串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mingqihuang/pics/raw/master/SA_suffix_links.pdf.svg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;在学习算法本身前，我们对之前学过的知识进行一下总结，并引入一些辅助记号。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的子串可以根据它们结束的位置 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 被划分为多个等价类；&lt;/li&gt;
&lt;li&gt;后缀自动机由初始状态 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 和与每一个 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 等价类对应的每个状态组成；&lt;/li&gt;
&lt;li&gt;对于每一个状态 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;，一个或多个子串与之匹配。我们记 &lt;span class=&quot;math inline&quot;&gt;\(longest(v)\)&lt;/span&gt; 为其中最长的一个字符串，记 &lt;span class=&quot;math inline&quot;&gt;\(len(v)\)&lt;/span&gt; 为它的长度。类似地，记 &lt;span class=&quot;math inline&quot;&gt;\(shortest(v)\)&lt;/span&gt; 为最短的子串，它的长度为 &lt;span class=&quot;math inline&quot;&gt;\(minlen(v)\)&lt;/span&gt;。那么所有对应这个状态的所有字符串都是字符串 &lt;span class=&quot;math inline&quot;&gt;\(longest(v)\)&lt;/span&gt; 的不同的后缀，且所有字符串的长度恰好覆盖区间 &lt;span class=&quot;math inline&quot;&gt;\([minlength(v),\,len(v)]\)&lt;/span&gt; 中的每一个整数。&lt;/li&gt;
&lt;li&gt;对于任意满足 &lt;span class=&quot;math inline&quot;&gt;\(v\ne t_0\)&lt;/span&gt; 的状态，定义后缀链接为连接到对应字符串 &lt;span class=&quot;math inline&quot;&gt;\(longest(v)\)&lt;/span&gt; 的长度为 &lt;span class=&quot;math inline&quot;&gt;\(minlen(v)-1\)&lt;/span&gt; 的后缀的一条边。从根节点 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 出发的后缀链接可以形成一棵树，与此同时，这棵树形成了 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 集合间的包含关系。&lt;/li&gt;
&lt;li&gt;我们可以对 &lt;span class=&quot;math inline&quot;&gt;\(v\ne t_0\)&lt;/span&gt; 的状态使用后缀链接 &lt;span class=&quot;math inline&quot;&gt;\(link(v)\)&lt;/span&gt; 解释 &lt;span class=&quot;math inline&quot;&gt;\(minlen(v)\)&lt;/span&gt; 如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[minlen(v)=len(link(v))+1.\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果我们从任意状态 &lt;span class=&quot;math inline&quot;&gt;\(v_0\)&lt;/span&gt; 开始顺着后缀链接遍历，早晚都会到达初始状态 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt;。这种情况下我们可以得到一个互不相交的区间 &lt;span class=&quot;math inline&quot;&gt;\([minlen(v_i),\,len(v_i)]\)&lt;/span&gt; 的序列，且它们的并集形成了连续的区间 &lt;span class=&quot;math inline&quot;&gt;\([0,\,len(v_0)]\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;算法&quot;&gt;算法&lt;/h3&gt;
&lt;p&gt;现在我们可以学习算法本身了。这个算法是&lt;strong&gt;在线&lt;/strong&gt;算法，这意味着我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护后缀自动机。&lt;/p&gt;
&lt;p&gt;为了保证线性的空间复杂度，我们将只保存 &lt;span class=&quot;math inline&quot;&gt;\(len\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(link\)&lt;/span&gt; 的值和每个状态的一个转移列表，我们不会标记终止状态（但是我们稍后会展示在构造后缀自动机后如何分配这些标记）。&lt;/p&gt;
&lt;p&gt;一开始后缀自动机只包含一个状态 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt;，编号为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;（其它状态的编号为 &lt;span class=&quot;math inline&quot;&gt;\(1,\,2,\,\ldots\)&lt;/span&gt;）。为了方便，我们分配给它 &lt;span class=&quot;math inline&quot;&gt;\(len=0\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(link=-1\)&lt;/span&gt;（&lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt; 表示一个虚拟的不存在的状态）。&lt;/p&gt;
&lt;p&gt;现在整个任务转化为实现给当前字符串添加一个字符 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的过程。算法流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(last\)&lt;/span&gt; 为对应添加字符 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 之前的整个字符串（一开始我们设置 &lt;span class=&quot;math inline&quot;&gt;\(last=0\)&lt;/span&gt; 且我们会在算法的最后一步对应地更新 &lt;span class=&quot;math inline&quot;&gt;\(last\)&lt;/span&gt;）。&lt;/li&gt;
&lt;li&gt;创建一个新的状态 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt;，并将 &lt;span class=&quot;math inline&quot;&gt;\(len(cur)\)&lt;/span&gt; 赋值为 &lt;span class=&quot;math inline&quot;&gt;\(len(last)+1\)&lt;/span&gt;，在这时 &lt;span class=&quot;math inline&quot;&gt;\(link(cur)\)&lt;/span&gt; 的值还未知。&lt;/li&gt;
&lt;li&gt;现在我们按以下流程进行：我们从状态 &lt;span class=&quot;math inline&quot;&gt;\(last\)&lt;/span&gt; 开始。如果还没有到字符 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的转移，我们就添加一个到状态 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt; 的转移，遍历后缀链接。如果在某个点已经存在到字符 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的后缀链接，我们就停下来，并将这个状态标记为 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;如果没有找到这样的状态 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;，我们就到达了虚拟状态 &lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt;，我们将 &lt;span class=&quot;math inline&quot;&gt;\(link(cur)\)&lt;/span&gt; 赋值为 &lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt; 并退出。&lt;/li&gt;
&lt;li&gt;假设现在我们找到了一个状态 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;，其可以转移到字符 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;，我们将这个状态转移到的状态标记为 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;现在我们分类讨论两种状态，要么 &lt;span class=&quot;math inline&quot;&gt;\(len(p) + 1 = len(q)\)&lt;/span&gt;，要么不是。&lt;/li&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;\(len(p)+1=len(q)\)&lt;/span&gt;，我们只要将 &lt;span class=&quot;math inline&quot;&gt;\(link(cur)\)&lt;/span&gt; 赋值为 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 并退出。&lt;/li&gt;
&lt;li&gt;否则就会有些复杂。需要&lt;strong&gt;复制&lt;/strong&gt;状态 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt;：我们创建一个新的状态 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt;，复制 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 的除了 &lt;span class=&quot;math inline&quot;&gt;\(len\)&lt;/span&gt; 的值以外的所有信息（后缀链接和转移）。我们将 &lt;span class=&quot;math inline&quot;&gt;\(len(clone)\)&lt;/span&gt; 赋值为 &lt;span class=&quot;math inline&quot;&gt;\(len(p)+1\)&lt;/span&gt;。&lt;br/&gt;复制之后，我们将后缀链接从 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt; 指向 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt;，也从 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 指向 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt;。&lt;br/&gt;最终我们需要使用后缀链接从状态 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 返回，因为存在一条通过 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 到状态 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 的转移，并在此过程中重定向所有状态到状态 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;以上三种情况，在完成这个过程之后，我们将 &lt;span class=&quot;math inline&quot;&gt;\(last\)&lt;/span&gt; 的值更新为状态 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果我们还想知道哪些状态是&lt;strong&gt;终止状态&lt;/strong&gt;而哪些不是，我们可以在为字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 构造完完整的后缀自动机后找到所有的终止状态。为此，我们从对应整个字符串的状态（存储在变量 &lt;span class=&quot;math inline&quot;&gt;\(last\)&lt;/span&gt; 中），遍历它的后缀链接，直到到达初始状态。我们将所有遍历到的节点都标记为终止节点。容易理解这样做我们会精确地标记字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的所有后缀，这些状态恰好是终止状态。&lt;/p&gt;
&lt;p&gt;在下一部分，我们将观察算法每一步的细节，并证明它的&lt;strong&gt;正确性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在，我们只注意到，因为我们只为 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的每个字符创建一个或两个新状态所以后缀自动机只包含&lt;strong&gt;线性个&lt;/strong&gt;状态。&lt;/p&gt;
&lt;p&gt;转移个数是线性规模的，以及总体上算法的运行时间是线性规模的，这两点还不那么清&lt;br/&gt;楚。&lt;/p&gt;
&lt;h3 id=&quot;正确性证明&quot;&gt;正确性证明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;若一个转移 &lt;span class=&quot;math inline&quot;&gt;\((p,\,q)\)&lt;/span&gt; 满足 &lt;span class=&quot;math inline&quot;&gt;\(len(p)+1=len(q)\)&lt;/span&gt; 则我们称这个转移是&lt;strong&gt;连续的&lt;/strong&gt;。否则，即当 &lt;span class=&quot;math inline&quot;&gt;\(len(p)+1&amp;lt;len(q)\)&lt;/span&gt; 时，这个转移被称为&lt;strong&gt;不连续的&lt;/strong&gt;。 从算法描述中可以看出，连续的和非连续的转移是算法的不同情况。连续的转移是固定的，我们不会再改变了。与此相反，当向字符串中插入一个新的字符时，非连续的转移可能会改变（转移边的端点可能会改变）。&lt;/li&gt;
&lt;li&gt;为了避免引起歧义，我们记向后缀自动机中插入当前字符 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 之前的字符串为 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;算法从创建一个新状态 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt; 开始，对应于整个字符串 &lt;span class=&quot;math inline&quot;&gt;\(s+c\)&lt;/span&gt;。我们创建一个新的节点的原因很清楚。与此同时我们也创建了一个新的字符和一个新的等价类。&lt;/li&gt;
&lt;li&gt;在创建一个新的状态之后，我们会从对应于整个字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的状态通过后缀链接进行遍历。对于每一个状态，我们尝试添加一个从字符 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 到新状态 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt; 的转移。然而我我们只能添加与原来已存在的转移不冲突的转移。因此我们只要找到已存在的 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的转移，我们就必须停止。&lt;/li&gt;
&lt;li&gt;最简单的情况是我们到达了虚拟状态 &lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt;，这意味着我们为所有 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的后缀添加了 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的转移。这也意味着，字符 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 从未在字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 中出现过。因此 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt; 的后缀链接为状态 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;第二种情况下，我们找到了现有的转移 &lt;span class=&quot;math inline&quot;&gt;\((p,\,q)\)&lt;/span&gt;。这意味着我们尝试向自动机内添加一个&lt;strong&gt;已经存在的&lt;/strong&gt;字符串 &lt;span class=&quot;math inline&quot;&gt;\(x+c\)&lt;/span&gt;（其中 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的一个后缀，且字符串 &lt;span class=&quot;math inline&quot;&gt;\(x+c\)&lt;/span&gt; 已经作为 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的一个子串出现过了）。因为我们假设字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的自动机的构造是正确的，我们不应该在这里添加一个新的转移。 然而，有一个难点。从状态 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt; 出发的后缀链接应该连接到哪个状态呢？我们要把后缀链接连到一个状态上，且其中最长的一个字符串恰好是 &lt;span class=&quot;math inline&quot;&gt;\(x+c\)&lt;/span&gt;，即这个状态的 &lt;span class=&quot;math inline&quot;&gt;\(len\)&lt;/span&gt; 应该是 &lt;span class=&quot;math inline&quot;&gt;\(len(p)+1\)&lt;/span&gt;。然而还不存在这样的状态，即 &lt;span class=&quot;math inline&quot;&gt;\(len(q)&amp;gt;len(p)+1\)&lt;/span&gt;。这种情况下，我们必须要通过拆开状态 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 来创建一个这样的状态。&lt;/li&gt;
&lt;li&gt;如果转移 &lt;span class=&quot;math inline&quot;&gt;\((p,\,q)\)&lt;/span&gt; 是连续的，那么 &lt;span class=&quot;math inline&quot;&gt;\(len(q)=len(p)+1\)&lt;/span&gt;。在这种情况下一切都很简单。我们只需要将 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt; 的后缀链接指向状态 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;否则转移是不连续的，即 &lt;span class=&quot;math inline&quot;&gt;\(len(q)&amp;gt;len(p)+1\)&lt;/span&gt;，这意味着状态 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 不只对应于长度为&lt;span class=&quot;math inline&quot;&gt;\(len(p)+1\)&lt;/span&gt; 的后缀 &lt;span class=&quot;math inline&quot;&gt;\(s+c\)&lt;/span&gt;，还对应于 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的更长的子串。除了将状态 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 拆成两个子状态以外我们别无他法，所以第一个子状态的长度就是 &lt;span class=&quot;math inline&quot;&gt;\(len(p)+1\)&lt;/span&gt; 了。&lt;br/&gt;我们如何拆开一个状态呢？我们&lt;strong&gt;复制&lt;/strong&gt;状态 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt;，产生一个状态 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt;，我们将 &lt;span class=&quot;math inline&quot;&gt;\(len(clone)\)&lt;/span&gt; 赋值为 &lt;span class=&quot;math inline&quot;&gt;\(len(p)+1\)&lt;/span&gt;。由于我们不想改变遍历到 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 的路径，我们将 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 的所有转移复制到 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt;。我们也将从 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt; 出发的后缀链接设置为 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 的后缀链接的目标，并设置 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 的后缀链接为 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt;。&lt;br/&gt;在拆开状态后，我们将从 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt; 出发的后缀链接设置为 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt;。&lt;br/&gt;最后一步我们将一些到 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 转移重定向到 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt;。我们需要修改哪些转移呢？只重定向相当于所有字符串 &lt;span class=&quot;math inline&quot;&gt;\(w+c\)&lt;/span&gt;（其中 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 的最长字符串）的后缀就够了。即，我们需要继续沿着后缀链接遍历，从顶点 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 直到虚拟状态 &lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt; 或者是转移到不是状态 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 的一个转移。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;对操作次数为线性的证明&quot;&gt;对操作次数为线性的证明&lt;/h3&gt;
&lt;p&gt;首先我们假设字符集大小为&lt;strong&gt;常数&lt;/strong&gt;。如果字符集大小不是常数，后缀自动机的时间复杂度就不是线性的。从一个顶点出发的转移存储在支持快速查询和插入的平衡树中。因此如果我们记 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 为字符集的大小，则算法的渐进时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(n\log k)\)&lt;/span&gt;，空间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;。然而如果字符集足够小，可以不写平衡树，以空间换时间将每个顶点的转移存储为长度为 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 的数组（用于快速查询）和链表（用于快速遍历所有可用关键字）。这样算法的时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，空间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(nk)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;所以我们将认为字符集的大小为常数，即每次对一个字符搜索转移、添加转移、查找下一个转移—这些操作的时间复杂度都为 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果我们考虑算法的各个部分，算法中有三处时间复杂度不明显是线性的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一处是遍历所有状态 &lt;span class=&quot;math inline&quot;&gt;\(last\)&lt;/span&gt; 的后缀链接，添加字符 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的转移。&lt;/li&gt;
&lt;li&gt;第二处是当状态 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 被复制到一个新的状态 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt; 时复制转移的过程。&lt;/li&gt;
&lt;li&gt;第三处是修改指向 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 的转移，将它们重定向到 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt; 的过程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们使用后缀自动机的大小（状态数和转移数）为&lt;strong&gt;线性的&lt;/strong&gt;的事实（对状态数是线性的的证明就是算法本身，对状态数为线性的的证明将在稍后实现算法后给出）。&lt;/p&gt;
&lt;p&gt;因此上述&lt;strong&gt;第一处和第二处&lt;/strong&gt;的总复杂度显然为线性的，因为单次操作均摊只为自动机添加了一个新转移。&lt;/p&gt;
&lt;p&gt;还需为&lt;strong&gt;第三处&lt;/strong&gt;估计总复杂度，我们将最初指向 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 的转移重定向到 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt;。我们记 &lt;span class=&quot;math inline&quot;&gt;\(v=longest(p)\)&lt;/span&gt;，这是一个字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的后缀，每次迭代长度都递减—因为作为字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的位置随着每次迭代都单调上升。这种情况下，如果在循环的第一次迭代之前，相对应的字符串 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 在距离 &lt;span class=&quot;math inline&quot;&gt;\(last\)&lt;/span&gt; 的深度为 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\((k\ge2)\)&lt;/span&gt; 的位置上（深度记为后缀链接的数量），那么在最后一次迭代后，字符串 &lt;span class=&quot;math inline&quot;&gt;\(v+c\)&lt;/span&gt; 将会成为路径上第二个从 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt; 出发的后缀链接（它将会成为新的 &lt;span class=&quot;math inline&quot;&gt;\(last\)&lt;/span&gt; 的值）。&lt;/p&gt;
&lt;p&gt;因此，循环中的每次迭代都会使作为当前字符串的后缀的字符串 &lt;span class=&quot;math inline&quot;&gt;\(longest(link(link(last))\)&lt;/span&gt; 的位置单调递增。因此这个循环最多不会执行超过 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 次迭代，这正是我们需要证明的。&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;首先，我们描述一种存储一个转移的全部信息的数据结构。如果需要的话，你可以在这里加入一个终止标记，也可以是一些其它信息。我们将会用一个 &lt;code&gt;map&lt;/code&gt; 存储转移的列表，允许我们在总计 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt; 的空间复杂度和 &lt;span class=&quot;math inline&quot;&gt;\(O(n\log k)\)&lt;/span&gt; 的时间复杂度内处理整个字符串。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct state {
    int len, link;
    map&amp;lt;char, int&amp;gt; next;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后缀自动机本身将会存储在一个 &lt;code&gt;state&lt;/code&gt; 结构体数组中。我们记录当前自动机的大小 &lt;code&gt;sz&lt;/code&gt; 和变量 &lt;code&gt;last&lt;/code&gt;，当前整个字符串对应的状态。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const int MAXLEN = 100000;
state st[MAXLEN * 2];
int sz, last;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义一个函数来初始化后缀自动机（创建一个只有一个状态的后缀自动机）。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void sa_init() {
    st[0].len = 0;
    st[0].link = -1;
    sz++;
    last = 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终我们给出主函数的实现—给当前行末增加一个字符，对应地重建自动机。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void sa_extend(char c) {
    int cur = sz++;
    st[cur].len = st[last].len + 1;
    int p = last;
    while (p != -1 &amp;amp;&amp;amp; !st[p].next.count(c)) {
        st[p].next[c] = cur;
        p = st[p].link;
    }
    if (p == -1) {
        st[cur].link = 0;
    } else {
        int q = st[p].next[c];
        if (st[p].len + 1 = st[q].len) {
            st[cur].link = q;
        } else {
            int clone = sz++;
            st[clone].len = st[p].len + 1;
            st[clone].next = st[q].next;
            st[clone].link = st[q].link;
            while (p != -1 &amp;amp;&amp;amp; st[p].next[c] == q) {
                st[p].next[c] = clone;
                p = st[p].link;
            }
            st[q].link = st[cur].link = clone;
        }
    }
    last = cur;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如之前提到的一样，如果你用内存换时间（空间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(nk)\)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 为字符集大小），你可以在 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt; 的时间内构造字符集大小 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 任意的后缀自动机。但是这样你需要为每一个状态储存一个大小为 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 的数组（用于快速跳转到转移的字符），和另外一个所有转移的链表（用于快速在转移中迭代）。&lt;/p&gt;
&lt;h2 id=&quot;更多的性质&quot;&gt;更多的性质&lt;/h2&gt;
&lt;h3 id=&quot;状态数&quot;&gt;状态数&lt;/h3&gt;
&lt;p&gt;对于一个长度为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 的字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;，它的后缀自动机中的状态数&lt;strong&gt;不会超过 &lt;span class=&quot;math inline&quot;&gt;\(2n-1\)&lt;/span&gt;&lt;/strong&gt; （假设 &lt;span class=&quot;math inline&quot;&gt;\(n\ge2\)&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;对上述结论的证明就是算法本身，因为一开始自动机含有一个状态，第一次和第二次迭代中只会创建一个节点，剩余的 &lt;span class=&quot;math inline&quot;&gt;\(n-2\)&lt;/span&gt; 步中每步会创建至多 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 个状态。&lt;/p&gt;
&lt;p&gt;然而我们也能在&lt;strong&gt;不知道这个算法&lt;/strong&gt;的情况下&lt;strong&gt;展示&lt;/strong&gt;这个估计值。我们回忆一下状态数等于不同的 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 集合个数。另外这些 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 集合形成了一棵树（祖先节点的集合包含了它所有孩子节点的集合）。考虑将这棵树稍微变形一下：只要它有一个只有一个孩子的内部顶点（这意味着该子节点的集合至少遗漏了它的父集合中的一个位置），我们创建一个含有这个遗漏位置的集合。最后我们可以获得一棵每一个内部顶点的度数大于一的树，并且叶子节点的个数不超过 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;。因此这样的树里有不超过 &lt;span class=&quot;math inline&quot;&gt;\(2n-1\)&lt;/span&gt; 个节点。&lt;/p&gt;
&lt;p&gt;对于每个确定的 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，状态数的上界是确定的。一个可能的字符串是：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[``abbb\ldots bbb\!&quot;\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从第三次迭代后的每次迭代，算法都会拆开一个状态，最终产生恰好 &lt;span class=&quot;math inline&quot;&gt;\(2n-1\)&lt;/span&gt; 个状态。&lt;/p&gt;
&lt;h3 id=&quot;转移数&quot;&gt;转移数&lt;/h3&gt;
&lt;p&gt;对于一个长度为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 的字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;，它的后缀自动机中的转移数&lt;strong&gt;不会超过 &lt;span class=&quot;math inline&quot;&gt;\(3n-4\)&lt;/span&gt;&lt;/strong&gt;（假设 &lt;span class=&quot;math inline&quot;&gt;\(n\ge 3\)&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;证明如下：&lt;/p&gt;
&lt;p&gt;我们首先估计连续的转移的数量。考虑自动机中从状态 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 开始的最长路径的生成树。生成树的骨架只包含连续的边，因此数量少于状态数，即，边数不会超过 &lt;span class=&quot;math inline&quot;&gt;\(2n-2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;现在我们来估计非连续的转移的数量。令当前非连续转移为 &lt;span class=&quot;math inline&quot;&gt;\((p,\,q)\)&lt;/span&gt;，其字符为 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;。我们取它的对应字符串 &lt;span class=&quot;math inline&quot;&gt;\(u+c+w\)&lt;/span&gt;，其中字符串 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 对应于初始状态到 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 的最长路径，&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 对应于从 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 到任意终止状态的最长路径。一方面，对于每个不完整的字符串所对应的形如 &lt;span class=&quot;math inline&quot;&gt;\(u+c+w\)&lt;/span&gt; 的字符串是不同的（因为字符串 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 仅由完整的转移组成）。另一方面，由终止状态的定义，每个形如 &lt;span class=&quot;math inline&quot;&gt;\(u+c+w\)&lt;/span&gt; 的字符串都是整个字符串 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 的后缀。因为 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 只有 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个非空后缀，且形如 &lt;span class=&quot;math inline&quot;&gt;\(u+c+w\)&lt;/span&gt; 的字符串都不包含 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;（因为整个字符串只包含完整的转移），所以非完整的转移的总数不会超过 &lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;将以上两个估计值结合起来，我们可以得到上界 &lt;span class=&quot;math inline&quot;&gt;\(3n-3\)&lt;/span&gt;。然而，最大的状态数只能在测试数据 &lt;span class=&quot;math inline&quot;&gt;\(``abbb\ldots bbb\!&quot;\)&lt;/span&gt; 中产生，这个测试数据的转移数量显然少于 &lt;span class=&quot;math inline&quot;&gt;\(3n-3\)&lt;/span&gt;，我们可以获得更为紧确的后缀自动机的转移数的上界：&lt;span class=&quot;math inline&quot;&gt;\(3n-4\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;上界可以通过字符串&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[``abbb\ldots bbbc\!&quot;\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;达到。&lt;/p&gt;
&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;
&lt;p&gt;下面我们来看一下一些可以用后缀自动机解决的问题。为了简单，我们假设字符集的大小 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 为常数，允许我们认为增加一个字符和遍历的复杂度为常数。&lt;/p&gt;
&lt;h3 id=&quot;检查字符串是否出现&quot;&gt;检查字符串是否出现&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;给一个文本串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 和多个模式串 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;，我们要检查字符串 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 是否作为 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 的一个子串出现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在 &lt;span class=&quot;math inline&quot;&gt;\(O(length(T))\)&lt;/span&gt; 的时间内为文本串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 构造后缀自动机。为了检查模式串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 是否在 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 中出现，我们沿转移（边）从 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 开始根据 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 的字符进行转移。如果在某个点无法转移下去，则模式串 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 不是 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 的一个子串。如果我们能够这样处理完整个字符串 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;，那么模式串在 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 中出现过。因此&lt;/p&gt;
&lt;p&gt;对于每个字符串 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 算法的时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(length(P))\)&lt;/span&gt;。此外，这个算法还找到了模式串 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 在文本串中出现的最大前缀长度。&lt;/p&gt;
&lt;h3 id=&quot;不同子串个数&quot;&gt;不同子串个数&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;给一个字符串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;，计算不同子串的个数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为字符串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 构造后缀自动机。&lt;/p&gt;
&lt;p&gt;每个 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 的子串都相当于自动机中的一些路径。因此不同子串的个数等于自动机中以 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt; 为起点的不同路径的条数。&lt;/p&gt;
&lt;p&gt;考虑到后缀自动机为有向无环图，不同路径的条数可以使用动态规划计算。&lt;/p&gt;
&lt;p&gt;即，令 &lt;span class=&quot;math inline&quot;&gt;\(d[v]\)&lt;/span&gt; 为从状态 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 开始的路径数量（包括长度为零的路径），则我们有如下递推方程式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[d[v]=1+\sum_{w:(v,\,w,\,c)\in SA}d[w]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即，&lt;span class=&quot;math inline&quot;&gt;\(d[v]\)&lt;/span&gt; 可以表示为所有 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 的转移的末端的和。&lt;/p&gt;
&lt;p&gt;所以不同子串的个数为 &lt;span class=&quot;math inline&quot;&gt;\(d[t_0]-1\)&lt;/span&gt;（因为要去掉空子串）。&lt;/p&gt;
&lt;p&gt;总时间复杂度为：&lt;span class=&quot;math inline&quot;&gt;\(O(length(S))\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;所有不同子串的总长度&quot;&gt;所有不同子串的总长度&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;给定一个字符串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;，计算所有不同子串的总长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本题做法与上一题类似，只是现在我们需要考虑分两部分进行动态规划：不同子串的数量 &lt;span class=&quot;math inline&quot;&gt;\(d[v]\)&lt;/span&gt; 和它们的总长度 &lt;span class=&quot;math inline&quot;&gt;\(ans[v]\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们已经在上一题中介绍了如何计算 &lt;span class=&quot;math inline&quot;&gt;\(d[v]\)&lt;/span&gt;。&lt;span class=&quot;math inline&quot;&gt;\(ans[v]\)&lt;/span&gt; 的值可以使用通过以下递推式计算：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ans[v]=\sum_{w:(v,\,w,\,c)\in DAWG}d[w]+ans[w]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们取每个邻接顶点 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 的答案，并加上 &lt;span class=&quot;math inline&quot;&gt;\(d[w]\)&lt;/span&gt;（因为从状态 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 出发的子串都增加了一个字符）。&lt;/p&gt;
&lt;p&gt;算法的时间复杂度仍然是 &lt;span class=&quot;math inline&quot;&gt;\(O(length(S))\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;字典序第-k-大子串&quot;&gt;字典序第 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 大子串&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;给定一个字符串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;。多组询问，每组询问给定一个数 &lt;span class=&quot;math inline&quot;&gt;\(K_i\)&lt;/span&gt;，查询所有子串中词典序第 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 大的子串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决这个问题的思路基于前两个问题的思路。字典序第 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 大的子串对应于后缀自动机中字典序第 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 大的路径。因此在计算每个状态的路径数后，我们可以很容易地从后缀自动机的根开始找到第 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 大的路径。&lt;/p&gt;
&lt;p&gt;预处理的时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(length(S))\)&lt;/span&gt;，单次查询的复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(length(ans)\cdot k)\)&lt;/span&gt;（其中 &lt;span class=&quot;math inline&quot;&gt;\(ans\)&lt;/span&gt; 是查询的答案，&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 为字符集的大小）。&lt;/p&gt;
&lt;h3 id=&quot;最小循环移位&quot;&gt;最小循环移位&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;给定一个字符串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;。找出字典序最小的循环移位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们为字符串 &lt;span class=&quot;math inline&quot;&gt;\(S+S\)&lt;/span&gt; 构造后缀自动机。则后缀自动机本身将包含字符串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 的所有循环移位作为路径。&lt;/p&gt;
&lt;p&gt;所以问题简化为寻找最小的长度为 &lt;span class=&quot;math inline&quot;&gt;\(length(S)\)&lt;/span&gt; 的路径，这可以通过平凡的方法做到：我们从初始状态开始，贪心地访问最小的字符即可。&lt;/p&gt;
&lt;p&gt;总的时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(length(S))\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;出现次数&quot;&gt;出现次数&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于一个给定的文本串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;，有多组询问，每组询问给一个模式串 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;，回答模式串 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 在字符串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 中作为子串出现了多少次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们为文本串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 构造后缀自动机。&lt;/p&gt;
&lt;p&gt;接下来我们做以下的预处理：对于自动机中的每个状态 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;，预处理值等于 &lt;span class=&quot;math inline&quot;&gt;\(endpos(v)\)&lt;/span&gt; 这个集合大小的 &lt;span class=&quot;math inline&quot;&gt;\(cnt[v]\)&lt;/span&gt;。事实上对应于同一状态 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 的所有子串在文本串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 中的出现次数相同，这相当于集合 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 中的位置数。&lt;/p&gt;
&lt;p&gt;然而我们不能明确的构造集合 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt;，因此我们只考虑它们的大小 &lt;span class=&quot;math inline&quot;&gt;\(cnt\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;为了计算这些值，我们进行以下操作。对于每个状态，如果它不是通过复制创建的（且它不是初始状态 &lt;span class=&quot;math inline&quot;&gt;\(t_0\)&lt;/span&gt;），我们用 &lt;span class=&quot;math inline&quot;&gt;\(cnt=1\)&lt;/span&gt; 初始化它。然后我们按它们的长度 &lt;span class=&quot;math inline&quot;&gt;\(len\)&lt;/span&gt; 降序遍历所有状态，并将当前的 &lt;span class=&quot;math inline&quot;&gt;\(cnt[v]\)&lt;/span&gt; 的值加到后缀链接上，即：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[cnt[link(v)]+=cnt[v]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样做每个状态的答案都是正确的。&lt;/p&gt;
&lt;p&gt;为什么这是正确的？通过复制获得的状态，恰好是 &lt;span class=&quot;math inline&quot;&gt;\(length(T)\)&lt;/span&gt;，并且它们中的前 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个在我们插入前 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个字符时产生。因此对于每个这样的状态，我们在它被处理时计算它们所对应的位置的数量。因此我们初始将这些状态的 &lt;span class=&quot;math inline&quot;&gt;\(cnt\)&lt;/span&gt; 的值赋为 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，其它状态的 &lt;span class=&quot;math inline&quot;&gt;\(cnt\)&lt;/span&gt; 值赋为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;接下来我们对每一个 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 执行以下操作：&lt;span class=&quot;math inline&quot;&gt;\(cnt[link(v)]+=cnt[v]\)&lt;/span&gt;。其背后的含义是，如果有一个字符串 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 出现了 &lt;span class=&quot;math inline&quot;&gt;\(cnt[v]\)&lt;/span&gt; 次，那么它的所有后缀也在完全相同的地方结束，即也出现了 &lt;span class=&quot;math inline&quot;&gt;\(cnt[v]\)&lt;/span&gt; 次。&lt;/p&gt;
&lt;p&gt;为什么我们在这个过程中不会重复计数（即把某些位置数了两次）呢？因为我们只将一个状态的位置添加到&lt;strong&gt;一个&lt;/strong&gt;其它的状态上，所以一个状态不可能以两种不同的方式将其位置重复地指向另一个状态。&lt;/p&gt;
&lt;p&gt;因此，我们可以在 &lt;span class=&quot;math inline&quot;&gt;\(O(length(T))\)&lt;/span&gt; 的时间内计算出所有状态的 &lt;span class=&quot;math inline&quot;&gt;\(cnt\)&lt;/span&gt; 的值。&lt;/p&gt;
&lt;p&gt;最后回答询问只需要查找查找值 &lt;span class=&quot;math inline&quot;&gt;\(cnt[t]\)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 为如果存在这样的状态就是状态对应的模式串，如果不存在答案就为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;。单次查询的时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(length(P))\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;第一次出现的位置&quot;&gt;第一次出现的位置&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;给定一个文本串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;，多组查询。每次查询字符串 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 在字符串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 中第一次出现的位置（&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 的开头位置）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们再构造一个后缀自动机。我们对自动机中的所有状态预处理位置 &lt;span class=&quot;math inline&quot;&gt;\(firstpos\)&lt;/span&gt;。即，对每个状态 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 我们想要找到第一次出现这个状态的末端的位置 &lt;span class=&quot;math inline&quot;&gt;\(firstpos[v]\)&lt;/span&gt;。换句话说，我们希望先找到每个集合 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 中的最小的元素（显然我们不能显式地维护所有 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 集合）。&lt;/p&gt;
&lt;p&gt;为了维护 &lt;span class=&quot;math inline&quot;&gt;\(firstpos\)&lt;/span&gt; 这些位置，我们将原函数扩展为 &lt;code&gt;sa_extend()&lt;/code&gt;。当我们创建新状态 &lt;span class=&quot;math inline&quot;&gt;\(cur\)&lt;/span&gt; 时，我们令：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[firstpos(cur)=len(cur)-1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;；当我们将顶点 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 复制到 &lt;span class=&quot;math inline&quot;&gt;\(clone\)&lt;/span&gt; 时，我们令：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[firstpos(clone)=firstpos(q)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（因为值的唯一其它选项 &lt;span class=&quot;math inline&quot;&gt;\(firstpos(cur)\)&lt;/span&gt; 肯定太大了）。&lt;/p&gt;
&lt;p&gt;那么查询的答案就是 &lt;span class=&quot;math inline&quot;&gt;\(firstpos(t)-length(P)+1\)&lt;/span&gt;，其中 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 为对应字符串 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 的状态。单次查询只需要 &lt;span class=&quot;math inline&quot;&gt;\(O(length(P))\)&lt;/span&gt; 的时间。&lt;/p&gt;
&lt;h3 id=&quot;所有出现的位置&quot;&gt;所有出现的位置&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;问题同上，这一次需要查询文本串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 中模式串出现的所有位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们还是为文本串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 构造后缀自动机。与上一个问题相似地，我们为所有状态计算位置 &lt;span class=&quot;math inline&quot;&gt;\(firstpos\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 为对应于模式串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 的状态，显然 &lt;span class=&quot;math inline&quot;&gt;\(firstpos(t)\)&lt;/span&gt; 为答案的一部分。需要查找的其它位置怎么办？我们使用了含有字符串 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 的自动机，我们还需要将哪些状态纳入自动机呢？所有对应于以 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 为后缀的字符串的状态。换句话说我们要找到所有可以通过后缀链接到达状态 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 的状态。&lt;/p&gt;
&lt;p&gt;因此为了解决这个问题，我们需要为每一个状态保存一个指向它的后缀引用列表。查询的答案就包含了对于每个我们能从状态 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 只使用后缀引用进行 DFS 或 BFS 的所有状态的 &lt;span class=&quot;math inline&quot;&gt;\(firstpos\)&lt;/span&gt; 值。&lt;/p&gt;
&lt;p&gt;这种变通方案的时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(answer(P))\)&lt;/span&gt;，因为我们不会重复访问一个状态（因为对于仅有一个后缀链接指向一个状态，所以不存在两条不同的路径指向同一状态）。&lt;/p&gt;
&lt;p&gt;我们只需要考虑两个可能有相同 &lt;span class=&quot;math inline&quot;&gt;\(endpos\)&lt;/span&gt; 值的不同状态。如果一个状态是由另一个复制而来的，则这种情况会发生。然而，这并不会对复杂度分析造成影响，因为每个状态至多被复制一次。&lt;/p&gt;
&lt;p&gt;此外，如果我们不从被复制的节点输出位置，我们也可以去除重复的位置。事实上对于一个状态，如果经过被复制状态可以到达，则经过原状态也可以到达。因此，如果我们给每个状态记录标记 &lt;code&gt;is_clone&lt;/code&gt;，我们就可以简单地忽略掉被复制的状态，只输出其它所有状态的 &lt;span class=&quot;math inline&quot;&gt;\(firstpos\)&lt;/span&gt; 的值。&lt;/p&gt;
&lt;p&gt;以下是实现的框架：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct state {
    ...
    bool is_clone;
    int first_pos;
    vector&amp;lt;int&amp;gt; inv_link;
};

// 在构造后缀自动机后
for (int v = 1; v &amp;lt; sz; v++) {
    st[st[v].link].inv_link.push_back(v);
}

// 输出所有出现位置
void output_all_occurrences(int v, int P_length) {
    if (!st[v].is_clone)
        cout &amp;lt;&amp;lt; st[v].first_pos - P_length + 1 &amp;lt;&amp;lt; endl;
    for (int u : st[v].inv_link)
        output_all_occurrences(u, P_length);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最短的没有出现的字符串&quot;&gt;最短的没有出现的字符串&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;给定一个字符串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 和一个特定的字符集，我们要找一个长度最短的没有在 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 中出现过的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在字符串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 的后缀自动机上做动态规划。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(d[v]\)&lt;/span&gt; 为节点 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 的答案，即，我们已经处理完了子串的一部分，当前在状态 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;，想找到不连续的转移需要添加的最小字符数量。计算 &lt;span class=&quot;math inline&quot;&gt;\(d[v]\)&lt;/span&gt; 非常简单。如果不存在使用字符集中至少一个字符的转移，则 &lt;span class=&quot;math inline&quot;&gt;\(d[v]=1\)&lt;/span&gt;。否则添加一个字符是不够的，我们需要求出所有转移中的最小值：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[d[v]=1+\min_{w(v,\,w,\,c)\in SA}d[w]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;问题的答案就是 &lt;span class=&quot;math inline&quot;&gt;\(d[t_0]\)&lt;/span&gt;，字符串可以通过计算过的数组 &lt;span class=&quot;math inline&quot;&gt;\(d[]\)&lt;/span&gt; 逆推回去。&lt;/p&gt;
&lt;h3 id=&quot;两个字符串的最长公共子串&quot;&gt;两个字符串的最长公共子串&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;给定两个字符串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;，求出最长公共子串，公共子串定义为在 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 中都作为子串出现过的字符串 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们为字符串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 构造后缀自动机。&lt;/p&gt;
&lt;p&gt;我们现在处理字符串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;，对于每一个前缀都在 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 中寻找这个前缀的最长后缀。换句话说，对于每个字符串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 中的位置，我们想要找到这个位置结束的 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 的最长公共子串的长度。&lt;/p&gt;
&lt;p&gt;为了达到这一目的，我们使用两个变量，&lt;strong&gt;当前状态&lt;/strong&gt; &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 和 &lt;strong&gt;当前长度&lt;/strong&gt; &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;。这两个变量描述当前匹配的部分：它的长度和它们对应的状态。&lt;/p&gt;
&lt;p&gt;一开始 &lt;span class=&quot;math inline&quot;&gt;\(v=t_0\)&lt;/span&gt; 且 &lt;span class=&quot;math inline&quot;&gt;\(l=0\)&lt;/span&gt;，即，匹配为空串。&lt;/p&gt;
&lt;p&gt;现在我们来描述如何添加一个字符 &lt;span class=&quot;math inline&quot;&gt;\(T[i]\)&lt;/span&gt; 并为其重新计算答案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果存在一个从 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 到字符 &lt;span class=&quot;math inline&quot;&gt;\(T[i]\)&lt;/span&gt; 的转移，我们只需要转移并让 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 自增一。&lt;/li&gt;
&lt;li&gt;如果不存在这样的转移，我们需要缩短当前匹配的部分，这意味着我们需要按照以下后缀链接进行转移：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[v=link(v)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;与此同时，需要缩短当前长度。显然我们需要将 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 赋值为 &lt;span class=&quot;math inline&quot;&gt;\(len(v)\)&lt;/span&gt;，因为经过这个后缀链接后我们到达的状态所对应的最长字符串是一个子串。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果仍然没有使用这一字符的转移，我们继续重复经过后缀链接并减小 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;，直到我们找到一个转移或到达虚拟状态 &lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt;（这意味着字符 &lt;span class=&quot;math inline&quot;&gt;\(T[i]\)&lt;/span&gt; 根本没有在 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 中出现过，所以我们设置 &lt;span class=&quot;math inline&quot;&gt;\(v=l=0\)&lt;/span&gt;）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;问题的答案就是所有 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 的最大值。&lt;/p&gt;
&lt;p&gt;这一部分的时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(length(T))\)&lt;/span&gt;，因为每次移动我们要么可以使 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 增加一，要么可以在后缀链接间移动几次，每次都减小 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 的值。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;string lcs (string S, string T) {
    sa_init();
    for (int i = 0; i &amp;lt; S.size(); i++)
        sa_extend(S[i]);

    int v = 0, l = 0, best = 0, bestpos = 0;
    for (int i = 0; i &amp;lt; T.size(); i++) {
        while (v &amp;amp;&amp;amp; !st[v].next.count(T[i])) {
            v = st[v].link ;
            l = st[v].length ;
        }
        if (st[v].next.count(T[i])) {
            v = st [v].next[T[i]];
            l++;
        }
        if (l &amp;gt; best) {
            best = l;
            bestpos = i;
        }
    }
    return t.substr(bestpos - best + 1, best);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多个字符串间的最长公共子串&quot;&gt;多个字符串间的最长公共子串&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;给定 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 个字符串 &lt;span class=&quot;math inline&quot;&gt;\(S_i\)&lt;/span&gt;。我们需要找到它们的最长公共子串，即作为子串出现在每个字符串中的字符串 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们将所有的子串连接成一个较长的字符串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;，以特殊字符 &lt;span class=&quot;math inline&quot;&gt;\(D_i\)&lt;/span&gt; 分开每个字符串（一个字符对应一个字符串）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[T=S_1+D_1+S_2+D_2+\cdots+S_k+D_k.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后为字符串 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 构造后缀自动机。&lt;/p&gt;
&lt;p&gt;现在我们需要在自动机中找到存在于所有字符串 &lt;span class=&quot;math inline&quot;&gt;\(S_i\)&lt;/span&gt; 中的一个字符串，这可以通过使用添加的特殊字符完成。注意如果 &lt;span class=&quot;math inline&quot;&gt;\(S_j\)&lt;/span&gt; 包含了一个子串，则后缀自动机中存在一条从包含字符 &lt;span class=&quot;math inline&quot;&gt;\(D_j\)&lt;/span&gt; 的子串而不包含以其它字符 &lt;span class=&quot;math inline&quot;&gt;\(D_1,\,\ldots,\,D_{j-1},\,D_{j+1},\,\ldots,\,D_k\)&lt;/span&gt; 开始的路径。&lt;/p&gt;
&lt;p&gt;因此我们需要计算可达性，它告诉我们对于自动机中的每个状态和每个字符 &lt;span class=&quot;math inline&quot;&gt;\(D_i\)&lt;/span&gt; 是否存在这样的一条路径。这可以容易地通过 DFS 或 BFS 与动态规划计算。在此之后，问题的答案就是状态 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 的字符串 &lt;span class=&quot;math inline&quot;&gt;\(longest(v)\)&lt;/span&gt; 中存在所有特殊字符的路径。&lt;/p&gt;
&lt;h2 id=&quot;练习&quot;&gt;练习&lt;/h2&gt;
&lt;p&gt;可以使用后缀自动机解决的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SPOJ #7258 SUBLEX 「字典序子串搜索」（难度：中等）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;相关文献&quot;&gt;相关文献&lt;/h2&gt;
&lt;p&gt;我们先给出与后缀自动机有关的最初的一些文献：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler, R. McConnell. &lt;strong&gt;Linear&lt;br/&gt;Size Finite Automata for the Set of All Subwords of a Word. An Outline of&lt;br/&gt;Results&lt;/strong&gt; [1983]&lt;/li&gt;
&lt;li&gt;A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler. &lt;strong&gt;The Smallest Automaton&lt;br/&gt;Recognizing the Subwords of a Text&lt;/strong&gt; [1984]&lt;/li&gt;
&lt;li&gt;Maxime Crochemore. &lt;strong&gt;Optimal Factor Transducers&lt;/strong&gt; [1985]&lt;/li&gt;
&lt;li&gt;Maxime Crochemore. &lt;strong&gt;Transducers and Repetitions&lt;/strong&gt; [1986]&lt;/li&gt;
&lt;li&gt;A. Nerode. &lt;strong&gt;Linear automaton transformations&lt;/strong&gt; [1958]&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，在更现代化的一些资源里，在很多关于字符串算法的书中，这个主题都能被找到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Maxime Crochemore, Rytter Wowjcieh. &lt;strong&gt;Jewels of Stringology&lt;/strong&gt; [2002]&lt;/li&gt;
&lt;li&gt;Bill Smyth. &lt;strong&gt;Computing Patterns in Strings&lt;/strong&gt; [2003]&lt;/li&gt;
&lt;li&gt;Bill Smith. &lt;strong&gt;Methods and algorithms of calculations on lines&lt;/strong&gt; [2006]&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 24 Aug 2018 13:01:00 +0000</pubDate>
<dc:creator>baka</dc:creator>
<og:description>[TOC] 本文译自博文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TheRoadToAu/p/Suffix-Automata.html</dc:identifier>
</item>
<item>
<title>回车与换行的故事 - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/9531939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/9531939.html</guid>
<description>&lt;p&gt;以前在学汇编的时候，一直不知道老师在换行时，总会打一个&lt;strong&gt;换行符&lt;/strong&gt;和&lt;strong&gt;回车符&lt;/strong&gt;，原来他们还有这么一个故事....&lt;/p&gt;
&lt;p&gt;在很久以前，有一种叫做&lt;strong&gt;电传打字机(Teletype Model 33 ASR)&lt;/strong&gt; 的机器，那时候还没有计算机这种玩意。在这种打字机上，有一个叫&lt;strong&gt;Carriage&lt;/strong&gt;的部件，它是打字头，相当于打字机的光标。每输入一个字符，光标就会前进一格。当输入的字符满一行后，光标重新从&lt;strong&gt;下一行的最左边&lt;/strong&gt;开始打印。&lt;/p&gt;
&lt;p&gt;这个时候会触发两个动作，一个是把光标在垂直方向上向下移，一个是在水平方向上把光标移动到最左边。然后这种打字机每秒可以打10个字符，相当于0.1秒打一个字符；而要完成这两个动作需要花费0.2秒的时间，如果在这0.2秒中，有新的字符传过来的话，那么这些字符将会丢失。&lt;/p&gt;
&lt;p&gt;为了解决这个字符丢失的问题，研制人员就在每行的后面添加了两个表示一行结束的字符：一个叫&lt;strong&gt;回车(carriage return)&lt;/strong&gt;，相当于告诉打字机，把光标在水平方向上移到最左边；一个叫&lt;strong&gt;换行(line feed)&lt;/strong&gt;，相当于告诉打字机，在垂直方向上把光标移动到下一行。&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;回车&lt;/strong&gt;和&lt;strong&gt;换行&lt;/strong&gt;的由来。&lt;/p&gt;
&lt;p&gt;后来，计算机出现了，这两个概念也被拿了过来。但是那时候储存设备非常昂贵，一些人认为用两个字符用来表示一行的结尾非常浪费，于是产生了分支，不同的厂商有不同的处理方法。&lt;/p&gt;
&lt;p&gt;在这些操作系统中，Unix操作系统每行结尾只有&lt;strong&gt;换行&lt;/strong&gt;，即&quot;\n&quot;;Windows则是&lt;strong&gt;回车+换行&lt;/strong&gt;，即“\r\n”；而Mac系统里则使用&lt;strong&gt;回车&lt;/strong&gt;来代表结尾，即“\r”。&lt;/p&gt;
&lt;p&gt;正是这个原因，才会导致我们有时用Windows系统来打开Unix/Mac系统的文件时，会出现所有文字变成一行的情况，而用Unix和Mac系统打开Windows系统的文件时，在每一行的结尾会多出一个 &lt;strong&gt;^M&lt;/strong&gt; 的字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关注公我的众号：&lt;strong&gt;苦逼的码农&lt;/strong&gt;，获取更多原创文章，后台回复&lt;strong&gt;礼包&lt;/strong&gt;送你一份特别的资源大礼包。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 24 Aug 2018 12:48:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>以前在学汇编的时候，一直不知道老师在换行时，总会打一个 换行符 和 回车符 ，原来他们还有这么一个故事.... 在很久以前，有一种叫做 电传打字机(Teletype Model 33 ASR) 的机器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/9531939.html</dc:identifier>
</item>
<item>
<title>html相对定位绝对定位 - 张少凯</title>
<link>http://www.cnblogs.com/shaokai7878/p/9531818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shaokai7878/p/9531818.html</guid>
<description>&lt;p&gt;　　孔子说：“温故而知新，可以为师矣。”这几天参加了一个免费的前端课，每天晚上都有直播，讲解一个独立的案例。在听前端基础的时候，发现自己有不少东西没学会，平时在学校虽说html也写了不少，但有好大一部分都被忽略掉了。就在刚才看了一个基础案例，很是有共鸣，一个简单的轮播图，牵扯到的东西实在是多。不得不说，专业的就是专业的。&lt;/p&gt;
&lt;p&gt;　　好了，废话不多说，直接上干货。经常做页面渲染的筒子可能会遇到的一个问题，position的相对定位和绝对定位。这个问题看似很简单，不就是一个定位嘛，有什么的？别急，我们慢慢往下看。网上流传着一个说法，叫子绝父相。就是说子元素设置绝对定位，父元素设置相对定位。然后就可以给子元素设定top,left值来控制位置。这其实是一种很错误的观念，完全曲解了定义。楼主之前在学校写页面的时候也犯过类似的错误，只要实现了效果就行，管他什么原理呢，结果每次碰到定位的问题都卡壳。查半天还记不住，为了彻底搞懂这个，特地花时间写了这篇帖子。&lt;/p&gt;
&lt;p&gt;　　relative也就是相对定位：是相对于本身的位置进行偏移。只看自己，不看其他。&lt;/p&gt;
&lt;p&gt;　　absolute绝对定位：相对于非static的祖先元素进行位置偏移，当这样的元素不存在，则相对于根级容器定位。&lt;/p&gt;
&lt;p&gt;　　以一个轮播图为例，html代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;banner&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;!--S banner--&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;banner-bg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;images/1.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;banner-bg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;images/2.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;banner-bg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;images/3.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;nav&quot;&amp;gt;&amp;lt;!--导航按钮，注意这里用的是&amp;lt;i&amp;gt;标签--&amp;gt;&lt;br/&gt;　　&amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
　　&amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
　　&amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&amp;lt;/div&amp;gt;&amp;lt;！--E banner--&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CSS代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1448663/201808/1448663-20180824192024185-1368810942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　banner是banner-bg的父级，然后给banner设置一个position：absolute属性。按照规则absolute要找他的非static祖先元素，我们为了让banner-bg这几个轮播图都固定在最上面，所以就要给轮播容器banner添加一个position：relative属性。这样设定left：0；top：0；就会定位到banner了。虽然不设定banner的relative属性也能将图片放到顶部，但那样的话，banner-bg找的是根级元素html，这并不是我们想要的效果。为了以后不出现差错，还是给想要定位的元素添加一个position：relative属性。&lt;/p&gt;
&lt;p&gt;　　说了这么多，其实absolute定位的时候，就看你想要定位到哪个父级元素，就给哪个元素添加relative属性。而不是盲目的去套那些子绝父相什么的。搞懂原理才是正解。希望能帮到需要的人，花了一下午整理，就怕有些定义搞不太懂，编辑博客也是一个学习的过程，本着对他人负责的态度，写出来的东西一定要确认无误后才敢发表。有不足之处欢迎指出。&lt;/p&gt;
</description>
<pubDate>Fri, 24 Aug 2018 12:06:00 +0000</pubDate>
<dc:creator>张少凯</dc:creator>
<og:description>孔子说：“温故而知新，可以为师矣。”这几天参加了一个免费的前端课，每天晚上都有直播，讲解一个独立的案例。在听前端基础的时候，发现自己有不少东西没学会，平时在学校虽说html也写了不少，但有好大一部分都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shaokai7878/p/9531818.html</dc:identifier>
</item>
</channel>
</rss>