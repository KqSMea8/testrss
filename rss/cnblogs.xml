<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一文读懂以太坊代币合约 - he1m4n6a</title>
<link>http://www.cnblogs.com/he1m4n6a/p/9327589.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/he1m4n6a/p/9327589.html</guid>
<description>
&lt;h2 id=&quot;以太坊代币&quot; data-anchor-id=&quot;r3pv&quot;&gt;以太坊代币&lt;/h2&gt;
&lt;p data-anchor-id=&quot;ak1o&quot;&gt;在以太坊系统中，存在作为基础货币的 Ether（以太），以及同样可以作为货币使用的 Token（代币）。&lt;/p&gt;
&lt;p data-anchor-id=&quot;rd1u&quot;&gt;以太坊与其他加密货币的主要不同在于，以太坊不是单纯的货币，而是一个环境/平台。在这个平台上，任何人都可以利用区块链的技术，通过智能合约来构建自己的项目和DAPPS（去中心化应用）。&lt;/p&gt;
&lt;p data-anchor-id=&quot;qruh&quot;&gt;如果把以太坊理解成互联网，DAPPS则是在上面运行的网页。DAPPS是去中心化的，意味着它不属于某个人，而是属于一群人。DAPPS发布的方式通常是采用被称为 ICO 的众筹方式。简单来说，你需要用你的以太来购买相应DAPP的一些tokens。&lt;/p&gt;
&lt;h4 id=&quot;一般有两种token&quot; data-anchor-id=&quot;bdxd&quot;&gt;一般有两种Token：&lt;/h4&gt;
&lt;ol data-anchor-id=&quot;ftbp&quot;&gt;&lt;li&gt;Usage Tokens: 就是对应 DAPP 的原生货币。Golem 就是一个很好的例子，如果你需要使用 Golem 的服务，你就需要为其支付 Golem Network Token（GNT）。由于这种 Tokens 有货币价值，所以通常不会有其他的权益。&lt;/li&gt;
&lt;li&gt;Work Tokens: 此类 Tokens 可以标识你对于 DAPP 的某种股东权益。以 DAO tokens 为例，如果你拥有 DAO tokens，那么你有权就DAO是否资助某款 DAPP 来进行投票。&lt;/li&gt;
&lt;/ol&gt;&lt;p data-anchor-id=&quot;v8tb&quot;&gt;　　类比到股权，可以把 Usage Tokens 简单理解为普通流通股，可以与真实货币兑换，本身具有价值。而 Work Token，则大致相当于投票权。&lt;/p&gt;
&lt;h4 id=&quot;为何需要token&quot; data-anchor-id=&quot;g88h&quot;&gt;为何需要Token:&lt;/h4&gt;
&lt;p data-anchor-id=&quot;ov5w&quot;&gt;不是有以太基础货币了，那为什么还需要 token 呢？可以想下现实生活的真实场景，在游乐场里，我们需要用现金兑换代币，然后用代币支付各种服务。 类比到以太坊，现金就是以太，代币就是 token，用 token 来执行合约中的各项功能。&lt;/p&gt;

&lt;h2 id=&quot;以太坊token标准&quot; data-anchor-id=&quot;pk6z&quot;&gt;以太坊Token标准&lt;/h2&gt;
&lt;p data-anchor-id=&quot;n6uz&quot;&gt;这个是本文学习的重点，所有遵循 ERC20 标准的函数，都要事先它定义的标准接口。搞懂这些，你也就能很快看懂一些智能合约代币的逻辑。&lt;/p&gt;
&lt;p data-anchor-id=&quot;dnj8&quot;&gt;ERC-20 标准是在2015年11月份推出的，使用这种规则的代币，表现出一种通用的和可预测的方式。任何 ERC-20 代币都能立即兼容以太坊钱包（几乎所有支持以太币的钱包，包括Jaxx、MEW、imToken等），由于交易所已经知道这些代币是如何操作的，它们可以很容易地整合这些代币。这就意味着，在很多情况下，这些代币都是可以立即进行交易的。简单理解就是，ERC20是开发者在自己的tokens中必须采用的一套具体的公式/方法，从而确保不同DAPP的token与ERC20标准兼容。&lt;/p&gt;
&lt;p data-anchor-id=&quot;9vuh&quot;&gt;ERC-20 标准规定了各个代币的基本功能，非常方便第三方使用，在开发人员的编程下，5 分钟就可以发行一个 ERC-20 代币。因为它可以快速发币，而且使用又方便，因此空投币和空气币基本上就是利用 ERC-20 标准开发的。基于 ERC-20 标准开发的同种代币价值都是相同的，它们可以进行互换。ERC-20 代币就类似于人民币，你的 100 元和我的 100 元是没有区别的，价值都是 100 元，并且这两张 100 元可以进行互换。有了这套标准，相当于全世界都使用人民币，而不用去别的国家还要计算汇率换成别的货币。想象下，每个Dapp都有不同格式的币，那对于这些应用的交互简直是种灾难。&lt;/p&gt;
&lt;p data-anchor-id=&quot;9vuh&quot;&gt;etherscan上开源的 ERC20 标准的智能合约：&lt;a href=&quot;https://etherscan.io/tokens&quot; target=&quot;_blank&quot;&gt;https://etherscan.io/tokens&lt;/a&gt;&lt;/p&gt;
&lt;h4 data-anchor-id=&quot;45do&quot;&gt;&lt;strong&gt;ERC20 Token标准接口：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
contract ERC20 {
    uint256 public totalSupply;

    function balanceOf(address who) constant public returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    function allowance(address owner, address spender) constant public returns (uint256);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;839r&quot;&gt;注意：非常重要的一点是调用者应该处理函数返回的错误，而不是假设错误永远不会发生。&lt;/p&gt;
&lt;ol data-anchor-id=&quot;so28&quot;&gt;&lt;li&gt;totalSupply: 返回token的总供应量&lt;/li&gt;
&lt;li&gt;balanceOf: 用于查询某个账户的账户余额&lt;/li&gt;
&lt;li&gt;tansfer: 发送 _value 个 token 到地址 _to&lt;/li&gt;
&lt;li&gt;transferFrom： 从地址 _from 发送 _value 个 token 到地址 _to&lt;/li&gt;
&lt;li&gt;approve： 允许 _spender 多次取回您的帐户，最高达 _value 金额； 如果再次调用此函数，它将用 _value 的当前值覆盖的 allowance 值。&lt;/li&gt;
&lt;li&gt;allowance： 返回 _spender 仍然被允许从 _owner 提取的金额。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 data-anchor-id=&quot;vpqo&quot;&gt;事件 :&lt;/h4&gt;
&lt;ol&gt;&lt;li data-anchor-id=&quot;vpqo&quot;&gt;event Transfer： 当 tokens 被转移时触发。 &lt;/li&gt;
&lt;li data-anchor-id=&quot;vpqo&quot;&gt;event Approval： 当任何成功调用 approve(address _spender, uint256 _value) 后，必须被触发。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代币合约实例分析&quot; data-anchor-id=&quot;huii&quot;&gt;代币合约实例分析&lt;/h2&gt;
&lt;p data-anchor-id=&quot;uw2e&quot;&gt;talk is cheap show me the code 。前面给的函数说明是简单的概括，大家可能还似懂非懂，下面就将用实例说明。《&lt;a href=&quot;http://www.freebuf.com/vuls/176917.html&quot; target=&quot;_blank&quot;&gt;AMR智能合约漏洞分析&lt;/a&gt;》这篇文章用实例讲解了智能合约的一种漏洞，合约代码在 &lt;a href=&quot;https://etherscan.io/address/0x96c833e43488c986676e9f6b3b8781812629bbb5#code&quot; target=&quot;_blank&quot;&gt;https://etherscan.io/address/0x96c833e43488c986676e9f6b3b8781812629bbb5#code &lt;/a&gt;，我们就以这个代码做个详细的分析。&lt;/p&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt;开始一行行分析这个智能合约：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256){
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256){
        assert(b &amp;gt; 0);
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256){
        assert(b &amp;lt;= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256){
        uint256 c = a + b;
        assert(c &amp;gt;= a);
        return c;
    }
}　
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt;这个比较简单，定义安全函数的库，用来防止整数溢出漏洞。&lt;/p&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
contract ERC20 {
    uint256 public totalSupply;

    function balanceOf(address who) constant public returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    function allowance(address owner, address spender) constant public returns (uint256);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ERC20 标准接口，上一节说过了。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
contract Ownable {
    address  owner;

    // 把当前合约的调用者赋值给owner
    function Ownable() public{
        owner = msg.sender;
    }

    // 只有智能合约的所有者才能调用的方法
    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }

    // 合约的所有者可以把权限转移给其他用户
    function transferOwnership(address newOwner) onlyOwner public{
        require(newOwner != address(0));
        owner = newOwner;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个合约接口的功能是判断和修改该合约的所有者。其中函数 onlyOwner 用到了 modifiers(函数修改器) 关键字。函数修改器可以用来改变一个函数的行为，比如用于在函数执行前检查某种前置条件。如果你了解 python 的装饰器，这个就很容易理解了。还不理解？没关系，我们再详细说明下这个接口。首先你需要理解下这边的几个概念：&lt;/p&gt;
&lt;p&gt;1. msg.sender 内置变量，代表当前调用该合约的账户地址。&lt;/p&gt;
&lt;p&gt;2. Ownable() 函数，和合约接口同名，这是个构造函数，只能在创建合约期间运行，不能在事后调用。所以这个owner是创建该合约人的地址，无法被篡改，除非合约创始人授权。&lt;/p&gt;
&lt;p&gt;3. 特殊字符串 _; 用来替换使用修改符的函数体。比如上述代码就是把 _; 替换成 transferOwnership ，也就是执行 transferOwnership 函数时候会先判断  require(msg.sender == owner);&lt;/p&gt;
&lt;p&gt;下面把这个合约加一个打印owner的函数，然后放到 remix 调试，这样更直观理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
pragma solidity ^0.4.24;

contract Ownable {
    address  owner;

    // 把当前合约的调用者赋值给owner
    function Ownable() public{
        owner = msg.sender;
    }
    
    function CurrentOwner() public returns (address){
        return owner;
    }

    // 只有智能合约的所有者才能调用的方法
    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }

    // 合约的所有者可以把权限转移给其他用户
    function transferOwnership(address newOwner) onlyOwner public{
        require(newOwner != address(0));
        owner = newOwner;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a) 使用账户 A 创建合约，则 owner 则是 A 的地址，切换到用户 B 点击 onlyOwner 函数，看到owner的值是账户 A 的地址。这时候如果点击 transferOwnership 会报错，因为这个函数被 onlyOwner 修饰了，会先判断当前调用合约的是否是合约所有者。当前合约所有者是账户 A，合约调用者账户 B 是没权限转移权限的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1205448/201807/1205448-20180718101202447-775134903.png&quot; alt=&quot;&quot; width=&quot;1183&quot; height=&quot;599&quot;/&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt;b)  把账户切换到 A，transferOwnership 地址填账户 B，这时候你就可以把合约所有者权限转移给账户 B 了。而再一次执行，发现提示错误了，因为此时合约所有者已经是账户 B，账户 A 没权限。&lt;/p&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1205448/201807/1205448-20180718103227181-55213379.png&quot; alt=&quot;&quot; width=&quot;1182&quot; height=&quot;589&quot;/&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&lt;br/&gt;contract StandardToken is ERC20 {
    using SafeMath for uint256;　　// 使用 SafeMath 函数库
    mapping (address =&amp;gt; mapping (address =&amp;gt; uint256)) allowed;　　// 类比二维数组
    mapping(address =&amp;gt; uint256) balances;　　// 类比一维数组
&lt;br/&gt;　　 // 把合约调用者的余额转移 _value 个tokens给用户 _to
    function transfer(address _to, uint256 _value) public returns (bool){
        assert(0 &amp;lt; _value);
        assert(balances[msg.sender] &amp;gt;= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

　　 // 查询 _owner 账户的余额
    function balanceOf(address _owner) constant public returns (uint256 balance){
        return balances[_owner];
    }

　　 // 从地址 _from 转移 _value 个 tokens 给地址 _to
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){
        uint256 _allowance = allowed[_from][msg.sender];
        assert (balances[_from] &amp;gt;= _value);
        assert (_allowance &amp;gt;= _value);
        assert (_value &amp;gt; 0);
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    // 允许 _spender 多次取回您的帐户，最高达 _value 金额； 如果再次调用此函数，它将用 _value 的当前值覆盖的 allowance 值
    function approve(address _spender, uint256 _value) public returns (bool){
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    // 返回 _spender 仍然被允许从 _owner 提取的金额
    function allowance(address _owner, address _spender) constant public returns (uint256 remaining){
        return allowed[_owner][_spender];
    }
}　
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt;这边逻辑不复杂，有个概念可能不太好理解，这里详细说明下。allowed 这个变量（类比成二维数组），是用来存取授信的额度，在 approve 函数中定义。&lt;/p&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
allowed[msg.sender][_spender] = _value;
&lt;/pre&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt;这个 msg.sender 是当前合约调用者，_spender 是被授权人，额度是 _value 。可以通俗的理解成，银行（msg.sender）给用户（ _spender） 授权了 _value 额度的 tokens 。在银行转账，相应的额度也会减少，而用户在此银行最多可以转被授权的 _value 个 tokens，不同的银行（msg.sender）可以给用户（_spender）授信不同的额度(_value)。&lt;/p&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt;把 allowd 的概念理解了，allowance 函数也就很好理解了，第一个参数 _owner 类比成银行，第二个参数 _spender 类比成用户，这个函数就用来查询用户（_spender）在银行（_owner）剩余的额度（tokens）。通过上述的讲解，可以知道 transfer 和 transferfrom 函数区别如下：&lt;/p&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt;1. transfer 是把当前合约调用者的 tokens 转移给其他人&lt;/p&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt;2. transferFrom 则是可以把 ”银行“ 授信额度的钱（tokens）转给自己或者他人，转移的是 “银行” 的 tokens&lt;/p&gt;
&lt;p data-anchor-id=&quot;sm7d&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
contract Ammbr is StandardToken, Ownable {
    string public name = '';
    string public symbol = '';
    uint8 public  decimals = 0;
    uint256 public maxMintBlock = 0;

    event Mint(address indexed to, uint256 amount);

    // 给地址 _to 初始化数量 _amount 数量的 tokens，注意 onlyOwner 修饰，只有合约创建者才有权限分配
    function mint(address _to, uint256 _amount) onlyOwner  public returns (bool){
        assert(maxMintBlock == 0);
        totalSupply = totalSupply.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Mint(_to, _amount);
        maxMintBlock = 1;
        return true;
    }

    // 转帐操作，可以同时转给多个人
    function multiTransfer(address[] destinations, uint[] tokens) public returns (bool success){
        assert(destinations.length &amp;gt; 0);
        assert(destinations.length &amp;lt; 128);
        assert(destinations.length == tokens.length);
        uint8 i = 0;
        uint totalTokensToTransfer = 0;
        for (i = 0; i &amp;lt; destinations.length; i++){
            assert(tokens[i] &amp;gt; 0);
            totalTokensToTransfer += tokens[i]; // 存在溢出
        }
        assert (balances[msg.sender] &amp;gt; totalTokensToTransfer);
        balances[msg.sender] = balances[msg.sender].sub(totalTokensToTransfer);
        for (i = 0; i &amp;lt; destinations.length; i++){
            balances[destinations[i]] = balances[destinations[i]].add(tokens[i]);
            emit Transfer(msg.sender, destinations[i], tokens[i]);
        }
        return true;
    }

    // 构造函数，可选
    function Ammbr(string _name , string _symbol , uint8 _decimals) public{
        name = _name;   // 设定代币的名字，比如： MyToken
        symbol = _symbol; // 返回代币的符号，比如： ARM
        decimals = _decimals;   // 设置 token 的精度
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在来详细说明下 decimals 这个参数。首先我们来理解下常说的以太（ether）到底是怎么换算的。在以太坊交易中，最小的单位是 wei ，1 ether = 10^18 wei 。单位换算在线地址： &lt;a href=&quot;https://converter.murkin.me/&quot; target=&quot;_blank&quot;&gt;https://converter.murkin.me/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ether单位对照表：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1205448/201807/1205448-20180720150147535-1587651772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用合约转发 Token 的时候，传入的值是要转发的 Token 数乘上精度（&lt;strong&gt;默认decimals=18&lt;/strong&gt;），比如转1个Token，传入合约的值是1000000000000000000 wei&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代币（Token）参数对照表：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1205448/201807/1205448-20180720155447416-1957393234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;前面把我认为的难点、疑惑点都说完了，想必大家看懂这个合约也没什么难度。看懂合约后，如果看过以太坊智能合约安全漏洞入门之类的文章，应该一看就能看出 multiTransfer 存在溢出漏洞。原理就是 totalTokensToTransfer 没有使用安全函数，可以导致整数上溢出。详情可参考 &lt;a href=&quot;http://www.freebuf.com/vuls/176917.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt; 。下面我们就手动调试下这个漏洞&lt;/p&gt;
&lt;p&gt;1. 首先运行 mint 函数，给账户 A 初始化 100000 个tokens&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1205448/201807/1205448-20180720163726016-723593423.png&quot; alt=&quot;&quot; width=&quot;1273&quot; height=&quot;621&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.  向账户 B,C 分别充值 57896044618658097711785492504343953926634992332820282019728792003956564819968， 相加得 115792089237316195423570985008687907853269984665640564039457584007913129639936，而账户 unit256 最大值15792089237316195423570985008687907853269984665640564039457584007913129639935，导致溢出 totalTokensToTransfer 的值为0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在 remix 调试时候，传入的数组可以用 [......, ......] 表示，但是地址必须用双引号包裹，传入的数字如果较大也必须用双引号包裹，否则会报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1205448/201807/1205448-20180720165448463-1466743984.png&quot; alt=&quot;&quot; width=&quot;1266&quot; height=&quot;645&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1205448/201807/1205448-20180720164804149-610928647.png&quot; alt=&quot;&quot; width=&quot;1272&quot; height=&quot;752&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1205448/201807/1205448-20180720164841816-777517130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;其实智能合约的代码比平常分析逆向的程序代码都简单多了，只要你掌握 ERC20 的标准几个接口，了解函数修改器的概念以及一些以太坊基本的概念，相信看懂一个 ERC20 标准的合约并不难。也希望大家能把上述分析自己动手实践一下，之前我很多地方也有疑问，通过动手实践很快就明白问题的所在了。如果学习有捷径的话就是多动手，多调试。Solidity 没有打印的函数，有时候会给调试带来不便，下面补个 Solidity 调试的代码，方便大家打印变量值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
pragma solidity ^0.4.21;

//通过log函数重载，对不同类型的变量trigger不同的event，实现solidity打印效果，使用方法为：log(string name, var value)

contract Console {
    event LogUint(string, uint);
    function log(string s , uint x) internal {
    emit LogUint(s, x);
    }
    
    event LogInt(string, int);
    function log(string s , int x) internal {
    emit LogInt(s, x);
    }
    
    event LogBytes(string, bytes);
    function log(string s , bytes x) internal {
    emit LogBytes(s, x);
    }
    
    event LogBytes32(string, bytes32);
    function log(string s , bytes32 x) internal {
    emit LogBytes32(s, x);
    }

    event LogAddress(string, address);
    function log(string s , address x) internal {
    emit LogAddress(s, x);
    }

    event LogBool(string, bool);
    function log(string s , bool x) internal {
    emit LogBool(s, x);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把文件保存成 Console.sol ，其他程序中引用这个文件即可。具体用法如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1205448/201807/1205448-20180720174122322-412914169.png&quot; alt=&quot;&quot; width=&quot;1275&quot; height=&quot;643&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上是全文内容，如果文中说的有误，或者大家有什么更好的想法，欢迎大家和我交流。 &lt;/p&gt;

&lt;p data-anchor-id=&quot;0gnl&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;0gnl&quot;&gt;&lt;a href=&quot;http://yinxiangblog.com/?id=10&quot; target=&quot;_blank&quot;&gt;http://yinxiangblog.com/?id=10&lt;/a&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;ujh2&quot;&gt;&lt;a href=&quot;https://github.com/ethereum/EIPs/issues/20&quot; target=&quot;_blank&quot;&gt;https://github.com/ethereum/EIPs/issues/20&lt;/a&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;cvjb&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/diandianxiyu_geek/article/details/78082551&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/diandianxiyu_geek/article/details/78082551&lt;/a&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;txkf&quot;&gt;&lt;a href=&quot;https://theethereum.wiki/w/index.php/ERC20_Token_Standard&quot; target=&quot;_blank&quot;&gt;https://theethereum.wiki/w/index.php/ERC20_Token_Standard&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Jul 2018 07:57:00 +0000</pubDate>
<dc:creator>he1m4n6a</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/he1m4n6a/p/9327589.html</dc:identifier>
</item>
<item>
<title>Android Studio使用adb命令连接平板 - slma</title>
<link>http://www.cnblogs.com/slma/p/9360545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/slma/p/9360545.html</guid>
<description>&lt;p&gt;有需要使用adb命令连接调试平板的同学可以参考下。&lt;/p&gt;
&lt;p&gt;1.android studio 里安装google usb driver，安装完重启Android studio即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1386549/201807/1386549-20180724154954685-777070777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、进入电脑设备管理器查看是否安装成功：截图显示是已经安装ok的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1386549/201807/1386549-20180724155212722-1971556658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3、找到sdk安装目录，在Android studio命令行环境进入sdk安装目录下platform-tools目录下，执行如下命令即可进入shell命令行环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1386549/201807/1386549-20180724155419605-598551372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;备注：由于平板（小米4）无法root，所以无法使用adb connect IP地址命令直接连接，会报如下错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1386549/201807/1386549-20180724155633330-400442587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 24 Jul 2018 07:57:00 +0000</pubDate>
<dc:creator>slma</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/slma/p/9360545.html</dc:identifier>
</item>
<item>
<title>【安富莱】【RL-TCPnet网络教程】第10章 RL-TCPnet网络协议栈移植（FreeRTOS） - 席萌0209</title>
<link>http://www.cnblogs.com/armfly/p/9360488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/armfly/p/9360488.html</guid>
<description>&lt;p&gt;&lt;span&gt;本章教程为大家讲解RL-TCPnet网络协议栈的FreeRTOS操作系统移植方式，学习了第6章讲解的底层驱动接口函数之后，移植就比较容易了，主要是添加库文件、配置文件和驱动文件即可。另外，RL-TCPnet移植到FreeRTOS要重新配置RL-TCPnet的接口函数，以此来支持RL-TCPnet多任务运行。使用RTX无需重新配置，因为默认情况下就是采用RTX的API函数配置的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本章教程含STM32F407开发板和STM32F429开发板的移植。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.1  移植前准备工作说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.2  STM32F407移植RL-TCPnet协议栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.3  STM32F429移植RL-TCPnet协议栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.4  总结&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;10.1  移植前准备工作说明&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、学习本章节前，务必要优先学习第6章的底层驱动讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、RL-TCPnet只有库，没有源码。库分为两个版本，一个用于调试的版本TCPD_CM3.lib和一个正式版本TCP_CM3.lib，当前的例子统一使用调试版本。另外注意，虽然是CM3版本的，但可同时用于CM3和CM4内核的MCU，因为官方没有专门的CM4内核库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;/span&gt;&lt;span&gt;测试时，请将网线接到路由器或者交换机上面测试，因为已经使能了DHCP，可以自动获取IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     而且使能了NetBIOS局域网域名，用户只需在电脑端ping armfly，就可以获得板子的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、如果要使用固定IP进行测试，请看附件C。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、网口使用的是DM9161/9162（挨着9帧串口座的网口），而不是DM9000。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、找一个简单的工程，最好是跑马灯之类的，越简单越好，我们就在这个简单的工程上面移植即可。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;10.2  STM32F407移植RL-TCPnet协议栈&lt;/h2&gt;
&lt;h3&gt;10.2.1  RL-TCPnet网络协议栈移植&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先准备好一个简单的FreeRTOS工程模板，工程模板的制作就不做讲解了，这里的重点是教大家移植RL-TCPnet协议栈。准备好的工程模板如下图所示（&lt;span&gt;大家也可以制作其它任意的工程模板，不限制&lt;/span&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154533136-575970447.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备好工程模板后，就可以开始移植了。首先要做的就是将所有需要的文件放到工程模板里面。下面分4步跟大家进行说明，当然，不限制必须使用下面的方法添加源码到工程，只要将需要的文件添加到工程模板即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第1步：将我们FreeRTOS模板中制作好的RL-ARM文件夹复制粘贴到大家准备好的工程模板中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154539531-904420109.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-ARM文件夹中有如下七个文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154545007-747653779.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Config文件夹用于存放RTX及其中间件的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Driver文件夹用于存放中间件的驱动文件，也就是底层移植文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-CAN文件夹用于存放CAN总线的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-FlashFS文件夹用于存放文件系统RL-FlashFS的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-RTX文件夹用于存放RTX的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet文件夹用于存放网络协议栈RL-TCPnet的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-USB文件夹用于存放USB协议栈RL-USB的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也许有用户会问：我们不是仅仅需要移植RL-TCPnet的相关文件就行了吗，为什么把RTX及其所有中间件都添加进来了？这样做的目的是为了以后升级的方便，如果需要添加USB、文件系统、CAN等组件，直接添加到工程即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些文件全部来自MDK4.74的安装目录，库文件位于路径：C:\Keil_v474\ARM\RV31下，而驱动和配置文件位于路径：C:\Keil_v474\ARM\RL下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第2步：添加RL-TCPnet的库文件、配置文件和驱动文件到工程，添加完毕后的效果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154550367-616233125.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Net_lib.c，Net_Config.c和NET_Debug.c在RL-ARM文件夹的Config文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCPD_CM3.lib在RL-ARM文件夹的RL-TCPnet文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ETH_STM32F4xx.c和ETH_STM32F4xx.h在RL-ARM文件夹的Driver文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第3步：添加相应的头文件路径，在原来工程模板的基础上新添加的几个路径：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154556714-159535648.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第4步：也是最后一步，添加预定义宏，点击MDK的option -&amp;gt; c/c++选项，添加上__RTX（&lt;span&gt;注意，字母RTX前面有两个下划线的&lt;/span&gt;），添加这个宏定义才可以使能RL-TCPnet的多任务支持。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154606957-184654726.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，RL-TCPnet的移植工作就完成了，剩下就是系统配置和应用了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;10.2.2 RL-TCPnet配置说明（Net_Config.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的配置工作是通过配置文件Net_Config.c实现。在MDK工程中打开文件Net_Config.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154613459-413682956.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet要配置的选项非常多，我们这里把几个主要的配置选项简单介绍下。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154620471-683471263.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;System Definitions&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Local Host Name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网域名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里起名为armfly，使用局域网域名限制为15个字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Memory Pool size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数范围1536-262144字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存池大小配置，单位字节。另外注意一点，配置向导这里显示的单位是字节，如果看原始定义，MDK会做一个自动的4字节倍数转换，比如我们这里配置的是8192字节，那么原始定义是#define MEM_SIZE  2048，也就是8192/4 = 2048。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Tick Timer interval&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可取10，20，25，40，50，100，200，单位ms。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统滴答时钟间隔，也就是网络协议栈的系统时间基准，默认情况下，取值100ms。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154626890-443686285.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，勾选了此选项就可以配置了，如果没有使能DHCP的话，将使用这里配置的固定IP&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）MAC Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网内可以随意配置，只要不跟局域网内其它设备的MAC地址冲突即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）IP Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Subnet mask&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子网掩码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Gateway&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认网关。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154633709-1541972214.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，这个配置里面还有如下两项比较重要的配置需要说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）NetBIOS Name Service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NetBIOS局域网域名服务，这里打上对勾就使能了。这样我们就可以通过前面配置的Local Host Name局域网域名进行访问，而不需要通过IP地址访问了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Dynaminc Host Configuration&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即DHCP，这里打上对勾就使能了。使能了DHCP后，RL-TCPnet就可以从外接的路由器上获得动态IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154639852-1429420980.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of UDP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的UDP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1 – 20。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154645385-1040597356.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of TCP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的TCP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Number of Retries&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围0-20。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置重试次数，TCP数据传输时，如果在设置的重试时间内得不到应答，算一次重试失败，这里就是配置的最大重试次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Retry Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-10，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重试时间。学习了第6章讲解的底层驱动接口函数之后，移植就比较容易了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Connect Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-600，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置默认的保持连接时间，即我们常说的Keep Alive时间，如果时间到了将断开连接。常用于HTTP Server，Telnet Server等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）Maximum Segment Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-1460，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MSS定义了TCP数据包能够传输的最大数据分段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）Receive Window Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-65535，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP接收窗口大小。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;10.2.3 RL-TCPnet调试说明（Net_Debug.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;span&gt;重要说明，RL-TCPnet的调试是通过串口打印出来的&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的调试功能是通过配置文件Net_Debug.c实现。在MDK工程中打开文件Net_Debug.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154651658-728118673.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Print Time Stamp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;勾选了此选项的话，打印消息时，前面会附带时间信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其它所有的选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，所有的调试选项都是关闭的，每个选项有三个调试级别可选择，这里我们以Memory Management Debug为例，点击下拉列表，可以看到里面有Off，Errors only和Full debug三个调试级别可供选择，每个调试选项里面都是这三个级别。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154657675-982456842.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Off：表示关闭此选项的调试功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Errors only：表示仅在此选项出错时，将其错误打印出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Full debug：表示此选项的全功能调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于调试功能的使用会在第11章详细为大家讲解，移植阶段将其全部关闭即可。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;10.2.4 RL-TCPnet的多任务驱动接口函数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;要让RL-TCPnet支持多任务，就需要修改Net_lib.c文件。默认情况下，Net_lib.c文件是支持RTX操作系统的，现在要将其修改为支持FreeRTOS，需要修改的几个地方如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;添加FreeRTOS的头文件。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#if&lt;/span&gt; (__RTX)&lt;span&gt;

  #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

  #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

  #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;queue.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

  #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;semphr.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定义信号量和互斥信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)

 &lt;span&gt;static&lt;/span&gt; BSD_INFO bsd_scb[BSD_NUMSOCKS +&lt;span&gt; BSD_SRVSOCKS];

 #ifdef __RTX

   SemaphoreHandle_t  bsd_mutex &lt;/span&gt;=&lt;span&gt; NULL;

   SemaphoreHandle_t  bsd_sem &lt;/span&gt;=&lt;span&gt; NULL;

  &lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; BSD_INRTX  __TRUE

 &lt;span&gt;#else&lt;/span&gt;

  &lt;span&gt;#define&lt;/span&gt; BSD_INRTX  __FALSE

 &lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

 BSD_CFG bsd_config &lt;/span&gt;=&lt;span&gt; {

   bsd_scb,

   BSD_NUMSOCKS &lt;/span&gt;+&lt;span&gt; BSD_SRVSOCKS,

   BSD_INRTX,

   BSD_RCVTOUT &lt;/span&gt;*&lt;span&gt; TICK_RATE

 };

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建互斥信号量和信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- init_system -----------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; init_system (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize configured interfaces and applications. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  eth_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (PPP_ENABLE)&lt;span&gt;

  ppp_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SLIP_ENABLE)&lt;span&gt;

  slip_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

  ip_init ();

  icmp_init ();

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; IGMP_ENABLE)&lt;span&gt;

  igmp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (UDP_ENABLE)&lt;span&gt;

  udp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TCP_ENABLE)&lt;span&gt;

  tcp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)&lt;span&gt;

  bsd_init ();

 &lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (BSD_GETHOSTEN)&lt;span&gt;

  bsd_init_host ();

 &lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (HTTP_ENABLE)&lt;span&gt;

  http_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TNET_ENABLE)&lt;span&gt;

  tnet_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTP_ENABLE)&lt;span&gt;

  tftp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTPC_ENABLE)&lt;span&gt;

  tftpc_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTP_ENABLE)&lt;span&gt;

  ftp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTPC_ENABLE)&lt;span&gt;

  ftpc_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; NBNS_ENABLE)&lt;span&gt;

  nbns_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; DHCP_ENABLE)&lt;span&gt;

  dhcp_init ();

&lt;/span&gt;&lt;span&gt;#elif&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  arp_notify ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (DNS_ENABLE)&lt;span&gt;

  dns_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SMTP_ENABLE)&lt;span&gt;

  smtp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNMP_ENABLE)&lt;span&gt;

  snmp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNTP_ENABLE)&lt;span&gt;

  sntp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

 {

     bsd_mutex &lt;/span&gt;=&lt;span&gt; xSemaphoreCreateMutex();

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bsd_mutex ==&lt;span&gt; NULL)

    {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ERR &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    }   

    

     bsd_sem &lt;/span&gt;=&lt;span&gt; xSemaphoreCreateBinary();

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bsd_sem ==&lt;span&gt; NULL)

    {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ERR &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    }

 }

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统运行时，使用互斥信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- run_system ------------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; run_system (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Run configured interfaces and applications. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

     xSemaphoreTake(bsd_mutex, portMAX_DELAY);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  eth_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (PPP_ENABLE)&lt;span&gt;

  ppp_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SLIP_ENABLE)&lt;span&gt;

  slip_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

  ip_run_local ();

  icmp_run_engine ();

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; IGMP_ENABLE)&lt;span&gt;

  igmp_run_host ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TCP_ENABLE)&lt;span&gt;

  tcp_poll_sockets ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)&lt;span&gt;

  bsd_poll_sockets ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (HTTP_ENABLE)&lt;span&gt;

  http_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TNET_ENABLE)&lt;span&gt;

  tnet_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTP_ENABLE)&lt;span&gt;

  tftp_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTPC_ENABLE)&lt;span&gt;

  tftpc_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTP_ENABLE)&lt;span&gt;

  ftp_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTPC_ENABLE)&lt;span&gt;

  ftpc_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; DHCP_ENABLE)&lt;span&gt;

  dhcp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (DNS_ENABLE)&lt;span&gt;

  dns_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SMTP_ENABLE)&lt;span&gt;

  smtp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNMP_ENABLE)&lt;span&gt;

  snmp_run_agent ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNTP_ENABLE)&lt;span&gt;

  sntp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

  xSemaphoreGive(bsd_mutex);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使能BSD Socket的话，Socket挂起和恢复的实现。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- bsd_suspend/resume ----------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_suspend (U8 *&lt;span&gt;tsk_id) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Suspend a socket owner task. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  xSemaphoreGive(bsd_mutex);

  xSemaphoreTake(bsd_sem, portMAX_DELAY);

  xSemaphoreTake(bsd_mutex, portMAX_DELAY);   

}

 

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; bsd_resume (U8 tsk_id) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Resume a task waiting for a socket event. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  xSemaphoreGive(bsd_sem);

}

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使能BSD Socket的话，锁机制的实现。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- bsd_lock/unlock -------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_lock (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Acquire mutex - Lock TCPnet functions. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  xSemaphoreTake(bsd_mutex, portMAX_DELAY);   

}

 

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_unlock (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Release mutex - Unlock TCPnet functions. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  xSemaphoreGive(bsd_mutex);

}

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;10.2.5 RL-TCPnet应用实例&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了验证移植的RL-TCPnet是否可以使用，需要添加测试代码。下面是编写的测试代码，配套的测试例子完整版是：V5-1003_RL-TCPnet实验_工程移植模板（FreeRTOS）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154723389-1570112311.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;FreeRTOS&lt;/strong&gt;&lt;strong&gt;操作系统创建的任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过上面的移植和配置之后，在 main.c 文件中添加如下代码，代码中创建了5个用户任务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vTaskTaskUserIF 任务: 按键消息处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vTaskLED        任务: LED闪烁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vTaskMsgPro    任务: 消息处理，这里用作按键检测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vTaskTCPnet    任务: RL-TCPnet测试任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vTaskStart      任务: 启动任务，实现RL-TCPnet的时间基准更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

**********************************************************************************************************

                                                   函数声明

**********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskTaskUserIF(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskLED(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskMsgPro(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskTCPnet(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskStart(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppObjCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; App_Printf(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;format, ...);

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

**********************************************************************************************************

                                                   变量声明

**********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; TaskHandle_t xHandleTaskUserIF =&lt;span&gt; NULL;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; TaskHandle_t xHandleTaskLED =&lt;span&gt; NULL;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; TaskHandle_t xHandleTaskMsgPro =&lt;span&gt; NULL;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; TaskHandle_t xHandleTaskTCPnet =&lt;span&gt; NULL;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; TaskHandle_t xHandleTaskStart =&lt;span&gt; NULL;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; SemaphoreHandle_t  xMutex =&lt;span&gt; NULL;

EventGroupHandle_t xCreatedEventGroup &lt;/span&gt;=&lt;span&gt; NULL;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: main

*    功能说明: 标准c程序入口。

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

       在启动调度前，为了防止初始化STM32外设时有中断服务程序执行，这里禁止全局中断(除了NMI和HardFault)。

       这样做的好处是：

       1. 防止执行的中断服务程序中有FreeRTOS的API函数。

       2. 保证系统正常启动，不受别的中断影响。

       3. 关于是否关闭全局中断，大家根据自己的实际情况设置即可。

       在移植文件port.c中的函数prvStartFirstTask中会重新开启全局中断。通过指令cpsie i开启，__set_PRIMASK(1)

       和cpsie i是等效的。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     __set_PRIMASK(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;); 

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 硬件初始化 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_Init();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 1. 初始化一个定时器中断，精度高于滴答定时器中断，这样才可以获得准确的系统信息 仅供调试目的，实际项

           目中不要使用，因为这个功能比较影响系统实时性。

        2. 为了正确获取FreeRTOS的调试信息，可以考虑将上面的关闭中断指令__set_PRIMASK(1); 注释掉。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     vSetupSysInfoTest();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     AppTaskCreate();

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建任务通信机制 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     AppObjCreate();

    

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 启动调度，开始执行任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    vTaskStartScheduler();

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

       如果系统正常启动是不会运行到这里的，运行到这里极有可能是用于定时器任务或者空闲任务的

       heap空间不足造成创建失败，此要加大FreeRTOSConfig.h文件中定义的heap大小：

       #define configTOTAL_HEAP_SIZE        ( ( size_t ) ( 17 * 1024 ) )

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: vTaskTaskUserIF

*    功能说明: 接口消息处理。

*    形    参: pvParameters 是在创建该任务时传递的形参

*    返 回 值: 无

*   优 先 级: 1  (数值越小优先级越低，这个跟uCOS相反)

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskTaskUserIF(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters)

{

     uint8_t ucKeyCode;

     uint8_t pcWriteBuffer[&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;];

 

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         ucKeyCode &lt;/span&gt;=&lt;span&gt; bsp_GetKey();

        

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ucKeyCode !=&lt;span&gt; KEY_NONE)

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ucKeyCode)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K1键按下，直接发送事件标志给任务vTaskTCPnet，设置bit0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K1:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K1键按下，直接发送事件标志给任务AppTaskTCPMain，bit0被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       xEventGroupSetBits(xCreatedEventGroup, KEY1_BIT0);          

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K2键按下，直接发送事件标志给任务vTaskTCPnet，设置bit1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K2:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K2键按下，直接发送事件标志给任务AppTaskTCPMain，bit1被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       xEventGroupSetBits(xCreatedEventGroup, KEY2_BIT1);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K3键按下，直接发送事件标志给任务vTaskTCPnet，设置bit2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K3:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K3键按下，直接发送事件标志给任务AppTaskTCPMain，bit2被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       xEventGroupSetBits(xCreatedEventGroup, KEY3_BIT2);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 摇杆的OK键按下，打印任务执行情况 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; JOY_DOWN_OK:          

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=================================================\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务名      任务状态 优先级   剩余栈 任务序号\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       vTaskList((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *)&amp;amp;&lt;span&gt;pcWriteBuffer);

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pcWriteBuffer);

                  

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n任务名       运行计数         使用率\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       vTaskGetRunTimeStats((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *)&amp;amp;&lt;span&gt;pcWriteBuffer);

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pcWriteBuffer);

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前动态内存剩余大小 = %d字节\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, xPortGetFreeHeapSize());

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

        

         vTaskDelay(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);

     }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: vTaskLED

*    功能说明: LED闪烁

*    形    参: pvParameters 是在创建该任务时传递的形参

*    返 回 值: 无

*   优 先 级: 2 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskLED(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters)

{

     TickType_t xLastWakeTime;

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; TickType_t xFrequency = &lt;span&gt;500&lt;/span&gt;&lt;span&gt;;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 获取当前的系统时间 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    xLastWakeTime &lt;/span&gt;=&lt;span&gt; xTaskGetTickCount();

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         bsp_LedToggle(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; vTaskDelayUntil是绝对延迟，vTaskDelay是相对延迟。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

        vTaskDelayUntil(&lt;/span&gt;&amp;amp;&lt;span&gt;xLastWakeTime, xFrequency);

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: vTaskMsgPro

*    功能说明: 消息处理，这里用作按键检测

*    形    参: pvParameters 是在创建该任务时传递的形参

*    返 回 值: 无

*   优 先 级: 3 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskMsgPro(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters)

{

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 按键扫描 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         bsp_KeyScan();

         vTaskDelay(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: vTaskTCPnet

*    功能说明: RL-TCPnet测试任务

*    形    参: pvParameters 是在创建该任务时传递的形参

*    返 回 值: 无

*   优 先 级: 4 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskTCPnet(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters)

{

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         TCPnetTest();

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: vTaskStart

*    功能说明: 启动任务，也是最高优先级任务，这里实现RL-TCPnet的时间基准更新

*    形    参: pvParameters 是在创建该任务时传递的形参

*    返 回 值: 无

*   优 先 级: 5 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskStart(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters)

{

     TickType_t xLastWakeTime;

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; TickType_t xFrequency = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化RL-TCPnet &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     init_TcpNet ();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 获取当前的系统时间 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    xLastWakeTime &lt;/span&gt;=&lt;span&gt; xTaskGetTickCount();

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {   

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet时间基准更新函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         timer_tick ();

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; vTaskDelayUntil是绝对延迟，vTaskDelay是相对延迟。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

        vTaskDelayUntil(&lt;/span&gt;&amp;amp;&lt;span&gt;xLastWakeTime, xFrequency);

    }

}

                  

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskCreate

*    功能说明: 创建应用任务

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

    xTaskCreate( vTaskTaskUserIF,   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vTaskUserIF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;512&lt;/span&gt;,               &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位word，也就是4字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 NULL,              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务参数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;1&lt;/span&gt;,                  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &amp;amp;xHandleTaskUserIF );  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

    

     xTaskCreate( vTaskLED,           &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vTaskLED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;512&lt;/span&gt;,                &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; stack大小，单位word，也就是4字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 NULL,               &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务参数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;2&lt;/span&gt;,                   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &amp;amp;xHandleTaskLED ); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

     xTaskCreate( vTaskMsgPro,            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vTaskMsgPro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,           &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;512&lt;/span&gt;,                     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位word，也就是4字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 NULL,                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务参数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;3&lt;/span&gt;,                       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &amp;amp;xHandleTaskMsgPro );  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

 

    xTaskCreate( vTaskTCPnet,             &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vTaskTCPnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,           &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;512&lt;/span&gt;,                     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位word，也就是4字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 NULL,                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务参数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;4&lt;/span&gt;,                       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &amp;amp;xHandleTaskTCPnet );  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

    

     xTaskCreate( vTaskStart,             &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vTaskStart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;512&lt;/span&gt;,                     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位word，也就是4字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 NULL,                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务参数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;5&lt;/span&gt;,                       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &amp;amp;xHandleTaskStart );   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppObjCreate

*    功能说明: 创建任务通信机制

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppObjCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建互斥信号量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    xMutex &lt;/span&gt;=&lt;span&gt; xSemaphoreCreateMutex();

    

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xMutex ==&lt;span&gt; NULL)

    {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 没有创建成功，用户可以在这里加入创建失败的处理机制 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    }

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建事件标志组 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     xCreatedEventGroup &lt;/span&gt;=&lt;span&gt; xEventGroupCreate();

    

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xCreatedEventGroup ==&lt;span&gt; NULL)

    {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 没有创建成功，用户可以在这里加入创建失败的处理机制 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: App_Printf

*    功能说明: 线程安全的printf方式                      

*    形    参: 同printf的参数。

*             在C中，当无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;  App_Printf(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;format, ...)

{

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;  buf_str[&lt;span&gt;512&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

    va_list   v_args;

 

 

    va_start(v_args, format);

   (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;)vsnprintf((&lt;span&gt;char&lt;/span&gt;       *)&amp;amp;buf_str[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                   (size_t      ) &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf_str),

                   (&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; *&lt;span&gt;) format,

                                  v_args);

    va_end(v_args);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 互斥信号量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     xSemaphoreTake(xMutex, portMAX_DELAY);

 

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf_str);

 

     xSemaphoreGive(xMutex);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;硬件外设初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;硬件外设的初始化是在 bsp.c 文件实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: bsp_Init

*    功能说明: 初始化所有的硬件设备。该函数配置CPU寄存器和外设的寄存器并初始化一些全局变量。只需要调用一次

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; bsp_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

         由于ST固件库的启动文件已经执行了CPU系统时钟的初始化，所以不必再次重复配置系统时钟。

         启动文件配置了CPU主时钟频率、内部Flash访问速度和可选的外部SRAM FSMC初始化。

 

         系统时钟缺省配置为168MHz，如果需要更改，可以修改 system_stm32f4xx.c 文件

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 优先级分组设置为4，可配置0-15级抢占式优先级，0级子优先级，即不存在子优先级。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);

 

     bsp_InitUart();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化串口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitKey();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化按键变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitLed();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始LED指示灯端口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RL-TCPnet&lt;/strong&gt;&lt;strong&gt;功能测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里专门创建了一个app_tcpnet_lib.c文件用于RL-TCPnet功能的测试，主要功能是创建了一个TCP Server。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_debug printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_debug(...)

&lt;span&gt;#endif&lt;/span&gt;

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; PORT_NUM       1001    /* TCP服务器监听端口号 */

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                         变量

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t socket_tcp;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: tcp_callback

*    功能说明: TCP Socket的回调函数

*    形    参: soc  TCP Socket类型

*             evt  事件类型

*             ptr  事件类型是TCP_EVT_DATA，ptr指向的缓冲区记录着接收到的TCP数据，其余事件记录IP地址

*             par  事件类型是TCP_EVT_DATA，记录接收到的数据个数，其余事件记录端口号

*    返 回 值:

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

U16 tcp_callback (U8 soc, U8 evt, U8 &lt;/span&gt;*&lt;span&gt;ptr, U16 par)

{

     &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;50&lt;/span&gt;&lt;span&gt;];

     uint16_t i;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确保是socket_tcp的回调 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;if&lt;/span&gt; (soc !=&lt;span&gt; socket_tcp)

     {

         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

     }

 

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (evt)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

              远程客户端连接消息

             1、数组ptr存储远程设备的IP地址，par中存储端口号。

             2、返回数值1允许连接，返回数值0禁止连接。

         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONREQ:

              sprintf(buf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;远程客户端请求连接IP: %d.%d.%d.%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ptr[&lt;span&gt;0&lt;/span&gt;], ptr[&lt;span&gt;1&lt;/span&gt;], ptr[&lt;span&gt;2&lt;/span&gt;], ptr[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP:%s  port:%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf, par);

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接终止 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ABORT:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Socket远程连接已经建立 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONNECT:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Socket is connected to remote peer\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接断开 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CLOSE:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection has been closed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发送的数据收到远程设备应答 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ACK:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到TCP数据帧，ptr指向数据地址，par记录数据长度，单位字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_DATA:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data length = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, par);

              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; par; i++&lt;span&gt;)

              {

                   printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ptr[%d] = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i, ptr[i]);

              }

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCP_StatusCheck

*    功能说明: 检测TCP的连接状态，主要用于网线插拔的判断

*    形    参: 无

*    返 回 值: __TRUE  连接

*             __FALSE 断开

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t TCP_StatusCheck(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     uint8_t res;

    

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (tcp_get_state(socket_tcp))

     {

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_FREE:

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CLOSED:

              res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_LISTEN:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CONNECT:

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__TRUE);

             

         &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: 

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__FALSE);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCPnetTest

*    功能说明: TCPnet应用

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; TCPnetTest(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{ 

     int32_t iCount;

     uint8_t &lt;/span&gt;*&lt;span&gt;sendbuf;

     uint8_t tcp_status;

     uint16_t maxlen;

     uint8_t res;

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; TickType_t xTicksToWait = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟2ms &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     EventBits_t uxBits;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        创建TCP Socket并创建监听，客户端连接服务器后，10秒内无数据通信将断开连接。

        但是由于这里使能了TCP_TYPE_KEEP_ALIVE，会一直保持连接，不受10秒的时间限制。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    socket_tcp &lt;/span&gt;= tcp_get_socket (TCP_TYPE_SERVER|TCP_TYPE_KEEP_ALIVE, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;, tcp_callback);

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(socket_tcp != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

     {

         res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

         printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

     }

    

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet处理函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         main_TcpNet();

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用于网线插拔的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         tcp_status &lt;/span&gt;=&lt;span&gt; TCP_StatusCheck();

 

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待所有任务发来事件标志 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         uxBits &lt;/span&gt;= xEventGroupWaitBits(xCreatedEventGroup, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 事件标志组句柄 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                      &lt;span&gt;0xFFFF&lt;/span&gt;,        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待0xFFFF某一位被设置 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                      pdTRUE,&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 退出前0xFFFF位被清除，这里是任意0xFFFF位被设置就“退出”&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                      pdFALSE,       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置为pdTRUE表示等待0xFFFF任意位被设置&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                       xTicksToWait);&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待延迟时间 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

         &lt;span&gt;if&lt;/span&gt;((uxBits != &lt;span&gt;0&lt;/span&gt;)&amp;amp;&amp;amp;(tcp_status ==&lt;span&gt; __TRUE))

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (uxBits)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K1键按下，给远程TCP客户端发送8字节数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY1_BIT0:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                }

                                

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K2键按下，给远程TCP客户端发送1024字节的数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY2_BIT1:       

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);                      

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                      

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K3键按下，给远程TCP客户端发送5MB数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY3_BIT2:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，FreeRTOS方式移植的RL-TCPnet就可以运行了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;10.2.6 RL-TCPnet实验测试和实验现象&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;测试前，先将开发板上面的DM9161/9162网口通过网线接到路由器或者交换机上面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RJ45&lt;/strong&gt;&lt;strong&gt;网络变压器插座上绿灯和黄灯现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各种网卡、交换机等网络设备都不一样，一般来讲：绿灯分为亮或不亮（代表网络速度），黄灯分为闪烁或不闪烁（代表是否有数据收发）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绿灯：长亮代表100M； 不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;黄灯：长亮代表无数据收发； 闪烁代表有数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也有些千兆网卡的灯以颜色区分，不亮代表10M / 绿色代表100M / 黄色代表1000M。现在10M的网络基本看不到了，如果一个灯长亮，基本可以说明100M网络或更高，而另一个灯时而闪烁，那代表有数据收发，具体要看你的网络设备了。甚至有些低等网卡如TP-LINK，只有一个灯，亮代表连通，闪烁代表数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于STM32F407开发板上面的RJ45网络变压器插座上面的灯而言，绿灯代表数据收发，长亮的话表示无数据收发，闪烁代表有数据收发。黄灯代表网络速度，长亮代表100M，不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;底层驱动执行情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了验证RL-TCPnet底层驱动接口函数是否有问题，专门在ETH_STM32F4xx.c文件中配置了串口调试打印函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_eth printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_eth(...)

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果底层驱动正常执行了，打印的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154741976-884364966.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ping&lt;/strong&gt;&lt;strong&gt;是否正确&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ping命令的主要作用是通过发送数据包并接收应答信息来检测两台设备之间的网络是否连通。ping命令成功说明当前主机与目的主机之间存在连通的路径。如果不成功，需要查看网线是否连通、网卡设置是否正确、IP地址是否可用等。测试方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）WIN+R组合键打开“运行”窗口，输入cmd。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154747043-877543361.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）弹出的命令窗口中，输入ping armfly，因为在前面的配置中我们使能了NetBIOS局域网域名，并将名字设置为armfly，而且使能了DHCP，通过ping命令还可以获得板子自动获取的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154752553-1315641513.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）输入ping armfly后，回车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154757590-275709383.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;收发相同，没有数据丢失，说明ping命令也是成功的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;电脑端创建一个TCP Client与板子上面的TCP Server通信&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体测试方法，查看第13章的13.6小节即可，因为配套例子实现的功能是一样的。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;10.3 STM32F429移植RL-TCPnet协议栈&lt;/h2&gt;
&lt;h3&gt;10.3.1 RL-TCPnet网络协议栈移植&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先准备好一个简单的FreeRTOS工程模板，工程模板的制作就不做讲解了，这里的重点是教大家移植RL-TCPnet协议栈。准备好的工程模板如下图所示（&lt;span&gt;大家也可以制作其它任意的工程模板，不限制&lt;/span&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154821048-1736188869.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备好工程模板后，就可以开始移植了。首先要做的就是将所有需要的文件放到工程模板里面。下面分4步跟大家进行说明，当然，不限制必须使用下面的方法添加源码到工程，只要将需要的文件添加到工程模板即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第1步：将我们FreeRTOS模板中制作好的RL-ARM文件夹复制粘贴到大家准备好的工程模板中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154826893-1469941654.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-ARM文件夹中有如下七个文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154831615-1619878252.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Config文件夹用于存放RTX及其中间件的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Driver文件夹用于存放中间件的驱动文件，也就是底层移植文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-CAN文件夹用于存放CAN总线的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-FlashFS文件夹用于存放文件系统RL-FlashFS的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-RTX文件夹用于存放RTX的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet文件夹用于存放网络协议栈RL-TCPnet的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-USB文件夹用于存放USB协议栈RL-USB的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也许有用户会问：我们不是仅仅需要移植RL-TCPnet的相关文件就行了吗，为什么把RTX及其所有中间件都添加进来了？这样做的目的是为了以后升级的方便，如果需要添加USB、文件系统、CAN等组件，直接添加到工程即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些文件全部来自MDK4.74的安装目录，库文件位于路径：C:\Keil_v474\ARM\RV31下，而驱动和配置文件位于路径：C:\Keil_v474\ARM\RL下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第2步：添加RL-TCPnet的库文件、配置文件和驱动文件到工程，添加完毕后的效果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154837485-1527837202.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Net_lib.c，Net_Config.c和NET_Debug.c在RL-ARM文件夹的Config文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCPD_CM3.lib在RL-ARM文件夹的RL-TCPnet文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ETH_STM32F4xx.c和ETH_STM32F4xx.h在RL-ARM文件夹的Driver文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第3步：添加相应的头文件路径，在原来工程模板的基础上新添加的几个路径：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154843427-1376561842.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第4步：也是最后一步，添加预定义宏，点击MDK的option -&amp;gt; c/c++选项，添加上__RTX（&lt;span&gt;注意，字母RTX前面有两个下划线的&lt;/span&gt;），添加这个宏定义才可以使能RL-TCPnet的多任务支持。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154848792-1621902855.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，RL-TCPnet的移植工作就完成了，剩下就是系统配置和应用了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;10.3.2 RL-TCPnet配置说明（Net_Config.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的配置工作是通过配置文件Net_Config.c实现。在MDK工程中打开文件Net_Config.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154858120-2054661042.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet要配置的选项非常多，我们这里把几个主要的配置选项简单介绍下。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154904484-948253897.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;System Definitions&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Local Host Name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网域名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里起名为armfly，使用局域网域名限制为15个字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Memory Pool size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数范围1536-262144字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存池大小配置，单位字节。另外注意一点，配置向导这里显示的单位是字节，如果看原始定义，MDK会做一个自动的4字节倍数转换，比如我们这里配置的是8192字节，那么原始定义是#define MEM_SIZE  2048，也就是8192/4 = 2048。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Tick Timer interval&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可取10，20，25，40，50，100，200，单位ms。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统滴答时钟间隔，也就是网络协议栈的系统时间基准，默认情况下，取值100ms。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154910720-1198073874.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，勾选了此选项就可以配置了，如果没有使能DHCP的话，将使用这里配置的固定IP&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）MAC Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网内可以随意配置，只要不跟局域网内其它设备的MAC地址冲突即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）IP Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Subnet mask&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子网掩码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Gateway&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认网关。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154917428-1983706998.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，这个配置里面还有如下两项比较重要的配置需要说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）NetBIOS Name Service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NetBIOS局域网域名服务，这里打上对勾就使能了。这样我们就可以通过前面配置的Local Host Name局域网域名进行访问，而不需要通过IP地址访问了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Dynaminc Host Configuration&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即DHCP，这里打上对勾就使能了。使能了DHCP后，RL-TCPnet就可以从外接的路由器上获得动态IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154923663-353509283.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of UDP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的UDP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1 – 20。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154929470-893608527.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of TCP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的TCP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Number of Retries&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围0-20。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置重试次数，TCP数据传输时，如果在设置的重试时间内得不到应答，算一次重试失败，这里就是配置的最大重试次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Retry Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-10，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重试时间。如果发送的数据在重试时间内得不到应答，将重新发送数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Connect Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-600，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置默认的保持连接时间，即我们常说的Keep Alive时间，如果时间到了将断开连接。常用于HTTP Server，Telnet Server等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）Maximum Segment Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-1460，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MSS定义了TCP数据包能够传输的最大数据分段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）Receive Window Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-65535，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP接收窗口大小。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;10.3.3 RL-TCPnet调试说明（Net_Debug.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;span&gt;重要说明，RL-TCPnet的调试是通过串口打印出来的&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的调试功能是通过配置文件Net_Debug.c实现。在MDK工程中打开文件Net_Debug.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154938908-1050079115.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Print Time Stamp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;勾选了此选项的话，打印消息时，前面会附带时间信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其它所有的选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，所有的调试选项都是关闭的，每个选项有三个调试级别可选择，这里我们以Memory Management Debug为例，点击下拉列表，可以看到里面有Off，Errors only和Full debug三个调试级别可供选择，每个调试选项里面都是这三个级别。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154944916-1498040247.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Off：表示关闭此选项的调试功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Errors only：表示仅在此选项出错时，将其错误打印出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Full debug：表示此选项的全功能调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于调试功能的使用会在第11章详细为大家讲解，移植阶段将其全部关闭即可。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;10.3.4 RL-TCPnet的多任务驱动接口函数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;要让RL-TCPnet支持多任务，就需要修改Net_lib.c文件。默认情况下，Net_lib.c文件是支持RTX操作系统的，现在要将其修改为支持FreeRTOS，需要修改的几个地方如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;添加FreeRTOS的头文件。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#if&lt;/span&gt; (__RTX)&lt;span&gt;

  #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

  #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

  #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;queue.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

  #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;semphr.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定义信号量和互斥信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)

 &lt;span&gt;static&lt;/span&gt; BSD_INFO bsd_scb[BSD_NUMSOCKS +&lt;span&gt; BSD_SRVSOCKS];

 #ifdef __RTX

   SemaphoreHandle_t  bsd_mutex &lt;/span&gt;=&lt;span&gt; NULL;

   SemaphoreHandle_t  bsd_sem &lt;/span&gt;=&lt;span&gt; NULL;

  &lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; BSD_INRTX  __TRUE

 &lt;span&gt;#else&lt;/span&gt;

  &lt;span&gt;#define&lt;/span&gt; BSD_INRTX  __FALSE

 &lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

 BSD_CFG bsd_config &lt;/span&gt;=&lt;span&gt; {

   bsd_scb,

   BSD_NUMSOCKS &lt;/span&gt;+&lt;span&gt; BSD_SRVSOCKS,

   BSD_INRTX,

   BSD_RCVTOUT &lt;/span&gt;*&lt;span&gt; TICK_RATE

 };

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建互斥信号量和信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- init_system -----------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; init_system (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize configured interfaces and applications. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  eth_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (PPP_ENABLE)&lt;span&gt;

  ppp_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SLIP_ENABLE)&lt;span&gt;

  slip_init_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

  ip_init ();

  icmp_init ();

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; IGMP_ENABLE)&lt;span&gt;

  igmp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (UDP_ENABLE)&lt;span&gt;

  udp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TCP_ENABLE)&lt;span&gt;

  tcp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)&lt;span&gt;

  bsd_init ();

 &lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (BSD_GETHOSTEN)&lt;span&gt;

  bsd_init_host ();

 &lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (HTTP_ENABLE)&lt;span&gt;

  http_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TNET_ENABLE)&lt;span&gt;

  tnet_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTP_ENABLE)&lt;span&gt;

  tftp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTPC_ENABLE)&lt;span&gt;

  tftpc_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTP_ENABLE)&lt;span&gt;

  ftp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTPC_ENABLE)&lt;span&gt;

  ftpc_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; NBNS_ENABLE)&lt;span&gt;

  nbns_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; DHCP_ENABLE)&lt;span&gt;

  dhcp_init ();

&lt;/span&gt;&lt;span&gt;#elif&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  arp_notify ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (DNS_ENABLE)&lt;span&gt;

  dns_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SMTP_ENABLE)&lt;span&gt;

  smtp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNMP_ENABLE)&lt;span&gt;

  snmp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNTP_ENABLE)&lt;span&gt;

  sntp_init ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

 {

     bsd_mutex &lt;/span&gt;=&lt;span&gt; xSemaphoreCreateMutex();

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bsd_mutex ==&lt;span&gt; NULL)

    {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ERR &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    }   

    

     bsd_sem &lt;/span&gt;=&lt;span&gt; xSemaphoreCreateBinary();

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bsd_sem ==&lt;span&gt; NULL)

    {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ERR &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    }

 }

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统运行时，使用互斥信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- run_system ------------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; run_system (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Run configured interfaces and applications. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

     xSemaphoreTake(bsd_mutex, portMAX_DELAY);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE)&lt;span&gt;

  eth_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (PPP_ENABLE)&lt;span&gt;

  ppp_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SLIP_ENABLE)&lt;span&gt;

  slip_run_link ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

  ip_run_local ();

  icmp_run_engine ();

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; IGMP_ENABLE)&lt;span&gt;

  igmp_run_host ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TCP_ENABLE)&lt;span&gt;

  tcp_poll_sockets ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE)&lt;span&gt;

  bsd_poll_sockets ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (HTTP_ENABLE)&lt;span&gt;

  http_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TNET_ENABLE)&lt;span&gt;

  tnet_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTP_ENABLE)&lt;span&gt;

  tftp_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (TFTPC_ENABLE)&lt;span&gt;

  tftpc_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTP_ENABLE)&lt;span&gt;

  ftp_run_server ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (FTPC_ENABLE)&lt;span&gt;

  ftpc_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (ETH_ENABLE &amp;amp;&amp;amp; DHCP_ENABLE)&lt;span&gt;

  dhcp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (DNS_ENABLE)&lt;span&gt;

  dns_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SMTP_ENABLE)&lt;span&gt;

  smtp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNMP_ENABLE)&lt;span&gt;

  snmp_run_agent ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (SNTP_ENABLE)&lt;span&gt;

  sntp_run_client ();

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

  xSemaphoreGive(bsd_mutex);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使能BSD Socket的话，Socket挂起和恢复的实现。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- bsd_suspend/resume ----------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_suspend (U8 *&lt;span&gt;tsk_id) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Suspend a socket owner task. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  xSemaphoreGive(bsd_mutex);

  xSemaphoreTake(bsd_sem, portMAX_DELAY);

  xSemaphoreTake(bsd_mutex, portMAX_DELAY);   

}

 

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; bsd_resume (U8 tsk_id) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Resume a task waiting for a socket event. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  xSemaphoreGive(bsd_sem);

}

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使能BSD Socket的话，锁机制的实现。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------------- bsd_lock/unlock -------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (BSD_ENABLE &amp;amp;&amp;amp; __RTX)&lt;span&gt;

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_lock (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Acquire mutex - Lock TCPnet functions. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  xSemaphoreTake(bsd_mutex, portMAX_DELAY);   

}

 

__used &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bsd_unlock (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Release mutex - Unlock TCPnet functions. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  xSemaphoreGive(bsd_mutex);

}

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;10.3.5 RL-TCPnet应用实例&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了验证移植的RL-TCPnet是否可以使用，需要添加测试代码。下面是编写的测试代码，配套的测试例子完整版是：V6-1003_RL-TCPnet实验_工程移植模板（FreeRTOS）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724154956141-453244595.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;FreeRTOS&lt;/strong&gt;&lt;strong&gt;操作系统创建的任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过上面的移植和配置之后，在 main.c 文件中添加如下代码，代码中创建了5个用户任务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vTaskTaskUserIF 任务: 按键消息处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vTaskLED        任务: LED闪烁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vTaskMsgPro    任务: 消息处理，这里用作按键检测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vTaskTCPnet    任务: RL-TCPnet测试任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vTaskStart      任务: 启动任务，实现RL-TCPnet的时间基准更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

**********************************************************************************************************

                                                   函数声明

**********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskTaskUserIF(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskLED(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskMsgPro(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskTCPnet(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskStart(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppObjCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; App_Printf(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;format, ...);

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

**********************************************************************************************************

                                                   变量声明

**********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; TaskHandle_t xHandleTaskUserIF =&lt;span&gt; NULL;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; TaskHandle_t xHandleTaskLED =&lt;span&gt; NULL;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; TaskHandle_t xHandleTaskMsgPro =&lt;span&gt; NULL;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; TaskHandle_t xHandleTaskTCPnet =&lt;span&gt; NULL;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; TaskHandle_t xHandleTaskStart =&lt;span&gt; NULL;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; SemaphoreHandle_t  xMutex =&lt;span&gt; NULL;

EventGroupHandle_t xCreatedEventGroup &lt;/span&gt;=&lt;span&gt; NULL;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: main

*    功能说明: 标准c程序入口。

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

       在启动调度前，为了防止初始化STM32外设时有中断服务程序执行，这里禁止全局中断(除了NMI和HardFault)。

       这样做的好处是：

       1. 防止执行的中断服务程序中有FreeRTOS的API函数。

       2. 保证系统正常启动，不受别的中断影响。

       3. 关于是否关闭全局中断，大家根据自己的实际情况设置即可。

       在移植文件port.c中的函数prvStartFirstTask中会重新开启全局中断。通过指令cpsie i开启，__set_PRIMASK(1)

       和cpsie i是等效的。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     __set_PRIMASK(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;); 

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 硬件初始化 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_Init();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 1. 初始化一个定时器中断，精度高于滴答定时器中断，这样才可以获得准确的系统信息 仅供调试目的，实际项

           目中不要使用，因为这个功能比较影响系统实时性。

        2. 为了正确获取FreeRTOS的调试信息，可以考虑将上面的关闭中断指令__set_PRIMASK(1); 注释掉。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     vSetupSysInfoTest();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     AppTaskCreate();

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建任务通信机制 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     AppObjCreate();

    

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 启动调度，开始执行任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    vTaskStartScheduler();

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

       如果系统正常启动是不会运行到这里的，运行到这里极有可能是用于定时器任务或者空闲任务的

       heap空间不足造成创建失败，此要加大FreeRTOSConfig.h文件中定义的heap大小：

       #define configTOTAL_HEAP_SIZE        ( ( size_t ) ( 17 * 1024 ) )

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: vTaskTaskUserIF

*    功能说明: 接口消息处理。

*    形    参: pvParameters 是在创建该任务时传递的形参

*    返 回 值: 无

*   优 先 级: 1  (数值越小优先级越低，这个跟uCOS相反)

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskTaskUserIF(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters)

{

     uint8_t ucKeyCode;

     uint8_t pcWriteBuffer[&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;];

 

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         ucKeyCode &lt;/span&gt;=&lt;span&gt; bsp_GetKey();

        

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ucKeyCode !=&lt;span&gt; KEY_NONE)

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ucKeyCode)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K1键按下，直接发送事件标志给任务vTaskTCPnet，设置bit0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K1:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K1键按下，直接发送事件标志给任务AppTaskTCPMain，bit0被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       xEventGroupSetBits(xCreatedEventGroup, KEY1_BIT0);          

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K2键按下，直接发送事件标志给任务vTaskTCPnet，设置bit1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K2:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K2键按下，直接发送事件标志给任务AppTaskTCPMain，bit1被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       xEventGroupSetBits(xCreatedEventGroup, KEY2_BIT1);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K3键按下，直接发送事件标志给任务vTaskTCPnet，设置bit2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K3:

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K3键按下，直接发送事件标志给任务AppTaskTCPMain，bit2被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       xEventGroupSetBits(xCreatedEventGroup, KEY3_BIT2);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 摇杆的OK键按下，打印任务执行情况 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; JOY_DOWN_OK:          

                        App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=================================================\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务名      任务状态 优先级   剩余栈 任务序号\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       vTaskList((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *)&amp;amp;&lt;span&gt;pcWriteBuffer);

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pcWriteBuffer);

                  

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n任务名       运行计数         使用率\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       vTaskGetRunTimeStats((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *)&amp;amp;&lt;span&gt;pcWriteBuffer);

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pcWriteBuffer);

                       App_Printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前动态内存剩余大小 = %d字节\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, xPortGetFreeHeapSize());

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

        

         vTaskDelay(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);

     }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: vTaskLED

*    功能说明: LED闪烁

*    形    参: pvParameters 是在创建该任务时传递的形参

*    返 回 值: 无

*   优 先 级: 2 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskLED(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters)

{

     TickType_t xLastWakeTime;

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; TickType_t xFrequency = &lt;span&gt;500&lt;/span&gt;&lt;span&gt;;

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 获取当前的系统时间 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    xLastWakeTime &lt;/span&gt;=&lt;span&gt; xTaskGetTickCount();

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         bsp_LedToggle(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; vTaskDelayUntil是绝对延迟，vTaskDelay是相对延迟。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

        vTaskDelayUntil(&lt;/span&gt;&amp;amp;&lt;span&gt;xLastWakeTime, xFrequency);

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: vTaskMsgPro

*    功能说明: 消息处理，这里用作按键检测

*    形    参: pvParameters 是在创建该任务时传递的形参

*    返 回 值: 无

*   优 先 级: 3 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskMsgPro(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters)

{

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 按键扫描 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         bsp_KeyScan();

         vTaskDelay(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: vTaskTCPnet

*    功能说明: RL-TCPnet测试任务

*    形    参: pvParameters 是在创建该任务时传递的形参

*    返 回 值: 无

*   优 先 级: 4 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskTCPnet(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters)

{

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         TCPnetTest();

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: vTaskStart

*    功能说明: 启动任务，也是最高优先级任务，这里实现RL-TCPnet的时间基准更新

*    形    参: pvParameters 是在创建该任务时传递的形参

*    返 回 值: 无

*   优 先 级: 5 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTaskStart(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;pvParameters)

{

     TickType_t xLastWakeTime;

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; TickType_t xFrequency = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化RL-TCPnet &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     init_TcpNet ();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 获取当前的系统时间 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    xLastWakeTime &lt;/span&gt;=&lt;span&gt; xTaskGetTickCount();

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {   

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet时间基准更新函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         timer_tick ();

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; vTaskDelayUntil是绝对延迟，vTaskDelay是相对延迟。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

        vTaskDelayUntil(&lt;/span&gt;&amp;amp;&lt;span&gt;xLastWakeTime, xFrequency);

    }

}

                  

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskCreate

*    功能说明: 创建应用任务

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

    xTaskCreate( vTaskTaskUserIF,   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vTaskUserIF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;512&lt;/span&gt;,               &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位word，也就是4字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 NULL,              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务参数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;1&lt;/span&gt;,                  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &amp;amp;xHandleTaskUserIF );  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

    

     xTaskCreate( vTaskLED,           &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vTaskLED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;512&lt;/span&gt;,                &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; stack大小，单位word，也就是4字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 NULL,               &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务参数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;2&lt;/span&gt;,                   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &amp;amp;xHandleTaskLED ); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

     xTaskCreate( vTaskMsgPro,            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vTaskMsgPro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,           &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;512&lt;/span&gt;,                     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位word，也就是4字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 NULL,                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务参数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;3&lt;/span&gt;,                       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &amp;amp;xHandleTaskMsgPro );  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

 

    xTaskCreate( vTaskTCPnet,             &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vTaskTCPnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,           &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;512&lt;/span&gt;,                     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位word，也就是4字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 NULL,                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务参数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;4&lt;/span&gt;,                       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &amp;amp;xHandleTaskTCPnet );  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

    

     xTaskCreate( vTaskStart,             &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vTaskStart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务名    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;512&lt;/span&gt;,                     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位word，也就是4字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                 NULL,                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务参数  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &lt;span&gt;5&lt;/span&gt;,                       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                 &amp;amp;xHandleTaskStart );   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppObjCreate

*    功能说明: 创建任务通信机制

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppObjCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建互斥信号量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    xMutex &lt;/span&gt;=&lt;span&gt; xSemaphoreCreateMutex();

    

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xMutex ==&lt;span&gt; NULL)

    {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 没有创建成功，用户可以在这里加入创建失败的处理机制 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    }

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建事件标志组 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     xCreatedEventGroup &lt;/span&gt;=&lt;span&gt; xEventGroupCreate();

    

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xCreatedEventGroup ==&lt;span&gt; NULL)

    {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 没有创建成功，用户可以在这里加入创建失败的处理机制 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: App_Printf

*    功能说明: 线程安全的printf方式                      

*    形    参: 同printf的参数。

*             在C中，当无法列出传递函数的所有实参的类型和数目时,可以用省略号指定参数表

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;  App_Printf(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;format, ...)

{

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;  buf_str[&lt;span&gt;512&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

    va_list   v_args;

 

 

    va_start(v_args, format);

   (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;)vsnprintf((&lt;span&gt;char&lt;/span&gt;       *)&amp;amp;buf_str[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],

                   (size_t      ) &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf_str),

                   (&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; *&lt;span&gt;) format,

                                  v_args);

    va_end(v_args);

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 互斥信号量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     xSemaphoreTake(xMutex, portMAX_DELAY);

 

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf_str);

 

     xSemaphoreGive(xMutex);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;硬件外设初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;硬件外设的初始化是在 bsp.c 文件实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: bsp_Init

*    功能说明: 初始化所有的硬件设备。该函数配置CPU寄存器和外设的寄存器并初始化一些全局变量。只需要调用一次

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; bsp_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

         由于ST固件库的启动文件已经执行了CPU系统时钟的初始化，所以不必再次重复配置系统时钟。

         启动文件配置了CPU主时钟频率、内部Flash访问速度和可选的外部SRAM FSMC初始化。

 

         系统时钟缺省配置为168MHz，如果需要更改，可以修改 system_stm32f4xx.c 文件

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 优先级分组设置为4，可配置0-15级抢占式优先级，0级子优先级，即不存在子优先级。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);

 

     bsp_InitUart();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化串口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitKey();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化按键变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitLed();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始LED指示灯端口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RL-TCPnet&lt;/strong&gt;&lt;strong&gt;功能测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里专门创建了一个app_tcpnet_lib.c文件用于RL-TCPnet功能的测试，主要功能是创建了一个TCP Server。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_debug printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_debug(...)

&lt;span&gt;#endif&lt;/span&gt;

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; PORT_NUM       1001    /* TCP服务器监听端口号 */

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                         变量

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t socket_tcp;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: tcp_callback

*    功能说明: TCP Socket的回调函数

*    形    参: soc  TCP Socket类型

*             evt  事件类型

*             ptr  事件类型是TCP_EVT_DATA，ptr指向的缓冲区记录着接收到的TCP数据，其余事件记录IP地址

*             par  事件类型是TCP_EVT_DATA，记录接收到的数据个数，其余事件记录端口号

*    返 回 值:

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

U16 tcp_callback (U8 soc, U8 evt, U8 &lt;/span&gt;*&lt;span&gt;ptr, U16 par)

{

     &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;50&lt;/span&gt;&lt;span&gt;];

     uint16_t i;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确保是socket_tcp的回调 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;if&lt;/span&gt; (soc !=&lt;span&gt; socket_tcp)

     {

         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

     }

 

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (evt)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

              远程客户端连接消息

             1、数组ptr存储远程设备的IP地址，par中存储端口号。

             2、返回数值1允许连接，返回数值0禁止连接。

         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONREQ:

              sprintf(buf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;远程客户端请求连接IP: %d.%d.%d.%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ptr[&lt;span&gt;0&lt;/span&gt;], ptr[&lt;span&gt;1&lt;/span&gt;], ptr[&lt;span&gt;2&lt;/span&gt;], ptr[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP:%s  port:%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf, par);

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接终止 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ABORT:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Socket远程连接已经建立 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONNECT:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Socket is connected to remote peer\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接断开 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CLOSE:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection has been closed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发送的数据收到远程设备应答 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ACK:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到TCP数据帧，ptr指向数据地址，par记录数据长度，单位字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_DATA:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data length = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, par);

              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; par; i++&lt;span&gt;)

              {

                   printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ptr[%d] = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i, ptr[i]);

              }

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCP_StatusCheck

*    功能说明: 检测TCP的连接状态，主要用于网线插拔的判断

*    形    参: 无

*    返 回 值: __TRUE  连接

*             __FALSE 断开

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t TCP_StatusCheck(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     uint8_t res;

    

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (tcp_get_state(socket_tcp))

     {

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_FREE:

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CLOSED:

              res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_LISTEN:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CONNECT:

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__TRUE);

             

         &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: 

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__FALSE);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCPnetTest

*    功能说明: TCPnet应用

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; TCPnetTest(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{ 

     int32_t iCount;

     uint8_t &lt;/span&gt;*&lt;span&gt;sendbuf;

     uint8_t tcp_status;

     uint16_t maxlen;

     uint8_t res;

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; TickType_t xTicksToWait = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟2ms &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     EventBits_t uxBits;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        创建TCP Socket并创建监听，客户端连接服务器后，10秒内无数据通信将断开连接。

        但是由于这里使能了TCP_TYPE_KEEP_ALIVE，会一直保持连接，不受10秒的时间限制。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    socket_tcp &lt;/span&gt;= tcp_get_socket (TCP_TYPE_SERVER|TCP_TYPE_KEEP_ALIVE, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;, tcp_callback);

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(socket_tcp != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

     {

         res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

         printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

     }

    

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet处理函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         main_TcpNet();

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用于网线插拔的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         tcp_status &lt;/span&gt;=&lt;span&gt; TCP_StatusCheck();

 

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待所有任务发来事件标志 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         uxBits &lt;/span&gt;= xEventGroupWaitBits(xCreatedEventGroup, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 事件标志组句柄 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                      &lt;span&gt;0xFFFF&lt;/span&gt;,        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待0xFFFF某一位被设置 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                      pdTRUE,&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 退出前0xFFFF位被清除，这里是任意0xFFFF位被设置就“退出”&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                      pdFALSE,       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置为pdTRUE表示等待0xFFFF任意位被设置&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                       xTicksToWait);&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等待延迟时间 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

         &lt;span&gt;if&lt;/span&gt;((uxBits != &lt;span&gt;0&lt;/span&gt;)&amp;amp;&amp;amp;(tcp_status ==&lt;span&gt; __TRUE))

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (uxBits)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K1键按下，给远程TCP客户端发送8字节数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY1_BIT0:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K2键按下，给远程TCP客户端发送1024字节的数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY2_BIT1:       

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);                      

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                      

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K3键按下，给远程TCP客户端发送5MB数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY3_BIT2:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，FreeRTOS方式移植的RL-TCPnet就可以运行了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;10.3.6 RL-TCPnet实验测试和实验现象&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;测试前，先将开发板上面的DM9161/9162网口通过网线接到路由器或者交换机上面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RJ45&lt;/strong&gt;&lt;strong&gt;网络变压器插座上绿灯和黄灯现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各种网卡、交换机等网络设备都不一样，一般来讲：绿灯分为亮或不亮（代表网络速度），黄灯分为闪烁或不闪烁（代表是否有数据收发）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绿灯：长亮代表100M； 不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;黄灯：长亮代表无数据收发； 闪烁代表有数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也有些千兆网卡的灯以颜色区分，不亮代表10M / 绿色代表100M / 黄色代表1000M。现在10M的网络基本看不到了，如果一个灯长亮，基本可以说明100M网络或更高，而另一个灯时而闪烁，那代表有数据收发，具体要看你的网络设备了。甚至有些低等网卡如TP-LINK，只有一个灯，亮代表连通，闪烁代表数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于STM32F429开发板上面的RJ45网络变压器插座上面的灯而言，绿灯代表数据收发，长亮的话表示无数据收发，闪烁代表有数据收发。黄灯代表网络速度，长亮代表100M，不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;底层驱动执行情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了验证RL-TCPnet底层驱动接口函数是否有问题，专门在ETH_STM32F4xx.c文件中配置了串口调试打印函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_eth printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_eth(...)

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果底层驱动正常执行了，打印的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724155004338-252415762.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ping&lt;/strong&gt;&lt;strong&gt;是否正确&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ping命令的主要作用是通过发送数据包并接收应答信息来检测两台设备之间的网络是否连通。ping命令成功说明当前主机与目的主机之间存在连通的路径。如果不成功，需要查看网线是否连通、网卡设置是否正确、IP地址是否可用等。测试方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）WIN+R组合键打开“运行”窗口，输入cmd。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724155010929-453642851.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）弹出的命令窗口中，输入ping armfly，因为在前面的配置中我们使能了NetBIOS局域网域名，并将名字设置为armfly，而且使能了DHCP，通过ping命令还可以获得板子自动获取的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724155016406-110554179.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）输入ping armfly后，回车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180724155021185-1682724153.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;收发相当，没有数据丢失，说明ping命令也是成功的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;电脑端创建一个TCP Client与板子上面的TCP Server通信&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体测试方法，查看第13章的13.6小节即可，因为配套例子实现的功能是一样的。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;10.4 总结&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;本章节为大家讲解了RL-TCPnet网络协议栈的FreeRTOS操作系统移植方法，移植相对比较简单。另一个重要内容是Net_Config.c配置向导文件的说明，这个比较重要，初学者要好好熟悉下。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 24 Jul 2018 07:51:00 +0000</pubDate>
<dc:creator>席萌0209</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/armfly/p/9360488.html</dc:identifier>
</item>
<item>
<title>echarts -  特殊需求实现代码汇总之【饼图】篇 - 郭菊锋</title>
<link>http://www.cnblogs.com/padding1015/p/9360408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/padding1015/p/9360408.html</guid>
<description>&lt;p&gt;&lt;span&gt;2018-07-24 15:36:43 起 - &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;饼图单项不同颜色的设置&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;效果图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180724151807331-216140804.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180724151849427-1901522353.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实很简单，就是设置全局的color属性即可。color属性可以是一套数组，里边的样式以字符串格式设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置以后饼图每一项会依照顺序使用数组的颜色值，如果不够用会循环使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;饼图每个单项的渐变效果&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;效果图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180724152047077-328071015.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180724152102822-1831620052.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;data数据可以是一个数组，数组每一项是一个对象，对象里边可以再次设置私有属性以覆盖全局属性，比如color。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以对每一个单项设置渐变色，就在data数组的每一个对象中单独设置color即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;64&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&lt;span&gt;data: [
    {
        value: 335,
        name: '直接访问',
        itemStyle: {
            color: {
                colorStops: [{
                        offset: 0,
                        color: '#ff7474 ' // 0% 处的颜色
                    }, {
                        offset: 1,
                        color: '#4176ff' // 100% 处的颜色
                    }]
            }
        }
    },
    {
        value: 310,
        name: '邮件营销',
        itemStyle: {
            color: {
                colorStops: [{
                        offset: 0,
                        color: '#ffe390' // 0% 处的颜色
                    }, {
                        offset: 1,
                        color: '#f7c222' // 100% 处的颜色
                    }]
            }
        }
    },
    {
        value: 234,
        name: '联盟广告',
        itemStyle: {
            color: {
                colorStops: [{
                        offset: 0,
                        color: '#9090ff' // 0% 处的颜色
                    }, {
                        offset: 1,
                        color: '#5656d0' // 100% 处的颜色
                    }]
            }
        }
    },
    {
        value: 135,
        name: '视频广告',
        itemStyle: {
            color: {
                colorStops: [{
                        offset: 0,
                        color: '#95ec95' // 0% 处的颜色
                    }, {
                        offset: 1,
                        color: '#4ebb4e' // 100% 处的颜色
                    }]
            }
        }
    },
    {
        value: 1548,
        name: '搜索引擎',
        itemStyle: {
            color: {
                colorStops: [{
                        offset: 0,
                        color: '#ea92ff' // 0% 处的颜色
                    }, {
                        offset: 1,
                        color: '#a847bf' // 100% 处的颜色
                    }]
            }
        }
    }
]
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;饼图label固定字数，超出的限制为显示”...”&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;效果图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180724152733339-1295057516.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;见另一篇文章总结比较清晰明了：&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/8625168.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/padding1015/p/8625168.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;饼图根据单项数据大小设置文案的展示状态（是否探出等）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;效果图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180724152859018-1422803251.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180724152919265-1926081325.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同颜色的道理一样，data数组里边的每一项还有很多可以设置的属性，包括label是否展示等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以在拿到数据以后，遍历返回的data每一项的value值，如果小于自己的需求范围，就在这一项上边设置label不展示的代码即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&lt;span&gt;data: [{
        value: 35,
        name: '视频广告',
        labelLine: {
            normal: {
                show: false
            }
        },
        label: {
            normal: {
                show: false
            }
        }
    }, {
        value: 315,
        name: '邮件营销'
    }
]
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;饼图展示标签在外边或在里边&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;效果图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180724153505341-1168753023.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201807/956663-20180724153529385-1545979210.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认设置全部都不探出，只在内部显示，而只要data某一项中value值符合条件就对此项单独设置为label探出效果即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;78&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&lt;span&gt;option = {
    title: {
        text: '某站点用户访问来源',
        subtext: '纯属虚构',
        x: 'center'
    },
    tooltip: {
        trigger: 'item',
        formatter: &quot;{a} &amp;lt;br/&amp;gt;{b} : {c} ({d}%)&quot;
    },
    legend: {
        orient: 'vertical',
        left: 'left',
        data: ['直接访问', '邮件营销', '联盟广告', '视频广告', '搜索引擎']
    },
    series: [{
            name: '访问来源',
            type: 'pie',
            radius: '55%',
            center: ['50%', '60%'],
            label: {
                show: true,
                position: 'inside'
            },
            labelLine: {
                show: false,
            },
            data: [{
                    value: 335,
                    name: '直接访问'
                }, {
                    value: 310,
                    name: '邮件营销'
                }, {
                    value: 234,
                    name: '联盟广告'
                }, {
                    value: 135,
                    name: '视频广告视频广告视频广告',
                    label: {
                        show: true,
                        position: 'outside'
                    },
                    labelLine: {
                        show: true,
                        smooth: true,
                        lineStyle: {
                           // color: 'red'
                        }
                    }
                }, {
                    value: 1548,
                    name: '搜索引擎搜索引擎搜索引擎搜索引擎搜索引擎',
                    label: {
                        formatter: function (params) {
                            if (params.data.name.length &amp;gt; 5) {
                                var labelNewText = params.data.name.substring(0, 6) + ' ...'
                            }
                            return labelNewText
                        }
                    }
                }],
            itemStyle: {
                emphasis: {
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                }
            }
        }]
};
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Jul 2018 07:43:00 +0000</pubDate>
<dc:creator>郭菊锋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/padding1015/p/9360408.html</dc:identifier>
</item>
<item>
<title>create-react-app源码解读之为什么不搞个山寨版的create-react-app呢？ - 渔歌</title>
<link>http://www.cnblogs.com/yugege/p/9360304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yugege/p/9360304.html</guid>
<description>&lt;p&gt;最近把 vue-cli@2.x 和 create-react-app 的源码都看了一遍。由于现在官方推荐使用 vue-cli@3.0 ，改动比较大，所以就不写关于 vue-cli 的了（据说是因为 vue-cli@2.x 创建项目时操作有点太复杂了，于是犹雨溪大大就借鉴了 create-react-app 的思想，搞出了个零配置的 vue-cli@3.0 ，有兴趣的小伙伴可以去自己看一下哈)。这篇随笔只讲解 create-react-app 的实现，但是，因为 &lt;a href=&quot;https://github.com/facebook/create-react-app/blob/next/packages/create-react-app/createReactApp.js&quot;&gt;create-react-app源码&lt;/a&gt; 加上注释总共800多行代码，这里也不打算对它的源码进行逐一解读了，如果想要对全部源码解读的，可以先把这篇文章看完、再去看源码，应该会容易明白很多。&lt;/p&gt;
&lt;p&gt;前面说了这么多废话，现在该进入正题了。那 create-react-app 到底是什么东东叱？这里还是引用官方 readme 文件的第一句话解释：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Create React apps with no build configuration.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，这解释得很清楚了：&lt;code&gt;creact-react-app&lt;/code&gt;可以让你零配置创建一个&lt;code&gt;React&lt;/code&gt;应用！为什么要强调零配置呢？因为我们都知道，&lt;code&gt;React&lt;/code&gt;是分模块的组件化的框架，这需要配置&lt;code&gt;webpack&lt;/code&gt;打包吧？还有使用了&lt;code&gt;JSX&lt;/code&gt;和高大上的&lt;code&gt;ES6新特性&lt;/code&gt;，这需要配置&lt;code&gt;bable&lt;/code&gt;了啊？另外还需要对代码做静态检查，需要配置&lt;code&gt;eslint&lt;/code&gt;吧？对于一个新手来说，能够成功的配置一个能运行&lt;code&gt;React&lt;/code&gt;的环境，真的很有可能需要一两天时间的。所以零配置的意义就在于让小萌新在不懂配置的情况下，也能迅速的编写自己的第一个&lt;code&gt;react-hello-world&lt;/code&gt;，这是很有成就感的！&lt;/p&gt;
&lt;p&gt;如果之前没有使用过&lt;code&gt;create-react-app&lt;/code&gt;也没有关系 ，这里是它最简单的用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create-react-app my-app&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待数分钟，就会在当前目录下创建一个&lt;code&gt;my-app&lt;/code&gt;的项目，然后进入这个根目录&lt;code&gt;npm start&lt;/code&gt;就可以启动一个&lt;code&gt;React&lt;/code&gt;项目了。记得要先全局安装好&lt;code&gt;create-react-app&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;介绍了&lt;code&gt;create-react-app&lt;/code&gt;是什么，以及他的最简单的用法。现在我们就一起动手实现一个&lt;code&gt;create-react-app&lt;/code&gt;山寨版吧。因为我们实现的是一个简化版的，去除了环境检查、版本检测、离线包安装等功能，代码就剩下100行左右，暂且就叫做&lt;code&gt;simple-create-react-app&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在实现代码之前我们先梳理一上思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过&lt;code&gt;commander&lt;/code&gt;获取项目名称;&lt;/li&gt;
&lt;li&gt;如果项目名称为空（实际上还要对包名进行有效性检查的，这里暂且忽略），则退出进程，并提示用户项目名称不能为空，否则进行步骤3;&lt;/li&gt;
&lt;li&gt;在当前目录下创建一个子目录，目录名称就是用户输入的项目名，并在里面初始化一个&lt;code&gt;package.json&lt;/code&gt;文件;&lt;/li&gt;
&lt;li&gt;进入项目的根目录，安装&lt;code&gt;react&lt;/code&gt;, &lt;code&gt;react-dom&lt;/code&gt; 和&lt;code&gt;react-scripts&lt;/code&gt;三个依赖;&lt;/li&gt;
&lt;li&gt;依赖安装完成后，调用&lt;code&gt;react-scripts&lt;/code&gt;的&lt;code&gt;init&lt;/code&gt;方法初始化项目;&lt;/li&gt;
&lt;li&gt;结束;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;按照上面的思路，开始编码吧！&lt;/p&gt;
&lt;p&gt;先引入一些必要的依赖，对于这些依赖有什么作用这里就不展开了。 以及定义一个用来存放项目名称的变量&lt;code&gt;projectName&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const commander = require('commander');
const chalk = require('chalk');
const spawn = require('cross-spawn'); 
const fs = require('fs-extra');
const path = require('path');
const os = require('os');

const packageJson = require('./package.json');

let projectName; // 项目名称，通过命令行参数获取&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，就创建一个&lt;code&gt;Commander&lt;/code&gt;的实例，获取用户输入的项目名称, 并判断是否为空。如果是空，则提示用户，并退出进程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const program = new commander.Command(packageJson.name)
.version(packageJson.version)
.arguments('&amp;lt;project-directory&amp;gt;')
.usage(`${chalk.green('&amp;lt;project-directory&amp;gt;')} [options]`)
.action(name =&amp;gt; {
  projectName = name;
})
.parse(process.argv) // 格式化参数，必须要的

// 如果没有输入项目名称，则给出提示，并退出进程
if(typeof projectName === 'undefined') {
  console.error('please specify the project directory');
  console.log();
  console.log('For examaple: ')
  console.log(`    ${chalk.cyan(program.name())} ${chalk.green('my-react-app')}`)
  console.log();
  process.exit(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果项目名称不为空，则开始创建一个空的项目，并且初始化一个&lt;code&gt;packgae.json&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 开始创建项目
createApp(projectName);

function createApp(name) {
  const root = path.resolve(name);
  fs.ensureDirSync(root); // 创建项目空目录
  console.log(`Creating a new React app in ${chalk.green(root)}.`);

  // 创建新项目的package.json
  const packageJson = {
    name: name,
    version: '0.1.0',
    private: true
  };
  fs.writeFileSync(path.join(root, 'package.json'), JSON.stringify(packageJson, null, 2) + os.EOL);

  // 将当前目录的路径存下来。因为下一步我们就要进入到新项目的目录了
  // 后面可能还会用到当前的路径
  const originalDirectory = process.cwd();

  // 进入新创建的项目里面
  process.chdir(root);

  run(root, originalDirectory);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建新项目之后，通过&lt;code&gt;process.chdir(root);&lt;/code&gt;让进程的工作目录进入到新项目里面。然后开始安装依赖，等数分钟之后，安装依赖完成后，开始调用&lt;code&gt;create-react-app&lt;/code&gt;的&lt;code&gt;init&lt;/code&gt;方法初始化项目：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function run(root, originalDirectory) {
  const allDependencies = ['react', 'react-dom', 'react-scripts'];
  console.log('Installing packages. This migth take a couple of minutes...');
  console.log(`Installing ${chalk.cyan('react')}, ${chalk.cyan('react-dom')}, and ${chalk.cyan('react-scripts')}...`);
  console.log();

  install(root, allDependencies)
  .then(() =&amp;gt; {
    console.log();
    console.log('Installing is success!');
    console.log();

    // 执行react-scripts模块下的init方法进行初始化项目
    const scriptsPath = path.resolve(
      process.cwd(),
      'node_modules',
      'react-scripts',
      'scripts',
      'init.js'
    )
    const init  = require(scriptsPath);
    init(root, projectName, null, originalDirectory);
  })
  .catch(reason =&amp;gt; {
    console.log();
    console.log('Aborting installation.');
    if(reason.command) {
      console.log(`    ${chalk.cyan(reason.command)} has failed.`);
    } else {
      console.log(chalk.red('Unexpected error!'), reason);
    }
  })
}

// 在指定目录下安装npm依赖
function install(root, dependencies) {
  return new Promise((resolve, reject) =&amp;gt; {
    let command = 'yarnpkg';
    const args = ['add'];
    [].push.apply(args, dependencies);
    let child = spawn(command, args, {stido: 'inherit'});
    child.on('close', code =&amp;gt; {
      if(code !== 0) {
        reject({
          command: `${command} ${args.join(' ')}`
        });
        return;
      }
      resolve();
    })
  });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数了一下，代码总共100多行，就这么简单就实现了&lt;code&gt;create-react-app&lt;/code&gt;的核心功能了。当然，实际上，还有环境检测、版本检测、离线安装等，我们这里忽略了的，如果有兴趣的，可以自己看一下官方的源码。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;create-reate-app&lt;/code&gt;就写这么多了，源码可以到&lt;a href=&quot;https://github.com/zhanyuzhang/simple-create-react-app.git&quot;&gt;我的github&lt;/a&gt;进行下载，如果喜欢的欢迎&lt;code&gt;star&lt;/code&gt;一下哈~&lt;/p&gt;
</description>
<pubDate>Tue, 24 Jul 2018 07:33:00 +0000</pubDate>
<dc:creator>渔歌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yugege/p/9360304.html</dc:identifier>
</item>
<item>
<title>redis系列--你真的入门了吗？redis4.0入门～ - W-D</title>
<link>http://www.cnblogs.com/wdliu/p/9360286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wdliu/p/9360286.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;redis作为nosql家族中非常热门的一员，也是被大型互联网公司所青睐，无论你是开发、测试或者运维，学习掌握它总会为你的职业生涯增色添彩。&lt;/p&gt;
&lt;p&gt;当然，你或多或少已经了解redis，但是你是否了解其中的某些细节，本片文章将详细介绍redis基础，后续也会介绍其高级部分如、持久化、复制、集群等内容，希望对你有所帮助。&lt;/p&gt;
&lt;p&gt;自redis3.0发布已经3年了，redis目前官方提供的redis稳定版本是4.0，以下示例均在4.0版本上进行。&lt;/p&gt;
&lt;h2&gt;一、redis简介&lt;/h2&gt;
&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;redis(REmote DIctionary Server)是一个由Salvatore Sanfilippo写key-value存储系统，它由C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value类型的数据库，并提供多种语言的API。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步，redis在3.0版本推出集群模式。&lt;/p&gt;
&lt;h3&gt;特点、优势&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;k、v键值存储以及数据结构存储（如列表、字典）&lt;/li&gt;
&lt;li&gt;所有数据(包括数据的存储)操作均在内存中完成&lt;/li&gt;
&lt;li&gt;单线程服务(这意味着会有较多的阻塞情况)，采用epoll模型进行请求响应，对比nginx&lt;/li&gt;
&lt;li&gt;支持主从复制模式，更提供高可用主从复制模式（哨兵）&lt;/li&gt;
&lt;li&gt;去中心化分布式集群&lt;/li&gt;
&lt;li&gt;丰富的编程接口支持，如Python、Golang、Java、php、Ruby、Lua、Node.js &lt;/li&gt;
&lt;li&gt;功能丰富，除了支持多种数据结构之外，还支持事务、发布/订阅、消息队列等功能&lt;/li&gt;
&lt;li&gt;支持数据持久化(AOF、RDB)&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;对比memcache&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;memcache是一个分布式的内存对象缓存系统，并不提供持久存储功能，而redis拥有持久化功能&lt;/li&gt;
&lt;li&gt;memcache数据存储基于LRU(简单说：最近、最少使用key会被剔除)，而redis则可以永久保存(服务一直运行情况下)&lt;/li&gt;
&lt;li&gt;memcache是多线程的（这是memcache优势之一），也就意味着阻塞情况少，而redis是单线程的，阻塞情况相对较多&lt;/li&gt;
&lt;li&gt;两者性能上相差不大&lt;/li&gt;
&lt;li&gt;memcache只支持简单的k、v数据存储，而redis支持多种数据格式存储。&lt;/li&gt;
&lt;li&gt;memcache是多线程、非阻塞IO复用网络模型，而redis是单线程IO复用模型&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;二、开始&lt;/h2&gt;
&lt;h3&gt;源码部署&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
yum install gcc -y  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;安装C依赖&lt;/span&gt;
wget http://download.redis.io/redis-stable.tar.gz  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;下载稳定版本&lt;/span&gt;
tar zxvf redis-stable.tar.gz  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;解压&lt;/span&gt;
cd redis-&lt;span&gt;stable
make PREFIX&lt;/span&gt;=/opt/app/redis install   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;指定目录编译，也可以不用指定&lt;/span&gt;
&lt;span&gt;make install
mkdir &lt;/span&gt;/etc/redis   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;建立配置目录&lt;/span&gt;
cp redis.conf /etc/redis/6379.conf &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拷贝配置文件&lt;/span&gt;
cp utils/redis_init_script /etc/init.d/redis  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;拷贝init启动脚本针对6.X系统&lt;/span&gt;
chmod a+x  /etc/init.d/redis  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加执行权限&lt;/span&gt;
vi /etc/redis/6379.conf &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改配置文件： &lt;/span&gt;
bind 0.0.0.0      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;监听地址&lt;/span&gt;
maxmemory 4294967296   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;限制最大内存（4G）：&lt;/span&gt;
daemonize yes   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;后台运行&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###启动与停止&lt;/span&gt;
/etc/init.d/&lt;span&gt;redis start
&lt;/span&gt;/etc/init.d/redis stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看是否成功安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行客户端工具&lt;/span&gt;
redis-&lt;span&gt;cli 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入命令info&lt;/span&gt;
127.0.0.1:6379&amp;gt;&lt;span&gt; info
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Server&lt;/span&gt;
redis_version:4.0.10&lt;span&gt;
redis_git_sha1:&lt;/span&gt;00000000&lt;span&gt;
redis_git_dirty:0
redis_build_id:cf83e9c690dbed33
redis_mode:standalone
os:Linux &lt;/span&gt;2.6.32-642&lt;span&gt;.el6.x86_64 x86_64
arch_bits:&lt;/span&gt;64&lt;span&gt;
multiplexing_api:epoll&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二进制文件说明&lt;/h3&gt;
&lt;p&gt;redis安装完成后会有以下可执行文件（window下是exe文件）生成，下面是各个文件的作用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
redis-server　　　　   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;Redis服务器和Sentinel服务器，启动时候可使用--sentinel指定为哨兵&lt;/span&gt;
redis-cli　　　　　    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;Redis命令行客户端 &lt;/span&gt;
redis-benchmark　     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;Redis性能测试工具 &lt;/span&gt;
redis-check-aof      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;AOF文件修复工具 &lt;/span&gt;
redis-check-dump     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;RDB文件检测工具 &lt;/span&gt;
redis-sentinel       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;Sentinel服务器,4.0版本已经做了软链接到redis-server&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、配置详解&lt;/h2&gt;
&lt;p&gt;redis所有的配置参数都可以通过客户端通过“CONFIG GET 参数名” 获取，参数名支持通配符，如*代表所有。所得结果并按照顺序分组，第一个返回结果是参数名，第二个结果是参数对应的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180719172522490-982020206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了查看配置还可以使用CONFIG SET修改配置，写入配置文件使用CONFIG REWRITE,使用时是需要注意某些关于服务配置参数慎重修改，如bind。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180719180427650-857052801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置参数以及解释，需要注意的是，有些配置是4.0.10新增的，有些配置已经废除，如vm相关配置，和集群相关配置在集群篇章在进行补充。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;logfile
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;日志文件位置及文件名称&lt;/span&gt;
&lt;span&gt;
bind &lt;/span&gt;0.0.0.0
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;监听地址，可以有多个 如bind 0.0.0.0 127.0.0.1&lt;/span&gt;
&lt;span&gt;
daemonize yes
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;yes启动守护进程运行，即后台运行，no表示不启用&lt;/span&gt;
&lt;span&gt;
pidfile &lt;/span&gt;/var/run/&lt;span&gt;redis.pid 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当redis在后台运行的时候，Redis默认会把pid文件在在/var/run/redis.pid，也可以配置到其他地方。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当运行多个redis服务时，需要指定不同的pid文件和端口&lt;/span&gt;
&lt;span&gt;
port &lt;/span&gt;6379
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定redis运行的端口，默认是6379&lt;/span&gt;
&lt;span&gt;
unixsocket 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;sock文件位置&lt;/span&gt;
&lt;span&gt;
unixsocketperm
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;sock文件权限&lt;/span&gt;
&lt;span&gt;
timeout 0
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接， 0是关闭此设置&lt;/span&gt;
&lt;span&gt;
loglevel debug
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose&lt;/span&gt;
&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 日志文件配置,默认值为stdout，标准输出，若后台模式会输出到/dev/null&lt;/span&gt;
&lt;span&gt;
syslog&lt;/span&gt;-&lt;span&gt;enabled
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否以syslog方式记录日志，yes开启no禁用，与该配置相关配置syslog-ident 和syslog-facility local0 分别是指明syslog的ident和facility&lt;/span&gt;
&lt;span&gt;
databases &lt;/span&gt;16
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;配置可用的数据库个数，默认值为16，默认数据库为0，数据库范围在0-（database-1）之间&lt;/span&gt;
&lt;span&gt;
always&lt;/span&gt;-show-logo yes &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4.0以后新增配置&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;是否配置日志显示redis徽标，yes显示no不显示&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################### 快照相关配置 #################################&lt;/span&gt;
&lt;span&gt;
save &lt;/span&gt;900 1&lt;span&gt;
save &lt;/span&gt;300 10&lt;span&gt;
save &lt;/span&gt;60 10000
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;配置快照(rdb)促发规则，格式：save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;save 900 1  900秒内至少有1个key被改变则做一次快照&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;save 300 10  300秒内至少有300个key被改变则做一次快照&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;save 60 10000  60秒内至少有10000个key被改变则做一次快照&lt;/span&gt;
&lt;span&gt;
dbfilename  dump.rdb
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;rdb持久化存储数据库文件名，默认为dump.rdb&lt;/span&gt;
&lt;span&gt;
stop&lt;/span&gt;-write-on-bgsave-&lt;span&gt;error yes 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;yes代表当使用bgsave命令持久化痤疮时候禁止写操作&lt;/span&gt;
&lt;span&gt;
rdbchecksum yes
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启rdb文件校验&lt;/span&gt;
&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据文件存放目录，rdb快照文件和aof文件都会存放至该目录&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################ 复制相关配置参数 #################################&lt;/span&gt;
&lt;span&gt;
slaveof &lt;/span&gt;&amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置该数据库为其他数据库的从数据库，设置当本机为slave服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步&lt;/span&gt;
&lt;span&gt;
masterauth &lt;/span&gt;&amp;lt;master-password&amp;gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;主从复制中，设置连接master服务器的密码（前提master启用了认证）&lt;/span&gt;
&lt;span&gt;
slave&lt;/span&gt;-serve-stale-&lt;span&gt;data yes
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续相应客户端的请求&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2) 如果slave-serve-stale-data是指为no，除了INFO和SLAVOF命令之外的任何请求都会返回一个错误&quot;SYNC with master in progress&quot;&lt;/span&gt;
&lt;span&gt;
repl&lt;/span&gt;-ping-slave-period 10
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从库会按照一个时间间隔向主库发送PING命令来判断主服务器是否在线，默认是10秒&lt;/span&gt;
&lt;span&gt;
repl&lt;/span&gt;-timeout 60
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置主库批量数据传输时间或者ping回复时间间隔超时时间，默认值是60秒&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 一定要确保repl-timeout大于repl-ping-slave-period&lt;/span&gt;
&lt;span&gt;
repl&lt;/span&gt;-backlog-&lt;span&gt;size 1mb
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置复制积压大小,只有当至少有一个从库连入才会释放。&lt;/span&gt;
&lt;span&gt;
slave&lt;/span&gt;-priority 100
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;当主库发生宕机时候，哨兵会选择优先级最高的一个称为主库，从库优先级配置默认100，数值越小优先级越高&lt;/span&gt;
&lt;span&gt;
min&lt;/span&gt;-slaves-to-write 3&lt;span&gt;
min&lt;/span&gt;-slaves-max-lag 10
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置某个时间断内，如果从库数量小于该某个值则不允许主机进行写操作，以上参数表示10秒内如果主库的从节点小于3个，则主库不接受写请求，min-slaves-to-write 0代表关闭此功能。&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################# 安全相关配置 ###################################&lt;/span&gt;
&lt;span&gt;
requirepass
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;客户端连接认证的密码，默认为空，即不需要密码，若配置则命令行使用AUTH进行认证&lt;/span&gt;
&lt;span&gt;
maxclients &lt;/span&gt;10000
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置同一时间最大客户端连接数，4.0默认10000，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果设置 maxclients 0，表示不作限制。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息&lt;/span&gt;
&lt;span&gt;
maxmemory 4gb
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置最大使用的内存大小&lt;/span&gt;
&lt;span&gt;
maxmemory&lt;/span&gt;-&lt;span&gt;policy noeviction
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置达到最大内存采取的策略：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; volatile-lru -&amp;gt; 利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; allkeys-lru -&amp;gt; 利用LRU算法移除任何key&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; volatile-random -&amp;gt; 移除设置过过期时间的随机key&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; allkeys-&amp;gt;random -&amp;gt; remove a random key, any key&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; volatile-ttl -&amp;gt; 移除即将过期的key(minor TTL)&lt;/span&gt;
&lt;span&gt;# 4&lt;/span&gt;&lt;span&gt;&lt;span&gt;.0默认noeviction代表不删除任何key，只在写操作时候返回错误。&lt;/span&gt;

maxmemory&lt;/span&gt;-samples 5
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;LRU，LFU等算法样本设置，默认5个key&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################# AOF相关配置###############################&lt;/span&gt;
&lt;span&gt;
appendonly no
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置AOF持久化，yes开启，no禁用，开启后redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 但是这样会造成appendonly.aof文件过大，所以redis还支持了BGREWRITEAOF指令，对appendonly.aof 进行重写。&lt;/span&gt;
&lt;span&gt;
appendfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appendonly.aof&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置AOF文件名&lt;/span&gt;
&lt;span&gt;
appendfsync everysec
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; AOF文件写策略，Redis支持三种同步AOF文件的策略:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; no: 不进行同步，交给操作系统去执行 ，速度较快&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; always: always表示每次有写操作都调用fsync方法强制内核将该写操作写入到文件，速度会慢, 但是安全，因为每次写操作都在AOF文件中.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; everysec: 表示对写操作进行累积，每秒同步一次，折中方案.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 默认是&quot;everysec&quot;，按照速度和安全折中这是最好的。&lt;/span&gt;
&lt;span&gt;
no&lt;/span&gt;-appendfsync-on-&lt;span&gt;rewrite no
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; AOF策略设置为always或者everysec时，后台处理进程(后台保存或者AOF日志重写)会执行大量的I/O操作&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 在某些Linux配置中会阻止过长的fsync()请求。注意现在没有任何修复，即使fsync在另外一个线程进行处理，为了减缓这个问题，可以设置下面这个参数no-appendfsync-on-rewrite&lt;/span&gt;
&lt;span&gt;
auto&lt;/span&gt;-aof-rewrite-percentage 100&lt;span&gt;
auto&lt;/span&gt;-aof-rewrite-min-&lt;span&gt;size 64mb
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;当AOF文件增长到一定大小的时候Redis能够调用BGREWRITEAOF对日志文件进行重写，它是这样工作的：Redis会记住上次进行些日志后文件的大小(如果从开机以来还没进行过重写，那日子大小在开机的时候确定)。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;基础大小会同现在的大小进行比较。如果现在的大小比基础大小大制定的百分比，重写功能将启动&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 同时需要指定一个最小大小用于AOF重写，这个用于阻止即使文件很小但是增长幅度很大也去重写AOF文件的情况&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 设置 percentage 为0就关闭这个特性&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;auto-aof-rewrite-percentage 代表AOF文件每次重写文件大小（以百分数代表），100表示百分之百，即当文件增加了1倍（100%），则开始重写AOF文件&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;auto-aof-rewrite-min-size  设置最小重写文件大小，避免文件小而执行太多次的重写&lt;/span&gt;
&lt;span&gt;
aof&lt;/span&gt;-load-&lt;span&gt;truncated yes
&lt;span&gt;＃当redis突然运行崩溃时，会出现aof文件被截断的情况，Redis可以在发生这种情况时退出并加载错误，以下选项控制此行为。
＃如果aof&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-load-truncated设置为yes，则加载截断的AOF文件，Redis服务器启动发出日志以通知用户该事件。
＃否则，如果该选项设置为no，则服务器将中止并显示错误并停止启动。当该选项设置为no时，用户需要在重启之前使用“redis-check-aof”实用程序修复AOF文件在进行重启


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################################# 慢查询配置 ###################################&lt;/span&gt;
&lt;span&gt;

slowlog&lt;/span&gt;-log-slower-than 10000
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;Redis Slow Log 记录超过特定执行时间的命令。执行时间不包括I/O计算比如连接客户端，返回结果等，只是命令执行时间，可以通过两个参数设置slow log：一个是告诉Redis执行超过多少时间被记录的参数slowlog-log-slower-than(微秒，因此1000000代表一分钟&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;另一个是slow log 的长度。当一个新命令被记录的时候最早的命令将被从队列中移除&lt;/span&gt;
&lt;span&gt; 
slowlog&lt;/span&gt;-max-len 128
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;慢查询命令记录队列长度设置，该队列占用内存，可以使用SLOWLOG RESET清空队列&lt;/span&gt;



&lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################## 高级配置 ###############################&lt;/span&gt;
&lt;span&gt;
hash&lt;/span&gt;-max-zipmap-entries 512&lt;span&gt;
hash&lt;/span&gt;-max-zipmap-value 64
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当hash中包含超过指定元素个数并且最大的元素没有超过临界时，hash将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。&lt;/span&gt;
&lt;span&gt;
list&lt;/span&gt;-max-ziplist-size -2
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Lists也以特殊方式编码，以节省大量空间。&lt;/span&gt;
&lt;span&gt;＃可以指定每个内部列表节点允许的条目数
＃作为固定的最大大小或最大元素数。
＃对于固定的最大大小，使用-5到-1表示：
＃-5：最大大小：64 Kb &amp;lt; - 不建议用于正常工作负载
＃-4：最大尺寸：32 Kb &amp;lt; - 不推荐
＃-3：最大尺寸：16 Kb &amp;lt; - 可能不推荐
＃-2：最大尺寸：8 Kb &amp;lt; - 好
＃-1：最大尺寸：4 Kb &amp;lt; - 良好
＃正数意味着存储_exactly_元素数量
＃每个列表节点。
＃性能最高的选项通常为-2（8 Kb大小）或-1（4&lt;/span&gt;&lt;span&gt;&lt;span&gt; Kb大小）&lt;/span&gt;

zset&lt;/span&gt;-max-ziplist-entries 128&lt;span&gt;
zset&lt;/span&gt;-max-ziplist-value 64
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; list数据类型多少节点以下会采用去指针的紧凑存储格式。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; list数据类型节点值大小小于多少字节会采用紧凑存储格式。&lt;/span&gt;
&lt;span&gt;
activerehashing yes
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存&lt;/span&gt;
&lt;span&gt;
client&lt;/span&gt;-output-buffer-&lt;span&gt;limit normal 0 0 0
client&lt;/span&gt;-output-buffer-limit slave 256mb 64mb 60&lt;span&gt;
client&lt;/span&gt;-output-buffer-limit pubsub 32mb 8mb 60
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;客户端输出缓冲区限制可用于强制断开客户端，由于某种原因，没有足够快地从服务器读取数据，常见的原因是Pub / Sub客户端不能像很快的消费一条消息，可以为三种不同类型的客户端设置不同的限制：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;normal - &amp;gt;普通客户端，包括MONITOR客户端&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;subve - &amp;gt;从服务器客户端&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;pubsub - &amp;gt;客户端订阅了至少一个pubsub通道或模式&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;设置方法：client-output-buffer-limit 软限制大小 硬限制大小 秒数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;当客户端达到硬限制大小则立即断开连接，当客户端达到软限制时候并且在设置的秒数缓冲大小任然超了，则在设置的秒数后断开连接&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四、数据类型以及相关操作&lt;/h2&gt;
&lt;p&gt;通常使用redis不外乎使用其常用的5中数据类型：string、list、hash、set、sorted_set,在3.2版本以后新添加geo经纬度支持，以下将对其类型的常用操作做说明。&lt;/p&gt;
&lt;h3&gt;命令使用前言&lt;/h3&gt;
&lt;p&gt;通大多数据库一样，redis所有的命令提供了帮助，可以使用help +命令名称查看其使用方法，帮助信息中不仅有命令用法，还有命令始于版本信息，分组等。&lt;/p&gt;
&lt;p&gt;为了友好的使用，redis还将所有命令都进行了分组,同时使用help+@+组名进行查看每个组中所有命令，以下是所有分组信息。&lt;/p&gt;
&lt;p&gt;上面以及介绍如何查看命令使用方法，所以在以下数据类型操作时候，只举例常用的命令，更多命令参考https://redis.io/commands&lt;/p&gt;
&lt;p&gt;注意：redis在3.2版本新增geo数据类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
generic       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;一般命令组，对大多数类型适用&lt;/span&gt;
string        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;字符串类型命令组，使用所有字符串类型&lt;/span&gt;
list          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;列表类型命令组&lt;/span&gt;
set           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;集合类型命令组&lt;/span&gt;
sorted_set    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;有序集合命令组&lt;/span&gt;
hash          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;hash操作命令组&lt;/span&gt;
pubsub        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;发布命令组&lt;/span&gt;
transactions  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;事务操作命令组&lt;/span&gt;
connection    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;连接相关命令组&lt;/span&gt;
server        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;服务器相关命令组&lt;/span&gt;
scripting     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;lua 脚本命令组&lt;/span&gt;
hyperloglog   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;hyperloglog类型命令组，redis在 2.8.9 版本添加了 HyperLogLog 结构&lt;/span&gt;
cluster       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;集群相关命令组&lt;/span&gt;
geo           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;经纬度相关命令组，适用于3.2.0以后的版本&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：查看事务操作所有命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180720163213695-601543803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;key操作&lt;/h3&gt;
&lt;p&gt;常用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
DEL key &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除某个key&lt;/span&gt;
KEYS pattern  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看符合正则的所有key&lt;/span&gt;
EXISTS key [key ...] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断某个key是否存在，可支持多个，返回存在的个数&lt;/span&gt;
EXPIRE key seconds &lt;span&gt;#&lt;/span&gt;&lt;span&gt;刷新某个key过期时间&lt;/span&gt;
MOVE key db  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;移动key到某个数据库&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180723101026306-311240094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;string操作&lt;/h3&gt;
&lt;p&gt;字符串操作中需要注意的是，redis中的整型也当作字符串处理。&lt;/p&gt;
&lt;p&gt;常用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
SET key value [EX seconds] [PX milliseconds] [NX|XX]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置key为指定的字符串值。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;EX seconds – 设置键key的过期时间，单位时秒&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;PX milliseconds – 设置键key的过期时间，单位时毫秒&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;NX – 只有键key不存在的时候才会设置key的值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;XX – 只有键key存在的时候才会设置key的值&lt;/span&gt;
&lt;span&gt;
APPEND key value  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果 key 已经存在，并且值为字符串，那么这个命令会把 value 追加到原来值（value）的结尾。 如果 key 不存在，那么它将首先创建一个空字符串的key，再执行追加操作，这种情况 APPEND 将类似于 SET 操作。&lt;/span&gt;
&lt;span&gt;
GET key &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取key值，不存在则返回nil&lt;/span&gt;
&lt;span&gt;
GETRANGE key start end &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取指定key值的索引开始位置和结束位置所对应的值，索引从0开始&lt;/span&gt;
&lt;span&gt;
GETSET key value  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置新的key值，并获取设置之前的值，如果key不存在则设置，并返回nil&lt;/span&gt;
&lt;span&gt;
MGET key [key ...]   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;批量获取key的值&lt;/span&gt;
&lt;span&gt;
MSET key value [key value ...] &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;批量设置key的值&lt;/span&gt;
&lt;span&gt;
DECR key &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数字类型的key自减操作，key类型不是数字则报错&lt;/span&gt;
&lt;span&gt;
INCR key  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数字类型key 自加操作，与DECR相反&lt;/span&gt;
&lt;span&gt;
DECRBY key decrement  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数字类型key指定减少数值&lt;/span&gt;
&lt;span&gt;
INCRBY key increment   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数字类型key指定增加数值，与DECRBY相反&lt;/span&gt;
&lt;span&gt;
STRLEN key  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取key长度&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180723111202450-413865489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;list操作&lt;/h3&gt;
&lt;p&gt;列表中的元素索引从0开始，倒数的元素可以用“-”+倒数位置表示，如-2，代表倒数第二个元素，-1则代表最后一个元素。&lt;/p&gt;
&lt;p&gt;Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边。&lt;/p&gt;
&lt;p&gt;一个列表最多可以包含 2&lt;sup&gt;32&lt;/sup&gt; - 1 个元素 (4294967295, 每个列表超过40亿个元素)。&lt;/p&gt;
&lt;p&gt;常用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
LPUSH key value [value ...]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从列表左边放入一个或者多个元素&lt;/span&gt;
&lt;span&gt;
LPUSHX key value  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;当列表存在时，从左边放入一个元素&lt;/span&gt;
&lt;span&gt;
RPUSH key value [value ...]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从列表右边放入一个或者多个元素&lt;/span&gt;
&lt;span&gt;
RPUSHX key value  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;当列表存在时，从右边放入一个元素&lt;/span&gt;
&lt;span&gt;
LSET key index value  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;根据索引设置列表中元素的值,当list不存在是报错&lt;/span&gt;
&lt;span&gt;
LINDEX key index  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;根据列表索引获取元素值，索引从0开始&lt;/span&gt;
&lt;span&gt;
LINSERT key BEFORE&lt;/span&gt;|AFTER pivot value  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在列表中，基于某个基准点插入值，pivot代表基准点&lt;/span&gt;
&lt;span&gt;
LLEN key &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取列表长度&lt;/span&gt;
&lt;span&gt;
LRANGE key start stop  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;根据索引获取列表中的元素，列表索引最后一个可以使用-1&lt;/span&gt;
&lt;span&gt;
LREM key count value  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从存于 key 的列表里移除前 count 次出现的值为 value 的元素&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;count &amp;gt; 0: 从头往尾移除值为 value 的元素&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;count &amp;lt; 0: 从尾往头移除值为 value 的元素&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;count = 0: 移除所有值为 value 的元素&lt;/span&gt;
&lt;span&gt;
LPOP key  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从列表左边删除一个元素&lt;/span&gt;
&lt;span&gt;
RPOP key  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从列表右边删除一个元素&lt;/span&gt;
&lt;span&gt;
RPOPLPUSH source destination  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除source列表中的删除最后一个元素将其追加到destination列表&lt;/span&gt;
&lt;span&gt;
LTRIM key start stop  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;根据索引start和stop保留列表元素&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180723143235852-2005355974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;hash操作&lt;/h3&gt;
&lt;p&gt;hash操作所有命令都以H开头。&lt;/p&gt;
&lt;p&gt;Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。&lt;/p&gt;
&lt;p&gt;Redis 中每个 hash 可以存储 2&lt;sup&gt;32&lt;/sup&gt; - 1 键值对（40多亿）。&lt;/p&gt;
&lt;p&gt;常用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HDEL key field [field ...]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除hash表中一个或多个字段&lt;/span&gt;
&lt;span&gt;
HEXISTS key field  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断hash表中字段是否存在&lt;/span&gt;
&lt;span&gt;
HGET key field  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取hash表中字段的值&lt;/span&gt;
&lt;span&gt;
HGETALL key  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取hash表中所有字段&lt;/span&gt;
&lt;span&gt;
HSET key field value  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置hash表中字段的值&lt;/span&gt;
&lt;span&gt;
HSETNX key field value  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只有当字段不存在时候才设置hash表中字段值，&lt;/span&gt;
&lt;span&gt;
HLEN key  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取hash表中字段个数&lt;/span&gt;
&lt;span&gt;
HVALS key  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取hash表中所有字段的值&lt;/span&gt;
&lt;span&gt;
HKEYS key  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取hash表中所有的字段&lt;/span&gt;
&lt;span&gt;
HSTRLEN key field &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取hash表中指定字段的值的长度&lt;/span&gt;
&lt;span&gt;
HMSET key field value [field value ...]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;批量设置hash表中字段的值&lt;/span&gt;
&lt;span&gt;
HMGET key field [field ...]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;批量获取hash表中字段的值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180723150640062-1294716815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;集合set操作&lt;/h3&gt;
&lt;p&gt;Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。&lt;/p&gt;
&lt;p&gt;Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。&lt;/p&gt;
&lt;p&gt;集合中最大的成员数为 2&lt;sup&gt;32 - 1&lt;/sup&gt; (4294967295, 每个集合可存储40多亿个成员)。&lt;/p&gt;
&lt;p&gt;常用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
SADD key member [member ...]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加一个或多个元素到集合中&lt;/span&gt;
&lt;span&gt;
SREM key member [member ...]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除一个或多个集合中的元素&lt;/span&gt;
&lt;span&gt;
SCARD key  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取集合中元素数量&lt;/span&gt;
&lt;span&gt;
SMEMBERS key  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回集合中所有的元素&lt;/span&gt;
&lt;span&gt;
SINTER key [key ...] &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取两个或两个以上集合的交集&lt;/span&gt;
&lt;span&gt;
SUNION key [key ...]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取两个或两个以上集合的并集&lt;/span&gt;
&lt;span&gt;
SDIFF key [key ...]     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取两个或者两个以上集合的差集&lt;/span&gt;
&lt;span&gt;
SISMEMBER key member  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断元素是否是在指定集合中&lt;/span&gt;
&lt;span&gt;
SMOVE source destination member &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;移动一个集合中的元素到另一个集合&lt;/span&gt;
&lt;span&gt;
SPOP key [count]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;移除count个集合中元素，count可选参数，默认为1，即移除一个&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;有序集合操作&lt;/h3&gt;
&lt;p&gt;Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。&lt;/p&gt;
&lt;p&gt;不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。&lt;/p&gt;
&lt;p&gt;有序集合的成员是唯一的,但分数(score)却可以重复。&lt;/p&gt;
&lt;p&gt;集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 2&lt;sup&gt;32 - 1&lt;/sup&gt; (4294967295, 每个集合可存储40多亿个成员)。&lt;/p&gt;
&lt;p&gt;常用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ZADD key [NX|XX] [CH] [INCR] score member [score member ...]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;向一个有序集合添加成员（元素）&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;XX: 仅仅更新存在的成员，不添加新成员。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;NX: 不更新存在的成员。只添加新成员。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;CH: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 changed 的意思)。更改的元素是新添加的成员，已经存在的成员更新分数。 所以在命令中指定的成员有相同的分数将不被计算在内。注：在通常情况下，ZADD返回值只计算新添加成员的数量。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;INCR: 当ZADD指定这个选项时，成员的操作就等同ZINCRBY命令，对成员的分数进行递增操作。&lt;/span&gt;
&lt;span&gt;
ZCARD key  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取有序集合中元素个数&lt;/span&gt;
&lt;span&gt;
ZCOUNT key min max  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;指定分数范围的元素个数&lt;/span&gt;
&lt;span&gt;
ZINCRBY key increment member  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;为有序集的元素的score值加上增加指定的increment&lt;/span&gt;
&lt;span&gt;
ZRANGE key start stop [WITHSCORES]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;根据有序集合中分数区间获取集合中的元素&lt;/span&gt;
&lt;span&gt;
ZRANGE key start stop [WITHSCORES]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取有序集合中元素的排名&lt;/span&gt;
&lt;span&gt;
ZREM key member [member ...]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除有序集合中一个或多个元素&lt;/span&gt;
&lt;span&gt;
ZSCORE key member  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置元素在集合中的分数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;GEO类型操作&lt;/h3&gt;
&lt;p&gt;Redis的GEO是 3.2 版本的新特性，对GEO(地理位置)的支持。这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。&lt;/p&gt;
&lt;p&gt;geo类型命令不多，总共6个所以这里全部列举出来了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
GEOADD key longitude latitude member [longitude latitude member ...]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将指定的地理空间位置（纬度、经度、名称）添加到指定的key中&lt;/span&gt;
&lt;span&gt;
GEODIST key member1 member2 [unit]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回两个给定位置之间的距离。如果两个位置之间的其中一个不存在， 那么命令返回空值。指定单位的参数 unit 必须是以下单位的其中一个：&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;m 表示单位为米&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;km 表示单位为千米&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;mi 表示单位为英里&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;ft 表示单位为英尺&lt;/span&gt;
&lt;span&gt;
GEOPOS key member [member ...]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从key里返回所有给定位置元素的位置（经度和纬度）&lt;/span&gt;
&lt;span&gt;
GEOHASH key member [member ...]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回一个或多个位置元素的 Geohash 表示。通常使用表示位置的元素使用不同的技术，使用Geohash位置52点整数编码。由于编码和解码过程中所使用的初始最小和最大坐标不同，编码的编码也不同于标准。此命令返回一个标准的Geohash&lt;/span&gt;
&lt;span&gt;
GEORADIUS key longitude latitude radius m&lt;/span&gt;|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|&lt;span&gt;DESC] [STORE key] [STOREDIST key]  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;范围可以使用以下其中一个单位：&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;m 表示单位为米。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;km 表示单位为千米。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;mi 表示单位为英里。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;ft 表示单位为英尺。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;在给定以下可选项时， 命令会返回额外的信息：&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;WITHCOORD: 将位置元素的经度和维度也一并返回。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ASC: 根据中心的位置， 按照从近到远的方式返回位置元素。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;DESC: 根据中心的位置， 按照从远到近的方式返回位置元素。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;在默认情况下， GEORADIUS 命令会返回所有匹配的位置元素。 虽然用户可以使用 COUNT &amp;lt;count&amp;gt; 选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的。&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回值：&lt;/span&gt;
  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在没有给定任何 WITH 选项的情况下， 命令只会返回一个像 [“New York”,”Milan”,”Paris”] 这样的线性（linear）列表。&lt;/span&gt;
  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在指定了 WITHCOORD 、 WITHDIST 、 WITHHASH 等选项的情况下， 命令返回一个二层嵌套数组， 内层的每个子数组就表示一个元素&lt;/span&gt;

  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在返回嵌套数组时， 子数组的第一个元素总是位置元素的名字。 至于额外的信息， 则会作为子数组的后续元素， 按照以下顺序被返回：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;以浮点数格式返回的中心与位置元素之间的距离， 单位与用户指定范围时的单位一致。&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;geohash 整数。&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;由两个元素组成的坐标，分别为经度和纬度。&lt;/span&gt;
&lt;span&gt;
GEORADIUSBYMEMBER key member radius m&lt;/span&gt;|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|&lt;span&gt;DESC] [STORE key] [STOREDIST key]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180723173956118-272001640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、发布订阅&lt;/h2&gt;
&lt;p&gt;Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。&lt;/p&gt;
&lt;p&gt;Redis 客户端可以订阅任意数量的频道。&lt;/p&gt;
&lt;p&gt;下图代表其发布订阅之间的关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180724102046761-1929696308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;运作原理&lt;/h3&gt;
&lt;p&gt;每个 Redis 服务器进程都维持着一个表示服务器状态的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;redis.h/redisServer&lt;/span&gt;&lt;/code&gt; 结构， 结构的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;pubsub_channels&lt;/span&gt;&lt;/code&gt; 属性是一个字典， 这个字典就用于保存订阅频道的信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; redisServer {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    dict *&lt;span&gt;pubsub_channels;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。&lt;/p&gt;
&lt;p&gt;比如说，在下图展示的这个 &lt;code class=&quot;docutils literal&quot;&gt;pubsub_channels&lt;/code&gt; 示例中， &lt;code class=&quot;docutils literal&quot;&gt;client1&lt;/code&gt; 、 &lt;code class=&quot;docutils literal&quot;&gt;client2&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;client3&lt;/code&gt; 就订阅了 &lt;code class=&quot;docutils literal&quot;&gt;channel1&lt;/code&gt; ， 而client3也同时订阅了channel2。&lt;/p&gt;
&lt;p&gt;当客户端调用 SUBSCRIBE 命令时， 程序就将客户端和要订阅的频道在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;pubsub_channels&lt;/span&gt;&lt;/code&gt; 字典中关联起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180724105321134-1954840099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;SUBSCRIBE 命令的行为可以用伪代码表示如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def SUBSCRIBE(client, channels):

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历所有输入频道&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; channel &lt;span&gt;in&lt;/span&gt;&lt;span&gt; channels:

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将客户端添加到链表的末尾&lt;/span&gt;
        redisServer.pubsub_channels[channel].append(client)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;pubsub_channels&lt;/span&gt;&lt;/code&gt; 字典， 程序只要检查某个频道是否为字典的键， 就可以知道该频道是否正在被客户端订阅； 只要取出某个键的值， 就可以得到所有订阅该频道的客户端的信息。&lt;/p&gt;
&lt;p&gt;了解了 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;pubsub_channels&lt;/span&gt;&lt;/code&gt; 字典的结构之后， 解释 PUBLISH 命令的实现就非常简单了： 当调用 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;PUBLISH &lt;span class=&quot;pre&quot;&gt;channel &lt;span class=&quot;pre&quot;&gt;message&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 命令， 程序首先根据 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;channel&lt;/span&gt;&lt;/code&gt; 定位到字典的键， 然后将信息发送给字典值链表中的所有客户端。&lt;/p&gt;
&lt;h3&gt;订阅模式&lt;/h3&gt;
&lt;p&gt;redis的发布订阅不仅仅提供简单的订阅频道，还提供模式匹配订阅。模式订阅使用命令PSUBSCRIBE实现。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;redisServer.pubsub_patterns&lt;/span&gt;&lt;/code&gt; 属性是一个链表，链表中保存着所有和模式相关的信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; redisServer {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    list *&lt;span&gt;pubsub_patterns;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;链表中的每个节点都包含一个 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;redis.h/pubsubPattern&lt;/span&gt;&lt;/code&gt; 结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; pubsubPattern {
    redisClient &lt;/span&gt;*&lt;span&gt;client;
    robj &lt;/span&gt;*&lt;span&gt;pattern;
} pubsubPattern;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;docutils literal&quot;&gt;client&lt;/code&gt; 属性保存着订阅模式的客户端，而 &lt;code class=&quot;docutils literal&quot;&gt;pattern&lt;/code&gt; 属性则保存着被订阅的模式。&lt;/p&gt;
&lt;p&gt;每当调用 &lt;code class=&quot;docutils literal&quot;&gt;PSUBSCRIBE&lt;/code&gt; 命令订阅一个模式时， 程序就创建一个包含客户端信息和被订阅模式的 &lt;code class=&quot;docutils literal&quot;&gt;pubsubPattern&lt;/code&gt; 结构， 并将该结构添加到 &lt;code class=&quot;docutils literal&quot;&gt;redisServer.pubsub_patterns&lt;/code&gt; 链表中。&lt;/p&gt;
&lt;p&gt;作为例子，下图展示了一个包含两个模式的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;pubsub_patterns&lt;/span&gt;&lt;/code&gt; 链表， 其中 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;client123&lt;/span&gt;&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;client256&lt;/span&gt;&lt;/code&gt; 都正在订阅 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;tweet.shop.*&lt;/span&gt;&lt;/code&gt; 模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180724112542370-1337959980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过遍历整个 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;pubsub_patterns&lt;/span&gt;&lt;/code&gt; 链表，程序可以检查所有正在被订阅的模式，以及订阅这些模式的客户端。&lt;/p&gt;
&lt;p&gt;当执行PUBLISH进行命令向channel命令发送消息时，PUBLISH 除了将 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;message&lt;/span&gt;&lt;/code&gt; 发送到所有订阅 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;channel&lt;/span&gt;&lt;/code&gt; 的客户端之外， 它还会将 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;channel&lt;/span&gt;&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;pubsub_patterns&lt;/span&gt;&lt;/code&gt; 中的模式进行对比， 如果 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;channel&lt;/span&gt;&lt;/code&gt; 和某个模式匹配的话， 那么也将 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;message&lt;/span&gt;&lt;/code&gt; 发送到订阅那个模式的客户端，例如一个客户端订阅了aa.bb.*频道，那么他会收到来自所有aa.bb开头的所有频道消息。&lt;/p&gt;
&lt;h3&gt;相关命令&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
PSUBSCRIBE pattern [pattern ...]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用模式订阅一个或多个符合给定模式的频道&lt;/span&gt;
&lt;span&gt;
PUNSUBSCRIBE [pattern [pattern ...]]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;退订所有给定模式的频道&lt;/span&gt;
&lt;span&gt;
SUBSCRIBE channel [channel ...]   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;订阅给定的一个或多个频道的信息&lt;/span&gt;
&lt;span&gt;
UNSUBSCRIBE [channel [channel ...]]   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;指退订给定的频道&lt;/span&gt;
&lt;span&gt;
PUBSUB subcommand [argument [argument ...]]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看订阅与发布系统状态&lt;/span&gt;
&lt;span&gt;
PUBLISH channel message   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将信息发送到指定的频道&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;实践&lt;/h3&gt;
&lt;p&gt;在以下示例中，将分别用SUBSCRIBE命令订阅aa.bb和使用PSUBSCRIBE模式订阅频道aa.bb*。&lt;/p&gt;
&lt;p&gt;SUBSCRIBE订阅：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180724113421089-2081098527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PSUBSCRIBE订阅：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180724113550043-1493570562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们使用PUBSH向aa.bb发送消息，返回接受到的频道数，两个订阅者都能收到消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180724113748805-271826950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;订阅者1:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180724113858218-1536831670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模式订阅者：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180724114007352-1131458355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;ul class=&quot;simple&quot;&gt;&lt;li&gt;订阅信息由服务器进程维持的 &lt;code class=&quot;docutils literal&quot;&gt;redisServer.pubsub_channels&lt;/code&gt; 字典保存，字典的键为被订阅的频道，字典的值为订阅频道的所有客户端。&lt;/li&gt;
&lt;li&gt;当有新消息发送到频道时，程序遍历频道（键）所对应的（值）所有客户端，然后将消息发送到所有订阅频道的客户端上。&lt;/li&gt;
&lt;li&gt;订阅模式的信息由服务器进程维持的 &lt;code class=&quot;docutils literal&quot;&gt;redisServer.pubsub_patterns&lt;/code&gt; 链表保存，链表的每个节点都保存着一个 &lt;code class=&quot;docutils literal&quot;&gt;pubsubPattern&lt;/code&gt; 结构，结构中保存着被订阅的模式，以及订阅该模式的客户端。程序通过遍历链表来查找某个频道是否和某个模式匹配。&lt;/li&gt;
&lt;li&gt;当有新消息发送到频道时，除了订阅频道的客户端会收到消息之外，所有订阅了匹配频道的模式的客户端，也同样会收到消息。&lt;/li&gt;
&lt;li&gt;退订频道和退订模式分别是订阅频道和订阅模式的反操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;六、事务&lt;/h2&gt;
&lt;p&gt;所谓事务应具有以下特效：原子性(Atomicity)， 一致性(Consistency)，隔离性(Isolation)，持久性(Durability)，简称ACID，但redis所提供的事务比较简单，它通过MULTI、EXEC、DISCARD和WATCH等命令实现事务。&lt;/p&gt;
&lt;p&gt;而Redis只支持简单的事务，将执行命令放入队列缓存，当程序中有异常或命令出错，执行DISCARD清空缓存队列不执行队列中命令，其事务过程有以下特点：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;事务是一个&lt;strong&gt;泛原子&lt;/strong&gt;操作（这里我以泛原子称呼，在某些情况redis的事务不是原子性的，后续会说明）：事务中的命令要么全部被执行，要么全部都不执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;EXEC 命令负责触发并执行事务中的所有命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。&lt;/li&gt;
&lt;li&gt;另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;特别说明文中的&lt;strong&gt;泛原子操作&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;redis在开启事务以后，若执行命令具有显示的错误或者客户端中断则此次事务在执行EXEC命令时会调用DISCARD清空缓存队列不执行队列中的所有任务，此时是原子性的。&lt;/li&gt;
&lt;li&gt;当执行命令过程中，命令没有显示的报错（例如LSET操作设置一个不存在的list），而是在EXEC调用时候某个命令出错，那么在这之前已经执行的命令将不会回滚，所以严格说来，&lt;span&gt;redis并不支持原子性。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;涉及命令&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
MULTI  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令执行缓存队列中的命令。&lt;/span&gt;
&lt;span&gt;
EXEC  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行缓存队列中的命令&lt;/span&gt;
&lt;span&gt;
DISCARD  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态，如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。&lt;/span&gt;
&lt;span&gt;
WATCH key [key ...]   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的&lt;/span&gt;
&lt;span&gt;
UNWATCH  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;清除所有先前为一个事务监控的键，如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;乐观锁机制&lt;/h3&gt;
&lt;p&gt;乐观锁：总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或检查再设置(CAS)操作实现。&lt;/p&gt;
&lt;p&gt;redis通过WATCH命令实现乐观锁，作为WATCH命令的参数的键会受到Redis的监控，Redis能够检测到它们的变化。在执行EXEC命令之前，如果Redis检测到至少有一个键被修改了，那么整个事务便会中止运行，然后EXEC命令会返回一个nil值，提醒用户事务运行失败。&lt;/p&gt;
&lt;p&gt;注意：WATCH命令需要在MULTI之前执行，不然redis会将其一个命令放入缓存队列中。&lt;/p&gt;
&lt;p&gt;示例：在以下示例中通过一个客户端开启事务监听name键，另一个客户端在执行EXEC之前修改name键，此次事务将不会执行，并返回nil，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180724150037057-928572007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180724150504414-1451703303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;原子性实践&lt;/h3&gt;
&lt;p&gt;为演示redis严格意义上将不支持原子性，做了一些简单实践。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180724152337730-2016437575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的结果可以看出，在开启事务前name 值为Rose，在开启事务先后执行了SET命令和LSET命令，但是LSET命令是错误的，当我们调用EXEC执行事务完事务以后，在回头看事务中的SET命令已经生效，并未回滚，因为在次过程中该命令没有显示的报错，所以可以说redis的事务不支持原子性。&lt;/p&gt;

&lt;p&gt;以上为本文所有内容，希望对你有所帮助！&lt;/p&gt;

</description>
<pubDate>Tue, 24 Jul 2018 07:31:00 +0000</pubDate>
<dc:creator>W-D</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wdliu/p/9360286.html</dc:identifier>
</item>
<item>
<title>关于 IO 和 NIO 的思考 - wskwbog</title>
<link>http://www.cnblogs.com/wskwbog/p/9360129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wskwbog/p/9360129.html</guid>
<description>&lt;p&gt;I/O 的实际操作由内核执行，其中一个重要手段是缓冲区。简单来说 I/O 可分为两类：面向磁盘和面向网络，Java 也是针对这两者来抽象设计 API，相关的类主要在 &lt;code&gt;java.io&lt;/code&gt; 和 &lt;code&gt;java.nio&lt;/code&gt; 包中，简称为 BIO 和 NIO。&lt;/p&gt;
&lt;h2 id=&quot;为什么设计-nio&quot;&gt;为什么设计 NIO&lt;/h2&gt;
&lt;p&gt;一个直接原因就是为了更好的利用操作系统特性，改善和扩展原有 API。与 NIO 相关的规范有两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=51&quot;&gt;JSR 51&lt;/a&gt;：它是 NIO 的第一个规范，关注缓冲区、通道和字符集的设计，引入一个简单的面向缓冲区的 I/O 模型，并且提供一套非阻塞、I/O 多路复用、可扩展的 API；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=203&quot;&gt;JSR 203(NIO.2)&lt;/a&gt;：它在前者的基础上，添加新的文件系统的抽象，完善现有 Socket 通道的配置，添加多播数据报的支持，并且定义了一个异步 I/O 编程 API。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，传统的 BIO 又有什么弊端？NIO 又是如何改进的？&lt;/p&gt;
&lt;h3 id=&quot;文件操作&quot;&gt;文件操作&lt;/h3&gt;
&lt;p&gt;关于 &lt;code&gt;java.io.file&lt;/code&gt;，它的不足之处在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当查询文件属性时，如修改时间或文件类型，都会发生系统调用，并且这些组合操作非常常见，造成性能问题；&lt;/li&gt;
&lt;li&gt;部分方法在发生错误时返回 false 而不是抛出异常，比如 delete、rename；&lt;/li&gt;
&lt;li&gt;一些 OS 常用功能不支持，比如符号链接、文件锁定、内存映射等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而 NIO 支持批量获取文件属性，对文件、目录的处理也重新设计，提供 FileLock、MappedByteBuffer。&lt;/p&gt;
&lt;h3 id=&quot;网络通信&quot;&gt;网络通信&lt;/h3&gt;
&lt;p&gt;传统 BIO 是阻塞式、基于流的I/O，其网络服务器模型是一连接一线程，通常采用线程池优化，但一个进程或者计算机打开的线程数是有限的，可扩展性差。&lt;/p&gt;
&lt;p&gt;NIO 是基于缓冲区（也是由字节流或字符流组成）的，对原始 I/O 提供了新的抽象 - Channel（通道）。&lt;code&gt;Channel&lt;/code&gt; 表示一个到硬件设备、文件或网络套接字的连接，与 java.net.Socket 的区别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可配置非阻塞，允许事件驱动的设计，提供了一种更加可扩展的服务器开发；&lt;/li&gt;
&lt;li&gt;面向字节缓冲区，可实现 &lt;a href=&quot;https://www.ibm.com/developerworks/library/j-zerocopy/&quot;&gt;零拷贝&lt;/a&gt; 执行 I/O ，一端得是 FileChannel。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;NIO 主要目标是设计、开发可扩展/可伸缩性服务器，让少量的线程管理大量的客户端连接，而灵活的代价是编程复杂，一复杂就会有人抽象出框架，NIO 常用的框架是 Netty，这里想到一个问题，Netty 宣称的零拷贝与OS级别的有区别吗？&lt;/p&gt;
&lt;p&gt;服务器常用的优化手段是对象池、减少数据复制（内核到用户进程或用户进程内部）、减少上下文切换和锁，ByteBuffer 本质就是提供了一个可复用的 byte[] 数组，而 BIO 做好这些优化也不见得比 NIO 慢，那么如何选择I/O模型？&lt;/p&gt;
&lt;h2 id=&quot;io-模型的选择&quot;&gt;I/O 模型的选择&lt;/h2&gt;
&lt;p&gt;首先了解一下 &lt;a href=&quot;https://en.wikipedia.org/wiki/C10k_problem#cite_note-C10K-1&quot;&gt;C10k problem&lt;/a&gt; - 描述单机处理1万个并发连接的问题，两个不同的概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;并发连接（concurrent connections）：在有限的时间内响应请求，关注高效的连接调度；&lt;/li&gt;
&lt;li&gt;每秒请求数（requests per second）：快速处理请求以响应，关注高吞吐量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;C10k 问题的本质在于 CPU，即线程数，单机创建大量线程，不仅占用大量的内存，频繁的数据复制和上下文切换还会导致 OS 崩溃。&lt;/p&gt;
&lt;p&gt;如果采用 BIO 一个直观的解决办法是水平扩展，采用分布式系统，但如果并发量上升到百万、千万、甚至上亿，那么服务器的成本得多大？解决此问题的关键是减少线程数，提高单机的处理能力，而如何使用少量的线程管理大量的连接，则在操作系统层面解决了，也就是 Linux 下的 Epoll，Java 中的 NIO。如果你的应用面临 C10k 问题，NIO 是最好的选择。&lt;/p&gt;
&lt;p&gt;那 BIO 有什么用呢？大家都用线程池，你有 ByteBuffer，我也可以自己维护字节缓冲，照样成块读取，阻塞无非因为 I/O 延迟高，那换成 SSD和光纤，而且我编程简单，唯一的缺点就是扩展性差了点。:)&lt;/p&gt;
&lt;p&gt;至于如何选择 I/O 模型，需要结合业务场景，综合考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;短连接还是长连接&lt;/li&gt;
&lt;li&gt;预计最大的并发数&lt;/li&gt;
&lt;li&gt;预计每个连接的数据量，即流量的大小&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但感觉还是很难给出明确的答案，简单来说，并发量低的可采用 BIO，高的可采用 NIO，至于 AIO 它应该不太成熟，不过多描述了。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;写的可能有点乱，等以后有更多的体会，再优化吧。欢迎讨论。&lt;/p&gt;
</description>
<pubDate>Tue, 24 Jul 2018 07:14:00 +0000</pubDate>
<dc:creator>wskwbog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wskwbog/p/9360129.html</dc:identifier>
</item>
<item>
<title>LinkedHashMap源码浅析jdk1.7 - kin1492</title>
<link>http://www.cnblogs.com/kin1492/p/9360068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kin1492/p/9360068.html</guid>
<description>&lt;h3&gt;LinkedHahsMap的继承关系&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1446360/201807/1446360-20180724125121188-1101987321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LinkedHashMap直接继承了HahsMap，而linkedHashMap和HashMap在同一个包下，因此HashMap中所有的非private的属性都能拿过来直接用。&lt;/p&gt;
&lt;p&gt;LinkedHashMap继承HashMap原来的功能同时进行了修改。主要对原来Entry的结构进行了扩展，在继承父类Entry的基础上，有添加的两个属性Entry&amp;lt;K,V&amp;gt; before, after;和addBefore方法。同时覆盖了父类的init，addEntry,createEntry，transfer等方法，添加了header成员变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; header;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; HashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; These fields comprise the doubly linked list used for iteration.&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt;&lt;span&gt; before, after;

        Entry(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, HashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hash, key, value, next);
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Removes this entry from the linked list.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            before.after &lt;/span&gt;=&lt;span&gt; after;
            after.before &lt;/span&gt;=&lt;span&gt; before;
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Inserts this entry before the specified existing entry in the list.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addBefore(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; existingEntry) {
            after  &lt;/span&gt;=&lt;span&gt; existingEntry;
            before &lt;/span&gt;=&lt;span&gt; existingEntry.before;
            before.after &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
            after.before &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * This method is invoked by the superclass whenever the value
         * of a pre-existing entry is read by Map.get or modified by Map.set.
         * If the enclosing Map is access-ordered, it moves the entry
         * to the end of the list; otherwise, it does nothing.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; recordAccess(HashMap&amp;lt;K,V&amp;gt;&lt;span&gt; m) {
            LinkedHashMap&lt;/span&gt;&amp;lt;K,V&amp;gt; lm = (LinkedHashMap&amp;lt;K,V&amp;gt;&lt;span&gt;)m;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (lm.accessOrder) {
                lm.modCount&lt;/span&gt;++&lt;span&gt;;
                remove();
                addBefore(lm.header);
            }
        }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; recordRemoval(HashMap&amp;lt;K,V&amp;gt;&lt;span&gt; m) {
            remove();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;LinkedHashMap的初始化&lt;/h3&gt;
&lt;p&gt;linkedHashMap所有的构造方法里都调用了父类相关的构造方法，在父类构造中有调用了init方法，而linkedHashMap又覆盖了init方法，因此初始化先执行父类相关的操作，在执行自己init方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        header &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;(-1, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        header.before &lt;/span&gt;= header.after =&lt;span&gt; header;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;init方法主要是将header实例化，实例化之后就会出现一个Entry类型的header的指针,其before和after都指向自己，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1446360/201807/1446360-20180724140132758-330725198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;LinkedHashMap put操作&lt;/h3&gt;
&lt;p&gt;linkedHashMap没有覆盖put方法，还是用父类的，因此调用父类的put会完成table属性的初始化，以及计算元素在table中的索引（调用的都是父类相关方法），然后调用addEntry方法，这时会调用自己的addEntry方法，因为linkedHashMap重写了addEntry方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;void&lt;/span&gt; addEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用父类的addEntry&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.addEntry(hash, key, value, bucketIndex);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove eldest entry if instructed&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; eldest =&lt;span&gt; header.after;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (removeEldestEntry(eldest)) {
            removeEntryForKey(eldest.key);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在自己的addEntry方法里面又调用了父类的方法，父类的方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; addEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看是否需要扩容&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; table[bucketIndex])) {
            resize(&lt;/span&gt;2 *&lt;span&gt; table.length);
            hash &lt;/span&gt;= (&lt;span&gt;null&lt;/span&gt; != key) ? hash(key) : 0&lt;span&gt;;
            bucketIndex &lt;/span&gt;=&lt;span&gt; indexFor(hash, table.length);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 又调用createEntry&lt;/span&gt;
&lt;span&gt;        createEntry(hash, key, value, bucketIndex);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;addEntry方法里有调用createEntry,同样linkedHashMap覆盖了父类的createEntry，调用本地的&lt;/p&gt;
&lt;pre&gt;
void createEntry(int hash, K key, V value, int bucketIndex) {&lt;br/&gt;HashMap.Entry&amp;lt;K,V&amp;gt; old = table[bucketIndex];&lt;br/&gt;Entry&amp;lt;K,V&amp;gt; e = new Entry&amp;lt;&amp;gt;(hash, key, value, old);&lt;br/&gt;table[bucketIndex] = e;&lt;br/&gt;e.addBefore(header);&lt;br/&gt;size++;&lt;br/&gt;}
&lt;/pre&gt;
&lt;p&gt;把entry添加到数组里面后，有调用了entry的addBefore方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addBefore(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; existingEntry) {
            after  &lt;/span&gt;=&lt;span&gt; existingEntry;
            before &lt;/span&gt;=&lt;span&gt; existingEntry.before;
            before.after &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
            after.before &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;addBefore传进来的是header,进行如下操作&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;1. after  =&lt;span&gt; existingEntry;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;把当前节点（比如是A）的after指向header(existingEntry传递的都是header), 因此A.after---&amp;gt;header  &lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;2. before =&lt;span&gt; existingEntry.before;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;当前节点的before指向 header所指向的before(header.before=B)，A.before----&amp;gt;B&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;3. before.after = this&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt; 也就是 B.after----&amp;gt;A&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;4. after.before = this&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt; 相当于header.before---&amp;gt;A&lt;/p&gt;
&lt;p&gt;如果是第一次添加,上面的B就是header对应如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1446360/201807/1446360-20180724145012227-1735746460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;linkedHashMap的Entry之间按照元素的put的先后顺序形成了双向循环链表，hashMap中元素与元素没有先后顺序，没法知道元素的put先后顺序，而linkedHashMap每次添加元素时都能通过header找到上一次添加的元素，通过after,和before记录当前元素前面的entry与后面的entry的联系。&lt;/p&gt;
&lt;h3&gt;LinkedHashMap和HashMap的结构的比较&lt;/h3&gt;
&lt;p&gt;linkedHashMap&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1446360/201807/1446360-20180724150440967-1526690409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HashMap&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1446360/201807/1446360-20180724150619350-1907531420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 24 Jul 2018 07:08:00 +0000</pubDate>
<dc:creator>kin1492</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kin1492/p/9360068.html</dc:identifier>
</item>
<item>
<title>Quartz实现JAVA定时任务的动态配置 - 小卖铺的老爷爷</title>
<link>http://www.cnblogs.com/laoyeye/p/9352002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoyeye/p/9352002.html</guid>
<description>&lt;p&gt;先说点无关本文的问题，这段时间特别的不爽，可能有些同学也遇到过。其实也可以说是小事一桩，但感觉也是不容忽视的。我刚毕业时的公司，每个人每次提交代码都有着严格的规范，像table和space的缩进都有严格的要求，可以说你不遵守开发规范就相当于线上bug问题，还是比较严重的。现在发现外面的公司真的是没那么重视这个不重要却又特别重要的问题啊，啊啊啊啊啊啊！！！&lt;/p&gt;

&lt;p&gt;回归正题，说下这次主题，动态配置。没接触过定时任务的同学可以先看下此篇：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/laoyeye/p/6530791.html&quot;&gt;JAVA定时任务实现的几种方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;定时任务实现方式千人千种，不过基础的无外乎 1、JDK 的Timer类 2、Quartz 3、SpringTask  。生产上三种方式我都有使用过。但是使用过程中用的最多的便是xml配置的方式，这种方式最简单，无代码侵入，也比较好理解。&lt;br/&gt;但是却有个致命的缺点，比如你要改某个任务的触发时间，亦或是你要新增一个任务，暂停一个任务。怎么做？&lt;br/&gt;停应用！改XML配置！重新启动！&lt;br/&gt;是不是很致命。最近重新研究了下Quartz的配置，实现了不停机添加、暂停、删除、立即触发任务的方法，在本篇分享出来，其实也不算是完全的研究，在上家公司已经有大佬实现了，这次是也是基于大佬的理解重新实现下。&lt;/p&gt;

&lt;p&gt;管理界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075594/201807/1075594-20180723212600580-771176423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 效果图：实在不知道该跑什么了，每隔十秒打一段话吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075594/201807/1075594-20180722234128778-631434944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;maven依赖&lt;/h3&gt;
&lt;p&gt;使用springboot做框架支持&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; quartz &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.quartz-scheduler&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;quartz&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.2.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-context-support&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;数据表&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `sys_task` (
  `id` &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `job_name` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;任务名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `description` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;任务描述&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `cron_expression` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cron表达式&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `bean_class` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;任务执行时调用哪个类的方法 包名+类名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `job_status` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;任务状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `job_group` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;任务分组&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `create_user` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建者&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `create_time` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `update_user` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;更新者&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `update_time` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;更新时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;MyISAM AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;实现步骤&lt;/h3&gt;
&lt;p&gt;①启动项目，启动task监听&lt;/p&gt;
&lt;p&gt;②读取数据库，将开启的任务job和trigger加载到scheduler调度器&lt;/p&gt;
&lt;p&gt;③根据任务调度运行job类&lt;/p&gt;
&lt;p&gt;④每次运行利用AdaptableJobFactory实例化job类，以便注入要运行的service&lt;/p&gt;
&lt;p&gt;听着是不是很简单，但却还是一头雾水，且听我慢慢道来~~&lt;/p&gt;
&lt;h3&gt; 代码逻辑&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一步：启动项目，加载监听&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Quartz配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Springboot的配置方法，常规Spring项目可以在xml中配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QuartzConfigration {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JobFactory jobFactory;

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SchedulerFactoryBean schedulerFactoryBean() {
        SchedulerFactoryBean schedulerFactoryBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SchedulerFactoryBean();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            schedulerFactoryBean.setOverwriteExistingJobs(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            schedulerFactoryBean.setQuartzProperties(quartzProperties());
            schedulerFactoryBean.setJobFactory(jobFactory);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; schedulerFactoryBean;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定quartz.properties，可在配置文件中配置相关属性&lt;/span&gt;
&lt;span&gt;    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Properties quartzProperties() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        PropertiesFactoryBean propertiesFactoryBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertiesFactoryBean();
        propertiesFactoryBean.setLocation(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;/config/quartz.properties&quot;&lt;span&gt;));
        propertiesFactoryBean.afterPropertiesSet();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; propertiesFactoryBean.getObject();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建schedule&lt;/span&gt;
    @Bean(name = &quot;scheduler&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Scheduler scheduler() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; schedulerFactoryBean().getScheduler();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;监听器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Order(value &lt;/span&gt;= 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ScheduleJobInitListener &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CommandLineRunner {

    @Autowired
    TaskService scheduleJobService;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; run(String... arg0) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            scheduleJobService.initSchedule();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;CommandLineRunner类似Spring框架的ApplicationListener监听器。官方的解释是:&lt;/span&gt;
&lt;/pre&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Interface used to indicate that a bean should run when it is contained within a SpringApplication. Multiple CommandLineRunner beans can be defined within the same application context and can be ordered using the Ordered interface or Order @Order annotation.&lt;br/&gt;接口被用作将其加入spring容器中时执行其run方法。多个CommandLineRunner可以被同时执行在同一个spring上下文中并且执行顺序是以order注解的参数顺序一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;strong&gt;第二步：读取数据库，加载scheduler调度器&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;job方法&lt;/p&gt;
&lt;div readability=&quot;44.017123886074&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initSchedule() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SchedulerException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里获取任务信息数据&lt;/span&gt;
        List&amp;lt;TaskDO&amp;gt; jobList =&lt;span&gt; taskMapper.list();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TaskDO task : jobList) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (JobStatusEnum.RUNNING.getCode().equals(task.getJobStatus())) {
                quartzManager.addJob(task);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加任务到Quartz调度器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加任务&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addJob(TaskDO task) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建jobDetail实例，绑定Job实现类
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指明job的名称，所在组的名称，以及绑定job类&lt;/span&gt;&lt;span&gt;
            Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Job&amp;gt; jobClass = (Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Job&amp;gt;&lt;span&gt;) (Class.forName(task.getBeanClass()).newInstance()
                    .getClass());
            JobDetail jobDetail &lt;/span&gt;= JobBuilder.newJob(jobClass).withIdentity(task.getJobName(), task.getJobGroup())&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务名称和组构成任务key&lt;/span&gt;
&lt;span&gt;                    .build();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义调度触发规则
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用cornTrigger规则&lt;/span&gt;
            Trigger trigger = TriggerBuilder.newTrigger().withIdentity(task.getJobName(), task.getJobGroup())&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发器key&lt;/span&gt;
                    .startAt(DateBuilder.futureDate(1&lt;span&gt;, IntervalUnit.SECOND))
                    .withSchedule(CronScheduleBuilder.cronSchedule(task.getCronExpression())).startNow().build();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把作业和触发器注册到任务调度中&lt;/span&gt;
&lt;span&gt;            scheduler.scheduleJob(jobDetail, trigger);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;scheduler.isShutdown()) {
                scheduler.start();
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Scheduler作为Quartz的核心调度器，有将近50多个API接口，包括任务的添加，暂停，恢复，删除等一系列的API，这里仅介绍一些常用的，想要了解更多可以稍后看下彩蛋部分。&lt;/p&gt;
&lt;p&gt;1、start()方法：只有调用start()方法后，Scheduler线程才开始启动触发器trigger，运行job&lt;/p&gt;
&lt;p&gt;2、pauseJob(JobKey jobKey) ：根据指定的JobDetail key暂停job。&lt;/p&gt;
&lt;p&gt;3、resumeJob(JobKey jobKey) ：根据指定的key恢复一个job。&lt;/p&gt;
&lt;p&gt;4、deleteJob(JobKey jobKey) ：删除一个job&lt;/p&gt;
&lt;p&gt;5、triggerJob(JobKey jobKey) ：触发一个JobDetail(现在执行)。&lt;/p&gt;
&lt;p&gt;6、rescheduleJob(TriggerKey triggerKey, Trigger newTrigger)：&lt;/p&gt;
&lt;div class=&quot;output-bd&quot; dir=&quot;ltr&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;用给定的键删除触发器，并存储新的触发器，它必须与同一个作业相关联（新触发器必须具有指定的作业名和组）-然而，新触发器不必具有与旧触发器相同的名称。&lt;/p&gt;
&lt;strong&gt;第三步：根据任务调度运行job类&lt;/strong&gt;&lt;br/&gt;其实这一步是不需要我们编写的，在我们将正确的JobDetail 和 Trigger 表达式加载到任务调度后，调度器会自动触发任务的执行&lt;/div&gt;

&lt;div class=&quot;output-bd&quot; dir=&quot;ltr&quot; readability=&quot;40.908954776879&quot;&gt;&lt;br/&gt;&lt;strong&gt;第四步：实例化job类，注入要运行的service&lt;/strong&gt;
&lt;p&gt;工厂类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JobFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AdaptableJobFactory {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个对象Spring会帮我们自动注入进来,也属于Spring技术范畴.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为什么需要这个类呢，在我写的这个demo中，大家可以将此类删掉，发现程序也可以正确运行，可是我为什么还是加上呢。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大家可以看下我们的任务类，大家可以看到Job对象的实例化过程是在Quartz中进行的，这时候我们将spring的东西注入进来，肯定是行不通的，所以需要这个类&lt;/span&gt;
&lt;span&gt;    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AutowireCapableBeanFactory capableBeanFactory;

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object createJobInstance(TriggerFiredBundle bundle) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用父类的方法&lt;/span&gt;
        Object jobInstance = &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.createJobInstance(bundle);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行注入&lt;/span&gt;
&lt;span&gt;        capableBeanFactory.autowireBean(jobInstance);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jobInstance;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;任务类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@DisallowConcurrentExecution &lt;span&gt;//&lt;/span&gt;&lt;span&gt;作业不并发&lt;/span&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HelloWorldJob &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Job{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; execute(JobExecutionContext arg0) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; JobExecutionException {
        
        System.out.println(&lt;/span&gt;&quot;欢迎使用yyblog,这是一个定时任务  --小卖铺的老爷爷!&quot;+ DateUtils.fullTime(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 好了，大功告成，一个简单的动态配置的定时任务已经完成。是不是so easy，下面我们再来简单实现下其他的几种常用的api吧。&lt;/p&gt;
&lt;p&gt;暂停一个job&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pauseJob(TaskDO task) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SchedulerException {
        JobKey jobKey &lt;/span&gt;=&lt;span&gt; JobKey.jobKey(task.getJobName(), task.getJobGroup());
        scheduler.pauseJob(jobKey);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;恢复一个job&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; resumeJob(TaskDO task) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SchedulerException {
        JobKey jobKey &lt;/span&gt;=&lt;span&gt; JobKey.jobKey(task.getJobName(), task.getJobGroup());
        scheduler.resumeJob(jobKey);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除一个job&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteJob(TaskDO task) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SchedulerException {
        JobKey jobKey &lt;/span&gt;=&lt;span&gt; JobKey.jobKey(task.getJobName(), task.getJobGroup());
        scheduler.deleteJob(jobKey);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;立即触发job&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; runJobNow(TaskDO task) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SchedulerException {
        JobKey jobKey &lt;/span&gt;=&lt;span&gt; JobKey.jobKey(task.getJobName(), task.getJobGroup());
        scheduler.triggerJob(jobKey);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新job表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updateJobCron(TaskDO task) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SchedulerException {

        TriggerKey triggerKey &lt;/span&gt;=&lt;span&gt; TriggerKey.triggerKey(task.getJobName(), task.getJobGroup());

        CronTrigger trigger &lt;/span&gt;=&lt;span&gt; (CronTrigger) scheduler.getTrigger(triggerKey);

        CronScheduleBuilder scheduleBuilder &lt;/span&gt;=&lt;span&gt; CronScheduleBuilder.cronSchedule(task.getCronExpression());

        trigger &lt;/span&gt;=&lt;span&gt; trigger.getTriggerBuilder().withIdentity(triggerKey).withSchedule(scheduleBuilder).build();

        scheduler.rescheduleJob(triggerKey, trigger);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好了，正文部分基本上就这些，不多废话了，本文没有太多的讲解原理，只是简单的应用，水平不够还望大家见谅。&lt;/p&gt;
&lt;p&gt;看了上面的效果图是不是还是有种看的见摸不着的感觉，老爷爷这里也做了个线上的实例供大家体验~有兴趣的同学可以亲自试验一下。&lt;/p&gt;
&lt;p&gt;实例地址：&lt;a href=&quot;http://www.laoyeye.net/management/index&quot; target=&quot;_blank&quot;&gt;http://www.laoyeye.net/management/index&lt;/a&gt;  账号/密码：test/123456  菜单：系统设置/计划任务&lt;/p&gt;
&lt;p&gt; 当然了还有最重要的源码和API文档我也不会忘的。&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/allanzhuo/yyblog&quot; target=&quot;_blank&quot;&gt;https://github.com/allanzhuo/yyblog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Quartz文档地址：&lt;a href=&quot;https://github.com/allanzhuo/yyblog/tree/master/doc&quot; target=&quot;_blank&quot;&gt;https://github.com/allanzhuo/yyblog/tree/master/doc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后的最后，看都看了，码字不易，顺手点个赞白~^_^&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 24 Jul 2018 05:36:00 +0000</pubDate>
<dc:creator>小卖铺的老爷爷</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoyeye/p/9352002.html</dc:identifier>
</item>
<item>
<title>【设计模式】工厂方法模式 Factory Method Pattern - 蓝之风</title>
<link>http://www.cnblogs.com/vaiyanzi/p/9359474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vaiyanzi/p/9359474.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/9336554.html&quot; target=&quot;_blank&quot;&gt;简单工厂模式&lt;/a&gt;中产品的创建统一在工厂类的静态工厂方法中创建，体现了面形对象的封装性，客户程序不需要知道产品产生的细节，也体现了面向对象的&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/6877436.html&quot; target=&quot;_blank&quot;&gt;单一职责原则（SRP)&lt;/a&gt;，这样在产品很少的情况下使用起来还是很方便， 但是如果产品很多，并且不断的有新产品加入，那么就会导致静态工厂方法变得极不稳定，每次加入一个新产品就要修改静态工厂方法，这违背了面向对象设计原则的&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/6894636.html&quot; target=&quot;_blank&quot;&gt;开闭原则（OCP）&lt;/a&gt;。那么在应对这种不断增加的新产品，简单工模式有些力不从心了，那么什么模式可以完美应对呢？这就是这篇文章要谈到的工厂方法模式。在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂类，系统提供一个与产品等级结构对应的工厂等级结构。&lt;/p&gt;
&lt;h2&gt;一、工厂方法模式定义&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;二、工厂方法模式结构图&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201807/15278-20180724133443013-721402324.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201807/15278-20180724133443460-642710512.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;467&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;工厂方法模式结构图&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.IProduct (抽象产品角色）：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;它是定义产品的接口，是工厂方法模式所创建对象的父类，也就是产品对象的公共父类，这个角色一般可以有抽象类或者接口来担当。&lt;/p&gt;
&lt;h3&gt;2.ConcreteProduct（具体产品）：&lt;/h3&gt;
&lt;p&gt;它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。&lt;/p&gt;
&lt;h3&gt;3.Factory（抽象工厂）：&lt;/h3&gt;
&lt;p&gt;在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建具体对象的具体工厂类都必须实现该接口。&lt;/p&gt;
&lt;h3&gt;4. ConcreteFactory（具体工厂）：&lt;/h3&gt;
&lt;p&gt;它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;三、工厂发发模式代码实现：&lt;/h2&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IProduct
{
    &lt;span&gt;void&lt;/span&gt; DoSomething();
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IFactory
{
    IProduct Create();
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteProductA : IProduct
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DoSomething()
    {
        Console.WriteLine(&quot;&lt;span&gt;I'm Product A&lt;/span&gt;&quot;);
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteProductB : IProduct
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DoSomething()
    {
        Console.WriteLine(&quot;&lt;span&gt;I'm Product B&lt;/span&gt;&quot;);
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteFactoryA : IFactory
{
    &lt;span&gt;public&lt;/span&gt; IProduct Create()
    {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ConcreteProductA();
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteFactoryB : IFactory
{
    &lt;span&gt;public&lt;/span&gt; IProduct Create()
    {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ConcreteProductB();
    }
}
&lt;/pre&gt;
&lt;p&gt;客户端调用：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main()
{
    &lt;span&gt;//使用ConcreteFactoryA 创建 ProductA&lt;/span&gt;
    IFactory factoryA = &lt;span&gt;new&lt;/span&gt; ConcreteFactoryA();
    IProduct productA = factoryA.Create();
    productA.DoSomething();

    &lt;span&gt;//使用ConcreteFactoryB 创建 ProductB&lt;/span&gt;
    IFactory factoryB = &lt;span&gt;new&lt;/span&gt; ConcreteFactoryB();
    IProduct productB = factoryB.Create();
    productB.DoSomething();

    Console.ReadKey();
}
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201807/15278-20180724133443726-1635906866.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201807/15278-20180724133444005-1756428977.png&quot; alt=&quot;image&quot; width=&quot;476&quot; height=&quot;120&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;四、重构音频播放器实例得到工厂方法模式&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/9336554.html&quot; target=&quot;_blank&quot;&gt;简单工厂模式&lt;/a&gt;中我们举了一个音频播放器的例子，开发人员从开始直接创建对象中逐步随着需求的改变最终得到了&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/9336554.html&quot; target=&quot;_blank&quot;&gt;简单工厂模式&lt;/a&gt;， 完美的解决了播放MP3，WAV，WMA格式的音频文件。最终代码看起来是这样：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IAudio
{
    &lt;span&gt;void&lt;/span&gt; Play(&lt;span&gt;string&lt;/span&gt; name);
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Wma : IAudio
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Play(&lt;span&gt;string&lt;/span&gt; name)
    {
        Console.WriteLine(&quot;&lt;span&gt;Start playing wma file...&lt;/span&gt;&quot;);
        Console.WriteLine($&quot;&lt;span&gt;The song name is: [{name}.wma]&lt;/span&gt;&quot;);
        Console.WriteLine(&quot;&lt;span&gt;..........&lt;/span&gt;&quot;);
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Wav : IAudio
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Play(&lt;span&gt;string&lt;/span&gt; name)
    {
        Console.WriteLine(&quot;&lt;span&gt;Start playing wav file...&lt;/span&gt;&quot;);
        Console.WriteLine($&quot;&lt;span&gt;The song name is: [{name}.wav]&lt;/span&gt;&quot;);
        Console.WriteLine(&quot;&lt;span&gt;..........&lt;/span&gt;&quot;);
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mp3 : IAudio
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Play(&lt;span&gt;string&lt;/span&gt; name)
    {
        Console.WriteLine(&quot;&lt;span&gt;Start playing mp3...&lt;/span&gt;&quot;);
        Console.WriteLine($&quot;&lt;span&gt;The song name is: [{name}.mp3]&lt;/span&gt;&quot;);
        Console.WriteLine(&quot;&lt;span&gt;..........&lt;/span&gt;&quot;);
    }
}


&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AudioFactory
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IAudio Create(&lt;span&gt;string&lt;/span&gt; songType)
    {
        IAudio audio;
        &lt;span&gt;switch&lt;/span&gt; (songType.ToUpper())
        {
            &lt;span&gt;case&lt;/span&gt; &quot;&lt;span&gt;A&lt;/span&gt;&quot;:
                audio = &lt;span&gt;new&lt;/span&gt; Wav();
                &lt;span&gt;break&lt;/span&gt;;
            &lt;span&gt;case&lt;/span&gt; &quot;&lt;span&gt;M&lt;/span&gt;&quot;:
                audio = &lt;span&gt;new&lt;/span&gt; Wma();
                &lt;span&gt;break&lt;/span&gt;;
            &lt;span&gt;case&lt;/span&gt; &quot;&lt;span&gt;P&lt;/span&gt;&quot;:
                audio = &lt;span&gt;new&lt;/span&gt; Mp3();
                &lt;span&gt;break&lt;/span&gt;;
            &lt;span&gt;default&lt;/span&gt;:
                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&quot;&lt;span&gt;Invalid argument&lt;/span&gt;&quot;, nameof(songType));
        }

        &lt;span&gt;return&lt;/span&gt; audio;
    }
}

[Description(&quot;&lt;span&gt;1.2. Simple Factory&lt;/span&gt;&quot;)]
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; App
{
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main()
    {
        Console.WriteLine(&quot;&lt;span&gt;Please input a or m or p&lt;/span&gt;&quot;);
        var input = Console.ReadKey();
        &lt;span&gt;if&lt;/span&gt; (input != &lt;span&gt;null&lt;/span&gt;)
        {
            IAudio audio = AudioFactory.Create(input.Key.ToString());
            audio.Play(&quot;&lt;span&gt;take me to your hert&lt;/span&gt;&quot;);
        }

        Console.ReadKey();
    }
}
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201807/15278-20180724133444283-1468260076.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201807/15278-20180724133444577-296835463.png&quot; alt=&quot;image&quot; width=&quot;476&quot; height=&quot;122&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看起来很不错，完美的解决了播放WMA，WAV和MP3 格式的音频文件，但是音乐文件的格式不断在发展增多，因此播放器也要通过不断的升级来支持不断涌现的新格式的音频文件。 甲方已经提出来了支持MPEG， MPEG-4 等等格式的文件，每次开发人员都要新增一个具体的音频格式的类，并且在工厂的静态方法中创建一个case条件来支持新的格式文件。日积月累，随着时间的推移，swich case 的逻辑变得异常的庞大和复杂，很难维护了，这不，最近甲方提出来要支持acc格式文件的播放，这次升级终于是产生了一次事故， 开发人员从甲方哪里拿到要支持acc音频格式的文件需求，轻车熟路创建了个acc的产品文件类，但是忘记在swich case 中加这个case就将代码编译打包提交给甲方。由于甲方和开发人员过去每次配合的都很好，这一次他就绝对的信任了开发人员，于是没有测试新的版本就直接发布到市场上投入了商业使用。结果可想而知根本就播放不了acc格式的音频文件。 甲方知道此事后很生气，勒令开发人员立马修复bug重新发布版本，但是市场是瞬息万变的，就因为这么一个失误的发布，市场上的竟品软件就很快蚕食了甲方播放器的市场。开发人员不敢怠慢，加班加点，找出bug并修复重新打包交付甲方，甲方赶紧将新版本经过充分测试后投入到市场。&lt;/p&gt;
&lt;p&gt;随后开发人员准备找出容易出现这种错误原因，将这种犯错的机会扼杀在摇篮。除了自身的粗心之外，他还想从代码上找到一些原因。于是他Review了一下自己的代码， 他发现工厂类中的静态工厂方法的逻辑太复杂了，翻滚了好几个屏幕，看了一个多小时才把这里面的代码理顺看清楚了， 看完后发发现静态工厂方法的职责随着产品的增多在不断的增多， 工厂方法的负担太重了， 他决定重构这个地方的代码，他期望将创建具体产品的职责单提取到独的一个类中来完成，一个类负责一个具体产品的创建，于是他提出了个这个创建具体产品的抽象接口IFactory， 然后让具体创建类都继承自这个接口， 通过重构代码，现在音频播放器的代码变成了这样：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IAudio
{
    &lt;span&gt;void&lt;/span&gt; Play(&lt;span&gt;string&lt;/span&gt; name);
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IFactory
{
    IAudio Create();
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Wma : IAudio
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Play(&lt;span&gt;string&lt;/span&gt; name)
    {
        Console.WriteLine(&quot;&lt;span&gt;Start playing wma file...&lt;/span&gt;&quot;);
        Console.WriteLine($&quot;&lt;span&gt;The song name is: [{name}.wma]&lt;/span&gt;&quot;);
        Console.WriteLine(&quot;&lt;span&gt;..........&lt;/span&gt;&quot;);
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Wav : IAudio
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Play(&lt;span&gt;string&lt;/span&gt; name)
    {
        Console.WriteLine(&quot;&lt;span&gt;Start playing wav file...&lt;/span&gt;&quot;);
        Console.WriteLine($&quot;&lt;span&gt;The song name is: [{name}.wav]&lt;/span&gt;&quot;);
        Console.WriteLine(&quot;&lt;span&gt;..........&lt;/span&gt;&quot;);
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mp3 : IAudio
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Play(&lt;span&gt;string&lt;/span&gt; name)
    {
        Console.WriteLine(&quot;&lt;span&gt;Start playing mp3...&lt;/span&gt;&quot;);
        Console.WriteLine($&quot;&lt;span&gt;The song name is: [{name}.mp3]&lt;/span&gt;&quot;);
        Console.WriteLine(&quot;&lt;span&gt;..........&lt;/span&gt;&quot;);
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Acc : IAudio
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Play(&lt;span&gt;string&lt;/span&gt; name)
    {
        Console.WriteLine(&quot;&lt;span&gt;Start playing Acc...&lt;/span&gt;&quot;);
        Console.WriteLine($&quot;&lt;span&gt;The song name is: [{name}.acc]&lt;/span&gt;&quot;);
        Console.WriteLine(&quot;&lt;span&gt;..........&lt;/span&gt;&quot;);
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WmaFactory : IFactory
{
    &lt;span&gt;public&lt;/span&gt; IAudio Create()
    {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Wma();
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WavFactory : IFactory
{
    &lt;span&gt;public&lt;/span&gt; IAudio Create()
    {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Wav();
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mp3Factory : IFactory
{
    &lt;span&gt;public&lt;/span&gt; IAudio Create()
    {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Mp3();
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccFactory : IFactory
{
    &lt;span&gt;public&lt;/span&gt; IAudio Create()
    {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Acc();
    }
}

[Description(&quot;&lt;span&gt;2.1. Factory Mothed payer&lt;/span&gt;&quot;)]
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; App
{
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main()
    {
        &lt;span&gt;//Wma play&lt;/span&gt;
        IFactory wmaFactory = &lt;span&gt;new&lt;/span&gt; WmaFactory();
        IAudio wamAudio = wmaFactory.Create();
        wamAudio.Play(&quot;&lt;span&gt;take me to your hert&lt;/span&gt;&quot;);
        &lt;span&gt;//Wav play&lt;/span&gt;
        IFactory wavFactory = &lt;span&gt;new&lt;/span&gt; WavFactory();
        IAudio wavAudio = wavFactory.Create();
        wavAudio.Play(&quot;&lt;span&gt;take me to your hert&lt;/span&gt;&quot;);
        &lt;span&gt;//Mp3 play&lt;/span&gt;
        IFactory mp3Factory = &lt;span&gt;new&lt;/span&gt; Mp3Factory();
        IAudio mp3Audio = mp3Factory.Create();
        mp3Audio.Play(&quot;&lt;span&gt;take me to your hert&lt;/span&gt;&quot;);
        &lt;span&gt;//Acc play&lt;/span&gt;
        IFactory accFactory = &lt;span&gt;new&lt;/span&gt; AccFactory();
        IAudio accAudio = accFactory.Create();
        accAudio.Play(&quot;&lt;span&gt;take me to your hert&lt;/span&gt;&quot;);

        Console.ReadKey();
    }
}
&lt;/pre&gt;
&lt;p&gt;运行软件输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201807/15278-20180724133444873-308521767.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201807/15278-20180724133445405-1160832023.png&quot; alt=&quot;image&quot; width=&quot;476&quot; height=&quot;201&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码重构完成，结构符合预期，在回过头来Review 一下代码，这不就是Factory Method Pattern吗？ 这样开发人员就将这种场景下的代码构造的比较合理了。甲方再增加新的音频文件格式时，就很容易应对了，只需要创建一个具体产品并且再创建一个具体的工厂类来创建这个产品就可以了。这样软件更符合面向对象设计原则的&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/6877436.html&quot; target=&quot;_blank&quot;&gt;SRP&lt;/a&gt; 和&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/6894636.html&quot; target=&quot;_blank&quot;&gt;OCP&lt;/a&gt;原则了。&lt;/p&gt;
&lt;p&gt;下来问题来了， 如果甲方提出需要这个播放器软件支持视频播放，开发人员应该怎么办能？ 那么 随着学习其他模式就能找到更合理的答案。&lt;/p&gt;
&lt;h2&gt;五、工厂方法模式的优点：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。&lt;/li&gt;
&lt;li&gt;基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。&lt;/li&gt;
&lt;li&gt;使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性和灵活性也就变得非常好，维护起来就变得简单了，完全符合“&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/6894636.html&quot; target=&quot;_blank&quot;&gt;开闭原则（OCP）&lt;/a&gt;”。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;六、工厂方法模式的缺点：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。&lt;/li&gt;
&lt;li&gt;由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到反射等技术，增加了系统的实现难度。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;七、工厂方法模式的使用场景：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。&lt;/li&gt;
&lt;li&gt;抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。有了这么一个特点， 我们可以在软件的运行时改变系统的功能，进而实现热插拔。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 24 Jul 2018 05:35:00 +0000</pubDate>
<dc:creator>蓝之风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vaiyanzi/p/9359474.html</dc:identifier>
</item>
</channel>
</rss>