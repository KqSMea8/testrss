<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>架构师入门：Spring Cloud系列，Hystrix与Eureka的整合 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/9874631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/9874631.html</guid>
<description>&lt;p&gt;    和Ribbon等组件一样，在项目中，Hystrix一般不会单独出现，而是会和Eureka等组件配套出现。在Hystrix和Eureka整合后的框架里，一般会用到Hystrix的断路器以及合并请求等特性，而在Web框架里，大多会有专门的缓存组件，所以不怎么会用到Hystrix的缓存特性。&lt;/p&gt;
&lt;h4&gt;1 准备Eureka服务器项目&lt;/h4&gt;
&lt;p&gt;    HystrixEurekaServer项目承担着Eureka服务器的作用，这部分的代码关键点如下。&lt;/p&gt;
&lt;p&gt;    第一，在pom.xml里，通过如下关键代码引入Eureka服务器组件的依赖包。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1    &amp;lt;dependency&amp;gt;
2        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
3        &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt;
4    &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    第二，在application.yml里，指定了本项目的主机名和端口号，并指定了对外提供eureka服务的Url路径，代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;    server:
&lt;/span&gt;2      port: 8888
3&lt;span&gt;    eureka:
&lt;/span&gt;4&lt;span&gt;      instance:
&lt;/span&gt;5&lt;span&gt;        hostname: localhost
&lt;/span&gt;6&lt;span&gt;      client:
&lt;/span&gt;7        register-with-eureka: &lt;span&gt;false&lt;/span&gt;
8        fetch-registry: &lt;span&gt;false&lt;/span&gt; 
9&lt;span&gt;        serviceUrl:
&lt;/span&gt;10          defaultZone: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8888/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    第三，在ServerStarter.java里，编写启动Eureka服务的代码，这里请注意，在第2和第3行里，通过注解声明了本类是Eureka服务器的启动类。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import的代码&lt;/span&gt;
2&lt;span&gt;    @EnableEurekaServer
&lt;/span&gt;3&lt;span&gt;    @SpringBootApplication
&lt;/span&gt;4    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServerStarter 
&lt;/span&gt;5&lt;span&gt;    {
&lt;/span&gt;6          &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
&lt;/span&gt;7        {      SpringApplication.run(ServerStarter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);  }
&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2 服务提供者的代码结构&lt;/h4&gt;
&lt;p&gt;    HystrixEurekaserviceProvider项目承担着Eureka服务提供者的角色。在pom.xml里，我们除了指定Eureka的依赖包以外，还了指定了Hystrix的依赖包，关键代码如下。其中，前4行指定的是Eureka的依赖包，后4行指定的是Hystrix的依赖包。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1    &amp;lt;dependency&amp;gt;
2            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
3            &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
4    &amp;lt;/dependency&amp;gt;
5    &amp;lt;dependency&amp;gt;
6            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
7            &amp;lt;artifactId&amp;gt;spring-cloud-starter-hystrix&amp;lt;/artifactId&amp;gt;
8   &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   而在application.yml里，指定了本项目的服务端口是1111，对外提供的项目名是hystrixEureka，以及是向第一部分指定的Eureka服务器注册，代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;    server:
&lt;/span&gt;2      port: 1111
3&lt;span&gt;    spring:
&lt;/span&gt;4&lt;span&gt;      application:
&lt;/span&gt;5&lt;span&gt;        name: hystrixEureka
&lt;/span&gt;6&lt;span&gt;    eureka:  
&lt;/span&gt;7&lt;span&gt;      client:
&lt;/span&gt;8&lt;span&gt;        serviceUrl:
&lt;/span&gt;9          defaultZone: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8888/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3 在服务提供者项目里引入断路器机制&lt;/h4&gt;
&lt;p&gt;     在服务提供者的启动类ServiceProviderApp.java里，我们是通过加入@EnableCircuitBreaker注解来启动断路器，代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import代码&lt;/span&gt;
2&lt;span&gt;    @SpringBootApplication
&lt;/span&gt;3&lt;span&gt;    @EnableEurekaClient
&lt;/span&gt;4&lt;span&gt;    @EnableCircuitBreaker
&lt;/span&gt;5&lt;span&gt;    @ServletComponentScan
&lt;/span&gt;6    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceProviderApp 
&lt;/span&gt;7&lt;span&gt;    {
&lt;/span&gt;8        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
&lt;/span&gt;9        {     SpringApplication.run(ServiceProviderApp.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);  }
&lt;/span&gt;10    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在Controller.java这个控制器类里，我们是在第9行里，通过调用service类提供的方法来返回具体的OrderDetail信息，代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import代码&lt;/span&gt;
2&lt;span&gt;    @RestController
&lt;/span&gt;3    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Controller {
&lt;/span&gt;4&lt;span&gt;            @Autowired
&lt;/span&gt;5        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; OrderDetailService service;   
&lt;/span&gt;6        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对外提供服务的getOrderDetailById方法 &lt;/span&gt;
7            @RequestMapping(value = &quot;/getOrderDetailById/{orderId}&quot;, method =&lt;span&gt; RequestMethod.GET)
&lt;/span&gt;8            &lt;span&gt;public&lt;/span&gt; OrderDetail getOrderDetailById(@PathVariable(&quot;orderId&quot;)   String orderId) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;9            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; service.getOrderDetailByID(orderId);
&lt;/span&gt;10&lt;span&gt;        }
&lt;/span&gt;11    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在OrderDetailService.java里，我们用HashMap这个数据结构来模拟数据库，以此来模拟从数据库读OrderDetail的方式，提供了“根据ID找相应对象的服务”，代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import代码&lt;/span&gt;
2&lt;span&gt;    @Service
&lt;/span&gt;3    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderDetailService {
&lt;/span&gt;4        &lt;span&gt;static&lt;/span&gt; HashMap&amp;lt;String,String&amp;gt; orderDB = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String,String&amp;gt;&lt;span&gt; ();
&lt;/span&gt;5        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过static代码，模拟数据库中存储的OrderDetail信息&lt;/span&gt;
6&lt;span&gt;        {
&lt;/span&gt;7            orderDB.put(&quot;1&quot;,&quot;Peter&quot;&lt;span&gt;);
&lt;/span&gt;8            orderDB.put(&quot;2&quot;,&quot;Tom&quot;&lt;span&gt;);
&lt;/span&gt;9            orderDB.put(&quot;3&quot;,&quot;Mike&quot;&lt;span&gt;);
&lt;/span&gt;10&lt;span&gt;        }
&lt;/span&gt;11    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在方法之前，通过注解引入Hystrix，并指定回退方法&lt;/span&gt;
12        @HystrixCommand(fallbackMethod = &quot;getFallback&quot;&lt;span&gt;)
&lt;/span&gt;13        &lt;span&gt;public&lt;/span&gt; OrderDetail getOrderDetailByID(String id) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;14&lt;span&gt;        {
&lt;/span&gt;15            OrderDetail orderDetail = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderDetail();        
&lt;/span&gt;16            &lt;span&gt;if&lt;/span&gt;(&quot;error&quot;.equals(id) ) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果输入是error，则故意抛出异常&lt;/span&gt;
17            {&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Exception(); }
&lt;/span&gt;18            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟地从数据库里得到信息并返回&lt;/span&gt;
19&lt;span&gt;            orderDetail.setOrderId(id);
&lt;/span&gt;20&lt;span&gt;            orderDetail.setOrderOwner(orderDB.get(id));
&lt;/span&gt;21            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderDetail;
&lt;/span&gt;22&lt;span&gt;        }
&lt;/span&gt;23        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义Hystrix的回退方法&lt;/span&gt;
24        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OrderDetail getFallback(String orderId) {
&lt;/span&gt;25            OrderDetail orderDetail = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderDetail();
&lt;/span&gt;26            orderDetail.setOrderId(&quot;error&quot;&lt;span&gt;);
&lt;/span&gt;27            orderDetail.setOrderOwner(&quot;error&quot;&lt;span&gt;);        
&lt;/span&gt;28            System.out.println(&quot;In fallbackForOrderDetail function&quot;&lt;span&gt;);    
&lt;/span&gt;29            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderDetail;
&lt;/span&gt;30&lt;span&gt;        }
&lt;/span&gt;31    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在第13行的getOrderDetailByID方法之前，我们在第12行通过fallbackMethod定义了回退方法，在这个方法的第16行里，我们定义了如果输入是error，那么则将抛出异常，以此触发回退方法getFallback。而在第24行定义的回退方法里，我们将返回一个ID和Owner都是error的OrderDetail对象。本类用到的OrderDetail模型类定义如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderDetail{
&lt;/span&gt;2           &lt;span&gt;private&lt;/span&gt; String orderId;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订单id&lt;/span&gt;
3         &lt;span&gt;private&lt;/span&gt; String orderOwner; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;订单所有人 &lt;/span&gt;
4        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的get和set方法&lt;/span&gt;
5    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    至此我们完成了开发工作，启动HystrixEurekaServer和HystrixEurekaserviceProvider后，如果在浏览器中输入&lt;a href=&quot;http://localhost:1111/getOrderDetailById/1&quot;&gt;http://localhost:1111/getOrderDetailById/1&lt;/a&gt;，能看到如下的输出，这说明走的是正常的流程。&lt;/p&gt;
&lt;p class=&quot;2&quot;&gt;{&quot;orderId&quot;:&quot;1&quot;,&quot;orderOwner&quot;:&quot;Peter&quot;}&lt;/p&gt;
&lt;p&gt;    但如果输入的是&lt;a href=&quot;http://localhost:1111/getOrderDetailById/error&quot;&gt;http://localhost:1111/getOrderDetailById/error&lt;/a&gt;，那么会在OrderDetailService类的getOrderDetailByID方法里抛出异常，从而走Hystrix的回退流程，由此会输入如下的语句。&lt;/p&gt;
&lt;p class=&quot;2&quot;&gt;        {&quot;orderId&quot;:&quot;error&quot;,&quot;orderOwner&quot;:&quot;error&quot;}&lt;/p&gt;
&lt;p&gt;    在这个案例中，我们是在“提供者服务”的模块引入hytrix断路器，而不是在“服务调用”模块，这和项目中的常规做法相符，因为启动断路器的场景一般是“提供服务模块的流量超载”。&lt;/p&gt;
&lt;p&gt;    本人之前写的和本文有关的Spring Cloud其它相关文章。&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/9557991.html&quot;&gt;Hystrix针对不可用服务的保护机制以及引入缓存&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a id=&quot;PostsList1_rpPosts_TitleUrl_1&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/9399209.html&quot;&gt;通过案例了解Hystrix的各种基本使用方式&lt;/a&gt; &lt;/p&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postText2&quot;&gt; &lt;a id=&quot;PostsList1_rpPosts_TitleUrl_2&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/8999772.html&quot;&gt;Ribbon整合Eureka组件，以实现负载均衡&lt;/a&gt; &lt;span class=&quot;postDesc2&quot;&gt; &lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postText2&quot;&gt; &lt;a id=&quot;PostsList1_rpPosts_TitleUrl_3&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/8648420.html&quot;&gt;Spring Clould负载均衡重要组件：Ribbon中重要类的用法&lt;/a&gt; &lt;span class=&quot;postDesc2&quot;&gt; &lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postText2&quot;&gt; &lt;a id=&quot;PostsList1_rpPosts_TitleUrl_4&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/8481756.html&quot;&gt;架构师入门：搭建双注册中心的高可用Eureka架构（基于项目实战）&lt;/a&gt; &lt;span class=&quot;postDesc2&quot;&gt; &lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postText2&quot;&gt; &lt;a id=&quot;PostsList1_rpPosts_TitleUrl_5&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/8471364.html&quot;&gt;架构师入门：搭建基本的Eureka架构（从项目里抽取）&lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt; &lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postText2&quot;&gt; &lt;a id=&quot;PostsList1_rpPosts_TitleUrl_6&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/8468934.html&quot;&gt;借助Maven入手Spring Boot第一个程序&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Mon, 29 Oct 2018 23:24:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<og:description>和Ribbon等组件一样，在项目中，Hystrix一般不会单独出现，而是会和Eureka等组件配套出现。在Hystrix和Eureka整合后的框架里，一般会用到Hystrix的断路器以及合并请求等特性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/9874631.html</dc:identifier>
</item>
<item>
<title>基于vue2.0实现仿百度前端分页效果（二） - fozero</title>
<link>http://www.cnblogs.com/fozero/p/9874334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fozero/p/9874334.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;上篇文章中，已经使用vue实现前端分页效果，这篇文章我们单独将分页抽离出来实现一个分页组件&lt;/p&gt;
&lt;p&gt;先看实现效果图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/871647/201810/871647-20181030004752528-1469683860.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;按照惯例，我们在冻手实现的时候还是先想一想vue实现组件的思路&lt;/p&gt;
&lt;p&gt;1、需要提前设定哪些参数需要暴露出来给父组件传递&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Paging 
      :name=&quot;name&quot;
      @change=&quot;onPageChange&quot;
      :page-size=&quot;size&quot;
      :total=&quot;total&quot;
      layout=&quot;jumper,total&quot;
      :current-page=&quot;curPage&quot;
    /&amp;gt;


方法及参数说明
属性 
page-size 每页显示条目个数
total 总条目数
current-page 当前页数
layout 布局 默认不显示 jumper,total

事件
change 当前页改变时触发&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、再一个就是涉及到的父子组件通信&lt;/p&gt;
&lt;p&gt;这里主要通过props向子组件传递参数&lt;br/&gt;在子组件中使用emit自定义事件返回数据给父组件&lt;/p&gt;
&lt;p&gt;a.字符串数组形式props&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
或者指定每个prop的值类型
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;b.props验证&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;props: {
    // 基础的类型检查 (`null` 匹配任何类型)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用props传递数据给子组件 ，子组件主要有三种形式来接收到父组件传递过来的参数&lt;br/&gt;props字符串数组、指定每个prop值类型以及props验证，通常我们会使用props验证&lt;/p&gt;
&lt;p&gt;分析完之后，接下来我们可以冻手实现了&lt;/p&gt;
&lt;p&gt;1、这里我们用vue-cli先创建一个vue项目&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;安装vue-cli
$npm install -g vue-cli

创建vue项目
$vue init webpack my-project

项目运行
$cd my-project
$npm run dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在components文件下创建一个Paging组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;paging clearfix&quot;&amp;gt;
     &amp;lt;div class=&quot;page-size fl&quot; v-if=&quot;isShowTotal&quot;&amp;gt;共{{total}}条&amp;lt;/div&amp;gt;
       &amp;lt;ul class=&quot;page-list fl clearfix&quot;&amp;gt;
            &amp;lt;li @click=&quot;changePage(currentPage-1)&quot;&amp;gt;上一页&amp;lt;/li&amp;gt;
            &amp;lt;li :class=&quot;{'active':currentPage==item.val}&quot; v-for=&quot;item in pagelist&quot; v-text=&quot;item.text&quot; @click=&quot;changePage(item.val)&quot;&amp;gt;1&amp;lt;/li&amp;gt;
            &amp;lt;li @click=&quot;changePage(currentPage+1)&quot;&amp;gt;下一页&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
        &amp;lt;div class=&quot;page-jump fl&quot; v-if=&quot;isShowJumper&quot;&amp;gt;
            前往&amp;lt;input class=&quot;input&quot; type=&quot;text&quot; v-model=&quot;toPage&quot; @keydown=&quot;submit(toPage,$event)&quot;&amp;gt;页
            &amp;lt;!-- &amp;lt;button  @click=&quot;changePage(toPage)&quot;&amp;gt;确定&amp;lt;/button&amp;gt; --&amp;gt;
        &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  name: 'Paging',
  // props:[
  //    'name'
  // ],
  // prop验证
  props:{
    name:String,
    pageSize: {
      type: Number,
      default: 10
    },
    total: {
      type: Number,
      default: 0
    },
    currentPage: {
      type: Number,
      default: 1
    },
    layout:{
        type: String
    }
  },
  data () {
    return {
            isShowJumper:false,
            isShowTotal:false,
        toPage:'',//跳转到x页
            pageGroup:10//可见分页数量 默认10个分页数
    }
  },
  created: function () {
        console.log('created');
        this.isShowTotal = this.layout.indexOf('total')!==-1;
        this.isShowJumper = this.layout.indexOf('jumper')!==-1;
    },
    mounted: function () {
        console.log('mounted',this.layout);
    },
    computed:{
        totalPage:function(){
            return Math.ceil(this.total / this.pageSize)
        },
        pagelist:function(){
            var list = [];
            var count = Math.floor(this.pageGroup/2), center = this.currentPage;
            var left = 1,right = this.totalPage;

            if(this.totalPage&amp;gt;this.pageGroup){
                if(this.currentPage&amp;gt;count+1){
                    if(this.currentPage &amp;lt; this.totalPage - count){
                        left = this.currentPage - count;
                        right = this.currentPage + count-1;
                    }else{
                        left = this.totalPage - this.pageGroup+1;
                    }
                }else{
                    right = this.pageGroup;
                }
            }

            // 遍历添加到数组里
            while(left&amp;lt;=right){
                list.push({
                    text:left,
                    val:left
                });
                left++;
            }
            return list;
        }
    },
  methods:{
    // 回车事件
    submit(toPage,e){
        // console.log('e.keyCode',toPage,e.keyCode)
        // key.Code === 13表示回车键 
        if(e.keyCode === 13){
            //逻辑处理
            this.changePage(toPage);
        }
    },
    changePage:function(idx){
        if(idx!=this.currentPage &amp;amp;&amp;amp; idx&amp;gt;0 &amp;amp;&amp;amp; idx&amp;lt;=this.totalPage){
            // 触发父组件事件  pageChange会转换成小写pagechange
            this.$emit('change',{curPage:Number(idx)});
            }
    }
    }
}
&amp;lt;/script&amp;gt;

&amp;lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&amp;gt;
&amp;lt;style scoped&amp;gt;
*{
        padding: 0;
        margin: 0;
}
.fl{
    float: left;
}
.clearfix:after{
    display: block;
    content: '';
    clear: both;
}
.page-size{
        height: 26px;
    line-height: 26px;
}
.page-list{

}
.page-jump{
        height: 26px;
    line-height: 26px;
    margin-left: 20px;
}
.page-jump .input{
    width: 32px;
        padding: 4px 2px;
    border-radius: 2px;
    border: 1px solid #dcdfe6;
    margin: 0 4px;
}
    ul{
        list-style: none;
    }
    ul li{
        float: left;
        color: #606266;
        background: #f4f4f5;
        padding: 2px 8px;
        cursor: pointer;
        border-radius: 2px;
        margin: 0 5px;
    }
    ul&amp;gt;li.active{
        background: #409eff;
        color:#fff;
    }
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、在父组件中引入并使用组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;!-- 分页组件 --&amp;gt;
    &amp;lt;Paging 
      :name=&quot;name&quot;
      @change=&quot;onPageChange&quot;
      :page-size=&quot;size&quot;
      :total=&quot;total&quot;
      layout=&quot;jumper,total&quot;
      :current-page=&quot;curPage&quot;
    /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;


&amp;lt;!-- 
Paging属性 
page-size 每页显示条目个数
total 总条目数
current-page 当前页数
layout 布局 默认不显示 jumper,total

Paging事件
change 当前页改变时触发
 --&amp;gt;
&amp;lt;script&amp;gt;

import Paging from '@/components/Paging';
export default {
  name: 'Index',
  components:{
    Paging
  },
  data () {
    return {
      msg: 'hello',
      name:'阿健a',
      size:10,
      total:201,
      curPage:1
    }
  },
  methods:{
    onPageChange:function(page){
      this.curPage = page.curPage;
    }
  }
}
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;遇到的问题&quot;&gt;遇到的问题&lt;/h3&gt;
&lt;p&gt;1、在子组件中修改currentPage时报错&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用组件时，传入的prop，被组件内部又做了一次修改&lt;br/&gt;避免直接修改prop，因为当父组件重新呈现时，值将被覆盖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;changePage:function(idx){
        if(idx!=this.currentPage &amp;amp;&amp;amp; idx&amp;gt;0 &amp;amp;&amp;amp; idx&amp;lt;=this.totalPage){
            this.currentPage = idx;
            // 触发父组件事件  pageChange会转换成小写pagechange
            this.$emit('change');
            }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决&lt;br/&gt;修改代码，通过emit传递curPage给父组件，让父组件修改&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;changePage:function(idx){
        if(idx!=this.currentPage &amp;amp;&amp;amp; idx&amp;gt;0 &amp;amp;&amp;amp; idx&amp;lt;=this.totalPage){
            // 触发父组件事件  pageChange会转换成小写pagechange
            this.$emit('change',{curPage:idx});
            }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;父组件监听事件更新curPage&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onPageChange:function(page){
      this.curPage = page.curPage;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;以上就是分页组件的整个实现过程 ，其实只要搞清楚父子组件是如何传参的，以及我们实现一个组件需要暴露哪些参数给父组件，整个实现过程还是不难的&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 16:49:00 +0000</pubDate>
<dc:creator>fozero</dc:creator>
<og:description>前言 上篇文章中，已经使用vue实现前端分页效果，这篇文章我们单独将分页抽离出来实现一个分页组件 先看实现效果图 代码实现 按照惯例，我们在冻手实现的时候还是先想一想vue实现组件的思路 1、需要提前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fozero/p/9874334.html</dc:identifier>
</item>
<item>
<title>听说你还不会用Dagger2？Dagger2 For Android最佳实践教程 - tangpj</title>
<link>http://www.cnblogs.com/tangpj/p/9874133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangpj/p/9874133.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Tangpj/MarkdownRes/master/mBlog/dagger2/dagger_for_android_cover.jpg&quot; alt=&quot;Material Render Phone&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Dagger2是现在非常火的一个依赖注入框架，目前由Google维护，在Github上面已经有12K star了。Dagger2的入门门槛其实是比较高的，据了解，目前有很多Android工程师对Dagger2还不甚了解，没有用上Dagger2或者是用法有问题，本文的主旨就是让Android工程师快速掌握Dagger2并且优雅简洁地使用Dagger2。这里为大家奉上一份Dagger2 在Android上的最佳实践教程。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Dagger2框架的上手难度是比一般的框架更难一些的，所以在练习的时候应该尽量减少干扰因素，尽量少引入其它复杂的第三方库，最佳做法是只依赖Android基础库和Dagger2 For Android需要的库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其它技术文章推荐&quot;&gt;其它技术文章推荐&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://tangpj.com/2018/09/29/calces-screen/&quot;&gt;给你一个全自动的屏幕适配方案（基于SW方案）！—— 解放你和UI的双手&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tangpj.com/2018/07/22/calces-componentization/&quot;&gt;Gradle自动实现Android组件化模块构建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Tangpj/Android-advanced-blueprint&quot;&gt;技术教程Demo地址（本文的Demo也在里面哟）👍&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Tangpj/calces-gradle-plugin&quot;&gt;你的支持，是我前进的动力，如果我的项目对您有帮助的话，可以点下star👍&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;依赖注入&quot;&gt;依赖注入&lt;/h2&gt;
&lt;h3 id=&quot;什么是依赖注入&quot;&gt;什么是依赖注入？&lt;/h3&gt;
&lt;p&gt;维基百科上面的介绍是：在软件工程中，依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。&lt;/p&gt;
&lt;p&gt;简单来说依赖注入就是将实例对象传入到另一个对象中去。&lt;/p&gt;
&lt;h3 id=&quot;依赖注入的实现&quot;&gt;依赖注入的实现&lt;/h3&gt;
&lt;p&gt;维基百科的说法非常抽象，其实在平常编码中，我们一直都在使用以来注入。依赖注入主要有以下几种方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构造函数注入&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Chef{
    Menu menu;
    public Man(Menu menu){
        this.menu = menu;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;setter方法注入&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Chef{
    Menu menu;
    public setMenu(Menu menu){
        this.menu = menu;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;接口注入&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface MenuInject{
    void injectMenu(Menu menu);
}

public class Chef implements MenuInject{
    Menu menu;
    
    @Override
    public injectMenu(Menu menu){
        this.menu = menu;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;依赖注入框架&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public @Inject class Menu{
    ...
}

public class Chef{
    @Inject
    Menu menu;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的例子可以看出，依赖注入其实就是我们天天都在用的东西。&lt;/p&gt;
&lt;h2 id=&quot;dagger2实现依赖注入&quot;&gt;Dagger2实现依赖注入&lt;/h2&gt;
&lt;h3 id=&quot;为什么要使用dagger2&quot;&gt;为什么要使用Dagger2？&lt;/h3&gt;
&lt;p&gt;从上面这个简单的例子来看，为了实现依赖注入，好像没必要引入第三方的框架。在只有一个人开发，并且业务像上面这么简单的时候，确实是没必要引入Dagger2。但是如果多人同时开发，并且业务非常复杂呢？例如，我们这里的Menu需要初始化，而菜单也要依赖具体的菜式的呢？如果只是一个地方用到的话，还是能接受的。如果项目中有很多地方同时用到呢？如果这个菜单要修改呢？有经验的开发者可能会想到使用单例模式。但是如果项目中有很多类型的结构的话，那么我们就需要管理非常多的单例，并且单例可能也需要依赖其它对象。在这种情况下如果有变更需求或者是更换维护人员，都会使简单的改动变得非常繁琐，并且容易导致各种各样的奇怪BUG。所以这里我们就需要引入第三方的依赖注入工具，让这个工具来帮助我们实现依赖注入。&lt;/p&gt;
&lt;p&gt;Dagger2就是我们需要的第三方依赖注入工具。Dagger2较其它依赖注入工具有一个优势，就是它是采用静态编译的方式编译代码的，会在编译期生成好辅助代码，不会影响运行时性能，这一点非常适合用于移动端。&lt;/p&gt;
&lt;h3 id=&quot;dagger2的使用方式&quot;&gt;Dagger2的使用方式&lt;/h3&gt;
&lt;p&gt;Dagger是通过Component来确认需求与依赖对象的，可以说Component是他们之间的纽带。如果各位用过Dagger2或者了解过Dagger2的教程的话，那么一定知道，Dagger2的使用方式是十分繁琐的，每个需要用到依赖注入的地方都需要通过编写DaggerxxxComponent的模版代码来实现依赖注入。要写非常多的模版代码，大大增加了系统的复杂度。笔者在使用Dagger 2.17的时候，发现Google对Dagger 2进行了优化，现在使用Dagger实现依赖注入要写的代码其实非常少，并且复杂度已经有了很大程度的降低了。在这里，笔者就不介绍旧的使用方式了，使用过Dagger2的同学可以对比这两种方式的差异，没有使用过的直接学习新的使用方式就可以了。&lt;/p&gt;
&lt;p&gt;Dagger2最简单的使用方式就是下面这种：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class A{
    @Inject
    public A(){
        
    }
}

public class B{
    @Inject A a;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法是最简单的，没什么难度。但是在实际的项目中我们会遇到各种各样的复杂情况，例如，A还需要依赖其它的类，并且这个类是第三方类库中提供的。又或者A实现了C接口，我们在编码的时候需要使用依赖导致原则来加强我们的代码的可维护性等等。这个时候，用上面这种方法是没办法实现这些需求的，我们使用Dagger2的主要难点也是因为上面这些原因导致的。&lt;/p&gt;
&lt;p&gt;还是用上面的例子来解释，假设需要做一个餐饮系统，需要把点好的菜单发给厨师，让厨师负责做菜。现在我们来尝试下用Dagger2来实现这个需求。&lt;/p&gt;
&lt;p&gt;首先，我们需要引入Dagger For Android的一些列依赖库：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt; implementation 'com.google.dagger:dagger-android:2.17'
    implementation 'com.google.dagger:dagger-android-support:2.17' // if you use the support libraries
    implementation 'com.google.dagger:dagger:2.17'
    annotationProcessor 'com.google.dagger:dagger-compiler:2.17'
    annotationProcessor 'com.google.dagger:dagger-android-processor:2.17'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们实现Chef类和Menu类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cooking接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Cooking{
    String cook();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Chef&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class Chef implements Cooking{

    Menu menu;

    @Inject
    public Chef(Menu menu){
        this.menu = menu;
    }

    @Override
    public String cook(){
        //key菜名， value是否烹饪
        Map&amp;lt;String,Boolean&amp;gt; menuList = menu.getMenus();
        StringBuilder sb = new StringBuilder();
        for (Map.Entry&amp;lt;String,Boolean&amp;gt; entry : menuList.entrySet()){
            if (entry.getValue()){
                sb.append(entry.getKey()).append(&quot;,&quot;);
            }
        }

        return sb.toString();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Menu&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class Menu {

    public Map&amp;lt;String,Boolean&amp;gt; menus;

    @Inject
    public Menu( Map&amp;lt;String,Boolean&amp;gt; menus){
         this.menus = menus;
    }
    
    Map&amp;lt;String,Boolean&amp;gt; getMenus(){
        return menus;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们写一个Activity，作用是在onCreate方法中使用Chef对象实现cooking操作。我们先来看看不使用Dagger2和使用Dagger2的代码区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MainActivity&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        setContentView(R.layout.activity_main);
        Map&amp;lt;String, Boolean&amp;gt; menus = new LinkedHashMap&amp;lt;&amp;gt;();
        menus.put(&quot;酸菜鱼&quot;, true);
        menus.put(&quot;土豆丝&quot;, true);
        menus.put(&quot;铁板牛肉&quot;, true);
        Menu menu = new Menu(menus);
        Chef chef = new Chef(menu);
        System.out.println(chef.cook());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DaggerMainActivity&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DaggerMainActivity extends DaggerActivity {
    @Inject
    Chef chef;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Log.d(TAG,chef.cook());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在使用Dagger2的时候，使用者的代码会变得非常简洁。但是，Dagger 2还需要一些列的辅助代码来实现依赖注入的。如果用过Dagger2就知道要实现依赖注入的话，需要写十分多模版代码。那么我们可不可以用更简单的方式使用Dagger2呢？今天笔者就来介绍一下在Android上使用Dagger2的更简洁的方案。&lt;/p&gt;
&lt;p&gt;我们先来看看在DaggerMainActivity上实现依赖注入还需要哪些代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CookModules&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Module
public class CookModules {

    @Singleton
    @Provides
    public Map&amp;lt;String, Boolean&amp;gt; providerMenus(){
        Map&amp;lt;String, Boolean&amp;gt; menus = new LinkedHashMap&amp;lt;&amp;gt;();
        menus.put(&quot;酸菜鱼&quot;, true);
        menus.put(&quot;土豆丝&quot;, true);
        menus.put(&quot;铁板牛肉&quot;, true);
        return menus;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ActivityModules&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Module
abstract class ActivityModules {

    @ContributesAndroidInjector
    abstract MainActivity contributeMainActivity();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CookAppComponent&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Singleton
@Component(modules = {
        AndroidSupportInjectionModule.class,
        ActivityModules.class,
        CookModules.class})
public interface CookAppComponent extends AndroidInjector&amp;lt;MyApplication&amp;gt; {

    @Component.Builder
    abstract class Builder extends AndroidInjector.Builder&amp;lt;MyApplication&amp;gt;{}

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;MyApplication&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyApplication extends DaggerApplication{

    @Override
    public void onCreate() {
        super.onCreate();
    }

    @Override
    protected AndroidInjector&amp;lt;? extends DaggerApplication&amp;gt; applicationInjector() {
        return DaggerCookAppComponent.builder().create(this);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dagger2-for-android-使用要点分析&quot;&gt;Dagger2 For Android 使用要点分析&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;CookModules&lt;/strong&gt;&lt;br/&gt;CookModule很简单，它的目的就是通过@Providers注解提供Menu对象需要的数据。因为Menu是需要依赖一个Map对象的，所以我们通过CookModules给它构造一个Map对象，并自动把它注入到Menu实例里面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ActivityModules&lt;/strong&gt;&lt;br/&gt;ActivityModules的主要作用就是通过@ContributesAndroidInjector来标记哪个类需要使用依赖注入功能，这里标记的是ManActivity，所以MainActivity能通过@Inject注解来注入Chef对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CookAppComponent&lt;/strong&gt;&lt;br/&gt;CookAppComponent相当于一个注射器，我们前面定义的Modules就是被注射的类，使用@Inject注入对象的地方就是接收者类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MyApplication&lt;/strong&gt;&lt;br/&gt;MyAppliction的特点是继承了DaggerAppliction类，并且在applicationInjector方法中构建了一个DaggerCookAppComponent注射器。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这就是Dagger 2在Android中的使用方案了，在这里我们可以看到，接收这类（MainActivity）中的代码非常简单，实现依赖注入只使用了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Inject
Chef chef;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在接收类里面完全没有多余的代码，如果我们要拓展可以SecondsActivity的话，在SecondsActivity我们要用到Menu类。&lt;/p&gt;
&lt;p&gt;那么我们只需要在ActivityModules中增加：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ContributesAndroidInjector
abstract SecondsActivity contributeSecondsActivity();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在SecondsActivity注入Menu：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Inject
Menu menu;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，对于整个工程来说，实现使用Dagger2 For Android实现依赖注入要写的模版代码其实非常少，非常简洁。只需要进行一次配置就可以，不需要频繁写一堆模版代码。总的来说，Dagger2造成模版代码增加这个问题已经解决了。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Tangpj/Android-advanced-blueprint&quot;&gt;Demo地址：目录下的Dagger2Simple就是Demo地址，上面的例子为Dagger2Simple中的simple Modules&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;dagger2的优势&quot;&gt;Dagger2的优势&lt;/h3&gt;
&lt;p&gt;在这里我们总结下使用Dagger2带来的优点。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;减少代码量，提高工作效率&lt;br/&gt;例如上面的例子中，我们构建一个Chef对象的话，不使用Dagger2的情况下，需要在初始化Chef对象之前进行一堆前置对象（Menu、Map）的初始化，并且需要手工注入到对应的实例中。你想像下，如果我们再加一个Restaurant( 餐馆 )对象，并且需要把Chef注入到Restaurant中的话，那么初始化Restaurant对象时，需要的前置步骤就更繁琐了。&lt;br/&gt;可能有人会觉得，这也没什么啊，我不介意手工初始化。但是如果你的系统中有N处需要初始化Restaurant对象的地方呢？使用Dagger2 的话，只需要用注解注入就可以了。&lt;/li&gt;
&lt;li&gt;自动处理依赖关系&lt;br/&gt;使用Dagger2的时候，我们不需要指定对象的依赖关系，Dagger2会自动帮我们处理依赖关系（例如Chef需要依赖Menu，Menu需要依赖Map，Dagger自动处理了这个依赖关系）。&lt;/li&gt;
&lt;li&gt;采用静态编译，不影响运行效率&lt;br/&gt;因为Dagger2是在编译期处理依赖注入的，所以不会影响运行效率在一定的程度上还能提高系统的运行效率（例如采用Dagger2实现单例，不用加锁效率更高）。&lt;/li&gt;
&lt;li&gt;提高多人编程效率&lt;br/&gt;在多人协作的时候，一个人用Dagger2边写完代码后，其它所有组员都能通过@Inject注解直接注入常用的对象。加快编程效率，并且能大大增加代码的复用性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面我们介绍完了Dagger2 For Android的基本用法了。可能有些读者意犹未尽，觉得这个例子太简单了。那么我们来尝试下构建一个更加复杂的系统，深度体验下Dagger2 For Android的优势。现在我们在上面这个例子的基础上拓展下，尝试开发一个简单的点餐Demo来深度体验下。&lt;/p&gt;
&lt;h2 id=&quot;dagger2应用实战&quot;&gt;Dagger2应用实战&lt;/h2&gt;
&lt;p&gt;现在我们来看下如何使用Dagger2来开发一个简单的Demo，这里笔者开发的Demo是一个简单的点餐Demo。这个Demo的功能非常简单，提供了菜单展示、菜单添加/编辑/删除和下单功能。而下单功能只是简单地把菜品名用Snackbar显示到屏幕上。&lt;/p&gt;
&lt;h3 id=&quot;demo展&quot;&gt;Demo展&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;操作展示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Tangpj/MarkdownRes/master/mBlog/dagger2/order_demo.gif&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Tangpj/Android-advanced-blueprint&quot;&gt;Demo地址：目录下的Dagger2Simple就是Demo地址，上面的例子为Dagger2Simple中的order Modules&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;代码目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Tangpj/MarkdownRes/master/mBlog/dagger2/demo_dir.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个Demo采用经典的MVP架构，我们先来简单分析下Demo的细节实现。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用SharedPreferences提供简单的缓存功能（存储菜单）。&lt;/li&gt;
&lt;li&gt;使用Gson把列表序列化成Json格式数据，然后以String的形式保存在SharedPreferences中。&lt;/li&gt;
&lt;li&gt;使用Dagger2实现依赖注入功能。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样基本就实现了一个简单的点菜Demo了。&lt;/p&gt;
&lt;h3 id=&quot;dagger在demo中的应用解释&quot;&gt;Dagger在Demo中的应用解释&lt;/h3&gt;
&lt;p&gt;当我们使用SharedPreferences和Gson实现缓存功能的时候我们会发现，项目中很多地方都会需要这个SharedPreferences和Gson对象。所以我们可以得出两个结论：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;项目中多个模块会用到一些公共实例。&lt;/li&gt;
&lt;li&gt;这些公共实例应该是单例对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们看看是如何通过使用Dagger2提供全局的Modules来实现这类型对象的依赖注入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CookAppModules&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Module
public abstract class CookAppModules {

    public static final String KEY_MENU = &quot;menu&quot;;
    private static final String SP_COOK = &quot;cook&quot;;

    @Singleton
    @Provides
    public static Set&amp;lt;Dish&amp;gt; providerMenus(SharedPreferences sp, Gson gson){
        Set&amp;lt;Dish&amp;gt; menus;
        String menuJson = sp.getString(KEY_MENU, null);
        if (menuJson == null){
            return new LinkedHashSet&amp;lt;&amp;gt;();
        }
        menus = gson.fromJson(menuJson, new TypeToken&amp;lt;Set&amp;lt;Dish&amp;gt;&amp;gt;(){}.getType());
        return menus;
    }

    @Singleton
    @Provides
    public static SharedPreferences providerSharedPreferences(Context context){
        return context.getSharedPreferences(SP_COOK, Context.MODE_PRIVATE);
    }

    @Singleton
    @Provides
    public static Gson providerGson(){
        return new Gson();
    }

    @Singleton
    @Binds
    public abstract Context context(OrderApp application);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里以dishes模块为例子，dishes中DishesPresenter是负责数据的处理的，所以我们会在DishesPresenter注入这些实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DishesPresenter&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DishesPresenter implements DishesContract.Presenter{

   private DishesContract.View mView;

   @Inject
   Set&amp;lt;Dish&amp;gt; dishes;

   @Inject
   Gson gson;

   @Inject
   SharedPreferences sp;

   @Inject
   public DishesPresenter(){

   }

   @Override
   public void loadDishes() {
       mView.showDishes(new ArrayList&amp;lt;&amp;gt;(dishes));
   }

   @Override
   public String order(Map&amp;lt;Dish, Boolean&amp;gt; selectMap) {
       if (selectMap == null || selectMap.size() == 0) return &quot;&quot;;
       StringBuilder sb = new StringBuilder();

       for (Dish dish : dishes){
           if (selectMap.get(dish)){
               sb.append(dish.getName()).append(&quot;、&quot;);
           }
       }
       if (TextUtils.isEmpty(sb.toString())) return &quot;&quot;;

       return &quot;烹饪: &quot; + sb.toString();
   }

   @Override
   public boolean deleteDish(String id) {
       for (Dish dish : dishes){
           if (dish.getId().equals(id)){
               dishes.remove(dish);
               sp.edit().putString(CookAppModules.KEY_MENU, gson.toJson(dishes)).apply();
               return true;
           }
       }
       return false;
   }


   @Override
   public void takeView(DishesContract.View view) {
       mView = view;
       loadDishes();
   }

   @Override
   public void dropView() {
       mView = null;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码能很好地体验Dagger2的好处，假如我们项目中有比较复杂的对象在很多地方都会用到的话，我们可以通过这种方式来简化我们的代码。&lt;/p&gt;
&lt;p&gt;Dishes模块的UI是由Activity加Fragment实现的，Fragment实现了主要的功能，而Activity只是简单作为Fragment的外层。它们分别是：DishesActivity和DishesFragment&lt;/p&gt;
&lt;p&gt;DishesActivity依赖了DishesFragment对象，而在DishesFragment则依赖了DishesAdapter、RecyclerView.LayoutManager、DishesContract.Presenter对象。&lt;/p&gt;
&lt;p&gt;我们先来分别看看DishesActivity与DishesFragment的关键代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DishesActivity&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DishesActivity extends DaggerAppCompatActivity {

    @Inject
    DishesFragment mDishesFragment;
    
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DishesFragment&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DishesFragment extends DaggerFragment implements DishesContract.View{

    RecyclerView rvDishes;

    @Inject
    DishesAdapter dishesAdapter;

    @Inject
    RecyclerView.LayoutManager layoutManager;

    @Inject
    DishesContract.Presenter mPresenter;
    
    @Inject
    public DishesFragment(){

    }
    
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DishesFragment通过Dagger2注入了DishesAdapter、RecyclerView.LayoutManager、DishesContract.Presenter，而这些实例是由DishesModules提供的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DishesModules&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
@Module
public abstract class DishesModules {

    @ContributesAndroidInjector
    abstract public DishesFragment dishesFragment();

    @Provides
    static DishesAdapter providerDishesAdapter(){
        return new DishesAdapter();
    }
    
    @Binds
    abstract DishesContract.View dishesView(DishesFragment dishesFragment);

    @Binds
    abstract RecyclerView.LayoutManager layoutManager(LinearLayoutManager linearLayoutManager);


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们先说明下这几个注解的作用。&lt;/p&gt;
&lt;ul readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;@ContributesAndroidInjector&lt;/strong&gt;&lt;br/&gt;你可以把它看成Dagger2是否要自动把需要的用到的Modules注入到DishesFragment中。这个注解是Dagger2 For Android简化代码的关键，下面的小节会通过一个具体例子来说明。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;@Module&lt;/strong&gt;&lt;br/&gt;被这个注解标记的类可以看作为依赖对象的提供者，可以通过这个被标记的类结合其它注解来实现依赖关系的关联。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;@Provides&lt;/strong&gt;&lt;br/&gt;主要作用就是用来提供一些第三方类库的对象或提供一些构建非常复杂的对象在Dagger2中类似工厂类的一个角色。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;@Binds&lt;/strong&gt;&lt;br/&gt;主要作用就是确定接口与具体的具体实现类，这样说得比较抽象，我们还是看看例子吧。&lt;br/&gt;在DishesFragment中有这么一句代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Inject
DishesContract.Presenter mPresenter;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道DishesContract.Presenter是一个接口而这个接口可能有很多不同的实现类，而@Binds的作用就是用来确定这个具体实现类的。以看看PresenterModules的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Module
public abstract class PresenterModules {
    @Binds
    abstract DishesContract.Presenter dishesPresenter(DishesPresenter presenter);

    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这句代码可以看出，使用@Inject注入的DishesContract.Presenter对象的具体实现类是DishesPresenter。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;dagger2-for-android是如何注入依赖的&quot;&gt;Dagger2 For Android是如何注入依赖的？&lt;/h3&gt;
&lt;p&gt;我们在用Dagger2的时候是通过一些模版代码来实现依赖注入的（ DaggerXXXComponent.builder().inject(xxx) 这种模版代码），但是在Demo中的DishesFragment根本没看到类似的代码啊，那么这些对象是什么时候注入到DishesFragment重的呢？&lt;/p&gt;
&lt;p&gt;答案就是&lt;strong&gt;@ContributesAndroidInjector&lt;/strong&gt;注解&lt;/p&gt;
&lt;p&gt;我们先来看看Dagger2是通过什么方式来实现自动把依赖注入到DishesActivity中的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ActivityModules&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Module
public abstract class ActivityModules {

    @ContributesAndroidInjector(modules = DishesModules.class)
    abstract public DishesActivity contributesDishActivity();

    @ContributesAndroidInjector(modules = AddEditModules.class)
    abstract public AddEditDishActivity contributesAddEditDishActivity();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错，就是@ContributesAndroidInjector这个注解，modules就代表这个DishesActivity需要依赖哪个Modules。这篇教程我们不解释它的具体实现原理，你只需要知道@ContributesAndroidInjector的作用就可以了。&lt;/p&gt;
&lt;p&gt;我们以前使用Dagger2的时候，需要些很多Component来辅助我们实现依赖注入，而现在我们整个App中只需要写一个Component就可以了。@ContributesAndroidInjector注解会帮助我们生成其它需要的Component，并且自动处理Component之间的关系，自动帮我们使用生成的Component来注入依赖。&lt;/p&gt;
&lt;p&gt;我们先看看我们现在整个模块中唯一存在的Component是怎么使用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OrderAppComponent&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Singleton
@Component(modules = {
        AndroidSupportInjectionModule.class,
        LayoutManagerModules.class,
        CookAppModules.class,
        PresenterModules.class,
        ActivityModules.class})
public interface OrderAppComponent extends AndroidInjector&amp;lt;OrderApp&amp;gt;{

    @Component.Builder
    abstract class Builder extends AndroidInjector.Builder&amp;lt;OrderApp&amp;gt;{
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;OrderApp&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class OrderApp extends DaggerApplication {


    @Override
    protected AndroidInjector&amp;lt;? extends DaggerApplication&amp;gt; applicationInjector() {
        return DaggerOrderAppComponent.builder().create(this);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了加深大家对@ContributesAndroidInjecto注解r的理解，我们稍微修改下DishesModules&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Module
public abstract class DishesModules {

    //@ContributesAndroidInjector
    //abstract public DishesFragment dishesFragment();

    @Provides
    static DishesAdapter providerDishesAdapter(){
        return new DishesAdapter();
    }

    @Binds
    abstract DishesContract.View dishesView(DishesFragment dishesFragment);

    @Binds
    abstract RecyclerView.LayoutManager layoutManager(LinearLayoutManager linearLayoutManager);


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DishesActivity&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class DishesActivity extends DaggerAppCompatActivity {

    //@Inject
    DishesFragment mDishesFragment;

    Toolbar toolbar;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_dishes);

        DishesFragment dishesFragment
                = (DishesFragment) getSupportFragmentManager().findFragmentById(R.id.content_fragment);

        if (dishesFragment == null){
            mDishesFragment = new DishesFragment();//新增代码
            dishesFragment = mDishesFragment;
            ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), dishesFragment, R.id.content_fragment);
        }
        initView();

    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//DaggerFragment改为Fragment
public class DishesFragment extends Fragment implements DishesContract.View{
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候，我们运行的时候会发现，DishesFragment中的依赖注入失败了，运行时会抛出空指针异常，没注入需要的数据。导致这个原因是因为我们在这里使用new来创建DishesFragment实例的，为什么使用new的时候会Dagger2没有帮我们注入实例呢？&lt;/p&gt;
&lt;p&gt;当我们使用@Inject来注入DishesFragment的时候，Dagger2会自动帮我们判断DishesFragment所依赖的对象（@Inject注解标记），如果能直接注入的对象则直接注入到Fragment中，否则则从DishesModules中寻找是否有需要的对象，有的话则注入到DishesFragment中。而我们使用new来创建DishesFragment时Dagger2无法通过DishesModules来查找对象，因为我们没有声明DishesFragment与DishesModules的联系，DishesFragment也没有自动注入注解的标记（ 没有实现HasSupportFragmentInjector ）。所以Dagger2无法判断它们依赖关系也没办法自动帮DishesFragment自动注入依赖。&lt;/p&gt;
&lt;p&gt;如果我们坚持要使用new的方式来依赖DishesFragment的话，则可以通过@ContributesAndroidInjecto注解来实现它们之间的关联。具体实现方式如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DishesModules&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Module(includes = PresenterModules.class)
public abstract class DishesModules {

    @ContributesAndroidInjector
    abstract public DishesFragment dishesFragment(); //增加这个抽象方法

    @Provides
    static DishesAdapter providerDishesAdapter(){
        return new DishesAdapter();
    }

    @Binds
    abstract DishesContract.View dishesView(DishesFragment dishesFragment);

    @Binds
    abstract RecyclerView.LayoutManager layoutManager(LinearLayoutManager linearLayoutManager);


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DishesFragment继承于DaggerFragment&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DishesFragment extends DaggerFragment implements DishesContract.View{
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改成这样，我们通过new方法来创建DishesFragment的时候也能实现通过注解进行依赖注入了，为什么会这样呢？因为@ContributesAndroidInjector的作用时帮我们生成需要的Subcomponent，然后在DaggerFragment通过 DispatchingAndroidInjector&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Module(subcomponents = DishesModules_DishesFragment.DishesFragmentSubcomponent.class)
public abstract class DishesModules_DishesFragment {
  private DishesModules_DishesFragment() {}

  @Binds
  @IntoMap
  @FragmentKey(DishesFragment.class)
  abstract AndroidInjector.Factory&amp;lt;? extends Fragment&amp;gt; bindAndroidInjectorFactory(
      DishesFragmentSubcomponent.Builder builder);

  @Subcomponent
  public interface DishesFragmentSubcomponent extends AndroidInjector&amp;lt;DishesFragment&amp;gt; {
    @Subcomponent.Builder
    abstract class Builder extends AndroidInjector.Builder&amp;lt;DishesFragment&amp;gt; {}
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，编生成的代码符合我们上面的结论。&lt;/p&gt;
&lt;h2 id=&quot;dagger2-for-android使用要点&quot;&gt;Dagger2 For Android使用要点&lt;/h2&gt;
&lt;p&gt;我们现在来总结下，简化版的Dagger实现依赖注入的几个必要条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第三方库通过Modules的@provides注解来提供依赖&lt;/li&gt;
&lt;li&gt;提供一个全局唯一的Component，并且Modules中需要天际AndroidSupportInjectionModule类，它的作用时关联需求与依赖之间的关系&lt;/li&gt;
&lt;li&gt;Application需要继承DaggerApplication类，并且在applicationInjector构建并返回全剧唯一的Component实例&lt;/li&gt;
&lt;li&gt;其它需要使用依赖注入的组建都需要继承&lt;strong&gt;Dagger组件名字&lt;/strong&gt;类，并且需要在相应的Modules中通过@ContributesAndroidInjector注解标记需要注入依赖的组建。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面四个步骤就是使用Dagger2实现依赖注入的要点了，总的来说，复杂度比之前的方法简单了非常多，要写的模版代码也减少了非常多。&lt;/p&gt;
&lt;p&gt;一般来说，上面的知识点已经足够让我们在项目中正常使用Dagger2了，但是在使用中还会遇到一些其它的问题，Dagger2也提供了解决方法。如果希望进一步了解的话，可以继续阅读下文。&lt;/p&gt;
&lt;h2 id=&quot;dagger2拓展&quot;&gt;Dagger2拓展&lt;/h2&gt;
&lt;h3 id=&quot;scope&quot;&gt;@Scope&lt;/h3&gt;
&lt;p&gt;Scope字面的意思是作用域，在我们使用Dagger2的时候经常会用到@Singleton这个注解，这个注解的意思的作用是提供单例对象。而我们在使用@Singleton这个注解的时候，会同时@Provides和@Component，为什么要这样做呢？因为@Scope的作用范围其实就是单例的作用范围，这个范围主要是通过Component来确定的。&lt;/p&gt;
&lt;p&gt;所以@Scope的作用就是以指定Component的范围为边界，提供局部的单例对象。我们可以以上面的例子为例验证这个论点论点。&lt;/p&gt;
&lt;p&gt;我们在DishesActivity中增加一句代码，作用时注入DishesPresneter对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Inject
DishesContract.Presenter mPresenter;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码中，我们知道DishesFragment中也用同样的方式来注入过DishesPresneter对象，那么它们有什么区别的，我们通过调试功能来看下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Tangpj/MarkdownRes/master/mBlog/dagger2/normal_activity.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Tangpj/MarkdownRes/master/mBlog/dagger2/normal_fragment.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，DishesActivity和DishesFragment中的DishesPresenter不是同一个实例，它们的内存地址是不一样的。如果我们在PresenterModules的dishesPresenter方法中加上@Singleton&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Singleton
@Binds
abstract DishesContract.Presenter dishesPresenter(DishesPresenter presenter);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以预见，DishesActivity和DishesFragment中的DishesPresenter会变成同一个实例，在这个例子中@Singleton的作用是提供全局的单例（ 因为OrderAppComponent这个全局唯一的Component也被标注成@Singleton ）。这种用法比较简单，这里不再深入。而比较难理解的就是自定义Scope了，下面我们通过一个例子来加深大家对自定义Scope的理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@DishesScoped&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Documented
@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface DishesScoped {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了使测试效果更明显，我们稍微修改下Order这个Demo。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DishesModules&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Module
public abstract class DishesModules {
   ...
    @DishesScoped  // 添加注解
    @Binds
    abstract DishesContract.Presenter dishesPresenter(DishesPresenter presenter);
   ...

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ActivityModules&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Module
public abstract class ActivityModules {

    @DishesScoped  // 添加注解
    @ContributesAndroidInjector(modules = DishesModules.class)
    abstract public DishesActivity contributesDishActivity();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后现在我们来运行Demo，看下DishesActivity和DishesFragment中的DishesContract.Presenter的对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Tangpj/MarkdownRes/master/mBlog/dagger2/scope_activity.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Tangpj/MarkdownRes/master/mBlog/dagger2/scope_fragment.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，它们是同一个对象，这验证了我们上面的结论。这里又个小问题就是，我们之前说@Scope是通过Component来确定作用边界的，但是上面这个例子中，并没有对任何Component类使用@Dishes注解啊？那么这里是如何确认边界的呢？&lt;/p&gt;
&lt;p&gt;我们可以看看Dagger生成的类&lt;strong&gt;ActivityModules_ContributesDishActivity&lt;/strong&gt;，这个类是根据ActivityModules中的contributesDishActivity方法生成的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Module(subcomponents = ActivityModules_ContributesDishActivity.DishesActivitySubcomponent.class)
public abstract class ActivityModules_ContributesDishActivity {
  private ActivityModules_ContributesDishActivity() {}

  @Binds
  @IntoMap
  @ActivityKey(DishesActivity.class)
  abstract AndroidInjector.Factory&amp;lt;? extends Activity&amp;gt; bindAndroidInjectorFactory(
      DishesActivitySubcomponent.Builder builder);

  @Subcomponent(modules = DishesModules.class)
  @DishesScoped   //看这里
  public interface DishesActivitySubcomponent extends AndroidInjector&amp;lt;DishesActivity&amp;gt; {
    @Subcomponent.Builder
    abstract class Builder extends AndroidInjector.Builder&amp;lt;DishesActivity&amp;gt; {}
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;谜底揭晓，当我们为contributesDishActivity添加上@DishesScoped注解后，自动生成的DishesActivitySubcomponent类被@DishesScoped注解了。所以@DishesScoped是通过DishesActivitySubcomponent来确认作用范围的，这也符合上面的结论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Scope的实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@Scope实现单例的原理其实很简单，我们可以看下加了@DishesScoped后Dagger为我们生成的注入辅助代码。在这里我们只看关键方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void initialize(final DishesActivitySubcomponentBuilder builder) {
      this.dishesFragmentSubcomponentBuilderProvider =
          new Provider&amp;lt;DishesModules_DishesFragment.DishesFragmentSubcomponent.Builder&amp;gt;() {
            @Override
            public DishesModules_DishesFragment.DishesFragmentSubcomponent.Builder get() {
              return new DishesFragmentSubcomponentBuilder();
            }
          };
      this.dishesPresenterProvider =
          DishesPresenter_Factory.create(
              DaggerOrderAppComponent.this.providerMenusProvider,
              DaggerOrderAppComponent.this.providerGsonProvider,
              DaggerOrderAppComponent.this.providerSharedPreferencesProvider);
      this.dishesPresenterProvider2 = DoubleCheck.provider((Provider) dishesPresenterProvider);   //这句代码是实现单例的关键。
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们的dishesPresenterProvider2这个对象的初始化是通过双锁校验的方式来实现单例的，所以这个对象是一个单例对象。而其它没有使用@Spoce注解的类则没有使用双锁校验的方式实现初始化，Dagger通过@Scope实现单例的原理其实非常简单。关于@Spoce的介绍就到这里了，如果需要深入的话，可以进一步查看Dagger2生成的辅助代码。&lt;/p&gt;
&lt;h3 id=&quot;qualifier和named注解&quot;&gt;@Qualifier和@Named注解&lt;/h3&gt;
&lt;p&gt;除了作用域的问题之外我们还会经常会遇到一个问题，总所周知，Dagger2是自动判断依赖关系的，如果我们的代码中需要使用同一个类生成两个或多个不同的对象呢？例如我们的LinearManager，我们现在想用Dagger提供一个横向的Manager，如果直接写在项目中是会报错的，因为Dagger无法判断需要注入/依赖的对象是哪个。如下面的代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LayoutManagerModules&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
@Module
public class LayoutManagerModules {

    @Provides
    public LinearLayoutManager providesLinearLayoutManager(Context context){
        return new LinearLayoutManager(context);
    }
    
    @Provides 
    public LinearLayoutManager providesHorizonalLinearLayoutManager(Context context){
        return new LinearLayoutManager(context, LinearLayoutManager.HORIZONTAL, false);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码肯定是会报错的，如果我们想实现这个功能的话，这个时候我们就需要用到@Qualifier或者@Named注解了。&lt;/p&gt;
&lt;p&gt;我们先用@Named来实现上面这个需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LayoutManagerModules&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Module
public class LayoutManagerModules {

    @Named(&quot;vertical&quot;)
    @Provides
    public LinearLayoutManager providesLinearLayoutManager(Context context){
        return new LinearLayoutManager(context);
    }

    @Named(&quot;horizontal&quot;)
    @Provides
    public LinearLayoutManager providesHorizonalLinearLayoutManager(Context context){
        return new LinearLayoutManager(context, LinearLayoutManager.HORIZONTAL, false);
    }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DishesModules&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DishesFragment extends DaggerFragment implements DishesContract.View{

    RecyclerView rvDishes;

    @Inject
    DishesAdapter dishesAdapter;

    @Named(&quot;horizontal&quot;)
    @Inject
    LinearLayoutManager layoutManager;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在注入的时候，我们通过 @Named(&quot;horizontal&quot;)就能控制实际是注入哪个LayoutManager了。在定义依赖的时候@Name注解要配合@Providers，而在使用的时候配合@Inject来使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Qualifier&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@Qualifier的作用和@Named是一样的，@Name也被@Qualifier注解。在使用@Named的时候需要加上我们定义的key所以略显麻烦，我们可以通过自定义@Qualifier注解来解决这个问题。而自定义@Qualifier注解的方式和自定义@Spoce是一样的，非常简单，这里不作深入介绍了。&lt;/p&gt;
&lt;p&gt;Dagger2还提供了例如懒加载等功能，使用起来都是比较简单的，这里限于篇幅就不作进一步介绍了。有兴趣的读者可以查阅源码或者看官方文档来体验下。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;Dagger2 For Android是一款非常适合移动端使用的依赖注入框架。它提供了静态编译的方式来实现依赖注入，性能非常好。并且最新版本的Dagger 2.17对Android提供了非常友好的支持，现在使用Dagger2的时候，我们不需要再手写注入代码，这一切Dagger2都帮我们自动实现了。总的来说，Dagger2是非常适合于应用到我们的项目中的。并且Dagger2实现依赖注入的方式非常有趣，能掌握这项技术的话，对我们的提升是非常大的，希望各位读者在阅读了本文后能够去体验一下。&lt;/p&gt;
&lt;p&gt;如果这篇文章对你有帮助的话，可以关注下笔者其它的文章，欢迎大家在我的github上面点star哦。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tangpj.com/2018/09/29/calces-screen/&quot;&gt;给你一个全自动的屏幕适配方案（基于SW方案）！—— 解放你和UI的双手&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tangpj.com/2018/07/22/calces-componentization/&quot;&gt;Gradle自动实现Android组件化模块构建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Tangpj/Android-advanced-blueprint&quot;&gt;技术教程Demo地址（本文的Demo也在里面哟）👍&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Tangpj/calces-gradle-plugin&quot;&gt;你的支持，是我前进的动力，如果我的项目对您有帮助的话，可以点下star👍&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 29 Oct 2018 15:51:00 +0000</pubDate>
<dc:creator>tangpj</dc:creator>
<og:description>Dagger2是现在非常火的一个依赖注入框架，目前由Google维护，在Github上面已经有12K star了。Dagger2的入门门槛其实是比较高的，据了解，目前有很多Android工程师对Dag</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tangpj/p/9874133.html</dc:identifier>
</item>
<item>
<title>vs中开发web站点使IIS Express支持局域网连接 - 张林-布莱恩特</title>
<link>http://www.cnblogs.com/zhangmumu/p/9874117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmumu/p/9874117.html</guid>
<description>&lt;p&gt;vs中开发web站点使IIS Express支持局域网连接&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在开发webapi的时候，客户端设备都会使用局域网的地址访问webapi，有时候需要调试api。这个时候就需要使用一些技巧了，这里我记录了我常用的两种方式，在局域网内调试vs中的web站点&lt;br/&gt;1.修改IIS Express的applicationhost.config文件&lt;br/&gt;2.附加到进程调试&lt;br/&gt;&lt;strong&gt;两者都需要以管理员身份启动IIS&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;修改iis-express的applicationhost.config文件&quot;&gt;修改IIS Express的applicationhost.config文件&lt;/h3&gt;
&lt;p&gt;1.要想在局域网内调试vs中的web站点，这种方式是最简单的。先新建一个web站点，运行之后,在任务栏找到IIS&lt;br/&gt;Express 的图标，点击悬着“显示所有应用程序”，可以看到这个配置的路径，点击打开。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181019201235104?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;vs中开发web项目IIS Express支持局域网访问（局域网内调试vs中的web站点）&quot;/&gt;&lt;br/&gt;2.找到sites节点，添加你的局域网的ip地址&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181019200015555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;site节点下的bingings（复数形式），可以绑定多个信息。红框中是我添加的，可以看到bindingInfomation=“&lt;em&gt;:53312:192.168.1.116”,这个192.168.1.116是我本机的地址，也可以修改为&lt;/em&gt; &lt;strong&gt;:53312:&lt;/strong&gt; *&lt;/p&gt;
&lt;p&gt;3.注意的是必须是调试模式、管理员身份运行。否则会出现下面的错误&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181019200231156?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;vs中开发web项目IIS Express支持局域网访问（局域网内调试vs中的web站点）&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181019200313128?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;vs中开发web项目IIS Express支持局域网访问（局域网内调试vs中的web站点）&quot;/&gt;&lt;br/&gt;4.在cmd中使用IIS Express开启所建的网站&lt;br/&gt;我们将““C:\Program Files (x86)\IIS Express”（64位）或“C:\Program Files\IIS Express”（32位）”加入到系统变量，这个比较简单，忘的话百度一下就ok。将路径添加到系统变量的Path中来。&lt;br/&gt;打开cmd，输入appcmd就可以看到如下提示&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181029231530518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;vs中开发web项目IIS Express支持局域网连接&quot;/&gt;&lt;br/&gt;查看config文件的信息命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;appcmd /apphostconfig:E:\XamarinForms\DebugSample\.vs\config\applicationhost.config list site&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181029231725575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;vs中开发web项目IIS Express支持局域网连接&quot;/&gt;&lt;br/&gt;我们可以在命令提示符中，使用iisexpress开启创建的网站，在控制台中输入一下&lt;br/&gt;这个站点id是2.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;iisexpress /config:E:\XamarinForms\DebugSample\.vs\config\applicationhost.config /siteid:2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个是时候打开浏览器，你会发现http://localhost:53312/ 是可以访问的，但是&lt;br/&gt;&lt;a href=&quot;http://192.168.1.116:53312/&quot; class=&quot;uri&quot;&gt;http://192.168.1.116:53312/&lt;/a&gt; 出现bad request 400错误无法访问。&lt;br/&gt;以管理员的方式打开cmd，为非管理员帐户保留指定的URL&lt;br/&gt;netsh http add urlacl url=&lt;a class=&quot;uri&quot;&gt;http://&lt;/a&gt;*:53312/ user=everyone&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018102923382165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;vs中开发web项目IIS Express支持局域网连接&quot;/&gt;&lt;br/&gt;&lt;strong&gt;记住要关闭防火墙，打开53312端口&lt;/strong&gt;。&lt;br/&gt;运行结果如图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181029234211307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;vs中开发web项目IIS Express支持局域网连接&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;附加到进程调试&quot;&gt;附加到进程调试&lt;/h3&gt;
&lt;p&gt;这种方式不太正经，不需要修改applicationhost.config文件。&lt;br/&gt;附加到进程调试的好处是。在进行断点调试，需要经过项目编译成功后，启动IIS Express 打开浏览器，最后进入我们的断点，附加到进程调试后节约时间。还可以调试局域网内的web站点。&lt;br/&gt;1.部署IIS站点&lt;br/&gt;刚刚新建的站点DebugSample，打开IIS添加这个站点目录。部署站点就不浪费时间了，百度起码有10万篇。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181019201717596?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;vs中开发web项目IIS Express支持局域网访问（局域网内调试vs中的web站点）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.先在iis打开这个站点，然后管理员身份打开站点debugSample。选择调试&amp;gt;附加到进程&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181019202100336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;vs中开发web项目IIS Express支持局域网访问（局域网内调试vs中的web站点）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181019202402729?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们就可以在vs中调试客户端的请求了，&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181019202647346?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlYmkwMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;vs中开发web项目IIS Express支持局域网访问（局域网内调试vs中的web站点）&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;1.修改IIS Express的applicationhost.config文件2.附加到进程调试，这两种方式都需要以管理员身份启动vs。附加到进程调试的优势在于不需要等待vs编译项目成功后启动IIS express，还可以进行客户端请求的调试，但是这种方式很多地方需要注意，只有你在实际操作过程去体会了&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 15:49:00 +0000</pubDate>
<dc:creator>张林-布莱恩特</dc:creator>
<og:description>在开发客户端使调用局域网的接口，需要支持局域网连接1.修改IIS Express的applicationhost.config文件2.附加到进程调试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangmumu/p/9874117.html</dc:identifier>
</item>
<item>
<title>Jenkins的一些笔记 - ZepheryWen</title>
<link>http://www.cnblogs.com/w1570631036/p/9861473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w1570631036/p/9861473.html</guid>
<description>&lt;p&gt;公司主要要开发自己的paas平台，集成了Jenkins，真的是遇到了很多很多困难，特别是在api调用的权限这一块，这里，把自己遇到的一些坑的解决方法做一下笔记吧。当然，首先要讲的，就是如何在开启安全的情况下进行API调用。&lt;/p&gt;
&lt;h2 id=&quot;一在全局安全配置中&quot;&gt;一、在全局安全配置中&lt;/h2&gt;
&lt;h4 id=&quot;启用安全&quot;&gt;1.1 启用安全&lt;/h4&gt;
&lt;p&gt;如果勾选不对，那么Jenkins有可能崩溃掉，亲身经历，之前一直没有勾选安全域，然后授权策略为登录用户可以做任何事，之后权限这一块就彻底崩溃了，重装了又重装，才知道，需要勾选安全域。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20181027023132911846860.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;跨域&quot;&gt;1.2 跨域&lt;/h4&gt;
&lt;p&gt;同时开启跨站请求伪造保护，Jenkins的一些API需要用到的。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/201810270231471528136147.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;二获取token&quot;&gt;二、获取TOKEN&lt;/h2&gt;
&lt;h4 id=&quot;token&quot;&gt;2.1 TOKEN&lt;/h4&gt;
&lt;p&gt;Jenkins的用户token可以在用户的设置下面获得，但是这种方式如果需要重装Jenkins的话，就得重新修改一次配置文件&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20181027023526539361439.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;经过对&lt;a href=&quot;https://github.com/jenkinsci/java-client-api&quot;&gt;Jenkins-client&lt;/a&gt;的抓包分析，token可以由username+&quot;:&quot;+password，然后进行base64加密组成，之后在token前面加上&quot;Basic &quot;即可，代码如下：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20181027024305570167743.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;三获取jenkins-crumb&quot;&gt;三、获取Jenkins-Crumb&lt;/h2&gt;
&lt;p&gt;在远程API调用的时候，Jenkins对于某些接口的要求不仅限于Authorization，还必须要有Jenkins-Crumb，这个东西之前在进行获取的时候，有时候会变来变去，比如用curl命令和f12查看的时候发现不一致，实在受不了，感觉毫无规律可言，之后才发现上面的Authorization来直接调用接口获取的才是正确的，再然后想想，可能是之前调用api的时候，没有开启启用安全，再或者是有没有勾选上使用碎片算法。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/201810270251031329488332.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;另，附上curl查询Jenkins-Crumb的命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;curl -s 'http://admin:yourtoken@jenkins-url/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,&quot;:&quot;,//crumb)'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;替换掉yourtoken和jenkins-url即可。&lt;/p&gt;
&lt;h2 id=&quot;四值得注意的事&quot;&gt;四、值得注意的事&lt;/h2&gt;
&lt;h4 id=&quot;api设计&quot;&gt;4.1 API设计&lt;/h4&gt;
&lt;p&gt;Jenkins的API设计可谓是独领风骚，能把一个提交设计成这样真实佩服测试之后才发现只要提交个表单，key为json，value为值即可，其他的都不需要，这个设计我也不知道怎么来的，感觉超级坑。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20181027030059348201424.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;生成构建job&quot;&gt;4.2 生成构建job&lt;/h4&gt;
&lt;p&gt;由于我们是将Jenkins集成在我们自己的平台里面，并不暴露Jenkins给用户，所以，创建一个job的时候，必须由我们平台的参数往Jenkins里面提交，这一提交，发现的问题不少。&lt;br/&gt;一是Jenkins的整个job的提交是由两步组成的，先是创建job，再提交配置。即：/createItem?name=xxx接口。&lt;br/&gt;二是提交的配置参数，提交的是整个xml，而不是由一个一个参数组成的。对于java来说，就得使用xstream或者其他来转化，甚是折腾，如图这种转化。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20181029112422597829257.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;构建的队列&quot;&gt;4.3 构建的队列&lt;/h4&gt;
&lt;p&gt;在点击立即构建的时候，Jenkins是没有返回任何信息，但是在Jenkins的内部，它是通过放到队列里等待的，如果有空闲，就开始构建，否则等待，这个队列是可以获取得到的，我们从里面可以获取上一次构建的信息，是成功还是失败。这种情况下，假设我们多个人同时点击，这下子就有点慌了，如何获取到具体某个人的构建结果，有点虐心。想了半天，最终得出的事：代码相同，意味着每次构建的结果相同，为什么要允许多个人同时点击？就这么解决了：从一个job的构建队列中获取最后一次构建的信息，如果是正在构建，那么不允许构建了，直到构建结果出来。&lt;/p&gt;
&lt;h4 id=&quot;构建进度的查看&quot;&gt;4.4 构建进度的查看&lt;/h4&gt;
&lt;p&gt;需要将Jenkins中的构建进度移植到我们自有的平台，Jenkins的构建进度时通过ajax轮询实现的，获取文本的规则主要从response header里面的两个字段获取&lt;br/&gt;（1）X-More-Data：是否有更多的数据&lt;br/&gt;（2）X-Text-Size：从开始到该次调用的文本大小&lt;br/&gt;我们是通过websocket来将文本内容推送到前端，使用的stomp协议，部分代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        while (true) {
            ...
            String string = response.body().string();
            String header = response.header(&quot;X-More-Data&quot;);
            if (!Strings.isNullOrEmpty(header) || start == 0) {
                template.convertAndSend(&quot;/topic/&quot; + uuid, string);
                String textSize = response.header(&quot;X-Text-Size&quot;);
                if (!Strings.isNullOrEmpty(textSize)) {
                    start = Integer.parseInt(textSize);
                }
                TimeUnit.SECONDS.sleep(5);
            } else {
                template.convertAndSend(&quot;/topic/&quot; + uuid, string);
                return;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;br/&gt;1.&lt;a href=&quot;https://www.cnblogs.com/jwentest/p/8204421.html&quot;&gt;通过jenkins API去build一个job&lt;/a&gt;&lt;br/&gt;2.&lt;a href=&quot;https://wiki.jenkins.io/display/JENKINS/Remote+access+API&quot;&gt;Jenkins Remote API&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 15:29:00 +0000</pubDate>
<dc:creator>ZepheryWen</dc:creator>
<og:description>公司主要要开发自己的paas平台，集成了Jenkins，真的是遇到了很多很多困难，特别是在api调用的权限这一块，这里，把自己遇到的一些坑的解决方法做一下笔记吧。当然，首先要讲的，就是如何在开启安全的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w1570631036/p/9861473.html</dc:identifier>
</item>
<item>
<title>Spring 12 种 常用注解! - Java-live-begin</title>
<link>http://www.cnblogs.com/wang-Java-begining/p/9874063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-Java-begining/p/9874063.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.声明bean的注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Component 组件，没有明确的角色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Service 在业务逻辑层使用（service层）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Repository 在数据访问层使用（dao层）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Controller 在展现层使用，控制器的声明（C）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.注入bean的注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Autowired：由Spring提供&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Inject：由JSR-330提供&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Resource：由JSR-250提供&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.java配置类相关注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.切面（AOP）相关注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Spring支持AspectJ的注解式切面编程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Aspect 声明一个切面（类上） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@After 在方法执行之后执行（方法上） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　@Before 在方法执行之前执行（方法上） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　@Around 在方法执行之前与之后执行（方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@PointCut 声明切点 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.@Bean的属性支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　其设置类型包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　Protetype （每次调用新建一个bean）, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　Request （web项目中，给每个http request新建一个bean）, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　Session （web项目中，给每个http session新建一个bean）, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　GlobalSession（给每一个 global http session新建一个Bean实例）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@StepScope 在Spring Batch中还有涉及&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.@Value注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Value 为属性注入值（属性上） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　支持如下方式的注入： &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　》注入普通字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;Michael Jackson&quot;)String&lt;span class=&quot;Apple-converted-space&quot;&gt; name;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入操作系统属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;#{systemProperties['os.name']}&quot;)String&lt;span class=&quot;Apple-converted-space&quot;&gt; osName;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入表达式结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;#{&lt;span class=&quot;Apple-converted-space&quot;&gt; T(java.lang.Math).random() *&lt;span class=&quot;Apple-converted-space&quot;&gt; 100&lt;span class=&quot;Apple-converted-space&quot;&gt; }&quot;) String&lt;span class=&quot;Apple-converted-space&quot;&gt; randomNumber;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入其它bean属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;#{domeClass.name}&quot;)String&lt;span class=&quot;Apple-converted-space&quot;&gt; name;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入文件资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;classpath:com/hgs/hello/test.txt&quot;)String&lt;span class=&quot;Apple-converted-space&quot;&gt; Resource file;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入网站资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;http://www.javastack.cn&quot;)Resource url;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Value(&quot;${book.name}&quot;)String&lt;span class=&quot;Apple-converted-space&quot;&gt; bookName;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注入配置使用方法： &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　① 编写配置文件（test.properties）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　book.name=《三体》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② @PropertySource 加载配置文件(类上)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@PropertySource(&quot;classpath:com/hgs/hello/test/test.propertie&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③ 还需配置一个PropertySourcesPlaceholderConfigurer的bean。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.环境切换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247484241&amp;amp;idx=1&amp;amp;sn=2d0378b4842db91985f61c5388584b0c&amp;amp;chksm=eb538667dc240f71c1746f6dd74cc9b3d94a58868139c4a102a8bd794f821467dddb06b543b0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;8.异步相关&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上），点击&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247484241&amp;amp;idx=1&amp;amp;sn=2d0378b4842db91985f61c5388584b0c&amp;amp;chksm=eb538667dc240f71c1746f6dd74cc9b3d94a58868139c4a102a8bd794f821467dddb06b543b0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;这里&lt;/em&gt;&lt;/a&gt;了解使用详情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上&lt;em&gt;所有的方法都将异步&lt;/em&gt;，需要@EnableAsync开启异步任务）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.定时任务相关&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.@Enable*注解说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些注解主要用来开启对xxx的支持。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableAsync 开启异步方法的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableScheduling 开启计划任务的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableWebMvc 开启Web MVC的配置支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableJpaRepositories 开启对SpringData JPA Repository的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableTransactionManagement 开启注解式事务的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableTransactionManagement 开启注解式事务的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableCaching 开启注解式的缓存支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11.测试相关注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@RunWith 运行器，Spring中通常用于对JUnit的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@RunWith(SpringJUnit4ClassRunner.class)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ContextConfiguration(classes={TestConfig.class})&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;12.SpringMVC相关注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Controller 声明该类为SpringMVC中的Controller&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上， &lt;/span&gt;&lt;br/&gt;&lt;span&gt;这对所有注解了 @RequestMapping的控制器内的方法有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ExceptionHandler 用于全局处理控制器里的异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。 &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 15:26:00 +0000</pubDate>
<dc:creator>Java-live-begin</dc:creator>
<og:description>Java 必须掌握的 12 种 Spring 常用注解！ 1.声明bean的注解 @Component 组件，没有明确的角色 @Service 在业务逻辑层使用（service层） @Reposito</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wang-Java-begining/p/9874063.html</dc:identifier>
</item>
<item>
<title>傻瓜式解读koa中间件处理模块koa-compose - 若邪</title>
<link>http://www.cnblogs.com/jaycewu/p/9873980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaycewu/p/9873980.html</guid>
<description>&lt;p&gt;最近需要单独使用到koa-compose这个模块，虽然使用koa的时候大致知道中间件的执行流程，但是没仔细研究过源码用起来还是不放心(主要是这个模块代码少，多的话也没兴趣去研究了)。&lt;/p&gt;
&lt;p&gt;koa-compose看起来代码少，但是确实绕。闭包，递归，Promise。。。看了一遍脑子里绕不清楚。看了网上几篇解读文章，都是针对单行代码做解释，还是绕不清楚。最后只好采取一种傻瓜的方式：&lt;/p&gt;
&lt;p&gt;koa-compose去掉一些注释，类型校验后，源码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function compose (middleware) {
  return function (context, next) {
    // last called middleware #
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      if (i &amp;lt;= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写出如下代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var index = -1;
function compose() {
    return dispatch(0)
}
function dispatch (i) {
      if (i &amp;lt;= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      var fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve('fn is undefined')
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
 }
 
 function f1(context,next){
    console.log('middleware 1');
    next().then(data=&amp;gt;console.log(data));
    console.log('middleware 1');
    return 'middleware 1 return';
  }
  function f2(context,next){
    console.log('middleware 2');
    next().then(data=&amp;gt;console.log(data));
    console.log('middleware 2');
    return 'middleware 2 return';
  }
  function f3(context,next){
    console.log('middleware 3');
    next().then(data=&amp;gt;console.log(data));
    console.log('middleware 3');
    return 'middleware 3 return';
  }
var middleware=[
  f1,f2,f3
]

var context={};
var next=function(context,next){
    console.log('middleware 4');
    next().then(data=&amp;gt;console.log(data));
    console.log('middleware 4');
    return 'middleware 4 return';
};
compose().then(data=&amp;gt;console.log(data));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接运行结果如下：&lt;/p&gt;
&lt;p&gt;&quot;middleware 1&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 1&quot;&lt;/p&gt;
&lt;p&gt;&quot;fn is undefined&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 1 return&quot;&lt;/p&gt;
&lt;p&gt;按着代码运行流程一步步分析：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dispatch(0)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;i==0,index==-1 i&amp;gt;index 往下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;index=0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;fn=f1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve(f1(context, dispatch.bind(null, 0 + 1)))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这就会执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;f1(context, dispatch.bind(null, 0 + 1))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;进入到f1执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 1');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 1&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实就是调用&lt;code&gt;dispatch(1)&lt;/code&gt; bind的功劳&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;递归开始&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dispatch(1)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;i==1,index==0 i&amp;gt;index 往下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;index=1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;fn=f2&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve(f2(context, dispatch.bind(null, 1 + 1)))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这就会执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;f2(context, dispatch.bind(null, 1 + 1))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;进入到f2执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 2');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 2&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实就是调用&lt;code&gt;dispatch(2)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着递归&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dispatch(2)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;i==2,index==1 i&amp;gt;index 往下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;index=2&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;fn=f3&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve(f3(context, dispatch.bind(null, 2 + 1)))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这就会执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;f3(context, dispatch.bind(null, 2 + 1))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;进入到f3执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 3');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 3&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实就是调用&lt;code&gt;dispatch(3)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着递归&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dispatch(3)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;i==3,index==2 i&amp;gt;index 往下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;index=3&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;i === middleware.length&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fn=next&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve(next(context, dispatch.bind(null, 3 + 1)))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这就会执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;next(context, dispatch.bind(null, 3 + 1))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;进入到next执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 4');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 4&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实就是调用&lt;code&gt;dispatch(4)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着递归&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dispatch(4)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;i==4,index==3 i&amp;gt;index 往下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;index=4&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fn=middleware[4]&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fn=undefined&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;reuturn Promise.resolve('fn is undefined')&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;回到next执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 4');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 4&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;return 'middleware 4 return'&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve('middleware 4 return')&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;回到f3执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 3');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 3&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;return 'middleware 3 return'&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve('middleware 3 return')&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;回到f2执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 2');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 2&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;return 'middleware 2 return'&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve('middleware 2 return')&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;回到f1执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 1');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 1&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;return 'middleware 1 return'&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve('middleware 1 return')&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;回到全局上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至此已经输出&lt;/p&gt;
&lt;p&gt;&quot;middleware 1&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 1&quot;&lt;/p&gt;
&lt;p&gt;那么&lt;/p&gt;
&lt;p&gt;&quot;fn is undefined&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 1 return&quot;&lt;/p&gt;
&lt;p&gt;怎么来的呢&lt;/p&gt;
&lt;p&gt;回头看一下，每个中间件里都有&lt;/p&gt;
&lt;p&gt;&lt;code&gt;next().then(data=&amp;gt;console.log(data));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照之前的分析，then里最先拿到结果的应该是next中间件的，而且结果就是&lt;code&gt;Promise.resolve('fn is undefined')&lt;/code&gt;的结果，然后分别是f4,f3,f2,f1。那么为什么都是最后才输出呢？&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Promise.resolve('fn is undefined').then(data=&amp;gt;console.log(data));
console.log('middleware 4');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下就清楚了&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;setTimeout(()=&amp;gt;console.log('fn is undefined'),0);
console.log('middleware 4');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个调用过程还可以看成是这样的：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function composeDetail(){
  return Promise.resolve(
    f1(context,function(){
      return Promise.resolve(
        f2(context,function(){
          return Promise.resolve(
            f3(context,function(){
              return Promise.resolve(
                next(context,function(){
                  return Promise.resolve('fn is undefined')
                })
              )
            })
          )
        })
      )
    })
  )
}
composeDetail().then(data=&amp;gt;console.log(data));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法虽蠢，但是compose的作用不言而喻了&lt;/p&gt;
&lt;p&gt;最后，&lt;code&gt;if (i &amp;lt;= index) return Promise.reject(new Error('next() called multiple times'))&lt;/code&gt;这句代码何时回其作用呢？&lt;/p&gt;
&lt;p&gt;一个中间件里调用两次&lt;code&gt;next()&lt;/code&gt;，按照上面的套路走，相信很快就明白了。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 15:06:00 +0000</pubDate>
<dc:creator>若邪</dc:creator>
<og:description>最近需要单独使用到koa compose这个模块，虽然使用koa的时候大致知道中间件的执行流程，但是没仔细研究过源码用起来还是不放心(主要是这个模块代码少，多的话也没兴趣去研究了)。 koa comp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jaycewu/p/9873980.html</dc:identifier>
</item>
<item>
<title>实验的方差分析（R语言） - EndlessCoding</title>
<link>http://www.cnblogs.com/endlesscoding/p/9863790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endlesscoding/p/9863790.html</guid>
<description>&lt;blockquote readability=&quot;5.709219858156&quot;&gt;
&lt;p&gt;实验设计与数据处理（大数据分析B中也用到F分布，故总结一下，加深印象）第3课小结——实验的方差分析（one-way analysis of variance）&lt;br/&gt;文章出自：&lt;a href=&quot;https://www.cnblogs.com/endlesscoding/p/9863790.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/endlesscoding/p/9863790.html&lt;/a&gt;，未经博主同意，请勿转载。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;实验结果&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;受多个因素&lt;span class=&quot;math inline&quot;&gt;\(A_i\)&lt;/span&gt;影响，但影响的程度各不相同，如何通过实验数据来确定因素的影响程度呢？其函数关系为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ S=f(A_1,A_2,\cdots,A_n) \tag{1} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方差&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;标准差的平方&lt;/code&gt;，表征&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(\bar{x}\)&lt;/span&gt;的&lt;strong&gt;偏离程度&lt;/strong&gt;。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;方差分析（ANalysis Of VAriance，简称&lt;code&gt;ANOVA&lt;/code&gt;）&lt;br/&gt;利用实验数据与均值的&lt;strong&gt;偏离程度&lt;/strong&gt;来判断各因素对实验结果影响&lt;code&gt;显著性&lt;/code&gt;程度的方法。 方差分析实质上是研究&lt;code&gt;自变量&lt;/code&gt;（因素）与&lt;code&gt;因变量&lt;/code&gt;（实验结果）的相互关系&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;指标（experimental index）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;衡量或考核实验效果的参数 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因素（experimental factor）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;影响实验指标的条件，可控因素&lt;/p&gt;
&lt;p&gt;因素的不同状态或内容&lt;/p&gt;

&lt;h2 id=&quot;单因素实验方差分析基本问题&quot;&gt;单因素实验方差分析基本问题&lt;/h2&gt;
&lt;p&gt;（1）目的：检验一个因素对实验结果的影响是否显著性&lt;/p&gt;
&lt;h2 id=&quot;单因素实验方差分析基本步骤&quot;&gt;单因素实验方差分析基本步骤&lt;/h2&gt;
&lt;h3 id=&quot;计算平均值&quot;&gt;1）计算平均值&lt;/h3&gt;
&lt;p&gt;组内平均值（同一水平的平均值）&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x_i}=\frac{1}{n_i}\sum_{j=1}^{n_i}{x_{ij}} \tag{2} \]&lt;/span&gt;&lt;br/&gt;总平均值&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline {x_i}=\frac{1}{n}\sum_{i=1}^{r}\sum_{j=1}^{n_i}{x_{ij}} \tag{3} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算离差平方和&quot;&gt;2）计算离差平方和&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;总离差平方和&lt;span class=&quot;math inline&quot;&gt;\(SS_T\)&lt;/span&gt;（sum of squares for total）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_T = \sum_{i=1}^{r}{\sum_{j=1}^{n_i}({x_{ij}-\overline{x}})^2} \tag{4} \]&lt;/span&gt;&lt;br/&gt;表示了各实验值与总平均值的偏差的平方和&lt;br/&gt;反映了实验结果之间存在的总差异&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;组间离差平方和 &lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt; （sum of square for factor A）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_A = \sum_{i=1}^{r}{\sum_{j=1}^{n_i}({\overline{x_{i}}-\overline{x}})^2} =\sum_{i=1}^{r}n_i({\overline{x_{i}}-\overline{x}})^2 \tag{5} \]&lt;/span&gt;&lt;br/&gt;反映了各组内平均值之间的差异程度&lt;br/&gt;由于因素A不同水平的不同作用造成的&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;组内离差平方和$ SS_e $（sum of square for error）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_T = \sum_{i=1}^{r}{\sum_{j=1}^{n_i}({x_{ij}-\overline{x}_i})^2} \tag{6} \]&lt;/span&gt;&lt;/p&gt;
反映了在各水平内，各实验值之间的差异程度&lt;br/&gt;由于随机误差的作用产生&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;三种离差平方和之间关系：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_T = SS_A + SS_e \tag{7} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;计算自由度degree-of-freedom&quot;&gt;3）计算自由度（degree of freedom）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;总自由度（&lt;span class=&quot;math inline&quot;&gt;\(SS_T\)&lt;/span&gt;对应的自由度）：&lt;span class=&quot;math inline&quot;&gt;\(df_T=n-1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;组间自由度（&lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt;对应的自由度）：&lt;span class=&quot;math inline&quot;&gt;\(df_A=r-1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;组内自由度（&lt;span class=&quot;math inline&quot;&gt;\(SS_e\)&lt;/span&gt;对就的自由度）：&lt;span class=&quot;math inline&quot;&gt;\(df_e=n-r\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;三者关系：&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_T=df_A+df_e\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算平均平方&quot;&gt;4）计算平均平方&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;均方 = 离差平方和除以对应的自由度&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ MS_A = SS_A/df_A \quad \quad MS_e = SS_e / df_e \]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;式中，&lt;span class=&quot;math inline&quot;&gt;\(MA_A\)&lt;/span&gt;——组间均方，&lt;span class=&quot;math inline&quot;&gt;\(MS_e\)&lt;/span&gt;——组内均方/误差的均方&lt;/p&gt;
&lt;h3 id=&quot;f检验&quot;&gt;5）F检验&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ F_A = \frac{组间均方}{组内均方}=\frac{MS_A}{MS_e} \tag{8} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_A,df_e)\)&lt;/span&gt;的&lt;code&gt;F分布&lt;/code&gt;（F distribution）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于给定的显著性水平&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;，从&lt;code&gt;F分布表&lt;/code&gt;查得临界值&lt;span class=&quot;math inline&quot;&gt;\(F_{\alpha}(df_A,df_e)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_A &amp;gt; F_{\alpha}(df_A,df_e)\)&lt;/span&gt;，则认为因素A对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素A对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;方差分析表&quot;&gt;6）方差分析表&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;组间（因素A）&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(r-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A=SS_A/(r-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;组内（误差）&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(n-r\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_e=SS_e/(n-r)\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;总和&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_T\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;若&lt;span class=&quot;math inline&quot;&gt;\(F_A &amp;gt; F_{0.01}(df_A,df_e)\)&lt;/span&gt;，称因素A对实验结果有&lt;code&gt;非常显著&lt;/code&gt;的影响，用&lt;code&gt;**&lt;/code&gt;号表示；&lt;/li&gt;
&lt;li&gt;若&lt;span class=&quot;math inline&quot;&gt;\(F_{0.05}(df_A,df_e)&amp;lt;F_A&amp;lt;F_{0.01}(df_A,df_e)\)&lt;/span&gt;，则因素A对实验结果&lt;code&gt;有显著&lt;/code&gt;的影响，用&lt;code&gt;*&lt;/code&gt;号表示；&lt;/li&gt;
&lt;li&gt;若&lt;span class=&quot;math inline&quot;&gt;\(F_A &amp;lt; F_{0.05}(df_A,df_e)\)&lt;/span&gt;，称因素A对实验结果的影响&lt;code&gt;不显著&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;讨论两个因素对实验结果影响的显著性，以称&lt;code&gt;二元方差分析&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;双因素无重复实验的方差分析&quot;&gt;双因素无重复实验的方差分析&lt;/h2&gt;
&lt;p&gt;双因素无重复实验&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{11}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{12}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{1s}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{21}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{22}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{2s}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_r\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{r1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{r2}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{rs}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;计算平均值-1&quot;&gt;1）计算平均值&lt;/h3&gt;
&lt;p&gt;总平均：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} = \frac{1}{rs}\sum_{i=1}^{r}{\sum_{j=1}^{s}x_{ij}} \tag{9} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_i\)&lt;/span&gt;水平时：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x}_{i\cdot} = \frac{1}{s}\sum_{j=1}^{s}x_{ij} \tag{10} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(B_j\)&lt;/span&gt;水平时：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x}_{{\cdot}j}= \frac{1}{r}\sum_{i=1}^{s}x_{ij} \tag{11} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算离差平方和-1&quot;&gt;2）计算离差平方和&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;总离差平方和：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} =\sum_{i=1}^{r}{\sum_{j=1}^{s}{(x_{ij}-\overline{x})^2}} \tag{12} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因素A引起离差平方和:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} =\sum_{i=1}^{r}{\sum_{j=1}^{s}{(x_{i{\cdot}}-\overline{x})^2}}=s\sum_{j=1}^{r}{(x_{i{\cdot}}-\overline{x})^2} \tag{13} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因素B引起的离差平方和:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} =\sum_{i=1}^{r}{\sum_{j=1}^{s}{(x_{{\cdot}j}-\overline{x})^2}}=r\sum_{j=1}^{s}{(x_{{\cdot}j}-\overline{x})^2} \tag{14} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;误差平方和:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} =\sum_{i=1}^{r}{\sum_{j=1}^{s}{(x_{ij}-x_{i{\cdot}}-x_{{\cdot}j}-\overline{x})^2}} \tag{15} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算自由度&quot;&gt;3）计算自由度&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_A=r-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_B=s-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_e=(r-1)(s-f)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_T=n-1=rs-1\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;计算均方&quot;&gt;4）计算均方&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A=\dfrac{SS_A}{df_A}=\dfrac{SS_A}{r-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B=\dfrac{SS_B}{df_A}=\dfrac{SS_B}{s-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_e=\dfrac{SS_e}{df_e}=\dfrac{SS_e}{(r-1)(s-1)}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;f-检验&quot;&gt;5）F 检验&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_A\)&lt;/span&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_A,df_e)\)&lt;/span&gt;的F分布：&lt;span class=&quot;math inline&quot;&gt;\(F_A=\dfrac{MS_A}{MS_e}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_B\)&lt;/span&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_B,df_e)\)&lt;/span&gt;的F分布：&lt;span class=&quot;math inline&quot;&gt;\(F_A=\dfrac{MS_B}{MS_e}\)&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于给定的的显著性水平&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;，查F分布表：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ F_{\alpha}(df_A,df_e) \quad \quad F_{\alpha}(df_B,df_e) \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_A &amp;gt; F_{\alpha}(df_A,df_e)\)&lt;/span&gt;，则认为因素A对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素A对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_B &amp;gt; F_{\alpha}(df_B,df_e)​\)&lt;/span&gt;，则认为因素A对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素A对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;无重复实验双因素方差分析表&quot;&gt;6）无重复实验双因素方差分析表&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;因素A&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(r-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A=SS_A/(r-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;因素B&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_B\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(s-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B=SS_B/(s-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;误差&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\((r-1)(s-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_e=SS_e/((r-1)(s-1))\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;总和&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_T\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(rs-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;双因素重复实验基本问题&quot;&gt;双因素重复实验基本问题&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;交互作用——因素间的联全作用称为交互作用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;因素间没有联合作用——相互独立，独立效应&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;因素间有联合作用——交互作用，交互效应&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;双因素重复实验方差分析基本步骤&quot;&gt;双因素重复实验方差分析基本步骤&lt;/h2&gt;
&lt;h3 id=&quot;计算平均值-2&quot;&gt;1）计算平均值&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;组合水平&lt;span class=&quot;math inline&quot;&gt;\(（A_i,B_i）\)&lt;/span&gt;上的&lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;次实验值的算术平均值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x}_{ij{\cdot}}=\frac{1}{c}\sum_{k=1}^{c}{x_{ijk}},i=1,2,\cdots,r;j=1,2,\cdots,s \tag{16} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_i\)&lt;/span&gt;水平时所有实验值的算术平均值：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x}_{i\cdot\cdot} = \frac{1}{sc}\sum_{j=1}^{s}x_{ijk} = \frac{1}{s}\sum_{j=1}^{s}x_{ijk},i=1,2,\cdots,r \tag{17} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(B_j\)&lt;/span&gt;水平时：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x}_{i\cdot\cdot} = \frac{1}{rc}\sum_{j=1}^{s}x_{ijk} = \frac{1}{r}\sum_{j=1}^{r}x_{ij\cdot},j=1,2,\cdots,s \tag{18} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有实验的总平均值：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} = \frac{1}{rsc} \sum_{i=1}^{r}\sum_{j=1}^{s}\sum_{k=1}^{c}x_{ijk} \tag{19} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算离差平方和-2&quot;&gt;2）计算离差平方和&lt;/h3&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;总离差平方和：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_T=\frac{1}{rsc}\sum_{i=1}^{r}\sum_{j=1}^{s}\sum_{k=1}^{c}{(x_{ijk}-\overline{x})^2} = SS_A+SS_B+SS_{A\times{B}}+SS_e \tag{20} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt;为A引起的离差平方和：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_A = sc\sum_{i=1}^{r}{(\overline{x}_{i\cdot\cdot}-\overline{x})^2} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_B\)&lt;/span&gt;为B引起的离差平方和：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_B = rc\sum_{j=1}^{s}{(\overline{x}_{\cdot{j}\cdot}-\overline{x})^2} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_{A\times{B}}\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(A\times{B}\)&lt;/span&gt;引起的离差平方和：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_{A\times{B}} = c\sum_{i=1}^{r}\sum_{j=1}{s}{(\overline{x}_{ij\cdot}-\overline{x}_{i\cdot\cdot}-\overline{x}_{\cdot{j}\cdot}+\overline{x})^2} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_e\)&lt;/span&gt;为误差平方和：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} = \sum_{i=1}^{r}\sum_{j=1}^{s}\sum_{k=1}^{c}{(x_{ijk}-\overline{x}_{ij\cdot})^2} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算自由度-1&quot;&gt;3）计算自由度&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_A=r-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_B=s-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_{A\times{B}}=(r-1)(n-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_e=rs(c-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_T=n-1=rsc-1\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;计算均方-1&quot;&gt;4）计算均方&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A=\dfrac{SS_A}{df_A}=\dfrac{SS_A}{r-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B=\dfrac{SS_B}{df_A}=\dfrac{SS_B}{s-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_{A\times{B}}=\dfrac{SS_{A\times{B}}}{(r-1)(s-1)}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_e=\dfrac{SS_e}{df_e}=\dfrac{SS_e}{rs(c-1)}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;f-检验-1&quot;&gt;5）F 检验&lt;/h3&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_A\)&lt;/span&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_A,df_e)\)&lt;/span&gt;的F分布：&lt;span class=&quot;math inline&quot;&gt;\(F_A=\dfrac{MS_A}{MS_e}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_B\)&lt;/span&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_B,df_e)\)&lt;/span&gt;的F分布：&lt;span class=&quot;math inline&quot;&gt;\(F_A=\dfrac{MS_B}{MS_e}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_{A\times{B}}\)&lt;/span&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_{A\times{B}},df_e)\)&lt;/span&gt;的F分布：&lt;span class=&quot;math inline&quot;&gt;\(F_A=\dfrac{MS_{A\times{B}}}{MS_e}\)&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;对于给定的的显著性水平&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;，查F分布表：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ F_{\alpha}(df_A,df_e) \quad \quad F_{\alpha}(df_B,df_e) \quad \quad F_{\alpha}(df_{A\times{B}},df_e) \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_A &amp;gt; F_{\alpha}(df_A,df_e)\)&lt;/span&gt;，则认为因素A对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素A对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_B &amp;gt; F_{\alpha}(df_B,df_e)\)&lt;/span&gt;，则认为因素B对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素B对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_{A\times{B}}&amp;gt; F_{\alpha}(df_{A\times{B}},df_e)\)&lt;/span&gt;，则认为交互作用&lt;span class=&quot;math display&quot;&gt;\[A\times{B}\]&lt;/span&gt;对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素&lt;span class=&quot;math inline&quot;&gt;\(A\times{B}\)&lt;/span&gt;对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;重复实验双因素方差分析表&quot;&gt;6）重复实验双因素方差分析表&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;因素A&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(r-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A=SS_A/(r-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;因素B&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_B\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(s-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B=SS_B/(s-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;交互作用&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_{A\times{B}}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\((r-1)(s-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_{A\times{B}}=\dfrac{SS_{A\times{B}}}{(r-1)(s-1)}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_{A\times{B}}/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;误差&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(rs(c-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_c=SS_e/(rs(c-1))\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;总和&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_T\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(rsc-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;r语言重复实验方差分析&quot;&gt;R语言重复实验方差分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;例:&lt;/strong&gt;下表中给出了某种化式产品在3种浓度、4种温度水平下得率的数据，试检验各因素及交互作用对产品得率的影响是否显著。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;14,11&lt;/td&gt;
&lt;td&gt;11,11&lt;/td&gt;
&lt;td&gt;13,9&lt;/td&gt;
&lt;td&gt;10,12&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;9,7&lt;/td&gt;
&lt;td&gt;10,8&lt;/td&gt;
&lt;td&gt;7,11&lt;/td&gt;
&lt;td&gt;6,10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5,11&lt;/td&gt;
&lt;td&gt;13,14&lt;/td&gt;
&lt;td&gt;12,13&lt;/td&gt;
&lt;td&gt;14,10&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们令：A因素：&lt;strong&gt;浓度&lt;/strong&gt;，B因素：&lt;strong&gt;温度&lt;/strong&gt;，由题可得，重复次数&lt;span class=&quot;math inline&quot;&gt;\(c=2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以分析出如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td/&gt;
&lt;td&gt;浓度/%&lt;/td&gt;
&lt;td&gt;10℃&lt;/td&gt;
&lt;td&gt;24℃&lt;/td&gt;
&lt;td&gt;38℃&lt;/td&gt;
&lt;td&gt;52℃&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;14,11&lt;/td&gt;
&lt;td&gt;11,11&lt;/td&gt;
&lt;td&gt;13,9&lt;/td&gt;
&lt;td&gt;10,12&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;9,7&lt;/td&gt;
&lt;td&gt;10,8&lt;/td&gt;
&lt;td&gt;7,11&lt;/td&gt;
&lt;td&gt;6,10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_3\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5,11&lt;/td&gt;
&lt;td&gt;13,14&lt;/td&gt;
&lt;td&gt;12,13&lt;/td&gt;
&lt;td&gt;14,10&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;接下来，我们在&lt;code&gt;RStudio&lt;/code&gt;（如果RStudio没有安装的，网上有大量的教程）中录入我们的数据，代码如下&lt;/p&gt;
&lt;pre class=&quot;r&quot;&gt;
&lt;code&gt;X &amp;lt;- c(14,9,5,11,10,13,13,7,12,10,6,14,10,7,11,11,8,14,9,11,13,12,10,10)
chemistryProduct&amp;lt;-data.frame(X,A=gl(3,1,24),B=gl(4,3,24),c=gl(12,1,24))
chemistryProduct.aov&amp;lt;-aov(X~A*B,data = chemistryProduct)
summary(chemistryProduct.aov)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;对上述代码的第1行和第2行简单说明一下。&lt;br/&gt;第1行中，X数据的输入，是以列的方向输入，先输入第1次实验的数据，输入完成后再按第1次的顺序输入第2次实验数据。&lt;/p&gt;
&lt;p&gt;第2行中，&lt;code&gt;A=gl(3,1,24)&lt;/code&gt;，第一个数&lt;code&gt;3&lt;/code&gt;表示有3行，第二个数&lt;code&gt;1&lt;/code&gt;表示行方向只增加1，第三个数&lt;code&gt;24&lt;/code&gt;表示总共有24个数据。后面的同理。可以查看一下它的输出如下，不难发现其中的输入规律。&lt;/p&gt;
&lt;p&gt;可以在RStudio中查看chemistryProduct的数据结构，多试一下，自行体会一下其中的A，B，c的规律。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;&amp;gt; chemistryProduct
    X A B  c
1  14 1 1  1
2   9 2 1  2
3   5 3 1  3
4  11 1 2  4
5  10 2 2  5
6  13 3 2  6
7  13 1 3  7
8   7 2 3  8
9  12 3 3  9
10 10 1 4 10
11  6 2 4 11
12 14 3 4 12
13 10 1 1  1
14  7 2 1  2
15 11 3 1  3
16 11 1 2  4
17  8 2 2  5
18 14 3 2  6
19  9 1 3  7
20 11 2 3  8
21 13 3 3  9
22 12 1 4 10
23 10 2 4 11
24 10 3 4 12&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到如下输出结果：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;            Df Sum Sq Mean Sq F value Pr(&amp;gt;F)  
A            2  44.33  22.167   4.092 0.0442 *
B            3  11.50   3.833   0.708 0.5657  
A:B          6  27.00   4.500   0.831 0.5684  
Residuals   12  65.00   5.417                 
---
Signif. codes:  
0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将实验结果写成上文所述的方差分析表，如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;因素A&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;44.33&lt;/td&gt;
&lt;td&gt;22.167&lt;/td&gt;
&lt;td&gt;4.092&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;因素B&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;11.50&lt;/td&gt;
&lt;td&gt;3.833&lt;/td&gt;
&lt;td&gt;0.708&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;交互作用&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;27.00&lt;/td&gt;
&lt;td&gt;4.500&lt;/td&gt;
&lt;td&gt;0.831&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;误差&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;65.00&lt;/td&gt;
&lt;td&gt;5.417&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;总和&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由分析结果可知，因素A对产品得率有显著性影响。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 15:00:00 +0000</pubDate>
<dc:creator>EndlessCoding</dc:creator>
<og:description>实验设计与数据处理（大数据分析B中也用到F分布，故总结一下，加深印象）第3课小结——实验的方差分析（one way analysis of variance） 文章出自：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/endlesscoding/p/9863790.html</dc:identifier>
</item>
<item>
<title>Python 装饰器入门(下) - 丁壮</title>
<link>http://www.cnblogs.com/flashBoxer/p/9873918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashBoxer/p/9873918.html</guid>
<description>&lt;p&gt;继续上次的进度:https://www.cnblogs.com/flashBoxer/p/9847521.html&lt;/p&gt;

&lt;h3&gt;装饰类&lt;/h3&gt;
&lt;p&gt;在类中有两种不通的方式使用装饰器，第一个和我们之前做过的函数非常相似:在类的方法上应用。这也是当时引入装饰器的原因之一&lt;/p&gt;&lt;p&gt;一些常用的装饰器已经内置到python中，像@classmethod @staticmethod @property。这三个装饰器我们之前都介绍过，这段就不翻译了(打字手酸，偷懒下)&lt;/p&gt;&lt;p&gt;下面的Circle 类使用了@classmethod @staticmethod和@property三个装饰器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Circle:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, radius):
        self._radius &lt;/span&gt;=&lt;span&gt; radius

    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; radius(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Get value of radius&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._radius

    @radius.setter
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; radius(self, value):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Set radius, raise error if negative&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; value &amp;gt;=&lt;span&gt; 0:
            self._radius &lt;/span&gt;=&lt;span&gt; value
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Radius must be positive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; area(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Calculate area inside circle&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self.pi() * self.radius**2

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; cylinder_volume(self, height):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Calculate volume of cylinder with circle as base&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self.area *&lt;span&gt; height

    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; unit_circle(cls):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Factory method creating a circle with radius 1&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; cls(1&lt;span&gt;)

    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pi():
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Value of π, could use math.pi instead though&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; 3.1415926535
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个类中&lt;br/&gt;    .cylinder_volume()是一个常规函数&lt;br/&gt;    .radius是一个可变属性:它可以被设置不同的值.然而通过定义setter方法，我们可以做一些判断来确保它不会被设置成一个没有意义的负数，.radius作为属性访问，不使用括号&lt;br/&gt;    .area 是一个不可变的属性:没有.setter()方法的属性是无法更改的，即使它被定义为一个方法，它也被作为不需要括号的属性来使用。&lt;br/&gt;    .unit_circle() 是一个类方法。它不被绑定到Circle的实例上.类方法通常用在工厂模式，用来创建类的特殊实例&lt;br/&gt;    .pi() 是一个静态方法.除了命名空间外它不依赖Circle类。静态方法可以在实例或类上调用。&lt;/p&gt;

&lt;p&gt;Circle类的使用例子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; c = Circle(5&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; c.radius
&lt;/span&gt;5

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; c.area
&lt;/span&gt;78.5398163375

&amp;gt;&amp;gt;&amp;gt; c.radius = 2
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; c.area
&lt;/span&gt;12.566370614

&amp;gt;&amp;gt;&amp;gt; c.area = 100&lt;span&gt;
AttributeError: can&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t set attribute&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt; c.cylinder_volume(height=4&lt;span&gt;)
&lt;/span&gt;50.265482456

&amp;gt;&amp;gt;&amp;gt; c.radius = -1&lt;span&gt;
ValueError: Radius must be positive

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; c =&lt;span&gt; Circle.unit_circle()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; c.radius
&lt;/span&gt;1

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; c.pi()
&lt;/span&gt;3.1415926535

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; Circle.pi()
&lt;/span&gt;3.1415926535
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让我们定义一个类，在这个类中，我们会用到前面的@debug和@timer装饰器:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; debug, timer

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TimeWaster:
    @debug
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, max_num):
        self.max_num &lt;/span&gt;=&lt;span&gt; max_num

    @timer
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; waste_time(self, num_times):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_times):
            sum([i&lt;/span&gt;**2 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(self.max_num)])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看一下结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; tw = TimeWaster(1000&lt;span&gt;)
Calling &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;(&amp;lt;time_waster.TimeWaster object at 0x7efccce03908&amp;gt;, 1000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; returned None

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; tw.waste_time(999&lt;span&gt;)
Finished &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;waste_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; 0.3376 secs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外一种方式是在整个类上使用装饰器.这里有个Python3.7中的dataclasses方法用例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; dataclasses &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dataclass

@dataclass
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PlayingCard:
    rank: str
    suit: str&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语法的类似于函数装饰器。在上面的例子中，也可以通过PlayingCard = dataclass(PlayingCard)来实现。&lt;/p&gt;&lt;p&gt;类装饰器的一种简单用法是作为元类方式的替代.在两种情况下，你都在动态的改变一个类的定义&lt;/p&gt;&lt;p&gt;类的装饰器和函数的装饰器语法接近，不同的是装饰器需要接收一个类而不是一个函数作为参数.事实上，上面的装饰器都可以作用于类，但当你这么用的时候，你可能得不到预期的结果。下面将@timer装饰器应用到一个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; timer

@timer
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TimeWaster:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, max_num):
        self.max_num &lt;/span&gt;=&lt;span&gt; max_num

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; waste_time(self, num_times):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_times):
            sum([i&lt;/span&gt;**2 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(self.max_num)])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@timer只是TimeWaster = timer(TimeWaster)的缩写&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在这里@timer只能显示类实例化需要的时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; tw = TimeWaster(1000&lt;span&gt;)
Finished &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TimeWaster&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; 0.0000&lt;span&gt; secs

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; tw.waste_time(999&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在后面会有一个正确的类装饰器的示例@singleton。它保证一个类只有一个实例&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;嵌套的装饰器&lt;/h3&gt;
&lt;p&gt;&lt;br/&gt;可以将多个装饰器叠加到一个函数上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; debug, do_twice

@debug
@do_twice
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; greet(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行的顺序会按照叠加的顺序, @debug 调用 @do_twice @do_twice 调用greet()，或者debug(do_twice(greet()))  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; greet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Eva&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Calling greet(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Eva&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Hello Eva
Hello Eva
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greet&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; returned None        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更改@debug和@do_twice的顺序:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; debug, do_twice

@do_twice
@debug
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; greet(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这种情况下，@do_twice也会被应用到@debug中: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; greet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Eva&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Calling greet(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Eva&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Hello Eva
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greet&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; returned None
Calling greet(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Eva&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Hello Eva
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greet&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; returned None       
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;带参数的装饰器&lt;/h3&gt;
&lt;p&gt; 在需要传参给你的装饰器是这个例子会非常有用。例如,@do_twice可以扩展到@repeat(num_times)装饰器.然后，可以将执行的被装饰函数的次数作为参数给出。      &lt;br/&gt;可以这么做:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@repeat(num_times=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; greet(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)      
        
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; greet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Hello World
Hello World
Hello World
Hello World        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       &lt;br/&gt;考虑下如何实现这个功能&lt;/p&gt;&lt;p&gt;到目前为止,写在@后面写的名字引用一个可以被另外一个函数调用的函数对象，需要repeat(num_times=4)来返回一个函数对象，这个对象可以被作为装饰器，幸运的是，我们已经知道如何返回函数!一般来说，需要以下内容:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; repeat(num_times):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_repeat(func):
        ...  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create and return a wrapper function&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; decorator_repeat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常，装饰器创建并返回一个内部包装函数，所以完整地写出这个例子会给你一个内部函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; repeat(num_times):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_repeat(func):
        @functools.wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_repeat(*args, **&lt;span&gt;kwargs):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_times):
                value &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_repeat
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_repeat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子看起来有点乱，但我们只是添加了一个def来接收参数，这个装饰器语法我们之前处理过多次.让我们从最里面的函数开始:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; wrapper_repeat(*args, **&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_times):
        value &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;wrapper_repeat()函数接收任意参数，并放回被装饰函数的值，func(). 这个包装函数还包括了被装饰函数num_times的循环 ，除了必须要使用外部参数num_times外，和之前看到的装饰器函数没有什么不同，&lt;/p&gt;&lt;p&gt;再走一步，你就会发现装饰器函数:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_repeat(func):
    @functools.wraps(func)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_repeat(*args, **&lt;span&gt;kwargs):
        ...
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; wrapper_repeat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;decorator_repeat()和我们之前写的装饰器函数非常像,除了他的名字不同,因为我们为最外层的函数保留了基础名称repeat()，这个是用户要调用的函数。&lt;/p&gt;&lt;p&gt;最外层返回装饰器函数的引用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; repeat(num_times):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_repeat(func):
        ...
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_repeat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在repeat()中有一些细节:&lt;/p&gt;
&lt;p&gt;        将decorator_repeat()作为一个内部函数意味着repeat()将引用一个函数对象-decotator_repeat.之前，我们用没有括号的repeat来引用函数对象.定义带有参数的装饰器，就需要添加括号&lt;br/&gt;        &lt;br/&gt;        num_times参数看起来没有在repeat()本身中使用，但是通过传递num_times，会创建一个闭包，来存储num_times的值，直到wrapper_repeat()使用它为止。&lt;br/&gt;    &lt;br/&gt;一切就绪后，让我们看看结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@repeat(num_times=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; greet(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; greet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Hello World
Hello World
Hello World
Hello World&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;这是我们想要的结果&lt;/p&gt;
&lt;h3&gt;Both Please, But Never Mind the Bread&lt;/h3&gt;
&lt;p&gt;稍微注意下.你可以把装饰器同时定义为带参数或者不带参数.你可能不需要这样，但更有灵活性也不错&lt;/p&gt;&lt;p&gt;前面已经看到，当装饰器需要参数的时候，需要有一个额外的外部函数，困难在于，代码需要知道装饰器是否被调用了，是否有参数&lt;/p&gt;&lt;p&gt;因为只有在没有参数的情况下调用装饰器时才会直接传递装饰的函数，这个函数必须是可选参数.意味着装饰器参数必须要友关键字指定，可以使用特殊的*，也就是说，下面的参数都是关键字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; name(_func=None, *, kw1=val1, kw2=val2, ...):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_name(func):
        ...  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create and return a wrapper function.&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; _func &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_name                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_name(_func)               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;_func参数是一个标记，提示装饰器被调用的时候是否有参数&lt;br/&gt;    1.如果name调用的时候没有传参,被装饰函数会被作为_func传入.如果有参数传入,_func会被置为None,一些关键字参数可能已不再是默认值， 参数列表中的*表示其余参数不能作为位置参数调用。&lt;/p&gt;&lt;p&gt;    2.装饰器可以传参调用，返回一个装饰器函数，它可以读取和返回一个函数&lt;br/&gt;    &lt;br/&gt;    3.装饰器不可以传参调用,会只将装饰器应用到函数上&lt;/p&gt;
&lt;p&gt;改造下之前的@repeat装饰器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; repeat(_func=None, *, num_times=2&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_repeat(func):
        @functools.wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_repeat(*args, **&lt;span&gt;kwargs):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_times):
                value &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_repeat

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; _func &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator_repeat
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_repeat(_func)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和之前的对比,唯一的变化是在末尾添加了_func参数和if-else。&lt;br/&gt;这些例子表明，@repeat现在可以在有或没有参数的情况下使用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@repeat
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; say_whee():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Whee!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

@repeat(num_times&lt;/span&gt;=3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; greet(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况num_times的值是2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee()
Whee!
Whee!

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; greet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Penny&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Hello Penny
Hello Penny
Hello Penny&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;有状态的装饰器&lt;/h3&gt;
&lt;p&gt;有时候，可以跟踪状态的装饰器也是很有用的.一个简单的例子，我们会创建一个统计函数调用次数的装饰器&lt;/p&gt;&lt;p&gt;注意:在教程的前面，我们讨论了基于给定参数返回值的纯函数.有状态的装饰器正好相反,返回值取决于当前状态以及给定的参数。&lt;/p&gt;&lt;p&gt;在下一节中，您将看到如何使用类来保持状态。但在简单的情况下，也可以使用函数属性:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; count_calls(func):
    @functools.wraps(func)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_count_calls(*args, **&lt;span&gt;kwargs):
        wrapper_count_calls.num_calls &lt;/span&gt;+= 1
        &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Call {wrapper_count_calls.num_calls} of {func.__name__!r}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*args, **&lt;span&gt;kwargs)
    wrapper_count_calls.num_calls &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_count_calls

@count_calls
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; say_whee():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Whee!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;状态——函数的调用次数——存储在包裹函数(wrapper_count_calls)的函数属性.num_calls中。下面是使用它的效果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee()
Call &lt;/span&gt;1 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;say_whee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Whee!

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee()
Call &lt;/span&gt;2 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;say_whee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Whee!

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee.num_calls
&lt;/span&gt;2
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;类装饰器&lt;/h3&gt;
&lt;p&gt;典型的维护状态的方式是使用类。在本节中，将看到如何重写@count_calls的例子来实现类装饰器&lt;/p&gt;&lt;p&gt;回想一下，装饰器语法@my_decorator只是func = my_decorator(func)一种方便快捷的用法.因此，如果my_decorator是一个类，需要在它的.__init__方法中接收func作为一个参数.而且,这个类需要是可以被调用的,这样它就可以替代装饰器函数了&lt;/p&gt;&lt;p&gt;如果需要一个类可以被调用,要实现.__call__方法(看示例:https://www.cnblogs.com/flashBoxer/tag/python/)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Counter:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, start=&lt;span&gt;0):
        self.count &lt;/span&gt;=&lt;span&gt; start

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;(self):
        self.count &lt;/span&gt;+= 1
        &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Current count is {self.count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.__call__方法每次运行都会尝试调用一个类的实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; counter =&lt;span&gt; Counter()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; counter()
Current count &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; 1

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; counter()
Current count &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; 2

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; counter.count
&lt;/span&gt;2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此，实现类装饰器需要实现.__init__和.__call__&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountCalls:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, func):
        functools.update_wrapper(self, func)
        self.func &lt;/span&gt;=&lt;span&gt; func
        self.num_calls &lt;/span&gt;=&lt;span&gt; 0

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        self.num_calls &lt;/span&gt;+= 1
        &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Call {self.num_calls} of {self.func.__name__!r}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.func(*args, **&lt;span&gt;kwargs)

@CountCalls
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; say_whee():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Whee!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.__init__方法必须可以存储一个函数的引用和能够做一些必要的初始化. 调用.__call__方法来替代装饰器函数.它做的和我们之前的 wrapper()函数基本一样，注意，这里使用functools.update_wrapper()函数，而不是@functools.wraps&lt;/p&gt;&lt;p&gt;这个@CountCalls装饰器的工作原理与前一节相同:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee()
Call &lt;/span&gt;1 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;say_whee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Whee!

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee()
Call &lt;/span&gt;2 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;say_whee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Whee!

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee.num_calls
&lt;/span&gt;2
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;

&lt;p&gt;&lt;br/&gt;我们已经学到了很多(看了下翻译的行数量，已经1K+了，确实很多)，已经学会如何创建各种各样的装饰师，把我们的新知识应用到创建更多的示例中，这些示例在现实中可能非常有用。&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;代码降速,重新访问&lt;/h3&gt;
&lt;p&gt;&lt;br/&gt;我们之前实现的@slow_down一直是保持sleep 1秒.现在你知道了如何给装饰器添加参数,因此，让我们来重写@slow_down，使用一个可选的rate参数来控制它的sleep时间:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; slow_down(_func=None, *, rate=1&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Sleep given amount of seconds before calling the function&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_slow_down(func):
        @functools.wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_slow_down(*args, **&lt;span&gt;kwargs):
            time.sleep(rate)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_slow_down

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; _func &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator_slow_down
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_slow_down(_func)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们使用  Both Please, But Never Mind the Bread  这里的样例来让@slow_down有参数和没有参数时都可调用，countdown()函数现在在每次计数之间休眠2秒:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@slow_down(rate=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; countdown(from_number):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; from_number &amp;lt; 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Liftoff!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(from_number)
        countdown(from_number &lt;/span&gt;- 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和前面一样，你最好自己写写，跑下看看结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; countdown(3&lt;span&gt;)
&lt;/span&gt;3
2
1&lt;span&gt;
Liftoff!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;创建单例模式&lt;/h3&gt;
&lt;p&gt;单例模式是一个只有一个实例的类.在Python经常使用的单例对象包括None,True和False.可以使用is来比较,像我们之前在Both Please的章节中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; _func &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator_name
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_name(_func)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is只对完全相同实例的对象返回True。下面的@singleton装饰器将类的第一个实例存储为属性，从而将类转换为单例对象。之后创建实例只是返回已经存储的实例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; singleton(cls):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Make a class a Singleton class (only one instance)&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    @functools.wraps(cls)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_singleton(*args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; wrapper_singleton.instance:
            wrapper_singleton.instance &lt;/span&gt;= cls(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_singleton.instance
    wrapper_singleton.instance &lt;/span&gt;=&lt;span&gt; None
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_singleton

@singleton
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TheOne:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个类装饰器和我们的函数装饰器基本一样.唯一不同的地方在于使用cls代替了fun来表示这是一个类装饰器&lt;/p&gt;
&lt;p&gt;看下运行结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; first_one =&lt;span&gt; TheOne()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; another_one =&lt;span&gt; TheOne()

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; id(first_one)
&lt;/span&gt;140094218762280

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; id(another_one)
&lt;/span&gt;140094218762280

&amp;gt;&amp;gt;&amp;gt; first_one &lt;span&gt;is&lt;/span&gt;&lt;span&gt; another_one
True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;很明显，first_one确实与另一个实例完全相同。&lt;/p&gt;
&lt;h3&gt;缓存返回值&lt;/h3&gt;
&lt;p&gt;装饰器可以提供很方便的缓存和记忆机制.作为一个例子，我们来看看斐波那契数列的递归定义:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; count_calls

@count_calls
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fibonacci(num):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num &amp;lt; 2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fibonacci(num - 1) + fibonacci(num - 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现很简单，性能很糟糕&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; fibonacci(10&lt;span&gt;)
&lt;/span&gt;&amp;lt;Lots of output &lt;span&gt;from&lt;/span&gt; count_calls&amp;gt;
55

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; fibonacci.num_calls
&lt;/span&gt;177
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了计算第10个斐波那契数，你实际上只需要计算前面的斐波那契数，但是这个实现需要177次计算。更糟糕的是:斐波纳契数列(20)需要21891次计算，第30次需要270万次计算。这是因为代码一直在重新计算已知的斐波那契数。&lt;/p&gt;&lt;p&gt;通常的解决方案是使用for循环和查找表来实现斐波那契数。但是，简单的计算缓存也可以做到这一点:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; count_calls

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; cache(func):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Keep a cache of previous function calls&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    @functools.wraps(func)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_cache(*args, **&lt;span&gt;kwargs):
        cache_key &lt;/span&gt;= args +&lt;span&gt; tuple(kwargs.items())
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cache_key &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; wrapper_cache.cache:
            wrapper_cache.cache[cache_key] &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_cache.cache[cache_key]
    wrapper_cache.cache &lt;/span&gt;=&lt;span&gt; dict()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_cache

@cache
@count_calls
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fibonacci(num):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num &amp;lt; 2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fibonacci(num - 1) + fibonacci(num - 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缓存作为查找表工作，所以现在fibonacci()只执行一次计算:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; fibonacci(10&lt;span&gt;)
Call &lt;/span&gt;1 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fibonacci&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
...
Call &lt;/span&gt;11 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fibonacci&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
55

&amp;gt;&amp;gt;&amp;gt; fibonacci(8&lt;span&gt;)
&lt;/span&gt;21
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，在对fibonacci(8)的最后调用中，没有进行新的计算，因为fibonacci(10)已经计算了第8个fibonacci数。&lt;br/&gt;在标准库中，提供了@functools.lru_cache。&lt;/p&gt;&lt;p&gt;这个装饰器比上面的例子要具备更多特性.我们应该使用@functools.lru_cache来代替我们自己写的缓存装饰器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

@functools.lru_cache(maxsize&lt;/span&gt;=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fibonacci(num):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Calculating fibonacci({num})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num &amp;lt; 2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fibonacci(num - 1) + fibonacci(num - 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;maxsize参数指定缓存了多少次调用。默认值是128，但是可以指定maxsize=None来缓存所有函数调用。但是，请注意，如果正在缓存许多很大的对象，这可能会导致内存问题。&lt;/p&gt;&lt;p&gt;可以使用.cache_info()方法查看缓存的执行情况，并在需要时进行调优。在我们的示例中，我们设定一个小maxsize来查看从缓存中删除元素的效果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; fibonacci(10&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;10&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;9&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;8&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;7&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;6&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;5&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;4&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;3&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;2&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;1&lt;span&gt;)
Calculating fibonacci(0)
&lt;/span&gt;55

&amp;gt;&amp;gt;&amp;gt; fibonacci(8&lt;span&gt;)
&lt;/span&gt;21

&amp;gt;&amp;gt;&amp;gt; fibonacci(5&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;5&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;4&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;3&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;2&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;1&lt;span&gt;)
Calculating fibonacci(0)
&lt;/span&gt;5

&amp;gt;&amp;gt;&amp;gt; fibonacci(8&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;8&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;7&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;6&lt;span&gt;)
&lt;/span&gt;21

&amp;gt;&amp;gt;&amp;gt; fibonacci(5&lt;span&gt;)
&lt;/span&gt;5

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; fibonacci.cache_info()
CacheInfo(hits&lt;/span&gt;=17, misses=20, maxsize=4, currsize=4)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;添加单元信息&lt;/h3&gt;
&lt;p&gt;下面的示例与前面的Registering Plugins示例有点类似，因为它不会真正改变被装饰函数的行为。相反，它只是将unit添加为函数属性:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; set_unit(unit):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Register a unit on a function&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_set_unit(func):
        func.unit &lt;/span&gt;=&lt;span&gt; unit
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_set_unit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的示例根据圆柱体的半径和高度(以厘米为单位)来计算体积:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; math

@set_unit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cm^3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; volume(radius, height):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; math.pi * radius**2 *&lt;span&gt; height   
    
这个.unit函数属性是可以访问的:    
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; volume(3, 5&lt;span&gt;)
&lt;/span&gt;141.3716694115407

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; volume.unit
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cm^3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，可以使用函数注释实现类似的功能: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; math

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; volume(radius, height) -&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cm^3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; math.pi * radius**2 * height   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，由于注释用于类型提示，因此很难将注释和静态类型检查相结合。   &lt;br/&gt;    &lt;br/&gt;在连接到一个能够在单位间转换的库，单位可以变得更加强大和有趣.pip install pint,  您可以将体积转换为立方英寸或加仑: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pint
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; ureg =&lt;span&gt; pint.UnitRegistry()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; vol = volume(3, 5) *&lt;span&gt; ureg(volume.unit)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; vol
&lt;/span&gt;&amp;lt;Quantity(141.3716694115407, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;centimeter ** 3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; vol.to(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cubic inches&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;lt;Quantity(8.627028576414954, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;inch ** 3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; vol.to(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gallons&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).m  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Magnitude&lt;/span&gt;
0.0373464440537444  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;你还可以修改装饰器来直接返回一个Pint数量.数量是通过与单位相乘得到的，在pint中，units必须只能在UnitRegistry中查询.这里注册用来存储函数属性来避免命名空间混乱&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; use_unit(unit):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Have a function return a Quantity with given unit&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    use_unit.ureg &lt;/span&gt;=&lt;span&gt; pint.UnitRegistry()
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_use_unit(func):
        @functools.wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_use_unit(*args, **&lt;span&gt;kwargs):
            value &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value *&lt;span&gt; use_unit.ureg(unit)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_use_unit
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator_use_unit

@use_unit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;meters per second&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; average_speed(distance, duration):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; distance / duration
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;使用@use_unit装饰器，转换单位实际上是很容易&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; bolt = average_speed(100, 9.58&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; bolt
&lt;/span&gt;&amp;lt;Quantity(10.438413361169102, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;meter / second&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; bolt.to(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;km per hour&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;lt;Quantity(37.578288100208766, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kilometer / hour&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; bolt.to(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mph&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).m  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Magnitude&lt;/span&gt;
23.350065679064745
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;验证JSON&lt;/h3&gt;
&lt;p&gt;让我们看最后一个用例。快速看下Flask路由的管理程序:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@app.route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/grade&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, methods=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; update_grade():
    json_data &lt;/span&gt;=&lt;span&gt; request.get_json()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; json_data:
        abort(&lt;/span&gt;400&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Update database&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们确保key student_id是请求的一部分.虽然验证有效，但它实际上并不属于函数本身.另外，可能还有其他使用相同验证的路由。因此，让我们Don't repeat yourself，来使用装饰器抽象出任何不必要的逻辑，下面的@validate_json装饰器会完成这个工作:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask, request, abort
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools
app &lt;/span&gt;= Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; validate_json(*expected_args):                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_validate_json(func):
        @functools.wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_validate_json(*args, **&lt;span&gt;kwargs):
            json_object &lt;/span&gt;=&lt;span&gt; request.get_json()
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; expected_arg &lt;span&gt;in&lt;/span&gt; expected_args:      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; expected_arg &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; json_object:
                    abort(&lt;/span&gt;400&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_validate_json
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_validate_json
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，装饰器采用了一个可变长度列表作为参数，这样我们就可以传递尽可能多的字符串参数，每个参数都代表一个用于验证JSON数据的键:&lt;/p&gt;
&lt;p&gt;    1.json的keys列表作为参数传递给装饰器&lt;br/&gt;    2.包裹函数验证JSON数据中出现的每个预期键&lt;/p&gt;
&lt;p&gt;然后，路由管理程序可以关注其真正的业务级别——因为它可以安全地假设JSON数据是有效的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@app.route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/grade&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, methods=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
@validate_json(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; update_grade():
    json_data &lt;/span&gt;=&lt;span&gt; request.get_json()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Update database.&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结束语:翻译就到这里吧,这篇文章的作者对装饰器的理解很是深入，文章很长，翻起来确实花了不少时间。文中如果有翻译不稳妥的地方，请留言给我。最后老铁们如果觉得对理解python的装饰器有帮助，右下角点个赞吧，结尾附上原文地址:https://realpython.com/primer-on-python-decorators/&lt;/p&gt;

</description>
<pubDate>Mon, 29 Oct 2018 14:53:00 +0000</pubDate>
<dc:creator>丁壮</dc:creator>
<og:description>继续上次的进度:https://www.cnblogs.com/flashBoxer/p/9847521.html 正文: 装饰类 在类中有两种不通的方式使用装饰器，第一个和我们之前做过的函数非常相似</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flashBoxer/p/9873918.html</dc:identifier>
</item>
<item>
<title>Java进阶篇设计模式之九----- 解释器模式和迭代器模式 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9873514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9873514.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/9794886.html&quot;&gt;上一篇&lt;/a&gt;中我们学习了行为型模式的责任链模式(Chain of Responsibility Pattern)和命令模式（Command Pattern）。本篇则来学习下行为型模式的两个模式， 解释器模式(Interpreter Pattern)和迭代器模式（Iterator Pattern）。&lt;/p&gt;
&lt;h2 id=&quot;解释器模式&quot;&gt;解释器模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;解释器模式顾名思义，就是对某事物进行解释。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解释器模式其实就是对某事物进行解释。比如生活中经常用到的计算器，将我们用的语言转换成计算器预言，还有我们编写代码时用到的&lt;strong&gt;正则表达式&lt;/strong&gt;等等。《大话设计模式》中对这个模式有个比较有意思的讲解，其中示例就是把老板对不同人说相同的话，不同的人会理解不同。这也说明的解释器模式核心就是进行解释。&lt;/p&gt;
&lt;p&gt;解释器模式主要由这四个角色组成，抽象表达式(Expression)角色、终结符表达式(Terminal Expression)角色、非终结符表达式(Nonterminal Expression)角色和环境(Context)角色。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象解释器：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器TerminalExpression和非终结符解释器NonterminalExpression完成。&lt;/li&gt;
&lt;li&gt;终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。&lt;/li&gt;
&lt;li&gt;非终结符表达式：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。&lt;/li&gt;
&lt;li&gt;环境角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里为了方便理解，我们使用一个简单的示例来加以说明。&lt;br/&gt;平常我们在进行英语学习的时候，会自行翻译或者用到翻译工具。但是不同的翻译工具翻译的结果也可能不一样，这时我们只需要拿到自己想要的结果就行了。比如，使用百度和有道翻译“好好学习，天天向上！”，它们翻译的结果分别为“Study hard and keep up!”和“study hard and make progress every day！”，而xuwujing翻译的结果是“ Good good study, day day up！”。&lt;br/&gt;那么我们便可以用解释器模式来实现这种场景。&lt;br/&gt;首先定义一个抽象的解释器接口，有解释的这个方法，然后再定义不同的解释器实现该接口和方法，最后再来进行测试。那么代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface Expreeion{
   void interpert(String word);
}

class  BaiduExpreeion implements Expreeion{
   String str =&quot;好好学习，天天向上!&quot;;
   @Override
   public void interpert(String word) {
       if(str.equals(word)) {
           System.out.println(&quot;百度翻译：&quot;+word+&quot; 的英文是  Study hard and keep up!&quot;);
       }
   }
}

class  YouDaoExpreeion implements Expreeion{
   String str =&quot;好好学习，天天向上!&quot;;
   @Override
   public void interpert(String word) {
       if(str.equals(word)) {
           System.out.println(&quot;有道翻译：&quot;+word+&quot; 的英文是  study hard and make progress every day！&quot;);
       }
   }
}

class  XuWuJingExpreeion implements Expreeion{
   String str =&quot;好好学习，天天向上!&quot;;
   @Override
   public void interpert(String word) {
       if(str.equals(word)) {
           System.out.println(&quot;xuwujing翻译：&quot;+word+&quot; 的英文是  Good good study, day day up！&quot;);
       }
   }
}

public class InterpreterTest {
   public static void main(String[] args) {
       String word = &quot;好好学习，天天向上!&quot;;
       Expreeion expreeion =new  BaiduExpreeion();
       Expreeion expreeion2 =new  YouDaoExpreeion();
       Expreeion expreeion3 =new  XuWuJingExpreeion();
       expreeion.interpert(word);
       expreeion2.interpert(word);
       expreeion3.interpert(word);
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
百度翻译：好好学习，天天向上! 的英文是  Study hard and keep up!
有道翻译：好好学习，天天向上! 的英文是  study hard and make progress every day！
xuwujing翻译：好好学习，天天向上! 的英文是  Good good study, day day up！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解释器模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;扩展性好，子类扩展非常方便。&lt;br/&gt;实现简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解释器模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可使用的场景比较少；&lt;br/&gt;类过多的话，会使代码臃肿，难以维护；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个简单的语法规则需要解释的场景，比如sql。&lt;br/&gt;有重复的问题的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;迭代器模式&quot;&gt;迭代器模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;迭代器模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示，属于行为型模式。 它提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们对迭代器（Iterator）肯定不陌生，因为我们在Java开发中会经常用到，比如对List、Set和Map集合进行遍历或对数组进行遍历的时候。但是迭代器模式的话，可能就不太理解了，这里我们就简单讲讲迭代器模式。&lt;/p&gt;
&lt;p&gt;迭代器模式主要由这四个角色组成，迭代器角色（Iterator）、具体迭代器角色（Concrete Iterator）、容器角色（Container）和具体容器角色（Concrete Container）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;迭代器角色（Iterator）：通过接口或抽象类声明实现的方法。&lt;/li&gt;
&lt;li&gt;具体迭代器角色（Concrete Iterator）：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。&lt;/li&gt;
&lt;li&gt;容器角色（Container）：容器角色负责提供创建具体迭代器角色的接口。&lt;/li&gt;
&lt;li&gt;具体容器角色（Concrete Container）：具体容器角色实现创建具体迭代器角色的接口——这个具体迭代器角色于该容器的结构相关。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为迭代器我们平时用的比较多，这里也不在过多描述了，这里就简单的介绍下迭代器模式的运作。&lt;br/&gt;首先，定义一个迭代器角色（MyIterator ）和容器角色（MyIterable）的接口。&lt;br/&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface MyIterator {
    boolean hasNext();
    String next();
}

interface MyIterable{
    MyIterator getIterator();
    void add(String str);
    String get(int index);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后定义一个 具体容器角色（ListContainer ）实现容器角色的接口，这里的实现方法通过List自带的进行实现；然后再定义一个具体迭代器角色（ListIterator ）实现迭代器角色的接口，这里的实现的方法由自己实现。&lt;br/&gt;那么代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class ListContainer implements MyIterable {
    
     private List&amp;lt;String&amp;gt; list =new ArrayList&amp;lt;&amp;gt;(); 

     
    @Override
    public MyIterator getIterator() {
        return new ListIterator();
    }

    @Override
    public void add(String str) {
        list.add(str);
    }

    @Override
    public String get(int index) {
        return list.get(index);
    }
    
    class ListIterator implements MyIterator{
        int index;
        @Override
        public boolean hasNext() {
            return index &amp;lt; list.size();
        }

        @Override
        public String next() {
            if (this.hasNext()) {
                return list.get(index++);
            }
            return null;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来进行代码的测试。&lt;br/&gt;测试代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {
        MyIterable myIterable = new ListContainer();
        myIterable.add(&quot;1&quot;);
        myIterable.add(&quot;zhangsan&quot;);
        myIterable.add(&quot;2&quot;);
        myIterable.add(&quot;lisi&quot;);
        myIterable.add(&quot;3&quot;);
        myIterable.add(&quot;xuwujing&quot;); 
        MyIterator myIterator = myIterable.getIterator();
        while (myIterator.hasNext()){
            String str = myIterator.next();
            System.out.println(str);
        }      
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        1
        zhangsan
        2
        lisi
        3
        xuwujing&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;迭代器模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;灵活度高，可以通过不同的方式遍历对象；&lt;br/&gt;扩展性好，可以很方便的增加新的聚合类和迭代器类而不用修改之前的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;迭代器模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要为聚合对象提供遍历的功能的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;分享一首很好听的日语歌曲！&lt;/p&gt;

&lt;h3 id=&quot;项目的代码&quot;&gt;项目的代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xuwujing/java-study&quot;&gt;java-study&lt;/a&gt;是本人在学习Java过程中记录的一些代码，也包括之前博文中使用的代码。如果感觉不错，希望顺手给个start，当然如果有不足，也希望提出。&lt;br/&gt;github地址: https://github.com/xuwujing/java-study&lt;/p&gt;
&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 13:44:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/9873514.html</dc:identifier>
</item>
</channel>
</rss>