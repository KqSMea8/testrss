<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Secret 的使用场景 - 每天5分钟玩转 Docker 容器技术（109） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8082429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8082429.html</guid>
<description>&lt;p&gt;&lt;span&gt;我们可以用 secret 管理任何敏感数据。这些敏感数据是容器在运行时需要的，同时我们不又想将这些数据保存到镜像中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;secret 可用于管理：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;用户名和密码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLS 证书。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSH 秘钥。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其他小于 500 KB 的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;secret 只能在 swarm service 中使用。普通容器想使用 secret，可以将其包装成副本数为 1 的 service。&lt;/p&gt;
&lt;p&gt;这里我们再举一个使用 secret 的典型场景。&lt;/p&gt;
&lt;p&gt;数据中心有三套 swarm 环境，分别用于开发、测试和生产。对于同一个应用，在不同的环境中使用不同的用户名密码。我们可以在三个环境中分别创建 secret，不过使用相同的名字，比如&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;username&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;和&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;password&lt;/span&gt;&lt;/code&gt;。应用部署时只需要指定 secret 名字，这样我们就可以用同一套脚本在不同的环境中部署应用了。&lt;/p&gt;
&lt;p&gt;除了敏感数据，secret 当然也可以用于非敏感数据，比如配置文件。不过目前新版本的 Docker 提供了 config 子命令来管理不需要加密的数据。config 与 secret 命令的使用方法完全一致。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;Secret 的安全性&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;当在 swarm 中创建 secret 时，Docker 通过 TLS 连接将加密后的 secret 发送给所以的 manager 节点。&lt;/p&gt;
&lt;p&gt;secret 创建后，即使是 swarm manager 也无法查看 secret 的明文数据，只能通过&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;docker secret inspect&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;查看 secret 的一般信息。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;556.png&quot; src=&quot;https://i.imgsafe.org/ba/bae9b95db1.png&quot; alt=&quot;556.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;只有当 secret 被指定的 service 使用是，Docker 才会将解密后的 secret 以文件的形式 mount 到容器中，默认的路径为&lt;code&gt;&lt;span&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/span&gt;&lt;/code&gt;。例如在前面 MySQL 的例子中，我们可以在容器中查看 secret。&lt;/p&gt;
&lt;div&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;555.png&quot; src=&quot;https://i.imgsafe.org/ba/bae98c3f35.png&quot; alt=&quot;555.png&quot;/&gt;&lt;/div&gt;

&lt;p&gt;当容器停止运行，Docker 会 unmount secret，并从节点上清除。&lt;/p&gt;
&lt;p&gt;下一节我们再通过一个更加综合例子加深对 Secret 的理解。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Dec 2017 23:29:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8082429.html</dc:identifier>
</item>
<item>
<title>Java开发小技巧（三）：Maven多工程依赖项目 - kMacro</title>
<link>http://www.cnblogs.com/zkh101/p/8083368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zkh101/p/8083368.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5266042-26f2758e0f40a631.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Maven多工程依赖项目开发流程&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本篇文章基于&lt;a href=&quot;http://www.jianshu.com/p/ec720603a82e&quot;&gt;Java开发小技巧（二）：自定义Maven依赖&lt;/a&gt;中创建的父工程&lt;code&gt;project-monitor&lt;/code&gt;实现，运用我们自定义的依赖包进行多工程依赖项目的开发。&lt;/p&gt;
&lt;p&gt;下面以多可执行Jar包项目的开发为例，进行Maven多工程依赖项目开发的讲解。&lt;/p&gt;

&lt;p&gt;首先来看一下封面图，我们要实现的效果是：&lt;br/&gt;1.多个项目共享一个项目的类和方法等通用内容&lt;br/&gt;2.每个子项目单独导入所需依赖，以及各自填充父项目配置文件中的占位符&lt;br/&gt;3.子项目按指定目录结构进行打包&lt;br/&gt;4.所有子项目集成打包到一个统一的目录，共享依赖包和配置文件等内容&lt;br/&gt;5.打包后目录结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bin：存放脚本文件，用来设置环境变量，执行相应的jar包&lt;/li&gt;
&lt;li&gt;lib：依赖、项目jar包&lt;/li&gt;
&lt;li&gt;etc：配置文件&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好啦，目标明确的，接下来要进行具体开发实现了&lt;/p&gt;

&lt;h2 id=&quot;打包配置&quot;&gt;打包配置&lt;/h2&gt;
&lt;p&gt;在上一篇文章中已经创建好了一个自定义的Maven依赖，相当于一个父项目，接下来我们新建一个子项目，命名为&lt;code&gt;project-one&lt;/code&gt;，&lt;code&gt;pom.xml&lt;/code&gt;文件与父项目基本相同，所有依赖包都必须单独引入，不同的是多了对父项目的依赖：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.demo&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;project-monitor&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.0.1&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及Maven插件&lt;code&gt;maven-assembly-plugin&lt;/code&gt;的引入，用来实现依赖的打包以及打包后的目录结构：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-assembly-plugin&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;appendAssemblyId&amp;gt;&lt;/span&gt;false&lt;span class=&quot;kw&quot;&gt;&amp;lt;/appendAssemblyId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;descriptors&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;descriptor&amp;gt;&lt;/span&gt;package.xml&lt;span class=&quot;kw&quot;&gt;&amp;lt;/descriptor&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/descriptors&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;id&amp;gt;&lt;/span&gt;make-assembly&lt;span class=&quot;kw&quot;&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;phase&amp;gt;&lt;/span&gt;package&lt;span class=&quot;kw&quot;&gt;&amp;lt;/phase&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;single&lt;span class=&quot;kw&quot;&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目录结构配置位于项目根目录下&lt;code&gt;package.xml&lt;/code&gt;配置文件中：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;assembly&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/assembly-1.0.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;id&amp;gt;&lt;/span&gt;package&lt;span class=&quot;kw&quot;&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;formats&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;format&amp;gt;&lt;/span&gt;zip&lt;span class=&quot;kw&quot;&gt;&amp;lt;/format&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/formats&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;includeBaseDirectory&amp;gt;&lt;/span&gt;true&lt;span class=&quot;kw&quot;&gt;&amp;lt;/includeBaseDirectory&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;fileSets&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;fileSet&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/resources&lt;span class=&quot;kw&quot;&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;includes&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;include&amp;gt;&lt;/span&gt;*.properties&lt;span class=&quot;kw&quot;&gt;&amp;lt;/include&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;include&amp;gt;&lt;/span&gt;*.xml&lt;span class=&quot;kw&quot;&gt;&amp;lt;/include&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/includes&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;outputDirectory&amp;gt;&lt;/span&gt;etc&lt;span class=&quot;kw&quot;&gt;&amp;lt;/outputDirectory&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/fileSet&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/fileSets&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencySets&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencySet&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;outputDirectory&amp;gt;&lt;/span&gt;lib&lt;span class=&quot;kw&quot;&gt;&amp;lt;/outputDirectory&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;runtime&lt;span class=&quot;kw&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencySet&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencySets&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/assembly&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上就实现了项目打包的配置工作，实现流程图中最后的项目结构，打包结果为zip文件&lt;/p&gt;
&lt;h2 id=&quot;填充配置文件占位符&quot;&gt;填充配置文件占位符&lt;/h2&gt;
&lt;p&gt;之前我们在父项目的spring上下文中定义了一个数据源bean，配置信息使用了占位符填充，所以如果我们想要使用这个bean，就需要替换其中的占位符信息，要怎么做呢？&lt;br/&gt;首先当然是创建配置文件了，在项目中创建&lt;code&gt;jdbc.properties&lt;/code&gt;JDBC配置文件，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localdb:3306/test?characterEncoding=utf8&amp;amp;useSSL=true&amp;amp;serverTimezone=UTC
jdbc.username=root
jdbc.password=5EF28C5A9A0CE86C2D231A526ED5B388&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们需要借助&lt;code&gt;PropertyPlaceholderConfigurer&lt;/code&gt;这个类来实现，在项目spring上下文中定义bean：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;locations&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;value&amp;gt;&lt;/span&gt;classpath:jdbc.properties&lt;span class=&quot;kw&quot;&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;ignoreResourceNotFound&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bingo，占位符修改完毕，别忘了引入父项目的上下文，毕竟我们要填充占位符的bean是在父项目中的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;import&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; resource=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;classpath*:project-monitor.xml&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;测试demo&quot;&gt;测试Demo&lt;/h2&gt;
&lt;p&gt;好了，接下来来测试项目的可行性，主要实现使用父项目定义的数据源来对MySql进行查询。&lt;br/&gt;先创建一个&lt;code&gt;DemoService&lt;/code&gt;类，内容如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.demo.project.one.service;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.apache.log4j.Logger;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import javax.sql.DataSource;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.sql.Connection;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.sql.ResultSet;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.sql.SQLException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.sql.Statement;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DemoService {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Logger logger = Logger.&lt;span class=&quot;fu&quot;&gt;getLogger&lt;/span&gt;(DemoService.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; DataSource dataSource;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;queryDb&lt;/span&gt;(){
        Connection conn = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        Statement stmt = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        ResultSet rs = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            conn = dataSource.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;();
            stmt = conn.&lt;span class=&quot;fu&quot;&gt;createStatement&lt;/span&gt;();
            rs = stmt.&lt;span class=&quot;fu&quot;&gt;executeQuery&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;select * from movie limit 1&quot;&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(rs.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;()){
                logger.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Movie[Id=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;,Title=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;,Director=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;,Genre=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;,Language=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;]&quot;&lt;/span&gt;,
                        rs.&lt;span class=&quot;fu&quot;&gt;getInt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;),
                        rs.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;),
                        rs.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;),
                        rs.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;),
                        rs.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)
                        ));
            }
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(rs != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
                    rs.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
                }
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(stmt != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
                    stmt.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
                }
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(conn != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
                    conn.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
                }
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
        }
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setDataSource&lt;/span&gt;(DataSource dataSource) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dataSource&lt;/span&gt; = dataSource;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上下文中为其注入dataSource定义：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;demoService&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.demo.project.one.service.DemoService&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;别忘了添加&lt;code&gt;log4j.properties&lt;/code&gt;配置文件，这里就不贴出文件内容了。&lt;br/&gt;OK，新建一个入口类来执行&lt;code&gt;DemoService&lt;/code&gt;的测试吧：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.demo.project.one;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.demo.project.one.service.DemoService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.ConfigurableApplicationContext;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.support.ClassPathXmlApplicationContext;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Application {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args){
        ConfigurableApplicationContext context = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/project-one.xml&quot;&lt;/span&gt;);
        DemoService demoService = (DemoService)context.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;demoService&quot;&lt;/span&gt;);
        demoService.&lt;span class=&quot;fu&quot;&gt;queryDb&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终的项目结构如图&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5266042-716cd2dd327c8992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;项目结构&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;打包&quot;&gt;打包&lt;/h2&gt;
&lt;p&gt;一切准备就绪，轮到项目打包了，在项目根目录执行以下Maven命令即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn clean package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完成后你会发现&lt;code&gt;target&lt;/code&gt;目录的结构如图所示&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5266042-db36dfa3a95f4a95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;target目录结构&quot;/&gt;&lt;br/&gt;project-one.zip就是我们要的打包结果，解压后你会发现，依赖包和配置文件已经放在了各自的目录下&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5266042-c752038e91a13183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;zip包目录结构&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;执行文件&quot;&gt;执行文件&lt;/h2&gt;
&lt;p&gt;项目开发完成，接下来就是执行程序了，以Windows平台下为例，首先创建&lt;code&gt;bin&lt;/code&gt;目录，目录中创建批处理文件&lt;code&gt;setenv.bat&lt;/code&gt;、&lt;code&gt;project-one.bat&lt;/code&gt;&lt;br/&gt;因为jar包与配置文件的分离，所以我们需要指定执行jar包时的&lt;code&gt;classpath&lt;/code&gt;，批处理文件内容如下：&lt;/p&gt;
&lt;h3 id=&quot;setenv.bat&quot;&gt;setenv.bat&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@echo off
set SRC_DIR=%cd%

cd %~dp0
cd ..
set MAIN_HOME=%cd%

cd %SRC_DIR%

set BIN_HOME=%MAIN_HOME%\bin
set ETC_HOME=%MAIN_HOME%\etc
set LIB_HOME=%MAIN_HOME%\lib
set CLASSPATH=%ETC_HOME%;%JAVA_HOME%\lib\tools.jar

for %%i in (%LIB_HOME%\*.jar) do set CLASSPATH=!CLASSPATH!;%%i&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;project-one.bat&quot;&gt;project-one.bat&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@echo off
@setlocal enableextensions enabledelayedexpansion
call setenv.bat

chcp 65001
java -cp %CLASSPATH% com.demo.project.one.Application
pause&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bat文件的内容就不详细解释，有兴趣可以百度了解一下，主要是为了拼接出完整的&lt;code&gt;CLASSPATH&lt;/code&gt;，执行&lt;code&gt;project-one-0.0.1.jar&lt;/code&gt;可执行jar包&lt;/p&gt;
&lt;h2 id=&quot;运行&quot;&gt;运行&lt;/h2&gt;
&lt;p&gt;点击&lt;code&gt;project-one.bat&lt;/code&gt;运行程序&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5266042-b807746111ff1cdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;运行结果&quot;/&gt;&lt;/p&gt;

&lt;p&gt;项目终于开发演示完毕，这里只是创建一个打造可执行jar包的子项目作为例子，你还可以创建多个子项目，最后打包的时候合并相同的依赖和配置文件，然后在&lt;code&gt;bin&lt;/code&gt;中创建相应项目的执行文件即可，各个子项目之间也可进行相互依赖。&lt;br/&gt;以上开发技巧不仅适用于可执行jar包的开发，同样适用于WEB项目的开发，具体还是由项目需求决定。&lt;/p&gt;
&lt;p&gt;文章项目源码已发布到Github：&lt;a href=&quot;https://github.com/ZKHDEV/MultDependPjo&quot; class=&quot;uri&quot;&gt;https://github.com/ZKHDEV/MultDependPjo&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.7127659574468&quot;&gt;
&lt;p&gt;本文为作者&lt;a href=&quot;http://www.jianshu.com/p/3fa98dd52520&quot;&gt;kMacro&lt;/a&gt;原创，转载请注明来源：&lt;a href=&quot;http://www.jianshu.com/p/3fa98dd52520&quot; class=&quot;uri&quot;&gt;http://www.jianshu.com/p/3fa98dd52520&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 21 Dec 2017 17:09:00 +0000</pubDate>
<dc:creator>kMacro</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zkh101/p/8083368.html</dc:identifier>
</item>
<item>
<title>ChromeExtension那些事儿 - 猴子猿</title>
<link>http://www.cnblogs.com/giggle/p/8082672.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/giggle/p/8082672.html</guid>
<description>&lt;p&gt;Chrome Extension是什么呢？&lt;/p&gt;
&lt;p&gt;简而言之，就是Chrome扩展，它是基于Chrome浏览器的，我们可以理解它为一个独立运行在Chrome浏览器下的APP，当然核心编程语言就是JavaScript咯，然后结合HTML以及CSS来开发。重点是，这个“APP”功能强大，可以独自运行，亦可以与打开的网页、Chrome控制面板(DevTools)、第三方插件等等进行通信，且，Google允许ChromeExtension不必受限于跨域限制，结合以上种种优点，固，我们可以使用ChromeExtension，结合自身业务，开发出许多提高工作效率的工具。&lt;/p&gt;
&lt;p&gt;部署ChromeExtension也很简单，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/887360/201712/887360-20171221223234365-920132516.png&quot; alt=&quot;&quot; width=&quot;208&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/887360/201712/887360-20171221223311865-849537979.png&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;106&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，现在来听听属于ChromeExtension它的故事。&lt;/p&gt;
&lt;table dir=&quot;ltr&quot; border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、概要及manifest.json&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;ChromeExtension是Chrome提出来的一个概念，其实正如上文所说，核心编程语言就是JavaScript，然后提供一切通信、存储接口，大致就差不多了。&lt;/p&gt;
&lt;p&gt;需要注意的是，ChromeExtension都包含一个Manifest文件——manifest.json，这个文件可以告诉Chrome关于这个扩展的相关信息，它是整个扩展的入口，也是Chrome扩展必不可少的部分。且必须包含name、version和manifest_version属性，其他常用的可选属性还有browser_action、page_action、background、permissions、options_page、content_scripts。&lt;/p&gt;
&lt;p&gt;所以我们可以保留一份manifest.json模板，当编写新的扩展时直接填入相应的属性值就OK了。&lt;/p&gt;
&lt;p&gt;manifest.json模板及相关属性解释如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;manifest_version&quot;: 2&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义chrome扩展的名称&lt;/span&gt;
    &quot;name&quot;: &quot;My Extension&quot;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义chrome扩展的版本&lt;/span&gt;
    &quot;version&quot;: &quot;versionString&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;default_locale&quot;: &quot;en&quot;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义chrome扩展的描述&lt;/span&gt;
    &quot;description&quot;: &quot;A plain text description&quot;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义了扩展相关图标文件的位置&lt;/span&gt;
    &quot;icons&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;16&quot;: &quot;images/icon16.png&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;48&quot;: &quot;images/icon48.png&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;128&quot;: &quot;images/icon128.png&quot;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
      Browser Actions将扩展图标置于Chrome浏览器工具栏中，地址栏的右侧。如果声明了popup页面，当用户点击图标时，在图标的下侧会打开这个页面。同时图标上面还可以附带badge——一个带有显示有限字符空间(只能显示4字节长度信息)的区域——用以显示一些有用的信息，如未读邮件数等。且Badge目前只能够通过JavaScript设定显示的内容，同时Chrome还提供了更改badge背景的方法。如果不定义badge的背景颜色，默认将使用红色。例如，显示了一个背景颜色为蓝色，内容为“Dog”的badge：
      chrome.browserAction.setBadgeBackgroundColor({color: '#0000FF'});
      chrome.browserAction.setBadgeText({text: 'Dog'});
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &quot;browser_action&quot;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过setIcon方法可以动态更改扩展的图标,chrome.browserAction.setIcon(details, callback)&lt;/span&gt;
        &quot;default_icon&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;19&quot;: &quot;images/icon19.png&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;38&quot;: &quot;images/icon38.png&quot;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义了当用户鼠标悬停于扩展图标上所显示的文字,chrome.browserAction.setTitle({title: 'This is a new title'})&lt;/span&gt;
        &quot;default_title&quot;: &quot;Extension Title&quot;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
          定义了当用户单击扩展图标时所显示页面的文件位置, 值得注意的是Chrome不允许将JavaScript代码段直接内嵌入HTML文档，所以我们需要通过外部引入的方式引用JS文件。由于其在关闭后，就相当于用户关闭了相应的标签页，这个页面不会继续运行。当用户再次打开这个页面时，所有的DOM和js空间变量都将被重新创建，所以不要在popup页面的js空间变量中保存数据，而是利用localStorage和chrome.storage将数据保存在用户的硬盘上。
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &quot;default_popup&quot;: &quot;popup.html&quot;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
      Page Actions与Browser Actions非常类似，除了Page Actions没有badge外，其他Browser Actions所有的方法Page Actions都有。另外的区别就是，Page Actions并不像Browser Actions那样一直显示图标，而是可以在特定标签特定情况下显示或隐藏，所以它还具有独有的show和hide方法。
        chrome.pageAction.show(integer tabId);
        chrome.pageAction.hide(integer tabId);
        另，tabId为标签（下面会具体讲解）id，可以通过tabs接口获取。
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &quot;page_action&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;default_icon&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;19&quot;: &quot;images/icon19.png&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;38&quot;: &quot;images/icon38.png&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;default_title&quot;: &quot;Extension Title&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;default_popup&quot;: &quot;popup.html&quot;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
      在Manifest中指定background域可以使扩展常驻后台。background可以包含三种属性，分别是scripts、page和persistent。如果指定了scripts属性，则Chrome会在扩展启动时自动创建一个包含所有指定脚本的页面；如果指定了page属性，则Chrome会将指定的HTML文件作为后台页面运行。通常我们只需要使用scripts属性即可，除非在后台页面中需要构建特殊的HTML——但一般情况下后台页面的HTML我们是看不到的。persistent属性定义了常驻后台的方式——当其值为true时，表示扩展将一直在后台运行，无论其是否正在工作；当其值为false时，表示扩展在后台按需运行，这就是Chrome后来提出的Event Page。Event Page可以有效减小扩展对内存的消耗，如非必要，请将persistent设置为false。注意，persistent的默认值为true。
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &quot;background&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;scripts&quot;: [&quot;background.js&quot;&lt;span&gt;]
    },
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
      可以指定将哪些脚本何时注入到哪些页面中，当用户访问这些页面后，相应脚本即可自动运行，从而对页面DOM进行操作。属性值为数组类型，数组的每个元素可以包含matches、exclude_matches、css、js、run_at、all_frames、include_globs和exclude_globs等属性其中matches属性定义了哪些页面会被注入脚本，exclude_matches则定义了哪些页面不会被注入脚本，css和js对应要注入的样式表和JavaScript，run_at定义了何时进行注入，all_frames定义脚本是否会注入到嵌入式框架中，include_globs和exclude_globs则是全局URL匹配，最终脚本是否会被注入由matches、exclude_matches、include_globs和exclude_globs的值共同决定.

　　　 注意：content_scripts中的脚本只是共享页面的DOM(DOM中的自定义属性不会被共享)，而并不共享页面内嵌JavaScript的命名空间。也就是说，如果当前页面中的JavaScript有一个全局变量a，content_scripts中注入的脚本也可以有一个全局变量a，两者不会相互干扰。当然你也无法通过content_scripts访问到页面本身内嵌JavaScript的变量和函数。
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &quot;content_scripts&quot;&lt;span&gt;: [
        {
            &lt;/span&gt;&quot;matches&quot;: [&quot;http://www.google.com/*&quot;&lt;span&gt;],
            &lt;/span&gt;&quot;css&quot;: [&quot;mystyles.css&quot;&lt;span&gt;],
            &lt;/span&gt;&quot;js&quot;: [&quot;jquery.js&quot;, &quot;myscript.js&quot;&lt;span&gt;]
        }
    ],
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
      有一些扩展允许用户进行个性化设置，这样就需要向用户提供一个选项页面。Chrome通过Manifest文件的options_page属性为开发者提供了这样的接口，可以为扩展指定一个选项页面。当用户在扩展图标上点击右键，选择菜单中的“选项”后，就会打开这个页面
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &quot;options_page&quot;: &quot;options.html&quot;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
      浏览器出于安全考虑是不允许跨域, 但这个规则如果同样限制Chrome扩展应用，就会使其能力大打折扣，所以Google允许Chrome扩展应用不必受限于跨域限制。但出于安全考虑，需要在Manifest的permissions属性中声明需要跨域的权限。
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &quot;permissions&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;*://www.google.com/*&quot;&lt;span&gt;
    ],
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为notification服务，桌面通知功能&lt;/span&gt;
    &quot;web_accessible_resources&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;images/*.png&quot;&lt;span&gt;
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table dir=&quot;ltr&quot; border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、存储&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;对于网站来说，用户的设置通常保存在Cookies中，或者保存在网站服务器的数据库中。对于JavaScript来说，一些数据可以保存在变量中。&lt;br/&gt;但，如果用户重新启动浏览器，这些数据就会消失。那么如何在扩展中保存用户的设置呢？我们可以使用HTML5新增的localStorage接口。&lt;br/&gt;当然，Chrome为扩展应用提供了存储API，以便将扩展中需要保存的数据写入本地磁盘。Chrome提供的存储API可以说是对localStorage的改进，它与localStorage相比有以下区别：&lt;br/&gt;　　1.如果储存区域指定为sync，数据可以自动同步；&lt;br/&gt;　　2.content_scripts可以直接读取数据，而不必通过background页面；&lt;br/&gt;　　3.在隐身模式下仍然可以读出之前存储的数据；&lt;br/&gt;　　4.读写速度更快；&lt;br/&gt;　　5.用户数据可以以对象的类型保存。&lt;br/&gt;对于第二点需要说明一下。首先localStorage是基于域名的，而content_scripts是注入到用户当前浏览页面中的，如果content_scripts直接读取localStorage，所读取到的数据是用户当前浏览页面所在域中的。所以通常的解决办法是“content_scripts”通过runtime.sendMessage和“background”通信，由“background”读写扩展所在域（通常是chrome-extension://extension-id/）的localStorage，然后再传递给content_scripts。&lt;/p&gt;
&lt;p&gt;使用Chrome存储API必须要在Manifest的permissions中声明&quot;storage&quot;，之后才有权限调用。Chrome存储API提供了2种储存区域，分别是sync和local。两种储存区域的区别在于，sync储存的区域会根据用户当前在Chrome上登陆的Google账户自动同步数据，当无可用网络连接可用时，sync区域对数据的读写和local区域对数据的读写行为一致。对于每种储存区域，Chrome又提供了5个方法，&lt;br/&gt;分别是get、getBytesInUse、set、remove和clear，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
StorageArea为sync或则local
例, chrome.storage.sync.get(...)
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
chrome.storage.StorageArea.get(keys, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(result){
　　console.log(result);
});
chrome.storage.StorageArea.getBytesInUse(keys, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(bytes){
　　console.log(bytes);
});
chrome.storage.StorageArea.set(items, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt;});
chrome.storage.StorageArea.remove(keys, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt;});
chrome.storage.StorageArea.clear(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Chrome同时还为存储API提供了一个onChanged事件，当存储区的数据发生改变时，这个事件会被触发，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
callback会接收到两个参数，第一个为changes，第二个是StorageArea。changes是个对象，键为更改的属性名称，值包含两个属性，分别为oldValue和newValue
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
chrome.storage.onChanged.addListener(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(changes, areaName){
　　console.log(&lt;/span&gt;'Value in '+areaName+' has been changed:'&lt;span&gt;);
　　console.log(changes);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table dir=&quot;ltr&quot; border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、通信&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Chrome提供了4个有关ChromeExtension页面间相互通信的接口，分别是&lt;code&gt;runtime.sendMessage&lt;/code&gt;、&lt;code&gt;runtime.onMessage&lt;/code&gt;、&lt;code&gt;runtime.connect&lt;/code&gt;和&lt;code&gt;runtime.onConnect。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;且，Chrome提供的大部分API是不支持在&quot;&lt;code&gt;content_scripts&quot;&lt;/code&gt;中运行的，但&lt;code&gt;runtime.sendMessage&lt;/code&gt;和&lt;code&gt;runtime.onMessage&lt;/code&gt;可以在&quot;&lt;code&gt;content_scripts&quot;&lt;/code&gt;中运行，所以扩展的其他页面也可以同&lt;code&gt;content_scripts&lt;/code&gt;相互通信。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
extensionId(optional)为所发送消息的目标扩展，如果不指定这个值，则默认为发起此消息的扩展本身；
message(required)为要发送的内容，类型随意，内容随意
options(optional)
callback(optional)用于接收返回结果
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
chrome.runtime.sendMessage(extensionId, message, options, callback)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
callback(required)接收到的参数有三个，分别是message、sender和sendResponse。&lt;br/&gt;其中sender对象包含4个属性，分别是tab、id、url和tlsChannelId，tab是发起消息的标签(下节会详讲)
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
chrome.runtime.onMessage.addListener(callback)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 例如，popup.html与backgroud可以如下通信：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;popup.html&lt;/span&gt;
chrome.runtime.sendMessage('Hello', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(response){
    document.write(response);
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;background&lt;/span&gt;
chrome.runtime.onMessage.addListener(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(message, sender, sendResponse){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(message == 'Hello'&lt;span&gt;){
        sendResponse(&lt;/span&gt;'Hello from background.'&lt;span&gt;);
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看popup.html页面会发现有输出“Hello from background.”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/887360/201712/887360-20171221235058693-134298345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;table dir=&quot;ltr&quot; border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、标签&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;标签的意思就是在浏览器中打开的一个个页面，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/887360/201712/887360-20171221235915100-1961431301.png&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;54&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Chrome通过&lt;code&gt;tabs&lt;/code&gt;方法提供了管理标签的方法与监听标签行为的事件，大多数方法与事件是无需声明特殊权限的，但有关标签的&lt;code&gt;url&lt;/code&gt;、&lt;code&gt;title&lt;/code&gt;和&lt;code&gt;favIconUrl&lt;/code&gt;的操作（包括读取），都需要声明&lt;code&gt;tabs&lt;/code&gt;权限。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&quot;permissions&quot;&lt;span&gt;: [
    &lt;/span&gt;&quot;tabs&quot;&lt;span&gt;
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取标签信息。Chrome提供了三种获取标签信息的方法，分别是&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;getCurrent&lt;/code&gt;和&lt;code&gt;query&lt;/code&gt;。&lt;code&gt;get&lt;/code&gt;方法可以获取到指定id的标签，&lt;code&gt;getCurrent&lt;/code&gt;则获取运行的脚本本身所在的标签，&lt;code&gt;query&lt;/code&gt;可以获取所有符合指定条件的标签。&lt;/p&gt;
&lt;p&gt;以getCurrent为例，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
chrome.tabs.getCurrent(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(tab){
    console.log(tab);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重点是，ChromeExtension也可以与指定的标签通信(标签中注入了&quot;content_scripts&quot;)，方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
chrome.tabs.sendMessage(tabId, message, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(response){
    console.log(response);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table dir=&quot;ltr&quot; border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、拓展阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;[1]. &lt;a href=&quot;https://developer.chrome.com/extensions/content_scripts&quot; target=&quot;_blank&quot;&gt;Chrome Extensions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]. &lt;a href=&quot;http://www.ituring.com.cn/book/miniarticle/110929&quot; target=&quot;_blank&quot;&gt;Chrome扩展及应用开发&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Dec 2017 16:21:00 +0000</pubDate>
<dc:creator>猴子猿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/giggle/p/8082672.html</dc:identifier>
</item>
<item>
<title>springMVC(1)---获取前段数据 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/8076274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/8076274.html</guid>
<description>&lt;p&gt;        首先说明，如果你学过Struts2，那么在学springMVC就会简单很多，我也不最基础的开始写了，我前篇文章搭建了个ssm框架，算是springmvc入门了。&lt;/p&gt;
&lt;p&gt;        链接：&lt;a href=&quot;http://www.cnblogs.com/qdhxhz/p/8032314.html&quot; target=&quot;_blank&quot;&gt;基于maven的ssm框架整合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;&lt;strong&gt;一.&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;首先看一下都有哪些绑定数据的注解：           &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     1.&lt;strong&gt;&lt;span&gt;@RequestParam&lt;/span&gt;&lt;/strong&gt;，绑定单个请求数据，可以是URL中的数据，表单提交的数据或上传的文件； &lt;br/&gt;     2.&lt;strong&gt;&lt;span&gt;@PathVariable&lt;/span&gt;&lt;/strong&gt;，绑定URL模板变量值； &lt;br/&gt;     3.&lt;strong&gt;&lt;span&gt;@CookieValue&lt;/span&gt;&lt;/strong&gt;，绑定Cookie数据； &lt;br/&gt;     4&lt;strong&gt;&lt;span&gt;.@RequestHeader&lt;/span&gt;&lt;/strong&gt;，绑定请求头数据； &lt;br/&gt;     5&lt;span&gt;&lt;strong&gt;.@ModelAttribute&lt;/strong&gt;&lt;/span&gt;，绑定数据到Model； &lt;br/&gt;     6.&lt;strong&gt;&lt;span&gt;@SessionAttributes&lt;/span&gt;&lt;/strong&gt;，绑定数据到Session； &lt;br/&gt;     7.&lt;strong&gt;&lt;span&gt;@RequestBody&lt;/span&gt;&lt;/strong&gt;，用来处理Content-Type不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等； &lt;br/&gt;     8.&lt;strong&gt;&lt;span&gt;@RequestPart&lt;/span&gt;&lt;/strong&gt;，绑定“multipart/data”数据，并可以根据数据类型进项对象转换；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;&lt;strong&gt;二.&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;@RequestParam讲解                                          &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;首先说明，项目的框架和架包我直接用的是smm框架整合的内容，我是在这个基础上进行操作,先看我jsp放置。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1090617/201712/1090617-20171221205651818-226489146.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(1)先看Controller层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.ServletRequestUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestParam;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.multipart.MultipartFile;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.multipart.MultipartHttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.ModelAndView;

@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParamController {
  
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * GET请求
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(value&lt;/span&gt;=&quot;/jsp/paramdate&quot;, method =&lt;span&gt; {RequestMethod.GET})
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView paramBind(){
        
        ModelAndView modelAndView &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView(); 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为我这边指定是post请求，所以不会走到这里，所以haha.jsp也没有写&lt;/span&gt;
        modelAndView.setViewName(&quot;haha&quot;&lt;span&gt;);  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * POST请求
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
    @RequestMapping(value&lt;/span&gt;=&quot;/jsp/paramdate&quot;, method =&lt;span&gt; {RequestMethod.POST})
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ModelAndView paramBind(HttpServletRequest request, @RequestParam(&quot;urlParam&quot;) String urlParam, @RequestParam(&quot;formParam&quot;) &lt;br/&gt;String formParam, @RequestParam(&quot;formFile&quot;&lt;span&gt;) MultipartFile formFile){
   
             
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过注解直接获得 &lt;/span&gt;
        ModelAndView modelAndView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();  
        modelAndView.addObject(&lt;/span&gt;&quot;urlParam&quot;&lt;span&gt;, urlParam);  
        modelAndView.addObject(&lt;/span&gt;&quot;formParam&quot;&lt;span&gt;, formParam);  
        modelAndView.addObject(&lt;/span&gt;&quot;formFileName&quot;&lt;span&gt;, formFile.getOriginalFilename());  
       
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不用注解获得数据，我们也可以手动获取&lt;/span&gt;
        String urlParam1 = ServletRequestUtils.getStringParameter(request, &quot;urlParam&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        String formParam1 &lt;/span&gt;= ServletRequestUtils.getStringParameter(request, &quot;formParam&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        MultipartFile formFile1 &lt;/span&gt;= ((MultipartHttpServletRequest) request).getFile(&quot;formFile&quot;&lt;span&gt;);     
 
        modelAndView.addObject(&lt;/span&gt;&quot;urlParam1&quot;&lt;span&gt;, urlParam1);  
        modelAndView.addObject(&lt;/span&gt;&quot;formParam1&quot;&lt;span&gt;, formParam1);  
        modelAndView.addObject(&lt;/span&gt;&quot;formFileName1&quot;&lt;span&gt;, formFile1.getOriginalFilename());  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;setViewName代表返回界面名称&lt;/span&gt;
        modelAndView.setViewName(&quot;return&quot;&lt;span&gt;);  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
    }        
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(2)开始的start.jsp&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;paramdate?urlParam=你好&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt; enctype&lt;/span&gt;&lt;span&gt;=&quot;multipart/form-data&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;formParam&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; 
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;formFile&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Submit&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1090617/201712/1090617-20171221210607537-960581300.png&quot; alt=&quot;我输入徐小小，提交好好生活.TXT文件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(3)返回return.jsp&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    注解获取数据：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${urlParam}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${formParam}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${formFileName}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    手动获取数据：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${urlParam1}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${formParam1}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${formFileName1}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;界面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1090617/201712/1090617-20171221210934318-424477958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这个小案例，我们通过注解和非注解的方式，把前段界面的值传到后端，在从后端传到前段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;思考：&lt;/span&gt;&lt;/strong&gt;我们在实际开发中，在前段往后段传值的时候，后端一个一个获取值再放到Model实体中，还是太麻烦。别担心，我们不需要把数据绑定到一个个变量然后在对model赋值，只需要把model加入相应的action参数（这里不需要指定绑定数据的注解）Spring MVC会自动进行数据转换并绑定到model对象上，一切就是这么简单。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 三.通过实体获取前端值                                                       &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;(1)建立User实体&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;提供set和get方法，toString方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(2)建立Controller类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.ui.Model;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.ssm.model.User;

@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UsersController {

@RequestMapping(&lt;/span&gt;&quot;/jsp/loging&quot;&lt;span&gt;)    
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getUser(HttpServletRequest request, Model model,User user){
    User  users&lt;/span&gt;=&lt;span&gt;user;
    System.out.println(users.getName()&lt;/span&gt;+&quot;--&quot;+&lt;span&gt;users.getPassword());
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(3)开始loging.jsp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 如何要使用SpringMVC标签，那么一定要添加下面这个taglib &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/tags/form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;

 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 如果你要使用model进行赋值，那就需要指明哪个model，而且id中的值要和下面值一致，不然会报错 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Neither BindingResult nor plain target object for bean name 'users' available as request attribute &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jsp:useBean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.ssm.model.User&quot;&lt;/span&gt;&lt;span&gt; scope&lt;/span&gt;&lt;span&gt;=&quot;request&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;loging&quot;&lt;/span&gt;&lt;span&gt; modelAttribute&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;     
        用户名：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:input &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        密 码：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:password &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Submit&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 还有如果你的form表单中，path中的名字，在model中没有也会报错，比如我加一个names，当加载页面时报错 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Invalid property 'names' of bean class [com.ssm.model.User]: Bean property 'names' is not readable &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;界面&lt;/span&gt;&lt;/strong&gt; (密码123)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1090617/201712/1090617-20171221221553631-1954540612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(4)最后我们在后台看我们打印的那条数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1090617/201712/1090617-20171221221701287-1797980910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;已经成功，直接把属性注入到了user中。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;想的太多，做的太少，中间的落差就是烦恼，要么去做，要么别想 &lt;/strong&gt;少尉【8】&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 21 Dec 2017 14:22:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/8076274.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Web API下事件驱动型架构的实现（一）：一个简单的实现 - dax.net</title>
<link>http://www.cnblogs.com/daxnet/p/8082694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daxnet/p/8082694.html</guid>
<description>&lt;p&gt;很长一段时间以来，我都在思考如何在ASP.NET Core的框架下，实现一套完整的事件驱动型架构。这个问题看上去有点大，其实主要目标是为了实现一个基于ASP.NET Core的微服务，它能够非常简单地订阅来自于某个渠道的事件消息，并对接收到的消息进行处理，于此同时，它还能够向该渠道发送事件消息，以便订阅该事件消息的消费者能够对消息数据做进一步处理。让我们回顾一下微服务之间通信的几种方式，分为同步和异步两种。同步通信最常见的就是RESTful API，而且非常简单轻量，一个Request/Response回环就结束了；异步通信最常见的就是通过消息渠道，将载有特殊意义的数据的事件消息发送到消息渠道，而对某种类型消息感兴趣的消费者，就可以获取消息中所带信息并执行相应操作，这也是我们比较熟知的事件驱动架构的一种表现形式。虽然事件驱动型架构看起来非常复杂，从微服务的实现来看显得有些繁重，但它的应用范围确实很广，也为服务间通信提供了新的思路。了解DDD的朋友相信一定知道CQRS体系结构模式，它就是一种事件驱动型架构。事实上，实现一套完整的、安全的、稳定的、正确的事件驱动架构并不简单，由于异步特性带来的一致性问题会非常棘手，甚至需要借助一些基础结构层工具（比如关系型数据库，不错！只能是关系型数据库）来解决一些特殊问题。本文就打算带领大家一起探探路，基于ASP.NET Core Web API实现一个相对比较简单的事件驱动架构，然后引出一些有待深入思考的问题，留在今后的文章中继续讨论。或许，本文所引入的源代码无法直接用于生产环境，但我希望本文介绍的内容能够给到读者一些启发，并能够帮助解决实际中遇到的问题。&lt;/p&gt;

&lt;p&gt;本文会涉及一些相关的专业术语，在此先作约定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事件：在某一特定时刻发生在某件事物上的一件事情，例如：在我撰写本文的时候，电话铃响了&lt;/li&gt;
&lt;li&gt;消息：承载事件数据的实体。事件的序列化/反序列化和传输都以消息的形式进行&lt;/li&gt;
&lt;li&gt;消息通信渠道：一种带有消息路由功能的数据传输机制，用以在消息的派发器和订阅器之间进行数据传输&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：为了迎合描述的需要，在下文中可能会混用事件和消息两个概念。&lt;/p&gt;

&lt;p&gt;先从简单的设计开始，基本上事件驱动型架构会有事件消息（Events）、事件订阅器（Event Subscriber）、事件派发器（Event Publisher）、事件处理器（Event Handler）以及事件总线（Event Bus）等主要组件，它们之间的关系大致如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221011475-1277958781.png&quot;&gt;&lt;img width=&quot;1234&quot; height=&quot;725&quot; title=&quot;class_diagram&quot; alt=&quot;class_diagram&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221011725-384486125.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，IEvent接口定义了事件消息（更确切地说，数据）的基本结构，几乎所有的事件都会有一个唯一标识符（Id）和一个事件发生的时间（Timestamp），这个时间通常使用UTC时间作为标准。IEventHandler定义了事件处理器接口，显而易见，它包含两个方法：CanHandle方法，用以确定传入的事件对象是否可被当前处理器所处理，以及Handle方法，它定义了事件的处理过程。IEvent和IEventHandler构成了事件处理的基本元素。&lt;/p&gt;
&lt;p&gt;然后就是IEventSubscriber与IEventPublisher接口。前者表示实现该接口的类型为事件订阅器，它负责事件处理器的注册，并侦听来自事件通信渠道上的消息，一旦所获得的消息能够被某个处理器处理，它就会指派该处理器对接收到的消息进行处理。因此，IEventSubscriber会保持着对事件处理器的引用；而对于实现了IEventPublisher接口的事件派发器而言，它的主要任务就是将事件消息发送到消息通信渠道，以便订阅端能够获得消息并进行处理。&lt;/p&gt;
&lt;p&gt;IEventBus接口表示消息通信渠道，也就是大家所熟知的消息总线的概念。它不仅具有消息订阅的功能，而且还具有消息派发的能力，因此，它会同时继承于IEventSubscriber和IEventPublisher接口。在上面的设计中，通过接口分离消息总线的订阅器和派发器的角色是很有必要的，因为两种角色的各自职责不一样，这样的设计同时满足SOLID中的SRP和ISP两个准则。&lt;/p&gt;
&lt;p&gt;基于以上基础模型，我们可以很快地将这个对象关系模型转换为C#代码：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
public interface IEvent
{
    Guid Id { get; }
    DateTime Timestamp { get; }
}

public interface IEventHandler
{
    Task&amp;lt;bool&amp;gt; HandleAsync(IEvent @event, CancellationToken cancellationToken = default);
    bool CanHandle(IEvent @event);
}

public interface IEventHandler&amp;lt;in T&amp;gt; : IEventHandler
    where T : IEvent
{
    Task&amp;lt;bool&amp;gt; HandleAsync(T @event, CancellationToken cancellationToken = default);
}

public interface IEventPublisher : IDisposable
{
    Task PublishAsync&amp;lt;TEvent&amp;gt;(TEvent @event, CancellationToken cancellationToken = default)
        where TEvent : IEvent;
}

public interface IEventSubscriber : IDisposable
{
    void Subscribe();
}

public interface IEventBus : IEventPublisher, IEventSubscriber { }
&lt;/pre&gt;
&lt;p&gt;短短30行代码，就把我们的基本对象关系描述清楚了。对于上面的代码我们需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这段代码使用了C# 7.1的新特性（default关键字）&lt;/li&gt;
&lt;li&gt;Publish以及Handle方法被替换为支持异步调用的PublishAsync和HandleAsync方法，它们会返回Task对象，这样可以方便使用C#中async/await的编程模型&lt;/li&gt;
&lt;li&gt;由于我们的这个模型可以作为实现消息系统的通用模型，并且会需要用到ASP.NET Core的项目中，因此，建议将这些接口的定义放在一个独立的NetStandard的Class Library中，方便今后重用和扩展&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;OK，接口定义好了。实现呢？下面，我们实现一个非常简单的消息总线：PassThroughEventBus。在今后的文章中，我还会介绍如何基于RabbitMQ和Azure Service Bus实现不一样的消息总线。&lt;/p&gt;

&lt;p&gt;顾名思义，PassThroughEventBus表示当有消息被派发到消息总线时，消息总线将不做任何处理与路由，而是直接将消息推送到订阅方。在订阅方的事件监听函数中，会通过已经注册的事件处理器对接收到的消息进行处理。整个过程并不会依赖于任何外部组件，不需要引用额外的开发库，只是利用现有的.NET数据结构来模拟消息的派发和订阅过程。因此，PassThroughEventBus不具备容错和消息重发功能，不具备消息存储和路由功能，我们先实现这样一个简单的消息总线，来体验事件驱动型架构的设计过程。&lt;/p&gt;
&lt;p&gt;我们可以使用.NET中的Queue或者ConcurrentQueue等基本数据结构来作为消息队列的实现，与这些基本的数据结构相比，消息队列本身有它自己的职责，它需要在消息被推送进队列的同时通知调用方。当然，PassThroughEventBus不需要依赖于Queue或者ConcurrentQueue，它所要做的事情就是模拟一个消息队列，当消息推送进来的时候，立刻通知订阅方进行处理。同样，为了分离职责，我们可以引入一个EventQueue的实现（如下），从而将消息推送和路由的职责（基础结构层的职责）从消息总线中分离出来。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
internal sealed class EventQueue
{
    public event System.EventHandler&amp;lt;EventProcessedEventArgs&amp;gt; EventPushed;

    public EventQueue() { }

    public void Push(IEvent @event)
    {
        OnMessagePushed(new EventProcessedEventArgs(@event));
    }

    private void OnMessagePushed(EventProcessedEventArgs e) =&amp;gt; this.EventPushed?.Invoke(this, e);
}
&lt;/pre&gt;
&lt;p&gt;EventQueue中最主要的方法就是Push方法，从上面的代码可以看到，当EventQueue的Push方法被调用时，它将立刻触发EventPushed事件，它是一个.NET事件，用以通知EventQueue对象的订阅者，消息已经被派发。整个EventQueue的实现非常简单，我们仅专注于事件的路由，完全没有考虑任何额外的事情。&lt;/p&gt;
&lt;p&gt;接下来，就是利用EventQueue来实现PassThroughEventBus。毫无悬念，PassThroughEventBus需要实现IEventBus接口，它的两个基本操作分别是Publish和Subscribe。在Publish方法中，会将传入的事件消息转发到EventQueue上，而Subscribe方法则会订阅EventQueue.EventPushed事件（.NET事件），而在EventPushed事件处理过程中，会从所有已注册的事件处理器（Event Handlers）中找到能够处理所接收到的事件，并对其进行处理。整个流程还是非常清晰的。以下便是PassThroughEventBus的实现代码：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
public sealed class PassThroughEventBus : IEventBus
{
    private readonly EventQueue eventQueue = new EventQueue();
    private readonly IEnumerable&amp;lt;IEventHandler&amp;gt; eventHandlers;

    public PassThroughEventBus(IEnumerable&amp;lt;IEventHandler&amp;gt; eventHandlers)
    {
        this.eventHandlers = eventHandlers;
    }

    private void EventQueue_EventPushed(object sender, EventProcessedEventArgs e)
        =&amp;gt; (from eh in this.eventHandlers
            where eh.CanHandle(e.Event)
            select eh).ToList().ForEach(async eh =&amp;gt; await eh.HandleAsync(e.Event));

    public Task PublishAsync&amp;lt;TEvent&amp;gt;(TEvent @event, CancellationToken cancellationToken = default)
        where TEvent : IEvent
            =&amp;gt; Task.Factory.StartNew(() =&amp;gt; eventQueue.Push(@event));

    public void Subscribe()
        =&amp;gt; eventQueue.EventPushed += EventQueue_EventPushed;


    #region IDisposable Support
    private bool disposedValue = false; // To detect redundant calls
    void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                this.eventQueue.EventPushed -= EventQueue_EventPushed;
            }

            disposedValue = true;
        }
    }
    public void Dispose() =&amp;gt; Dispose(true);
    #endregion
}
&lt;/pre&gt;
&lt;p&gt;实现过程非常简单，当然，从这些代码也可以更清楚地了解到，PassThroughEventBus不做任何路由处理，更不会依赖于一个基础结构设施（比如实现了AMQP的消息队列），因此，不要指望能够在生产环境中使用它。不过，目前来看，它对于我们接下来要讨论的事情还是会很有帮助的，至少在我们引入基于RabbitMQ等实现的消息总线之前。&lt;/p&gt;
&lt;p&gt;同样地，请将PassThroughEventBus实现在另一个NetStandard的Class Library中，虽然它不需要额外的依赖，但它毕竟是众多消息总线中的一种，将它从接口定义的程序集中剥离开来，好处有两点：第一，保证了定义接口的程序集的纯净度，使得该程序集不需要依赖任何外部组件，并确保了该程序集的职责单一性，即为消息系统的实现提供基础类库；第二，将PassThroughEventBus置于独立的程序集中，有利于调用方针对IEventBus进行技术选择，比如，如果开发者选择使用基于RabbitMQ的实现，那么，只需要引用基于RabbitMQ实现IEventBus接口的程序集就可以了，而无需引用包含了PassThroughEventBus的程序集。这一点我觉得可以归纳为框架设计中“隔离依赖关系（Dependency Segregation）”的准则。&lt;/p&gt;
&lt;p&gt;好了，基本组件都定义好了，接下来，让我们一起基于ASP.NET Core Web API来做一个RESTful服务，并接入上面的消息总线机制，实现消息的派发和订阅。&lt;/p&gt;

&lt;p&gt;我们仍然以客户管理的RESTful API为例子，不过，我们不会过多地讨论如何去实现管理客户信息的RESTful服务，那并不是本文的重点。作为一个案例，我使用ASP.NET Core 2.0 Web API建立了这个服务，使用Visual Studio 2017 15.5做开发，并在CustomersController中使用Dapper来对客户信息CRUD。后台基于SQL Server 2017 Express Edition，使用SQL Server Management Studio能够让我方便地查看数据库操作的结果。&lt;/p&gt;
&lt;h2&gt;RESTful API的实现&lt;/h2&gt;
&lt;p&gt;假设我们的客户信息只包含客户ID和名称，下面的CustomersController代码展示了我们的RESTful服务是如何保存并读取客户信息的。当然，我已经将本文的代码通过Github开源，开源协议为MIT，虽然商业友好，但毕竟是案例代码没有经过测试，所以请谨慎使用。本文源代码的使用我会在文末介绍。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
[Route(&quot;api/[controller]&quot;)]
public class CustomersController : Controller
{
    private readonly IConfiguration configuration;
    private readonly string connectionString;

    public CustomersController(IConfiguration configuration)
    {
        this.configuration = configuration;
        this.connectionString = configuration[&quot;mssql:connectionString&quot;];
    }


    // 获取指定ID的客户信息
    [HttpGet(&quot;{id}&quot;)]
    public async Task&amp;lt;IActionResult&amp;gt; Get(Guid id)
    {
        const string sql = &quot;SELECT [CustomerId] AS Id, [CustomerName] AS Name FROM [dbo].[Customers] WHERE [CustomerId]=@id&quot;;
        using (var connection = new SqlConnection(connectionString))
        {
            var customer = await connection.QueryFirstOrDefaultAsync&amp;lt;Model.Customer&amp;gt;(sql, new { id });
            if (customer == null)
            {
                return NotFound();
            }

            return Ok(customer);
        }
    }

    // 创建新的客户信息
    [HttpPost]
    public async Task&amp;lt;IActionResult&amp;gt; Create([FromBody] dynamic model)
    {
        var name = (string)model.Name;
        if (string.IsNullOrEmpty(name))
        {
            return BadRequest();
        }

        const string sql = &quot;INSERT INTO [dbo].[Customers] ([CustomerId], [CustomerName]) VALUES (@Id, @Name)&quot;;
        using (var connection = new SqlConnection(connectionString))
        {
            var customer = new Model.Customer(name);
            await connection.ExecuteAsync(sql, customer);

            return Created(Url.Action(&quot;Get&quot;, new { id = customer.Id }), customer.Id);
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;代码一如既往的简单，Web API控制器通过Dapper简单地实现了客户信息的创建和返回。我们不妨测试一下，使用下面的Invoke-RestMethod PowerShell指令，发送Post请求，通过上面的Create方法创建一个用户：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221011959-1353324131.png&quot;&gt;&lt;img width=&quot;862&quot; height=&quot;153&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012131-1565904431.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到，response中已经返回了新建客户的ID号。接下来，继续使用Invoke-RestMethod来获取新建客户的详细信息：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012287-1264844047.png&quot;&gt;&lt;img width=&quot;863&quot; height=&quot;181&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012459-563335535.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OK，API调试完全没有问题。下面，我们将这个案例再扩充一下，我们希望这个API在完成客户信息创建的同时，向外界发送一条“客户信息已创建”的事件，并设置一个事件处理器，负责将该事件的详细内容保存到数据库中。&lt;/p&gt;
&lt;h2&gt;加入事件总线和消息处理机制&lt;/h2&gt;
&lt;p&gt;首先，我们在ASP.NET Core Web API项目上，添加对以上两个程序集的引用，然后，按常规做法，在ConfigureServices方法中，将PassThroughEventBus添加到IoC容器中：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [3];&quot;&gt;
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddSingleton&amp;lt;IEventBus, PassThroughEventBus&amp;gt;();
}
&lt;/pre&gt;
&lt;p&gt;在此，将事件总线注册为单例（Singleton）服务，是因为它不保存状态。理论上讲，使用单例服务时，需要特别注意服务实例对象的生命周期管理，因为它的生命周期是整个应用程序级别，在程序运行的过程中，由其引用的对象资源将无法释放，因此，当程序结束运行时，需要合理地将这些资源dispose掉。好在ASP.NET Core的依赖注入框架中已经帮我们处理过了，因此，对于上面的PassThroughEventBus单例注册，我们不需要过多担心，程序执行结束并正常退出时，依赖注入框架会自动帮我们dispose掉PassThroughEventBus的单例实例。那么对于单例实例来说，我们是否只需要通过AddSingleton方法进行注册就可以了，而无需关注它是否真的被dispose了呢？答案是否定的，有兴趣的读者可以参考&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection#designing-your-services-for-dependency-injection&quot; target=&quot;_blank&quot;&gt;微软的官方文档&lt;/a&gt;，在下一篇文章中我会对这部分内容做些介绍。&lt;/p&gt;
&lt;p&gt;接下来，我们需要定义一个CustomerCreatedEvent对象，表示“客户信息已经创建”这一事件信息，同时，再定义一个CustomerCreatedEventHandler事件处理器，用来处理从PassThroughEventBus接收到的事件消息。代码如下，当然也很简单：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
public class CustomerCreatedEvent : IEvent
{
    public CustomerCreatedEvent(string customerName)
    {
        this.Id = Guid.NewGuid();
        this.Timestamp = DateTime.UtcNow;
        this.CustomerName = customerName;
    }

    public Guid Id { get; }

    public DateTime Timestamp { get; }

    public string CustomerName { get; }
}

public class CustomerCreatedEventHandler : IEventHandler&amp;lt;CustomerCreatedEvent&amp;gt;
{
    public bool CanHandle(IEvent @event)
        =&amp;gt; @event.GetType().Equals(typeof(CustomerCreatedEvent));

    public Task&amp;lt;bool&amp;gt; HandleAsync(CustomerCreatedEvent @event, CancellationToken cancellationToken = default)
    {
        return Task.FromResult(true);
    

    public Task&amp;lt;bool&amp;gt; HandleAsync(IEvent @event, CancellationToken cancellationToken = default)
        =&amp;gt; CanHandle(@event) ? HandleAsync((CustomerCreatedEvent)@event, cancellationToken) : Task.FromResult(false);
}
&lt;/pre&gt;
&lt;p&gt;两者分别实现了我们最开始定义好的IEvent和IEventHandler接口。在CustomerCreatedEventHandler类的第一个HandleAsync重载方法中，我们暂且让它简单地返回一个true值，表示事件处理成功。下面要做的事情就是，在客户信息创建成功后，向事件总线发送CustomerCreatedEvent事件，以及在ASP.NET Core Web API程序启动的时候，注册CustomerCreatedEventHandler实例，并调用事件总线的Subscribe方法，使其开始侦听事件的派发行为。&lt;/p&gt;
&lt;p&gt;于是，CustomerController需要依赖IEventBus，并且在CustomerController.Create方法中，需要通过调用IEventBus的Publish方法将事件发送出去。现对CustomerController的实现做一些调整，调整后代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [6,9,13,32];&quot;&gt;
[Route(&quot;api/[controller]&quot;)]
public class CustomersController : Controller
{
    private readonly IConfiguration configuration;
    private readonly string connectionString;
    private readonly IEventBus eventBus;

    public CustomersController(IConfiguration configuration,
        IEventBus eventBus)
    {
        this.configuration = configuration;
        this.connectionString = configuration[&quot;mssql:connectionString&quot;];
        this.eventBus = eventBus;
    }

    // 创建新的客户信息
    [HttpPost]
    public async Task&amp;lt;IActionResult&amp;gt; Create([FromBody] dynamic model)
    {
        var name = (string)model.Name;
        if (string.IsNullOrEmpty(name))
        {
            return BadRequest();
        }

        const string sql = &quot;INSERT INTO [dbo].[Customers] ([CustomerId], [CustomerName]) VALUES (@Id, @Name)&quot;;
        using (var connection = new SqlConnection(connectionString))
        {
            var customer = new Model.Customer(name);
            await connection.ExecuteAsync(sql, customer);

            await this.eventBus.PublishAsync(new CustomerCreatedEvent(name));

            return Created(Url.Action(&quot;Get&quot;, new { id = customer.Id }), customer.Id);
        }
    }
    
    // Get方法暂且省略
}
&lt;/pre&gt;
&lt;p&gt;然后，修改Startup.cs中的ConfigureServices方法，将CustomerCreatedEventHandler注册进来：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [5];&quot;&gt;
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();

    services.AddTransient&amp;lt;IEventHandler, CustomerCreatedEventHandler&amp;gt;();
    services.AddSingleton&amp;lt;IEventBus, PassThroughEventBus&amp;gt;();
}
&lt;/pre&gt;
&lt;p&gt;并且调用Subscribe方法，开始侦听消息总线：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [3,4];&quot;&gt;
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    var eventBus = app.ApplicationServices.GetRequiredService&amp;lt;IEventBus&amp;gt;();
    eventBus.Subscribe();

    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.UseMvc();
}
&lt;/pre&gt;
&lt;p&gt;OK，现在让我们在CustomerCreatedEventHandler的HandleAsync方法上设置个断点，按下F5启用Visual Studio 2017调试，然后重新使用Invoke-RestMethod命令发送一个Post请求，可以看到，HandleAsync方法上的断点被命中，同时事件已被正确派发：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012600-1791331395.png&quot;&gt;&lt;img width=&quot;1033&quot; height=&quot;359&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012787-398473329.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据库中的数据也被正确更新：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012943-1439451562.png&quot;&gt;&lt;img width=&quot;562&quot; height=&quot;304&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221013146-1790163733.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前还差最后一小步，就是在HandleAsync中，将CustomerCreatedEvent对象的数据序列化并保存到数据库中。当然这也不难，同样可以考虑使用Dapper，或者直接使用ADO.NET，甚至使用比较重量级的Entity Framework Core，都可以实现。那就在此将这个问题留给感兴趣的读者朋友自己搞定啦。&lt;/p&gt;

&lt;p&gt;到这里基本上本文的内容也就告一段落了，回顾一下，本文一开始就提出了一种相对简单的消息系统和事件驱动型架构的设计模型，并实现了一个最简单的事件总线：PassThroughEventBus。随后，结合一个实际的ASP.NET Core Web API案例，了解了在RESTful API中实现事件消息派发和订阅的过程，并实现了在事件处理器中，对获得的事件消息进行处理。&lt;/p&gt;
&lt;p&gt;然而，我们还有很多问题需要更深入地思考，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果事件处理器需要依赖基础结构层组件，依赖关系如何管理？组件生命周期如何管理？&lt;/li&gt;
&lt;li&gt;如何实现基于RabbitMQ或者Azure Service Bus的事件总线？&lt;/li&gt;
&lt;li&gt;如果在数据库更新成功后，事件发送失败怎么办？&lt;/li&gt;
&lt;li&gt;如何保证事件处理的顺序？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;等等。。。在接下来的文章中，我会尽力做更详细的介绍。&lt;/p&gt;

&lt;p&gt;本系列文章的源代码在&lt;a href=&quot;https://github.com/daxnet/edasample&quot;&gt;https://github.com/daxnet/edasample&lt;/a&gt;这个Github Repo里，通过不同的release tag来区分针对不同章节的源代码。本文的源代码请参考chapter_1这个tag，如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221013303-1527015098.png&quot;&gt;&lt;img width=&quot;671&quot; height=&quot;478&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221013568-1526148515.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来还将会有chapter_2、chapter_3等这些tag，对应本系列文章的第二部分、第三部分等等。敬请期待。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Dec 2017 14:10:00 +0000</pubDate>
<dc:creator>dax.net</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daxnet/p/8082694.html</dc:identifier>
</item>
<item>
<title>数据结构(三)--栈 - xiaoyouPrince</title>
<link>http://www.cnblogs.com/xiaoyouPrince/p/8082640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyouPrince/p/8082640.html</guid>
<description>&lt;p&gt;通常程序开发中内存管理是非常重要的，而内存主要分为占内存和堆内存。那么栈和堆内存有什么区别呢？希望在这篇文章里能带你找到答案！&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;1. 栈和堆的引入&lt;/h2&gt;
&lt;p&gt;在一个简单的程序中我们定义和声明几个基本类型的变量、结构体和数组，先来直观看一下栈和堆的不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905487/201712/905487-20171221214952568-2020010359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;静态变量 和 局部变量是以压栈出栈的方式分配内存的，系统会在一个代码段中分配和回收局部变量，实际上每个代码段、函数都是一个或多个嵌套的栈，我们不需要手动管理栈区内存。&lt;/li&gt;
&lt;li&gt;动态内存是一种堆排序的方式分配内存的，内存分配好后便不会自动回收，需要程序员手动回收。否则就会造成内存泄漏，内存越用越少。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单了解了一下程序中内存栈与堆的区别，下面就正式开始讲数据结构中的栈。&lt;br/&gt;(注意：数据结构栈、内存栈、函数调用栈三者在含义上略有不同，但是其核心思想和理念是相同的)&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;2. 栈的定义&lt;/h2&gt;
&lt;p&gt;栈是一种“先进后出”的一种数据结构，有压栈出栈两种操作方式。如下图：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905487/201712/905487-20171221215006693-1385262401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;3. 栈的分类&lt;/h2&gt;
&lt;p&gt;栈主要分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态栈&lt;/li&gt;
&lt;li&gt;动态栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;【静态栈】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【动态栈】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905487/201712/905487-20171221215107365-1093439111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_4&quot;&gt;4. 栈的算法&lt;/h2&gt;
&lt;p&gt;栈的算法主要是压栈和出栈两种操作的算法，下面我就用代码来实现一个简单的栈。&lt;/p&gt;
&lt;p&gt;首先要明白以下思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;栈操作的是一个一个节点&lt;/li&gt;
&lt;li&gt;栈本身也是一种存储的数据结构&lt;/li&gt;
&lt;li&gt;栈有&lt;code&gt;初始化&lt;/code&gt;、&lt;code&gt;压栈&lt;/code&gt;、&lt;code&gt;出栈&lt;/code&gt;、&lt;code&gt;判空&lt;/code&gt;、&lt;code&gt;遍历&lt;/code&gt;、&lt;code&gt;清空&lt;/code&gt;等主要方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;toc_5&quot;&gt;4.1 栈的头文件定义&lt;/h3&gt;
&lt;p&gt;头文件定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct Node{    // 节点
    
    int data;
    struct Node *pNext;
    
}*PNODE,NODE;

typedef struct Stack{   // 栈
    
    PNODE pTop;
    PNODE pBottom;
    
}STACK,*PSTACK;

/**栈的初始化*/
void init(PSTACK);
/**压栈*/
void push(PSTACK,int);
/**出栈*/
int pop(PSTACK , int *);
/**遍历打印栈*/
void traverse(PSTACK);
/**是否为空栈*/
int isEmpty(PSTACK);
/**清空栈*/
void clearStack(PSTACK);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了头文件定义，基本就确定了栈的使用结构和使用方式。下面是在主函数中对这个栈的创建和使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int main(void){
    
    STACK stack;  // 声明一个栈
    init(&amp;amp;stack);   // 初始化
    
    // 压栈
    push(&amp;amp;stack, 10);
    push(&amp;amp;stack, 20);
    push(&amp;amp;stack, 30);
    push(&amp;amp;stack, 40);
    push(&amp;amp;stack, 50);
    
    traverse(&amp;amp;stack);   // 遍历打印栈
    
    int val;
    int isPopSuccess = pop(&amp;amp;stack,&amp;amp;val);
    if (isPopSuccess) {
        printf(&quot;pop 的值为 %d\n&quot;,val);
    }
    
    traverse(&amp;amp;stack);
    
    clearStack(&amp;amp;stack);   // 清空栈
    traverse(&amp;amp;stack);
    
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;4.2 栈的初始化&lt;/h3&gt;
&lt;p&gt;思路：&lt;br/&gt;拿到栈声明的指针，开辟一块内存空间给栈顶栈底，此时是一个空栈，栈顶栈底指向同一块内存，且栈底栈顶以外不再指向其他节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**栈的初始化*/
void init(PSTACK pS){
    
    pS-&amp;gt;pTop = (PNODE)malloc(sizeof(NODE));
    if (pS-&amp;gt;pTop == NULL) {
        printf(&quot;内存分配失败退出&quot;);
        return;
    }else
    {
        pS-&amp;gt;pBottom = pS-&amp;gt;pTop;
        pS-&amp;gt;pTop-&amp;gt;pNext = NULL;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;toc_7&quot;&gt;4.3 压栈 和 出栈&lt;/h3&gt;
&lt;p&gt;思路：&lt;br/&gt;压栈是把新的节点放入栈顶，且每次压栈操作只能将新的节点放到栈的顶部。&lt;br/&gt;出栈需判断是否原本为空栈，存在出栈失败的情况，把栈顶指向栈顶元素的下一个元素，并释放原来栈顶元素空间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**
 压栈

 @param pS 执行压栈的栈指针
 @param val 被压栈的值
 */
void push(PSTACK pS,int val){
    
    // 创建新节点，放到栈顶
    
    PNODE pNew = (PNODE)malloc(sizeof(NODE));
    pNew-&amp;gt;data = val;
    pNew-&amp;gt;pNext = pS-&amp;gt;pTop;
    
    pS-&amp;gt;pTop = pNew;    // 栈顶指针指向新元素
}

/**
 出栈

 @param pS 执行出栈的栈地址
 @param val 出栈值的地址
 @return 是否出栈成功
 */
int pop(PSTACK pS , int *val){
    
    if (isEmpty(pS)) {
        printf(&quot; 空栈 ，出栈失败&quot;);
        return 0;
    }else
    {
        PNODE p = pS-&amp;gt;pTop;
        pS-&amp;gt;pTop = p-&amp;gt;pNext;
        
        if (val != NULL) {
            *val = p-&amp;gt;data;
        }
        free(p);                // 释放原来top内存
        p = NULL;
        return 1;
    }
}

/**是否为空栈*/
int isEmpty(PSTACK pS)
{
    if (pS-&amp;gt;pTop == pS-&amp;gt;pBottom) {
        return 1;
    }else
    {
        return 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;toc_8&quot;&gt;4.4 栈的清空 和 遍历&lt;/h3&gt;
&lt;p&gt;当一个代码段执行完成之后，实际上就是这个栈所有分配的空间都被回收，栈随之被清空！&lt;/p&gt;
&lt;p&gt;思路：&lt;br/&gt;栈清空，实际就是需要循环执行出栈操作。&lt;br/&gt;栈遍历，实际就是栈元素从栈顶一个个遍历到栈底，可以打印栈中元素的值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**清空栈*/
void clearStack(PSTACK pS){
    
    if (isEmpty(pS)) {
        return;
    }else{
        PNODE p = pS-&amp;gt;pTop;
        PNODE q = NULL;
        
        while (p!=pS-&amp;gt;pBottom) {
            q = p-&amp;gt;pNext;
            free(p);        // 释放原栈顶元素空间
            p = q;
        }
        pS-&amp;gt;pTop = pS-&amp;gt;pBottom;
    }

    
//    偷懒的做法
//    while (!isEmpty(pS)) {
//        pop(pS, NULL);
//    }
}


/**遍历打印栈*/
void traverse(PSTACK pS){
    
    // 只要不是空栈，就一直输出
    PNODE p = pS-&amp;gt;pTop;
    while (p != pS-&amp;gt;pBottom) {
    
        printf(&quot;%d   &quot;,p-&amp;gt;data);
        
        p = p-&amp;gt;pNext;  // 把top的下一个节点付给top，继续遍历
    }
    printf(&quot;\n&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_9&quot;&gt;5. 栈的应用&lt;/h2&gt;
&lt;p&gt;栈结构固有的先进后出的特性，使它成为在程序设计中非常有用的工具，这里列举几个典型的例子。&lt;/p&gt;
&lt;h3 id=&quot;toc_10&quot;&gt;5.1 数制转换&lt;/h3&gt;
&lt;p&gt;十进制数 N 和其他 d 进制数的转换是计算机实现计算的基本问题，其解决方法有很多种，其中一个简单的方法基于如下原理：&lt;br/&gt;&lt;code&gt;N = (N div d) * d + N mod d&lt;/code&gt;(其中div是整除运算，mod 为求余运算)&lt;br/&gt;例如：1348(10进制) == 2504(8进制)运算过程如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;N&lt;/th&gt;
&lt;th&gt;N div 8&lt;/th&gt;
&lt;th&gt;N mod 8&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1348&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;需求:&lt;/strong&gt;输入一个任意非负十进制整数，打印输出其对应的八进制整数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路:&lt;/strong&gt;由于上述计算过程是从低到高位顺序产生八进制数的各个数位，而打印输出，一般来说应从高位到低位进行，恰好和计算过程相反。因此可利用栈先进后出特性，将计算过程中得到的八进制数各位顺序进栈，再按出栈序列打印输出既为与输入对应的八进制数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void conversion(void){
    
    // 创建栈
    STACK S;
    init(&amp;amp;S);
    
    // 用户输入十进制数
    scanf(&quot;%d&quot;,&amp;amp;N);
        
    // 放入栈中
    while (N) {
        push(&amp;amp;S, N % 8);
        N = N / 8;
    }
    
    // 打印出来
    printf(&quot;对应八进制数字为:&quot;);
    int a;
    while (!isEmpty(&amp;amp;S)) {
        pop(&amp;amp;S, &amp;amp;a);
        printf(&quot;%d&quot;,a);
    }
    printf(&quot;\n&quot;);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;思考&lt;/strong&gt; 用数组实现貌似更简单，为什么不用数组？&lt;br/&gt;从算法上分析不难看出，栈的引入简化了程序设计的问题，划分了不同的关注层次，使思考范围缩小了。而使用数组不仅掩盖了问题的本质，还要分散精力去思路数组下标增减等细节问题。&lt;br/&gt;这也是早期面向对象编程的一种思想，要把对应的功能划分关注层次，在逻辑的实现上面更加专注问题的本质。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;toc_11&quot;&gt;5.2 括号匹配的检验&lt;/h3&gt;
&lt;p&gt;编程语言中基本都允许使用 &lt;code&gt;(),[],{}&lt;/code&gt;这几种括号，假设现在让使用两种，一段完整代码中其须成对匹配，检验括号是否匹配的方法可用&quot;期待的紧迫程度&quot;这个概念来描述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905487/201712/905487-20171221215130975-32921400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当计算机接受了第一个括号后，它期待着与其匹配的第八个括号出现，然而等来的确实第二个括号，此时第一个括号&lt;code&gt;[&lt;/code&gt;只能暂时靠边，而迫切等待与第二个括号匹配的第七个括号&lt;code&gt;)&lt;/code&gt;出现，类似地，等来的是第三个括号&lt;code&gt;[&lt;/code&gt;，其期待的匹配程度比第二个更加急迫，则第二个括号也只能靠边，让位于第三个括号，显然第二个括号的期待急迫性高于第一个括号，在接受了第四个括号之后，第三个括号的期待得到满足，消解之后，第二个括号的期待匹配变成最紧迫的任务了·····，以此类推。&lt;/p&gt;
&lt;p&gt;可见此处理过程与栈的特点相吻合，由此，在算法中设置一个栈，每读入一个括号，若是右括号则使至于栈顶的最紧迫的期待得以消解，若是不合法的情况（左括号），则作为一个新的更紧迫的期待压入栈中，自然使原来所有未消解的期待的紧迫性都降了一级。另外在算法开始和结束的时候，栈都应该是空的。&lt;/p&gt;
&lt;p&gt;算法实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**
 检测括号(本实例用数字代替括号)
 
 [ ]    --&amp;gt;    1 , 2
 ( )    --&amp;gt;    3 , 4
 
 */
void checkBracelet(void)
{
    // 创建栈
    STACK S;
    init(&amp;amp;S);
    
    // 用户输入括号
    int N;
    printf(&quot;请输入对应的括号(end结束):\n&quot;);
    scanf(&quot;%d&quot;,&amp;amp;N);
    
    if (isEmpty(&amp;amp;S)) {
        push(&amp;amp;S, N);
        printf(&quot;第一个括号输入\n&quot;);
        traverse(&amp;amp;S);       // 打印此时栈内容
    }
    
    while (!isEmpty(&amp;amp;S)) {

        // 用户输入括号
        int N;
        printf(&quot;请输入对应的括号(0结束):\n&quot;);
        scanf(&quot;%d&quot;,&amp;amp;N);
        
        if (N == 0) {
            break;  // 用户输入0直接退出
        }
        
        // 判断当前栈顶是否符合标准，
        if (S.pTop-&amp;gt;data == N) {
            printf(&quot;消除一对\n&quot;);
            pop(&amp;amp;S, NULL);
            traverse(&amp;amp;S);       // 打印此时栈内容
        }else
        {
            printf(&quot;未消除\n&quot;);
            push(&amp;amp;S, N);
            traverse(&amp;amp;S);       // 打印此时栈内容
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的实例我列举了两个，实际上还有很多。比如 &lt;strong&gt;行编辑程序&lt;/strong&gt;、&lt;strong&gt;迷宫求解&lt;/strong&gt;、&lt;strong&gt;表达式求值&lt;/strong&gt;等。这里我就先不做列举了。&lt;/p&gt;
&lt;h2 id=&quot;toc_12&quot;&gt;6. 小结&lt;/h2&gt;
&lt;p&gt;通过这里复习数据结构中栈的内容，感觉重新理解了很多计算机实现的底层知识，虽然不知道的更多，但是面对计算机心中又多了一层认知！&lt;/p&gt;
&lt;p&gt;文中代码地址：&lt;a href=&quot;https://github.com/xiaoyouPrince/DataStructure&quot;&gt;https://github.com/xiaoyouPrince/DataStructure&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Dec 2017 13:53:00 +0000</pubDate>
<dc:creator>xiaoyouPrince</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoyouPrince/p/8082640.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——1. 考虑使用静态工厂方法替代构造方法 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8082510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8082510.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一个类允许客户端获取其实例的传统方式是提供一个公共构造方法。 其实还有另一种技术应该成为每个程序员工具箱的一部分。 一个类可以提供一个公共静态工厂方法，它只是一个返回类实例的静态方法。 下面是一个&lt;code&gt;Boolean&lt;/code&gt;简单的例子（&lt;code&gt;boolean&lt;/code&gt;基本类型的包装类）。 此方法将&lt;code&gt;boolean&lt;/code&gt;基本类型转换为&lt;code&gt;Boolean&lt;/code&gt;对象引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，静态工厂方法与设计模式中的工厂方法模式不同[Gamma95]。本条目中描述的静态工厂方法在设计模式中没有直接的等价。&lt;/p&gt;
&lt;p&gt;类可以为其客户端提供静态工厂方法，而不是公共构造方法。提供静态工厂方法而不是公共构造方法有优点也有缺点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂方法的一个优点是，不像构造方法，它们是有名字的。&lt;/strong&gt; 如果构造方法的参数本身并不描述被返回的对象，则具有精心选择名称的静态工厂更易于使用，并且生成的客户端代码更易于阅读。 例如，返回一个可能为素数的&lt;code&gt;BigInteger&lt;/code&gt;的构造方法&lt;code&gt;BigInteger(int，int，Random)&lt;/code&gt;可以更好地表示为名为&lt;code&gt;BigInteger.probablePrime&lt;/code&gt;的静态工厂方法。 （这个方法是在Java 1.4中添加的。）&lt;/p&gt;
&lt;p&gt;一个类只能有一个给定签名的构造方法。 程序员知道通过提供两个构造方法来解决这个限制，这两个构造方法的参数列表只有它们的参数类型的顺序不同。 这是一个非常糟糕的主意。 这样的API用户将永远不会记得哪个构造方法是哪个，最终会错误地调用。 阅读使用这些构造方法的代码的人只有在参考类文档的情况下才知道代码的作用。&lt;/p&gt;
&lt;p&gt;因为他们有名字，所以静态工厂方法不会受到上面讨论中的限制。在类中似乎需要具有相同签名的多个构造方法的情况下，用静态工厂方法替换构造方法，并仔细选择名称来突出它们的差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂方法的第二个优点是，与构造方法不同，它们不需要每次调用时都创建一个新对象。&lt;/strong&gt;这允许不可变的类(条目17)使用预先构建的实例，或者在构造时缓存实例，并反复分配它们以避免创建不必要的重复对象。&lt;code&gt;boolean.valueof(boolean)&lt;/code&gt;方法说明了这种方法：它从不创建对象。这种技术类似于Flyweight模式[Gamma95]。如果经常请求等价对象，那么它可以极大地提高性能，特别是如果在创建它们非常昂贵的情况下。&lt;/p&gt;
&lt;p&gt;静态工厂方法从重复调用返回相同对象的能力允许类保持在任何时候存在的实例的严格控制。这样做的类被称为实例控制（ instance-controlled）。编写实例控制类的原因有很多。实例控制允许一个类来保证它是一个单例(3)项或不可实例化的(条目4)。同时,它允许一个不可变的值类(条目17)保证不存在两个相同的实例：当且仅当&lt;code&gt;a== b&lt;/code&gt;时&lt;code&gt;a.equals(b)&lt;/code&gt;。这是享元模式的基础[Gamma95]。&lt;code&gt;Enum&lt;/code&gt;类型(条目34)提供了这个保证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂方法的第三个优点是，与构造方法不同，它们可以返回其返回类型的任何子类型的对象。&lt;/strong&gt; 这为你在选择返回对象的类时提供了很大的灵活性。&lt;/p&gt;
&lt;p&gt;这种灵活性的一个应用是API可以返回对象而不需要公开它的类。 以这种方式隐藏实现类会使 API非常紧凑I。 这种技术适用于基于接口的框架（条目20），其中接口为静态工厂方法提供自然返回类型。&lt;/p&gt;
&lt;p&gt;在Java 8之前，接口不能有静态方法。根据约定，一个名为&lt;code&gt;Type&lt;/code&gt;的接口的静态工厂方法被放入一个非实例化的伙伴类(companion class)(条目4)&lt;code&gt;Types&lt;/code&gt;类中。例如，Java集合框架有45个接口的实用工具实现，提供不可修改的集合、同步集合等等。几乎所有这些实现都是通过静态工厂方法在一个非实例类(&lt;code&gt;java .util. collections&lt;/code&gt;)中导出的。返回对象的类都是非公开的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Collections&lt;/code&gt;框架API的规模要比它之前输出的45个单独的公共类要小得多，每个类有个便利类的实现。不仅是API的大部分减少了，还包括概念上的权重：程序员必须掌握的概念的数量和难度，才能使用API。程序员知道返回的对象恰好有其接口指定的API，因此不需要为实现类读阅读额外的类文档。此外，使用这种静态工厂方法需要客户端通过接口而不是实现类来引用返回的对象，这通常是良好的实践(条目64)。&lt;/p&gt;
&lt;p&gt;从Java 8开始，接口不能包含静态方法的限制被取消了，所以通常没有理由为接口提供一个不可实例化的伴随类。 很多公开的静态成员应该放在这个接口本身。 但是，请注意，将这些静态方法的大部分实现代码放在单独的包私有类中仍然是必要的。 这是因为Java 8要求所有接口的静态成员都是公共的。 Java 9允许私有静态方法，但静态字段和静态成员类仍然需要公开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同。&lt;/strong&gt; 声明的返回类型的任何子类都是允许的。 返回对象的类也可以随每次发布而不同。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EnumSet&lt;/code&gt;类（条目 36）没有公共构造方法，只有静态工厂。 在OpenJDK实现中，它们根据底层枚举类型的大小返回两个子类中的一个的实例：如果大多数枚举类型具有64个或更少的元素，静态工厂将返回一个&lt;code&gt;RegularEnumSet&lt;/code&gt;实例， 返回一个&lt;code&gt;long&lt;/code&gt;类型；如果枚举类型具有六十五个或更多元素，则工厂将返回一个&lt;code&gt;JumboEnumSet&lt;/code&gt;实例，返回一个&lt;code&gt;long&lt;/code&gt;类型的数组。&lt;/p&gt;
&lt;p&gt;这两个实现类的存在对于客户是不可见的。 如果&lt;code&gt;RegularEnumSet&lt;/code&gt;不再为小枚举类型提供性能优势，则可以在未来版本中将其淘汰，而不会产生任何不良影响。 同样，未来的版本可能会添加&lt;code&gt;EnumSet&lt;/code&gt;的第三个或第四个实现，如果它证明有利于性能。 客户既不知道也不关心他们从工厂返回的对象的类别; 他们只关心它是&lt;code&gt;EnumSet&lt;/code&gt;的一些子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂的第5个优点是，在编写包含该方法的类时，返回的对象的类不需要存在。&lt;/strong&gt;这种灵活的静态工厂方法构成了服务提供者框架的基础，比如Java数据库连接API(JDBC)。服务提供者框架是提供者实现服务的系统，并且系统使得实现对客户端可用，从而将客户端从实现中分离出来。&lt;/p&gt;
&lt;p&gt;服务提供者框架中有三个基本组：服务接口，它表示实现；提供者注册API，提供者用来注册实现；以及服务访问API，客户端使用该API获取服务的实例。服务访问API允许客户指定选择实现的标准。在缺少这样的标准的情况下，API返回一个默认实现的实例，或者允许客户通过所有可用的实现进行遍历。服务访问API是灵活的静态工厂，它构成了服务提供者框架的基础。&lt;/p&gt;
&lt;p&gt;服务提供者框架的一个可选的第四个组件是一个服务提供者接口，它描述了一个生成服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须对实现进行反射实例化(条目65)。在JDBC的情况下，&lt;code&gt;Connection&lt;/code&gt;扮演服务接口的一部分，&lt;code&gt;DriverManager.registerDriver&lt;/code&gt;提供程序注册API、&lt;code&gt;DriverManager.getConnection&lt;/code&gt;是服务访问API，&lt;code&gt;Driver&lt;/code&gt;是服务提供者接口。&lt;/p&gt;
&lt;p&gt;服务提供者框架模式有许多变种。 例如，服务访问API可以向客户端返回比提供者提供的更丰富的服务接口。 这是桥接模式[Gamma95]。 依赖注入框架（条目5）可以被看作是强大的服务提供者。 从Java 6开始，平台包含一个通用的服务提供者框架&lt;code&gt;java.util.ServiceLoader&lt;/code&gt;，所以你不需要，一般也不应该自己编写（条目59）。 JDBC不使用&lt;code&gt;ServiceLoader&lt;/code&gt;，因为前者早于后者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只提供静态工厂方法的主要限制是，没有公共或受保护构造方法的类不能被子类化。&lt;/strong&gt;例如，在&lt;code&gt;Collections&lt;/code&gt;框架中不可能将任何方便实现类子类化。可以说，这可能是因祸得福，因为它鼓励程序员使用组合而不是继承(条目18)，并且是不可变类型(条目17)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂方法的第二个缺点是，程序员很难找到它们。&lt;/strong&gt;它们不像构造方法那样在API文档中突出，因此很难找出如何实例化一个提供静态工厂方法而不是构造方法的类。Javadoc工具可能有一天会引起对静态工厂方法的注意。与此同时，可以通过将注意力吸引到类或接口文档中的静态工厂以及遵守通用的命名约定来减少这个问题。下面是一些静态工厂方法的常用名称。以下清单并非完整：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;from——A类型转换方法，它接受单个参数并返回此类型的相应实例，例如：&lt;code&gt;Date d = Date.from(instant)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;of——一个聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：&lt;code&gt;Set&amp;lt;Rank&amp;gt; faceCards = EnumSet.of(JACK, QUEEN, KING)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;valueOf——from和to更为详细的替代 方式，例如：&lt;code&gt;BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;instance或getinstance——返回一个由其参数(如果有的话)描述的实例，但不能说它具有相同的值，例如：&lt;code&gt;StackWalker luke = StackWalker.getInstance(options)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;create 或 newInstance——与instance 或 getInstance类似，除了该方法保证每个调用返回一个新的实例，例如：&lt;code&gt;Object newArray = Array.newInstance(classObject, arrayLen)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;getType——与getInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，例如：&lt;code&gt;FileStore fs = Files.getFileStore(path)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;newType——与newInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，例如：&lt;code&gt;BufferedReader br = Files.newBufferedReader(path)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;type—— getType 和 newType简洁的替代方式，例如：&lt;code&gt;List&amp;lt;Complaint&amp;gt; litany = Collections.list(legacyLitany)&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之，静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。通常，静态工厂更可取，因此避免在没有考虑静态工厂的情况下提供公共构造方法。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Dec 2017 13:12:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8082510.html</dc:identifier>
</item>
<item>
<title>C#中的Explicit和Implicit - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/8082405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/8082405.html</guid>
<description>&lt;p&gt;&lt;span&gt;今天在Review一个老项目的时候，看到一段奇怪的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;if (dto.Payment == null) continue;

var entity = entries.FirstOrDefault(e =&amp;gt; e.LedgerEntryID == dto.LedgerEntryID);

dto.Payment = entity?.Payment;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中dto.Payment是一个&lt;code&gt;PaymentDTO&lt;/code&gt;类的实例，entity?.Payment是一个&lt;code&gt;Payment&lt;/code&gt;类的实例，&lt;code&gt;PaymentDTO&lt;/code&gt;类和&lt;code&gt;Payment&lt;/code&gt;类没有子父关系，所以不存在子类和父类之间的隐式转换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;奇怪的是Visual Studio的编译器没有提示任何编译错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开PaymentDTO类的定义之后，发现了以下方法签名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; PaymentDTO(Payment payment)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从方法签名上看，这就是重写PaymentDTO类型的操作符，但并不是我以前常用的+,-,*,/, ==等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询MSDN之后，才了解到implicit和explicit是一对转换操作符。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;Implicit&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Implicit关键字用于声明隐式的用户定义类型转换运算符。它可以实现2个不同类的隐式转换 ，提高代码的可读性。但是需要注意使用隐式转换操作符之后，在编译时会跳过异常检查，所以隐式转换运算符应当从不引发异常并且从不丢失信息，否则在运行时会出现一些意想不到的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如当前PaymentDTO和Payment的定义如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Payment

    {

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Amount { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    }

 

&lt;/span&gt;&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PaymentDTO

    {

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AmountString { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果需要将Payment隐式转换成PaymentDTO, 仅需声明PaymentDTO的隐式转换运算符&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PaymentDTO

        {

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AmountString { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

 

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;&lt;span&gt; PaymentDTO(Payment payment)

            {

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PaymentDTO

                {

                    AmountString &lt;/span&gt;= payment.Amount.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

                };

            }

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;调用时只需要直接赋值就可以&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program

        {

            &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)

            {

                PaymentDTO dto &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Payment { Amount = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; };

 

                Console.WriteLine(dto.AmountString);

                Console.Read();

            }

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Explicit&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Explicit关键字声明必须通过转换来调用的用户定义的类型转换运算符。不同于隐式转换，显式转换运算符必须通过转换的方式来调用，如果缺少了显式的转换，在编译时就会产生错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如现在我们将前面PaymentDTO类中定义的转换操作符从Implicit变为Explicit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PaymentDTO

        {

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AmountString { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

 

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;explicit&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;&lt;span&gt; PaymentDTO(Payment payment)

            {

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PaymentDTO

                {

                    AmountString &lt;/span&gt;= payment.Amount.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

                };

            }

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时候由于Main方法中没有显式转换，所以编译器出错，提示Cannot implicitly convert type 'ExplicitImplicit.Payment' to 'ExplicitImplicit.PaymentDTO'. An explicit conversion exists (are you missing a cast?)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/65831/201712/65831-20171221210015021-1105353834.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想要编译器通过编译, 只需要做一个显示转换即可&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program

        {

            &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)

            {

                PaymentDTO dto &lt;/span&gt;= (PaymentDTO)&lt;span&gt;new&lt;/span&gt; Payment { Amount = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; };

 

                Console.WriteLine(dto.AmountString);

                Console.Read();

            }

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;Implicit提高了代码的可读性，但程序员需要自己保证转换不引发异常且不丢失信息&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Explicit可阻止编译器静默调用可能产生意外后果的转换操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;前者更易于使用，后者能向阅读代码的每个人清楚地指示您要转换类型&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 21 Dec 2017 12:57:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/8082405.html</dc:identifier>
</item>
<item>
<title>TCP的十一种状态与三次握手分析（有图） - xcywt</title>
<link>http://www.cnblogs.com/xcywt/p/8082428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcywt/p/8082428.html</guid>
<description>&lt;p&gt;我们知道TCP是面向连接的，我们只知道有连接断开，其实内部还有一些比较复杂的状态。去了解各个状态之间的切换有助于我们更加深入的了解TCP。下面我们就来分析各个状态。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、如下图示（图源百度）图中显示出了10种状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221201248131-854463251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们假定断开时是client主动断开的。&lt;br/&gt;对于server来说状态有：closed -&amp;gt; listen -&amp;gt; syn_recv -&amp;gt; enstablished -&amp;gt; close_wait -&amp;gt; last_ack -&amp;gt; closed&lt;br/&gt;对于client来说状态有：closed -&amp;gt; syn_send -&amp;gt; enstablished -&amp;gt; fin_wait1 -&amp;gt; fin_wait2 -&amp;gt; time_wait&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.结合三次握手进行分析状态&lt;/span&gt;&lt;br/&gt;我们知道三次握手的这样： &lt;br/&gt;client 发送 syn x到server&lt;br/&gt;server 回复syn y和ack x+1&lt;br/&gt;client再回复 ack y+1&lt;br/&gt;下面分析上面三步与状态的关系：&lt;br/&gt;1）首先，刚创建的socket都是closed状态，server调用listen之后进入listen状态&lt;br/&gt;2）接着、客户端调用connnect。（TCP协议会完成三次握手，client发送第一个syn之后就进入syn_send状态。与此同时，server收到syn并回复syn和ack，server进入syn_recv状态）&lt;br/&gt;3）之后、client和server都进入了enstablisted状态。之后就可以互相发送数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221202912443-243227396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;关于TCP协议头中的确认号ack的理解可以参考：http://www.cnblogs.com/xcywt/p/8075623.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于Wireshark的理解可以参考：http://www.cnblogs.com/xcywt/p/8025113.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;结合Wireshark抓包分析三次握手：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 这里设置的过滤器，先清空当前捕获的包，在浏览器打开博客园。&lt;/p&gt;
&lt;p&gt;假设TCPa -&amp;gt; TCPb&lt;/p&gt;
&lt;p&gt;第一次：如下图，发送一个请求 syn，序号为0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221203715709-684208524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二次：B回复，发送syn，ack为0+1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221203725521-1135477587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三次，A回复，ack = y + 1。其中y为之前B发送过来的序号，这里过来的序号的0，所以ack = 1；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221203736381-380871809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;3.结合断开时四次握手进行分析状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如图（图源百度，侵删）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221204951256-1675354780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道四次握手是这样的（假定是client先close 的）：&lt;br/&gt;client调用close。TCP协议会发送FIN x给server&lt;br/&gt;server收到FIN x之后，会回复ack x+1&lt;br/&gt;接着、server调用close，给客户端发送FIN y&lt;br/&gt;最后，客户端回复ack y+1&lt;br/&gt;分析与状态的关系：&lt;br/&gt;1）client调用close，发送了FINx。client进入&lt;span&gt;fin_wait1&lt;/span&gt;状态。server收到并回复ack，server进入&lt;span&gt;close_wait&lt;/span&gt;状态。然后client会收到ack，进入&lt;span&gt;fin_wait2&lt;/span&gt;状态&lt;br/&gt;2）server接着调用close，给client发送了fin，server则进入了了&lt;span&gt;last_ack&lt;/span&gt;状态。&lt;br/&gt;3）client收到FIN 之后，回复ack。client进入time_wait状态。server收到ack之后，进入&lt;span&gt;closed&lt;/span&gt;状态。&lt;br/&gt;（&lt;span&gt;client在保持了2个MSL&lt;/span&gt;之后就进入&lt;span&gt;closed&lt;/span&gt;状态）&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.注意事项&lt;/span&gt;&lt;br/&gt;1）&lt;span&gt;client进入time_wait状态之后，会保持在这个状态2MSL&lt;/span&gt;。目的是为了确保发送过去的ack可以被收到（因为后面已经没有数据可以发送了）。&lt;br/&gt;2）连接过程是状态的改变，促使状态的改变是用户的调用。所以切换状态不一定是用户的调用。（比如，server进入close_wait状态，纯粹是TCP协议做好的，用户并没有调用什么接口）&lt;br/&gt;3）关于退出时的分析，存在一个主动一个被动关系。上面分析的client主动，则client会出现&lt;span&gt;fin_wait1、fin_wait2、time_wai&lt;/span&gt;t状态。server会出现&lt;span&gt;close_wait、last_ack&lt;/span&gt;状态。&lt;br/&gt;如果是server主动断开的，则关系刚刚反过来了。server先进入&lt;span&gt;fin_wait1&lt;/span&gt;状态，然后是&lt;span&gt;fin_wait2&lt;/span&gt;状态。后面整个就反过来了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.关于closing状态的出现&lt;strong&gt;&lt;span&gt;（这里就是第十一种状态）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;通过上面的分析我们知道，client主动退出时，先给server发送了一个FIN。接着会收到一个ack确认这个FIN。&lt;br/&gt;&lt;span&gt;如果没收到ack，而是收到server发来的FIN y。那么这时候则进入closing状态。&lt;/span&gt;&lt;br/&gt;这种情况是怎么出现的呢：那就是双方几乎同时closer一个socket。这是双方都正在关闭socket连接。这种情况出现的几率很小&lt;/p&gt;&lt;p&gt;&lt;span&gt;6.为什么连接需要三次握手，断开需要四次握手。&lt;/span&gt;&lt;br/&gt;首先我们知道，TCP协议是去全双工的。可以在发送的同时进行接收数据。&lt;br/&gt;假定是主机A和主机B进行通信，断开时是A主动断开的。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;1）三次握手：&lt;/span&gt;&lt;/strong&gt;第一次握手表明A可以发数据给B。但是无法保证B发给A的数据可以被收到。所以B也需要发送SYN给A，A对它进行回应，才保证了B也可以发数据给A。&lt;br/&gt;个人理解可以把三步拆分为四步理解：&lt;br/&gt;a）主机A给B发送SYN&lt;br/&gt;b）主机B回复ack --- 这时表明A可以发数据给B&lt;br/&gt;c）主机B发送SYN给A&lt;br/&gt;d）主机A回复ack --- 这时表明B也可以发送数据给A&lt;br/&gt;&lt;span&gt;只不过协议中，把中间两步放在一步进行了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）四次握手，就像下面这样理解：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;a）主机A给B发送FIN，表示对B说“我要断开了”&lt;br/&gt;b）主机B回复ack进行确认，表示对A说“嗯，我知道了，你可以断开了”&lt;br/&gt;c）然后B发送FIN给A，表示对A说“A，我也要断开了”&lt;br/&gt;d）A回复ack进行确认，表示对B说：“嗯，知道了，你断开吧”&lt;br/&gt;前两步对A进行断开，后两步对B进行断开。&lt;br/&gt;&lt;span&gt;那么为什么不能把中间两步进行合并呢，因为无法保证被断开的一方的数据已经传送完毕了。&lt;/span&gt;&lt;br/&gt;就拿上面的例子来说，假如A断开了通知B，但是B还有数据没有发送完毕，如果立即断开（调用close发送FIN），就无法保证数据的可靠性。&lt;br/&gt;如果等数据发送完毕再将fin和ack一起发过去，n那么A就会长时间处于fin_wait1状态。这样就比较不好了。&lt;/p&gt;&lt;p&gt;实际情况中我们可能会在server忘记关闭客户端的socket。那么client就会一直处于fin_wait2状态，越来越多的fin_wait2状态会导致系统崩溃。所以我们需要在编程中要注意在什么情况下要关闭双方的socket。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7.其他知识&lt;/span&gt;&lt;br/&gt;什么时候会收到SIGPIPE这个信号呢？&lt;br/&gt;当server关闭一个连接之后，client接着发送数据，第一次发送会收到一个RST的响应。如果接着发送则系统会发出一个SIGPIPE信号给client。&lt;br/&gt;系统默认的处理是将应用程序退出。实际编程中，我们可以捕获这个信号，让应用程序不退出&lt;/p&gt;
&lt;p&gt; 如下（伪代码）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;signal.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; sig_recvpipe(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sig)
{
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    ......
    signal(SIGPIPE, sig_recvpipe);
    ......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 21 Dec 2017 12:55:00 +0000</pubDate>
<dc:creator>xcywt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcywt/p/8082428.html</dc:identifier>
</item>
<item>
<title>【DevOps】团队敏捷开发系列--开山篇 - 千万之路刚开始</title>
<link>http://www.cnblogs.com/hyhnet/p/8082390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hyhnet/p/8082390.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;随着软件发布迭代的频率越来越高，传统的「瀑布型」（开发—测试—发布）模式已经不能满足快速交付的需求。2009 年左右 DevOps 应运而生，开发运维一体化，通过自动化工具与流程让整个软件开发构建、测试、发布更加快捷、频繁、高效和可靠。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-6958c29683b13b8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;本系列教程目录&quot;&gt;本系列教程目录&lt;/h2&gt;
&lt;p&gt;本系列将详细讲解Devops落地细节。将构建整个持续集成与交付的一整套体系与流程。对于未来要开篇的系列博文列表如下：&lt;/p&gt;
&lt;p&gt;【DevOps】团队敏捷开发系列(一)--开山篇&lt;br/&gt;【DevOps】团队敏捷开发系列(二)--版本控制之道Git&lt;br/&gt;【DevOps】团队敏捷开发系列(三)--代码管理之道Gitlab&lt;br/&gt;【DevOps】团队敏捷开发系列(四)--前后端分离契机Swagger&lt;br/&gt;【DevOps】团队敏捷开发系列(五)--代码编译MAVEN&lt;br/&gt;【DevOps】团队敏捷开发系列(六)--自动化CI工具Jenkins&lt;br/&gt;【DevOps】团队敏捷开发系列(七)--自动化流程编排&lt;br/&gt;【DevOps】团队敏捷开发系列(八)--自动化单元测试Junit&lt;br/&gt;【DevOps】团队敏捷开发系列(九)--自动化性能压测Jmater&lt;br/&gt;【DevOps】团队敏捷开发系列(十)--持续部署流程编排&lt;br/&gt;【DevOps】团队敏捷开发系列(番外篇)--Linux常用命令&lt;/p&gt;
&lt;h2 id=&quot;相关概念解释&quot;&gt;相关概念解释&lt;/h2&gt;
&lt;h3 id=&quot;devops-概念&quot;&gt;DevOps 概念&lt;/h3&gt;
&lt;p&gt;Ops&quot;是一个总括术语，泛指系统工程师、系统管理员、操作人员，发布工程师、DBA、网络工程师、安全专家和各种其他分支和头衔。&quot;Dev&quot;是开发人员的简称，但真正在实践中意味着更广泛的&quot;参与开发的产品&quot;的所有人，可包括产品,质量保证,和其他种类的学科。&lt;/p&gt;
&lt;h3 id=&quot;devops-发展&quot;&gt;DevOps 发展&lt;/h3&gt;
&lt;p&gt;DevOps（英文Development和Operations的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作。 从2009年起，相关的工作组、专业组织和博客快速涌现。&lt;/p&gt;
&lt;h3 id=&quot;自动化概念&quot;&gt;自动化概念&lt;/h3&gt;
&lt;p&gt;自动化（Automation）是指机器设备、系统或过程（生产、管理过程）在没有人或较少人的直接参与下，按照人的要求，经过自动检测、信息处理、分析判断、操纵控制，实现预期的目标的过程。自动化技术广泛用于工业、农业、军事、科学研究、交通运输、商业、医疗、服务和家庭等方面。采用自动化技术不仅可以把人从繁重的体力劳动、部分脑力劳动以及恶劣、危险的工作环境中解放出来，而且能扩展人的器官功能，极大地提高劳动生产率，增强人类认识世界和改造世界的能力。因此，自动化是工业、农业、国防和科学技术现代化的重要条件和显著标志。&lt;/p&gt;
&lt;h3 id=&quot;devops自动化&quot;&gt;DevOps自动化&lt;/h3&gt;
&lt;p&gt;全面自动化 —— 部署、 升级、 扩展、 维护、 数据、 测试、 监测、 安全和策略管理。在自动化方面投入巨资，目标是100%的自动化，不考虑低于90%的可能性。但是，全面自动化也可能会引起自动化泛滥。集中审查和调整可以控制Chef或Puppet脚本库的无序增长。&lt;br/&gt;DevOps战略必须获取本组织自顶向下的全面支持。整个行政领导团队 ——不只是首席信息官 ——应知道它为什么重要和怎样使它取得成功。&lt;/p&gt;
&lt;h2 id=&quot;为什么devops&quot;&gt;为什么DevOps&lt;/h2&gt;
&lt;p&gt;为什么我们采用DevOps,首先来看一下传统的开发运维模式。&lt;/p&gt;
&lt;h3 id=&quot;传统开发模式&quot;&gt;传统开发模式&lt;/h3&gt;
&lt;p&gt;首先，开发人员开发完毕，并进行简单自测，和 手动 功能测试。&lt;br/&gt;其次，开发人员利用IDE 手动 打包。&lt;br/&gt;然后，将构建后的文件 手动 复制到公网服务器指定目录。&lt;br/&gt;最后，启动程序并进行手工测试。&lt;br/&gt;很明显，在这个过程中，有太多重复性的东西，会严重影响团队效率。&lt;/p&gt;
&lt;h3 id=&quot;自动化方案&quot;&gt;自动化方案&lt;/h3&gt;
&lt;p&gt;我们可以简单的来将我们的系统优化，最终形成强大的自动化敏捷体系。&lt;/p&gt;
&lt;h4 id=&quot;自动化单元测试&quot;&gt;自动化单元测试&lt;/h4&gt;
&lt;p&gt;我们可以通过一些自动化平台例如jenkins 进行自动化单元测试的集成。可以很高效的对整个开发进行系统的单元测试，简化测试流程，提升测试效率&lt;/p&gt;
&lt;h4 id=&quot;自动化打包构建&quot;&gt;自动化打包构建&lt;/h4&gt;
&lt;p&gt;通过一些列的代码与版本控制管理工具，例如Git与Gitlab可以非常有效的管理代码、版本、分支、标签等等。当然不仅于此，还有很多比较优秀的工具供我们使用。但是目前市场最流行的当属Git与Gitlab体系。&lt;/p&gt;
&lt;h4 id=&quot;自动化发布&quot;&gt;自动化发布&lt;/h4&gt;
&lt;p&gt;针对于后端服务用Java开发的应用程序，我们大可以使用MAVEN或者Gradle进行统一的依赖管理及代码编译打包控制。可以通过一些列Wiki进行配置触发器，集成到jenkins等工具上，然后进行自动化的远程节点打包。当然可以在jenkins建立多个节点去持续多点出发集成。&lt;/p&gt;
&lt;h4 id=&quot;自动化部署&quot;&gt;自动化部署&lt;/h4&gt;
&lt;p&gt;通过强大的shell命令，让我们可以在每个服务器、每一个环境当中，自由穿梭。对于自动化部署，需要按照实际需求，编写不同的shell脚本，然后将相关流程进行配置，结合jenkins等工具，可以快速实现每一个环节的发布。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-f4ebcb0dcb53af35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;devops团队需要做什么&quot;&gt;DevOps团队需要做什么&lt;/h2&gt;
&lt;p&gt;DevOps团队执行各种任务, 如:&lt;br/&gt;1. 新虚拟服务器的配置&lt;br/&gt;2. 配置网络设备&lt;br/&gt;3. 应用程序部署&lt;br/&gt;4. 收集和聚合的日志&lt;br/&gt;5. 性能监视服务&lt;br/&gt;6. 报警和自动修复的问题&lt;br/&gt;7. 服务器和服务可用性监控&lt;/p&gt;
&lt;h2 id=&quot;devops团队工具&quot;&gt;DevOps团队工具&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;right&quot;&gt;Docker&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;虚拟化容器技术，快速构建独立隔离服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;right&quot;&gt;Jenkins&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;自动化平台，可以配置自动化测试与持续部署&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;right&quot;&gt;New Relic&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;应用性能监测&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;right&quot;&gt;Ansible&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;自动化(配置管理工具)平台，持续集成与编排&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;right&quot;&gt;Kubernetes&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;开源的docker编排工具，可以发布与回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;right&quot;&gt;JMeter&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;基于Java的压力测试工具。用于对软件做压力测试&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;还有很多工具可以使用，这个具体我们后续慢慢讲来。&lt;/p&gt;
&lt;h2 id=&quot;番外篇&quot;&gt;番外篇&lt;/h2&gt;
&lt;p&gt;除了一整套DevOps的体系，我们会在整个系统当中，穿插讲解Docker容器的使用。对于我们很多时候遇到的依赖或者安装流程复杂的问题，都可以容器的方式快速解决，并且可以快速启动或销毁多个服务。&lt;/p&gt;
&lt;p&gt;未尽之处将会在系列博文中详细说道。本文只是对系列博文的概要说明，本文也参考了互联网很多资料整理所得。&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;本文出处：&lt;a href=&quot;http://www.hanyahong.com/&quot; class=&quot;uri&quot;&gt;http://www.hanyahong.com/&lt;/a&gt;&lt;br/&gt;（欢迎转发、请注明出处！）&lt;/p&gt;
</description>
<pubDate>Thu, 21 Dec 2017 12:45:00 +0000</pubDate>
<dc:creator>千万之路刚开始</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hyhnet/p/8082390.html</dc:identifier>
</item>
</channel>
</rss>