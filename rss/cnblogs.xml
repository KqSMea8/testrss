<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>redis5.0.0功能介绍以及主从集群、哨兵搭建 - ibethfy</title>
<link>http://www.cnblogs.com/ibethfy/p/9965902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ibethfy/p/9965902.html</guid>
<description>&lt;p&gt;这两天突然想起redis，索性就再尝试一下搭建最新版本的redis，过程有点艰辛呀，记录一下，供自己和大家今后搭建做参考。&lt;/p&gt;
&lt;p&gt;一、为什么用Redis？&lt;/p&gt;
&lt;p&gt;　　我自己总结了一下：&lt;/p&gt;
&lt;p&gt;　　1、基于内存实现的key-value类型的存储，速度快，性能好。&lt;/p&gt;
&lt;p&gt;　　2、支持多种存储类型，有Strings，Hashes，Sets，Lists，Sorted Sets类型。&lt;/p&gt;
&lt;p&gt;　　3、支持数据持久化，有Snapshotting，Append-Only File模式的持久化。&lt;/p&gt;
&lt;p&gt;　　4、支持集群和哨兵。&lt;/p&gt;
&lt;p&gt;　　5、支持主从复制。&lt;/p&gt;
&lt;p&gt;　　6、支持简单的事务控制。&lt;/p&gt;
&lt;p&gt;　　7、支持消息的发布和订阅。&lt;/p&gt;
&lt;p&gt;　　8、安全性的支持。&lt;/p&gt;
&lt;p&gt;　　9、支持数据过期。等等&lt;/p&gt;
&lt;p&gt;二、Redis的应用场景&lt;/p&gt;
&lt;p&gt;　　总结了以下几点，应用场景特别多，大家根据其特性可类推其作用：&lt;/p&gt;
&lt;p&gt;　　1、主要是用于热点数据的存储，比如Top100，最新10个数据。&lt;/p&gt;
&lt;p&gt;　　2、时间过期（如短信验证码的过期时间等）。&lt;/p&gt;
&lt;p&gt;　　3、计数器，由于Redis是单线程且命令的原子性，可用来构建计数器。&lt;/p&gt;
&lt;p&gt;　　4、可用来构建队列，Sorted Sets。&lt;/p&gt;
&lt;p&gt;　　5、缓存，为减轻数据库访问压力。&lt;/p&gt;
&lt;p&gt;　　6、分布式锁，分布式session管理。&lt;/p&gt;
&lt;p&gt;三、Redis主要功能介绍。&lt;/p&gt;
&lt;p&gt;　　先介绍Redis的几个主要功能。&lt;/p&gt;
&lt;p&gt;　　1、不同数据类型的存储。这个我在这里就不讲了。哈哈，大家去百度下都有了。&lt;/p&gt;
&lt;p&gt;　　2、高级特性。在这里，我通过redis的redis.conf配置文件来给大家讲解，只讲经常会用到的，其余配置，大家感兴趣可自己学习下。&lt;/p&gt;
&lt;p&gt;　　(1)、NETWORK，网络配置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bind：绑定服务器的网卡IP，由于一个服务器可能有多个网卡，配置这个bind属性，可限制访问该网卡IP才能访问到Redis。注意：不是绑定外部访问该服务器的IP，网上很多地方都是错误讲解的。我这边搭建环境一般都是将其注释掉，允许该服务器所有IP都能访问到Redis服务。默认是bind 127.0.0.1。&lt;/li&gt;
&lt;li&gt;protected-mode：Redis服务的保护模式，保护模式下，只能允许127.0.0.1 and ::1这种本地访问，配置默认为开启状态protected-mode yes。这里要注意保护模式的生效条件。根据配置文件中注释：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　# When protected mode is on and if:1) The server is not binding explicitly to a set of addresses using the &quot;bind&quot; directive.2) No password is configured.&lt;/p&gt;
&lt;p&gt;　　　该模式在bind被注释掉和没有配置访问密码的时候才生效。一般可让其为开启状态，同时配置访问密码，来实现Redis的服务安全性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;port：配置Redis服务的端口。很重要哦。默认是6379。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(2)、GENERAL，常规配置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;daemonize：服务是否后台运行，默认是no，我们自己没有改的话，启动redis时候，会占用当前连接。所以，大家记得改成yes，让其在后台运行。&lt;/li&gt;
&lt;li&gt;pidfile：配置Redis服务的PID号存在哪个文件。由于可能在同一服务器上启动多个Redis服务，所以，大家最好指定具体的PID文件，且不同的Redis服务的PID文件不同。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　如配置为：pidfile /var/run/redis_（端口）.pid&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;logfile：指定Redis服务的日志路径，大家记得也修改一下。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(3)、SNAPSHOTTING，快照类型的持久化配置，这里说明下快照的原理：快照是Redis的默认持久化方式，这种方式就是以快照的方式将内存中的数据写到二进制文件中，文件名为dump.rdb。介绍下快照保存的步骤：1、redis调用fork，产生一个子进程。2、父进程继续接受client的请求处理数据，利用copy on write，将执行快照动作时候的内存拷贝做成副本。3、子进程通过副本将数据写入临时文件，并替换之前的dump.rdb文件，然后退出。所以，快照持久化的数据是执行快照动作时的内存数据。Client可以通过调用save或者bgsave命令执行快照，不同点事save命令由redis主进程完成，会阻塞所以client请求，而bgsave是开启子进程执行，不会阻塞其他client请求。需要注意的是，当Redis服务是作为大数据量的内存存储时，调用快照，由于数据量较大，且是快照所有内存数据，这会造成大量磁盘IO动作，可能会严重影响性能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;save 900 1&lt;br/&gt;save 300 10&lt;br/&gt;save 60 10000&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;，配置快照触发的条件。解读第一个sava：900秒内有一个key值变化，则会触发快照。可配置多个条件，条件是独立的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stop-writes-on-bgsave-error：这个配置默认为yes，是指Redis在后台持久化失败后，为了让客户感知到，会拒绝写服务，直到后台持久化恢复正常。如果需要在后台持久化失败后，希望能继续服务。可将其设置为no。&lt;/li&gt;
&lt;li&gt;dbfilename：指定二进制文件名，默认为dump.rdb。&lt;/li&gt;
&lt;li&gt;dir：指定rdb文件路径。配置为文件夹那一层。在一台服务器上启动多个Redis服务时，注意修改为不同文件路径。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(4)、REPLICATION，主从模式的配置。注意，之前版本的redis，配置为slave of，现在改为REPLICATION。主从模式，可以是树状的，从服务属于多台主服务，且从服务也可以有从服务。主从模式，可实现读写分离；高可用模式下，主服务出现问题，也可以通过哨兵切换从服务为主服务；可实现主服务不用数据持久化，从服务进行持久化工作，减轻主服务负担等等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;replicaof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;：配置主服务的ip和端口。配置之后，就是这台机器的小弟了。主服务也能知道谁是他的小弟。&lt;/li&gt;
&lt;li&gt;masterauth &amp;lt;master-password&amp;gt;：如果主服务需要密码认证，这里需要配置从服务连接主服务的密码。&lt;/li&gt;
&lt;li&gt;replica-read-only：默认为yes，配置从服务默认为只读模式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(5)、SECURITY，安全配置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;requirepass：配置连接该Redis服务需要的认证密码。注意一下，由于redis的请求速度特别快，每秒150K，所以密码强度一定要高一些，不然很快就会被破解。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(6)、CLIENTS，客户端配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;maxclients：配置最大客户端连接数，最大支持10000个。超过了连接时，客户端会收到超过最大连接数的提示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(7)、MEMORY MANAGEMENT，内存管理配置。配置Redis服务占用的最大内存，超过内存后，会将设置超时的key按超时时间来剔除，如果没有可剔除的key后，那就报内存已满。配置没细细研究，下来研究一下补充。&lt;/p&gt;
&lt;p&gt;　　(8)、APPEND ONLY MODE，aof模式的另一种持久化方式。这种模式，是为了弥补快照模式的不足。快照模式下，对于大内存数据时，快照严重影响性能，而且，快照是有触发条件的时间间隔，这个间隔时间内，如果Redis服务Down掉，那这个时间段的数据就消失了。如果应用的数据一致性要求比较高，那就可以使用AOF模式。AOF模式是在收到写命令后，通过write将命令追加到appendonly.aof文件中。Redis重启后，通过读取该文件中的命令来重新恢复内存数据（注意，如果同时存在aof和rdb文件，Redis服务启动时，优先读取aof文件）。注意：持久化文件会越来越大，而且会有很多重复的命令，这也会导致不必要的内存影响，所以，Redis提供了bgrewriteaof命令来重建aof文件，过程如下：1、主进程调用fork，产生子进程。2、Redis子进程通过当前数据的快照，往aof临时文件中写入数据命令。3、redis主进程继续接收命令，并存在缓存中。4、子进程写完快照命令后，通知主进程，主进程将缓存中的命令也写入临时aof文件中。5、写完后，主进程用临时的aof文件替换之前的aof文件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;appendonly：默认为no，关闭aof模式，需要开启则设置为yes。&lt;/li&gt;
&lt;li&gt;appendfilename ：&quot;appendonly.aof&quot;，指定aof文件名。&lt;/li&gt;
&lt;li&gt;appendfsync ：always，每次写操作时触发aof。&lt;br/&gt;appendfsync ：everysec，每秒写一次aof，默认设置，3个配置选一个就行。&lt;br/&gt;appendfsync ：no，依赖os系统，当系统想刷新aof时，就执行aof。（任性，性能高，不稳定，和快照感觉差不多）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(9)、REDIS CLUSTER，redis集群配置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cluster-enabled：默认是注释掉，不启用集群模式的。取消注释即可开启集群模式。&lt;/li&gt;
&lt;li&gt;cluster-config-file：指定cluster的配置文件，每个cluster的节点都需要这个配置文件，会在简历集群的时候自动填充内容，所以，需要指定为不同的文件。&lt;/li&gt;
&lt;li&gt;cluster-node-timeout：超过这个时间，某个节点不能被连通，则视该节点为failover状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(10)、其余配置项大家自己研究一下。&lt;/p&gt;
&lt;p&gt;四、Redis集群及哨兵简单介绍&lt;/p&gt;
&lt;p&gt;　　集群：集群是一个提供在多Redis节点间共享数据的程序集。Redis集群会把数据分配到不同的片区，引入了16384个哈希槽，哈希槽会分布在集群中的主节点，key通过CRC16校验后，对16384取模，来决定数据落在哪个槽内，有利于添加或删除节点，只需进行哈希槽的重新分配。集群通过主从模式，具有高可用性，某个主节点fail后，集群会选取主节点下一个从节点作为新的主节点，并给它分配之前主节点的槽位，如果切换完成后，旧的主节点上线，它此时也只能作为新的主节点的从节点。注意，Redis5.0之前，部署集群需要安装ruby等，但在Redis5.0中，不需要安装Ruby，直接使用redis-cli就可以创建集群！&lt;/p&gt;
&lt;p&gt;　　哨兵：主从模式下，为了使主从具备高可用性，就需要通过哨兵进行监控，在主节点下线后，会通过投票出新的主节点，在主节点上线后，也只能作为新主节点的从节点。哨兵在生产环境下，也需要具备高可用，所以哨兵一般也要配置为集群。&lt;/p&gt;
&lt;p&gt;五、搭建主从模式的Redis服务，并启动多个哨兵进行监控&lt;/p&gt;
&lt;p&gt;　　1、下载redis。下载地址：http://www.redis.cn/download.html。&lt;/p&gt;
&lt;p&gt;　　2、解压，编译Redis。&lt;/p&gt;
&lt;p&gt;　　(1)、新建一个文件夹放Redis服务相关的东西。&lt;/p&gt;
&lt;p&gt;　　(2)、在该文件夹下解压、编译Redis。&lt;/p&gt;
&lt;p&gt;　　　　tar -zxvf redis-5.0.0.tar.gz&lt;/p&gt;
&lt;p&gt;　　　　make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;p&gt;　　(3)、在解压后的Redis文件夹中，找到redis.conf文件，该文件是启动redis服务所需文件，拿出来，我们这里建三个redis服务，一主两从，将文件拷贝三份，分别命名为redis-7000.conf，redis-7001.conf，redis-7002.conf，分别编辑以下内容，注意如果配置的文件夹不存在，则需要新建好。其余配置保持默认。我举一个例子说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;#bind 127.0.0.1，将bind注释掉。&lt;/li&gt;
&lt;li&gt;port 7000：改变其服务端口，三份文件端口分别为7000,7001,7002，注意检查端口是否被其他程序占用。&lt;/li&gt;
&lt;li&gt;daemonize yes：修改服务为后台运行。&lt;/li&gt;
&lt;li&gt;pidfile /var/run/redis_7000.pid：指定不同的pid文件，注意三份配置文件不同。&lt;/li&gt;
&lt;li&gt;logfile &quot;/var/redis/7000.log&quot;：指定log日志路径，自己配，要求不同。&lt;/li&gt;
&lt;li&gt;dir /opt/redis-cluster/redis-7000：这个指定rdb文件的路径配置，要求改成不同。&lt;/li&gt;
&lt;li&gt;# replicaof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;：主服务这句话注释，从服务配置的两台需要开启。配置主服务的ip的port。&lt;/li&gt;
&lt;li&gt;masterauth ibethfy：都配上吧，从服务到主服务的认证密码。&lt;/li&gt;
&lt;li&gt;requirepass ibethfy：三份文件都配置，客户端访问需要密码验证。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(4)、配置好三份文件后，使用redis-server redis-7000.conf，redis-server redis-7001.conf，redis-server redis-7002.conf启动服务，注意我是在配置文件路径执行的命令。&lt;/p&gt;
&lt;p&gt;　　　　使用ps -ef|grep redis查看是否三个服务都正常启动，使用redis-cli -h ip地址 -p 端口 -a 密码，通过客户端登陆，执行info replication，可以查看到主从信息。&lt;/p&gt;
&lt;p&gt;　　(5)、搭建哨兵。新起一台linux吧。同样执行1,2步骤，安装redis。拷贝sentinel.conf三份，分别为sentinel-26380.conf，sentinel-26381.conf，sentinel-26382.conf。&lt;/p&gt;
&lt;p&gt;　　(6)、修改sentinel&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;protected-mode no：关闭保护模式，使外网能访问。&lt;/li&gt;
&lt;li&gt;port 26380：修改端口。三份文件分别不同。&lt;/li&gt;
&lt;li&gt;daemonize yes：修改为后台运行。&lt;/li&gt;
&lt;li&gt;pidfile /opt/redis-cluster/redis-sentinel-26380/sentinel.pid：指定不同pid文件，注意文件夹不存在自己要新建。&lt;/li&gt;
&lt;li&gt;logfile &quot;/opt/redis-cluster/redis-sentinel-26380/26380.log&quot;：配置哨兵日志文件。&lt;/li&gt;
&lt;li&gt;dir /opt/redis-cluster/redis-sentinel-26380：配置哨兵工作路径。&lt;/li&gt;
&lt;li&gt;sentinel monitor master7000 192.167.3.145 7000 2：配置哨兵需要监控的主节点ip和端口，最后的2代表，如果有2个哨兵主观认为主节点down了，那么就客观认为主节点down掉了，开始发起投票选举新主节点的操作。多个主节点配置多个。&lt;/li&gt;
&lt;li&gt;sentinel auth-pass master7000 ibethfy：配置哨兵连接主节点的认证密码。（主节点配置的requirepass）。&lt;/li&gt;
&lt;li&gt;sentinel down-after-milliseconds master7000 5000：配置多少毫秒后没收到主节点的反馈，则主观认为主节点down了。&lt;/li&gt;
&lt;li&gt;sentinel failover-timeout master7000 30000：failover过期时间。当failover开始后，在此时间内仍然没有触发任何failover操作，当前sentinel将会认为此次failoer失败。  &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         注意，配置前把之前的默认的mymaster开启的配置全部注销掉！或者直接在其上修改！不然会出现问题！&lt;/p&gt;
&lt;p&gt;　　(7)、在配置文件目录下执行redis-sentinel sentinel-26380.conf，redis-sentinel sentinel-26381.conf，redis-sentinel sentinel-26382.conf，分别启动三个哨兵。&lt;/p&gt;
&lt;p&gt;　　(8)、测试，kill掉7000端口的redis服务，一段时间后，登陆到其他端口的客户端，查看info replication，此时是否从节点的某一个已切换成主节点，另一个从节点属于新主节点的从节点。并测试主节点再次上线后，是否是新主节点的从节点。&lt;/p&gt;
&lt;p&gt;　　(9)、哨兵的细节问题，可参考：http://www.redis.cn/topics/sentinel.html。&lt;/p&gt;
&lt;p&gt;六、集群搭建&lt;/p&gt;
&lt;p&gt;　　(1)、同样解压安装、编译Redis，拷贝redis.conf文件，分别为7000-7008，共九个文件。准备搭建1主2从的3套Redis。&lt;/p&gt;
&lt;p&gt;　　(2)、配置文件修改，同主从搭建的第三步，只是不需要配置服务的状态了，将replicaof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;这个注释掉。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cluster-enabled yes：开启集群模式。&lt;/li&gt;
&lt;li&gt;cluster-config-file nodes-7000.conf：指定不同的集群节点配置文件，集群会自己修改内容。&lt;/li&gt;
&lt;li&gt;cluster-node-timeout 15000：配置多少毫秒后，主节点失联将会触发节点切换。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(3)、使用redis-server redis-7000.conf等将所有节点启动。&lt;/p&gt;
&lt;p&gt;　　(4)、使用redis-cli配置集群。命令和启动成功的提示如下。过程中会让你看下节点分配是否可以，输入yes确定。通过日志可以看到，主节点为7000,7001,7002，每个主节点各两个从节点，replicates后面跟的是主节点的nodeid。Slots 0-5460表明各主节点分配到的槽位。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@rhel64 redis-cluster]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis-cli --cluster create 192.167.3.145:7000 192.167.3.145:7001 192.167.3.145:7002 192.167.3.145:7003 192.167.3.145:7004 192.167.3.145:7005 192.167.3.145:7006 192.167.3.145:7007 192.167.3.145:7008 --cluster-replicas 2 -a ibethfy&lt;/span&gt;
Warning: Using a password with &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; option on the command line interface may &lt;span&gt;not&lt;/span&gt;&lt;span&gt; be safe.
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; Performing hash slots allocation on 9&lt;span&gt; nodes...
Master[0] &lt;/span&gt;-&amp;gt; Slots 0 - 5460&lt;span&gt;
Master[&lt;/span&gt;1] -&amp;gt; Slots 5461 - 10922&lt;span&gt;
Master[&lt;/span&gt;2] -&amp;gt; Slots 10923 - 16383&lt;span&gt;
Adding replica &lt;/span&gt;192.167.3.145:7003 to 192.167.3.145:7000&lt;span&gt;
Adding replica &lt;/span&gt;192.167.3.145:7004 to 192.167.3.145:7000&lt;span&gt;
Adding replica &lt;/span&gt;192.167.3.145:7005 to 192.167.3.145:7001&lt;span&gt;
Adding replica &lt;/span&gt;192.167.3.145:7006 to 192.167.3.145:7001&lt;span&gt;
Adding replica &lt;/span&gt;192.167.3.145:7007 to 192.167.3.145:7002&lt;span&gt;
Adding replica &lt;/span&gt;192.167.3.145:7008 to 192.167.3.145:7002
&amp;gt;&amp;gt;&amp;gt; Trying to optimize slaves allocation &lt;span&gt;for&lt;/span&gt; anti-&lt;span&gt;affinity
[WARNING] Some slaves are &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; the same host as their master
M: 35d56aab1045bded29a8b273dca0d8a9258b4182 &lt;/span&gt;192.167.3.145:7000&lt;span&gt;
   slots:[0&lt;/span&gt;-5460] (5461&lt;span&gt; slots) master
M: 238c6ca906531cd0feeebaaa6ff2afb84b9cc072 &lt;/span&gt;192.167.3.145:7001&lt;span&gt;
   slots:[&lt;/span&gt;5461-10922] (5462&lt;span&gt; slots) master
M: 144577204f66c0857920dd3ce91ad3248a16e426 &lt;/span&gt;192.167.3.145:7002&lt;span&gt;
   slots:[&lt;/span&gt;10923-16383] (5461&lt;span&gt; slots) master
S: a98785183466cc59ae39599779196d986402c94a &lt;/span&gt;192.167.3.145:7003&lt;span&gt;
   replicates 35d56aab1045bded29a8b273dca0d8a9258b4182
S: d80ffdfeef5a536e5e9aaa69aa175b42ca5b1f32 &lt;/span&gt;192.167.3.145:7004&lt;span&gt;
   replicates 238c6ca906531cd0feeebaaa6ff2afb84b9cc072
S: 43bf3f2f15cd963f2cb7cbc8427e3c5d70d8b9dc &lt;/span&gt;192.167.3.145:7005&lt;span&gt;
   replicates 35d56aab1045bded29a8b273dca0d8a9258b4182
S: 0723dfeeb31015178791eba46f895076ca66bc05 &lt;/span&gt;192.167.3.145:7006&lt;span&gt;
   replicates 144577204f66c0857920dd3ce91ad3248a16e426
S: 603d61677a6044e57e415afb325d7a81501a78c8 &lt;/span&gt;192.167.3.145:7007&lt;span&gt;
   replicates 238c6ca906531cd0feeebaaa6ff2afb84b9cc072
S: 110918384563a4173bb17d36b6dd6958a3e97b3c &lt;/span&gt;192.167.3.145:7008&lt;span&gt;
   replicates 144577204f66c0857920dd3ce91ad3248a16e426
Can I set the above configuration? (type &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; to accept): yes
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; Nodes configuration updated
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; Assign a different config epoch to each node
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; Sending CLUSTER MEET messages to join the cluster
Waiting &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; the cluster to join
..........
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 192.167.3.145:7000&lt;span&gt;)
M: 35d56aab1045bded29a8b273dca0d8a9258b4182 &lt;/span&gt;192.167.3.145:7000&lt;span&gt;
   slots:[0&lt;/span&gt;-5460] (5461&lt;span&gt; slots) master
   &lt;/span&gt;2&lt;span&gt; additional replica(s)
S: 603d61677a6044e57e415afb325d7a81501a78c8 &lt;/span&gt;192.167.3.145:7007&lt;span&gt;
   slots: (0 slots) slave
   replicates 238c6ca906531cd0feeebaaa6ff2afb84b9cc072
S: 0723dfeeb31015178791eba46f895076ca66bc05 &lt;/span&gt;192.167.3.145:7006&lt;span&gt;
   slots: (0 slots) slave
   replicates 144577204f66c0857920dd3ce91ad3248a16e426
M: 238c6ca906531cd0feeebaaa6ff2afb84b9cc072 &lt;/span&gt;192.167.3.145:7001&lt;span&gt;
   slots:[&lt;/span&gt;5461-10922] (5462&lt;span&gt; slots) master
   &lt;/span&gt;2&lt;span&gt; additional replica(s)
M: 144577204f66c0857920dd3ce91ad3248a16e426 &lt;/span&gt;192.167.3.145:7002&lt;span&gt;
   slots:[&lt;/span&gt;10923-16383] (5461&lt;span&gt; slots) master
   &lt;/span&gt;2&lt;span&gt; additional replica(s)
S: d80ffdfeef5a536e5e9aaa69aa175b42ca5b1f32 &lt;/span&gt;192.167.3.145:7004&lt;span&gt;
   slots: (0 slots) slave
   replicates 238c6ca906531cd0feeebaaa6ff2afb84b9cc072
S: 110918384563a4173bb17d36b6dd6958a3e97b3c &lt;/span&gt;192.167.3.145:7008&lt;span&gt;
   slots: (0 slots) slave
   replicates 144577204f66c0857920dd3ce91ad3248a16e426
S: 43bf3f2f15cd963f2cb7cbc8427e3c5d70d8b9dc &lt;/span&gt;192.167.3.145:7005&lt;span&gt;
   slots: (0 slots) slave
   replicates 35d56aab1045bded29a8b273dca0d8a9258b4182
S: a98785183466cc59ae39599779196d986402c94a &lt;/span&gt;192.167.3.145:7003&lt;span&gt;
   slots: (0 slots) slave
   replicates 35d56aab1045bded29a8b273dca0d8a9258b4182
[OK] All nodes agree about slots configuration.
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; Check &lt;span&gt;for&lt;/span&gt;&lt;span&gt; open slots...
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; Check slots coverage...
[OK] All &lt;/span&gt;16384 slots covered.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　(5)、测试节点下线，这里就不说明了。结论是主节点故障后，下挂从节点会有一个升级成主节点，并接替主节点的槽位。另一个从节点切换成作为新主节点的从节点。旧主节点上线后，也只能作为其从节点。&lt;/p&gt;
&lt;p&gt;　　(6)、高级特性我这里不说明了，太多了，给大家一个网址：http://www.redis.cn/topics/cluster-tutorial.html。&lt;/p&gt;







</description>
<pubDate>Fri, 16 Nov 2018 07:17:00 +0000</pubDate>
<dc:creator>ibethfy</dc:creator>
<og:description>这两天突然想起redis，索性就再尝试一下搭建最新版本的redis，过程有点艰辛呀，记录一下，供自己和大家今后搭建做参考。 一、为什么用Redis？ 我自己总结了一下： 1、基于内存实现的key-va</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ibethfy/p/9965902.html</dc:identifier>
</item>
<item>
<title>从零打造在线网盘系统之Struts2框架核心功能全解析 - jimisun</title>
<link>http://www.cnblogs.com/jimisun/p/9969406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimisun/p/9969406.html</guid>
<description>&lt;blockquote readability=&quot;11.842105263158&quot;&gt;
&lt;p&gt;欢迎浏览&lt;a href=&quot;https://www.cnblogs.com/jimisun/p/9936579.html&quot;&gt;Java工程师SSH教程从零打造在线网盘系统系列教程&lt;/a&gt;,本系列教程将会使用SSH(Struts2+Spring+Hibernate)打造一个在线网盘系统,本系列教程是从零开始,所以会详细以及着重地阐述SSH三个框架的基础知识,第四部分将会进入项目实战,如果您已经对SSH框架有所掌握,那么可以直接浏览第四章,源码均提供在&lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk&quot;&gt;&lt;strong&gt;GitHub/ssh-network-hard-disk&lt;/strong&gt;&lt;/a&gt;上供大家参阅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我相信你在使用任何一个MVC框架的时候都会接触到以下功能,你必须要会使用这些功能才能够在Struts2中熟练的解决大多数问题&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;本篇目标&quot;&gt;本篇目标&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;接收参数&lt;/li&gt;
&lt;li&gt;参数校验&lt;/li&gt;
&lt;li&gt;数据转换&lt;/li&gt;
&lt;li&gt;响应数据&lt;/li&gt;
&lt;li&gt;上传下载&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;li&gt;国际化支持&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;接收参数-示例源码下载&quot;&gt;接收参数 &lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk/tree/master/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AStruts2/3.Struts2%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/&quot;&gt;示例源码下载&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Struts2接收参数有三种方式,&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Servlet API&lt;/li&gt;
&lt;li&gt;getter和Setter方法&lt;/li&gt;
&lt;li&gt;模型驱动&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Servlet API&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Action(value = &quot;register&quot;)
    public void register() {
        ActionContext context = ActionContext.getContext();
        HttpServletRequest httpServletRequest = (HttpServletRequest) context.get(StrutsStatics.HTTP_REQUEST);
        String username = httpServletRequest.getParameter(&quot;username&quot;);
        String password = httpServletRequest.getParameter(&quot;password&quot;);
        System.out.println(&quot;username:&quot; + username + &quot;    password:&quot; + password);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getter和Setter方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private String username;
    
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Action(value = &quot;register&quot;)
    public void register() {
        System.out.println(&quot;username:&quot; + username + &quot;    password:&quot; + password);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然你也可以使用JavaBean进行接收参数,类似下面这样,前端传递的name属性需要有些变动,name属性需要改成xxxx.xxx与属性名一致&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;form action=&quot;register.action&quot; method=&quot;get&quot;&amp;gt;
    &amp;lt;input name=&quot;user.username&quot; type=&quot;text&quot;&amp;gt;
    &amp;lt;input name=&quot;user.password&quot; type=&quot;text&quot;&amp;gt;
    &amp;lt;input type=&quot;submit&quot;&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    private User user;

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    @Action(value = &quot;register&quot;)
    public void register() {
        System.out.println(&quot;username:&quot; + user.getUsername() + &quot;    password:&quot; + user.getPassword());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模型驱动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@ParentPackage(&quot;default&quot;)
public class RegisterAction implements ModelDriven&amp;lt;User&amp;gt; {


    private User user = new User();

    @Override
    public User getModel() {
        return user;
    }
    
    @Action(value = &quot;register&quot;)
    public void register() {
        System.out.println(&quot;username:&quot; + user.getUsername() + &quot;    password:&quot; + user.getPassword());
    }


}
![1](7623C3566DA045869126C1B9D546A934)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参数校验-示例源码下载&quot;&gt;参数校验 &lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk/tree/master/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AStruts2/3.Struts2%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/&quot;&gt;示例源码下载&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;对于前端传递的参数来讲,存在太多不稳定性,所以对于参数的校验是必不可少的,对于校验来说大体上分为两种,一种是前端校验,一种是后端校验,前端校验的方法在这里就不再累述,这里仅仅讲述Struts2如何使用Validation校验框架&lt;/p&gt;
&lt;p&gt;获取参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  private String username;
  private String password;
  getter and setter......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Action同级目录增加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE validators PUBLIC
        &quot;-//Apache Struts//XWork Validator 1.0.2//EN&quot;
        &quot;http://struts.apache.org/dtds/xwork-validator-1.0.2.dtd&quot;&amp;gt;

&amp;lt;validators&amp;gt;
    &amp;lt;!-- 要对哪个属性进行验证 --&amp;gt;
    &amp;lt;field name=&quot;username&quot;&amp;gt;
        &amp;lt;!-- 验证规则 --&amp;gt;
        &amp;lt;field-validator type=&quot;requiredstring&quot;&amp;gt;
            &amp;lt;!-- 违反规则的提示 --&amp;gt;
            &amp;lt;message&amp;gt;用户名不能为null!&amp;lt;/message&amp;gt;
        &amp;lt;/field-validator&amp;gt;
    &amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;password&quot;&amp;gt;
        &amp;lt;field-validator type=&quot;requiredstring&quot;&amp;gt;
            &amp;lt;message&amp;gt;密码不能为null&amp;lt;/message&amp;gt;
        &amp;lt;/field-validator&amp;gt;
    &amp;lt;/field&amp;gt;

&amp;lt;/validators&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心Action(这里可以看到如果校验正确跳转 &quot;/success.jsp&quot;,如果校验失败错误信息输出在&quot;/form.jsp&quot;)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Override
    @Action(value = &quot;register&quot;, results = {
            @Result(name = SUCCESS, location = &quot;/success.jsp&quot;),
            @Result(name = INPUT,location = &quot;/form.jsp&quot;)
    })
    public String execute() throws Exception {
        System.out.println(&quot;username&quot;+username+&quot;password:&quot;+password);
        return SUCCESS;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载本小节源码访问http://localhost:8080/form.jsp&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116150721713-8262449.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据转换-示例源码下载&quot;&gt;数据转换 &lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk/tree/master/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AStruts2/3.Struts2%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/&quot;&gt;示例源码下载&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WEB系统都是基于网页形式的,接收到的信息都是字符串,Java又是强类型的语言,所以必须需要一个转换的过程.而Struts2的类型转换是基于OGNL表达式的,只需要将表单中的name属性根据OGNL规则命名就能转换成相应的Java类型,通常情况下哦我们无需建立自己的类型转换器,Struts2的内建转换器完全能帮助我们完成任务&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116150746653-878940523.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如我们有下面一个需求(包含Integer,Date,数组的转换)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116150805654-563101801.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们该怎么办呢?不不不~~~~我们什么都不用做正常编写Action就行了,Struts2会自动帮我们进行转换&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RegisterAction extends ActionSupport implements ModelDriven&amp;lt;User&amp;gt; {

    private User user = new User();

    @Override
    public User getModel() {
        return user;
    }
    @Override
    @Action(value = &quot;register&quot;, results = {
            @Result(name = SUCCESS, location = &quot;/success.jsp&quot;)
    })
    public String execute() throws Exception {
        System.out.println(user.toString());
        return SUCCESS;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116150826313-694140136.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好吧,真的没什么挑战力,下面我们要自己实现转换器了&lt;/p&gt;
&lt;p&gt;例如:我们需要将字符串&quot;自行车,1033,100&quot;转换为Java的Product对象&lt;/p&gt;
&lt;p&gt;自定义转换器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StringToProductTypeConverter extends DefaultTypeConverter {
    
    @Override
    public Object convertValue(Map context, Object value, Class toType) {
        if (toType == Product.class) {
            String[] params = (String[]) value;
            Product product = new Product();
            String[] productValues = params[0].split(&quot;,&quot;);
            product.setProductName(productValues[0].trim());
            product.setPrice(Float.parseFloat(productValues[1].trim()));
            product.setCount(Integer.parseInt(productValues[2].trim()));
            return product;
        } else if (toType == String.class) {
            Product product = (Product) value;
            return product.toString();
        }
        return null;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置全局转换器(在WEB-INF\classes目录新建xwork-conversion.properties)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;com.jimisun.action.Product=com.jimisun.action.StringToProductTypeConverter&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Action中接收(不要使用模型驱动方式接收参数,接收不到)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ProductAction extends ActionSupport {

    private Product product;

    public Product getProduct() {
        return product;
    }

    public void setProduct(Product product) {
        this.product = product;
    }

    @Override
    @Action(value = &quot;register&quot;, results = {
            @Result(name = SUCCESS, location = &quot;/success.jsp&quot;)
    })
    public String execute() throws Exception {
        System.out.println(product.toString());
        return SUCCESS;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116150844817-173424212.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;响应数据-示例源码下载&quot;&gt;响应数据 &lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk/tree/master/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AStruts2/3.Struts2%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/&quot;&gt;示例源码下载&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我们一直都没有探讨一个问题,那就是Struts2的结果的响应.对于任何一个程序而言,最重要的莫过于输入和输出,当我们了解了Struts2接收参数后,现在我们一起来看一看Struts2如何响应参数吧&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Servlet API存取值&lt;/li&gt;
&lt;li&gt;属性值存取值&lt;/li&gt;
&lt;li&gt;值栈Set方法存取值&lt;/li&gt;
&lt;li&gt;值栈Push方法存取值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Servlet API存取值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    ActionContext context = ActionContext.getContext();
    HttpServletRequest request  = (HttpServletRequest) context.get(StrutsStatics.HTTP_REQUEST);
    request.setAttribute(&quot;requestValue&quot;,&quot;requestValue&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%--从Servlet API的Request域对象中取值--%&amp;gt;
Request取值:&amp;lt;s:property value=&quot;#request.requestValue&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性值存取值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private User user = new User(&quot;jimisun&quot;, &quot;jimisun&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%--获取属性值--%&amp;gt;
简单属性取值:&amp;lt;s:property value=&quot;user.username&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么对于复杂的属性存取值我们可以这样,例如List&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private List&amp;lt;User&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
  User user1 = new User(&quot;list1&quot;,&quot;list1&quot;);
  User user2 = new User(&quot;list2&quot;,&quot;list2&quot;);
  list.add(user1);
  list.add(user2);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%--获取属性List值--%&amp;gt;
list属性取值:
&amp;lt;br&amp;gt;
&amp;lt;s:iterator value=&quot;list&quot; var=&quot;user&quot;&amp;gt;

    &amp;lt;s:property value=&quot;#user.username&quot;/&amp;gt;
    &amp;lt;s:property value=&quot;#user.password&quot;/&amp;gt;
    &amp;lt;br/&amp;gt;
&amp;lt;/s:iterator&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值栈Set方法存取值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; ActionContext context = ActionContext.getContext();
 ValueStack valueStack = context.getValueStack();
 valueStack.set(&quot;valueStackDemo&quot;, &quot;valueStackDemoSet&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%--值栈Set方法取值--%&amp;gt;
值栈set取值:&amp;lt;s:property value=&quot;valueStackDemo&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值栈Push方法存取值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; ActionContext context = ActionContext.getContext();
 ValueStack valueStack = context.getValueStack();
 valueStack.push(&quot;valueStackPush&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%--值栈Push方法取值--%&amp;gt;
值栈push取值:&amp;lt;s:property value=&quot;[0].top&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK,现在对于Struts2的几种数据的响应方式我们大概已经知道了,现在我们来看一看这几种存储数据方式在值栈中的结构,在本小节源码中运行项目直接访问http://localhost:8080/outputdate.action即可&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116150909268-1380076257.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意点:使用OGNL表达式访问&quot;根&quot;对象中的对象及属性时,不需要前面加&quot;#&quot;号&lt;/p&gt;
&lt;h3 id=&quot;文件上传-示例源码下载&quot;&gt;文件上传 &lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk/tree/master/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AStruts2/3.Struts2%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/&quot;&gt;示例源码下载&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;对于文件上传功能Struts2并没有提出自己的解决方案,但是Struts2为文件上传提供了统一的接口,开发人员在使用上传文件的组件时,并不需要知道太多的细节就可以轻松使用他们,Struts2目前支持三种上传文件组件&lt;strong&gt;Commons-FileUpload,cos,pell&lt;/strong&gt;,例如我们使用Commons-FileUpload为例来快速学习文件上传功能&lt;/p&gt;
&lt;p&gt;commons-fileupload依赖(已经内置,无须再次添加)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116150924268-1765666938.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;struts.properties相关配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struts.multipart.parser=jakarta
struts.multipart.maxSize=2097152&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心上传代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Action(value = &quot;UploadAction&quot;, params = {&quot;uploadPath&quot;, &quot;D:/&quot;}, results = {
            @Result(name = &quot;success&quot;, location = &quot;/result.jsp&quot;)
    })
    public String execute() throws Exception {
        String fn = &quot;&quot;;
        if (filename.equals(&quot;&quot;)) {
            fn = uploadPath + uploadFileName;
        } else {
            fn = uploadPath + filename;
        }

        if (new File(fn).exists()) {
            result = &quot;该文件已经存在!&quot;;
        } else {
            FileOutputStream fileOutputStream = new FileOutputStream(fn);
            InputStream inputStream = new FileInputStream(upload);
            byte[] buffer = new byte[8192];
            int count = 0;
            while ((count = inputStream.read(buffer)) &amp;gt; 0) {
                fileOutputStream.write(buffer, 0, count);
            }
            fileOutputStream.close();
            inputStream.close();
            result = &quot;文件上传成功!&quot;;
        }
        return &quot;success&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116150939128-417361208.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们再进行展示同时上传多个文件的示例,对于同时上传多个文件,我们仅仅需要做一点改变即可,即接收值的属性改成数组或者List集合&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private File[] upload;
    private String[] uploadFileName;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    @Action(value = &quot;UploadAction&quot;, params = {&quot;uploadPath&quot;, &quot;D:/&quot;}, results = {
            @Result(name = &quot;success&quot;, location = &quot;/result.jsp&quot;)
    })
    public String execute() throws Exception {
        for (int i = 0; i &amp;lt; uploadFileName.length; i++) {
            String fn = uploadPath + uploadFileName[i];
            FileOutputStream fileOutputStream = new FileOutputStream(fn);
            InputStream inputStream = new FileInputStream(upload[i]);
            byte[] buffer = new byte[8192];
            int count = 0;
            while ((count = inputStream.read(buffer)) &amp;gt; 0) {
                fileOutputStream.write(buffer, 0, count);
            }
            fileOutputStream.close();
            inputStream.close();
        }
        result = &quot;文件上传成功!&quot;;
        return &quot;success&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116150959939-783004150.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们了解了文件上传那么现在我们再来一起看一下文件的下载,再Struts2中提供了一种使用Stream下载文件的方式,类似于文件和浏览器的一个&quot;代理&quot;,通过这个&quot;代理&quot;我们就能控制某某下载文件,如下是一个Download的Action&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public InputStream getFileInputStream() {
        // 以及文件的mime类型以及创建流
        ServletContext context = ServletActionContext.getServletContext();
        contentType = context.getMimeType(context.getRealPath(filePath + &quot;/&quot; + fileName));
        setContentType(contentType);
        return context.getResourceAsStream(filePath + &quot;/&quot; + fileName);
    }

    @Override
    @Action(value = &quot;download&quot;, params = {&quot;filePath&quot;, &quot;/file&quot;}, results = {
            @Result(name = SUCCESS, type = &quot;stream&quot;,
                    params = {&quot;contentType&quot;, &quot;${contentType}&quot;, &quot;inputName&quot;, &quot;fileInputStream&quot;, &quot;contentDisposition&quot;, &quot;attachment;filename=\&quot;${fileName}\&quot;&quot;})
    })
    public String execute() throws Exception {
        return SUCCESS;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116151014233-422755953.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;异常处理-示例源码下载&quot;&gt;异常处理 &lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk/tree/master/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AStruts2/3.Struts2%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/&quot;&gt;示例源码下载&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;异常处理是任何成熟的MVC框架必备的功能,在Struts2中提供了异常的拦截器,我们可以在struts.xml文件中进行配置异常,以灵活的方式处理异常&lt;/p&gt;
&lt;p&gt;配置全局异常&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;package name=&quot;default&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&amp;gt;
        &amp;lt;global-results&amp;gt;
            &amp;lt;result name=&quot;exception&quot;&amp;gt;/error.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/global-results&amp;gt;
        
        &amp;lt;global-exception-mappings&amp;gt;
            &amp;lt;exception-mapping exception=&quot;java.sql.SQLException&quot; result=&quot;exception&quot;&amp;gt;&amp;lt;/exception-mapping&amp;gt;
        &amp;lt;/global-exception-mappings&amp;gt;
        
        ...
    &amp;lt;/package&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模拟异常&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@ParentPackage(&quot;default&quot;)
public class ExceptionAction extends ActionSupport {


    @Override
    @Action(value = &quot;testerror&quot;, results = {
            @Result(name = SUCCESS, location = &quot;/success.jsp&quot;)
    })
    public String execute() throws Exception {
        if (&quot;a&quot;.equals(&quot;a&quot;)) {
            throw new SQLException(&quot;SQL错误!!!&quot;);
        }
        return SUCCESS;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当发生异常后就会跳转到所配置的error.jsp页面&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116151032115-611928204.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;国际化支持-示例源码下载&quot;&gt;国际化支持 &lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk/tree/master/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AStruts2/3.Struts2%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/&quot;&gt;示例源码下载&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Struts2的国际化支持是建立在Java对国际化的支持之上的,对Java的国际化支持进行了封装,下面我们来针对一段优美的诗,我们我们将会展示中文和英文两种页面给访问者&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我那美丽的女孩&lt;br/&gt;我的挚爱&lt;br/&gt;无论梦里梦外&lt;br/&gt;去去来来&lt;/p&gt;
&lt;p&gt;抬头眺望云端&lt;br/&gt;高不可攀&lt;br/&gt;低头忆你容颜&lt;br/&gt;温柔绚烂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配置Struts2全局资源文件(使用下面两种方式都可以)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在struts.properties中配置
struts.custom.i18n.resources=Resource&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;在struts.xml中配置
&amp;lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;Resource&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建两个资源文件(中文和英文)&lt;/p&gt;
&lt;p&gt;Resource_en_US.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;welcome = hello,{0}
content = My beautiful girl, my love, my dream, my dream, my dream, my dream, my dream&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Resource_zh_CN.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;welcome = 你好,{0}
content = 我那美丽的女孩 我的挚爱 无论梦里梦外 去去来来 抬头眺望云端 高不可攀 低头忆你容颜 温柔绚烂&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Action中使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BeautifulGirlAction extends ActionSupport {

    private String username;
    private String content;
    private String welcome;

    @Override
    @Action(value = &quot;girl&quot;, results = {
            @Result(name = SUCCESS, location = &quot;/success.jsp&quot;)
    })
    public String execute() throws Exception {
        welcome = getText(&quot;welcome&quot;, new String[]{username});
        content = getText(&quot;content&quot;);
        return SUCCESS;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过下载本小节示例源码访问http://localhost:8080/form.jsp&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201811/1218060-20181116151056645-414595509.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;本章总结&quot;&gt;本章总结&lt;/h3&gt;
&lt;p&gt;在WEB应用中常见的功能是很多的,很多场景下Struts2都为我们提供了响应的解决方案,本章叙述中在下主要讲述了Struts2的常见的功能的基本使用,即只有广度而没有深度,更为深度的学习还希望小伙伴们查阅相关资料,例如OGNL表达式等...&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 07:12:00 +0000</pubDate>
<dc:creator>jimisun</dc:creator>
<og:description>欢迎浏览Java工程师SSH教程从零打造在线网盘系统系列教程,本系列教程将会使用SSH(Struts2+Spring+Hibernate)打造一个在线网盘系统,本系列教程是从零开始,所以会详细以及着重</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimisun/p/9969406.html</dc:identifier>
</item>
<item>
<title>Android实例（一）—— 3D画廊 - Q_King</title>
<link>http://www.cnblogs.com/QY-admin/p/9969193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QY-admin/p/9969193.html</guid>
<description>&lt;p&gt;&lt;span&gt;3D画廊&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;之前我都是写的学习的内容，我在写这些教程时遇到有趣的炫酷的小例子也会专门拿出来写一篇文章，今天就写一个酷炫的小例子，叫3D画廊，它是属于ViewPage的进阶版。&lt;/p&gt;
&lt;p&gt;此项目下载地点：&lt;a href=&quot;https://github.com/qySvip/3D-gallery&quot; target=&quot;_blank&quot;&gt;https://github.com/qySvip/3D-gallery&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面的指示器是使用的一大神的第三方库，会在文章下方简单讲述一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;效果图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1380550/201811/1380550-20181116133400099-2040467717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3D画廊的实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是布局文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;FrameLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    xmlns:app&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    android:clipChildren&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    android:background&lt;/span&gt;&lt;span&gt;=&quot;@android:color/black&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/frame_layout&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;android.support.v4.view.ViewPager
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;450dp&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        android:layout_gravity&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/gallery&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        android:clipChildren&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        android:layout_marginLeft&lt;/span&gt;&lt;span&gt;=&quot;85dp&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        android:layout_marginRight&lt;/span&gt;&lt;span&gt;=&quot;85dp&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.lwj.widget.viewpagerindicator.ViewPagerIndicator
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/indicator_circle_line&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;50dp&quot;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            android:layout_gravity&lt;/span&gt;&lt;span&gt;=&quot;bottom&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#efefef&quot;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            app:vpi_default_color&lt;/span&gt;&lt;span&gt;=&quot;#FF239AF5&quot;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            app:vpi_distance&lt;/span&gt;&lt;span&gt;=&quot;60dp&quot;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            app:vpi_distanceType&lt;/span&gt;&lt;span&gt;=&quot;BY_LAYOUT&quot;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            app:vpi_indicatorType&lt;/span&gt;&lt;span&gt;=&quot;CIRCLE_LINE&quot;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            app:vpi_radius&lt;/span&gt;&lt;span&gt;=&quot;10dp&quot;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            app:vpi_selected_color&lt;/span&gt;&lt;span&gt;=&quot;#FF239AF5&quot;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;FrameLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中的ViewPagerIndicator是用于实现下方的指示器，这个我们在最后在进行解释；&lt;/p&gt;
&lt;p&gt;首先布局使用帧布局，内部用到ViewPager控件，注意在ViewPager控件的父布局中我们要添加android:clipChildren=&quot;false&quot;属性，它的作用是定义它的子控件是否要在它应有的边界内进行绘制，默认值为true。我们这里要用false。&lt;/p&gt;
&lt;p&gt;然后在ViewPager中用到android:layout_marginLeft和android:layout_marginRight属性，值不能太大，过大会导致看不到两边的图像，具体根据自己满意进行调整。高度属性为图片和倒影的加起来的高度，自己进行调整。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GalleryPageTransformer类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; sample.sdk.qy.com.demo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.support.v4.view.ViewPager;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GalleryPageTransformer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ViewPager.PageTransformer {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; MAX_ROTATION=20.0f&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; MIN_SCALE=0.75f&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; MAX_TRANSLATE=20.0f&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; transformPage(View page, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; position) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(position&amp;lt;-1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            page.setTranslationX(MAX_TRANSLATE);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            page.setScaleX(MIN_SCALE);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            page.setScaleY(MIN_SCALE);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             page.setRotationY(-&lt;span&gt;MAX_ROTATION);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(position&amp;lt;=0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             page.setTranslationX(-MAX_TRANSLATE*&lt;span&gt;position);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt; scale=MIN_SCALE+(1-MIN_SCALE)*(1.0f+&lt;span&gt;position);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            page.setScaleX(scale);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            page.setScaleY(scale);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             page.setRotationY(MAX_ROTATION*&lt;span&gt;position);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(position&amp;lt;=1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             page.setTranslationX(-MAX_TRANSLATE*&lt;span&gt;position);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt; scale=MIN_SCALE+(1-MIN_SCALE)*(1.0f-&lt;span&gt;position);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            page.setScaleX(scale);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            page.setScaleY(scale);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             page.setRotationY(MAX_ROTATION*&lt;span&gt;position);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             page.setTranslationX(-&lt;span&gt;MAX_TRANSLATE);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            page.setScaleX(MIN_SCALE);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            page.setScaleY(MIN_SCALE);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            page.setRotationY(MAX_ROTATION);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PageTransformer是ViewPager内部定义的接口，这个接口主要用于控制ViewPager中item view的滑动效果。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;setTranslationX     设置view相对原始位置的水平偏移量&lt;/li&gt;
&lt;li&gt;setScaleX              设置水平缩放的基准点&lt;/li&gt;
&lt;li&gt;setScaleY              设置竖直缩放的基准点&lt;/li&gt;
&lt;li&gt;setRotationY          设置竖直的选择的基准点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; ImageUtils类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; sample.sdk.qy.com.demo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Context;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.Bitmap;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.BitmapFactory;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.Canvas;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.Color;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.LinearGradient;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.Matrix;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.Paint;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.PorterDuff;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.PorterDuffXfermode;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.Shader;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImageUtils {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Bitmap getReverseBitmapById(Context context, &lt;span&gt;int&lt;/span&gt; resId, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; percent) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get the source bitmap&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         Bitmap srcBitmap=&lt;span&gt; BitmapFactory.decodeResource(context.getResources(), resId);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get the tow third segment of the reverse bitmap&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         Matrix matrix=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Matrix();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         matrix.setScale(1, -1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Bitmap rvsBitmap=Bitmap.createBitmap(srcBitmap, 0, (&lt;span&gt;int&lt;/span&gt;) (srcBitmap.getHeight()*(1-&lt;span&gt;percent)),
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 srcBitmap.getWidth(), (&lt;span&gt;int&lt;/span&gt;) (srcBitmap.getHeight()*percent), matrix, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; combine the source bitmap and the reverse bitmap&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         Bitmap comBitmap=&lt;span&gt;Bitmap.createBitmap(srcBitmap.getWidth(),
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 srcBitmap.getHeight()+rvsBitmap.getHeight()+20&lt;span&gt;, srcBitmap.getConfig());
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         Canvas gCanvas=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Canvas(comBitmap);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         gCanvas.drawBitmap(srcBitmap, 0, 0, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         gCanvas.drawBitmap(rvsBitmap, 0, srcBitmap.getHeight()+20, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         Paint paint=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Paint();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         LinearGradient shader=&lt;span&gt;new&lt;/span&gt; LinearGradient(0, srcBitmap.getHeight()+20, 0&lt;span&gt;, comBitmap.getHeight(),
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                Color.BLACK, Color.TRANSPARENT, Shader.TileMode.CLAMP);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        paint.setShader(shader);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         paint.setXfermode(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PorterDuffXfermode(PorterDuff.Mode.DST_IN));
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         gCanvas.drawRect(0, srcBitmap.getHeight()+20&lt;span&gt;, srcBitmap.getWidth(), comBitmap.getHeight(), paint);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; comBitmap;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是做图片倒影的方法，内部使用了Canvas和Bitmap类，这些后面会进行讲述。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; ViewAdapter类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; sample.sdk.qy.com.demo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.support.v4.view.PagerAdapter;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.ViewGroup;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ViewAdapter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; PagerAdapter {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;View&amp;gt;&lt;span&gt; datas;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ViewAdapter(List&amp;lt;View&amp;gt;&lt;span&gt; list) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         datas=&lt;span&gt;list;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; datas.size();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isViewFromObject(View view, Object object) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; view==&lt;span&gt;object;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object instantiateItem(ViewGroup container, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; position) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         View view=&lt;span&gt;datas.get(position);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        container.addView(view);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; view;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; destroyItem(ViewGroup container, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; position, Object object) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        container.removeView(datas.get(position));
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;适配器类，这里的适配方式为图片和倒影一同进行适配。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MainActivity类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; sample.sdk.qy.com.demo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.app.Activity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.support.v4.view.PagerAdapter;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.support.v4.view.ViewPager;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.MotionEvent;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.FrameLayout;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.ImageView;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.lwj.widget.viewpagerindicator.ViewPagerIndicator;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Activity {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;View&amp;gt;&lt;span&gt; pages;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; FrameLayout layout;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ViewPager pager;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ViewPagerIndicator mIndicatorCircleLine;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        setContentView(R.layout.activity_main);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         pages=&lt;span&gt;getPages();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         pager=&lt;span&gt;(ViewPager) findViewById(R.id.gallery);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         PagerAdapter adapter=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ViewAdapter(pages);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        pager.setAdapter(adapter);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         pager.setPageMargin(20&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         pager.setOffscreenPageLimit(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         pager.setPageTransformer(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GalleryPageTransformer());
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         layout=&lt;span&gt;(FrameLayout) findViewById(R.id.frame_layout);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         layout.setOnTouchListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; View.OnTouchListener() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onTouch(View v, MotionEvent event) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pager.dispatchTouchEvent(event);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         mIndicatorCircleLine =&lt;span&gt; (ViewPagerIndicator) findViewById(R.id.indicator_circle_line);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         mIndicatorCircleLine.setViewPager(pager,9&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;View&amp;gt;&lt;span&gt; getPages() {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         List&amp;lt;View&amp;gt; pages=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         Field[] fields=R.drawable.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getDeclaredFields();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Field field : fields) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (field.getName().startsWith(&quot;page&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                     ImageView view = &lt;span&gt;new&lt;/span&gt; ImageView(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                     view.setImageBitmap(ImageUtils.getReverseBitmapById(&lt;span&gt;this&lt;/span&gt;, field.getInt(&lt;span&gt;null&lt;/span&gt;), 0.5f&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                    pages.add(view);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalAccessException e) {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pages;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主界面方法，主要用于填充入图片、适配器适配。这里填充图片的方法为在drawable文件中查找以page开头的图片进行填充。&lt;/p&gt;

&lt;p&gt;到这里3D画廊就完成了。。。。。。。。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;指示器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面来说一下指示器的做法，用的是网上一大神的第三方类。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、在 project的build.gradle 添加:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;allprojects { repositories { ... maven { url &quot;https://jitpack.io&quot; } } }&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在module的build.gradle 添加:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;dependencies { &lt;/code&gt;implementation  &lt;code&gt;'com.github.LinweiJ:ViewPagerIndicator:0.1.0' }&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意这里要用implementation，&lt;/span&gt;&lt;code&gt;compile现在已被废弃，官方显示将在2018年年底删除。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 3、将&lt;code&gt;ViewPagerIndicator控件添加到布局文件。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;app:vpi_selected_color&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;app:vpi_default_color&lt;/code&gt; (如果 indicatorType=CIRCLE_LINE default_color 为指示器唯一颜色 ,selected_color 不起作用)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;app:vpi_radius&lt;/code&gt; (点的大小,在indicatorType= CIRCLE_LINE 的情况下 radius 是点的高)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;app:vpi_length&lt;/code&gt; (只作用在 indicatorType=CIRCLE_LINE 的情况下,为 指示器点的长度)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;app:vpi_distance&lt;/code&gt; (只作用在 distanceType=BY_DISTANCE 的情况下)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;app:vpi_num&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;app:vpi_indicatorType&lt;/code&gt; (LINE; CIRCLE; CIRCLE_LINE; BEZIER;SPRING)LINE：线 ; CIRCLE：圆点(默认) ; CIRCLE_LINE：圆角矩形; BEZIER：弹性球 ; SPRING： 弹簧粘性球&lt;/li&gt;
&lt;li&gt;&lt;code&gt;app:vpi_distanceType&lt;/code&gt; (BY_RADIUS; BY_DISTANCE ; BY_LAYOUT )BY_RADIUS：3倍radius ; BY_DISTANCE ：定义固定距离 ;BY_LAYOUT ：根据layout_width均分得到距离&lt;/li&gt;
&lt;li&gt;&lt;code&gt;app:vpi_animation&lt;/code&gt;(默认为true:动画开启 ; false:关闭动画)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 4、在java文件中初始化该控件&lt;/p&gt;
&lt;p&gt;使用mIndicatorCircleLine.setViewPager(pager,9);，第一个参数为适配器，第二个参数为图片的个数。&lt;/p&gt;

</description>
<pubDate>Fri, 16 Nov 2018 06:35:00 +0000</pubDate>
<dc:creator>Q_King</dc:creator>
<og:description>3D画廊 之前我都是写的学习的内容，我在写这些教程时遇到有趣的炫酷的小例子也会专门拿出来写一篇文章，今天就写一个酷炫的小例子，叫3D画廊，它是属于ViewPage的进阶版。 此项目下载地点：https</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QY-admin/p/9969193.html</dc:identifier>
</item>
<item>
<title>测试面试过程中的几点困惑 - 测试小柚子</title>
<link>http://www.cnblogs.com/nanaheidebk/p/9969101.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nanaheidebk/p/9969101.html</guid>
<description>&lt;div id=&quot;article_title&quot; readability=&quot;33&quot;&gt;
&lt;p id=&quot;atitle&quot; title=&quot;测试面试过程中的几点困惑&quot;&gt;最近在面试中遇到了很多困惑和无奈，笔者总结了几条，与诸君分享。顺便也谈谈笔者对面试的一些浅解。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;article_content&quot; readability=&quot;78&quot;&gt;
&lt;p&gt;&lt;strong&gt;困惑一：简历与实际脱节&lt;/strong&gt;。这个问题现在挺普遍，很多人把简历写的天花乱坠，而实际可能并不具备。前几天笔者面试了一个小伙伴，他在简历里写精通python和数据库，于是笔者就问怎样把一个字符串倒序打印出来，其实的答案很简单，用数列的分片且步长为－1就可以了，或者用一个for循环也可以。结果这个小伙伴告诉我不会，而且告诉我这个很简单，百度一下就可以了。。。当他告诉我可以百度的时候，瞬间我觉得我开始怀疑人生了。&lt;/p&gt;
&lt;p&gt;我不知道是我的思维与时代脱节了还是我对“精通”这个词的理解出现了偏差，首先我认为一个人真诚的态度远比他掌握的技能要重要的多，不熟悉的可以在简历说简单了解过，通过查百度解决入门级的问题绝不叫精通。其次，每个人都不是万能的，我们在面试中考察一个人，并不是期望他能解决所有问题（如果能，当然更好），我们其实考察的是这个人解决问题的思路。当然去查百度解决问题并不在解决问题的思路范畴内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;困惑二：“我觉得”怪圈&lt;/strong&gt;。很多人在面试的沟通中，非常喜欢用“我觉得”来开始回答问题。因为我比较喜欢用非常具体的场景来提问，那么在该场景中按照逻辑上来讲，必然存在着确切的因果关系或特定的解决方法。如果一切都是“我觉得”，那么意味着测试本身就是建立在主观因素上的，这我想大家都是不能同意的。&lt;/p&gt;
&lt;p&gt;举个实际的例子，笔者很喜欢问的一个问题“比如我在商店中购买了一件道具，购买道具用的金币扣除错误，请问这是前端显示错了还是后端计算错了？”这个问题笔者认为至少有好几种方法来确定，我们也希望面试者能尝试给出怎么来判断这个问题的思路（比如，查看网络包，查看数据库，退出重登，查看代码，再次购买等），而不是“通常以我的经验，我觉得这个是后端错了。。”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;困惑三：无逻辑的天马行空&lt;/strong&gt;。这个现象也比较普遍，例如经典的面试题，如何测试一台自动贩卖机？这道题很大程度上考察了面试者的测试用例设计能力，逻辑是不是清晰，覆盖度是不是广泛等基本功。很多基本功不扎实的小伙伴在回答的时候一会说测试硬件，一会说测试软件，夹杂着各种互不关联的步骤。笔者很怀疑这样的用例是否能执行，或者执行起来的效率和难度是否是合适的。&lt;/p&gt;
&lt;p&gt;这道题笔者看来可以用层次法来分析，第一层是大的软件和硬件2部分，第二层是分别针对软件部分和硬件部分进行拆分成大的模块，比如软件部分的购买模块，显示模块，退款模块等等，硬件部分的电源模块，外壳模块，出货口模块等等，第三层再针对第二层的模块进行细分，这样一层一层的去拆分，不仅逻辑清晰，而且不容易出现遗漏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;困惑四：经验与经历&lt;/strong&gt;。几乎所有人的简历里都会写自己有xx年的工作经验，在笔者看来，xx年的工作，有时候可能并不能算作经验，仅仅是经历。对有的人来说，可能xx年都在当一天和尚撞一天钟，仅仅是应付差事，并没有全身心的投入到工作中。&lt;/p&gt;
&lt;p&gt;请各位小伙伴思考一下，我们自己负责的工作，有没有在我们负责的期间有所提升或改善？有没有尝试着哪怕仅仅是思考去让自己的工作更完美一些？有没有尝试去承担更多的责任从而带给团队更大的价值？有没有坚持不断的去提升自己？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.51ste.com/img/share/2018/201804281.jpg&quot; alt=&quot;测试面试过程中的几点困惑&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上的几点大家思考一下，是否在工作期间思考或行动了呢？如果没有，那你的工作仅仅是经历。也许有小伙伴会反驳我说，那些都是领导们应该做的事，我只需完成自己的任务就好了，对不起，在笔者看来，我们每个人都是领导，一件事没人去做或没人愿意去做，你主动承担了，并完成了，那么你就是领导。&lt;/p&gt;
&lt;p&gt;困惑非常多，这里简单的写了几条常见问题，希望能对小伙伴们有所帮助，也欢迎小伙伴们一起探讨。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 16 Nov 2018 06:22:00 +0000</pubDate>
<dc:creator>测试小柚子</dc:creator>
<og:description>最近在面试中遇到了很多困惑和无奈，笔者总结了几条，与诸君分享。顺便也谈谈笔者对面试的一些浅解。 最近在面试中遇到了很多困惑和无奈，笔者总结了几条，与诸君分享。顺便也谈谈笔者对面试的一些浅解。 困惑一：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nanaheidebk/p/9969101.html</dc:identifier>
</item>
<item>
<title>网站集群架构实战（LVS负载均衡、Nginx代理缓存、Nginx动静分离、Rsync+Inotify全网备份、Zabbix自动注册全网监控）--技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9931863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9931863.html</guid>
<description>
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近做了一个不大不小的项目，现就删繁就简单独拿出来web集群这一块写一篇博客。数据库集群请参考《&lt;a id=&quot;post_title_link_9869382&quot; href=&quot;https://www.cnblogs.com/kenken2018/p/9869382.html&quot;&gt;MySQL集群架构篇：MHA+MySQL-PROXY+LVS实现MySQL集群架构高可用/高性能-技术流ken&lt;/a&gt;》下面是项目的一些简单介绍。&lt;/p&gt;

&lt;h2&gt;WEB集群项目简介&lt;/h2&gt;
&lt;p&gt;随着网站访问量的激增，势必会导致网站的负载增加，现需求搭载一套高性能，高负载，高可用的网站集群架构以保障网站的持续、高效、安全、稳定的运行。&lt;/p&gt;
&lt;p&gt;针对以上需求，我们采用了如下的技术：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用负载均衡技术来实现网站请求的调度分发，减小后端服务器的压力。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;配置了&lt;/span&gt;KEEPALIVED解决单点故障问题。&lt;/li&gt;
&lt;li&gt;采用动静分离的技术，客户端请求会根据请求文件类型往不同的后端节点进行转发、调度，均衡每个节点的压力。&lt;/li&gt;
&lt;li&gt;数据库采用读写分离及级联复制的架构，使得数据的写入和读取更加的快捷。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;为了保障数据库的持续运行及安全，我们部署了&lt;/span&gt;MHA实现数据库的高可用，可实现即时报警及故障切换。&lt;/li&gt;
&lt;li&gt;为了保障数据的安全，定时做了数据库的完全备份以及增量备份。&lt;/li&gt;
&lt;li&gt;针对网站数据做了实时差异化备份，保证数据的一致性和完整性。&lt;/li&gt;
&lt;li&gt;分布式监控系统，实时监测各个节点的运行状况；邮件报警通知机制，做到实时报警通知，快速定位问题，解决问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;WEB集群项目环境说明&lt;/h2&gt;
&lt;p&gt;² &lt;span&gt;系统版本：&lt;/span&gt;CentOS Linux release 7.5.1804 (Core)&lt;/p&gt;
&lt;p&gt;² &lt;span&gt;内核版本：&lt;/span&gt;3.10.0-862.el7.x86_64&lt;/p&gt;
&lt;p&gt;² SELinux关闭状态&lt;/p&gt;
&lt;p&gt;² Firewalld关闭状态&lt;/p&gt;

&lt;h2&gt;WEB集群项目图片示例&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181108201522198-1069985440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;WEB集群项目架构说明&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;第一部分：WEB集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.当用户请求经过路由器转发进网络中，由Keepalived+Lvs组成的一台服务器首先接收请求，根据配置好的调度规则转发至后端服务器节点。在这里准备了两台服务器，使用Keepalived解决单点故障问题，实现服务的高可用。&lt;/p&gt;
&lt;p&gt;2.由Keepalived+Lvs转发过来的用户请求进入到缓存代理服务器当中。这里使用Nginx做了一个缓存服务器以及代理服务器，如果缓存中有用户请求的缓存数据，就会直接返回给客户端，如果没有用户请求数据的缓存就会根据文件类别进行往后方节点转发。&lt;/p&gt;
&lt;p&gt;3.如果客户请求是静态文件就会被调度到静态服务器。静态服务器由apache构建，静态服务器提供静态文件，并由后方的文件共享服务器提供文件。&lt;/p&gt;
&lt;p&gt;4.如果客户请求是动态文件就会被调度到动态服务器。动态服务器由nginx构建，动态服务器提供动态文件，这里做了一个apache,mysql,php分离的架构。&lt;/p&gt;
&lt;p&gt;5.把需要部署的网站包放在文件共享服务器。文件共享服务器部署NFS。&lt;/p&gt;
&lt;p&gt;6.对文件共享服务器做好备份，防止数据丢失。这里采用rsync+inotify实现数据的完全备份，保证数据的一致性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二部分：监控集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.监控采用zabbix,并使用分布式监控系统，减小主监控节点的压力。&lt;/p&gt;
&lt;p&gt;2.两个mysql-proxy分别监控web集群和mysql集群，实时反应每个节点的状态信息，快速定位故障节点进行修复。&lt;/p&gt;
&lt;p&gt;3.在zabbix服务器端一起配置了DNS以及NTP服务，分别提供内部服务器的网站域名解析服务，以及时间同步服务。&lt;/p&gt;


&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;主机名（角色）&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;IP地址&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;keepalived+lvs主&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10.220.5.131&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;keepalived+lvs备&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10.220.5.132&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;VIP&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10.220.5.133&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;代理缓存1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10.220.5.134&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;代理缓存2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10.220.5.135&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;静态服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10.220.5.137&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;动态服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10.220.5.138&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;文件共享服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10.220.5.139&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;备份服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10.220.5.140&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;zabbix.ntp.dns&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10.220.5.111&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;WEB集群架构脚本&lt;/h2&gt;
&lt;p&gt;上面的架构我已经写成了脚本，可以实现一键安装，脚本可以复用。先就针对每个脚本进行讲解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# ls
arp.sh       fileshare.sh  inotify7.sh  keepalived.conf  qimojiagou.tar.gz  ssh1.sh     zhengti.sh
dongtai5.sh  huancun3.sh   keep2.sh     nginx.conf       rsync6.sh          static4.sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;第一步：秘钥自动批量分发&lt;/h3&gt;
&lt;p&gt;1.实现脚本一键安装第一步要做的就是秘钥的分发。&lt;/p&gt;
&lt;p&gt;2.秘钥自动分发借助于expect来实现，所以脚本中第一步是要安装expect。&lt;/p&gt;
&lt;p&gt;3.删除保存的秘钥信息，可以实现脚本的复用。&lt;/p&gt;
&lt;p&gt;4.使用ssh-keygen来生成秘钥，借助于expect实现自动化。&lt;/p&gt;
&lt;p&gt;5.使用一个for循环的语句，把你需要联系的节点的IP地址写进去，这样就可以实现免秘钥登录了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# vim ssh1.sh
#&lt;/span&gt;!/bin/&lt;span&gt;bash
. &lt;/span&gt;/etc/init.d/&lt;span&gt;functions
#下载expect
yum install expect &lt;/span&gt;-y &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ $? -eq &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ];then
        echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;download expect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        success
        echo &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;download expect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        failure
        echo &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        exit &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
fi
#删除保存的秘钥信息
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ -f id_rsa -o -f id_rsa.pub -&lt;span&gt;o known_hosts ];then
        rm &lt;/span&gt;-rf /root/.ssh/id*&lt;span&gt;
        rm &lt;/span&gt;-rf /root/.ssh/known*&lt;span&gt;
fi
#自动生成秘钥对
&lt;/span&gt;/usr/bin/expect&amp;lt;&amp;lt;&lt;span&gt;eof
spawn ssh&lt;/span&gt;-&lt;span&gt;keygen 
expect {
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(/root/.ssh/id_rsa)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {send \r;exp_continue}
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passphrase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {send \r;exp_continue}
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;again&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {send \r}
}
expect eof
exit
eof
#在各个节点分发秘钥
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;31&lt;/span&gt; &lt;span&gt;32&lt;/span&gt; &lt;span&gt;34&lt;/span&gt; &lt;span&gt;35&lt;/span&gt; &lt;span&gt;37&lt;/span&gt; &lt;span&gt;38&lt;/span&gt; &lt;span&gt;39&lt;/span&gt; &lt;span&gt;40&lt;/span&gt;
&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
ken&lt;/span&gt;=&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.1&lt;/span&gt;&lt;span&gt;$i
&lt;/span&gt;/usr/bin/expect&amp;lt;&amp;lt;&lt;span&gt;eof
spawn ssh&lt;/span&gt;-copy-&lt;span&gt;id $ken
expect {
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes/no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {send yes\r;exp_continue}
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {send o\r}
}
expect eof
exit
eof
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;第二步：配置keepalived+lvs&lt;/h3&gt;
&lt;p&gt;1.在两个keepalived节点之上下载需要的软件&lt;/p&gt;
&lt;p&gt;2.使用ssh结合命令在备节点执行下载操作&lt;/p&gt;
&lt;p&gt;3.把/root/下的keepalived文件传到备节点之上&lt;/p&gt;
&lt;p&gt;4.使用sed修改keepalived配置文件&lt;/p&gt;
&lt;p&gt;5.做后端节点的arp抑制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# vim keep2.sh
#&lt;/span&gt;!/bin/&lt;span&gt;bash
. &lt;/span&gt;/etc/init.d/&lt;span&gt;functions
bash &lt;/span&gt;/root/&lt;span&gt;ssh1.sh
yum install nginx keepalived ipvsadm libnl&lt;/span&gt;* popt* -y &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ $? -ne &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ];then
        echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;download error at master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        failure
        echo &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        exit &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
fi
#keepalved备节点也下载软件
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.132&lt;/span&gt; yum install keepalived ipvsadm libnl* popt* -y &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ $? -ne &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ];then
        echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;download error at slave&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        failure
        echo &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        exit &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
fi

#把准备好的从节点keepalived文件传送到备节点并启动
scp &lt;/span&gt;-q /root/keepalived.conf &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.132&lt;/span&gt;:/etc/keepalived &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ssh  &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.132&lt;/span&gt; systemctl restart keepalived  &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;

#准备主keepalived文件并启动
cp &lt;/span&gt;-f /root/keepalived.conf /etc/keepalived/&lt;span&gt;
sed &lt;/span&gt;-i &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/router_id id2/router_id id1/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; /etc/keepalived/keepalived.conf &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
sed &lt;/span&gt;-i &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/state SLAVE/state MASTER/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    /etc/keepalived/keepalived.conf &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
sed &lt;/span&gt;-i &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/priority 100/priority 150/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   /etc/keepalived/keepalived.conf &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
systemctl restart keepalived  &lt;/span&gt;&amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
#缓存1arp抑制
scp &lt;/span&gt;-q /root/arp.sh &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.134&lt;/span&gt;:/&lt;span&gt;root
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.134&lt;/span&gt; bash /root/&lt;span&gt;arp.sh

#缓存2arp抑制
scp &lt;/span&gt;-q /root/arp.sh &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.135&lt;/span&gt;:/&lt;span&gt;root
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.135&lt;/span&gt; bash /root/&lt;span&gt;arp.sh

systemctl restart nginx
ipvsadm &lt;/span&gt;-L -n
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;第三步：配置代理缓存节点&lt;/h3&gt;
&lt;p&gt;1.在后端节点10.220.5.134,10.220.5.135安装nginx作为缓存代理服务器&lt;/p&gt;
&lt;p&gt;2.把准备好的nginx配置文件发送到后端节点并进行重启生效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
. &lt;/span&gt;/etc/init.d/&lt;span&gt;functions

#配置134代理缓存
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.134&lt;/span&gt; yum install nginx -y &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ $? -ne &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ];then
        echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;download nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        failure
        echo &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        exit &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
fi
mkdir &lt;/span&gt;/k  &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
mkdir &lt;/span&gt;/kenken  &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
scp &lt;/span&gt;-q /root/nginx.conf &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.134&lt;/span&gt;:/etc/nginx &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.134&lt;/span&gt; systemctl restart nginx &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
#配置135代理缓存
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.135&lt;/span&gt; yum install nginx -y &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ $? -ne &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ];then
        echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;download nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        failure
        echo &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        exit &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
fi
scp &lt;/span&gt;-q /root/nginx.conf &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.135&lt;/span&gt;:/etc/nginx   &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.135&lt;/span&gt; systemctl restart nginx &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;第四步：配置静态服务器&lt;/h3&gt;
&lt;p&gt;1.安装httpd以及nfs组件&lt;/p&gt;
&lt;p&gt;2.挂载共享服务器节点至本机的网站根目录&lt;/p&gt;
&lt;p&gt;3.重启nginx使配置生效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim static4.sh &lt;br/&gt;#!/bin/&lt;span&gt;bash
. &lt;/span&gt;/etc/init.d/&lt;span&gt;functions
yum install httpd nfs&lt;/span&gt;-utils -y &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
#mkdir &lt;/span&gt;-p /&lt;span&gt;var&lt;/span&gt;/www/html/&lt;span&gt;static&lt;/span&gt; &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
mount &lt;/span&gt;-t nfs &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.139&lt;/span&gt;:/ken /&lt;span&gt;var&lt;/span&gt;/www/html &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
systemctl restart httpd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;第五步：配置动态服务器&lt;/h3&gt;
&lt;p&gt;1.安装配置lnmp环境&lt;/p&gt;
&lt;p&gt;2.挂载共享服务器节点至本机的网站根目录之下&lt;/p&gt;
&lt;p&gt;3.重启apache使配置生效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# vim dongtai5.sh
#&lt;/span&gt;!/bin/&lt;span&gt;bash
yum install httpd php php&lt;/span&gt;-mysql  nfs-utils -y &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
#mkdir &lt;/span&gt;-p /&lt;span&gt;var&lt;/span&gt;/www/html/dongtai &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
mount &lt;/span&gt;-t nfs &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.139&lt;/span&gt;:/ken /&lt;span&gt;var&lt;/span&gt;/www/html/ &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
systemctl restart httpd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;第六步：配置rsync服务器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim rsync6.sh&lt;br/&gt;#!/bin/&lt;span&gt;bash
. &lt;/span&gt;/etc/init.d/&lt;span&gt;functions
ruser&lt;/span&gt;=&lt;span&gt;user1
vuser&lt;/span&gt;=&lt;span&gt;kenken
file&lt;/span&gt;=/&lt;span&gt;ken
hosts&lt;/span&gt;=&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.139&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;&lt;span&gt;
yum install rsync &lt;/span&gt;-y &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
useradd &lt;/span&gt;-r -u &lt;span&gt;333&lt;/span&gt; -s /sbin/nologin $ruser &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ ! -&lt;span&gt;e $file ];then
        mkdir $file &lt;/span&gt;&amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
fi
chown &lt;/span&gt;-&lt;span&gt;R $ruser $file
cat&lt;/span&gt;&amp;gt;/etc/rsyncd.conf&amp;lt;&amp;lt;&lt;span&gt;eof
pid file&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/&lt;span&gt;lock&lt;/span&gt;/subsys/&lt;span&gt;pidfile
&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt; file=/&lt;span&gt;var&lt;/span&gt;/&lt;span&gt;lock&lt;/span&gt;/subsys/&lt;span&gt;rsync
log file&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/log/&lt;span&gt;rsync
uid&lt;/span&gt;=&lt;span&gt;333&lt;/span&gt;&lt;span&gt;
gid&lt;/span&gt;=&lt;span&gt;333&lt;/span&gt;&lt;span&gt;
timeout&lt;/span&gt;=&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
max connections&lt;/span&gt;=&lt;span&gt;199&lt;/span&gt;&lt;span&gt;
[ken]
path&lt;/span&gt;=/&lt;span&gt;ken
list&lt;/span&gt;=&lt;span&gt;yes
use chroot&lt;/span&gt;=&lt;span&gt;yes
read only&lt;/span&gt;=&lt;span&gt;no
auth users&lt;/span&gt;=&lt;span&gt;kenken
secrets file&lt;/span&gt;=/etc/&lt;span&gt;rsyncd.pwd
hosts allow&lt;/span&gt;=&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.139&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;&lt;span&gt;
eof
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$vuser:123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; /etc/&lt;span&gt;rsyncd.pwd
chmod &lt;/span&gt;&lt;span&gt;600&lt;/span&gt; /etc/&lt;span&gt;rsyncd.pwd
rsync &lt;/span&gt;--daemon &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ $? -eq &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ];then
        echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start rsync...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        success
        echo &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        echo &lt;/span&gt;-n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start rsync...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        failure
        echo &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;第七步：配置inotify&lt;/h3&gt;
&lt;p&gt;1.在本机安装inotify和rsync&lt;/p&gt;
&lt;p&gt;2.监控/ken下的文件，如果发生更改就会被推送至rsync服务器端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# vim inotify7.sh
#&lt;/span&gt;!/bin/&lt;span&gt;bash
. &lt;/span&gt;/etc/init.d/&lt;span&gt;functions
file&lt;/span&gt;=/&lt;span&gt;ken
vuser&lt;/span&gt;=&lt;span&gt;kenken
host&lt;/span&gt;=&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.140&lt;/span&gt;&lt;span&gt;
mname&lt;/span&gt;=&lt;span&gt;ken
yum install inotify&lt;/span&gt;-tools -y &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;/etc/&lt;span&gt;rsync.pwd
chmod &lt;/span&gt;&lt;span&gt;600&lt;/span&gt; /etc/&lt;span&gt;rsync.pwd
inotifywait &lt;/span&gt;-mrq --format &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%w%f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -e create,delete,modify $file | &lt;span&gt;while&lt;/span&gt;&lt;span&gt; read line
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
rsync &lt;/span&gt;-rz --delete $file $vuser@$host::$mname --password-file=/etc/&lt;span&gt;rsync.pwd
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;第八步：配置nfs服务器端&lt;/h3&gt;
&lt;p&gt;1.把本机的/ken目录共享给10.220.5.137，10.220.5.138服务器端文件可以解压在本目录下即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim fileshare.sh&lt;br/&gt;#!/bin/&lt;span&gt;bash
. &lt;/span&gt;/etc/init.d/&lt;span&gt;functions
yum install nfs&lt;/span&gt;-utils rpcbind -y &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
mkdir &lt;/span&gt;-p /ken/&lt;span&gt;static&lt;/span&gt; &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
mkdir &lt;/span&gt;-p /ken/dongtai &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
chown &lt;/span&gt;-R nfsnobody.nfsnobody /&lt;span&gt;ken
cat&lt;/span&gt;&amp;gt;/etc/exports&amp;lt;&amp;lt;&lt;span&gt;eof
&lt;/span&gt;/ken &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.137&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;(rw,&lt;span&gt;async&lt;/span&gt;&lt;span&gt;,all_squash)
&lt;/span&gt;/ken &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.138&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;(rw,&lt;span&gt;async&lt;/span&gt;&lt;span&gt;,all_squash)
eof
systemctl restart rpcbind
systemctl restart nfs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;至此所有的脚本已经介绍完毕，下面来看一下nginx的配置文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# For more information on configuration, see:
#   &lt;/span&gt;* Official English Documentation: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/en/docs/&lt;/span&gt;
#   * Official Russian Documentation: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/ru/docs/&lt;/span&gt;
&lt;span&gt;
user nginx;
worker_processes auto;
error_log &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/nginx/&lt;span&gt;error.log;
pid &lt;/span&gt;/run/&lt;span&gt;nginx.pid;

# Load &lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt; modules. See /usr/share/nginx/README.&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt;.
include &lt;/span&gt;/usr/share/nginx/modules&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
default_type        application/octet-stream;

    # Load modular configuration files from the /etc/nginx/conf.d directory.
    # See &lt;/span&gt;&lt;span&gt;http://nginx.org/en/docs/ngx_core_module.html&lt;/span&gt;&lt;span&gt;#include
    # for more information.
        proxy_cache_path /k  levels=1:2 keys_zone=scache:30m;   #定义静态文件的缓存
        fastcgi_cache_path /kenken levels=1:2 keys_zone=kenken:30m;  #定义动态文件的缓存
    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /var/www/html;
        index  index.html;

        # Load configuration files for the default server block.
       # include /etc/nginx/default.d/*.conf;

        location / {
        proxy_pass &lt;/span&gt;&lt;span&gt;http://10.220.5.137&lt;/span&gt;&lt;span&gt;;    #静态文件会被代理到10.220.5.137
        proxy_set_header host $host;
        proxy_set_header realip $remote_addr;

        proxy_cache scache;                 #使scache缓存
        proxy_cache_valid any 10m;         #定义缓存的类型及时间
        }
        location ~ \.php$ {                       
        proxy_pass &lt;/span&gt;&lt;span&gt;http://10.220.5.138&lt;/span&gt;&lt;span&gt;;         #动态的文件会被缓存到10.220.5.138
        proxy_set_header host $host;
        proxy_set_header realip $remote_addr;
        fastcgi_cache kenken;                      #使用动态缓存
        fastcgi_cache_valid any 10m;  
        fastcgi_cache_key http://$host$request_uri;             #定义动态缓存的key
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后来看一下整体的脚本，即执行的脚本&lt;/p&gt;
&lt;p&gt;1.把写好的脚本及准备好的配置文件都存放在10.220.5.131的/root下&lt;/p&gt;
&lt;p&gt;2.使用scp及ssh进行远程传送脚本及运行脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim zhengti.sh&lt;br/&gt;#!/bin/&lt;span&gt;bash
. &lt;/span&gt;/etc/init.d/&lt;span&gt;functions

#执行秘钥分发
bash &lt;/span&gt;/root/&lt;span&gt;ssh1.sh

#实现keepalived&lt;/span&gt;+&lt;span&gt;LVS
bash &lt;/span&gt;/root/&lt;span&gt;keep2.sh

#实现缓存代理
bash &lt;/span&gt;/root/&lt;span&gt;huancun3.sh

#实现文件共享
scp &lt;/span&gt;-q /root/fileshare.sh &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.139&lt;/span&gt;:/&lt;span&gt;root
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.139&lt;/span&gt; bash /root/&lt;span&gt;fileshare.sh

#实现静态服务器
scp &lt;/span&gt;-q /root/static4.sh &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.137&lt;/span&gt;:/&lt;span&gt;root
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.137&lt;/span&gt; bash /root/&lt;span&gt;static4.sh

#实现动态服务器
scp &lt;/span&gt;-q /root/dongtai5.sh &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.138&lt;/span&gt;:/&lt;span&gt;root
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.138&lt;/span&gt; bash /root/&lt;span&gt;dongtai5.sh


#实现备份服务器rsync
scp &lt;/span&gt;-q /root/rsync6.sh &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.140&lt;/span&gt;:/&lt;span&gt;root
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.140&lt;/span&gt; bash /root/&lt;span&gt;rsync6.sh

#实现共享文件服务器inotify
scp &lt;/span&gt;-q /root/inotify7.sh &lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.139&lt;/span&gt;:/&lt;span&gt;root
ssh &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.139&lt;/span&gt; bash /root/inotify7.sh  &amp;amp;&lt;span&gt;

iptables &lt;/span&gt;-F
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;运行脚本并测试&lt;/h2&gt;

&lt;p&gt;只要运行总的脚本即可，会自动调用其他脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# bash zhengti.sh
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第一步：在10.220.5.137主机创建静态测试文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@ken html]# cat index.html 
test &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; 137ddd
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步:在10.220.5.138主机创建动态测试文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@ken html]# cat index.php 
&lt;/span&gt;&amp;lt;?&lt;span&gt;php
phpinfo();
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：输入10.220.5.133/index.html，即虚拟IP 访问10.220.5.137主机的动态文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181115084334341-716283169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四步：输入10.220.5.133/index.php，即虚拟IP 访问10.220.5.138主机的动态文件&lt;/p&gt;
&lt;p&gt;看到这些信息即表示成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181115084430401-125066345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;zabbix自动注册全网监控&lt;/h2&gt;
&lt;p&gt;实现全网监控首先需要给每个待监控的主机安装zabbix的客户端，可以使用如下脚本进行安装\&lt;/p&gt;

&lt;p&gt;第一步：执行如下脚本&lt;/p&gt;
&lt;p&gt;给每个待监控的客户端安装zabbix-agen客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
#author:技术流ken
#date:&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;11&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt;&lt;span&gt;
#desc:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; script &lt;span&gt;for&lt;/span&gt; downloading zabbix-agent &lt;span&gt;for&lt;/span&gt;&lt;span&gt; clients
ip&lt;/span&gt;=&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.1&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;31&lt;/span&gt; &lt;span&gt;32&lt;/span&gt; &lt;span&gt;34&lt;/span&gt; &lt;span&gt;35&lt;/span&gt; &lt;span&gt;37&lt;/span&gt; &lt;span&gt;38&lt;/span&gt; &lt;span&gt;39&lt;/span&gt; &lt;span&gt;40&lt;/span&gt;
&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
ssh $ip$i yum install zabbix&lt;/span&gt;-agent -y  &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ssh $ip$i sed &lt;/span&gt;-i &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/Server=127.0.0.1/Server=10.220.5.137/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; /etc/zabbix/zabbix_agentd.conf &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ssh $ip$i systemctl restart zabbix&lt;/span&gt;-agent &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：在zabbix服务器端开启自动注册&lt;/p&gt;
&lt;p&gt;点击configuration&amp;gt;actions&amp;gt;选择右上角的auto redistration&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181115082352004-909157604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击creation action&lt;/p&gt;
&lt;p&gt;选择如下动作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181115082618209-789631978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击add保存&lt;/p&gt;

&lt;p&gt;第三步：查看&lt;/p&gt;
&lt;p&gt;点击configure&amp;gt;hosts即可查看自动注册到的主机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181115162202379-1841879149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 16 Nov 2018 06:05:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>前言 最近做了一个不大不小的项目，现就删繁就简单独拿出来web集群这一块写一篇博客。数据库集群请参考《MySQL集群架构篇：MHA+MySQL-PROXY+LVS实现MySQL集群架构高可用/高性能-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9931863.html</dc:identifier>
</item>
<item>
<title>Python--基于朴素贝叶斯算法的情感分析 - Star_Zhao</title>
<link>http://www.cnblogs.com/star-zhao/p/9940437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/star-zhao/p/9940437.html</guid>
<description>&lt;p&gt;&lt;span&gt;win8, python3.7, jupyter notebook&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;什么是情感分析?(以下引用百度百科定义)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;情感分析（Sentiment analysis），又称倾向性分析，意见抽取（Opinion extraction），意见挖掘（Opinion mining），情感挖掘（Sentiment mining），主观分析（Subjectivity analysis），它是对带有情感色彩的主观性文本进行分析、处理、归纳和推理的过程，如从评论文本中分析用户对“数码相机”的“变焦、价格、大小、重量、闪光、易用性”等属性的情感倾向。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;简单来说, 就是从文本中总结归纳出个人对某一话题的主观态度(褒义或贬义的两种或者更多种类型). 对于情感分析的方法中, 目前基于监督学习(已知分类标签)是主流, 我们选择监督学习算法中的朴素贝叶斯进行分析介绍.&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;1. 朴素贝叶斯&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;朴素贝叶斯中的朴素是指特征条件独立假设, 贝叶斯是指贝叶斯定理, 我们从贝叶斯定理开始说起吧.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.1 贝叶斯定理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86&quot; target=&quot;_blank&quot;&gt;贝叶斯定理&lt;/a&gt;是用来描述两个条件概率之间的关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1). 什么是条件概率? &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果有两个事件A和B, 条件概率就是指在事件B发生的条件下, 事件A发生的概率, 记作P(A|B).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若P(A)&amp;gt;0, 则满足以下公式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181111011150329-1539914443.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若P(B) &amp;gt; 0, 同理.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过条件概率公式我们可以直接推出概率的乘法公式.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2). 概率的乘法公式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181111010825438-94941554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进而通过概率的乘法公式, 可以推出贝叶斯公式.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3). 贝叶斯公式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181111010958177-699524680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;贝叶斯公式同样满足条件P(A)&amp;gt;0, P(B)&amp;gt;0, 在该公式中, A和B均代表单个事件, 但是当B代表一个事件组时, 公式又是如何呢?在介绍之前, 引出全概公式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4). 全概公式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当事件组B&lt;sub&gt;1&lt;/sub&gt;, B&lt;sub&gt;2&lt;/sub&gt;, B&lt;sub&gt;3&lt;/sub&gt;, ....B&lt;sub&gt;n&lt;/sub&gt;是完备事件组(两两互不相容, 其和为全集), 并且当P(B&lt;sub&gt;n&lt;/sub&gt;) &amp;gt;0时, 对于任意一个事件A, 满足全概公式:&lt;sub&gt;&lt;br/&gt;&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181111033343366-1600126834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;推导过程如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181111033742102-2091406698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么, 此时的完备事件组B&lt;sub&gt;1&lt;/sub&gt;, B&lt;sub&gt;2&lt;/sub&gt;, B&lt;sub&gt;3&lt;/sub&gt;, ...B&lt;sub&gt;n&lt;/sub&gt;对于任意事件A的贝叶斯公式可写成:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181111035315591-1096506747.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上式中P(B&lt;sub&gt;i&lt;/sub&gt;)被称为先验概率, P(B&lt;sub&gt;i&lt;/sub&gt;|A&lt;/span&gt;&lt;span&gt;)被称为后验概率. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5). 先验概率, 后验概率分别指什么呢? (举例说明)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;某地区10月份下大暴雨的概率为0.9. 下大暴雨时, 发洪水的概率是0.6; 不下大暴雨时, 发洪水的概率为0.02, 试求该地区已发洪水, 下暴雨的概率?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记A&lt;sub&gt;1&lt;/sub&gt;=下大暴雨, B&lt;sub&gt;1&lt;/sub&gt;=发洪水, A&lt;sub&gt;2&lt;/sub&gt;=不下大暴雨, B&lt;sub&gt;2&lt;/sub&gt;=不发洪水, 由题意知, P(A&lt;sub&gt;1&lt;/sub&gt;) = 0.9, P(B&lt;sub&gt;1&lt;/sub&gt;|A&lt;sub&gt;1&lt;/sub&gt;) = 0.6, P(B&lt;sub&gt;1&lt;/sub&gt;|A&lt;sub&gt;2&lt;/sub&gt;) = 0.02, 根据贝叶斯公式得: P(A&lt;sub&gt;1&lt;/sub&gt;|B&lt;sub&gt;1&lt;/sub&gt;)=0.9*0.6/[0.9*0.6 + (1-0.9)*0.02] = 0.996.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上述例子中, 先验概率(下大暴雨的概率)很容易从现有条件中得出, 而后验概率(已经发洪水时下大暴雨的概率)需要根据附加信息用贝叶斯公式去计算得出, 下面引出百度百科对于这两者的定义.&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13.439065108514&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87&quot; target=&quot;_blank&quot;&gt;先验概率&lt;/a&gt;（prior probability）是指根据以往经验和分析得到的概率，如全概率公式，它往往作为&quot;由因求果&quot;问题中的&quot;因&quot;出现的概率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87&quot; target=&quot;_blank&quot;&gt;后验概率&lt;/a&gt;是指在得到“结果”的信息后重新修正的概率，是“执果寻因”问题中的&quot;果&quot;。先验概率与后验概率有不可分割的联系，后验概率的计算要以先验概率为基础.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事情还没有发生，要求这件事情发生的可能性的大小，是先验概率。事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，是后验概率。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;将定义与例题相结合就能更好的理解先验概率和后验概率.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6). 如果A也是事件组时, 公式又是如何呢?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设现有两个事件A&lt;sub&gt;1&lt;/sub&gt;和A&lt;sub&gt;2&lt;/sub&gt;, 公式则可改写为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181111154717808-1588012155.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要想求满足条件A&lt;sub&gt;1&lt;/sub&gt;和A&lt;sub&gt;2&lt;/sub&gt;时Bi的概率, 关键在于求P(A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;|B&lt;sub&gt;i&lt;/sub&gt;)的概率, 在这之前需要了解事件的独立性:&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;通常情况下, 条件概率P(A|B)与无条件概率P(A)是不相等的, 如果P(A|B)=P(A), 则说明事件B对事件A的发生没有任何影响, 也就是说事件A与B是相互独立的, 又根据我们上面的概率乘法公式可以推出P(AB)=P(A|B)P(B)=P(A)P(B).&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;现假设事件A&lt;sub&gt;1&lt;/sub&gt;和事件A&lt;sub&gt;2&lt;/sub&gt;关于事件B独立, 根据事件的独立性, 则有P[(A&lt;sub&gt;1&lt;/sub&gt;|B)(A&lt;sub&gt;2&lt;/sub&gt;|B)]=P(A&lt;sub&gt;1&lt;/sub&gt;|B)P(A&lt;sub&gt;2&lt;/sub&gt;|B), 又由于只有在事件B这个共同条件下事件A&lt;sub&gt;1&lt;/sub&gt;才会与事件A&lt;sub&gt;2&lt;/sub&gt;独立, 我们不妨将式子改写为P(A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;|B) = P(A&lt;sub&gt;1&lt;/sub&gt;|B)P(A&lt;sub&gt;2&lt;/sub&gt;|B), 从而可以将我们的贝叶斯公式改写为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181111191833645-467609815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设事件组A&lt;sub&gt;m&lt;/sub&gt;中的所有事件关于完备事件组B&lt;sub&gt;n&lt;/sub&gt;中任意一个事件两两相互独立, 进而公式可以推广为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181111193407679-1192993116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要想上式成立, 则必须要满足前提条件: 事件组Am中的所有事件关于事件组Bn的任意一个事件两两相互独立, 到这里贝叶斯定理部分就介绍完毕了,&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.2 特征条件独立假设&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;将上面的公式应用到分类问题中, A&lt;sub&gt;m&lt;/sub&gt;表示m个特征, B&lt;sub&gt;n&lt;/sub&gt;表示n个分类标签, 而要想上式成立, 要满足前提条件: m个特征关于n个分类标签中任意一个两两相互独立, 也就是特征条件独立, 而&quot;朴素&quot;二字表示特征条件独立假设, 即假设特征条件独立(前提条件), 想必这也就是为什么&quot;朴素&quot;二字恰好在贝叶斯之前.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.3 朴素贝叶斯模型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;朴素贝叶斯分类模型要做的事就是在先验概率的基础上将数据集归为n个标签中后验概率最大的标签(基于最小错误率贝叶斯决策原则).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于数据集的特征个数m和分类标签总数n是固定不变的, 即贝叶斯定理中分母不变, 所以要求最大值, 只需求出分子中的最大值, 即下式中的最大值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181111203747763-1403326197.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;又可利用argmax()函数, 表示为最大值的类别, 比如X&lt;sub&gt;1&lt;/sub&gt; = argmax(f(x))表示当f(x)中的自变量x=X&lt;sub&gt;1&lt;/sub&gt;时, f(x)取最大值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181116124323412-915729192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即求自变量B&lt;sub&gt;i&lt;/sub&gt;的值, 当B&lt;sub&gt;n&lt;/sub&gt; = B&lt;sub&gt;i&lt;/sub&gt;时, 后验概率最大, 上式也称为朴素贝叶斯推导式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上式, 影响最终结果的有先验概率和条件概率, 另外满足特征条件独立假设时, 上式才会成立. &lt;/span&gt;&lt;span&gt;即当先验概率, 条件概率和特征条件独立假设均成立时, 根据朴素贝叶斯推导式得出的结果具有真正最小错误率..&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) 先验概率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当先验概率已知时, 可以直接通过公式计算.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当先验概率未知时, 基于最小最大损失准则(让其在最糟糕的情况下, 带来的损失最小)或者N-P(聂曼-皮尔逊)决策准则来进行分类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于这部分的具体细节可参看 &lt;a href=&quot;https://wenku.baidu.com/view/85e559104431b90d6d85c704.html&quot; target=&quot;_blank&quot;&gt;https://wenku.baidu.com/view/85e559104431b90d6d85c704.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2) 条件概率(举例说明)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现需对某产品评价中&quot;质量好, 价格便宜, 颜值高&quot;这三个词语作出统计, 假设它们之间两两相互独立. 已知某论坛上关于该产品的1000条评价中未购买用户概率为0.2, 未购买用户的评价中&quot;质量好&quot;出现0次, &quot;价格便宜&quot;出现100次, &quot;颜值高&quot;出现150次; 已购买用户的评价中&quot;质量好&quot;出现600次, &quot;价格便宜&quot;出现500次, &quot;颜值高&quot;出现700次, 试问评价中同时出现&quot;质量好, 价格便宜, 颜值高&quot;这三个词语的用户是未购买用户的概率.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先, 特征条件相互独立, 且先验概率已知, 可直接列举出我们的公式:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181112112924954-557246350.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事件B&lt;sub&gt;1&lt;/sub&gt;表示未购买用户, 事件B&lt;sub&gt;2&lt;/sub&gt;表示已购买用户, 事件A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, A&lt;sub&gt;3&lt;/sub&gt;则分别表示&quot;质量好, 价格便宜, 颜值高&quot;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由题知, P(A&lt;sub&gt;1&lt;/sub&gt;|B&lt;sub&gt;1&lt;/sub&gt;)=0, 分子为0, P(B&lt;sub&gt;1&lt;/sub&gt;|A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, A&lt;sub&gt;3&lt;/sub&gt;)也就为0, 如果我们根据计算结果直接就下定义: 做出&quot;质量好, 价格便宜, 颜值高&quot;这个评价的用户不可能是未购买用户, 会有点以偏概全了, 比如现新有一条包含这三个词语的新评价且为未购买用户, 经询问, 该用户在体验朋友(已购买用户)的产品一段时间后, 进而在论坛作此评价. 对于此种情况, 重新计算吗?假设该用户在半个月, 一个月...后才出现, 我们要等半个月, 一个月..再计算的话, 有点不切合实际.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于此种情况, 法国数学家拉普拉斯最早提出用加1的方法估计没有出现过的现象的概率, 所以加法平滑也叫做拉普拉斯平滑. 假定训练样本很大时, 每个分量计数加1造成的估计概率变化可以忽略不计，但可以方便有效的避免零概率问题。(参考自博文: &lt;a href=&quot;https://www.cnblogs.com/bqtang/p/3693827.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/bqtang/p/3693827.html&lt;/a&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应用在我们的示例中就是, P(A&lt;sub&gt;1&lt;/sub&gt;|B&lt;sub&gt;1&lt;/sub&gt;)=1/203, P(A&lt;sub&gt;2&lt;/sub&gt;|B&lt;sub&gt;1&lt;/sub&gt;)=101/203, P(A&lt;sub&gt;3&lt;/sub&gt;|B&lt;sub&gt;1&lt;/sub&gt;)=151/203, 进而求解即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3) 特征条件独立假设&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设特征条件独立, 但是实际中往往不是真正独立甚至有时特征之间存在某种联系(比如年龄和星座), 这时就需通过特征选择, 主成分分析等方法尽可能让特征之间独立.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里, 朴素贝叶斯分类模型就介绍完了, 下面就是应用了, 决定将朴素贝叶斯应用在某电视剧的评论上进行情感分类&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2&gt;2. 爬取评论文本&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;由于我本人想对爬虫再练习练习, 所以先从爬虫开始介绍(哈哈, 有点自私了.., 对这部分内容不感兴趣的朋友可以跳过)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.1 目标站点分析&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;分析的目的是为了找出真正的url, 请求方式等信息&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.2 新建爬虫项目&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1. 在cmd命令行中执行以下命令, 新建youku项目文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
scrapy startproject yok
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 进入yok项目中, 新建spider文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd yok
scrapy genspider pinglun yok.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. 新建main.py文件, 用来执行项目&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.3 定义要爬取的字段&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在items.py文件中编辑如下代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; scrapy.item &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Item, Field
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; YoukuItem(Item):&lt;/span&gt;&lt;span&gt;
    content &lt;/span&gt;=&lt;span&gt; Field()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.4 编辑爬虫主程序&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在pinglun.py文件中编辑&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; yok.items &lt;span&gt;import&lt;/span&gt;&lt;span&gt; YokItem

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PinglunSpider(scrapy.Spider):
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pinglun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    allowed_domains &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yok.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    episodes &lt;/span&gt;= [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start_requests(self):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ep &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.episodes:
            url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://p.Id={0}&amp;amp;Page=1&amp;amp;pageSize=30&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(str(ep))
            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; scrapy.Request(url=url, callback=self.parse_pages, meta={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:ep}, dont_filter=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse_pages(self,response):
    　　&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;获取总页数&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        ep, results&lt;/span&gt;= response.meta[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;], response.text
        results &lt;/span&gt;= results.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n_commentList(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
        results &lt;/span&gt;= json.loads(results, strict=&lt;span&gt;False)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; results.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) ==&lt;span&gt; 0:
            pages &lt;/span&gt;= results.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;totalPage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; page &lt;span&gt;in&lt;/span&gt; range(1, int(pages)+1&lt;span&gt;):
                url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://p.Id={0}Page={1}&amp;amp;pageSize=30&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(str(ep), str(page))
                &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; scrapy.Request(url=url, callback=self.parse, dont_filter=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):
    　　&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;解析内容&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        results &lt;/span&gt;=&lt;span&gt; response.text
        results&lt;/span&gt;= results.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n_commentList(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;strict表示对json语法要求不严格&lt;/span&gt;
        results = json.loads(results, strict =&lt;span&gt; False)
        item &lt;/span&gt;=&lt;span&gt; YoukuItem()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; results.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; results.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;comment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
                comments &lt;/span&gt;= results.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;comment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; comment &lt;span&gt;in&lt;/span&gt;&lt;span&gt; comments:&lt;/span&gt;&lt;span&gt;
                    item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =comment.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).strip().replace(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.5 保存到Mysql数据库&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在pipelines.py中编辑&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; YokPipeline(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.db &lt;/span&gt;=&lt;span&gt; pymysql.connect(
            host&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            user&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            password&lt;/span&gt;=&lt;span&gt;'1234&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            db&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yok&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            port&lt;/span&gt;=3306&lt;span&gt;,
            charset&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        )
        self.cursor &lt;/span&gt;=&lt;span&gt; self.db.cursor()
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
        sql &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO pinglun(content) values(%s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        data &lt;/span&gt;= (item[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.cursor.execute(sql, data)
            self.db.commit()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;存储失败&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            self.db.rollback()
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; closed_spider(self, spider):
        self.cursor.close()
        self.db.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;2.6 配置settings&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
BOT_NAME = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;yok&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
SPIDER_MODULES &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yok.spiders&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
NEWSPIDER_MODULE &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;yok.spiders&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
USER_AGENT &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
ROBOTSTXT_OBEY &lt;/span&gt;=&lt;span&gt; False
DOWNLOAD_DELAY &lt;/span&gt;= 2&lt;span&gt;
COOKIES_ENABLED &lt;/span&gt;=&lt;span&gt; False
DEFAULT_REQUEST_HEADERS &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:authority&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;p.comments.yok.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:method&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:scheme&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accept&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*/*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accept-encoding&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gzip, deflate, br&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accept-language&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zh-CN,zh;q=0.9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;referer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.yok.com/id.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
ITEM_PIPELINES &lt;/span&gt;=&lt;span&gt; {
   &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yok.pipelines.YokPipeline&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 300&lt;span&gt;,
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;2.7 执行程序&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在main.py中编辑&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; scrapy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cmdline

cmdline.execute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scrapy crawl pinglun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.split())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最终爬取到1万5千多条数据.&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2&gt;3. 朴素贝叶斯分类&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过爬虫分析过程了解到我们的数据是无标签的, 但朴素贝叶斯是有监督的学习, 因此我又爬取了一些同类型电视剧评论的标签数据, 将问题转化为情感分类问题, 即通过这些标签数据进行训练模型, 进而对无标签数据进行分类.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.1 从数据库中读取数据&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;连接数据库&lt;/span&gt;
conn = pymysql.connect(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, user=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=3306, db=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, charset=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
sql &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from pinglun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取数据&lt;/span&gt;
df =&lt;span&gt; pd.read_sql(sql, conn)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除重复记录&lt;/span&gt;
df.drop_duplicates(inplace =&lt;span&gt; True)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置行的最大显示为2条&lt;/span&gt;
pd.set_option(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;display.max_rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2)&lt;br/&gt;df
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181115182712864-1395471269.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.2 对数据进行分类&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们依据评分进行情感分类, 大于3分为积极情感, 小于3分为消极情感, 积极情感用1表示, 消极情感用0表示.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;转换数据类型&lt;/span&gt;
df.score =&lt;span&gt; df.score.astype(int)
teleplay_0 &lt;/span&gt;= df[df.score &amp;lt;3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过比对,发现消极情感的总数较少,随机抽取同数量的积极情感&lt;/span&gt;
teleplay_1 = df[df.score &amp;gt; 3].sample(n=&lt;span&gt;teleplay_0.shape[0])
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对两者进行拼接&lt;/span&gt;
teleplay = pd.concat([teleplay_1, teleplay_0], axis=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对情感进行分类, 0消极,1积极&lt;/span&gt;
teleplay[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;emotion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = np.where(teleplay.score &amp;gt; 3, 1&lt;span&gt;, 0)
teleplay&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181116020842082-1066701297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.3 对评论进行分词处理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我这里采用两种库, 一个jieba, 一个是snownlp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 安装两个库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip install jieba&lt;br/&gt;pip install snownlp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 对评论进行分词&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; snownlp &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SnowNLP
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; jieba
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对评论进行分词, 并以空格隔开&lt;/span&gt;
teleplay[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cut_jieba&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = teleplay.content.apply(&lt;span&gt;lambda&lt;/span&gt; x: &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(jieba.cut(x)))
teleplay[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cut_snownlp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = teleplay.content.apply(&lt;span&gt;lambda&lt;/span&gt; x: &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(SnowNLP(x).words))
teleplay&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到两者的分词结果还是有区别的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181116021402952-1655304927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.4 停用词处理&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;什么是停用词? 我们把&quot;看到&quot;, &quot;和&quot;, &quot;的&quot;, &quot;基本&quot;等这类可忽略的词汇, 称为停用词. 它们的存在反而影响处理效率, 因此将它们除去.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_stopwords(path):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;读取停用词&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    with open(path) as f:
        stopwords &lt;/span&gt;= [i.strip() &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f.readlines()]
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stopwords
    
path &lt;/span&gt;= r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\stopword.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
stopwords &lt;/span&gt;=&lt;span&gt; get_stopwords(path)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分别去除cut_jieba和cut_snownlp中的停用词&lt;/span&gt;
teleplay[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cut_jieba&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = teleplay.cut_jieba.apply(&lt;span&gt;lambda&lt;/span&gt; x: &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;.join([w &lt;span&gt;for&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt; (x.split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;if&lt;/span&gt; w &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; stopwords]))
teleplay[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cut_snownlp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = teleplay.cut_snownlp.apply(&lt;span&gt;lambda&lt;/span&gt; x: &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;.join([w &lt;span&gt;for&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt; (x.split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;if&lt;/span&gt; w &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; stopwords]))
teleplay&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181116021559396-1433033684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.5 特征向量化&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;特征向量化的目的就是将mX1的矩阵转化为mXn的矩阵(其中1表示1维文本, n表示1维文本中的n个词汇), 分别计算n个特征词汇在m行中出现的频数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 在特征向量化之前按照2:8的比例将数据集随机划分为训练集和测试集.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分别对cut_jieba和cut_snownlp进行划分&lt;/span&gt;
X1, X2, y = teleplay[[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cut_jieba&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]], teleplay[[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cut_snownlp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]], teleplay.emotion
X1_train, X1_test, y1_train, y1_test &lt;/span&gt;= train_test_split(X1, y, test_size=0.2&lt;span&gt;)
X2_train, X2_test, y2_train, y2_test &lt;/span&gt;= train_test_split(X2, y, test_size=0.2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 特征向量化(只对训练集进行向量化)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.feature_extraction.text &lt;span&gt;import&lt;/span&gt;&lt;span&gt; CountVectorizer
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
vect =&lt;span&gt; CountVectorizer()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分别对cut_jieba和cut_snownlp进行向量化, 并转化为dataframe.&lt;/span&gt;
vect_matrix_1 = pd.DataFrame(vect.fit_transform(X1_train.cut_jieba).toarray(), columns =&lt;span&gt; vect.get_feature_names())
vect_matrix_2 &lt;/span&gt;= pd.DataFrame(vect.fit_transform(X2_train.cut_snownlp).toarray(), columns =&lt;span&gt; vect.get_feature_names())
vect_matrix_1&lt;br/&gt;vect_matrix_2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181116021757022-2003127145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181116021830181-1392542278.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到向量化的结果中存在05, 07, 08...等数字, 而且这些数字对于分类的结果无太大作用, 需要剔除, 可以选择在向量化之前借助正则表达式进行剔除, 下面直接在CountVectorizer中筛选&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;max_df的类型若为int, 则表示过滤掉文档中出现次数大于max_df的词汇, 若为float时, 则是百分比; min_df类似, token_pattern表示token的正则表达式&lt;/span&gt;
vect = CountVectorizer(max_df = 0.8&lt;span&gt;, 
                     min_df &lt;/span&gt;= 2&lt;span&gt;,
                     token_pattern &lt;/span&gt;= r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(?u)\b[^\d\W]\w+\b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
vect_matrix_1 &lt;/span&gt;= pd.DataFrame(vect.fit_transform(X1_train.cut_jieba).toarray(), columns =&lt;span&gt; vect.get_feature_names())
vect_matrix_2 &lt;/span&gt;= pd.DataFrame(vect.fit_transform(X2_train.cut_snownlp).toarray(), columns =&lt;span&gt; vect.get_feature_names())
vect_matrix_1
vect_matrix_2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;两种分词方式经过同样的处理之后均过滤掉一半以上.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181116021932263-66825594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181116021957944-2014230225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.6  构建模型&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1. 构建模型与交叉验证&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.pipeline &lt;span&gt;import&lt;/span&gt;&lt;span&gt; make_pipeline
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.naive_bayes &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MultinomialNB
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cross_val_score
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化朴素贝叶斯模型&lt;/span&gt;
nb =&lt;span&gt; MultinomialNB()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用pipeline管道进行特征向量化&lt;/span&gt;
pipe =&lt;span&gt; make_pipeline(vect, nb)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;交叉验证,将训练集分成10份,即计算10次,在每次计算中用10份中的一份当作验证集,对应的另外9份用作训练集,最后对10次计算出的准确率求平均值&lt;/span&gt;
score1 = cross_val_score(pipe, X1_train.cut_jieba, y1_train, cv=10, scoring=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).mean()
score2 &lt;/span&gt;= cross_val_score(pipe, X2_train.cut_snownlp, y2_train, cv=10, scoring=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).mean()
score1
score2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
0.8002292107510046
&lt;/pre&gt;
&lt;pre&gt;
0.7559003695080964
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;在训练集上, jieba分词后的模型的准确率比snownlp能高些&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 模型评估&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; metrics
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练出模型&lt;/span&gt;
&lt;span&gt;pipe1= pipe.fit(X1_train.cut_jieba, y1_train)&lt;br/&gt;pipe2= pipe.fit(X2_train.cut_jieba, y2_train)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用训练的模型分别预测cut_jieba和cut_snownlp的测试集&lt;/span&gt;
y1_pre =&lt;span&gt;  pipe1.predict(X1_test.cut_jieba)
y2_pre &lt;/span&gt;=&lt;span&gt;  pipe2.predict(X2_test.cut_snownlp)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;评价模型预测结果&lt;/span&gt;
&lt;span&gt;metrics.accuracy_score(y1_test, y1_pre)
metrics.accuracy_score(y2_test, y2_pre)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
0.8071278825995807
&lt;/pre&gt;
&lt;pre&gt;
0.7631027253668763
&lt;/pre&gt;
&lt;p&gt; &lt;span&gt;在测试集上, jieba同样比snownlp的准确率高, 对于分类问题通常用混淆矩阵中的精准度和召回率进行评价.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) 混淆矩阵&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181116041132581-787267509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1和0表示真实值(1和0代表两个类别, 非数字意义), P和N表示预测值, T表示预测正确, F则错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准确率: (TP+TN)/(1+0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;灵敏度: TP/1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;精准度: TP/（TP+FP）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;召回率: TP/(TP+FN)等价于灵敏度 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2) 在朴素贝叶斯怎么才能得到混淆矩阵?&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分别求得cut_jieba和cut_snownlp的混淆矩阵&lt;/span&gt;
con_matrix1 =&lt;span&gt; metrics.confusion_matrix(y1_test, y1_pre)
con_matrix2 &lt;/span&gt;=&lt;span&gt; metrics.confusion_matrix(y2_test, y2_pre)
&lt;/span&gt;&lt;span&gt;#分别&lt;/span&gt;&lt;span&gt;计算精准率和召回率&lt;/span&gt;
accu_rate1, accu_rate2= con_matrix1[0][0]/(con_matrix1[1][0]+con_matrix1[0][0]), con_matrix2[0][0]/(con_matrix2[1][0]+&lt;span&gt;con_matrix2[0][0])
recall_rate1, recall_rate2 &lt;/span&gt;= con_matrix1[0][0]/(con_matrix1[0][1]+con_matrix1[0][0]), con_matrix2[0][0]/(con_matrix2[0][1]+&lt;span&gt;con_matrix2[0][0])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jieba_confused_matrix:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(con_matrix1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accurate_rate:{0}, recall_rate:{1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(accu_rate1, recall_rate1))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;snownlp_confused_matrix:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(con_matrix2)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accurate_rate:{0}, recall_rate:{1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(accu_rate2, recall_rate2))
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
jieba_confused_matrix:
[[351 130]
 [ 54 419]]
accurate_rate:0.8666666666666667, recall_rate:0.7297297297297297

snownlp_confused_matrix:
[[353 146]
 [ 80 375]]
accurate_rate:0.815242494226328, recall_rate:0.7074148296593187
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;在精准度和召回率上jieba同样表现更佳, 也从另一个层面上说明了特征的重要性, snownlp还有情感分类功能, 不妨看看结果如何&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3) snownlp情感分类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
y_pred_snow = X1_test.cut_jieba.apply(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x: SnowNLP(x).sentiments)
y_pred_snow&lt;/span&gt;= np.where(y_pred_snow &amp;gt; 0.5, 1&lt;span&gt;, 0)
metrics.accuracy_score(y1_test, y_pred_snow)
metrics.confusion_matrix(y1_test, y_pred_snow)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
0.640461215932914
&lt;/pre&gt;
&lt;pre&gt;
array([[179, 299],
       [ 44, 432]], dtype=int64)
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;可以看到在电视剧的评论上准确率不高, 但是精确率还是很高的: 0.80, 召回率: 0.37&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面将利用训练出的模型对新数据集进行情感分类&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2&gt;4. 情感分类&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过以上可以看到通过jieba分词后训练的朴素贝叶斯模型还是相当不错的, 那么现在就用该模型对新数据集进行分类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取数据, 删除重复项以及jieba分词&lt;/span&gt;
conn = pymysql.connect(host = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, user=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=3306,db=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yok&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, charset=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
sql &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from pinglun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
yk &lt;/span&gt;=&lt;span&gt; pd.read_sql(sql, conn)
yk.drop_duplicates(inplace&lt;/span&gt;=&lt;span&gt;True)
yk[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cut_content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = yk.content.apply(&lt;span&gt;lambda&lt;/span&gt; x: &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(jieba.cut(x)))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用模型进行情感分类&lt;/span&gt;
yk[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;emotion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; pipe1.predict(yk.cut_content)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算积极情感占比&lt;/span&gt;
yk[yk.emotion_nb == 1].shape[0]/yk.shape[0]
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
0.5522761760242793
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;另外根据模型在测试集的精准度0.87(在预测的结果为1中有87%真实值也是1), 因此在0.55的基础上再乘0.87, 结果为0.48, 这仅仅是预测为1且真实为1所占总体的参考比例, 不妨再利用snownlp对情感进行分类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用snownlp进行情感分类&lt;/span&gt;
emotion_pred = yk.cut_content.apply(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x: SnowNLP(x).sentiments)
yk[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;emotion_snow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = np.where(emotion_pred &amp;gt; 0.5, 1&lt;span&gt;, 0)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算积极情感占比&lt;/span&gt;
yk[yk.emotion_snow == 1].shape[0]/yk.shape[0]
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
0.6330804248861912
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;两者的差距也是挺大的, 相差8个百分点&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;随机抽取1个&lt;/span&gt;
yk.sample(n=1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181116095945326-728832526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表情就能表示出情感, 没能预测正确看来还是训练数据量太少, 有必要扩充了, 另外当训练数据达到某种程度, 会远超人类的判断力&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2&gt;5. 生成词云图&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; wordcloud &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WordCloud
bg_image &lt;/span&gt;= plt.imread(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tig.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)                
wc &lt;/span&gt;= WordCloud(width=1080,                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置宽度&lt;/span&gt;
               height=840,                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置高度&lt;/span&gt;
               background_color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;背景颜色&lt;/span&gt;
               mask=bg_image,                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;背景图&lt;/span&gt;
               font_path=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;STKAITI.TTF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;中文字体&lt;/span&gt;
               stopwords=stopwords,              &lt;span&gt;#&lt;/span&gt;&lt;span&gt;停用词&lt;/span&gt;
               max_font_size=400,                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;字体最大值&lt;/span&gt;
               random_state=50                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;随机配色方案&lt;/span&gt;
&lt;span&gt;              )            
wc.generate_from_text(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;.join(yk.cut_content))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成词云&lt;/span&gt;
plt.imshow(wc)                                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制图像&lt;/span&gt;
plt.axis(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)                                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭坐标轴显示&lt;/span&gt;
wc.to_file(&lt;span&gt;'pig&lt;/span&gt;&lt;span&gt;.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201811/1469712-20181116112417061-318977169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上便是对学习过程的总结, 若出现错误, 还望指正, 谢谢!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考: &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://www.cnblogs.com/mxp-neu/articles/5316989.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/29aa3ad63f9d&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;声明: 本文仅用作学习交流&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 05:43:00 +0000</pubDate>
<dc:creator>Star_Zhao</dc:creator>
<og:description>环境 win8, python3.7, jupyter notebook 正文 什么是情感分析?(以下引用百度百科定义) 情感分析（Sentiment analysis），又称倾向性分析，意见抽取（O</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/star-zhao/p/9940437.html</dc:identifier>
</item>
<item>
<title>带着萌新看springboot源码07 - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/9964069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/9964069.html</guid>
<description>&lt;p&gt;　　上一节在springboot中配置了servlet三大组件以及嵌入式servlet容器，并且还简单的说了如何切换不同的容器。&lt;/p&gt;
&lt;p&gt;　　这一节就来说说如何改变servlet容器的配置参数，一般有两种常见的方式，第一种：配置文件（properties和yml）；第二种：往容器里添加组件的方式&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;注意注意：我这里说的容器和嵌入式容器不一样的，容器指的是ioc容器，嵌入式servlet容器值得是servlet容器，不要混淆了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.通过配置文件的方式配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　yml为例，下图所示，这是配置容器启动的端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115134721375-456393688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　而且我们可以点开这个端口，可以发现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115135505652-1023260138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而这个ServerProperties的很多属性，port，adress，serverPath等等都可以在配置文件中server.xxx=xxxxx进行修改。&lt;/p&gt;

&lt;p&gt;　　在这个类中，起作用的主要是这个customize方法来设置容器的属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115135908414-1524708356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 2.通过嵌入式servlet容器定制器设置（这种配置比上面优先级高）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;随便找个配置类，如下代码（也可以配置其他属性，我用最简单的port演示一下）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115140441216-1359448471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　可以启动容器，看控制台，8082端口，启动成功，而且覆盖了yml配置的8080端口，这种方式的优先级更高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115140531153-1408418910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.一起来剖析原理（Tomcat为例）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以发现这两种的本质是一样的，最终都是向容器里添加一个嵌入式servlet容器定制器，执行其中的customize方法。&lt;/p&gt;
&lt;p&gt;　　那么，我们从哪里入手呢？（不用想，肯定是自动配置类啊，记住，一切配置入手都是从自动配置类开始）&lt;/p&gt;
&lt;p&gt;　　打开一个叫做EmbeddedServletContainerAutoConfiguration的类，翻译就叫做嵌入式servlet容器自动配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115150026161-1995096447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　   重点是这个自动配置类里面的配置（就以默认的tomcat为例）　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115142139514-1342129935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　只要添加了tomcat的依赖，会为ioc容器里面添加Tomcat的嵌入式servlet容器工厂，打开这个容器工厂&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115143135122-1933517811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115143301371-757985816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　点开这个类之后。我们主要看这里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115143515008-688708858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115143721371-1261222494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115143817076-1869038686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一直到这里，tomcat的配置都过了一遍，总结一下啊：只要EmbeddedServletContainerAutoConfiguration这个配置类生效-------&amp;gt;向ioc容器导入TomcatEmbeddedServletContainerFactory组件----------&amp;gt;这个tomcat嵌入式容器工厂里面会创建正常Tomcat容器对象----------&amp;gt;然后进行封装成嵌入式类型的容器，内部会直接启动Tomcat，从这里可以大概看出来先启动的ioc容器，然后再是Tomcat容器&lt;/p&gt;
&lt;p&gt;　　是不是还忘记了前面说的，这个自动配置类要起作用，会提前在ioc容器中导入一个注册器，这个组件很关键，他会在EmbeddedServletContainerAutoConfiguration自动配置类之前先给容器中注册一些后置处理器，而后面再ioc容器中满足条件的Bean创建对象但是还没有赋值的时候，会做一些准备工作，下面我们打开这个注册器BeanPostProcessorsRegistrar，看看注册了哪些后置处理器（BeanPostProcessors），打开这个来，看这里&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115145145513-1104817305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　打开这个嵌入式servlet容器定制器的后置处理器（这个单词够长......），打来这个很长的后置处理器，看这个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115150628515-395974077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115150924135-2136713600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　到这里就差不多了，一个很大的循环，和最开始的嵌入式servlet容器定制器链接起来了，哈哈，剖析了清楚了，还是很容易的，而且，上图中我们还可以看看getCustomizers（）是怎么获取所有的定制器的，点开这个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115151609240-278669675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　最后这个是一个简单的方法，就是容器中按照某种类型获取某些组件，然后保存起来，供别的方法遍历，每一个都去执行一个方法，这种模式在springboot中大量的可以看到。&lt;/p&gt;
&lt;p&gt;　　因为这一节东西比较多，我就总结一下。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;总结全过程：&lt;/span&gt;&lt;/strong&gt;启动springboot应用，创建ioc容器（这个过程我也会找个时间好好说一下ioc容器创建全过程，这里暂时掠过）----------&amp;gt;刷新ioc容器-----------&amp;gt;会导入很多的自动配置类，其中就有一个EmbeddedServletContainerAutoConfiguration，这个配置类起作用，又会往ioc容器中导入后置处理器的注册器（BeanPostProcessorsRegistrar）向容器中导入那个很长的后置处理器（EmbeddedServletContainerCustomizerBeanPostProcessor），还会导入tomcat容器工厂（TomcatEmbeddedServletContainerFactory）-----------&amp;gt;在这个容器工厂内部就会创建tomcat容器，然后进行一些参数的配置，再包装成嵌入式tomcat，同时我们配置的嵌入式容器定制器（EmbeddedServletContainerCustomizer）加载到ioc容器里,这个时候就会触发那个很长的后置处理器去拿到容器里所有的嵌入式容器定制器，遍历，执行customize方法也为嵌入式tomcat配置一些参数（当然，这些配置是我们写的，优先级更高）----------&amp;gt;tomcat启动&lt;/p&gt;
&lt;p&gt;　　哎，水平有限只能分析到这里，还是说一句，这里只是粗略的说了一下原理，真实情况下会更加复杂，等我什么时候水平到了，再继续分析吧！&lt;/p&gt;
&lt;p&gt;　　后面，我会分析分析springboot从启动开始怎么工作，包括ioc容器的创建过程（这个其实属于spring注解版的内容）；以及springboot不用嵌入式Tomcat，并支持jsp的做法，这些东西会总结一下。&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 04:29:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>上一节在springboot中配置了servlet三大组件以及嵌入式servlet容器，并且还简单的说了如何切换不同的容器。 这一节就来说说如何改变servlet容器的配置参数，一般有两种常见的方式，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/9964069.html</dc:identifier>
</item>
<item>
<title>tcp、udp、ip、icmp报文格式分析 - 楠神一</title>
<link>http://www.cnblogs.com/znl233/p/9968592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/znl233/p/9968592.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;TCP 、UDP 、IP、 ICMP协议报文格式分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tcp&lt;/strong&gt;&lt;strong&gt;报文格式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115502901-1420591519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Wireshark&lt;/strong&gt;&lt;strong&gt;抓包如图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115409756-2094066260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;源端口&lt;/strong&gt;&lt;strong&gt;/&lt;/strong&gt;&lt;strong&gt;目的端口&lt;/strong&gt;&lt;strong&gt;(16bit)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在TCP报文中包涵了源端口/目的端口，源端口标识了发送进程，目的端口标识了接收方进程。由上图可以看出在此报文中我们的源端口号是54160, 目的端口是cichlid（1377）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;序列号（&lt;/strong&gt;&lt;strong&gt;32bit&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Sequence Number这个是发送序列号，用来标识从源端向目的端发送的数据字节流，它表示在这个报文端中的第一个数据字节的顺序号，序列号是32位的无符号类型，序列号表达达到2^32 - 1后又从0开始， 当建立一个新的连接时，SYN标志为1，系列号将由主机随机选择一个顺序号ISN(Initial Sequence Number)。此报文中的序列号是0x37e3d3a9如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115555736-1920922110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;确认号&lt;/strong&gt;&lt;strong&gt;(32bit)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;Acknowledgment Number它包涵了发送确认一端所期望收到的下一个顺序号。因此确认序列号应当是上次成功接收到数据的顺序号加1。只有ACK标志为1时确认序号字段才有效。TCP为应用层提供全双工服务，这意味着数据能在两个方向上独立的进行传输，因此连接的两断必须要保证每个方向上的传输数据顺序。由图可以看出此报文的确认号为0xaa09ab7b。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115617020-253491449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;偏移（&lt;/strong&gt;&lt;strong&gt;4bit&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里的偏移实际指的是TCP首部的长度，它用来表明TCP首部中32bit字的数目，通过它可以知道一个TCP包它的用户数据从哪里开始，这个字段占4bit，若此字段的值为1000，则说明TCP首部的长度是8 * 4 = 32字节，所以TCP首部的最大长度是该字段的值为1111 = 15， 15 * 4 =60字节。此报文我们的偏移量在0x50中，又因它占4bit,0x50等于二进制的0101 0000 所以我们的偏移量是 0101=5，所以我们的TCP报文首部长度为5* 4 = 20字节。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115644305-1453074318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;标志&lt;/strong&gt;&lt;strong&gt;(Flags)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115710763-1006418549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reverved&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Nonce&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;CWR&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Ecn-Echo(6bit)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;目前没有使用，它们的值都为0，作为保留，留待以后开发新技术时使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URG(Urgent Pointer Field Significant):&lt;/strong&gt;紧急指针标志，用来保证TCP连接不被中断，并且督促中间设备尽快处理这些数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACK(Acknowledgement Field Signigicant):&lt;/strong&gt;确认号字段，该字段为1时表示应答字段有效，即TCP应答号将包含在TCP报文中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PSH(Push Function):&lt;/strong&gt; 推送功能，所谓推送功能指的是接收端在接收到数据后立即推送给应用程序，而不是在缓冲区中排队。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RST(Reset the connection):&lt;/strong&gt; 重置连接，不过一般表示断开一个连接，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYN(Synchronize sequence numbers):&lt;/strong&gt;同步序列号，用来发起一个连接请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FIN(No more data from sender):&lt;/strong&gt;表示发送端发送任务已经完成（即断开连接）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;窗口大小&lt;/strong&gt;&lt;strong&gt;(16bit)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示现在运行对方发送的数据量。也就是告诉对方，从本报文段的确认号开始允许对方发送的数据量,由下图可以看出该窗口允许发送65536的数据量。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115744935-1085569244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;校验和&lt;/strong&gt;&lt;strong&gt;(16bit)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包含TCP首部和TCP数据段，这是一个强制性的字段，一定是由发送端计算和存储，由接收端进行验证。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115802688-918283290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt;&lt;strong&gt;报文格式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115824908-1527494515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络抓包如图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115841921-1435332775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115851626-1697215052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由图可知源&lt;strong&gt;端口号（&lt;/strong&gt;&lt;strong&gt;Source port&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;为64668，&lt;strong&gt;目的端口号（&lt;/strong&gt;&lt;strong&gt;Destination port&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;为10019，用户数&lt;strong&gt;据报长度（&lt;/strong&gt;&lt;strong&gt;Length&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;为136bit，&lt;strong&gt;校验和&lt;/strong&gt;&lt;strong&gt;(checksum)&lt;/strong&gt;为0x8e67=36455，另外存在128bytes的&lt;strong&gt;数据（&lt;/strong&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP&lt;/strong&gt;&lt;strong&gt;报文格式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115913413-2081101586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络抓包如下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115932724-2012876880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;版本&lt;/strong&gt;&lt;strong&gt;(Version&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首部长度&lt;/strong&gt;&lt;strong&gt;(Header length)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;IP报头的长度。固定部分的长度（20字节）和可变部分的长度之和。共占4位。最大为1111，即10进制的15，代表IP报头的最大长度可以为15个32bits（4字节），也就是最长可为15*4=60字节，除去固定部分的长度20字节，可变部分的长度最大为40字节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总长度&lt;/strong&gt;&lt;strong&gt;(Total Length)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;IP报文的总长度。报头的长度和数据部分的长度之和。此IP报文的总长度为52字节。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;标识（&lt;/strong&gt;&lt;strong&gt;Identification&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;唯一的标识主机发送的每一分数据报。通常每发送一个报文，它的值加一。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。故该字段标记当前分片为第几个分片，在数据报重组时很有用。由图可知当前分片为第17919个分片。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116115958147-520808277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;标志（&lt;/strong&gt;&lt;strong&gt;Flags&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;共3位。R(Reserved bit)、DF(Don’t fragment)、MF(More fragment)三位。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示不是最后一片，还有其他分片，为0表示这是最后一片。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116120015506-1567337960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;片偏移&lt;/strong&gt;&lt;strong&gt;(Fragment offset)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;该字段是与ip分片后，相应的ip片在总的ip片的位置。该字段的单位是8字节。比如，一个长度为4000字节的ip报文，到达路由器。这是超过了链路层的MTU，需要进行分片，4000字节中，20字节为包头，3980字节为数据，需要分成3个ip片（链路层MTU为1500），那么第一个分片的片偏移就是0，表示该分片在3980的第0位开始，第1479位结束。第二个ip片的片偏移为185（1480/8），表示该分片开始的位置在原来ip的第1480位，结束在2959。第三片的片偏移为370（2960/8），表示开始的时候是2960位，结束的时候在3979位。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116120030259-462236049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生存时间（&lt;/strong&gt;&lt;strong&gt;Time to live&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为0时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定，当前值为 54，表明此数据包经过了64-54=10台路由器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;协议&lt;/strong&gt;&lt;strong&gt;(Protocol)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;指出IP报文携带的数据使用的是那种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首部校验和&lt;/strong&gt;&lt;strong&gt;(Header checksum)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;计算IP头部的校验和，检查IP报头的完整性。由图中的correct可知该IP报头是完整的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源&lt;/strong&gt;&lt;strong&gt;IP&lt;/strong&gt;&lt;strong&gt;地址&lt;/strong&gt;&lt;strong&gt;(source)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;标识IP数据报的源端设备，由图可知该源IP地址为183.232.173.182&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;strong&gt;IP&lt;/strong&gt;&lt;strong&gt;地址&lt;/strong&gt;&lt;strong&gt;(destination)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;标识IP数据报的目的地址,由图可知该目的IP地址为172.31.116.155&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Icmp&lt;/strong&gt;&lt;strong&gt;报文格式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116120109434-672465344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络抓包如图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116120250723-2074586864.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116120236446-1552938465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362576/201811/1362576-20181116120305332-852567133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实验原理：&lt;/strong&gt;ping是用来测试网络连通性的命令，一旦发出ping命令，主机会发出连续的测试数据包到网络中，在通常的情况下，主机会收到回应数据包，ping采用的是ICMP协议。&lt;/p&gt;

&lt;p&gt;在这次实验中可以发现，日常进行的ping操作的icmp报文就只有两种，&lt;strong&gt;请求&lt;/strong&gt;&lt;strong&gt;(request)&lt;/strong&gt;和&lt;strong&gt;应答&lt;/strong&gt;&lt;strong&gt;(reply)&lt;/strong&gt;。这两个报文的type不一样，8代表请求，0代表应答；code都为0，表示为回显应答；标示符和序列号都是一样的，表示这两个报文是配对的。&lt;/p&gt;

</description>
<pubDate>Fri, 16 Nov 2018 04:20:00 +0000</pubDate>
<dc:creator>楠神一</dc:creator>
<og:description>TCP 、UDP 、IP、 ICMP协议报文格式分析 Tcp报文格式： Wireshark抓包如图： 源端口/目的端口(16bit)： 在TCP报文中包涵了源端口/目的端口，源端口标识了发送进程，目的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/znl233/p/9968592.html</dc:identifier>
</item>
<item>
<title>python 历险记（四）— python 中常用的 json 操作 - ReyCG</title>
<link>http://www.cnblogs.com/reycg-blog/p/9967865.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reycg-blog/p/9967865.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;你一定听说过 JSON 吧。JSON 是当前最常用的数据传输格式之一，纯文本，容易使用，方便阅读，最重要的是在多个场合都被大量被使用。&lt;/p&gt;
&lt;p&gt;既然 JSON 这么好，那就让我们继续探险，去掌握 python 中对 JSON 的常用操作吧， okay， let's go!&lt;/p&gt;

&lt;p&gt;庄子曰：“水之积也不厚，则其负大舟也无力。”。要完全掌握一个知识点，先将这个知识点需要的基础知识补齐，这样学的才能牢固。&lt;/p&gt;
&lt;p&gt;下面就是我认为学习对 JSON 操作前的知识点。如果您对这部分已经了然于胸，尽可以略过这部分，跳到下一节。&lt;/p&gt;
&lt;h2 id=&quot;什么是-json&quot;&gt;什么是 JSON？&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Json (Javascript Object Notation) 是一种轻量级的数据交换格式，它基于 Javascript 的对象字面量。尽管它只是 Javascript 的一个子集，但它与语言无关。以现代编程语言编写的程序，都可以用它来彼此交换数据。它是一种文本格式，人和机器都可以阅读它。&lt;/p&gt;
&lt;p&gt;—— 《Javascript 语言精粹》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然以现代编程语言都可以用它来交换数据，强大的 python 当然也不例外。要更好的使用 JSON 一定要先了解下它的语法。&lt;/p&gt;
&lt;h2 id=&quot;json-的语法&quot;&gt;JSON 的语法&lt;/h2&gt;
&lt;p&gt;JSON 的值分为 6 种类型，分别是对象，数组，字符串，数字，布尔值 (&lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; )和&lt;code&gt;null&lt;/code&gt;。来看一个典型的 JSON 集合，体会下这些类型。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;obj&quot;: {
    &quot;name&quot;: &quot;xxx&quot;,
    &quot;address&quot;: {
      &quot;country&quot;: &quot;china&quot;,
      &quot;city&quot;: &quot;TianJin&quot;
    }
  },
  &quot;arr_simple&quot;: [1, 2, 3, 5],
  &quot;arr_complex&quot;: [
    1,
    &quot;a&quot;,
    {
      &quot;b&quot;: &quot;yyy&quot;
    },
    true,
    null
  ],
  &quot;str&quot;: &quot;I am a string&quot;,
  &quot;num&quot;: 888,
  &quot;booValue&quot;: false,
  &quot;nullValue&quot;: null
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上面代码， JSON 语法有什么特点呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JSON 字符串必须使用 &lt;strong&gt;双引号&lt;/strong&gt;包围&lt;/li&gt;
&lt;li&gt;可以在任何值前后插入空白（包括空格，制表符，回车，换行），当然这些空白符也可以去除。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;像字符串，数字，布尔值，null 都比较简单，无需细数，接下来我们重点来看下对象和数组。&lt;/p&gt;
&lt;h3 id=&quot;json-对象有哪些特点&quot;&gt;JSON 对象有哪些特点？&lt;/h3&gt;
&lt;p&gt;JSON 对象的结构是什么样子呢？&lt;/p&gt;
&lt;p&gt;上面代码中的 &lt;code&gt;obj&lt;/code&gt; 就是一个 JSON 对象，我们来观察下它。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它是用 &lt;code&gt;{}&lt;/code&gt; 括起来的一个集合，每一项都包含&lt;strong&gt;名称&lt;/strong&gt; 和&lt;strong&gt;值&lt;/strong&gt; ，如 &lt;code&gt;name&lt;/code&gt; 就是名称，而值就是 &lt;code&gt;xxx&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;名称可以是任意字符串，但必须是字符串才可以哦。&lt;/li&gt;
&lt;li&gt;值只要是上面 6 种类型之一就可以&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;名称/值&lt;/strong&gt; 对没有固定的顺序，可以是任意顺序&lt;/li&gt;
&lt;li&gt;可以支持无限层的嵌套，如 &lt;code&gt;obj&lt;/code&gt; 对象中嵌套了一个 &lt;code&gt;address&lt;/code&gt; 对象，但是为了保证处理的高效性，请尽量保持结构的扁平性，也就是不要嵌套太多层哦）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了能够处理 JSON 数据，许多语言都有对应的数据类型可以映射为 JSON 对象，那么 python 中是什么数据类型呢？&lt;/p&gt;
&lt;p&gt;是 &lt;code&gt;dict&lt;/code&gt; ，如果有您对 &lt;code&gt;dict&lt;/code&gt; 有些遗忘了，就请到&lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/9907327.html#%E5%AD%97%E5%85%B8-dict&quot;&gt;这里&lt;/a&gt;复习下吧。&lt;/p&gt;
&lt;h3 id=&quot;json-数组有哪些特点&quot;&gt;JSON 数组有哪些特点？&lt;/h3&gt;
&lt;p&gt;上面代码中的 &lt;code&gt;arr_simple&lt;/code&gt; 和 &lt;code&gt;arr_complex&lt;/code&gt; 都表示数组，它们有哪些特点呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是一个 &lt;strong&gt;有序序列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;只有 &lt;strong&gt;值&lt;/strong&gt; 组成&lt;/li&gt;
&lt;li&gt;值可以是任意类型的 JSON 值，如 &lt;code&gt;arr_complex&lt;/code&gt; 数组。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;python 也有能够映射为 JSON 对象的数据类型，是 &lt;code&gt;list&lt;/code&gt; 和 &lt;code&gt;tuple&lt;/code&gt; ， 如果您对 &lt;code&gt;list&lt;/code&gt; 和 &lt;code&gt;tuple&lt;/code&gt; 的特性有些生疏了，也可以在&lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/9907327.html#%E5%88%97%E8%A1%A8-list&quot;&gt;这里&lt;/a&gt;回顾下。&lt;/p&gt;
&lt;h3 id=&quot;什么是编码和解码&quot;&gt;什么是编码和解码？&lt;/h3&gt;
&lt;p&gt;说到 JSON 和 python 之间的转换，就会涉及到两个名词：&lt;strong&gt;编码&lt;/strong&gt; 和 &lt;strong&gt;解码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么到底什么是编码和解码呢？&lt;/p&gt;
&lt;blockquote readability=&quot;5.3932584269663&quot;&gt;
&lt;p&gt;&lt;strong&gt;编码&lt;/strong&gt;是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF&quot;&gt;信息&lt;/a&gt;从一种&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F&quot;&gt;形式&lt;/a&gt;或&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F&quot;&gt;格式&lt;/a&gt;转换为另一种形式的过程。&lt;strong&gt;解码&lt;/strong&gt;，是&lt;strong&gt;编码&lt;/strong&gt;的逆过程，亦即把&lt;strong&gt;编码&lt;/strong&gt;过的信息恢复成原来样式。&lt;/p&gt;
&lt;p&gt;——维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编码的作用则是为了利于传输和存储，JSON 当然是非常适合的。因此，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把 python 对象转换成 JSON 的过程就称为编码&lt;/li&gt;
&lt;li&gt;把 JSON 转换成 python 对象的过程就称为解码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;刚开始接触 json 的操作，我主要有下面几个疑问：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;json 操作需要什么库？&lt;/li&gt;
&lt;li&gt;如何将 python 对象转换成 JSON字符串，更进一步，能不能直接转换成文件句柄存储到文件中？（编码）&lt;/li&gt;
&lt;li&gt;如何将 json 字符串转换成 python 对象，更进一步，能不能直接将 JSON 格式的文件转换成 python 对象？（解码）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面就让我们一一来探索这些问题。&lt;/p&gt;
&lt;h2 id=&quot;json-操作需要什么库&quot;&gt;json 操作需要什么库？&lt;/h2&gt;
&lt;p&gt;使用 json 函数前需要先导入 json 库：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;import json&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;json&lt;/code&gt; 库本身就是 python 内置的标准库，因此你不需要做任何安装的操作。只要声明了上面语句，就可直接使用。&lt;/p&gt;
&lt;h2 id=&quot;如何将-python-编码成-json&quot;&gt;如何将 python 编码成 JSON？&lt;/h2&gt;
&lt;h3 id=&quot;python-编码为-json-的对照表&quot;&gt;python 编码为 JSON 的对照表&lt;/h3&gt;
&lt;p&gt;要完成这个功能，先要看下 python 数据结构编码为 json 的对照表。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;dict&lt;/td&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;list, tuple&lt;/td&gt;
&lt;td&gt;array&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;str&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;int, float, int- &amp;amp; float-derived Enums&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;有了这张表，我们就可以清楚的知道 python 对象将编码成的 json 格式。&lt;/p&gt;
&lt;h3 id=&quot;json.dumps&quot;&gt;json.dumps()&lt;/h3&gt;
&lt;p&gt;json.dumps() 方法的作用就是将 python 对象转换成 JSON 字符串，下面来看具体的函数声明：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数看起来好多啊，不过不用担心，这么多参数，只有第一个参数是必填的。下面就来一一了解下这些参数的意义&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;obj&lt;/strong&gt; 就是要编码的 python 对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;skipkeys&lt;/strong&gt; 默认值是 &lt;code&gt;False&lt;/code&gt;。设置为 &lt;code&gt;True&lt;/code&gt; ,假如 &lt;code&gt;obj&lt;/code&gt; 中的 dict keys 不是基本类型(&lt;code&gt;str&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; )， 就会被忽略，而不是抛出 &lt;code&gt;TypeError&lt;/code&gt; 错误&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ensure_ascii&lt;/strong&gt; 默认是 &lt;code&gt;True&lt;/code&gt; , 表示默认使用ascii 编码。如果 obj 内含有非 ASCII 字符，就会出现 &quot;\uXXXX&quot; 格式显式的数据， 设置成 &lt;code&gt;False&lt;/code&gt; 就会使用字符本来的编码。
&lt;ul&gt;&lt;li&gt;这里要注意，如果输入是中文，需要指定 &lt;code&gt;ensure_ascii=False&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;check_circular&lt;/strong&gt; 默认值是 &lt;code&gt;True&lt;/code&gt;，如果设置为 &lt;code&gt;False&lt;/code&gt; 就不会检查内部类型是否包含循环引用，而且循环引用会导致 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OverflowError&quot;&gt;OverflowError&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;allow_nan&lt;/strong&gt; 默认值为 &lt;code&gt;False&lt;/code&gt; ，如果碰到超过范围的 &lt;code&gt;float&lt;/code&gt; 值（&lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, &lt;code&gt;-inf&lt;/code&gt; )就使用 (&lt;code&gt;NaN&lt;/code&gt;,&lt;code&gt;Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;) 替换
&lt;ul&gt;&lt;li&gt;如果为 &lt;code&gt;True&lt;/code&gt; 碰到这些值则会导致 &lt;code&gt;ValueError&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;indent&lt;/strong&gt; 缩进设置
&lt;ul&gt;&lt;li&gt;如果是非负整数或者 string, JSON Array 元素和对象元素将会按照设置的缩进格式化显示&lt;/li&gt;
&lt;li&gt;值为 0, 负值，或者 &lt;code&gt;&quot;&quot;&lt;/code&gt; 只会插入新的一行&lt;/li&gt;
&lt;li&gt;值为 &lt;code&gt;None&lt;/code&gt; （也是默认值）会尽可能的压缩&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;separators&lt;/strong&gt; 分隔符。
&lt;ul&gt;&lt;li&gt;如果要设置它，参数需要是一个元组&lt;code&gt;(item_separator, key_separator)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认值是 &lt;code&gt;(', ', ': ')&lt;/code&gt; ，表示 keys 之间用 &lt;code&gt;,&lt;/code&gt; 隔开，而 key 和 value 之间用 &lt;code&gt;:&lt;/code&gt; 隔开&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sort_keys&lt;/strong&gt; 默认值是 &lt;code&gt;False&lt;/code&gt; ,如果设置成 &lt;code&gt;True&lt;/code&gt; , dict 结构的输出就会按照 key 来排序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;encoding&lt;/strong&gt; 默认值是 UTF-8 用于设置 JSON 数据的编码方式，在处理中文时这里一定要注意。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来看一个例子&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import json
&amp;gt;&amp;gt;&amp;gt; json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
'[&quot;foo&quot;, {&quot;bar&quot;: [&quot;baz&quot;, null, 1.0, 2]}]'
&amp;gt;&amp;gt;&amp;gt; print(json.dumps(&quot;\&quot;foo\bar&quot;))
&quot;\&quot;foo\bar&quot;
&amp;gt;&amp;gt;&amp;gt; print(json.dumps('\u1234'))
&quot;\u1234&quot;
&amp;gt;&amp;gt;&amp;gt; print(json.dumps('\\'))
&quot;\\&quot;
&amp;gt;&amp;gt;&amp;gt; print(json.dumps({&quot;c&quot;: 0, &quot;b&quot;: 0, &quot;a&quot;: 0}, sort_keys=True))
{&quot;a&quot;: 0, &quot;b&quot;: 0, &quot;c&quot;: 0}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;json.dump&quot;&gt;json.dump()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;json.dump()&lt;/code&gt; 函数的作用就是将 python 对象转换成 JSON 字符串，并将其通过 fp 文件流写入到文件中。来看下具体的函数声明：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt; json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和前面的 dumps 函数进行比较，会发现两个函数的参数是非常相似的，而且它们的意义也都相同。来看下面的例子&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import json
&amp;gt;&amp;gt;&amp;gt; from io import StringIO
&amp;gt;&amp;gt;&amp;gt; io = StringIO()
&amp;gt;&amp;gt;&amp;gt; json.dump(['streaming API'], io)
&amp;gt;&amp;gt;&amp;gt; io.getvalue()
'[&quot;streaming API&quot;]'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何将-json-解码成-python-对象&quot;&gt;如何将 JSON 解码成 python 对象？&lt;/h2&gt;
&lt;h3 id=&quot;json-解码为-python-的对照表&quot;&gt;JSON 解码为 python 的对照表&lt;/h3&gt;
&lt;p&gt;要完成这个功能，也先要看下 json 解码为 python 对象的对照表&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;dict&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;array&lt;/td&gt;
&lt;td&gt;list&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;str&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;number (int)&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;number (real)&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;编码对照表和解码对照表并不是一一对应的，因此如果一个 python对象 先编码成 JSON，再转码回来后得到的对象可就不一定完全相等了。&lt;/p&gt;
&lt;h3 id=&quot;json.loads&quot;&gt;json.loads()&lt;/h3&gt;
&lt;p&gt;这个方法的作用就是将参数 &lt;code&gt;s&lt;/code&gt; 按照上面的对照表反序列化为一个 python 对象。参数 &lt;code&gt;s&lt;/code&gt; 可以是 &lt;code&gt;str&lt;/code&gt; ,&lt;code&gt;byte&lt;/code&gt; 或者&lt;code&gt;byteArray&lt;/code&gt; 格式, 但必须要包含 JSON 文本才可以）。具体函数声明如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面就来一一了解下一些常用参数的意义&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;s&lt;/strong&gt; 就是要解码的 python 字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;encoding&lt;/strong&gt; 指定编码格式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;parse_float&lt;/strong&gt; ，默认情况下相当于 float(num_str)。如果设置为其他值，将会把一个 JSON 字符串按照 float 解码调用，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;parse_int&lt;/strong&gt; ，默认情况下相当于 int(num_str)，如果指定，将把每个 JSON 字符串按照 int 解码调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来看下面的例子，其中最后一行就指定了 &lt;code&gt;parse_float&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import json
&amp;gt;&amp;gt;&amp;gt; json.loads('[&quot;foo&quot;, {&quot;bar&quot;:[&quot;baz&quot;, null, 1.0, 2]}]')
['foo', {'bar': ['baz', None, 1.0, 2]}]
&amp;gt;&amp;gt;&amp;gt; json.loads('&quot;\\&quot;foo\\bar&quot;')
'&quot;foo\x08ar'
&amp;gt;&amp;gt;&amp;gt; import decimal
&amp;gt;&amp;gt;&amp;gt; json.loads('1.1', parse_float=decimal.Decimal)
Decimal('1.1')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;json.load&quot;&gt;json.load()&lt;/h3&gt;
&lt;p&gt;先来看函数声明&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt; json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作用是将 &lt;code&gt;fp&lt;/code&gt; 文件流反序列化为 python 对象，其中的参数意义和 &lt;code&gt;loads&lt;/code&gt; 方法相同。来看一个例子。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import json
&amp;gt;&amp;gt;&amp;gt; from io import StringIO
&amp;gt;&amp;gt;&amp;gt; io = StringIO('[&quot;streaming API&quot;]')
&amp;gt;&amp;gt;&amp;gt; json.load(io)
['streaming API']&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本文主要介绍了 JSON 的定义，语法以及 JSON 的常用操作。但是并没有涉及 JSON 处理自定义数据类型的高级内容（&lt;code&gt;JSONEncoder&lt;/code&gt;和&lt;code&gt;JSONDecoder&lt;/code&gt;），这部分内容会再后面的篇章中专门介绍。&lt;/p&gt;
&lt;p&gt;下篇会介绍 python 的模块，敬请期待。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/3.7/library/json.html&quot;&gt;python json API Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/3590768/&quot;&gt;《Javascript 语言精粹》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81&quot;&gt;编码—维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Fri, 16 Nov 2018 03:46:00 +0000</pubDate>
<dc:creator>ReyCG</dc:creator>
<og:description>[TOC] 引言 你一定听说过 JSON 吧。JSON 是当前最常用的数据传输格式之一，纯文本，容易使用，方便阅读，最重要的是在多个场合都被大量被使用。 既然 JSON 这么好，那就让我们继续探险，去</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/reycg-blog/p/9967865.html</dc:identifier>
</item>
<item>
<title>asp.netcore 深入了解配置文件加载过程 - Ron.liang</title>
<link>http://www.cnblogs.com/viter/p/9967936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/9967936.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;    配置文件中程序运行中，担当着不可或缺的角色；通常情况下，使用 visual studio 进行创建项目过程中，项目配置文件会自动生成在项目根目录下，如 appsettings.json，或者是被大家广泛使用的 appsettings.{env.EnvironmentName}.json；配置文件&lt;br/&gt;作为一个入口，可以让我们在不更新代码的情况，对程序进行干预和调整，那么对其加载过程的全面了解就显得非常必要。&lt;/p&gt;
&lt;h3 id=&quot;何时加载了默认的配置文件&quot;&gt;何时加载了默认的配置文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;在 Program.cs 文件中，查看以下代码&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class Program
    {
        public static void Main(string[] args)
        {
            CreateWebHostBuilder(args).Build().Run();
        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)
                .UseStartup&amp;lt;Startup&amp;gt;();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;WebHost.CreateDefaultBuilder 位于程序集 Microsoft.AspNetCore.dll 内，当程序执行 WebHost.CreateDefaultBuilder(args) 的时候，在 CreateDefaultBuilder 方法内部加载了默认的配置文件&lt;br/&gt;&lt;strong&gt;&lt;em&gt;代码如下&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static IWebHostBuilder CreateDefaultBuilder(string[] args)
        {
            var builder = new WebHostBuilder();

            if (string.IsNullOrEmpty(builder.GetSetting(WebHostDefaults.ContentRootKey)))
            {
                builder.UseContentRoot(Directory.GetCurrentDirectory());
            }
            if (args != null)
            {
                builder.UseConfiguration(new ConfigurationBuilder().AddCommandLine(args).Build());
            }

            builder.UseKestrel((builderContext, options) =&amp;gt;
                {
                    options.Configure(builderContext.Configuration.GetSection(&quot;Kestrel&quot;));
                })
                .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
                {
                    var env = hostingContext.HostingEnvironment;

                    config.AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
                          .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;, optional: true, reloadOnChange: true);

                    if (env.IsDevelopment())
                    {
                        var appAssembly = Assembly.Load(new AssemblyName(env.ApplicationName));
                        if (appAssembly != null)
                        {
                            config.AddUserSecrets(appAssembly, optional: true);
                        }
                    }

                    config.AddEnvironmentVariables();

                    if (args != null)
                    {
                        config.AddCommandLine(args);
                    }
                })
                .ConfigureLogging((hostingContext, logging) =&amp;gt;
                {
                    logging.AddConfiguration(hostingContext.Configuration.GetSection(&quot;Logging&quot;));
                    logging.AddConsole();
                    logging.AddDebug();
                    logging.AddEventSourceLogger();
                })
                .ConfigureServices((hostingContext, services) =&amp;gt;
                {
                    // Fallback
                    services.PostConfigure&amp;lt;HostFilteringOptions&amp;gt;(options =&amp;gt;
                    {
                        if (options.AllowedHosts == null || options.AllowedHosts.Count == 0)
                        {
                            // &quot;AllowedHosts&quot;: &quot;localhost;127.0.0.1;[::1]&quot;
                            var hosts = hostingContext.Configuration[&quot;AllowedHosts&quot;]?.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                            // Fall back to &quot;*&quot; to disable.
                            options.AllowedHosts = (hosts?.Length &amp;gt; 0 ? hosts : new[] { &quot;*&quot; });
                        }
                    });
                    // Change notification
                    services.AddSingleton&amp;lt;IOptionsChangeTokenSource&amp;lt;HostFilteringOptions&amp;gt;&amp;gt;(
                        new ConfigurationChangeTokenSource&amp;lt;HostFilteringOptions&amp;gt;(hostingContext.Configuration));

                    services.AddTransient&amp;lt;IStartupFilter, HostFilteringStartupFilter&amp;gt;();
                })
                .UseIIS()
                .UseIISIntegration()
                .UseDefaultServiceProvider((context, options) =&amp;gt;
                {
                    options.ValidateScopes = context.HostingEnvironment.IsDevelopment();
                });

            return builder;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可以看到，CreateDefaultBuilder 内部还是使用了 IConfigurationBuilder 的实现，且写死了默认配置文件的名字&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static IWebHostBuilder CreateDefaultBuilder(string[] args)
        {
            var builder = new WebHostBuilder();

            if (string.IsNullOrEmpty(builder.GetSetting(WebHostDefaults.ContentRootKey)))
            {
                builder.UseContentRoot(Directory.GetCurrentDirectory());
            }
            if (args != null)
            {
                builder.UseConfiguration(new ConfigurationBuilder().AddCommandLine(args).Build());
            }

            builder.UseKestrel((builderContext, options) =&amp;gt;
                {
                    options.Configure(builderContext.Configuration.GetSection(&quot;Kestrel&quot;));
                })
                .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
                {
                    var env = hostingContext.HostingEnvironment;

                    config.AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
                          .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;, optional: true, reloadOnChange: true);

                    if (env.IsDevelopment())
                    {
                        var appAssembly = Assembly.Load(new AssemblyName(env.ApplicationName));
                        if (appAssembly != null)
                        {
                            config.AddUserSecrets(appAssembly, optional: true);
                        }
                    }

                    config.AddEnvironmentVariables();

                    if (args != null)
                    {
                        config.AddCommandLine(args);
                    }
                })
                .ConfigureLogging((hostingContext, logging) =&amp;gt;
                {
                    logging.AddConfiguration(hostingContext.Configuration.GetSection(&quot;Logging&quot;));
                    logging.AddConsole();
                    logging.AddDebug();
                    logging.AddEventSourceLogger();
                })
                .ConfigureServices((hostingContext, services) =&amp;gt;
                {
                    // Fallback
                    services.PostConfigure&amp;lt;HostFilteringOptions&amp;gt;(options =&amp;gt;
                    {
                        if (options.AllowedHosts == null || options.AllowedHosts.Count == 0)
                        {
                            // &quot;AllowedHosts&quot;: &quot;localhost;127.0.0.1;[::1]&quot;
                            var hosts = hostingContext.Configuration[&quot;AllowedHosts&quot;]?.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                            // Fall back to &quot;*&quot; to disable.
                            options.AllowedHosts = (hosts?.Length &amp;gt; 0 ? hosts : new[] { &quot;*&quot; });
                        }
                    });
                    // Change notification
                    services.AddSingleton&amp;lt;IOptionsChangeTokenSource&amp;lt;HostFilteringOptions&amp;gt;&amp;gt;(
                        new ConfigurationChangeTokenSource&amp;lt;HostFilteringOptions&amp;gt;(hostingContext.Configuration));

                    services.AddTransient&amp;lt;IStartupFilter, HostFilteringStartupFilter&amp;gt;();
                })
                .UseIIS()
                .UseIISIntegration()
                .UseDefaultServiceProvider((context, options) =&amp;gt;
                {
                    options.ValidateScopes = context.HostingEnvironment.IsDevelopment();
                });

            return builder;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;由于以上代码，我们可以在应用程序根目录下使用 appsettings.json 和 appsettings.{env.EnvironmentName}.json 这种形式的默认配置文件名称&lt;br/&gt;&lt;strong&gt;&lt;em&gt;并且，由于 Main 方法默认对配置文件进行了 Build 方法的调用操作&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; public static void Main(string[] args)
        {
            CreateWebHostBuilder(args).Build().Run();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们可以在 Startup.cs 中使用注入的方式获得默认的配置文件对象 IConfigurationRoot/IConfiguration，代码片段&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这是为什么呢，因为在 执行 Build 方法的时候，方法内部已经将默认配置文件对象加入了 ServiceCollection 中，代码片段&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;  var services = new ServiceCollection();
  services.AddSingleton(_options);
  services.AddSingleton&amp;lt;IHostingEnvironment&amp;gt;(_hostingEnvironment);
  services.AddSingleton&amp;lt;Extensions.Hosting.IHostingEnvironment&amp;gt;(_hostingEnvironment);
  services.AddSingleton(_context);

  var builder = new ConfigurationBuilder()
                .SetBasePath(_hostingEnvironment.ContentRootPath)
                .AddConfiguration(_config);

  _configureAppConfigurationBuilder?.Invoke(_context, builder);

  var configuration = builder.Build();
  services.AddSingleton&amp;lt;IConfiguration&amp;gt;(configuration);
  _context.Configuration = configuration;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;以上这段代码非常熟悉，因为在 Startup.cs 文件中，我们也许会使用过 ServiceCollection 对象将业务系统的自定义对象加入服务上下文中，以方便后续接口注入使用。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;addjsonfile-方法的使用&quot;&gt;AddJsonFile 方法的使用&lt;/h3&gt;
&lt;p&gt;    通常情况下，我们都会使用默认的配置文件进行开发，或者使用 appsettings.{env.EnvironmentName}.json 的文件名称方式来区分 开发/测试/产品 环境，根据环境变量加载不同的配置文件；可是这样一来带来了另外一个管理上的问题，产品环境的配置参数和开发环境&lt;br/&gt;是不同的，如果使用环境变量的方式控制配置文件的加载，则可能导致密码泄露等风险；诚然，可以手工在产品环境创建此文件，但是这样一来，发布流程将会变得非常繁琐，稍有错漏文件便会被覆盖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;我们推荐使用 AddJsonFile 加载产品环境配置，代码如下&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public Startup(IConfiguration configuration, IHostingEnvironment env)
        {
            Configuration = AddCustomizedJsonFile(env).Build();

        }

        public ConfigurationBuilder AddCustomizedJsonFile(IHostingEnvironment env)
        {
            var build = new ConfigurationBuilder();
            build.SetBasePath(env.ContentRootPath).AddJsonFile(&quot;appsettings.json&quot;, true, true);
            if (env.IsProduction())
            {
                build.AddJsonFile(Path.Combine(&quot;/data/sites/config&quot;, &quot;appsettings.json&quot;), true, true);
            }
            return build;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;    通过 AddCustomizedJsonFile 方法去创建一个 ConfigurationBuilder 对象，并覆盖系统默认的 ConfigurationBuilder 对象，在方法内部，默认加载开发环境的配置文件，在产品模式下，额外加载目录 /data/sites/config/appsettings.json 文件，&lt;br/&gt;不同担心配置文件冲突问题，相同键值的内容将由后加入的配置文件所覆盖。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置文件的变动&quot;&gt;配置文件的变动&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在调用 AddJsonFile 时，我们看到该方法共有 5 个重载的方法&lt;br/&gt;&lt;strong&gt;&lt;em&gt;其中一个方法包含了 4 个参数，代码如下&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, IFileProvider provider, string path, bool optional, bool reloadOnChange)
        {
            if (builder == null)
            {
                throw new ArgumentNullException(nameof(builder));
            }
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException(Resources.Error_InvalidFilePath, nameof(path));
            }

            return builder.AddJsonFile(s =&amp;gt;
            {
                s.FileProvider = provider;
                s.Path = path;
                s.Optional = optional;
                s.ReloadOnChange = reloadOnChange;
                s.ResolveFileProvider();
            });
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;    在此方法中，有一个参数 bool reloadOnChange,从参数描述可知，该值指示在文件变动的时候是否重新加载，默认值为：false；一般在手动加载配置文件，即调用 AddJsonFile 方法时，建议将该参数值设置为 true。&lt;br/&gt;那么 .netcore 是如果通过该参数 reloadOnChange 是来监控文件变动，以及何时进行重新加载的操作呢，看下面代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        public IConfigurationRoot Build()
        {
            var providers = new List&amp;lt;IConfigurationProvider&amp;gt;();
            foreach (var source in Sources)
            {
                var provider = source.Build(this);
                providers.Add(provider);
            }
            return new ConfigurationRoot(providers);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在我们执行 .Build 方法的时候，方法内部最后一行代码给我们利用 AddJsonFile 方法的参数创建并返回了一个 ConfigurationRoot 对象&lt;br/&gt;&lt;strong&gt;&lt;em&gt;在 ConfigurationRoot 的构造方法中&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        public ConfigurationRoot(IList&amp;lt;IConfigurationProvider&amp;gt; providers)
        {
            if (providers == null)
            {
                throw new ArgumentNullException(nameof(providers));
            }

            _providers = providers;
            foreach (var p in providers)
            {
                p.Load();
                ChangeToken.OnChange(() =&amp;gt; p.GetReloadToken(), () =&amp;gt; RaiseChanged());
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们看到，方法内部一次读取了通过 AddJsonFile 方法加入的配置文件，并为每个配置文件单独分配了一个监听器 ChangeToken，并绑定当前文件读取对象 IConfigurationProvider.GetReloadToken 方法到监听器中&lt;br/&gt;&lt;strong&gt;&lt;em&gt;当文件产生变动的时候，监听器会收到一个通知，同时，对该文件执行原子操作&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; private void RaiseChanged()
        {
            var previousToken = Interlocked.Exchange(ref _changeToken, new ConfigurationReloadToken());
            previousToken.OnReload();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;由于 AddJsonFile 方法内部使用了 JsonConfigurationSource ，而 Build 的重载方法构造了一个 JsonConfigurationProvider 读取对象，查看代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        public override IConfigurationProvider Build(IConfigurationBuilder builder)
        {
            EnsureDefaults(builder);
            return new JsonConfigurationProvider(this);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在 JsonConfigurationProvider 继承自 FileConfigurationProvider 类，该类位于程序集 Microsoft.Extensions.Configuration.Json.dll 内&lt;br/&gt;&lt;strong&gt;&lt;em&gt;在 FileConfigurationProvider 的构造方法中实现了监听器重新加载配置文件的过程&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        public FileConfigurationProvider(FileConfigurationSource source)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }
            Source = source;

            if (Source.ReloadOnChange &amp;amp;&amp;amp; Source.FileProvider != null)
            {
                ChangeToken.OnChange(
                    () =&amp;gt; Source.FileProvider.Watch(Source.Path),
                    () =&amp;gt; {
                        Thread.Sleep(Source.ReloadDelay);
                        Load(reload: true);
                    });
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;值得注意的是，该监听器不是在得到文件变动通知后第一时间去重新加载配置文件，方法内部可以看到，这里有一个 Thread.Sleep(Source.ReloadDelay)，而 ReloadDelay 的默认值为：250ms，该属性的描述为&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;获取或者设置重新加载将等待的毫秒数, 然后调用 &quot;Load&quot; 方法。 这有助于避免在完全写入文件之前触发重新加载。默认值为250&lt;/li&gt;
&lt;li&gt;让人欣慰的是，我们可以自定义该值，如果业务对文件变动需求不是特别迫切，您可以将该值设置为一个很大的时间，通常情况下，我们不建议那么做&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;    以上就是 asp.netcore 中配置文件加载的内部执行过程，从中我们认识到，默认配置文件是如何加载，并将默认配置文件如何注入到系统中的，还学习到了如果在不同的环境下，选择加载自定义配置文件的过程；但配置文件变动的时候，系统内部又是如何去把配置文件重新加载到内存中去的。&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 03:26:00 +0000</pubDate>
<dc:creator>Ron.liang</dc:creator>
<og:description>前言     配置文件中程序运行中，担当着不可或缺的角色；通常情况下，使用 visual studio 进行创建项目过程中，项目配置文件会自动生成在项目根目录下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viter/p/9967936.html</dc:identifier>
</item>
</channel>
</rss>