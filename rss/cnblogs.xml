<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NETCore的Kestrel服务器 - Chaunce</title>
<link>http://www.cnblogs.com/xiaoliangge/p/8387772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoliangge/p/8387772.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/578477/201801/578477-20180130224642031-1211289777.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Kestrel是开源的（&lt;/span&gt;&lt;a href=&quot;https://github.com/aspnet/KestrelHttpServer&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;&lt;span&gt;&lt;span&gt;提供的源代码&lt;/span&gt;&lt;span&gt;），事件驱动的异步I / O服务器，用于在任何平台上托管ASP.NET应用程序。&lt;/span&gt;&lt;span&gt;这是一个监听服务器和一个命令行界面。&lt;/span&gt;&lt;span&gt;您将侦听服务器安装在Windows或Linux服务器上，并在计算机上安装命令行界面（安装.netcore会自动一整套安装）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;它是与ASP.NET Core一起由微软推出的。&lt;/span&gt;&lt;span&gt;所有ASP.NET Core应用程序都使用新的MVC框架和Kestrel Web服务器。&lt;/span&gt;&lt;span&gt;这些新的应用程序可以运行在完整的.NET Framework或.NET Core上。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Kestrel Web服务器的概述&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Kestrel被认为是较新的ASP.NET应用程序的首选Web服务器（请参阅这篇文章与IIS比较， &lt;a href=&quot;https://stackify.com/kestrel-web-server-asp-net-core-kestrel-vs-iis/&quot;&gt;why you need both&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;span&gt;它j机遇&lt;a href=&quot;http://blog.dotnetnerd.dk/post/2015/11/08/Kestrel-the-new-web-server-for-ASPNET-5.aspx&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt; libuv library&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，与node.js使用的&lt;/span&gt;&lt;a href=&quot;http://blog.dotnetnerd.dk/post/2015/11/08/Kestrel-the-new-web-server-for-ASPNET-5.aspx&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;库&lt;/span&gt;&lt;/a&gt;&lt;span&gt;相同。&lt;/span&gt;&lt;span&gt;Libuv支持事件驱动的编程风格。&lt;/span&gt;&lt;span&gt;它的一些核心工具包括：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;非阻塞网络支持&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;异步文件系统访问&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;计时器&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;子进程&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;它允许ASP.NET Core应用程序在其他跨平台的Web服务器（如Jexus,Nginx和Apache）上轻松运行，而无需解决不同的启动配置。&lt;/span&gt;&lt;span&gt;通过使用Kestrel作为进程内服务器，&lt;/span&gt;&lt;span&gt; 即使有跨平台支持&lt;/span&gt;&lt;span&gt;，应用程序也将具有一致的处理（&lt;em&gt;Startup (Main()&lt;/em&gt;, &lt;em&gt;Startup.ConfigireServices()&lt;/em&gt;, &lt;em&gt;Startup.Configure())&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;Kestrel Web服务器的工作原理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;应用程序通常是为了响应人的行为而编写的。&lt;/span&gt;&lt;span&gt;使用事件驱动的编程，有一个循环来监听事件。&lt;/span&gt;&lt;span&gt;然后触发一个回调函数。&lt;/span&gt;&lt;span&gt;为了减少SYS调用的数量，所有其他工作都在标准.NET工作线程的托管代码中执行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Kestrel提供了一个事件循环和基于回调的I / O通知。&lt;/span&gt;&lt;span&gt;Libuv管理从操作系统收集和监视事件。&lt;/span&gt;&lt;span&gt;此外，用户可以在事件发生时注册回调。&lt;/span&gt;&lt;span&gt;所以，Kestrel使用libuv进行I / O工作，并支持运行多个事件循环。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于它轻巧，Kestrel不允许你进行SSL termination，URL重写或GZip压缩，但是相同的轻量级设计使他比起其他服务器会更快。&lt;/span&gt;&lt;span&gt;实际上，它比静态和纯文本操作的node.js快6倍。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Kestrel的好处&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Kestrel支持.NET Core支持的所有平台和版本。&lt;/span&gt;&lt;span&gt;此外，它默认包含的ASP.NET Core新项目模板中，可以提供&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://www.codedigest.com/quick-start/5/learn-kestrel-webserver-in-10-minutes&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;更好的请求处理的性能&lt;/a&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;在Visual Studio中创建新项目时，项目会&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://tostring.it/2016/01/12/Using-Kestrel-with-ASPNET-5/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;自动配置&lt;/a&gt;&lt;span&gt;为在Kestrel中运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如前所述，这不是一个功能齐全的网络服务器，但这正是为什么它很快。&lt;/span&gt;&lt;span&gt;如果您觉得需要速度，Kestrel就是答案 - 特别是因为它被设计用于ASP.NETCore的生产。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以做的是在一个功能更全面的网络服务器（如IIS或&lt;/span&gt;&lt;a href=&quot;https://aspnetmonsters.com/2016/07/2016-07-17-nginx/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;NGNIX）&lt;/a&gt;&lt;span&gt;&lt;span&gt;之后运行它&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;您可以使用&lt;/span&gt;&lt;/span&gt;&lt;em&gt;HttpPlatformHandler&lt;/em&gt;&lt;span&gt;&lt;span&gt;在IIS &lt;/span&gt;&lt;span&gt;后面运行它，&lt;/span&gt;&lt;span&gt;或者在&lt;/span&gt;&lt;span&gt;Visual Studio &lt;/span&gt;&lt;span&gt;后面使用&lt;/span&gt;&lt;/span&gt;&lt;em&gt;HttpPlatformHandler&lt;/em&gt;&lt;span&gt;&lt;span&gt;在IIS Express &lt;/span&gt;&lt;span&gt;后面运行它&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;而且，您需要在ASP.NET Core项目中支持它，以便开发人员可以在任何支持的平台上方便地运行它们。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，即使您不是跨平台的，也可以直接从web服务器命令行上运行ASP.NET。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于Kestrel不是一个全功能的Web服务器，您应该让web程序在&lt;/span&gt;&lt;a href=&quot;https://stackify.com/kestrel-web-server-asp-net-core-kestrel-vs-iis/&quot;&gt;在IIS&lt;/a&gt;&lt;span&gt;&lt;span&gt;或NGNIX &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://stackify.com/kestrel-web-server-asp-net-core-kestrel-vs-iis/&quot;&gt;之后运行&lt;/a&gt;（IIS;Jexus或者NGINX代理web程序，提供转发到Kestrel的形式工作）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;它旨在使ASP.NET尽可能快，但其管理安全性和提供静态文件的能力有限。&lt;/span&gt;&lt;span&gt;如果您使用的是Kestrel作为web服务器的ASP.NET Core，则 可以利用 &lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://support.stackify.com/hc/en-us/articles/209962473-Using-Prefix-with-ASP-NET-Core-Kestrel&quot;&gt;Prefix&lt;/a&gt;&lt;span&gt;来实现强大的代码分析功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://stackify.com/what-is-kestrel-web-server/&quot; target=&quot;_blank&quot;&gt;What is Kestrel Web Server? How It Works, Benefits, and More&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;What is Kestrel Web Server? How It Works, Benefits, and More&quot; href=&quot;https://stackify.com/what-is-kestrel-web-server/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 23:35:00 +0000</pubDate>
<dc:creator>Chaunce</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoliangge/p/8387772.html</dc:identifier>
</item>
<item>
<title>04 整合IDEA+Maven+SSM框架的高并发的商品秒杀项目之高并发优化 - nnngu</title>
<link>http://www.cnblogs.com/nnngu/p/8390387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnngu/p/8390387.html</guid>
<description>&lt;p&gt;Github：&lt;a href=&quot;https://github.com/nnngu&quot; class=&quot;uri&quot;&gt;https://github.com/nnngu&lt;/a&gt;&lt;br/&gt;项目源代码：&lt;a href=&quot;https://github.com/nnngu/nguSeckill&quot; class=&quot;uri&quot;&gt;https://github.com/nnngu/nguSeckill&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;关于并发&quot;&gt;关于并发&lt;/h2&gt;
&lt;p&gt;并发性上不去是因为当多个线程同时访问一行数据时，产生了事务，因此产生写锁，当一个获取了事务的线程把锁释放，另一个排队线程才能拿到写锁，QPS(Query Per Second每秒查询率)和事务执行的时间有密切关系，事务执行时间越短，并发性越高，这也是要将费时的 IO 操作移出事务的原因。&lt;/p&gt;
&lt;h3 id=&quot;项目中的高并发发生在哪&quot;&gt;项目中的高并发发生在哪？&lt;/h3&gt;
&lt;p&gt;下图中，红色的部分就表示会发生高并发的地方，绿色部分表示对于高并发没有影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517334205021.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么要单独获取系统时间&quot;&gt;为什么要单独获取系统时间？&lt;/h3&gt;
&lt;p&gt;这是为了我们的秒杀系统的优化做铺垫。比如在秒杀还未开始的时候，用户大量刷新秒杀商品详情页面是很正常的情况，这时候秒杀还未开始，大量的请求发送到服务器会造成不必要的负担。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517334438454.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们将这个详情页放置到CDN中，这样用户在访问该页面时就不需要访问我们的服务器了，起到了降低服务器压力的作用。而CDN中存储的是静态化的详情页和一些静态资源（css，js等），这样我们就拿不到系统的时间来进行秒杀时段的控制，所以我们需要单独设计一个请求来获取我们服务器的系统时间。&lt;/p&gt;
&lt;h3 id=&quot;cdncontent-delivery-network的理解&quot;&gt;CDN（Content Delivery Network）的理解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517334600302.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取系统时间不需要优化&quot;&gt;获取系统时间不需要优化&lt;/h3&gt;
&lt;p&gt;因为Java访问一次内存（Cacheline）大约10ns，1s=10亿ns，也就是如果不考虑GC，这个操作1s可以做1亿次。&lt;/p&gt;
&lt;h3 id=&quot;秒杀地址接口分析&quot;&gt;秒杀地址接口分析&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;无法使用CDN缓存，因为CDN适合请求对应的资源不变化的，比如静态资源、JavaScript；秒杀地址返回的数据是变化的，不适合放在CDN缓存；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;适合服务端缓存：Redis等，1秒钟可以承受10万QPS。多个Redis组成集群，可以到100万个QPS。所以后端缓存可以用业务系统控制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;秒杀地址接口优化&quot;&gt;秒杀地址接口优化&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517334903423.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;秒杀操作优化分析&quot;&gt;秒杀操作优化分析&lt;/h3&gt;
&lt;p&gt;大部分写的操作和核心操作无法使用CDN，也不可能在缓存中减库存。你在Redis中减库存，那么用户也可能通过缓存来减库存，这样库存会不一致，所以要通过mysql的事务来保证一致性。&lt;/p&gt;
&lt;p&gt;比如一个热门商品所有人都在抢，那么会在同一时间对数据表中的一行数据进行大量的&lt;code&gt;update set&lt;/code&gt;操作。&lt;/p&gt;
&lt;p&gt;行级锁在commit之后才释放，所以优化方向是减少行级锁的持有时间。&lt;/p&gt;
&lt;h3 id=&quot;延迟问题很关键&quot;&gt;延迟问题很关键&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;同城机房网络（0.5ms~2ms），最高并发性是1000qps。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;update后JVM -GC(垃圾回收机制)大约50ms，最高并发性是20qps。并发性越高，GC就越可能发生，虽然不一定每次都会发生，但一定会发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;异地机房，比如北京到上海之间的网络延迟，经过计算大概13~20ms。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517335304628.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何判断update更新库存成功&quot;&gt;如何判断update更新库存成功？&lt;/h3&gt;
&lt;p&gt;有两个条件：&lt;/p&gt;
&lt;p&gt;优化思路：把客户端逻辑放到MySQL服务端，避免网络延迟和GC影响&lt;/p&gt;
&lt;h3 id=&quot;如何把客户端逻辑放到mysql服务端&quot;&gt;如何把客户端逻辑放到MySQL服务端&lt;/h3&gt;
&lt;p&gt;有两种方案：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;定制SQL方案，在每次update后都会自动提交，但需要修改MySQL源码，成本很高，不是大公司（BAT等）一般不会使用这种方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用存储过程：整个事务在MySQL端完成，用存储过程写业务逻辑，服务端负责调用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;接下来先分析第一种方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517335653112.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517335681904.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据上图的成本分析，我们的秒杀系统采用第二种方案，即使用存储过程。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;优化总结&quot;&gt;优化总结&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;前端控制。暴露接口，按钮防重复（点击一次按钮后就变成灰色，禁止重复点击按钮）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;动静态数据分离。CDN缓存，后端缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事务竞争优化。减少事务行级锁的持有时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;下载安装redis&quot;&gt;下载安装Redis&lt;/h2&gt;
&lt;p&gt;Redis是一个开源的、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库&lt;/p&gt;
&lt;p&gt;下载安装Redis的步骤，搜索引擎能找到相关的资料，本文不做展开。&lt;/p&gt;
&lt;p&gt;下载安装完Redis之后就可以继续进行操作。&lt;/p&gt;
&lt;h2 id=&quot;使用java操作redis&quot;&gt;使用Java操作Redis&lt;/h2&gt;
&lt;p&gt;Java操作Redis使用的是jedis包。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;pom.xml&lt;/code&gt;添加jedis的依赖，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/30/1517325699734.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加protostuff-core 以及protostuff-runtime 序列化jar包，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/30/1517325829466.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;序列化是处理对象流的机制，就是将对象的内容进行流化，可以对流化后的对象进行读写操作，也可以将流化后的对象在网络间传输。反序列化就是将流化后的对象重新转化成原来的对象。&lt;/p&gt;
&lt;p&gt;在Java中内置了序列化机制，通过implements Serializable来标识一个对象实现了序列化接口，不过其性能并不高。&lt;/p&gt;
&lt;h3 id=&quot;建立操作redis的dao类&quot;&gt;建立操作Redis的dao类&lt;/h3&gt;
&lt;p&gt;原本查询秒杀商品时是通过主键直接去数据库查询的，选择将数据缓存在Redis，在查询秒杀商品时先去Redis缓存中查询，以此降低数据库的压力。如果在缓存中查询不到数据再去数据库中查询，再将查询到的数据放入Redis缓存中，这样下次就可以直接去缓存中直接查询到。&lt;/p&gt;
&lt;p&gt;添加&lt;code&gt;RedisDao.java&lt;/code&gt;文件，位于下图所示的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/30/1517325955175.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RedisDao.java&lt;/code&gt;文件里面的代码请参照项目的源代码。&lt;/p&gt;
&lt;h3 id=&quot;在applicationcontext-dao.xml中注入redisdao&quot;&gt;在applicationContext-dao.xml中注入redisDao&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;applicationContext-dao.xml&lt;/code&gt;中添加下图所示的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/30/1517326483818.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;改造exportseckillurl方法&quot;&gt;改造exportSeckillUrl方法：&lt;/h3&gt;
&lt;p&gt;修改&lt;code&gt;SeckillServiceImpl.java&lt;/code&gt;文件中的&lt;code&gt;exportSeckillUrl&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 在秒杀开启时输出秒杀接口的地址，否则输出系统时间跟秒杀地址&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param seckillId &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;秒杀商品Id&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;根据对应的状态返回对应的状态实体&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Exposer &lt;span class=&quot;fu&quot;&gt;exportSeckillUrl&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; seckillId) {
        
        Seckill seckill = redisDao.&lt;span class=&quot;fu&quot;&gt;getSeckill&lt;/span&gt;(seckillId);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (seckill == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;// 访问数据库读取数据&lt;/span&gt;
            seckill = seckillMapper.&lt;span class=&quot;fu&quot;&gt;queryById&lt;/span&gt;(seckillId);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (seckill == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Exposer&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, seckillId);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;// 放入redis&lt;/span&gt;
                redisDao.&lt;span class=&quot;fu&quot;&gt;putSeckill&lt;/span&gt;(seckill);
            }
        }

        &lt;span class=&quot;co&quot;&gt;// 判断是否还没到秒杀时间或者是过了秒杀时间&lt;/span&gt;
        Date startTime = seckill.&lt;span class=&quot;fu&quot;&gt;getStartTime&lt;/span&gt;();
        Date endTime = seckill.&lt;span class=&quot;fu&quot;&gt;getEndTime&lt;/span&gt;();
        Date nowTime = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date();
        &lt;span class=&quot;co&quot;&gt;// 开始时间大于现在的时候说明没有开始秒杀活动；秒杀活动结束时间小于现在的时间说明秒杀已经结束了&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (nowTime.&lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;() &amp;gt; startTime.&lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;() &amp;amp;&amp;amp; nowTime.&lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;() &amp;lt; endTime.&lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;()) {
            &lt;span class=&quot;co&quot;&gt;//秒杀开启,返回秒杀商品的id,用给接口加密的md5&lt;/span&gt;
            String md5 = &lt;span class=&quot;fu&quot;&gt;getMd5&lt;/span&gt;(seckillId);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Exposer&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;, md5, seckillId);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Exposer&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, seckillId, nowTime.&lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;(), startTime.&lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;(), endTime.&lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;());
        
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;简单的优化&quot;&gt;简单的优化&lt;/h2&gt;
&lt;p&gt;以前的实现流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517337117090.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户的秒杀操作分为两步：减库存、插入购买明细，我们在这里进行简单的优化，就是将原本先update（减库存）再进行insert（插入购买明细）的步骤改成：先insert再update。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517337228818.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么要先insert再update&quot;&gt;为什么要先insert再update&lt;/h3&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先是在更新操作的时候给行加锁，插入并不会加锁，如果更新操作在前，那么就需要执行完更新和插入以后事务提交或回滚才释放锁。而如果插入在前，更新在后，那么只有在更新时才会加行锁，之后在更新完以后事务提交或回滚释放锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在这里，插入是可以并行的，而更新由于会加行级锁是串行的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;也就是说是如果更新在前，加锁和释放锁之间两次的网络延迟和GC，如果更新在后，则加锁和释放锁之间只有一次的网络延迟和GC，也就是减少的持有锁的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;这里先insert并不是忽略了库存不足的情况，而是因为insert和update是在同一个事务里，光是insert并不一定会提交，只有在update成功才会提交，所以并不会造成过量插入秒杀成功记录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;去代码里改造执行秒杀的&lt;code&gt;executeSeckill()&lt;/code&gt;方法，优化性能。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;深度优化使用存储过程&quot;&gt;深度优化（使用存储过程）&lt;/h2&gt;
&lt;p&gt;前边通过调整insert和update的执行顺序来实现简单的优化，但依然存在着Java客户端和服务器通信时的网络延迟和GC影响，我们可以将执行秒杀操作时的insert和update放到MySQL服务端的存储过程里，而Java客户端直接调用这个存储过程，这样就可以避免网络延迟和可能发生的GC影响。另外，由于我们使用了存储过程，也就用不到Spring的事务管理了，因为在存储过程里我们会直接启用一个事务。&lt;/p&gt;
&lt;h3 id=&quot;去mysql的控制台执行储存过程procedure.sql里面的代码&quot;&gt;去MySQL的控制台执行储存过程&lt;code&gt;procedure.sql&lt;/code&gt;里面的代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;去MySQL的控制台执行储存过程&lt;code&gt;procedure.sql&lt;/code&gt;里面的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;procedure.sql&lt;/code&gt;文件位于项目的sql目录下。&lt;/p&gt;
&lt;p&gt;注意点：在存储过程中，row_count() 函数用来返回上一条 sql（delete, insert, update）影响的行数。&lt;/p&gt;
&lt;p&gt;根据row_count() 的返回值，可以进行接下来的流程判断：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;：未修改数据；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;0&lt;/code&gt;：表示修改的行数；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;0&lt;/code&gt;：表示SQL错误或未执行修改SQL&lt;/p&gt;
&lt;h2 id=&quot;修改源码以调用存储过程&quot;&gt;修改源码以调用存储过程&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;SeckillMapper.java&lt;/code&gt;接口中声明&lt;code&gt;killByProcedure()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 使用储存过程执行秒杀&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param paramMap&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;killByProcedure&lt;/span&gt;(Map&amp;lt;String, Object&amp;gt; paramMap);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在&lt;code&gt;SeckillMapper.xml&lt;/code&gt;中写&lt;code&gt;sql&lt;/code&gt;语句，具体代码请参照项目的源代码。&lt;/p&gt;
&lt;p&gt;接着在&lt;code&gt;SeckillService.java&lt;/code&gt;接口中声明 &lt;code&gt;executeSeckillProcedure()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;在pom.xml中添加&lt;code&gt;commons-collections&lt;/code&gt;的依赖，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517328581037.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在&lt;code&gt;SeckillServiceImpl.java&lt;/code&gt;中实现&lt;code&gt;executeSeckillProcedure()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;SeckillServiceImplTest.java&lt;/code&gt;中编写测试方法&lt;code&gt;executeSeckillProcedureTest()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517330110383.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;SeckillController.java&lt;/code&gt;中的&lt;code&gt;execute()&lt;/code&gt;方法，把一开始调用普通方法的改成调用储存过程的方法。&lt;/p&gt;
&lt;h2 id=&quot;存储过程优化总结&quot;&gt;存储过程优化总结&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;存储过程优化：事务行级锁持有的时间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不要过度依赖存储过程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;简单的逻辑依赖存储过程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;QPS:一个秒杀单6000/qps&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;经过简单优化和深度优化之后，本项目大概能达到一个秒杀单6000qps，这个数据对于一个秒杀商品来说其实已经挺ok了，注意这里是指同一个秒杀商品6000qps，如果是不同商品不存在行级锁竞争的问题。&lt;/p&gt;
&lt;h3 id=&quot;系统部署架构&quot;&gt;系统部署架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517339924527.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CDN：放置一些静态化资源，或者可以将动态数据分离。一些js依赖直接用公网的CDN，自己开发的一些页面也做静态化处理推送到CDN。用户在CDN获取到的数据不需要再访问我们的服务器，动静态分离可以降低服务器请求量。比如秒杀详情页，做成HTML放在CDN上，动态数据可以通过ajax请求后台获取。&lt;/p&gt;
&lt;p&gt;Nginx：作为http服务器，响应客户请求，为后端的servlet容器做反向代理，以达到负载均衡的效果。&lt;/p&gt;
&lt;p&gt;Redis：用来做服务器端的缓存，通过Jedis提供的API来达到热点数据的一个快速存取的过程，减少数据库的请求量。&lt;/p&gt;
&lt;p&gt;MySQL：保证秒杀过程的数据一致性与完整性。&lt;/p&gt;
&lt;p&gt;智能DNS解析+智能CDN加速+Nginx并发+Redis缓存+MySQL分库分表，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517340069294.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大型系统部署架构，逻辑集群就是开发的部分。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;Nginx做负载均衡&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;分库分表：在秒杀系统中，一般通过关键的秒杀商品id取模进行分库分表，以512为一张表，1024为一张表。分库分表一般采用开源架构，如阿里巴巴的tddl分库分表框架。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;统计分析：一般使用hadoop等架构进行分析&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这样一个架构中，可能参与的角色如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/31/1517340432690.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，该项目已经全部完成，感谢阅读本文。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 23:29:00 +0000</pubDate>
<dc:creator>nnngu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnngu/p/8390387.html</dc:identifier>
</item>
<item>
<title>如何 Scale Up/Down Deployment？- 每天5分钟玩转 Docker 容器技术（126） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8383356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8383356.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;伸缩（Scale Up/Down）是指在线增加或减少 Pod 的副本数。&lt;br/&gt;Deployment &lt;/span&gt;&lt;code&gt;&lt;span&gt;nginx-deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 初始是两个副本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201801/775365-20180130051445656-818568996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;k8s-node1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;k8s-node2&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 上各跑了一个副本。现在修改 nginx.yml，将副本改成 5 个。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201801/775365-20180130051458000-561984023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;再次执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201801/775365-20180130051510296-711036325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;三个新副本被创建并调度到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;k8s-node1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;k8s-node2&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出于安全考虑，默认配置下 Kubernetes 不会将 Pod 调度到 Master 节点。如果希望将 k8s-master 也当作 Node 使用，可以执行如下命令：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl taint node k8s-master node-role.kubernetes.io/master-&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;如果要恢复 Master Only 状态，执行如下命令：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl taint node k8s-master node-role.kubernetes.io/master=&quot;&quot;:NoSchedule&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来修改配置文件，将副本数减少为 3 个，重新执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201801/775365-20180130051523000-549230282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到两个副本被删除，最终保留了 3 个副本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一节我们学习 Deployment 的 Failover。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 22:26:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8383356.html</dc:identifier>
</item>
<item>
<title>我的2017——求职篇（三） - codingHeart</title>
<link>http://www.cnblogs.com/codingHeart/p/8370502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingHeart/p/8370502.html</guid>
<description>&lt;p&gt;　　这两天深圳变得好冷，晚上打字手都有点僵僵的。接着上篇继续：&lt;/p&gt;
&lt;p&gt;　　从上家公司面试完出来的时候，已经1点多了，约好的下午四点的面试感觉过去时间很紧，于是饭都没吃，买了瓶营养快线还是啥的就开始朝那边赶了，到那边的时候又找了半小时才找到，迟到了十几分钟，然而，老板也迟到了。对，老板亲自联系我和面试我，感觉我面试遇到的事情总有点不对劲。这个公司位置还挺好的就在地铁旁边，一栋两层楼的写字楼（不知道算不算），公司在二楼，一进门，小姑凉小伙子的，都很有活力，也有点“疯”，可能是因为老板不在吧....。这个前台比之前那个就要热情不少了，奔奔跳跳，手舞足蹈，满天桃花，没看到我之前各个同事间 勾肩搭背 的闹，我一时间都快以为我回到了学校的班里。&lt;/p&gt;
&lt;p&gt;　　前台看到我了 还是蹦跶过来的，盯着我心跳加速，脸都要红了，额，回正题，当然，我说明来意后，还是拿着一套题带我进小黑屋。当我拿到那一页题的时候，会心的一笑，感觉这家公司的格调倒是挺高，几乎全是bat的一些前端面试题，就没多久之前闲得没事儿时  我有看了些bat前端笔试题，没想到啊，居然在这里用上了，说实话，如果那张题目满分100，我觉得我80分应该是有的（然而并没什么卵用，尽是纸上谈兵）。&lt;/p&gt;
&lt;p&gt;　　很快，就做完了，交了题目后，他们老大还是没来。于是让我在一边坐着等，我有点坐不住了就在他们办公室随便逛，这一逛不得了，直接让我有想走的冲动！当我看到他们在墙上贴的规章制度，简直怀疑人生的，什么迟到几分钟就要在群里发多少的红包，超过多久又要罚钱到公司的组织经费什么的用于聚餐，出游啥的，还有什么打扫卫生，拖地，关灯关门 乱七八糟的一堆。&lt;/p&gt;
&lt;p&gt;　　正当我看得入迷的时候，好像他们老板来不了还是怎么，就派了个开发人员过来面我，他们公司用vue的，问我熟不熟，实话实说，不太熟，也没有做过实际项目，感觉是直接把天聊死了。。。然后，他接着介绍，公司是做邮件服务这一块儿的，我就搭了句，之前有做过邮件相关的功能模块。后面继续简单的了解下我的项目经验，重点又转回前端，毕竟没搞过前端工程相关的东西，所以当时也能感觉到有心无力，这种上来就要人能干实事儿的小公司，我心里知道希望应该是很小的，但既然来了，就当面试练习吧，我能接上话的时候也会很积极的与他交流，自己感觉面试效果很差。也不知道是不是他客套话，最后的时候也不忘问我的期望薪资，我当时可能是太膨胀了，心里想已经有个差不多8.5k的offer了，就说了个9k（这样确实有点不好，主要是多数情况下会搞得对方有点尴尬）。他好像也没太吃惊（看样子见过世面了，哈哈），说了句，这个我得回头跟老板谈谈。&lt;/p&gt;
&lt;p&gt;　　面试结束，我就准备打道回府了。&lt;/p&gt;
&lt;p&gt;　　也不知道为什么，虽然他们的制度让人很哭笑不得，但当我出他们办公室路过这群小菇凉小伙子，再看到她们在外面出游时拍的各种疯的照片墙的时候，心里又不自觉的感觉其实这样也挺不错的。以至于我离开前 都不忘再回头看两眼 这 有烟火的地方。&lt;/p&gt;
&lt;p&gt;　　然而我已不再是少年，烟火留给她们吧，我现在更需要硝烟，于是从容的离开了。&lt;/p&gt;
&lt;p&gt;　　回去的路上，其实我还在想8.5k的那个offer怎么处理，没办法，有时候人就是这么贪婪，我也好无奈。其实我是打算花个一个月来这边找工作的，现在才刚过10多天，其实不是很急，就当我在地铁里正思绪万千的时候，电话来了，上午那家公司的hr打来的，一个迄今为止，我见过的最热心的人（是的，可能比我的亲人还要热心），她先表示了下歉意，说自己有事情之前没在公司，然后表示想约我谈谈 这份工作 的事儿，我正准备说时间的时候，她接着说道：“我看你那边过来公司也有点远，我们就直接在电话里谈吧”。我当然觉得舒服，最不喜欢早起坐车了...。后面要进一步谈的时候呢，因为是在地铁里，很嘈杂，信号好像也不是很好，有时候会听不清，中间说着的时候，地铁到了一站，她应该是有听到播音的声音，然后问我是在坐地铁吗，我说是的。于是她便建议 ：要不你到家了 方便的时候再聊?。&lt;/p&gt;
&lt;p&gt;　　之后我一时间也不知道都要问些什么，就直接加微信聊了，她表示8.5k的薪资没问题，转正给9k。这时候 我对她的印象可以说已经非常好了（我也是个见钱眼开的人啊），毕竟 hr 不压已经够可以了，象征性的加500已经很不错了。她怕我有顾虑，接着又给我说，加上补贴什么的大约有个10k，表现好的话 还可以调薪，有些同事不到一年就加薪2，3k了。这几剂强心针打下来，我感觉我都快不行了。。。10k，在我还读大学的时候，曾经是想毕业后用三年来实现的目标呐。幸福来得。。这么快么。&lt;/p&gt;
&lt;p&gt;　　“有什么要问的，只要我知道 就回答你”她继续说道。&lt;/p&gt;
&lt;p&gt;　　因为五险一金什么的 招聘信息上有 ，我就没再多问了，开始询问附近租房子的事儿，为此她后面还问了不少同事，自己也顺便在附近帮我拍了几张租房子的信息。我表示感谢，她倒觉得这些是自己理所当然该做的，没什么。给人感觉真是不一般的好啊。既然公司有这样的人，那公司应该也差不到哪儿去了，这是我的第一想法。即便做到这份上了，她在询问我意向的时候 依旧很尊重我：“你自己好好考虑了 再做决定”。&lt;/p&gt;
&lt;p&gt;　　我这个人有个喜欢拖延的毛病，所以她这不急的语气，弄得我也很淡定了，一直没急着回复。&lt;/p&gt;
&lt;p&gt;　　于是，第四次面试悄然来临，那之后我是开始真的有深刻体会到，大千世界，无奇不有，芸芸码农，各择其主。不禁想起李斯列传里的话：人之贤不肖譬如鼠矣，在所自处耳。&lt;/p&gt;
&lt;p&gt;　　待续。。。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 18:17:00 +0000</pubDate>
<dc:creator>codingHeart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingHeart/p/8370502.html</dc:identifier>
</item>
<item>
<title>安卓开发-intent在Activity之间数据传递 - 环家伟</title>
<link>http://www.cnblogs.com/hjw1/p/8386881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hjw1/p/8386881.html</guid>
<description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;intent实现普通跳转&quot;&gt;intent实现普通跳转&lt;/h2&gt;
&lt;p&gt;使用intent的setclass方法，示例（由此界面跳转到NewActivity界面）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        &lt;span class=&quot;co&quot;&gt;//使用setOnClickListener方法设置点击事件&lt;/span&gt;
        Button button=(Button)&lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;mainButton&lt;/span&gt;);
        button.&lt;span class=&quot;fu&quot;&gt;setOnClickListener&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;OnClickListener&lt;/span&gt;()
            {

                &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onClick&lt;/span&gt;(View p1)
                {
                    Intent intent=&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Intent&lt;/span&gt;();
                    intent.&lt;span class=&quot;fu&quot;&gt;setClass&lt;/span&gt;(MainActivity.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;,NewActivity.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
                    &lt;span class=&quot;co&quot;&gt;//新建一个Intent，使用setClass方法设置跳转的哪个界面&lt;/span&gt;
                    &lt;span class=&quot;fu&quot;&gt;startActivity&lt;/span&gt;(intent);
                }
                
            
        });&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;使用bundle传递数据的跳转&quot;&gt;使用Bundle传递数据的跳转&lt;/h2&gt;
&lt;h3 id=&quot;bundle类&quot;&gt;Bundle类&lt;/h3&gt;
&lt;p&gt;Bundle类用来携带数据，类似于map。里面存放键值对。Bundle类有putXXX()/getXXX()方法，如&lt;code&gt;putInt()&lt;/code&gt;,&lt;code&gt;getInt()&lt;/code&gt;,&lt;code&gt;putString()&lt;/code&gt;,&lt;code&gt;getString()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;putXXX()用来往Bundle对象存入数据。&lt;/p&gt;
&lt;p&gt;getXXX()用来从Bundle对象取出数据。&lt;/p&gt;
&lt;p&gt;其内部使用了&lt;code&gt;HashMap&amp;lt;String,Object&amp;gt;&lt;/code&gt;类型的变量存储数据。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;
&lt;p&gt;如下代码实现将数据从当前Activity传递到另一个Activity：&lt;/p&gt;
&lt;p&gt;(当前Activity)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        Button button=(Button)&lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;button&lt;/span&gt;);
        button.&lt;span class=&quot;fu&quot;&gt;setOnClickListener&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; View.&lt;span class=&quot;fu&quot;&gt;OnClickListener&lt;/span&gt;() {
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onClick&lt;/span&gt;(View v) {
                Bundle data=&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Bundle&lt;/span&gt;();
                &lt;span class=&quot;co&quot;&gt;//创建了一个Bundle对象用来存储在两个Activity之间传递的数据&lt;/span&gt;
                data.&lt;span class=&quot;fu&quot;&gt;putString&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;website&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;cnblogs.com/hjw1&quot;&lt;/span&gt;);
                data.&lt;span class=&quot;fu&quot;&gt;putString&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;环家伟&quot;&lt;/span&gt;);
                data.&lt;span class=&quot;fu&quot;&gt;putInt&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;age&quot;&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;);
                &lt;span class=&quot;co&quot;&gt;//添加进Bundle对象里面两个String类型的数据和一个int类型的数据&lt;/span&gt;
                Intent gotoAnother=&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Intent&lt;/span&gt;(MainActivity.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;,Main2Activity.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
                &lt;span class=&quot;co&quot;&gt;//创建了一个从MainActivity跳转到Main2Activity的Intent&lt;/span&gt;
                gotoAnother.&lt;span class=&quot;fu&quot;&gt;putExtras&lt;/span&gt;(data);
                &lt;span class=&quot;co&quot;&gt;//将存储了数据的Bundle对象put进Intent里面&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;startActivity&lt;/span&gt;(gotoAnother);
                &lt;span class=&quot;co&quot;&gt;//开始跳转&lt;/span&gt;
            }
        });&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(目标Activity)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(Bundle savedInstanceState) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(savedInstanceState);
        &lt;span class=&quot;fu&quot;&gt;setContentView&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;layout&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;activity_main2&lt;/span&gt;);
        Bundle receive=&lt;span class=&quot;fu&quot;&gt;getIntent&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getExtras&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//得到随Intent传递过来的Bundle对象&lt;/span&gt;
        String name=receive.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;);
        String website=receive.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;website&quot;&lt;/span&gt;);
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; age=receive.&lt;span class=&quot;fu&quot;&gt;getInt&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;age&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;//根据设定的String关键词得到对应的数据。&lt;/span&gt;
        ((TextView)&lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;姓名：&quot;&lt;/span&gt;+name);
        ((TextView)&lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;age&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;年龄：&quot;&lt;/span&gt;+age);
        ((TextView)&lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;website&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;博客地址：&quot;&lt;/span&gt;+website);
        &lt;span class=&quot;co&quot;&gt;//将数据显示到TextView上面&lt;/span&gt;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;姓名：环家伟
年龄：20
博客地址：cnblogs.com/hjw1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;直接使用intent传递数据&quot;&gt;直接使用Intent传递数据&lt;/h2&gt;
&lt;p&gt;Intent自身也有一系列的&lt;code&gt;putExtra()&lt;/code&gt;函数。( 这里与上面的&lt;code&gt;putExtras()&lt;/code&gt;函数区分开，这里没有s )&lt;br/&gt;这个函数有很多重载，如&lt;code&gt;putExtra(String name,String value)&lt;/code&gt;,&lt;code&gt;putExtra(String name,int value)&lt;/code&gt;等。&lt;br/&gt;与上面的Bundle类操作方法相似，都是String-value键值对。&lt;br/&gt;接收时，Intent对象有&lt;code&gt;getXXXExtra()&lt;/code&gt;一系列函数得到传递过来的数据,如&lt;code&gt;getStringExtra()&lt;/code&gt;等。&lt;/p&gt;
&lt;h3 id=&quot;示例-1&quot;&gt;示例：&lt;/h3&gt;
&lt;p&gt;(当前Activity)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;                Intent gotoAnother=&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Intent&lt;/span&gt;(MainActivity.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;,Main2Activity.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
                &lt;span class=&quot;co&quot;&gt;//创建了一个从MainActivity跳转到Main2Activity的Intent&lt;/span&gt;
                gotoAnother.&lt;span class=&quot;fu&quot;&gt;putExtra&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;环家伟&quot;&lt;/span&gt;);
                gotoAnother.&lt;span class=&quot;fu&quot;&gt;putExtra&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;age&quot;&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;);
                gotoAnother.&lt;span class=&quot;fu&quot;&gt;putExtra&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;website&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;cnblogs.com/hjw1&quot;&lt;/span&gt;);
                &lt;span class=&quot;co&quot;&gt;//将数据put进Intent里面&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;startActivity&lt;/span&gt;(gotoAnother);
                &lt;span class=&quot;co&quot;&gt;//开始跳转&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(目标Activity)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(Bundle savedInstanceState) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(savedInstanceState);
        &lt;span class=&quot;fu&quot;&gt;setContentView&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;layout&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;activity_main2&lt;/span&gt;);
        Intent receiveIntent=&lt;span class=&quot;fu&quot;&gt;getIntent&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//得到Intent&lt;/span&gt;
        String name=receiveIntent.&lt;span class=&quot;fu&quot;&gt;getStringExtra&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;);
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; age=receiveIntent.&lt;span class=&quot;fu&quot;&gt;getIntExtra&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;age&quot;&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
        String website=receiveIntent.&lt;span class=&quot;fu&quot;&gt;getStringExtra&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;website&quot;&lt;/span&gt;);
        ((TextView)&lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;姓名：&quot;&lt;/span&gt;+name);
        ((TextView)&lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;age&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;年龄：&quot;&lt;/span&gt;+age);
        ((TextView)&lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;website&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;博客地址：&quot;&lt;/span&gt;+website);
        &lt;span class=&quot;co&quot;&gt;//将数据显示到TextView上面&lt;/span&gt;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;姓名：环家伟
年龄：20
博客地址：cnblogs.com/hjw1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;得到新activity关闭后的数据&quot;&gt;得到新Activity关闭后的数据&lt;/h2&gt;
&lt;p&gt;想象一下，你要做一个图像处理的app。你在当前actuvity点击了一个按钮，然后出现图片列表，选择图片后原activity要得到图片。这种情况在Windows里面经常出现，点击按钮打开文件管理器选择文件。&lt;/p&gt;
&lt;p&gt;要想得到新Activity关闭后传过来的数据，只要在打开新Activity的跳转时使用&lt;code&gt;startActivityForResult(Intent intent,int requestCode)&lt;/code&gt; 函数，而不是以前的&lt;code&gt;startActivity()&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;这样打开的Activity在关闭后会传回数据。&lt;/p&gt;
&lt;p&gt;为了得到传回的数据，需要在前面的Activity里面重写&lt;code&gt;onActivityResult(int requestCode,int resultCode,Intent data)&lt;/code&gt;函数。&lt;/p&gt;
&lt;h3 id=&quot;示例-2&quot;&gt;示例&lt;/h3&gt;
&lt;p&gt;实现点击按钮&lt;code&gt;得到字符串时&lt;/code&gt;，打开新界面，点击按钮关闭新界面后，Toast显示&lt;code&gt;环家伟&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而点击按钮&lt;code&gt;得到整数&lt;/code&gt;时，Toast内容为&lt;code&gt;20&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        Button stringButton=(Button)&lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;stringButton&lt;/span&gt;);
        stringButton.&lt;span class=&quot;fu&quot;&gt;setOnClickListener&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; View.&lt;span class=&quot;fu&quot;&gt;OnClickListener&lt;/span&gt;() {
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onClick&lt;/span&gt;(View v) {
                Intent gotoAnother=&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Intent&lt;/span&gt;(MainActivity.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;,Main2Activity.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
                &lt;span class=&quot;fu&quot;&gt;startActivityForResult&lt;/span&gt;(gotoAnother,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
                &lt;span class=&quot;co&quot;&gt;//第二个参数是请求码，比如此Activity有两个按钮都是启动同一个新Activity&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;//请求码就是用来区分到底是哪个按钮请求的&lt;/span&gt;
            }
        });
        Button intButton=(Button)&lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;intButton&lt;/span&gt;);
        intButton.&lt;span class=&quot;fu&quot;&gt;setOnClickListener&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; View.&lt;span class=&quot;fu&quot;&gt;OnClickListener&lt;/span&gt;() {
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onClick&lt;/span&gt;(View v) {
                Intent gotoAnother=&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Intent&lt;/span&gt;(MainActivity.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;,Main2Activity.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
                &lt;span class=&quot;fu&quot;&gt;startActivityForResult&lt;/span&gt;(gotoAnother,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;);
                &lt;span class=&quot;co&quot;&gt;//此处请求码是2&lt;/span&gt;
            }
        });&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重写onActivityResult方法用来接收传过来的信息&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onActivityResult&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; requestCode, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; resultCode, Intent data) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onActivityResult&lt;/span&gt;(requestCode, resultCode, data);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(requestCode==&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            Toast.&lt;span class=&quot;fu&quot;&gt;makeText&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;按钮1得到字符串：&quot;&lt;/span&gt;+data.&lt;span class=&quot;fu&quot;&gt;getStringExtra&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;),Toast.&lt;span class=&quot;fu&quot;&gt;LENGTH_SHORT&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;show&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(requestCode==&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
            Toast.&lt;span class=&quot;fu&quot;&gt;makeText&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;按钮2得到整数：&quot;&lt;/span&gt;+data.&lt;span class=&quot;fu&quot;&gt;getIntExtra&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;age&quot;&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;),Toast.&lt;span class=&quot;fu&quot;&gt;LENGTH_SHORT&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;show&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//此处的requestCode就是startActivityForResult里面传递的requestCode&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 可以用来区分是哪个按钮请求的&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        提示：Toast不要忘记show()&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新Activity中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        Button closeButton=(Button)&lt;span class=&quot;fu&quot;&gt;findViewById&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;);
        closeButton.&lt;span class=&quot;fu&quot;&gt;setOnClickListener&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; View.&lt;span class=&quot;fu&quot;&gt;OnClickListener&lt;/span&gt;() {
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onClick&lt;/span&gt;(View v) {
                Intent intent=&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Intent&lt;/span&gt;();&lt;span class=&quot;co&quot;&gt;//数据通过Intent返回&lt;/span&gt;
                intent.&lt;span class=&quot;fu&quot;&gt;putExtra&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;环家伟&quot;&lt;/span&gt;);
                intent.&lt;span class=&quot;fu&quot;&gt;putExtra&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;age&quot;&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;);
                Main2Activity.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;setResult&lt;/span&gt;(RESULT_OK,intent);
                &lt;span class=&quot;co&quot;&gt;//RESULT_OK是一个整数，此参数是结果码，可以用来区分是哪个Activity返回的数据&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;//（如果原Activity可以打开多个新Activity）&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;finish&lt;/span&gt;();&lt;span class=&quot;co&quot;&gt;//关闭新Activity&lt;/span&gt;
            }
        });&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 30 Jan 2018 17:36:00 +0000</pubDate>
<dc:creator>环家伟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hjw1/p/8386881.html</dc:identifier>
</item>
<item>
<title>原生 JS 实现一个瀑布流插件 - 牧云云</title>
<link>http://www.cnblogs.com/MuYunyun/p/8388250.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MuYunyun/p/8388250.html</guid>
<description>&lt;blockquote readability=&quot;3.6046511627907&quot;&gt;
&lt;p&gt;更好的阅读体验，点击 &lt;a href=&quot;http://muyunyun.cn/posts/16b9cce7/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;瀑布流布局中的图片有一个核心特点 —— 等宽不定等高，瀑布流布局在国内网网站都有一定规模的使用，比如&lt;a href=&quot;https://www.pinterest.com/&quot;&gt;pinterest&lt;/a&gt;、&lt;a href=&quot;http://huaban.com/&quot;&gt;花瓣网&lt;/a&gt;等等。那么接下来就基于这个特点开始瀑布流探索之旅。&lt;/p&gt;
&lt;h3 id=&quot;基础功能实现&quot;&gt;基础功能实现&lt;/h3&gt;
&lt;p&gt;首先我们定义好一个有 20 张图片的容器，&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;fl&quot;&gt;#waterfall&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;fl&quot;&gt;.waterfall-box&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;float:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;waterfall&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;images/1.png&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;waterfall-box&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;images/2.png&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;waterfall-box&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;images/3.png&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;waterfall-box&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;images/4.png&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;waterfall-box&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;images/5.png&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;waterfall-box&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;images/6.png&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;waterfall-box&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    ...
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;embed src=&quot;http://oqhtscus0.bkt.clouddn.com/88935550542f9cc012151460095d9579.jpg-300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于未知的 css 知识点，丝袜最长的妹子把下面的空间都占用掉了。。。&lt;/p&gt;
&lt;p&gt;接着正文，假如如上图，每排有 5 列，那第 6 张图片应该出现前 5 张图片哪张的下面呢？当然是绝对定位到前 5 张图片高度最小的图片下方。&lt;/p&gt;
&lt;p&gt;那第 7 张图片呢？这时候把第 6 张图片和在它上面的图片当作是一个整体后，思路和上述是一致的。代码实现如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;Waterfall&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  ...
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; perNum &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getPerNum&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;// 获取每排图片数&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; perList &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []              &lt;span class=&quot;co&quot;&gt;// 存储第一列的各图片的高度&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; perNum&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;perList&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(imgList[i].&lt;span class=&quot;at&quot;&gt;offsetHeight&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; pointer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getMinPointer&lt;/span&gt;(perList) &lt;span class=&quot;co&quot;&gt;// 求出当前最小高度的数组下标&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; perNum&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;imgList&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    imgList[i].&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'absolute'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 核心语句&lt;/span&gt;
    imgList[i].&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;imgList[pointer].&lt;span class=&quot;at&quot;&gt;offsetLeft&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;px`&lt;/span&gt;
    imgList[i].&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;top&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;perList[pointer]&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;px`&lt;/span&gt;

    perList[pointer] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; perList[pointer] &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; imgList[i].&lt;span class=&quot;at&quot;&gt;offsetHeight&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 数组最小的值加上相应图片的高度&lt;/span&gt;
    pointer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getMinPointer&lt;/span&gt;(perList)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;细心的朋友也许发现了代码中获取图片的高度用到了 &lt;code&gt;offsetHeight&lt;/code&gt; 这个属性，这个属性的高度之和等于&lt;code&gt;图片高度 + 内边距 + 边框&lt;/code&gt;，正因为此，我们用了 padding 而不是 margin 来设置图片与图片之间的距离。此外除了&lt;code&gt;offsetHeight&lt;/code&gt; 属性，此外还要理解 &lt;code&gt;offsetHeight&lt;/code&gt;、&lt;code&gt;clientHeight&lt;/code&gt;、&lt;code&gt;offsetTop&lt;/code&gt;、&lt;code&gt;scrollTop&lt;/code&gt; 等属性的区别，才能比较好的理解这个项目。css 代码简单如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.waterfall-box&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;float:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;padding-left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;padding-bottom:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此完成了瀑布流的基本布局，效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://oqhtscus0.bkt.clouddn.com/74f00b858ebdc430e780aa1da6ca0ce1.jpg-300&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;scrollresize-事件监听的实现&quot;&gt;scroll、resize 事件监听的实现&lt;/h3&gt;
&lt;p&gt;实现了初始化函数 init 以后，下一步就要实现对 scroll 滚动事件进行监听，从而实现当滚到父节点的底部有源源不断的图片被加载出来的效果。这时候要考虑一个点，是滚动到什么位置时触发加载函数呢？这个因人而异，我的做法是当满足 &lt;code&gt;父容器高度 + 滚动距离 &amp;gt; 最后一张图片的 offsetTop&lt;/code&gt; 这个条件，即橙色线条 + 紫色线条 &amp;gt; 蓝色线条时触发加载函数，代码如下：&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://oqhtscus0.bkt.clouddn.com/c8cda4bb070a7739eeec0fc968e91a1b.jpg-300&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onscroll&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (scrollPX &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; bsHeight &lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; imgList[&lt;span class=&quot;va&quot;&gt;imgList&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].&lt;span class=&quot;at&quot;&gt;offsetTop&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;// 浏览器高度 + 滚动距离 &amp;gt; 最后一张图片的 offsetTop&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; fragment &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createDocumentFragment&lt;/span&gt;()
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; img &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'img'&lt;/span&gt;)
      &lt;span class=&quot;va&quot;&gt;img&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'src'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;`images/&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;.png`&lt;/span&gt;)
      &lt;span class=&quot;va&quot;&gt;img&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'class'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'waterfall-box'&lt;/span&gt;)
      &lt;span class=&quot;va&quot;&gt;fragment&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;appendChild&lt;/span&gt;(img)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;$waterfall&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;appendChild&lt;/span&gt;(fragment)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为父节点可能自定义节点，所以提供了对监听 scroll 函数的封装，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;  &lt;span class=&quot;va&quot;&gt;proto&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bind&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; bindScrollElem &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;opts&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;scrollElem&lt;/span&gt;)
    &lt;span class=&quot;va&quot;&gt;util&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addEventListener&lt;/span&gt;(bindScrollElem &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; window&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'scroll'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;scroll&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;))
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; util &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (elem&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; evName&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; func) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;elem&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addEventListener&lt;/span&gt;(evName&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; func&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;resize 事件的监听与 scroll 事件监听大同小异，当触发了 resize 函数，调用 init 函数进行重置就行。&lt;/p&gt;
&lt;h3 id=&quot;使用发布-订阅模式和继承实现监听绑定&quot;&gt;使用发布-订阅模式和继承实现监听绑定&lt;/h3&gt;
&lt;p&gt;既然以开发插件为目标，不能仅仅满足于功能的实现，还要留出相应的操作空间给开发者自行处理。联想到业务场景中瀑布流中下拉加载的图片一般都来自 Ajax 异步获取，那么加载的数据必然不能写死在库里，期望能实现如下调用(此处借鉴了 &lt;a href=&quot;https://github.com/mqyqingfeng/waterfall&quot;&gt;waterfall&lt;/a&gt; 的使用方式)，&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; waterfall &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Waterfall&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;options&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

&lt;span class=&quot;va&quot;&gt;waterfall&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;load&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 此处进行 ajax 同步/异步添加图片&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;观察调用方式，不难联想到使用发布/订阅模式来实现它，关于发布/订阅模式，之前在 &lt;a href=&quot;https://github.com/MuYunyun/fe_cloud/issues/7&quot;&gt;Node.js 异步异闻录&lt;/a&gt; 有介绍它。其核心思想即通过订阅函数将函数添加到缓存中，然后通过发布函数实现异步调用，下面给出其代码实现:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;eventEmitter&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;eventEmitter&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (eventName&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; func) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 订阅函数&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;sub&lt;/span&gt;[eventName]) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;sub&lt;/span&gt;[eventName] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;sub&lt;/span&gt;[eventName].&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(func) &lt;span class=&quot;co&quot;&gt;// 添加事件监听器&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;eventEmitter&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (eventName) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 发布函数&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; argsList &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;slice&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;call&lt;/span&gt;(arguments&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
  &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; length &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;sub&lt;/span&gt;[eventName].&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; length&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;sub&lt;/span&gt;[eventName][i].&lt;span class=&quot;at&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; argsList) &lt;span class=&quot;co&quot;&gt;// 调用事件监听器&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着，要让 Waterfall 能使用发布/订阅模式，只需让 Waterfall 继承 eventEmitter 函数，代码实现如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Waterfall&lt;/span&gt;(options &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;eventEmitter&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;init&lt;/span&gt;(options) &lt;span class=&quot;co&quot;&gt;// 这个 this 是 new 的时候，绑上去的&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;Waterfall&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;eventEmitter&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;Waterfall&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Waterfall&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继承方式的写法吸收了基于构造函数继承和基于原型链继承两种写法的优点，以及使用 &lt;code&gt;Object.create&lt;/code&gt; 隔离了子类和父类，关于继承更多方面的细节，可以另写一篇文章了，此处点到为止。&lt;/p&gt;
&lt;h3 id=&quot;小优化&quot;&gt;小优化&lt;/h3&gt;
&lt;p&gt;为了防止 scroll 事件触发多次加载图片，可以考虑用函数防抖与节流实现。在基于发布-订阅模式的基础上，定义了个 isLoading 参数表示是否在加载中，并根据其布尔值决定是否加载，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; isLoading &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; scroll &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (isLoading) &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 避免一次触发事件多次&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (scrollPX &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; bsHeight &lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; imgList[&lt;span class=&quot;va&quot;&gt;imgList&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].&lt;span class=&quot;at&quot;&gt;offsetTop&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 浏览器高度 + 滚动距离 &amp;gt; 最后一张图片的 offsetTop&lt;/span&gt;
    isLoading &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'load'&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;proto&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'done'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    isLoading &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;
    ...
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'done'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候需要在调用的地方加上 &lt;code&gt;waterfall.done&lt;/code&gt;, 从而告知当前图片已经加载完毕，代码如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; waterfall &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Waterfall&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;waterfall&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;load&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 异步/同步加载图片&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;waterfall&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;done&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;项目地址&quot;&gt;项目地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MuYunyun/waterfall&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MuYunyun/reactSPA/blob/master/src/common/pages/waterfall/index.js&quot;&gt;此插件在 React 项目中的运用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目简陋，不足之处在所难免，欢迎留下你们宝贵的意见。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 16:49:00 +0000</pubDate>
<dc:creator>牧云云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MuYunyun/p/8388250.html</dc:identifier>
</item>
<item>
<title>Python实现一个简单的微信跳一跳辅助 - Pleiades</title>
<link>http://www.cnblogs.com/pleiades/p/8387934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pleiades/p/8387934.html</guid>
<description>&lt;h2&gt;1.  前言&lt;/h2&gt;
&lt;p&gt;微信的跳一跳相信大家都很熟悉了，而且现在各种外挂、辅助也是满天飞，反正本人的好友排行榜中已经是八九百都不足为奇了。某宝上一搜一堆结果，最低的居然只要3块多，想刷多少分就刷多少分，真是离谱。&lt;/p&gt;
&lt;p&gt;作为一枚程序猿，我决心也自己搞一下，不为别的，一来为了磨练一下自己的解决问题的能力，而来也为了娱乐一下。像这种任务，最适合的当然是Python，丰富的第三方库，而且具有胶水语言的特点。&lt;/p&gt;
&lt;p&gt;本程序的主要设计思路就是，PC端adb连接手机→截屏→在PC端展示→用户鼠标选取起点和终点→计算距离、时长→adb发送指令模拟按压→截屏循环。&lt;/p&gt;
&lt;h2&gt;2.  ADB&lt;/h2&gt;
&lt;p&gt;adb，Android Debug Bridge，即安卓调试桥，包含如下几个部分:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Client端, 运行在开发机器中，即你的开发PC机，用来发送adb命令&lt;/li&gt;
&lt;li&gt;Deamon守护进程，运行在调试设备中，即的调试手机或模拟器&lt;/li&gt;
&lt;li&gt;Server端，作为一个后台进程运行在开发机器中，即你的开发PC机，用来管理PC中的Client端和手机的Deamon之间的通信&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们通常用的adb命令指的就是Client端程序。Server端实际上在本机侦听端口5037，将指令通过usb线/wifi转发给移动设备的Deamon进程。&lt;/p&gt;
&lt;p&gt;adb命令读者可以去官方网站查看文档（http://adbshell.com/commands），这里只介绍用到的几个命令。&lt;/p&gt;
&lt;p&gt;(1)    adb devices列出所有连接的模拟器/设备&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Prints a list of all attached emulator/device&lt;/p&gt;
&lt;p&gt;adb devices&lt;/p&gt;
&lt;p&gt;In response, return serial number and state&lt;/p&gt;
&lt;p&gt;e4b25377        device&lt;/p&gt;
&lt;p&gt;emulator-5554  device&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(2)    adb shell screencap截屏&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;taking a screenshot of a device display.&lt;/p&gt;
&lt;p&gt;adb shell screencap &amp;lt;filename&amp;gt;&lt;/p&gt;
&lt;p&gt;adb shell screencap /sdcard/screen.png&lt;/p&gt;
&lt;p&gt;download the file from the device将文件从设备下载到本机。&lt;/p&gt;
&lt;p&gt;adb pull /sdcard/screen.png&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(3)    adb shell input swipe模拟滑动操作（长按）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;adb shell input swipe 100 100 100 100 500模拟长按坐标(100, 100)时长500ms&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    C:\Documents and Settings\Administrator&amp;gt;&lt;span&gt;adb shell  
    root&lt;/span&gt;@NX403A:/ &lt;span&gt;#&lt;/span&gt;&lt;span&gt; input  &lt;/span&gt;
&lt;span&gt;    input  
    Usage: input [&amp;lt;source&lt;/span&gt;&amp;gt;] &amp;lt;command&amp;gt; [&amp;lt;arg&amp;gt;&lt;span&gt;...]  
      
    The sources are:  
          trackball  
          joystick  
          touchnavigation  
          mouse  
          keyboard  
          gamepad  
          touchpad  
          dpad  
          stylus  
          touchscreen  
      
    The commands and &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; sources are:  
          text &amp;lt;string&lt;/span&gt;&amp;gt; (&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;: touchscreen)  
          keyevent [&lt;/span&gt;--longpress] &amp;lt;key code number or name&amp;gt; ... (&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;: keyboard)  
          tap &amp;lt;x&lt;/span&gt;&amp;gt; &amp;lt;y&amp;gt; (&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;: touchscreen)  
          swipe &amp;lt;x1&lt;/span&gt;&amp;gt; &amp;lt;y1&amp;gt; &amp;lt;x2&amp;gt; &amp;lt;y2&amp;gt; [duration(ms)] (&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;: touchscreen)  
          press (&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;: trackball)  
          roll &amp;lt;dx&lt;/span&gt;&amp;gt; &amp;lt;dy&amp;gt; (&lt;span&gt;Default&lt;/span&gt;: trackball)  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，以上是本次所需adb的知识点。&lt;/p&gt;
&lt;h2&gt;3.  Python&lt;/h2&gt;
&lt;p&gt;（1）     调用命令行&lt;/p&gt;
&lt;p&gt;Python调用命令行有多种方式，比较常用的是os.system(cmd)和os.popen(cmd)，以及commands.getoutput(cmd)，这三者主要区别在返回值的获取方面，第一个无法获得返回值，第二、三个则可以获取。这里用哪个都可以，因为不需要获得返回值。&lt;/p&gt;
&lt;p&gt;（2）     OpenCV&lt;/p&gt;
&lt;p&gt;主要用OpenCV做一些图片缩放等操作，用PIL也是可以的。&lt;/p&gt;
&lt;p&gt;（3）     Tkinter&lt;/p&gt;
&lt;p&gt;主要用到了Button、PhotoImage这两个Widget。不多说了。&lt;/p&gt;
&lt;p&gt;程序的实现是很简单的，这里处于某些原因就不公开代码了，主要就是一个细调参数的过程。&lt;/p&gt;
&lt;p&gt;程序截图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201801/345405-20180130235855218-1454080606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下一步的目标是，结合OpenCV和神经网络实现自动识别、计算距离。&lt;/p&gt;
&lt;p&gt;郑重声明，本文仅供学习、娱乐只用，请勿随意传播。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 16:05:00 +0000</pubDate>
<dc:creator>Pleiades</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pleiades/p/8387934.html</dc:identifier>
</item>
<item>
<title>IronFort---基于Django和Websocket的堡垒机 - 刘江liujiangblog.com</title>
<link>http://www.cnblogs.com/feixuelove1009/p/8387774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixuelove1009/p/8387774.html</guid>
<description>&lt;p&gt;WebSSH有很多，基于Django的Web服务也有很多，使用Paramiko在Python中进行SSH访问的就更多了。但是通过gevent将三者结合起来，实现通过浏览器访问的堡垒机就很少见了。本文将简要介绍下我开发的IronFort堡垒机，其详细内容在我的官方网站liujiangblog.com的视频教程中。&lt;/p&gt;
&lt;h2 id=&quot;一堡垒机概述&quot;&gt;一、堡垒机概述&lt;/h2&gt;
&lt;p&gt;百度百科：堡垒机，在一个特定的网络环境下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段实时收集和监控网络环境中每一个组成部分的系统状态、安全事件、网络活动，以便集中报警、及时处理及审计定责。&lt;/p&gt;
&lt;p&gt;对于一个中型以上的公司，当用户和职员人数较多，公司所属服务器也数量较大的情况下，其服务器上的帐号管理难度将急剧增加，参考下面的图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/wguf60ojd3huwzxcvtfi4iri/1.png&quot; alt=&quot;1.png-153.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这其中必然存在很多问题，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户、主机、账号数量太多，工作量大，管理混乱；&lt;/li&gt;
&lt;li&gt;每个人员的权限和可使用账号没有系统管理，等级区分不明；&lt;/li&gt;
&lt;li&gt;用户直接掌握主机的帐号密码；&lt;/li&gt;
&lt;li&gt;密码可能交叉使用；&lt;/li&gt;
&lt;li&gt;离职人员可能还可以使用公司的帐号；&lt;/li&gt;
&lt;li&gt;内部人员可以跳过防火墙，直接使用帐号在机房内访问；&lt;/li&gt;
&lt;li&gt;内部人员离职前设下木马或暗门，一段时间后再爆发；&lt;/li&gt;
&lt;li&gt;对人员的访问记录、过往操作没有日志和审计，缺乏事后追踪手段；&lt;/li&gt;
&lt;li&gt;其它风险&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在运行初期，公司可能采取Excel表格等工具，使用人工管理的方式，靠‘人治’和道德水平约束，但当公司体量逐渐变大的时候，这种方式必然遭到淘汰，于是就出现了堡垒机的概念，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/es1zf4ojya05hcgidxpdqz12/2.png&quot; alt=&quot;2.png-148.7kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种架构带来如下的好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户不能直接访问远程主机，而是需要通过堡垒机跳转；&lt;/li&gt;
&lt;li&gt;用户不再掌握远程主机的帐号密码，只有访问堡垒机的帐号；&lt;/li&gt;
&lt;li&gt;限制用户登录远程主机后的修改密码能力，不允许修改；&lt;/li&gt;
&lt;li&gt;堡垒机的用户、远程主机的用户、用户密码、用户权限等等都被统一集中管理，大量节省人工成本；&lt;/li&gt;
&lt;li&gt;用户在登录堡垒机后所进行的一切操作将被记录下来，用于后期的行为审计；&lt;/li&gt;
&lt;li&gt;由于没有远程主机帐号密码，即使进入机房也无法直连主机；&lt;/li&gt;
&lt;li&gt;还可以实现批量命令执行、文件分发等附带功能；&lt;/li&gt;
&lt;li&gt;其它收益。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;堡垒机的核心概念是用户不再掌握帐号密码，用户的行为被记录用于审计。堡垒机主要针对的是内部网络和内部人员，对于人员流动性较强、体量大、行业风险高的企业需求特别强烈，比如金融行业。&lt;/p&gt;
&lt;p&gt;堡垒机已经拥有商业产品，多数以硬件服务器为载体进行销售，价格几十万不等。也有开源的解决方案，但这些方案有的不是基于浏览器，界面不够友好，日志记录困难；有的基于Tornado，并且只能进行简单的命令执行功能，而公司使用的是Django；更多的情况是与公司需求不一致，需要二次开发，维护和升级困难，等等不一而足。&lt;/p&gt;
&lt;p&gt;‘授人以鱼不如授人以渔’，自己掌握了开发堡垒机的核心技能，就可以快速、方便、灵活的针对公司具体需求进行定制开发，既为公司节省了购置硬件经费，又利于维护升级。&lt;/p&gt;
&lt;h2 id=&quot;二-ironfort堡垒机体系架构&quot;&gt;二、 IronFort堡垒机体系架构&lt;/h2&gt;
&lt;p&gt;IronFort堡垒机的体系架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/qaqurkzm1y750i3rjmemsciz/3.png&quot; alt=&quot;3.png-78.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个完整的通信过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户通过使用支持HTML5的浏览器，在HTTP的基础上，向堡垒机发送websocket请求；&lt;/li&gt;
&lt;li&gt;堡垒机上使用gevent接收websocket请求并转发给Django；&lt;/li&gt;
&lt;li&gt;Django接收请求后，调用paramiko建立与远程主机的ssh通道；&lt;/li&gt;
&lt;li&gt;远程主机执行用户的命令后，通过ssh返回数据给Django；&lt;/li&gt;
&lt;li&gt;Django通过gevent以websocket的形式返回给用户浏览器；&lt;/li&gt;
&lt;li&gt;用户浏览器使用term.js插件模拟Linux终端，显示远程主机返回的结果。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;核心机制就是这样，下面我们来看下开发过程。&lt;/p&gt;
&lt;h2 id=&quot;三开发简介&quot;&gt;三、开发简介&lt;/h2&gt;
&lt;h3 id=&quot;项目创建&quot;&gt;1. 项目创建&lt;/h3&gt;
&lt;p&gt;堡垒机本身通常是布置在Linux主机上的，比ubuntu16.04，对外以HTTP的形式提供服务。&lt;/p&gt;
&lt;p&gt;首先需要建立虚拟环境，并安装Python3.6以及Django2.0，不再赘述。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;django-admin startproject&lt;/code&gt;和&lt;code&gt;python manage.py startapp app_name&lt;/code&gt;分别创建项目和app。&lt;/p&gt;
&lt;p&gt;此时，可以尝试运行Django服务，如果看到下面的页面，表示Ok。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/q4ichkxxbnj492uh7k59lmmz/QQ%E6%88%AA%E5%9B%BE20180130104720.jpg&quot; alt=&quot;QQ截图20180130104720.jpg-35.9kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Django2.0的欢迎界面比以前漂亮了一点，还带链接，与时俱进呀。&lt;/p&gt;
&lt;h3 id=&quot;orm模型&quot;&gt;2. ORM模型&lt;/h3&gt;
&lt;p&gt;任何一个Web项目都必须在深入分析项目需求的情况下，首先设计好ORM模型，也就是数据库的表结构。&lt;/p&gt;
&lt;p&gt;IronFort中设计了六个模型，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;远程主机&lt;/li&gt;
&lt;li&gt;远程主机用户&lt;/li&gt;
&lt;li&gt;远程主机绑定的用户&lt;/li&gt;
&lt;li&gt;堡垒机用户&lt;/li&gt;
&lt;li&gt;堡垒机用户组&lt;/li&gt;
&lt;li&gt;日志&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里需要提醒的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个远程主机账户可以绑定多个远程主机，两者实际是多对多的关系；&lt;/li&gt;
&lt;li&gt;堡垒机用户不能直接绑定远程主机；&lt;/li&gt;
&lt;li&gt;堡垒机用户绑定的实际是一个主机+主机账户的对象；&lt;/li&gt;
&lt;li&gt;考虑账户是否激活或者被经用的enabled属性；&lt;/li&gt;
&lt;li&gt;考虑某些字段的unique_together属性；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于模型设计，每个人有每个人的需求和想法，这其中有很多坑和需要注意的地方，限于篇幅，无法展开论述。在我的个人网站liujiangblog.com的视频教程中有详细的讲解。&lt;/p&gt;
&lt;p&gt;模型设计好了，可以同时注册Django的admin后台。然后makemigrations、migrate和createsuperuser，重启服务器后就可以在admin中创建测试用例了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/bmsqqq9yykvbwvr2ny73ndj7/9-admin%E5%90%8E%E5%8F%B0.jpg&quot; alt=&quot;9-admin后台.jpg-127.8kB&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;url和路由&quot;&gt;3. url和路由&lt;/h3&gt;
&lt;p&gt;url的设计并不复杂，没有太多的复杂页面，下面是项目中使用的一些url：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.contrib &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; admin
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.urls &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; path, re_path
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; fort &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; views

urlpatterns &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [
    path(&lt;span class=&quot;st&quot;&gt;'admin/'&lt;/span&gt;, admin.site.urls),
    path(&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;, views.login),
    path(&lt;span class=&quot;st&quot;&gt;'login/'&lt;/span&gt;, views.login),
    path(&lt;span class=&quot;st&quot;&gt;'logout/'&lt;/span&gt;, views.logout),
    path(&lt;span class=&quot;st&quot;&gt;'index/'&lt;/span&gt;, views.index),
    path(&lt;span class=&quot;st&quot;&gt;'log/'&lt;/span&gt;, views.get_log),
    path(&lt;span class=&quot;st&quot;&gt;'host/&amp;lt;int:user_bind_host_id&amp;gt;/'&lt;/span&gt;, views.&lt;span class=&quot;ex&quot;&gt;connect&lt;/span&gt;),
]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Django2.0的url语法向flask等框架靠拢了，但依然可以使用正则模式。关于2.0和之前版本的区别，可以查看我曾经写过的一篇博文&lt;a href=&quot;http://www.liujiangblog.com/blog/8/&quot;&gt;Django 2.0 新特性 抢先看！&lt;/a&gt;。其实不是重度使用者，基本感受不出变化来，该怎么用还是怎么用。最大的区别也就在url编写，和Python2及3的支持。&lt;/p&gt;
&lt;h3 id=&quot;前端框架adminlte&quot;&gt;4. 前端框架AdminLTE&lt;/h3&gt;
&lt;p&gt;为了让用户界面美观，我这里使用了基于bootstrap的开源框架AdminLTE。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/6rf43qdduu1alob82g3b2h1p/adminlet.png&quot; alt=&quot;adminlet.png-668.8kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AdminLTE托管在GitHub上，可以通过下面的地址下载：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/almasaeed2010/AdminLTE/releases&quot; class=&quot;uri&quot;&gt;https://github.com/almasaeed2010/AdminLTE/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AdminLTE自带JQuery和Bootstrap3，无需另外下载。&lt;/p&gt;
&lt;p&gt;AdminLTE自带多种配色皮肤，可根据需要实时调整。&lt;/p&gt;
&lt;p&gt;AdminLTE是移动端自适应的，无需单独考虑。&lt;/p&gt;
&lt;p&gt;AdminLTE自带大量插件，比如datatables，可根据需要载入。&lt;/p&gt;
&lt;p&gt;但是AdminLTE的源文件包内，缺少font-awesome-4.6.3和ionicons-2.0.1这两个图标插件，它是通过CDN的形式加载的，如果网络不太好，加载可能比较困难或者缓慢，最好用本地静态文件的形式，请自定下载并引入项目内。&lt;/p&gt;
&lt;p&gt;我们不需要AdminLTE那么多的功能，只需要它的基本框架。在其源码包内，对index文件进行裁剪和静态文件导入处理，形成一个基本的base.html用于拓展，在它的基础上，我们可以扩展出index和log页面。&lt;/p&gt;
&lt;h3 id=&quot;堡垒机用户登录页面&quot;&gt;5. 堡垒机用户登录页面&lt;/h3&gt;
&lt;p&gt;堡垒机用户登录页面不需要使用AdminLTE，最好是单独一个简单的页面，展示的内容越少越好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/3nij6dl0tht5ud1wsaibvkd5/1-%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.jpg&quot; alt=&quot;1-登录界面.jpg-108.6kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而用户登录的处理视图就很简单了，直接使用Django内置的Auth认证系统。&lt;/p&gt;
&lt;p&gt;使用Django自带的authenticate和login方法就可以完成用户验证和登录会话。&lt;/p&gt;
&lt;p&gt;既然有了登录，必然就要有登出。为了限制未登录用户访问堡垒机系统，所有的相关视图都必须先使用装饰器进行是否登录验证。&lt;/p&gt;
&lt;p&gt;通常而言，堡垒机不需要提供面向用户的注册页面。堡垒机用户的注册都是超级管理员掌控的，在后台进行！&lt;/p&gt;
&lt;h3 id=&quot;主机帐号页面&quot;&gt;6. 主机帐号页面&lt;/h3&gt;
&lt;p&gt;也就是我们堡垒机用户登录进系统后，显示的默认页面index。这里将通过表格的形式，列出当前堡垒机用户可以使用的远程主机帐号。视图很简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@login_required(login_url='/login/')
def index(request):
    # ...通过ORM的API查询可使用的帐号
    return render(request, 'fort/index.html', locals())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主机账户的前端页面index基于base.html，使用datatable插件，提供搜索、排序和分页等高级功能，其展示效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/62j1753qsrihvvzarbcrd3mv/2-%E4%B8%BB%E6%9C%BA%E5%B8%90%E5%8F%B7%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2.jpg&quot; alt=&quot;2-主机帐号显示页面.jpg-255kB&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在浏览器中打开websocket通道&quot;&gt;7. 在浏览器中打开websocket通道&lt;/h3&gt;
&lt;p&gt;百度百科：WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。&lt;/p&gt;
&lt;p&gt;本文不打算成为一篇websocket的科普文，有兴趣深入研究的可以查看博客园的精华博文&lt;a href=&quot;https://www.cnblogs.com/chyingp/p/websocket-deep-in.html&quot;&gt;WebSocket协议：5分钟从入门到精通&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的说，有以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HTTP本身是无状态连接，不支持实时通信；&lt;/li&gt;
&lt;li&gt;websocket基于HTML5，需要浏览器支持；&lt;/li&gt;
&lt;li&gt;通过在http报头中添加upgrade属性，申请通信协议升级为websocket；&lt;/li&gt;
&lt;li&gt;升级成为websocket通信后，可以实现浏览器和远程服务器之间的全双工实时通信。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于websocket的使用教程，可以参考阮一峰专家的博文&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/05/websocket.html&quot;&gt;WebSocket 教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其具体API如下图所示（图片来自菜鸟教程）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/0y4p79f9wj58bjy5lytucq26/image.png&quot; alt=&quot;image.png-74.8kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/wtpvdtyphltytyrz7kpj92s1/image.png&quot; alt=&quot;image.png-92.7kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要简单的创建并使用一个websocket，按下面的套路就可以了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;new WebSocket(url, [protocol] );&lt;/code&gt;创建ws对象&lt;/li&gt;
&lt;li&gt;使用ws，调用onopen、onmessage、onerror和onclose方法处理通信过程中的数据&lt;/li&gt;
&lt;li&gt;使用ws，调用send方法发送数据给后端服务器&lt;/li&gt;
&lt;li&gt;使用ws，调用close方法，关闭websocket连接。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们在主机帐号表格中隐藏一个主机帐号id的字段，通过js代码获取该字段的值，然后启动websocket通信，传递这个id作为参数之一，用于构造websocket通信使用的url。&lt;/p&gt;
&lt;p&gt;在浏览器模拟Linux终端方面，我使用的是term.js插件。这是一个开源在github上的浏览器模拟Linux终端的js插件，地址为：&lt;code&gt;https://github.com/chjj/term.js&lt;/code&gt;。其官方文档比较简单，有兴趣的同学可以深入研读其源代码，或者使用xterm作为替代。&lt;/p&gt;
&lt;p&gt;最终效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/7mi7c899koh0raxzfcpn1g2j/%E6%97%A0%E6%95%88%E8%BF%9E%E6%8E%A5.jpg&quot; alt=&quot;无效连接.jpg-98.6kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为此时后端还没有完成，所以是连接不上任何主机的。&lt;/p&gt;
&lt;h3 id=&quot;创建websocket服务器&quot;&gt;8. 创建websocket服务器&lt;/h3&gt;
&lt;p&gt;Django本身是一个同步Web框架，也不支持websocket。所以你使用它的runserver，是无法接收和处理websocket请求的。为了解决这个问题，可以使用gevent这个Python的第三方异步网络框架。&lt;/p&gt;
&lt;p&gt;gevent基于greelet协程库，自带有WSGI服务器，并且其扩展库gevent-websocket支持websocket通信。&lt;/p&gt;
&lt;p&gt;请先用&lt;code&gt;pip install gevent gevent-websocket&lt;/code&gt;安装这两个库。&lt;/p&gt;
&lt;p&gt;在IronFort项目根目录下创建一个&lt;code&gt;start_ironfort.py&lt;/code&gt;脚本，以后这就是我们的服务启动脚本了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from gevent import monkey
monkey.patch_all()

from gevent.pywsgi import WSGIServer
from geventwebsocket.handler import WebSocketHandler
from ironfort.wsgi import application

print('ironfort is running ......')

ws_server = WSGIServer(
    (host, port),
    application,
    log=None,
    handler_class=WebSocketHandler
)

try:
    ws_server.serve_forever()
except KeyboardInterrupt:
    print('服务器关闭......')
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心要点是，使用gevent的WSGIServer服务器代替DJango的runserver，使用geventwebsocket的WebSocketHandler来处理浏览器发送过来的websocket通信请求，并将其转发到Django的application。&lt;/p&gt;
&lt;p&gt;我们知道Django的通信入口就存在于&lt;code&gt;from ironfort.wsgi import application&lt;/code&gt;中的这个方法。通过gevent的帮助，我们让Django具备了接收websocket通信请求的能力。&lt;/p&gt;
&lt;p&gt;运行&lt;code&gt;python start_ironfort&lt;/code&gt;可以启动新的服务器，在浏览器验证一下，都可以正常访问。&lt;/p&gt;
&lt;h3 id=&quot;在django中创建视图处理websocket请求&quot;&gt;9. 在Django中创建视图处理websocket请求&lt;/h3&gt;
&lt;p&gt;我们前面的根路由中已经写了相关的url，这里再贴出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;path('host/&amp;lt;int:user_bind_host_id&amp;gt;/', views.connect),&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，以&lt;code&gt;ws://ip:port/host/15/&lt;/code&gt;形式的url请求，将被转发到connect视图进行处理，这其中传递了‘15’这个主机帐号id的参数。具体connect视图局部代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;at&quot;&gt;@login_required&lt;/span&gt;(login_url&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/login/'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;connect&lt;/span&gt;(request, user_bind_host_id):
    &lt;span class=&quot;co&quot;&gt;#　如果当前请求不是websocket请求则退出&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# ...省略&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 获取remote_user_bind_host&lt;/span&gt;

    bridge &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; WSSHBridge(request.environ.get(&lt;span class=&quot;st&quot;&gt;'wsgi.websocket'&lt;/span&gt;), request.user)

    &lt;span class=&quot;cf&quot;&gt;try&lt;/span&gt;:
        bridge.&lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(
            host_ip&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;remote_user_bind_host.host.ip,
            port&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;remote_user_bind_host.host.port,
            username&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;remote_user_bind_host.remote_user.remote_user_name,
            password&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;remote_user_bind_host.remote_user.password
        )
    &lt;span class=&quot;cf&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;pp&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; e:
        message &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'尝试连接&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{0}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;的过程中发生错误：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{1}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(
            remote_user_bind_host.remote_user.remote_user_name, e)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(message)
        add_log(request.user, message, log_type&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'2'&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; HttpResponse(&lt;span class=&quot;st&quot;&gt;&quot;错误！无法建立SSH连接！&quot;&lt;/span&gt;)

    bridge.shell()

    request.environ.get(&lt;span class=&quot;st&quot;&gt;'wsgi.websocket'&lt;/span&gt;).close()
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'用户断开连接.....'&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; HttpResponse(&lt;span class=&quot;st&quot;&gt;&quot;200, ok&quot;&lt;/span&gt;) &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取id对应的远程帐号；&lt;/li&gt;
&lt;li&gt;调用WSSHBridge()方法，传入websocket对象和当前用户，创建一个websocket和ssh通信的桥接类，这个类一会我们会介绍。&lt;/li&gt;
&lt;li&gt;调用open方法启动ssh通信；&lt;/li&gt;
&lt;li&gt;调用shell方法启动终端环境；&lt;/li&gt;
&lt;li&gt;通信结束后调用close方法，关闭通道。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么这里的WSSHBridge类是什么呢？&lt;/p&gt;
&lt;h3 id=&quot;wsshbridge桥接通信类&quot;&gt;10. WSSHBridge桥接通信类&lt;/h3&gt;
&lt;p&gt;WSSHBridge：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import gevent
from gevent.socket import wait_read, wait_write
import paramiko
import json


class WSSHBridge:
    &quot;&quot;&quot;
    桥接websocket和SSH的核心类
    &quot;&quot;&quot;

    def __init__(self, websocket, user):
        self.user = user
        self._websocket = websocket
        self._tasks = []
        #...

    def open(self, host_ip, port=22, username=None, password=None):
        &quot;&quot;&quot;        建立SSH连接        &quot;&quot;&quot;
        pass

    def _forward_inbound(self, channel):
        &quot;&quot;&quot;        正向数据转发，websocket -&amp;gt;  ssh        &quot;&quot;&quot;
        pass

    def _forward_outbound(self, channel):
        &quot;&quot;&quot;        反向数据转发，ssh -&amp;gt; websocket        &quot;&quot;&quot;
        pass

    def _bridge(self, channel):
        &quot;&quot;&quot;        桥接websocket和ssh        &quot;&quot;&quot;
        pass

    def close(self):
        &quot;&quot;&quot;        结束桥接会话        &quot;&quot;&quot;
        pass

    def shell(self):
        &quot;&quot;&quot;        启动一个shell通信界面        &quot;&quot;&quot;
       pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先需要&lt;code&gt;pip install paramiko&lt;/code&gt;安装模块。&lt;/p&gt;
&lt;p&gt;WSSHBridge类，本质上就是桥接websocket通道和paramiko打开的ssh通道，进行数据双向转发。&lt;/p&gt;
&lt;p&gt;open方法调用paramiko的相关API，传入主机ip、port、用户名和密码，打开ssh通道，&lt;code&gt;_forward_inbound&lt;/code&gt;和&lt;code&gt;_forward_outbound&lt;/code&gt;方法分别实现数据的正向和反向转发。&lt;/p&gt;
&lt;p&gt;核心的关键是&lt;code&gt;_bridge&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;self._tasks = [
            gevent.spawn(self._forward_inbound, channel),
            gevent.spawn(self._forward_outbound, channel),
        ]
        gevent.joinall(self._tasks)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用gevent的spawn方法创建了两个协同任务，然后调用joinall方法等待它们任务结束。这样就实现了数据在websocket通道和ssh通道之间的一发一收，一收一发的通信机制。&lt;/p&gt;
&lt;p&gt;这一步完成后，重启服务器，我们就可以来展示整个通信过程了。&lt;/p&gt;
&lt;p&gt;首先是，连接成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/kdzf0apx4wvx0bgwv7hbcbd4/4-%E5%9F%BA%E4%BA%8Ewebsocket%E7%9A%84%E5%A0%A1%E5%9E%92%E6%9C%BAssh%E8%BF%9E%E6%8E%A5.jpg&quot; alt=&quot;4-基于websocket的堡垒机ssh连接.jpg-188.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其次是类似Python这种交互式命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/7bnojzd5vaarlyc8g10ryhtt/5-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%8E%AF%E5%A2%83%E5%91%BD%E4%BB%A4.jpg&quot; alt=&quot;5-交互式环境命令.jpg-266.9kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后是top这种动态命令结果返回：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/8kpl2fq9o93gpifgoxhvb4k2/6-%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9%E4%BC%A0%E8%BE%93%E5%91%BD%E4%BB%A4%EF%BC%88%E6%AF%94%E5%A6%82top%EF%BC%89.jpg&quot; alt=&quot;6-动态内容传输命令（比如top）.jpg-386.9kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后是vim这种编辑环境：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/9ch5obdo6enpbs4mkyn6yzpp/7-vim%E7%AD%89%E7%BC%96%E8%BE%91%E7%8E%AF%E5%A2%83.jpg&quot; alt=&quot;7-vim等编辑环境.jpg-133.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们是支持彩色输出的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/1wfy4ricvjw59vasj6i65bi2/8-%E6%94%AF%E6%8C%81%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA.jpg&quot; alt=&quot;8-支持彩色输出.jpg-194kB&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;日志记录和行为审计&quot;&gt;11. 日志记录和行为审计&lt;/h3&gt;
&lt;p&gt;关于用户操作，在数据由websocket往ssh发送过程中，可以保存用户通过前端Linux模拟器终端所敲击的所有按键记录，并且很规整的以回车键进行分隔，非常容易判别。&lt;/p&gt;
&lt;p&gt;我们只需要创建一个日志模型，编写一个保存日志的方法，然后在需要的位置保存日志即可。&lt;/p&gt;
&lt;p&gt;日志展示页面非常类似主机账户的页面，同样使用datatable插件进行处理，最终效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/eezlnc7dtc137y822uowfify/3-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E9%A1%B5%E9%9D%A2.jpg&quot; alt=&quot;3-日志系统页面.jpg-270kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，基于Webssh的堡垒机核心功能就开发完毕了。限于篇幅，不可能点点滴滴、枝叶不漏的全部叙述，我这里也只是一个抛砖引玉的过程。&lt;/p&gt;
&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;远程主机的创建、主机账号的管理、堡垒机用户和用户组的管理，这一系列的工作，目前我还是放在admin后台中进行。后期，大家可以将它迁移到堡垒机页面中一起管理。如果将IronFort用于生产环境，添加批量命令执行、文件分发功能，进行系统部署上线、结合Linux运维等等，必然需要大量的额外工作和安全机制，这些就留给大家自己去研究了。&lt;/p&gt;
&lt;p&gt;另外，我在官方主页&lt;a href=&quot;http://www.liujiangblog.com/&quot;&gt;刘江的博客和教程&lt;/a&gt;中，还有一个关于CMDB主机管理系统的教程，将它结合到堡垒机项目中来，一个运维管理平台的核心底层功能就基本具备了，在此基础上进行扩展，大有可为！&lt;/p&gt;
&lt;p&gt;最后，个人技术和能力有限，必然存在不足之处，请大家轻喷，多提宝贵意见，谢谢！&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 15:19:00 +0000</pubDate>
<dc:creator>刘江liujiangblog.com</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixuelove1009/p/8387774.html</dc:identifier>
</item>
<item>
<title>深入理解final关键字以及一些建议 - Chan'sBlog</title>
<link>http://www.cnblogs.com/chansblogs/p/8387801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chansblogs/p/8387801.html</guid>
<description>&lt;p&gt;引子：一说到final关键字，相信大家都会立刻想起一些基本的作用，那么我们先稍微用寥寥数行来回顾一下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、final关键字的含义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;final是Java中的一个保留关键字，它可以标记在成员变量、方法、类以及本地变量上。一旦我们将某个对象声明为了final的，那么我们将不能再改变这个对象的引用了。如果我们尝试将被修饰为final的对象重新赋值，编译器就会报错。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、用法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.修饰变量&lt;/p&gt;
&lt;p&gt;final修饰在成员变量或者局部变量上，那么我们可以称这个变量是final变量，这可能使我们用到最多的地方，举个栗子：常量(虽然现在建议使用枚举类来代替常量)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/872578/201801/872578-20180130213206609-353674850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们将被final修饰的变量重新赋值，编译器就会报出如图：cannot assign a value to final variable.(不能给final变量赋值)&lt;/p&gt;

&lt;p&gt;2.修饰方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被final所修饰的方法将无法被子类重写。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“&lt;strong&gt;使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。&lt;/strong&gt;” -- 摘自《Java编程思想》&lt;/p&gt;
&lt;p&gt;因此如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定(正如编程思想中所提到的，在现在几版较新的JDK中，已经几乎没有性能差别了)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/872578/201801/872578-20180130214946171-730300605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(当我们尝试重写的时候编译器就会报错)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：类的private方法会隐式地被指定为final方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;3.修饰类&lt;/p&gt;
&lt;p&gt;如果某个类被final所修饰，那么表明这个的功能通常是完整的；&lt;strong&gt;该类将不能被继承&lt;/strong&gt;。并且&lt;span&gt;final类的所有方法都会被隐式的修饰成final&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;4.ps：&lt;span&gt;匿名类中的所有变量都必须是final的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、关键字final的好处小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;final关键字提高了性能。JVM和Java应用都会缓存final变量。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用final关键字，JVM会对方法、变量及类进行优化。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于不可变类，它的对象是只读的，可以在多线程环境下安全的共享，不用额外的同步开销。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、来自《Effective Java》中的一些建议&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该书的第17条：&lt;span&gt;&lt;strong&gt;要么为了继承而设计，并提供文档说明，要么就禁止继承&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;该条目提醒我们，如果类不是被设计用来继承的，那么这个类就应该被禁止继承(听起来有点绕，但细想下来的设计思想是很好的)，否则就应该提供足够的文档及注释(具体可参考java.util.AbstractCollection这个骨架实现里的注释文档规范)。&lt;/p&gt;
&lt;p&gt;而禁止类被子类化的方法通常有两个：&lt;/p&gt;
&lt;p&gt;1.将所有的构造器设为私有的(private)或者包级私有的(default)，并使用静态工厂方法来代替构造器；&lt;/p&gt;
&lt;p&gt;2.将类标记为final。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.一些思考回头再来审视我们日常中的程序，我们可能已经习惯了不去那么刻意的使用final，顶多在写常量的时候用一用，但实际上我们很多的类，方法或者变量是不需要被改变的，或者说不会被继承的。比如我在刚读到《Effective Java》中的这个条目后，回首自己正在做的一个项目中审视了一下，我首先将自己的domain层中的一些类标为了final，因为我觉得这些类是不可能被继承的，如果继承了是不太符合设计的，并且程序运行没有异常，同时修改的还有我的依赖注入方式(参考我的上一篇博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chansblogs/p/8343930.html&quot;&gt;Spring注解依赖注入的三种方式的优缺点以及优先选择&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;我重新纠正了一下自己在设计类的时候的思想顺序：之前自己在准备写一个类的时候(虽然通常我是不给类加final的= =)，可能觉得这个类(变量或者方法)不能被改变，有很强烈的这种想法时才会加上final，但现在是：这个类需不需要使他可以被子类化？如果在以后的项目更新，迭代中，并不需要，那么我会毫不犹豫的给他加上final。&lt;/p&gt;

&lt;p&gt;2.&lt;em&gt;&quot;final关键字能提升性能&quot;？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当时发现这一点之后，我可能是中毒了，给能加上final的地方都加上了，自以为改善了性能心里还美滋滋呢。其实对这个“提升性能”一点一直还有一丝的疑问，于是我回头就去了Stack Overflow上转了一圈，找到了我想要的答案：&lt;a class=&quot;question-hyperlink&quot; href=&quot;https://stackoverflow.com/questions/4279420/does-use-of-final-keyword-in-java-improve-the-performance&quot;&gt;Does use of final keyword in Java improve the performance?&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;大佬指出，&lt;span&gt;通常是不会的&lt;/span&gt;，对于方法，HotPot会跟踪看它是否真的被重写了，并且能够优化没有被重写的内敛方法，直到它加载到了一个类复写了这个方法，这时它可以撤销(或部分撤销)这些优化。(当然,这是假设您使用的是HotPot,但到目前为止这是最常见的JVM,所以…)&lt;/p&gt;
&lt;p&gt;之后大佬指出了我们不应该为了这么丝许的性能而绞尽脑汁，建议我们应该明确设计，写出好的结构的代码以及可读性优良的代码。(在此又应证了《Effective Java》中的第55条：&lt;strong&gt;谨慎地进行优化中所指出的核心：优化的格言就是：不要进行优化&lt;/strong&gt;) （也验证了上面《Java编程思想》中最后的那句话）&lt;/p&gt;

&lt;p&gt; 3.关于局部变量以及参数中的final&lt;/p&gt;
&lt;p&gt;接着我尝试将我的局部变量以及方法中的参数都标记为final的，同2一样，已经中毒颇深了。但是我对此同时也存在着同样的疑问，然后在Stack Overflow中得到了经验证的又一个结论：局部变量以及参数中的final，同样不能提升我们的性能，它&lt;span&gt;甚至不会被写进字节码中&lt;/span&gt;。于是我操起了键盘啪啪啪一顿敲了几行代码编译了一下，并用反编译工具(如JD-GUI)打开：&lt;/p&gt;
&lt;p&gt;先来看我们的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FinalTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; say(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; number) {
        System.out.println(&lt;/span&gt;&quot;number: &quot; +&lt;span&gt; number);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; num = 0&lt;span&gt;;
        say(num);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看看编译后的.class文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FinalTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FinalTest() {
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; say(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number) {
        System.out.println(&lt;/span&gt;&quot;number: &quot; +&lt;span&gt; number);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        say(&lt;/span&gt;0&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到在写入字节码的时候就被优化掉了，final只是编译时静态限制我们不能再赋值(改变引用)。&lt;/p&gt;

</description>
<pubDate>Tue, 30 Jan 2018 15:09:00 +0000</pubDate>
<dc:creator>Chan&amp;#39;sBlog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chansblogs/p/8387801.html</dc:identifier>
</item>
<item>
<title>postgres的initdb解析——从一次插件升级失败说起 - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/8385208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/8385208.html</guid>
<description>&lt;p&gt;我们公司基于postgres开发了一款数据库产品，不用说我们对OSS的源码做了改动，并且也集成和自己编写了一些插件。因此，当postgresql和相关插件升级时，我们也需要将升级反应到自己的产品中去，这是背景。&lt;/p&gt;
&lt;p&gt;这次的问题是在我们升级postgresql的插件orafce(3.2.0--&amp;gt;3.6.0)时发生的。按照往常惯例我们将该插件升级后，组织源码进行编译，OK编译通过。&lt;/p&gt;
&lt;p&gt;然而，在我们进行测试时，程序在initdb时就报错停止了。报错如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[postgres@localhost data]$ initdb -D `pwd`
The files belonging to this database system will be owned by user &quot;postgres&quot;.
This user must also own the server process.

The database cluster will be initialized with locale &quot;en_US.UTF-8&quot;.
The default database encoding has accordingly been set to &quot;UTF8&quot;.
The default text search configuration will be set to &quot;english&quot;. (15541)

Data page checksums are disabled. (18153)

fixing permissions on existing directory /data ... ok (15516)
creating subdirectories ... ok (15516)
selecting default max_connections ... 100
selecting default shared_buffers ... 128MB
selecting dynamic shared memory implementation ... posix
creating configuration files ... ok (15516)
creating template1 database in /data/base/1 ... ok (15516)
initializing pg_authid ... ok (15516)
initializing dependencies ... ok (15516)
creating information schema ... FATAL: relation &quot;information_schema.columns&quot; does not exist (10414)
......
(以下省略)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;众人费解。只是升级了插件，怎么会导致无法创建initdb呢？&lt;/p&gt;
&lt;p&gt;我注意到报错中的这行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;creating information schema ... FATAL: relation &quot;information_schema.columns&quot; does not exist (10414)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;似乎挺熟悉？我看看了orafce最新的升级文件。发现在文件中有以下SQL文：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- Oracle system views
create view oracle.user_tab_columns as
    select table_name,
           column_name,
           data_type,
           coalesce(character_maximum_length, numeric_precision) AS data_length,
           numeric_precision AS data_precision,
           numeric_scale AS data_scale,
           is_nullable AS nullable,
           ordinal_position AS column_id,
           is_updatable AS data_upgraded,
           table_schema
    from information_schema.columns;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;似乎对上了，真的是升级惹的祸？不应该啊，社区应该没这么蠢啊，再说只是个插件，怎么会影响postgres呢？这个时候还没导入插件呢，怎么会存在这个错误？&lt;/p&gt;
&lt;p&gt;困惑。&lt;/p&gt;
&lt;p&gt;因为我们产品中的postgresql的代码也有我们自己添加的代码，为了确定错误来源，我先取了一份postgresql的source，在contrib目录下放入最新的orafce代码。然后make world。&lt;/p&gt;
&lt;p&gt;在运行initdb命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(以上省略)
copying template1 to postgres ... ok (15516)
syncing data to disk ... ok (15516)

WARNING: enabling &quot;trust&quot; authentication for local connections
You can change this by editing pg_hba.conf or using the option -A, or
--auth-local and --auth-host, the next time you run initdb.

Success. You can now start the database server using:

    pg_ctl -D /data -l logfile start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功了！说明不是OSS的问题。&lt;/p&gt;
&lt;p&gt;很好，那么就是我们的修正代码的问题了。然而initdb这一块代码不是我们team维护的，我不知道我们的产品修改了什么。好的，老老实实看看差分代码吧。&lt;/p&gt;
&lt;p&gt;结果差分代码一看，initdb.c文件我们就修改了两行代码，看了看，也只是改善性代码，和本次的问题毫无关系。费解。。。。&lt;/p&gt;
&lt;p&gt;好吧，既然是initdb出了问题，我看看initdb的代码，理理思路吧。跑过去看看抛出出错信息的代码。再加上自己的整理。大概搞清楚了原因。&lt;/p&gt;
&lt;p&gt;具体是什么原因先卖个关子。我们先看看postgresql在initdb时会执行哪些操作(缩进代表调用关系)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main
    确保stdout和stderr的缓冲行为与交互式使用中的行为相匹配
    设置特定于应用程序的区域设置和服务目录
    process command-line options
    sync_only模式
    密码与服务器认证相关
    setup_pgdata()设置pgdata环境
    setup_bin_paths()获取postgres命令的路径，判断是否与initdb版本匹配
    set_info_version()提取信息模式所需的版本号
    setup_data_file_paths() check初始化脚本和配置文件模板
    setup_locale_encoding()设置编码方式
    setup_text_search()根据encoding设置text search方式
    do_sync模式
    initialize_data_directory
        create_data_directory()创建数据库目录pgdata
        create_xlog_or_symlink()创建pgdata下的pg_xlog目录
        创建其他子目录
        创建并配置postgresql.conf文件
        bootstrap_template1()调用postgres在Bootstrap模式下创建模板数据库template1
        (以下的配置均针对模板数据库template1)
        setup_auth()设置template1的密码表
        setup_depend()建立系统表pg_depend，该表描述了数据库对象之间的依赖关系
        setup_sysviews()运行脚本system_views.sql创建系统视图★
        setup_description()创建系统表pg_description和pg_shdescription
        setup_collation()创建系统表pg_collation，该表描述了可用的排序规则，其本质是从一个SQL名字到操作系统locale分类的映射
        setup_conversion()运行脚本conversion_create.sql创建系统表pg_conversion，该表描述编码转换过程
        setup_dictionary()运行脚本snowball_create.sql创建一些额外的目录
        setup_privileges()为postgres内置的一些object设置默认权限
        setup_schema()运行脚本information_schema.sql创建模式information_schema★
        load_plpgsql()加载plpgsql服务端编程语言
        vacuum_db()清理template1
        make_template0()根据做好的template1，拷贝复制一份作为template0
        make_postgres()根据做好的template1，拷贝复制一份作为postgres
    告诉用户initdb执行结束&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是initdb的执行过程。很清晰也很简单。其中最重要的是initialize_data_directory()函数。正是该函数一步步地建立起了数据库的基本元素。因此，出问题的地方就在这个函数&quot;内部&quot;。&lt;/p&gt;
&lt;p&gt;聪明的朋友可能看出来了，我在上面打了两处&quot;★&quot;。是的，没有错，正是这两块代码的问题，哦不，确切的说是sql的问题。&lt;/p&gt;
&lt;p&gt;下面来说。&lt;/p&gt;
&lt;p&gt;我们可爱的开发人员在&lt;strong&gt;system_views.sql&lt;/strong&gt;中加入了以下两行(询问发现是客户希望使用orafce功能，但又不想手动创建，想&quot;透明&quot;地使用)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE EXTENSION orafce;
SET search_path TO DEFAULT;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道orafce的初始化引用了 information_schema.columns这个视图,而这个视图在&lt;strong&gt;information_schema.sql&lt;/strong&gt;中被创建。&lt;/p&gt;
&lt;p&gt;而由上面的initdb执行过程可以看到：system_views.sql的执行顺序在information_schema.sql之前，也是就说：&lt;br/&gt;我们在初始化 orafce的时候，information_schema.columns还不存在，因此，会在执行system_views.sql时，报以上错误。&lt;/p&gt;
&lt;p&gt;知道了原因就很好改了，只要保证加入的那两行sql代码在创建information_schema之后即可~&lt;/p&gt;
&lt;p&gt;以上&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jan 2018 15:01:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/8385208.html</dc:identifier>
</item>
</channel>
</rss>