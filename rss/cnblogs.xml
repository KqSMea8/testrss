<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>WPF XAML 资源样式模板属性存放位置 - 梦机器</title>
<link>http://www.cnblogs.com/DMSkin/p/8453062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DMSkin/p/8453062.html</guid>
<description>&lt;p&gt;WPF的XAML 资源申明 类似HTML。&lt;/p&gt;
&lt;p&gt;整体来说分3种&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.行类资源样式属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1 行内属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;Button Content=&quot;按钮&quot; Foreground=&quot;White&quot; FontSize=&quot;30&quot;&amp;gt;&amp;lt;/Button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2 行内样式 模板（没多大意义）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;Button Content=&quot;按钮&quot;&amp;gt;
  &amp;lt;Button.Style&amp;gt;
         &amp;lt;Style TargetType=&quot;Button&quot;&amp;gt;
                    &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;White&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
                    &amp;lt;Setter Property=&quot;FontSize&quot; Value=&quot;30&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
                    &amp;lt;Setter Property=&quot;Template&quot;&amp;gt;
                        &amp;lt;Setter.Value&amp;gt;
                            &amp;lt;ControlTemplate TargetType=&quot;Button&quot;&amp;gt;
                                &amp;lt;Grid&amp;gt;&amp;lt;/Grid&amp;gt;
                            &amp;lt;/ControlTemplate&amp;gt;
                        &amp;lt;/Setter.Value&amp;gt;
                    &amp;lt;/Setter&amp;gt;
          &amp;lt;/Style&amp;gt;
  &amp;lt;/Button.Style&amp;gt;
  &amp;lt;Button.Template&amp;gt;
           &amp;lt;ControlTemplate TargetType=&quot;Button&quot;&amp;gt;
                    &amp;lt;Grid&amp;gt;&amp;lt;/Grid&amp;gt;
           &amp;lt;/ControlTemplate&amp;gt;
  &amp;lt;/Button.Template&amp;gt;
&amp;lt;/Button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2.头部资源样式属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 头部样式模板 （申明）&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;Window.Resources&amp;gt;
        &amp;lt;Style x:Key=&quot;xxx&quot; TargetType=&quot;Button&quot;&amp;gt;
            &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;White&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
            &amp;lt;Setter Property=&quot;FontSize&quot; Value=&quot;30&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
            &amp;lt;Setter Property=&quot;Template&quot;&amp;gt;
                &amp;lt;Setter.Value&amp;gt;
                    &amp;lt;ControlTemplate TargetType=&quot;Button&quot;&amp;gt;
                        &amp;lt;Grid&amp;gt;&amp;lt;/Grid&amp;gt;
                    &amp;lt;/ControlTemplate&amp;gt;
                &amp;lt;/Setter.Value&amp;gt;
            &amp;lt;/Setter&amp;gt;
        &amp;lt;/Style&amp;gt;
        &amp;lt;ControlTemplate x:Key=&quot;xx&quot; TargetType=&quot;Button&quot;&amp;gt;
            &amp;lt;Grid&amp;gt;&amp;lt;/Grid&amp;gt;
        &amp;lt;/ControlTemplate&amp;gt;
&amp;lt;/Window.Resources&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.2 头部样式模板 （引用）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;Window.Resources&amp;gt;
        &amp;lt;ResourceDictionary&amp;gt;
            &amp;lt;ResourceDictionary.MergedDictionaries&amp;gt;
                &amp;lt;ResourceDictionary Source=&quot;Dictionary.xaml&quot;/&amp;gt;
            &amp;lt;/ResourceDictionary.MergedDictionaries&amp;gt;
        &amp;lt;/ResourceDictionary&amp;gt;
&amp;lt;/Window.Resources&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;3.全局资源样式属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App.xaml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    &amp;lt;Application.Resources&amp;gt;
        &amp;lt;ResourceDictionary&amp;gt;&lt;br/&gt;&amp;lt;ResourceDictionary.MergedDictionaries&amp;gt;
                &amp;lt;ResourceDictionary Source=&quot;Dictionary.xaml&quot;/&amp;gt;
            &amp;lt;/ResourceDictionary.MergedDictionaries&amp;gt;&lt;br/&gt;&amp;lt;Style x:Key=&quot;xxx&quot; TargetType=&quot;Button&quot;&amp;gt;
                &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;White&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
                &amp;lt;Setter Property=&quot;FontSize&quot; Value=&quot;30&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
                &amp;lt;Setter Property=&quot;Template&quot;&amp;gt;
                    &amp;lt;Setter.Value&amp;gt;
                        &amp;lt;ControlTemplate TargetType=&quot;Button&quot;&amp;gt;
                            &amp;lt;Grid&amp;gt;&amp;lt;/Grid&amp;gt;
                        &amp;lt;/ControlTemplate&amp;gt;
                    &amp;lt;/Setter.Value&amp;gt;
                &amp;lt;/Setter&amp;gt;
            &amp;lt;/Style&amp;gt;
            &amp;lt;ControlTemplate x:Key=&quot;xx&quot; TargetType=&quot;Button&quot;&amp;gt;
                &amp;lt;Grid&amp;gt;&amp;lt;/Grid&amp;gt;
            &amp;lt;/ControlTemplate&amp;gt;
        &amp;lt;/ResourceDictionary&amp;gt;
    &amp;lt;/Application.Resources&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;！！！！！！！！！！！！！！配合资源字典的使用！！！！！！！！！　&lt;/span&gt;　&lt;/p&gt;

&lt;p&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.行类属性尽量少用，只有特殊控件 需要用到行内属性，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   正确的做法是封装统一风格的所有控件。&lt;br/&gt;  （例如按钮，统一高宽，字体，字体大小，然后申明到独立的资源字典中，&lt;br/&gt;    在App.xaml中引用）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.头部资源引用情况用于 不同 Window 适应不同主题或者风格的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   比如为某一个窗口申明一个当前窗口单独使用的样式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  （例如播放器的旋转控件，只有一个页面用到，只需要在Window级引用对应资源字典）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   不放在App.xaml原因是为了降低内存消耗。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.App.xaml 里面的资源引用适用于全局资源。理论上每一个被申明的Window&lt;br/&gt;   都会创建一个对应资源字典的实例。除非是每个Window都会用到的模块，&lt;br/&gt;    不然建议放到对应Window级&lt;br/&gt;  &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Feb 2018 11:33:00 +0000</pubDate>
<dc:creator>梦机器</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DMSkin/p/8453062.html</dc:identifier>
</item>
<item>
<title>------ 新春第一炮：阶乘算法性能分析与 double fault 蓝屏故障排查 Part I ------ - f1yin9_0x5hark</title>
<link>http://www.cnblogs.com/flying-shark/p/8452931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-shark/p/8452931.html</guid>
<description>&lt;p&gt;——————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;春节期间闲来无事想研究下算法，上机测试代码却遇到了意外错误，在此记录整个过程，祝各位新的一年在算法设计和故障排查&lt;/span&gt;&lt;span&gt;方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面的思维敏锐度媲美 dog 的&lt;/span&gt;&lt;span&gt;嗅觉！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;——————————————————————————————————————————————————————————————————————————&lt;/p&gt;

&lt;p&gt;&lt;span&gt;整数 n 的阶乘（factorial）记作“&lt;span&gt;n!&lt;/span&gt;”，比如要计算 5!，那么就是计算 5 * 4 * 3 * 2 * 1 = 120。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 32 位系统上，“&lt;span&gt;unsigned int（ULONG）&lt;/span&gt;”型变量能够持有的最大 10 进制值为 4,294,967,295（FFFF FFFF），意味着无符号数最多只能用来计算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;12!（479,001,600 = 1C8C FC00）；若计算 13!（6,227,020,800 = 1 7328 CC00）就会发生溢出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类似地，“int”型变量能够持有的最大 10 进制值为 2,147,483,647（7FFF FFFF），意味着有符号数最多也只能用来计算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;12!；若计算 13! 就会发生&lt;span&gt;下溢&lt;/span&gt;（8000 0000 = -2,147,483,648）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一般的编程范式通常以&lt;span&gt;函数递归调用自身&lt;/span&gt;来实现阶乘计算，并在函数内部添加递归的终止条件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图是一种叫做“尾递归”的阶乘计算算法，从源码级别来看，它的巧妙之处在于第二个形参“computed_value”可以用来保存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本次递归的计算结果，然后作为下一次的输入。每次第一个参数“number”的值都递减，终止条件就是当它降到 1 时，即返回&lt;/span&gt;&lt;span&gt;最新的 computed_value&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;值。&lt;/span&gt;&lt;span&gt;“&lt;span&gt;tail_recursivef_factorial()&lt;/span&gt;”开头的判断逻辑确保了我们不会因为计算 13! 或更大数的阶乘导致溢出：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218161453546-954502993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;作为对比，下图则是另一种“基本递归”的阶乘计算算法，“&lt;span&gt;recursive_factorial()&lt;/span&gt;”只有一个形参，就是要计算阶乘的正整数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面的逻辑大致与 tail_recursivef_factorial() 相同，除了最后那条 return 语句，它把对自身的递归调用放进了一个&lt;/span&gt;&lt;span&gt;表达式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中，这种做法对性能的影响是&lt;/span&gt;&lt;span&gt;致命的，因为不得不等待递归调用终止才能完成整个表达式的求值计算：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218161647874-388493315.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; ————————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设我们忽略溢出的情况，或者在 64 位系统上执行这段代码，就可以传入更大的正整数。而从源码上看，recursive_factorial() &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;性能严重依赖于输入&lt;/span&gt;&lt;span&gt;参数——试想要计算 100!，它可能需要反复地创建，销毁函数调用栈帧 100 次，才能完成表达式求值并&lt;/span&gt;&lt;span&gt;返&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反观 tail_recursivef_factorial()，因为它引入了一个额外变量存储每次调用的结果，从形式上而言与 for 循环并无太大区别，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“貌似”编译器可以优化这段代码来生成与 for 循环类似的汇编指令，从而避免函数调用造成的额外 CPU 时钟周期开销（反复的&lt;/span&gt;&lt;span&gt;压&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;栈弹栈都需要访问内&lt;/span&gt;&lt;span&gt;存）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的美好愿望是：同样计算 100!，tail_recursivef_factorial() 无需多余的 99 次函数调用栈帧开销，在汇编级别&lt;/span&gt;&lt;span&gt;直接用与类似 for&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;循环的迭代控制结构即可&lt;/span&gt;&lt;span&gt;实现相同效果，使得执行时间大幅缩短。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在后面的调试环节你会看到：这个“美好愿望”或许对其它编译器而言能够成立，对 Visual C/C++ 编译器而言则不行——它还&lt;/span&gt;&lt;span&gt;不&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;够智能来进行尾递归优化&lt;/span&gt;&lt;span&gt;（或称尾递归“消除”）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;做性能分析就需要计算两者的执行时间，我们使用内核例程“&lt;span&gt;KeQuerySystemTime()&lt;/span&gt;”，分别在两个函数各自的调用前后获取一次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前系统时间，然后相减&lt;/span&gt;&lt;span&gt;得出差值，它就是两种阶乘计算算法的运行时间，如下图，注意黄框部分的逻辑，变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;量&lt;/span&gt;&lt;span&gt;“&lt;span&gt;execution_time_of_factorial_algorithm&lt;/span&gt;”存储它们各自的运行时&lt;/span&gt;&lt;span&gt;间：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218162203358-1434632024.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218162236062-753538781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 图中以内联汇编添加的软件断点是为了方便观察 KeQuerySystemTime() 如何使用“&lt;span&gt;LARGE_INTEGER&lt;/span&gt;”这个结构体：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218162335187-989114892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;原始文档写得很清楚—— KeQuerySystemTime() 输出的系统时间（由一枚“LARGE_INTEGER”型指针引用）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是&lt;span&gt;从 1601年1月1日开始至当前的“100 纳秒”数量&lt;/span&gt;，通常约每 10 毫秒会更新一次系统时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KeQuerySystemTime() 的输出值是根据 GMT 时区计算的，使用 ExSystemTimeToLocalTime() 可以把它调整为&lt;/span&gt;&lt;span&gt;本地时区的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然 1 毫秒 = 1000 微秒 = 1000000 纳秒，只需把这个值除以 10000 即可得到“毫秒数”，再除以 1000 即可得出以秒为单位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的运行时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是事情没那么简单，你想看看：从 1601年1月1日以来到当前 KeQuerySystemTime() 调用经历了多少个“100 纳秒”，无论这&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;数值为何，肯定不是 32 位系统上的 4 字节变量能够容纳得下的，所以要么在 64 位 Windows 上调试这段代码，要么必须使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LARGE_INTEGER 结构体的 &lt;span&gt;QuadPart&lt;/span&gt; 字段，该字段实质上是内存中一个连续的 8 字节区域：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218162542249-430292783.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;以 32 位系统而言，ULONG 型变量最多支持 4294967295 个“100 纳秒”，亦即 429 秒；换言之，阶乘算法运行超过 7 分钟，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就无法用 ULONG 变量（&lt;span&gt;execution_time_of_factorial_algorithm&lt;/span&gt;）存储执行时间（该值已溢出所以不正确）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-0-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这不是问题，我们的测试代码载体是内核态驱动程序，没有内核-用户模式的切换开销，加上现代高性能微处理器每秒都能够执行&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;上千万条指令，所以上述两种算法再怎么低效，执行时间应该都在&lt;span&gt;数十毫秒级别&lt;/span&gt;，除非我们计算 1000！乃至 10000！——在后面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你会看到，从理论上而言（忽略 64 位数能够表示的上限值，&lt;span&gt;即便连 64 位数也无法存放 21! 和更大的正整数阶乘值&lt;/span&gt;），&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;recursive_factorial() 求值 10000！所需的运行时间可能缓慢到秒级别，但事实上，每个线程的内核栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;空间是很狭小的，以至于当我们计算 255! 时就会因为向内核栈上压入过多的参数而越界，访问到了无效的内存地址，导致页错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;误，&lt;/span&gt;&lt;span&gt;而此后向同一个无效地址压入&lt;span&gt;异常现场&lt;/span&gt;并转移控制到错误处理程序之前，会进一步升级成“&lt;span&gt;double fault&lt;/span&gt;”，因为连续两次访&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存&lt;/span&gt;&lt;span&gt;操作都是无效的，最终致使系统崩溃蓝屏（或者断入调试器）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总而言之，两个从 1601年1月1日以来的历时是 64 位数，相减后只有低 32 位——多数情况下，高 32 位都是零。这样我们就能够&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比较&lt;/span&gt;&lt;span&gt;两种算法的性能优劣了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正如你可能意识到的那样：当要计算阶乘的数太小时，两者间的性能差距不明显，所以我把上面计算 12! 的逻辑改成了计算 229！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;，同时又不会导致内核栈溢出，调试过程如下，首先来看看 tail_recursivef_factorial() 的反汇编代码，它说明了微软 &lt;/span&gt;&lt;span&gt;Visual C/C++ 编译器是如何实现尾递归&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算法对应的指令序列：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218163207890-1901021019.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上图编号 1 黄框中的汇编代码把 ebp+8 处的内核内存与立即数 0xe6（230）比较（&lt;span&gt;cmp&lt;/span&gt;），如果低于等于 230 就跳转到 9f52e044&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;地址处执行（&lt;span&gt;jbe&lt;/span&gt;），反之则清零 eax 寄存器后跳转到 9f52e074 地址处，在那里的“pop ebp”和“ret 8”（图中没有绘出）指令序列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;导致 tail_recursivef_factorial() 返回——因此我们推断 ebp+8 就是第一个参数 &lt;span&gt;number&lt;/span&gt;，并对应于源码中检查它是否大于 &lt;/span&gt;&lt;span&gt;230 的逻辑；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类似地，编号 2 黄框中的汇编代码对应源码中检查 number 是否等于 0 的逻辑——如果不等于 0 则跳转（&lt;span&gt;jne&lt;/span&gt;）到 9f52e053&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;地址处（编号 3 黄框），在该处继续检查 number 是否等于 1 ——如果 number 已经递减至 1，表明满足递归退出条件，把&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ebp + c 处的栈内存值（亦即 第二个参数 &lt;span&gt;computed_value&lt;/span&gt; ）拷贝到 eax 寄存器内作为返回值，跳转到 9f52e074 地址处返回；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;否则，把 number 移动到 eax 中并与 computed_value 执行&lt;span&gt;有符号乘法（imul）&lt;/span&gt;，然后把存储在 eax 中的计算结果压入栈上，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时 number 递减 1 后的值移动到 ecx 中（通常被当成&lt;strong&gt;循环计数器&lt;/strong&gt;），为下一次的 tail_recursivef_factorial() 调用做好准备。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上图你可以发现两件有趣的事情：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其一，尽管我在源码中显示指定了两个参数的类型，以及返回值均为“ULONG”（无符号），但 Visual C/C++ 编译器依旧无动于衷，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;坚持在汇编级别使用有符号数乘法指令“imul”，而非无符号的版本“mul”；而根据 intel 手册，“imul”指令的双操作数模式中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果计算结果超过了目的操作数（本例中是 eax）的大小，则&lt;span&gt;从乘积的最高位开始截断——若被丢弃的不是符号位，该指令会设置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;EFLAG 寄存器中的溢出和进位标志&lt;/span&gt;—— 32 位有符号数的上限值为 2,147,483,647（7FFF FFFF），若超出就会下溢，结合上面的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反汇编代码推算：当第四次递归调用时（229 * 228 * 227 * 226，亦即当 ecx 值为 0xe2 时）就会发生下溢，&lt;/span&gt;&lt;span&gt;从而设置相关标志位，我们在后面调试会验证；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其二，尽管源码中的尾递归调用已经刻意书写成能够被编译器利用等价的迭代控制结构替换，从而节约反复的函数调用开销，但&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Visual C/C++ 却笨得没有意识到这一点，还是傻傻地照本宣科来翻译，&lt;span&gt;这导致我们的 tail_recursivef_factorial() 实际执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;性能不如理论上那样比基本递归的 recursive_factorial() 优越！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;了解 tail_recursivef_factorial() 的机器机实现后，接下来就是断点设置的艺术了——当前触发的断点是我在源码中指定的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;，位于 KeQuerySystemTime() 调用前，目的是检查 LARGE_INTEGER 结构体是怎样被使用的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218163908655-304935912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上图中 ebp-18 处的内核栈内容是啥？让我们观察 DriverEntry() 的局部变量统计信息：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218164033593-851879865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;原来 ebp-18 处就是一个 LARGE_INTEGER 实例—— &lt;span&gt;current_time_BEFORE_compute_factorial&lt;/span&gt;，而指令“lea eax,[ebp-18h]”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把它的地址移动到 eax 中，然后压入栈上，这符合 KeQuerySystemTime() 的形参类型要求—— C 的取地址操作符“&lt;span&gt;&amp;amp;&lt;/span&gt;”在汇编级别&lt;/span&gt;&lt;span&gt;用“&lt;span&gt;lea&lt;/span&gt;”指令实&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现，形参“&lt;strong&gt;&lt;span&gt;P&lt;/span&gt;&lt;/strong&gt;LARGE_INTEGER”需要持有一个 LARGE_INTEGER 实例的地址，单步跟踪（F8）验证：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218164247046-815958998.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;此刻我们进入了系统例程 KeQuerySystemTime() 内部，我们想知道它当它返回后，变量 current_time_BEFORE_compute_factorial&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的内部组织形式；同时还要在后续的 tail_recursivef_factorial() 调用内部设置几个断点，方便研究“imul”指令的行为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218164406437-1658329909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上图分别在 KeQuerySystemTime() 返回后（&lt;span&gt;返回地址 9f52e0a1&lt;/span&gt; 那里），以及 tail_recursivef_factorial() 内部的“imul”指令&lt;/span&gt;&lt;span&gt;地址处（&lt;span&gt;9f52e063&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;处），设置了两个断点，我们按下“g”键继续执行以触发第一个断点，然后观察存储了当前系统时间的 &lt;/span&gt;&lt;span&gt;current_time_BEFORE_compute_factorial 结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构内部：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218164542062-946644649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可以看到 current_time_BEFORE_compute_factorial 的 QuadPart 字段 10 进制值为 131633454897796336，它就是自从&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1601年1月1日以来经过的“100”纳秒数量——让我们转换成年：131633454897796336 / (10000 * 1000 * 60 * 60 * 24 * 365) = &lt;span&gt;417&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最终结果等于 2018 - 1601 = 417 年&lt;/strong&gt;。至此我们成功通过 KeQuerySystemTime() 获取到当前系统时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外，ebp-10 处的内核栈存储另一个 LARGE_INTEGER 实例：current_time_AFTER_compute_factorial，两者占用的空间差值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（0x8 字节）就是 LARGE_INTEGER 结构体的大小。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;先&lt;/span&gt;&lt;span&gt;禁用掉 9f52e063 的断点，然后在 &lt;span&gt;9f52e0bb&lt;/span&gt; 处，也就是第二次 KeQuerySystemTime() 调用的返回地址设置第三个断点，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样可以准确地计算出尾递归阶乘算法的执行时间，如下图所示，把这两个 LARGE_INTEGER 的 &lt;span&gt;QuadPart&lt;/span&gt; 字段值相减，换算成毫秒，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行时间为：(131633454897826432 - 131633454897796336) / 10000 = &lt;span&gt;3 毫秒&lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;229! 值为零是因为发生了溢出（前面讲过，32 位系统上计算 13! 就会溢出）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218164901765-406357319.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218164954249-1941835198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218165130015-1907718344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;经过多次反复调试，证明 tail_recursivef_factorial() 计算 229! 时的运行时间在 2—4 毫秒之间，看来即便没有做编译器优化，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CPU 的高速运算能力也让两百多次的函数调用在毫秒级别就能够完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-17-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-18-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-19-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-20-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-21-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-22-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-23-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-24-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-25-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-26-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-27-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-28-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-29-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-30-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-31-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-32-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-33-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;span class=&quot;_3gl1 _5zz4&quot; data-offset-key=&quot;5sce0-34-0&quot;&gt;&lt;span class=&quot;_ncl&quot;&gt;👽&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一次让我们在 tail_recursivef_factorial() 内部的“imul”指令地址处设置断点，&lt;span&gt;由于递归调用的关系，这个断点每次都会&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;被触发，直至满足终止条件&lt;/span&gt;；在经过四次调用后的概况如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218165227077-791767737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如上图所示，在第四次执行“imul”指令前，内核栈上已经有 4 次 tail_recursivef_factorial() 的栈帧记录；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前的 Computed_Value 值为 &lt;span&gt;11,852,124（0xb4d95c）&lt;/span&gt;，也就是 229 * 228 * 227 ——前三次“imul”指令的执行结果，假设&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本次再执行“imul”指令把 Computed_Value 与 eax 的当前值（0xe2，亦即 226）相乘，就会发生溢出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“elf = 00000206”是执行前的 EFLAG 寄存器内容，解码后的标志位如下图，表明尚未溢出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218165802655-1585867354.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一个关键信息是红框处的 ebp 值，它暗示每次递归调用都会消耗 &lt;span&gt;16 字节&lt;/span&gt;的内核栈空间——这 16 字节是怎么来的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再次回顾 tail_recursivef_factorial() 的反汇编代码，第一条使用栈上 4 字节空间的指令是“push ebp”、第二条是&lt;/span&gt;&lt;span&gt;“push eax”，第三条是“push&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ecx”。。。而在“call computefactorialtail!tail_recursivef_factorial”执行前&lt;/span&gt;&lt;span&gt;，会隐式地压入 4 字节的返回地址，这&lt;/span&gt;&lt;span&gt;是“call”指令内建的功能，不会作为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反汇编输出：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218165441874-21465168.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;查看当前执行线程的内核栈，可知其下限在 &lt;span&gt;8b715000&lt;/span&gt; 地址处；而首次的 tail_recursivef_factorial() 调用是从 &lt;/span&gt;&lt;span&gt;&lt;span&gt;8b717aa8&lt;/span&gt; 地址处开始消耗栈空间的，换言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之：(8b717aa8 - 8b715000) / 0x10 = 0n682，仅能够供 682 次递归调用，&lt;/span&gt;&lt;span&gt;&lt;span&gt;第 683 次调用就会越界&lt;/span&gt;，访问到尚未分配的物理内存区域，引发一次页错误，后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面我修改源码计算 683! 并在调试时就会出现&lt;/span&gt;&lt;span&gt;这种情况，它会升级为“double fault”：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218165632499-152842818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 现在单步执行，然后检查“imul”指令的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180218165907405-2108204038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上图中的 EFLAG 寄存器内容（0xa83）经解码后显示&lt;span&gt;符号位&lt;/span&gt;和&lt;span&gt;溢出位&lt;/span&gt;都被设置了，表明乘法运算发生了下溢，观察 eax 中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存储的计算结果“9fa7e338”，它的 10 进制值为“&lt;strong&gt;&lt;span&gt;-1,616,387,272&lt;/span&gt;&lt;/strong&gt;”，所以后续的计算结果都是错误的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; ——————————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结：本篇介绍通过获取当前系统时间来测量程序或一段代码&lt;span&gt;块&lt;/span&gt;执行性能的方法，揭示了神秘的“LARGE_INTEGER”工作机制，&lt;/span&gt;&lt;span&gt;并且比较源码级和机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;器&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;指令级算法实现的区别——其差异性完全由编译器主导；接着演示 32 位有符号数的溢出。。。所有&lt;/span&gt;&lt;span&gt;这些都是在内核态下进行的，因此可谓比一般的用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;户&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;态调试更“底层”。&lt;/span&gt;&lt;span&gt;限于篇幅，下一篇将比较另一种阶乘算法“recursive_factorial()”的机器级实现、执行性能，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;然后通过递归调用访问无效的内核&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;栈区域触发“double fault”并进行故障排查！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;————————————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
</description>
<pubDate>Sun, 18 Feb 2018 09:04:00 +0000</pubDate>
<dc:creator>f1yin9_0x5hark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-shark/p/8452931.html</dc:identifier>
</item>
<item>
<title>JDBC【事务、元数据、改造JDBC工具类】 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8452924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8452924.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个SESSION所进行的所有更新操作要么一起成功，要么一起失败&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子:&lt;strong&gt;A向B转账，转账这个流程中如果出现问题，事务可以让数据恢复成原来一样【A账户的钱没变，B账户的钱也没变】。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事例说明：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

        &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        * 我们来模拟A向B账号转账的场景&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        *   A和B账户都有1000块，现在我让A账户向B账号转500块钱&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        * */&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//JDBC默认的情况下是关闭事务的，下面我们看看关闭事务去操作转账操作有什么问题&lt;/span&gt;

            &lt;span class=&quot;co&quot;&gt;//A账户减去500块&lt;/span&gt;
            String sql = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE a SET money=money-500 &quot;&lt;/span&gt;;
            preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql);
            preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();

            &lt;span class=&quot;co&quot;&gt;//B账户多了500块&lt;/span&gt;
            String sql2 = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE b SET money=money+500&quot;&lt;/span&gt;;
            preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql2);
            preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面看，我们的确可以发现A向B转账，成功了。可是&lt;strong&gt;如果A向B转账的过程中出现了问题呢？&lt;/strong&gt;下面模拟一下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
            &lt;span class=&quot;co&quot;&gt;//A账户减去500块&lt;/span&gt;
            String sql = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE a SET money=money-500 &quot;&lt;/span&gt;;
            preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql);
            preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();
            
            &lt;span class=&quot;co&quot;&gt;//这里模拟出现问题&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;


            String sql2 = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE b SET money=money+500&quot;&lt;/span&gt;;
            preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql2);
            preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，上面&lt;strong&gt;代码是会抛出异常的&lt;/strong&gt;，我们再来查询一下数据。&lt;strong&gt;A账户少了500块钱，B账户的钱没有增加&lt;/strong&gt;。&lt;strong&gt;这明显是不合理的&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我们可以通过事务来解决上面出现的问题&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
            &lt;span class=&quot;co&quot;&gt;//开启事务,对数据的操作就不会立即生效。&lt;/span&gt;
            connection.&lt;span class=&quot;fu&quot;&gt;setAutoCommit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
            
            &lt;span class=&quot;co&quot;&gt;//A账户减去500块&lt;/span&gt;
            String sql = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE a SET money=money-500 &quot;&lt;/span&gt;;
            preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql);
            preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();

            &lt;span class=&quot;co&quot;&gt;//在转账过程中出现问题&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

            &lt;span class=&quot;co&quot;&gt;//B账户多500块&lt;/span&gt;
            String sql2 = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE b SET money=money+500&quot;&lt;/span&gt;;
            preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql2);
            preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();
            
            &lt;span class=&quot;co&quot;&gt;//如果程序能执行到这里，没有抛出异常，我们就提交数据&lt;/span&gt;
            connection.&lt;span class=&quot;fu&quot;&gt;commit&lt;/span&gt;();

            &lt;span class=&quot;co&quot;&gt;//关闭事务【自动提交】&lt;/span&gt;
            connection.&lt;span class=&quot;fu&quot;&gt;setAutoCommit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
            

        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;//如果出现了异常，就会进到这里来，我们就把事务回滚【将数据变成原来那样】&lt;/span&gt;
                connection.&lt;span class=&quot;fu&quot;&gt;rollback&lt;/span&gt;();
                
                &lt;span class=&quot;co&quot;&gt;//关闭事务【自动提交】&lt;/span&gt;
                connection.&lt;span class=&quot;fu&quot;&gt;setAutoCommit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e1) {
                e1.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的程序也一样抛出了异常，A账户钱没有减少，B账户的钱也没有增加。&lt;/p&gt;
&lt;p&gt;注意：当Connection遇到一个未处理的SQLException时，系统会非正常退出，事务也会自动回滚，但&lt;strong&gt;如果程序捕获到了异常，是需要在catch中显式回滚事务的。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;savapoint&quot;&gt;savapoint&lt;/h3&gt;
&lt;p&gt;我们还可以使用savepoint设置中间点。如果在某地方出错了，我们设置中间点，回滚到出错之前即可。&lt;/p&gt;
&lt;p&gt;应用场景：现在我们要算一道数学题，算到后面发现算错数了。前面的运算都是正确的，我们不可能重头再算【直接rollback】，最好的做法就是在&lt;strong&gt;保证前面算对的情况下，设置一个保存点。从保存点开始重新算。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;savepoint不会结束当前事务，普通提交和回滚都会结束当前事务的&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;事务的隔离级别&quot;&gt;事务的隔离级别&lt;/h3&gt;
&lt;p&gt;数据库定义了4个隔离级别：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Serializable【可避免脏读，不可重复读，虚读】&lt;/li&gt;
&lt;li&gt;Repeatable read【可避免脏读，不可重复读】&lt;/li&gt;
&lt;li&gt;Read committed【可避免脏读】&lt;/li&gt;
&lt;li&gt;Read uncommitted【级别最低，什么都避免不了】&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分别对应Connection类中的4个常量&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;TRANSACTION_READ_UNCOMMITTED&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TRANSACTION_READ_COMMITTED&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TRANSACTION_REPEATABLE_READ&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TRANSACTION_SERIALIZABLE&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;脏读：&lt;strong&gt;一个事务读取到另外一个事务未提交的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例子：A向B转账，&lt;strong&gt;A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了&lt;/strong&gt;！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;不可重复读：&lt;strong&gt;一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注：&lt;strong&gt;A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的，那么A查询出来的信息就没有意思了】&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;虚读(幻读)：&lt;strong&gt;是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注：&lt;strong&gt;和不可重复读类似，但虚读(幻读)会读到其他事务的插入的数据，导致前后读取不一致&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;简单总结：&lt;strong&gt;脏读是不可容忍的，不可重复读和虚读在一定的情况下是可以的【做统计的肯定就不行】&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3 id=&quot;什么是元数据&quot;&gt;什么是元数据&lt;/h3&gt;
&lt;p&gt;元数据其实就是数据库，表，列的定义信息&lt;/p&gt;
&lt;h3 id=&quot;为什么我们要用元数据&quot;&gt;为什么我们要用元数据&lt;/h3&gt;
&lt;p&gt;即使我们写了一个简单工具类，我们的代码还是非常冗余。&lt;strong&gt;对于增删改而言，只有SQL和参数是不同的&lt;/strong&gt;，我们为何不把这些相同的代码抽取成一个方法？对于&lt;strong&gt;查询而言&lt;/strong&gt;，&lt;strong&gt;不同的实体查询出来的结果集是不一样的&lt;/strong&gt;。我们要&lt;strong&gt;使用元数据获取结果集的信息，才能对结果集进行操作&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ParameterMetaData --参数的元数据&lt;/li&gt;
&lt;li&gt;ResultSetMetaData --结果集的元数据&lt;/li&gt;
&lt;li&gt;DataBaseMetaData --数据库的元数据&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;问题：我们&lt;strong&gt;对数据库的增删改查都要连接数据库，关闭资源，获取PreparedSteatment对象，获取Connection对象此类的操作，这样的代码重复率是极高的&lt;/strong&gt;，所以我们要对工具类进行增强&lt;/p&gt;
&lt;h3 id=&quot;增删改&quot;&gt;增删改&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;//我们发现，增删改只有SQL语句和传入的参数是不知道的而已，所以让调用该方法的人传递进来&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;//由于传递进来的参数是各种类型的，而且数目是不确定的，所以使用Object[]&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(String sql, Object[] objects) {

        Connection connection = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        PreparedStatement preparedStatement = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        ResultSet resultSet = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            connection = &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;();
            preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql);

            &lt;span class=&quot;co&quot;&gt;//根据传递进来的参数，设置SQL占位符的值&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; objects.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; i++) {
                preparedStatement.&lt;span class=&quot;fu&quot;&gt;setObject&lt;/span&gt;(i + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, objects[i]);
            }

            &lt;span class=&quot;co&quot;&gt;//执行SQL语句&lt;/span&gt;
            preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeUpdate&lt;/span&gt;();


        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;查询&quot;&gt;查询&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        1:对于查询语句来说，我们不知道对结果集进行什么操作【常用的就是把数据封装成一个Bean对象，封装成一个List集合】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        2:我们可以定义一个接口，让调用者把接口的实现类传递进来&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        3:这样接口调用的方法就是调用者传递进来实现类的方法。【策略模式】&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;    */&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//这个方法的返回值是任意类型的，所以定义为Object。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;(String sql, Object[] objects, ResultSetHandler rsh) {

        Connection connection = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        PreparedStatement preparedStatement = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        ResultSet resultSet = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            connection = &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;();
            preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql);

            &lt;span class=&quot;co&quot;&gt;//根据传递进来的参数，设置SQL占位符的值&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (objects != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; objects.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; i++) {
                    preparedStatement.&lt;span class=&quot;fu&quot;&gt;setObject&lt;/span&gt;(i + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, objects[i]);
                }
            }


            resultSet = preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeQuery&lt;/span&gt;();

            &lt;span class=&quot;co&quot;&gt;//调用调用者传递进来实现类的方法，对结果集进行操作&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; rsh.&lt;span class=&quot;fu&quot;&gt;hanlder&lt;/span&gt;(resultSet);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;接口：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    * 定义对结果集操作的接口，调用者想要对结果集进行什么操作，只要实现这个接口即可&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    * */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; ResultSetHandler {
         Object &lt;span class=&quot;fu&quot;&gt;hanlder&lt;/span&gt;(ResultSet resultSet);
    
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实现类：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

&lt;span class=&quot;co&quot;&gt;//接口实现类，对结果集封装成一个Bean对象&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BeanHandler &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; ResultSetHandler {


    &lt;span class=&quot;co&quot;&gt;//要封装成一个Bean对象，首先要知道Bean是什么，这个也是调用者传递进来的。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Class clazz;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanHandler&lt;/span&gt;(Class clazz) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;clazz&lt;/span&gt; = clazz;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;hanlder&lt;/span&gt;(ResultSet resultSet) {

        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {

            &lt;span class=&quot;co&quot;&gt;//创建传进对象的实例化&lt;/span&gt;
            Object bean = clazz.&lt;span class=&quot;fu&quot;&gt;newInstance&lt;/span&gt;();

            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (resultSet.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;()) {

                &lt;span class=&quot;co&quot;&gt;//拿到结果集元数据&lt;/span&gt;
                ResultSetMetaData resultSetMetaData = resultSet.&lt;span class=&quot;fu&quot;&gt;getMetaData&lt;/span&gt;();

                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; resultSetMetaData.&lt;span class=&quot;fu&quot;&gt;getColumnCount&lt;/span&gt;(); i++) {

                    &lt;span class=&quot;co&quot;&gt;//获取到每列的列名&lt;/span&gt;
                    String columnName = resultSetMetaData.&lt;span class=&quot;fu&quot;&gt;getColumnName&lt;/span&gt;(i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;);

                    &lt;span class=&quot;co&quot;&gt;//获取到每列的数据&lt;/span&gt;
                    String columnData = resultSet.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;);

                    &lt;span class=&quot;co&quot;&gt;//设置Bean属性&lt;/span&gt;
                    Field field = clazz.&lt;span class=&quot;fu&quot;&gt;getDeclaredField&lt;/span&gt;(columnName);
                    field.&lt;span class=&quot;fu&quot;&gt;setAccessible&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
                    field.&lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(bean,columnData);
                }

                &lt;span class=&quot;co&quot;&gt;//返回Bean对象&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; bean;
            }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;【策略模式】简单理解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们并不知道调用者想对结果集进行怎么样的操作，于是&lt;strong&gt;让调用者把想要做的操作对象传递过来&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;我们只要&lt;strong&gt;用传递过来的对象对结果集进行封装&lt;/strong&gt;就好了。
&lt;ul&gt;&lt;li&gt;至于调用者会传递什么对象过来，该对象要实现什么方法。我们可以&lt;strong&gt;使用接口来对其规范&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
对我个人理解，&lt;strong&gt;策略模式就是我们在使用别人API时，可以使用匿名内部类的时候。别人用的就是策略模式。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章的同学，&lt;strong&gt;可以关注微信公众号:Java3y&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 18 Feb 2018 08:56:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8452924.html</dc:identifier>
</item>
<item>
<title>Java实现单链表的快速排序和归并排序 - morethink</title>
<link>http://www.cnblogs.com/morethink/p/8452914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/morethink/p/8452914.html</guid>
<description>&lt;p&gt;本文描述了LeetCode 148题 &lt;a href=&quot;https://leetcode.com/problems/sort-list/description/&quot;&gt;sort-list&lt;/a&gt; 的解法。&lt;/p&gt;
&lt;p&gt;题目描述如下:&lt;br/&gt;Sort a linked list in O(n log n) time using constant space complexity.&lt;/p&gt;
&lt;p&gt;题目要求我们在O(n log n)时间复杂度下完成对单链表的排序，我们知道平均时间复杂度为O(n log n)的排序方法有快速排序、归并排序和堆排序。而一般是用数组来实现二叉堆，当然可以用二叉树来实现，但是这么做太麻烦，还得花费额外的空间构建二叉树，于是不采用堆排序。&lt;/p&gt;&lt;p&gt;故本文采用快速排序和归并排序来对单链表进行排序。&lt;/p&gt;

&lt;p&gt;在一般实现的快速排序中，我们通过首尾指针来对元素进行切分，下面采用快排的另一种方法来对元素进行切分。&lt;/p&gt;
&lt;p&gt;我们只需要两个指针p1和p2，这两个指针均往next方向移动，移动的过程中保持p1之前的key都小于选定的key，p1和p2之间的key都大于选定的key，那么当p2走到末尾时交换p1与key值便完成了一次切分。&lt;/p&gt;
&lt;p&gt;图示如下：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140326225106296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZG91ZmVpX2Njc3Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ListNode &lt;span class=&quot;fu&quot;&gt;sortList&lt;/span&gt;(ListNode head) {
    &lt;span class=&quot;co&quot;&gt;//采用快速排序&lt;/span&gt;
   &lt;span class=&quot;fu&quot;&gt;quickSort&lt;/span&gt;(head, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
   &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; head;
}
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;quickSort&lt;/span&gt;(ListNode head, ListNode end) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (head != end) {
        ListNode node = &lt;span class=&quot;fu&quot;&gt;partion&lt;/span&gt;(head, end);
        &lt;span class=&quot;fu&quot;&gt;quickSort&lt;/span&gt;(head, node);
        &lt;span class=&quot;fu&quot;&gt;quickSort&lt;/span&gt;(node.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;, end);
    }
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ListNode &lt;span class=&quot;fu&quot;&gt;partion&lt;/span&gt;(ListNode head, ListNode end) {
    ListNode p1 = head, p2 = head.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;//走到末尾才停&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (p2 != end) {

        &lt;span class=&quot;co&quot;&gt;//大于key值时，p1向前走一步，交换p1与p2的值&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p2.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt; &amp;lt; head.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt;) {
            p1 = p1.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;

            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp = p1.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt;;
            p1.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt; = p2.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt;;
            p2.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt; = temp;
        }
        p2 = p2.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
    }

    &lt;span class=&quot;co&quot;&gt;//当有序时，不交换p1和key值&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p1 != head) {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp = p1.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt;;
        p1.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt; = head.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt;;
        head.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt; = temp;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; p1;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;归并排序应该算是链表排序最佳的选择了，保证了最好和最坏时间复杂度都是nlogn，而且它在数组排序中广受诟病的空间复杂度在链表排序中也从O(n)降到了O(1)。&lt;/p&gt;
&lt;p&gt;归并排序的一般步骤为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将待排序数组（链表）取中点并一分为二；&lt;/li&gt;
&lt;li&gt;递归地对左半部分进行归并排序；&lt;/li&gt;
&lt;li&gt;递归地对右半部分进行归并排序；&lt;/li&gt;
&lt;li&gt;将两个半部分进行合并（merge）,得到结果。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首先用快慢指针(快慢指针思路，快指针一次走两步，慢指针一次走一步，快指针在链表末尾时，慢指针恰好在链表中点)的方法找到链表中间节点，然后递归的对两个子链表排序，把两个排好序的子链表合并成一条有序的链表。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ListNode &lt;span class=&quot;fu&quot;&gt;sortList&lt;/span&gt;(ListNode head) {
    &lt;span class=&quot;co&quot;&gt;//采用归并排序&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (head == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || head.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; head;
    }
    &lt;span class=&quot;co&quot;&gt;//获取中间结点&lt;/span&gt;
    ListNode mid = &lt;span class=&quot;fu&quot;&gt;getMid&lt;/span&gt;(head);
    ListNode right = mid.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
    mid.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;//合并&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;mergeSort&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;sortList&lt;/span&gt;(head), &lt;span class=&quot;fu&quot;&gt;sortList&lt;/span&gt;(right));
}

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 获取链表的中间结点,偶数时取中间第一个&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param head&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @return&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ListNode &lt;span class=&quot;fu&quot;&gt;getMid&lt;/span&gt;(ListNode head) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (head == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || head.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; head;
    }
    &lt;span class=&quot;co&quot;&gt;//快慢指针&lt;/span&gt;
    ListNode slow = head, quick = head;
    &lt;span class=&quot;co&quot;&gt;//快2步，慢一步&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (quick.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; quick.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        slow = slow.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
        quick = quick.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; slow;
}

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 归并两个有序的链表&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param head1&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param head2&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @return&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ListNode &lt;span class=&quot;fu&quot;&gt;mergeSort&lt;/span&gt;(ListNode head1, ListNode head2) {
    ListNode p1 = head1, p2 = head2, head;
   &lt;span class=&quot;co&quot;&gt;//得到头节点的指向&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (head1.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt; &amp;lt; head2.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt;) {
        head = head1;
        p1 = p1.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        head = head2;
        p2 = p2.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
    }

    ListNode p = head;
    &lt;span class=&quot;co&quot;&gt;//比较链表中的值&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (p1 != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; p2 != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p1.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt; &amp;lt;= p2.&lt;span class=&quot;fu&quot;&gt;val&lt;/span&gt;) {
            p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = p1;
            p1 = p1.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
            p = p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = p2;
            p2 = p2.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
            p = p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
        }
    }
    &lt;span class=&quot;co&quot;&gt;//第二条链表空了&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p1 != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = p1;
    }
    &lt;span class=&quot;co&quot;&gt;//第一条链表空了&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p2 != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = p2;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; head;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整代码放在：&lt;br/&gt;&lt;a href=&quot;https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/SortList.java&quot; class=&quot;uri&quot;&gt;https://github.com/morethink/algorithm/blob/master/src/algorithm/leetcode/SortList.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文档&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/TenosDoIt/p/3666585.html&quot;&gt;链表排序（冒泡、选择、插入、快排、归并、希尔、堆排序）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 18 Feb 2018 08:50:00 +0000</pubDate>
<dc:creator>morethink</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/morethink/p/8452914.html</dc:identifier>
</item>
<item>
<title>【开源项目】将图片转换为字符画 - xiaoxi666</title>
<link>http://www.cnblogs.com/xiaoxi666/p/8452717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxi666/p/8452717.html</guid>
<description>&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;选定填充图片的ASCII字符，不同的字符对应于不同的灰度&lt;/li&gt;
&lt;li&gt;读取图片并计算各像素灰度值（同时考虑透明背景），用相应的的ASCII字符替换该像素&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;程序功能&quot;&gt;程序功能&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;支持3种文件选择方式：选定文件（支持图片预览），添加文件夹，拖入文件&lt;/li&gt;
&lt;li&gt;支持5种图片格式：.jpg， .jpeg， .gif， .png，.bmp&lt;/li&gt;
&lt;li&gt;支持5挡不同的缩放比例：10%，20%，25%，50%，以及不缩放，默认为不缩放&lt;/li&gt;
&lt;li&gt;转换结果以文件名“原文件名+.txt”保存至新建文件夹，新建文件夹的命名方式为“字符画转换结果+当前时间”，其中当前时间的格式为“年_月_日_时_分_秒”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;建议：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;转换后的txt文件最好用notepad++等类似软件打开，这类软件不会将内容换行，同时支持缩放&lt;/li&gt;
&lt;li&gt;图片宽和高最好控制在1000px以内，太大的话，出来的图太过精细，不方便查看。这时可利用缩放功能。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;可视化界面&quot;&gt;可视化界面&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;为方便操作，特意包装成可视化界面，并加入“保持窗口最前”选项，方便文件拖入&lt;/li&gt;
&lt;li&gt;注意：如果所选文件格式不正确，“开始转换”按钮不可用&lt;/li&gt;
&lt;li&gt;程序已打包为exe文件64位版本，可以直接使用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;源码exe文件-以及-软件截图效果图&quot;&gt;源码、exe文件 以及 软件截图、效果图&lt;/h2&gt;
&lt;p&gt;请移步Github仓库：&lt;a href=&quot;https://github.com/xiaoxi666/Img2AsciiVision&quot; class=&quot;uri&quot;&gt;https://github.com/xiaoxi666/Img2AsciiVision&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;source文件夹：源码及其资源文件&lt;/li&gt;
&lt;li&gt;ExecuteFileAndPackageTools文件夹：可执行文件Img2Ascii.exe及其打包工具&lt;/li&gt;
&lt;li&gt;Demos文件夹： 软件截图和效果图&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;软件截图和效果图&quot;&gt;软件截图和效果图&lt;/h2&gt;
&lt;p&gt;软件截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/609124/201802/609124-20180218134834515-1146101988.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原图：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/609124/201802/609124-20180218134908577-542600774.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转换为Ascii后的字符画：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/609124/201802/609124-20180218134921827-1667081202.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;局部放大图（可以看到Ascii码字符）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/609124/201802/609124-20180218135002905-1345819393.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Feb 2018 05:35:00 +0000</pubDate>
<dc:creator>xiaoxi666</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxi666/p/8452717.html</dc:identifier>
</item>
<item>
<title>获取View组件宽度以及ViewTreeObserver - ganchuanpu</title>
<link>http://www.cnblogs.com/ganchuanpu/p/8452698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ganchuanpu/p/8452698.html</guid>
<description>&lt;h2&gt;View宽高测量方法：&lt;/h2&gt;
&lt;p&gt;测量方法有三种，如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）&lt;/strong&gt;（直接在onCreate()执行）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; w = View.MeasureSpec.makeMeasureSpec(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,View.MeasureSpec.UNSPECIFIED);  
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = View.MeasureSpec.makeMeasureSpec(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,View.MeasureSpec.UNSPECIFIED);  
imageView.measure(w, h);  
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; height =&lt;span&gt;imageView.getMeasuredHeight();  
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; width =&lt;span&gt;imageView.getMeasuredWidth();  
textView.append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+height+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+width);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）&lt;/span&gt;&lt;/strong&gt;2和3都是在onCreate()调用完后回调拿到组件的宽高&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ViewTreeObserver vto =&lt;span&gt; imageView.getViewTreeObserver();  
vto.addOnPreDrawListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ViewTreeObserver.OnPreDrawListener() {  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean onPreDraw() {  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; imageView.getMeasuredHeight();  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; width =&lt;span&gt; imageView.getMeasuredWidth();  
        textView.append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+height+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;width);  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
    }  
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ViewTreeObserver vto2 =&lt;span&gt; imageView.getViewTreeObserver();    
vto2.addOnGlobalLayoutListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnGlobalLayoutListener() {  
    @Override    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onGlobalLayout() {  
        imageView.getViewTreeObserver().removeGlobalOnLayoutListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);    
        textView.append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+imageView.getHeight()+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;imageView.getWidth());  
    }    
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：方法一比其他方法多一次onMeasure计算，方法二的回调函数会被多次调用。&lt;/p&gt;
&lt;p&gt;转自http://blog.csdn.net/johnny901114/article/details/7839512&lt;/p&gt;
&lt;h2&gt;ViewTreeObserver&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一、结构&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; final &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ViewTreeObserver extends Object
    java.lang.Object
         android.view.ViewTreeObserver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二、概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    这是一个注册监听视图树的观察者(observer)，在视图树种全局事件改变时得到通知。这个全局事件不仅还包括整个树的布局，从绘画过程开始，触摸模式的改变等。ViewTreeObserver不能够被应用程序实例化，因为它是由视图提供，参照getViewTreeObserver()以查看更多信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、内部类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;  ViewTreeObserver.OnGlobalFocusChangeListener         
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当在一个视图树中的焦点状态发生改变时，所要调用的回调函数的接口类&lt;/span&gt;
 
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;  ViewTreeObserver.OnGlobalLayoutListener
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时，所要调用的回调函数的接口类&lt;/span&gt;
 
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;  ViewTreeObserver.OnPreDrawListener
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当一个视图树将要绘制时，所要调用的回调函数的接口类&lt;/span&gt;
 
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;  ViewTreeObserver.OnScrollChangedListener
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当一个视图树中的一些组件发生滚动时，所要调用的回调函数的接口类&lt;/span&gt;
 
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;  ViewTreeObserver.OnTouchModeChangeListener
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当一个视图树的触摸模式发生改变时，所要调用的回调函数的接口类&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、公共方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*注册一个回调函数，当在一个视图树中的焦点状态发生改变时调用这个回调函数。
 * 参数 listener    将要被添加的回调函数
 *异常 IllegalStateException       如果isAlive() 返回false
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addOnGlobalFocusChangeListener (ViewTreeObserver.OnGlobalFocusChangeListener listener)
     
 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*注册一个回调函数，当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时调用这个回调函数。
 *参数 listener    将要被添加的回调函数
 *异常 IllegalStateException       如果isAlive() 返回false
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addOnGlobalLayoutListener (ViewTreeObserver.OnGlobalLayoutListener listener)
　　
 
　　
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*注册一个回调函数，当一个视图树将要绘制时调用这个回调函数。
 *参数 listener    将要被添加的回调函数
 *异常 IllegalStateException       如果isAlive() 返回false
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
　&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addOnPreDrawListener (ViewTreeObserver.OnPreDrawListener listener)
 
　   
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*注册一个回调函数，当一个视图发生滚动时调用这个回调函数。
  *参数 listener    将要被添加的回调函数
　*异常 IllegalStateException       如果isAlive() 返回false
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addOnScrollChangedListener (ViewTreeObserver.OnScrollChangedListener listener)  
 
　
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*注册一个回调函数，当一个触摸模式发生改变时调用这个回调函数。
  *参数 listener    将要被添加的回调函数
  *异常 IllegalStateException       如果isAlive() 返回false
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addOnTouchModeChangeListener (ViewTreeObserver.OnTouchModeChangeListener listener)
 
　　
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当整个布局发生改变时通知相应的注册监听器。如果你强制对视图布局或者在一个没有附加到一个窗口的视图的层次结构或者在GONE状态下，它可以被手动的调用&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispatchOnGlobalLayout ()
    
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*当一个视图树将要绘制时通知相应的注册监听器。如果这个监听器返回true，则这个绘制将被取消并重新计划。如果你强制对视图布局或者在一个没有附加到一个窗口的视图的层次结构或者在一个GONE状态下，它可以被手动的调用
 *返回值  当前绘制能够取消并重新计划则返回true，否则返回false。
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; final boolean dispatchOnPreDraw ()
 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*指示当前的ViewTreeObserver是否可用(alive)。当observer不可用时，任何方法的调用（除了这个方法）都将抛出一个异常。如果一个应用程序保持和ViewTreeObserver一个历时较长的引用，它应该总是需要在调用别的方法之前去检测这个方法的返回值。
　*返回值 但这个对象可用则返回true，否则返回false   
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean isAlive ()
    
     
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*移除之前已经注册的全局布局回调函数。
  *参数 victim 将要被移除的回调函数
  *异常 IllegalStateException       如果isAlive() 返回false   
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeGlobalOnLayoutListener (ViewTreeObserver.OnGlobalLayoutListener victim)
　　
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*移除之前已经注册的焦点改变回调函数。
　*参数 victim 将要被移除的回调函数
　*异常 IllegalStateException       如果isAlive() 返回false 
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeOnGlobalFocusChangeListener (ViewTreeObserver.OnGlobalFocusChangeListener victim)
　　
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*移除之前已经注册的预绘制回调函数。
　*参数 victim 将要被移除的回调函数
　 *异常 IllegalStateException       如果isAlive() 返回false  
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeOnPreDrawListener (ViewTreeObserver.OnPreDrawListener victim)
　　
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*移除之前已经注册的滚动改变回调函数。
　*参数 victim 将要被移除的回调函数
　*异常 IllegalStateException       如果isAlive() 返回false 
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeOnScrollChangedListener (ViewTreeObserver.OnScrollChangedListener victim)
　
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*移除之前已经注册的触摸模式改变回调函数
　*参数 victim 将要被移除的回调函数
　*异常 　IllegalStateException       如果isAlive() 返回false
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; removeOnTouchModeChangeListener (ViewTreeObserver.OnTouchModeChangeListener victim)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;五、代码示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;1、创建监听器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; final ViewTreeObserver.OnGlobalLayoutListener mGlobalLayoutListener = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ViewTreeObserver.OnGlobalLayoutListener() {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onGlobalLayout() {
      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; width = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; height = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
      
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        width &lt;/span&gt;=&lt;span&gt; getActivity().getWindow().getDecorView().getWidth();
        height &lt;/span&gt;=&lt;span&gt; getActivity().getWindow().getDecorView().getHeight();
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; called too early. so, just skip.&lt;/span&gt;
&lt;span&gt;      }
      
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (width != -&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; mGlobalLayoutWidth != width) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有当尺寸真正有了数值，即已经确定了，更新UI才有意义&lt;/span&gt;
        mGlobalLayoutWidth =&lt;span&gt; width;
        updateUI();
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (height != -&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; mGlobalLayoutHeight !=&lt;span&gt; height) {
        mGlobalLayoutHeight &lt;/span&gt;=&lt;span&gt; height;                
    updateUI();
 } } };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、一般在onCreate或onCreateView中注册监听器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mViewTreeObserver =&lt;span&gt; getActivity().getWindow().getDecorView().getViewTreeObserver();
mViewTreeObserver.addOnGlobalLayoutListener(mGlobalLayoutListener);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 18 Feb 2018 04:59:00 +0000</pubDate>
<dc:creator>ganchuanpu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ganchuanpu/p/8452698.html</dc:identifier>
</item>
<item>
<title>浅析Xilinx 三速以太网MAC IP核（仿真篇） - 没落骑士</title>
<link>http://www.cnblogs.com/moluoqishi/p/8448286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moluoqishi/p/8448286.html</guid>
<description>&lt;p&gt;　&lt;span&gt;　之前在使用Altera的三速以太网MAC IP的基础上，完成了UDP协议数据传输。此次为了将设计移植到xilinx FPGA上，需要用到xilinx的三速以太网MAC IP核，当然也可以自己用HDL编写，但必须对数据链路层协议有非常清晰的认识。以下是在使用xilinx 三速以太网MAC过程中的一些记录和总结。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在使用IP核传输数据之前要对MAC层功能有个了解。MAC层功能用一个词概括就是“成帧解帧”，具体来讲&lt;span&gt;TX方向对用户侧发送来的MAC帧添加前导码和帧尾校验和，对长度过短帧会在帧尾填充0直至最小帧长，此外流控模块可以根据需要发送pause帧。RX方向过滤掉不符合规范的数据帧并移除填充域，只有目的MAC地址与自身相符且帧尾校验和正确的数据帧才为有效数据帧，去除前导码和校验域后即发送给用户侧。接收端也会根据可能收到的pause帧做出暂停发送处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/em&gt;&lt;span&gt;认识以太网帧结构同样非常重要，目前常见的是Ethernet II和IEEE802.3两种格式，总体可以归纳为：目的MAC地址　　源MAC地址　　长度/类型　　有效负荷（可能有填充）　　帧校验，长度依次是6byte、6byte、2byte、46~1500byte、4byte。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;区别在于Ethernet II帧长度/类型域解释为上层协议类型，而IEEE802.3同样位置是长度字段。区分两者的标准是：当该字段值小于等于1500（十六进制的0x05DC）时，为IEEE802.3格式；当字段值大于等于1536（或者十六进制的0x0600）时，帧使用的是Ethernet II格式。&lt;/span&gt;其中Ethernet II最为常见。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　IP核的配置很简单，根据自己的需求设置即可。重点关注第二页，这里选择使用GMII作为物理层接口，并选择三速模式，可以通过接口改动传输速率。&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201289/201802/1201289-20180214144124281-1615650465.png&quot; alt=&quot;&quot; width=&quot;772&quot; height=&quot;526&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;IP核配置生成输出文件后，和其他较为复杂的IP核一样要熟读文档和分析example design的结构和功能。资料主要参考PG051.我们直接打开example design顶层文件对工程有个整体的认识：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    --------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | EXAMPLE DESIGN WRAPPER                         |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |                                                |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |                                                |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |   -------------------     -------------------  |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |   |                 |     |                 |  |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |   |    Clocking     |     |     Resets      |  |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |   |                 |     |                 |  |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |   -------------------     -------------------  |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |           -------------------------------------|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |           |FIFO BLOCK WRAPPER                  |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |           |                                    |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |           |                                    |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |           |              ----------------------|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |           |              | SUPPORT LEVEL       |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | --------  |              |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |      |  |              |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | | AXI  |-&amp;gt;|-------------&amp;gt;|                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | | LITE |  |              |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |  SM  |  |              |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |      |&amp;lt;-|&amp;lt;-------------|                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |      |  |              |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | --------  |              |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |           |              |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | --------  |  ----------  |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |      |  |  |        |  |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |      |-&amp;gt;|-&amp;gt;|        |-&amp;gt;|                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | | PAT  |  |  |        |  |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | | GEN  |  |  |        |  |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |(ADDR |  |  |  AXI-S |  |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | | SWAP)|  |  |  FIFO  |  |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |      |  |  |        |  |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |      |  |  |        |  |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |      |  |  |        |  |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |      |&amp;lt;-|&amp;lt;-|        |&amp;lt;-|                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | |      |  |  |        |  |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    | --------  |  ----------  |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |           |              |                     |
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |           |              ----------------------|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    |           -------------------------------------|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    --------------------------------------------------

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　上边是官方提供的注释，非常清晰地给出了工程结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;example_clocks:　　　　　时钟模块，提供工程中用到的所有时钟信号；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;example_resets:　　　　　复位模块，产生所有子模块的复位信号；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;axi_lite_controller:　　　　控制模块，内部通过状态机对MAC和PHY芯片进行初始化和相应配置工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;basic_pat_gen_inst:         包测试模块，有两种模式：发送固定样式测试数据包和将收到数据包环回送出给PHY。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;trimac_fifo_block:　　       AXI-S接口异步FIFO和MAC IP核。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　MAC IP核包含的主要接口类型及作用是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GMII接口--PHY数据通道　　　　 &lt;/span&gt;&lt;span&gt;MDIO接口--PHY芯片配置管理　　　　 &lt;/span&gt;&lt;span&gt;AXI-Stream接口--用户数据通道　　　　 &lt;/span&gt;&lt;span&gt;AXI-Lite接口--用户控制管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　初步需要掌握的是用户数据接口，实际上AXI-Stream也无需过多关注，只要理解FIFO用户侧接口即可。以发送方向为例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201289/201802/1201289-20180214153720827-1234578887.png&quot; alt=&quot;&quot; width=&quot;652&quot; height=&quot;165&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　tx_axis_fifo_tdata 8位数据，tx_axis_fifo_tvalid 数据有效指示，tx_axis_fifo_tready MAC发送准备信号，tx_axis_fifo_tlast 数据包尾指示。接下来使用示例工程的testbench查看仿真波形，对用户接口时序有一个直观的认识。官方testbench demo_tb文件中会持续分别以10M 100M 1000M速率向example design RX方向GMII端口发送5个不同数据帧。先来看&lt;span&gt;&lt;strong&gt;千兆网&lt;/strong&gt;&lt;/span&gt;波形，在千兆模式下TX时钟为由FPGA提供的125MHz信号gtx_clk_bufg，RX时钟由PHY通过时钟恢复得到125MHz时钟信号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201289/201802/1201289-20180217153927718-347303136.png&quot; alt=&quot;&quot; width=&quot;1192&quot; height=&quot;373&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;数据的流向为：gmii_rx_xx --&amp;gt; rx_axis_mac_xx --&amp;gt; rx_axis_fifo_xx --&amp;gt; tx_axis_fifo_xx --&amp;gt; tx_axis_mac_xx --&amp;gt; gmii_tx_xx。此时example design中basic_pat_gen_inst模块设置为环回模式，会将MAC接收的数据环回到发送通道。由于第三个帧错误指示信号gmii_rx_er拉高，而第5个帧MAC地址不匹配，因此这两个数据帧被滤除掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201289/201802/1201289-20180218113547343-1300218406.png&quot; alt=&quot;&quot; width=&quot;1249&quot; height=&quot;210&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上图看出第三个数据帧带有错误指示信号，FIFO模块才会将其丢弃。第五个数据包MAC地址不符，在MAC核内部被丢弃。以第四个数据包为例观察时序：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201289/201802/1201289-20180218114021515-2104445608.png&quot; alt=&quot;&quot; width=&quot;1259&quot; height=&quot;92&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;包尾指示和数据在MAC核收到FCS并检测完毕后才输出有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201289/201802/1201289-20180217155603031-755993682.png&quot; alt=&quot;&quot; width=&quot;1257&quot; height=&quot;92&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;该帧目的MAC地址是48'hda_02_03_04_05_06 源MAC地址是48'h5a_02_03_04_05_06 长度/类型域是16'h00_03，因此是解释为帧长度为3字节，负荷是01 02 03。&lt;/span&gt;&lt;span&gt;环回后目的MAC地址和源MAC地址被basic_pat_gen_inst模块交换，TX方向用户数据包为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201289/201802/1201289-20180217155819374-599265245.png&quot; alt=&quot;&quot; width=&quot;1261&quot; height=&quot;101&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;我们看下MAC核TX方向实际的用户接口时序，FIFO模块屏蔽了用户侧与MAC核之间的握手应答机制，缓存至少一个数据帧即开始数据传输，从而简化了接口时序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201289/201802/1201289-20180218110125577-394202472.png&quot; alt=&quot;&quot; width=&quot;1260&quot; height=&quot;97&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;当数据发送到物理层接口，由于数据包小于最小长度，因此发送到gmii接口上再次被填充至最小帧长。此外添加上前导码和校验和。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201289/201802/1201289-20180217161722171-1266151171.png&quot; alt=&quot;&quot; width=&quot;1256&quot; height=&quot;80&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;再&lt;/span&gt;&lt;span&gt;来看看&lt;span&gt;&lt;strong&gt;百兆网&lt;/strong&gt;&lt;/span&gt;，速率为100M时TX和RX方向时钟信号均由PHY芯片提供。第四数据帧TX方向用户接口波形：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201289/201802/1201289-20180218110505358-2103899341.png&quot; alt=&quot;&quot; width=&quot;1247&quot; height=&quot;117&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;FIFO提供的用户侧接口时序上与千兆网没有差别，时钟频率是125MHz，位宽依然是8bit，那么又是如何实现百兆速率的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1201289/201802/1201289-20180218110911905-137846735.png&quot; alt=&quot;&quot; width=&quot;1250&quot; height=&quot;101&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;MAC核用户接口时钟为25MHz，位宽为8bit，MAC核提供的tready信号每两周期拉高一周期，速率为25M*8/2 = 100M，因此100M速率是通过tready信号限流实现的。综上，对100M和1000M速率下全双工以太网概念和帧结构、MAC IP核配置以及核心用户接口时序功能均进行了阐述，本人也在学习中，希望对大家有帮助。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Feb 2018 03:51:00 +0000</pubDate>
<dc:creator>没落骑士</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moluoqishi/p/8448286.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 2.0 : 四.  _Layout与_ViewStart - FlyLolo</title>
<link>http://www.cnblogs.com/FlyLolo/p/8452169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FlyLolo/p/8452169.html</guid>
<description>&lt;p&gt;本章我们新建一个项目,并通过这个项目熟悉一下_Layout与_ViewStart以及它们的加载顺序.&lt;/p&gt;

&lt;p&gt;首先, 文件-&amp;gt;新建一个解决方案&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/548134/201802/548134-20180217213100544-1212981877.png&quot; alt=&quot;&quot; width=&quot;204&quot; height=&quot;69&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择.Net Core 的APP下面的ASP.NET Core Web App(MVC)&lt;/p&gt;
&lt;p&gt;Next&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/548134/201802/548134-20180218090605733-389996591.jpg&quot; alt=&quot;&quot; width=&quot;408&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置解决方案的名称(和Xcode的界面风格有点像), 输入FL.WeightManager, 做一个每天记录体重的应用&lt;/p&gt;
&lt;p&gt;点击Create.&lt;/p&gt;
&lt;p&gt;项目新建完毕, 项目的文件结构上一章已经说过了.&lt;/p&gt;


&lt;p&gt;新建好的项目默认运行效果如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/548134/201802/548134-20180218092051640-1762210003.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面主要分三部分, 上面的header, 下面的footer, 点击上面菜单总的Home、About和Contact切换一下页面看一下&lt;/p&gt;
&lt;p&gt;这两部分都是不变的, 只有中间部分在变.&lt;/p&gt;
&lt;p&gt;打开Shared文件夹下面的_layout.cshtml页面看一下, header和footer都是定义在这里的, &lt;/p&gt;
&lt;p&gt;而中间变的部分是 &lt;span&gt;@RenderBody().&lt;/span&gt;&lt;span&gt;也就是我们经常要改变的地方了.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在将主页改变一下, 打开Home文件夹下的Index文件,将里面的一大堆代码改成如下代码&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     ViewData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主页&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &amp;lt;table &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table table-hover&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;thead&amp;gt;
&lt;span&gt; 6&lt;/span&gt;         &amp;lt;tr&amp;gt;
&lt;span&gt; 7&lt;/span&gt;             &amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;
&lt;span&gt; 8&lt;/span&gt;             &amp;lt;th&amp;gt;日期&amp;lt;/th&amp;gt;
&lt;span&gt; 9&lt;/span&gt;             &amp;lt;th&amp;gt;体重&amp;lt;/th&amp;gt;
&lt;span&gt;10&lt;/span&gt;             &amp;lt;th&amp;gt;备注&amp;lt;/th&amp;gt;
&lt;span&gt;11&lt;/span&gt;         &amp;lt;/tr&amp;gt;
&lt;span&gt;12&lt;/span&gt;     &amp;lt;/thead&amp;gt;
&lt;span&gt;13&lt;/span&gt;     &amp;lt;tbody&amp;gt;
&lt;span&gt;14&lt;/span&gt;         &amp;lt;tr&amp;gt;
&lt;span&gt;15&lt;/span&gt;             &amp;lt;td&amp;gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;/td&amp;gt;
&lt;span&gt;16&lt;/span&gt;             &amp;lt;td&amp;gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt;&amp;lt;/td&amp;gt;
&lt;span&gt;17&lt;/span&gt;             &amp;lt;td&amp;gt;&lt;span&gt;66.6&lt;/span&gt;&amp;lt;/td&amp;gt;
&lt;span&gt;18&lt;/span&gt;             &amp;lt;td&amp;gt;除夕,胖了&amp;lt;/td&amp;gt;
&lt;span&gt;19&lt;/span&gt;         &amp;lt;/tr&amp;gt;
&lt;span&gt;20&lt;/span&gt;         &amp;lt;tr&amp;gt;
&lt;span&gt;21&lt;/span&gt;             &amp;lt;td&amp;gt;&lt;span&gt;2&lt;/span&gt;&amp;lt;/td&amp;gt;
&lt;span&gt;22&lt;/span&gt;             &amp;lt;td&amp;gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt;&amp;lt;/td&amp;gt;
&lt;span&gt;23&lt;/span&gt;             &amp;lt;td&amp;gt;&lt;span&gt;68.8&lt;/span&gt;&amp;lt;/td&amp;gt;
&lt;span&gt;24&lt;/span&gt;             &amp;lt;td&amp;gt;春节,又重了&amp;lt;/td&amp;gt;
&lt;span&gt;25&lt;/span&gt;         &amp;lt;/tr&amp;gt;
&lt;span&gt;26&lt;/span&gt;     &amp;lt;/tbody&amp;gt;
&lt;span&gt;27&lt;/span&gt; &amp;lt;/table&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刷新一下页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/548134/201802/548134-20180217224433236-1995262637.png&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来效果还不错, 可能会注意到, 这个table有个class  &lt;span class=&quot;cnblogs_code&quot;&gt;&amp;lt;table &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table table-hover&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; ,&lt;/p&gt;
&lt;p&gt;这个class定义在哪里呢.&lt;/p&gt;
&lt;p&gt;再次打开_layout文件, 可以看到里面在Development环境下引用了bootstrap的css&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &amp;lt;environment include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/lib/bootstrap/dist/css/bootstrap.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
        &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/css/site.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/environment&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以可以把一些&quot;通用&quot;的css和js的引用放在layout文件里, 避免重复写这些引用.&lt;/p&gt;
&lt;p&gt;顺便把header和footer中显示的项目名称改一下, 然后分别打开Index和About这些页面, Header和Footer都统一改变了.&lt;/p&gt;
&lt;p&gt;如下图的About页面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/548134/201802/548134-20180217221525137-558510817.png&quot; alt=&quot;&quot; width=&quot;498&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但是我们在这个Index页中没有对这个模板做引用, 是通过什么方式引用的呢?&lt;/p&gt;

&lt;p&gt;回顾修改后的Index页面, 我们并没有写 &lt;span class=&quot;cnblogs_code&quot;&gt;Layout = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Layout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; 这样的代码, 这是因为已经在_ViewStart中默认设置了&lt;/p&gt;
&lt;p&gt;_ViewStart中只有这一句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    Layout &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Layout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们在Index页面中添加一句 &lt;span class=&quot;cnblogs_code&quot;&gt;Layout=&lt;span&gt;null&lt;/span&gt;&lt;/span&gt; 如下,&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    Layout&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主页&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次刷新页面, 样子变成了这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/548134/201802/548134-20180217224206353-1532728059.png&quot; alt=&quot;&quot; width=&quot;242&quot; height=&quot;121&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Header和Footer以及Table的样式全都没有了, 是因为这些本来都写在_Layout中, 现在失去了对_Layout的引用, 这些也就消失了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt; _ViewStart对模板页做了默认的设置, 除非显示的写明Layout=XXX, 否则会采用_ViewStart中的设置.&lt;/p&gt;
&lt;p&gt;       所以未做设置和设置 &lt;span class=&quot;cnblogs_code&quot;&gt;Layout = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Layout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; 的效果是一样的.&lt;/p&gt;


&lt;p&gt; 加载顺序是: _ViewStart =&amp;gt;Index=&amp;gt;_Layout.&lt;/p&gt;
&lt;p&gt;1._ViewStart在所有View加载之前加载, 设置了默认的模板页.&lt;/p&gt;
&lt;p&gt;2.接着由Controller指定的页面查找Index.cshtml加载, 并读取该页面的Layout设置. &lt;/p&gt;
&lt;p&gt;3.根据Index页面的Layout设置的模板页查找对应的模板页加载.&lt;/p&gt;
&lt;p&gt;将_ViewStart中的 &lt;span class=&quot;cnblogs_code&quot;&gt;Layout = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Layout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; 改为 &lt;span class=&quot;cnblogs_code&quot;&gt;Layout = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Layout1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; , 再次运行, 页面会出现如下找不到模板的错误.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
An unhandled exception occurred &lt;span&gt;while&lt;/span&gt;&lt;span&gt; processing the request.

InvalidOperationException: The layout view &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_Layout1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; could not be located. The following locations were searched:
&lt;/span&gt;/Views/Home/&lt;span&gt;_Layout1.cshtml
&lt;/span&gt;/Views/Shared/&lt;span&gt;_Layout1.cshtml
Microsoft.AspNetCore.Mvc.Razor.RazorView.GetLayoutPage(ViewContext context, &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; executingFilePath, &lt;span&gt;string&lt;/span&gt; layoutPath)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;View的查找规则:&lt;/strong&gt; 先查找Controller对应的文件夹(这里是Home), 若未找到则到Shared文件夹查找, 若最终未找到则提示错误.&lt;/p&gt;
</description>
<pubDate>Sun, 18 Feb 2018 01:59:00 +0000</pubDate>
<dc:creator>FlyLolo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FlyLolo/p/8452169.html</dc:identifier>
</item>
<item>
<title>JDK8的新特性——Lambda表达式 - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/8452379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/8452379.html</guid>
<description>&lt;p&gt;　　JDK8已经发布快4年的时间了，现在来谈它的新特性显得略微的有点“不合时宜”。尽管JDK8已不再“新”，但它的重要特性之一——Lambda表达式依然是不被大部分开发者所熟练运用，甚至不被开发者所熟知。&lt;/p&gt;
&lt;p&gt;　　国内的开发环境大家都知道，有各种的老项目，有各种各样的发布风险，让公司以及项目组对新的技术往往望而却步，有公司甚至时至今日还在使用JDK6来进行项目开发，这导致了在很多技术的选择上受到了很大限制，进而不能跟随时代的脚步使得项目甚至公司一步一步走向衰落。&lt;/p&gt;
&lt;p&gt;　　本文简单认识JDK8的重要新特性之一——Lambda表达式。 在JDK8之前，Java是不支持函数式编程的，所谓的函数编程，即可理解是将一个函数（也称为“行为”）作为一个参数进行传递。通常我们提及得更多的是面向对象编程，面向对象编程是对数据的抽象（各种各样的POJO类），而函数式编程则是对行为的抽象（将行为作为一个参数进行传递）。在JavaScript中这是很常见的一个语法特性，但在Java中将一个函数作为参数传递这却行不通，好在JDK8的出现打破了Java的这一限制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;认识Lambda表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;首先来引入一个示例，不知给是否有在IDEA编写代码的经历，如果在JDK8的环境下如下所示按照Java传统的语法规则编写一个线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(&quot;Hello World!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　IDEA会给出提示可以使用Lambda表达式替换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/630246/201802/630246-20180218000826703-1226076574.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用Lambda表达式则只需要使用一句话就可代替上面使用匿名类的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&quot;Hello World!&quot;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　在这个例子中，传统的语法规则，我们是将一个匿名内部类作为参数进行传递，我们实现了Runnable接口，并将其作为参数传递给Thread类，这实际上我们传递的是一段代码，也即我们将代码作为了数据进行传递，这就带来许多不必要的“样板代码”。&lt;/p&gt;
&lt;p&gt;　　Lambda表达式一共有三部分组成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/630246/201802/630246-20180218001032906-1130608891.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;157&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　后面的示例中我们会详解这个结构，包括有无参数，有无返回值的问题。 那么这个看起来奇奇怪怪的不太像Java的语法规则，其本身含义到底什么呢？这也是开始困扰我的问题，什么时候在什么场景下可以使用Lambda表达式。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;能够接收Lambda表达式的参数类型，是一个只包含一个方法的接口。&lt;/strong&gt;只包含一个方法的接口称之为“&lt;strong&gt;函数接口&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;　　例如上面创建一个线程的示例，Runnable接口只包含一个方法，所以它被称为“函数接口”，所以它可以使用Lambad表达式来代替匿名内部类。根据这个规则，我们试着来写一个函数接口，并使用Lambda表达式作为参数传递。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.custom;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt; * 函数接口：只有一个方法的接口。作为Lambda表达式的类型
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/17.
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FunctionInterface {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test();
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.custom;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * 函数接口测试
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/17.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FunctionInterfaceTest {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testLambda() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         func(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FunctionInterface() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 System.out.println(&quot;Hello World!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Lambda表达式代替上面的匿名内部类&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         func(&lt;strong&gt;() -&amp;gt; System.out.println(&quot;Hello World&quot;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;)&lt;/strong&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; func(FunctionInterface functionInterface) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        functionInterface.test();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，只要是一个接口中只包含一个方法，则可以使用Lambda表达式，这样的接口称之为“函数接口”。&lt;/p&gt;
&lt;p&gt;　　上面的函数接口比较简单&lt;strong&gt;不包含参数，也不包含返回值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　我们再来修改FunctionInterface函数接口逐步加大Lambda表达式的难度——&lt;strong&gt;包含参数，不包含返回值&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.custom;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt; * 函数接口：只有一个方法的接口。作为Lambda表达式的类型
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/17.
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FunctionInterface {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; param);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.custom;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * 函数接口测试
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/17.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FunctionInterfaceTest {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testLambda() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Lambda表达式代替匿名内部类&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         func(&lt;strong&gt;(x) -&amp;gt; System.out.println(&quot;Hello World&quot; +&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; x)&lt;/strong&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; func(FunctionInterface functionInterface) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; x = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        functionInterface.test(x);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　关注Lambda表达式“(x) -&amp;gt; Sysout.out.println(&quot;Hello World&quot; + x)”，左边传递的是参数，此处并没有指明参数类型，因为它可以通过上下文进行类型推导，但在有些情况下不能推导出参数类型（在编译时不能推导通常IDE会提示），此时则需要指明参数类型。&lt;strong&gt;我个人建议，任何情况下指明函数的参数类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　哪种情况不能推导出参数类型呢？就是函数接口是一个泛型的时候。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.custom;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt; * 函数接口：只有一个方法的接口。作为Lambda表达式的类型
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/17.
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; FunctionInterface&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test(T param);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.custom;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * 函数接口测试
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/17.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FunctionInterfaceTest {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testLambda() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Lambda表达式代替匿名内部类&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         func(&lt;strong&gt;(Integer x) -&amp;gt; System.out.println(&quot;Hello World&quot; +&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; x)&lt;/strong&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; func(FunctionInterface&amp;lt;Integer&amp;gt;&lt;span&gt; functionInterface) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; x = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        functionInterface.test(x);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的示例提到了Lambda表达式的两种情况：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;无参数，无返回值；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　有参数，无返回值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　接下来就是&lt;strong&gt;有参数，有返回值&lt;/strong&gt;这种较为复杂的情况。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.custom;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt; * 函数接口：只有一个方法的接口。作为Lambda表达式的类型
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/17.
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; FunctionInterface&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test(T param);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.coderbuff.custom;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * 函数接口测试
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2018/2/17.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FunctionInterfaceTest {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testLambda() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Lambda表达式代替匿名内部类&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         func(&lt;strong&gt;(Integer x) -&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; func(FunctionInterface&amp;lt;Integer&amp;gt;&lt;span&gt; functionInterface) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; x = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        functionInterface.test(x);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时的Lambda表达式“(Integer x) -&amp;gt; true”，右边是表达式的主体，直接返回true，如果有多行代码，则可以直接使用花括号表示，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
func(&lt;strong&gt;(Integer x) -&amp;gt;&lt;span&gt; {
    System.out.println(&lt;/span&gt;&quot;Hello World&quot; +&lt;span&gt; x);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;;
}&lt;/strong&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Lambda表达式基本的语法规则：&lt;/p&gt;
&lt;p&gt;　　无参数，无返回值；&lt;/p&gt;
&lt;p&gt;　　有参数，无返回值；&lt;/p&gt;
&lt;p&gt;　　有参数，有返回值。&lt;/p&gt;
&lt;p&gt;　　这三种基本情况已经大致清楚了，特别是需要弄清，什么时候可以使用Lambda表达式代替匿名内部类，也就是Lambda表达式的应用场景是函数接口。Lambda表达式这一新特性在JDK8中的引入，更大的好处则是集合API的更新，新增的Stream类库，使得我们在遍历使用集合时不再像以往那样不断地使用for循环。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JDK8使用集合的正确姿势&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　示例：计算来自“chengdu”的学生数量有多少。&lt;/p&gt;
&lt;p&gt;　　在JDK8前的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Student student : studentList) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (student.getCity().equals(&quot;chengdu&quot;&lt;span&gt;)) {
        count&lt;/span&gt;++&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　JDK8使用集合的正确姿势：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
count = &lt;strong&gt;studentList.stream().filter((student -&amp;gt; student.getCity().equals(&quot;chengdu&quot;))).count()&lt;/strong&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　API的使用“难度”恰似提高了，实际只是不熟悉而已。传统迭代的方式需要阅读完整个循环才能明白代码逻辑，JDK8通过流的方式则可以望文生义且代码量大大减小。&lt;/p&gt;
&lt;p&gt;　　其中最为重要的是——Stream流。Stream的是通过函数式编程方式实现的在集合类上进行复杂操作的工具。若要详细讲解Stream的实现方式我相信再写一篇博客也不为过，所以此处不再考查Stream的内部实现。这里是想告诉大家，如果有幸使用JDK8的开发环境进行开发，尽量学习使用新的集合操作API。&lt;/p&gt;
&lt;p&gt;　　上面对于Lambda表达式以及函数式编程仅仅只是到了一个“认识”的地步，似乎只是感受到了缩小代码量，本文对于Lambda式的认识不深入更多的是对于后面更多的知识做一个铺垫或者作为一个扫盲贴，有关Lambda表达式的应用太多，并发编程、响应式编程等等。如果你有关于Lambda表达式或者函数式编程有更好的见解不妨留下评论。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Feb 2018 16:20:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/8452379.html</dc:identifier>
</item>
<item>
<title>R语言-选择样本数量 - 月上贺兰</title>
<link>http://www.cnblogs.com/luhuajun/p/8452377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luhuajun/p/8452377.html</guid>
<description>&lt;p&gt;功效分析:可以帮助在给定置信度的情况下,判断检测到给定效应值时所需的样本量,也可以在给定置信水平的情况下,计算某样本量内可以检测到的给定效应值的概率&lt;/p&gt;
&lt;p&gt;1.t检验&lt;/p&gt;
&lt;p&gt;　　案例:使用手机和司机反应时间的实验&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;library(pwr)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; n表示样本大小&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; d表示标准化均值之差&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; sig.level表示显著性水平&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; power为功效水平&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; type指的是检验类型&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; alternative指的是双侧检验还是单侧检验&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; pwr.t.test(d=.8,sig.level = .05,power = .9,type = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;two.sample&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,alternative = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;two.sided&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1173792/201802/1173792-20180217233314421-175958414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:每组需要34个样本(68)人才能保证有90%的把握检测到0.8效应值,并且最多5%会存在误差&lt;/p&gt;
&lt;p&gt;2.方差分析&lt;/p&gt;
&lt;p&gt;　　案例:对5组数据做方差分析,达到0.8的功效,效应值为0.25,选择0.5的显著水平.计算总体样本的大小&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; k表示组的个数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; f表示效应值&lt;/span&gt;
pwr.anova.test(k=5,f=.25,sig.level = .05,power = .8)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1173792/201802/1173792-20180217234433500-1460140112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:需要39*5,195受试者参与实验才能得出以上结果&lt;/p&gt;
&lt;p&gt;3.相关性&lt;/p&gt;
&lt;p&gt;　　案例:抑郁症和孤独的关系,零假设和研究假设为&lt;/p&gt;
&lt;p&gt;　　　　 H0:p&amp;lt;=0.25和H1:p&amp;gt;0.25&lt;/p&gt;
&lt;p&gt;　　　　设定显著水平为0.05,耳光拒绝零假设,希望有90%的信息拒绝H0,需要多少测试者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; r表示效应值&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; pwr.r.test(r=.25,sig.level = .05,power = .90,alternative = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;greater&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1173792/201802/1173792-20180217235054609-225760778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:需要134名受试者参与实验&lt;/p&gt;
&lt;p&gt;4.线性模型&lt;/p&gt;
&lt;p&gt;　　案例:老板的领导风格对员工满意度的影响,薪水和小费能解释30%员工满意度方差,领导风格能解释35%的方差,&lt;/p&gt;
&lt;p&gt;　　　　  要达到90%置信度下,显著水平为0.05,需要多少受试者才能达到方差贡献率&lt;/p&gt;
&lt;p&gt;　　f2 = (0.35-0.3)/(1-0.35)=0.0769&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; u表示分子自由度&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; v表示分母自由度&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; f2表示效应值&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; pwr.f2.test(u=3,f2=0.0769,sig.level = .05,power = .90)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1173792/201802/1173792-20180218000022765-2123891470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:v=总体样本-预测变量-1,所以N=v+7+1=187+7+1=193&lt;/p&gt;
&lt;p&gt;5.比例检验&lt;/p&gt;
&lt;p&gt;　　案例:某种药物有60%的治愈率,新药有65%的治愈率,现在有多少受试者才能体会到两种药物的差异&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; pwr.2p.test(h=ES.h(.65,.6),sig.level = .05,power = .9,alternative = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;greater&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1173792/201802/1173792-20180218000352531-1402053669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:本案例中使用单边检验,得出需要1605名受试者才能得出两种药品的区别&lt;/p&gt;
&lt;p&gt;6.卡方检验&lt;/p&gt;
&lt;p&gt;　　卡方检验用来评价两个变量之间的关系,零假设是变量之间独立,拒绝零假设是变量不独立&lt;/p&gt;
&lt;p&gt;　　案例:研究晋升和种族的关系:样本中70%是白人,10%黑人,20%西班牙裔,相比20%的黑人和50%的西班牙裔,60%的白人更容易获得晋升&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; prob &amp;lt;- matrix(c(.42,.28,.03,.07,.10,.10),byrow = T,nrow = 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算双因素列连表中的备择假设的效应值&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;ES.w2(prob)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; w是效应值,&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; df是自由度&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; pwr.chisq.test(w=0.1853198,df=2,sig.level = .05,power = .90)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1173792/201802/1173792-20180218000950578-157303240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:该实验需要369名测试者才能证明晋升和种族存在关联&lt;/p&gt;
&lt;p&gt;7.在新的情况下选择合适的效应值&lt;/p&gt;
&lt;p&gt;　　7.1单因素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; es &amp;lt;- seq(.1,.5,.01&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; nes &amp;lt;-&lt;span&gt; length(es)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; samsize &amp;lt;-&lt;span&gt; NULL
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;(i &lt;span&gt;in&lt;/span&gt; 1&lt;span&gt;:nes){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   result &amp;lt;- pwr.anova.test(k=5,f=es[i],sig.level = .05,power = .90&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   samsize[i] &amp;lt;-&lt;span&gt; ceiling(result$n)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; plot(samsize,es,type=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,lwd=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,col=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      ylab = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Effect Size&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      xlab = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sample Szie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      main = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;One way Anova with power=.90 and alpha=.05&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1173792/201802/1173792-20180218001136203-95920441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:赝本数量高于200时,在增加样本是效果不明显&lt;/p&gt;
&lt;p&gt;　　7.2 绘制功效分析图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.生成一系列相关系数和功效值&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; r &amp;lt;- seq(.1,.5,.01&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; nr &amp;lt;-&lt;span&gt; length(r)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; p &amp;lt;- seq(.4,.9,.1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; np &amp;lt;-&lt;span&gt; length(p)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.获取样本大小&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; samsize &amp;lt;- array(numeric(nr*np),dim =&lt;span&gt; c(nr,np))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;(i &lt;span&gt;in&lt;/span&gt; 1&lt;span&gt;:np){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt;(j &lt;span&gt;in&lt;/span&gt; 1&lt;span&gt;:nr){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     result &amp;lt;- pwr.r.test(n=NULL,r=r[j],sig.level = .05,power = p[i],alternative = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;two.sided&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     samsize[j,i] &amp;lt;-&lt;span&gt; ceiling(result$n)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.创建图形&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; xrange &amp;lt;-&lt;span&gt; range(r)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; yrange &amp;lt;-&lt;span&gt; round(range(samsize))
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; colors &amp;lt;-&lt;span&gt; rainbow(length(p))
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; plot(xrange,yrange,type=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;      xlab = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Corrlation Coefficient&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;      ylab = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sample Size&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.添加功效曲线&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;(i &lt;span&gt;in&lt;/span&gt; 1&lt;span&gt;:np){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;   lines(r,samsize[,i],type=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,lwd=2,col=&lt;span&gt;colors[i])
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.网格线&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; abline(v=0,h=seq(0,yrange[2],50),lty=2,col=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;grey89&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; abline(h=0,v=seq(xrange[1],xrange[2],.02),lty=2,col=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;grey89&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6.标题和注释&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sample Size Estimation for Corrlation\nSig=0.05&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; legend(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;topright&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,title = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Power&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,as.character(p),fill=colors)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1173792/201802/1173792-20180218001549203-337765991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　结论:在40%的置信度下,要检测到0.2的相关性需要约75个样本,在90%的置信度下,要检测到相同的相关性需要大约260个样本&lt;/p&gt;

</description>
<pubDate>Sat, 17 Feb 2018 16:19:00 +0000</pubDate>
<dc:creator>月上贺兰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luhuajun/p/8452377.html</dc:identifier>
</item>
</channel>
</rss>