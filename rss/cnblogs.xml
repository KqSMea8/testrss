<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>线性表 - song.yan</title>
<link>http://www.cnblogs.com/excellencesy/p/8647853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/excellencesy/p/8647853.html</guid>
<description>&lt;p&gt;1，线性表是数据结构的线性表现&lt;/p&gt;
&lt;p&gt;2，线性表的两种表现方式：顺序表，链表&lt;/p&gt;
&lt;p&gt;3，顺序表：开辟连续的空间，顺序存储&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1157942/201803/1157942-20180325225655947-1019374825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4，链表：每个存储单元包括存数据的地方，存指针的地方。离散的空间通过指针连接在一起。&lt;/p&gt;
&lt;p&gt;5，链表：单链表，循环链表，双向链表&lt;/p&gt;
&lt;p&gt;6，单链表：只有一套指针，指针单向&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1157942/201803/1157942-20180325230137327-456230171.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;7，循环链表：把尾元素的指针指向头节点&lt;/p&gt;
&lt;p&gt;优点：无需重新定位到头指针&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1157942/201803/1157942-20180325230157704-1545593011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8，双向链表：两套指针，正向，逆向两种&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1157942/201803/1157942-20180325230213249-768467225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9.链表的基本操作【操作步骤不可变！！！】&lt;/p&gt;
&lt;p&gt;点击下列链表查看详情&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/excellencesy/p/8646128.html&quot; target=&quot;_blank&quot;&gt;单链表的增加，删除节点操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/excellencesy/p/8647849.html&quot; target=&quot;_blank&quot;&gt;双向链表的增加，删除节点操作&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 15:54:00 +0000</pubDate>
<dc:creator>song.yan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/excellencesy/p/8647853.html</dc:identifier>
</item>
<item>
<title>JAVA实现双向链表的增删功能 - song.yan</title>
<link>http://www.cnblogs.com/excellencesy/p/8647849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/excellencesy/p/8647849.html</guid>
<description>&lt;p&gt;JAVA实现双向链表的增删功能，完整代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; linked;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkedTable{
    
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkedTableTest {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造单链表&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; Node node1 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name1&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node2 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name2&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node3 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name3&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node4 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name4&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node5 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name5&quot;&lt;span&gt;);
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置指针&lt;/span&gt;
&lt;span&gt;        setPoint();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历&lt;/span&gt;
        System.out.println(&quot;*******初始链表*******&quot;&lt;span&gt;);
        out(node1,node5);
        System.out.println();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入节点在node2的后面&lt;/span&gt;
&lt;span&gt;        addNode(node2,node3);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环遍历&lt;/span&gt;
        System.out.println(&quot;*******插入node2.5*******&quot;&lt;span&gt;);
        out(node1, node5);
        System.out.println();
                
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除节点&lt;/span&gt;
&lt;span&gt;        node2.setNextNode(node3);
        node3.setNextNodeF(node2);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环遍历&lt;/span&gt;
        System.out.println(&quot;*******删除node2.5*******&quot;&lt;span&gt;);
        out(node1, node5);
        System.out.println();
        
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置指针&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPoint()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置正向指针&lt;/span&gt;
&lt;span&gt;        node1.setNextNode(node2);
        node2.setNextNode(node3);
        node3.setNextNode(node4);
        node4.setNextNode(node5);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置反向指针&lt;/span&gt;
&lt;span&gt;        node5.setNextNodeF(node4);
        node4.setNextNodeF(node3);
        node3.setNextNodeF(node2);
        node2.setNextNodeF(node1);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历单链表&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outLinked(Node startNode){
        Node node&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
        node.setNextNode(startNode);
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        {
            node&lt;/span&gt;=&lt;span&gt;node.getNextNode();
            System.out.print(node.getName()&lt;/span&gt;+&quot;----&quot;&lt;span&gt;);    
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(node.getNextNode()!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反向循环遍历单链表&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outLinkedF(Node endNode){
        Node node&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
        node.setNextNodeF(endNode);
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        {
            node&lt;/span&gt;=&lt;span&gt;node.getNextNodeF();
            System.out.print(node.getName()&lt;/span&gt;+&quot;----&quot;&lt;span&gt;);    
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(node.getNextNodeF()!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; out(Node startNode,Node endNode)
    {
        
        outLinked(startNode);
        System.out.println();
        outLinkedF(endNode);
        
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入节点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addNode(Node preNode,Node nextNode)
    {
        Node node_add &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;name2.5&quot;&lt;span&gt;);
        node_add.setNextNode(preNode.getNextNode());
        preNode.setNextNode(node_add);
        
        node_add.setNextNodeF(nextNode.getNextNodeF());
        nextNode.setNextNodeF(node_add);
    }
    
    

    
}


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node nextNode;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node nextNodeF;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNextNode(Node nextNode)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNode=&lt;span&gt;nextNode;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNextNodeF(Node nextNodeF)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNodeF=&lt;span&gt;nextNodeF;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getNextNode()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNode;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getNextNodeF()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNodeF;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNode=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node( )
    {
        
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1，构造node节点，需要两个指针，一个正向存储下一个元素的位置，一个反向存储下一个元素的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1157942/201803/1157942-20180325234027699-1840961168.png&quot; alt=&quot;&quot; width=&quot;365&quot; height=&quot;113&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;　　name:用于存储node自身的信息&lt;/p&gt;
&lt;p&gt;　　nextNode:用于存储正向指针&lt;/p&gt;
&lt;p&gt;　　nextNodeF:用于存储反向指针&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node nextNode;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node nextNodeF;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNextNode(Node nextNode)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNode=&lt;span&gt;nextNode;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNextNodeF(Node nextNodeF)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNodeF=&lt;span&gt;nextNodeF;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getNextNode()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNode;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getNextNodeF()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNodeF;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNode=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node( )
    {
        
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2，创建节点，设置指针连接节点&lt;/p&gt;
&lt;p&gt;正向指针：指向下一个节点&lt;/p&gt;
&lt;p&gt;反向节点：指向上一个节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造单链表&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; Node node1 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name1&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node2 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name2&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node3 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name3&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node4 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name4&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node5 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name5&quot;&lt;span&gt;);
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPoint()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置正向指针&lt;/span&gt;
&lt;span&gt;        node1.setNextNode(node2);
        node2.setNextNode(node3);
        node3.setNextNode(node4);
        node4.setNextNode(node5);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置反向指针&lt;/span&gt;
&lt;span&gt;        node5.setNextNodeF(node4);
        node4.setNextNodeF(node3);
        node3.setNextNodeF(node2);
        node2.setNextNodeF(node1);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3，将链表循环遍历输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outLinked(Node startNode){
        Node node&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
        node.setNextNode(startNode);
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        {
            node&lt;/span&gt;=&lt;span&gt;node.getNextNode();
            System.out.print(node.getName()&lt;/span&gt;+&quot;----&quot;&lt;span&gt;);    
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(node.getNextNode()!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outLinkedF(Node endNode){
        Node node&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
        node.setNextNodeF(endNode);
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        {
            node&lt;/span&gt;=&lt;span&gt;node.getNextNodeF();
            System.out.print(node.getName()&lt;/span&gt;+&quot;----&quot;&lt;span&gt;);    
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(node.getNextNodeF()!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4，添加节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addNode(Node preNode,Node nextNode)
    {
        Node node_add &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;name2.5&quot;&lt;span&gt;);
        node_add.setNextNode(preNode.getNextNode());
        preNode.setNextNode(node_add);
        
        node_add.setNextNodeF(nextNode.getNextNodeF());
        nextNode.setNextNodeF(node_add);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5，删除节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;node2.setNextNode(node3);
node3.setNextNodeF(node2);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;class Node {private String name;private Node nextNode;private Node nextNodeF;public void setName(String name){this.name=name;}public void setNextNode(Node nextNode){this.nextNode=nextNode;}public void setNextNodeF(Node nextNodeF){this.nextNodeF=nextNodeF;}public String getName(){return this.name;}public Node getNextNode(){return this.nextNode;}public Node getNextNodeF(){return this.nextNodeF;}public Node(String name){this.name=name;this.nextNode=null;}public Node( ){}}&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 15:52:00 +0000</pubDate>
<dc:creator>song.yan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/excellencesy/p/8647849.html</dc:identifier>
</item>
<item>
<title>Access第一周总结 - 小丑覃</title>
<link>http://www.cnblogs.com/suces/p/8647833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suces/p/8647833.html</guid>
<description>&lt;p&gt;数据库【DataBase】是存放数据的仓库，是长期存在计算机的，有组织的、大量的、可共享的数据集合；数据模型的概念有：实体【Entity】、属性【Attribute】、关键字【Key】、域【Domain】、实体型【Entity Type】、实体集【Entity Set】、联系【Relationship】；实体间有一对一，一对多，多对多的联系方式；结构模型只有一个父结点。&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 15:46:00 +0000</pubDate>
<dc:creator>小丑覃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suces/p/8647833.html</dc:identifier>
</item>
<item>
<title>PAT 个位数统计 - 极限之旅</title>
<link>http://www.cnblogs.com/baobao2201128470/p/8647835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baobao2201128470/p/8647835.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;strong class=&quot;MyB1&quot;&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;tzc_panel_bottom&quot; align=&quot;left&quot; readability=&quot;13&quot;&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;给定一个k位整数N = d&lt;sub&gt;k-1&lt;/sub&gt;*10&lt;sup&gt;k-1&lt;/sup&gt; + ... + d&lt;sub&gt;1&lt;/sub&gt;*10&lt;sub&gt;1&lt;/sub&gt; + d&lt;sub&gt;0&lt;/sub&gt; (0&amp;lt;=d&lt;sub&gt;i&lt;/sub&gt;&amp;lt;=9, i=0,...,k-1, d&lt;sub&gt;k-1&lt;/sub&gt;&amp;gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，和1个3。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong class=&quot;MyB1&quot;&gt;输入&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;tzc_panel_bottom&quot; align=&quot;left&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个输入包含1个测试用例，即一个不超过1000位的正整数N。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong class=&quot;MyB1&quot;&gt;输出&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;tzc_panel_bottom&quot; align=&quot;left&quot; readability=&quot;8&quot;&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;对N中每一种不同的个位数字，以D:M的格式在一行中输出该位数字D及其在N中出现的次数M。要求按D的升序输出。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong class=&quot;MyB1&quot;&gt;样例输入&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 100311&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong class=&quot;MyB1&quot;&gt;样例输出&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;0:2&lt;br/&gt;1:3&lt;br/&gt;3:1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstring&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;  a[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; b[&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m,j,i,k,s,h;
    gets(b);
    n&lt;/span&gt;=&lt;span&gt;strlen(b);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
    {
        a[b[i]&lt;/span&gt;-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(a[i])
            cout&lt;/span&gt;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;&lt;span&gt;endl;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 15:46:00 +0000</pubDate>
<dc:creator>极限之旅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baobao2201128470/p/8647835.html</dc:identifier>
</item>
<item>
<title>Docker + webpack 打包前端项目 - xiangxiong</title>
<link>http://www.cnblogs.com/binb/p/webpack-docker.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binb/p/webpack-docker.html</guid>
<description>&lt;div&gt;
&lt;p&gt;码云代码地址：&lt;/p&gt;


&lt;/div&gt;
&lt;p&gt;构建基础镜像:&lt;/p&gt;
&lt;p&gt;1、下载一个 Apline Linux 操作系统 作为基础镜像，约5MB左右.&lt;/p&gt;
&lt;p&gt;docker pull Apline&lt;/p&gt;

&lt;p&gt;2、进入到 Apline 容器内。&lt;/p&gt;
&lt;p&gt;docker run -a stdin -a stdout -i -t  alpine /bin/sh  进入容器内部.&lt;/p&gt;

&lt;p&gt;3、安装好NodeJs，webpack ,npm 环境.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;apk update&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;apk add nodejs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;npm install webpack -g (这个注意，默认安装的4.0版本，要根据的项目来安装webpack版本).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;npm install&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; -g cnpm&lt;span class=&quot;Apple-converted-space&quot;&gt; --registry=https://registry.npm.taobao.org&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、测试安装是否成功.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;node -v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;npm -v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;exit; 退出容器.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、将容器打包成基础镜像.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;docker commit --author  &quot;shawn&quot;  --message &quot;Node基础镜像&quot; 7a012ac764af snode:1.0&lt;/p&gt;

&lt;p&gt;6、将容器推送至阿里云镜像仓库.(先注册一个阿里云账号)&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;pre data-spm-anchor-id=&quot;5176.8351553.8577669.i4.749b1991hitA5w&quot;&gt;
$ sudo docker login --username=xxx registry.cn-hangzhou.aliyuncs.com
&lt;/pre&gt;
&lt;pre data-spm-anchor-id=&quot;5176.8351553.8577669.i4.749b1991hitA5w&quot;&gt;
$ sudo docker pull registry.cn-hangzhou.aliyuncs.com/sblockchain/node:[镜像版本号]
&lt;/pre&gt;
&lt;pre data-spm-anchor-id=&quot;5176.8351553.8577669.i3.749b1991hitA5w&quot;&gt;
&lt;span data-spm-anchor-id=&quot;5176.8351553.8577669.i2.749b1991hitA5w&quot;&gt;$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/sblockchain/node:[镜像版本号]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre data-spm-anchor-id=&quot;5176.8351553.8577669.i3.749b1991hitA5w&quot;&gt;
&lt;span data-spm-anchor-id=&quot;5176.8351553.8577669.i2.749b1991hitA5w&quot;&gt;$ sudo docker push registry.cn-hangzhou.aliyuncs.com/sblockchain/node:[镜像版本号]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre data-spm-anchor-id=&quot;5176.8351553.8577669.i3.749b1991hitA5w&quot;&gt;
&lt;span data-spm-anchor-id=&quot;5176.8351553.8577669.i2.749b1991hitA5w&quot;&gt;做完上面6个步骤，基础镜像就已经构造好了。基础镜像中安装什么环境，取决于你项目的需要.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以React 项目为例，将React 项目打包成Docker 镜像.&lt;/p&gt;

&lt;p&gt;1、编写dockerfile&lt;/p&gt;
&lt;p&gt;FROM registry.cn-hangzhou.aliyuncs.com/sblockchain/node&lt;/p&gt;
&lt;p&gt;WORKDIR /package&lt;/p&gt;
&lt;p&gt;COPY package.json  /package/&lt;/p&gt;
&lt;p&gt;RUN cnpm install&lt;/p&gt;
&lt;p&gt;WORKDIR /usr/src/mobile&lt;/p&gt;
&lt;p&gt;COPY .   /usr/src/mobile&lt;/p&gt;
&lt;p&gt;RUN cp -a  /package/node_modules  /usr/src/mobile&lt;/p&gt;
&lt;p&gt;RUN webpack&lt;/p&gt;
&lt;p&gt;ENV PORT=3002&lt;/p&gt;
&lt;p&gt;CMD [&quot;node&quot;,&quot;./dev-server.js&quot;]&lt;/p&gt;
&lt;p&gt;EXPOSE 3002&lt;/p&gt;

&lt;p&gt;2、编译代码&lt;/p&gt;
&lt;p&gt;docker build -t webpack-docker&lt;/p&gt;


&lt;p&gt;3、启动代码.&lt;/p&gt;
&lt;p&gt;# For development&lt;/p&gt;
&lt;p&gt;docker run --name my-webpack-docker -p 80:4000 -e NODE_ENV=dev  webpack-docker&lt;/p&gt;

&lt;p&gt;# For deployment&lt;/p&gt;
&lt;p&gt;docker run --name my-webpack-docker -p 80:4000 webpack-docker&lt;/p&gt;


</description>
<pubDate>Sun, 25 Mar 2018 15:40:00 +0000</pubDate>
<dc:creator>xiangxiong</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/binb/p/webpack-docker.html</dc:identifier>
</item>
<item>
<title>从分布式一致性到共识机制（一）Paxos算法 - 邴越</title>
<link>http://www.cnblogs.com/binyue/p/8645565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binyue/p/8645565.html</guid>
<description>&lt;p&gt;从分布式系统的CAP理论出发，关注分布式一致性，以及区块链的共识问题及解决。&lt;/p&gt;
&lt;p&gt;区块链首先是一个大规模分布式系统，共识问题本质就是分布式系统的一致性问题，但是又有很大的不同。&lt;br/&gt;工程开发中，认为系统中存在故障（fault），但不存在恶意（corrupt）节点，而区块链，特别是公开链是落地到物理世界中，涉及到人性和利益关系，不可避免的存在信任以及恶意攻击问题。&lt;/p&gt;
&lt;p&gt;分布式一致性处理的是节点失效情况（即可能消息丢失或重复，但无错误消息）的共识达成（Consensus）问题，主要是Paxos算法及衍生的Raft算法。&lt;/p&gt;
&lt;h2&gt;一、分布式系统的挑战&lt;/h2&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;671&quot; data-height=&quot;578&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/524341/201803/524341-20180325231545668-2098396606.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;483&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;CAP理论的核心思想是任何基于网络的数据共享系统最多只能满足数据一致性(Consistency)、可用性(Availability)和网络分区容忍(Partition Tolerance)三个特性中的两个。&lt;/p&gt;
&lt;p&gt;可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。&lt;br/&gt;对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。也就是，该系统使用的任何算法必须最终终止。当同时要求分区容忍性时，这是一个很强的定义：即使是严重的网络错误，每个请求必须终止。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Partition Tolerance 分区容忍性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Tolerance也可以翻译为容错，分区容忍性具体指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即系统容忍网络出现分区，分区之间网络不可达的情况，分区容忍性和扩展性紧密相关，Partition Tolerance特指在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。分区容忍就提高了。然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;723&quot; data-height=&quot;395&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1392632-def45a3585ac11d9..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1392632-def45a3585ac11d9..png&quot; data-original-width=&quot;723&quot; data-original-height=&quot;395&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;29213&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如图，Client A可以发送指令到Server并且设置更新X的值，Client 1从Server读取该值，在单点情况下，即没有网络分区的情况下，或者通过简单的事务机制，可以保证Client 1读到的始终是最新的值，不存在一致性的问题。&lt;/p&gt;
&lt;p&gt;如果在系统中增加一组节点，Write操作可能在Server 1上成功，在Server 1上失败，这时候对于Client 1和Client 2，就会读取到不一致的值，出现不一致。如果要保持x值的一致性，Write操作必须同时失败，降低系统的可用性。&lt;/p&gt;
&lt;p&gt;可以看到，在分布式系统中，同时满足CAP定律中“一致性”、“可用性”和“分区容错性”三者是不可能的。&lt;/p&gt;
&lt;p&gt;在通常的分布式系统中，为了保证数据的高可用，通常会将数据保留多个副本(replica)，网络分区是既成的现实，于是只能在可用性和一致性两者间做出选择。CAP理论关注的是绝对情况下，在工程上，可用性和一致性并不是完全对立，我们关注的往往是如何在保持相对一致性的前提下，提高系统的可用性。&lt;/p&gt;
&lt;h2&gt;二、数据一致性模型&lt;/h2&gt;
&lt;p&gt;在互联网领域的绝大多数的场景，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。&lt;/p&gt;
&lt;p&gt;对于一致性，可以分为从服务端和客户端两个不同的视角，即内部一致性和外部一致性。&lt;br/&gt;没有全局时钟，绝对的内部一致性是没有意义的，一般来说，我们讨论的一致性都是外部一致性。外部一致性主要指的是多并发访问时更新过的数据如何获取的问题。&lt;/p&gt;
&lt;p&gt;强一致性：&lt;br/&gt;当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。&lt;/p&gt;
&lt;p&gt;弱一致性：&lt;br/&gt;系统并不保证续进程或者线程的访问都会返回最新的更新过的值。用户读到某一操作对系统特定数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。&lt;/p&gt;
&lt;p&gt;最终一致性：&lt;br/&gt;是弱一致性的一种特例。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。&lt;/p&gt;
&lt;p&gt;最终一致性模型根据其提供的不同保证可以划分为更多的模型，包括因果一致性和读自写一致性等。&lt;/p&gt;
&lt;h2&gt;三、两阶段和三阶段提交&lt;/h2&gt;
&lt;p&gt;在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。&lt;br/&gt;典型的比如关系型数据库，由于存在事务机制，可以保证每个独立节点上的数据操作可以满足ACID。&lt;br/&gt;但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况，所以两台机器理论上无法达到一致的状态。&lt;/p&gt;
&lt;p&gt;如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。&lt;br/&gt;但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以节点并不知道本次事务到底应该commit还是 roolback。&lt;/p&gt;
&lt;p&gt;所以实现分布式事务，需要让当前节点知道其他节点的任务执行状态。常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。著名的是二阶段提交协议（Two Phase Commitment Protocol）和三阶段提交协议（Three Phase Commitment Protocol）。&lt;/p&gt;
&lt;h3&gt;1.二阶段提交协议&lt;/h3&gt;
&lt;p&gt;Two Phase指的是Commit-request阶段Commit阶段。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;请求阶段&lt;br/&gt;在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。&lt;br/&gt;在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;提交阶段&lt;br/&gt;在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。&lt;br/&gt;当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务。参与者在接收到协调者发来的消息后将执行响应的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;780&quot; data-height=&quot;504&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1392632-7a350524d54d267c..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1392632-7a350524d54d267c..png&quot; data-original-width=&quot;780&quot; data-original-height=&quot;504&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;40403&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;可以看出，两阶段提交协议存在明显的问题：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;同步阻塞&lt;br/&gt;执行过程中，所有参与节点都是事务独占状态，当参与者占有公共资源时，第三方节点访问公共资源被阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;单点问题&lt;br/&gt;一旦协调者发生故障，参与者会一直阻塞下去。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;数据不一致性&lt;br/&gt;在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行commit，其余的参与者没有收到通知一直处于阻塞状态，这段时间就产生了数据的不一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2.三阶段提交协议&lt;/h3&gt;
&lt;p&gt;Three Phase分别为CanCommit、PreCommit、DoCommit。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;806&quot; data-height=&quot;698&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1392632-39d7a92d1d4cd372..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1392632-39d7a92d1d4cd372..png&quot; data-original-width=&quot;806&quot; data-original-height=&quot;698&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;47731&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;三阶段提交针对两阶段提交做了改进：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;引入超时机制。在2PC中，只有协调者拥有超时机制，3PC同时在协调者和参与者中都引入超时机制。&lt;/li&gt;
&lt;li&gt;在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;四、Paxos算法的提出&lt;/h2&gt;
&lt;p&gt;二阶段提交还是三阶段提交都无法很好的解决分布式的一致性问题，直到Paxos算法的提出，Paxos协议由Leslie Lamport最早在1990年提出，目前已经成为应用最广的分布式一致性算法。&lt;/p&gt;
&lt;p&gt;Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。&lt;/p&gt;
&lt;h3&gt;1.节点角色&lt;/h3&gt;
&lt;p&gt;Paxos 协议中，有三类节点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Proposer:提案者&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Proposer 可以有多个，Proposer 提出议案(value)。所谓 value，在工程中可以是任何操作，例如“修改某个变量的值为某个值”、“设置当前 primary 为某个节点”等等。Paxos 协议中统一将这些操作抽象为 value。&lt;br/&gt;不同的 Proposer 可以提出不同的甚至矛盾的 value，例如某个 Proposer 提议“将变量 X 设置为 1”，另一个 Proposer 提议“将变量 X 设置为 2”，但对同一轮 Paxos 过程，最多只有一个 value 被批准。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Acceptor:批准者&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Acceptor 有 N 个，Proposer 提出的 value 必须获得超过半数(N/2+1)的&lt;br/&gt;Acceptor 批准后才能通过。Acceptor 之间完全对等独立。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Learner:学习者&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Learner 学习被批准的 value。所谓学习就是通过读取各个 Proposer 对 value 的选择结果，如果某个 value 被超过半数 Proposer 通过，则 Learner 学习到了这个 value。&lt;/p&gt;
&lt;p&gt;这里类似 Quorum 议会机制，某个 value 需要获得 W=N/2 + 1 的 Acceptor 批准，Learner 需要至少读取 N/2+1 个 Accpetor，至多读取 N 个 Acceptor 的结果后，能学习到一个通过的 value。&lt;/p&gt;
&lt;h3&gt;2.约束条件&lt;/h3&gt;
&lt;p&gt;上述三类角色只是逻辑上的划分，实践中一个节点可以同时充当这三类角色。有些文章会添加一个Client角色，作为产生议题者，实际不参与选举过程。&lt;/p&gt;
&lt;p&gt;Paxos中 proposer 和 acceptor 是算法的核心角色，paxos 描述的就是在一个由多个 proposer 和多个 acceptor 构成的系统中，如何让多个 acceptor 针对 proposer 提出的多种提案达成一致的过程，而 learner 只是“学习”最终被批准的提案。&lt;/p&gt;
&lt;p&gt;Paxos协议流程还需要满足几个约束条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Acceptor必须接受它收到的第一个提案；&lt;/li&gt;
&lt;li&gt;如果一个提案的v值被大多数Acceptor接受过，那后续的所有被接受的提案中也必须包含v值（v值可以理解为提案的内容，提案由一个或多个v和提案编号组成）；&lt;/li&gt;
&lt;li&gt;如果某一轮 Paxos 协议批准了某个 value，则以后各轮 Paxos 只能批准这个value；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每轮 Paxos 协议分为准备阶段和批准阶段，在这两个阶段 Proposer 和 Acceptor 有各自的处理流程。&lt;/p&gt;
&lt;p&gt;Proposer与Acceptor之间的交互主要有4类消息通信，如下图：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;557&quot; data-height=&quot;449&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1392632-73d30142aed5b790..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/557&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1392632-73d30142aed5b790..png&quot; data-original-width=&quot;557&quot; data-original-height=&quot;449&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;17538&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这4类消息对应于paxos算法的两个阶段4个过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Phase 1&lt;br/&gt;a) proposer向网络内超过半数的acceptor发送prepare消息&lt;br/&gt;b) acceptor正常情况下回复promise消息&lt;/li&gt;
&lt;li&gt;Phase 2&lt;br/&gt;a) 在有足够多acceptor回复promise消息时，proposer发送accept消息&lt;br/&gt;b) 正常情况下acceptor回复accepted消息&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;3.选举过程&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;932&quot; data-height=&quot;698&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1392632-99f2f1eede18882b..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1392632-99f2f1eede18882b..png&quot; data-original-width=&quot;932&quot; data-original-height=&quot;698&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;28847&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Phase 1 准备阶段&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Proposer 生成全局唯一且递增的ProposalID，向 Paxos 集群的所有机器发送 Prepare请求，这里不携带value，只携带N即ProposalID 。&lt;/p&gt;
&lt;p&gt;Acceptor 收到 Prepare请求 后，判断：收到的ProposalID 是否比之前已响应的所有提案的N大：&lt;br/&gt;如果是，则：&lt;br/&gt;(1) 在本地持久化 N，可记为Max_N。&lt;br/&gt;(2) 回复请求，并带上已Accept的提案中N最大的value（若此时还没有已Accept的提案，则返回value为空）。&lt;br/&gt;(3) 做出承诺：不会Accept任何小于Max_N的提案。&lt;/p&gt;
&lt;p&gt;如果否：不回复或者回复Error。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Phase 2 选举阶段&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;P2a：Proposer 发送 Accept&lt;br/&gt;经过一段时间后，Proposer 收集到一些 Prepare 回复，有下列几种情况：&lt;br/&gt;(1) 回复数量 &amp;gt; 一半的Acceptor数量，且所有的回复的value都为空，则Porposer发出accept请求，并带上自己指定的value。&lt;br/&gt;(2) 回复数量 &amp;gt; 一半的Acceptor数量，且有的回复value不为空，则Porposer发出accept请求，并带上回复中ProposalID最大的value(作为自己的提案内容)。&lt;br/&gt;(3) 回复数量 &amp;lt;= 一半的Acceptor数量，则尝试更新生成更大的ProposalID，再转P1a执行。&lt;/p&gt;
&lt;p&gt;P2b：Acceptor 应答 Accept&lt;br/&gt;Accpetor 收到 Accpet请求 后，判断：&lt;br/&gt;(1) 收到的N &amp;gt;= Max_N (一般情况下是 等于)，则回复提交成功，并持久化N和value。&lt;br/&gt;(2) 收到的N &amp;lt; Max_N，则不回复或者回复提交失败。&lt;/p&gt;
&lt;p&gt;P2c: Proposer 统计投票&lt;br/&gt;经过一段时间后，Proposer 收集到一些 Accept 回复提交成功，有几种情况：&lt;br/&gt;(1) 回复数量 &amp;gt; 一半的Acceptor数量，则表示提交value成功。此时，可以发一个广播给所有Proposer、Learner，通知它们已commit的value。&lt;br/&gt;(2) 回复数量 &amp;lt;= 一半的Acceptor数量，则 尝试 更新生成更大的 ProposalID，再转P1a执行。&lt;br/&gt;(3) 收到一条提交失败的回复，则尝试更新生成更大的 ProposalID，再转P1a执行。&lt;/p&gt;
&lt;h3&gt;4.相关讨论&lt;/h3&gt;
&lt;p&gt;Paxos算法的核心思想：&lt;br/&gt;（1）引入了多个Acceptor，单个Acceptor就类似2PC中协调者的单点问题，避免故障&lt;br/&gt;（2）Proposer用更大ProposalID来抢占临时的访问权，可以对比2PC协议，防止其中一个Proposer崩溃宕机产生阻塞问题&lt;br/&gt;（3）保证一个N值，只有一个Proposer能进行到第二阶段运行，Proposer按照ProposalID递增的顺序依次运行&lt;br/&gt;(3) 新ProposalID的proposer比如认同前面提交的Value值，递增的ProposalID的Value是一个继承关系&lt;/p&gt;
&lt;p&gt;为什么在Paxos运行过程中，半数以内的Acceptor失效都能运行？&lt;br/&gt;(1) 如果半数以内的Acceptor失效时 还没确定最终的value，此时，所有Proposer会竞争 提案的权限，最终会有一个提案会 成功提交。之后，会有半过数的Acceptor以这个value提交成功。&lt;br/&gt;(2) 如果半数以内的Acceptor失效时 已确定最终的value，此时，所有Proposer提交前 必须以 最终的value 提交，此值也可以被获取，并不再修改。&lt;/p&gt;
&lt;p&gt;如何产生唯一的编号呢？&lt;br/&gt;在《Paxos made simple》中提到的是让所有的Proposer都从不相交的数据集合中进行选择，例如系统有5个Proposer，则可为每一个Proposer分配一个标识j(0~4)，则每一个proposer每次提出决议的编号可以为5*i + j(i可以用来表示提出议案的次数)。&lt;/p&gt;
&lt;p&gt;推荐larmport和paxos相关的三篇论文：&lt;br/&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Flamport.azurewebsites.net%2Fpubs%2Flamport-paxos.pdf&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;The Part-Time Parliament&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Flamport.azurewebsites.net%2Fpubs%2Fpaxos-simple.pdf&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Paxos made simple&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fresearch%2Fpublication%2Ffast-paxos%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Fast Paxos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2PC/3PC和Paxos协议是经典的分布式协议，理解了它们以后，学习其他分布式协议会简单很多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FCAP_theorem&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;CAP theorem&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fwww.atatech.org%2Farticles%2F28525&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;浅谈分布式系统的基本问题：可用性与一致性&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DBhosKsE8up8&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;分布式系统入门到实战&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;a href=&quot;https://link.jianshu.com/?t=http%3A%2F%2Fcodemacro.com%2F2014%2F10%2F15%2Fexplain-poxos%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;图解分布式一致性协议Paxos&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fbaozh.github.io%2F2016-03%2Fpaxos-learning%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Paxos协议学习小结&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 15:16:00 +0000</pubDate>
<dc:creator>邴越</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/binyue/p/8645565.html</dc:identifier>
</item>
<item>
<title>【Android】你知道还可以通过 View.animate() 来实现动画么 - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/8647702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/8647702.html</guid>
<description>&lt;p&gt;这次想来讲讲 &lt;strong&gt;View.animate()&lt;/strong&gt;，这是一种超好用的动画实现方式，用这种方式来实现常用的动画效果非常方便，但在某些场景下会有一个坑，所以这次就来梳理一下它的原理。&lt;/p&gt;

&lt;p&gt;首先，先来看一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mView.animate().sacleX(1.2f).scaleY(1.2f).alpha(0.5f).setDuration(1000).start();  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以有些人还没接触过这个，但并不妨碍首次理解上述代码。单从方法名上来看，上述代码就是一个实现了持续 1s 的放大 &amp;amp; 透明度结合的动画，是不是发现使用起来特别简单，一行代码就搞定。&lt;/p&gt;
&lt;p&gt;当然，上述的动画效果也可以通过 &lt;strong&gt;ValueAnimator&lt;/strong&gt; 或 &lt;strong&gt;ObjectAnimator&lt;/strong&gt; 来实现，只是可能没法像上述一样一行代码就搞定。如果用 &lt;strong&gt;Animation&lt;/strong&gt; 来实现，那么需要的代码就更多了。&lt;/p&gt;
&lt;p&gt;所以，我们的问题就来了：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q1：动画基本可以分为 Animator 和 Animation 两大类，而 View.animate() 返回的是一个 ViewPropertyAnimator 类型的对象，这个类并没有继承自任何类，那么它实现动画的原理又是什么呢？单从命名上看好像是通过 Animator 实现，那么真的是这样么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2：开头说了，使用这种方式实现的动画在某些场景下会有一个坑，这个坑又是什么，是在什么场景下的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好了，下面就开始来跟着源码一起学习吧：&lt;/p&gt;

&lt;p&gt;ps:本篇阅读的源码版本都是 android-25，版本不一样，源码可能会有些许差别，大伙自己过的时候注意一下。&lt;/p&gt;
&lt;p&gt;那么，源码阅读的着手点就跟之前几篇分析动画的一样，从 &lt;code&gt;start()&lt;/code&gt; 开始一步步跟踪下去就行了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator#start()
public void start() {
    mView.removeCallbacks(mAnimationStarter);
    startAnimation();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码很少就两行，第二行是调用了一个方法，看方法名可以猜测应该是去处理动画开始的工作，那么在动画开始前还移除了一个回调，但要搞清楚第一行的代码是干嘛用的，我们得先知道两个变量的含义，首先是第一个 mView：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator构造函数
ViewPropertyAnimator(View view) {
    mView = view;
    view.ensureTransformationInfo();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mView 是一个成员变量，在构造函数中被赋值，还记得吧，要用这种方式实现动画时，都得先调用 &lt;strong&gt;View.animate()&lt;/strong&gt; 来创造一个 ViewPropertyAnimator 对象，所以去 View 的 &lt;code&gt;animate()&lt;/code&gt; 方法里瞧瞧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//View#animate() 
public ViewPropertyAnimator animate() {
    if (mAnimator == null) {
        mAnimator = new ViewPropertyAnimator(this);
    }
    return mAnimator;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法里会去创建一个 ViewPropertyAnimator 对象，并将 View 自身 this 作为参数传递进去，也就是说，在 ViewPropertyAnimator 里的 mView 变量其实指向的就是要进行动画的那个 View。&lt;/p&gt;
&lt;p&gt;知道了 mView 其实就是需要进行动画的那个 View 后，接下去来看看另一个变量 mAnimationStarter 是什么了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator.mAnimationnStarter
private Runnable mAnimationStarter = new Runnable() {
    @Override
    public void run() {
        startAnimation();
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 Runnable 就是一个启动动画的工作，emmm，这样就有点奇怪了，我们再回过头来看看 &lt;code&gt;start()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator#start()
public void start() {
    mView.removeCallbacks(mAnimationStarter);
    startAnimation();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;为什么明明方法的第二行就会去执行 &lt;code&gt;startAnimation()&lt;/code&gt; 了，第一行却又要去取消一个执行 &lt;code&gt;startAnimation()&lt;/code&gt; 的 Runnable 呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只能说明，在我们调用 &lt;code&gt;start()&lt;/code&gt; 之前，ViewPropertyAnimator 内部就已经预先安排了一个会执行 &lt;code&gt;startAnimation()&lt;/code&gt; 的 Runnable 进入待执行状态，所以在调用了 &lt;code&gt;start()&lt;/code&gt; 之后先去取消这个 Runnable 才会有意义。&lt;/p&gt;
&lt;p&gt;那么，又是哪里会去触发安排一个 Runnable 呢？&lt;/p&gt;
&lt;p&gt;回头再看看我们使用这种方式来实现动画效果是怎么用的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mView.animate().sacleX(1.2f).scaleY(1.2f).alpha(0.5f).setDuration(1000).start();  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，通过 &lt;code&gt;View.animate()&lt;/code&gt; 先创建一个 ViewPropertyAnimator 对象，中间设置了一系列动画行为，最后才调用了 &lt;code&gt;start()&lt;/code&gt;。那么，有机会去触发安排一个待执行的 Runnable 操作也只能发生在中间的这些方法里了，那么我们选择一个跟进去看看，&lt;code&gt;scaleX()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator#scaleX()
public ViewPropertyAnimator scaleX(float value) {
    animateProperty(SCALE_X, value);
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续跟进去看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator#animateProperty()
private void animateProperty(int constantName, float toValue) {
    float fromValue = getValue(constantName);
    float deltaValue = toValue - fromValue;
    animatePropertyBy(constantName, fromValue, deltaValue);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于各个参数是什么意思，我们后面再来分析，目前我们是想验证是不是这些封装好的动画接口内部会去触发一个待执行的 Runnable 操作，所以优先继续跟踪下去：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator#animatePropertyBy()
private void animatePropertyBy(int constantName, float startValue, float byValue){
    ...
    mView.removeCallbacks(mAnimationStarter);
    mView.postOnAnimation(mAnimationStarter);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;终于找到了，而且不仅仅是 &lt;code&gt;scaleX()&lt;/code&gt; 方法，其他封装好的动画接口如 &lt;code&gt;scaleY()&lt;/code&gt;，&lt;code&gt;alpha()&lt;/code&gt;，&lt;code&gt;translationX()&lt;/code&gt; 等等所有这一系列的方法内部最终都会走到 &lt;code&gt;animatePropertyBy()&lt;/code&gt; 里去。而在这个方法最后都会先将待执行的 Runnable 先移除掉，再重新 post。&lt;/p&gt;
&lt;p&gt;要理解这么做的用意，得先明白 View 的这两个方法：&lt;code&gt;removeCallbacks()&lt;/code&gt;，&lt;code&gt;postOnAnimation()&lt;/code&gt; 是干嘛用的。这里我就不跟下去了，直接给大伙说下结论：&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;postOnAnimation()&lt;/code&gt; 传进去的 Runnable 并不会被马上执行，而是要等到下一个屏幕刷新信号来的时候才会被取出来执行。&lt;/p&gt;
&lt;p&gt;那么，将这些串起来，也就是说，&lt;strong&gt;仅仅只是 &lt;code&gt;View.animate().scaleX()&lt;/code&gt; 这样使用时，就算不主动调用 &lt;code&gt;start()&lt;/code&gt; ，其实内部也会自动安排一个 Runnable，最迟在下一个屏幕刷新信号来的时候，就会自动去调用 &lt;code&gt;startAnimation()&lt;/code&gt; 来启动动画。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但如果主动调用了 &lt;code&gt;start()&lt;/code&gt;，内部就需要先将安排好的 Runnable 操作取消掉，然后直接调用 &lt;code&gt;startAnimation()&lt;/code&gt; 来启动动画。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，接下去就来看看是如何启动动画的，&lt;code&gt;startAnimation()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator#startAnimation()
private void startAnimation() {
    //1. 这里我还没搞懂，也不清楚什么场景下会满足这里的条件，直接 return。所以，本篇接下去的分析都是基于假设会直接跳过这里，后面如果搞懂了再来填坑。 
    if (mRTBackend != null &amp;amp;&amp;amp; mRTBackend.startAnimation(this)) {
        return;
    }
    ...
    
    //2. 创建一个 0.0-1.0 变化的 ValueAnimator
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);

    //3. 将当前 mPengingAnimations 里保存的一系列动画全都取出来，作为同一组一起执行一起结束的动画
    ArrayList&amp;lt;NameValuesHolder&amp;gt; nameValueList =
            (ArrayList&amp;lt;NameValuesHolder&amp;gt;) mPendingAnimations.clone();
    ...

    //4. 创建一个新的 PropertyBundle 来保存这一组动画，以ValueAnimator作为key来区分
    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));
    
    //5. 提供动画开始前，结束后的操作回调
    if (mPendingSetupAction != null) {
        mAnimatorSetupMap.put(animator, mPendingSetupAction);
        mPendingSetupAction = null;
    }
    ...

    //6. 对ValueAnimator进行 Listener、StartDelay、Duration、Interpolator 的设置
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    ...

    //7. 启用ValueAnimator.start()
    animator.start();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码可以先不用细看，我们稍后再来一块一块慢慢过，我已经将整个方法里做的事大概划分成了 7 件，首先有一点需要提一下，方法内其实是通过 ValueAnimator 来实现的。&lt;/p&gt;
&lt;p&gt;上一篇博客&lt;a href=&quot;https://www.jianshu.com/p/46f48f1b98a9&quot;&gt;属性动画 ValueAnimator 运行原理全解析&lt;/a&gt;中，我们已经将 ValueAnimator 的运行原理分析完了，感兴趣的可以回去看看，这里大概提几点结论：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;ValueAnimator 内部其实并没有进行任何 ui 操作，它只是提供了一种机制，可以根据设定的几个数值，如 0-100，内部自己在每一帧内，根据当前时间，第一帧的时间，持续时长，以及插值器规则，估值器规则来计算出在当前帧内动画的进度并映射到设定的数值区间，如 0-100 区间内映射之后的数值应该是多少。&lt;/p&gt;
&lt;p&gt;既然 ValueAnimator 并没有进行任何 ui 操作，那么要用它来实现动画效果，只能自己在 ValueAnimator 提供的每一帧的回调里（AnimatorUpdateListener），自己取得 ValueAnimator 计算出的数值，来自行应用到需要进行动画效果的那个 View 上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想想自己使用 ValueAnimator 的时候是不是这样，我们并没有将 View 作为参数传递给 ValueAnimator，所以它内部也就没有持有任何 View 的引用，自然做不了任何 ui 操作。&lt;/p&gt;
&lt;p&gt;所以看看 &lt;code&gt;startAnimation()&lt;/code&gt; 方法里的，我标出来的第 2、6、7点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator#startAnimation()
private void startAnimation() {
    ...
    
    //2. 创建一个 0.0-1.0 变化的 ValueAnimator
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);

    ...
    //6. 对ValueAnimator进行 Listener、StartDelay、Duration、Interpolator 的设置
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    ...

    //7. 启用ValueAnimator.start()
    animator.start();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，ViewPropertyAnimator 其实是通过 &lt;code&gt;ValueAnimator.ofFloat(1.0f)&lt;/code&gt;，也就是借助 ValueAnimator 的机制，来计算每一帧动画进度在 0-1 内对应的数值。然后在它的每一帧的回调里再去进行 view 的 ui 操作来达到动画效果，那么 ui 操作也就是在 mAnimatorEventListener 里做的事了，跟进去看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator.mAnimatorEventListener
private AnimatorEventListener mAnimatorEventListener = new AnimatorEventListener();  

private class AnimatorEventListener implements Animator.AnimatorListener, ValueAnimator.AnimatorUpdateListener {
    ...

    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        ...

        //1. 取出 ValueAnimator 计算出的当前帧的动画进度    
        float fraction = animation.getAnimatedFraction();
        
        //2. 根据取得的动画进度，进行一系列view的ui操作，来达到动画效果
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;省略了绝大部分代码，等会会再来慢慢过，这样省略后比较容易梳理出整个流程，优先将流程梳理清楚，再来分析每个步骤具体干的活。&lt;/p&gt;
&lt;p&gt;所以，可以看到，ViewPropertyAnimator 确实是在 ValueAnimator 的每一帧的回调中，取得 VauleAnimator 机制计算出来的动画进度值，然后自行进行 ui 操作来达到动画效果。&lt;/p&gt;
&lt;p&gt;那么，到这里，整个流程就已经梳理出来了，我们先来&lt;strong&gt;梳理一下目前的信息&lt;/strong&gt;：&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;通过 &lt;code&gt;View.animate().scaleX(1.2f).start()&lt;/code&gt; 实现的动画，如果外部没有手动调用 &lt;code&gt;start()&lt;/code&gt; 方法，那么 ViewPropertyAnimator 内部最迟会在下一帧的时候自动调用 &lt;code&gt;startAnimation()&lt;/code&gt; 来启动动画。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;ViewPropertyAnimator 实现下一帧内自动启动动画是通过 &lt;code&gt;View.postOnAnimation()&lt;/code&gt; 实现，View 的这个方法会将传递进来的 Runnable 等到下一帧的时候再去执行。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;如果外部手动调用了 &lt;code&gt;start()&lt;/code&gt;，那么内部会先将第 2 步中安排的自动启动动画的 Runnable 取消掉，然后直接调用 &lt;code&gt;startAnimation()&lt;/code&gt; 启动动画。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;startAnimation()&lt;/code&gt; 启动动画，实际上是借助 ValueAnimator 的机制，在 &lt;code&gt;onAnimationUpdate()&lt;/code&gt; 里取得每一帧内的动画进度时，再自行进行对应的 ui 操作来达到动画效果。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;ValueAnimator 只是会根据当前时间，动画第一帧时间，持续时长，插值器规则，估值器规则等来计算每一帧内的当前动画进度值，然后根据关键帧机制来映射到设定的范围内的数值，最后通过每一帧的进度回调，供外部使用，它本身并没有任何 ui 操作（详情可看上一篇博客）。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好了，流程上已经梳理清理了，接下去就是细节问题了，ViewPropertyAnimator 取得了每一帧对应的动画进度时又是&lt;strong&gt;如何进行的 ui 操作的呢&lt;/strong&gt;？&lt;code&gt;View.animate()&lt;/code&gt; 后面是支持一系列的动画操作，如 &lt;code&gt;scaleX()&lt;/code&gt;，&lt;code&gt;alpha()&lt;/code&gt; 等一起执行的，那么&lt;strong&gt;内部又是如何区分，维护的呢&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;我们还是按照流程来一步步详细的分析，&lt;strong&gt;View.animate()&lt;/strong&gt; 方式实现的动画，流程上是&lt;strong&gt;&lt;em&gt;设置动画行为--启动动画--每一帧进度回调中进行ui操作&lt;/em&gt;&lt;/strong&gt;。所以，下面就先看看第一个步骤，跟着 &lt;code&gt;scaleX()&lt;/code&gt; 进去看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator#scaleX()
public ViewPropertyAnimator scaleX(float value) {
    //1. 第一个参数用于区分不同的动画，第二个参数设定动画最后一帧的值
    animateProperty(SCALE_X, value);
    return this;
}

//ViewPropertyAnimator#animateProperty()
private void animateProperty(int constantName, float toValue) {
    //2. 第一步先取得该种动画行为下的默认第一帧值，最后一帧值就是参数传递进来
    float fromValue = getValue(constantName);
    //3. 计算出动画的变化数值
    float deltaValue = toValue - fromValue;
    animatePropertyBy(constantName, fromValue, deltaValue);
}

//ViewPropertyAnimator#getValue()
private float getValue(int propertyConstant) {
    final RenderNode node = mView.mRenderNode;
    switch (propertyConstant) {
        ...
        //4. 直接通过 getScaleX() 取得当前 view 的默认属性值
        case SCALE_X:
            return node.getScaleX();
        ...
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码作用，其实也就只是取得对应动画行为下的第一帧的属性值，然后根据设定的最后一帧属性值来计算出动画变化的数值，最终作为参数传递给 &lt;code&gt;animatePropertyBy()&lt;/code&gt;，所以最关键的任务肯定在这个方法里，但要捋清楚这个方法里的代码前，还需要先了解一些变量以及内部类的含义：&lt;/p&gt;
&lt;p&gt;ViewPropertyAnimator 内部有两个数据结构类 &lt;strong&gt;NameValuesHolder&lt;/strong&gt; 和 &lt;strong&gt;PropertyBundle&lt;/strong&gt;，都是用于存储各种动画信息的，除此之外，还有一系列成员变量的列表，如 &lt;strong&gt;mPendingAnimations&lt;/strong&gt;，&lt;strong&gt;mAnimatorMap&lt;/strong&gt; 等。要搞清楚这些的含义，还得先搞懂 &lt;code&gt;View.animate()&lt;/code&gt; 是支持如何使用的。&lt;/p&gt;
&lt;p&gt;这么说吧，还是拿开头的示例代码来说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mView.animate().scaleX(1.2f).scaleY(1.2f).alpha(0.5f).setDuration(1000).start();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ViewPropertyAnimator 亮点就是支持链式调用一系列不同的动画一起执行，所以需要注意一点，一旦像上述那样使用，那么设定的这一系列动画就会是一起执行一起结束的。&lt;/p&gt;
&lt;p&gt;那么，有可能存在这种场景：先设置了一系列动画执行，如果在这一系列的动画执行结束前，又通过 &lt;code&gt;View.animate()&lt;/code&gt; 设置了另外一系列一起执行的动画效果，那么这时就会有两组动画都在运行中，每组动画都可能含有多种类型的动画，所以内部就需要以每组为单位来保存信息，确保每组动画可以互不干扰，这就是 PropertyBundle 这个类的作用了:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator$PropertyBundle
private static class PropertyBundle {
    int mPropertyMask;
    ArrayList&amp;lt;NameValuesHolder&amp;gt; mNameValuesHolder;

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样解释完，再来看这个类，这样理解两个成员变量的含义就容易多了，首先 mNameValuesHolder 是一个 ArrayList 对象，显然就是用来存储这一组动画里的那一系列不同类型的动画；那具体存在列表里都有哪些类型的动画呢，就是另一个成员变量 mPropertyMask 来进行标志了。&lt;/p&gt;
&lt;p&gt;而列表里存的这一组动画里的不同类型的动画，所以 NamaValuesHolder 这个类的作用就是用于区分各种不同类型的动画了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator$NameValuesHolder
static class NameValuesHolder {
    int mNameConstant;
    float mFromValue;
    float mDeltaValue;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个成员变量 mNameConstant 就是用于区分不同类型的动画，在 ViewPropertyAnimator 内部定义了一系列常用动画的常量，mNameConstant 这个变量的取值就在这些常量中，如开头出现 SCALE_X。而另外两个变量表示的就是这种类型的动画要进行变化的数值信息。&lt;/p&gt;
&lt;p&gt;另外，ViewPropertyAnimator 支持设置一系列不同类型的动画，那么它是以什么为依据来决定哪一系列的动画作为第一组，哪一系列作为第二组呢？其实很简单，就是以 &lt;code&gt;startAnimation()&lt;/code&gt; 被调用为依据。那么，成员变量 mPendingAnimations 的作用也就出来了。&lt;/p&gt;
&lt;p&gt;每一次调用 &lt;code&gt;scaleX()&lt;/code&gt; 等等之类的方法时，都会创建一个 NameValuesHolder 对象来保存对应这种类型的动画信息，然后保存在 mPendingAnimations 列表中。&lt;code&gt;scaleY()&lt;/code&gt; 等这些方法不断被调用，mPendingAnimations 就会保存越来越多的待执行的不同类型的动画。而一旦 &lt;code&gt;startAnimation()&lt;/code&gt; 方法被调用时，就会将当前 mPendingAnimations 列表里存的这一系列动画作为同一组一起执行一起结束的动画保存到一个新的 PropertyBundle 对象里。然后清空 mPendingAnimations，直到下一次 &lt;code&gt;startAnimation()&lt;/code&gt; 被调用时，再次将 mPendingAnimations 中新保存的一系列动画作为另外一组动画保存到新的 PropertyBundle 中去。&lt;/p&gt;
&lt;p&gt;那么，最后还需要有一个变量来保存并区分这一组一组的动画，这就是 mAnimatorMap 变量的作用了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private HashMap&amp;lt;Animator, PropertyBundle&amp;gt; mAnimatorMap = new HashMap&amp;lt;Animator, PropertyBundle&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下定义，没错吧，PropertyBundle 保存的是一组动画里一起开始一起结束的一系列动画，所以 mAnimatorMap 是以 Animator 为 Key 区分每一组动画的。&lt;/p&gt;
&lt;p&gt;捋清楚了这些内部类和变量的作用，我们下面再来看之前分析的调用了 &lt;code&gt;scaleX()&lt;/code&gt; 后，内部跟到了 &lt;code&gt;animatePropertyBy()&lt;/code&gt;，那么我们继续跟下去看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator#animatePropertyBy()
private void animatePropertyBy(int constantName, float startValue, float byValue) {
    //1. mAnimatorMap 存放着一组一组正在运行中的动画
    if (mAnimatorMap.size() &amp;gt; 0) {
        Animator animatorToCancel = null;
        Set&amp;lt;Animator&amp;gt; animatorSet = mAnimatorMap.keySet();
        for (Animator runningAnim : animatorSet) {
            // 2. bundle 保存着当前这一组动画里的一系列正在运行中的不同类型的动画
            PropertyBundle bundle = mAnimatorMap.get(runningAnim);
            if (bundle.cancel(constantName)) {
                if (bundle.mPropertyMask == NONE) {    
                    animatorToCancel = runningAnim;
                    break;
                }
            }
        }
        if (animatorToCancel != null) {
            animatorToCancel.cancel();
        }
    }
    // 3. 所以上述1 2步的工作就是要将当前constantName类型的动画取消掉

    //4. 创建一个 NameValuesHolder 对象用于保存当前constantName类型的动画信息
    NameValuesHolder nameValuePair = new NameValuesHolder(constantName, startValue, byValue);
    //5. 将该类型的动画信息保存到 mPendingAnimations 中
    mPendingAnimations.add(nameValuePair);

    //6. 安排一个自动开启动画的Runnable，最迟在下一帧触发
    mView.removeCallbacks(mAnimationStarter);
    mView.postOnAnimation(mAnimationStarter);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码里从第 4-6 的步骤应该都清楚了吧，每次调用 &lt;code&gt;scaleX()&lt;/code&gt; 之类的动画，内部需要先创建一个 NameValuesHolder 对象来保存该类型的动画行为（第4步），然后将该类型动画添加到 mPendingAnimations 列表中（第5步）来作为组成一系列一起开始一起结束的动画，最后会自动安排一个最迟在下一帧内自动启动动画的 Runnable（第6步）。&lt;/p&gt;
&lt;p&gt;那么第 1-3 步又是干嘛的呢？&lt;/p&gt;
&lt;p&gt;是这样的，上面说过，可能会存在一组一组都在运行中的动画，每一组都有一系列不同类型的动画，那么就有可能出现同一种类型的动画，比如 &lt;code&gt;scaleX()&lt;/code&gt;，既在第一组里，又在第二组里。很显然，ViewPropertyAnimator 里的所有动画都是作用于同一个 View 上，而不同组的动画又有可能同一时刻都在运行中，那么，一个 View 的同一种类型动画有可能在同一时刻被执行两次么？说得白一点，一个 View 的大小如果在同一帧内先放大 1.2 倍，同时又放大 1.5 倍，那这个 View 呈现出来的效果肯定特别错乱。&lt;/p&gt;
&lt;p&gt;所以，ViewPropertyAnimator 里所有的动画，在同一时刻，同一类型的动画只支持只有一个处于正在运行中的状态，这也就是第 1-3 步的意义，它需要去遍历当前每一组里的每一个动画，如果类型跟当前设定的动画类型一致，那么就将之前的动画取消掉，以最近设定的这次为准。&lt;/p&gt;
&lt;p&gt;好了，&lt;code&gt;scaleX()&lt;/code&gt; 这些设定动画的行为，内部实现的细节我们已经分析完了，下面就继续看看下一个流程，启动动画里都干了啥，&lt;code&gt;startAnimation()&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator#startAnimation()
private void startAnimation() {
    //1. 这里我还没搞懂，也不清楚什么场景下会满足这里的条件，直接 return。所以，本篇接下去的分析都是基于假设会直接跳过这里，后面如果搞懂了再来填坑。 
    if (mRTBackend != null &amp;amp;&amp;amp; mRTBackend.startAnimation(this)) {
        return;
    }
    mView.setHasTransientState(true);
    
    //2. 创建一个 0.0-1.0 变化的 ValueAnimator
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);

    //3. 将当前 mPengingAnimations 里保存的一系列动画全都取出来，作为同一组一起执行一起结束的动画
    ArrayList&amp;lt;NameValuesHolder&amp;gt; nameValueList =
            (ArrayList&amp;lt;NameValuesHolder&amp;gt;) mPendingAnimations.clone();
    mPendingAnimations.clear();
    int propertyMask = 0;
    int propertyCount = nameValueList.size();
    //3.1 遍历这一系列动画，将这些动画都有哪些类型的动画标志出来
    for (int i = 0; i &amp;lt; propertyCount; ++i) {
        NameValuesHolder nameValuesHolder = nameValueList.get(i);
        propertyMask |= nameValuesHolder.mNameConstant;
    }

    //4. 创建一个新的 PropertyBundle 来保存这一组动画，以ValueAnimator作为key来区分
    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));
    
    //5. 提供动画开始前，结束后的操作回调
    if (mPendingSetupAction != null) {
        mAnimatorSetupMap.put(animator, mPendingSetupAction);
        mPendingSetupAction = null;
    }
    if (mPendingCleanupAction != null) {
        mAnimatorCleanupMap.put(animator, mPendingCleanupAction);
        mPendingCleanupAction = null;
    }
    if (mPendingOnStartAction != null) {
        mAnimatorOnStartMap.put(animator, mPendingOnStartAction);
        mPendingOnStartAction = null;
    }
    if (mPendingOnEndAction != null) {
        mAnimatorOnEndMap.put(animator, mPendingOnEndAction);
        mPendingOnEndAction = null;
    }

    //6. 对ValueAnimator进行 Listener、StartDelay、Duration、Interpolator 的设置
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    if (mStartDelaySet) {
        animator.setStartDelay(mStartDelay);
    }
    if (mDurationSet) {
        animator.setDuration(mDuration);
    }
    if (mInterpolatorSet) {
        animator.setInterpolator(mInterpolator);
    }

    //7. 启用ValueAnimator.start()
    animator.start();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第 1 步我还没搞清楚，就先暂时跳过吧。&lt;/p&gt;
&lt;p&gt;第 2-4 步就是我们上面有说过的，当 &lt;code&gt;startAnimation()&lt;/code&gt; 被调用时，将当前保存在 mPendingAnimations 列表里所有的动画都作为同一组一起开始一起结束的动画，保存到一个新的 PropertyBundle 对象中，每一组动画什么时候开始，结束，以及每一帧的进度都是借助 ValueAnimator 机制实现，所以每一组动画就以不同的 ValueAnimator 对象作为 key 值保存到 mAnimatorMap 中相户区分，独立出来。&lt;/p&gt;
&lt;p&gt;第 5 步是 ViewPropertyAnimator 支持的接口，都是供外部根据需要使用，比如 mPendingOnStartAction 就是表示会在这一组动画开始的时候被执行，时机跟 &lt;code&gt;onAnimationStart()&lt;/code&gt; 相同，外部使用的时候调用 &lt;code&gt;withStartAction()&lt;/code&gt; 就可以了。那么为什么需要提供这样的接口呢？&lt;/p&gt;
&lt;p&gt;这是因为，如果我们想要在动画开始或结束的时候做一些事，如果我们是这样使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mView.animate().scaleX(1.2f)
    .setListener(new AnimatorListenerAdapter() {
        @Override
        public void onAnimationStart(Animator animation) {
            //do something
        }
    }).start();  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错，这样写的话，确实可以实现在动画前去执行我们指定的工作。但这样会有一个问题，因为 ViewPropertyAnimator 动画是支持多组动画同时进行中的，如果像上面这样写的话，那么每一组动画在开始之前就都会去回调这个 &lt;code&gt;onAnimationStart()&lt;/code&gt; 方法，去做相同的事。&lt;/p&gt;
&lt;p&gt;如果我们只希望当前一组动画去执行这些动画开始前的工作，其他组动画不用去执行，那么这时候就可以使用 &lt;code&gt;withStartAction()&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;p&gt;这就是第 5 步的用意。&lt;/p&gt;
&lt;p&gt;第 6-7 步也就是对 ValueAnimator 做各种配置，如持续时长，延迟开始时间，插值器等等，最后调用 &lt;code&gt;ValueAnimator.start()&lt;/code&gt; 来启动。&lt;/p&gt;
&lt;p&gt;好，启动动画的具体的工作我们也分析完了，剩下最后一个流程了，在每一帧的回调中如何进行 ui 操作并且应用一系列的动画。那么，最后就看看 AnimatorEventListener:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator.mAnimatorEventListener

private class AnimatorEventListener implements Animator.AnimatorListener, ValueAnimator.AnimatorUpdateListener {
    ...

    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        //1. 取出跟当前 ValueAnimator 绑定的那一组动画
        PropertyBundle propertyBundle = mAnimatorMap.get(animation);
        ...

        //省略一堆没看懂的代码，跟硬件加速有关
        ...

        //2. 获取 ValueAnimator 机制计算出的当前帧的动画进度
        float fraction = animation.getAnimatedFraction();
        int propertyMask = propertyBundle.mPropertyMask;
        ...

        //3. 遍历这一组动画里的所有动画，分别根据不同类型的动画进行不同的 ui 操作来实现动画效果
        ArrayList&amp;lt;NameValuesHolder&amp;gt; valueList = propertyBundle.mNameValuesHolder;
        if (valueList != null) {
            int count = valueList.size();
            for (int i = 0; i &amp;lt; count; ++i) {
                //3.1 取出第i个动画
                NameValuesHolder values = valueList.get(i);
                //3.2 根据ValueAnimator计算的当前帧动画进度，以及第i个动画的第一帧的属性值和变化的值来计算出当前帧时的属性值是多少
                float value = values.mFromValue + fraction * values.mDeltaValue;
                
                //3.3 如果是 alpha 动画，通过View的set方法来修改alpha值，否则调用setValue方法
                if (values.mNameConstant == ALPHA) {
                    alphaHandled = mView.setAlphaNoInvalidation(value);
                } else {
                    setValue(values.mNameConstant, value);
                }
            }
        }
        
        //省略alpha动画的一些辅助处理
        ...

        //4. 进度回调，通知外部
        if (mUpdateListener != null) {
            mUpdateListener.onAnimationUpdate(animation);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法做的事也很明确了，上述代码中的注释大概也说完了。也就是说 ViewPropertyAnimator 动画内部在 ValueAnimator 的每一帧回调中，取出跟 ValueAnimator 绑定的那一组动画，以及当前帧的动画进度，然后再遍历当前组的所有动画，分别计算出每个动画当前帧的属性值，如果不是 alpha 动画的话，直接调用 &lt;code&gt;setValue()&lt;/code&gt; 方法来进行 ui 操作达到动画效果，如果是 alpha 动画，则调用 view 的一个 set 方法来实现。&lt;/p&gt;
&lt;p&gt;那么，下面再继续看看 &lt;code&gt;setValue()&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ViewPropertyAnimator#setValue()
private void setValue(int propertyConstant, float value) {
    final View.TransformationInfo info = mView.mTransformationInfo;
    final RenderNode renderNode = mView.mRenderNode;
    switch (propertyConstant) {
        case TRANSLATION_X:
            renderNode.setTranslationX(value);
            break;
        ...
        case SCALE_X:
            renderNode.setScaleX(value);
            break;
        case SCALE_Y:
            renderNode.setScaleY(value);
            break;
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;省略了一堆类似的代码，这个方法里，就全部都是根据不同类型的动画，取得当前 View 的 mRenderNode 对象，然后分别调用相应的 setXXX 方法，如 SCALE_X 动画，就调用 &lt;code&gt;setScaleX()&lt;/code&gt; 方法来进行 ui 操作达到动画效果。&lt;/p&gt;
&lt;p&gt;以上，&lt;code&gt;View.animate()&lt;/code&gt; 这种方式实现的动画，也就是 ViewPropertyAnimator 动画，的整个流程以及流程里每个步骤的工作，我们到此就全部梳理清楚了。&lt;/p&gt;

&lt;p&gt;最后，就来进行一下总结：&lt;/p&gt;
&lt;ol readability=&quot;15.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;View.animate()&lt;/code&gt; 这种方式实现的动画其实是 ViewPropertyAnimator 动画。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;ViewPropertyAnimator 并不是一种动画，它没有继承自 Animator 或者 Animation，它其实只是一个封装类，将常用的动画封装起来，对外提供方便使用的接口，内部借助 ValueAnimator 机制。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;ViewPropertyAnimator 动画支持自动启动动画，如果外部没有明确调用了 &lt;code&gt;start()&lt;/code&gt;，那么内部会安排一个 Runnable 操作，最迟在下一帧内被执行，这个 Runnable 会去启动动画。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;当然，如果外部手动调用了 &lt;code&gt;start()&lt;/code&gt;，那么自动启动动画就没意义了，内部会自己将其取消掉。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;ViewPropertyAnimator 对外提供的使用动画的接口非常方便，如 &lt;code&gt;scaleX()&lt;/code&gt; 表示 x 的缩放动画，&lt;code&gt;alpha()&lt;/code&gt; 表示透明度动画，而且支持链式调用。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;由于支持链式调用，所以它支持一系列动画一起开始，一起执行，一起结束。那么当这一系列动画还没执行完又重新发起了另一系列的动画时，此时两个系列动画就需要分成两组，每一组动画互不干扰，可以同时执行。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;但如果同一种类型的动画，如 SCALE_X，在同一帧内分别在多组里都存在，如果都同时运行的话，View 的状态会变得很错乱，所以 ViewPropertyAnimator 规定，同一种类型的动画在同一时刻只能有一个在运行。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;也就是说，多组动画可以处于并行状态，但是它们内部的动画是没有交集的，如果有交集，比如 SCALE_X 动画已经在运行中了，但是外部又新设置了一个新的 SCALE_X 动画，那么之前的那个动画就会被取消掉，新的 SCALE_X 动画才会加入新的一组动画中。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;由于内部是借助 ValueAnimator 机制，所以在每一帧内都可以接收到回调，在回调中取得 ValueAnimator 计算出的当前帧的动画进度。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;取出当前帧的动画进度后，就可以遍历跟当前 ValueAnimator 绑定的那一组动画里所有的动画，分别根据每一个动画保存的信息，来计算出当前帧这个动画的属性值，然后调用 View 的 mRenderNode 对象的 setXXX 方法来修改属性值，达到动画效果。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;还有一些细节并没有归纳到总结中，如果只看总结的小伙伴，有时间还是建议可以慢慢跟着本文过一遍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q1：开头说了，使用这种方式实现的动画在某些场景下会有一个坑，这个坑又是什么，是在什么场景下的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开头说过使用这种方式实现的动画，在某些场景下会存在一些坑。本来以为这篇里也能顺便说清楚，但单单只是原理梳理下来，篇幅就很长了，那么也当做遗留问题，留到之后的文章中来好好说下吧。可以先说下是什么坑：&lt;/p&gt;
&lt;p&gt;如果当前界面有使用 RecyclerView 控件，然后又对它的 item 通过 &lt;code&gt;View.animate()&lt;/code&gt; 方式实现了一些动画效果，比如很常见的 Tv 应用的主页，界面会有很多卡位，然后每个卡位获得焦点时一般都需要放大的动画，此时这个卡位就是 RecyclerView 的 item，放大动画可以通过 &lt;code&gt;View.animate()&lt;/code&gt; 方式来实现。&lt;/p&gt;
&lt;p&gt;在这种场景下，可能会存在这么一种现象，当界面刷新时，如果此时有进行遥控器的方向键按键事件，那么可能会有一些卡位的缩放动画被中断的现象。为什么会出现这种现象，再找个时间来梳理清楚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2：View 的 mRenderNode 对象又是个什么东西？它的 setXXX 方法又是如何修改 View 的属性值来达到动画效果的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还有第二个遗留问题，虽然本篇梳理了 ViewPropertyAnimator 动画的流程和原理，但到最后，我们其实只知道它内部借助了 ValueAnimator 机制来计算每一帧的动画进度，然后在每一帧的回调中先获取 View 的 mRenderNode 对象，再调用相应的 setXXX 方法来修改属性值达到动画效果。但这个 mRenderNode 是个什么东西，又是如何修改 view 的状态来达到动画效果的这点就还需要找个时间来梳理了。&lt;/p&gt;
&lt;p&gt;所以到最后，ViewPropertyAnimator 内部的流程和原理虽然已经清楚了，但具体要不要将这个动画归纳到属性动画中，我就不大清楚了。虽然它内部是借助了 ViewAnimator 机制，但 ValueAnimator 其实并没有任何的 ui 操作，ObjectAnimator 才会去通过反射来调用相关的 setXXX 方法来修改属性值，这个过程才是 ui 操作，最后才会有相应的动画效果呈现出来。这点还有待继续研究。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-35fed4659c556352.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;QQ图片20180316094923.jpg&quot;/&gt;&lt;br/&gt;最近（2018-03）刚开通了公众号，想激励自己坚持写作下去，初期主要分享原创的Android或Android-Tv方面的小知识，准备可能还有点不足，感兴趣的可以先点一波关注，谢谢支持~~&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 15:15:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/8647702.html</dc:identifier>
</item>
<item>
<title>微信小程序学习笔记（阶段二） - MacrazdS</title>
<link>http://www.cnblogs.com/macrazds/p/8647680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/macrazds/p/8647680.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;二阶段学习过程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（一）看官方文档的框架、组件、API：https://mp.weixin.qq.com/debug/wxadoc/dev/&lt;/p&gt;
&lt;p&gt;　　（二）看极客学院第3、4章视频：http://www.php.cn/course/297.html&lt;/p&gt;
&lt;p&gt;　　（三）模仿并写出各个demo（模板应用demo、快递查询demo、登陆界面demo）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;获取app.js的变量/方法：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;前提：在app.js中定义了变量或所需方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　①在当前页面的*.js最上面定义var app=getApp()&lt;/p&gt;
&lt;p&gt;　　②在需要调用app中变量的方法中调用即可，使用实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  btnClick:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thispage=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;console.log(&lt;span&gt;app.data.nu&lt;/span&gt;);
    &lt;span&gt;app.getExpressInfo&lt;/span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data.nu,&lt;span&gt;function&lt;/span&gt;(data){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;getExpressInfo在app.js中的定义&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里面不能用this，因为这里的this不是指当前的second页面，要在外面再定义一个var thispage=this才可&lt;/span&gt;
      &lt;span&gt;//这个被当作参数的方法用于将在app.js中getExpressInfo方法所得到的请求结果数据回传到当前页面&lt;/span&gt;&lt;br/&gt;　　　 console.log(data);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看返回结果的结构&lt;/span&gt;
&lt;span&gt;      thispage.setData({info:data.data});
      console.log(thispage.data.info);
    });
  },
  input:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
    console.log(event);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在控制台查看event的结构&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.setData({nu: event.detail.value});  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取输入的运单号&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;注：方法的参数也可以是另一个方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;wxml模板引用：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;模板的使用有两种方式：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;方法1：引入代码如下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../templates/header&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;这种方式读入模板，里面的{{text}}直接使用的是second页面的text变量，相当于直接复制过来&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;附：此处引用的模板内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{text}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;非template模板导入template模板可以生效&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;方法2：引入代码如下&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;import &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../templates/footer&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt;=&quot;footer1&quot;&lt;/span&gt;&lt;span&gt; data&lt;/span&gt;&lt;span&gt;=&quot;{{test:testMsg}}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt;=&quot;footer2&quot;&lt;/span&gt;&lt;span&gt; data&lt;/span&gt;&lt;span&gt;=&quot;{{test:testMsg}}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;附：此处引用的模板内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;footer1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
!! this is footer1 (testMsg: {{test}}) !!
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;template模板导入template模板不会生效&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;footer2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
!! this is footer2 (testMsg: {{test}}) !!
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;wxml中if和for的使用：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;wx:if：&lt;/span&gt;&lt;/strong&gt;格式如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;wx:if&lt;/span&gt;&lt;span&gt;=&quot;{{show}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ifText}} show&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;wx:else&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ifText}} no-show&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　即当前页面中变量show的值为true时，显示变量ifText的内容+&quot;show&quot;；否则显示变量ifText的内容+&quot;no-show&quot;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;wx:for：&lt;/span&gt;&lt;/strong&gt;格式如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;-----------wx:for的使用1
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;wx:for&lt;/span&gt;&lt;span&gt;=&quot;{{forText}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  {{index}}-{{item}}
  &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;index当前表循环计数值i item为默认的forText[i]的替代变量名&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

-----------wx:for的使用2
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;wx:for&lt;/span&gt;&lt;span&gt;=&quot;{{forText}}&quot;&lt;/span&gt;&lt;span&gt; wx:for-item&lt;/span&gt;&lt;span&gt;=&quot;demoItem&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  {{index}}-{{demoItem}}
  &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;wx:for-item=&quot;demoItem&quot;用于更改forText[i]的替代变量名&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　循环次数为forText的元素个数次，大概类似foreach的用法&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;窗口跳转（导航）方法：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;①wx.redirectTo：&lt;/span&gt;&lt;/strong&gt;这个方法会将当前页面关闭，不会保留在后台中，无法直接返回。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;②wx.navigateTo：&lt;/span&gt;&lt;/strong&gt;这个方法会保留当前页面在后台。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;③wx.switchTab：&lt;/span&gt;&lt;/strong&gt;这个方法用于跳转到有tabBar的页面，并关闭所有非tabBar页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（注：使用wx.redirectTo从原页面（含tabBar）跳转到当前页面后，不要用wx.switchTab跳转回上一页面，否则会出现渲染错误！这种情况下应该用wx.reLaunch）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;④wx.reLaunch：&lt;/span&gt;&lt;/strong&gt;这个方法会关闭当前的所有页面，并打开目标页面。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;⑤wx.navigatBack：&lt;/span&gt;&lt;/strong&gt;关闭当前页面，返回上一页面或多级页面。可通过&lt;code&gt;getCurrentPages()&lt;/code&gt;获取当前的页面栈，决定需要返回几层。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用方法：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;①在*.js中使用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wx.****({  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;****为前四种种方法之一&lt;/span&gt;
    url: &quot;../index/index&quot;&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wx.navigateBack({
  delta: n  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;n为返回层数&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;②在*.wxml中使用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;非redirect跳转&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;navigator &lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;=&quot;../index/index&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;no-redirect&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;navigator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;redirect跳转&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;navigator &lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;=&quot;../index/index&quot;&lt;/span&gt;&lt;span&gt; redirect&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;redirect&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;navigator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;给目标页面传递数据：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　在url后面添加?a=0&amp;amp;b=1即可，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
wx.****({  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;****为前四种种方法之一&lt;/span&gt;
    url: &quot;../index/index?a=0&amp;amp;b=1&quot;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示传递a=0和b=1的参数&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;从上一页面获取传来的数据：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
onload : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(&lt;span&gt;options&lt;/span&gt;){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({xx : &lt;span&gt;options.a&lt;/span&gt;, yy : &lt;span&gt;options.b&lt;/span&gt;});
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;小技巧：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当不知道数据的内容或格式的时候，可以用console.log(var);显示在控制台（Console）中，即可查看它的内容和结构，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1335312/201803/1335312-20180325222642446-2095527482.png&quot; alt=&quot;&quot; width=&quot;575&quot; height=&quot;114&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1 控制台（Console）中显示数据的结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1335312/201803/1335312-20180325222520645-313916712.png&quot; alt=&quot;&quot; width=&quot;313&quot; height=&quot;70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2 知道数据的结构后摘取其中数据的代码&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;个人感想：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;在本次阶段学习中，最主要有三个问题，实在是令人抓狂。&lt;/p&gt;
&lt;p&gt;　　一是用百度查询快递的api的时候，对照着视频的步骤，然而实际上和视频上的步骤有出入。&lt;/p&gt;
&lt;p&gt;　　二是出在写最后一个登录界面demo的过程中，由于wxss的使用不熟悉导致做页面做了很长时间。然后是因为视频上的开发工具版本和现在我使用的版本有所区别，所以窗口之间的跳转（导航）方法，又花了很长时间去解决。&lt;/p&gt;
&lt;p&gt;　　三是开发工具本身的调试界面，显示出来的页面组件和实际组件的位置不相应，一开始没发现这个问题，导致测试不了输入框输入内容的触发事件的方法。&lt;/p&gt;
&lt;p&gt;　　总结来说，这三个问题耗费了我大量的时间，计划也被延迟了。从此吸取教训：一，视频上的步骤和实际操作并不一定是一致的，很有可能当时和现在由于版本问题或其他资源的更新导致问题的出现；二、开发工具的功能并不值得完全信任。通过这一次血的教训，如果下次遇到这种问题，大概就不会浪费这么多事件了。&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 15:12:00 +0000</pubDate>
<dc:creator>MacrazdS</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/macrazds/p/8647680.html</dc:identifier>
</item>
<item>
<title>django初探-创建简单的博客系统(一) - 小兵千睿</title>
<link>http://www.cnblogs.com/xiaobingqianrui/p/8644112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobingqianrui/p/8644112.html</guid>
<description>&lt;h2&gt;1. django安装&lt;/h2&gt;
&lt;p&gt;　　pip install django&lt;/p&gt;
&lt;p&gt;　　print(django.get_version()) 查看django版本&lt;/p&gt;
&lt;h2&gt;2. 创建项目&lt;/h2&gt;
&lt;p&gt;　　打开cmd，进入指定目录&lt;/p&gt;
&lt;p&gt;　　django-admin startproject projectname或&lt;/p&gt;
&lt;p&gt;　　django-admin startproject projectname .     #最后是空格加点&lt;/p&gt;
&lt;p&gt;　　二者会在文件目录上存在差别&lt;/p&gt;
&lt;h2&gt;3. 创建应用&lt;/h2&gt;
&lt;p&gt;　　进入project目录&lt;/p&gt;
&lt;p&gt;　　django-admin startapp appname或&lt;/p&gt;
&lt;p&gt;　　python manage.py startapp appname&lt;/p&gt;
&lt;p&gt;　　二者虽方式不同，但效果一样&lt;/p&gt;
&lt;p&gt;　　manage.py文件在项目创建后会被自动生成在项目的根目录下，它是对django-admin.py的简单封装，所以效果一样&lt;/p&gt;
&lt;h2&gt;4. 启动服务&lt;/h2&gt;
&lt;p&gt;　　python manage.py runserver&lt;/p&gt;
&lt;h2&gt;5. 测试&lt;/h2&gt;
&lt;p&gt;　　在浏览器中输入http://localhost:8000或http://127.0.0.1:8000&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1117865/201803/1117865-20180325132006846-1305198036.png&quot; alt=&quot;&quot; width=&quot;416&quot; height=&quot;163&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　windows平台下使用tree/f命令查看详细的文件结构&lt;/p&gt;
&lt;p&gt;　　下图创建xbqr项目和blog应用后的文件结构：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1117865/201803/1117865-20180325133141572-1211094621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;xbqr文件夹&lt;/h2&gt;
&lt;p&gt;　　1. settings.py:这个文件包含了项目的初始化设置，可以针对整个项目进行相关参数配置，比如配置数据库，添加应用。&lt;/p&gt;
&lt;p&gt;　　　　重点关注以下几项：&lt;/p&gt;
&lt;p&gt;　　　　（1）DEBUG:&lt;/p&gt;
&lt;p&gt;　　　　　　# SECURITY WARNING: don't run with debug turned on in production!&lt;br/&gt;　　　　　　DEBUG = True&lt;/p&gt;
&lt;p&gt;　　　　（2）ALLOWED_HOST&lt;/p&gt;
&lt;p&gt;　　　　　　在DEBUG为true时，其值可以为空，当部署到生产环境中时，要把主域名添加在这里，&lt;/p&gt;
&lt;p&gt;　　　　　　才能通过域名访问到本网站&lt;/p&gt;
&lt;p&gt;　　　　（3）INSTALLED_APPS&lt;/p&gt;
&lt;p&gt;　　　　　　 这是一个非常重要的配置，所有的应用都被添加在这里&lt;/p&gt;
&lt;p&gt;　　　　（4）DATEBASES&lt;/p&gt;
&lt;p&gt;　　　　　　 配置数据库，django支持多种数据库，MySQL、PosttgreSQL、Oracle等，默认的配置是SQLite&lt;/p&gt;
&lt;p&gt;　　　　（5）LANGUAGE_CODE&lt;/p&gt;
&lt;p&gt;　　　　　　设置项目语言，一般情况下不用修改，若非用汉字，则设置为‘zh-hans’&lt;/p&gt;
&lt;p&gt;　　　　（6）TIME_ZONE&lt;/p&gt;
&lt;p&gt;　　　　　　设置时区，通常为东八区，设置为‘Asia/Shanghai’&lt;/p&gt;
&lt;p&gt;　　2. urls.py&lt;/p&gt;
&lt;p&gt;　　　　URL配置表文件，根据用户输入的url将URL映射到应用程序上&lt;/p&gt;
&lt;p&gt;　　3. wsgi.py&lt;/p&gt;
&lt;p&gt;　　　　WSGI是python所选择的服务器和应用标准，Django也会使用&lt;/p&gt;
&lt;h2&gt;blog文件夹&lt;/h2&gt;
&lt;p&gt;　　1. admin.py&lt;/p&gt;
&lt;p&gt;　　　　在这个文件中可以自定义Django的管理工具，比如设置在管理界面能够管理的项目，&lt;/p&gt;
&lt;p&gt;　　　　或者通过自定义与系统有关的类对象，向管理功能添加新的内容&lt;/p&gt;
&lt;p&gt;　　2. apps.py&lt;/p&gt;
&lt;p&gt;　　　　包含对应用的配置，为管理功能提供一个合适的应用名称&lt;/p&gt;
&lt;p&gt;　　3. migrations&lt;/p&gt;
&lt;p&gt;　　　　这是一个目录，用于存储应用的数据库表结构的指令，通过这些指令可以修改和创建数据库，从而在models.py模型类和数据库之间迁移&lt;/p&gt;
&lt;p&gt;　　4. models.py&lt;/p&gt;
&lt;p&gt;　　　　应用的数据模型&lt;/p&gt;
&lt;p&gt;　　5. tests.py&lt;/p&gt;
&lt;p&gt;　　　　编写测试文档来测试所建立的应用&lt;/p&gt;
&lt;p&gt;　　6. views.py&lt;/p&gt;
&lt;p&gt;　　　　用户保存响应各种请求的函数和类&lt;/p&gt;

&lt;h2&gt;1. 编写数据模型类&lt;/h2&gt;
&lt;p&gt;　　修改blog/modells.py文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create your models here.&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; django.contrib.auth.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; User
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.utils &lt;span&gt;import&lt;/span&gt;&lt;span&gt; timezone
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; BlogArticles(&lt;strong&gt;models.Model&lt;/strong&gt;): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;注意基类&lt;/span&gt;
    &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        标题，内容，作者，发布时间
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    title &lt;/span&gt;= &lt;strong&gt;models.CharField&lt;/strong&gt;(max_length=300&lt;span&gt;)
    content &lt;/span&gt;=&lt;span&gt;&lt;strong&gt; models.TextField&lt;/strong&gt;()
    author &lt;/span&gt;= &lt;strong&gt;models.ForeignKey&lt;/strong&gt;(User, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unknow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, related_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blog_posts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    publish &lt;/span&gt;= &lt;strong&gt;models.DateTimeField&lt;/strong&gt;(default=&lt;span&gt;timezone.now)

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        ordering &lt;/span&gt;= (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-publish&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; str(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.title
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. 根据数据模型建立数据库表&lt;/h2&gt;
&lt;p&gt;　　在/xbqr/manage.py执行python manage.py makemigrations&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1117865/201803/1117865-20180325212858960-1410106777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样会在D:\Pystu\xbqr\blog\migrations目录下生成&lt;strong&gt;0001_initial.py&lt;/strong&gt;文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;&lt;img id=&quot;code_img_closed_316183b5-996c-45d0-95ad-e1dcad5a79c4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_316183b5-996c-45d0-95ad-e1dcad5a79c4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_316183b5-996c-45d0-95ad-e1dcad5a79c4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Generated by Django 2.0.3 on 2018-03-25 06:47&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.conf &lt;span&gt;import&lt;/span&gt;&lt;span&gt; settings
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; migrations, models
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; django.utils.timezone


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Migration(migrations.Migration):

    initial &lt;/span&gt;=&lt;span&gt; True

    dependencies &lt;/span&gt;=&lt;span&gt; [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations &lt;/span&gt;=&lt;span&gt; [
        migrations.CreateModel(
            name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BlogArticles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            fields&lt;/span&gt;=&lt;span&gt;[
                (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
                (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, models.CharField(max_length=300&lt;span&gt;)),
                (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, models.TextField()),
                (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publish&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, models.DateTimeField(default=&lt;span&gt;django.utils.timezone.now)),
                (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, models.ForeignKey(on_delete=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;unknow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, related_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blog_posts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, to=&lt;span&gt;settings.AUTH_USER_MODEL)),
            ],
            options&lt;/span&gt;=&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ordering&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-publish&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,),
            },
        ),
    ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　如果对上述代码的含义不是很清楚，可以用python manage.py sqlmigrate blog 0001查看&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1117865/201803/1117865-20180325213612631-234547544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3. 创建数据库　　&lt;/h2&gt;
&lt;p&gt;　　上面创建了一个能够建立数据库表的文件，下面在此基础上真正创建数据库&lt;/p&gt;
&lt;p&gt;　　python manage.py migrate&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1117865/201803/1117865-20180325214301976-243204856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以查看db.sqlite3数据库文件&lt;/p&gt;
&lt;p&gt;　　如何查看可以参考博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/xiaobingqianrui/p/8461707.html&quot;&gt;Python之sqlite3&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;4. 发布博客文章&lt;/h2&gt;
&lt;p&gt;　　先用最简单的方式实现博客文章的发布，使用django默认的管理功能就可以发布文章，要使用此功能，必须先创建超级管理员&lt;/p&gt;
&lt;p&gt;　　python manage.py createsuperuser&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1117865/201803/1117865-20180325215049052-384035109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在服务器运行的情况下&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1117865/201803/1117865-20180325215650590-56323575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开浏览器输入http://127.0.0.1:8000/admin进入网页&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1117865/201803/1117865-20180325215828669-1036744767.png&quot; alt=&quot;&quot; width=&quot;401&quot; height=&quot;176&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　&lt;/strong&gt;登录后会看到Groups和Users两项，却找不到发布文章的地方&lt;/p&gt;
&lt;p&gt;　　找到/blog/admin/py文件,添加代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from django.contrib &lt;span&gt;import&lt;span&gt; admin

&lt;span&gt;from .models &lt;span&gt;import&lt;span&gt; BlogArticles
&lt;span&gt;#&lt;span&gt; Register your models here.
admin.site.register(BlogArticles)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这下我们就看到发布博客的地方&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1117865/201803/1117865-20180325221343296-470602380.png&quot; alt=&quot;&quot; width=&quot;475&quot; height=&quot;247&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击add，添加博客&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　下篇博客继续讲解如何显示博客文章标题和文章内容！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 25 Mar 2018 14:37:00 +0000</pubDate>
<dc:creator>小兵千睿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaobingqianrui/p/8644112.html</dc:identifier>
</item>
<item>
<title>走进webpack（1）--环境拆分及模块化 - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8647377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8647377.html</guid>
<description>&lt;p&gt;　　初级的文章和demo已经基本完成了，代码也已经上传到了我的&lt;a href=&quot;https://github.com/ZakingQ/structure-demo/tree/master/webpackPrimaryDemo&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;上，如果你对webpack的使用并不是十分了解，那么建议你回头看下&lt;a href=&quot;http://www.cnblogs.com/zaking/&quot; target=&quot;_blank&quot;&gt;走近系列&lt;/a&gt;，里面包括了当前项目中使用频繁的插件，loader的讲解。以及基本的webpack配置，相关依赖等。如果你已经有了一定的webpack使用经验。那么你直接看这篇文章也是完全没问题的。&lt;/p&gt;
&lt;p&gt;　　这一系列会着重讲解webpack的进阶使用方法，前面文章讲解过的一些部分，就不会再去重复的解释。&lt;/p&gt;
&lt;p&gt;　　那么，还是先交代一下环境以及目录结构，这些你可以直接从github上获取到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201803/1184971-20180325212119028-1006709791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面是当前的环境配置版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201803/1184971-20180325212241760-1409273882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在实际的工作当中，我们会区分不同的环境来执行不同的webpack配置代码，以实现不同环境的要求，当前的主要环境其实就两个，一个开发环境，一个生产环境。开发环境更倾向于便捷的调试，开发的方便，比如热加载等。而生产环境希望代码的体积更小，http请求更少，页面的加载速度更快。甚至有些时候两个环境的要求是互斥的。所以才需要根据不同的环境来配置不同的代码。&lt;/p&gt;
&lt;p&gt;　　废话不多说，咱们直接进入正题吧。&lt;/p&gt;

&lt;p&gt;　　在前面的文章中，为了使静态资源找到正确的路径，我们设置了一个变量webpath，那么如果要区分环境，变量的值肯定是不同的，那么我们如何根据命令来使webpath获得不同的值呢，其实很简单：&lt;/p&gt;
&lt;p&gt;　　修改一下package.json中的build命令和dev命令，加上一个参数，然后我们在webpack.config.js中可以通过process.env来获取到这个参数。这样就可以区分不同的环境了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&quot;scripts&quot;&lt;span&gt;: {
  &lt;/span&gt;&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;build&quot;: &quot;set type=build&amp;amp;webpack --mode production&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;dev&quot;: &quot;set type=dev&amp;amp;webpack-dev-server --mode development&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;version&quot;: &quot;webpack -v&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么修改完package.json中的命令后，我们还需要修改一下webpack.config.js中webpath那段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;根据参数的不同来区分不同的环境&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(process.env.type == &quot;build&quot;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webpath=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;这个地址目前是随便写的，只是为了区别于开发环境，真实上线的话要改成你上线的地址&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        publicPath:&lt;/span&gt;&quot;http://www.zaking.com/&quot;&lt;span&gt;
    }
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webpath=&lt;span&gt;{
        publicPath:&lt;/span&gt;&quot;http://192.168.199.124:9090/&quot;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样就可以了，运行不同的命令来试试效果如何吧。这里简单说明一下，process.env是什么，process是node的一个全局环境变量，process.env.type也就是你设置在scripts命令中的type值。更详细的内容不在这里多说，有强迫症的小伙伴可以去看看这里：&lt;a href=&quot;https://nodejs.org/dist/latest-v8.x/docs/api/process.html#process_process_env&quot; target=&quot;_blank&quot;&gt;https://nodejs.org/dist/latest-v8.x/docs/api/process.html#process_process_env&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　那么环境拆分说完了，如何模块化配置webpack呢？其实也很简单，听起来比较高逼格罢了。简单说就是把通用变量放在一个单独的js文件中，然后通过export暴露接口，require引入接口而已！比如你在使用vue中一定写过很多这种东西，再简单也要说一下滴。&lt;/p&gt;
&lt;p&gt;　　我们新建一个与webpack.config.js同级的文件夹，名字就叫做entry.js（入口）。然后我们在entry.js中写入入口配置的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const entry =&lt;span&gt;{};  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明路径属性&lt;/span&gt;
entry.path=&lt;span&gt;{
    main:&lt;/span&gt;'./src/main.js'&lt;span&gt;  
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出该变量&lt;/span&gt;
module.exports = entry;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后在webpack.config.js中引入该模块，并且修改下入口处的配置代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;在这里引入entry文件的路径&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
const entry &lt;/span&gt;=  require(&quot;./entry.js&quot;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;入口文件&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
entry:entry.path&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样就实现了所谓的模块化，当然这里只是举一个简单的例子，复杂的配置项目可能会有逻辑复杂的模块化配置。比如vue-cli那样的，现在你再去看看vue-cli的代码，应该也可以看懂一些了，只是它的功能更为复杂，模块的关联更强。那么这篇文章就暂时写到这里。下一篇会带大家一起看看如何打包第三方类库等更贴近生活的实用技能。本篇文章的代码也已经同步更新到&lt;a href=&quot;https://github.com/ZakingQ/structure-demo/tree/master/webpackSeniorDemo&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;上了，以后随着文章的更新会实时同步代码，方便大家学习。&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 14:26:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8647377.html</dc:identifier>
</item>
</channel>
</rss>