<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java配置context.xml文件 - Mr.right少年</title>
<link>http://www.cnblogs.com/shaonian404/p/8433811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shaonian404/p/8433811.html</guid>
<description>&lt;p&gt;&lt;strong&gt;2018-02-08   23:32:23&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修改context.xml文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;自从学习了&lt;span&gt;servlet后，每次修改里面的内容后，想要访问都要重启服务器，这样感觉很麻烦的，所以今天就教大家一个方法，只需要一行代码就解决“&lt;strong&gt;&lt;span&gt;无需重新启动服务器&lt;/span&gt;&lt;/strong&gt;”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请看下面的图示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1173558/201802/1173558-20180208232009060-967568509.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1173558/201802/1173558-20180208232213716-1337086266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在第&lt;span&gt;&lt;strong&gt;19行&lt;/strong&gt;&lt;/span&gt;代码处&lt;strong&gt;&lt;span&gt;&amp;lt;Context&amp;gt;&lt;/span&gt;&lt;/strong&gt;里面写上&lt;span&gt;reloadable=&quot;true&quot;&lt;/span&gt;,然后进行保存。    reloadable=&quot;true&quot;意思是&lt;strong&gt;&lt;span&gt;重新加载（自动刷新）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样就可以实现无论修改什么都&lt;strong&gt;&lt;span&gt;不需要重新启动服务器&lt;/span&gt;&lt;/strong&gt;，就可以直接访问了。&lt;/p&gt;
&lt;p&gt;是不是很简单又实用，喜欢的关注下，谢谢支持！！！&lt;/p&gt;

</description>
<pubDate>Thu, 08 Feb 2018 15:34:00 +0000</pubDate>
<dc:creator>Mr.right少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shaonian404/p/8433811.html</dc:identifier>
</item>
<item>
<title>cdh版本的hive安装以及配置 - 小宁哥</title>
<link>http://www.cnblogs.com/xningge/p/8433792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xningge/p/8433792.html</guid>
<description>&lt;p&gt;hive依赖hadoop&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要的软件包：hive-0.13.1-cdh5.3.6.tar.gz 、hadoop-2.5.0-cdh5.3.6.tar.gz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、hadoop的安装步骤请访问：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　http://www.cnblogs.com/xningge/articles/8433297.html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、将hive软件包上传到Linux系统指定的目录：/opt/softwares/cdh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、解压hive-0.13.1-cdh5.3.6.tar.gz到指定的目录：/opt/modules/cdh/&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;tar -zxvf hive-0.13.1-cdh5.3.6.tar.gz -C /opt/modules/cdh/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、重命名hive-env.sh (去掉.template)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HADOOP_HOME=/opt/modules/cdh/hadoop-2.5.0-cdh5.3.6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export HIVE_CONF_DIR=/opt/modules/cdh/hive-0.13.1-cdh5.3.6/conf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、重命名hive-site.xml (去掉.template，修改为site)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;property&amp;gt;&lt;br/&gt;　　&amp;lt;name&amp;gt;javax.jdo.option.ConnectionURL&amp;lt;/name&amp;gt;&lt;br/&gt;　　&amp;lt;value&amp;gt;jdbc:mysql://&lt;span&gt;&lt;strong&gt;hadoop01.xningge.com&lt;/strong&gt;&lt;/span&gt;:3306/&lt;strong&gt;&lt;span&gt;cdhmetastore&lt;/span&gt;&lt;/strong&gt;?createDatabaseIfNotExist=true&amp;lt;/value&amp;gt;&lt;br/&gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;property&amp;gt;&lt;br/&gt;　　&amp;lt;name&amp;gt;javax.jdo.option.ConnectionDriverName&amp;lt;/name&amp;gt;&lt;br/&gt;　　&amp;lt;value&amp;gt;com.mysql.jdbc.Driver&amp;lt;/value&amp;gt;&lt;br/&gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;property&amp;gt;&lt;br/&gt;　　&amp;lt;name&amp;gt;javax.jdo.option.ConnectionUserName&amp;lt;/name&amp;gt;&lt;br/&gt;　　&amp;lt;value&amp;gt;&lt;strong&gt;&lt;span&gt;xningge&lt;/span&gt;&lt;/strong&gt;&amp;lt;/value&amp;gt;&lt;br/&gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&amp;lt;property&amp;gt;&lt;br/&gt;　　&amp;lt;name&amp;gt;javax.jdo.option.ConnectionPassword&amp;lt;/name&amp;gt;&lt;br/&gt;　　&amp;lt;value&amp;gt;&lt;strong&gt;&lt;span&gt;???&lt;/span&gt;&lt;/strong&gt;&amp;lt;/value&amp;gt;&lt;br/&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;**注意：模板文件有一个bug，在hive-site.xml的2781行少了一个&amp;lt;property&amp;gt;开始标记&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、重命名hive-log4j.properties (去掉.template)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$ mkdir logs&lt;/span&gt;&lt;br/&gt;** 修改hive-log4j.properties&lt;br/&gt;&lt;span&gt;hive.log.dir=/opt/modules/cdh/hive-0.13.1-cdh5.3.6/logs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7、拷贝jdbc driver&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　** 将驱动文件复制到lib/&lt;br/&gt;　　&lt;span&gt;$ cp /opt/software/mysql-connector-java-5.1.27-bin.jar lib/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、切换到CDH Hadoop目录，建立目录，并修改权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　** /user/hive/warehouse为Hive存放数据的目录&lt;br/&gt;&lt;span&gt;　　$ bin/hdfs dfs -mkdir -p /user/hive/warehouse&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　$ bin/hdfs dfs -chmod g+w /user/hive/warehouse&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　$ bin/hdfs dfs -chmod g+w /tmp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9、启动客户端使用Hive&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　eg:把profile里HIVE_HOME注解掉(如果有配置这个全局变量的话，则注释)&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;$ bin/hive&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　hive&amp;gt; show databases;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Feb 2018 15:29:00 +0000</pubDate>
<dc:creator>小宁哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xningge/p/8433792.html</dc:identifier>
</item>
<item>
<title>python可用ORM之Pony - 我走的很慢</title>
<link>http://www.cnblogs.com/liao-lin/p/8433785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liao-lin/p/8433785.html</guid>
<description>&lt;p&gt;Pony是Python的一种ORM，它允许使用生成器表达式来构造查询，通过将生成器表达式的抽象语法树解析成SQL语句。它也有在线ER图编辑器可以帮助你创建Model。&lt;/p&gt;
&lt;p&gt;示例分析&lt;/p&gt;
&lt;p&gt;Pony语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select(p for p in Person if p.age &amp;gt; 20)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;翻译成sql语句就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT p.id, p.name, p.age, p.classtype, p.mentor, p.gpa, p.degree

FROM person p

WHERE p.classtype IN ('Student', 'Professor', 'Person')

AND p.age &amp;gt; 20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Pony语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select(c for c in Customer
         if sum(c.orders.price) &amp;gt; 1000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;翻译成sql语句就是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT &quot;c&quot;.&quot;id&quot;
FROM &quot;Customer&quot; &quot;c&quot;
  LEFT JOIN &quot;Order&quot; &quot;order-1&quot;
    ON &quot;c&quot;.&quot;id&quot; = &quot;order-1&quot;.&quot;customer&quot;
GROUP BY &quot;c&quot;.&quot;id&quot;
HAVING coalesce(SUM(&quot;order-1&quot;.&quot;total_price&quot;), 0) &amp;gt; 1000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装Pony&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install pony&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Pony&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
#-*- coding:utf-8 -*-

import datetime
import pony.orm as pny
import sqlite3

# conn = sqlite3.connect('D:\日常python学习PY2\Pony学习\music.sqlite')
# print conn

# database = pny.Database()
# database.bind(&quot;sqlite&quot;,&quot;music.sqlite&quot;,create_db=True)

# 路径建议写绝对路径。我这边开始写相对路径报错 unable to open database file
database = pny.Database(&quot;sqlite&quot;,&quot;D:\日常python学习PY2\Pony学习\music.sqlite&quot;,create_db=True)

########################################################################
class Artist(database.Entity):
    &quot;&quot;&quot;
    Pony ORM model of the Artist table
    &quot;&quot;&quot;
    name = pny.Required(unicode)
    #被外键关联
    albums = pny.Set(&quot;Album&quot;)

########################################################################
class Album(database.Entity):
    &quot;&quot;&quot;
    Pony ORM model of album table
    &quot;&quot;&quot;
    #外键字段artlist,外键关联表Artist，Artist表必须写Set表示被外键关联
    #这个外键字段默认就是index=True,除非自己指定index=False才不会创建索引，索引名默认为[idx_表名__字段](artist)
    artist = pny.Required(Artist)
    title = pny.Required(unicode)
    release_date = pny.Required(datetime.date)
    publisher = pny.Required(unicode)
    media_type = pny.Required(unicode)

# turn on debug mode
pny.sql_debug(True)      # 显示debug信息(sql语句)

# map the models to the database
# and create the tables, if they don't exist
database.generate_mapping(create_tables=True)       # 如果数据库表没有创建表&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后生成sqlite如下:&lt;/p&gt;
&lt;p&gt;上述代码对应的sqlite语句是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET CONNECTION FROM THE LOCAL POOL
PRAGMA foreign_keys = false
BEGIN IMMEDIATE TRANSACTION
CREATE TABLE &quot;Artist&quot; (
  &quot;id&quot; INTEGER PRIMARY KEY AUTOINCREMENT,
  &quot;name&quot; TEXT NOT NULL
)
 
CREATE TABLE &quot;Album&quot; (
  &quot;id&quot; INTEGER PRIMARY KEY AUTOINCREMENT,
  &quot;artist&quot; INTEGER NOT NULL REFERENCES &quot;Artist&quot; (&quot;id&quot;),
  &quot;title&quot; TEXT NOT NULL,
  &quot;release_date&quot; DATE NOT NULL,
  &quot;publisher&quot; TEXT NOT NULL,
  &quot;media_type&quot; TEXT NOT NULL
)
 
CREATE INDEX &quot;idx_album__artist&quot; ON &quot;Album&quot; (&quot;artist&quot;)
 
SELECT &quot;Album&quot;.&quot;id&quot;, &quot;Album&quot;.&quot;artist&quot;, &quot;Album&quot;.&quot;title&quot;, &quot;Album&quot;.&quot;release_date&quot;, &quot;Album&quot;.&quot;publisher&quot;, &quot;Album&quot;.&quot;media_type&quot;
FROM &quot;Album&quot; &quot;Album&quot;
WHERE 0 = 1
 
SELECT &quot;Artist&quot;.&quot;id&quot;, &quot;Artist&quot;.&quot;name&quot;
FROM &quot;Artist&quot; &quot;Artist&quot;
WHERE 0 = 1
 
COMMIT
PRAGMA foreign_keys = true
CLOSE CONNECTION&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入/增加数据&lt;/p&gt;
&lt;p&gt;详情见：&lt;a href=&quot;https://github.com/flowpig/daily_demos&quot; class=&quot;uri&quot;&gt;https://github.com/flowpig/daily_demos&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
#-*- coding:utf-8 -*-

import datetime
import pony.orm as pny
from models import Album, Artist
from database import PonyDatabase


# ----------------------------------------------------------------------
@pny.db_session
def add_data():
    &quot;&quot;&quot;&quot;&quot;&quot;

    new_artist = Artist(name=u&quot;Newsboys&quot;)
    bands = [u&quot;MXPX&quot;, u&quot;Kutless&quot;, u&quot;Thousand Foot Krutch&quot;]
    for band in bands:
        artist = Artist(name=band)

    album = Album(artist=new_artist,
                  title=u&quot;Read All About It&quot;,
                  release_date=datetime.date(1988, 12, 01),
                  publisher=u&quot;Refuge&quot;,
                  media_type=u&quot;CD&quot;)

    albums = [{&quot;artist&quot;: new_artist,
               &quot;title&quot;: &quot;Hell is for Wimps&quot;,
               &quot;release_date&quot;: datetime.date(1990, 07, 31),
               &quot;publisher&quot;: &quot;Sparrow&quot;,
               &quot;media_type&quot;: &quot;CD&quot;
               },
              {&quot;artist&quot;: new_artist,
               &quot;title&quot;: &quot;Love Liberty Disco&quot;,
               &quot;release_date&quot;: datetime.date(1999, 11, 16),
               &quot;publisher&quot;: &quot;Sparrow&quot;,
               &quot;media_type&quot;: &quot;CD&quot;
               },
              {&quot;artist&quot;: new_artist,
               &quot;title&quot;: &quot;Thrive&quot;,
               &quot;release_date&quot;: datetime.date(2002, 03, 26),
               &quot;publisher&quot;: &quot;Sparrow&quot;,
               &quot;media_type&quot;: &quot;CD&quot;}
              ]

    for album in albums:
        a = Album(**album)


if __name__ == &quot;__main__&quot;:
    db = PonyDatabase()
    db.bind(&quot;sqlite&quot;, &quot;D:\日常python学习PY2\Pony学习\music.sqlite&quot;, create_db=True)
    db.generate_mapping(create_tables=True)


    add_data()

    # use db_session as a context manager
    with pny.db_session:
        a = Artist(name=&quot;Skillet&quot;)


'''
您会注意到我们需要使用一个装饰器db_session来处理数据库。 
它负责打开连接，提交数据并关闭连接。 你也可以把它作为一个上
下文管理器，with pny.db_session
'''&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
#-*- coding:utf-8 -*-

import pony.orm as pny

from models import Artist, Album
from database import PonyDatabase

db = PonyDatabase()
db.bind(&quot;sqlite&quot;, &quot;D:\日常python学习PY2\Pony学习\music.sqlite&quot;, create_db=True)
db.generate_mapping(create_tables=True)


with pny.db_session:
    band = Artist.get(name=&quot;Newsboys&quot;)
    print band.name

    for record in band.albums:
        print record.title

    # update a record
    band_name = Artist.get(name=&quot;Kutless&quot;)
    band_name.name = &quot;Beach Boys&quot;
    
    #使用生成器形式查询
    '''
    result = pny.select(i.name for i in Artist)
    result.show()
    
    结果：
    i.name              
    --------------------
    Newsboys            
    MXPX                
    Beach Boys          
    Thousand Foot Krutch
    Skillet             

    '''&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除记录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import pony.orm as pny
 
from models import Artist
 
with pny.db_session:
    band = Artist.get(name=&quot;MXPX&quot;)
    band.delete()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Pony补充&lt;/p&gt;
&lt;p&gt;可以连接的数据库：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;##postgres

db.bind('postgres', user='', password='', host='', database='')

##sqlite         create_db:如果数据库不存在创建数据库文件

db.bind('sqlite', 'filename', create_db=True)

##mysql

db.bind('mysql', host='', user='', passwd='', db='')

##Oracle

db.bind('oracle', 'user/password@dsn')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Entity(实体)类似mvc里面的model&lt;/p&gt;
&lt;p&gt;在创建实体实例之前，需要将实体映射到数据库表，生成映射后，可以通过实体查询数据库并创建新的实例。db.Entity自己定义新的实体必须从db.Entity继承&lt;/p&gt;
&lt;p&gt;属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Customer(db.Entity):
    name = Required(str)
    picture = Optional(buffer)

sql_debug(True)  # 显示debug信息(sql语句)
db.generate_mapping(create_tables=True)  # 如果数据库表没有创建表&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Required&lt;/li&gt;
&lt;li&gt;Optional&lt;/li&gt;
&lt;li&gt;PrimaryKey&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Required and Optional&lt;/p&gt;
&lt;p&gt;通常实体属性分为Required(必选)和Optional(可选)&lt;/p&gt;
&lt;p&gt;PrimaryKey(主键)&lt;/p&gt;
&lt;p&gt;默认每个实体都有一个主键，默认添加了id=PrimaryKey(int,auto=True)属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Product(db.Entity):
    name = Required(str, unique=True)
    price = Required(Decimal)
    description = Optional(str)
    
#等价于下面

class Product(db.Entity):
    id = PrimaryKey(int, auto=True)
    name = Required(str, unique=True)
    price = Required(Decimal)
    description = Optional(str)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Set&lt;/p&gt;
&lt;p&gt;定义了一对一，一对多，多对多等数据结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 一对一
class User(db.Entity):
    name = Required(str)
    cart = Optional(&quot;Cart&quot;) #必须Optional-Required or Optional-Optional

class Cart(db.Entity):
    user = Required(&quot;User&quot;)
    
# 多对多
class Student(db.Entity):
    name = pny.Required(str)
    courses = pny.Set(&quot;Course&quot;)

class Course(db.Entity):
    name = pny.Required(str)
    semester = pny.Required(int)
    students = pny.Set(Student)
    pny.PrimaryKey(name, semester)      #联合主键

pny.sql_debug(True)      # 显示debug信息(sql语句)
db.generate_mapping(create_tables=True)     # 如果数据库表没有创建表
#-------------------------------------------------------
#一对多
class Artist(database.Entity):
    &quot;&quot;&quot;
    Pony ORM model of the Artist table
    &quot;&quot;&quot;
    name = pny.Required(unicode)
    #被外键关联
    albums = pny.Set(&quot;Album&quot;)

class Album(database.Entity):
    &quot;&quot;&quot;
    Pony ORM model of album table
    &quot;&quot;&quot;
    #外键字段artlist,外键关联表Artist，Artist表必须写Set表示被外键关联
    #这个外键字段默认就是index=True,除非自己指定index=False才不会创建索引，索引名默认为[idx_表名__字段](artist)
    artist = pny.Required(Artist)       #外键字段(数据库显示artist)
    title = pny.Required(unicode)
    release_date = pny.Required(datetime.date)
    publisher = pny.Required(unicode)
    media_type = pny.Required(unicode)

# Compositeindexes(复合索引)
class Example1(db.Entity):
    a = Required(str)
    b = Optional(int)
    composite_index(a, b)
    #也可以使用字符串composite_index(a, 'b')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性数据类型&lt;/p&gt;
&lt;p&gt;格式为 ：&lt;/p&gt;
&lt;p&gt;属性名 = 属性类型(数据类型)&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li&gt;str&lt;/li&gt;
&lt;li&gt;unicode&lt;/li&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;float&lt;/li&gt;
&lt;li&gt;Decimal&lt;/li&gt;
&lt;li&gt;datetime&lt;/li&gt;
&lt;li&gt;date&lt;/li&gt;
&lt;li&gt;time&lt;/li&gt;
&lt;li&gt;timedelta&lt;/li&gt;
&lt;li&gt;bool&lt;/li&gt;
&lt;li&gt;buffer ---used for binary data in Python 2 and 3&lt;/li&gt;
&lt;li&gt;bytes ---used for binary data in Python 3&lt;/li&gt;
&lt;li&gt;LongStr ---used for large strings&lt;/li&gt;
&lt;li&gt;LongUnicode ---used for large strings&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;UUID&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;attr1 = Required(str)
# 等价
attr2 = Required(unicode)

attr3 = Required(LongStr)
# 等价
attr4 = Required(LongUnicode)

attr1 = Required(buffer) # Python 2 and 3

attr2 = Required(bytes) # Python 3 only

#字符串长度,不写默认为255
name = Required(str,40)     #VARCHAR(40)

#整数的大小，默认32bit
attr1 = Required(int, size=8)   # 8 bit - TINYINT in MySQL
attr2 = Required(int, size=16)  # 16 bit - SMALLINT in MySQL
attr3 = Required(int, size=24)  # 24 bit - MEDIUMINT in MySQL
attr4 = Required(int, size=32)  # 32 bit - INTEGER in MySQL
attr5 = Required(int, size=64)  # 64 bit - BIGINT in MySQL

#无符号整型
attr1 = Required(int, size=8, unsigned=True) # TINYINT UNSIGNED in MySQL

# 小数和精度
price = Required(Decimal, 10, 2)        #DECIMAL(10,2)

# 时间
dt = Required(datetime,6)

# 其它参数
unique   是否唯一
auto    是否自增
default     默认值
sql_default 
created_at = Required(datetime, sql_default=’CURRENT_TIMESTAMP’)
index   创建索引
index='index_name'  指定索引名称
lazy    延迟加载的属性加载对象
cascade_delete      关联删除对象
column      映射到数据库的列名
columns Set(多对多列名)
table   多对多中间表的表名字
nullable    允许该列为空
py_check    可以指定一个函数，检查数据是否合法和修改数据

class Student(db.Entity): 
    name = Required(str) 
    gpa = Required(float, py_check=lambda val: val &amp;gt;= 0 and val &amp;lt;= 5)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实例操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 获取实例

p = Person.get(name=&quot;Person&quot;)   #返回单个实例，如同
Django ORM的get
#------------------------------
# 查询
persons = Person.select()
'''
select并没有连接数据库查询，只是返回一个Query object，调用persons[:]返回所有Person实例
'''

# limit
persons [1:5]

# show
persons.show()

# 生成器表达式查询，然后解析AST树的方式构造SQL语句

select(p for p in Person) 
#和Person.select()一样返回Query object

select((p.id, p.name) for p in Person)[:]

# 带where条件查询
select((p.id, p.name) for p in Person if p.age ==20)[:]

# 分组聚合查询
select((max(p.age)) for p in Person)[:] #[25]

max(p.age for p in Person) #25

select(p.age for p in Person).max() #25
#-----------------------------
# 修改实例
@db_session
def update_persons():
  p = Person.get(id=2)
  p.page = 1000
  commit()
  
# 删除
@db_session
def delete_persons():
    p = Person.get(id=2)
    p.delete()
    commit()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pony使用还可以使用游标操作(这样就可以写原生sql语句了)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;result = db.execute('''select name from Artist''')
print result.fetchall()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似Django ORM的save函数&lt;/p&gt;
&lt;p&gt;before_insert()&lt;/p&gt;
&lt;p&gt;Is called only for newly created objects before it is inserted into the database.&lt;/p&gt;
&lt;p&gt;before_update()&lt;/p&gt;
&lt;p&gt;Is called for entity instances before updating the instance in the database.&lt;/p&gt;
&lt;p&gt;before_delete()&lt;/p&gt;
&lt;p&gt;Is called before deletion the entity instance in the database.&lt;/p&gt;
&lt;p&gt;after_insert()&lt;/p&gt;
&lt;p&gt;Is called after the row is inserted into the database.&lt;/p&gt;
&lt;p&gt;after_update()&lt;/p&gt;
&lt;p&gt;Is called after the instance updated in the database.&lt;/p&gt;
&lt;p&gt;after_delete()&lt;/p&gt;
&lt;p&gt;Is called after the entity instance is deleted in the database.&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Message(db.Entity):
    title = Required(str)
    content = Required(str)

    def before_insert(self):
        print(&quot;Before insert! title=%s&quot; % self.title)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;http://www.blog.pythonlibrary.org/2014/07/21/python-101-an-intro-to-pony-orm/&quot; class=&quot;uri&quot;&gt;http://www.blog.pythonlibrary.org/2014/07/21/python-101-an-intro-to-pony-orm/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Feb 2018 15:27:00 +0000</pubDate>
<dc:creator>我走的很慢</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liao-lin/p/8433785.html</dc:identifier>
</item>
<item>
<title>小白如何运行Faster RCNN的tensorflow代码 - ToOnE</title>
<link>http://www.cnblogs.com/toone/p/8433581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toone/p/8433581.html</guid>
<description>&lt;p&gt;　　刚刚学习faster rcnn目标检测算法，在尝试跑通github上面Xinlei Chen的tensorflow版本的faster rcnn代码时候遇到很多问题（我真是太菜），代码地址如下：&lt;/p&gt;
&lt;p&gt;https://github.com/endernewton/tf-faster-rcnn&lt;/p&gt;

&lt;p&gt;　　代码的README里面说明了，环境要求既有是这个git里面的，还有就是rbg的caffe代码中也有了一些环境。基本上包括：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python2.7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CUDA（并行计算库）&amp;gt;=6.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cudnn（深度学习库）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;cython&lt;/code&gt;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;opencv-pyt&lt;/code&gt;&lt;span&gt;&lt;code&gt;hon&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;easydict=1.6&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当然这只是跑通代码的环境，并没有那么苛刻的。&lt;/p&gt;
&lt;h2&gt;1.1 检查环境&lt;/h2&gt;
&lt;p&gt;　　检查环境的目的是为了安装TensorFlow，首先是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1.1 Linux 内核和发行版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　需要查看 linux内核和发行版，来确定后续一些软件的安装版本选择。《如何查看LINUX发行版的名称及其版本号》：https://www.qiancheng.me/post/coding/show-linux-issue-version&lt;/p&gt;
&lt;p&gt;　　查看Linux内核&lt;/p&gt;

&lt;p&gt;　　查看Linux发行版&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
cat /etc/redhat-release #centos下面的命令
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/737444/201802/737444-20180208164841716-1978396645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我用的是 centos，在运行demo期间没发现什么问题，但最好是用Ubutu 14或者16吧&lt;/p&gt;

&lt;h3&gt;1.1.2 检查cuda 和cudnn的版本&lt;/h3&gt;
&lt;p&gt;chen 推荐的是 TensorFlow 的 r1.2 版本，应该是安装r1.2推荐的cuda和cudnn，但是因为我没有服务器的root权限，无法更改cuda和cudnn，所以只能选择一个和本机环境相对应的tensorflow版本了。&lt;/p&gt;
&lt;p&gt;注意这里如果不安装匹配的版本，可能会出现cudnn库找不到的情况，（别问我怎么知道的），https://stackoverflow.com/questions/42013316/after-building-tensorflow-from-source-seeing-libcudart-so-and-libcudnn-errors，如果有root权限的，最好是装r1.2版本的，当然要查好r1.2支持的cuda和cudnn，方法也在下面。&lt;/p&gt;
&lt;p&gt;查看cuda的版本：http://blog.csdn.net/zhangjunhit/article/details/76532196&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
cat /usr/local/cuda/version.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看cudnn版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/737444/201802/737444-20180208165517388-1854114946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我的cuda=8，cudnn=6&lt;/p&gt;
&lt;p&gt;　　到tensorflow 的官网上查对应的TF版本：https://www.tensorflow.org/install/install_sources#common_installation_problems&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/737444/201802/737444-20180208165651670-1487329580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果没有GPU的就安装cpu版本，README里面说cpu也是能运行的，我没试。&lt;/p&gt;
&lt;h2&gt;1.2 安装Anaconda 和TensorFlow&lt;/h2&gt;
&lt;p&gt;　　tensorflow r1.4的安装教程：https://www.tensorflow.org/versions/r1.4/install/install_linux?hl=zh-cn，我是按照Anaconda的方法弄的，比较简单。&lt;/p&gt;
&lt;p&gt;　　因为我的系统上面安装了anaconda，之前装了python3。为了方便，直接用anaconda新开了一个环境，装了python2.7。教程：https://www.jianshu.com/p/d2e15200ee9b&lt;/p&gt;
&lt;p&gt;　　创建环境：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
conda create -n tensorflow python=2.7
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　进入环境：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
source activate tensorflow 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/737444/201802/737444-20180208165253545-1667418273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　前面这样显示就对了（我的名字叫python27，你的应该是tensorflow）&lt;/p&gt;
&lt;p&gt;　　使用pip安装tensorflow：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;pip install --ignore-installed --upgrade&lt;/strong&gt; &lt;em&gt;tfBinaryURL&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意这里的 &lt;em&gt;tfBinaryURL 是 &lt;a href=&quot;https://www.tensorflow.org/versions/r1.4/install/install_linux?hl=zh-cn#the_url_of_the_tensorflow_python_package&quot;&gt;URL of the TensorFlow Python package&lt;/a&gt; &lt;/em&gt;，但这里面都是谷歌的镜像，要是没挂科学上网的话应该是访问不到的，我是用的阿里的镜像：http://mirrors.aliyun.com/pypi/simple，自己找合适的版本，我用的是http://mirrors.aliyun.com/pypi/packages/68/b4/8731e144a68a6044b8eba47f51f0a862c696b0c016c8512ca2aa3916f62a/tensorflow_gpu-1.4.0rc1-cp27-cp27mu-manylinux1_x86_64.whl。&lt;/p&gt;
&lt;p&gt;　　更多镜像在：https://www.jianshu.com/p/502638407add&lt;/p&gt;
&lt;p&gt;　　输入上面的命令之后就成功了，运行了一下官方的测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/737444/201802/737444-20180208222725513-1178234338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　成功输出：Hello，TensorFlow！&lt;/p&gt;
&lt;h2&gt;1.3 安装其他依赖&lt;/h2&gt;
&lt;p&gt;　　保持在tensorflow这个环境中，继续用pip安装&lt;code&gt;cython&lt;/code&gt;, &lt;code&gt;opencv-python&lt;/code&gt;, &lt;code&gt;easydict这三个库。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
pip install cython
pip install opencv-python
pip install easydict==1.6
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/737444/201802/737444-20180208171336795-838178540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　链接cython模块的时候出现了一个警告，具体什么原因我也不太清楚，就暂时没有管它，最后也是能运行demo的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
cc1plus: 警告：command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++ [默认启用]
In file included from /home/luoguiyang/env/anaconda3/envs/python27/lib/python2.7/site-packages/numpy/core/include/numpy/ndarraytypes.h:1816:0,
                 from /home/luoguiyang/env/anaconda3/envs/python27/lib/python2.7/site-packages/numpy/core/include/numpy/ndarrayobject.h:18,
                 from /home/luoguiyang/env/anaconda3/envs/python27/lib/python2.7/site-packages/numpy/core/include/numpy/arrayobject.h:4,
                 from nms/gpu_nms.cpp:346:
/home/luoguiyang/env/anaconda3/envs/python27/lib/python2.7/site-packages/numpy/core/include/numpy/npy_1_7_deprecated_api.h:15:2: 警告：#warning &quot;Using deprecated NumPy API, disable it by &quot; &quot;#defining NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION&quot; [-Wcpp]
 #warning &quot;Using deprecated NumPy API, disable it by &quot; \
  ^
g++ -pthread -shared -L/home/luoguiyang/env/anaconda3/envs/python27/lib -Wl,-rpath=/home/luoguiyang/env/anaconda3/envs/python27/lib,--no-as-needed build/temp.linux-x86_64-2.7/nms/nms_kernel.o build/temp.linux-x86_64-2.7/nms/gpu_nms.o -L/usr/local/cuda/lib64 -L/home/luoguiyang/env/anaconda3/envs/python27/lib -Wl,-R/usr/local/cuda/lib64 -lcudart -lpython2.7 -o /home/luoguiyang/projects/3dcnn/branch/tf-faster-rcnn/lib/nms/gpu_nms.so
rm -rf build
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 　　到这一步，按照README里面的提示一步一步走就应该没问题了（如果在本地测试的话）。&lt;/p&gt;
&lt;p&gt;　　1、clone github的仓库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
git clone https://github.com/endernewton/tf-faster-rcnn.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、更新GPU的架构配置，到setup.py中找到 -arch 这个参数，改成自己的GPU架构就行了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
cd tf-faster-rcnn/lib
# Change the GPU architecture (-arch) if necessary
vim setup.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对应的配置如右图，github里面可能会对一些其他的显卡更新参数。　&lt;img src=&quot;https://images2017.cnblogs.com/blog/737444/201802/737444-20180208223549716-1178912485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、链接cython 模块，注意这也是在上一步那个lib 文件夹中进行的&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
make clean
make
cd ..
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、安装 Python COCO API，这是为了使用COCO数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
cd data
git clone https://github.com/pdollar/coco.git
cd coco/PythonAPI
make
cd ../../..
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　1、下载预训练模型&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# Resnet101 for voc pre-trained on 07+12 set
./data/scripts/fetch_faster_rcnn_models.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　README里面也说了，下载链接可能会失效，sh文件里面给了一个备用链接也是不管用的，但是readme里面还给了备份的Google Drive的地址，我把其中的要用的模型 voc_0712_80k-110k.tgz 这个文件手动下载了（百度云备份：https://pan.baidu.com/s/1kWkF3fT），下载之后放到 data文件夹中就行，（但是md5sum校验值对不上，估计是下载地址不一样的问题，也暂时忽略吧），运行以下命令解压：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
tar xvf voc_0712_80k-110k.tgz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、建立预训练模型的软连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
NET=res101
TRAIN_IMDB=voc_2007_trainval+voc_2012_trainval
mkdir -p output/${NET}/${TRAIN_IMDB}
cd output/${NET}/${TRAIN_IMDB}
ln -s ../../../data/voc_2007_trainval+voc_2012_trainval ./default
cd ../../..
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、运行以下代码就能测试demo了，主义是在tf-faster-rcnn 这个根文件夹中运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# at repository root
GPU_ID=0
CUDA_VISIBLE_DEVICES=${GPU_ID} ./tools/demo.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里还有一个问题，demo里面一个文件 import matlibplot.pyplot ，这时候如果是用终端连接的服务器的话，可能会出现DISPLAY 变量未设置这个bug，echo $DISPLAY 命令这时候肯定是什么不显示的。错误如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;64&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Demo for data/demo/000456.jpg
Detection took 1.316s for 300 object proposals
Traceback (most recent call last):
  File &quot;./tools/demo.py&quot;, line 153, in &amp;lt;module&amp;gt;
    demo(sess, net, im_name)
  File &quot;./tools/demo.py&quot;, line 100, in demo
    vis_detections(im, cls, dets, thresh=CONF_THRESH)
  File &quot;./tools/demo.py&quot;, line 50, in vis_detections
    fig, ax = plt.subplots(figsize=(12, 12))
  File &quot;/home/luoguiyang/env/anaconda3/envs/python27/lib/python2.7/site-packages/matplotlib/pyplot.py&quot;, line 1177, in subplots
    fig = figure(**fig_kw)
  File &quot;/home/luoguiyang/env/anaconda3/envs/python27/lib/python2.7/site-packages/matplotlib/pyplot.py&quot;, line 527, in figure
    **kwargs)
  File &quot;/home/luoguiyang/env/anaconda3/envs/python27/lib/python2.7/site-packages/matplotlib/backends/backend_qt4agg.py&quot;, line 46, in new_figure_manager
    return new_figure_manager_given_figure(num, thisFig)
  File &quot;/home/luoguiyang/env/anaconda3/envs/python27/lib/python2.7/site-packages/matplotlib/backends/backend_qt4agg.py&quot;, line 53, in new_figure_manager_given_figure
    canvas = FigureCanvasQTAgg(figure)
  File &quot;/home/luoguiyang/env/anaconda3/envs/python27/lib/python2.7/site-packages/matplotlib/backends/backend_qt4agg.py&quot;, line 76, in __init__
    FigureCanvasQT.__init__(self, figure)
  File &quot;/home/luoguiyang/env/anaconda3/envs/python27/lib/python2.7/site-packages/matplotlib/backends/backend_qt4.py&quot;, line 68, in __init__
    _create_qApp()
  File &quot;/home/luoguiyang/env/anaconda3/envs/python27/lib/python2.7/site-packages/matplotlib/backends/backend_qt5.py&quot;, line 138, in _create_qApp
    raise RuntimeError('Invalid DISPLAY variable')
&lt;span&gt;RuntimeError: Invalid DISPLAY variable
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是因为matplotlib 输出的图像没有输出出来，有两种方法：&lt;/p&gt;
&lt;p&gt;　　解决方法（1）设置X11转发，具体方法Google一下，因为我的服务器没有配置Xauth，我也没有root权限，所以对我不适用了&lt;/p&gt;
&lt;p&gt;　　解决方法（2）改代码，不要让图像show了，而是把图像保存起来。错误里面可以看出引入matplotlib 的是 ./tools/demo.py 这个文件，教程：http://rootlu.com/blog/2017/10/08/MatplotlibInLinux.html/&lt;/p&gt;
&lt;p&gt;　　　　更改了两处&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/737444/201802/737444-20180208225522170-1844950870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/737444/201802/737444-20180208225503029-98879402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　改完之后，图片就保存在 tf-faster-rcnn 这里了，下载下来是这样的（没仔细改代码，只保存了一幅）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/737444/201802/737444-20180208225733482-466871475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　基础的demo就可以运行了。后面调试的部分研究明白了再补上。&lt;/p&gt;

</description>
<pubDate>Thu, 08 Feb 2018 14:59:00 +0000</pubDate>
<dc:creator>ToOnE</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toone/p/8433581.html</dc:identifier>
</item>
<item>
<title>通俗化理解Spring3 IoC的原理和主要组件（spring系列知识二总结） - 思维焦点</title>
<link>http://www.cnblogs.com/xiezhidong/p/6476960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiezhidong/p/6476960.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;♣什么是IoC?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;♣通俗化理解IoC原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;♣IoC好处&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;♣工厂模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;♣IoC的主要组件&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;♣IoC的应用实例&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;♣附：实例代码&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.什么是IoC（控制反转）?&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring3框架的核心是实现&lt;span&gt;控制反转（IoC）&lt;/span&gt;模式&lt;/span&gt;&lt;span&gt;，IoC又叫做&lt;span&gt;依赖注入（DI）。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是控制反转呢？答案就是“获得依赖对象的过程被反转了”，获得依赖对象的过程&lt;span&gt;由自身管理对象&lt;/span&gt;变为&lt;span&gt;由IoC容器主动注入，&lt;span&gt;于是控制反转又叫做依赖注入。那么“控制反转”完全就是“依赖注入”咯？其实，我们可以将“控制反转”理解为名词，将“依赖注入”理解为动词，所以“依赖注入”用来实现“控制反转”的一种方法、手段。依赖注入就是&lt;span&gt;由IoC容器在运行期间，动态地将某种依赖关系注入到对象之中，&lt;span&gt;最终实现对象之间的解耦&lt;/span&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通俗形象地理解依赖注入的过程：举&lt;span&gt;计算机（对象A）,usb设备（对象B）,人（IoC容器）&lt;/span&gt;的例子。如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;利用计算机（对象A）和usb接口实现：计算机（对象A）从usb设备中读取文件的任务。特点:1.计算机（对象A）不用关心连接的外部设备是什么，比如是u盘还是移动硬盘，计算机（对象A）只能被动接受；2.usb设备（对象B）只要符合usb的标准就ok了；3.当计算机（对象A）需要外部usb设备的时候，不用说出来，人（IoC容器）会自动帮它挂上。这就是usb设备（对象B）在系统运行时被注入到计算机（对象A）的过程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1036228/201703/1036228-20170302215235110-1694952288.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由此可见，对象A依赖于对象B,当对象A需要用到对象B的时候，IoC容器就会立即创建一个对象B给对象A。&lt;span&gt;IoC容器就是一个对象制造工厂&lt;/span&gt;，你需要什么，给你制造好然后送给你，你什么都不用管，包括对象是如何生成和销毁的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.&lt;strong&gt;通俗化理解IoC原理&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 上面已经介绍了什么是控制反转，现在再进一步啰嗦一下。控制反转的原理就是：&lt;span&gt;由容器来控制程序之间的关系&lt;/span&gt;（以前是有程序代码直接操控，即在一个类中调用另外一个类，也就是要用到某个类的时候才手动用代码new 一个这个类的对象出来），&lt;span&gt;“反转”的意思就是“控制权”的转移&lt;/span&gt;，控制权由应用代码中转到外部容器。&lt;/p&gt;
&lt;p&gt;  下面举个通俗的&lt;span&gt;齿轮例&lt;/span&gt;子来说明为什么要使用IoC容器来控制程序之间的关系（如果不懂什么是“解耦”，看了这个例子你就明白了）：&lt;/p&gt;
&lt;p&gt;  1.从下面的图可以看出，相互啮合的A、B、C、D四个齿轮组成一个齿轮组，用来完成某项任务。但是，如果有一个齿轮出了问题，就很有可能影响整个齿轮组的正常运转。&lt;/p&gt;
&lt;p&gt;    我们可以&lt;span&gt;把齿轮组中的齿轮之间的关系，类比为软件系统中对象之间的耦合关系&lt;/span&gt;。对象之间的耦合是无法避免的，因为这是协同合作的基础。但随着软件的规模越来越来，比如一些工业级的软件，那么对象之间的依赖关系也会相当复杂，经常会出现对象之间的多重依赖性关系。耦合度过高，结果就会导致“牵一发而动全身”的情形。所以，为了实现对象之间的“解耦”，提出了IoC理论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1036228/201703/1036228-20170302221230641-431633827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   2.引入IoC容器，充当“黏合剂”的作用，使得A、B、C、D四个齿轮(对象)没有了解耦关系，这样程序员就能够更好地分工开发各个模块了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1036228/201703/1036228-20170302222117360-1635382008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt;IoC好处&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt; 这里还是继续使用计算机和u盘的例子来简单说明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt; &lt;span&gt;1.方便解耦，简化开发&lt;/span&gt;：计算机和u盘之间没有相关性，无论哪个出现问题都不会影响另一方。而且，因为这两种组件之间的无耦合，所以生成计算机的厂商和生成u盘的厂商可以不同。这样的话就能够更好的分工开发了。&lt;/p&gt;
&lt;p&gt; &lt;span&gt; 2.易于测试&lt;/span&gt;：因为计算机和u盘之间的无关性，所以非常便于单元测试，分开调试和诊断。这符合spring一直贯彻的“好的设计优于具体实现，代码应易于测试”的理念。&lt;/p&gt;
&lt;p&gt; 4&lt;strong&gt;.&lt;/strong&gt;工厂模式&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt; 工厂模式，顾名思义就是社会工业化带来的产品生产分工。这里的工厂指的是专门生产对象的地方，也就是声明一个类作为工厂（工厂类）用来生成其他类的实例对象。&lt;/p&gt;
&lt;p&gt;  举个例子：A组件需要B组件的协助时，不用A组件自己去实例化B组件，而是通过生产B组件的工厂（beanFactory）获取。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/1036228/201703/1036228-20170303132425641-353022975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  下面用一个&lt;span&gt;factoryexample的例子&lt;/span&gt;来体会下：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2015.cnblogs.com/blog/1036228/201703/1036228-20170303190433126-396042881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 接口person类的代码：Person.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package factoryexample;

public interface Person {
    void eat();//定义抽象的吃方法
    void drink();//定义抽象的喝方法
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 实现接口类的代码：&lt;/p&gt;
&lt;p&gt; Chinese类：Chinese.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package factoryexample;

public class Chinese implements Person{
    public void eat()
    {
        System.out.println(&quot;中国人喜欢吃中餐！&quot;);
    }
    public void drink()
    {
        System.out.println(&quot;中国人喜欢喝开水！&quot;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　American类：American.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package factoryexample;

public class American implements Person{
    public void eat()
    {
        System.out.println(&quot;美国人喜欢吃西餐！&quot;);
    }
    public void drink()
    {
        System.out.println(&quot;美国人喜欢喝咖啡！&quot;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　工厂类：Factory.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package factoryexample;

public class Factory {
    public Person getPerson(String name)
    {
        if(name.equals(&quot;中国人&quot;))
            return new Chinese();
        else if(name.equals(&quot;美国人&quot;))
           return new American(); 
        else
            throw new IllegalArgumentException(&quot;参数不正确！&quot;);        
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　测试类：Test.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package factoryexample;

public class Test {
    public static void main(String[] args) {
        Person person=null;
        person=new Factory().getPerson(&quot;中国人&quot;);
        person.eat();
        person.drink();
        person=new Factory().getPerson(&quot;美国人&quot;);
        person.eat();
        person.drink();    
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/1036228/201703/1036228-20170303191435298-1897363363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　&lt;img src=&quot;https://images2015.cnblogs.com/blog/1036228/201703/1036228-20170303191439501-870606095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  上面的factoryexample这个例子是用一个factory类来做对象创建的工作，在spring IoC中，我们就使用IoC容器来完成对象的创建，具体代码看iocexample这个例子，iocexample例子的代码在文章最后的附件资源里。&lt;/p&gt;
&lt;p&gt; 5&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;IoC的主要组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt;Spring3框架的两个最基本和最重要的包：&lt;/p&gt;
&lt;p&gt;  1.org.springframework.beans.factory包（该包的主要接口是BeanFactory）&lt;/p&gt;
&lt;p&gt;  2.org.springframework.context包（该包的主要接口是ApplicationFactory）&lt;/p&gt;

&lt;p&gt;  SpringIoC框架&lt;span&gt;主要组件&lt;/span&gt;如下：&lt;/p&gt;
&lt;p&gt;  (1).Beans&lt;/p&gt;
&lt;p&gt;  (2).配置文件（beans.xml或applicationContext.xml）&lt;/p&gt;
&lt;p&gt;  (3).BeanFactory接口及其相关类&lt;/p&gt;
&lt;p&gt;  (4).ApplicationContext接口及其相关类&lt;/p&gt;

&lt;p&gt;  使用&lt;span&gt;iocexample2例子&lt;/span&gt;来理解 SpringIoC框架四个主要组件：&lt;/p&gt;
&lt;p&gt;  (1).Beans&lt;/p&gt;
&lt;p&gt;   Beans是指项目中提供业务的Bean,及&lt;span&gt;容器要管理的Bean&lt;/span&gt;,如上面介绍的Chinese.java和American.java就是javaBean 。 Bean可以包含一些属性以及属性对应的getter和setter方法，也可以包含其他方法。&lt;/p&gt;
&lt;p&gt;  (2).配置文件（beans.xml或applicationContext.xml）&lt;/p&gt;
&lt;p&gt;  Spirng3&lt;span&gt;通过配置文件来管理Bean&lt;/span&gt;,编辑配置文件这个动作又叫做“装配bean”,装配bean实际就是告诉容器需要哪些bean，以及容器如何使用IoC将它们配置起来。&lt;/p&gt;
&lt;p&gt;  配置文件包含：Bean的id、类、属性及其值； 一个&amp;lt;beans&amp;gt;元素和数个&amp;lt;bean&amp;gt;子元素。&lt;/p&gt;
&lt;p&gt;  Spring IoC框架根据Bean的id从Bean配置文件中取得该Bean的类，并生成该类的一个对象，继而从配置文件中获取该对象的属性和值。&lt;/p&gt;
&lt;p&gt;  下面是iocexample2例子的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1036228/201703/1036228-20170303224700220-517835419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  下面是iocexample2例子的配置文件（applicationContext.xml）：下面的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN 2.0//EN&quot; &quot;http://www.springframework.org/dtd/spring-beans-2.0.dtd&quot; [
&amp;lt;!ENTITY contextInclude SYSTEM &quot;org/springframework/web/context/WEB-INF/contextInclude.xml&quot;&amp;gt;
]&amp;gt;

&amp;lt;beans&amp;gt;
    &amp;lt;!--配置Bean，注入Chinese类对象--&amp;gt;
    &amp;lt;bean id=&quot;中国人&quot; class=&quot;iocexample2.Chinese&quot;&amp;gt;
        &amp;lt;!--property元素用来指定需要容器注入的属性；name元素的指定属性值language；
        ref元素指定需要向language属性注入的id，即注入的对象“英语”，该对象为Englis类生成--&amp;gt;
        &amp;lt;property name=&quot;language&quot; ref=&quot;英语&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--注入English--&amp;gt;
    &amp;lt;bean id=&quot;英语&quot; class=&quot;iocexample2.English&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　iocexample2例子的运行结果：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2015.cnblogs.com/blog/1036228/201703/1036228-20170303204948501-1761200895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;  (3).BeanFactory接口及其相关类&lt;/p&gt;
&lt;p&gt;  (4).ApplicationContext接口及其相关类&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注：spring3的最后的两个主要组件就先放到下篇再讲。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;spring系列目录：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/xiezhidong/p/6476960.html%20&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;通俗化理解Spring3 IoC的原理和主要组件（知识二总结）&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring3 IoC主要组件详解（知识三总结）&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Feb 2018 14:23:00 +0000</pubDate>
<dc:creator>思维焦点</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiezhidong/p/6476960.html</dc:identifier>
</item>
<item>
<title>Android+TensorFlow+CNN+MNIST 手写数字识别实现 - SkySeraph</title>
<link>http://www.cnblogs.com/skyseraph/p/8057734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyseraph/p/8057734.html</guid>
<description>&lt;p&gt;SkySeraph 2018&lt;/p&gt;
&lt;p&gt;Email：&lt;a href=&quot;mailto:skyseraph00@163.com&quot;&gt;skyseraph00#163.com&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;更多精彩请直接访问&lt;a href=&quot;http://www.skyseraph.com/&quot; target=&quot;_blank&quot;&gt;SkySeraph个人站点&lt;/a&gt;：&lt;a href=&quot;http://www.skyseraph.com/&quot;&gt;www.skyseraph.com&lt;/a&gt; &lt;/h3&gt;

&lt;p&gt;本文系“&lt;a href=&quot;http://skyseraph.com&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;SkySeraph AI 实践到理论系列&lt;/strong&gt;&lt;/a&gt;”第一篇，咱以AI界的HelloWord 经典MNIST数据集为基础，在Android平台，基于TensorFlow，实现CNN的手写数字识别。&lt;br/&gt;&lt;a href=&quot;https://github.com/skyseraph/AI_P2T&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;Code here~&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;Environment&quot;&gt;Environment&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;TensorFlow： 1.2.0&lt;/li&gt;
&lt;li&gt;Python： 3.6&lt;/li&gt;
&lt;li&gt;Python IDE： PyCharm 2017.2&lt;/li&gt;
&lt;li&gt;Android IDE： Android Studio 3.0&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;Train-amp-Evaluate（Python-TensorFlow）&quot;&gt;Train &amp;amp; Evaluate（Python+TensorFlow）&lt;/h2&gt;
&lt;p&gt;训练和评估部分主要目的是生成用于测试用的pb文件，其保存了利用TensorFlow python API构建训练后的网络拓扑结构和参数信息，实现方式有很多种，除了cnn外还可以使用rnn，fcnn等。&lt;br/&gt;其中基于cnn的函数也有两套，分别为tf.layers.conv2d和tf.nn.conv2d， tf.layers.conv2d使用tf.nn.conv2d作为后端处理，参数上filters是整数，filter是4维张量。原型如下：&lt;br/&gt;convolutional.py文件&lt;br/&gt;def conv2d(inputs, filters, kernel_size, strides=(1, 1), padding=’valid’, data_format=’channels_last’,&lt;br/&gt;dilation_rate=(1, 1), activation=None, use_bias=True, kernel_initializer=None,&lt;br/&gt;bias_initializer=init_ops.zeros_initializer(), kernel_regularizer=None, bias_regularizer=None,&lt;br/&gt;activity_regularizer=None, kernel_constraint=None, bias_constraint=None, trainable=True, name=None,&lt;br/&gt;reuse=None)&lt;/p&gt;
&lt;p&gt;gen_nn_ops.py 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def conv2d(input, filter, strides, padding, use_cudnn_on_gpu=True, data_format=&quot;NHWC&quot;, name=None)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;官方Demo实例中使用的是layers module，结构如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Convolutional Layer #1：32个5×5的filter，使用ReLU激活函数&lt;/li&gt;
&lt;li&gt;Pooling Layer #1：2×2的filter做max pooling，步长为2&lt;/li&gt;
&lt;li&gt;Convolutional Layer #2：64个5×5的filter，使用ReLU激活函数&lt;/li&gt;
&lt;li&gt;Pooling Layer #2：2×2的filter做max pooling，步长为2&lt;/li&gt;
&lt;li&gt;Dense Layer #1：1024个神经元，使用ReLU激活函数，dropout率0.4 (为了避免过拟合，在训练的时候，40%的神经元会被随机去掉)&lt;/li&gt;
&lt;li&gt;Dense Layer #2 (Logits Layer)：10个神经元，每个神经元对应一个类别（0-9）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;核心代码在cnn_model_fn(features, labels, mode)函数中，完成卷积结构的完整定义，核心代码如下.&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid02.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以采用传统的tf.nn.conv2d函数, 核心代码如下。&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid03.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;Test（Android-TensorFlow）&quot;&gt;Test（Android+TensorFlow）&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;核心是使用API接口： TensorFlowInferenceInterface.java&lt;/li&gt;
&lt;li&gt;配置gradle 或者 自编译TensorFlow源码导入jar和so&lt;br/&gt;compile ‘org.tensorflow:tensorflow-android:1.2.0’&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;导入pb文件.pb文件放assets目录，然后读取&lt;/p&gt;
&lt;p&gt;String actualFilename = labelFilename.split(“file:///android_asset/“)[1];&lt;br/&gt;Log.i(TAG, “Reading labels from: “ + actualFilename);&lt;br/&gt;BufferedReader br = null;&lt;br/&gt;br = new BufferedReader(new InputStreamReader(assetManager.open(actualFilename)));&lt;br/&gt;String line;&lt;br/&gt;while ((line = br.readLine()) != null) {&lt;br/&gt;c.labels.add(line);&lt;br/&gt;}&lt;br/&gt;br.close();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TensorFlow接口使用&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid13.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;最终效果：&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid04.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid05.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;MNIST&quot;&gt;MNIST&lt;/h2&gt;
&lt;p&gt;MNIST，最经典的机器学习模型之一，包含0~9的数字，28*28大小的单色灰度手写数字图片数据库，其中共60,000 training examples和10,000 test examples。&lt;br/&gt;文件目录如下，主要包括4个二进制文件，分别为训练和测试图片及Label。&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid06.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;如下为训练图片的二进制结构，在真实数据前（pixel），有部分描述字段（魔数，图片个数，图片行数和列数），真实数据的存储采用大端规则。&lt;br/&gt;（大端规则，就是数据的高字节保存在低内存地址中，低字节保存在高内存地址中）&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid07.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;在具体实验使用，需要提取真实数据，可采用专门用于处理字节的库struct中的unpack_from方法，核心方法如下：&lt;br/&gt;struct.unpack_from(self._fourBytes2, buf, index)&lt;/p&gt;
&lt;p&gt;MNIST作为AI的Hello World入门实例数据，TensorFlow封装对其封装好了函数，可直接使用&lt;br/&gt;mnist = input_data.read_data_sets(‘MNIST’, one_hot=True)&lt;/p&gt;
&lt;h2 id=&quot;CNN（Convolutional-Neural-Network）&quot;&gt;CNN（Convolutional Neural Network）&lt;/h2&gt;
&lt;h3 id=&quot;CNN-Keys&quot;&gt;CNN Keys&lt;/h3&gt;
&lt;h3 id=&quot;CNN-Architecture&quot;&gt;CNN Architecture&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;三层神经网络。分别为输入层（Input layer）,输出层（Output layer）,隐藏层（Hidden layer），如下图所示[21]&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid10.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;CNN层级结构。 斯坦福cs231n中阐述了一种[INPUT-CONV-RELU-POOL-FC]，如下图所示[21]，分别为输入层，卷积层，激励层，池化层，全连接层。&lt;/li&gt;
&lt;li&gt;CNN通用架构分为如下三层结构：
&lt;ul&gt;&lt;li&gt;Convolutional layers 卷积层&lt;/li&gt;
&lt;li&gt;Pooling layers 汇聚层&lt;/li&gt;
&lt;li&gt;Dense (fully connected) layers 全连接层&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid12.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;动画演示。参考[22]。&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160707204048899&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;Regression-Softmax&quot;&gt;Regression + Softmax&lt;/h2&gt;
&lt;p&gt;机器学习有监督学习（supervised learning）中两大算法分别是分类算法和回归算法，分类算法用于离散型分布预测，回归算法用于连续型分布预测。&lt;br/&gt;回归的目的就是建立一个回归方程用来预测目标值，回归的求解就是求这个回归方程的回归系数。&lt;br/&gt;其中回归（Regression）算法包括Linear Regression，Logistic Regression等， Softmax Regression是其中一种用于解决多分类（multi-class classification）问题的Logistic回归算法的推广，经典实例就是在MNIST手写数字分类上的应用。&lt;/p&gt;
&lt;h3 id=&quot;Linear-Regression&quot;&gt;Linear Regression&lt;/h3&gt;
&lt;p&gt;Linear Regression是机器学习中最基础的模型，其目标是用预测结果尽可能地拟合目标label&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多元线性回归模型定义&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid16.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;多元线性回归求解&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid17.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Mean Square Error (MSE)
&lt;ul&gt;&lt;li&gt;Gradient Descent（梯度下降法）&lt;/li&gt;
&lt;li&gt;Normal Equation（普通最小二乘法）&lt;/li&gt;
&lt;li&gt;局部加权线性回归（LocallyWeightedLinearRegression, LWLR )：针对线性回归中模型欠拟合现象，在估计中引入一些偏差以便降低预测的均方误差。&lt;/li&gt;
&lt;li&gt;岭回归（ridge regression)和缩减方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选择： Normal Equation相比Gradient Descent，计算量大（需计算X的转置与逆矩阵），只适用于特征个数小于100000时使用；当特征数量大于100000时使用梯度法。当X不可逆时可替代方法为岭回归算法。LWLR方法增加了计算量，因为它对每个点做预测时都必须使用整个数据集，而不是计算出回归系数得到回归方程后代入计算即可，一般不选择。&lt;/li&gt;
&lt;li&gt;调优： 平衡预测偏差和模型方差（高偏差就是欠拟合，高方差就是过拟合）
&lt;ul&gt;&lt;li&gt;获取更多的训练样本 - 解决高方差&lt;/li&gt;
&lt;li&gt;尝试使用更少的特征的集合 - 解决高方差&lt;/li&gt;
&lt;li&gt;尝试获得其他特征 - 解决高偏差&lt;/li&gt;
&lt;li&gt;尝试添加多项组合特征 - 解决高偏差&lt;/li&gt;
&lt;li&gt;尝试减小 λ - 解决高偏差&lt;/li&gt;
&lt;li&gt;尝试增加 λ -解决高方差&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;Softmax-Regression&quot;&gt;Softmax Regression&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Softmax Regression估值函数（hypothesis）&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid18.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Softmax Regression代价函数（cost function）&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid19.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;理解：&lt;br/&gt;&lt;img src=&quot;http://p30lospbv.bkt.clouddn.com/AIHandwritingAndroid20.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Softmax Regression &amp;amp; Logistic Regression：
&lt;ul&gt;&lt;li&gt;多分类 &amp;amp; 二分类。Logistic Regression为K=2时的Softmax Regression&lt;/li&gt;
&lt;li&gt;针对K类问题，当类别之间互斥时可采用Softmax Regression，当非斥时，可采用K个独立的Logistic Regression&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;总结： Softmax Regression适用于类别数量大于2的分类，本例中用于判断每张图属于每个数字的概率。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MNIST&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Softmax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;CNN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;TensorFlow+CNN / TensorFlow+Android&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;By SkySeraph-2018&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/skyseraph/p/8057734.html&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;SkySeraph cnBlogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;本文首发于&lt;/span&gt;&lt;a href=&quot;http://skyseraph.com/&quot;&gt;skyseraph.com&lt;/a&gt;&lt;span&gt;：&lt;/span&gt;&lt;a href=&quot;http://skyseraph.com/2018/01/10/AI/AIHandwritingAndroid/&quot;&gt;“Android+TensorFlow+CNN+MNIST 手写数字识别实现”&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt; &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Feb 2018 14:15:00 +0000</pubDate>
<dc:creator>SkySeraph</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyseraph/p/8057734.html</dc:identifier>
</item>
<item>
<title>过滤器应用【编码、敏感词、压缩、转义过滤器】 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8433237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8433237.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在上篇博文中，我们已经讲解了过滤器的基本概念，使用以及简单的Servlet应用了。这篇博文主要讲解过滤器的高级应用。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目的：&lt;strong&gt;解决全站的乱码问题&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;开发过滤器&quot;&gt;开发过滤器&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(ServletRequest req, ServletResponse resp, FilterChain chain) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ServletException, IOException {

        &lt;span class=&quot;co&quot;&gt;//将request和response强转成http协议的&lt;/span&gt;
        HttpServletRequest httpServletRequest = (HttpServletRequest) req;
        HttpServletResponse httpServletResponse = (HttpServletResponse) resp;

        httpServletRequest.&lt;span class=&quot;fu&quot;&gt;setCharacterEncoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;);
        httpServletResponse.&lt;span class=&quot;fu&quot;&gt;setCharacterEncoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;);
        httpServletResponse.&lt;span class=&quot;fu&quot;&gt;setContentType&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;);
        
        chain.&lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(httpServletRequest, httpServletResponse);
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;第一次测试&quot;&gt;第一次测试&lt;/h3&gt;
&lt;p&gt;Servlet1中向浏览器回应中文数据，没有出现乱码。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doPost&lt;/span&gt;(HttpServletRequest request, HttpServletResponse response) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ServletException, IOException {

        response.&lt;span class=&quot;fu&quot;&gt;getWriter&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;看完博客点赞！&quot;&lt;/span&gt;);

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/8/161758ab304bc418?w=813&amp;amp;h=312&amp;amp;f=png&amp;amp;s=24571&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;上面的过滤器是不完善的，因为&lt;strong&gt;浏览器用get方式提交给服务器的中文数据，单单靠上面的过滤器是无法完成的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么我们需要怎么做呢？？我们之前解决get方式的乱码问题是这样的：&lt;strong&gt;使用request获取传递过来的数据，经过ISO 8859-1反编码获取得到不是乱码的数据（传到Servlet上的数据已经被ISO 8859-1编码过了，反编码就可以获取原来的数据），再用UTF-8编码，得到中文数据！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考我之前的博文：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=100000001&amp;amp;idx=6&amp;amp;sn=b0c346d7f17a097525ad106291aad28c&amp;amp;chksm=6bd740005ca0c916f72872122dff3bad8c49f9f690ea51b442b542dbbb654382bb663a01473b&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0206hvswcHK67to1b4tr46AK#rd&quot; class=&quot;uri&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=100000001&amp;amp;idx=6&amp;amp;sn=b0c346d7f17a097525ad106291aad28c&amp;amp;chksm=6bd740005ca0c916f72872122dff3bad8c49f9f690ea51b442b542dbbb654382bb663a01473b&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0206hvswcHK67to1b4tr46AK#rd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Servlet获取浏览器以GET方式提交过来的中文是乱码的根本原因是：getParameter()方法是以ISO 8859-1的编码来获取浏览器传递过来的数据的，得到的是乱码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然知道了根本原因，那也好办了：&lt;strong&gt;过滤器传递的request对象，使用getParameter()方法的时候，获取得到的是正常的中文数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是说，sun公司为我们提供的request对象是不够用的，&lt;strong&gt;因为sun公司提供的request对象使用getParameter()获取get方式提交过来的数据是乱码，于是我们要增强request对象（使得getParameter()获取得到的是中文）！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;增强request对象&quot;&gt;增强request对象&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;增强request对象，我们要使用包装设计模式！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包装设计模式的五个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;1、实现与被增强对象相同的接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2、定义一个变量记住被增强对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3、定义一个构造器，接收被增强对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4、覆盖需要增强的方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5、对于不想增强的方法，直接调用被增强对象（目标对象）的方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;sun公司也知道我们可能对request对象的方法不满意，于是提供了HttpServletRequestWrapper类给我们实现（如果实现HttpServletRequest接口的话，要实现太多的方法了！）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyRequest &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; HttpServletRequestWrapper {
    
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; HttpServletRequest request;
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyRequest&lt;/span&gt;(HttpServletRequest request) {
            &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(request);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt; = request;
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getParameter&lt;/span&gt;(String name) {
            String value = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getParameter&lt;/span&gt;(name);
    
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (value == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            }
    
            &lt;span class=&quot;co&quot;&gt;//如果不是get方法的，直接返回就行了&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getMethod&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;equalsIgnoreCase&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;get&quot;&lt;/span&gt;)) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            }
    
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
    
                &lt;span class=&quot;co&quot;&gt;//进来了就说明是get方法，把乱码的数据&lt;/span&gt;
                value = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(value.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ISO8859-1&quot;&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCharacterEncoding&lt;/span&gt;());
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; value ;
    
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (UnsupportedEncodingException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
    
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;st&quot;&gt;&quot;不支持该编码&quot;&lt;/span&gt;);
            }
    
        }
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;将被增强的request对象传递给目标资源，那么目标资源使用request调用getParameter()方法的时候，获取得到的就是中文数据，而不是乱码了！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;//将request和response强转成http协议的&lt;/span&gt;
        HttpServletRequest httpServletRequest = (HttpServletRequest) req;
        HttpServletResponse httpServletResponse = (HttpServletResponse) resp;

        httpServletRequest.&lt;span class=&quot;fu&quot;&gt;setCharacterEncoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;);
        httpServletResponse.&lt;span class=&quot;fu&quot;&gt;setCharacterEncoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;);
        httpServletResponse.&lt;span class=&quot;fu&quot;&gt;setContentType&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;);

        MyRequest myRequest = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyRequest&lt;/span&gt;(httpServletRequest);

        &lt;span class=&quot;co&quot;&gt;//传递给目标资源的request是被增强后的。&lt;/span&gt;
        chain.&lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(myRequest, httpServletResponse);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;第二次测试&quot;&gt;第二次测试&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用get方式传递中文数据给服务器&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;form&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; action=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${pageContext.request.contextPath}/Servlet1&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;get&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;hidden&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;中国&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;submit&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;提交&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/8/161758ab3063bec8?w=1236&amp;amp;h=465&amp;amp;f=gif&amp;amp;s=118801&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;如果用户输入了敏感词（傻b、尼玛、操蛋等等不文明语言时），我们要将这些不文明用于屏蔽掉，替换成符号！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要实现这样的功能也很简单，用户输入的敏感词肯定是在getParameter()获取的，我们在getParameter()得到这些数据的时候，判断有没有敏感词汇，如果有就替换掉就好了！简单来说：也是要增强request对象&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;增强request对象-1&quot;&gt;增强request对象&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyDirtyRequest &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; HttpServletRequestWrapper {
    
        HttpServletRequest request;
    
        &lt;span class=&quot;co&quot;&gt;//定义一堆敏感词汇&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; list = Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;傻b&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;尼玛&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;操蛋&quot;&lt;/span&gt;);
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyDirtyRequest&lt;/span&gt;(HttpServletRequest request) {
            &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(request);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt; = request;
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getParameter&lt;/span&gt;(String name) {
    
            String value = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getParameter&lt;/span&gt;(name);
    
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (value == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            }
    
            &lt;span class=&quot;co&quot;&gt;//遍历list集合，看看获取得到的数据有没有敏感词汇&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (String s : list) {
    
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (s.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(value)) {
                    value = &lt;span class=&quot;st&quot;&gt;&quot;*****&quot;&lt;/span&gt;;
                }
            }
    
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; value ;
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;开发过滤器-1&quot;&gt;开发过滤器&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(ServletRequest req, ServletResponse resp, FilterChain chain) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ServletException, IOException {

        &lt;span class=&quot;co&quot;&gt;//将request和response强转成http协议的&lt;/span&gt;
        HttpServletRequest httpServletRequest = (HttpServletRequest) req;
        HttpServletResponse httpServletResponse = (HttpServletResponse) resp;

        MyDirtyRequest dirtyRequest = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyDirtyRequest&lt;/span&gt;(httpServletRequest);

        &lt;span class=&quot;co&quot;&gt;//传送给目标资源的是被增强后的request对象&lt;/span&gt;
        chain.&lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(dirtyRequest, httpServletResponse);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/8/161758ab30b689b0?w=1236&amp;amp;h=465&amp;amp;f=gif&amp;amp;s=330141&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;按照过滤器的执行顺序：&lt;strong&gt;执行完目标资源，过滤器后面的代码还会执行。所以，我们在过滤器中可以获取执行完目标资源后的response对象！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们知道sun公司提供的response对象调用write()方法，是直接把数据返回给浏览器的&lt;/strong&gt;。我们要想实现压缩的功能，&lt;strong&gt;write()方法就不能直接把数据写到浏览器上！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这和上面是类似的，&lt;strong&gt;过滤器传递给目标资源的response对象就需要被我们增强，使得目标资源调用writer()方法的时候不把数据直接写到浏览器上&lt;/strong&gt;！&lt;/p&gt;
&lt;h2 id=&quot;增强response对象&quot;&gt;增强response对象&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;response对象可能会使用PrintWriter或者ServletOutputStream对象来调用writer()方法的，所以我们增强response对象的时候，需要把getOutputSteam和getWriter()重写&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    
    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyResponse &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; HttpServletResponseWrapper{
    
        HttpServletResponse response;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyResponse&lt;/span&gt;(HttpServletResponse response) {
            &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(response);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;response&lt;/span&gt; = response;
        }
    
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ServletOutputStream &lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;();
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; PrintWriter &lt;span class=&quot;fu&quot;&gt;getWriter&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getWriter&lt;/span&gt;();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，&lt;strong&gt;ServletOutputSteam要调用writer()方法，使得它不会把数据写到浏览器上。这又要我们增强一遍了！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;增强servletoutputsteam&quot;&gt;增强ServletOutputSteam&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;/*增强ServletOutputSteam，让writer方法不把数据直接返回给浏览器*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyServletOutputStream &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; ServletOutputStream{
    
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ByteArrayOutputStream byteArrayOutputStream;
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyServletOutputStream&lt;/span&gt;(ByteArrayOutputStream byteArrayOutputStream) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;byteArrayOutputStream&lt;/span&gt; = byteArrayOutputStream;
        }
    
        &lt;span class=&quot;co&quot;&gt;//当调用write()方法的时候，其实是把数据写byteArrayOutputSteam上&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; b) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;byteArrayOutputStream&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(b);
    
        }
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;增强printwriter&quot;&gt;增强PrintWriter&lt;/h3&gt;
&lt;p&gt;PrintWriter对象就好办了，它&lt;strong&gt;本来就是一个包装类，看它的构造方法，我们直接可以把ByteArrayOutputSteam传递给PrintWriter上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/8/161758ab30d8d0dc?w=840&amp;amp;h=421&amp;amp;f=png&amp;amp;s=22108&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; PrintWriter &lt;span class=&quot;fu&quot;&gt;getWriter&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        printWriter = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PrintWriter(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; OutputStreamWriter(byteArrayOutputStream, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCharacterEncoding&lt;/span&gt;()));

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; printWriter;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;获取缓存数据&quot;&gt;获取缓存数据&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;我们把数据都写在了ByteArrayOutputSteam上了，应该提供方法给外界过去缓存中的数据！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;getBuffer&lt;/span&gt;() {

        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {

            &lt;span class=&quot;co&quot;&gt;//防止数据在缓存中，要刷新一下！&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (printWriter != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                printWriter.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (byteArrayOutputStream != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                byteArrayOutputStream.&lt;span class=&quot;fu&quot;&gt;flush&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; byteArrayOutputStream.&lt;span class=&quot;fu&quot;&gt;toByteArray&lt;/span&gt;();
            }
            
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;增强response的完整代码&quot;&gt;增强response的完整代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyResponse &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; HttpServletResponseWrapper{

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ByteArrayOutputStream byteArrayOutputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayOutputStream();

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; PrintWriter printWriter ;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; HttpServletResponse response;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyResponse&lt;/span&gt;(HttpServletResponse response) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(response);
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;response&lt;/span&gt; = response;
    }


    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ServletOutputStream &lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {

        &lt;span class=&quot;co&quot;&gt;//这个的ServletOutputSteam对象调用write()方法的时候，把数据是写在byteArrayOutputSteam上的&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyServletOutputStream&lt;/span&gt;(byteArrayOutputStream);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; PrintWriter &lt;span class=&quot;fu&quot;&gt;getWriter&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        printWriter = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PrintWriter(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; OutputStreamWriter(byteArrayOutputStream, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCharacterEncoding&lt;/span&gt;()));

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; printWriter;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;getBuffer&lt;/span&gt;() {

        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {

            &lt;span class=&quot;co&quot;&gt;//防止数据在缓存中，要刷新一下！&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (printWriter != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                printWriter.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (byteArrayOutputStream != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                byteArrayOutputStream.&lt;span class=&quot;fu&quot;&gt;flush&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; byteArrayOutputStream.&lt;span class=&quot;fu&quot;&gt;toByteArray&lt;/span&gt;();
            }

        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;过滤器&quot;&gt;过滤器&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(ServletRequest req, ServletResponse resp, FilterChain chain) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ServletException, IOException {


        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;
        MyResponse myResponse = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyResponse&lt;/span&gt;(response);

        &lt;span class=&quot;co&quot;&gt;//把被增强的response对象传递进去，目标资源调用write()方法的时候就不会直接把数据写在浏览器上了&lt;/span&gt;
        chain.&lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(request, myResponse);

        &lt;span class=&quot;co&quot;&gt;//得到目标资源想要返回给浏览器的数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] bytes = myResponse.&lt;span class=&quot;fu&quot;&gt;getBuffer&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;//输出原来的大小&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;压缩前：&quot;&lt;/span&gt;+bytes.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;);

        
        &lt;span class=&quot;co&quot;&gt;//使用GZIP来压缩资源，再返回给浏览器&lt;/span&gt;
        ByteArrayOutputStream byteArrayOutputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayOutputStream();
        GZIPOutputStream gzipOutputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; GZIPOutputStream(byteArrayOutputStream);
        gzipOutputStream.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(bytes);
        
        &lt;span class=&quot;co&quot;&gt;//得到压缩后的数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] gzip = byteArrayOutputStream.&lt;span class=&quot;fu&quot;&gt;toByteArray&lt;/span&gt;();
        
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;压缩后：&quot;&lt;/span&gt; + gzip.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;);
        
        &lt;span class=&quot;co&quot;&gt;//还要设置头，告诉浏览器，这是压缩数据！&lt;/span&gt;
        response.&lt;span class=&quot;fu&quot;&gt;setHeader&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;content-encoding&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;gzip&quot;&lt;/span&gt;);
        response.&lt;span class=&quot;fu&quot;&gt;setContentLength&lt;/span&gt;(gzip.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;);
        response.&lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(gzip);
     
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;测试-1&quot;&gt;测试&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在Servlet上输出一大段文字：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doPost&lt;/span&gt;(HttpServletRequest request, HttpServletResponse response) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ServletException, IOException {

        response.&lt;span class=&quot;fu&quot;&gt;getWriter&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;fdshfidsuhfidusfhuidsfhuidshdsuifhsd&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;uifhsduifffffdshfidsuhfidusfhuidsfhuidshdsuif&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;hsduifhsduifffffdshfidsuhfidusfhuidsfhuidshd&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;suifhsduifhsduifffffdshfidsuhfidusfhuidsfhuidsh&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;dsuifhsduifhsduifffffdshfidsuhfidusfhuidsfhuids&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;hdsuifhsduifhsduifffffdshfidsuhfidusfhuidsfhuid&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;shdsuifhsduifhsduiffdshfidsuhfidusfhuidsfhuids&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;hdsuifhsduifhsduifffffdshfidsuhfidusfhuidsfhui&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;dshdsuifhsduifhsduifffffdshfidsuhfidusfhuidsfh&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;uidshdsuifhsduifhsduifffffdshfidsuhfidusfhuids&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;fhuidshdsuifhsduifhsduifffffdshfidsuhfidusfhuid&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;sfhuidshdsuifhsduifhsduifffffdshfidsuhfidusfhui&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;dsfhuidshdsuifhsduifhsduifffffdshfidsuhfidusfh&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;uidsfhuidshdsuifhsduifhsduifffffdshfidsuhfidusf&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;huidsfhuidshdsuifhsduifhsduifffffdshfidsuhfidus&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;fhuidsfhuidshdsuifhsduifhsduifffffdshfidsuhfid&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;usfhuidsfhuidshdsuifhsduifhsduifffffdshfidsuhf&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;idusfhuidsfhuidshdsuifhsduifhsd&quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;uifffffdshfidsuhfidusfhuidsfhuidshdsuifhsduifhsduifffffff&quot;&lt;/span&gt;);

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/8/161758ab32dba938?w=460&amp;amp;h=173&amp;amp;f=png&amp;amp;s=6996&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;只要把getParameter()获取得到的数据转义一遍，就可以完成功能了。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;增强request&quot;&gt;增强request&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyHtmlRequest &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; HttpServletRequestWrapper{

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; HttpServletRequest request;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyHtmlRequest&lt;/span&gt;(HttpServletRequest request) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(request);
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt; = request;
    }


    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getParameter&lt;/span&gt;(String name) {

        String value = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getParameter&lt;/span&gt;(name);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Filter&lt;/span&gt;(value);
        
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String Filter(String message) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (message == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);

        &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; content[] = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;[message.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;()];
        message.&lt;span class=&quot;fu&quot;&gt;getChars&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, message.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;(), content, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
        StringBuffer result = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; StringBuffer(content.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; content.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; i++) {
            &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; (content[i]) {
                &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; '&amp;lt;':
                    result.&lt;span class=&quot;fu&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;lt;&quot;&lt;/span&gt;);
                    &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
                &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; '&amp;gt;':
                    result.&lt;span class=&quot;fu&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;gt;&quot;&lt;/span&gt;);
                    &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
                &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; '&amp;amp;':
                    result.&lt;span class=&quot;fu&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;amp;&quot;&lt;/span&gt;);
                    &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
                &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; '&lt;span class=&quot;st&quot;&gt;&quot;':&lt;/span&gt;
                    result.&lt;span class=&quot;fu&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;quot;&quot;&lt;/span&gt;);
                    &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
                &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:
                    result.&lt;span class=&quot;fu&quot;&gt;append&lt;/span&gt;(content[i]);
            }
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (result.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;());
        
    }
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;过滤器-1&quot;&gt;过滤器&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;



    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(ServletRequest req, ServletResponse resp, FilterChain chain) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ServletException, IOException {



        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;
        MyHtmlRequest myHtmlRequest = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyHtmlRequest&lt;/span&gt;(request);

        &lt;span class=&quot;co&quot;&gt;//传入的是被增强的request！&lt;/span&gt;
        chain.&lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(myHtmlRequest, response);

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;测试-2&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;jsp代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;form&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; action=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${pageContext.request.contextPath}/Servlet1&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;post&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    
    
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;hidden&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;h1&amp;gt;你好i好&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;h1&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;submit&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;提交&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Servlet代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doPost&lt;/span&gt;(HttpServletRequest request, HttpServletResponse response) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ServletException, IOException {

        String value = request.&lt;span class=&quot;fu&quot;&gt;getParameter&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;);
        response.&lt;span class=&quot;fu&quot;&gt;getWriter&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(value);

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/8/161758ab3126b7fa?w=979&amp;amp;h=240&amp;amp;f=png&amp;amp;s=27234&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;在前面我们已经做过了，让浏览器不缓存数据【验证码的图片是不应该缓存的】。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们要做的是：&lt;strong&gt;缓存数据到内存中【如果某个资源重复使用，不轻易变化，应该缓存到内存中】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个和压缩数据的Filter非常类似的，因为&lt;strong&gt;让数据不直接输出给浏览器，把数据用一个容器（ByteArrayOutputSteam）存起来。如果已经有缓存了，就取缓存的。没有缓存就执行目标资源！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;增强response对象-1&quot;&gt;增强response对象&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyResponse &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; HttpServletResponseWrapper {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ByteArrayOutputStream byteArrayOutputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayOutputStream();

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; PrintWriter printWriter ;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; HttpServletResponse response;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyResponse&lt;/span&gt;(HttpServletResponse response) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(response);
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;response&lt;/span&gt; = response;
    }


    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ServletOutputStream &lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {

        &lt;span class=&quot;co&quot;&gt;//这个的ServletOutputSteam对象调用write()方法的时候，把数据是写在byteArrayOutputSteam上的&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyServletOutputStream&lt;/span&gt;(byteArrayOutputStream);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; PrintWriter &lt;span class=&quot;fu&quot;&gt;getWriter&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        printWriter = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PrintWriter(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; OutputStreamWriter(byteArrayOutputStream, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCharacterEncoding&lt;/span&gt;()));

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; printWriter;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;getBuffer&lt;/span&gt;() {

        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {

            &lt;span class=&quot;co&quot;&gt;//防止数据在缓存中，要刷新一下！&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (printWriter != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                printWriter.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (byteArrayOutputStream != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                byteArrayOutputStream.&lt;span class=&quot;fu&quot;&gt;flush&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; byteArrayOutputStream.&lt;span class=&quot;fu&quot;&gt;toByteArray&lt;/span&gt;();
            }

        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }
}


&lt;span class=&quot;co&quot;&gt;//增强ServletOutputSteam，让writer方法不把数据直接返回给浏览器&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyServletOutputStream &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; ServletOutputStream {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ByteArrayOutputStream byteArrayOutputStream;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyServletOutputStream&lt;/span&gt;(ByteArrayOutputStream byteArrayOutputStream) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;byteArrayOutputStream&lt;/span&gt; = byteArrayOutputStream;
    }

    &lt;span class=&quot;co&quot;&gt;//当调用write()方法的时候，其实是把数据写byteArrayOutputSteam上&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; b) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;byteArrayOutputStream&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(b);

    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;过滤器-2&quot;&gt;过滤器&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(ServletRequest req, ServletResponse resp, FilterChain chain) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ServletException, IOException {

        &lt;span class=&quot;co&quot;&gt;//定义一个Map集合，key为页面的地址，value为内存的缓存&lt;/span&gt;
        Map&amp;lt;String, &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[]&amp;gt; map = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;

        &lt;span class=&quot;co&quot;&gt;//得到客户端想要请求的资源&lt;/span&gt;
        String uri = request.&lt;span class=&quot;fu&quot;&gt;getRequestURI&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] bytes = map.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(uri);

        &lt;span class=&quot;co&quot;&gt;//如果有缓存，直接返回给浏览器就行了，就不用执行目标资源了&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (bytes != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            response.&lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(bytes);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ;
        }

        &lt;span class=&quot;co&quot;&gt;//如果没有缓存，就让目标执行&lt;/span&gt;
        MyResponse myResponse = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyResponse&lt;/span&gt;(response);
        chain.&lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(request, myResponse);

        &lt;span class=&quot;co&quot;&gt;//得到目标资源想要发送给浏览器的数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] b = myResponse.&lt;span class=&quot;fu&quot;&gt;getBuffer&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;//把数据存到集合中&lt;/span&gt;
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(uri, b);

        &lt;span class=&quot;co&quot;&gt;//把数据返回给浏览器&lt;/span&gt;
        response.&lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(b);


    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;测试-3&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;尽管是刷新，获取得到的也是从缓存拿到的数据！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/8/161758ab691b0964?w=1397&amp;amp;h=840&amp;amp;f=gif&amp;amp;s=431373&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章的同学，可以关注微信公众号:Java3y&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 08 Feb 2018 13:13:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8433237.html</dc:identifier>
</item>
<item>
<title>给HttpClient添加Socks代理 - 子非鱼焉</title>
<link>http://www.cnblogs.com/cwjcsu/p/how-to-add-socks-proxy-support-for-httpclient.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwjcsu/p/how-to-add-socks-proxy-support-for-httpclient.html</guid>
<description>&lt;p&gt;本文描述http client使用socks代理过程中需要注意的几个方面：1，socks5支持用户密码授权；2，支持https；3，支持让代理服务器解析DNS；&lt;/p&gt;

&lt;p&gt;从原理上来看，不管用什么http客户端（httpclient，okhttp），最终都要转换到&lt;code&gt;java.net.Socket&lt;/code&gt;的创建上去，看到代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package java.net;
 public Socket(Proxy proxy) {
    ...
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是JDK中对网络请求使用Socks代理的入口方法。（http代理是在http协议层之上的，不在此文讨论范围之内）。&lt;br/&gt;HttpClient要实现socks代理，就需要塞进去一个Proxy对象，也就是定制两个类：&lt;code&gt;org.apache.http.conn.ssl.SSLConnectionSocketFactory&lt;/code&gt; 和&lt;code&gt;org.apache.http.conn.socket.PlainConnectionSocketFactory&lt;/code&gt;，分别对应https和http。&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private class SocksSSLConnectionSocketFactory extends SSLConnectionSocketFactory {

        public SocksSSLConnectionSocketFactory(SSLContext sslContext, HostnameVerifier hostnameVerifier) {
            super(sslContext, hostnameVerifier);
        }

        @Override
        public Socket createSocket(HttpContext context) throws IOException {
            ProxyConfig proxyConfig = (ProxyConfig) context.getAttribute(ProxyConfigKey);
            if (proxyConfig != null) {//需要代理
                return new Socket(proxyConfig.getProxy());
            } else {
                return super.createSocket(context);
            }
        }

        @Override
        public Socket connectSocket(int connectTimeout, Socket socket, HttpHost host, InetSocketAddress remoteAddress,
                                    InetSocketAddress localAddress, HttpContext context) throws IOException {
            ProxyConfig proxyConfig = (ProxyConfig) context.getAttribute(ProxyConfigKey);
            if (proxyConfig != null) {//make proxy server to resolve host in http url
                remoteAddress = InetSocketAddress
                        .createUnresolved(host.getHostName(), host.getPort());
            }
            return super.connectSocket(connectTimeout, socket, host, remoteAddress, localAddress, context);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private class SocksSSLConnectionSocketFactory extends SSLConnectionSocketFactory {

        public SocksSSLConnectionSocketFactory(SSLContext sslContext, HostnameVerifier hostnameVerifier) {
            super(sslContext, hostnameVerifier);
        }

        @Override
        public Socket createSocket(HttpContext context) throws IOException {
            ProxyConfig proxyConfig = (ProxyConfig) context.getAttribute(ProxyConfigKey);
            if (proxyConfig != null) {
                return new Socket(proxyConfig.getProxy());
            } else {
                return super.createSocket(context);
            }
        }

        @Override
        public Socket connectSocket(int connectTimeout, Socket socket, HttpHost host, InetSocketAddress remoteAddress,
                                    InetSocketAddress localAddress, HttpContext context) throws IOException {
            ProxyConfig proxyConfig = (ProxyConfig) context.getAttribute(ProxyConfigKey);
            if (proxyConfig != null) {//make proxy server to resolve host in http url
                remoteAddress = InetSocketAddress
                        .createUnresolved(host.getHostName(), host.getPort());
            }
            return super.connectSocket(connectTimeout, socket, host, remoteAddress, localAddress, context);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在创建httpclient对象时，给HttpClientConnectionManager设置socketFactoryRegistry&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            Registry&amp;lt;ConnectionSocketFactory&amp;gt; socketFactoryRegistry = RegistryBuilder.&amp;lt;ConnectionSocketFactory&amp;gt;create()
                .register(Protocol.HTTP.toString(), new SocksConnectionSocketFactory())
                .register(Protocol.HTTPS.toString(), new SocksSSLConnectionSocketFactory(sslContext, NoopHostnameVerifier.INSTANCE))
                .build();

        PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(socketFactoryRegistry);
    &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：运行httpClient的进程所在主机可能并不能上公网，大部分时候，也无法进行DNS解析，这时通常会出现域名无法解析的IO异常，下面介绍怎么避免在客户端解析域名。&lt;/p&gt;
&lt;p&gt;上面有一行代码非常关键：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;remoteAddress = InetSocketAddress 
                        .createUnresolved(host.getHostName(), host.getPort());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变量&lt;code&gt;host&lt;/code&gt;是你发起http请求的目标主机和端口信息，这里创建了一个未解析(Unresolved)的SocketAddress，在socks协议握手阶段，InetSocketAddress信息会原封不动的发送到代理服务器，由代理服务器解析出具体的IP地址。&lt;br/&gt;Socks的&lt;a href=&quot;https://tools.ietf.org/html/rfc1928&quot;&gt;协议描述&lt;/a&gt;中有个片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   The SOCKS request is formed as follows:

        +----+-----+-------+------+----------+----------+
        |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
        +----+-----+-------+------+----------+----------+
        | 1  |  1  | X'00' |  1   | Variable |    2     |
        +----+-----+-------+------+----------+----------+

     Where:

          o  VER    protocol version: X'05'
          o  CMD
             o  CONNECT X'01'
             o  BIND X'02'
             o  UDP ASSOCIATE X'03'
          o  RSV    RESERVED
          o  ATYP   address type of following address
             o  IP V4 address: X'01'
             o  DOMAINNAME: X'03'
             o  IP V6 address: X'04'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码按上面方法写，协议握手发送的是&lt;code&gt;ATYP=X'03'&lt;/code&gt;，即采用域名的地址类型。否则，HttpClient会尝试在客户端解析，然后发送&lt;code&gt;ATYP=X'01'&lt;/code&gt;进行协商。当然，大多数时候HttpClient在解析域名的时候就挂了。&lt;/p&gt;

&lt;p&gt;在使用httpclient访问https网站的时候，经常会遇到javax.net.ssl包中的异常，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Caused by: javax.net.ssl.SSLException: Received fatal alert: internal_error
    at sun.security.ssl.Alerts.getSSLException(Unknown Source) ~[na:1.7.0_80]
    at sun.security.ssl.Alerts.getSSLException(Unknown Source) ~[na:1.7.0_80]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般需要做几个设置：&lt;/p&gt;
&lt;h2 id=&quot;创建不校验证书链的sslcontext&quot;&gt;创建不校验证书链的SSLContext&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;        SSLContext sslContext = null;
        try {
            sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() {
                @Override
                public boolean isTrusted(X509Certificate[] chain, String authType)
                        throws CertificateException {
                    return true;
                }

            }).build();
        } catch (Exception e) {
            throw new com.aliyun.oss.ClientException(e.getMessage());
        }
        ...
        new SocksSSLConnectionSocketFactory(sslContext, NoopHostnameVerifier.INSTANCE)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建不校验域名的hostnameverifier&quot;&gt;创建不校验域名的HostnameVerifier&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class NoopHostnameVerifier implements javax.net.ssl.HostnameVerifier {

    public static final NoopHostnameVerifier INSTANCE = new NoopHostnameVerifier();

    @Override
    public boolean verify(final String s, final SSLSession sslSession) {
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;java SDK中给Socks代理授权有点特殊，不是按socket来的，而是在系统层面做的全局配置。比如，可以通过下面代码设置一个全局的Authenticator：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Authenticator.setDefault(new MyAuthenticator(&quot;userName&quot;, &quot;Password&quot;));
...
class MyAuthenticator extends java.net.Authenticator {
    private String user ;
    private String password ;
  
    public MyAuthenticator(String user, String password) {
      this.user = user;
      this.password = password;
    }
  
    protected PasswordAuthentication getPasswordAuthentication() {
      return new PasswordAuthentication(user, password.toCharArray());
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法很简单，不过有些不方便的地方，如果你的产品中需要连接不同的Proxy服务器，而他们的用户名密码是不一样的，那么这个方法就不适用了。&lt;/p&gt;
&lt;h2 id=&quot;基于threadlocal的authenticator&quot;&gt;基于ThreadLocal的Authenticator&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadLocalProxyAuthenticator extends Authenticator{
    private ThreadLocal&amp;lt;PasswordAuthentication&amp;gt; credentials = null;
     private static class SingletonHolder {
        private static final ThreadLocalProxyAuthenticator instance = new ThreadLocalProxyAuthenticator();
    }
    public static final ThreadLocalProxyAuthenticator getInstance() {
        return SingletonHolder.instance;
    }
      public void setCredentials(String user, String password) {
        credentials.set(new PasswordAuthentication(user, password.toCharArray()));
    }
    public static void clearCredentials() {
        ThreadLocalProxyAuthenticator authenticator = ThreadLocalProxyAuthenticator.getInstance();
        Authenticator.setDefault(authenticator);
        authenticator.credentials.set(null);
    }
    public PasswordAuthentication getPasswordAuthentication() {
        return credentials.get();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类意味着，授权信息只会保存到当前调用者的线程中，其他线程的调用者无法访问，在创建Socket的线程中设置密钥和清理密钥，就可以做到授权按照Socket连接进行隔离。Java TheadLocal相关知识本文不赘述。&lt;/p&gt;
&lt;h2 id=&quot;按连接隔离的授权&quot;&gt;按连接隔离的授权&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt; class ProxyHttpClient extends CloseableHttpClient{
    private CloseableHttpClient httpClient;
    public ProxyHttpClient(CloseableHttpClient httpClient){
        this.httpClient=httpClient;
    }
    protected CloseableHttpResponse doExecute(HttpHost target, HttpRequest request, HttpContext context) throws IOException, ClientProtocolException {
            ProxyConfig proxyConfig = //这里获取当前连接的代理配置信息
            boolean clearCredentials = false;
            if (proxyConfig != null) {
                if (context == null) {
                    context = HttpClientContext.create();
                }
                context.setAttribute(ProxyConfigKey, proxyConfig);
                if (proxyConfig.getAuthentication() != null) {
                    ThreadLocalProxyAuthenticator.setCredentials(proxyConfig.getAuthentication());//设置授权信息
                    clearCredentials = true;
                }
            }
            try {
                return httpClient.execute(target, request, context);
            } finally {
                if (clearCredentials) {//清理授权信息
                    ThreadLocalProxyAuthenticator.clearCredentials();
                }
            }
        }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，线程是可以复用的，因为每次调用完毕后，都清理了授权信息。&lt;br/&gt;这里有个一POJO类&lt;code&gt;ProxyConfig&lt;/code&gt;，保存的是socks代理的IP端口和用户密码信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ProxyConfig {
    private Proxy proxy;
    private PasswordAuthentication authentication;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 08 Feb 2018 13:09:00 +0000</pubDate>
<dc:creator>子非鱼焉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwjcsu/p/how-to-add-socks-proxy-support-for-httpclient.html</dc:identifier>
</item>
<item>
<title>浅谈python中的闭包函数 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/8433212.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/8433212.html</guid>
<description>&lt;h3 id=&quot;闭包函数初探&quot;&gt;闭包函数初探&lt;/h3&gt;
&lt;p&gt;通常我们定义函数都是这样定义的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实在函数式编程中，函数里面还可以嵌套函数，如下面这样&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; foo():
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in foo&quot;&lt;/span&gt;)
    
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in bar&quot;&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们调用foo函数，执行结果会是什么样子的呢？？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hello world in foo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如上所示，只会执行foo函数的第一层函数，bar函数是不会被执行的。为什么呢&lt;/p&gt;
&lt;p&gt;实际上来说，不管函数写在哪个部分，那都只是定义了一个函数，只有这个函数被调用，函数内部的语句才会被执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在上面的例子中，bar函数虽然在foo函数内部定义了，但是并没有被执行，所以bar函数是不会被执行的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样说来，定义在一个函数内部的函数就没什么作用了吗？？其实不是这样的。&lt;/p&gt;
&lt;p&gt;来看下面的例子，把bar函数作为一个值返回给foo函数，来看执行过程&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; foo():
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in foo&quot;&lt;/span&gt;)
    
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in bar&quot;&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; bar

f1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;foo()
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f1)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，由于bar函数作为一个返回值被返回给了foo，所以foo函数执行结果是有返回值的&lt;/p&gt;
&lt;p&gt;此时定义一个变量f1来接收foo函数的执行返回结果，然后打印f1&lt;/p&gt;
&lt;p&gt;返回的结果如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;hello world &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; foo
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;function foo.&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;locals&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;.bar at &lt;span class=&quot;bn&quot;&gt;0x0000000002941A60&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到首先打印了foo函数中定义的一个print语句，接着打印的是foo函数中包含的bar函数的内存地址&lt;/p&gt;
&lt;p&gt;既然是一个函数的内存地址，当然可以加括号来执行这个函数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; foo():
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in foo&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in bar&quot;&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; bar

f1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;foo()
f1()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，这段代码的执行结果为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;hello world &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; foo
hello world &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; bar&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个print语句都被打印出来了。&lt;/p&gt;
&lt;p&gt;在上面的例子里，首先定义了一个函数foo,接着在foo函数内部又嵌套定义了一个函数bar,然后返回函数bar的函数名，这就是闭包函数的定义方式。&lt;/p&gt;
&lt;p&gt;其实，闭包的定义就是一个函数内部又嵌套了一个函数&lt;/p&gt;
&lt;p&gt;来看下面的这段代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; foo():
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in foo&quot;&lt;/span&gt;)
        name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;python&quot;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in bar&quot;&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; bar
    
    f1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;foo()
    f1()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的例子里，在外层函数中定义了一个变量name，然后在内层函数中打印这个变量name&lt;/p&gt;
&lt;p&gt;此时执行上面的代码，在打印name这个变量的时候，会先在bar函数内部查找name这个变量，但是bar函数里面是没有name这个变量的,&lt;/p&gt;
&lt;p&gt;此时根据python查找变量的&lt;code&gt;LEGB&lt;/code&gt;法则，会到bar函数的外面一层去继续查找name这个变量，此时可以找到name这个变量&lt;/p&gt;
&lt;p&gt;所以这里打印的foo函数中定义的name的值&lt;/p&gt;
&lt;p&gt;执行上面的代码，打印结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hello world in foo
python
hello world in bar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要记住很重要的一点就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;内层函数引用了外层函数的局部变量&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来分析下上面的例子中程序的执行过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;首先运行foo函数，foo函数的执行结果是返回bar的函数名，此时又把foo函数的执行结果定义给了变量f1,
所以此时f1就等于bar这个函数的内存地址,然后f1加括号运行就表示运行了bar函数。
在执行bar函数的过程中，bar函数访问到了外层foo函数中定义的变量，这就是一个典型的闭包函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那使用闭包函数有什么好处呢？？在上面的例子里，f1的值是bar函数的内存地址，f1加括号运行就是在运行bar函数。&lt;/p&gt;
&lt;p&gt;又由于f1是一个全局变量，这意味着可以在整个程序的任意位置都可以运行f1函数，此时再定义一个函数，在这个函数内部调用f1函数，&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; foo():
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in foo&quot;&lt;/span&gt;)
        name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python&quot;&lt;/span&gt;
    
        &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in bar&quot;&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; bar
    
    f1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; foo()
    
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; func():
        name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;aaaaa&quot;&lt;/span&gt;
        f1()
    
    func()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来分析一下程序的执行过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.运行func函数，程序会先在内存中申请一块空间以保存name变量的值，然后运行f1函数，f1是在全局中定义的变量，所以一定可以找到f1函数的内存地址
2.f1加括号运行，就是在执行一个闭包函数，这个闭包函数内部引用了name这个变量
3.name这个变量在bar函数的外部已经定义了，所以在func函数内部调用f1函数，也就是bar函数时，其引用的变量依然是foo函数内部定义的name变量，而不是func函数内部定义的name变量，
4.因为f1函数的内部已经包含了name这个函数的值，所以就算在func函数内部也定义了name这个变量，程序执行的结果打印的依然是foo函数内部定义的name的值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hello world in foo
python
hello world in bar&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;怎样验证一个函数是闭包函数&quot;&gt;怎样验证一个函数是闭包函数&lt;/h3&gt;
&lt;h4 id=&quot;首先闭包函数都有一个特有的属性closure&quot;&gt;首先，闭包函数都有一个特有的属性：&lt;strong&gt;closure&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在上面的例子里，打印f1的&lt;code&gt;__closure__&lt;/code&gt;属性&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; foo():
        name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python&quot;&lt;/span&gt;
    
        &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in bar&quot;&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; bar
    
    f1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; foo()
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f1.__closure__)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(&amp;lt;cell at 0x0000000001DF5708: str object at 0x0000000001E79688&amp;gt;,)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到__closure__属性的打印结果是一个元组形式的，其值就是&lt;code&gt;f1函数的外层函数作用域&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时可以调用&lt;code&gt;__closure__返回的元组的元素的cell_contents方法&lt;/code&gt;打印出name变量的值&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; foo():
        name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python&quot;&lt;/span&gt;
    
        &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in bar&quot;&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; bar
    
    f1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; foo()
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f1.__closure__[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].cell_contents)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到程序已经打印出name变量的值了&lt;/p&gt;
&lt;p&gt;即然__closure__的返回结果是一个元组，那么这个元组中一定是可以包含多个值的，看下面的例子&lt;/p&gt;
&lt;p&gt;在foo函数内部定义多个变量，然后在bar函数内部打印几个变量的值，&lt;/p&gt;
&lt;p&gt;然后运行这个闭包函数，打印闭包函数的__closure__方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; foo():
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in foo&quot;&lt;/span&gt;)
        name1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python1&quot;&lt;/span&gt;
        name2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python2&quot;&lt;/span&gt;
        name3 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python3&quot;&lt;/span&gt;
        name4 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python4&quot;&lt;/span&gt;
    
        &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name1)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name2)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name3)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name4)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in bar&quot;&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; bar
    
    f1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; foo()
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f1.__closure__)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(&amp;lt;cell at 0x0000000002145708: str object at 0x00000000021C9260&amp;gt;, 
&amp;lt;cell at 0x0000000002145A08: str object at 0x00000000021C93B0&amp;gt;, 
&amp;lt;cell at 0x0000000002145768: str object at 0x000000000295BE30&amp;gt;, 
&amp;lt;cell at 0x0000000002145C18: str object at 0x0000000002963880&amp;gt;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于在foo函数内部定义了4个变量，而且在bar函数内部引用了这4个变量，所以打印这个闭包函数的__closure__方法，返回的元组中就有4个元素&lt;/p&gt;
&lt;p&gt;现在可以分别打印返回的元组中的这4个字符串对象的值了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; foo():
        name1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python1&quot;&lt;/span&gt;
        name2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python2&quot;&lt;/span&gt;
        name3 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python3&quot;&lt;/span&gt;
        name4 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python4&quot;&lt;/span&gt;
    
        &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name1)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name2)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name3)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name4)
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello world in bar&quot;&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; bar
    
    f1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; foo()
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f1.__closure__[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].cell_contents)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f1.__closure__[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].cell_contents)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f1.__closure__[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;].cell_contents)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f1.__closure__[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;].cell_contents)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python1
python2
python3
python4&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;那么现在还剩下最后一个问题了那就是闭包函数的内层函数一定要返回吗&quot;&gt;那么现在还剩下最后一个问题了，那就是闭包函数的内层函数一定要返回吗??&lt;/h4&gt;
&lt;p&gt;来看下面一个例子&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; foo():
        name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python1&quot;&lt;/span&gt;
    
        &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(bar.__closure__)
    
    foo()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义了一个嵌套函数，然后这个嵌套函数的内层函数没有被返回，而是直接打印内层函数的__closure__方法，然后直接调用外层函数。&lt;/p&gt;
&lt;p&gt;程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(&amp;lt;cell at 0x0000000002155708: str object at 0x00000000021D9688&amp;gt;,)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依然打印出了内层函数的引用的变量对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;这说明闭包函数的内层函数还一定要返回&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;闭包函数的内层函数可以调用全局变量吗&quot;&gt;闭包函数的内层函数可以调用全局变量吗？？&lt;/h4&gt;
&lt;p&gt;把外层函数内部定义的变量改为全局变量，然后在内层函数中引用这个变量&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;python1&quot;&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; foo():
        &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
    
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(bar.__closure__)
    
    f&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;foo()
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;None
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，程序的执行结果是两个None,嵌套函数的内层函数的__closure__函数的值为None&lt;/p&gt;
&lt;p&gt;这说明foo函数的内层嵌套函数bar调用的全局变量没有成功，所以上面的例子不是一个闭包函数&lt;/p&gt;
&lt;h3 id=&quot;关于闭包函数的一些总结&quot;&gt;关于闭包函数的一些总结：&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;闭包的定义为：
    在函数内部定义的函数，称为内部函数
    内部函数调用了外部函数的局部变量
    即使内部函数返回了，还是可以使用局部变量
    通常闭包函数的内层函数都要被返回给外部函数
    闭包函数的外部函数可以在任何地方被调用，而不再受函数定义时层级的限制&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;闭包函数的作用&quot;&gt;闭包函数的作用&lt;/h3&gt;
&lt;h4 id=&quot;闭包函数自带函数作用域&quot;&gt;1.闭包函数自带函数作用域&lt;/h4&gt;
&lt;p&gt;正常意义上的函数，在函数执行过程中查找变量的顺序是一层一层向外找，符合LEGB(Local-&amp;gt;Enclose-&amp;gt;Global-&amp;gt;Built in)法则的，&lt;/p&gt;
&lt;p&gt;但是对闭包函数来说，查找变量只会找内部函数外面的那一层，因为闭包函数本身就自带一层作用域，这样才符合&quot;闭包&quot;两个字的意思&lt;/p&gt;
&lt;h4 id=&quot;延迟计算也叫惰性计算&quot;&gt;2.延迟计算(也叫惰性计算)&lt;/h4&gt;
&lt;p&gt;看下面的例子&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; func():
        name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;python&quot;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; bar():
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(name)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; bar
    
    f&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;func()
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.__closure)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的例子里，执行foo()函数的返回结果是一个包含自带的某种状态的函数，实际上这个函数并没有执行，&lt;/p&gt;
&lt;p&gt;以后想执行这个自带状态的函数时，把func()返回结果所赋值的那个变量加括号就可以执行了，&lt;/p&gt;
&lt;h4 id=&quot;要想让一个函数始终保持一种状态就可以使用闭包&quot;&gt;3.要想让一个函数始终保持一种状态，就可以使用闭包&lt;/h4&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;python&quot;&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; func():
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;I like &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; name)
    
    func()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码执行结果会打印一行:&quot;I like python&quot;&lt;/p&gt;
&lt;p&gt;但是我们知道，在不同的地方调用func函数，打印的结果很大可能是不一样的&lt;/p&gt;
&lt;p&gt;那么如果我想不管在什么地方调用func函数，打印的结果都是&quot;I like python&quot;时，&lt;/p&gt;
&lt;p&gt;就可以使用闭包了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; func1():
    
        name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;python&quot;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; func():
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;I like &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; name)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; func
    
    func&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;func1()
    func()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上图所示，在func函数外面再包含一层函数func1，执行func1函数，再把func1函数的返回结果赋值给func这个变量&lt;/p&gt;
&lt;p&gt;此时func就是一个闭包函数了,把func函数加括号就可以执行了&lt;/p&gt;
&lt;p&gt;而且我们一定知道，此时func函数的执行结果一定会打印&quot;I like python&quot;这句话，而且不管func函数在程序的哪个位置被调用，执行结果都是一样的&lt;/p&gt;
</description>
<pubDate>Thu, 08 Feb 2018 13:02:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/8433212.html</dc:identifier>
</item>
<item>
<title>【精解】开发一个智能合约 - 一面千人</title>
<link>http://www.cnblogs.com/Evsward/p/contract.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Evsward/p/contract.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这两天被老大搞去搬砖，学习计划有变但无大碍，这篇文章将仔细分析智能合约相关内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关键字：智能合约，remix，Solidity，truffle，geth，leveldb，datadir，ganache，web3j&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;合约&quot;&gt;合约&lt;/h3&gt;
&lt;p&gt;合约也称合同、协议，是甲乙双方参与的，制定一系列条目规范双方权利与义务的文件。智能合约是电子化的，自动执行的，去中心化的，具有不可抵赖性，本质上它是一段代码，依托于区块链技术，它可以做很多事情，基于以太坊的智能合约可以让你的区块链扩展出任何你想要的功能。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我相信，智能合约是区块链的未来，因为基于它能做的商业模型太多样了，远远不仅是数字货币一种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;solidity&quot;&gt;Solidity&lt;/h3&gt;
&lt;p&gt;智能合约的编程语言是Solidity，扩展名为.sol，它是基于C++、JavaScript、Python创造而来的，这里是&lt;a href=&quot;https://solidity.readthedocs.io/en/develop/index.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Solidity是静态类型的，支持继承，有自己的函数库，它同样支持面向对象语言的自定义类型等其他功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Solidity编写的智能合约代码运行在EVM，即以太坊虚拟机，正如java编写的代码运行在JVM一样，在同一个区块链中每一个结点的EVM都是相同的运行环境。通过智能合约，可以开发匿名投票、匿名拍卖、众筹以及多重签名的钱包等，以太坊每一个结点可以有多个账户，所以每个结点都可以称作钱包，可以管理名下的账户，以及转账、挖矿等操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官方推荐IDE：Remix&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实Solidity智能合约开发的IDE有很多，官方推荐的Remix是基于浏览器的，运行环境可以切换：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;挂在自己的JavaScript EVM&lt;/li&gt;
&lt;li&gt;也可以使用web3 provider&lt;/li&gt;
&lt;li&gt;还可以使用注入的web3连接到本机调试环境&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我使用以后，觉得浏览器的方式还是不习惯，尤其保存的文件无故消失，让我始终心有余悸，经过调研，下面我们将采用goLand，安装Intellij-Solidity-2.0.4插件的方式开发智能合约，然后使用Remix环境进行智能合约的部署。当然我们也可以使用Remix进行运行、测试以及调试工作，下面酌情展示。&lt;/p&gt;
&lt;h3 id=&quot;gas&quot;&gt;gas&lt;/h3&gt;
&lt;p&gt;区块链中比较有意思的命名，相当于手续费但又有些不同。gas为天然气，用来代表我们程序运行所有的能耗，当发生交易等操作时会消耗相应的gas，gas的计算方式是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gas 单价 × gas 数量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中gas单价是由用户，像我们这样的发起者愿意为此次操作付出多少以太币而定的（相当于你开车上路前愿意给你的油箱加多少油，假设你的油箱是无限大的）。gas数量是程序根据你操作的复杂度自动定义的。&lt;/p&gt;
&lt;p&gt;智能合约也是一样的，当一个发起者部署运行一段智能合约时，以太坊会收取gas费用，就像汽车行驶需要烧油一样，直到你的智能合约运行完毕，“油箱”中剩余的gas会退还给你，如果你的代码死循环了，耗尽了你“油箱”中的gas，那么以太坊会自动报出异常停止你的智能合约。我们在学习智能合约阶段，可以使用testnet环境来避免真的花费以太币。&lt;/p&gt;
&lt;h3 id=&quot;dapp&quot;&gt;Dapp&lt;/h3&gt;
&lt;p&gt;Dapp为Solidity提供了源码构建工具，包管理工具，单元测试以及智能合约部署，一会儿我们看看是否必须要用它。有时它也被称作去中心化的应用程序(Decentralized App)。这种应用程序除了有一段代码的智能合约以外，还需要UI，UE设计等，正如apple的app开发，我们未来的目标之一可以是开发自己的Dapp。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;首先要开启一个本地的EVM，&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/ethereum.html&quot;&gt;前面的文章&lt;/a&gt;对Geth做了详细的介绍，这里直接启动一个本地开发模式的结点。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;geth --datadir testNet --dev console 2&amp;gt;&amp;gt;Documents/someLogs/testGeth.log&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简介一下geth的参数选项：&lt;/p&gt;
&lt;h3 id=&quot;dev&quot;&gt;dev&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Ephemeral proof-of-authority network with a pre-funded developer account, mining enabled&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;短暂的认证证明网络，同时创建一个预存款很多钱的一个开发者账户，并自动开始挖矿。&lt;/p&gt;
&lt;h3 id=&quot;datadir&quot;&gt;datadir&lt;/h3&gt;
&lt;p&gt;datadir，指定结点文件目录，如果没有会自动创建一个，该目录包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;geth
&lt;ul&gt;&lt;li&gt;chaindata 区块数据、状态数据的目录，数据库是leveldb（一个键值对数据库）
&lt;ul&gt;&lt;li&gt;000001.log&lt;/li&gt;
&lt;li&gt;CURRENT 指向MANIFEST&lt;/li&gt;
&lt;li&gt;LOCK 区块数据锁定标识文件&lt;/li&gt;
&lt;li&gt;LOG 数据库（区块和状态）操作日志&lt;/li&gt;
&lt;li&gt;*.ldb 块数据文件&lt;/li&gt;
&lt;li&gt;MANIFEST-000000 （TODO，我也不知道是什么，谁能告诉我一下）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LOCK 结点锁定标识文件&lt;/li&gt;
&lt;li&gt;nodekey 结点身份公钥，用于p2p网络寻找结点使用&lt;/li&gt;
&lt;li&gt;transactions.rlp&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;geth.ipc Mist是以太坊钱包，该文件是Mist用来内部过程通信的socket文件。&lt;/li&gt;
&lt;li&gt;keystore 存储私钥
&lt;ul&gt;&lt;li&gt;UTC--2018-02-06T03-46-35.626115529Z--740b9c48d67cf333c8b1c0e609b6b90b40d3cdea&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上目录中元素精解：&lt;/p&gt;
&lt;h4 id=&quot;nodekey&quot;&gt;① nodekey&lt;/h4&gt;
&lt;p&gt;结点之间相互寻找是通过一个发现协议：一个基于S/Kademlia的网络协议。这个协议会把包含IP地址的公钥联系起来。实际上在结点之间的peer连接使用的是一个完全不同的，加密的协议（RLPX）。RLPX加密的工作方式需要远程终端连接发起者的公钥作为身份识别。本质上来说，这个key链接了发现协议和RLPX。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;你可以随时删除这个nodekey，重启的时候会自动生成一个新的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;keystoreutc--2018-02-06t03-46-35.626115529z--740b9c48d67cf333c8b1c0e609b6b90b40d3cdea&quot;&gt;② keystore/UTC--2018-02-06T03-46-35.626115529Z--740b9c48d67cf333c8b1c0e609b6b90b40d3cdea&lt;/h4&gt;
&lt;p&gt;这是存储结点私钥的位置，文件名为时间戳加上本地账户拼成的字符串。打开文件，内容为一个json，格式化以后为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;address&quot;: &quot;740b9c48d67cf333c8b1c0e609b6b90b40d3cdea&quot;, &quot;comment&quot;:&quot;本地账户地址&quot;, 
    &quot;crypto&quot;: {
        &quot;cipher&quot;: &quot;aes-128-ctr&quot;, &quot;comment&quot;:&quot;加密协议采用的是AES-128&quot;,
        &quot;ciphertext&quot;: &quot;b331a3dbdde9abd14991116ac0bb1b742f22edda162b567974f8fbf1d694daef&quot;, &quot;comment&quot;:&quot;密文&quot;,
        &quot;cipherparams&quot;: {
            &quot;iv&quot;: &quot;06d0df7a5b7160da852fbb01339149ae&quot;, &quot;comment&quot;:&quot;加密参数&quot;
        }, 
        &quot;kdf&quot;: &quot;scrypt&quot;, &quot;comment&quot;:&quot;Key Derivation Function, 将短密码加盐hash成长密码，防彩虹表、防暴力破解&quot;,
        &quot;kdfparams&quot;: {
            &quot;dklen&quot;: 32, &quot;comment&quot;:&quot;KDF加密参数&quot;,
            &quot;n&quot;: 262144, 
            &quot;p&quot;: 1, 
            &quot;r&quot;: 8, 
            &quot;salt&quot;: &quot;6ffbd23fac4ed386aac703bc180f50be02690bef5239057a34dde4dd4de2416b&quot;, &quot;comment&quot;:&quot;盐值，加盐加密&quot;
        }, 
        &quot;mac&quot;: &quot;06b7d92b98a3b732dc1e63e7e09b8e3d79a9e8e1d43ee7a1b40482db295ea367&quot;, &quot;comment&quot;:&quot;message authentication code，消息认证码&quot;
    }, 
    &quot;id&quot;: &quot;ff7e243a-150e-45f6-ac64-06b0ed2e68ec&quot;, &quot;comment&quot;:&quot;文件主键&quot;,
    &quot;version&quot;: 3
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这部分范畴属于密码学方面了，可以参考&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/cryptography.html&quot;&gt;《应用密码学初探》&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;transactions.rlp&quot;&gt;③ transactions.rlp&lt;/h4&gt;
&lt;p&gt;RLP（Recursive Length Prefix），递归长度前缀。是以太坊中用于序列号对象的主要编码方法。根据文件名可以猜出，这是所有交易的序列化对象文件。&lt;/p&gt;
&lt;h4 id=&quot;chaindata&quot;&gt;④ chaindata&lt;/h4&gt;
&lt;p&gt;数据库采用leveldb，存储了区块数据以及状态数据。该目录下打包存储以.ldb为扩展名的每个区块的数据文件。每个块文件有容量的最大值，目前我本机默认的是2.1M，我们设想一下目前以太坊的区块高度为5039768，如果一个块是2.1M的话，那么整个区块链的数据大小为10TB。&lt;/p&gt;
&lt;h4 id=&quot;leveldb&quot;&gt;⑤ leveldb&lt;/h4&gt;
&lt;p&gt;Google出品的另一利器，使用C++编写，基于LSM(Log-Structured-Merge Tree)日志结构化合并树，是一个高效的键值对存储系统，是没有Sql语句的非关系型数据库。键值对均采用字符串类型，按照key排序。&lt;/p&gt;
&lt;p&gt;特点包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;键和值都是当作简单的字节数组,所以内容可以从ASCII字符串到二进制文件。&lt;/li&gt;
&lt;li&gt;数据按照key排序存储。&lt;/li&gt;
&lt;li&gt;调用者可以自定义一个比较方法来复写排序。&lt;/li&gt;
&lt;li&gt;基本操作有插入、获取和删除：Put(key,value), Get(key), Delete(key).&lt;/li&gt;
&lt;li&gt;一次原子批量操作可以执行多重变更操作。&lt;/li&gt;
&lt;li&gt;用户能够创建一个瞬时快照来获取一个统一的数据视图。&lt;/li&gt;
&lt;li&gt;数据可以向前亦或是向后迭代。&lt;/li&gt;
&lt;li&gt;数据采用Snappy（也是Google的一个压缩库）自动被压缩。&lt;/li&gt;
&lt;li&gt;用户可以通过一个虚拟接口自定义操作交互系统来实现一些额外的操作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;局限性包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;无SQL，无索引，非关系型数据库&lt;/li&gt;
&lt;li&gt;同时只允许一个进程访问（但支持多线程）&lt;/li&gt;
&lt;li&gt;无客户端-服务端内置库支持，一个应用程序必须要包装自己的服务器到库才能获得这样的支持。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;console&quot;&gt;console&lt;/h3&gt;
&lt;p&gt;console命令在EVM启动的同时开启了一个交互控制台，后面的一串命令是将输出的log转存到文件testGeth.log中去，启动时的日志文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WARN [02-06|11:46:35] No etherbase set and no accounts found as default 
INFO [02-06|11:46:37] Using developer account                  address=0x740b9C48D67Cf333C8b1c0E609b6b90b40D3CdeA
INFO [02-06|11:46:37] Starting peer-to-peer node               instance=Geth/v1.7.3-stable-4706005b/linux-amd64/go1.9.2
INFO [02-06|11:46:37] Allocated cache and file handles         database=/home/liuwenbin/testNet/geth/chaindata cache=128 handles=1024
INFO [02-06|11:46:37] Writing custom genesis block 
INFO [02-06|11:46:37] Initialised chain configuration          config=&quot;{ChainID: 1337 Homestead: 0 DAO: &amp;lt;nil&amp;gt; DAOSupport: false EIP150: 0 EIP155: 0 EIP158: 0 Byzantium: 0 Engine: clique}&quot;
INFO [02-06|11:46:37] Initialising Ethereum protocol           versions=&quot;[63 62]&quot; network=1
INFO [02-06|11:46:37] Loaded most recent local header          number=0 hash=593c0e…256b90 td=1
INFO [02-06|11:46:37] Loaded most recent local full block      number=0 hash=593c0e…256b90 td=1
INFO [02-06|11:46:37] Loaded most recent local fast block      number=0 hash=593c0e…256b90 td=1
INFO [02-06|11:46:37] Regenerated local transaction journal    transactions=0 accounts=0
INFO [02-06|11:46:37] Starting P2P networking 
INFO [02-06|11:46:37] started whisper v.5.0 
INFO [02-06|11:46:37] RLPx listener up                         self=&quot;enode://ede08b763001ed3642e0b3860d57e694489bcc1f47dde8563f2577bdec48e6949748826d9b88f55f456af2ae1e75ce2ea04a59eb0ef1c2c53330be92e44e6515@[::]:46591?discport=0&quot;
INFO [02-06|11:46:37] Transaction pool price threshold updated price=18000000000
INFO [02-06|11:46:37] IPC endpoint opened: /home/liuwenbin/testNet/geth.ipc 
INFO [02-06|11:46:37] Starting mining operation 
INFO [02-06|11:46:37] Commit new mining work                   number=1 txs=0 uncles=0 elapsed=53.048µs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们逐行分析，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动时第一行并未找到以太坊base的设置以及默认账户。&lt;/li&gt;
&lt;li&gt;说明使用了开发者账户，后面给出了账户地址。&lt;/li&gt;
&lt;li&gt;开始p2p网络结点，实例采用的是基于go1.9.2版本的geth实例。&lt;/li&gt;
&lt;li&gt;分配缓存和文件句柄（打开文件的唯一标识，给一个文件、设备、socket或管道一个名字，隐藏关联细节），数据库位置在/home/liuwenbin/testNet/geth/chaindata，缓存大小为128M, 文件句柄数为1024。&lt;/li&gt;
&lt;li&gt;写入当前创世块。&lt;/li&gt;
&lt;li&gt;初始化链配置，展示配置信息。&lt;/li&gt;
&lt;li&gt;初始化以太坊协议。&lt;/li&gt;
&lt;li&gt;载入大部分最近的本地数据头&lt;/li&gt;
&lt;li&gt;载入大部分最近的本地完整块数据&lt;/li&gt;
&lt;li&gt;载入大部分最近的本地最高块数据&lt;/li&gt;
&lt;li&gt;重新生成本地交易账本&lt;/li&gt;
&lt;li&gt;开始p2p网络&lt;/li&gt;
&lt;li&gt;开始whisper&lt;/li&gt;
&lt;li&gt;RLPx开始监控，并打印出当前enode信息&lt;/li&gt;
&lt;li&gt;交易池价格阀值更新，价格为=18000000000&lt;/li&gt;
&lt;li&gt;IPC端点开启：/home/liuwenbin/testNet/geth.ipc&lt;/li&gt;
&lt;li&gt;开始挖矿操作&lt;/li&gt;
&lt;li&gt;提交新的挖矿工作&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;helloworld&quot;&gt;helloworld&lt;/h2&gt;
&lt;p&gt;下面在console中查看一下当前账户的余额，发现开发环境默认给分配的余额太大，并不好测试，那么我们自己再创建一个用户，余额为0，然后用第一个“大款”账户转账给新创建用户1个以太币。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; eth.sendTransaction({from: '0x740b9c48d67cf333c8b1c0e609b6b90b40d3cdea',to:'0x1d863371462223910a1f05329b6dea0b0f9c49f8',value:web3.toWei(1,&quot;ether&quot;)})
&quot;0xb456244e4fb25b74108f05afe53670b5f1a857f5671e7d3fa2e221419d04382c&quot;
&amp;gt; eth.getBalance(eth.accounts[1])

333333333333333333&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我发现一个事，之前乘三那个geth还存在呢（捂脸笑出泪），让我改一下吧。改后我重新部署了geth命令，然后将新建用户的3个以太转回大款账户，由于gas的存在（实际上即使转账时你自己指定，也是基于一个最小值，往多了给，如果低于这个最小值，就会报错：“你加的油太少啦，我根本跑不过去”。所以最终费了大力，让新账户保留下了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; eth.getBalance(eth.accounts[1])
79000&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这79000wei的以太币是无法转出去了，因为我的余额付不起油钱。实际上79000这个数字可读性还行，所以拿这个测试也可以。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ide编码&quot;&gt;IDE编码&lt;/h3&gt;
&lt;p&gt;上面说道了我们采用goLand安装Solidity插件的方式来开发智能合约。JetBrain系列IDE插件的安装我就不介绍了，网上随便查。下面我们开始编码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pragma solidity ^0.4.0;

contract helloworld {
    string content;

    function helloworld(string _str) public {
        content = _str;
    }

    function getContent() constant public returns (string){
        return content;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码编写很简单，我们逐行解读：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过关键字pragma标识Solidity的版本为0.4.0，我们下面的代码都会采用该版本来编译。&lt;/li&gt;
&lt;li&gt;contract关键字定义一个合约，它可以有自己的方法，自己的属性（智能合约里面更愿意称为状态），将会存储在区块链中特定的地址。&lt;/li&gt;
&lt;li&gt;声明了一个字符串类型（注意首字母小写的类型关键字string）的content状态（叫做属性、成员变量都可以）&lt;/li&gt;
&lt;li&gt;通过关键字function定义一个构造方法，需要传入一个字符串数据，注意该方法的权限public被标识在了参数列表的后面。&lt;/li&gt;
&lt;li&gt;通过该方法赋值给状态content（注意不用使用this），方法的参数变量名采用了下划线开头的方式用来代表该变量的作用域很小，是私有变量，这是编程语言中的一种约定俗成的命名规则。&lt;/li&gt;
&lt;li&gt;通过关键字function定义一个打印方法，返回状态content的值，注意除了public权限以外，public的前侧还有一个constant关键字，后侧还通过关键字returns定义了返回值类型。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;部署&quot;&gt;部署&lt;/h3&gt;
&lt;p&gt;上面我们使用了goLand的Solidity插件进行了合约代码的开发，然而该插件的功能仅包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;语法高亮，代码提示&lt;/li&gt;
&lt;li&gt;代码完整性检查&lt;/li&gt;
&lt;li&gt;文件模板&lt;/li&gt;
&lt;li&gt;goto声明&lt;/li&gt;
&lt;li&gt;Find usages&lt;/li&gt;
&lt;li&gt;代码格式化&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以说都是针对编码辅助的操作，然而若我们要部署智能合约，还得回到Remix，我们新建一个sol文件，粘贴进去上面写好的helloworld代码，然后点击右侧Details，弹出的界面包含了名字、字节码、元数据等内容，我们只要其中的WEB3DEPLOY，复制出其中内容，将第一行传入参数“hello world”：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var string_str = &quot;hello world&quot; ;
var helloworldContract = web3.eth.contract([{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;getContent&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;name&quot;:&quot;string_str&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;}]);
var helloworld = helloworldContract.new(
   string_str,
   {
     from: web3.eth.accounts[0], 
     data: '0x6060604052341561000f57600080fd5b6040516102b83803806102b8833981016040528080518201919050508060009080519060200190610041929190610048565b50506100ed565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061008957805160ff19168380011785556100b7565b828001600101855582156100b7579182015b828111156100b657825182559160200191906001019061009b565b5b5090506100c491906100c8565b5090565b6100ea91905b808211156100e65760008160009055506001016100ce565b5090565b90565b6101bc806100fc6000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806359016c7914610046575b600080fd5b341561005157600080fd5b6100596100d4565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009957808201518184015260208101905061007e565b50505050905090810190601f1680156100c65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100dc61017c565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101725780601f1061014757610100808354040283529160200191610172565b820191906000526020600020905b81548152906001019060200180831161015557829003601f168201915b5050505050905090565b6020604051908101604052806000815250905600a165627a7a72305820f4bd9a6659a8625f89177c604c901764cf9cca4fa8aa2e792525da3647ca7a510029', 
     gas: '4700000'
   }, function (e, contract){
    console.log(e, contract);
    if (typeof contract.address !== 'undefined') {
         console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash);
    }
 })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仔细观察上面的代码，Remix帮我们将代码转成了EVM可识别的样子，也就是将Solidity代码编译成web3的版本，其中也帮我们估算好了gas的金额，当我们执行这段合约时会自动扣掉我们余额中相应的数值作为gas费用。&lt;/p&gt;
&lt;p&gt;接着，我们回到console，先解锁智能合约发布者的账号，我们选择刚才新建的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; personal.unlockAccount(eth.accounts[1],&quot;lwb&quot;)
true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将上面的web3版的代码复制过来，回车，输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Contract mined! address: 0x71db931bdb2f9516cf892aa0c620bd686d1095e5 transactionHash: 0x6e39a97dd2f260517bedeb9934cf88430526b46a379d5680cc092d8ea3f44602
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;合约被挖出，打印出来了合约地址，交易hash（这在以太坊中也被认定为是一笔交易，我们付费gas给以太坊）。&lt;br/&gt;然后继续在console中输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; helloworld.getContent()
&quot;hello world&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于我们余额是79000，上面gas给预估的是4700000，所以预想结果是您的余额不足，合约无法运行，然而合约部署运行成功了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们从大款那再转账一个以太币过来。然后关闭重启geth console，重复上面的操作。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;TODO: 余额仍旧未减少。不知道gas扣到哪去了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同步查看日志输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INFO [02-06|17:36:34] Submitted contract creation              fullhash=0x6e39a97dd2f260517bedeb9934cf88430526b46a379d5680cc092d8ea3f44602 contract=0x71DB931bdb2f9516Cf892aA0c620bD686D1095E5
INFO [02-06|17:36:34] Commit new mining work                   number=18 txs=1 uncles=0 elapsed=313.823µs
INFO [02-06|17:36:34] Successfully sealed new block            number=18 hash=37913b…f101af
INFO [02-06|17:36:34] 🔨 mined potential block                  number=18 hash=37913b…f101af
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每当我们提交了一个合约，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一行打印出了上面合约部署成功时的交易hash和合约地址。&lt;/li&gt;
&lt;li&gt;然后开始挖矿记账，目前已经记到第18个块了&lt;/li&gt;
&lt;li&gt;第三行第四行显示成功密封了一个新的区块。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;solidity语法&quot;&gt;Solidity语法&lt;/h2&gt;
&lt;p&gt;上面使用Solidity编写了一个helloworld智能合约，稍显力不从心，下面我们专门来学习一下Solidity语法，为未来我们编写复杂的智能合约工程打下基础。&lt;/p&gt;
&lt;h3 id=&quot;类型&quot;&gt;类型&lt;/h3&gt;
&lt;p&gt;学习一门新的编程语言，首先要看它的类型，Solidity是静态类型语言，跟java一样，也就是说在编译之前都要指定好每个变量的具体类型。类型可以分为值类型和引用类型，与java类似。&lt;/p&gt;
&lt;h4 id=&quot;值类型&quot;&gt;1.值类型&lt;/h4&gt;
&lt;p&gt;值类型作为参数时永远传的是值，每一次入参出参都是内存中值的副本。包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;布尔类型bool，true\false，与非门操作不多说。&lt;/li&gt;
&lt;li&gt;整型int，与go语言相同，有符无符int/uint，从长度8到256(int8, int16, int32... int256)，数学运算包括位运算不多讲，有不明的地方请转到&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/go.html&quot;&gt;掌握一门语言Go&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;定长浮点型fixed，有符无符fixed/ufixed，还未完全被Solidity支持，可声明不可赋值，多说无益。&lt;/li&gt;
&lt;li&gt;定长字节数组（byte/bytes1, bytes2, bytes3, ..., bytes32），没什么好说的，有个length属性可以取出长度。&lt;/li&gt;
&lt;li&gt;变长字节数组（bytes, string），与以上定长类型不同的是，变长类型不必预先指定长度，但bytes和string都属于引用类型，下面会具体介绍。&lt;/li&gt;
&lt;li&gt;地址类型address，根据以太坊结点、账户、合约等address的概念设计，长度限制为20字节。神奇的是，address封装好了一个balance属性，可以查看账户余额，以及transfer方法，可以直接转账，非常方便。此外它还有send、call等很多常用方法，这是Solidity封装好的一个基本类型，适用于智能合约开发，以后用到了再详细探究细节。&lt;/li&gt;
&lt;li&gt;枚举类型enum，例如“enum ColorEnums {Red, White, Black}”，注意返回的都是下标值，Red会返回0，White返回1，Black返回2。&lt;/li&gt;
&lt;li&gt;函数类function，变量可以作为其他function的参数，也可以作为其他function的返回值。方法在参数后面可以声明函数可见性，除了public（任意合约）和private（当前合约）以外，还有internal（当前合约以及继承合约）和external（仅外部访问）。external是由address和function签名组成，可作为外部调用函数的参数或者返回值，默认情况无显式声明时就是internal。function还需要声明返回值类型，returns (type)，但若方法无返回值时要省略这个部分。另外还有特殊的部分是在internal和returns中间还可以加入一个配置属性，[pure|constant|view|payable]。constant标识了一个常量不会被更改，只读不可写入。view是查看区块链上的数据的意思，比constant更加准确地表达了只是看看，不做修改的意图 。pure是纯函数的意思，就是保证不读取和写入到区块链内存的函数。payable是声明了该函数设计支付操作，需要虚拟机提供事务支持。 protected,&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是针对以上类型的字面量类型：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;字面量是一种针对某种值的表示法，简单来说，就是变量赋值时必须是等号右边的部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Address字面量，十六进制字面量的一种特殊情况：长度在为40个十六进制数（一个字节8位可存储两个十六进制数，一个4位），且通过了address checksum 校验。&lt;/li&gt;
&lt;li&gt;有理数整型字面量，整数，小数，科学计数法2e10，最广泛的字面量类型。&lt;/li&gt;
&lt;li&gt;字符串字面量，单引号、双引号均可的字符串。&lt;/li&gt;
&lt;li&gt;十六进制字面量，hex开头，例如hex&quot;001122FF&quot;，必须是一个字符串，内容必须是十六进制。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;引用类型&quot;&gt;2.引用类型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;数据位置类型，分为memory（内存-临时）和storage（区块链-永久），通过在变量名前声明memory还是storage来定义该变量的数据位置。一般来讲，函数参数默认为memory，局部复杂类型（作用域为局部）以及状态变量（作用域为全局）属于storage类型。还有一个calldata与memory差不多，专门用于存储函数参数的，也不是永久存储。额外提一点，EVM的memory是基于stack的，stack可以临时存储一些小的局部变量。这些变量存储消耗的gas是不同的，storage最大，memory较小，stack几乎免费，calldata与memory差不多。&lt;/li&gt;
&lt;li&gt;数组类型Arrays，长度可定可变，可以存储于storage和memory，元素类型可以是任何类型，但memory时不能是映射类型（就是键值对类型）。&lt;/li&gt;
&lt;li&gt;结构体struct，与Go语言相同的设定，自定义类型，使用方式也与Go极为相似。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;mapping类型&quot;&gt;mapping类型&lt;/h4&gt;
&lt;p&gt;mapping类型就是键值对，现在最新语言都会给自身增加键值对数据结构的封装支持。mapping的声明方式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mapping(_KeyType =&amp;gt; _ValueType)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;键值对中间通过一个“=&amp;gt;”连接。元素内容，Solidity类型均可，与其他键值对使用差不多，遇到问题再深入研究。&lt;/p&gt;
&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;p&gt;关于Solidity其他语法这里暂不过多介绍，掌握以上Solidity的类型知识，我想其他语法可以在实战中解决掉。下面会以“Solidit语法补充说明”的形式对新遇到的语法问题进行补充研究。&lt;/p&gt;

&lt;p&gt;上面我们开发部署运行智能合约helloworld时，编码是在goLand，编译是在Remix，部署运行是在geth console，感觉好混乱，也不适合大规模工程开发，是否有一种工具可以集成这一切？&lt;/p&gt;
&lt;p&gt;Truffle!&lt;/p&gt;
&lt;h3 id=&quot;准备工作-1&quot;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;由于truffle是依赖于nodejs，可能会有版本不兼容的问题，因此要先完全删除你机器上的nodejs和npm，然后再安装纯净版的nodejs，npm，truffle，请按照以下命令进行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo apt-get remove nodejs
sudo apt-get remove npm
sudo apt-get update
which node
wget https://nodejs.org/dist/v8.8.0/node-v8.8.0-linux-x64.tar.gz
sudo tar -xf node-v8.8.0-linux-x64.tar.gz --directory /usr/local --strip-components 1
node --version
npm --version
sudo npm install -g truffle&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;metacoin初始化&quot;&gt;MetaCoin初始化&lt;/h3&gt;
&lt;p&gt;此时应该可以直接使用命令truffle了，下面我们建立一个工作间truffle-workspace，然后在工作间执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir MetaCoin
cd MetaCoin
truffle unbox metacoin&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原来使用truffle init，但现在它存在于unbox。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;unbox&quot;&gt;unbox&lt;/h4&gt;
&lt;p&gt;Truffle 的盒子Boxs装有很多非常实用的项目样板，可以让你忽略一些环境配置问题，从而可以集中与开发你自己的DApp的业务唯一性。除此之外，Truffle Boxes能够容纳其他有用的组件、Solidity合约或者库，前后端视图等等。所有这些都是一个完整的实例Dapp程序。都可以下载下来逐一研究，寻找适合自己公司目前业务模型的组件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://truffleframework.com/boxes/&quot;&gt;Truffle的官方Boxes地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到，现在官方盒子还不多，总共7个，有三个是关于react的，两个是truffle自己的项目，可以下载体验，剩下两个是我们比较关心的，一个是metacoin，非常好的入门示例，另一个是webpack，顾名思义，它是一套比起metacoin更加完整的模板的存在。既然我们是初学，下面我们就从metacoin入手学习。&lt;/p&gt;
&lt;h4 id=&quot;目录结构&quot;&gt;目录结构&lt;/h4&gt;
&lt;p&gt;进入metacoin目录，当前目录已经被初始化成一个新的空的以太坊工程，目录结构如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;contracts
&lt;ul&gt;&lt;li&gt;ConvertLib.sol&lt;/li&gt;
&lt;li&gt;MetaCoin.sol&lt;/li&gt;
&lt;li&gt;Migrations.sol&lt;/li&gt;
&lt;li&gt;.placeholder&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;migrations
&lt;ul&gt;&lt;li&gt;1_initial_migration.js&lt;/li&gt;
&lt;li&gt;2_deploy_contracts.js&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;test
&lt;ul&gt;&lt;li&gt;metacoin.js&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;TestMetacoin.sol&lt;/li&gt;
&lt;li&gt;.placeholder&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;truffle-config.js&lt;/li&gt;
&lt;li&gt;truffle.js&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;初始化文件解释1migrations.sol&quot;&gt;初始化文件解释1：Migrations.sol&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pragma solidity ^0.4.17;

contract Migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function Migrations() public {
    owner = msg.sender;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们学习了Solidity具体的类型语法，我们来分析一下这个文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它定义了一个名字为“迁移”的合约&lt;/li&gt;
&lt;li&gt;有一个任意访问的全局变量，存储于storage的地址类型变量owner&lt;/li&gt;
&lt;li&gt;有一个可任意访问的全局变量，存储于storage的无符号整型类型的变量last_completed_migration&lt;/li&gt;
&lt;li&gt;modifier下面细说，此处略过&lt;/li&gt;
&lt;li&gt;msg.sender下面细说，此处略过&lt;/li&gt;
&lt;li&gt;构造函数，初始化将发送方赋值给owner保存&lt;/li&gt;
&lt;li&gt;一个setCompleted赋值方法，赋值给last_completed_migration，其中该方法被声明为restricted，下面细说，此处略过&lt;/li&gt;
&lt;li&gt;upgrade方法，调用当前合约自己的方法，得到合约的实例upgraded，然后通过该是咧调用setCompleted赋值方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;solidity语法补充说明1function-modifier&quot;&gt;Solidity语法补充说明1：function modifier&lt;/h4&gt;
&lt;p&gt;modifier的使用方法，就看上面的Migrations合约的例子即可，它可以自动改变函数的行为，例如你可以给他预设一个条件，他会不断检查，一旦符合条件即可走预设分支。它可以影响当前合约以及派生合约。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pragma solidity ^0.4.11;

contract owned {
    function owned() public { owner = msg.sender; }
    address owner;
    // 这里仅定义了一个modifier但是没有使用，它将被子类使用，方法体在这里“_;”，这意味着如果owner调用了这个函数，函数会被执行，其他人调用会抛出一个异常。
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
}

// 通过is关键字来继承一个合约类，mortal是owned的子类，也叫派生类。
contract mortal is owned {
    // 当前合约派生了owned，此方法使用了父类的onlyOwner的modifier
    // public onlyOwner， 这种写法挺让人困惑，下面给出了我的思考，暂理解为派生类要使用基类的modifier。
    function close() public onlyOwner {
        selfdestruct(owner);
    }
}

contract priced {
    // Modifiers可以接收参数
    modifier costs(uint price) {
        // 这里modifier方法体是通过条件判断，是否满足，满足则执行“_;”分支。
        if (msg.value &amp;gt;= price) {
            _;
        }
    }
}

contract Register is priced, owned {
    mapping (address =&amp;gt; bool) registeredAddresses;
    uint price;
    
    // 构造函数给全局变量price赋值。
    function Register(uint initialPrice) public { price = initialPrice; }

    // payable关键字重申，如果不声明的话，函数关于以太币交易的操作都会被拒回。
    function register() public payable costs(price) {
        registeredAddresses[msg.sender] = true;
    }

    // 此派生类也要使用基类的modifier。
    function changePrice(uint _price) public onlyOwner {
        price = _price;
    }
}

contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(!locked);
        locked = true;
        _;
        locked = false;
    }

    function f() public noReentrancy returns (uint) {
        require(msg.sender.call());
        return 7;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又延伸出来一个盲点：require关键字，它是错误判断，提到assert就懂了，官方文档的解释为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;require(bool condition):
throws if the condition is not met - to be used for errors in inputs or external components.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下modifier：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;声明modifier时，特殊符号“_;”的意思有点像TODO，是一个“占位符”，指出了你要写的具体方法体内容的位置。&lt;/li&gt;
&lt;li&gt;function close() public onlyOwner，派生类某方法想“如虎添翼”加入基类的某个modifier功能，就可以这样写，这行的具体意思就是：close方法也必须是owner本人执行，否则报错！&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;solidity语法补充说明2restricting-access&quot;&gt;Solidity语法补充说明2：Restricting Access&lt;/h4&gt;
&lt;p&gt;限制访问一种针对合约的常见模式。但其实你永远不可能限制得了任何人或电脑读取你的交易内容或者你的合同状态。你可以使用加密增大困难，但你的合约就是用来读取数据的，那么其他人也会看到。所以，其实上面的modifier onlyOwner是一个特别好的可读性极高的限制访问的手段。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么restricted关键字如何使用呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好吧，我刚刚带着modifier的知识重新看了上面的Migrations合约的内容发现，restricted并不是关键字，而是modifier的方法名，在其下的想增加该modifier功能的函数中，都使用了public restricted的方式来声明。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;说到这里，我又明白了为什么要使用public onlyOwner这种写法，因为public是函数可见性修饰符，onlyOwner是自定义的限制访问的modifier方法，他们都是关于函数使用限制方面的，所以会写在一起，可以假想一个括号将它俩括起来，他们占一个位置，就是原来属于public|private|internal|external的那个位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;solidity语法补充说明3special-variables-and-functions&quot;&gt;Solidity语法补充说明3：Special Variables and Functions&lt;/h4&gt;
&lt;p&gt;这一点很重要了，我们研究一下Solidity自身携带的特殊变量以及函数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;block.blockhash(uint blockNumber) returns (bytes32): 返回参数区块编号的hash值。（范围仅限于最近256块，还不包含当然块）&lt;/li&gt;
&lt;li&gt;block.coinbase (address): 当前区块矿工地址&lt;/li&gt;
&lt;li&gt;block.difficulty (uint): 当前区块难度&lt;/li&gt;
&lt;li&gt;block.gaslimit (uint): 当前区块的gaslimit&lt;/li&gt;
&lt;li&gt;block.number (uint): 当前区块编号&lt;/li&gt;
&lt;li&gt;block.timestamp (uint): 当前区块的timestamp，使用UNIX时间秒&lt;/li&gt;
&lt;li&gt;msg.data (bytes): 完整的calldata&lt;/li&gt;
&lt;li&gt;msg.gas (uint): 剩余的gas&lt;/li&gt;
&lt;li&gt;msg.sender (address): 信息的发送方 (当前调用)&lt;/li&gt;
&lt;li&gt;msg.sig (bytes4): calldata的前四个字节 (i.e. 函数标识符)&lt;/li&gt;
&lt;li&gt;msg.value (uint): 消息发送的wei的数量&lt;/li&gt;
&lt;li&gt;now (uint): 当前区块的timestamp (block.timestamp别名)&lt;/li&gt;
&lt;li&gt;tx.gasprice (uint): 交易的gas单价&lt;/li&gt;
&lt;li&gt;tx.origin (address): 交易发送方地址(完全的链调用)&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;msg有两个属性，一个是msg.sender，另一个是msg.value，这两个值可以被任何external函数调用，包含库里面的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意谨慎使用block.timestamp, now and block.blockhash，因为他们都是有可能被篡改的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;初始化文件解释2metacoin.sol&quot;&gt;初始化文件解释2：MetaCoin.sol&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pragma solidity ^0.4.18;

import &quot;./ConvertLib.sol&quot;;

// 这是一个简单的仿币合约的例子。它并不是标准的可兼容其他币或token的合约，
// 如果你想创建一个标准兼容的token，请转到 https://github.com/ConsenSys/Tokens（TODO:一会儿我们再过去转）

contract MetaCoin {
        mapping (address =&amp;gt; uint) balances;// 定义了一个映射类型变量balances，key为address类型，值为无符整型，应该是用来存储每个账户的余额，可以存多个。

        event Transfer(address indexed _from, address indexed _to, uint256 _value);// Solidity语法event，TODO:见下方详解。

        function MetaCoin() public {// 构造函数，tx.origin查查上面，找到它会返回交易发送方的地址，也就是说合约实例创建时会默认为当前交易发送方的余额塞10000，单位应该是你的仿币。
                balances[tx.origin] = 10000;
        }

        function sendCoin(address receiver, uint amount) public returns(bool sufficient) {// 函数声明部分没有盲点，方法名，参数列表，函数可见性，返回值类型定义。
                if (balances[msg.sender] &amp;lt; amount) return false;// 如果余额不足，则返回发送币失败
                balances[msg.sender] -= amount;// 否则从发送方余额中减去发送值，注意Solidity也有 “-=”，“+=” 的运算符哦
                balances[receiver] += amount;// 然后在接收方的余额中加入发送值数量。
                Transfer(msg.sender, receiver, amount);// 使用以上event关键字声明的方法
                return true;
        }

        function getBalanceInEth(address addr) public view returns(uint){// 获取以太币余额
                return ConvertLib.convert(getBalance(addr),2);// 调用了其他合约的方法，TODO:稍后介绍ConvertLib合约时说明。
        }

        function getBalance(address addr) public view returns(uint) {// 获取当前账户的仿币余额
                return balances[addr];
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;solidity语法补充说明4events&quot;&gt;Solidity语法补充说明4：Events&lt;/h4&gt;
&lt;p&gt;Events allow the convenient usage of the EVM logging facilities, which in turn can be used to “call” JavaScript callbacks in the user interface of a dapp, which listen for these events.&lt;br/&gt;Events提供了日志支持，进而可用于在用户界面上“调用”dapp JavaScript回调,监听了这些事件。简单来说，我们的DApp是基于web服务器上的web3.js与EVM以太坊结点进行交互的，而智能合约是部署在EVM以太坊结点上的。举一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;contract ExampleContract {
  // some state variables ...
  function foo(int256 _value) returns (int256) {
    // manipulate state ...
    return _value;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;合约ExampleContract有个方法foo被部署在EVM的一个结点上运行了，此时用户如果想在DApp上调用合约内部的这个foo方法，如何操作呢，有两种办法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;var returnValue = exampleContract.foo.call(2);// 通过web3 的message的call来调用。&lt;/li&gt;
&lt;li&gt;合约内部再声明一个event ReturnValue(address indexed _from, int256 _value);并在foo方法内使用该event用来返回方法执行结果。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一种办法在方法本身比较耗时的情况下会阻塞，或者不会获取到准确的返回值。所以采用第二种办法：就是通过Solidity的关键字event。event在这里就是一个回调函数的概念，当函数运行结束以后（交易进块），会通过event返回给web3，也就是DApp用户界面相应的结果。这是以太坊一种客户端异步调用方法。关于这个回调，要在DApp使用web3时显示编写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exampleEvent.watch(function(err, result) {
  if (err) {
    console.log(err)
    return;
  }
  console.log(result.args._value)
  // 检查合约方法是否反返回结果，若有则将结果显示在用户界面并且调用exampleEvent.stopWatching()方法停止异步回调监听。
})&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;写Solidity最大的不同在于，我们要随时计算好我们的gas消耗，方法的复杂度，变量类型的存储位置（memory，storage等等）都会决定gas的消耗量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用event可以获得比storage更便宜的gas消耗。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;总结一下event，就是如果你的Dapp客户端web3.js想调用智能合约内部的函数，则使用event作为桥梁，它能方便执行异步调用同时又节约gas消耗。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;初始化文件解释3convertlib.sol&quot;&gt;初始化文件解释3：ConvertLib.sol&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pragma solidity ^0.4.4;

library ConvertLib{
        function convert(uint amount,uint conversionRate) public pure returns (uint convertedAmount)
        {
                return amount * conversionRate;
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与MetaCoin智能合约不同的是，ConvertLib是由library声明的一个库，它只有一个方法，就是返回给定的两个无符整数值相乘的结果。返回到上面的MetaCoin中该库的使用位置去分析，即可知道，MetaCoin的仿币的价格是以太币的一倍，所以MetaCoin是以以太币为标杆，通过智能合约发布的一个token，仿币。&lt;/p&gt;
&lt;blockquote readability=&quot;6.070110701107&quot;&gt;
&lt;p&gt;这似乎就可以很好地解决我在&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/eth-rpc.html&quot;&gt;《以太坊RPC机制与API实例》&lt;/a&gt;文章中需要发布三倍以太币的token的需求了，而我们完全不必更改以太坊源码，但那篇文章通过这个需求的路线研究了以太坊的Go源码也算功不可没。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;初始化文件解释41_initial_migration.js&quot;&gt;初始化文件解释4：1_initial_migration.js&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;var Migrations = artifacts.require(&quot;./Migrations.sol&quot;);

module.exports = function(deployer) {
  deployer.deploy(Migrations);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个js文件是nodejs的写法，看上去它的作用就是部署了上面的Migrations智能合约文件。&lt;/p&gt;
&lt;h4 id=&quot;初始化文件解释52_deploy_contracts.js&quot;&gt;初始化文件解释5：2_deploy_contracts.js&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;var ConvertLib = artifacts.require(&quot;./ConvertLib.sol&quot;);
var MetaCoin = artifacts.require(&quot;./MetaCoin.sol&quot;);

module.exports = function(deployer) {
  deployer.deploy(ConvertLib);
  deployer.link(ConvertLib, MetaCoin);
  deployer.deploy(MetaCoin);
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个文件是meatcoin智能合约的部署文件，里面约定了部署顺序，依赖关系。这里我们看到了MetaCoin智能合约是要依赖于库ConvertLib的，所以要先部署ConvertLib，然后link他们，再部署MetaCoin，这部分js的写法可以参照官方文档&lt;a href=&quot;http://truffleframework.com/docs/getting_started/migrations&quot;&gt;DEPLOYER API&lt;/a&gt;，主要就是介绍了一下deploy、link以及then三个方法的详细用法，不难这里不再赘述。&lt;/p&gt;
&lt;h4 id=&quot;初始化文件解释6truffle-config.js-truffle.js&quot;&gt;初始化文件解释6：truffle-config.js, truffle.js&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  // See &amp;lt;http://truffleframework.com/docs/advanced/configuration&amp;gt;
  // to customize your Truffle configuration!
};
module.exports = {
  // See &amp;lt;http://truffleframework.com/docs/advanced/configuration&amp;gt;
  // to customize your Truffle configuration!
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个文件也都是nodejs，他们都是配置文件，可能作用域不同，目前它俩是完全相同的（因为啥也没有）。我们去它推荐的网站看一看。给出了一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  networks: {
    development: {
      host: &quot;127.0.0.1&quot;,
      port: 8545,
      network_id: &quot;*&quot; // Match any network id
    }
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子展示了该配置文件可以配置网络环境，暂先到这，以后遇上了针对该配置文件进行研究。&lt;/p&gt;
&lt;h4 id=&quot;初始化文件解释7.placeholder&quot;&gt;初始化文件解释7：.placeholder&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;This is a placeholder file to ensure the parent directory in the git repository. Feel free to remove.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来就是：placeholder文件是用来保证在git库中父级目录的，可以删除。&lt;/p&gt;
&lt;h4 id=&quot;初始化文件解释8metacoin.js&quot;&gt;初始化文件解释8：metacoin.js&lt;/h4&gt;
&lt;p&gt;和下面的文件一样，他们的功能都是用来做单元测试的，truffle在编译期间会自动执行这些测试脚本。当前文件为js版本，模拟用户在DApp客户端用户界面操作的情形。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var MetaCoin = artifacts.require(&quot;./MetaCoin.sol&quot;); // 这与1_initial_migration.js文件的头是一样的，引入了一个智能合约文件。

contract('MetaCoin', function(accounts) {
  it(&quot;should put 10000 MetaCoin in the first account&quot;, function() {
    return MetaCoin.deployed().then(function(instance) {
      return instance.getBalance.call(accounts[0]);
    }).then(function(balance) {
      assert.equal(balance.valueOf(), 10000, &quot;10000 wasn't in the first account&quot;);
    });
  });
  it(&quot;should call a function that depends on a linked library&quot;, function() {
    var meta;
    var metaCoinBalance;
    var metaCoinEthBalance;

    return MetaCoin.deployed().then(function(instance) {
      meta = instance;
      return meta.getBalance.call(accounts[0]);
    }).then(function(outCoinBalance) {
      metaCoinBalance = outCoinBalance.toNumber();
      return meta.getBalanceInEth.call(accounts[0]);
    }).then(function(outCoinBalanceEth) {
      metaCoinEthBalance = outCoinBalanceEth.toNumber();
    }).then(function() {
      assert.equal(metaCoinEthBalance, 2 * metaCoinBalance, &quot;Library function returned unexpected function, linkage may be broken&quot;);
    });
  });
  it(&quot;should send coin correctly&quot;, function() {
    var meta;

    // Get initial balances of first and second account.
    var account_one = accounts[0];
    var account_two = accounts[1];

    var account_one_starting_balance;
    var account_two_starting_balance;
    var account_one_ending_balance;
    var account_two_ending_balance;

    var amount = 10;

    return MetaCoin.deployed().then(function(instance) {
      meta = instance;
      return meta.getBalance.call(account_one);
    }).then(function(balance) {
      account_one_starting_balance = balance.toNumber();
      return meta.getBalance.call(account_two);
    }).then(function(balance) {
      account_two_starting_balance = balance.toNumber();
      return meta.sendCoin(account_two, amount, {from: account_one});
    }).then(function() {
      return meta.getBalance.call(account_one);
    }).then(function(balance) {
      account_one_ending_balance = balance.toNumber();
      return meta.getBalance.call(account_two);
    }).then(function(balance) {
      account_two_ending_balance = balance.toNumber();

      assert.equal(account_one_ending_balance, account_one_starting_balance - amount, &quot;Amount wasn't correctly taken from the sender&quot;);
      assert.equal(account_two_ending_balance, account_two_starting_balance + amount, &quot;Amount wasn't correctly sent to the receiver&quot;);
    });
  });
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来分析一波这个truffle metacoin js版本的单元测试：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接函数contract走起，第一个参数为智能合约名字，第二个参数为匿名内部函数&lt;/li&gt;
&lt;li&gt;匿名函数传入了当前账户地址，函数体是单元测试集&lt;/li&gt;
&lt;li&gt;每个单元测试是由关键字it函数来做，第一个参数传入单元测试的comments，第二个参数传入一个无参匿名函数&lt;/li&gt;
&lt;li&gt;进到无参匿名函数的函数体内，就是正式的单元测试内容，可以定义自己的成员属性，通过调用truffle内部组件自动部署合约逐一测试，使用成员属性接收返回值，最后使用关键字assert来判断是否符合预期。具体业务不详细展开，可根据自己业务内容随意更改。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是官方文档，详细说明&lt;a href=&quot;http://truffleframework.com/docs/getting_started/javascript-tests&quot;&gt;如何使用JS来编写智能合约的单元测试&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;初始化文件解释9testmetacoin.sol&quot;&gt;初始化文件解释9：TestMetacoin.sol&lt;/h4&gt;
&lt;p&gt;好下面来看看Solidity智能合约版本的单元测试。一般来讲，这种文件的命名规则是Test加待测智能合约的名字拼串组成。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pragma solidity ^0.4.2;

import &quot;truffle/Assert.sol&quot;;
import &quot;truffle/DeployedAddresses.sol&quot;;
import &quot;../contracts/MetaCoin.sol&quot;;

contract TestMetacoin {

  function testInitialBalanceUsingDeployedContract() public {
    MetaCoin meta = MetaCoin(DeployedAddresses.MetaCoin());

    uint expected = 10000;

    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);
  }

  function testInitialBalanceWithNewMetaCoin() public {
    MetaCoin meta = new MetaCoin();

    uint expected = 10000;

    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先import了truffle的几个类库，用来支持我们接下来的测试内容。然后import了待测智能合约。&lt;/li&gt;
&lt;li&gt;建立单元测试智能合约，根据合约不同方法定义对应的test测试方法。&lt;/li&gt;
&lt;li&gt;方法体内部去调用待测智能合约的方法，传参接收返回值，然后使用关键字assert判断是否符合预期。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是官方文档，详细说明&lt;a href=&quot;http://truffleframework.com/docs/getting_started/solidity-tests&quot;&gt;如何使用Solidity来编写智能合约的单元测试&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;编译合约&quot;&gt;编译合约&lt;/h3&gt;
&lt;p&gt;键入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;truffle compile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@liuwenbin-H81M-DS2:~/work/truffle-workspace/MetaCoin$ truffle compile
Compiling ./contracts/ConvertLib.sol...
Compiling ./contracts/MetaCoin.sol...
Compiling ./contracts/Migrations.sol...
Writing artifacts to ./build/contracts&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据编译输出的路径地址./build/contracts，我们去查看一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@liuwenbin-H81M-DS2:~/work/truffle-workspace/build/contracts$ ls
ConvertLib.json  MetaCoin.json  Migrations.json&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到原来所在在contracts目录下的智能合约文件（有合约contract，有库library）均被编译成了json文件。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这些json文件就是truffle用来部署合约的编译文件，这与上面通过Remix编译的WEB3DEPLOY的js代码段不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;部署合约&quot;&gt;部署合约&lt;/h3&gt;
&lt;p&gt;移植，对这里叫移植，但下面我们仍使用“部署”这个词，truffle中部署的命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;truffle migrate&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里遇到的问题较多，我来一一解决：&lt;/p&gt;
&lt;h4 id=&quot;问题1启动本地以太坊客户端结点&quot;&gt;问题1：启动本地以太坊客户端结点&lt;/h4&gt;
&lt;p&gt;以太坊客户端有很多，truffle自己就有一个ganache，但我没安装成功，下面列举一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Geth (go-ethereum)也就是我们之前到现在一直在介绍的。&lt;/li&gt;
&lt;li&gt;WebThree (cpp-ethereum): C++版本，我们一直在使用的是上面的Go版本。&lt;/li&gt;
&lt;li&gt;Parity&lt;/li&gt;
&lt;li&gt;More: &lt;a href=&quot;https://www.ethereum.org/cli&quot; class=&quot;uri&quot;&gt;https://www.ethereum.org/cli&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然了，我们还是继续使用geth，仍旧使用上面介绍过的启动命令启动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;geth --datadir testNet --dev console 2&amp;gt;&amp;gt;Document/someLogs/testGeth.log&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;问题2配置truffle.js&quot;&gt;问题2：配置truffle.js&lt;/h4&gt;
&lt;p&gt;上文说到了，truffle.js是truffle的配置文件，启动好以太坊本地结点以后，我们需要让truffle去识别它并使用它，这就需要在truffle.js中配置相关属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  networks: {
    development: {
      host: &quot;127.0.0.1&quot;,
      port: 8545,
      network_id: &quot;*&quot; // Match any network id
    }
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;问题3修改geth启动命令与truffle.js配置文件&quot;&gt;问题3：修改geth启动命令与truffle.js配置文件&lt;/h4&gt;
&lt;p&gt;以上两个问题解决以后，我们使用truffle migrate来部署，terminal报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@liuwenbin-H81M-DS2:~/work/truffle-workspace/MetaCoin$ truffle migrate
Could not connect to your Ethereum client. Please check that your Ethereum client:
    - is running
    - is accepting RPC connections (i.e., &quot;--rpc&quot; option is used in geth)
    - is accessible over the network
    - is properly configured in your Truffle configuration file (truffle.js)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误信息很清楚，直接增加一个参数--rpc，最终修改我们的启动命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;geth --datadir testNet --dev --rpc console 2&amp;gt;&amp;gt;Document/someLogs/testGeth.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续使用truffle migrate来部署，terminal及继续报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Error: exceeds block gas limit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;去truffle github issues中查找，找到一行解决办法，粘贴如下：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;Possibility: you're giving the transaction too high of a gasLimit. If the transaction has a limit of 2,000,000, it'd stop you since it could theoretically go over the block gas limit, even if in practice it won't. If this is the case, see if you can reduce the transaction's gasLimit while remaining above the amount it actually needs--that might do the trick.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好，我们再修改一下truffle.js如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  networks: {
    development: {
      host: &quot;127.0.0.1&quot;,
      port: 8545,
      network_id: &quot;*&quot;, // Match any network id
      gas:500000
    }
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续执行truffle migrate，执行成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@liuwenbin-H81M-DS2:~/work/truffle-workspace/MetaCoin$ truffle migrate
Using network 'development'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x2adf8c421a2814ea4d5f1a211048ac64c47f6fcf64a1418dd4abc463d604d8fc

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时terminal处于监听状态，我们先不管他，下面请转到“IDE cooking steps”章节会给出解释。&lt;/p&gt;
&lt;p&gt;去看一下Documents/someLogs/testGeth.log文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INFO [02-08|14:59:39] Submitted contract creation              fullhash=0x2adf8c421a2814ea4d5f1a211048ac64c47f6fcf64a1418dd4abc463d604d8fc contract=0xc8B95403276e5B4482718803C25A449743d59755
INFO [02-08|14:59:39] Commit new mining work                   number=23 txs=1 uncles=0 elapsed=351.917µs
INFO [02-08|14:59:39] Successfully sealed new block            number=23 hash=b97b83…b19548
INFO [02-08|14:59:39] 🔨 mined potential block                  number=23 hash=b97b83…b19548
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我截取到了日志文件中以上的部分，可以看到，我们的智能合约已经被成功部署了，且日志中的hash值与上面监听状态的terminal中显式的是相同的，说明是一致的。下面我们就可以在终端使用该智能合约了。&lt;/p&gt;
&lt;h3 id=&quot;测试合约&quot;&gt;测试合约&lt;/h3&gt;
&lt;p&gt;上面我们介绍了智能合约的单元测试的写法，包括js版本和Solidity版本，我们也知道在执行编译时会自动执行这些单元测试，如果有一个测试未通过则会中断编译过程。而在开发阶段，我们也可以自己使用命令来测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;truffle test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没有报错就说明通过了，绿条，有报错就会打印在下方。&lt;/p&gt;
&lt;h2 id=&quot;使用truffle开发智能合约&quot;&gt;使用truffle开发智能合约&lt;/h2&gt;
&lt;p&gt;经过上面truffle metacoin环境模板的搭建，我们整个智能合约的开发、编译、部署以及运行环境就搭建好了。下面我们用这套环境来重现最初的helloworld智能合约。&lt;/p&gt;
&lt;h3 id=&quot;创建工程&quot;&gt;创建工程&lt;/h3&gt;
&lt;p&gt;首先创建我们的工程Helloworld：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@liuwenbin-H81M-DS2:~/work/truffle-workspace$ mkdir helloworld &amp;amp;&amp;amp; cd helloworld
liuwenbin@liuwenbin-H81M-DS2:~/work/truffle-workspace/helloworld$ truffle init
Downloading...
Unpacking...
Setting up...
Unbox successful. Sweet!

Commands:

  Compile:        truffle compile
  Migrate:        truffle migrate
  Test contracts: truffle test
liuwenbin@liuwenbin-H81M-DS2:~/work/truffle-workspace/helloworld$ ls
contracts  migrations  test  truffle-config.js  truffle.js
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ide-cooking-steps&quot;&gt;IDE cooking steps&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;仍旧使用goLand + Solidity插件&lt;/li&gt;
&lt;li&gt;*导入项目truffle-workspace/helloworld&lt;/li&gt;
&lt;li&gt;在contracts目录下新建一个智能合约文件Helloworld.sol（注意要与工程名相同，同时最好都首字母大写），输入与上文相同的内容。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;*然后在IDE内部打开一个terminal，启动EVM&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@liuwenbin-H81M-DS2:~$ geth --datadir testNet --dev --rpc console&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;*将上面的truffle.js配置内容粘贴到当前工程的truffle.js配置文件中&lt;/li&gt;
&lt;li&gt;新增一个helloworld的部署文件“2_deploy_helloworld.js”到migrations目录下，添加对helloworld智能合约的部署配置。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;再开启一个terminal，执行truffle compile, truffle migrate。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;WARN: 这一步遇到问题，上面所谓监听状态实际上是卡住了，我们的智能合约并未部署成功，虽然在EVM中已经写入了块，但是无法识别该合约对象。理想状态下我们可以调用合约对象了，这个流程就全通了，但是没事，我去继续查一下解决方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;采用客户端ganache代替geth&quot;&gt;采用客户端ganache代替geth&lt;/h2&gt;
&lt;p&gt;上文说明了这些原因，我也在官网下载了ganache，这是一个AppImage文件，这个文件在linux系统可以直接启动，首先我们需要将它的执行权限修改一下，然后启动即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;chmod a+x exampleName.AppImage&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动以后，可以看到这个界面。&lt;br/&gt;&lt;img src=&quot;http://truffleframework.com/docs/ganache/images/accounts.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很丰满。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我想到一个事情，这里重申一下：我目前的测试开发环境，如果没有交易产生，挖矿不会自动进行。对于比特币和以太坊的正式环境来说，他们会限制出块时间，因为现在他们的交易量都很大，交易就会被拖慢，而不会产生没有交易，到了固定时间就要出个空块的情况。不过也有特例，因为共识算法加上对出块时间的限制，是有可能出现空块的。这很浪费，不过就我目前来看，算是留个思考题吧。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们应该都可以直观的看懂，然后我们将它的网络配置到工程的truffle.js中去。&lt;/p&gt;
&lt;blockquote readability=&quot;5.0307692307692&quot;&gt;
&lt;p&gt;我们仍旧可以使用命令“geth attach &lt;a href=&quot;http://localhost:7545/&quot; class=&quot;uri&quot;&gt;http://localhost:7545&lt;/a&gt;” ，从geth命令行attach到这个ganache EVM网络中去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;truffle-migrate&quot;&gt;truffle migrate&lt;/h3&gt;
&lt;p&gt;配置完成后，继续执行以上命令，可以看到不再发生以上被卡住的情况了，但是不识别我的Helloworld智能合约:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Error: Could not find artifacts for Helloworld.sol from any sources&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续探索...&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;解决方案：居然是我的contract 名字不匹配的原因，因为我当时想统一将工程名、合约文件名都改为首字母大写，但忘记该合约文件内部的contract后面的名字了，以及构造函数，这就像你改了java的类文件名，但没有该内部类名一样，可惜goland的Solidity插件并未报错啊，害的我找了半天，不过以后还是要靠自己多注意了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是，仍然有问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Error encountered, bailing. Network state unknown. Review successful transactions manually.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应该是truffle.js中网络配置的问题。&lt;/p&gt;
&lt;p&gt;继续探索...&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;解决方案：哥们定睛一看，在上面这个表明看起来的error面前，不要先入为主，下面还有一行报错信息：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Error: Helloworld contract constructor expected 1 arguments, received 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来是我的合约内部有问题，我们通过truffle部署的时候不知道如何去给构造函数赋值，当时我们使用Remix的时候是手动修改的WEB3DEPLOY的js代码段，这里我就直接在合约代码中修改吧，最后是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pragma solidity ^0.4.0;

contract Helloworld {
    string content;

    function Helloworld() public {
        content = &quot;hello, world!&quot;;
    }

    function getContent() constant public returns (string){
        return content;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;truffle migrate!&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;liuwenbin@liuwenbin-H81M-DS2:~/work/truffle-workspace/Helloworld$ truffle migrate
Using network 'development'.

Running migration: 2_deploy_contracts.js
  Deploying Helloworld...
  ... 0x391f2c060b1f9cbe7b42493fc858ffa455d40f6e9af754a105092a9ac32e53c3
  Helloworld: 0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4
Saving successful migration to network...
  ... 0x0e8fab8924d93f0b17aa1c9dc58b976089a61e4debcd185dffa2c16e5cc539e9
Saving artifacts...
liuwenbin@liuwenbin-H81M-DS2:~/work/truffle-workspace/Helloworld$ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功！&lt;/p&gt;
&lt;p&gt;对比ganache日志来看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[5:24:49 PM]   Transaction: 0x391f2c060b1f9cbe7b42493fc858ffa455d40f6e9af754a105092a9ac32e53c3
[5:24:49 PM]   Contract created: 0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4
[5:24:49 PM]   Gas usage: 205611
[5:24:49 PM]   Block Number: 7
[5:24:49 PM]   Block Time: Thu Feb 08 2018 17:24:49 GMT+0800 (CST)
[5:24:49 PM]   Transaction: 0x0e8fab8924d93f0b17aa1c9dc58b976089a61e4debcd185dffa2c16e5cc539e9
[5:24:49 PM]   Gas usage: 26981
[5:24:49 PM]   Block Number: 8
[5:24:49 PM]   Block Time: Thu Feb 08 2018 17:24:49 GMT+0800 (CST)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们通过truffle部署一个智能合约，要提交两个块，有两笔交易产生。为什么呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为第一笔交易是来自与Helloworld.sol的创建，第二笔交易是来自于migration，每次部署一个新的合约都要执行这两步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;与合约交互&quot;&gt;与合约交互&lt;/h3&gt;
&lt;p&gt;由于我们不是使用web3.js来部署的智能合约，因此在基于web3.js的以太坊客户端geth中，即使我们attach进去了，仍旧无法与合约实现交互。那么我们只能使用JSON-RPC的方式来与合约交互。&lt;/p&gt;
&lt;p&gt;truffle提供了属于自己的与合约交互的方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;truffle console，一个基本的交互控制台，可以连接任何EVM客户端。如果你已经有了自己的ganache或者geth等EVM的本地环境，那么就可以使用truffle console来交互，所以如果你已经有一个现成的小组共享的开发用EVM，那么使用这个没错。&lt;/li&gt;
&lt;li&gt;truffle develop，一个交互控制台，启动时会自动生成一个开发用区块链环境（其实我认为它与ganache就是一个底层实现机制，都是默认生成10个账户）。如果你没有自己的EVM环境的话，直接使用truffle develop非常方便。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我虽然希望能够得到大一统的简单编写的开发测试环境，但是我并不愿意使用develop模式，下面我们使用console模式来与刚刚部署的Helloworld智能合约进行交互。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;truffle console&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行以后，我们可以敲出Helloworld了，打印出一个json结构，展示了它的各种属性内容。它是一个TruffleContract，内容非常多。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;tip: 上面提到过Solidity的event语法，里面展示了如果针对未使用event的智能合约，要通过var returnValue = exampleContract.foo.call(2);// 通过web3 的message的call来调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们的Helloworld合约并未使用event方法，所以让我尝试一下这种方式来调取：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;truffle(development)&amp;gt; Helloworld.at(&quot;0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4&quot;).getContent.call()
'hello, world!'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;此刻的心情真是扬眉吐气，从来没有一次这么艰难的“helloworld”历程！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;调试合约&quot;&gt;调试合约&lt;/h3&gt;
&lt;p&gt;truffle debug我还没来得及体验，先使用Remix吧，等我日后体验完觉得它不错我再来补充。Remix的debug其实还不错，不过很多人好像用不明白。我这里简单介绍一下吧，当你编写完一个智能合约以后，一般它会自动帮你编译，并且会在下方展示出你的属性，方法（如果没有的话，请尝试去交易的位置把交易和gas配置一下即可），然后点击其中你想调试的方法（注意入参），在控制台会打印出它的执行过程，同时右侧会有一个“debug”的小按钮，点击它（注意要预先在代码中设置断点），然后就可以按行调试了，随着一行行的运行，属性变量的值也会有所改变。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天是2017农历最后一个工作日，此时周围早已心飞扬的同事们呼呼啦啦地走光了，我刚刚完成了这篇文章，孤零零的我却满腹成就感。本篇文章仍旧采取我的以往习惯，采用主线分支的路线，详细介绍了如何开发一个智能合约，这里面把我这一条路线上遇到的所有的坑都趟过了，重点研究了Solidity的语法（当然并不是全面的，我只研究相关的了），智能合约的开发环境，各种新鲜工具的使用，最后着重介绍了智能合约的大杀器——truffle。希望能够对您有所帮助，一起努力！&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;基本全部来自于各种官方文档，stackoverflow，askUbuntu，github issues等网站，没有实体书，这种新知识实体书永远是滞后太多的。&lt;/p&gt;

</description>
<pubDate>Thu, 08 Feb 2018 10:32:00 +0000</pubDate>
<dc:creator>一面千人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Evsward/p/contract.html</dc:identifier>
</item>
</channel>
</rss>