<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python系列之 - 面向对象(1) - 慕沁</title>
<link>http://www.cnblogs.com/ls-2018/p/8804472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ls-2018/p/8804472.html</guid>
<description>&lt;p&gt;python是一门面向对象的编程语言,python中的一切均是对象。 &lt;/p&gt;
&lt;p&gt;有对象就提到类，对象和类就像是儿子和老子的关系，是不可分的一对。&lt;/p&gt;
&lt;p&gt;什么是类 &lt;br/&gt;    类就是具有一些共同特性的事物的统称。好比人类，共有的特性是能说话、能走路、要吃饭、睡觉等共同特性 &lt;br/&gt;什么是对象 &lt;br/&gt;    对象是类的实体，除了有人类的共有特性外也可能还有个体特性，比如两个人张三、李四就是两个不同的对象。&lt;/p&gt;
&lt;p&gt;1 类的定义 &lt;br/&gt;class 类名称()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个people类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People()：
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    python中的类定义分为经典类和新式类，不过这种分类方式是正对python2.x来说的，在python3.x中定义的所有类默认都是新式类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 经典类定义&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClassidClass():
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 新式类定义&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; NewClass(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    虽然在python3中都是新式类,但为了程序的规范,定义类时都采用新式类定义的方法定义类&lt;/p&gt;
&lt;p&gt;2 对象的定义 &lt;br/&gt;   严格说对象不是定义的，而是实例化来的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化对象&lt;/span&gt;
zhangsan = People()
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs python has-numbering&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;3 类成员 &lt;br/&gt;   类的成员分为：字段、属性、方法 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20160225155606689&quot; alt=&quot;类成员分类&quot; width=&quot;522&quot; height=&quot;218&quot;/&gt;&lt;br/&gt;字段： &lt;br/&gt;   当创建完一个类后，系统就在内存中分配一块地址用来保存类信息，当实例化一个对象时，系统会再次开辟一块内存空间用来保存实例化的对象信息，但在实例化对象时，仅将类中的普通字段加载到对象的内存空间，其它的所有类成员地址都保存在类的内存空间中。 &lt;br/&gt;换言之： &lt;br/&gt;普通字段属于对象,在所有对象中都保存一份，通过对象访问 &lt;br/&gt;静态字段属于类，保存在类中，通过类访问 &lt;br/&gt;方法： &lt;br/&gt;   简单的说就是类中定义的函数就是类方法。这个函数和普通的非类中的函数有什么区别呢？类函数(方法)只能被类或类的实例化对象访问，其它对象无法访问。而普通函数可以被任何对象访问。 &lt;br/&gt;在类的方法中有一种比较特殊的方法 init() ,这个交构造函数。当类中有此方法是,实例化一个对象时将自动调用该函数。 &lt;br/&gt;属性： &lt;br/&gt;    和类方法一样，只是在函数的上面多了一个@property装饰器，只要加了这个装饰器名，就成为一个属性。属性在调用时可以不用加括号，而且属性是没有参数的。而方法需要加括号。 &lt;br/&gt;以下为类的所有成员及调用例子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People(object):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 静态字段&lt;/span&gt;
    country = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;china&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 构造函数&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 普通字段&lt;/span&gt;
        self.name =&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0} 说话&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.name))

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 属性&lt;/span&gt;
&lt;span&gt;    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; drink(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0} 喝水&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.name))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化对象&lt;/span&gt;
zhangsan = People(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(zhangsan.name)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方法调用&lt;/span&gt;
&lt;span&gt;zhangsan.talk()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 属性调用&lt;/span&gt;
zhangsan.drink
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类及对象内存分配方式 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20160225172856338&quot; alt=&quot;类及成员内存分配情况&quot;/&gt; &lt;br/&gt;对象zhangsan在实例化是只是将普通字段copy一份到新的内存空间，其它所有属性及方法都存在类空间中。&lt;/p&gt;
&lt;p&gt;4 对象方法调用 &lt;br/&gt;    既然属性及方法存在类中，那么对象调用 talk()方法、drink方法时是如何调用的呢，图中看到对象实例化时存了一份类的地址指针。当调用talk()方法时，实质是：&lt;/p&gt;
&lt;p&gt;zhangsan.talk() = People.talk(zhangsan)&lt;/p&gt;
&lt;p&gt;这就要说到self到底是个什么东西： &lt;br/&gt;    其实从上面讲到的可以看到,self其实就是zhangsan这个对象本身。&lt;/p&gt;
&lt;p&gt;方法分类 &lt;br/&gt;类方法分为3类： &lt;br/&gt;普通方法： 至少有一个 self 默认参数,由实例化对象调用。无任何装饰器. &lt;br/&gt;普通方法可以访问对象属性，也可以访问类属性。&lt;/p&gt;
&lt;p&gt;类方法： 至少有一个 cls 默认参数 ， 由类调用。有@classmethod装饰器。 &lt;br/&gt;类方法只能访问类属性，无法访问对象属性&lt;/p&gt;
&lt;p&gt;静态方法： 没有默认参数，由类调用。有@staticmethod装饰器。 只能访问静态方法中定义的变量。 &lt;br/&gt;无法访问类属性,也无法访问对象属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; People(object):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 静态字段&lt;/span&gt;
    country = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;china&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 构造函数&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 普通字段&lt;/span&gt;
        self.name =&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 普通方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0} 说话&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.name))

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 静态方法&lt;/span&gt;
&lt;span&gt;    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;静态方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类方法&lt;/span&gt;
&lt;span&gt;    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; class_walk(cls):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;类方法：走路&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 属性&lt;/span&gt;
&lt;span&gt;    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; drink(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0} 喝水&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.name))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化对象&lt;/span&gt;
zhangsan = People(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(zhangsan.name)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 普通方法调用&lt;/span&gt;
&lt;span&gt;zhangsan.talk()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类方法调用&lt;/span&gt;
&lt;span&gt;People.class_walk()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 静态方法&lt;/span&gt;
People.eat()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;属性 &lt;br/&gt;属性定义方式： 普通方法加@property装饰器 &lt;br/&gt;属性功能： 实现一些内部计算或逻辑处理，调用时可以实现和字段一样的效果 &lt;br/&gt;属性特性： 普通方法一样定义，但区别是只有一个默认参数 self&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Goods(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 原价&lt;/span&gt;
        self.original_price = 100
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 折扣&lt;/span&gt;
        self.discount = 0.8&lt;span&gt;

    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; price(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实际价格 = 原价 * 折扣&lt;/span&gt;
        new_price = self.original_price *&lt;span&gt; self.discount
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; new_price

p &lt;/span&gt;=&lt;span&gt; Goods()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(p.price)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 80.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;/pre&gt;
&lt;p&gt;属性的@property装饰其实是一个类，这个类构造时有4个参数：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs lasso has-numbering&quot;&gt;property(fget&lt;span class=&quot;hljs-subst&quot;&gt;=&lt;span class=&quot;hljs-literal&quot;&gt;None, fset&lt;span class=&quot;hljs-subst&quot;&gt;=&lt;span class=&quot;hljs-literal&quot;&gt;None, fdel&lt;span class=&quot;hljs-subst&quot;&gt;=&lt;span class=&quot;hljs-literal&quot;&gt;None, doc&lt;span class=&quot;hljs-subst&quot;&gt;=&lt;span class=&quot;hljs-literal&quot;&gt;None) &lt;span class=&quot;hljs-subst&quot;&gt;-&amp;gt; property attribute&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;fget,fset,fdel分别是3个函数用来实现对类字段的属性值进行操作获取值、设置值、删除值 &lt;br/&gt;doc 是描述信息 &lt;br/&gt;还是上面的例子，我们改变一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Goods(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 原价&lt;/span&gt;
        self.original_price = 100
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 折扣&lt;/span&gt;
        self.discount = 0.8&lt;span&gt;

    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; price(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实际价格 = 原价 * 折扣&lt;/span&gt;
        new_price = self.original_price *&lt;span&gt; self.discount
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; new_price

    @price.setter
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; price(self, value):
        self.original_price &lt;/span&gt;=&lt;span&gt; value

    @price.deleter
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; price(self):
        &lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; self.original_price



good &lt;/span&gt;=&lt;span&gt; Goods()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(good.price)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取商品实际价格 调用fget方法  = 80.0&lt;/span&gt;
good.price = 200   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调整商品原价为200，调用fset方法&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(good.price)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; =160.0&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; good.price     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用fdel方法, 删除了类字段 &lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(good.price)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; AttributeError: 'Goods' object has no attribute 'original_pric&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Wed, 11 Apr 2018 23:42:00 +0000</pubDate>
<dc:creator>慕沁</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ls-2018/p/8804472.html</dc:identifier>
</item>
<item>
<title>初学Java Web(4)——Servlet学习总结 - 我没有三颗心脏丶</title>
<link>http://www.cnblogs.com/wmyskxz/p/8804447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/8804447.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-65cb65e46c091671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;经过一段时间的学习，对于Servlet有了新的不一样的见解，在这里做一下总结，将近来学习到的知识总结一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;servlet-的请求流程&quot;&gt;Servlet 的请求流程&lt;/h3&gt;
&lt;ol readability=&quot;6.340082009226&quot;&gt;&lt;li readability=&quot;0.86574074074074&quot;&gt;
&lt;p&gt;&lt;strong&gt;浏览器发出请求：&lt;/strong&gt;&lt;a href=&quot;http://localhost:80/xxx1/xxx2&quot; class=&quot;uri&quot;&gt;http://localhost:80/xxx1/xxx2&lt;/a&gt; （80端口可以默认不写，因为这是http协议默认的端口，平时我们访问https://www.baidu.com/ 时其实访问的是https://www.baidu.com:80/）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器解析请求信息：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;**&lt;a href=&quot;http:**协议名称&quot; class=&quot;uri&quot;&gt;http:**协议名称&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;localhost:&lt;/strong&gt;访问的是互联网中的&lt;strong&gt;哪一台计算机&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;80:&lt;/strong&gt;从主机当中找到&lt;strong&gt;对应 80 端口的程序&lt;/strong&gt; （&lt;strong&gt;这里即为 Tomcat 服务器&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/xxx1:&lt;/strong&gt;当前项目的&lt;strong&gt;上下文路径&lt;/strong&gt; （即在 server.xml 中配置主机时配置的 &lt;strong&gt;path属性&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/xxx2:&lt;/strong&gt;当前&lt;strong&gt;请求的资源名&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解析&lt;/strong&gt; Tomcat 服务器根目录下的 &lt;strong&gt;/config/server.xml&lt;/strong&gt; 文件：&lt;br/&gt;&lt;code&gt;&amp;lt;Context docBase=&quot;D:\javaPros\test\webapp&quot; path=&quot;xxx1&quot; /&amp;gt;&lt;/code&gt;&lt;br/&gt;判断哪一个&lt;code&gt;&amp;lt;Context /&amp;gt;&lt;/code&gt;元素的 &lt;strong&gt;path属性&lt;/strong&gt; 属性为 &lt;code&gt;xxx1&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;若找不到，则返回 &lt;strong&gt;404错误&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若找到了，则解析该&lt;code&gt;&amp;lt;Context /&amp;gt;&lt;/code&gt;元素，得到&lt;code&gt;docBase&lt;/code&gt;属性，获取当前访问 Web 项目的跟的绝对路径：&lt;code&gt;D:\javaPros\test\webapp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;D:\javaPros\test\webapp&lt;/code&gt;下的 &lt;strong&gt;WEB-INF&lt;/strong&gt; 下找到 &lt;strong&gt;web.xml&lt;/strong&gt; 文件&lt;br/&gt;判断 &lt;strong&gt;web.xml&lt;/strong&gt; 文件中是否有 &lt;code&gt;&amp;lt;url-pattern&amp;gt;&lt;/code&gt; 的文本内容为 &lt;strong&gt;/xxx2&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;若找不到，则返回 &lt;strong&gt;404错误&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若找到了，则继续&lt;strong&gt;获取该资源对应 Servlet 类的全限名称：&lt;/strong&gt; xxx.xxx&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;
&lt;p&gt;判断 &lt;strong&gt;Servlet 实例缓存池&lt;/strong&gt; 中是否有 xxx.xxx 的对象&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Map&amp;lt;String,Servlet&amp;gt; cache = ......(Tomcat提供的);
key:存Servlet类的全限定名称
value:该Servlet类的对象.
Servlet obj = cache.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;xxx.xxx&quot;&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(obj==&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
    &lt;span class=&quot;co&quot;&gt;//Servlet实例缓存中没有该类的对象,第一次.&lt;/span&gt;
    GOTO &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;:
}&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;{
    &lt;span class=&quot;co&quot;&gt;//有对象,非第一次.&lt;/span&gt;
    GOTO &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;:
}
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;使用反射&lt;/strong&gt;调用构造器，&lt;strong&gt;创建对应的对象&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;obj = Class.forName(&quot;xxx.xxx&quot;).newInstance();&lt;/code&gt;&lt;br/&gt;把当前创建的 &lt;strong&gt;Servlet 对象&lt;/strong&gt;，存放在缓存之中，&lt;strong&gt;供给下一次的使用.&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;cache.put(&quot;xxx.xxx&quot;,obj);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建 &lt;strong&gt;ServletConfig 对象&lt;/strong&gt;，并调用 &lt;strong&gt;init()&lt;/strong&gt; 方法&lt;br/&gt;&lt;code&gt;obj.init(config);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;创建 &lt;strong&gt;ServletRequest 对象和 ServletResponse 对象&lt;/strong&gt;，并调用 &lt;strong&gt;service()&lt;/strong&gt;方法&lt;br/&gt;&lt;code&gt;obj.service(req,resp);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 &lt;strong&gt;service()&lt;/strong&gt; 方法中对浏览器作出响应操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3 id=&quot;servlet-生命周期&quot;&gt;Servlet 生命周期&lt;/h3&gt;
&lt;p&gt;在 Web 容器中，Servlet 主要经历 4 个阶段，如下图：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-2599bf65a828350d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Servlet 生命周期&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;加载 Servlet：&lt;/strong&gt;当 Tomcat &lt;strong&gt;第一次访问 Servlet&lt;/strong&gt; 的时候，Tomcat 会负责&lt;strong&gt;创建 Servlet 的实例。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化 Servlet：&lt;/strong&gt;当 Servlet 被实例化之后，Tomcat 会调用 &lt;strong&gt;init()&lt;/strong&gt; 方法来初始化这个对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理服务：&lt;/strong&gt;当浏览器&lt;strong&gt;访问 Servlet&lt;/strong&gt; 的时候，Servlet 会调用 &lt;strong&gt;service()&lt;/strong&gt; 方法处理请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;销毁：&lt;/strong&gt;当 &lt;strong&gt;Tomcat 关闭&lt;/strong&gt;或者&lt;strong&gt;检测到 Servlet 要从 Tomcat 删除&lt;/strong&gt;的时候，会自动调用 &lt;strong&gt;destroy()&lt;/strong&gt; 方法，让该实例所占用的资源释放掉。一个 Servlet 如果长时间不被使用的话，也会被 Tomcat 自动销毁。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;简单总结：&lt;/strong&gt;只要访问 Servlet ，就会调用其对应的 &lt;strong&gt;service()&lt;/strong&gt; 方法，&lt;strong&gt;init()&lt;/strong&gt; 方法只会在第一次访问 Serlvet 的时候才会被调用。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;3.2142857142857&quot;&gt;
&lt;p&gt;这一部分参考文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247483680&amp;amp;idx=3&amp;amp;sn=d5380ff58c5077271ac9c43d2d96f6c1&amp;amp;chksm=ebd74021dca0c93733255324df8c1e522dbe36ccaf8c2c4bcca4765113a120eb9851ca0e2442#rd&quot;&gt;这里是链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;servlet-提供处理请求的方法&quot;&gt;Servlet 提供处理请求的方法&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/bbdc459b9187&quot;&gt;前面的文章&lt;/a&gt;里面提到过，广义上，&lt;strong&gt;Servlet&lt;/strong&gt; 即实现了 &lt;strong&gt;Servlet 接口&lt;/strong&gt; 的类，当我们创建一个自定义类，实现 &lt;strong&gt;Servlet 接口&lt;/strong&gt; 的时候，会发现有 5 个方法需要重写，有init【初始化】，destroy【销毁】,service【服务】,ServletConfig【Servlet配置】,getServletInfo【Serlvet信息】。&lt;/p&gt;
&lt;p&gt;这样做的话，我们每次都需要实现 5 个方法，太麻烦了！&lt;/p&gt;
&lt;p&gt;我们可以直接&lt;strong&gt;继承 HttpServlet&lt;/strong&gt; 类，该类已经默认实现了 Servlet 接口中的所有方法，在编写 Servlet 的时候，你只需要&lt;strong&gt;重写你需要的方法&lt;/strong&gt;就好了，并且该类还在原有 Servlet 接口上添加了一些与 HTTP 协议处理相关的方法，比 Servlet 接口的功能&lt;strong&gt;更强大。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Servlet 处理请求的方法一共有三种：&lt;br/&gt;① 实现 &lt;strong&gt;service()&lt;/strong&gt; 方法。&lt;br/&gt;② 重写 &lt;strong&gt;doGet()&lt;/strong&gt; 和 &lt;strong&gt;doPost()&lt;/strong&gt; 方法，并在 &lt;strong&gt;doGet()&lt;/strong&gt; 中添加一句&lt;code&gt;this.doPost(req, resp);&lt;/code&gt;（因为无论是get或post请求提交的数据，处理方式都基本相同，下同）&lt;br/&gt;③ 重写 &lt;strong&gt;doGet()&lt;/strong&gt; 和 &lt;strong&gt;doPost()&lt;/strong&gt; 方法，并在 &lt;strong&gt;doPost()&lt;/strong&gt; 中添加一句&lt;code&gt;this.doGet()(req, resp);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;推荐方式①。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;servlet-是单例的&quot;&gt;Servlet 是单例的&lt;/h3&gt;
&lt;h4 id=&quot;为什么servlet是单例的&quot;&gt;为什么Servlet是单例的&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;浏览器多次对Servlet的请求，&lt;/strong&gt;一般情况下，&lt;strong&gt;服务器只创建一个Servlet对象，&lt;/strong&gt;也就是说，Servlet对象&lt;strong&gt;一旦创建了，&lt;/strong&gt;就会&lt;strong&gt;驻留在内存中，为后续的请求做服务，直到服务器关闭。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;每次访问请求对象和响应对象都是新的&quot;&gt;每次访问请求对象和响应对象都是新的&lt;/h4&gt;
&lt;p&gt;对于&lt;strong&gt;每次访问请求，&lt;/strong&gt;Servlet引擎都会&lt;strong&gt;创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，&lt;/strong&gt;然后将这&lt;strong&gt;两个对象作为参数传递给它调用的Servlet的service()方法，&lt;/strong&gt;service方法再根据请求方式分别调用doXXX方法。&lt;/p&gt;
&lt;h4 id=&quot;线程安全问题&quot;&gt;线程安全问题&lt;/h4&gt;
&lt;p&gt;当多个用户访问Servlet的时候，&lt;strong&gt;服务器会为每个用户创建一个线程。&lt;/strong&gt;当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原则：&lt;/strong&gt;&lt;br/&gt;1. 如果一个变量&lt;strong&gt;需要多个用户共享&lt;/strong&gt;，则应当在访问该变量的时候，&lt;strong&gt;加同步机制synchronized (对象){}&lt;/strong&gt;&lt;br/&gt;2. 如果一个变量&lt;strong&gt;不需要共享，&lt;/strong&gt;则&lt;strong&gt;直接在 doGet() 或者 doPost()定义&lt;/strong&gt;.这样不会存在线程安全问题&lt;/p&gt;

&lt;h3 id=&quot;httpservletrequest-和-httpservletresponse-对象&quot;&gt;HttpServletRequest 和 HttpServletResponse 对象&lt;/h3&gt;
&lt;p&gt;对于&lt;strong&gt;每次访问&lt;/strong&gt;请求，&lt;strong&gt;Servlet引擎&lt;/strong&gt;都会创建一个&lt;strong&gt;新的HttpServletRequest请求对象&lt;/strong&gt;和一个&lt;strong&gt;新的HttpServletResponse响应对象&lt;/strong&gt;，即 request 和 response 对象。&lt;/p&gt;
&lt;p&gt;既然 request 对象代表 http 请求，那么我们&lt;strong&gt;获取浏览器提交过来的数据，就找 request 对象&lt;/strong&gt; 即可。response 对象代表 http 响应，那么我们&lt;strong&gt;向浏览器输出数据，找 response 对象&lt;/strong&gt;即可。&lt;/p&gt;
&lt;h3 id=&quot;httpservletrequest-常用方法&quot;&gt;HttpServletRequest 常用方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;String getContextPath():&lt;/strong&gt;&lt;br/&gt;获取上下文路径,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;String getHeader(String headName):&lt;/strong&gt;&lt;br/&gt;根据指定的请求头获取对应的请求头的值.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;String getRequestURI():&lt;/strong&gt;&lt;br/&gt;返回当期请求的资源名称. 上下文路径/资源名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;StringBuffer getRequestURL():&lt;/strong&gt;&lt;br/&gt;返回浏览器地址栏的内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;String getRemoteAddr():&lt;/strong&gt;&lt;br/&gt;返回请求服务器的客户端的IP&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;获取请求参数的方法&quot;&gt;获取请求参数的方法：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;String getParameter(String name):&lt;/strong&gt;&lt;br/&gt;根据参数名称,获取对应参数的值.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;String[] getParameterValues(String name):&lt;/strong&gt;&lt;br/&gt;根据参数名称,获取该参数的多个值.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Enumeration getParameterNames():&lt;/strong&gt;&lt;br/&gt;获取所有请求参数的名字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Map getParameterMap():&lt;/strong&gt;&lt;br/&gt;返回请求参数组成的Map集合.&lt;br/&gt;&lt;strong&gt;key:&lt;/strong&gt;参数名称&lt;br/&gt;&lt;strong&gt;value:&lt;/strong&gt;参数值,封装在String数组中.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;httpservletresponse-常用方法&quot;&gt;HttpServletResponse 常用方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;OutputStream getOutputStream():&lt;/strong&gt;&lt;br/&gt;获取字节输出流:&lt;strong&gt;文件下载&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Writer getWriter():&lt;/strong&gt;&lt;br/&gt;获取字符输出流:&lt;strong&gt;输出内容&lt;/strong&gt;&lt;br/&gt;设置文件输出的编码格式和内容类型：&lt;code&gt;resp.setContentType(&quot;text/html;charset=utf-8&quot;);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;get-和-post-的区别&quot;&gt;GET 和 POST 的区别&lt;/h3&gt;
&lt;p&gt;要知道，GET 和 POST 都是请求方式&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;&lt;strong&gt;GET：&lt;/strong&gt;&lt;br/&gt;浏览器器地址栏：&lt;code&gt;http://localhost/test.html&lt;/code&gt;&lt;strong&gt;?name=wmyskxz&amp;amp;sex=male&lt;/strong&gt;&lt;br/&gt;这里提交了两个参数，一个是&lt;code&gt;name&lt;/code&gt;属性值为&lt;code&gt;wmyskxz&lt;/code&gt;，另一个是&lt;code&gt;sex&lt;/code&gt;属性值为&lt;code&gt;male&lt;/code&gt;，这是一种直接的请求方式，在请求资源后面跟上 &lt;strong&gt;?&lt;/strong&gt; 符号与参数连接，其他的参数使用 &lt;strong&gt;&amp;amp;&lt;/strong&gt; 符号连接。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br/&gt;1.暴露请求信息，&lt;strong&gt;不安全&lt;/strong&gt;&lt;br/&gt;2.请求信息不能超过&lt;strong&gt;1kb&lt;/strong&gt;，可传输的信息有限，不能上传图片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST：&lt;/strong&gt;&lt;br/&gt;浏览器地址栏：&lt;code&gt;http://localhost/test.html#&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br/&gt;1.隐藏了请求信息，&lt;strong&gt;较安全&lt;/strong&gt;（但仍可以通过相关工具访问到数据）&lt;br/&gt;2.POST 方式&lt;strong&gt;没有限制&lt;/strong&gt;请求的数据大小，可以做图片的上传&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;但并不是所有的数据都需要使用 POST 请求来完成，事实上，GET 请求方式会比 POST 请求更快，当数据小并且安全性要求不是那么高的时候，GET 仍然是很好的选择.(并且 GET 相较 POST 简单)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;请求中文乱码的处理&quot;&gt;请求中文乱码的处理&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;Tomcat 服务器&lt;/strong&gt;中，接受请求的时候，&lt;strong&gt;默认的编码方式为 ISO-8859-1&lt;/strong&gt;，而该编码方式只占一个字节，不支持中文（两个字节），所以当我们做请求的时候，会出现乱码的问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;br/&gt;1.对乱码使用 &lt;strong&gt;ISO-8859-1&lt;/strong&gt; 解码，转换成&lt;strong&gt;byte数组&lt;/strong&gt;，恢复为二进制&lt;br/&gt;&lt;code&gt;byte[] data = name.getBytes(&quot;ISO-8859-1&quot;);&lt;/code&gt;&lt;br/&gt;2.对byte数组重新进行 UTF-8 编码：&lt;br/&gt;&lt;code&gt;name = new String(data,&quot;UTF-8&quot;);&lt;/code&gt;&lt;br/&gt;但是这样会出现一个问题，那就是当表单数据太多的时候，这样反复解码-编码，会很繁琐。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终极解决方案：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;1.对于 POST 请求：&lt;/strong&gt;&lt;br/&gt;设置请求的编码方式：&lt;code&gt;request.setCharacterEncoding(&quot;UTF-8&quot;);&lt;/code&gt;&lt;br/&gt;&lt;strong&gt;注意：&lt;/strong&gt;必须在获取&lt;strong&gt;第一个参数之前设置&lt;/strong&gt;，并且该方式&lt;strong&gt;只对 POST 方式有效。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2.对于 GET 请求：&lt;/strong&gt;&lt;br/&gt;重新设置 Tomcat 的编码方式，修改 Tomcat 的配置文件:&lt;br/&gt;&lt;code&gt;Tomcat根目录/conf/server.xml(修改端口的那一行)&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-cd366b295c8ed531.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;servlet-细节&quot;&gt;Servlet 细节&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1.一个 Servlet 可以有&lt;strong&gt;多个&lt;/strong&gt; &lt;code&gt;&amp;lt;url-pattern&amp;gt;&lt;/code&gt; ，可以使用多个资源名称找到当前的 Servlet&lt;/li&gt;
&lt;li&gt;2.配置 Servlet 可以使用&lt;strong&gt;通配符&lt;/strong&gt;（*）&lt;br/&gt;&lt;code&gt;*&lt;/code&gt;表示任意字符&lt;br/&gt;&lt;code&gt;/*&lt;/code&gt;：可以使用&lt;strong&gt;任意的字符&lt;/strong&gt;访问当前的 Servlet&lt;br/&gt;&lt;code&gt;*.xxx&lt;/code&gt;：如 wmyskxz.wudi&lt;/li&gt;
&lt;li&gt;3.&lt;strong&gt;自定义的 Servlet 的 &lt;code&gt;&amp;lt;servlet-name&amp;gt;&lt;/code&gt; 不能够为 default ，&lt;/strong&gt;使用它会造成项目下面的静态资源找不到，在 &lt;code&gt;Tomcat/conf/web.xml&lt;/code&gt; 文件中配置一个名字为default的Servlet,该Servlet在负责访问项目下的静态资源&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-23070ab172726a2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;web.xml 中配置的默认项&quot;/&gt;&lt;/li&gt;
&lt;li&gt;4.关于 &lt;strong&gt;Servlet 的初始化操作，&lt;/strong&gt;如果初始化操作非常的耗时，那么第一个请求的用户的用户体验就非常差&lt;br/&gt;&lt;strong&gt;解决思路：&lt;/strong&gt;将初始化操作&lt;strong&gt;向前移,&lt;/strong&gt;在服务器启动的时候执行 Servlet 的初始化&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-afae824b9279c9ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;---&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;通过注解配置-servlet&quot;&gt;通过注解配置 Servlet&lt;/h3&gt;
&lt;p&gt;这是 Servlet 3.0 提出的新特性，支持注解配置，这大大简化了我们的工作。&lt;/p&gt;
&lt;p&gt;在之前的开发工作中，我们总是去 &lt;code&gt;web.xml&lt;/code&gt; 文件中进行配置，至少会出现8行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-1e9520edba4da3bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;web.xml 中配置 Servlet&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而当一个项目中存在&lt;strong&gt;很多 Servlet&lt;/strong&gt; ，那么配置文件就会变得&lt;strong&gt;非常臃肿，不便于后期的维护，&lt;/strong&gt;在 Servlet 3.0 推出之后，我们可以使用&lt;strong&gt;注解来配置 Servlet，&lt;/strong&gt;上面 8 行的配置可以简化为下面的简单的注解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-9bb5cb4ed2098464.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者也可以使用属性 &lt;code&gt;value&lt;/code&gt; 定义访问的 URL，&lt;strong&gt;只有 URL 这个属性是必要的，&lt;/strong&gt;&lt;code&gt;name&lt;/code&gt; 是可以缺省的值，而默认的 &lt;code&gt;value&lt;/code&gt; 也可以省略不写，所以可以简写成：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@WebServlet&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/foreServlet&quot;&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h3 id=&quot;web-组件之间的跳转方式&quot;&gt;Web 组件之间的跳转方式&lt;/h3&gt;
&lt;h4 id=&quot;请求转发forward&quot;&gt;&lt;strong&gt;1.请求转发（forward）&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;又叫做&lt;strong&gt;直接转发方式，&lt;/strong&gt;客户端和浏览器&lt;strong&gt;只发出一次请求，&lt;/strong&gt;Servlet、HTML、JSP或其它信息资源，由&lt;strong&gt;第二个信息资源响应该请求，&lt;/strong&gt;在请求对象request中，保存的对象对于&lt;strong&gt;每个信息资源是共享的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如：从 AServlet 请求转发到 BServlet&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-881fc9bb05d46ac8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;request.&lt;span class=&quot;fu&quot;&gt;getRequestDispatcher&lt;/span&gt;(path).&lt;span class=&quot;fu&quot;&gt;forward&lt;/span&gt;(request, response);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;em&gt;参数：&lt;/em&gt;&lt;code&gt;path&lt;/code&gt;，要跳转到的资源路径：&lt;strong&gt;上下文路径 / 资源路径&lt;/strong&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;1.地址栏中的地址【不会】改变&lt;/strong&gt;&lt;br/&gt;通常看作是服务端的跳转&lt;br/&gt;&lt;strong&gt;2.只有一个请求&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;3.资源是共享的，&lt;/strong&gt;也就是说在两个 Servlet 中可以共享请求的资源&lt;br/&gt;可以通过&lt;code&gt;request.setAttribute(String var1,Object var2)&lt;/code&gt;&lt;strong&gt;设置要共享的数据资源&lt;/strong&gt;，并通过&lt;code&gt;request.getAttribute(String var1);&lt;/code&gt;来&lt;strong&gt;获取传递的资源&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;4.【可以】访问 WEB-INF 中的资源&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;WEB-INF&lt;/strong&gt; 文件夹是 Java Web 应用的&lt;strong&gt;默认安全目录，&lt;/strong&gt;即客户端无法直接访问，只有服务端可以访问的目录。&lt;br/&gt;如果想在页面中&lt;strong&gt;直接访问&lt;/strong&gt;其中的文件，&lt;strong&gt;必须通过web.xml文件&lt;/strong&gt;对要访问的文件进行&lt;strong&gt;相应映射&lt;/strong&gt;才能访问。&lt;br/&gt;&lt;strong&gt;注意：&lt;/strong&gt;在实际的开发中，可以把不希望用户直接访问到（通过浏览器输入地址栏）的网页放在文件夹中&lt;strong&gt;通过此方式访问。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;5.请求转发【不能】跨域访问&lt;/strong&gt;&lt;br/&gt;所谓的同域，是指&lt;strong&gt;域名，协议，端口均相同&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;url-重定向redirect&quot;&gt;2.URl 重定向（redirect）&lt;/h4&gt;
&lt;p&gt;又叫做&lt;strong&gt;间接转发方式（Redirect）&lt;/strong&gt;实际是&lt;strong&gt;两次HTTP请求，&lt;/strong&gt;服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。&lt;/p&gt;
&lt;p&gt;比如:从AServlet重定向到BServlet&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-c49539085575bc26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;请求包含include&quot;&gt;3.请求包含（include）&lt;/h4&gt;
&lt;hr/&gt;&lt;h3 id=&quot;mvc-模式&quot;&gt;MVC 模式&lt;/h3&gt;
&lt;p&gt;MVC 是一种分层的设计模式 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;M 代表 模型（Model）&lt;/strong&gt;&lt;br/&gt;模型是什么呢？ 模型就是&lt;strong&gt;数据，&lt;/strong&gt;就是dao,bean&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;V 代表 视图（View）&lt;/strong&gt;&lt;br/&gt;视图是什么呢？ 就是网页, JSP，用来&lt;strong&gt;展示模型中的数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C 代表 控制器（controller)&lt;/strong&gt;&lt;br/&gt;控制器是什么？ &lt;strong&gt;控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这部分可以参考一下&lt;a href=&quot;http://how2j.cn/k/mvc/mvc-tutorials/561.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.3290322580645&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;@我没有三颗心脏&lt;br/&gt;CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq939419061&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq939419061&lt;/a&gt;&lt;br/&gt;简书：&lt;a href=&quot;http://www.jianshu.com/u/a40d61a49221&quot; class=&quot;uri&quot;&gt;http://www.jianshu.com/u/a40d61a49221&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 11 Apr 2018 23:08:00 +0000</pubDate>
<dc:creator>我没有三颗心脏丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmyskxz/p/8804447.html</dc:identifier>
</item>
<item>
<title>谈程序员如何做好业务 - 子慕大诗人</title>
<link>http://www.cnblogs.com/1wen/p/8781281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1wen/p/8781281.html</guid>
<description>&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　技术能做两种事情，通过技术实现业务和通过技术支持技术。我们大部分时候做的是前者，养活我们的大部分也是业务。  近两个月，作为项目负责人角色从0到1经历了新项目的几个版本迭代，跨入了部分新领域，也有一定收获，对如何做好业务也比以前有了更深的理解，所以作此博客记录项目中经历的事情，和自己对业务的认识。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　从原公司转到兄弟公司，负责一个要求快速产出的新项目，团队人员也是从其他项目组过来支援的。  临近年关，2月初开始开发，3月初上线，中间还有过年的时间。  公司很重视，不能延期。  事态紧迫，研发部门领导综合考虑，过年加班才能赶上进度，因此在一开始就找到愿意过年加班的同事，并且向公司上层申请了加班奖金。  技术方面，需要申请两个公众号，公众号申请需要时间；涉及和另一个系统打通，需要对方支持和开发对接模块，文章后面称之为B系统。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;面临一些问题&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我对B系统不熟悉&lt;/li&gt;
&lt;li&gt;对团队人员不熟悉&lt;/li&gt;
&lt;li&gt;对公司的框架不熟悉&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;反正就是干&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　不熟悉的都可以很快熟悉起来，同事也可以协助自己。这种境况下，是一种挑战，也是能逼迫自己去更快融入环境。不怂～&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201804/623144-20180411201737672-1996925053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;砍需求&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　团队合计了一下，按照初版的需求，即便过年加班也做不完，不能保证3月初上线，于是我们还是和需求方讨论，把非核心的需求一个个砍了，砍到最后我们觉得还比较轻松了，但实际的工作量仍然很大。  我们往往在拿到一个需求的时候，第一反应都会低谷它带来的工作量。  因为细节还未完善，很多事情在开发过程中才会发现、沟通、解决。  当我们把零散的功能和页面做完，最后整合直到完全跑通整个流程，这期间也会花费很多时间。  无论如何，项目千万不能延期，要延期也不能是因为前期估算不准导致的，一旦估算时间定了，跪着也要如期上线。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;思维转化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　最开始，在某些方面，自己都有一点缺少主动性。  当时几个同事在旁边不远讨论B系统需求的时候没叫上我。  也是因为才来，其他同事对我不熟悉，我自己包括大家都没有意识到我是项目负责人，我对自己的边界也有点模糊，我认为主要还是技术负责人。  看到他们在讨论，自己觉得好像没叫我，应该没我什么事，领导看到了，说我是负责人，那么多人讨论我得去听。  到后来，我也就明白了，涉及到负责的项目不管是什么事情，我都得站出来，否则怎么能称之为负责人，同事也不会信服这样的负责人。&lt;/p&gt;
&lt;p&gt;　　当一个技术人员，开发了一个系统，并且更全面的了解需求的时候，那他对整个系统的理解应该是超越产品的，我认为。  在项目开发过程中，我和产品发生了小小的分歧，其实就是一个文案的问题，那个文案可能会造成混乱或者误解。  从产品的角度，是我们太程序员思维了，作为销售渠道是能理解的，从我的角度，虽然能理解，但是概念有重合，需要思维转化，不直观，容易造成系统使用错误。  不纠结这个细节，问题在于我的矛盾，因为我平时做事想的多，提的多，但也知道自己的想法不一定都是对的，又出现了双方都不能说服对方的情况。  我后来想了下，如果对方已经把理由说清楚了，自己觉得自己的方案还是更好，那自己又有拍板的权利，就拍板吧。  如果对方有那个权利，就让对方拍板吧，否则就太浪费时间和精力了。  拍板之前至少要思考对方的想法，不能完全自己专断，同时也要时刻对自己保持怀疑。 &lt;/p&gt;

&lt;h2&gt;&lt;span&gt;加班&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　也是为了保证进度，今年过年团队部分同事，我们只休息了3天，公司放假是9天。  牺牲了假期，但是在上线后，我们确实也得到了相应的奖金。  领导说到做到，公司也体恤员工，这样的加班至少对我来说也是值得的。  加班这个事情，对我们团队来说，是一直保持一种可持续化发展的态度。  996是底线，一般都没有打破过，大部分的时间不会达到996的水平，  通宵就更少了。  但是团队的战力并不差，我觉得这样的状态刚刚好。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;市场部沟通&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　在项目第一版本上线以后，我们很快开始规划第二版，这次我和产品同事参加了和市场部门的需求讨论。  市场部门的需求一般要求快快快，他们面临业绩压力，自然这种压力也会倾斜到我们研发部门。  大家应该也知道一些段子：销售出去卖产品，给客户说一周之类就能搞定，然后签了合同，最后告诉研发部门，合同已经签了，预订金已收，时间就这个点，剩下一堆想离职的程序猿......  开个玩笑，当然我们没有出现这种事情~  总之我们需要和市场部门的对接人保持紧密沟通。 这次我们是和市场部门领导沟通的需求，连着几天拉着过需求，总体还算顺利，梳理的也还是很清楚。  其实和对方部门领导直接沟通，算成本比较低的。  如果说对方领导派一个中间人来对接的话，这对我们的工作量、时间安排、心理压力都会增加很多，毕竟他不能拍板，需求也不是直接来自于他。  &lt;/p&gt;
&lt;p&gt;　　因为和B系统强相关的缘故，市场部门给B系统提需求的时候，不知道涉及到我们系统，在一次沟通中，发现了一个需要和B系统对接的新需求问题，庆幸的是当时B系统的新需求和我们的新需求都没上线，所以还没造成严重的生产事故，这次以后，B系统有新需求我都得了解了，要避免系统间的风险。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;变化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　迭代了几个小版本后，现在因为公司战略需要，团队被分散到其他项目做支持，项目迭代会暂停一段时间。  但是项目依旧要运营，B系统还会迭代，B系统的迭代需求可能和我们的系统冲突，或者造成bug。  所以B系统一旦有迭代，我都得了解他们的需求，评估对我们系统是否有影响。 &lt;/p&gt;

&lt;h2&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　业务是饭碗，业务做不好，其他什么都别谈。  两年多以前有一个项目，因为自己的问题，导致了延期，对自己各方面的影响都非常不好，于是决心再也不能犯同样的错误了。  对于任何人而言，个人原因延期都是职场大忌，犯不得啊～  对于初中级前端要想有更大的提升，业务方面的能力要达到游刃有余才行，否则飞上去也会摔下来。  做好业务的标准是什么呢？我也不知道，列出一些我能很快想到的点吧：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是否延期&lt;/li&gt;
&lt;li&gt;是否了解整个系统和细节&lt;/li&gt;
&lt;li&gt;是否在写代码以前就能预见到细节问题&lt;/li&gt;
&lt;li&gt;核心逻辑能否一次性思考完善，不出逻辑漏洞&lt;/li&gt;
&lt;li&gt;带动其他同事，推动整个业务前进，正能量&lt;/li&gt;
&lt;li&gt;同样的错误最多只犯一次&lt;/li&gt;
&lt;li&gt;产品思维，关注用户体验&lt;/li&gt;
&lt;li&gt;合理的时间，可持续性，工作量饱和&lt;/li&gt;
&lt;li&gt;及时汇报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　&lt;span&gt;都看到这里了，要不点个赞～&lt;/span&gt;　　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201804/623144-20180411201910362-1461495632.png&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 11 Apr 2018 16:53:00 +0000</pubDate>
<dc:creator>子慕大诗人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1wen/p/8781281.html</dc:identifier>
</item>
<item>
<title>从抖音关闭评论，看服务治理的重要性 - 陈树义</title>
<link>http://www.cnblogs.com/chanshuyi/p/the_important_of_soa_from_douyin.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanshuyi/p/the_important_of_soa_from_douyin.html</guid>
<description>&lt;p&gt;4月10日，广电总局责令今日头条永久关停「内涵段子」等低俗视听产品。&lt;/p&gt;
&lt;p&gt;该消息传出后，大量内涵段子用户涌入抖音，以统一头像和内涵段子风格的评论迅速占领抖音热门视频评论区。&lt;/p&gt;
&lt;p&gt;而就在昨晚 23 点 40 左右，抖音关闭了评论的所有功能。虽然页面显示有几千条评论，但是当点开评论的时候却发现没有评论内容。&lt;/p&gt;
&lt;p&gt;之后抖音发布官方声明，表示服务器维护停止直播和评论功能，等待升级完成之后再重新开放。而在 4 月 11 日，今日头条官方公众号发表了一篇致歉信。今日头条创始人张一鸣表示，接受处罚，所有责任在自己。接下来，要将正确的价值观融入技术和产品，并要整改社区秩序，优化社区氛围。&lt;/p&gt;
&lt;p&gt;作为技术人员，我不禁在想：抖音的用户量如此之大，技术上如何能够如此快速地关闭所有评论功能？&lt;/p&gt;
&lt;p&gt;我们可以猜想，以抖音这种数量级的用户，抖音后台早已实现了各个功能模块的服务化拆分，并且进行了服务治理。而从今日头条对外的技术分享来看，今日头条确实是这么做的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们使用 Go 语言研发了内部的微服务框架 kite，协议上完全兼容 Thrift。以五元组为基础单元，我们在 kite 框架上集成了服务注册和发现，分布式负载均衡，超时和熔断管理，服务降级，Method 级别的指标监控，分布式调用链追踪等功能。目前统一使用 kite 框架开发内部 Go 语言的服务，整体架构支持无限制水平扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的技术分享片段，我们可以知道今日头条内部使用了 Go 语言开发的 Kite 微服务框架，并且实现了服务监控、服务熔断、服务降级、服务指标监控等功能。&lt;/p&gt;
&lt;p&gt;所以我们可以猜想：当 4 月 10 日，广电总局宣布勒令关闭内涵段子，大量段友涌入抖音评论区的时候，抖音评论接口调用数暴增，相应的服务监控报警，相关的技术人员收到信息进行紧急处理。此时技术人员便会排查评论接口调用暴增的原因，并且商量对应的对策。&lt;/p&gt;
&lt;p&gt;到了 4 月 10 日 23 点 40 分左右，或许因为担心事态进一步发酵，所以抖音选择将评论接口进行服务熔断。所有请求评论列表的请求，全部返回空的评论数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实所谓的「服务熔断」指的就是当某个指标达到一定程度时，服务接口自动熔断，对所有请求该接口的消费者都返回一个默认值。&lt;/strong&gt;例如抖音一定时间内评论接口调用数达到100万次，自动返回空的评论数据。当然了，服务熔断也可以手动触发。&lt;/p&gt;
&lt;p&gt;现在回头想一想，抖音之所以能快速地处理好这件事情，很大一部分是服务治理的功劳。试想一下，如果没有服务监控，那么技术人员就无法第一时间获取异常信息。那段友就会在抖音评论区一直刷屏，这时时态很可能得不到平息，反而会越演越烈，抖音很可能会成为下一个内涵段子，这对今日头条的打击将是巨大的。&lt;/p&gt;
&lt;p&gt;正是因为服务治理对于突发情况的处理效果出众，所以当一个公司产品达到一定数量级之后，服务治理一定是绕不过的一个话题。&lt;/p&gt;
&lt;p&gt;而服务治理不仅仅在处理突发事件效果出众，对于线上问题处理，服务监控也能发挥很大的作用。笔者之前的公司有一个完善的服务监控系统，它能统计各个接口的异常率，并且能针对每个异常请求显示出完整的分布式调用链，这对于开发人员排查线上问题非常有用。&lt;/p&gt;
&lt;p&gt;服务监控、服务熔断其实只是服务治理很小的一部分，本文也只是简略地提了一下。希望这篇文章，能让更多的技术人了解到热点背后的技术，提炼出对于技术更深刻的理解。&lt;/p&gt;

</description>
<pubDate>Wed, 11 Apr 2018 16:12:00 +0000</pubDate>
<dc:creator>陈树义</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chanshuyi/p/the_important_of_soa_from_douyin.html</dc:identifier>
</item>
<item>
<title>ShellCode瘦身的艺术0_HASH - Reginald.S</title>
<link>http://www.cnblogs.com/Reginald-S/p/8797585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Reginald-S/p/8797585.html</guid>
<description>&lt;p&gt;&lt;strong&gt;写在前面的话：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面几篇文章，我们介绍了如何获取kernerl32.dll导出函数地址的方法；&lt;/p&gt;
&lt;p&gt;并在此基础上，编写了ShellCode，实现了动态加载DLL以及解析API地址；&lt;/p&gt;
&lt;p&gt;但是，似乎还称不上Perfect，我们能够获取到LoadLibrary和GetProcAddress，事情就结束了吗？&lt;/p&gt;
&lt;p&gt;我们仍然需要给他们push一些个参数，那些API的名字，占用了我们ShellCode的大部分空间；(如果API较多的话)&lt;/p&gt;
&lt;p&gt;这使得我们的ShellCode看上去不那么美妙，因此，对API做HASH势在必行；&lt;/p&gt;
&lt;p&gt;那也许有朋友会问：做了HASH，总有一处还原的地方吧，如果不还原，那程序里就一定有字符串存在；否则，GetProcAddress怎么玩呢？&lt;/p&gt;
&lt;p&gt;也因此，我们对Kernel32.dll导出表的解析，就需要一般化一下了；让它不止适应于kernel32.dll，而是windows下的任何32位的PE文件；&lt;/p&gt;
&lt;p&gt;(64位类似，解析PE，都一样，笔者就拿32位举例了，有兴趣的朋友也可以自行解析)&lt;/p&gt;
&lt;p&gt;如果能够做到，那我们的HASH才会有意义，因为，ENT里就有API名字了；&lt;/p&gt;
&lt;p&gt;因此，在开始HASH运算前，我们先来搞一下之前的那部分程序；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;零：导出表一般化解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0. 先来看下PE的DOS头结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt; _IMAGE_DOS_HEADER {      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DOS .EXE header&lt;/span&gt;
    WORD   e_magic;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Magic number&lt;/span&gt;
    WORD   e_cblp;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Bytes on last page of file&lt;/span&gt;
    WORD   e_cp;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Pages in file&lt;/span&gt;
    WORD   e_crlc;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Relocations&lt;/span&gt;
    WORD   e_cparhdr;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Size of header in paragraphs&lt;/span&gt;
    WORD   e_minalloc;                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Minimum extra paragraphs needed&lt;/span&gt;
    WORD   e_maxalloc;                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Maximum extra paragraphs needed&lt;/span&gt;
    WORD   e_ss;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initial (relative) SS value&lt;/span&gt;
    WORD   e_sp;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initial SP value&lt;/span&gt;
    WORD   e_csum;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Checksum&lt;/span&gt;
    WORD   e_ip;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initial IP value&lt;/span&gt;
    WORD   e_cs;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initial (relative) CS value&lt;/span&gt;
    WORD   e_lfarlc;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; File address of relocation table&lt;/span&gt;
    WORD   e_ovno;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Overlay number&lt;/span&gt;
    WORD   e_res[&lt;span&gt;4&lt;/span&gt;];                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reserved words&lt;/span&gt;
    WORD   e_oemid;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; OEM identifier (for e_oeminfo)&lt;/span&gt;
    WORD   e_oeminfo;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; OEM information; e_oemid specific&lt;/span&gt;
    WORD   e_res2[&lt;span&gt;10&lt;/span&gt;];                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reserved words&lt;/span&gt;
    LONG   e_lfanew;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; File address of new exe header&lt;/span&gt;
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们需要关注的是最后一个字段，这个里的内容是NT头的偏移，首先，看下，这个字段在本结构体的偏移60(0x3C)&lt;/p&gt;
&lt;p&gt;也就是说，[BaseAddr+0x3C]就是e_lfanew的值，因此，NT头的首地址BaseAddr+e_lfanew;&lt;/p&gt;
&lt;p&gt;那再看下NT头的结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, &lt;/span&gt;*&lt;span&gt;PIMAGE_NT_HEADERS32;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NT头中的文件头20Byte&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, &lt;/span&gt;*&lt;span&gt;PIMAGE_FILE_HEADER;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NT头中的扩展头&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_OPTIONAL_HEADER {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Standard fields.
    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NT additional fields.
    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, &lt;/span&gt;*&lt;span&gt;PIMAGE_OPTIONAL_HEADER32;


typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, &lt;/span&gt;*&lt;span&gt;PIMAGE_DATA_DIRECTORY;

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们要找什么呢，导出表的RVA，导出表是扩展头里的第0号元素；因此，计算出的数据目录表[导出表]相对NT头的偏移，就是0x78;&lt;/p&gt;
&lt;p&gt;至此，我们通过分析DOS头和NT头结构，得到了下面的信息：&lt;/p&gt;
&lt;p&gt;0、e_lfanew = [BaseAddr+0x3C]&lt;/p&gt;
&lt;p&gt;1、NTStartVA：BaseAddr + e_lfnew&lt;/p&gt;
&lt;p&gt;2、ExportStartRVA：[NTStartVA + 0x78]&lt;/p&gt;
&lt;p&gt;3、ExportStartVA：BaseAddr + ExportStartRVA&lt;/p&gt;
&lt;p&gt;到这一步，接下来就需要看下导出表的结构了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RVA from base of image&lt;/span&gt;
    DWORD   AddressOfNames;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RVA from base of image&lt;/span&gt;
    DWORD   AddressOfNameOrdinals;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RVA from base of image&lt;/span&gt;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要的字段，EAT/ENT/EOT，我们在上边的分析中，其实已经得到了这个导出表结构体的首地址了，就是ExportStartVA，那就简单了&lt;/p&gt;
&lt;p&gt;4、EATRVA = [ExportStartVA + 0x1C]  -&amp;gt; EAT = BaseAddr + EATRVA&lt;/p&gt;
&lt;p&gt;5、ENTRVA = [ExportStartVA + 0x20]  -&amp;gt; ENT = BaseAddr + ENTRVA&lt;/p&gt;
&lt;p&gt;6、EOTRVA = [ExportStartVA + 0x24]  -&amp;gt; EOT = BaseAddr + EOTRVA&lt;/p&gt;
&lt;p&gt;至此，分析结束，开始编写代码；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、代码(为了便于理解，咱们封装成一些裸函数)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0、获取基址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; __declspec(naked) GetKernelBase() {
    _asm {
        push ebp;
        mov ebp, esp;
        sub esp, &lt;/span&gt;&lt;span&gt;0x0C&lt;/span&gt;&lt;span&gt;;
        mov eax, fs:[&lt;/span&gt;&lt;span&gt;0x30&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PEB&lt;/span&gt;
        mov eax, [eax + &lt;span&gt;0xC&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; LDR&lt;/span&gt;
        mov eax, [eax + &lt;span&gt;0xC&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; InLoadOrderModuleList, exe&lt;/span&gt;
        mov eax, [eax]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; nt.dll&lt;/span&gt;
        mov eax, [eax]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; kernel32.dll&lt;/span&gt;
        mov eax, dword ptr ds : [eax + &lt;span&gt;0x18&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BaseAddr;&lt;/span&gt;
&lt;span&gt;        mov esp, ebp;
        pop ebp;
        ret;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1、解析导出表，部分关键代码(全部代码，考虑下，还是在我们写完HASH算法后贴出来)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;_asm{
        &lt;/span&gt;&lt;span&gt;push&lt;/span&gt; ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; ebp, esp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;sub&lt;/span&gt; esp, 0x10&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;push&lt;/span&gt; ebx&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;push&lt;/span&gt; ecx&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;push&lt;/span&gt; esi&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;push&lt;/span&gt; edi&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;        
        ...
    
        &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt; [ebp - 0x4], eax&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // [ebp - 0x4] -&amp;gt; BaseAddr&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; eax, [eax + 0x3C]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // e_lfanew&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; eax, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // NTStartVA&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; eax, [eax + 0x78]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ExportStartRVA&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; eax, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ExportStart_VA&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ebx, [eax + 0x1C]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EATRVA&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; ebx, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EAT&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; [ebp - 0x8], ebx&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // [ebp - 0x8] -&amp;gt; EAT&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ebx, [eax + 0x20]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ENTRVA&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; ebx, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ENT&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; [ebp - 0xC], ebx&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // [ebp - 0xC] -&amp;gt; ENT&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ebx, [eax + 0x24]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EOTRVA&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; ebx, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EOT&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; [ebp - 0x10], ebx&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // [ebp - 0x10] -&amp;gt; EOT&lt;/span&gt;
&lt;span&gt;        
        ...

        &lt;/span&gt;&lt;span&gt;pop&lt;/span&gt; edi&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;pop&lt;/span&gt; esi&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;pop&lt;/span&gt; ecx&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;pop&lt;/span&gt; ebx&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; esp, ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;pop&lt;/span&gt; ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;ret&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、接下来就要考虑如何实现HASH算法了&lt;/p&gt;
&lt;p&gt;要求：尽量简单，又不失功能；(不同的API的HASH碰撞几率越小越好，同时ShellCode里，要兼顾体积)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*
* @1 API
* @2 Length
*/
void __declspec(naked) ApiHash() {
    _asm {
        &lt;/span&gt;&lt;span&gt;push&lt;/span&gt; ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; ebp, esp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;sub&lt;/span&gt; esp, 0x8&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; dword ptr[ebp - 0x4], 0x6B821B17&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // Init Hash Value&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; dword ptr[ebp - 0x8], &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // Init Local Var&lt;/span&gt;
        &lt;span&gt;jmp&lt;/span&gt; short _begin&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;_loop:&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; eax, [ebp + 0x8]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // eax = srcApi&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; eax, 0x1&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // eax = srcApi + 1&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt;[ebp + 0x8], eax&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // srcApi++&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ecx, [ebp - 0x8]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ecx = i&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; ecx, 0x1&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ecx += 1&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt;[ebp - 0x8], ecx&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // i++&lt;/span&gt;

    &lt;span&gt;_begin:&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; edx, [ebp - 0x8]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // edx = i&lt;/span&gt;
        &lt;span&gt;cmp&lt;/span&gt; edx, [ebp + 0xC]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // edx vs len&lt;/span&gt;
        &lt;span&gt;jnb&lt;/span&gt; short _end&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // if (edx &amp;gt;= len) exit;&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; eax, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // eax = Hash&lt;/span&gt;
        &lt;span&gt;shl&lt;/span&gt; eax, 0x5&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // eax = Hash &amp;lt;&amp;lt; 5&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ecx, [ebp + &lt;span&gt;8&lt;/span&gt;]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ecx = srcApi&lt;/span&gt;
        &lt;span&gt;movsx&lt;/span&gt; edx, byte ptr[ecx]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // edx = *srcApi&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; eax, edx&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // eax = Hash &amp;lt;&amp;lt; 5 + *srcApi&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ecx, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ecx = Hash&lt;/span&gt;
        &lt;span&gt;shr&lt;/span&gt; ecx, 0x2&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ecx = Hash &amp;gt;&amp;gt; 2&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; eax, ecx&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // eax = Hash &amp;lt;&amp;lt; 5 + *srcApi + Hash &amp;gt;&amp;gt; 2&lt;/span&gt;
        &lt;span&gt;xor&lt;/span&gt; eax, [ebp - 0x4]&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt;[ebp - 0x4], eax&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // Hash ^= (Hash &amp;lt;&amp;lt; 5 + *srcApi + Hash &amp;gt;&amp;gt; 2);&lt;/span&gt;
        &lt;span&gt;jmp&lt;/span&gt; short _loop&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;_end:&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; eax, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // eax = Hash&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; esp, ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;pop&lt;/span&gt; ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;ret&lt;/span&gt; 0x8&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、既然HASH算法也有了，在开始编写获取API的函数之前，先实现一个获取字符串长度的函数；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*
 * @ String
 */
void __declspec(naked) asmstrlen() {
    _asm {
        &lt;/span&gt;&lt;span&gt;push&lt;/span&gt; ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; ebp, esp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;sub&lt;/span&gt; esp, 0x4&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; dword ptr [ebp - 0x4], &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;jmp&lt;/span&gt; short _begin&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;_loop:&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; eax, [ebp + 0x8]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // eax = String&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; eax, 0x1&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // eax = String + 1&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; [ebp + 0x8], eax&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // String++&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ecx, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ecx = i&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; ecx, 0x1&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ecx += 1&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; [ebp - 0x4], ecx&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // i++&lt;/span&gt;

    &lt;span&gt;_begin:&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ecx, [ebp + &lt;span&gt;8&lt;/span&gt;]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ecx = String&lt;/span&gt;
        &lt;span&gt;movsx&lt;/span&gt; edx, byte ptr [ecx]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // edx = *String&lt;/span&gt;
        &lt;span&gt;cmp&lt;/span&gt; edx, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;je&lt;/span&gt; _end&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;jmp&lt;/span&gt; _loop&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;_end:&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; eax, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // eax = len&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; esp, ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;pop&lt;/span&gt; ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;ret&lt;/span&gt; 0x4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、接下来，就要编写通过HASH获取API地址的函数了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/* 
 * @1 BaseAddr
 * @2 HASH
 */
void __declspec(naked) GetHASHAPIAddr() {
    _asm {
        &lt;/span&gt;&lt;span&gt;push&lt;/span&gt; ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; ebp, esp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;sub&lt;/span&gt; esp, 0x14&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;push&lt;/span&gt; esi&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;push&lt;/span&gt; edi&lt;span&gt;;
&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; eax, [ebp + &lt;span&gt;8&lt;/span&gt;]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // BaseAddr&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; [ebp - 0x4], eax&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; eax, [eax + 0x3C]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // e_lfanew&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; eax, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // NTStartVA&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; eax, [eax + 0x78]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ExportStartRVA&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; eax, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ExportStart_VA&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ebx, [eax + 0x1C]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EATRVA&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; ebx, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EAT&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; [ebp - 0x8], ebx&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // [ebp - 0x8] -&amp;gt; EAT&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ebx, [eax + 0x20]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ENTRVA&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; ebx, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ENT&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; [ebp - 0xC], ebx&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // [ebp - 0xC] -&amp;gt; ENT&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ebx, [eax + 0x24]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EOTRVA&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; ebx, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EOT&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; [ebp - 0x10], ebx&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // [ebp - 0x10] -&amp;gt; EOT&lt;/span&gt;

        &lt;span&gt;xor&lt;/span&gt; ebx, ebx&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; eax, [eax + 0x18]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // NumOfNames&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; [ebp - 0x14], eax&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;cld&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;_ENT_FIND:&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; esi, [ebp - 0xC]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ENTStartVA&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; esi, [esi + &lt;span&gt;4&lt;/span&gt; * ebx]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ENTContentRVA&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; esi, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // ENTContentVA&lt;/span&gt;
        &lt;span&gt;push&lt;/span&gt; esi&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;push&lt;/span&gt; esi&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;call&lt;/span&gt; asmstrlen&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;pop&lt;/span&gt; esi&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;push&lt;/span&gt; eax&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;push&lt;/span&gt; esi&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;call&lt;/span&gt; ApiHash&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; edi, [ebp + 0xC]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // HASH&lt;/span&gt;
        &lt;span&gt;cmp&lt;/span&gt; eax, edi&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;je&lt;/span&gt; _ENT_OK&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;inc&lt;/span&gt; ebx&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; eax, [ebp - 0x14]&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;dec&lt;/span&gt; eax&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; [ebp - 0x14], eax&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;cmp&lt;/span&gt; eax, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;jg&lt;/span&gt; _ENT_FIND&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;jmp&lt;/span&gt; _ENT_END&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;_ENT_OK:&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ecx, [ebp - 0x10]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EOTStartVA&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; ecx, [ecx + &lt;span&gt;2&lt;/span&gt; * ebx]&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;and&lt;/span&gt; ecx, 0xFFFF&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; esi, [ebp - 0x8]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EATStartVA&lt;/span&gt;
        &lt;span&gt;mov&lt;/span&gt; eax, [esi + &lt;span&gt;4&lt;/span&gt; * ecx]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EAT Address RVA&lt;/span&gt;
        &lt;span&gt;add&lt;/span&gt; eax, [ebp - 0x4]&lt;span&gt;;&lt;/span&gt;&lt;span&gt; // EAT Address VA&lt;/span&gt;

    &lt;span&gt;_ENT_END:&lt;/span&gt;
        &lt;span&gt;pop&lt;/span&gt; edi&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;pop&lt;/span&gt; esi&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;mov&lt;/span&gt; esp, ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;pop&lt;/span&gt; ebp&lt;span&gt;;
&lt;/span&gt;        &lt;span&gt;ret&lt;/span&gt; 0x8&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们只需要事先准备好需要的API的HASH值，就可以了，下面让我们来测试下；&lt;/p&gt;
&lt;p&gt;5、测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;**&lt;span&gt; argv) {
    DWORD LoadLibAddr &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    _asm {
        call GetKernelBase;
        push &lt;/span&gt;&lt;span&gt;0x28182EF6&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; LoadLibrayA HASH&lt;/span&gt;
&lt;span&gt;        push eax;
        call GetHASHAPIAddr;
        mov LoadLibAddr, eax;
    }

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LoadLibrary[0x%X]\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, LoadLibAddr);

    getchar();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/574777/201804/574777-20180411233931287-788932876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在调试器中输入这个地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/574777/201804/574777-20180411234020958-1563216809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，获取到了这个函数的地址；&lt;/p&gt;
&lt;p&gt;获取有同学会说，这个是在kernel32.dll里的，其他dll里的函数也可以吗；当然了，看我们的GetHashAPIAddr参数就知道了；&lt;/p&gt;
&lt;p&gt;来代码吧，搞一个MessageBox的函数，这个是在user32.dll里的，见代码，运行后会弹框，证明就成功了；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;**&lt;span&gt; argv) {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; srcDll[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user32.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    DWORD LoadLibAddr &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    _asm {
        call GetKernelBase;
        push &lt;/span&gt;&lt;span&gt;0x28182EF6&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; LoadLibrayA HASH&lt;/span&gt;
&lt;span&gt;        push eax;
        call GetHASHAPIAddr;
        mov LoadLibAddr, eax;

        push esi;
        mov esi, eax;
        lea eax, srcDll;
        push eax;
        call esi;
        push &lt;/span&gt;&lt;span&gt;0x564B6854&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MessageBoxA HASH&lt;/span&gt;
&lt;span&gt;        push eax;
        call GetHASHAPIAddr;

        push &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        push &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        push &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        push &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        call eax;
    }

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LoadLibraryA[0x%X]\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, LoadLibAddr);

    getchar();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/574777/201804/574777-20180411235333669-1239324396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们的API算是都准备好了，通过实现HASH算法，我们去掉了占用体积过大的API字符串，瘦身的目的达到了；&lt;/p&gt;
&lt;p&gt;在后续的文章中，笔者将带领大家一起分析ShellCode中的截断问题，敬请期待；&lt;/p&gt;
</description>
<pubDate>Wed, 11 Apr 2018 15:57:00 +0000</pubDate>
<dc:creator>Reginald.S</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Reginald-S/p/8797585.html</dc:identifier>
</item>
<item>
<title>推荐几个IDEA插件，Java开发者撸码利器。 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/8799437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/8799437.html</guid>
<description>&lt;h2 id=&quot;2-JRebel-for-IntelliJ&quot;&gt;这里只是推荐一下好用的插件，具体的使用方法不一一详细介绍。 &lt;/h2&gt;
&lt;h2&gt;JRebel for IntelliJ&lt;/h2&gt;
&lt;p&gt;一款热部署插件，只要不是修改了项目的配置文件，用它都可以实现热部署。收费的，破解比较麻烦。不过功能确实很强大。算是开发必备神器了。热部署快捷键是control+F9/command+F9。&lt;/p&gt;
&lt;h2&gt;.ignore&lt;/h2&gt;
&lt;p&gt;git提交时过滤掉不需要提交的文件，很方便，有些本地文件是不需要提交到Git上的。&lt;/p&gt;
&lt;h2&gt;CamelCase&lt;/h2&gt;
&lt;p&gt;将不是驼峰格式的名称，快速转成驼峰格式，安装好后，选中要修改的名称，按快捷键shift+alt+u。&lt;/p&gt;
&lt;h2&gt;Lombok plugin&lt;/h2&gt;
&lt;p&gt;开发神器，可以简化你的实体类，让你i不再写get/set方法，还能快速的实现builder模式，以及链式调用方法，总之就是为了简化实体类而生的插件。&lt;/p&gt;
&lt;h2&gt;Mybatis plugin&lt;/h2&gt;
&lt;p&gt;可以在mapper接口中和mapper的xml文件中来回跳转，就想接口跳到实现类那样简单。&lt;/p&gt;
&lt;h2&gt;codehelper.generator&lt;/h2&gt;
&lt;p&gt;可以让你在创建一个对象并赋值的时候，快速的生成代码，不需要一个一个属性的向里面set,根据new关键字，自动生成掉用set方法的代码，还可以一键填入默认值。&lt;/p&gt;
&lt;div class=&quot;page__content&quot;&gt;
&lt;div class=&quot;g-container&quot;&gt;
&lt;div class=&quot;g-row plugin-content&quot;&gt;
&lt;div class=&quot;g-col-8 _md-12&quot;&gt;
&lt;div class=&quot;plugin-content__description article-content&quot;&gt;
&lt;p&gt;GenAllSetter 特性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Java方法中, 根据 &lt;code&gt;new&lt;/code&gt; 关键词, 为Java Bean 生成所有Setter方法。&lt;/li&gt;
&lt;li&gt;按GenAllSetter键两次, 会为Setter方法生成默认值。&lt;/li&gt;
&lt;li&gt;可在&lt;code&gt;Intellij Idea&lt;/code&gt;中为&lt;code&gt;GenAllSetter&lt;/code&gt;设置快捷键。&lt;/li&gt;
&lt;li&gt;如何使用:
&lt;ul&gt;&lt;li&gt;将光标移动到 &lt;code&gt;new&lt;/code&gt; 语句的下一行。&lt;/li&gt;
&lt;li&gt;点击主菜单Tools-&amp;gt; Codehelper-&amp;gt; GenAllSetter, 或者按下&lt;code&gt;GenAllSetter&lt;/code&gt;快捷键。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;GenDaoCode 特性&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;根据Pojo 文件一键生成 Dao，Service，Xml，Sql文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Pojo文件更新后一键更新对应的Sql和mybatis xml文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;提供insert，insertList，update，select，delete五种方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;能够批量生成多个Pojo的对应的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自动将pojo的注释添加到对应的Sql文件的注释中。 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;丰富的配置，如果没有配置文件，则会使用默认配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以在Intellij Idea中快捷键配置中配置快捷键。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;目前支持MySQL + Java，后续会支持更多的DB。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果喜欢我们的插件，非常感谢您的分享。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;GenDaoCode 使用方法&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;主菜单Tools-&amp;gt; Codehelper-&amp;gt; GenDaoCode 按键便可生成代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法一：点击GenDaoCode，然后根据提示框输入Pojo名字，多个Pojo以 | 分隔。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Codehelper Generator会根据默认配置为您生成代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法二：在工程目录下添加文件名为codehelper.properties的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;点击GenDaoCode，Codehelper Generator会根据您的配置文件为您生成代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;下面几个是装X神器了（让你的开发工具变得靓丽起来）&lt;/h2&gt;
&lt;h2&gt;Material Theme UI&lt;/h2&gt;
&lt;p&gt;这是一款主题插件，可以让你的ide的图标变漂亮，配色搭配的很到位，还可以切换不同的颜色，甚至可以自定义颜色。默认的配色就很漂亮了，如果需要修改配色，可以在工具栏中Tools-&amp;gt;Material Theme然后修改配色等。&lt;/p&gt;
&lt;h2&gt;Background image Plus&lt;/h2&gt;
&lt;p&gt;这是一款可以设置idea背景图片的插件，不但可以设置固体的图片，还可以设置一段时间后随机变化背景图片，以及设置图片的透明度等等。&lt;/p&gt;
&lt;h2&gt;active-power-mode&lt;/h2&gt;
&lt;p&gt;这是一款让你在编码的时候，整个屏幕都为之颤抖的插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/772743/201804/772743-20180411232130374-2087271550.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;TOP-3-Nyan-progress-bar&quot;&gt;Nyan progress bar&lt;/h2&gt;
&lt;p&gt;这是一个将你idea中的所有的进度条都变成萌新动画的小插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/772743/201804/772743-20180411233141721-621184731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;好的开发工具可以提高开发效率，所以的能让自己提高效率，把时间节省出来去学习，去提升自己。这些插件只是日常开发当中用到的一些，等到以后再发现了新的好玩的有意思，和提高工作效率的插件，继续分享出来。&lt;/p&gt;


</description>
<pubDate>Wed, 11 Apr 2018 15:39:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimoer/p/8799437.html</dc:identifier>
</item>
<item>
<title>JDBC入门学习 - KrAchill</title>
<link>http://www.cnblogs.com/xld21/p/8799443.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xld21/p/8799443.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;我是通过传智博客学习的，也向大家推荐一下&lt;/strong&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;JDBC&lt;span&gt;入门&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;l &lt;span&gt;导&lt;/span&gt;jar&lt;span&gt;包：驱动！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;加载驱动类：&lt;/span&gt;Class.forName(“类名”);&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;给出&lt;/span&gt;url&lt;span&gt;、&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;，其中&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;背下来！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;使用&lt;/span&gt;DriverManager&lt;span&gt;类来得到&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;对象！&lt;/span&gt;&lt;/p&gt;



&lt;h6&gt;&lt;strong&gt;1&lt;span&gt;　什么是&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;JDBC&lt;span&gt;（&lt;/span&gt;Java DataBase Connectivity&lt;span&gt;）就是&lt;/span&gt;Java&lt;span&gt;数据库连接，说白了就是用&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;语言来操作数据库。原来我们操作数据库是在控制台使用&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句来操作数据库，&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;是用&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;语言向数据库发送&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句。&lt;/span&gt;&lt;/p&gt;

&lt;h6&gt;&lt;strong&gt;2&lt;span&gt;　&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;原理&lt;/span&gt;&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;早期&lt;/span&gt;SUN&lt;span&gt;公司的天才们想编写一套可以连接天下所有数据库的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;，但是当他们刚刚开始时就发现这是不可完成的任务，因为各个厂商的数据库服务器差异太大了。后来&lt;/span&gt;&lt;span&gt;SUN&lt;/span&gt;&lt;span&gt;开始与数据库厂商们讨论，最终得出的结论是，由&lt;/span&gt;&lt;span&gt;SUN&lt;/span&gt;&lt;span&gt;提供一套访问数据库的规范（就是一组接口），并提供连接数据库的协议标准，然后各个数据库厂商会遵循&lt;/span&gt;&lt;span&gt;SUN&lt;/span&gt;&lt;span&gt;的规范提供一套访问自己公司的数据库服务器的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;出现。&lt;/span&gt;&lt;span&gt;SUN&lt;/span&gt;&lt;span&gt;提供的规范命名为&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;，而各个厂商提供的，遵循了&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;规范的，可以访问自己数据库的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;被称之为驱动！&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;JDBC&lt;span&gt;是接口，而&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;驱动才是接口的实现，没有驱动无法完成数据库连接！每个数据库厂商都有自己的驱动，用来连接自己公司的数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然还有第三方公司专门为某一数据库提供驱动，这样的驱动往往不是开源免费的！&lt;/p&gt;

&lt;h6&gt;&lt;strong&gt;3&lt;span&gt;　&lt;/span&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;核心类（接口）介绍&lt;/span&gt;&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;JDBC&lt;span&gt;中的核心类有：&lt;/span&gt;&lt;span&gt;DriverManager&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;，和&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DriverManger&lt;span&gt;（驱动管理器）的作用有两个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;注册驱动：这可以让&lt;/span&gt;JDBC&lt;span&gt;知道要使用的是哪个驱动；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;获取&lt;/span&gt;Connection&lt;span&gt;：如果可以获取到&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;，那么说明已经与数据库连接上了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Connection&lt;span&gt;对象表示连接，与数据库的通讯都是通过这个对象展开的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l Connection&lt;span&gt;最为重要的一个方法就是用来获取&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;对象；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Statement&lt;span&gt;是用来向数据库发送&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句的，这样数据库就会执行发送过来的&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l void executeUpdate(String sql)&lt;span&gt;：执行更新操作（&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;等）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l ResultSet executeQuery(String sql)&lt;span&gt;：执行查询操作，数据库在执行查询后会把查询结果，查询结果就是&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;ResultSet&lt;span&gt;对象表示查询结果集，只有在执行查询操作后才会有结果集的产生。结果集是一个二维的表格，有行有列。操作结果集要学习移动&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;内部的“行光标”，以及获取当前行上的每一列上的数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l boolean next()&lt;span&gt;：使“行光标”移动到下一行，并返回移动后的行是否存在；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l XXX getXXX(int col)&lt;span&gt;：获取当前行指定列上的值，参数就是列数，列数从&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;开始，而不是&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h6&gt;&lt;strong&gt;4&lt;span&gt;　&lt;/span&gt;&lt;span&gt;Hello JDBC&lt;/span&gt;&lt;/strong&gt;&lt;/h6&gt;

&lt;p&gt;&lt;span&gt;下面开始编写第一个&lt;/span&gt;JDBC&lt;span&gt;程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1&lt;span&gt;　&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;数据库的驱动&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;mysql-connector-java-5.1.13-bin.jar&lt;/strong&gt;&lt;strong&gt;；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2&lt;span&gt;　获取连接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取连接需要两步，一是使用&lt;/span&gt;DriverManager&lt;span&gt;来注册驱动，二是使用&lt;/span&gt;&lt;span&gt;DriverManager&lt;/span&gt;&lt;span&gt;来获取&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册驱动&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;看清楚了，注册驱动就只有一句话：&lt;/span&gt;Class.forName(&lt;/strong&gt;&lt;strong&gt;“&lt;/strong&gt;&lt;strong&gt;com.mysql.jdbc.Driver&lt;/strong&gt;&lt;strong&gt;”&lt;/strong&gt;&lt;strong&gt;)&lt;span&gt;，下面的内容都是对这句代码的解释。今后我们的代码中，与注册驱动相关的代码只有这一句。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DriverManager&lt;span&gt;类的&lt;/span&gt;&lt;span&gt;registerDriver()&lt;/span&gt;&lt;span&gt;方法的参数是&lt;/span&gt;&lt;span&gt;java.sql.Driver&lt;/span&gt;&lt;span&gt;，但&lt;/span&gt;&lt;span&gt;java.sql.Driver&lt;/span&gt;&lt;span&gt;是一个接口，实现类由&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;驱动来提供，&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;驱动中的&lt;/span&gt;&lt;span&gt;java.sql.Driver&lt;/span&gt;&lt;span&gt;接口的实现类为&lt;/span&gt;&lt;span&gt;com.mysql.jdbc.Driver&lt;/span&gt;&lt;span&gt;！那么注册驱动的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DriverManager.registerDriver(new com.mysql.jdbc.Driver());&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面代码虽然可以注册驱动，但是出现硬编码（代码依赖&lt;/span&gt;mysql&lt;span&gt;驱动&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包），如果将来想连接&lt;/span&gt;&lt;span&gt;Oracle&lt;/span&gt;&lt;span&gt;数据库，那么必须要修改代码的。并且其实这种注册驱动的方式是注册了两次驱动！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDBC&lt;span&gt;中规定，驱动类在被加载时，需要自己“主动”把自己注册到&lt;/span&gt;&lt;span&gt;DriverManger&lt;/span&gt;&lt;span&gt;中，下面我们来看看&lt;/span&gt;&lt;span&gt;com.mysql.jdbc.Driver&lt;/span&gt;&lt;span&gt;类的源代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;com.mysql.jdbc.Driver.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Driver &lt;span&gt;extends&lt;/span&gt; NonRegisteringDriver &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.sql.Driver {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            java.sql.DriverManager.registerDriver(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Driver());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException E) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;Can't register driver!&quot;&lt;span&gt;);
        }
    }
……
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;com.mysql.jdbc.Driver&lt;span&gt;类中的&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;块会创建本类对象，并注册到&lt;/span&gt;&lt;span&gt;DriverManager&lt;/span&gt;&lt;span&gt;中。这说明只要去加载&lt;/span&gt;&lt;span&gt;com.mysql.jdbc.Driver&lt;/span&gt;&lt;span&gt;类，那么就会执行这个&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;块，从而也就会把&lt;/span&gt;&lt;span&gt;com.mysql.jdbc.Driver&lt;/span&gt;&lt;span&gt;注册到&lt;/span&gt;&lt;span&gt;DriverManager&lt;/span&gt;&lt;span&gt;中，所以可以把&lt;/span&gt;&lt;strong&gt;注册驱动类&lt;/strong&gt;的代码修改为&lt;strong&gt;加载驱动类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Class.forName(“com.mysql.jdbc.Driver”);&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;获取连接&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;获取连接的也只有一句代码：&lt;/span&gt;DriverManager.getConnection(url,username,password)&lt;span&gt;，其中&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;是登录数据库的用户名和密码，如果我没说错的话，你的&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;数据库的用户名和密码分别是：&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;url&lt;span&gt;查对复杂一点，它是用来找到要连接数据库“网址”，就好比你要浏览器中查找百度时，也需要提供一个&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;。下面是&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;jdbc:mysql://localhost:3306/mydb1&lt;/p&gt;
&lt;p&gt;JDBC&lt;span&gt;规定&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;的格式由三部分组成，每个部分中间使用逗号分隔。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;第一部分是&lt;/span&gt;jdbc&lt;span&gt;，这是固定的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;第二部分是数据库名称，那么连接&lt;/span&gt;mysql&lt;span&gt;数据库，第二部分当然是&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;l &lt;span&gt;第三部分是由数据库厂商规定的，我们需要了解每个数据库厂商的要求，&lt;/span&gt;mysql&lt;span&gt;的第三部分分别由数据库服务器的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址（&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;）、端口号（&lt;/span&gt;&lt;span&gt;3306&lt;/span&gt;&lt;span&gt;），以及&lt;/span&gt;&lt;span&gt;DATABASE&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;(mydb1)&lt;/span&gt;&lt;span&gt;组成。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;下面是获取连接的语句：&lt;/p&gt;
&lt;p&gt;Connection con = DriverManager.getConnection(“jdbc:mysql://localhost:3306/mydb1”,”root”,”123”);&lt;/p&gt;

&lt;p&gt;&lt;span&gt;还可以在&lt;/span&gt;url&lt;span&gt;中提供参数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;jdbc:mysql://localhost:3306/mydb1&lt;strong&gt;?&lt;/strong&gt;&lt;strong&gt;useUnicode=true&lt;/strong&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;strong&gt;characterEncoding=&lt;/strong&gt;&lt;strong&gt;UTF8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;useUnicode&lt;span&gt;参数指定这个连接数据库的过程中，使用的字节集是&lt;/span&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;span&gt;字节集；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;characherEncoding&lt;span&gt;参数指定穿上连接数据库的过程中，使用的字节集编码为&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;编码。请注意，&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;中指定&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;编码是给出的是&lt;/span&gt;&lt;span&gt;UTF8&lt;/span&gt;&lt;span&gt;，而不是&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;。要小心了！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.3&lt;span&gt;　获取&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在得到&lt;/span&gt;Connectoin&lt;span&gt;之后，说明已经与数据库连接上了，下面是通过&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;对象的代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Statement stmt = con.createStatement();&lt;/p&gt;
&lt;p&gt;Statement&lt;span&gt;是用来向数据库发送要执行的&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句的！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.4&lt;span&gt;　发送&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;增、删、改语句&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String sql = “insert into user value(’zhangSan’, ’123’)”;&lt;/p&gt;
&lt;p&gt;int m = stmt.executeUpdate(sql);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;/span&gt;int&lt;span&gt;类型的返回值表示执行这条&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句所影响的行数，我们知道，对&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;来说，最后只能影响一行，而&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;可能会影响&lt;/span&gt;&lt;span&gt;0~n&lt;/span&gt;&lt;span&gt;行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果&lt;/span&gt;SQL&lt;span&gt;语句执行失败，那么&lt;/span&gt;&lt;span&gt;executeUpdate()&lt;/span&gt;&lt;span&gt;会抛出一个&lt;/span&gt;&lt;span&gt;SQLException&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.5&lt;span&gt;　发送&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;查询语句&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String sql = “select * from user”;&lt;/p&gt;
&lt;p&gt;ResultSet rs = stmt.executeQuery(sql);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请注册，执行查询使用的不是&lt;/span&gt;executeUpdate()&lt;span&gt;方法，而是&lt;/span&gt;&lt;span&gt;executeQuery()&lt;/span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;span&gt;executeQuery()&lt;/span&gt;&lt;span&gt;方法返回的是&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;封装了查询结果，我们称之为结果集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.6&lt;span&gt;　读取结果集中的数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ResultSet&lt;span&gt;就是一张二维的表格，它内部有一个“行光标”，光标默认的位置在“第一行上方”，我们可以调用&lt;/span&gt;&lt;span&gt;rs&lt;/span&gt;&lt;span&gt;对象的&lt;/span&gt;&lt;span&gt;next()&lt;/span&gt;&lt;span&gt;方法把“行光标”向下移动一行，当第一次调用&lt;/span&gt;&lt;span&gt;next()&lt;/span&gt;&lt;span&gt;方法时，“行光标”就到了第一行记录的位置，这时就可以使用&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;提供的&lt;/span&gt;&lt;span&gt;getXXX(int col)&lt;/span&gt;&lt;span&gt;方法来获取指定列的数据了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rs.next();//&lt;span&gt;光标移动到第一行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rs.getInt(1);//&lt;span&gt;获取第一行第一列的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你使用&lt;/span&gt;rs.getInt(1)&lt;span&gt;方法时，你必须可以肯定第&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;列的数据类型就是&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;类型，如果你不能肯定，那么最好使用&lt;/span&gt;&lt;span&gt;rs.getObject(1)&lt;/span&gt;&lt;span&gt;。在&lt;/span&gt;&lt;span&gt;ResultSet&lt;/span&gt;&lt;span&gt;类中提供了一系列的&lt;/span&gt;&lt;span&gt;getXXX()&lt;/span&gt;&lt;span&gt;方法，比较常用的方法有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Object getObject(int col)&lt;/p&gt;
&lt;p&gt;String getString(int col)&lt;/p&gt;
&lt;p&gt;int getInt(int col)&lt;/p&gt;
&lt;p&gt;double getDouble(int col)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.7&lt;span&gt;　关闭&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与&lt;/span&gt;IO&lt;span&gt;流一样，使用后的东西都需要关闭！关闭的顺序是先得到的后关闭，后得到的先关闭。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rs.close();&lt;/p&gt;
&lt;p&gt;stmt.close();&lt;/p&gt;
&lt;p&gt;con.close();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.8&lt;span&gt;　代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static Connection getConnection() throws Exception {
                Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
                String url = &quot;jdbc:mysql://localhost:3306/mydb1&quot;;
                return DriverManager.getConnection(url, &quot;root&quot;, &quot;123&quot;);
        }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Connection con &lt;/span&gt;=&lt;span&gt; getConnection();
        Statement stmt &lt;/span&gt;=&lt;span&gt; con.createStatement();
        String sql &lt;/span&gt;= &quot;insert into user values('zhangSan', '123')&quot;&lt;span&gt;;
        stmt.executeUpdate(sql);
        System.out.println(&lt;/span&gt;&quot;插入成功！&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; update() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Connection con &lt;/span&gt;=&lt;span&gt; getConnection();
        Statement stmt &lt;/span&gt;=&lt;span&gt; con.createStatement();
        String sql &lt;/span&gt;= &quot;update user set password='456' where username='zhangSan'&quot;&lt;span&gt;;
        stmt.executeUpdate(sql);
        System.out.println(&lt;/span&gt;&quot;修改成功！&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Connection con &lt;/span&gt;=&lt;span&gt; getConnection();
        Statement stmt &lt;/span&gt;=&lt;span&gt; con.createStatement();
        String sql &lt;/span&gt;= &quot;delete from user where username='zhangSan'&quot;&lt;span&gt;;
        stmt.executeUpdate(sql);
        System.out.println(&lt;/span&gt;&quot;删除成功！&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; query() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Connection con &lt;/span&gt;=&lt;span&gt; getConnection();
        Statement stmt &lt;/span&gt;=&lt;span&gt; con.createStatement();
        String sql &lt;/span&gt;= &quot;select * from user&quot;&lt;span&gt;;
        ResultSet rs &lt;/span&gt;=&lt;span&gt; stmt.executeQuery(sql);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(rs.next()) {
            String username &lt;/span&gt;= rs.getString(1&lt;span&gt;);
            String password &lt;/span&gt;= rs.getString(2&lt;span&gt;);
            System.out.println(username &lt;/span&gt;+ &quot;, &quot; +&lt;span&gt; password);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.9&lt;span&gt;　规范化代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓规范化代码就是无论是否出现异常，都要关闭&lt;/span&gt;ResultSet&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Statement&lt;/span&gt;&lt;span&gt;，以及&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;，如果你还记得&lt;/span&gt;&lt;span&gt;IO&lt;/span&gt;&lt;span&gt;流的规范化代码，那么下面的代码你就明白什么意思了。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; query() {
        Connection con &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Statement stmt &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        ResultSet rs &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
[在try外给出引用的定义]        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            con &lt;/span&gt;=&lt;span&gt; getConnection();[在try内为对象实例化]
            stmt &lt;/span&gt;=&lt;span&gt; con.createStatement();
            String sql &lt;/span&gt;= &quot;select * from user&quot;&lt;span&gt;;
            rs &lt;/span&gt;=&lt;span&gt; stmt.executeQuery(sql);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(rs.next()) {
                String username &lt;/span&gt;= rs.getString(1&lt;span&gt;);
                String password &lt;/span&gt;= rs.getString(2&lt;span&gt;);
                System.out.println(username &lt;/span&gt;+ &quot;, &quot; +&lt;span&gt; password);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rs != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) rs.close();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(stmt != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) stmt.close();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(con != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) con.close();
[在finally中进行关闭]            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(SQLException e) {}
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 11 Apr 2018 15:38:00 +0000</pubDate>
<dc:creator>KrAchill</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xld21/p/8799443.html</dc:identifier>
</item>
<item>
<title>从零开始：一个正式的vue+webpack项目的目录结构是怎么形成的 - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/8799415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/8799415.html</guid>
<description>&lt;div readability=&quot;85&quot;&gt;
&lt;p&gt;如何从零开始一个vue+webpack前端工程工作流的搭建，首先我们先从项目的目录结构入手。一个持续可发展，不断加入新功能，方便后期维护的目录结构究竟是长什么样子的？接下来闰土大叔带你们一起手摸手学起来。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;初级前端初始化目录篇&lt;/h2&gt;
&lt;p&gt;项目伊始，我们肯定是先在terminal终端命令行（以下简称terminal）cd进入&amp;lt;project name&amp;gt;根目录，然后输入 &lt;code&gt;npm init&lt;/code&gt; 初始化一个npm项目，在项目根目录下面就会出现一个package.json文件。 然后就可以安装依赖了，直接在terminal里输入 &lt;code&gt;npm i webpack vue vue-loader -D&lt;/code&gt;。当我们把这几个安装好以后，terminal这边会提示我们WARN（警告⚠️）：&lt;/p&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4bc347a6104b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4bc347a6104b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;327&quot;/&gt;
&lt;p&gt;翻译过来大意是，vue-loader需要一个css-loader和vue-template-compiler作为它的第三方依赖,所以听它的话，我们去进行一下安装：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm i css-loader vue-template-compiler -D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那下面的警告信息提示我们缺少一些信息，这个其实无关痛痒，所以不需要去关心它。&lt;/p&gt;
&lt;p&gt;通过以上简单几个步骤，我们的项目就初始化好了。然后在根目录下面创建一个src文件夹，这是我们源码放置的目录。然后我们在src目录下面新建一个app.vue文件，里面就可以写一些关于项目的业务代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&amp;lt;template&amp;gt;
    &amp;lt;div id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&amp;gt;{{text}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span class=&quot;hljs-built_in&quot;&gt;export default {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;data () {
            text: &lt;span class=&quot;hljs-string&quot;&gt;'闰土大叔'
        }
    }
&amp;lt;/script&amp;gt;
&amp;lt;style&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然这个后缀为.vue 文件是不可以在浏览器里直接运行的，我们需要想办法让它运行起来。&lt;/p&gt;
&lt;p&gt;现在我们要在项目根目录下新建一个webpack.config.js文件，webpack是帮我们前端来打包资源的，前端资源有很多不同的类型，比如说JavaScript，css，html，image，iconfont等这些资源都是需要通过http请求加载的东西。webpack是将一个js文件加载到浏览器端之后，然后去把所有的内容去渲染出来。所以，很多时候，我们可以把js文件作为项目的入口文件。&lt;/p&gt;
&lt;p&gt;这个时候，我们在src目录下新建一个index.js作为入口文件，顺便在里面写点东西：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;import Vue from &lt;span class=&quot;hljs-string&quot;&gt;'vue'
import App from &lt;span class=&quot;hljs-string&quot;&gt;'./app.vue'

const root = document.createElement(&lt;span class=&quot;hljs-string&quot;&gt;'div')
document.body.appendChild(root)

new Vue({
    render: (h) =&amp;gt; h(App)
}).&lt;span class=&quot;hljs-variable&quot;&gt;$mount(root)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;index.js准备完毕之后，那么在webpack.config.js里面就可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;const path = require(&lt;span class=&quot;hljs-string&quot;&gt;'path')

module.exports = {
    entry:  path.join(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;'src/index.js'),
    output: {
        filename: &lt;span class=&quot;hljs-string&quot;&gt;'bundle.js',
        path: path.join(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;'dist')
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，__dirname就代表这个文件所在的目录地址，path.join()的意思就是和后面的字符串路径拼接起来，形成一个绝对的路径。&lt;/p&gt;
&lt;p&gt;然后通过webpack把所有的文件打包成一个bundle.js文件，并且是能在浏览器里面直接运行的代码。现在我们可以在package.json 文件里的scripts对象里面添加一个脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;scripts&quot;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;build&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;webpack --config webpack.config.js&quot;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这儿，肯定有童鞋要问了，为什么要在这里面调用webpack而不是在terminal里面直接运行呢？&lt;/p&gt;
&lt;p&gt;因为只有在这里调用webpack，它才会优先调用我们项目里面安装的webpack版本，如果我们在命令行里面输入webpack，它会调动全局的webpack，这个时候全局的webpack可能会跟我们项目中的webpack版本不一致，所以我们还是采取这种方式比较稳妥。&lt;/p&gt;
&lt;p&gt;写完之后，我们就可以在terminal输入&lt;code&gt;npm run build&lt;/code&gt;跑一下，会尴尬地发现报错了：&lt;/p&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4e9708eac1be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4e9708eac1be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;672&quot;/&gt;
&lt;p&gt;这个错误告诉我们，需要为.vue文件去声明一个loader。因为webpack原生是只支持JS文件类型的，并且只支持ES5的语法，所以我们在使用超出它理解范围的语法的时候，我们要使用一些帮它去处理的工具。所以我们要在webpack.config.js文件里面继续写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;module: {
    rules: [
        {
            &lt;span class=&quot;hljs-built_in&quot;&gt;test: /.vue$/,
            loader: &lt;span class=&quot;hljs-string&quot;&gt;'vue-loader'
        }
    ]
}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加完这段之后，我们再去terminal执行下&lt;code&gt;npm run build&lt;/code&gt;，你会发现项目根目录下多了一个dist文件夹，点开里面发现webpack为我们自动打包生成了一个bundle.js文件，感兴趣的童鞋可以点开这个js文件看看：&lt;/p&gt;
&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f43c4e29c1b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f43c4e29c1b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;717&quot;/&gt;&lt;/div&gt;


&lt;div readability=&quot;128&quot;&gt;它里面代码很多，上面是固有的webpack的代码，这些代码是处理项目中的模块依赖的，因为我们项目里有很多的js相互依赖。

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f5081d9a947?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f5081d9a947?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;721&quot;/&gt;
&lt;p&gt;往下翻到100多行左右的时候，你会发现有很多的代码其实是vue源码。因为我们项目要依赖vue.js，所以webpack会把vue.js文件打包进来。&lt;/p&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f82b0c9e685?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b4f82b0c9e685?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;593&quot;/&gt;
&lt;p&gt;你可以通过快捷键 command (Ctrl) + F 查找关键词$mount看到，红线圈住的这段代码就是我们自己写的代码，其实webpack做的工作就是把这些不同的静态资源的类型打包成一个js，然后我们在html里面引用这个js，就可以正常运行。&lt;/p&gt;
&lt;p&gt;相信大家做前端都知道，在做一个项目开发的时候，我们希望把一些零碎的js文件打包到一起，这样可以减少http请求。同样的，我们希望使用模块依赖，因为项目中会做很多可复用的代码，把它写到一个模块里面去，这样的话当我们再去写一个新项目的时候，不用再把原来的代码重新写一遍，或者是拷贝一份。&lt;/p&gt;
&lt;p&gt;当然这里面我们暂时没有提到.babelrc、.eslintrc、editorconfig、postcss.config.js等，这些我们留到后面再讲。&lt;/p&gt;

&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;中级前端合理细化目录篇&lt;/h2&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b2e670d04f87a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b2e670d04f87a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;564&quot;/&gt;
&lt;p&gt;初始化工作完成之后，接下来我们要细分目录了。首先我们需要在项目的根目录下新建一个文件夹叫build，把webpack的文件单独放到这个文件夹里面。因为我们项目中会用到很多不同的相关文件的配置，接下来先新建一个 webpack.config.base.js 文件，我们把webpack里面需要用到的共同的配置放到这个base的文件里面。比如开发环境和正式环境，以及后期我们要提到的服务端渲染的环境。我们都依赖于base这个配置。&lt;/p&gt;
&lt;p&gt;以下是webpack.config.base.js文件里的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;const path = require(&lt;span class=&quot;hljs-string&quot;&gt;'path')
const createVueLoaderOptions = require(&lt;span class=&quot;hljs-string&quot;&gt;'./vue-loader.config')

const isDev = process.env.NODE_ENV === &lt;span class=&quot;hljs-string&quot;&gt;'development'

const config = {
  target: &lt;span class=&quot;hljs-string&quot;&gt;'web',
  entry: path.join(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;'../client/index.js'),
  output: {
    filename: &lt;span class=&quot;hljs-string&quot;&gt;'bundle.[hash:8].js',
    path: path.join(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;'../dist')
  },
  module: {
    rules: [
      {
        &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.(vue|js|jsx)$/,
        loader: &lt;span class=&quot;hljs-string&quot;&gt;'eslint-loader',
        exclude: /node_modules/,
        enforce: &lt;span class=&quot;hljs-string&quot;&gt;'pre'
      },
      {
        &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.vue$/,
        loader: &lt;span class=&quot;hljs-string&quot;&gt;'vue-loader',
        options: createVueLoaderOptions(isDev)
      },
      {
        &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.jsx$/,
        loader: &lt;span class=&quot;hljs-string&quot;&gt;'babel-loader'
      },
      {
        &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.js$/,
        loader: &lt;span class=&quot;hljs-string&quot;&gt;'babel-loader',
        exclude: /node_modules/
      },
      {
        &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.(gif|jpg|jpeg|png|svg)$/,
        use: [
          {
            loader: &lt;span class=&quot;hljs-string&quot;&gt;'url-loader',
            options: {
              &lt;span class=&quot;hljs-built_in&quot;&gt;limit: 1024,
              name: &lt;span class=&quot;hljs-string&quot;&gt;'resources/[path][name].[hash:8].[ext]'
            }
          }
        ]
      }
    ]
  }
}

module.exports = config

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们再新建一个 webpack.config.client.js ，这个client文件依赖于base文件，在此基础上扩展一些其他配置。因此我们需要在webpack.config.client.js里面敲入一行代码引入base文件 ：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const baseConfig = require('./webpack.config.base')&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;基础工作做完之后，我们该如何去扩展配置呢？首先在terminal终端命令行安装下 &lt;code&gt;npm i webpack-merge -D&lt;/code&gt; 我们需要webpack-merge这个工具帮助去扩展、合并不同的webpack配置，然后根据声明好的isDev来判断应该怎么合并配置。&lt;/p&gt;
&lt;p&gt;以下是webpack.config.client.js文件里的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;const path = require(&lt;span class=&quot;hljs-string&quot;&gt;'path')
const HTMLPlugin = require(&lt;span class=&quot;hljs-string&quot;&gt;'html-webpack-plugin')
const webpack = require(&lt;span class=&quot;hljs-string&quot;&gt;'webpack')
const merge = require(&lt;span class=&quot;hljs-string&quot;&gt;'webpack-merge')
const ExtractPlugin = require(&lt;span class=&quot;hljs-string&quot;&gt;'extract-text-webpack-plugin')
const baseConfig = require(&lt;span class=&quot;hljs-string&quot;&gt;'./webpack.config.base')

const isDev = process.env.NODE_ENV === &lt;span class=&quot;hljs-string&quot;&gt;'development'

const defaultPlugins = [
  new webpack.DefinePlugin({
    &lt;span class=&quot;hljs-string&quot;&gt;'process.env': {
      NODE_ENV: isDev ? &lt;span class=&quot;hljs-string&quot;&gt;'&quot;development&quot;' : &lt;span class=&quot;hljs-string&quot;&gt;'&quot;production&quot;'
    }
  }),
  new HTMLPlugin()
]

const devServer = {
  port: 8000,
  host: &lt;span class=&quot;hljs-string&quot;&gt;'0.0.0.0',
  overlay: {
    errors: &lt;span class=&quot;hljs-literal&quot;&gt;true
  },
  hot: &lt;span class=&quot;hljs-literal&quot;&gt;true
}

&lt;span class=&quot;hljs-built_in&quot;&gt;let config

&lt;span class=&quot;hljs-keyword&quot;&gt;if (isDev) {
  // 开发环境的配置
  config = merge(baseConfig, {
    devtool: &lt;span class=&quot;hljs-string&quot;&gt;'#cheap-module-eval-source-map',
    module: {
      rules: [
        {
          &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.styl/,
          use: [
            &lt;span class=&quot;hljs-string&quot;&gt;'vue-style-loader',
            &lt;span class=&quot;hljs-string&quot;&gt;'css-loader',
            // {
            //   loader: &lt;span class=&quot;hljs-string&quot;&gt;'css-loader',
            //   options: {
            //     module: &lt;span class=&quot;hljs-literal&quot;&gt;true,
            //     &lt;span class=&quot;hljs-built_in&quot;&gt;localIdentName: isDev ? &lt;span class=&quot;hljs-string&quot;&gt;'[path]-[name]-[hash:base64:5]' : &lt;span class=&quot;hljs-string&quot;&gt;'[hash:base64:5]'
            //   }
            // },
            {
              loader: &lt;span class=&quot;hljs-string&quot;&gt;'postcss-loader',
              options: {
                &lt;span class=&quot;hljs-built_in&quot;&gt;sourceMap: &lt;span class=&quot;hljs-literal&quot;&gt;true
              }
            },
            &lt;span class=&quot;hljs-string&quot;&gt;'stylus-loader'
          ]
        }
      ]
    },
    devServer,
    plugins: defaultPlugins.concat([
      new webpack.HotModuleReplacementPlugin(),
      new webpack.NoEmitOnErrorsPlugin()
    ])
  })
} &lt;span class=&quot;hljs-keyword&quot;&gt;else {
  // 正式环境的配置
  config = merge(baseConfig, {
    entry: {
      app: path.join(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;'../client/index.js'),
      vendor: [&lt;span class=&quot;hljs-string&quot;&gt;'vue']
    },
    output: {
      filename: &lt;span class=&quot;hljs-string&quot;&gt;'[name].[chunkhash:8].js'
    },
    module: {
      rules: [
        {
          &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.styl/,
          use: ExtractPlugin.extract({
            fallback: &lt;span class=&quot;hljs-string&quot;&gt;'vue-style-loader',
            use: [
              &lt;span class=&quot;hljs-string&quot;&gt;'css-loader',
              {
                loader: &lt;span class=&quot;hljs-string&quot;&gt;'postcss-loader',
                options: {
                  &lt;span class=&quot;hljs-built_in&quot;&gt;sourceMap: &lt;span class=&quot;hljs-literal&quot;&gt;true
                }
              },
              &lt;span class=&quot;hljs-string&quot;&gt;'stylus-loader'
            ]
          })
        }
      ]
    },
    plugins: defaultPlugins.concat([
      new ExtractPlugin(&lt;span class=&quot;hljs-string&quot;&gt;'styles.[contentHash:8].css'),
      new webpack.optimize.CommonsChunkPlugin({
        name: &lt;span class=&quot;hljs-string&quot;&gt;'vendor'
      }),
      new webpack.optimize.CommonsChunkPlugin({
        name: &lt;span class=&quot;hljs-string&quot;&gt;'runtime'
      })
    ])
  })
}

module.exports = config

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，这个src文件夹我们要重命名一下，叫client，因为我们后期还要写服务端的代码，对应的就命名成server，正好对应它的含义。这样看起来，名称就变得更加的合理。&lt;/p&gt;
&lt;p&gt;当我们万事大吉的时候，千万记得要把 webpack.config.base.js 和 webpack.config.client.js 里面的src路径改掉，换成client，否则就会报错。&lt;/p&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b513d1c5fc7c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b513d1c5fc7c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;720&quot;/&gt;
&lt;p&gt;以上就是我们项目最终形成的目录结构，client目录下分别有assets、layout、views这三个文件夹，其中assets目录下放静态资源，例如images、styles等；layout目录下放通用布局的组件；views目录下放具体的业务代码的组件。&lt;/p&gt;
&lt;p&gt;当然，这个目录其实还可以随着项目的开发再细分下去，这里就不展开叙述了。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;大家一定要注意，在我们正式开发项目、创建一个项目工程的时候，一定要先把目录结构理顺，条理一定要清楚。每个目录结构里面放什么东西，心里一定要先有个概念。以后新建的文件不要乱放，因为项目一旦做大，维护时间比较久的时候，可能两三个月里面都有一个文件你不会去碰它。到时候如果要去找一个东西的时候，你会找不到它，这是非常令人难受的一件事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最重要的一点是，目录结构的混乱，会导致你后续开发项目的效率变得非常的低。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这次关于“一个正式项目的目录结构是怎么形成的”的话题就说到这里，我之后的文章会讲些什么呢？文章预告如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;eslint的错误修复小技巧&lt;/li&gt;
&lt;li&gt;vue-loader是如何配置的&lt;/li&gt;
&lt;li&gt;如何回答“对vue生命周期的理解”才能让面试官满意？&lt;/li&gt;
&lt;li&gt;浅谈css-module的配置&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;li&gt;正式环境打包以及异步模块打包优化&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;以上内容均会第一时间发布在我的公众号：闰土大叔 ，欢迎关注。&lt;/h3&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b5210a4abba19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/4/11/162b5210a4abba19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;258&quot; data-height=&quot;258&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 11 Apr 2018 15:34:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/8799415.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构（数组篇03） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8784575.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8784575.html</guid>
<description>&lt;p&gt;　　终于，这是有关于数组的最后一篇，下一篇会真真切切给大家带来数据结构在js中的实现方式。那么这篇文章还是得啰嗦一下数组的相关知识，因为数组真的太重要了！不要怀疑数组在JS中的重要性与实用性。这篇文章分为两部分，第一部分会给大家简单说一下数组原生的排序方法sort和reverse。第二部分会给大家简单说一下二维和三维数组。都不难，仔细看，很简单的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、reverse()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;reverse比较容易理解，颠倒数组中元素的顺序，也就是第一个变成最后一个，最后一个呢变成第一个。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5,6,7&lt;span&gt;];
nums.reverse();
console.log(nums)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[7, 6, 5, 4, 3, 2, 1, 0]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　reverse方法只是无差别的对数组进行倒叙，可能很多时候并不适用于我们的应用场景，所以才出现了sort()方法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、sort()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　　sort()方法可以说是js数组中不太容易记忆和使用的方法，但是sort()是十分重要的一个方法，那么下面我就详细的说明一下，sort()的应用场景和使用方法。&lt;/p&gt;
&lt;p&gt; 　　sort()方法允许传入一个匿名函数作为排序的依据，也可以不传参数，但是我想大家都知道，在不传参数的情况下，很多时候的结果并不是我们想要的，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,2,4,9,10,11,20,32,3,6,7,8,15,26&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newNums =&lt;span&gt; nums.sort();
console.log(newNums)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0, 10, 11, 15, 2, 20, 26, 3, 32, 4, 6, 7, 8, 9]&lt;/span&gt;
console.log(nums)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0, 10, 11, 15, 2, 20, 26, 3, 32, 4, 6, 7, 8, 9]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码说明，sort会改变原来的数组，而不是生成一个排序后的新数组，大家看到上面的排序并不是依据数字从大到小排序的。这是因为，sort在排序的时候会默认把数组中的各个元素转换成字符串，并且依据字符串对应的&lt;a href=&quot;https://baike.baidu.com/item/ASCII/309296?fr=aladdin&amp;amp;fromid=99077&amp;amp;fromtitle=ascii%E7%A0%81&quot; target=&quot;_blank&quot;&gt;ASCII码值&lt;/a&gt;来比较的，那&lt;a href=&quot;https://baike.baidu.com/item/ASCII/309296?fr=aladdin&amp;amp;fromid=99077&amp;amp;fromtitle=ascii%E7%A0%81&quot; target=&quot;_blank&quot;&gt;ASCII&lt;/a&gt;是什么？&lt;a href=&quot;https://baike.baidu.com/item/ASCII/309296?fr=aladdin&amp;amp;fromid=99077&amp;amp;fromtitle=ascii%E7%A0%81&quot; target=&quot;_blank&quot;&gt;ASCII&lt;/a&gt;是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。&lt;/p&gt;
&lt;p&gt;　　显然这不是我们想要的结果，所以就需要给sort传入一个函数（compareFunction）来使排序得到我们想要的结果或者自定义排序的方式。&lt;/p&gt;
&lt;p&gt;　　在大多数实际工作的排序中，我们都会依据id值得大小，或者一些依据数值大小来排序的场景。那么我们看看如何使用compareFunction来使sort排序可以得到正确的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,2,4,9,10,11,20,32,3,6,7,8,15,26&lt;span&gt;];
nums.sort(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (a,b) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a -&lt;span&gt; b;
})
console.log(nums)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [0, 2, 3, 4, 6, 7, 8, 9, 10, 11, 15, 20, 26, 32]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我在刚接触sort时候看到这样的写法，第一个反应就是a和b是什么？他所代表的参数是什么意义？为什么要用a和b?我用其他的参数可以么？&lt;/p&gt;
&lt;p&gt;　　首先，a和b在这里只是代表数组中任意两个元素的值，你可以使用任何两个参数来代表它。&lt;/p&gt;
&lt;p&gt;　　那么再给大家看一个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,2,4,9,10,11,20,32,3,6,7,8,15,26&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; i = 0&lt;span&gt;;
nums.sort(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (m,n) {
    console.log(m,n)
    console.log(&lt;/span&gt;++&lt;span&gt;i)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; m -&lt;span&gt; n;
})
console.log(nums)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [0, 2, 3, 4, 6, 7, 8, 9, 10, 11, 15, 20, 26, 32]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码，给大家留下一个疑问自己去找答案。这里不会多说，看看再不同数组长度下sort会循环多少次？m，n每一次的值又是什么样的？其实一个sort方法就包含很多更深层次的问题。&lt;/p&gt;
&lt;p&gt;　　那么还有一种场景，比如说后端传给我一个包含对象元素的数组，我需要依照id的大小来给这个数组排序，要怎么做呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
objArr.sort(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a,b){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; m =&lt;span&gt; a.id;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n =&lt;span&gt; b.id;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; m -&lt;span&gt; n;
})
console.log(objArr)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　console出来的结果是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201804/1184971-20180411221656128-228285468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么这样就实现了我们在工作场景中排序的大多数的情况。那么如果你想要倒叙排序怎么办呢？a-b变成b-a。其实a-b这样的方式是简写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
nums.sort(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (a,b) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a&amp;lt;&lt;span&gt;b) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a&amp;gt;&lt;span&gt;b) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;或许这样更清晰一点，判断a和b值得大小来决定是否要调换两个值得位置，如果a&amp;lt;b那么a就放在b的后面，如果a&amp;gt;b，那么久把a放在b的前面，如果a既不大于b，也不小于b，那么说明a=b，则不改变两个值得位置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;这里有一篇文章，大家可以去看一下，&lt;a href=&quot;https://segmentfault.com/a/1190000000410506&quot;&gt;JS基础篇--sort()方法的用法，参数以及排序原理&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、多维数组的使用及场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;其实多维数组在平时的工作中还是很常见的，最普通的要说是二维数组了，也可以叫做矩阵。但是其实js是不支持二维或者多维数组的，但是好在js够灵活，我没有的，都可以模拟出来。那么我们也可以通过数组嵌套数组的方式来模拟多维数组。&lt;/p&gt;
&lt;p&gt;　　我们先来看看二维数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; matrix = [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;],[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;],[1,2,3,4]];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这就是一个简单的二维数组形式，我们通常需要遍历数组获取其中的每一个值，其实我们可以把二维数组视为行和列，第一层循环每一行，第二层循环每一行的每一列，这样就可以得到二维数组中的每一个元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; matrix = [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;],[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;],[1,2,3,4&lt;span&gt;]];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; matrix.length; i++&lt;span&gt;) {
    document.write(&lt;/span&gt;&quot;&amp;lt;/br&amp;gt;&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; matrix[i].length;j++&lt;span&gt;) {
        document.write(matrix[i][j])
    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样我们就得到了一个二维数组内所有的元素。&lt;/p&gt;
&lt;p&gt;　　其实三维数组也是一样的，只是再多循环一层，我们来看一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; matrix3 =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
    matrix3[i] &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; 3; j++&lt;span&gt;) {
        matrix3[i][j] &lt;/span&gt;=&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; k = 0; k &amp;lt; 3; k++&lt;span&gt;) {
            matrix3[i][j][k] &lt;/span&gt;= i + j +&lt;span&gt; k;
        }
    }
}
console.log(matrix3)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201804/1184971-20180411225312177-447656454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　数组的介绍到这里就基本结束了，下一篇文章会跟大家一起来看看如何用JS来实现栈这种数据结构。&lt;/p&gt;
&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Apr 2018 15:08:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8784575.html</dc:identifier>
</item>
<item>
<title>【原创】自己动手实现RPC服务调用框架 - 孤独烟</title>
<link>http://www.cnblogs.com/rjzheng/p/8798556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rjzheng/p/8798556.html</guid>
<description>&lt;p&gt;本文利用java自带的socket编程实现了一个简单的rpc调用框架，由两个工程组成分别名为battercake-provider（服务提供者）、battercake-consumer（服务调用者）。&lt;/p&gt;
&lt;h2 id=&quot;服务提供者&quot;&gt;服务提供者&lt;/h2&gt;
&lt;p&gt;本部分的工程为battercake-provider，项目结构图如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1194802/o_batterprovider.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先上rpc框架调用部分的代码，RpcProvider，该部分代码可以总结为两步&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将需要发布的服务存储在一个内存变量serviceList中&lt;/li&gt;
&lt;li&gt;启动socket，server.accept()方法阻塞在那，监听输入&lt;/li&gt;
&lt;li&gt;针对每一个请求，单独启动一个线程处理&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.rpc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.net.ServerSocket;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.Socket;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Arrays;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * RPC服务提供器&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;zhengrongjun&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RpcProvider {
    
    &lt;span class=&quot;co&quot;&gt;//存储注册的服务列表&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; List&amp;lt;Object&amp;gt; serviceList;
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 发布rpc服务&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param object&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param port&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@throws Exception&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;export&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; port,Object&lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;services) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        serviceList=Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(services);
        ServerSocket server = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ServerSocket(port);
        Socket client = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;//阻塞等待输入&lt;/span&gt;
            client = server.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;//每一个请求，启动一个线程处理&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ServerThread&lt;/span&gt;(client,serviceList)).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来ServerThread线程处理类的代码，ServerThread主要做以下几个步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;读取客户端发送的服务名&lt;/li&gt;
&lt;li&gt;判断服务是否发布&lt;/li&gt;
&lt;li&gt;如果发布，则走反射逻辑，动态调用，返回结果&lt;/li&gt;
&lt;li&gt;如果未发布，则返回提示通知&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.rpc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.ObjectInputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.ObjectOutputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.Method;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.Socket;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ServerThread &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Socket client = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; List&amp;lt;Object&amp;gt; serviceList = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ServerThread&lt;/span&gt;(Socket client, List&amp;lt;Object&amp;gt; service) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;client&lt;/span&gt; = client;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;serviceList&lt;/span&gt; = service;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
        ObjectInputStream input = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        ObjectOutputStream output = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            input = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectInputStream(client.&lt;span class=&quot;fu&quot;&gt;getInputStream&lt;/span&gt;());
            output = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectOutputStream(client.&lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;());
            &lt;span class=&quot;co&quot;&gt;// 读取客户端要访问那个service&lt;/span&gt;
            Class serviceClass = (Class) input.&lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 找到该服务类&lt;/span&gt;
            Object obj = &lt;span class=&quot;fu&quot;&gt;findService&lt;/span&gt;(serviceClass);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (obj == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(serviceClass.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;服务未发现&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;//利用反射调用该方法，返回结果&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                    String methodName = input.&lt;span class=&quot;fu&quot;&gt;readUTF&lt;/span&gt;();
                    Class&amp;lt;?&amp;gt;[] parameterTypes = (Class&amp;lt;?&amp;gt;[]) input.&lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;();
                    Object[] arguments = (Object[]) input.&lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;();
                    Method method = obj.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getMethod&lt;/span&gt;(methodName, parameterTypes);  
                    Object result = method.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(obj, arguments);  
                    output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(result); 
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable t) {
                    output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(t);
                }
            }
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                client.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
                input.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
                output.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
                &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated catch block&lt;/span&gt;
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
        }

    }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;findService&lt;/span&gt;(Class serviceClass) {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Object obj : serviceList) {
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; isFather = serviceClass.&lt;span class=&quot;fu&quot;&gt;isAssignableFrom&lt;/span&gt;(obj.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;());
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isFather) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; obj;
            }
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是使用的部分&lt;br/&gt;先创建一个微服务，接口如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.service;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; BatterCakeService {
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 卖煎饼的服务&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param name&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * @return&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;sellBatterCake&lt;/span&gt;(String name);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现类如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.service.impl;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.service.BatterCakeService;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BatterCakeServiceImpl &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; BatterCakeService {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;sellBatterCake&lt;/span&gt;(String name) {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; name+&lt;span class=&quot;st&quot;&gt;&quot;煎饼,卖的特别好&quot;&lt;/span&gt;;
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来就是发布服务&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.start;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.rpc.RpcProvider;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.service.BatterCakeService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.service.impl.BatterCakeServiceImpl;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RpcBootStrap {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        BatterCakeService batterCakeService =&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BatterCakeServiceImpl&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//发布卖煎饼的服务，注册在20006端口&lt;/span&gt;
        RpcProvider.&lt;span class=&quot;fu&quot;&gt;export&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;20006&lt;/span&gt;,batterCakeService);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;服务消费者&quot;&gt;服务消费者&lt;/h2&gt;
&lt;p&gt;本部分的工程为battercake-consumer，项目结构图如下图所示&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1194802/o_batterconsumer.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先上rpc框架调用部分的代码RpcConsumer，步骤分两步&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;封装一个代理类处理器&lt;/li&gt;
&lt;li&gt;返回service的代理类对象&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.rpc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.Proxy;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RpcConsumer {
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T &lt;span class=&quot;fu&quot;&gt;getService&lt;/span&gt;(Class&amp;lt;T&amp;gt; clazz,String ip,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; port) {
        ProxyHandler proxyHandler =&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProxyHandler&lt;/span&gt;(ip,port);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (T)Proxy.&lt;span class=&quot;fu&quot;&gt;newProxyInstance&lt;/span&gt;(RpcConsumer.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;(), &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[] {clazz}, proxyHandler);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来上代理类处理器的代码，代理类处理步骤分以下几步&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建立socket连接&lt;/li&gt;
&lt;li&gt;封装请求数据，发送给服务提供者&lt;/li&gt;
&lt;li&gt;返回结果&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.rpc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.ObjectInputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.ObjectOutputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.InvocationHandler;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.Method;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.net.Socket;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.service.BatterCakeService;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProxyHandler &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; InvocationHandler {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String ip;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; port;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProxyHandler&lt;/span&gt;(String ip, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; port) {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated constructor stub&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ip&lt;/span&gt; = ip;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;port&lt;/span&gt; = port;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(Object proxy, Method method, Object[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Throwable {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;
        Socket socket = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Socket(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ip&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;port&lt;/span&gt;);
        ObjectOutputStream output = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectOutputStream(socket.&lt;span class=&quot;fu&quot;&gt;getOutputStream&lt;/span&gt;());
        ObjectInputStream input = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectInputStream(socket.&lt;span class=&quot;fu&quot;&gt;getInputStream&lt;/span&gt;());
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(proxy.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getInterfaces&lt;/span&gt;()[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
            output.&lt;span class=&quot;fu&quot;&gt;writeUTF&lt;/span&gt;(method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
            output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(method.&lt;span class=&quot;fu&quot;&gt;getParameterTypes&lt;/span&gt;());
            output.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(args);
            output.&lt;span class=&quot;fu&quot;&gt;flush&lt;/span&gt;();
            Object result = input.&lt;span class=&quot;fu&quot;&gt;readObject&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(result &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; Throwable) {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; (Throwable) result;
            }
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            socket.&lt;span class=&quot;fu&quot;&gt;shutdownOutput&lt;/span&gt;();
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来建立一个测试类RpcTest如下（跑该测试类前，记得运行在battercake-provider端的RpcBootstrap类发布BatterCakeService服务）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.rjzheng.start;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.rpc.RpcConsumer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.rjzheng.service.BatterCakeService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RpcTest {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        BatterCakeService batterCakeService=RpcConsumer.&lt;span class=&quot;fu&quot;&gt;getService&lt;/span&gt;(BatterCakeService.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;20006&lt;/span&gt;);
        String result=batterCakeService.&lt;span class=&quot;fu&quot;&gt;sellBatterCake&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;双蛋&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(result);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;双蛋煎饼,卖的特别好&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们就实现了一个简易的rpc服务调用框架&lt;/p&gt;
</description>
<pubDate>Wed, 11 Apr 2018 14:40:00 +0000</pubDate>
<dc:creator>孤独烟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rjzheng/p/8798556.html</dc:identifier>
</item>
</channel>
</rss>