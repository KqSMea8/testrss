<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>微服务初步理解 - Tomorrow1</title>
<link>http://www.cnblogs.com/yucaikang/p/9499236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yucaikang/p/9499236.html</guid>
<description>&lt;h4 id=&quot;本文参考书籍&quot;&gt;本文参考书籍&lt;/h4&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;has-numbering&quot;&gt;https://github.com/oopsguy/microservices-from-design-to-deployment-chinese
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;微服务简介&quot;&gt;微服务简介&lt;/h4&gt;
&lt;h5 id=&quot;单体应用&quot;&gt;单体应用&lt;/h5&gt;
&lt;p&gt;在项目开发启动阶段，比如开发一个电商系统，该系统包括了订单模块、商品搜索模块、用户模块和后台等系统，启动阶段虽然按照业务逻辑分模块开发，但是最终成功上线运行的是一个单体应用，在项目开发的初期，单应用的架构有助于快速更改业务流程，快速迭代，当项目发展到一定时期后，一个庞大、复杂的单体，对于新的功能的开发可能就是陷入了很大的困境，无论是修复线上小的问题还是新需求的开发都设计到整个项目的重新部署和测试，并且降低了开发的效率。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://blog.csdn.net/qq_33339479/article/details/sample.png&quot; alt=&quot;&quot;/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20180804120429956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzM5NDc5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;单体应用架构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当项目发展到一定阶段后，不同模块存在资源需求的冲突，单体应用可能难以扩展；当单体应用在线上实际运行过程中，任何一个模块出现一个bug，都可能会导致整个单体应用不可用。当需要对项目中开发的某个模块进行灰度发布的时候，单体应用往往也不能满足很好的扩展性。那么如何进行改进呢？&lt;/p&gt;
&lt;h5 id=&quot;微服务&quot;&gt;微服务&lt;/h5&gt;
&lt;p&gt;通过将应用程序分解成一套比较小的互联服务，即微服务架构模式。一个服务通常实现了一组不同的特性或功能，例如用户模块等。每一个微服务都是一个迷你应用，都包括了自己实现的业务逻辑，暴露了对外服务的接口，服务可单独部署与开发。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://blog.csdn.net/qq_33339479/article/details/new_arh_blog.png&quot; alt=&quot;&quot;/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20180804120503105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzM5NDc5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;微服务架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用程序的每个功能区域都由相应的微服务实现，每个后端服务暴露相关接口，服务之间可以使用异步或基于消息的通信，一些API也暴露给移动端应用，但是应用不能直接访问后端服务，它们之间的通信都由一个API网关的中介负责，API网关负责负载均衡、缓存、访问控制、API计量和监控。微服务架构模式影响到了应用程序与数据局之间的关系，与其他共享单个数据库模式服务有所不同，其每一个服务都由自己的数据库模式，这样就可以实现松耦合的结构，并且服务可根据自身的需求选择不同的数据库，以达到最佳的适用场景。每个服务也可以选用不同的技术栈来实现不同场景的业务。&lt;/p&gt;
&lt;h4 id=&quot;微服务优缺点&quot;&gt;微服务优缺点&lt;/h4&gt;
&lt;h5 id=&quot;优点&quot;&gt;优点&lt;/h5&gt;
&lt;p&gt;1.解决了复杂的问题，将庞大的单体应用分解成一套服务，虽然功能数量不变，但是应用程序已经被分解成可管理的服务，每个服务都有一个明确定义的API，如RPC或消息驱动，每个服务能更快地开发并更容易理解与维护。&lt;/p&gt;
&lt;p&gt;2.每个服务都可以选用不同的技术栈，由不同的团队开发维护。&lt;/p&gt;
&lt;p&gt;3.每个服务都可以独立部署。&lt;/p&gt;
&lt;p&gt;4.微服务使得每个服务都能够独立扩展。&lt;/p&gt;
&lt;h5 id=&quot;缺点&quot;&gt;缺点&lt;/h5&gt;
&lt;p&gt;1.由于微服务是一个分布式系统，其使得整体项目变得复杂，开发者需要选择和实现基于消息或者rpc的进程间通信机制，此外，由于目标请求可能延迟或不可用，还需要额外的处理机制保证通信。&lt;/p&gt;
&lt;p&gt;2.微服务面临着分区数据库问题，在基于微服务的应用程序中，需要更新不同服务的数据库，一般不会选择分布式事务，不仅因为CAP定理，也是因为如果使用了NoSql数据库和消息代理，就没有很好的支持，最后使用最终一致性方法，这对开发人员来说更具挑战性。&lt;/p&gt;
&lt;p&gt;3.微服务的测试工作相对复杂，一个微服务的测试需要启动该服务所依赖的所有服务，增大了测试的难度。&lt;/p&gt;
&lt;p&gt;4.微服务的部署工作也相对复杂，一个单体应用可以很容易地部署到基于传统负载均衡器的一组服务器上，相比之下，微服务应用程序通常由大量的服务这次，每个服务都可以有多个运行时实例，这对服务的发现机制，服务的部署监控和扩展都提出了更高的要求。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;构建微服务本质上需要考虑的方向很多，需要根据当前项目的业务紧密相关联，单体应用适用于简单、轻量级的应用程序，如果应用发展到一定规模，微服务架构虽然复杂、维护大，但是保证了业务的灵活性和扩展性。如何选择需要实际业务进行选择。&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 15:18:00 +0000</pubDate>
<dc:creator>Tomorrow1</dc:creator>
<og:description>本文参考书籍 微服务简介 在项目开发启动阶段，比如开发一个电商系统，该系统包括了订单模块、商品搜索模块、用户模块和后台等系统，启动阶段虽然按照业务逻辑分模块开发，但是最终成功上线运行的是一个单体应用，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yucaikang/p/9499236.html</dc:identifier>
</item>
<item>
<title>亿级流量场景下，大型缓存架构的虚拟机环境搭建 - 小勇DW3</title>
<link>http://www.cnblogs.com/gxyandwmm/p/9499225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gxyandwmm/p/9499225.html</guid>
<description>&lt;p&gt;---内容持续更新---&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818105315585-180048582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;小型电商：&lt;/h2&gt;
&lt;p&gt;静态模板是固定的 数据库中的数据全量喧嚷到模板中，下次请求来了直接返回，速度也很快；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818110106551-404540120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当数据上亿的时候，如果模板改定，把这些所有的数据在mysql中渲染进模板，非常耗时，不现实；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818110506644-357276788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;大型电商：&lt;/h2&gt;
&lt;p&gt;缓存数据生产服务；&lt;/p&gt;
&lt;p&gt;不需要再进行全量重新渲染，直接将最新的html模板推送到nginx服务器，请求过来后直接在nginx本地进行渲染进模板中返回请求；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818105211785-61724488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;redis的重要性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818112452513-1323113298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 虚拟机环境设置一：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;虚拟机中安装CentOS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动一个virtual box虚拟机管理软件 使用CentOS 6.5镜像即可，CentOS-6.5-i386-minimal.iso。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置网络&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vi /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/p&gt;
&lt;p&gt;DEVICE=eth0&lt;br/&gt;TYPE=Ethernet&lt;br/&gt;ONBOOT=yes&lt;br/&gt;BOOTPROTO=dhcp&lt;br/&gt;service network restart&lt;br/&gt;ifconfig&lt;/p&gt;
&lt;p&gt;BOOTPROTO=static&lt;br/&gt;IPADDR=192.168.0.X&lt;br/&gt;NETMASK=255.255.255.0&lt;br/&gt;GATEWAY=192.168.0.1&lt;br/&gt;service network restart&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置hosts&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vi /etc/hosts&lt;br/&gt;配置本机的hostname到ip地址的映射&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置SecureCRT【本人使用的Xshell 感觉也很好用】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时就可以使用SecureCRT从本机连接到虚拟机进行操作了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭防火墙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;service iptables stop&lt;br/&gt;service ip6tables stop&lt;br/&gt;chkconfig iptables off&lt;br/&gt;chkconfig ip6tables off&lt;/p&gt;
&lt;p&gt;vi /etc/selinux/config&lt;br/&gt;SELINUX=disabled&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭windows的防火墙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置yum&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;yum clean all&lt;br/&gt;yum makecache&lt;br/&gt;yum install wget&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在每个CentOS中都安装Java和Perl&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WinSCP，就是在windows宿主机和linux虚拟机之间互相传递文件的一个工具&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）安装JDK&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、将jdk-7u60-linux-i586.rpm通过WinSCP上传到虚拟机中&lt;br/&gt;2、安装JDK：rpm -ivh jdk-7u65-linux-i586.rpm&lt;br/&gt;3、配置jdk相关的环境变量&lt;br/&gt;vi .bashrc&lt;br/&gt;export JAVA_HOME=/usr/java/latest&lt;br/&gt;export PATH=$PATH:$JAVA_HOME/bin&lt;br/&gt;source .bashrc&lt;br/&gt;4、测试jdk安装是否成功：java -version&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）安装Perl&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;yum install -y gcc&lt;/p&gt;
&lt;p&gt;wget http://www.cpan.org/src/5.0/perl-5.16.1.tar.gz&lt;br/&gt;tar -xzf perl-5.16.1.tar.gz&lt;br/&gt;cd perl-5.16.1&lt;br/&gt;./Configure -des -Dprefix=/usr/local/perl&lt;br/&gt;make &amp;amp;&amp;amp; make test &amp;amp;&amp;amp; make install&lt;br/&gt;perl -v&lt;/p&gt;
&lt;p&gt;为什么要装perl？我们整个大型电商网站的详情页系统，复杂。java+nginx+lua，需要perl。&lt;/p&gt;
&lt;p&gt;perl，是一个基础的编程语言的安装，tomcat，跑java web应用&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、在4个虚拟机中安装CentOS集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）按照上述步骤，再安装三台一模一样环境的linux机器&lt;br/&gt;（2）另外三台机器的hostname分别设置为eshop-cache02，eshop-cache03，eshop-cache04&lt;br/&gt;（3）安装好之后，在每台机器的hosts文件里面，配置好所有的机器的ip地址到hostname的映射关系&lt;/p&gt;
&lt;p&gt;比如说，在eshop-cache01的hosts里面&lt;/p&gt;
&lt;p&gt;192.168.31.187 eshop-cache01&lt;br/&gt;192.168.31.xxx eshop-cache02&lt;br/&gt;192.168.31.xxx eshop-cache03&lt;br/&gt;192.168.31.xxx eshop-cache04&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、配置4台CentOS为ssh免密码互相通信【此时四台linux虚拟机可以通过ssh实现无密码输入通信】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）首先在四台机器上配置对本机的ssh免密码登录&lt;br/&gt;ssh-keygen -t rsa&lt;br/&gt;生成本机的公钥，过程中不断敲回车即可，ssh-keygen命令默认会将公钥放在/root/.ssh目录下&lt;br/&gt;cd /root/.ssh&lt;br/&gt;cp id_rsa.pub authorized_keys&lt;br/&gt;将公钥复制为authorized_keys文件，此时使用ssh连接本机就不需要输入密码了&lt;/p&gt;
&lt;p&gt;（2）接着配置三台机器互相之间的ssh免密码登录&lt;br/&gt;使用ssh-copy-id -i hostname命令将本机的公钥拷贝到指定机器的authorized_keys文件中&lt;/p&gt;

&lt;h2&gt; 虚拟机安装二：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、安装单机版redis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz&lt;br/&gt;tar -xzvf tcl8.6.1-src.tar.gz&lt;br/&gt;cd /usr/local/tcl8.6.1/unix/&lt;br/&gt;./configure&lt;br/&gt;make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;p&gt;使用redis-3.2.8.tar.gz（截止2017年4月的最新稳定版）&lt;br/&gt;tar -zxvf redis-3.2.8.tar.gz&lt;br/&gt;cd redis-3.2.8&lt;br/&gt;make &amp;amp;&amp;amp; make test &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、redis的生产环境启动方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一般的学习课程，你就随便用redis-server启动一下redis，做一些实验，这样的话，没什么意义&lt;/p&gt;
&lt;p&gt;要把redis作为一个系统的daemon进程去运行的，每次系统启动，redis进程一起启动&lt;/p&gt;
&lt;p&gt;（1）redis utils目录下，有个redis_init_script脚本&lt;br/&gt;（2）将redis_init_script脚本拷贝到linux的/etc/init.d目录中（初始化目录），将redis_init_script重命名为redis_6379，6379是我们希望这个redis实例监听的端口号&lt;br/&gt;（3）修改redis_6379脚本的第6行的REDISPORT，设置为相同的端口号（默认就是6379）&lt;br/&gt;（4）创建两个目录：/etc/redis（存放redis的配置文件），/var/redis/6379（存放redis的持久化文件，也就是后面要使用的redis备份）&lt;br/&gt;（5）修改redis配置文件（默认在根目录下，redis.conf），拷贝到/etc/redis目录中，修改名称为6379.conf&lt;/p&gt;
&lt;p&gt;（6）修改redis.conf中的部分配置为生产环境&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;daemonize yes 让redis以daemon进程运行（守护线程，可以理解为java运行时的jvm线程，在后台进行service服务）&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;pidfile /var/run/redis_6379.pid 设置redis的pid文件位置 【/var/run 目录下放的是各程序的pid&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;strong&gt;port 6379 设置redis的监听端口号&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;dir /var/redis/6379 设置持久化文件的存储位置&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;（7）启动redis，执行cd /etc/init.d, chmod 777 redis_6379，./redis_6379 start&lt;/p&gt;
&lt;p&gt;（8）确认redis进程是否启动，ps -ef | grep redis&lt;/p&gt;
&lt;p&gt;（9）让redis跟随系统启动自动启动&lt;/p&gt;
&lt;p&gt;在redis_6379脚本中，最上面，加入两行注释&lt;/p&gt;
&lt;p&gt;# chkconfig: 2345 90 10&lt;/p&gt;
&lt;p&gt;# description: Redis is a persistent key-value database&lt;/p&gt;
&lt;p&gt;chkconfig redis_6379 on&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;3、redis cli的使用&lt;/p&gt;
&lt;p&gt;redis-cli SHUTDOWN，连接本机的6379端口停止redis进程&lt;/p&gt;
&lt;p&gt;redis-cli -h 127.0.0.1 -p 6379 SHUTDOWN，制定要连接的ip和端口号&lt;/p&gt;
&lt;p&gt;redis-cli PING，ping redis的端口，看是否正常&lt;/p&gt;
&lt;p&gt;redis-cli，进入交互式命令行&lt;/p&gt;
&lt;p&gt;存取删测试：&lt;/p&gt;
&lt;p&gt;SET k1 v1&lt;br/&gt;GET k1&lt;/p&gt;
&lt;p&gt;del k1&lt;/p&gt;
&lt;p&gt;redis的技术，包括4块&lt;/p&gt;
&lt;p&gt;redis各种数据结构和命令的使用，包括java api的使用&lt;br/&gt;redis一些特殊的解决方案的使用，pub/sub消息系统，&lt;span&gt;分布式锁，&lt;/span&gt;输入的自动完成，等等&lt;br/&gt;redis日常的管理相关的命令&lt;br/&gt;&lt;span&gt;redis企业级的集群部署和架构&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; Redis在不使用备份的情况下会产生缓存雪崩问题；&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1449963/201808/1449963-20180818230550852-1985003621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;






























&lt;p&gt;---恢复内容结束---&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 15:16:00 +0000</pubDate>
<dc:creator>小勇DW3</dc:creator>
<og:description>内容持续更新 小型电商： 静态模板是固定的 数据库中的数据全量喧嚷到模板中，下次请求来了直接返回，速度也很快； 当数据上亿的时候，如果模板改定，把这些所有的数据在mysql中渲染进模板，非常耗时，不现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gxyandwmm/p/9499225.html</dc:identifier>
</item>
<item>
<title>java8新特性（三）_Optional类的使用 - 养码青年</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9499073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9499073.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;说实话，我第一次知道这个东西是从阿里规约中，因为公司前一段时间一直在搞代码审核，我的代码写的就感觉很烂，就像规范下。让别人看起来没那么烂。于是就开始看阿里规约，在看到NPE处理的时候，上面提到用Optional类进行处理。这就是我第一次知道这个东东。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;optional简介&quot;&gt;Optional简介&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Optional 类的引入很好的解决空指针异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;optional源码查看&quot;&gt;Optional源码查看&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里建议大家自行阅读其完整源码，这里只分析filter 和 map 方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;类的属性和方法&quot;&gt;类的属性和方法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/20180818222207.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中我们可以看出，它的构造方法都是private修饰的。其实是一个单例模式的应用。&lt;/p&gt;
&lt;h4 id=&quot;filter-方法&quot;&gt;filter 方法&lt;/h4&gt;
&lt;p&gt;该方法是过滤方法，过滤符合条件的Optional对象，这里的条件用Lambda表达式来定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public Optional&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super T&amp;gt; predicate) {
        //如果入参predicate对象为null将抛NullPointerException异常
        Objects.requireNonNull(predicate);
        //如果Optional对象的值为null，将直接返回该Optional对象
        if (!isPresent())
            return this;
        //如果Optional对象的值符合限定条件（Lambda表达式来定义），返回该值，否则返回空的Optional对象
        else
            return predicate.test(value) ? this : empty();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;map方法&quot;&gt;map方法&lt;/h4&gt;
&lt;p&gt;map方法用于修改该值，并返回修改后的Optional对象,一般会在多级取值的时候用到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public&amp;lt;U&amp;gt; Optional&amp;lt;U&amp;gt; map(Function&amp;lt;? super T, ? extends U&amp;gt; mapper) {
        //如果入参mapper对象为null将抛NullPointerException异常
        Objects.requireNonNull(mapper);
        //如果Optional对象的值为null，将直接返回该Optional对象
        if (!isPresent())
            return empty();
        //执行传入的lambda表达式，并返回经lambda表达式操作后的Optional对象
        else {
            return Optional.ofNullable(mapper.apply(value));
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实战演练&quot;&gt;实战演练&lt;/h3&gt;
&lt;h4 id=&quot;判断不为null然后进行操作&quot;&gt;判断不为null然后进行操作&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;     /**
     * 不为null时进行操作
     *
     * @param name
     */
    public static void doThing(String name) {
        if (name != null) {
            System.out.println(name);
        }
    }

    public static void doThingOptional(String name) {
        Optional.ofNullable(name)
                .ifPresent(System.out::println);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多层级取值&quot;&gt;多层级取值&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * 多级取值
     *
     * @param user
     * @return
     */
    public static String getAddress(UserEntity user) {
        if (user != null) {
            AddressEntity addressEntity = user.getAddressEntity();
            if (addressEntity != null) {
                String address = addressEntity.getAddress();
                if (address != null &amp;amp;&amp;amp; address.length() &amp;gt; 3) {
                    return address;
                }

            }
        }

        return null;
    }

    public static String getAddressOptional(UserEntity user) {
        return Optional.ofNullable(user)
                .map(u -&amp;gt; u.getAddressEntity())
                .map(a -&amp;gt; a.getAddress())
                .filter(s -&amp;gt; s.length() &amp;gt; 3)
                .orElse(null);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，玩的开心.&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 14:44:00 +0000</pubDate>
<dc:creator>养码青年</dc:creator>
<og:description>说实话，我第一次知道这个东西是从阿里规约中，因为公司前一段时间一直在搞代码审核，我的代码写的就感觉很烂，就像规范下。让别人看起来没那么烂。于是就开始看阿里规约，在看到NPE处理的时候，上面提到用Opt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9499073.html</dc:identifier>
</item>
<item>
<title>Java 集合之 Collection - YJK923</title>
<link>http://www.cnblogs.com/YJK923/p/9498975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YJK923/p/9498975.html</guid>
<description>&lt;p&gt;集合就是一组数的集合，就像是一个容器，但是我们应该清楚的是集合中存放的都是对象的引用，而不是真正的实体。而我们常说的集合中的对象其实指的就是对象的引用。&lt;/p&gt;

&lt;p&gt;我们可以把集合理解为一个小型数据库，用于存放数据，我们对集合的操作也就是数据的增删改查，在 Java 中有两个顶层接口 Collection 和 Map 用于定义和规范集合的相关操作。这篇文章主要说一下集合框架中的 Collection 部分。&lt;/p&gt;

&lt;p&gt;Collection 表示一组对象，这些对象可以是有序也可以是无序的，它提供了不同的子接口满足我们的需求。我们主要看看 List 和 Set 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1453063/201808/1453063-20180818222304068-2093936246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;List 整体的特征就是有序可重复。我们需要研究的是上图中具体的实现类都有什么特性。底层的实现原理是什么，首先来看一看 List 的古老的实现类 Vector ，说是古老是因为在 JDK 1.0 的时候就出现了，都走开，我要开始看源码了！这些源码来自于 JDK 1.7。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Vector&amp;lt;E&amp;gt;
    &lt;span&gt;extends&lt;/span&gt; AbstractList&amp;lt;E&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; List&amp;lt;E&amp;gt;&lt;span&gt;, RandomAccess, Cloneable, java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The array buffer into which the components of the vector are
     * stored.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object[] elementData;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The number of valid components in this {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Vector} object.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; elementCount;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The amount by which the capacity of the vector is automatically
     * incremented when its size becomes greater than its capacity.  If
     * the capacity increment is less than or equal to zero, the capacity
     * of the vector is doubled each time it needs to grow.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacityIncrement;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Vector() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(10&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        modCount&lt;/span&gt;++&lt;span&gt;;
        ensureCapacityHelper(elementCount &lt;/span&gt;+ 1&lt;span&gt;);
        elementData[elementCount&lt;/span&gt;++] =&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; E remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index &amp;gt;=&lt;span&gt; elementCount)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayIndexOutOfBoundsException(index);
        E oldValue &lt;/span&gt;=&lt;span&gt; elementData(index);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; numMoved = elementCount - index - 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numMoved &amp;gt; 0&lt;span&gt;)
            System.arraycopy(elementData, index&lt;/span&gt;+1&lt;span&gt;, elementData, index,
                             numMoved);
        elementData[&lt;/span&gt;--elementCount] = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Let gc do its work&lt;/span&gt;

        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; E set(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index &amp;gt;=&lt;span&gt; elementCount)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayIndexOutOfBoundsException(index);

        E oldValue &lt;/span&gt;=&lt;span&gt; elementData(index);
        elementData[index] &lt;/span&gt;=&lt;span&gt; element;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; E get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index &amp;gt;=&lt;span&gt; elementCount)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayIndexOutOfBoundsException(index);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; elementData(index);
    }
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;就以上源码分析就可以知道关于 Vector 的特征。1 底层实现是使用数组来存储数据，所以相应的查找元素和添加元素速度较快，删除和插入元素较慢。2 数组的初始长度为 10 ，当长度不够时，增长量也为 10 使用变量 capacityIncrement 来表示。3 方法的声明中都加入了 synchronized 关键字，线程安全的，所以效率相应降低了。 4 没分析出来的再看一遍。 &lt;/p&gt;

&lt;p&gt;下面开始看 ArrayList 的源码。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArrayList&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractList&amp;lt;E&amp;gt;
        &lt;span&gt;implements&lt;/span&gt; List&amp;lt;E&amp;gt;&lt;span&gt;, RandomAccess, Cloneable, java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 8683452581122892189L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Default initial capacity.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = 10&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Shared empty array instance used for empty instances.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object[] EMPTY_ELEMENTDATA =&lt;span&gt; {};

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The array buffer into which the elements of the ArrayList are stored.
     * DEFAULT_CAPACITY when the first element is added.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt;&lt;span&gt; Object[] elementData;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructs an empty list with an initial capacity of ten.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ArrayList() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elementData =&lt;span&gt; EMPTY_ELEMENTDATA;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        ensureCapacityInternal(size &lt;/span&gt;+ 1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increments modCount!!&lt;/span&gt;
        elementData[size++] =&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加数组的长度&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; grow(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow-conscious code&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; elementData.length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; 0&lt;span&gt;)
            newCapacity &lt;/span&gt;=&lt;span&gt; minCapacity;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0&lt;span&gt;)
            newCapacity &lt;/span&gt;=&lt;span&gt; hugeCapacity(minCapacity);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; minCapacity is usually close to size, so this is a win:&lt;/span&gt;
        elementData =&lt;span&gt; Arrays.copyOf(elementData, newCapacity);
    }
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为源码和 Vector 类似，所以有些就不贴了，但是不耽误我们继续分析 ArrayList 。1 底层存储数据使用的还是数组，长度依旧为 10 ，但是进步了，没有在刚开始创建的时候就初始化，而是在添加第一个元素的时候才初始化的。2 方法的声明少了 synchronized 关键字，线程不安全，但性能提高了。3 数组长度不够时，会自动增加为原长度的 1.5 倍。&lt;/p&gt;

&lt;p&gt;以上分析也能体现出 Vector 和 ArrayList 的差别。主要就是想说 Vector 已经不用了。使用 ArrayList 即可，关于线程安全问题，后面再说。&lt;/p&gt;

&lt;p&gt;接着看 LinkedList 的实现，上源码 ~&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedList&amp;lt;E&amp;gt;
    &lt;span&gt;extends&lt;/span&gt; AbstractSequentialList&amp;lt;E&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;&lt;span&gt;, Cloneable, java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Pointer to first node.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; first;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Pointer to last node.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; last;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructs an empty list.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkedList() {
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每一个元素即为一个节点，节点的结构如下（这是一个内部类啊）&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; {
        E item;
        Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; next;
        Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; prev;

        Node(Node&lt;/span&gt;&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; element;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prev =&lt;span&gt; prev;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        linkLast(e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkLast(E e) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l =&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(l, e, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        last &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            l.next &lt;/span&gt;=&lt;span&gt; newNode;
        size&lt;/span&gt;++&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除某个节点的逻辑&lt;/span&gt;
    E unlink(Node&amp;lt;E&amp;gt;&lt;span&gt; x) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert x != null;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; E element =&lt;span&gt; x.item;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; next =&lt;span&gt; x.next;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; prev =&lt;span&gt; x.prev;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            first &lt;/span&gt;=&lt;span&gt; next;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            prev.next &lt;/span&gt;=&lt;span&gt; next;
            x.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            last &lt;/span&gt;=&lt;span&gt; prev;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            next.prev &lt;/span&gt;=&lt;span&gt; prev;
            x.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        x.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size&lt;/span&gt;--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重点就是 LinkedList 的底层实现是双链表。这样就会有以下特性，1 查找元素较慢，但是添加和删除较快。2 占内存，因为每一个节点都要维护两个索引。3 线程不安全 。4 对集合长度没有限制。&lt;/p&gt;

&lt;p&gt;以上，List 的几个实现已经分析完成，以后再谈到 Vector ，ArrayList ，LinkedList 之间的区别应该不会不知所云了吧！还要接着看 Collection 的另一个子接口 Set 。首先有个大前提，Set 中存储的元素是无序不可重复的。然后我们再来看实现类是如何实现的。下面开始 HashSet 的表演。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashSet&amp;lt;E&amp;gt;
    &lt;span&gt;extends&lt;/span&gt; AbstractSet&amp;lt;E&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; Set&amp;lt;E&amp;gt;&lt;span&gt;, Cloneable, java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; HashMap&amp;lt;E,Object&amp;gt;&lt;span&gt; map;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Dummy value to associate with an Object in the backing Map&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object PRESENT = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructs a new, empty set; the backing &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; instance has
     * default initial capacity (16) and load factor (0.75).
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HashSet() {
        map &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加元素，其实就是像 Map 中添加主键，所以添加的元素不能重复&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; map.put(e, PRESENT)==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现 Iterable 接口中的 Iterator 方法。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map.keySet().iterator();
    }
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看了源码才发现，1 原来 HashSet 就是对 HashMap 的封装啊，底层实现是基于 hash 表的，回头有必要再好好的介绍一下 hash 相关的知识。2 Set 集合中的值，都会以 key 的形式存放在 Map 中，所以说 Set 中的元素不能重复。3 线程不安全。4 允许存放空值，因为 Map 的键允许为空。&lt;/p&gt;

&lt;p&gt;今天要说的最后一个实现类终于出现啦，他就是 TreeSet ，这个实现类中的元素是有序的！注意这里说的有序是指按照一定的规则排序，而我们说 Set 集合中的元素无序是因为添加进集合的顺序和输出的顺序不保证一致。TreeSet 是怎么保证有序我们待会再说，还是一样的套路，是对 TreeMap 的封装，线程依旧不安全。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TreeSet&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractSet&amp;lt;E&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; NavigableSet&amp;lt;E&amp;gt;&lt;span&gt;, Cloneable, java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The backing map.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; NavigableMap&amp;lt;E,Object&amp;gt;&lt;span&gt; m;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Dummy value to associate with an Object in the backing Map&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object PRESENT = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructs a set backed by the specified navigable map.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    TreeSet(NavigableMap&lt;/span&gt;&amp;lt;E,Object&amp;gt;&lt;span&gt; m) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.m =&lt;span&gt; m;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructs a new, empty tree set, sorted according to the
     * natural ordering of its elements.  All elements inserted into
     * the set must implement the Comparable interface.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeSet() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; TreeMap&amp;lt;E,Object&amp;gt;&lt;span&gt;());
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructs a new, empty tree set, sorted according to the specified
     * comparator.  All elements inserted into the set must be mutually
     * comparable by the specified comparator
     * If the Comparable natural ordering of the elements will be used.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; TreeSet(Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; comparator) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;&lt;span&gt;(comparator));
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加元素方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; m.put(e, PRESENT)==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }    
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到 TreeSet 中构造函数上方的注释，TreeSet 要保证元素有序，保证有序的思路是在添加元素的时候进行比较。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
... &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是 TreeMap 的 put 方法的节选，为了看到比较的过程。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
    ...
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; split comparator and comparable paths&lt;/span&gt;
        Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt; cpr =&lt;span&gt; comparator;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cpr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                parent &lt;/span&gt;=&lt;span&gt; t;
                cmp &lt;/span&gt;=&lt;span&gt; cpr.compare(key, t.key);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
                    t &lt;/span&gt;=&lt;span&gt; t.left;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cmp &amp;gt; 0&lt;span&gt;)
                    t &lt;/span&gt;=&lt;span&gt; t.right;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t.setValue(value);
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            Comparable&lt;/span&gt;&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt; k = (Comparable&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt;) key;
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                parent &lt;/span&gt;=&lt;span&gt; t;
                cmp &lt;/span&gt;=&lt;span&gt; k.compareTo(t.key);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
                    t &lt;/span&gt;=&lt;span&gt; t.left;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cmp &amp;gt; 0&lt;span&gt;)
                    t &lt;/span&gt;=&lt;span&gt; t.right;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t.setValue(value);
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
    ...
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Java 中提供了两种方式，第一种方法，需要我们所添加对象的类实现 Comparable 接口，进而实现 compareTo 方法，这种方式也叫自然排序，我们并没有传入什么排序规则。这种方式对应 TreeSet 的空参构造器。而另一种方式就是定制排序，即我们自己定义两个元素的排序规则，在实例化 TreeSet 的时候传入对应的排序规则即可，对应于 TreeSet 中带有 Comparator 接口的构造器，这里面需要实现 compare 方法 。有点迷糊了是吧，举个例子看看 ~&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt; Comparable&amp;lt;Person&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String name,Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 自定义的比较的逻辑：
     *      首先按照对象的 name 属性排序
     *      其次按照 age 属性排序
     * 方法的返回值为 0 ，大于 0，小于 0 ，分别对应于 相等，大于，和小于
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(Person o) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name.compareTo(o.name);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i == 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age.compareTo(o.age);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;[Person] name:&quot;+&lt;span&gt;this&lt;/span&gt;.name+&quot; age:&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    }
}

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下是测试代码&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TreeSet&lt;/span&gt;&amp;lt;Person&amp;gt; set = &lt;span&gt;new&lt;/span&gt; TreeSet&amp;lt;&amp;gt;&lt;span&gt;();
        set.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;AJK923&quot;,20&lt;span&gt;));
        set.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;BJK923&quot;,20&lt;span&gt;));
        set.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;AJK923&quot;,21&lt;span&gt;));
        set.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;BJK923&quot;,21&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Person person : set) {
            System.out.println(person.toString());
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        [Person] name:AJK923 age:20
        [Person] name:AJK923 age:21
        [Person] name:BJK923 age:20
        [Person] name:BJK923 age:21
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                
        ----以下为定制排序的部分----匿名内部类实现 Comparator 接口----&lt;span&gt;        
        TreeSet&lt;/span&gt;&amp;lt;Person&amp;gt; set2 = &lt;span&gt;new&lt;/span&gt; TreeSet&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Person&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Person o1, Person o2) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; o1.age.compareTo(o2.age);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i == 0&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o1.name.compareTo(o2.name);
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
                }
            }
        });

        set2.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;AJK923&quot;,20&lt;span&gt;));
        set2.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;BJK923&quot;,20&lt;span&gt;));
        set2.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;AJK923&quot;,21&lt;span&gt;));
        set2.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;BJK923&quot;,21&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Person person : set2) {
            System.out.println(person.toString());
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
            [Person] name:AJK923 age:20
            [Person] name:BJK923 age:20
            [Person] name:AJK923 age:21
            [Person] name:BJK923 age:21
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面就是自然排序和定制排序的应用。要说明几点：&lt;/p&gt;
&lt;p&gt;1 定制排序和自然排序同时存在的话，优先执行定制排序。可以看看上面的 put 方法的实现 。&lt;/p&gt;

&lt;p&gt;2 自然排序对应 Comparable 接口，定制排序对应 Comparator 接口。&lt;/p&gt;

&lt;p&gt;3 String ，包装类，日期类都已经实现了 Comparable 接口的 comparaTo 方法，所以我上面的例子中都偷懒了，没有自己实现具体比较，而是直接调用现成的。&lt;/p&gt;

&lt;p&gt;看到这里，也算是对 Collection 有了整体的认识，但是这里我并没有说到具体的 API ，我现在日常也用不到几个方法，就放一张 Collection 接口的结构图吧，方法也比较简单，看个名字就大概知道什么意思了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1453063/201808/1453063-20180818222611615-1249191867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是要重点说一下 iterator 方法。这个方法定义在 Iterable 接口中（Collection 继承了 Iterable 接口），方法返回的是 iterator 接口对象。iterator 中定义了迭代器的操作规则，而 Collection 的实现类中是具体的实现。Iterator 接口中定义了 next ，hasNext 和 remove 方法。看一下在ArrayList 中是如何实现的吧。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cursor;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index of next element to return&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastRet = -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index of last element returned; -1 if no such&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; expectedModCount =&lt;span&gt; modCount;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cursor !=&lt;span&gt; size;
        }

        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            checkForComodification();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; size)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
            Object[] elementData &lt;/span&gt;= ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; elementData.length)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            cursor &lt;/span&gt;= i + 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E) elementData[lastRet =&lt;span&gt; i];
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastRet &amp;lt; 0&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
            checkForComodification();

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                ArrayList.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remove(lastRet);
                cursor &lt;/span&gt;=&lt;span&gt; lastRet;
                lastRet &lt;/span&gt;= -1&lt;span&gt;;
                expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IndexOutOfBoundsException ex) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            }
        }

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }


应用起来还是比较简单的，使用一个 &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; 循环即可。看下面这个例子。



       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        List&lt;/span&gt;&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(); 
        list.add(&lt;/span&gt;1&lt;span&gt;);
        list.add(&lt;/span&gt;2&lt;span&gt;);
        list.add(&lt;/span&gt;3&lt;span&gt;);

        Iterator&lt;/span&gt;&amp;lt;Integer&amp;gt; it =&lt;span&gt; list.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (it.hasNext()) {
            Integer i &lt;/span&gt;=&lt;span&gt; it.next();
            System.out.println(i);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不知道你有没有发现，除了 Vector 以外，保存集合元素的那个变量都定义为 transient 不管你是数组，Node 或是 Map ，不由得我又要想一想为什么这样设计？&lt;/p&gt;

&lt;p&gt;先看一下 transient 的作用吧！Java 的 serialization 提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用 serialization 机制来保存它。为了在一个特定对象的一个域上关闭 serialization，可以在这个域前加上关键字 transient 。当一个对象被序列化的时候，transient 型变量的值不包括在序列化的表示中，非 transient 型的变量是被包括进去的。&lt;/p&gt;

&lt;p&gt;那么为什么要这么做呢，好好的标准序列化不用，原因如下：&lt;/p&gt;

&lt;p&gt;对于 ArrayList 来说，底层实现是数组，而数组的长度和容量不一定相等，可能容量为 10 ，而我们的元素只有 5 。此时序列化的时候就有点浪费资源，序列化和反序列化还是要的，故 ArrayList 自己实现了两个方法，分别是 writeObject 和 readObject ，用于序列化和反序列化。&lt;/p&gt;

&lt;p&gt;对于 HashSet 和  HashMap 来说，底层实现都是依赖于 hash 表，而不同的 JVM 可能算出的 hashCode 值不一致，这样在跨平台的时候就会导致序列化紊乱。故也重写了那两个方法。借用一句似懂非懂的话：&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当一个对象的物理表示方法与它的逻辑数据内容有实质性差别时，使用默认序列化形式有 N 种缺陷，所以应该尽可能的根据实际情况重写序列化方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对应于 Collection ，有一个 Collections 工具类，其中提供很多方法，比如说集合的排序，求子集合，最大值，最小值，交换，填充，打乱集合等等，还记得上面说到的实现类中存在线程不安全的情况吧，这个工具类中提供很多对应的 synchronized 的方法。&lt;/p&gt;

&lt;p&gt;后记 ：不知不觉中扩展了这么多知识点，实话说，肯定还有遗漏的地方，就我现在能想到的依然还有很多，除去 Hash 表和 Hash 算法这一部分之外，我还没有对底层的数据结构进一步分析，数组，链表，二叉树等等，现在是分析不动了，本文已经很长了。&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 14:28:00 +0000</pubDate>
<dc:creator>YJK923</dc:creator>
<og:description>集合就是一组数的集合，就像是一个容器，但是我们应该清楚的是集合中存放的都是对象的引用，而不是真正的实体。而我们常说的集合中的对象其实指的就是对象的引用。 我们可以把集合理解为一个小型数据库，用于存放数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YJK923/p/9498975.html</dc:identifier>
</item>
<item>
<title>使用 intellijIDEA 创建 maven 工程进行 Spring ioc 测试 - 希希里之海</title>
<link>http://www.cnblogs.com/weixuqin/p/9498918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weixuqin/p/9498918.html</guid>
<description>&lt;h2 id=&quot;使用-intellijidea-创建-maven-工程进行-spring-ioc-测试&quot;&gt;使用 intellijIDEA 创建 maven 工程进行 Spring ioc 测试&lt;/h2&gt;
&lt;h2 id=&quot;ioc-概念&quot;&gt;ioc 概念&lt;/h2&gt;
&lt;p&gt;控制反转（Inversion of Control，缩写为&lt;strong&gt;IOC&lt;/strong&gt;），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做&lt;strong&gt;依赖注入&lt;/strong&gt;（Dependency Injection，简称&lt;strong&gt;DI&lt;/strong&gt;）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。&lt;/p&gt;
&lt;h3 id=&quot;ioc和di区别&quot;&gt;IOC和DI区别&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;IOC: 控制反转，把对象创建交给spring进行配置&lt;/li&gt;
&lt;li&gt;DI: 依赖注入，向类里面的属性中设置值&lt;/li&gt;
&lt;li&gt;关系：依赖注入不能单独存在，需要在ioc基础之上完成操作&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;创建-spring-实例进行-ioc-测试&quot;&gt;创建 spring 实例进行 ioc 测试&lt;/h3&gt;
&lt;p&gt;我们使用 intellijIDEA 来完成这一操作，首先创建 maven 工程（maven提供了 java 中 jar 包的下载管理，方便我们使用下载和导入 jar 包，推荐使用）。打开 idea，选择 &lt;code&gt;Create New Project&lt;/code&gt;, 在弹出来的窗口中选择创建 maven 工程，设置好 JDK 后点击 next 进行下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fue3b38wxzj30rd0fsgpm.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置好 GrouId、ArtifactId、Version 后，按提示一路设置创建好 maven 项目。&lt;br/&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fue3fw95qjj30rc0fraas.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们修改 pom.xml 设置，配置需要添加下载的 jar 包：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.2.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.2.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.2.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-expression&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.2.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们修改pom.xml 文件时，idea 会提示我们导入，我们点击 &lt;code&gt;Import Change&lt;/code&gt;即可，当然也可以设置&lt;code&gt;Auto-Import&lt;/code&gt;自动导入：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fue3kiwworj30bh034q37.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在 &lt;code&gt;src/main/java&lt;/code&gt; 下新建一个 package：&lt;code&gt;cn.itcast.ioc&lt;/code&gt;, 并在 package 下新建 User.java:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.itcast.ioc;

public class User {
    public void add(){
        System.out.println(&quot;add......&quot;);
    }

    //public static void main(String[] args) {
        //原始做法
        //User user = new User();
        //user.add();
    //}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 resources目录下新建 applicationContext.xml 配置文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!-- scheme约束 --&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;!-- ioc 入门 --&amp;gt;
    &amp;lt;bean id=&quot;user&quot; class=&quot;cn.itcast.ioc.User&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 &lt;code&gt;src/main/java&lt;/code&gt; 下创建测试文件 TestIOC.java ，尝试能否通过装载 bean，交由 spring 创建对象，通过配置文件输出 ioc 实例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.itcast.ioc;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestIOC {
    @Test
    public void testUser(){
        //1.加载 spring 配置文件,根据创建对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //2.得到配置创建的对象
        User user = (User) context.getBean(&quot;user&quot;);
        user.add();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行 TestIOC.java , 若控制台能输出 add() 方法，便测试成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fue477eegxj30ck039aai.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;通过配置文件注入属性&quot;&gt;通过配置文件注入属性&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;介绍：创建对象时候，向类里面属性设置值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 spring 中我们一般采用通过set 方法注入。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;src/main/java/&lt;/code&gt; 下创建 UserService.java:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.itcast.ioc;

public class UserService {

    //1 定义 user 类型
    private User user;
    //2 生成set 方法
    public void setUser(User user) {
        this.user = user;
    }

    public void add(){
        System.out.println(&quot;service....&quot;);
        user.add();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 applicationContext.xml 文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

&amp;lt;!-- 注入对象类型 --&amp;gt;
    &amp;lt;!-- 配置 service 和 user 对象 --&amp;gt;
    &amp;lt;bean id=&quot;user&quot; class=&quot;cn.itcast.ioc.User&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.ioc.UserService&quot;&amp;gt;
        &amp;lt;!-- 注入 user 对象
                name 属性值, service 类里面的属性名称
                ref 属性， 配置bean 标签中 id 值
       --&amp;gt;
        &amp;lt;property name=&quot;user&quot; ref=&quot;user&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 TestIOC.java:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.itcast.ioc;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestIOC {
    @Test
    public void testUser(){
        //1.加载 spring 配置文件,根据创建对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //2.得到配置创建的对象
        UserService userService = (UserService) context.getBean(&quot;userService&quot;);
        userService.add();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功在控制台输出 UserService类的 add() 方法和注入的属性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwly1fue68150vgj308403ijrs.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通过注解创建-ioc-实例&quot;&gt;通过注解创建 ioc 实例&lt;/h3&gt;
&lt;p&gt;上述实例是通过配置 xml 文件来实现创建对象的功能，spring 也提供了另一种方式来实现上述功能：注解。&lt;/p&gt;
&lt;h4 id=&quot;注解介绍&quot;&gt;注解介绍&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;代码里面特殊标记，使用注解可以完成功能&lt;/li&gt;
&lt;li&gt;注解写法 @注解名称(属性名称=属性值)&lt;/li&gt;
&lt;li&gt;注解使用在类上面，方法上面和属性上面&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;创建对象的四个注解&quot;&gt;创建对象的四个注解&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;@Component&lt;/li&gt;
&lt;li&gt;@Controller&lt;/li&gt;
&lt;li&gt;@Service&lt;/li&gt;
&lt;li&gt;@Repository&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要是通过 Component 衍生出 其他三个在web 层、业务层、持久层注解，主要是为了后续增强。但对我来说这四个注解功能目前来说是一样的，都是创建对象。&lt;/p&gt;
&lt;p&gt;我们重新配置一下 applicationContext.xml 文件，引入新的约束，开启注解扫描：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt; &amp;lt;!-- bean definitions here --&amp;gt;

    &amp;lt;!-- 开启注解扫描
        (1) 到包里面扫描类,方法,属性上面是否有注解
    --&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;cn.itcast.ioc&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
    &amp;lt;!-- 扫描属性上面的注解 --&amp;gt;
    &amp;lt;!--&amp;lt;context:annotation-config&amp;gt;&amp;lt;/context:annotation-config&amp;gt;--&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 User.java 文件：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.itcast.ioc;

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

@Service(value = &quot;user&quot;)  //相当于&amp;lt;bean id=&quot;user&quot; class=&quot;&quot;/&amp;gt;
@Scope(value = &quot;prototype&quot;) //多实例

public class User {
    public void add(){
        System.out.println(&quot;add........&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改TestIOC.java：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.itcast.ioc;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestIOC {
    @Test
    public void testUser(){
        //1.加载 spring 配置文件,根据创建对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //2.得到配置创建的对象,这里的getBean()方法中的 user 为User类通过注解的 value 值。
        User user = (User) context.getBean(&quot;user&quot;);
        user.add();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台成功输入User 类的 add()方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwly1fue477eegxj30ck039aai.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;通过注解注入属性&quot;&gt;通过注解注入属性&lt;/h4&gt;
&lt;p&gt;同样的，我们可以通过使用注解注入属性。&lt;/p&gt;
&lt;p&gt;这里有两种方式，我们可以通过使用 @Autowired（自动注入）或 @Resource(name=&quot;value&quot;)（name属性值：注解创建对象 value 值），推荐使用后一种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：使用注解不需要 set 方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是举个栗子：&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;src/main/java/&lt;/code&gt; 下创建 package 和 UserDao.java 和 UserService.java。&lt;/p&gt;
&lt;p&gt;UserDao.java:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.itcast.anno;

import org.springframework.stereotype.Service;

@Service(value = &quot;userDao&quot;)
public class UserDao {
    public void add(){
        System.out.println(&quot;dao.........&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UserService.java:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.itcast.anno;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import javax.annotation.Resource;

@Service(value = &quot;userService&quot;)
public class UserService {

    //得到dao 对象
    //定义 dao 类型
    //方法一：在 dao属性上面使用注解,完成对象注入
//    @Autowired
//    private UserDao userDao;
    //使用注解不需要set 方法
    
    //方法二：
    //name属性值: 注解创建 dao对象 value 值
    @Resource(name = &quot;userDao&quot;)
    private UserDao userDao;

    public void add(){
        System.out.println(&quot;service.......&quot;);
        userDao.add();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用上述 applicationContext.xml 中的注解配置，创建 TestAnno.java:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.itcast.anno;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestAnno {

    @Test
    public void TestService(){
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserService userService = (UserService) context.getBean(&quot;userService&quot;);
        userService.add();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行 TestAnno.java ，控制台输出如下信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwly1fue6tk6xewj309403pmxl.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;通过 spring框架的 ioc 容器，我们可以把对象的创建交给 spring 进行，降低代码的耦合度。&lt;/li&gt;
&lt;li&gt;使用 spring 框架 ioc 容器，可以通过配置 xml 文件和注解两种方式进行管理。&lt;/li&gt;
&lt;li&gt;掌握注入属性的两种方式：配置 xml 文件和注解。&lt;/li&gt;
&lt;li&gt;先创建对象，再注入属性。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 18 Aug 2018 14:18:00 +0000</pubDate>
<dc:creator>希希里之海</dc:creator>
<og:description>使用 intellijIDEA 创建 maven 工程进行 Spring ioc 测试 ioc 概念 控制反转（Inversion of Control，缩写为 IOC ），是面向对象编程中的一种设计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weixuqin/p/9498918.html</dc:identifier>
</item>
<item>
<title>可持久化 trie 的简单入门 - Judge_Cheung</title>
<link>http://www.cnblogs.com/Judge/p/9498797.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Judge/p/9498797.html</guid>
<description>&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;by Judge&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;cstring&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; M=1e5+&lt;span&gt;111&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt;&lt;span&gt; read(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; x=&lt;span&gt;0&lt;/span&gt;,f=&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;char&lt;/span&gt; c=&lt;span&gt;getchar();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;!isdigit(c);c=getchar()) &lt;span&gt;if&lt;/span&gt;(c==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) f=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;isdigit(c);c=getchar()) x=x*&lt;span&gt;10&lt;/span&gt;+c-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;return&lt;/span&gt; x*&lt;span&gt;f;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m,pat,cnt;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; head[M],d[&lt;span&gt;20&lt;/span&gt;],rt[M],to[M&amp;lt;&amp;lt;&lt;span&gt;5&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;],sum[M&amp;lt;&amp;lt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val[M],siz[M],dep[M],top[M],f[M],son[M];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Edge{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; to,next;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     Edge(&lt;span&gt;int&lt;/span&gt; to,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; next): to(to),next(next){} Edge(){}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }e[M&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; u,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     e[++pat]=Edge(v,head[u]),head[u]=&lt;span&gt;pat;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     e[++pat]=Edge(u,head[v]),head[v]=&lt;span&gt;pat; 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;************         模板         *******************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; split(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k){
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; len=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,i;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(k) d[++len]=k&amp;amp;&lt;span&gt;1&lt;/span&gt;,k&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=len+&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=&lt;span&gt;18&lt;/span&gt;;++i) d[i]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; update(&lt;span&gt;int&lt;/span&gt;&amp;amp; root,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; las){
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; now=root=++&lt;span&gt;cnt;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     sum[now]=sum[las]+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;18&lt;/span&gt;;i;--&lt;span&gt;i){
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         to[now][d[i]^&lt;span&gt;1&lt;/span&gt;]=to[las][d[i]^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         to[now][d[i]]=++cnt,las=&lt;span&gt;to[las][d[i]],
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         now=cnt,sum[now]=sum[las]+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; v e[i].to
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dfs1(&lt;span&gt;int&lt;/span&gt; u,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; fa){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     siz[u]=&lt;span&gt;1&lt;/span&gt;,son[u]=top[u]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    split(val[u]),update(rt[u],rt[fa]);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=head[u];i;i=e[i].next) &lt;span&gt;if&lt;/span&gt;(v!=&lt;span&gt;fa){
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         f[v]=u,dep[v]=dep[u]+&lt;span&gt;1&lt;/span&gt;,dfs1(v,u),siz[u]+=&lt;span&gt;siz[v];
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(siz[v]&amp;gt;siz[son[u]]) son[u]=&lt;span&gt;v;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dfs2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; u){
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(!top[u]) top[u]=u; &lt;span&gt;if&lt;/span&gt;(!son[u]) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     top[son[u]]=&lt;span&gt;top[u],dfs2(son[u]);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=head[u];i;i=&lt;span&gt;e[i].next)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(v!=son[u] &amp;amp;&amp;amp; v!=&lt;span&gt;f[u]) dfs2(v);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;#undef&lt;/span&gt; v
&lt;span&gt;54&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt; LCA(&lt;span&gt;int&lt;/span&gt; u,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v){
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(top[u]^&lt;span&gt;top[v])
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         dep[top[u]]&amp;gt;dep[top[v]]?u=f[top[u]]:v=&lt;span&gt;f[top[v]]; 
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; dep[u]&amp;lt;dep[v]?&lt;span&gt;u:v;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;          程序         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; inline &lt;span&gt;int&lt;/span&gt; query(&lt;span&gt;int&lt;/span&gt; u,&lt;span&gt;int&lt;/span&gt; v,&lt;span&gt;int&lt;/span&gt; lca,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; f_lca){
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;18&lt;/span&gt;;i;--&lt;span&gt;i){
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(sum[to[u][d[i]^&lt;span&gt;1&lt;/span&gt;]]+sum[to[v][d[i]^&lt;span&gt;1&lt;/span&gt;]]-sum[to[lca][d[i]^&lt;span&gt;1&lt;/span&gt;]]-sum[to[f_lca][d[i]^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]])
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             ans|=(&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;i-&lt;span&gt;1&lt;/span&gt;),u=to[u][d[i]^&lt;span&gt;1&lt;/span&gt;],v=to[v][d[i]^&lt;span&gt;1&lt;/span&gt;],lca=to[lca][d[i]^&lt;span&gt;1&lt;/span&gt;],f_lca=to[f_lca][d[i]^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; u=to[u][d[i]],v=to[v][d[i]],lca=to[lca][d[i]],f_lca=&lt;span&gt;to[f_lca][d[i]];
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     } &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x,y,z,lca;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt;&lt;span&gt; query(){
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     x=read(),y=read(),z=read(),lca=&lt;span&gt;LCA(x,y),split(z);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,query(rt[x],rt[y],rt[lca],rt[f[lca]]));
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(~scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;m)){
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         pat=cnt=&lt;span&gt;0&lt;/span&gt;,memset(head,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(head));
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;++i) val[i]=&lt;span&gt;read();
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;,u,v;i&amp;lt;n;++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             u=read(),v=&lt;span&gt;read(),add(u,v);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         dfs1(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;),dfs2(&lt;span&gt;1&lt;/span&gt;); &lt;span&gt;while&lt;/span&gt;(m--&lt;span&gt;) query();
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;     } &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Sat, 18 Aug 2018 13:48:00 +0000</pubDate>
<dc:creator>Judge_Cheung</dc:creator>
<og:description>可持久化 $trie$ ....又是一个表里不一的东西..... 可持久化 $trie$ 的介绍： 和主席树类似的，其实可持久化就是体现在前缀信息的维护上（搞不懂这怎么就叫做可持久化了...） $tr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Judge/p/9498797.html</dc:identifier>
</item>
<item>
<title>Android 9 Pie震撼来袭 同步登陆WeTest - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/9498747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/9498747.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2018年8月7日，Google对外发布最新 Android 9.0 正式版系统，并宣布系统版本Android P 被正式命名为代号“Pie”，最新系统已经正式推送包括谷歌Pixel、Pixel2系列以及Essential Phone。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;腾讯WeTest一直致力于和谷歌一起，共建安卓生态。本次Android 9.0 的推出，腾讯WeTest平台对“&lt;/strong&gt;云真机”第一时间进行了系统升级，提供安卓9机型兼容测试和远程调试服务，持续限免对外开放，为广大开发者提供便利。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为新一代的系统，Android 9.0 利用人工智能技术，让手机更加智能、简洁与人性化。具体都有哪些变化呢？小编这里结合WeTest云真机功能，一起来近距离体验Android 9带来的“黑科技”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180818212936030-144413149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、以机器学习为核心 打造更为智能的手机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Android 9.0 赋予手机强大的学习能力：系统能够根据用户在使用过程中展露的习惯与偏好，进行自我学习与适应—从强劲续航到人性化应用推荐，保障持久流畅的用户体验。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、动态电量管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;利用机器学习技术对系统资源进行有限分配，更专注于用户最常用的应用。该功能会优先考虑你最喜欢的应用程序，并且限制你使用较少的应用程序对手机的资源利用。然后对那些你不太可能使用的应用程序进行电量消耗限制。从此，出门在外再也不用担心手机没电，而错过和男神女神的约会了。&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180818212955613-1587213893.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;只有官方的动图那是远远不够的，WeTest小编在WeTest平台体验了一把Android 9.0 版本的云真机，把此功能设置过程还原给了大家：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180818213006217-388645743.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、Slices&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Slices 能够有效帮助用户节省操作时间，不需要通过全屏体验就能够使用应用的部分功能。Slices 能够将应用内容以高动态、富交互的形式插入到多个使用场景中，比如 Google Search 和 Assistant。下图是在WeTest平台远程Android云真机模拟此过程。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180818213025127-413448810.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、App Actions&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;App Actions 是一种全新的应用推荐方式。借助机器学习技术，App Actions 能对应用的语义意图和使用场景进行分析，并根据分析结果在适当的时机向用户推荐您的应用。比如当你打开通讯录，系统会根据你之前的使用喜欢，自动判断你是否想打电话，准备打给谁，从而提前将电话应用的一些功能展示在最显眼的位置，帮助用户更简单高效使用手机。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180818213038674-1954193996.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、文本识别与 Smart Linkify&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Android 9.0 中，针对识别文本的机器学习模型进行了扩展，使其可以借助 TextClassifier API识别出类似日期或航班号这样的信息。此外， Smart Linkify 允许开发者通过 Linkify API 使用文本识别模块完成多项操作，比如对用户可采取的操作提出建议。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180818213109196-1077586635.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、凹口屏支持&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Android 9.0 中加入了凹口屏支持，让应用可以充分利用最新全面屏。该功能可以在大部分应用中无缝工作，系统会通过调整状态栏高度将应用内容与屏幕缺口区域分开。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180818213122948-249689985.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;△ 内含沉浸式内容的应用可以在凹口屏设备上实现全屏显示 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、文本放大镜&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Android 9.0 中添加文字放大镜工具 (Magnifier widget)，以提升文本选择方面的用户体验。由于该放大器提供了可以在文本上方拖拽的文本放大面板，所以有助于用户精准地定位光标或文本选择手柄。该放大器工具还可以提供任何视图或界面的放大版本，而不仅仅是文本。 &lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180818213148989-1986954943.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Pie的这个功能貌似很炫酷，小编毅然尝试下，打开WeTest官网，进入云真机操控界面，（记得选择Android 9.0系统的机型哦），有图有真相，少侠何不来试试看？&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180818213200171-1391439582.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;立刻登录腾讯WeTest，体验 Android 9.0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;-0.94&quot;&gt;&lt;li readability=&quot;0.94&quot;&gt;
&lt;p&gt;最新Android 9.0 系统机型已经上线，有测试需求的同学可前往&lt;a href=&quot;http://wetest.qq.com/cloud/help/AndroidP?from=content_cnblogs&quot;&gt;WeTest官网&lt;/a&gt;免费体验一把。现在完成个人或企业实名认证，我们将免费赠送您额外测试福利！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;http://wetest.qq.com/cloud/help/AndroidP?from=content_cnblogs&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201808/992994-20180818213224844-1453701200.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;△ 上图为WeTest云真机选择界面，可以自由选择所需机型及操作系统&lt;/p&gt;

&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;WeTest提供云端自动化兼容测试及远程调试服务。提供上千台真实手机，支持市面主流机型，覆盖真正目标用户。独家支持微信/QQ账号自动登录，一键提测，测试完成微信邮件即时通知。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;标准兼容测试：&lt;/strong&gt;通过开放腾讯内部的测试引擎，有效发现各种兼容问题。对应用进行安装、登录、拉起、卸载、Monkey测试，4小时内获得测试报告。提供全程测试截图，完整的日志，定位准确到出错代码行，还可通过真机远程调试，方便问题修复。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;远程调试：&lt;/strong&gt;基于腾讯大数据选取，新上线主流手机第一时间加入云端，覆盖市场真实TOP机型。通过在对不同品牌、分辨率、操作系统、高中低端设备上进行调试，获取真实环境下用户体验。打开网页即可操作云端手机，流畅零延时，随时随地快速测试。&lt;/p&gt;

&lt;/blockquote&gt;
</description>
<pubDate>Sat, 18 Aug 2018 13:34:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<og:description>WeTest 导读 2018年8月7日，Google对外发布最新 Android 9.0 正式版系统，并宣布系统版本Android P 被正式命名为代号“Pie”，最新系统已经正式推送包括谷</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/9498747.html</dc:identifier>
</item>
<item>
<title>【从零开始搭建自己的.NET Core Api框架】（六）泛型仓储的作用 - 在7楼</title>
<link>http://www.cnblogs.com/RayWang/p/9498591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RayWang/p/9498591.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;系列目录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一&lt;span&gt;.  创建项目并集成swagger&lt;a class=&quot;feed_link&quot; href=&quot;https://www.cnblogs.com/RayWang/p/9216820.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9216820.html&quot;&gt;1.1 创建&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9218258.html&quot;&gt;1.2 完善&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9221484.html&quot;&gt;二. 搭建项目整体架构&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;三. 集成轻量级ORM框架——SqlSugar&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9226790.html&quot;&gt;3.1 搭建环境&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9227006.html&quot;&gt;3.2 实战篇：利用SqlSugar快速实现CRUD&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9235704.html&quot;&gt;3.3 生成实体类&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9255093.html&quot;&gt;四. 集成JWT授权验证&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9274913.html&quot;&gt;五. 实现CORS跨域&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;六. 集成泛型仓储&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt; 源码下载：&lt;a href=&quot;https://github.com/WangRui321/RayPI_V2.0&quot;&gt;https://github.com/WangRui321/RayPI_V2.0&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;  1. 根&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;之前在集成SqlSugar的时候，我们用Student类作为例子，写了5个基础的接口：获取集合、获取单个、添加、修改、删除，也就是常说的仓储的CRUD了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818193926376-256316784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Service层的代码是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818194108856-403255145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;而且我们规定，以后每个实体类都必须有这个5个基础接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，当我们再添加一个实体（比如Teacher）时，在TeacherService中也要写和StudentService几乎一样的代码（其实就是把代码里所有“Student”换成“Teacher”就行了）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这么多重复代码，显然是不符合程序员的审美的。这个时候使用泛型仓储就再适合不过了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;  2. 道&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;整体思路是，写一个基类“BaseService”，这个基类是一个抽象的泛型类，然后让每个实体的Service都继承它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么当再新建一个Service时，不需要写任何代码，就已经实现了我们需要的那5种基础CRUD了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 2.1 IService层&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在IService层新建一个IBase接口：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818201953682-751899203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_57b2bf49-b6b8-45ec-866d-914b227341bb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_57b2bf49-b6b8-45ec-866d-914b227341bb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_57b2bf49-b6b8-45ec-866d-914b227341bb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RayPI.Model;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RayPI.IService
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IBase&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T:&lt;span&gt;class&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取分页列表
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pageIndex&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pageSize&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        TableModel&amp;lt;T&amp;gt; GetPageList(&lt;span&gt;int&lt;/span&gt; pageIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pageSize);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取单个
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        T Get(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 添加
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;entity&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Add(T entity);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 编辑
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;entity&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Update(T entity);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 批量删除
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ids&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; Dels(&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt;[] ids);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;IBase&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;该接口是个泛型接口，里面集成了对泛型T的5中基础CRUD操作。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 2.2 Service层&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在Service层新建一个BaseService类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818200805939-1796348941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_5847407e-6d7b-4410-9907-a9b50eb11702&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5847407e-6d7b-4410-9907-a9b50eb11702&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5847407e-6d7b-4410-9907-a9b50eb11702&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RayPI.Model;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; SqlSugar;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq.Expressions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RayPI.Service
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 服务层基类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseService&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T:&lt;span&gt;class&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseService()
        {
            db &lt;/span&gt;=&lt;span&gt; GetClient();
            sdb &lt;/span&gt;=&lt;span&gt; db.GetSimpleClient();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SqlSugarClient db;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SimpleClient sdb;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取客户端
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SqlSugarClient GetClient()
        {
            SqlSugarClient db &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSugarClient(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionConfig()
                {
                    ConnectionString &lt;/span&gt;=&lt;span&gt; BaseDBConfig.ConnectionString,
                    DbType &lt;/span&gt;=&lt;span&gt; DbType.SqlServer,
                    IsAutoCloseConnection &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                }
            );
            db.Aop.OnLogExecuting &lt;/span&gt;= (sql, pars) =&amp;gt;&lt;span&gt;
            {
                Console.WriteLine(sql &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + db.Utilities.SerializeObject(pars.ToDictionary(it =&amp;gt; it.ParameterName, it =&amp;gt;&lt;span&gt; it.Value)));
                Console.WriteLine();
            };
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; db;
        }

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; CRUD
        &lt;span&gt;public&lt;/span&gt; TableModel&amp;lt;T&amp;gt; GetPageList(&lt;span&gt;int&lt;/span&gt; pageIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pageSize)
        {
            PageModel p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PageModel() { PageIndex = pageIndex, PageSize =&lt;span&gt; pageSize };
            Expression&lt;/span&gt;&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; ex = (it =&amp;gt; &lt;span&gt;1&lt;/span&gt; == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            List&lt;/span&gt;&amp;lt;T&amp;gt; data =&lt;span&gt; sdb.GetPageList(ex, p);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t = &lt;span&gt;new&lt;/span&gt; TableModel&amp;lt;T&amp;gt;&lt;span&gt;
            {
                Code &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                Count &lt;/span&gt;=&lt;span&gt; p.PageCount,
                Data &lt;/span&gt;=&lt;span&gt; data,
                Msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T Get(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sdb.GetById&amp;lt;T&amp;gt;&lt;span&gt;(id);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Add(T entity)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sdb.Insert(entity);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Update(T entity)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sdb.Update(entity);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Dels(&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt;[] ids)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sdb.DeleteByIds&amp;lt;T&amp;gt;&lt;span&gt;(ids);
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;BaseService&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;该类为abstract抽象类，只能用来被其他类继承，不能实例化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后该类除了之前的获取SqlSugarClient的函数，还了5个集成基础CRUD操作，不一样的是这里不是传的实体类，而是一个泛型T。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;  3. 果&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下面，我们写一个Teacher的完整的增删改查。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;先在数据库新建一张教师表：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818201359456-1716642483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后运行项目，调用我们之前写好的自动生成实体类的接口：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818201613965-1909716596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;生成的实体类是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818201720853-928701417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在IService层新建一个ITeacher接口：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818202541418-578002680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;跟之前不一样的是，这个接口里不需要再写增删改查的接口了，直接继承IBase，把Teacher传过去，就行了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在Service层，新建一个TeacherService：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818202750439-15875986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该Service也不要写增删改查，直接继承BaseService就有了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后Bussiness层和控制器层这里就不说了，跟之前一样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818203010797-294979759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818203144556-647682748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;运行调试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201808/1327955-20180818203333350-807376080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;这样，不用写任何底层的Service，就能实现基础的增删改查了，是不是很爽~&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 18 Aug 2018 12:46:00 +0000</pubDate>
<dc:creator>在7楼</dc:creator>
<og:description>系列目录 一. 创建项目并集成swagger 1.1 创建 1.2 完善 二. 搭建项目整体架构 三. 集成轻量级ORM框架——SqlSugar 3.1 搭建环境 3.2 实战篇：利用Sql</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RayWang/p/9498591.html</dc:identifier>
</item>
<item>
<title>Spring之IOC容器 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/9498533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/9498533.html</guid>
<description>&lt;p&gt;在前面博客中介绍什么是依赖注入时有提到：依赖注入是组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。那什么是容器?既然Spring框架实现了IOC，那Spring中的容器是什么呢?&lt;br/&gt; 一、容器介绍&lt;br/&gt;在日常生活中容器是指用以容纳物料并以壳体为主的基本装置，它是用来盛放东西的。在编程中容器是用来存储和组织其他对象的对象，首先要确定容器也是对象，也可以当做bean，只是这个对象是用来存储和组织其他对象，那其他对象是什么呢?其他对象其实就是bean对象，这也是面向对象编程的一种体现，万物皆对象。在Spring提供了BeanFactory、ApplicationContext两个IOC容器，来管理众多的bean对象。&lt;br/&gt;二、BeanFactory&lt;br/&gt;一提到工厂我们生活当中可能会想到富某康，工厂是一类用以生产货物的大型工业建筑物。而BeanFactory不是用来生产货物的而是用来生产管理bean的。BeanFactory会在bean的生命周期的各个阶段中对bean进行各种管理，并且Spring将这些阶段通过各种接口暴露给我们，让我们可以对bean进行各种处理，我们只要让bean实现对应的接口，那么Spring就会在bean的生命周期调用我们实现的接口来处理该bean。那它是怎么实现的呢?它主要分两个阶段。&lt;br/&gt;1）、Bean容器的启动&lt;br/&gt;工厂要生产货物那首先得把工厂运转起来之后才能生产货物。同样bean容器要管理bean也需要先把容器启动起来，获取到bean的定义信息之后才能管理。&lt;br/&gt;1. 读取bean的xml配置文件，然后将xml中每个bean元素分别转换成BeanDefinition对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractBeanDefinition &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BeanMetadataAttributeAccessor
&lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanDefinition, Cloneable {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Object beanClass;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String scope =&lt;span&gt; SCOPE_DEFAULT;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; abstractFlag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; lazyInit = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; autowireMode =&lt;span&gt; AUTOWIRE_NO;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dependencyCheck =&lt;span&gt; DEPENDENCY_CHECK_NONE;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] dependsOn;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ConstructorArgumentValues constructorArgumentValues;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MutablePropertyValues propertyValues;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String factoryBeanName;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String factoryMethodName;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String initMethodName;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String destroyMethodName;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; BeanClass保存bean的class属性，scop保存Bean的作用域，abstractFlag保存该bean是否抽象，lazyInit保存是否延迟初始化，autowireMode保存是否自动装配，dependencyCheck保存是否坚持依赖，dependsOn保存该bean依赖于哪些bean(这些bean必须提取初始化)，constructorArgumentValues保存通过构造函数注入的依赖，propertyValues保存通过setter方法注入的依赖，factoryBeanName和factoryMethodName用于factorybean，也就是工厂类型的bean，initMethodName和destroyMethodName分别对应bean的init-method和destory-method属性。后面会对这些内容进行详细介绍。&lt;/p&gt;
&lt;p&gt;2. 通过BeanDefinitionRegistry将bean注册到beanFactory中&lt;/p&gt;
&lt;p&gt;上面获取到bean的信息之后，是怎么注册到BeanFactory中的呢？其实是通过BeanDefinitionRegistry将bean注册到beanFactory中。因为BeanFactory的实现类，需要实现BeanDefinitionRegistry 接口。&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; BeanDefinitionRegistry &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AliasRegistry {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; registerBeanDefinition(String beanName, BeanDefinition beanDefinition)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; removeBeanDefinition(String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
    BeanDefinition getBeanDefinition(String beanName) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsBeanDefinition(String beanName);
    String[] getBeanDefinitionNames();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getBeanDefinitionCount();
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isBeanNameInUse(String beanName);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BeanDefinitionRegistry接口提供了根据beanName注册对应beanDefinition的方法,而在DefaultListableBeanFactory中实现了该方法，并将beanDefinition保存在了ConcurrentHashMap中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
@SuppressWarnings(&quot;serial&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultListableBeanFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractAutowireCapableBeanFactory
        &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Map of bean definition objects, keyed by bean name &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, BeanDefinition&amp;gt;(64&lt;span&gt;);
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanDefinitionStoreException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... ...&lt;/span&gt;
       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanDefinitionMap.put(beanName, beanDefinition);
       }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外Spring还对外暴露了一些接口用来对bean初始化，例如BeanFactoryPostProcessor。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BeanFactoryPostProcessor {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Modify the application context's internal bean factory after its standard
     * initialization. All bean definitions will have been loaded, but no beans
     * will have been instantiated yet. This allows for overriding or adding
     * properties even to eager-initializing beans.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; beanFactory the bean factory used by the application context
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; org.springframework.beans.BeansException in case of errors
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以翻译一下postProcessBeanFactory的注释信息，postProcessBeanFactory可以修改应用上下文中已经进行standard初始化的beanFactory，此时所有bean的定义信息已经加载完成，但还未实例化，允许覆盖、新增甚至重新初始化bean信息，一个典型的例子就是属性覆盖器PropertyOverrideConfigurer。对于一些参数可以配置在properties中，而不用配置在Spring的XML配置文件中。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;2)、容器Bean的实例化&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上面把bean容器启动之后，工厂算是运转起来了，配方(beanDefinition)也已经准备充分，然后就是生产(实例化)、管理货物(bean)了。实例化bean主要通过反射和CGLIB两种方式，在bean的实例化过程中，Spring也暴露了一些接口。&lt;br/&gt;BeanNameAware 获取该bean在配置文件中对应的id&lt;br/&gt;BeanFactoryAware 获取实例化该bean的BeanFactory&lt;br/&gt;InitializingBean bean实例化、所有属性设置后调用初始化方法&lt;br/&gt;DisposableBean 在bean丢弃的时候调用销毁方法&lt;br/&gt;我们可以通过示例演示一下这几个接口的使用。&lt;br/&gt;1. 首先创建了Maven project,pom.xml引入spring-core、spring-context。&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
  xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.demo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;BeanFactoryDemo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;BeanFactoryDemo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spring.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.0.0.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spring.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-context&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.8.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2. 创建bean对象，实现上面列出的接口&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;
 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.BeansException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactoryAware;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanNameAware;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.DisposableBean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.InitializingBean;
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserBean &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanNameAware,BeanFactoryAware,InitializingBean,DisposableBean {
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String name) {
System.out.println(name);
}
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBeanFactory(BeanFactory beanFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
System.out.println(beanFactory);
}
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterPropertiesSet() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
System.out.println(&lt;/span&gt;&quot;InitializingBean&quot;&lt;span&gt;);
}
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; destroy() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
System.out.println(&lt;/span&gt;&quot;DisposableBean&quot;&lt;span&gt;);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. bean配置&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
   &amp;lt;bean id=&quot;user&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.demo.model.UserBean&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4. 测试&lt;/p&gt;
&lt;p&gt; 使用ApplicationContext获取BeanFactory，再通过getBean方法获取到对应的bean，最后调用destroy方法进行销毁，从输出结果可以看到依次调用了BeanNameAware,BeanFactoryAware,InitializingBean,DisposableBean接口。&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main( String[] args ) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;applicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        UserBean user&lt;/span&gt;=(UserBean)factory.getBean(&quot;user&quot;&lt;span&gt;);
        user.destroy();
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果:user&lt;/p&gt;
&lt;p&gt;org.springframework.beans.factory.support.DefaultListableBeanFactory@6bf256fa: defining beans [user]; root of factory hierarchy&lt;br/&gt;InitializingBean&lt;br/&gt;DisposableBean&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;三、ApplicationContext&lt;br/&gt;在上面的示例中使用了ApplicationContext获取bean的配置，然后直接将ApplicationContext接口 对象赋值给了BeanFactory接口对象,为什么可以赋值呢?其实ApplicationContext接口实现了BeanFactory接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ApplicationContext &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,
MessageSource, ApplicationEventPublisher, ResourcePatternResolver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面ApplicationContext接口的继承关系可以看到，它还通过继承其他接口扩展了BeanFactory的功能。MessageSource：为应用提供国际化访问功能。ResourceLoader：提供资源（如URL和文件系统）的访问支持。ApplicationEventPublisher：引入事件机制，包括启动事件、关闭事件等，让容器在上下文中提供了对应用事件的支持。它代表的是一个应用的上下文环境。beanFactory主要是面对与 spring 框架的基础设施，面对 spring 自己。而 Applicationcontex 主要面对与 spring 使用的开发者。基本都会使用 Applicationcontex 并非 beanFactory 。所以在上面实例使用的ApplicationContext获取BeanFactory接口对象。&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 12:37:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>在前面博客中介绍什么是依赖注入时有提到：依赖注入是组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。那什么是容器?既然Spring框架实现了IOC，那Spring中的容器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/9498533.html</dc:identifier>
</item>
<item>
<title>Docker系列一：Docker的介绍和安装 - 白天不懂夜的黑i</title>
<link>http://www.cnblogs.com/zpzhue/p/9498024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zpzhue/p/9498024.html</guid>
<description>&lt;h2 id=&quot;docker介绍&quot;&gt;Docker介绍&lt;/h2&gt;
&lt;p&gt;Docker是指容器化技术，用于支持创建和实验Linux Container。借助Docker，你可以将容器当做重量轻、模块化的虚拟机来使用，同时，你还将获得高度的灵活性，从而实现对容器的高效创建、部署和复制，并能将其从一个环境顺利迁移至另外一个环境。&lt;/p&gt;
&lt;p&gt;Docker官方网站：&lt;a href=&quot;http://www.docker.com&quot; class=&quot;uri&quot;&gt;http://www.docker.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github Docker 源码：&lt;a href=&quot;https://github.com/docker/docker&quot; class=&quot;uri&quot;&gt;https://github.com/docker/docker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基础特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于C/S架构应用程序&lt;/li&gt;
&lt;li&gt;模块化&lt;/li&gt;
&lt;li&gt;层与镜像版本控制&lt;/li&gt;
&lt;li&gt;支持回滚&lt;/li&gt;
&lt;li&gt;快速部署&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Docker的应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Web 应用的自动化打包和发布。&lt;/li&gt;
&lt;li&gt;自动化测试和持续集成、发布。&lt;/li&gt;
&lt;li&gt;在服务型环境中部署和调整数据库或其他的后台应用。&lt;/li&gt;
&lt;li&gt;从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Docker基础架构图&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.178linux.com/wp-content/uploads/2018/08/4.png&quot; alt=&quot;Docker架构图&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器&lt;/li&gt;
&lt;li&gt;Docker 容器通过 Docker 镜像来创建&lt;/li&gt;
&lt;li&gt;DOCKER_HOST：真正运行容器的主机&lt;/li&gt;
&lt;li&gt;Containers：容器，独立运行的一个或一组应用&lt;/li&gt;
&lt;li&gt;Images：镜像，用于创建 Docker 容器的模板&lt;/li&gt;
&lt;li&gt;Registry：镜像仓库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;镜像image与容器Container区别&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;镜像是静态的，不会运行&lt;/li&gt;
&lt;li&gt;容器则是动态的，有生命周期&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Docker容器镜像站：&lt;a href=&quot;https://hub.docker.com&quot; class=&quot;uri&quot;&gt;https://hub.docker.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker object&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;image&lt;/li&gt;
&lt;li&gt;containers&lt;/li&gt;
&lt;li&gt;networks&lt;/li&gt;
&lt;li&gt;volumes&lt;/li&gt;
&lt;li&gt;plugins&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;docker的安装&quot;&gt;Docker的安装&lt;/h2&gt;
&lt;h4 id=&quot;直接在centos上安装docker&quot;&gt;直接在CentOS上安装Docker&lt;/h4&gt;
&lt;p&gt;首先安装之前先卸载之前的旧版本：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装docker依赖包：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sudo yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加docker源（如果Docker官方下载的速度太慢也可以使用阿里的镜像源：http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo）：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装docker：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo yum install docker-ce&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完直接启动docker即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;~]# systemctl start docker&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;docker version&lt;/code&gt; 可以看到我们安装docker的版本&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;~]# docker version 
Client:
 Version:      18.03.1-ce
 API version:  1.37
 Go version:   go1.9.5
 Git commit:   9ee9f40
 Built:        Thu Apr 26 07:20:16 2018
 OS/Arch:      linux/amd64
 Experimental: false
 Orchestrator: swarm

Server:
 Engine:
  Version:      18.03.1-ce
  API version:  1.37 (minimum version 1.12)
  Go version:   go1.9.5
  Git commit:   9ee9f40
  Built:        Thu Apr 26 07:23:58 2018
  OS/Arch:      linux/amd64
  Experimental: false&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用vagrant-virtual-box快速搭建docker环境&quot;&gt;使用Vagrant + Virtual Box快速搭建Docker环境&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Vagrant介绍&lt;/strong&gt;&lt;br/&gt;Vagrant是一个基于Ruby的工具，用于创建和部署虚拟化开发环境。它 使用Oracle的开源VirtualBox虚拟化系统，使用 Chef创建自动化虚拟环境。我们可以使用它来干如下这些事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;建立和删除虚拟机&lt;/li&gt;
&lt;li&gt;配置虚拟机运行参数&lt;/li&gt;
&lt;li&gt;管理虚拟机运行状态&lt;/li&gt;
&lt;li&gt;自动配置和安装开发环境&lt;/li&gt;
&lt;li&gt;打包和分发虚拟机运行环境&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Vagrant的运行，需要依赖某项具体的虚拟化技术，最常见的有VirtualBox以及VMWare两款，早期，Vagrant只支持VirtualBox，后来才加入了VMWare的支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vagrant安装和使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vagrant是基于其他虚拟化产品来创建虚拟机的，这里我们选择开源产品Virtual Box，我们先安装Virtual Box和Vagrant：&lt;/p&gt;
&lt;p&gt;下载好之后先使用&lt;code&gt;vagrant init centos/7&lt;/code&gt;生成默认的Vagrntfile，然后使用&lt;code&gt;vagrant up&lt;/code&gt;即可自动创建虚拟机，我们为了配置Docker环境需要更改下Vagrantfile，在创建虚拟机的时候自动安装docker环境（配置&lt;code&gt;config.vm.provision &quot;shell&quot;&lt;/code&gt;选项）并且按照自己的要求配置虚拟机的规模和网络。&lt;/p&gt;
&lt;p&gt;我的Vagrantfile配置如下&lt;/p&gt;
&lt;pre class=&quot;vagrantfile&quot;&gt;
&lt;code&gt;# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.require_version &quot;&amp;gt;= 1.6.0&quot;

boxes = [
    {
        :name =&amp;gt; &quot;docker-1&quot;,
    :eth1 =&amp;gt; &quot;172.16.56.11&quot;,
        :mem =&amp;gt; &quot;1024&quot;,
        :cpu =&amp;gt; &quot;1&quot;
    }
]

Vagrant.configure(2) do |config|

  config.vm.box = &quot;centos/7&quot;
  boxes.each do |opts|
    config.vm.define opts[:name] do |config|
      config.vm.hostname = opts[:name]
      config.vm.provider &quot;vmware_fusion&quot; do |v|
        v.vmx[&quot;memsize&quot;] = opts[:mem]
        v.vmx[&quot;numvcpus&quot;] = opts[:cpu]
      end
      config.vm.provider &quot;virtualbox&quot; do |v|
        v.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, opts[:mem]]
        v.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, opts[:cpu]]
      end
      config.vm.network :public_network, ip: opts[:eth1]
    end
  end

#  config.vm.synced_folder &quot;../sync&quot;, &quot;/home/vagrant/sync&quot;

  config.vm.provision &quot;shell&quot;, inline: &amp;lt;&amp;lt;-SHELL
      yum -y install wget
      wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
      yum makecache
      yum install -y yum-utils device-mapper-persistent-data lvm2
      yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
      yum makecache fast
      yum -y install docker-ce
      sudo systemctl start docker
  SHELL
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后使用&lt;code&gt;vagrant up&lt;/code&gt;创建即可&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;λ vagrant up
Bringing machine 'docker-1' up with 'virtualbox' provider...
==&amp;gt; docker-1: Importing base box 'centos/7'...

[KProgress: 20%
[KProgress: 40%
[KProgress: 90%
[K==&amp;gt; docker-1: Matching MAC address for NAT networking...
==&amp;gt; docker-1: Checking if box 'centos/7' is up to date...
==&amp;gt; docker-1: Setting the name of the VM: docker-1_docker-1_1534247086153_83300
==&amp;gt; docker-1: Clearing any previously set network interfaces...
==&amp;gt; docker-1: Preparing network interfaces based on configuration...
    docker-1: Adapter 1: nat
    docker-1: Adapter 2: bridged
==&amp;gt; docker-1: Forwarding ports...
    docker-1: 22 (guest) =&amp;gt; 2222 (host) (adapter 1)
==&amp;gt; docker-1: Running 'pre-boot' VM customizations...
==&amp;gt; docker-1: Booting VM...
==&amp;gt; docker-1: Waiting for machine to boot. This may take a few minutes...
    docker-1: SSH address: 127.0.0.1:2222
    docker-1: SSH username: vagrant
    docker-1: SSH auth method: private key
    docker-1: 
    docker-1: Vagrant insecure key detected. Vagrant will automatically replace
    docker-1: this with a newly generated keypair for better security.
    docker-1: 
    docker-1: Inserting generated public key within guest...
==&amp;gt; docker-1: Machine booted and ready!
==&amp;gt; docker-1: Checking for guest additions in VM...

...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个过程中Vagrant会帮我们创建好一台Centos 7的虚拟机并安装好Docker环境，使用&lt;code&gt;vagrant ssh&lt;/code&gt;直接登陆虚拟机&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;λ vagrant ssh
Last login: Wed Aug 15 15:54:32 2018 from 10.0.2.2
[vagrant@docker-1 ~]$ sudo docker version
Client:
 Version:           18.06.0-ce
 API version:       1.38
 Go version:        go1.10.3
 Git commit:        0ffa825
 Built:             Wed Jul 18 19:08:18 2018
 OS/Arch:           linux/amd64
 Experimental:      false

Server:
 Engine:
  Version:          18.06.0-ce
  API version:      1.38 (minimum version 1.12)
  Go version:       go1.10.3
  Git commit:       0ffa825
  Built:            Wed Jul 18 19:10:42 2018
  OS/Arch:          linux/amd64
  Experimental:     false
[vagrant@docker-1 ~]$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Vagrantfile中有一项&lt;code&gt;config.vm.synced_folder&lt;/code&gt;可以配置本地文件夹同步到虚拟机，挂载本地文件夹到虚拟机中需要VBoxAdditions的支持，这个可以在虚拟机起来之后在安装，也可以参考&lt;a href=&quot;https://github.com/dotless-de/vagrant-vbguest&quot;&gt;vagrant-vbguest&lt;/a&gt;这个插件的使用，这个功能比较适合开发人员，可以在本地编写代码而在Linux环境中调试代码运行。&lt;/p&gt;&lt;p&gt;Docker和vagrant都是最近才开始了解学习的，有什么错误或者不对的地方还请大家指正，有什么不懂的也可以一起交流。&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 12:33:00 +0000</pubDate>
<dc:creator>白天不懂夜的黑i</dc:creator>
<og:description>Docker介绍 Docker是指容器化技术，用于支持创建和实验Linux Container。借助Docker，你可以将容器当做重量轻、模块化的虚拟机来使用，同时，你还将获得高度的灵活性，从而实现对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zpzhue/p/9498024.html</dc:identifier>
</item>
</channel>
</rss>