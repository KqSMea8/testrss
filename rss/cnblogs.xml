<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>重磅消息-Service Fabric 正式开源 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/8571341.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/8571341.html</guid>
<description>&lt;p&gt;微软的Azure Service Fabric的官方博客在2017.3.24日发布了一篇博客 &lt;a href=&quot;https://blogs.msdn.microsoft.com/azureservicefabric/2017/03/24/service-fabric-net-sdk-goes-open-source/&quot;&gt;Service Fabric .NET SDK goes open source&lt;/a&gt; ，介绍了社区呼声最高的Service Fabric开源的情况以及当前的情况，当时开源了Service Fabric的.NET SDK部分，社区一直在期盼着Service Fabric的正式开源，经过了一年漫长的等待，2018年3月14日微软终于开源了Service Fabric，而且是以&lt;strong&gt;MIT许可下开放源代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前微软在Github上的开源地址是 &lt;a title=&quot;https://github.com/Microsoft/service-fabric&quot; href=&quot;https://github.com/Microsoft/service-fabric&quot;&gt;https://github.com/Microsoft/service-fabric&lt;/a&gt;，目前的代码构建适用于Linux的Service Fabric，运行基本测试，有问题可以在上面提交issue和PR了，Windows构建环境以及完整的CI环境还没有迁移过来，看到代码还是3个小时前初始化的。Windows内部为Service Fabric开发了将近十年的内部服务，其中大部分时间都是微软内部平台，比如Office365，Azure Stack平台等，这意味着我们有近十年的内部微软工具可以在迁移之前完成迁移和流程细化，逐步全部开源，以后全部开发都在开源模式下进行开发工作。&lt;/p&gt;
&lt;p&gt;微软去年漫长的一年时间里也开放了非常多的代码，包括包括&lt;a href=&quot;https://github.com/Azure/service-fabric-services-and-actors-dotnet&quot;&gt;Reliable Services&lt;/a&gt;，&lt;a href=&quot;https://github.com/Azure/service-fabric-services-and-actors-dotnet&quot;&gt;Reliable Actors&lt;/a&gt;和&lt;a href=&quot;https://github.com/Azure/service-fabric-aspnetcore&quot;&gt;ASP.NET Core集成库&lt;/a&gt;，Azure基础架构服务以及Azure SQL DB，Azure Cosmos DB和Cortana等大型解决方案都在使用Service Fabric构建。&lt;/p&gt;
&lt;p&gt;Service Fabric会带来如下好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持创建无状态和有状态的微服务，通过云平台来伸缩他们，以应对高复杂度、低延迟、数据密集的情况&lt;/li&gt;
&lt;li&gt;通过应用程序级别的感知和洞察，为微服务带来编排和自动化的优势&lt;/li&gt;
&lt;li&gt;解决分布式系统诸如状态管理这样的难点，为开发人员提供应用程序生命周期管理的能力以便随着业务的增长无需重构系统架构&lt;/li&gt;
&lt;li&gt;相关工具会集成到Visual Studio中，也会提供相应命令行工具，以便开发人员能够快速和轻易地上手&lt;/li&gt;
&lt;li&gt;同时支持.NET和Java，这个特性特别适合目前国内原来很多投资于.NET平台，被人忽悠爬上了Java 贼船，看到了.NET Core，想回来的可以回来了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里顺便广告下我们的网关项目Ocelot 也完成了Service Fabric的集成工作，具体参考我们的文档 &lt;a title=&quot;http://ocelot.readthedocs.io/en/latest/features/servicefabric.html&quot; href=&quot;http://ocelot.readthedocs.io/en/latest/features/servicefabric.html&quot;&gt;http://ocelot.readthedocs.io/en/latest/features/servicefabric.html&lt;/a&gt; ，.NET Core的生态有了Service Fabric这一利器，我们将进一步发展壮大，让很多从.NET转向Java的人看清.NETCore的发展潜力。对于使用.net技术还想着转向Java的企业给一个规劝，转向.netcore更有前途。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 23:21:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/8571341.html</dc:identifier>
</item>
<item>
<title>号称了解mesos双层调度的你，先来回答下面这五个问题！ - popsuper1982</title>
<link>http://www.cnblogs.com/popsuper1982/p/8571270.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/popsuper1982/p/8571270.html</guid>
<description>&lt;p&gt;一提mesos，很多人知道双层调度，但是大多数理解都在表面，不然试一下下面五个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题一：如果有两个framework，一万个节点，按说应该平均分配给两个framework，怎么个分法？一人一台这样分，还是前五千给一人，后五千给第二个人，还是随机分，随机分怎么个分法？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题二：在没有reserved情况下，每个节点是只能得给一个framework，还是可以分给多个framework?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题三：如果两个framework的权重比例为1比2，是如何保证资源分配是这个比例？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题四：如果两个framework的权重比例为1比2，当第二个用完了三分之二，在第一个没有任务运行的时候，第二个能多用一些么？如何平衡别人不用多用，别人要用保持比例呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题五：将资源提供给多个framework的时候，是一个节点的资源给第一个framework，第一个framework说我不用，然后再给第二个framework么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好了，接下来我们来看Mesos双层调度的基本原理。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、入门级理解Mesos双层调度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Mesos的调度过程如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201803/635909-20180315004129353-1677435086.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Mesos有Framework, Master, Agent, Executor, Task几部分组成。这里面有两层的Scheduler，一层在Master里面，allocator会将资源公平的分给每一个Framework，二层在Framework里面，Framework的scheduler将资源按规则分配给Task。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、进阶级理解Mesos双层调度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Mesos采用了DRF（主导资源公平算法 Dominant Resource Fairness），Framework拥有的全部资源类型份额中占最高百分比的就是Framework的主导份额。DRF算法会使用所有已注册的Framework来计算主导份额，以确保每个Framework能接收到其主导资源的公平份额。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;举个例子&lt;/p&gt;

&lt;p&gt;考虑一个9CPU，18GBRAM的系统，拥有两个用户，其中用户A运行的任务的需求向量为{1CPU, 4GB}，用户B运行的任务的需求向量为{3CPU，1GB}，用户可以执行尽量多的任务来使用系统的资源。&lt;/p&gt;

&lt;p&gt;在上述方案中，A的每个任务消耗总cpu的1/9和总内存的2/9，所以A的dominant resource是内存；B的每个任务消耗总cpu的1/3和总内存的1/18，所以B的dominant resource为CPU。DRF会均衡用户的dominant shares，执行3个用户A的任务，执行2个用户B的任务。三个用户A的任务总共消耗了{3CPU，12GB}，两个用户B的任务总共消耗了{6CPU，2GB}；在这个分配中，每一个用户的dominant share是相等的，用户A获得了2/3的RAM，而用户B获得了2/3的CPU。&lt;/p&gt;

&lt;p&gt;以上的这个分配可以用如下方式计算出来：x和y分别是用户A和用户B的分配任务的数目，那么用户A消耗了{xCPU，4xGB}，用户B消耗了{3yCPU，yGB}，在图三中用户A和用户B消耗了同等dominant resource；用户A的dominant share为4x/18，用户B的dominant share为3y/9。所以DRF分配可以通过求解以下的优化问题来得到：&lt;/p&gt;

&lt;p&gt;max(x,y) #(Maximize allocations)&lt;/p&gt;
&lt;p&gt;subject to&lt;/p&gt;
&lt;p&gt;x + 3y &amp;lt;= 9 #(CPU constraint)&lt;/p&gt;
&lt;p&gt;4x + y &amp;lt;= 18 #(Memory Constraint)&lt;/p&gt;
&lt;p&gt;2x/9 = y/3 #(Equalize dominant shares)&lt;/p&gt;

&lt;p&gt;最后解出x=3以及y=2，因而用户A获得{3CPU，12GB}，B得到{6CPU， 2GB}。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、代码级理解Mesos双层调度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;首先理解几个概念容易混淆：Quota, Reservation, Role, Weight&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每个Framework可以有Role，既用于权限，也用于资源分配&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;可以给某个role在offerResources的时候回复Offer::Operation::RESERVE,来预订某台slave上面的资源。Reservation是很具体的，具体到哪台机器的多少资源属于哪个Role&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Quota是每个Role的最小保证量，但是不具体到某个节点，而是在整个集群中保证有这么多就行了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Reserved资源也算在Quota里面。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不同的Role之间可以有Weight&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mesos的代码实现中，不是用原生的DRF，而是使用HierarchicalDR，也即分层的DRF.&lt;/p&gt;

&lt;p&gt;调用了三个排序器Sorter(quotaRoleSorter, roleSorter, frameworkSorter)，对所有的Framework进行排序，哪个先得到资源，哪个后得到资源。&lt;/p&gt;

&lt;p&gt;总的来说分两大步：先保证有quota的role，调用quotaRoleSorter，然后其他的资源没有quota的再分，调用roleSorter。&lt;/p&gt;

&lt;p&gt;对于每一个大步分两个层次排序：一层是按照role排序，第二层是相同的role的不同Framework排序，调用frameworkSorter。&lt;/p&gt;

&lt;p&gt;每一层的排序都是按照计算的share进行排序来先给谁，再给谁。Share的计算就是按照DRF算法。&lt;/p&gt;

&lt;p&gt;接下来我们具体分析一下这个资源分配的过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 生成一个数据结构offerable，用于保存资源分配的结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;hashmap&amp;lt;FrameworkID, hashmap&amp;lt;SlaveID, Resources&amp;gt;&amp;gt; offerable;&lt;/p&gt;

&lt;p&gt;这是一个MAP，对于每一个Framework，都会有一个资源的MAP，保存的是每个slave上都有哪些资源。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 对于所有的slave打乱默认排序，从而使得资源分配相对均匀&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;std::random_shuffle(slaveIds.begin(), slaveIds.end());&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 进行第一次三层循环，对于有quota的Framework进行排序&lt;/strong&gt;&lt;/p&gt;

&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;foreach (const SlaveID&amp;amp; slaveId, slaveIds) {&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;  foreach (const string&amp;amp; role, quotaRoleSorter-&amp;gt;sort()) {&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;    foreach (const string&amp;amp; frameworkId_, frameworkSorters[role]-&amp;gt;sort()) {&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于每一个slave，首先对role进行排序，对于每一个role，对于Framework进行排序，排序靠前的Framework优先获得这个slave。&lt;/p&gt;

&lt;p&gt;排序的算法在DRFSorter里面实现，里面有一个函数calculateShare，里面的关键点在于进行了一个循环，对于每一种资源都计算如下的share值：&lt;/p&gt;

&lt;p&gt;share = std::max(share, allocation / _total);&lt;/p&gt;

&lt;p&gt;allocation除以total即一种资源占用的百分比，这里之所以求max，就是找资源占用百分比最高的资源，也即主导资源。&lt;/p&gt;

&lt;p&gt;但是这个share不是直接进行排序，而是share / weights[name]除以权重进行排序。如果权重越大，这个值越小，这个role会排在前面，分配更多的资源。&lt;/p&gt;

&lt;p&gt;排序结束后，对于每一个Framework，将当前slave的资源分配给它。&lt;/p&gt;

&lt;p&gt;Resources available = slaves[slaveId].total - slaves[slaveId].allocated;&lt;/p&gt;

&lt;p&gt;首先查看这个slave的可用资源，也即总资源减去已经分配的资源。&lt;/p&gt;

&lt;p&gt;Resources resources = (available.unreserved() + available.reserved(role)).nonRevocable();&lt;/p&gt;

&lt;p&gt;每个slave上没有预留的资源和已经预留给这个Framework的资源都会给这个Framework，当然如果上面有预留给其他Framework的资源是不会给当前的Framework的。&lt;/p&gt;

&lt;p&gt;offerable[frameworkId][slaveId] += resources;&lt;/p&gt;
&lt;p&gt;slaves[slaveId].allocated += resources;&lt;/p&gt;

&lt;p&gt;分配的资源会保存在数据结构offerable中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 进行第二次三层循环，对于没有quota的Framework进行排序&lt;/strong&gt;&lt;/p&gt;

&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;foreach (const SlaveID&amp;amp; slaveId, slaveIds) {&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;  foreach (const string&amp;amp; role, roleSorter-&amp;gt;sort()) {&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;    foreach (const string&amp;amp; frameworkId_,frameworkSorters[role]-&amp;gt;sort()) {&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;5. 全部分配结束后，将资源真正提供给各个Framework&lt;/strong&gt;&lt;/p&gt;

&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;foreachkey (const FrameworkID&amp;amp; frameworkId, offerable) {&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;  offerCallback(frameworkId, offerable[frameworkId]);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里的offerCallback是调用Master::Offer，最终调用Framework的Scheduler的resourceOffers，让Framework进行二次调度。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;最后，让我们来解答一下这些问题：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题一：如果有两个framework，一万个节点，按说应该平均分配给两个framework，怎么个分法？一人一台这样分，还是前五千给一人，后五千给第二个人，还是随机分，随机分怎么个分法？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;答：是随机分，怎么分呢？是将节点随机排序，但是排好序之后，就不再随机分了，而是开始排序，比如随机后的节点队列中的第一个节点分给了第一个framework，等下次循环再排序的时候，第二个framework由于没有拿到资源，排在了第一个framework的前面，于是第二个节点就分配给了第二个framework，然后for循环到第三个节点的时候(这是外层循环)，内层循环对framework排序的时候，第一个framework又排在了第二个前面，于是第三个节点分给了第一个framework。就这样你一个，我一个，实现了平均分配。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题二：在没有reserved情况下，每个节点是只能得给一个framework，还是可以分给多个framework?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;答：是的，在没有reserved的情况下，一个节点是只给一个framework，如果有reserved的情况下，reserved的那部分会给reserve它的那个framework，其他的部分，还是只能给一个framework，不一定是哪一个，看谁排在前面。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题三：如果两个framework的权重比例为1比2，是如何保证资源分配是这个比例？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;答：也是通过排序来的，对节点的for循环是外层循环，对framework的排序和循环是内层循环，第一次排序的时候，权重为2的framework排在前面，于是第一个节点是它的，第二次排序的时候，还是权重为2的framework排在前面，于是第二个节点也是它的，第三次排序的时候，权重为1的framework由于从来没拿到过资源，排在了前面，于是第三个节点是它的。就这样你两个，我一个，你两个，我一个，实现了资源按权重分配。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题四：如果两个framework的权重比例为1比2，当第二个用完了三分之二，在第一个没有任务运行的时候，第二个能多用一些么？如何平衡别人不用多用，别人要用保持比例呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;答：能的。如果权重为2的framework用完了三分之二，则每次排序，它都会排在权重为1的但是没有得到资源的framework后面，按说它永远得不到资源。但是算法中会有一个filter机制，当一个节点分给某一个framework之后，如果这个framework不用，退回来，则下次再遇到这个framework的时候，先filter掉，这样另一个framework就有机会得到这个节点了。下次又不会filter掉了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题五：将资源提供给多个framework的时候，是一个节点的资源给第一个framework，第一个framework说我不用，然后再给第二个framework么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;答：不是的。统一运行一遍分配算法，把资源都全部分配好，才统一发送给framework，如果需要再次分配，是下次统一计算的时候了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;欢迎关注微信公众号&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201803/635909-20180315012220504-152861446.jpg&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 17:21:00 +0000</pubDate>
<dc:creator>popsuper1982</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/popsuper1982/p/8571270.html</dc:identifier>
</item>
<item>
<title>java 实现登录验证码 （kaptcha 验证码组件） - 筱月</title>
<link>http://www.cnblogs.com/ainyi/p/8571029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ainyi/p/8571029.html</guid>
<description>&lt;h2&gt;验证码的作用：&lt;/h2&gt;
&lt;p&gt;1、防止广告机注册和发帖、评论。&lt;br/&gt;2、防止暴力破解密码，特别是有管理员权限的密码。&lt;/p&gt;
&lt;h2&gt;在这里介绍一种非常实用的验证码生成工具：kaptcha &lt;/h2&gt;
&lt;p&gt;这个工具，可以生成各种样式的验证码，因为它是可配置的。&lt;/p&gt;
&lt;p&gt;而 kaptcha工作的原理，是调用 com.google.code.kaptcha.servlet.KaptchaServlet，生成一个图片。同时将生成的验证码字符串放到 HttpSession中，直接从session中获取这张验证码图片，而不会占用实际内存。&lt;/p&gt;
&lt;p&gt;使用 kaptcha 可以方便的配置如下属性：&lt;/p&gt;
&lt;p&gt;kaptcha.border 　　　　　　　　　　是否有边框 默认为true 我们可以自己设置yes，no&lt;br/&gt;kaptcha.border.color　　　　　　　　边框颜色 默认为Color.BLACK&lt;br/&gt;kaptcha.border.thickness 　　　　　   边框粗细度 默认为1&lt;br/&gt;kaptcha.producer.impl 　　　　　　    验证码生成器 默认为DefaultKaptcha&lt;br/&gt;kaptcha.textproducer.impl 　　　　　  验证码文本生成器 默认为DefaultTextCreator&lt;br/&gt;kaptcha.textproducer.char.string　　    验证码文本字符内容范围 默认为abcde2345678gfynmnpwx&lt;br/&gt;kaptcha.textproducer.char.length 　　  验证码文本字符长度 默认为5&lt;br/&gt;kaptcha.textproducer.font.names 　　  验证码文本字体样式 默认为new Font(&quot;Arial&quot;, 1, fontSize), new Font(&quot;Courier&quot;, 1, fontSize)&lt;br/&gt;kaptcha.textproducer.font.size 　　　  验证码文本字符大小 默认为40&lt;br/&gt;kaptcha.textproducer.font.color 　　 　验证码文本字符颜色 默认为Color.BLACK&lt;br/&gt;kaptcha.textproducer.char.space 　　  验证码文本字符间距 默认为2&lt;br/&gt;kaptcha.noise.impl 　　　　　　　　   验证码噪点生成对象 默认为DefaultNoise&lt;br/&gt;kaptcha.noise.color 　　　　　　　　  验证码噪点颜色 默认为Color.BLACK&lt;br/&gt;kaptcha.obscurificator.impl 　　　　    验证码样式引擎 默认为WaterRipple&lt;br/&gt;kaptcha.word.impl 　　　　　　　　    验证码文本字符渲染 默认为DefaultWordRenderer&lt;br/&gt;kaptcha.background.impl 　　　　　   验证码背景生成器 默认为DefaultBackground&lt;br/&gt;kaptcha.background.clear.from 　　     验证码背景颜色渐进 默认为Color.LIGHT_GRAY&lt;br/&gt;kaptcha.background.clear.to 　　 　　验证码背景颜色渐进 默认为Color.WHITE&lt;br/&gt;kaptcha.image.width　　　　　　 　   验证码图片宽度 默认为200&lt;br/&gt;kaptcha.image.height 　　　　　　     验证码图片高度 默认为50&lt;br/&gt;kaptcha.session.key 　　　　　　　   session中存放验证码的key键&lt;/p&gt;

&lt;p&gt;所实用的框架：SSM&lt;/p&gt;
&lt;p&gt;所需的验证码的 jar 包：kaptcha-2.3.2.jar，可以到官网上下载：&lt;a href=&quot;http://code.google.com/p/kaptcha/&quot; target=&quot;_blank&quot;&gt;http://code.google.com/p/kaptcha/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;applicationContext.xml 需要配置验证码的相关属性：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 验证码 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;captchaProducer&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.google.code.kaptcha.impl.DefaultKaptcha&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;config&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.google.code.kaptcha.util.Config&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;这里的颜色只支持标准色和rgb颜色，不可使用十六进制的颜色&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 是否有边框 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;kaptcha.border&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;no&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 验证码文本字符颜色 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;kaptcha.textproducer.font.color&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;black&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 验证码图片宽度 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;kaptcha.image.width&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;92&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 验证码图片高度 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;kaptcha.image.height&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;36&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 验证码文本字符大小 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;kaptcha.textproducer.font.size&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;24&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; session中存放验证码的key键 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;kaptcha.session.key&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;code&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 验证码噪点颜色 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;kaptcha.noise.color&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;white&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 验证码文本字符间距 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;kaptcha.textproducer.char.space&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 验证码样式引擎 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;kaptcha.obscurificator.impl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.google.code.kaptcha.impl.ShadowGimpy&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 验证码文本字符长度 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;kaptcha.textproducer.char.length&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 验证码文本字体样式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;kaptcha.textproducer.font.names&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;宋体,楷体,微软雅黑&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;生成二维码图片的控制类：CaptchaController.java&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * com.krry.web 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * 方法名：生成二维码控制类
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 创建人：krry 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; response
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * 返回类型：ModelAndView
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@exception&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt;  1.0.0
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     @RequestMapping(&quot;/code&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ModelAndView getKaptchaImage(HttpServletRequest request,HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         HttpSession session =&lt;span&gt; request.getSession();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取验证码
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    String code = (String) session.getAttribute(Constants.KAPTCHA_SESSION_KEY);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    String code = (String) session.getAttribute(&quot;Kaptcha_Code&quot;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除浏览器的缓存&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         response.setDateHeader(&quot;Expires&quot;, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set standard HTTP/1.1 no-cache headers.&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         response.setHeader(&quot;Cache-Control&quot;,&quot;no-store, no-cache, must-revalidate&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set IE extended HTTP/1.1 no-cache headers (use addHeader).&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         response.addHeader(&quot;Cache-Control&quot;, &quot;post-check=0, pre-check=0&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set standard HTTP/1.0 no-cache header.&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; return a jpeg&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         response.setContentType(&quot;image/jpeg&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器记忆功能-----当前过浏览器和服务器交互成功以后下载的图片和资源会进行缓存一次。下次刷新的时候就不会在到服务器去下载。
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取KAPTCHA验证的随机文本&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         String capText =&lt;span&gt; captchaProducer.createText();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将生成好的图片放入会话中&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        session.setAttribute(Constants.KAPTCHA_SESSION_KEY, capText);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create the image with the text&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         BufferedImage bi =&lt;span&gt; captchaProducer.createImage(capText);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         ServletOutputStream out =&lt;span&gt; response.getOutputStream();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; write the data out&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         ImageIO.write(bi, &quot;jpg&quot;&lt;span&gt;, out);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            out.flush();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             out.close();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;前台调用：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;='text' &lt;/span&gt;&lt;span&gt;placeholder&lt;/span&gt;&lt;span&gt;='请输入验证码...' &lt;/span&gt;&lt;span&gt;maxlength&lt;/span&gt;&lt;span&gt;='4' &lt;/span&gt;&lt;span&gt;autocomplete&lt;/span&gt;&lt;span&gt;='off' &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='inp &lt;/span&gt;&lt;span&gt;kr_code' id&lt;/span&gt;&lt;span&gt;='code'&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='&quot;+basePath+&quot;/kaptcha/code.do' &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='yanz_img' &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;='changeyanz($(this));'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;js方法：&lt;/h2&gt;
&lt;h3&gt;点击验证码图片换验证码时，&amp;lt;img&amp;gt; 的 onclick 里面做的就是改变 &amp;lt;img&amp;gt; 标签的 src 属性。&lt;/h3&gt;
&lt;h3&gt;所以要给 url 带一个随机数，这样每次点击验证码图片时，都会由于 src 改变而重新请求 jsp&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; changeyanz(obj){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     obj.attr(&quot;src&quot;,basePath+&quot;/kaptcha/code.do?d=&quot;+&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime());
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 14 Mar 2018 16:11:00 +0000</pubDate>
<dc:creator>筱月</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ainyi/p/8571029.html</dc:identifier>
</item>
<item>
<title>接口测试介绍 - SeanPan</title>
<link>http://www.cnblogs.com/Sean-Pan/p/8571021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Sean-Pan/p/8571021.html</guid>
<description>&lt;div id=&quot;8280-1520764273954&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接口的概念&amp;amp;特点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;接口的概念：&lt;/strong&gt;软件由许多模块构成，软件的功能往往不是某个单独的模块来实现的，而是由模块跟模块之间协作共同实现某个功能，这种模块间的的交互就是通过接口来实现的，我们可以理解为接口就是自己提供给外界的一种抽象物，或者说是一种沟通的协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口测试的本质&lt;/strong&gt;：其实所谓的接口测试本质就是功能测试，只不过我们采用测试接口的方式来测试功能。我们对接口的操作最终会发送到数据库，也就是对数据库进行一些列增、删、改、查的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口测试的优势&lt;/strong&gt;： 接口测试的优势在于，当一个页面还未开发完成的时候，测试可以提前介入，测试软件的功能。接口测试可以发现一些页面操作发现不了的问题，测试介入的越早，解决bug的成本越低。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接口的分类：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;依据开放性划分&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;外部接口：也就是所谓的openapi，是软件对用户可见的接口（包括对应发布的接口文档），用户可以通过工具调取相应接口实现需要的功能。测试人员一般都是测试openapi 。&lt;/li&gt;
&lt;li&gt;内部接口：内部模块间的接口，用户不可见，公司内部人员可见的接口。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依据类型划分&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;webService（SOAP）接口：走soap协议，通过http传输，请求的报文和返回的报文都是xml格式的，需要通过工具进行调用和测试。&lt;/li&gt;
&lt;li&gt;Http API接口：目前较常见的接口，走http协议，通过路径来区分调用的方法，请求的报文都是key-value形式的，返回的报文一般都是json串，包括的方法有post/get/put/delete/patch等。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;延伸概念：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;前端(客户端):负责貌美如花，用户能看的到的都是前端，前台的编程语言有：html,css,js等。&lt;/li&gt;
&lt;li&gt;后端(服务端):负责养家糊口，功能主要靠后端实现的，后台的编程语言有：python,java,php,c,c++等。&lt;/li&gt;
&lt;li&gt;前后端的关系：前后端通过接口交互，采用通用的数据类型(json:所有语言可以解析)，接口返回的都是json体，server端测试主要指的就是接口测试，测试依据接口文档写脚本测试。&lt;/li&gt;
&lt;li&gt;json串的组成 ：key + value ，android开发就是java开发的一个分支，iso采用object-c编译的。&lt;/li&gt;
&lt;li&gt;抓包：就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，为了提供安全性，许都公司的协议都采用https而不是http。&lt;/li&gt;
&lt;li&gt;接口签名：所谓接口签名就是给接口做了加密处理，防止别人恶意篡改请求，它是一个加密（MD5）之后的字符串。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;接口文档包含的内容：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;URL&lt;/li&gt;
&lt;li&gt;接口说明&lt;/li&gt;
&lt;li&gt;请求方式：post/get/delete/put&lt;/li&gt;
&lt;li&gt;入参&lt;/li&gt;
&lt;li&gt;出参&lt;/li&gt;
&lt;li&gt;请求、返回的样例，状态码说明。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;post请求和get请求的区别：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;get请求：浏览器输入url可以直接发送请求，参数都在url里面或者cookie里面，一般用来获取数据，多见于查询接口。&lt;/li&gt;
&lt;li&gt;post请求：参数都在请求体里面，一般包含请求头和请求体，post请求比get请求安全，get请求长度有限制，post无限制，一般是发送数据，多见于创建接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;常见的状态码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;200：代表请求已正常发送和接收。&lt;/li&gt;
&lt;li&gt;300:3开头的代表重定向，最常见的就是302，请求被重定向到其他地址。&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;例子：京东商城里面，用户在没登录的情况下先添加商品到购物车，下单后跳转到登录界面，再跳转到下单页面，就用到了重定向。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;400:400代表请求有语法错误，一般是请求体有误；401代表访问的页面没有授权，用户鉴权失败；403代表没有权限访问页面，404代表页面不存在，多半是url有误。&lt;/li&gt;
&lt;li&gt;500：5开头的代表服务器异常，500代表服务器内部错误，一般服务端有问题。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;接口测试用例设计：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通用性测试：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;正常测试：正确的url+请求方式+请求体等组合到一起。&lt;/li&gt;
&lt;li&gt;异常测试：根据参数类型，是否必填，长度等进行异常测试。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数组合：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;op1 : 新增：name ,班级，电话三个必选。&lt;/li&gt;
&lt;li&gt;op2 : 修改学生，name ,电话三选一&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口安全：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;绕过验证：修改价格&lt;/li&gt;
&lt;li&gt;绕过身份鉴权&lt;/li&gt;
&lt;li&gt;参数是否加密&lt;/li&gt;
&lt;li&gt;密码安全规则&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;cookie跟session的区别：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cookie ：用户登录后，存在本地的一个键值对。&lt;/li&gt;
&lt;li&gt;session：用户登录后，存在服务端的一个键值对，相当于token 。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 14 Mar 2018 16:09:00 +0000</pubDate>
<dc:creator>SeanPan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Sean-Pan/p/8571021.html</dc:identifier>
</item>
<item>
<title>程序员的800字作文 - 刘科宏</title>
<link>http://www.cnblogs.com/firstblogtoliukehong/p/8570979.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/firstblogtoliukehong/p/8570979.html</guid>
<description>&lt;p&gt;**回首**&lt;/p&gt;
&lt;p&gt;转眼三年，行将毕业。这个时候总有很多人感叹第一次踏入校门的模样，毕竟俗人，难免俗套，回顾计机学习三年。&lt;/p&gt;
&lt;p&gt;我问过我周围很多人，当初为什么选这个专业，尤其好奇女生的原因，然而她们绝大多数是调剂过来的，并非第一志愿。但这不是我想要的答案，我以为每一个计算机学院的人都是抱着成为一个黑客的目标而来的。不得不说，欧美一些大片谍中谍之类中的每个团队小组，不可或缺的都是电脑天才这一角色，一人一台电脑，局势尽在掌控。相比于浑身肌肉的主角，我更喜欢不苟言笑的科技向的技术宅。所以，高考结束后，想到的便是计算机方面专业。选填计算机专业还有另一个原因，高考的结果也并非我想要的。看着以前的同学可以去更好的学校，心里也很多不甘。那时候觉得兴趣决定这专业能力，所以在计算机方面，至少每个学校教授的内容都差不多，大家至少应该是公平的，甚至于我可以强过我的一些高中同学。&lt;/p&gt;
&lt;p&gt;但经历了三年，仍然憧憬着一种生活方式穿着帽衫在一个安静的角落与世隔绝，电脑屏幕跑动着代码的荧光指引到另一个更为宽广神秘的世界。小小的房间有一个门，开门即出世，关门则入世。所以依旧不后悔三年前的选择。以前最感兴趣的还是网络安全领域，万般变化绕指柔，但这三年，专业使我更多地关注人工智能领域，更多地好奇，人工智能背后的算法，是如何将冰冷的代码转换成有温度的硅基生命体。&lt;/p&gt;
&lt;p&gt;**总结**&lt;/p&gt;
&lt;p&gt;三年来，从计算机导论说起，我们学过了C程序设计，离散数学，C++程序设计，数据结构，计算机组成原理呢，网络原理，说是掌握了什么专业知识，个人倒觉得并没有真正学到些什么。C和C++也只是学到了编程基本操作，却谈不上学会了什么很多的高级算法，只会几种排序算法，链表栈指针的操作，数据结构依稀记得哈夫曼编码，最短路径算法。等学到了网络原理，觉得也蛮感兴趣的，可这和组原一样，不能像编程一样，随时就能练习操作的。嗯，看着代码运行成功，更具有成就感。学得的仅仅只限于老师课堂上所教授，勉强应付考试。当突然一天了解到以前的同学已经加入ACM校队去外地比赛时，才知道大学所学的，和以后要用的更多地是靠自己自学。当意识到这一点时已经大二下学期了，想着自学什么来着，可转过头来再仔细想想，是不是精通一门语言就可以了，其他的语言了解一下基本的语法规则？就在犹豫中，家人有催促着考研，顿时觉得留给大学时日真的不多了。&lt;/p&gt;
&lt;p&gt;**未来**&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;看到一位清华学长的一篇博客，介绍到自己从接触计算机到实习面试工作的全过程。突然感慨道，若是清华学生也都这样诸事皆不顺的话，那么现在浑浑噩噩的我的前途岂不是更堪忧！？但理想毕竟还是理想，兴趣之所在，依然对未来的自己抱着极大的自信的，也说不上为什么，总是对自己有着迷之自信。再想想，自己毕竟是本科，相较于其他像行行转IT的人来说，自己还是有一定的基础优势的。再有着兴趣与理想的加持，嗯，迷之自信又来了。关于规划，更近一点地是在实习中及工作的初期，努力参加各种项目，学习更适合社会需求的专业知识。有着只是和能力的储备，然后可以谋求更好一点的工作职位和专业研究了。&lt;/p&gt;

</description>
<pubDate>Wed, 14 Mar 2018 16:00:00 +0000</pubDate>
<dc:creator>刘科宏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/firstblogtoliukehong/p/8570979.html</dc:identifier>
</item>
<item>
<title>解决Android Studio 3.0导入module依赖后unable to merge index - Yusuzhan</title>
<link>http://www.cnblogs.com/fortitude/p/8570960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fortitude/p/8570960.html</guid>
<description>&lt;h2 id=&quot;解决android-studio-3.0导入module依赖后unable-to-merge-index&quot;&gt;解决Android Studio 3.0导入module依赖后unable to merge index&lt;/h2&gt;
&lt;p&gt;项目需要使用im, 在项目里导入了腾讯im的几个module依赖, 项目无法编译, 报错unable to merge dex&lt;/p&gt;
&lt;p&gt;网上搜索一番后发现解决方案大致分以下几种:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先clean再rebuild, 删除.gradle文件夹 clean rebuild....&lt;/li&gt;
&lt;li&gt;降低play-service版本, 腾讯IM demo中用的play-serivce是3.0的, 估计已经够低了 :)&lt;/li&gt;
&lt;li&gt;依赖冲突导致&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;试了前两种方案没有解决我的问题, 我的项目是近期创建的, &lt;strong&gt;腾讯IM demo的gradle插件版本是2.3.3, gradle版本3.3&lt;/strong&gt;, &lt;strong&gt;我的项目gradle插件版本3.0.1, gradle版本4.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;./gradlew dependencies&lt;/code&gt;, 检查依赖, 发现多处传递依赖, 几个库module中compile sdk版本有的是22, 有的是23, 因此使用的support包版本也不相同, 导致依赖版本冲突&lt;/p&gt;
&lt;p&gt;使用gradle3新增函数&lt;code&gt;implementation&lt;/code&gt;替换库module中的&lt;code&gt;compile&lt;/code&gt;函数, &lt;code&gt;implementation&lt;/code&gt;导入的依赖只会在module内部引用而不会传递, 问题解决.&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 15:57:00 +0000</pubDate>
<dc:creator>Yusuzhan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fortitude/p/8570960.html</dc:identifier>
</item>
<item>
<title>异步解决方案promise及源码实现 - bluebear</title>
<link>http://www.cnblogs.com/shibaxiong/p/8570964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shibaxiong/p/8570964.html</guid>
<description>&lt;p&gt;js语言的特性，造就了特别的异步处理方式，我记得以前用的最多的就是回调函数，那个时候写jquery的ajax时候，特别喜欢写这种代码：&lt;/p&gt;
&lt;p&gt;$.ajax({&lt;/p&gt;
&lt;p&gt;　　method:'get',&lt;/p&gt;
&lt;p&gt;　　url:&quot;http://text/api&quot;,&lt;/p&gt;
&lt;p&gt;　　success:function(){&lt;/p&gt;
&lt;p&gt;　　　　　　$.ajax({&lt;/p&gt;
&lt;p&gt;　　　　　　　　method:'get',&lt;/p&gt;
&lt;p&gt;　　　　　　　　url:&quot;http://text/api&quot;,&lt;/p&gt;
&lt;p&gt;　　　　　　　　success:function(){&lt;/p&gt;
&lt;p&gt;　　　　　　}&lt;/p&gt;
&lt;p&gt;　　　　});&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;后一个ajax的发送需要依赖前面的ajax的返回，也许有的朋友说还好啊，其实一两个确实还好，但是多了就比较晕。不直观。后面调试起来有点麻烦。后来很多浏览器就自己实现了一种promise原生对象，这个对象提供一系列方法，来解决这种回调带来的不直观，不易维护的问题。&lt;/p&gt;

&lt;p&gt;　　首先，这个promise很多浏览器已经实现了，开发者只需要调用就可以，就像window,document之类的一样。首先介绍一下它的用法吧！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775923/201803/775923-20180314231945343-2088989196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们需要通过new调用Promise对象，这个对象需要传入一个函数，函数有两个参数，分别是resolve,reject,分别代表成功和失败两种状态，同时还有一个then的方法，它也有两函数作为参数，第一个表示任务处理成功的后续操作，第二个表示任务处理失败的后续操作，当我们调用实例上的then 的方法后，promise会根据我们在new Promise过程中调用的是resolve还是reject来判断应该执行哪一个函数。&lt;/p&gt;
&lt;p&gt;　　这样我们可以简单粗暴的改写一个上面那个ajax的代码&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/775923/201803/775923-20180314233522333-550575119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样一来代码变的更加明了，而且then方法可以一直链式调用下去，不管有多少异步任务都可以通过then方法写下去。&lt;/p&gt;
&lt;p&gt;　　接下来，我们看看怎么模拟这种操作，写一个自己的promise。&lt;/p&gt;
&lt;p&gt;　　首先，我们需要设定三种状态，成功，失败 和 等待，也就是一个任务完成的情况，做完了就是成功，没做好就是失败，还没开始做就是等待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775923/201803/775923-20180314234140738-769384948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775923/201803/775923-20180314234228388-1880252996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就完成了一个promise最基本的功能，此时，如果在excutor函数中，出现一个异步任务，需要等待一秒才能执行resolve或者reject,此时状态会处于pending,我们需要做一个数组，把这些等着状态的任务装起来，在reject或者resolve执行时候，遍历数组，一个一个依次执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775923/201803/775923-20180314234855585-1109344304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775923/201803/775923-20180314234949425-1287066582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来增加链式调用功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775923/201803/775923-20180314235117786-1196587315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775923/201803/775923-20180314235142009-260681749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775923/201803/775923-20180314235212051-1890663460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此我们还要解决用户在then方法中随意返回数据的问题，用户可能返回一个普通值，也可能返回一个新的promise，因此还需要作进一步处理&lt;/p&gt;

&lt;pre readability=&quot;8&quot;&gt;
function Promise(executor) { // executor是一个执行函数&lt;br/&gt;let self = this;&lt;br/&gt;self.status = 'pending';&lt;br/&gt;self.value = undefined; // 默认成功的值&lt;br/&gt;self.reason = undefined; // 默认失败的原因&lt;br/&gt;self.onResolvedCallbacks = []; // 存放then成功的回调&lt;br/&gt;self.onRejectedCallbacks = []; // 存放then失败的回调&lt;br/&gt;function resolve(value) { // 成功状态&lt;br/&gt;if (self.status === 'pending') {&lt;br/&gt;self.status = 'resolved';&lt;br/&gt;self.value = value;&lt;br/&gt;self.onResolvedCallbacks.forEach(function (fn) {&lt;br/&gt;fn();&lt;br/&gt;});&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;function reject(reason) { // 失败状态&lt;br/&gt;if (self.status === 'pending') {&lt;br/&gt;self.status = 'rejected';&lt;br/&gt;self.reason = reason;&lt;br/&gt;self.onRejectedCallbacks.forEach(function (fn) {&lt;br/&gt;fn();&lt;br/&gt;})&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;try {&lt;br/&gt;executor(resolve, reject)&lt;br/&gt;} catch (e) { // 捕获的时候发生异常,就直接失败了&lt;br/&gt;reject(e);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;function resolvePromise(p2,x,resolve,reject){&lt;br/&gt;// 有可能这里返回的x是别人的promise&lt;br/&gt;// 尽可能允许其他乱写&lt;br/&gt;if(p2===x){ //这里应该报一个类型错误，有问题&lt;br/&gt;return reject(new TypeError('循环引用了'))&lt;br/&gt;}&lt;br/&gt;// 看x是不是一个promise,promise应该是一个对象&lt;br/&gt;if(x!==null||(typeof x === 'object'||typeof x === 'function')){&lt;br/&gt;// 可能是promise {},看这个对象中是否有then方法，如果有then我就认为他是promise了&lt;br/&gt;try{ // {then:1}&lt;br/&gt;let then = x.then;&lt;br/&gt;if(typeof then === 'function'){&lt;br/&gt;// 成功&lt;br/&gt;then.call(x,function(y){&lt;br/&gt;// y可能还是一个promise，在去解析直到返回的是一个普通值&lt;br/&gt;resolvePromise(promise2,y,resolve,reject)&lt;br/&gt;},function(err){ //失败&lt;br/&gt;reject(err);&lt;br/&gt;})&lt;br/&gt;}else{&lt;br/&gt;resolve(x)&lt;br/&gt;}&lt;br/&gt;}catch(e){&lt;br/&gt;reject(e);&lt;br/&gt;}&lt;br/&gt;}else{ // 说明是一个普通值1&lt;br/&gt;resolve(x); // 表示成功了&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;Promise.prototype.then = function (onFulfilled, onRjected) {&lt;br/&gt;let self = this;&lt;br/&gt;let promise2; //返回的promise&lt;br/&gt;if (self.status === 'resolved') {&lt;br/&gt;promise2 = new Promise(function (resolve, reject) {&lt;br/&gt;// 当成功或者失败执行时有异常那么返回的promise应该处于失败状态&lt;br/&gt;// x可能是一个promise 也有可能是一个普通的值&lt;br/&gt;let x = onFulfilled(self.value);&lt;br/&gt;// x可能是别人promise，写一个方法统一处理&lt;br/&gt;resolvePromise(promise2,x,resolve,reject);&lt;br/&gt;})&lt;br/&gt;}&lt;br/&gt;if (self.status === 'rejected') {&lt;br/&gt;promise2 = new Promise(function (resolve, reject) {&lt;br/&gt;let x = onRjected(self.reason);&lt;br/&gt;resolvePromise(promise2,x,resolve,reject);&lt;br/&gt;})&lt;br/&gt;}&lt;br/&gt;// 当调用then时可能没成功 也没失败&lt;br/&gt;if (self.status === 'pending') {&lt;br/&gt;promise2 = new Promise(function (resolve, reject) {&lt;br/&gt;// 此时没有resolve 也没有reject&lt;br/&gt;self.onResolvedCallbacks.push(function () {&lt;br/&gt;let x = onFulfilled(self.value);&lt;br/&gt;resolvePromise(promise2,x,resolve,reject);&lt;br/&gt;});&lt;br/&gt;self.onRejectedCallbacks.push(function () {&lt;br/&gt;let x = onRjected(self.reason);&lt;br/&gt;resolvePromise(promise2,x,resolve,reject);&lt;br/&gt;});&lt;br/&gt;})&lt;br/&gt;}&lt;br/&gt;return promise2;&lt;br/&gt;}&lt;br/&gt;// mjs&lt;br/&gt;module.exports = Promise&lt;p&gt;到此基本完成promise的基本功能，但还有一些方法没有实现，比如race ,all,也没有实现同时调用reject和resolve的问题，后续有时间再处理。有问题请指正
&lt;/p&gt;&lt;/pre&gt;



</description>
<pubDate>Wed, 14 Mar 2018 15:57:00 +0000</pubDate>
<dc:creator>bluebear</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shibaxiong/p/8570964.html</dc:identifier>
</item>
<item>
<title>秘密：从程序员到领导者的微妙之处 - mindwind</title>
<link>http://www.cnblogs.com/mindwind/p/8570942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mindwind/p/8570942.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/815275/201803/815275-20180314235253139-659041164.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;读到一篇关于程序员、领导力和领导者的好文章，翻译过来分享下。借用一句文中的话：“好吧，我只是个程序员，为什么需要领导？” ，读完你就知道了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;做一个优秀的领导者可能不是大部分程序员会立即认同的东西。许多人的脑海里立即浮现出这样一种形象：宏大的讲台与高昂的演讲。&lt;/p&gt;
&lt;p&gt;然而，让我们看看塞斯·高汀（Seth Godin）对领导力的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;领导力的秘密很简单：做相信的事，画出一幅未来的图像。去那里，人们自会跟随。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;突然之间，领导力似乎唾手可得，就像是每个人都能做的事情。领导力并不是仅保留给那些被授予权力的人，比如 CEO，CTO 或公司的创始人。&lt;/p&gt;
&lt;p&gt;领导力可能是你缺失的一块，它能让你的职业生涯跨越一大步；领导力也可以是一种工具，它能解决你代码库中遍布的大隐患。&lt;/p&gt;
&lt;p&gt;也许我们想要成为一位优秀的领导者，然而领导者们为了获得他们的影响力与尊重，所做的事情比表面上看起来更微妙。优秀的领导者具有一些微妙的习惯和行为，他们把这些习惯融入了日常的互动与关系之中。&lt;/p&gt;
&lt;h2 id=&quot;好吧但我只是个程序员为什么我需要领导&quot;&gt;好吧，但我只是个程序员，为什么我需要领导？&lt;/h2&gt;
&lt;p&gt;领导力发生在所有的层级上，不仅仅是 CTO 或创始人他们才能领导，领导力可以来自组织架构树的任何层级。由于大多数程序员都处在执行层面的核心位置，所以他们有绝佳的机会注意到效率问题，并带头创新。&lt;/p&gt;
&lt;p&gt;领导力让你与众不同。那种 “我只是一个程序员” 的心态会严重妨碍你的职业生涯发展，一个技术熟练又善于领导的人将会脱颖而出。&lt;/p&gt;
&lt;p&gt;你可以一边领导一边写代码，变成一个领导者并不意味着放弃你作为程序员的日常工作。领导者是一个有想法的人，他有足够的勇气来描绘一个愿景，并坚持不懈地追求它。你甚至可以带领你的团队走向一个技术愿景，这个愿景将你与你所热爱的开发工作更紧密地联系在一起，而不是让你远离它。&lt;/p&gt;
&lt;p&gt;领导力是永恒的。你使用 Java、C 或 Ruby 编写代码的能力可能会随着时间的推移或语言、平台与需求的变化而减弱。然而，领导一个团队走向成功的能力是永恒的，而且永远是人们所需要的。&lt;/p&gt;
&lt;p&gt;领导力需要时间，培育领导力需要时间。也许，当下领导团队不是你的优先事项，但在未来，你很可能发现自己要么处在一个领导位置，要么想要成为一个领导者 —— 那么现在做好准备可能是个好主意。&lt;/p&gt;
&lt;p&gt;领导力将给予你在团队中的影响力。对如何改进代码库有一个很好的主意？想要使用一种新的编程语言或框架？对新产品有一个好主意？棒极了，然而，严酷的现实是，每个人都有想法。问题是：你能实现它们吗？领导者是这样的人，他们的想法才会被倾听并且推动其前行。&lt;/p&gt;
&lt;p&gt;那些推动变化的人才会获得奖励。你的头衔可能是 “软件开发工程师” 并且容易陷入这种身份认知。然而，你不仅仅是你的头衔。你被雇佣来解决问题（诚然，主要是用代码解决问题），为了解决问题，你要能够利用他人的力量和经验 —— 这就是领导力。当你实现了改变并产生了影响，你就会得到回报。不要坐等改变 —— 让它发生。&lt;/p&gt;
&lt;p&gt;英雄般的传奇程序员一直是个神话，没有程序员能够单独完成任何事情，软件开发如今成了一项团队运动。为了取得成功，你需要能够让周围的人支持你或你的团队。如果你能证明你能激励一个团队，让他们行动起来，你就会变得无价。&lt;/p&gt;
&lt;p&gt;并不存在十倍效能于他人的程序员，但的确有让 5 个队友技能倍增的程序员。&lt;/p&gt;
&lt;h2 id=&quot;成为一个领导者不是那么简单的任务&quot;&gt;成为一个领导者不是那么简单的任务&lt;/h2&gt;
&lt;p&gt;做为一个初级程序员，当我第一次尝试成为领导者时，我犯了一个巨大的错误：我模仿周围的人。我痛苦的发现我的作法是多么的天真，并了解到领导力比我最初想象的要微妙的多。&lt;/p&gt;
&lt;p&gt;事实上，我是在健身房学会了领导力课程。我持续健身有七年多了，我观察到在每个健身房都存在一种新手现象，让人想笑，他们都在做一样的动作，无论我走到哪个健身房都一样。&lt;/p&gt;
&lt;p&gt;这些新手到底有什么共同点？他们直接复制与模仿他人。&lt;/p&gt;
&lt;p&gt;想象一下：你正在完成你的第一次锻炼，然后走开，开始你的第二次锻炼。一旦你离开，回头看，你就会发现一些健身新手就在你身后，像影子一样模仿你的一举一动！&lt;/p&gt;
&lt;p&gt;当你对一个领域知之甚少，照搬别人似乎是有意义的。但是，以我的经验来看，这是一个巨大的错误。&lt;/p&gt;
&lt;p&gt;在健身训练中，实质发生在表象之后。高级健身会员可能会通过做一些你看不到的事情来获得你想要的成果。&lt;/p&gt;
&lt;p&gt;作为一名新手，我没有意识到高级健身会员训练中的以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;他们已经策略性的分析了自己的弱点&lt;/li&gt;
&lt;li&gt;他们在用不同的方式加固他们的核心&lt;/li&gt;
&lt;li&gt;他们专注于建立 “思维-肌肉” 的联系&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所有这些都无法被明显地观察到 —— 这些就是其中的微妙之处，就像高效领导者的行为一样。&lt;/p&gt;
&lt;p&gt;当你观察你的资深程序员或团队领导时，你可能没有意识到他们在幕后投入了多少基础工作来支持和鼓励团队。&lt;/p&gt;
&lt;p&gt;一个资深程序员在弹指间驱动团队的强大能力，可不是朝夕之间建立起来的 —— 并且这无关乎他们有多好的编码能力。多年来，他们的影响力被持续精心打磨，并在其所加入的所有团队中被精心实现。&lt;/p&gt;
&lt;p&gt;我在我的第一个领导角色中犯下的 “复制错误” —— 我模仿其他人看上去是如何领导的 —— 创造了一种不真实，机械且虚假的风格。我没能观察到领导力的微妙之处。我当时以为领导是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;委派任务!&lt;/li&gt;
&lt;li&gt;发布命令！&lt;/li&gt;
&lt;li&gt;表现权威！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好尴尬！（如今想来）&lt;/p&gt;
&lt;p&gt;我错过了什么？一个简单的事实：好的领导是支持与说服的大师。&lt;/p&gt;
&lt;p&gt;仅仅观察一个领导者的行为，只会给你全貌的一半。&lt;/p&gt;
&lt;p&gt;作为一名程序员，当你想让你的想法获得通过时，你需要能够理解他人，理解他们的动机和他们的需求，以便得到你想要的行动与改变。&lt;/p&gt;
&lt;h2 id=&quot;领导者的微妙习惯&quot;&gt;领导者的微妙习惯&lt;/h2&gt;
&lt;p&gt;好吧，我想你已经确信成为一个领导者对你做为软件开发工程师的职业生涯来说是很重要的，但你该如何去做呢？&lt;/p&gt;
&lt;h3 id=&quot;领导者基于同理心控制自己的情绪&quot;&gt;1. 领导者基于同理心控制自己的情绪&lt;/h3&gt;
&lt;p&gt;当我们对批评或困难作出情绪化反应时，结果可能很难接受。领导者需要保持平易近人的态度，这样他们的队友就会觉得可以对他们保持开放与诚实。做为一个领导者，你想要诚实的信息而非糖衣包裹的美化物。&lt;/p&gt;
&lt;p&gt;为了实现这种情绪稳定，领导者们一直在努力理解他人的感受。&lt;/p&gt;
&lt;p&gt;在对情况作出反应之前，好的领导者会作出如下思考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么其他人是以这样的方式感觉的&lt;/li&gt;
&lt;li&gt;为什么其他人是以这样的方式行为的&lt;/li&gt;
&lt;li&gt;为什么其他人会说这些话&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：你可能评审了其他程序员的代码，而他们对你的反馈感到不快。一种未经考虑的情绪反应可能会对你们的关系产生负面影响。&lt;/p&gt;
&lt;p&gt;你可能会想：“但我写下这些评价，是因为我想帮助他们啊！”。&lt;/p&gt;
&lt;p&gt;尽管有这样的想法，一个好的领导者还是会花一点时间去理解他们同事的观点，并意识到批评有时是很难接受的。考虑到这种更有同理心的反应，你可能会平静地解释所要求的改变的目的，甚至可能会主动提出结对编程。&lt;/p&gt;
&lt;h3 id=&quot;领导者建立个人关系&quot;&gt;2. 领导者建立个人关系&lt;/h3&gt;
&lt;p&gt;非正式且个人化的探讨建立信任。&lt;/p&gt;
&lt;p&gt;成组的 “团队建设” 有它的作用。优秀的领导者不仅要花时间在团队环境中，而且要寻求与团队成员进行一对一的高质量的交流。个人与个人相处的时间让你有机会在更有意义和更个人的层面上与某人建立联系，这会建立你们之间的信任。&lt;/p&gt;
&lt;p&gt;结对编程是建立这种一对一信任的另一个重要机会。与其他团队成员坐在一起，帮助他们一起完成工作。与他们分享你的知识，保持耐心与理解。&lt;/p&gt;
&lt;p&gt;编码可能是个相当孤独的游戏。尽量找到机会，花一点时间与队友远离键盘。一起吃午餐，或者在他们戴上耳机潜心代码之前，激发起一些关于周末安排的交谈。这些对建立关系的小投资将会获得长期的回报。&lt;/p&gt;
&lt;h3 id=&quot;领导者不做评价dont-judge&quot;&gt;3. 领导者不做评价（Don't Judge）&lt;/h3&gt;
&lt;p&gt;领导者期望深思熟虑的冒险者为自己工作，他们希望围绕在自己身边的人能够自我驱动。&lt;/p&gt;
&lt;p&gt;为了更好地给予帮助，领导者不去做评价或嘲笑周围人的决策，这样做会削弱领导者的权力与影响力。&lt;/p&gt;
&lt;p&gt;当你的队友意外提交了一些他们不该提交的代码时，会发生什么？你会谴责他们吗？当众说他们是笨蛋？还是帮他们私下清理干净，甚至承认你曾经也犯过很多次类似同样的错误？&lt;/p&gt;
&lt;p&gt;谦卑一点，行将至远。&lt;/p&gt;
&lt;h3 id=&quot;领导者给予反馈&quot;&gt;4. 领导者给予反馈&lt;/h3&gt;
&lt;p&gt;领导者优先考虑他人。&lt;/p&gt;
&lt;p&gt;领导者以建设性的方式向同事提供反馈，以支持他们的成长。他们把团队的最大利益放在心上。&lt;/p&gt;
&lt;p&gt;作为一个程序员，到处都有提供反馈的机会：最困难的部分是有勇气以建设性的方式表达自己的感受。&lt;/p&gt;
&lt;p&gt;当一个团队成员主持一次正式会议，一次敏捷站立会，一次复盘等等，抓住机会，提供一些你认为哪里是好的和哪里还可以改进的洞察。&lt;/p&gt;
&lt;p&gt;记住，一个好反馈的核心在于意愿 —— 你希望其他队友或程序员知道你提供反馈是因为你想帮助他们。&lt;/p&gt;
&lt;h3 id=&quot;领导者慷慨而公开的赞扬&quot;&gt;5. 领导者慷慨而公开的赞扬&lt;/h3&gt;
&lt;p&gt;领导者表现得正面积极时会更有力量。假如你是一个充满活力的人，当你离开后也会被想念。当你看见某人做了一件了不起的事情时，要特别强调它，并且公开地这样做。&lt;/p&gt;
&lt;p&gt;赞扬能在团队中产生最大的影响。好的，公开的赞扬建立起了那些被你赞扬的人的信心，并让别人有机会模仿这样的行为，从而获得同样的赞扬。&lt;/p&gt;
&lt;p&gt;赞扬的好时机 —— 包括敏捷计划会，每日站立会和复盘回顾。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这就是，成为一个领导者的一些更微妙的方面。&lt;/p&gt;
&lt;p&gt;记住：如果你想成为团队中的领导者，它不需要浮夸的演讲或者骑着马走进办公室。&lt;/p&gt;
&lt;p&gt;要成为领导者，你可以通过每天建立这些小的行为习惯来投资自己，通过花时间有意识地自我反思，并提醒自己想要展示的行为以及你希望如何被你的团队看到。&lt;/p&gt;
&lt;p&gt;很快，可能在你意识到之前，你将会展现出这些微妙的习惯，并会发现其他人蜂拥向你寻求建议、支持与机会。很快，你将发现你的职业生涯实现了一大步的跨越。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;作者：Lou Bichard&lt;br/&gt;日期：2017-06-07&lt;br/&gt;原文：&lt;a href=&quot;https://simpleprogrammer.com/secrets-effective-leaders/&quot;&gt;5 Subtle Secrets Of Effective Leaders&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写点文字，画点画儿，记录成长瞬间。&lt;br/&gt;微信公众号「瞬息之间」，既然遇见，不如同行。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/815275/201602/815275-20160216164606173-1251141402.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 15:54:00 +0000</pubDate>
<dc:creator>mindwind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mindwind/p/8570942.html</dc:identifier>
</item>
<item>
<title>Spark ML源码分析之一 设计框架解读 - jicanghai</title>
<link>http://www.cnblogs.com/jicanghai/p/8570805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jicanghai/p/8570805.html</guid>
<description>&lt;p&gt;本博客为作者原创，如需转载请注明http://www.cnblogs.com/jicanghai/p/8570805.html&lt;/p&gt;

&lt;p&gt;        在深入理解Spark ML中的各类算法之前，先理一下整个库的设计框架，是非常有必要的，优秀的框架是对复杂问题的抽象和解剖，对这种抽象的学习本身，就是加深框架所面对的问题的理解的一种有效途径。纷繁复杂的机器学习问题，经过优秀框架的解析，变得简单清晰起来。&lt;/p&gt;
&lt;p&gt;        基于面向对象语言的程序设计，本质上类似于搭积木，从一个最抽象、最简单的内容开始，一点一点的往上堆叠，形成一个对象的框架。比如Java中的Object，Python中的PyObject等等，这也是面向对象语言教给我们的一种解决问题的思路：剥洋葱，把外层非本质的表皮一个一个剥去，剩下的就是事物的本质与核心。&lt;/p&gt;
&lt;p&gt;        那么，机器学习问题的核心是什么呢？Spark ML给出的答案是，参数。所有的机器学习模型、算法，说到底都是对参数的学习。因此，在Spark ML框架中，最底层也是最抽象的类，就是Param，一个对象只要是能包含参数的，都可以叫做Param。&lt;/p&gt;
&lt;p&gt;        在param文件夹下，包含了对参数类及其子类的代码。参数类的子类，主要分成两种，第一种是数据类型类，包括IntParam，DoubleParam，顾名思义，这些参数包含了某种数据类型的数据，第二种是参数集合Params，表示其中包含了许多参数，这个类就很了不起了，从它开始衍生出了很多实用的参数，比如HasRegParam，表示其中包含了正则化的参数，再比如HasMaxIter，表示其中包含了最大迭代次数的参数。看，机器学习模型的积木已经帮我们准备好了，从参数的角度来抽象各类机器学习问题，可以按照是否包含某个参数，对机器学习模型和算法进行拆解，一个算法需要什么参数，就在定义时，像搭积木一样，把对应的参数包括进来就好了。&lt;/p&gt;
&lt;p&gt;        参数仅是静态的内容，如果要让这个对象有用，就需要让它具有一定的功能。最底层的具有功能性的类是PipelineStage，它实际上是一个Params，关于Pipeline的概念，我们稍后介绍，这里需要理解的是，虽然PipelineStage与Pipeline的名称很相似，但它们之间还隔了一层，完全不是一个层面上的东西。PipelineStage是一个抽象的阶段，它本身不具备任何功能，它的存在仅是为了给真正有功能的类一个公共的子类，与Param的其它子类相区分。&lt;/p&gt;
&lt;p&gt;        接下来就到了我们平时最常用的类，Transformer。一个类，只要它拥有将一个数据集转化成另外一个数据集的功能，它就是一个Transformer。注意，一个Transformer就是一个PipelineStage。&lt;/p&gt;
&lt;p&gt;        仅能完成数据转换，还不够，在机器学习中，最重要的事情是对数据的拟合，这里Estimator类正式登场，只要具有数据拟合的功能，即，只要能从数据中学习，就是Estimator，这个类里包含了我们最熟悉的一个函数，fit，是它赋予了所有Estimator从数据中学习的能力。&lt;/p&gt;
&lt;p&gt;        到这里，我们在机器学习中最常见的“模型”的概念，就已经呼之欲出了。Model类本质上是一个Transformer，这个很好理解，一个训练得到的模型，本身的任务就是做预测，做数据转化的。Model的独特之处在于，它是由Estimator的fit方法生成的，一个Estimator在经过对数据的学习之后，就产生了一个Model，而一个Model中除了一个指向生成自己的Estimator的“指针”之外，真的什么都没有。&lt;/p&gt;
&lt;p&gt;        这里我们再总结一下Transformer（简称T），Estimator（简称E），Model（简称M）三者之间的关系。T和E本质上都是PipelineStage，更本质的来说都是Param，而M本质上是一个T，但它是由E产生的，因此M是连接T和E之间的桥梁。&lt;/p&gt;
&lt;p&gt;        下面要介绍的就是Pipeline，我们知道很多机器学习的任务，都不是一步能完成的，比如做分类，我们要先对数据进行预处理，进行分类，然后再对分类结果进行处理，才能得到想要的结果。于是Spark ML提供了一个非常棒的抽象，流水线（Pipeline），它的引入能使得机器学习的各个任务能像流水线一样被顺序执行，因此能提供非常简洁优雅的编程接口。Pipeline本质上是一个E，它是由一个一个的PipelineStage组成的。通过上文我们知道，T和E都是PipelineStage，因此一个Pipeline中就包含了许多的T和E。由于Pipeline本质上是一个E，因此它在调用fit函数之后，会产生一个PipelineModel，这就是一个Model了。还记得Model的本质是Transformer吗？&lt;/p&gt;
&lt;p&gt;        我们知道，机器学习中的问题可以简单分为两类，监督学习和非监督学习，监督学习的一个特点就是，能够对某个事情做出“预测”，而非监督学习更多的是挖掘数据中的一些内在本质特点，不能做出预测，因此，为了将监督学习的本质提炼出来，设计了一个Predictor类。&lt;/p&gt;
&lt;p&gt;        能做出预测的类，需要有一些共同的参数，还记得刚才我们对于Param的分析吗？参数是区分各类机器学习算法的一种角度，PredictorParams就是有预测能力的监督学习模型拥有参数的一种抽象，而Predictor本质上是一个带有PredictorParams的Estimator，而每一个Estimator在调用fit函数之后都会产生一个Model，这里产生的就是一个PredictorModel，这是一个带有PredictorParams的Model。&lt;/p&gt;

&lt;p&gt;        好了，今天就写到这里。写作也是整理思路的一种很好的方式，在刚才的写作中，对Spark ML的设计思路又有了新的认识。由于本人才疏学浅，以上的理解不免会有纰漏，还请大家不吝赐教。下次将跟大家一起分析下具体算法的设计。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 15:25:00 +0000</pubDate>
<dc:creator>jicanghai</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jicanghai/p/8570805.html</dc:identifier>
</item>
<item>
<title>网络游戏开发- 开场白 - 青城大兄弟</title>
<link>http://www.cnblogs.com/boxrice/p/8570730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boxrice/p/8570730.html</guid>
<description>&lt;p&gt;众所周知（&lt;strong&gt;mei ren zhi dao&lt;/strong&gt;），去年来到一家18线不知名的游戏公司，担任web后台开发的岗位。&lt;/p&gt;
&lt;p&gt;简单来说就是负责充钱啊，做报表啊，维护服务器啊之类的打杂的事情&lt;/p&gt;
&lt;p&gt;每天看到游戏组的同事在那边写代码 debug，眼浅的不得了。于是乎，下班回家，自己也开始来撸一下，游戏也是程序啊。&lt;/p&gt;
&lt;p&gt;同事们主要是用的Unity C++ lua，我一个也不会。。。。请教他们都只能问问思路。。。&lt;/p&gt;
&lt;p&gt;我打算用Egret来写客户端，asp.net core 来写服务器，中间通信使用websocket来完成&lt;/p&gt;
&lt;p&gt;本系列博客不间断更新，看工作忙闲程度吧&lt;/p&gt;
&lt;p&gt;&lt;em&gt;服务器主要内容：&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用.Net Core自带的Websocket类库完成，不依赖第三方包&lt;/li&gt;
&lt;li&gt;实现一个简单的连接池&lt;/li&gt;
&lt;li&gt;实现一个简单的定时任务模块&lt;/li&gt;
&lt;li&gt;实现一个简单的类似于Asp.Net Core Mvc的开发结构&lt;/li&gt;
&lt;li&gt;最后实现一个炸金花的棋牌游戏服务器&lt;/li&gt;
&lt;li&gt;约定和客户端使用的协议内容，选择一种序列化的方式（Json 二进制 protocol   ???? 待确定）&lt;/li&gt;
&lt;li&gt;主要使用技术ASp.Net Core Redis Mysql EFCore Log4Net&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;客户端主要内容：&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;TypeScript的熟悉&lt;/li&gt;
&lt;li&gt;Egret引擎的基本应用&lt;/li&gt;
&lt;li&gt;Egret的EUI简单的应用&lt;/li&gt;
&lt;li&gt;Egret的Tween实现发牌动画&lt;/li&gt;
&lt;li&gt;Egret自带的Websocket框架实现通信&lt;/li&gt;
&lt;li&gt;发布Android Windows10 微信小游戏 H5等平台&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;希望我能坚持，当我说给我朋友说我要写一个这游戏的时候，他怎么都不信，毕竟我的座右铭是：&lt;strong&gt;世上无难事，只要肯放弃&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后我们打了一个100块钱的赌。哈哈&lt;/p&gt;
&lt;p&gt;之所以会选择写一段这样的开场白，或者算是立项之类的话，是因为上一任老板提到的一个词语 “&lt;strong&gt;仪式感&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;写上这么一段，也算是一个开始，放弃的时候，想到万一有园子里的大兄弟等着我更新呢？我不更新会不会给我寄刀片啊？？？&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/653862/201803/653862-20180314231730322-1808902276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 14 Mar 2018 15:18:00 +0000</pubDate>
<dc:creator>青城大兄弟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/boxrice/p/8570730.html</dc:identifier>
</item>
</channel>
</rss>