<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>拥抱开源，Office 365开发迎来新时代 - 陈希章</title>
<link>http://www.cnblogs.com/chenxizhang/p/8870829.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxizhang/p/8870829.html</guid>
<description>&lt;p&gt;作为全球最大的开放源代码托管平台，Github在上周迎来了它的十岁生日。自从2008年正式上线以来，Github上面汇聚了数以千万计的开发人员和各种项目，它几乎成为了开源的代名词和风向标，各大软件巨头都纷纷支持，在广大程序员心目中，也更是精神图腾一般的存在，坊间戏言它是最大的同性交友平台。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-21-22-05.png&quot;&gt;&lt;img alt=&quot;github 十周年&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-21-22-05.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我自己对开源了解不多，并且能力也有限，一直没有在这方面有所贡献，但我肯定和大家一样都是Github的受益者。今天这篇文章一方面是希望借此为Github庆生（本来是上周想写，但一直没有时间），另外也是因为最近有开源社区的朋友邀请我有机会谈一谈这些年Office 开发（尤其指Office 365开发）中对开源的支持，因为工作的关系，我多多少少知道一点，就斗胆写出来，也算是向“开源”精神致敬吧，请大家参考。&lt;/p&gt;
&lt;blockquote readability=&quot;6.9132947976879&quot;&gt;
&lt;p&gt;本文以及这个系列文章都是托管在&lt;code&gt;Github&lt;/code&gt;上面，用&lt;code&gt;markdown&lt;/code&gt;这种自由奔放的轻量级标记语言写成，使用的工具&lt;code&gt;Visual Studio Code&lt;/code&gt;也是开源的，欢迎到&lt;a href=&quot;https://github.com/chenxizhang/office365devlabs&quot;&gt;https://github.com/chenxizhang/office365devlabs&lt;/a&gt; 上面来提&lt;code&gt;issue&lt;/code&gt;，欢迎给我&lt;code&gt;star&lt;/code&gt;给我鼓励，欢迎&lt;code&gt;fork&lt;/code&gt;这个&lt;code&gt;repo&lt;/code&gt;并且通过&lt;code&gt;pull request&lt;/code&gt;提交你的见解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;微软这几年内部进行了深刻的转型，为外界所熟知的除了有业务方向的变化、组织的调整、股价的飞涨之外，时不时会有一些让业界“看不懂”的新动作，过去的不多说，今天最新的一个劲爆新闻是微软也要推出自己定制版本的Linux，不仅让人感慨这世界到底怎么了。&lt;/p&gt;
&lt;p&gt;但要论起微软在开源方面的努力，其实在多年前就开始了。2006年前后，微软发布了Codeplex网站，当时也是规模不小的开源代码托管平台，微软自己有很多著名的项目，都是在这个平台上面开放源代码，包括ASP.NET等，后来的故事大家也差不多知道，随着Github的崛起并且成为事实上的标准，微软将几乎所有项目迁移到了Github，并且于2017年12月份正式封存了Codeplex（目前继续提供只读查询，和下载服务）&lt;/p&gt;
&lt;p&gt;2014年4月，微软宣布成立.NET基金会，同时宣布释出.NET编译器平台Roslyn，作为开放源代码软件。11月释出在服务器上运行的.NET Core源代码，交由.NET基金会管理，鼓励自由软件社群参与将.NET软件平台移植到Linux与Mac OS上。基金会由开源社区的大神Miguel领衔，管理着55个正式的项目，不少业界的知名公司也是基金会的重要成员，包括Google，三星等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-21-56-32.png&quot;&gt;&lt;img alt=&quot;.net 基金会&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-21-56-32.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.6842105263158&quot;&gt;
&lt;p&gt;值得一提的是，.NET基金会的源代码也是托管在Github上面的，地址是 &lt;a href=&quot;https://github.com/dotnet&quot;&gt;https://github.com/dotnet&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回到Github上面来，据不完全统计，目前微软员工参与Github的人数是全世界最多的，所有项目获得Star总数组织排名全世界第三。下面我有一个不完全的统计，开源看出近四年来，微软在Github上面的贡献稳步攀升的表现，目前的Repository数量至少有 2054 个。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-01-16.png&quot;&gt;&lt;img alt=&quot;microsoft at github&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-01-16.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前在Github上面，微软最受欢迎的40个项目如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-03-11.png&quot;&gt;&lt;img alt=&quot;top 40&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-03-11.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么，我们来看看Office 365的开发，到底跟开源有什么关系呢？在Github上面，微软除了有一个最大的组织（&lt;a href=&quot;https://github.com/microsoft&quot;&gt;https://github.com/microsoft&lt;/a&gt;）外, 还有两个跟Office 365开发直接相关的组织，他们分别是&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SharePoint 开发 ：&lt;a href=&quot;https://github.com/sharepoint&quot;&gt;https://github.com/sharepoint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Office 365 开发 ：&lt;a href=&quot;https://github.com/officedev&quot;&gt;https://github.com/officedev&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;SharePoint开发十大最受欢迎项目如下所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-08-59.png&quot;&gt;&lt;img alt=&quot;sharepoint project&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-08-59.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Office 365开发中star数量超过100个16个项目如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-10-04.png&quot;&gt;&lt;img alt=&quot;office project&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-10-04.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上是微软产品组不断贡献出来的一些项目。接下来，我还要谈一下在Office 365开发的不同层面，我们是如何支持开源平台的。目前来说，我们一般将Office 365的开发分为如下几个领域&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用Microsoft Graph将你的业务应用与Office 365无缝整合。&lt;/li&gt;
&lt;li&gt;通过Office Add-in的技术扩展你熟悉的Office应用程序。&lt;/li&gt;
&lt;li&gt;通过SharePoint Add-in的技术打造基于SharePoint的业务应用。&lt;/li&gt;
&lt;li&gt;基于Microsoft Teams开发智能机器人或者业务选项卡、连接器应用。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;Microsoft Graph对于开源平台的支持&lt;/h2&gt;
&lt;p&gt;使用 Microsoft Graph API 轻松连接到可加快工作效率的数据 – 邮件、日历、联系人、文档、目录、设备以及在这些数据中发现有价值的信息 —— 不夸张地说，如果说员工和知识是企业的两大无形资产的话，那么Microsoft Graph就是一个宝藏，它不仅代表着现在，也意味着未来极大的可能。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-25-14.png&quot;&gt;&lt;img alt=&quot;graph&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-25-14.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了让Microsoft Graph能够极大地方便开发者调用，从一开始的设计理念，就是要支持所有的开发平台，不管是开源的，还是不开源的。这一点是由Microsoft Graph的工作机制来保证的 —— 它就是一套标准的REST API。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-30-53.png&quot;&gt;&lt;img alt=&quot;list Messages&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-30-53.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些API都是返回Json数据格式，而且完全基于OData的规范设计，支持标准的查询参数。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-32-13.png&quot;&gt;&lt;img alt=&quot;odata query&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-32-13.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了REST API ，微软也有针对主流的平台提供了SDK，可以加快开发的速度。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-33-22.png&quot;&gt;&lt;img alt=&quot;sdk&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-33-22.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;使用Visual Studio Code快速开发Office Add-in&lt;/h2&gt;
&lt;p&gt;我此前有过一篇&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/vscodetoofficeadd.md&quot;&gt;文章&lt;/a&gt;专门介绍这个主题，这里简单地整理几个要点。&lt;/p&gt;
&lt;p&gt;要开发Office Add-in，你现在有多个选择&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果你是Visual Studio的资深用户，你的经验可以很好地复用，Visual Studio 2017提供了开箱即用的Office Add-in模板，几次点击就可以创建一个项目，并且可以一键进行调试。&lt;/li&gt;
&lt;li&gt;与此同时，你可以使用Visual Studio Code这个开源的编辑器，结合 NodeJS、 Typescript、React、JQuery 等开源平台和框架来构建你的Office Add-in，在设计你的UI时，你还开源直接使用微软开源的Office Fabric UI呢。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我演示一个基本的步骤&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装环境（NodeJS，Visual Studio Code）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装Office Add-in项目生成器 &lt;code&gt;npm install -g yo generator-office&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建项目 &lt;code&gt;yo office&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-43-21.png&quot;&gt;&lt;img alt=&quot;create office project&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-43-21.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在Visual Studio Code中编辑和调试项目&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-45-13.png&quot;&gt;&lt;img alt=&quot;visual studio code&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-45-13.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Visual Studio Code的话题也许三天都讲不完，通过上述的介绍，大家可以看到现在开发Office Add-in是一种全新的体验，你可以使用你最熟悉的编辑器，搭配你最喜欢的框架来工作。&lt;/p&gt;
&lt;h2&gt;全新的SharePoint Framework，全新的组件式开发体验&lt;/h2&gt;
&lt;p&gt;与Office Add-in一样，我此前也已经有专门的&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/sharepointframework.md&quot;&gt;文章&lt;/a&gt;介绍和演示了SharePoint Framework的开发体验，这里也仅仅是将与开源相关的内容重点整理给大家参考。&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装环境（NodeJS，Visual Studio Code）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装模块 &lt;code&gt;npm install -g yo gulp&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装SharePoint Framework 项目模板 &lt;code&gt;npm install -g @microsoft/generator-sharepoint&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建项目 &lt;code&gt;yo @microsoft/sharepoint&lt;/code&gt; 推荐使用React&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-52-43.png&quot;&gt;&lt;img alt=&quot;sharepoint project&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-52-43.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;运行和调试项目 &lt;code&gt;gulp serve&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-53-34.png&quot;&gt;&lt;img alt=&quot;sharepoint workbench&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-22-53-34.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在Visual Studio Code中编辑项目(图略)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;部署项目 &lt;code&gt;gulp bundle&lt;/code&gt;，&lt;code&gt;gulp package-solution&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;Microsoft Teams的扩展开发体验&lt;/h2&gt;
&lt;p&gt;Microsoft Teams是Office 365中一个重要的创新，它可以将团队协作提升到一个新的层次。从另一方面，开发人员也可以在这个平台上面拥有全所未有的能力，例如&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为Teams定制智能会话机器人 (Bot)，以全新的交互方式为用户提供服务&lt;/li&gt;
&lt;li&gt;将业务应用，以选项卡（Tab）的方式集成到Teams的频道中来&lt;/li&gt;
&lt;li&gt;定制消息扩展（Message Extension）及连接器（Connector，Webhook），与外部系统进行松耦合式的对接&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;听起来有点复杂，但其实做起来真的不难，请参考下面的步骤&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装环境（NodeJS，Visual Studio Code）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装Teams项目模板 &lt;code&gt;npm install yo generator-teams -g&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建Teams项目 &lt;code&gt;yo teams&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-23-07-28.png&quot;&gt;&lt;img alt=&quot;yo teams&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-23-07-28.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在Visual Studio Code中编辑项目&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-23-10-27.png&quot;&gt;&lt;img alt=&quot;vscode teams&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/36399c337f3d0c580e06559c724bf1b9ee48b15e/docs/images/2018-04-17-23-10-27.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;你可以通过上面的步骤快速创建一个Microsoft Teams应用，但是要做出来一个真正可用的App，你毫无疑问还需要更多的时间，请参考官方的文档 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/microsoftteams/platform/&quot;&gt;https://docs.microsoft.com/zh-cn/microsoftteams/platform/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文带领大家回顾了一下开源及社区的发展、微软在开源方面的努力，以及具体在Office 365开发的四个领域如何张开双手拥抱开源。一千个人的心目中有一千个哈姆雷特，但开源的精神应该只有一个，它不仅仅是开放源代码，它是一种开放的心态；同时开源需要更多的人参与、去贡献，只有这样，我们的“源”头活水才会生机勃发，越来越&quot;开&quot;阔。笔者今年的小目标是除了维护之前的一个小的开源项目外，争取参与到微软官方的几个大的Office 365开源项目中去做一点贡献，也希望看到更多的开发人员参与进来。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 15:29:00 +0000</pubDate>
<dc:creator>陈希章</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxizhang/p/8870829.html</dc:identifier>
</item>
<item>
<title>ASP.NET MVC应用迁移到ASP.NET Core及其异同简介 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/8870286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/8870286.html</guid>
<description>&lt;p&gt;　　ASP.NET Core是微软新推出支持跨平台、高性能、开源的开发框架，相比起原有的ASP.NET来说，ASP.NET Core更适合开发现代应用程序，如跨平台、Dorker的支持、集成现代前端开发框架(如npm、bower、gulp等等)。另外相比ASP.NET它的性能更好，还内置了依赖注入等功能对开发方式进行了优化。但它们之间也有很多相同或相似的地方，如都使用C#进行开发、都提供了MVC、Entity Framework、Identity等组件来快速构建应用程序。&lt;/p&gt;
&lt;p&gt;　　本文将通过迁移一个简单的ASP.NET应用为例，来介绍ASP.NET与ASP.NET Core之间的异同，其主要内容有：&lt;br/&gt;　　● &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#netcore&quot;&gt;.Net Core &amp;amp; ASP.NET Core &amp;amp; .Net Standard&lt;/a&gt;&lt;br/&gt;　　● &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#aspnetmigration&quot;&gt;ASP.NET应用迁移分析&lt;/a&gt;&lt;br/&gt;　　● &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#libmigraiton&quot;&gt;类库项目迁移&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#createlib&quot;&gt;通过创建新项目完成类库迁移&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#efmigration&quot;&gt;迁移EntityFramework&lt;/a&gt;&lt;br/&gt;　　● &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#mvcmigration&quot;&gt;迁移ASP.NET MVC&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#createmvc&quot;&gt;创建一个新的ASP.NET Core MVC项目&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#route&quot;&gt;路由迁移&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#filter&quot;&gt;过滤器迁移&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#DI&quot;&gt;依赖注入迁移&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#view&quot;&gt;Web静态资源及View迁移&lt;/a&gt;&lt;br/&gt;　　● &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html#summary&quot;&gt;小结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　注：本文使用的VS2017为15.6.4版本，.Net Core SDK版本为2.1.103。&lt;/p&gt;
&lt;h2&gt;.Net Core &amp;amp; ASP.NET Core &amp;amp; .Net Standard&lt;/h2&gt;
&lt;p&gt;　　在介绍如何迁移ASP.NET应用之前，先了解一下新框架.Net Core和ASP.NET Core，.Net Core是一个全新开发平台，新的运行时、SDK、类库、工具(编译工具、项目模板生成工具等等)，而ASP.NET Core则是基于.Net Core的一个Web应用开发框架，它们的关系实际上与.Net Framework和ASP.NET是一样的。&lt;br/&gt;　　但是在使用.Net开发的时候出现了一个新的名词.Net Standard，&lt;span&gt;.Net Standard是一个&lt;/span&gt;可用于所有.Net程序的&lt;span&gt;API标准&lt;/span&gt;，换句话说就是如果使用.Net开发的API(类库)符合.Net Standard，那么该类库将可以用于所有的.Net应用。如下表所示，如果开发的类库是以.Net Standard2.0标准开发的，那么该类库将可应用到.Net Core2.0、.Net Framework4.6.1(需要.NET Core2.0的SDK支持)、Mono5.4、Xamarin、UWP等平台的应用上。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417173824969-217002675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更多关于.Net Standard的内容可参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/net-standard&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/dotnet/standard/net-standard&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ASP.NET应用迁移分析&lt;/h2&gt;
&lt;p&gt;　　.Net Core虽然是一个全新的开发平台（新运行时、新SDK、新类库、新工具），但是它毕竟是以.Net Framework为基础，所以对于部分API来说它仍然是参照且兼容.Net Framework的，所以在迁移.Net Core应用时可以先对代码进行分析。&lt;br/&gt;　　1、使用工具分析代码：&lt;br/&gt;　　有一个名为.Net Portability Analyzer的工具专门用于分析代码和引用程序集在.Net不同平台上的支持情况，该工具可以在VS的拓展管理中搜索并安装，或者到页面上下载VS插件双击安装(&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer&quot; target=&quot;_blank&quot;&gt;https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer&lt;/a&gt;)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417202907619-1960750506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　安装完成后在VS的解决方案窗口中右键解决方案或者项目就可以看到下图两个菜单项，分别用于分析程序集的可移植性和对移植分析器的配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417203022574-34443007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　移植分析器的配置主要是对目标平台和报表输出类型进行配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417203213569-107581844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下图是对My Blog应用进行可移植性分析的Excel报表(部分)：&lt;br/&gt;　　可移植性总结：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417203403444-1351517118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　问题细节：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417203437342-782877546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　缺失的程序集：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417203510919-2081746361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：没找到更多关于缺少程序集的解释，不确定是无法解析还是无兼容性，本文暂时将这些程序集理解为仅支持.Net Framework平台。&lt;/span&gt;&lt;br/&gt;　　从分析报告中可以看出，除了MVC项目，其它类库项目与.Net Core或者.Net standard标准的兼容程度均为100%。&lt;br/&gt;　　2、根据实际情况对项目引用进行分析：&lt;br/&gt;　　工具对代码的分析仅可参考，毕竟使用.Net Framework开发的应用可能引用了很多第三方类库，这些类库可能不支持其它平台，有些类库可能支持，但是对于原有版本有了很多Break Changes，使用方法与原先不一致了，所以在进行代码迁移之前对项目引用进行分析，从技术上分析代码迁移是否可行。&lt;br/&gt;　　本例中仓储的实现依赖了Entity Framework、EF MySQL、Autofac、Identity等组件，这些组件在.Net Core下也是有相应实现，虽然API会有改动，但技术上是没有问题的可以迁移。接下来就开始介绍如何完成迁移。&lt;/p&gt;
&lt;h2&gt;类库项目迁移&lt;/h2&gt;
&lt;p&gt;　　现在.Net Core项目与.Net Framework项目一样都是使用MSBuild格式的csproj文件来管理项目的相关属性，如名称、版本号、包依赖、项目依赖等等，所以实际上项目的迁移最大的改动就是将csproj的内容改为.Net Core的即可(.Net Core的csproj文件详情参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/tools/csproj&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/dotnet/core/tools/csproj&lt;/a&gt;)，改动csproj文件有两种方法，如果熟悉文件格式，那么直接改动原有文件即可，如果不熟悉那么可以通过重新创建项目的方式，让VS来完成创建/修改工作。&lt;/p&gt;
&lt;h3&gt;通过创建新项目完成类库迁移&lt;/h3&gt;
&lt;p&gt;　　本文将通过重新创建项目的方式来完成项目迁移，以保证csproj配置文件的正确性。&lt;br/&gt;　　首先通过VS创建一个.Net Standard的类库项目：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417203952652-54220148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后把相应的代码复制到新建项目的目录下，删除不存在的命名空间即可。&lt;br/&gt;　　&lt;span&gt;注：.Net Core会自动识别项目目录下的代码文件，而原来的.Net Fx项目需要在csporj文件中引入，所以这里直接复制代码文件即可识别到项目中。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;迁移EntityFramework&lt;/h3&gt;
&lt;p&gt;　　本例程序中用于实现仓储的类库依赖了EF，而实现MySQL EF的类库还依赖了My SQL的EF相关组件。&lt;br/&gt;另外随着.Net Core的推出，EF也推出了EFCore，另外新版本的.Net大量引入了Options模式来对程序进行配置，关于Options模式可参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-2.1&lt;/a&gt;&lt;br/&gt;　　中文文档：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?tabs=basicconfiguration&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?tabs=basicconfiguration&lt;/a&gt;&lt;br/&gt;　　所以在迁移EF的时候，除了创建新的项目，还需要安装新的Nuget包并且修改相应的配置代码：&lt;br/&gt;　　1. 安装EFCore组件：&lt;br/&gt;　　安装Microsoft.EntityFrameworkCore：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417204401505-1887388429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.处理EFCore的配置：&lt;br/&gt;　　EFCore配置文档：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/ef/core/miscellaneous/configuring-dbcontext&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/ef/core/miscellaneous/configuring-dbcontext&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417212939552-582224207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：EFCore针对不同数据库的配置信息通过DbContextOptions对象完成，所以构造方法不再是一个简单的连接字符串，另外EFCore提供了针对ASP.NET Core容器的依赖注入方法，为了利用依赖注入可以把DbContext配置交由ASP.NET Core项目完成，包括对不同数据源的支持。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过上面的方法即可把例子中的类库项目完成迁移，接下来进行MVC项目的迁移工作。&lt;/p&gt;
&lt;h2&gt;迁移ASP.NET MVC&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;ASP.NET Core是一项变革&lt;/span&gt;，除了跨平台之外，它还改变了原先ASP.NET的思想和开发方式，如MVC及API的Controller合二为一、拥抱现代前端开发方式方法、Dorcker支持等，接下来将通过介绍其迁移过程来了解ASP.NET与ASP.NET Core的异同。&lt;/p&gt;
&lt;h3&gt;创建一个新的ASP.NET Core MVC项目&lt;/h3&gt;
&lt;p&gt;　　相对与类库来说MVC项目的迁移要复杂的多，因为新的ASP.NET在项目文件结构、程序启动、开发方式等方面都有了区别，这里仍然使用创建新项目的方式完成ASP.NET MVC应用的迁移：&lt;br/&gt;　　创建一个ASP.NET Core MVC应用：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417214421409-1442006622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面是新项目的目录结构：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417214453065-1403118344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ASP.NET Core MVC与原先ASP.NET MVC类似核心仍然是Controllers、Models、Views三个目录，另外通过wwwroot目录对HTML资源进行了整合、配置文件变更为Json格式、删除了Global.asax取而代之的是Program.cs和Startup.cs文件。&lt;br/&gt;　　ASP.NET开发的Web应用程序需要IIS作为宿主才可以运行，而ASP.NET Core作为一种可跨平台的Web应用开发框架其应用必定是与IIS完全解耦的，所以它的启动方式也完全不一样。&lt;br/&gt;　　ASP.NET Core中引入了Program类型，如Console应用一样通过Main方法来运行程序，而ASP.NET Core的Main方法主要内容是指明一个Startup类型完成Web服务器的创建。而&lt;span&gt;Startup类型则负责了整个应用的配置和HTTP请求管道搭建的任务&lt;/span&gt;，所以首先要完成的工作就是将原先Global及Owin Startup文件中的内容移植到Startup文件中，下面就开始详细介绍ASP.NET Core MVC的变化及迁移方法。&lt;br/&gt;　　MVC除了包含Controller、Model、View等文件外，还需要进行路由、过滤器等功能配置，所以首先需要将原项目的相关文件(controller、model、view等注：因为原项目和ASP.NET Core的MVC都依赖Identity实现用户管理功能，所以涉及到用户管理的部分不需要复制)复制到新项目中，修改命名空间引用如：System.Web.Mvc-&amp;gt;Microsoft.AspNetCore.Mvc并修复其它命名空间引用错误。&lt;br/&gt;　　接下来完成其它几个重要方面的迁移。&lt;/p&gt;
&lt;h3&gt;路由迁移&lt;/h3&gt;
&lt;p&gt;　　将原有的路由配置包含Area的路由配置转移至Startup类型的Configure方法中：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417214645978-159383374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：本例存在Controller名称重名情况，但ASP.NET Core MVC没有提供如ASP.NET中通过命名空间区别的方式区别Controller重名，本例通过修改名称解决问题，如需命名空间区分Controller可参考：&lt;a href=&quot;https://stackoverflow.com/questions/34306891/restrict-route-to-controller-namespace-in-asp-net-core&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://stackoverflow.com/questions/34306891/restrict-route-to-controller-namespace-in-asp-net-core&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;过滤器迁移&lt;/h3&gt;
&lt;p&gt;　　全局过滤器的配置则是由原来的通过FilterConfig对象注册改为Startup的ConfigureServices方法中对MVC进行配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417220354316-103162041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417220405286-1006176534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;依赖注入迁移&lt;/h3&gt;
&lt;p&gt;　　ASP.NET Core内置了依赖注入功能，甚至一些组件都提供了专门的拓展方法将其服务添加到容器中，如EFCore、Identity、MVC。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417220811176-468850591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图为ASP.NET Core默认的为将DbContext、Identity以及MVC相关服务添加到容器的代码，除此之外为了顺应依赖注入思想，这里将原有代码的仓储和服务类型均注册到容器中，其依赖通过构造方法进行注入。&lt;br/&gt;　　仓储代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417220854403-68621683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　业务代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417220916508-403477620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　控制器代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417220933407-1116279328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　服务注册代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417221107439-278099859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　注：本例中实现依赖的是实现而非抽象，这不符合依赖倒置原则，所以此处仅作为ASP.NET Core依赖注入使用示例。另外为了让EFCore支持MySQL，所以需要在项目中添加Pomelo.EntityFrameworkCore.MySql组件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417221605135-1814410213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Web静态资源及View迁移&lt;/h3&gt;
&lt;p&gt;　　ASP.NET的页面是基于HTML实现的，一个ASP.NET的页面除了HTML代码外还会引用一些外部静态资源，如css、js、image、font等内容，而ASP.NET中专门提供了Bundle技术来管理这些资源（可参考：《&lt;a id=&quot;link_post_title&quot; class=&quot;link-post-title&quot; href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html&quot;&gt;ASP.NET没有魔法——ASP.NET MVC界面美化及使用Bundle完成静态资源管理&lt;/a&gt;》），那么ASP.NET Core是如何管理这些资源的呢？&lt;br/&gt;　　首先要处理ASP.NET Core中静态文件的访问问题，在ASP.NET中由于它依赖IIS，而静态文件访问已经被IIS处理了，所以程序中无需关心，但ASP.NET Core不一样，需要在其请求管道中添加相应的处理中间件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417221638610-762310294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：ASP.NET Core项目模板默认添加该中间件。&lt;br/&gt;　　对于静态资源的管理ASP.NET Core通过bundleconfig.json配置文件进行配置取代了原先的BundleConfig类型。把原先的资源文件复制到ASP.NET Core的wwwroot目录下，然后在bundleconfig.json文件下进行配置，如下图(部分)：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417222050544-1688776103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　完成配置后还需要在项目中添加一个BuildBundlerMinifier的组件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417222135846-426233942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　引入BuildBundlerMinifier后&lt;span&gt;编译项目&lt;/span&gt;就会触发资源绑定和最小化操作：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417222302626-926613660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：和ASP.NET不同，Core里面的静态资源管理是在编译过程中处理的，并且通过一个json配置文件完成处理定义，除了BuildBundlerMinifier外还可以使用Gulp等工具完成资源的优化，关于Gulp的使用可参考：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/client-side/bundling-and-minification?view=aspnetcore-2.0&amp;amp;tabs=visual-studio%2Caspnetcore2x#consume-bundleconfigjson-from-gulp&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://docs.microsoft.com/en-us/aspnet/core/client-side/bundling-and-minification?view=aspnetcore-2.0&amp;amp;tabs=visual-studio%2Caspnetcore2x#consume-bundleconfigjson-from-gulp&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　完成静态资源迁移后因为Bundle机制的改变还需要对View中资源引用进行修改(ASP.NET Core中不再提供@Scripts和@Styles类型来渲染样式和脚本引用)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417222336477-450178200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417222354659-1058981024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201804/640251-20180417222420359-851282606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　.Net Core是一个新的开发框架，2.0版本的.Net Core已经相对完善，本文介绍了一个简单的ASP.NET MVC迁移至.Net Core的例子，从例子中可以看出新的开发平台已经实现了原有的所有功能和解决方案，甚至在原有基础上进行了改进。另外.Net Core作为新框架它是开源的并且相对于.Net Framework来说它的文档更全面(中文文档相对落后)，所以.Net Core更容易学习和使用。&lt;/p&gt;
&lt;p&gt;　　对于迁移来说，首先还是看需求和目的，为什么要进行迁移？为了容器化？跨平台部署？在真实项目中迁移一个项目是非常复杂且具有风险的，所以如果要进行迁移需要慎重考虑，考虑迁移是否是最好的解决方案。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://crbtech.in/Dot-Net-Training/9-things-know-converting-asp-dot-net-to-dot-net-core/&quot; target=&quot;_blank&quot;&gt;http://crbtech.in/Dot-Net-Training/9-things-know-converting-asp-dot-net-to-dot-net-core/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/tools/project-json-to-csproj&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/dotnet/core/tools/project-json-to-csproj&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-2.1&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/client-side/bundling-and-minification?view=aspnetcore-2.1&amp;amp;tabs=visual-studio%2Caspnetcore2x&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/client-side/bundling-and-minification?view=aspnetcore-2.1&amp;amp;tabs=visual-studio%2Caspnetcore2x&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://stackoverflow.com/questions/34306891/restrict-route-to-controller-namespace-in-asp-net-core&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/34306891/restrict-route-to-controller-namespace-in-asp-net-core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/migration/proper-to-2x/?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/migration/proper-to-2x/?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ASP.NET MVC应用迁移到ASP.NET Core及其异同&quot; href=&quot;http://www.cnblogs.com/selimsong/p/8870286.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/selimsong/p/8870286.html&lt;/a&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 15:20:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/8870286.html</dc:identifier>
</item>
<item>
<title>web攻击和防御措施 - Cheney.rain</title>
<link>http://www.cnblogs.com/chenhaoyu/p/8870782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhaoyu/p/8870782.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1、SQL注入：参照下面的链接&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
http://www.cnblogs.com/chenhaoyu/p/8758888.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、跨网站脚本攻击(Cross Site Scripting, XSS)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　攻击者将恶意代码注入到网页上，其他用户在加载网页时就会执行代码，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。这些恶意代码通常是JavaScript、HTML以及其他客户端脚本语言。&lt;/p&gt;
&lt;p&gt;如果传入一段脚本&amp;lt;script&amp;gt;[code]&amp;lt;/script&amp;gt;，那么脚本也会执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
防范方法：&lt;br/&gt;　　　　1、使用htmlspecialchars函数将特殊字符转换成HTML编码，过滤输出的变量&lt;br/&gt;　　　　2、如果想更彻底的过滤，使用HTMLPurifire插件过滤，专门用来防止xss攻击的插件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、跨网站请求伪造攻击(Cross Site Request Forgeries, CSRF)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　攻击者伪造目标用户的HTTP请求，然后此请求发送到有CSRF漏洞的网站，网站执行此请求后，引发跨站请求伪造攻击。攻击者利用隐蔽的HTTP连接，让目标用户在不注意的情况下单击这个链接，由于是用户自己点击的，而他又是合法用户拥有合法权限，所以目标用户能够在网站内执行特定的HTTP链接，从而达到攻击者的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;与xss的不同点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
它与XSS的攻击方法不同，XSS利用漏洞影响站点内的用户，攻击目标是同一站点内的用户者，而CSRF 通过伪装成受害用户发送恶意请求来影响Web系统中受害用户的利益。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单说下原理：首先有一个站点A，用户访问了其中一个页面，URL为/sdad/asd?uid=1&amp;amp;username=ww，又访问了一个站点B的其中一个页面，而这个页面中有一个img标签，如&lt;/p&gt;
&lt;pre&gt;
&amp;lt;img src=&quot;/sdad/asd?uid=1&amp;amp;username=bbbb&quot;&amp;gt;，如果A站点的那个页面是修改用户名操作，那么当用户访问站点B的这个页面时，就触发了CSRF攻击，就把用户名ww改为了bbbb，从而实现了CSRF攻击&lt;br/&gt;&lt;strong&gt;&lt;span&gt;防御措施一：判断请求头的来源&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
// 检查上一页面是否为当前站点下的页面
 3 if (!empty($_SERVER['HTTP_REFERER'])) {
 4     if (parse_url($_SERVER['HTTP_REFERER'], PHP_URL_HOST) != 'html5.yang.com') {
 5         // 可以设置http错误码或者指向一个无害的url地址
 6         //header('HTTP/1.1 404 not found');
 7         //header('HTTP/1.1 403 forbiden');
 8         header('Location: http://html5.yang.com/favicon.ico');
 9         // 这里需要注意一定要exit(), 否则脚本会接着执行
10         exit();
11     }
12  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;防御措施二：在页面生成一个随即串并保存在token中，用于在服务器中比对，参照laravel中的CSRF防御机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、&lt;/span&gt;Session劫持攻击(Session Hijacking)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;攻击者利用各种手段来获取目标用户的session id。一旦获取到session id，那么攻击者可以利用目标用户的身份来登录网站，获取目标用户的操作权限。&lt;/p&gt;
&lt;p&gt;防御方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
1、 更改Session名称。PHP中Session的默认名称是PHPSESSID，此变量会保存在Cookie中，如果攻击者不分析站点，就不能猜到Session名称，阻挡部分攻击。

2、 关闭透明化Session ID。透明化Session ID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，Session ID则使用URL来传递。

3、 设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。

4、 关闭所有phpinfo类dump request信息的页面。

5、验证HTTP头部信息

6、每当用户登陆的时候就进行重置sessionID

7、sessionID闲置过久时，进行重置sessionID
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、&lt;strong&gt;文件上传漏洞攻击(File Upload Attack)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;攻击者利用程序缺陷绕过系统对文件的验证与处理策略将恶意代码上传到服务器并获得执行服务器端命令的能力。&lt;br/&gt;常用的攻击手段有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
上传Web脚本代码，Web容器解释执行上传的恶意脚本；
上传Flash跨域策略文件crossdomain.xml，修改访问权限(其他策略文件利用方式类似)；
上传病毒、木马文件，诱骗用户和管理员下载执行；
上传包含脚本的图片，某些浏览器的低级版本会执行该脚本，用于钓鱼和欺诈。
总的来说，利用的上传文件要么具备可执行能力(恶意代码)，要么具备影响服务器行为的能力(配置文件)。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　防范措施：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
1.文件上传的目录设置为不可执行；
2.判断文件类型，设置白名单。对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码；
3.使用随机数改写文件名和文件路径：一个是上传后无法访问；再来就是像shell、.php 、.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击；
4.单独设置文件服务器的域名：由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 17 Apr 2018 15:16:00 +0000</pubDate>
<dc:creator>Cheney.rain</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenhaoyu/p/8870782.html</dc:identifier>
</item>
<item>
<title>MySQL/MariaDB触发器 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8870446.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8870446.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8870446.html#blog1&quot;&gt;&lt;span&gt;1.创建触发器&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8870446.html#blog2&quot;&gt;&lt;span&gt;2.insert触发器&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8870446.html#blog3&quot;&gt;&lt;span&gt;3.delete触发器&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8870446.html#blog4&quot;&gt;&lt;span&gt;4.update触发器&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8870446.html#blog5&quot;&gt;&lt;span&gt;5.通过on duplicate key update分析触发器触发原理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8870446.html#blog6&quot;&gt;&lt;span&gt;6.replace to算法验证&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8870446.html#blog7&quot;&gt;&lt;span&gt;7.查看、删除触发器&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;触发器用来实现在永久表上进行某些操作时触发启动另一操作。&lt;/p&gt;


&lt;p&gt;以下是MariaDB中create trigger的语法：mysql不支持or replace和if not exists子句。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; [&lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt;] &lt;span class=&quot;hljs-keyword&quot;&gt;TRIGGER&lt;/span&gt; [&lt;span class=&quot;hljs-keyword&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EXISTS&lt;/span&gt;] trigger_name
    { &lt;span class=&quot;hljs-keyword&quot;&gt;BEFORE&lt;/span&gt; | &lt;span class=&quot;hljs-keyword&quot;&gt;AFTER&lt;/span&gt; } { &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; | &lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; | &lt;span class=&quot;hljs-keyword&quot;&gt;DELETE&lt;/span&gt; }
    &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; tbl_name &lt;span class=&quot;hljs-keyword&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EACH&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ROW&lt;/span&gt;
    trigger_body&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;触发器只能建立在永久表上，不能建立在视图和临时表上。MySQL/MariaDB中的触发器只支持行级触发器(即每行都触发一次触发器)，不支持数据库级别和服务器级别的触发器。&lt;span&gt;&lt;strong&gt;MySQL/MariaDB中的触发器虽然都是基于表的，却存储在数据库下&lt;/strong&gt;&lt;/span&gt;，理解这一点很重要，以后查看、删除、引用trigger的时候都是通过数据库名称来引用的，而不是使用表来引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;before和after是触发时间，insert/update/delete是触发事件&lt;/span&gt;。&lt;/strong&gt;例如&lt;code&gt;before insert&lt;/code&gt;表示插入记录之前触发程序。其中before触发器类似于SQL Server中的instead of触发器，作用在检查约束之前。而after触发器和SQL Server中一样，在检查约束之后才生效。&lt;/p&gt;
&lt;p&gt;下图为SQL Server中instead of和after触发器的工作位置。在MySQL/MariaDB中是一样的，只要把MySQL/MariaDB中的概念和SQL Server中的概念对应起来即可。&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8870446.html#blog5&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;后文&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中有对该图的分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201804/733013-20180417163230158-1381206159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在MySQL中，一张表只能有一个同时间、同事件的触发器，所以MySQL中不支持基于列的触发器。例如，一张表中可以存在&lt;code&gt;before insert&lt;/code&gt;触发器和&lt;code&gt;before update&lt;/code&gt;，所以每张表最多只能有6个触发器。但是MariaDB 10.2.3中可以为同时间、同事件创建多个触发器。&lt;/p&gt;
&lt;p&gt;在MySQL/MariaDB中，使用&lt;span&gt;&lt;strong&gt;old和new表&lt;/strong&gt;&lt;/span&gt;分别表示触发器激活后的新旧表，在SQL Server中使用的是inserted和deleted表，其实它们的意义是等价的。但是坑爹的是MySQL/MariaDB中只能引用这两张表中的列，而无法直接引用这两张表。例如可以引用&lt;code&gt;old.col_name&lt;/code&gt;，但是不能直接&lt;code&gt;select * from old&lt;/code&gt;这样引用old表。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;old表表示删除目标记录之后将删除的记录保存在old表中，即deleted表。new表表示向表中插入新记录之前，新记录保存在new表中，即inserted表。&lt;/strong&gt;&lt;/span&gt;或者说，只要涉及了insert相关的操作就有new表，只要涉及了delete相关的操作就有old表，而update操作基本可以认为是先delete再insert的行为，所以也会触发这两张表。&lt;/p&gt;
&lt;p&gt;注意，即使是after触发器，也是先将数据填充到old、new表中，再执行DML语句，最后激活触发器执行触发器中的语句。&lt;/p&gt;
&lt;p&gt;在下面的小节中会分别验证不同事件不同时间的触发器行为。在验证它们之前，先创建示例数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;DATABASE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EXISTS&lt;/span&gt; test ;&lt;/span&gt;

&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;USE&lt;/span&gt; test ;&lt;/span&gt;

&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; emp (
    emp_no &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,
    mgr_no &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,
    emp_name &lt;span class=&quot;hljs-built_in&quot;&gt;VARCHAR&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,
    &lt;span class=&quot;hljs-keyword&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;KEY&lt;/span&gt; (emp_no)
) 
&lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; emp (emp_no, mgr_no, emp_name) &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;
    (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'David'&lt;/span&gt;),
    (&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'Mariah'&lt;/span&gt;),
    (&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'Tommy'&lt;/span&gt;),
    (&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'Jim'&lt;/span&gt;),
    (&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'Selina'&lt;/span&gt;),
    (&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'John'&lt;/span&gt;),
    (&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'Monty'&lt;/span&gt;);&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看该表数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201804/733013-20180417163537278-1320506696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再创建一个极其简单的审核表audit，该表前两列为自增列和注释列，后面的列结构等同于emp表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EXISTS&lt;/span&gt;  audit;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; emp &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;ADD&lt;/span&gt; id &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt; AUTO_INCREMENT &lt;span class=&quot;hljs-keyword&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FIRST&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;ADD&lt;/span&gt; note &lt;span class=&quot;hljs-built_in&quot;&gt;CHAR&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;AFTER&lt;/span&gt; id;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;insert触发器的作用是：当向表中插入数据的时候，将会激活触发器。有两类：before和after触发器，分别表示数据插入到表中之前和数据插入到表中之后激活触发器。&lt;/p&gt;
&lt;p&gt;注意，只要向表中插入了新行，就会激活insert触发器。插入新行的动作不仅仅只有insert语句，还有其他插入操作，例如load data语句、replace语句等等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 创建before &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt;触发器
DELIMITER $$
&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TRIGGER&lt;/span&gt; test.trig_demo1 
    &lt;span class=&quot;hljs-keyword&quot;&gt;BEFORE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; test.emp &lt;span class=&quot;hljs-keyword&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EACH&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ROW&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'before insert'&lt;/span&gt;,new.emp_no,new.mgr_no,new.emp_name);&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt;$$
DELIMITER ;&lt;/span&gt;

# 创建after &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt;触发器
DELIMITER $$
&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TRIGGER&lt;/span&gt; test.trig_demo2
    &lt;span class=&quot;hljs-keyword&quot;&gt;AFTER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; test.emp &lt;span class=&quot;hljs-keyword&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EACH&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ROW&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'after insert'&lt;/span&gt;,new.emp_no,new.mgr_no,new.emp_name);&lt;/span&gt; 
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt;$$
DELIMITER ;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;before insert&lt;/code&gt;触发器的作用是：当向表emp中insert数据时，将首先激活该触发器，该触发器首先会将待插入数据填充到new表中，再向审核表audit中插入一行数据，并标明此次触发操作是&quot;before insert&quot;。触发器执行结束后，才开始向emp表中插入数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;after insert&lt;/code&gt;触发器的作用是：当向表emp中insert数据时，将先将数据填充到new表中，再插入到emp表，之后激活该触发器，该触发器会向审核表audit中插入一行数据，并标明此次触发操作是&quot;after insert&quot;。&lt;/p&gt;
&lt;p&gt;现在向emp表中插入数据进行测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; emp &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'longshuai'&lt;/span&gt;);&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入之后，查看audit表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [test]&amp;gt; select * from audit;
&lt;span class=&quot;hljs-addition&quot;&gt;+----+---------------+--------+--------+-----------+&lt;/span&gt;
| id | note          | emp_no | mgr_no | emp_name  |
&lt;span class=&quot;hljs-addition&quot;&gt;+----+---------------+--------+--------+-----------+&lt;/span&gt;
|  1 | before insert |     10 |      3 | longshuai |
|  2 | after insert  |     10 |      3 | longshuai |
&lt;span class=&quot;hljs-addition&quot;&gt;+----+---------------+--------+--------+-----------+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，一次insert操作触发了before insert和after insert两个触发器。且无论是before还是after insert触发器都有new表的存在。&lt;/p&gt;
&lt;p&gt;在mariadb 10.2.3版本之后，一个表中可以为同一时间、同一事件创建多个触发器(在mysql中不允许)。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 创建第二个after &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt;触发器
DELIMITER $$
&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TRIGGER&lt;/span&gt; test.trig_demo3
    &lt;span class=&quot;hljs-keyword&quot;&gt;AFTER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; test.emp &lt;span class=&quot;hljs-keyword&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EACH&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ROW&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'after insert2'&lt;/span&gt;,new.emp_no,new.mgr_no,new.emp_name);&lt;/span&gt; 
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt;$$
DELIMITER ;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;triggers&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201804/733013-20180417173708710-1623343402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此处删除新建的这个trigger，注意删除trigger的时候是通过数据库名称来也引用trigger的，而不是table名称。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;trigger&lt;/span&gt; test.trig_demo3;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;delete触发器的作用是：当删除表中数据记录的时候，将会激活触发器。&lt;/p&gt;
&lt;p&gt;有两类insert触发器：before和after触发器，分别表示表中记录被删除之前和表中数据被删除之后激活触发器。&lt;/p&gt;
&lt;p&gt;注意，delete触发器只在表中记录被删除的时候才会被激活。例如delete语句、replace语句。但是drop语句、truncate语句不会激活delete触发器，因为它们是DDL语句，而MySQL/MariaDB不支持DDL触发器，它们并没有对表中的记录执行delete操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 创建before &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;触发器
DELIMITER $$
&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TRIGGER&lt;/span&gt; test.trig_demo3 
    &lt;span class=&quot;hljs-keyword&quot;&gt;BEFORE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; test.emp &lt;span class=&quot;hljs-keyword&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EACH&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ROW&lt;/span&gt; 
    &lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'before delete'&lt;/span&gt;,old.emp_no,old.mgr_no,old.emp_name);&lt;/span&gt; 
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt;$$
DELIMITER ;&lt;/span&gt;

# 创建after &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt;触发器
DELIMITER $$
&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TRIGGER&lt;/span&gt; test.trig_demo4
    &lt;span class=&quot;hljs-keyword&quot;&gt;AFTER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; test.emp &lt;span class=&quot;hljs-keyword&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EACH&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ROW&lt;/span&gt; 
    &lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'after delete'&lt;/span&gt;,old.emp_no,old.mgr_no,old.emp_name);&lt;/span&gt; 
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt;$$
DELIMITER ;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个delete事件的触发器作用很简单，先将待删除的记录插入到old表中，再在删除表中的记录之前、之后，向审核表audit中插入一行'before delete'或'after delete'的审核日志。&lt;/p&gt;
&lt;p&gt;现在删除emp表中的一行记录进行测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; emp &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; emp_no=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除emp表中数据之后，查看audit表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [test]&amp;gt; SELECT * FROM audit;
+----+---------------+--------+--------+-----------+
| &lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; | note          | emp_no | mgr_no | emp_name  |
+----+---------------+--------+--------+-----------+
|  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | before insert |     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | longshuai |
|  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; | after insert  |     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | longshuai |
|  &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | before delete |      &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; |   &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt; | &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;      |
|  &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; | after delete  |      &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; |   &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt; | &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;      |
+----+---------------+--------+--------+-----------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，一次delete操作触发了before delete和after delete触发器。且删除记录前后old表都存在。&lt;/p&gt;


&lt;p&gt;update触发器的作用是：当表中数据记录被修改的时候，将会激活触发器。&lt;/p&gt;
&lt;p&gt;有两类update触发器：before和after触发器，分别表示表中记录被修改之前和表中数据被修改之后激活触发器。&lt;/p&gt;
&lt;p&gt;注意，update操作可以认为是先delete再insert，因此它将填充old表和new表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 创建before &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt;触发器
DELIMITER $$
&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TRIGGER&lt;/span&gt; test.trig_demo5
    &lt;span class=&quot;hljs-keyword&quot;&gt;BEFORE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; test.emp &lt;span class=&quot;hljs-keyword&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EACH&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ROW&lt;/span&gt; 
    &lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'before update from new'&lt;/span&gt;,new.emp_no,new.mgr_no,new.emp_name);&lt;/span&gt;
        &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'before update from old'&lt;/span&gt;,old.emp_no,old.mgr_no,old.emp_name);&lt;/span&gt;
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt;$$
DELIMITER ;&lt;/span&gt; 

# 创建after &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt;触发器
DELIMITER $$   
&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TRIGGER&lt;/span&gt; test.trig_demo6
    &lt;span class=&quot;hljs-keyword&quot;&gt;AFTER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; test.emp &lt;span class=&quot;hljs-keyword&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EACH&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ROW&lt;/span&gt; 
    &lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'after update from new'&lt;/span&gt;,new.emp_no,new.mgr_no,new.emp_name);&lt;/span&gt;
        &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; audit &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'after update from old'&lt;/span&gt;,old.emp_no,old.mgr_no,old.emp_name);&lt;/span&gt; 
    &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt;$$
DELIMITER ;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;before update&lt;/code&gt;触发器的作用是：当更新emp表中的一条记录时，首先将表中该行记录插入到old表中，待更新结果插入到new表中，然后激活触发器，向审核表中写入数据，最后修改emp表中的记录。&lt;br/&gt;&lt;code&gt;after update&lt;/code&gt;触发器的作用是：当更新emp表中的一条记录时，首先将表中该行记录插入到old表中，待更新结果插入到new表中，然后修改emp表中的记录，最后激活触发器，向审核表中写入数据。&lt;/p&gt;
&lt;p&gt;更新emp表中一行记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt; emp &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; emp_no=&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; emp_no=&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看audit表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [test]&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; audit;
+----+------------------------+--------+--------+-----------+
| id | note                   | emp_no | mgr_no | emp_name  |
+----+------------------------+--------+--------+-----------+
|  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | before insert          |     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | longshuai |
|  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; | after insert           |     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | longshuai |
|  &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | before delete          |      &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; |   NULL | NULL      |
|  &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; | after delete           |      &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; |   NULL | NULL      |
|  &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; | before update &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | Monty     |
|  &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt; | before update &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; old |      &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | Monty     |
|  &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; | after update &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;  |      &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | Monty     |
|  &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; | after update &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; old  |      &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | Monty     |
+----+------------------------+--------+--------+-----------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，一次update操作触发了before update触发器和after update触发器，并且update操作时，new和old两张表中都有新旧数据。上面的结果中from new对应的是更新后的数据，来源于更新前填充的new表，from old对应的是更新前的旧数据，来源于更新前填充的old表。&lt;/p&gt;


&lt;p&gt;在MySQL/MariaDB中，如果向表中插入的数据有重复冲突检测时会阻止插入。解决这个问题的其中一个方法就是使用&lt;code&gt;on duplicate key update&lt;/code&gt;子句。这个子句应用在insert字句中，但其中涉及到了update操作，那到底会触发哪些触发器呢？&lt;/p&gt;
&lt;p&gt;这里先清空上面的audit表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;TRUNCATE&lt;/span&gt; audit;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先测试下使用&lt;code&gt;on duplicate key update&lt;/code&gt;子句插入无重复的记录。注意，emp表的emp_no列具有主键属性，它不允许出现重复值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; emp &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang'&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; DUPLICATE &lt;span class=&quot;hljs-keyword&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; emp_name=&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang'&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看audit表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [test]&amp;gt; select * from audit;
&lt;span class=&quot;hljs-addition&quot;&gt;+----+---------------+--------+--------+----------+&lt;/span&gt;
| id | note          | emp_no | mgr_no | emp_name |
&lt;span class=&quot;hljs-addition&quot;&gt;+----+---------------+--------+--------+----------+&lt;/span&gt;
|  1 | before insert |     15 |      5 | xiaofang |
|  2 | after insert  |     15 |      5 | xiaofang |
&lt;span class=&quot;hljs-addition&quot;&gt;+----+---------------+--------+--------+----------+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在插入没有重复冲突的行只触发了before insert和after insert触发器。没有触发update触发器。&lt;/p&gt;
&lt;p&gt;再插入一条有重复冲突的记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;TRUNCATE&lt;/span&gt; audit;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; emp &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang'&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; DUPLICATE &lt;span class=&quot;hljs-keyword&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; emp_name=&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang'&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看audit表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [test]&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; audit;
+----+------------------------+--------+--------+----------+
| id | note                   | emp_no | mgr_no | emp_name |
+----+------------------------+--------+--------+----------+
|  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | before insert          |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | xiaofang |
|  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; | before update &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | xiaofang |
|  &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | before update &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; old |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | Tommy    |
|  &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; | after update &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;  |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | xiaofang |
|  &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; | after update &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; old  |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | Tommy    |
+----+------------------------+--------+--------+----------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里触发了3个触发器：before insert/before update/after update，为什么前面只触发了两个insert触发器而这里触发了3个触发器。其实根据下面的图很好分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201804/733013-20180417163230158-1381206159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;insert into... on duplicate key update&lt;/code&gt;语句中，插入没有重复值冲突的记录时，首先判断是否存在before insert触发器，有就触发，触发之后检查约束，发现没有重复值冲突，然后直接触发after insert触发器。所以这种情况下只触发了before insert和after insert触发器。&lt;/p&gt;
&lt;p&gt;而插入有重复值冲突的记录时，首先触发了before insert触发器，然后检查约束发现存在重复值冲突，所以改insert操作为update操作，update操作再次回到事务的顶端，先触发before update再检查约束，这时候已经不再重复值冲突，所以后面触发after update触发器。&lt;/p&gt;


&lt;p&gt;插入新记录时，对于重复值冲突的记录，使用&lt;code&gt;replace to&lt;/code&gt;语句代替insert into是另一种方法。这种方法实现方式和&lt;code&gt;on duplicate key update&lt;/code&gt;方式不一样。&lt;/p&gt;
&lt;p&gt;replace to算法说明如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;尝试插入新行。&lt;/li&gt;
&lt;li&gt;存在重复值冲突时，从表中删除重复行。&lt;/li&gt;
&lt;li&gt;将新行插入到表中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;也就是说，存在重复值冲突时，如果使用触发器的话，将先触发before insert，再触发delete操作，先是before delete再是after delete，最后触发after insert。&lt;/p&gt;
&lt;p&gt;以下是验证过程和结果：首先清空audit表，再插入重复冲突的记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;TRUNCATE&lt;/span&gt; audit;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; emp &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'gaoxiaofang'&lt;/span&gt;);&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看audit表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MariaDB [test]&amp;gt; select * from audit;
+----+---------------+--------+--------+-------------+
| &lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; | note          | emp_no | mgr_no | emp_name    |
+----+---------------+--------+--------+-------------+
|  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | before insert |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | gaoxiaofang |
|  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; | before delete |      &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; |   &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt; | &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;        |
|  &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; | after delete  |      &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; |   &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt; | &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;        |
|  &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; | after insert  |      &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; |      &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; | gaoxiaofang |
+----+---------------+--------+--------+-------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，和算法说明的结果是对应的。&lt;/p&gt;


&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; SHOW CREATE TRIGGER trig_demo5\G
&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-strong&quot;&gt;** 1. row **&lt;/span&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;
&lt;span class=&quot;hljs-code&quot;&gt;               Trigger: trig_demo5&lt;/span&gt;
&lt;span class=&quot;hljs-code&quot;&gt;              sql_mode: &lt;/span&gt;
SQL Original Statement: CREATE DEFINER=&lt;span class=&quot;hljs-code&quot;&gt;`root`&lt;/span&gt;@&lt;span class=&quot;hljs-code&quot;&gt;`192.168.100.%`&lt;/span&gt; TRIGGER &lt;span class=&quot;hljs-code&quot;&gt;`test`&lt;/span&gt;.&lt;span class=&quot;hljs-code&quot;&gt;`trig_demo5`&lt;/span&gt; BEFORE UPDATE ON &lt;span class=&quot;hljs-code&quot;&gt;`test`&lt;/span&gt;.&lt;span class=&quot;hljs-code&quot;&gt;`emp`&lt;/span&gt;
&lt;span class=&quot;hljs-code&quot;&gt;    FOR EACH ROW BEGIN&lt;/span&gt;
&lt;span class=&quot;hljs-code&quot;&gt;        INSERT INTO audit VALUES(NULL,'before update from new',new.emp_no,new.mgr_no,new.emp_name);&lt;/span&gt;
&lt;span class=&quot;hljs-code&quot;&gt;        INSERT INTO audit VALUES(NULL,'before update from old',old.emp_no,old.mgr_no,old.emp_name);&lt;/span&gt;
&lt;span class=&quot;hljs-code&quot;&gt;    END&lt;/span&gt;
  character&lt;span class=&quot;hljs-emphasis&quot;&gt;_set_&lt;/span&gt;client: utf8
  collation&lt;span class=&quot;hljs-emphasis&quot;&gt;_connection: utf8_&lt;/span&gt;general_ci
&lt;span class=&quot;hljs-code&quot;&gt;    Database Collation: latin1_swedish_ci&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show triggers;
mysql&amp;gt; show trigger like &lt;span class=&quot;hljs-string&quot;&gt;'pattern'&lt;/span&gt;;
mysql&amp;gt; show trigger &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'expression'&lt;/span&gt;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是要注意，这个like的模式是对表名进行匹配的，而不是触发器名。例如触发器trig_demo1是基于emp表创建的，则使用like 'emp'而不能使用like 'trig_demo1'。&lt;/p&gt;
&lt;p&gt;在information_schema中有TRIGGERS元数据表：&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from information_schema.triggers where trigger_name=&lt;span class=&quot;hljs-string&quot;&gt;'trig_demo1'&lt;/span&gt;\G
*************************** &lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt; row ***************************
           TRIGGER_CATALOG: def
            TRIGGER_SCHEMA: test
              TRIGGER_NAME: trig_demo1
        EVENT_MANIPULATION: INSERT
      EVENT_OBJECT_CATALOG: def
       EVENT_OBJECT_SCHEMA: test
        EVENT_OBJECT_TABLE: emp
              ACTION_ORDER: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
          ACTION_CONDITION: &lt;span class=&quot;hljs-keyword&quot;&gt;NULL&lt;/span&gt;
          ACTION_STATEMENT: BEGIN
        INSERT INTO audit VALUES(&lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'before insert'&lt;/span&gt;,&lt;span class=&quot;hljs-keyword&quot;&gt;NEW&lt;/span&gt;.emp_no,&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;.mgr_no,&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;.emp_name);
    END
        ACTION_ORIENTATION: ROW
             ACTION_TIMING: BEFORE
ACTION_REFERENCE_OLD_TABLE: &lt;span class=&quot;hljs-keyword&quot;&gt;NULL&lt;/span&gt;
ACTION_REFERENCE_NEW_TABLE: &lt;span class=&quot;hljs-keyword&quot;&gt;NULL&lt;/span&gt;
  ACTION_REFERENCE_OLD_ROW: OLD
  ACTION_REFERENCE_NEW_ROW: &lt;span class=&quot;hljs-keyword&quot;&gt;NEW&lt;/span&gt;
                   CREATED: &lt;span class=&quot;hljs-keyword&quot;&gt;NULL&lt;/span&gt;
                  SQL_MODE: 
                   DEFINER: root@&lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.%
      CHARACTER_SET_CLIENT: utf8
      COLLATION_CONNECTION: utf8_general_ci
        DATABASE_COLLATION: latin1_swedish_ci
&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; row in set (&lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt; sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除触发器的时候，需要使用drop语句指定数据库名，而不是指定表名称。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TRIGGER&lt;/span&gt; [ &lt;span class=&quot;hljs-keyword&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EXISTS&lt;/span&gt; ] test.example_trigger;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8870446.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8870446.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 14:29:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8870446.html</dc:identifier>
</item>
<item>
<title>Python 函数的参数 - SharpCJ</title>
<link>http://www.cnblogs.com/joy99/p/8870188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joy99/p/8870188.html</guid>
<description>&lt;p&gt;python 函数的参数可分为位置参数、缺省参数、可变参数和关键字参数。其中可变参数和关键字参数又可以进行拆包。&lt;/p&gt;
&lt;h2 id=&quot;位置参数&quot;&gt;位置参数&lt;/h2&gt;
&lt;p&gt;看下面程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def fun1(a, b):
        print(&quot;a -- &quot; + str(a))
        print(&quot;b -- &quot; + str(b))
        return a + b

    print(fun1(2, 3))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，程序结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    a ---- 2
    b ---- 3
    5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的函数 fun1 中的参数 a 和 b 就是位置参数。位置参数在调用时，必须给到具体值。&lt;/p&gt;
&lt;h2 id=&quot;缺省参数&quot;&gt;缺省参数&lt;/h2&gt;
&lt;p&gt;看下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def fun2(a, b, c=0):
        print(&quot;a -- &quot; + str(a))
        print(&quot;b -- &quot; + str(b))
        print(&quot;c -- &quot; + str(c))
        return a + b + c

    print(fun2(2, 3))
    print(fun2(2, 3, 4))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    a -- 2
    b -- 3
    c -- 0
    5
    a -- 2
    b -- 3
    c -- 4
    9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里函数 fun2 中，有三个参数，其中 a 和 b 是位置参数， c 即是一个缺省参数。声明函数 fun2 时指定了参数 c=0 ，表示参数 c 的默认值是 0 ，上面程序中两次在调用 fun2 时，分别传入了两个参数和三个参数。我们看到，在传入两个参数时，a 和 b 的值分别是传入的 2 和 3，其中 c 的值为默认值 0 ，在传入三个参数时，a， b 和 c&lt;br/&gt;值分别是传入的 2， 3， 4 。&lt;br/&gt;很好理解，在函数定义的时候，给参数赋了一个默认值，这样的参数就叫缺省参数，也叫默认参数。&lt;br/&gt;假设有多个缺省参数，而我只传入了部分缺省参数会是怎样的情况？看下面的程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def fun2(a, b, c=0, d=0):
        print(&quot;a -- &quot; + str(a))
        print(&quot;b -- &quot; + str(b))
        print(&quot;c -- &quot; + str(c))
        print(&quot;d -- &quot; + str(d))
        return a + b + c + d

    print(fun2(2, 3, 4))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    a -- 2
    b -- 3
    c -- 4
    d -- 0
    9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明，前面的位置参数是必须要传入的，c 的值是 4 ，而 d 的值是默认值 0 ，这说明，传入的部分缺省参数会按顺序赋值。如果偏要将 4 赋给 d ，而 c 用默认参数呢，则用下面方式调用函数即可：&lt;br/&gt;&lt;code&gt;print(fun2(2, 3, d=4))&lt;/code&gt;&lt;br/&gt;程序结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    a -- 2
    b -- 3
    c -- 0
    d -- 4
    9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不止是缺省参数，位置参数也可以在调用函数时，也可以指定具体的值赋给哪个参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得注意的是：定义函数时缺省参数要放在位置参数后面&lt;/strong&gt;，如果向下面这样定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def fun2(a, b=0, c):
        return a + b + c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则会报错：&lt;code&gt;SyntaxError: non-default argument follows default argument&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;熟悉 java、C# 或者 C++ 等语言的应该知道“重载方法”的概念。参数列表不相同，包括参数的类型不相同和参数的个数不相同。在python中，用缺省参数，正好可以实现重载类似的效果。&lt;/p&gt;
&lt;h2 id=&quot;可变参数不定长参数&quot;&gt;可变参数（不定长参数）&lt;/h2&gt;
&lt;p&gt;在Python函数中，还可以定义可变参数，也叫不定长参数。顾名思义，可变参数就是传入的参数个数是可变的，写法为，在参数前面加上一个 &lt;code&gt;*&lt;/code&gt; ，类似于 java 中的不定长参数。不同的是，java中不定长参数，以数组形式存储，在python中，可变参数则是一个元组。看下面的程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def fun3(a, *b):
        print(type(a))
        print(a)
        print(type(b))
        print(b)

    fun3(1, 2, 3, 4, 5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;class 'int'&amp;gt;
    1
    &amp;lt;class 'tuple'&amp;gt;
    (2, 3, 4, 5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序中，函数 fun3 的参数 a 是一个 int 型，后面 *b 即为可变参数，在调用时，可以根据需要传入不同个数的参数，除去 a 之后，剩余所有的参数，都添加到一个元组中。&lt;/p&gt;
&lt;p&gt;看下面的调用：&lt;br/&gt;&lt;code&gt;fun3(1, 2, (3, 4, 5), [6, 7], {'x': 8, 'y': 9}, 10, 11)&lt;/code&gt;&lt;br/&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;class 'int'&amp;gt;
    1
    &amp;lt;class 'tuple'&amp;gt;
    (2, (3, 4, 5), [6, 7], {'x': 8, 'y': 9}, 10, 11)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示很明确了，即便我传入列表，元组，字典类型的参数，也会被当做元组的元素，添加进去。&lt;br/&gt;约定俗成，函数中的可变参数一般用 &lt;code&gt;*args&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;h2 id=&quot;关键字参数&quot;&gt;关键字参数&lt;/h2&gt;
&lt;p&gt;最后说说 python 的关键字参数。python 关键字参数是在参数前面加上 &lt;code&gt;**&lt;/code&gt; ，和可变参数有点类似，区别在于，关键字参数是以字典形式存储。调用的时候也有区别，看下面的程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def fun4(a, *b, **c):
        print(type(c))
        print(a)
        print(b)
        print(c)

    fun4(1, 2, 3, 4, 5, x=6, y=7)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;class 'dict'&amp;gt;
    1
    (2, 3, 4, 5)
    {'x': 6, 'y': 7}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示，参数 C 的类型是 dict 字典。在调用时，需要按照 &lt;code&gt;key = value&lt;/code&gt; 的形式传入关键字参数。约定俗成，关键字参数一般用 &lt;code&gt;**kwargs&lt;/code&gt; 来表示。按照上面的写法，我们调用函数时可以随意传入关键字参数，有时候，我们需要限定关键字参数的 'key' ，这样我们可以使用命名关键字参数。比如，上面的程序，我在调用时关键字参数，传入了 'x' 和 'y'，事实上，我想的话，还可以传入更多的参数 ，用命名关键字参数，则可以限定，只传入 'x' 和 'y' ,程序如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def fun5(a, *, x, y):
        print(a)
        print(x)
        print(y)


    fun5(1, x=2, y=3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    1
    2
    3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即用一个 &lt;code&gt;*，&lt;/code&gt;，后面跟上指定的参数。这样，你如果多传，或者少穿关键字参数，都是不可以的。&lt;/p&gt;
&lt;h2 id=&quot;可变参数和关键字参数拆包&quot;&gt;可变参数和关键字参数拆包&lt;/h2&gt;
&lt;p&gt;再回头看前面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def fun3(a, *b):
        print(type(a))
        print(a)
        print(type(b))
        print(b)

    fun3(1, 2, 3, 4, 5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行 &lt;code&gt;fun3(1, 2, (3, 4, 5), [6, 7], {'x': 8, 'y': 9}, 10, 11)&lt;/code&gt;&lt;br/&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;class 'int'&amp;gt;
    1
    &amp;lt;class 'tuple'&amp;gt;
    (2, (3, 4, 5), [6, 7], {'x': 8, 'y': 9}, 10, 11)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，传入参数的 (3,4,5) 和 [6,7] 和 {'x': 8, 'y': 9} 都被当作元组里面的元素了。下面在调用时，参数前面添加一个 &lt;code&gt;*&lt;/code&gt; ,如下：&lt;br/&gt;&lt;code&gt;fun3(1, 2, *(3, 4, 5), *[6, 7], *{'x': 8, 'y': 9}, 10, 11)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;class 'int'&amp;gt;
    1
    &amp;lt;class 'tuple'&amp;gt;
    (2, 3, 4, 5, 6, 7, 'x', 'y', 12, 13)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看结果，在列表或者元组参数前面添加 &lt;code&gt;*&lt;/code&gt; 之后，却反而被拆开成单个元素，作为元组的元素。而字典，只是把它的 'key' 拆成单个元素。这就是可变参数的拆包。一般，可变参数的拆包我们只针对元组和列表，不针对字典。&lt;br/&gt;同样，对于含有关键字参数的函数，也可对传入的参数进行拆包，看下面这个函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def fun6(**kwargs):
        print(kwargs)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我调用函数 &lt;code&gt;fun6({'x': 1, 'y': 2})&lt;/code&gt; ，这时候，程序会报错&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758949/201804/758949-20180417215307003-1964380396.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为，关键字参数，在调用的时候传参，需要按照 &lt;code&gt;key = value&lt;/code&gt; 的形式传入。而我现在传入一个字典，会被当做一个整体，作为一个位置参数传入。如果以下面这种方式&lt;br/&gt;&lt;code&gt;fun6(**{'x': 1, 'y': 2})&lt;/code&gt;&lt;br/&gt;调用，则可行，结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    {'x': 1, 'y': 2}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即通过 &lt;code&gt;**&lt;/code&gt; 将字典拆成了 &lt;code&gt;'x'=1 , 'y'=2&lt;/code&gt; 的形式。这就是关键字参数的拆包。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 14:05:00 +0000</pubDate>
<dc:creator>SharpCJ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joy99/p/8870188.html</dc:identifier>
</item>
<item>
<title>Java 并发编程——Callable+Future+FutureTask - NeilZhang</title>
<link>http://www.cnblogs.com/NeilZhang/p/8870062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeilZhang/p/8870062.html</guid>
<description>
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;项目中经常有些任务需要异步(提交到线程池中)去执行，而主线程往往需要&lt;strong&gt;知道异步执行产生的结果&lt;/strong&gt;，这时我们要怎么做呢？用runnable是无法实现的，我们需要用callable实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.util.concurrent.Callable;
&lt;span&gt;import&lt;/span&gt; java.util.concurrent.ExecutionException;
&lt;span&gt;import&lt;/span&gt; java.util.concurrent.ExecutorService;
&lt;span&gt;import&lt;/span&gt; java.util.concurrent.Executors;
&lt;span&gt;import&lt;/span&gt; java.util.concurrent.Future;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AddTask &lt;span&gt;implements&lt;/span&gt; Callable&amp;lt;Integer&amp;gt; {

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a,b;

    &lt;span&gt;public&lt;/span&gt; AddTask(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b) {
        &lt;span&gt;this&lt;/span&gt;.a = a;
        &lt;span&gt;this&lt;/span&gt;.b = b;
    }

    @Override
    &lt;span&gt;public&lt;/span&gt; Integer call() &lt;span&gt;throws&lt;/span&gt; Exception {
        Integer result = a + b;
        &lt;span&gt;return&lt;/span&gt; result;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        &lt;span&gt;//JDK目前为止返回的都是FutureTask的实例  &lt;/span&gt;
        Future&amp;lt;Integer&amp;gt; future = executor.submit(&lt;span&gt;new&lt;/span&gt; AddTask(1, 2));
        Integer result = future.get();&lt;span&gt;// 只有当future的状态是已完成时(future.isDone() = true),get()方法才会返回  &lt;/span&gt;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;Callable接口                                                                                                     &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Callable接口Runable接口可谓是兄弟关系，只不过Callable是带返回值的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Callable&amp;lt;V&amp;gt; {
    &lt;span&gt;/**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */&lt;/span&gt;
    V call() &lt;span&gt;throws&lt;/span&gt; Exception;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;Future 接口                                                                                                        &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;接口函数及含义 ：public interface Future&amp;lt;V&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;boolean  cancel(boolean mayInterruptIfRunning)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取消当前执行的任务，如果已经执行完毕或者已经被取消/由于某种原因不能被取消 则取消任务失败。&lt;/p&gt;
&lt;p&gt;参数mayInterruptIfRunning： 当任务正在执行，如果参数为true ，则尝试中断任务，否则让任务继续执行知道结束。&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;boolean isCancelled()&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;pre&gt;
Returns {@code true} if this task was cancelled before it completed&lt;br/&gt;* normally.
&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;boolean isDone();&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;pre&gt;
/**&lt;br/&gt;* Returns {@code true} if this task completed.&lt;br/&gt;*&lt;br/&gt;* Completion may be due to normal termination, an exception, or&lt;br/&gt;* cancellation -- in all of these cases, this method will return&lt;br/&gt;* {@code true}.&lt;br/&gt;*&lt;br/&gt;* @return {@code true} if this task completed&lt;br/&gt;*/
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;V get() throws InterruptedException, ExecutionException;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
/**&lt;br/&gt;* Waits if necessary for the computation to complete, and then&lt;br/&gt;* retrieves its result.&lt;br/&gt;*&lt;br/&gt;* @return the computed result&lt;br/&gt;* @throws CancellationException if the computation was cancelled&lt;br/&gt;* @throws ExecutionException if the computation threw an&lt;br/&gt;* exception&lt;br/&gt;* @throws InterruptedException if the current thread was interrupted&lt;br/&gt;* while waiting&lt;br/&gt;*/
&lt;/pre&gt;
&lt;pre&gt;
由注释可以看出，当没有执行完成时，需要等待任务执行完成了才会将计算结果返回。
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;V get(long timeout, TimeUnit unit)&lt;br/&gt;throws InterruptedException, ExecutionException, TimeoutException;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
Waits if necessary for at most the given time for the computation&lt;br/&gt;* to complete, and then retrieves its result, if available.
&lt;/pre&gt;
&lt;p&gt;如果等待的时间超过设置的时间则会报 TimeoutException异常&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;FutureTask                                                                                                     &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由定义可以看出它实现了RunnableFuture接口，那么这个接口又是什么呢？看下面的接口定义，其实很简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; RunnableFuture&amp;lt;V&amp;gt; &lt;span&gt;extends&lt;/span&gt; Runnable, Future&amp;lt;V&amp;gt; {
    &lt;span&gt;/**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; run();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再回到FutureTask,它其实就是实现了Runnable和Future接口，FutureTask的执行是 状态转换的过程，源码中有七种状态如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  * Possible state transitions:
     * NEW -&amp;gt; COMPLETING -&amp;gt; NORMAL
     * NEW -&amp;gt; COMPLETING -&amp;gt; EXCEPTIONAL
     * NEW -&amp;gt; CANCELLED
     * NEW -&amp;gt; INTERRUPTING -&amp;gt; INTERRUPTED
     */
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NEW          = 0;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; COMPLETING   = 1;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NORMAL       = 2;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXCEPTIONAL  = 3;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED    = 4;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERRUPTING = 5;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERRUPTED  = 6;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当FutureTask刚刚被创建时，它的状态是NEW，其它状态查看源码。&lt;/p&gt;
&lt;p&gt;其它成员变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/** The underlying callable; nulled out after running */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Callable&amp;lt;V&amp;gt; callable;
    &lt;span&gt;/** The result to return or exception to throw from get() */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Object outcome; &lt;span&gt;// non-volatile, protected by state reads/writes&lt;/span&gt;
    &lt;span&gt;/** The thread running the callable; CASed during run() */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Thread runner;
    &lt;span&gt;/** Treiber stack of waiting threads */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; WaitNode waiters;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;callable是待执行的任务，FutureTask 的 run（）函数中执行callable中的任务。&lt;/p&gt;
&lt;p&gt;outcome ： 是callable的执行结果，当正常执行完成后会将结果set到outcome中&lt;/p&gt;
&lt;p&gt;runner：是执行callable 的线程&lt;/p&gt;
&lt;p&gt;WaitNode : 是的受阻塞的线程链表，当cancel一个任务后，阻塞的线程会被唤醒。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造函数：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; FutureTask(Callable&amp;lt;V&amp;gt;&lt;span&gt; callable) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callable == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.callable =&lt;span&gt; callable;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state = NEW;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ensure visibility of callable&lt;/span&gt;
&lt;span&gt;    }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FutureTask(Runnable runnable, V result) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.callable =&lt;span&gt; Executors.callable(runnable, result);
    &lt;/span&gt;&lt;span&gt;&lt;span&gt;this&lt;/span&gt;.state = NEW; &lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ensure visibility of callable&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从构造函数可以看出，不光可以通过callable构造FutureTask还可以通过Runnable接口转化为callable来构造。关键函数为黄色标记部分，Executors中的实现源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * A callable that runs given task and returns given result.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RunnableAdapter&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt; Callable&amp;lt;T&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Runnable task;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; T result;
        RunnableAdapter(Runnable task, T result) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.task =&lt;span&gt; task;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.result =&lt;span&gt; result;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T call() {
            task.run();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面不懂result到底有什么意义，明明就是预先设置好的。&lt;/p&gt;

&lt;p&gt;其它具体的方法说明这里不再细说，里面用到了很多sun.misc.Unsafe中的方法以及其他SDK底层接口，后续有时间再学习。下面贴出了整个源码及说明&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65.5&quot;&gt;&lt;img id=&quot;code_img_closed_6dc2a526-ff82-432c-acbf-1329b7f3ba00&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6dc2a526-ff82-432c-acbf-1329b7f3ba00&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6dc2a526-ff82-432c-acbf-1329b7f3ba00&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;126&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FutureTask&amp;lt;V&amp;gt; &lt;span&gt;implements&lt;/span&gt; RunnableFuture&amp;lt;V&amp;gt; {
    &lt;span&gt;/*
     * Revision notes: This differs from previous versions of this
     * class that relied on AbstractQueuedSynchronizer, mainly to
     * avoid surprising users about retaining interrupt status during
     * cancellation races. Sync control in the current design relies
     * on a &quot;state&quot; field updated via CAS to track completion, along
     * with a simple Treiber stack to hold waiting threads.
     *
     * Style note: As usual, we bypass overhead of using
     * AtomicXFieldUpdaters and instead directly use Unsafe intrinsics.
     */&lt;/span&gt;

    &lt;span&gt;/**
     * The run state of this task, initially NEW.  The run state
     * transitions to a terminal state only in methods set,
     * setException, and cancel.  During completion, state may take on
     * transient values of COMPLETING (while outcome is being set) or
     * INTERRUPTING (only while interrupting the runner to satisfy a
     * cancel(true)). Transitions from these intermediate to final
     * states use cheaper ordered/lazy writes because values are unique
     * and cannot be further modified.
     *
     * Possible state transitions:
     * NEW -&amp;gt; COMPLETING -&amp;gt; NORMAL
     * NEW -&amp;gt; COMPLETING -&amp;gt; EXCEPTIONAL
     * NEW -&amp;gt; CANCELLED
     * NEW -&amp;gt; INTERRUPTING -&amp;gt; INTERRUPTED
     */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NEW          = 0;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; COMPLETING   = 1;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NORMAL       = 2;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXCEPTIONAL  = 3;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED    = 4;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERRUPTING = 5;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERRUPTED  = 6;

    &lt;span&gt;/** The underlying callable; nulled out after running */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Callable&amp;lt;V&amp;gt; callable;
    &lt;span&gt;/** 用来存储任务执行结果或者异常对象,根据任务state在get时候选择返回执行结果还是抛出异常 */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Object outcome; &lt;span&gt;// non-volatile, protected by state reads/writes&lt;/span&gt;
    &lt;span&gt;/** 当前运行Run方法的线程  */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Thread runner;
    &lt;span&gt;/** Treiber stack of waiting threads */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; WaitNode waiters;

    &lt;span&gt;/**
     * Returns result or throws exception for completed task.
     *
     * @param s completed state value
     */&lt;/span&gt;
    @SuppressWarnings(&quot;&lt;span&gt;unchecked&lt;/span&gt;&quot;)
    &lt;span&gt;private&lt;/span&gt; V report(&lt;span&gt;int&lt;/span&gt; s) &lt;span&gt;throws&lt;/span&gt; ExecutionException {
        Object x = outcome;
        &lt;span&gt;if&lt;/span&gt; (s == NORMAL)
            &lt;span&gt;return&lt;/span&gt; (V)x;
        &lt;span&gt;if&lt;/span&gt; (s &amp;gt;= CANCELLED)
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CancellationException();
        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ExecutionException((Throwable)x);
    }

    &lt;span&gt;/**
     * Creates a {@code FutureTask} that will, upon running, execute the
     * given {@code Callable}.
     *
     * @param  callable the callable task
     * @throws NullPointerException if the callable is null
     */&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; FutureTask(Callable&amp;lt;V&amp;gt; callable) {
        &lt;span&gt;if&lt;/span&gt; (callable == &lt;span&gt;null&lt;/span&gt;)
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();
        &lt;span&gt;this&lt;/span&gt;.callable = callable;
        &lt;span&gt;this&lt;/span&gt;.state = NEW;       &lt;span&gt;// ensure visibility of callable&lt;/span&gt;
    }

    &lt;span&gt;/**
     * Creates a {@code FutureTask} that will, upon running, execute the
     * given {@code Runnable}, and arrange that {@code get} will return the
     * given result on successful completion.
     *
     * @param runnable the runnable task
     * @param result the result to return on successful completion. If
     * you don't need a particular result, consider using
     * constructions of the form:
     * {@code Future&amp;lt;?&amp;gt; f = new FutureTask&amp;lt;Void&amp;gt;(runnable, null)}
     * @throws NullPointerException if the runnable is null
     */&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; FutureTask(Runnable runnable, V result) {
        &lt;span&gt;this&lt;/span&gt;.callable = Executors.callable(runnable, result);
        &lt;span&gt;this&lt;/span&gt;.state = NEW;       &lt;span&gt;// ensure visibility of callable&lt;/span&gt;
    }
    &lt;span&gt;//判断任务是否已取消(异常中断、取消等)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isCancelled() {
        &lt;span&gt;return&lt;/span&gt; state &amp;gt;= CANCELLED;
    }
   &lt;span&gt;/**
    判断任务是否已结束（取消、异常、完成、NORMAL都等于结束）
    **
    public boolean isDone() {
        return state != NEW;
    }

    /**
   mayInterruptIfRunning用来决定任务的状态。
                   true : 任务状态= INTERRUPTING = 5。如果任务已经运行，则强行中断。如果任务未运行，那么则不会再运行
                   false：CANCELLED    = 4。如果任务已经运行，则允许运行完成（但不能通过get获取结果）。如果任务未运行，那么则不会再运行
    **/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; cancel(&lt;span&gt;boolean&lt;/span&gt; mayInterruptIfRunning) {
        &lt;span&gt;if&lt;/span&gt; (state != NEW)
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;
        &lt;span&gt;if&lt;/span&gt; (mayInterruptIfRunning) {
            &lt;span&gt;if&lt;/span&gt; (!UNSAFE.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, stateOffset, NEW, INTERRUPTING))
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;
            Thread t = runner;
            &lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;)
                t.interrupt();
            UNSAFE.putOrderedInt(&lt;span&gt;this&lt;/span&gt;, stateOffset, INTERRUPTED); &lt;span&gt;// final state&lt;/span&gt;
        }
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!UNSAFE.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, stateOffset, NEW, CANCELLED))
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;
        finishCompletion();
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;
    }

    &lt;span&gt;/**
     * @throws CancellationException {@inheritDoc}
     */&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; V get() &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException {
        &lt;span&gt;int&lt;/span&gt; s = state;
        &lt;span&gt;//如果任务未彻底完成，那么则阻塞直至任务完成后唤醒该线程&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (s &amp;lt;= COMPLETING)
            s = awaitDone(&lt;span&gt;false&lt;/span&gt;, 0L);
        &lt;span&gt;return&lt;/span&gt; report(s);
    }

    &lt;span&gt;/**
     * @throws CancellationException {@inheritDoc}
     */&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; V get(&lt;span&gt;long&lt;/span&gt; timeout, TimeUnit unit)
        &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException, TimeoutException {
        &lt;span&gt;if&lt;/span&gt; (unit == &lt;span&gt;null&lt;/span&gt;)
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();
        &lt;span&gt;int&lt;/span&gt; s = state;
        &lt;span&gt;if&lt;/span&gt; (s &amp;lt;= COMPLETING &amp;amp;&amp;amp;
            (s = awaitDone(&lt;span&gt;true&lt;/span&gt;, unit.toNanos(timeout))) &amp;lt;= COMPLETING)
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TimeoutException();
        &lt;span&gt;return&lt;/span&gt; report(s);
    }

    &lt;span&gt;/**
     * Protected method invoked when this task transitions to state
     * {@code isDone} (whether normally or via cancellation). The
     * default implementation does nothing.  Subclasses may override
     * this method to invoke completion callbacks or perform
     * bookkeeping. Note that you can query status inside the
     * implementation of this method to determine whether this task
     * has been cancelled.
     */&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; done() { }


    &lt;span&gt;/**
    该方法在FutureTask里只有run方法在任务完成后调用。
    主要保存任务执行结果到成员变量outcome 中，和切换任务执行状态。
    由该方法可以得知：
    COMPLETING ： 任务已执行完成（也可能是异常完成），但还未设置结果到成员变量outcome中，也意味着还不能get
    NORMAL    ： 任务彻底执行完成
    **/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; set(V v) {
        &lt;span&gt;if&lt;/span&gt; (UNSAFE.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, stateOffset, NEW, COMPLETING)) {
            outcome = v;
            UNSAFE.putOrderedInt(&lt;span&gt;this&lt;/span&gt;, stateOffset, NORMAL); &lt;span&gt;// final state&lt;/span&gt;
            finishCompletion();
        }
    }

    &lt;span&gt;/**
     * Causes this future to report an {@link ExecutionException}
     * with the given throwable as its cause, unless this future has
     * already been set or has been cancelled.
     *
     * &amp;lt;p&amp;gt;This method is invoked internally by the {@link #run} method
     * upon failure of the computation.
     *
     * @param t the cause of failure
     */&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setException(Throwable t) {
        &lt;span&gt;if&lt;/span&gt; (UNSAFE.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, stateOffset, NEW, COMPLETING)) {
            outcome = t;
            UNSAFE.putOrderedInt(&lt;span&gt;this&lt;/span&gt;, stateOffset, EXCEPTIONAL); &lt;span&gt;// final state&lt;/span&gt;
            finishCompletion();
        }
    }

    &lt;span&gt;/**
    由于实现了Runnable接口的缘故，该方法可由执行线程所调用。
    **/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; run() {
        &lt;span&gt;//只有当任务状态=new时才被运行继续执行&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (state != NEW ||
            !UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, runnerOffset,
                                         &lt;span&gt;null&lt;/span&gt;, Thread.currentThread()))
            &lt;span&gt;return&lt;/span&gt;;
        &lt;span&gt;try&lt;/span&gt; {
            Callable&amp;lt;V&amp;gt; c = callable;
            &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; state == NEW) {
                V result;
                &lt;span&gt;boolean&lt;/span&gt; ran;
                &lt;span&gt;try&lt;/span&gt; {
                    &lt;span&gt;//调用Callable的Call方法&lt;/span&gt;
                    result = c.call();
                    ran = &lt;span&gt;true&lt;/span&gt;;
                } &lt;span&gt;catch&lt;/span&gt; (Throwable ex) {
                    result = &lt;span&gt;null&lt;/span&gt;;
                    ran = &lt;span&gt;false&lt;/span&gt;;
                    setException(ex);
                }
                &lt;span&gt;if&lt;/span&gt; (ran)
                    set(result);
            }
        } &lt;span&gt;finally&lt;/span&gt; {
            &lt;span&gt;// runner must be non-null until state is settled to&lt;/span&gt;
            &lt;span&gt;// prevent concurrent calls to run()&lt;/span&gt;
            runner = &lt;span&gt;null&lt;/span&gt;;
            &lt;span&gt;// state must be re-read after nulling runner to prevent&lt;/span&gt;
            &lt;span&gt;// leaked interrupts&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; s = state;
            &lt;span&gt;if&lt;/span&gt; (s &amp;gt;= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }


    &lt;span&gt;/**
   如果该任务在执行过程中不被取消或者异常结束，那么该方法不记录任务的执行结果，且不修改任务执行状态。
   所以该方法可以重复执行N次。不过不能直接调用，因为是protected权限。
    **/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; runAndReset() {
        &lt;span&gt;if&lt;/span&gt; (state != NEW ||
            !UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, runnerOffset,
                                         &lt;span&gt;null&lt;/span&gt;, Thread.currentThread()))
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;
        &lt;span&gt;boolean&lt;/span&gt; ran = &lt;span&gt;false&lt;/span&gt;;
        &lt;span&gt;int&lt;/span&gt; s = state;
        &lt;span&gt;try&lt;/span&gt; {
            Callable&amp;lt;V&amp;gt; c = callable;
            &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; s == NEW) {
                &lt;span&gt;try&lt;/span&gt; {
                    c.call(); &lt;span&gt;// don't set result&lt;/span&gt;
                    ran = &lt;span&gt;true&lt;/span&gt;;
                } &lt;span&gt;catch&lt;/span&gt; (Throwable ex) {
                    setException(ex);
                }
            }
        } &lt;span&gt;finally&lt;/span&gt; {
            &lt;span&gt;// runner must be non-null until state is settled to&lt;/span&gt;
            &lt;span&gt;// prevent concurrent calls to run()&lt;/span&gt;
            runner = &lt;span&gt;null&lt;/span&gt;;
            &lt;span&gt;// state must be re-read after nulling runner to prevent&lt;/span&gt;
            &lt;span&gt;// leaked interrupts&lt;/span&gt;
            s = state;
            &lt;span&gt;if&lt;/span&gt; (s &amp;gt;= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
        &lt;span&gt;return&lt;/span&gt; ran &amp;amp;&amp;amp; s == NEW;
    }

    &lt;span&gt;/**
     * Ensures that any interrupt from a possible cancel(true) is only
     * delivered to a task while in run or runAndReset.
     */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handlePossibleCancellationInterrupt(&lt;span&gt;int&lt;/span&gt; s) {
        &lt;span&gt;// It is possible for our interrupter to stall before getting a&lt;/span&gt;
        &lt;span&gt;// chance to interrupt us.  Let's spin-wait patiently.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (s == INTERRUPTING)
            &lt;span&gt;while&lt;/span&gt; (state == INTERRUPTING)
                Thread.yield(); &lt;span&gt;// wait out pending interrupt&lt;/span&gt;

        &lt;span&gt;// assert state == INTERRUPTED;&lt;/span&gt;

        &lt;span&gt;// We want to clear any interrupt we may have received from&lt;/span&gt;
        &lt;span&gt;// cancel(true).  However, it is permissible to use interrupts&lt;/span&gt;
        &lt;span&gt;// as an independent mechanism for a task to communicate with&lt;/span&gt;
        &lt;span&gt;// its caller, and there is no way to clear only the&lt;/span&gt;
        &lt;span&gt;// cancellation interrupt.&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;// Thread.interrupted();&lt;/span&gt;
    }

    &lt;span&gt;/**
     * Simple linked list nodes to record waiting threads in a Treiber
     * stack.  See other classes such as Phaser and SynchronousQueue
     * for more detailed explanation.
     */&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WaitNode {
        &lt;span&gt;volatile&lt;/span&gt; Thread thread;
        &lt;span&gt;volatile&lt;/span&gt; WaitNode next;
        WaitNode() { thread = Thread.currentThread(); }
    }


    &lt;span&gt;/**
    该方法在任务完成（包括异常完成、取消）后调用。删除所有正在get获取等待的节点且唤醒节点的线程。和调用done方法和置空callable.
    **/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; finishCompletion() {
        &lt;span&gt;// assert state &amp;gt; COMPLETING;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (WaitNode q; (q = waiters) != &lt;span&gt;null&lt;/span&gt;;) {
            &lt;span&gt;if&lt;/span&gt; (UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, waitersOffset, q, &lt;span&gt;null&lt;/span&gt;)) {
                &lt;span&gt;for&lt;/span&gt; (;;) {
                    Thread t = q.thread;
                    &lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;) {
                        q.thread = &lt;span&gt;null&lt;/span&gt;;
                        LockSupport.unpark(t);
                    }
                    WaitNode next = q.next;
                    &lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;)
                        &lt;span&gt;break&lt;/span&gt;;
                    q.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// unlink to help gc&lt;/span&gt;
                    q = next;
                }
                &lt;span&gt;break&lt;/span&gt;;
            }
        }

        done();

        callable = &lt;span&gt;null&lt;/span&gt;;        &lt;span&gt;// to reduce footprint&lt;/span&gt;
    }


    &lt;span&gt;/**
    阻塞等待任务执行完成（中断、正常完成、超时）
    **/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; awaitDone(&lt;span&gt;boolean&lt;/span&gt; timed, &lt;span&gt;long&lt;/span&gt; nanos)
        &lt;span&gt;throws&lt;/span&gt; InterruptedException {
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; deadline = timed ? System.nanoTime() + nanos : 0L;
        WaitNode q = &lt;span&gt;null&lt;/span&gt;;
        &lt;span&gt;boolean&lt;/span&gt; queued = &lt;span&gt;false&lt;/span&gt;;
        &lt;span&gt;for&lt;/span&gt; (;;) {
            &lt;span&gt;/**
            这里的if else的顺序也是有讲究的。
            1.先判断线程是否中断，中断则从队列中移除(也可能该线程不存在于队列中)
            2.判断当前任务是否执行完成，执行完成则不再阻塞，直接返回。
            3.如果任务状态=COMPLETING，证明该任务处于已执行完成，正在切换任务执行状态，CPU让出片刻即可
            4.q==null，则证明还未创建节点，则创建节点
            5.q节点入队
            6和7.阻塞
            **/&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt; (Thread.interrupted()) {
                removeWaiter(q);
                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InterruptedException();
            }

            &lt;span&gt;int&lt;/span&gt; s = state;
            &lt;span&gt;if&lt;/span&gt; (s &amp;gt; COMPLETING) {
                &lt;span&gt;if&lt;/span&gt; (q != &lt;span&gt;null&lt;/span&gt;)
                    q.thread = &lt;span&gt;null&lt;/span&gt;;
                &lt;span&gt;return&lt;/span&gt; s;
            }
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s == COMPLETING) &lt;span&gt;// cannot time out yet&lt;/span&gt;
                Thread.yield();
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (q == &lt;span&gt;null&lt;/span&gt;)
                q = &lt;span&gt;new&lt;/span&gt; WaitNode();
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!queued)
                queued = UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, waitersOffset,
                                                     q.next = waiters, q);
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (timed) {
                nanos = deadline - System.nanoTime();
                &lt;span&gt;if&lt;/span&gt; (nanos &amp;lt;= 0L) {
                    removeWaiter(q);
                    &lt;span&gt;return&lt;/span&gt; state;
                }
                LockSupport.parkNanos(&lt;span&gt;this&lt;/span&gt;, nanos);
            }
            &lt;span&gt;else&lt;/span&gt;
                LockSupport.park(&lt;span&gt;this&lt;/span&gt;);
        }
    }

    &lt;span&gt;/**
     * Tries to unlink a timed-out or interrupted wait node to avoid
     * accumulating garbage.  Internal nodes are simply unspliced
     * without CAS since it is harmless if they are traversed anyway
     * by releasers.  To avoid effects of unsplicing from already
     * removed nodes, the list is retraversed in case of an apparent
     * race.  This is slow when there are a lot of nodes, but we don't
     * expect lists to be long enough to outweigh higher-overhead
     * schemes.
     */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; removeWaiter(WaitNode node) {
        &lt;span&gt;if&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;) {
            node.thread = &lt;span&gt;null&lt;/span&gt;;
            retry:
            &lt;span&gt;for&lt;/span&gt; (;;) {          &lt;span&gt;// restart on removeWaiter race&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (WaitNode pred = &lt;span&gt;null&lt;/span&gt;, q = waiters, s; q != &lt;span&gt;null&lt;/span&gt;; q = s) {
                    s = q.next;
                    &lt;span&gt;if&lt;/span&gt; (q.thread != &lt;span&gt;null&lt;/span&gt;)
                        pred = q;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;) {
                        pred.next = s;
                        &lt;span&gt;if&lt;/span&gt; (pred.thread == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;// check for race&lt;/span&gt;
                            &lt;span&gt;continue&lt;/span&gt; retry;
                    }
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, waitersOffset,
                                                          q, s))
                        &lt;span&gt;continue&lt;/span&gt; retry;
                }
                &lt;span&gt;break&lt;/span&gt;;
            }
        }
    }

    &lt;span&gt;// Unsafe mechanics&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; sun.misc.Unsafe UNSAFE;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; stateOffset;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; runnerOffset;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; waitersOffset;
    &lt;span&gt;static&lt;/span&gt; {
        &lt;span&gt;try&lt;/span&gt; {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class&amp;lt;?&amp;gt; k = FutureTask.&lt;span&gt;class&lt;/span&gt;;
            stateOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField(&quot;&lt;span&gt;state&lt;/span&gt;&quot;));
            runnerOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField(&quot;&lt;span&gt;runner&lt;/span&gt;&quot;));
            waitersOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField(&quot;&lt;span&gt;waiters&lt;/span&gt;&quot;));
        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(e);
        }
    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;FutureTask简单应用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FutureMain {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ExecutionException, InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造FutureTask&lt;/span&gt;
        FutureTask&amp;lt;String&amp;gt; futureTask = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;String&amp;gt;(&lt;span&gt;new&lt;/span&gt; CallableClass(&quot;xxx&quot;&lt;span&gt;));
        ExecutorService executorService &lt;/span&gt;= Executors.newFixedThreadPool(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行FutureTask，发送请求
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里开启线程进行RealData的call()执行&lt;/span&gt;
&lt;span&gt;        executorService.submit(futureTask);

        System.out.println(&lt;/span&gt;&quot;请求完毕。。。&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里可以进行其他额外的操作，这里用sleep代替其他业务的处理&lt;/span&gt;
            Thread.sleep(200&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取call()方法的返回值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果此时call()方法没有执行完成，则依然会等待&lt;/span&gt;
        System.out.println(&quot;真实数据:&quot;+&lt;span&gt;futureTask.get());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;如何给Future类 设置监听器，查看参考链接中。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://lixiaohui.iteye.com/blog/2319738&quot; href=&quot;http://lixiaohui.iteye.com/blog/2319738&quot;&gt;http://lixiaohui.iteye.com/blog/2319738&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 13:14:00 +0000</pubDate>
<dc:creator>NeilZhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeilZhang/p/8870062.html</dc:identifier>
</item>
<item>
<title>JavaScript, 函数是实现异步的基础 - 追梦子</title>
<link>http://www.cnblogs.com/pssp/p/8869928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pssp/p/8869928.html</guid>
<description>&lt;p&gt;昨天一朋友和我聊到JS中的异步和同步, 后来从异步和同步的问题中得出了函数的另一面, 觉得挺不错, 特此分享一下&lt;/p&gt;
&lt;p&gt;====&lt;/p&gt;
&lt;p&gt;追梦子: 聊天是同步还是异步&lt;/p&gt;
&lt;p&gt;小A: 异步&lt;/p&gt;
&lt;p&gt;小A: 和你聊还可以和别人聊&lt;/p&gt;
&lt;p&gt;追梦子: 那得看怎么聊，&lt;/p&gt;
&lt;p&gt;小A: 那你也没法说我错&lt;/p&gt;
&lt;p&gt;追梦子: 你要是等另一个人回答后再回，也就是你一句我一句，那就是同步&lt;/p&gt;
&lt;p&gt;小A: 可如果我和你聊着同事也在和别人聊&lt;/p&gt;
&lt;p&gt;小A: 就是异步&lt;/p&gt;
&lt;p&gt;追梦子: 如果你和对方左一句又一句，不按顺序来，那就是异步&lt;/p&gt;
&lt;p&gt;追梦子: 我说你错是因为，你都说是异步&lt;/p&gt;
&lt;p&gt;追梦子: 没有说什么情况下才是异步&lt;/p&gt;
&lt;p&gt;小A: 不是说左一句右一句 不按顺序就是异步&lt;/p&gt;
&lt;p&gt;小A: 而应该是在你输入的情况下 我可以去和别人聊天的呀&lt;/p&gt;
&lt;p&gt;追梦子: 对，是这个意思&lt;/p&gt;
&lt;p&gt;小A: 😁&lt;/p&gt;
&lt;p&gt;小A: 我说对了&lt;/p&gt;
&lt;p&gt;追梦子: 你说的有理，左一句又一句这说的太范了，不算是异步&lt;/p&gt;
&lt;p&gt;小A: 嗯&lt;/p&gt;
&lt;p&gt;追梦子: 异步就是不去等待&lt;/p&gt;
&lt;p&gt;小A: 对&lt;/p&gt;
&lt;p&gt;小A: 同步是顺序执行 但会堵塞 异步解决的堵塞 但也会改变顺序&lt;/p&gt;
&lt;p&gt;追梦子: 改变顺序是结果产生的，不要把重点放在顺序上&lt;/p&gt;
&lt;p&gt;小A: 嗯嗯&lt;/p&gt;
&lt;p&gt;追梦子: 在等待的过程中，可以去做别的事，才是异步的本质，或者异步的价值所在&lt;/p&gt;
&lt;p&gt;小A: 那回调函数你有什么要说的么&lt;/p&gt;
&lt;p&gt;追梦子: 做完某件事，通知你一下&lt;/p&gt;
&lt;p&gt;小A: 并且这件事还得最后做&lt;/p&gt;
&lt;p&gt;追梦子: 那不是这样说&lt;/p&gt;
&lt;p&gt;追梦子: 又不是非得最后执行这个回调函数&lt;/p&gt;
&lt;p&gt;小A: 是要最后执行啊&lt;/p&gt;
&lt;p&gt;追梦子: 回调就是，你事先告诉某人，你说xx你做完件事通知下我，当他做完的时候就会告诉你，但是他在告诉完你以后还可以去做别的&lt;/p&gt;
&lt;p&gt;追梦子: 所以不存在最后执行一说&lt;/p&gt;
&lt;p&gt;追梦子: 你说最后执行，那你有例子？&lt;/p&gt;
&lt;p&gt;小A: 我找找&lt;/p&gt;
&lt;p&gt;小A: 你看这个 他事先输出this will.... 然后执行fn里的 最后进行回调输出this&lt;/p&gt;
&lt;p&gt;小A: &lt;a href=&quot;https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;追梦子: 哈哈&lt;/p&gt;
&lt;p&gt;追梦子: 你看的是表面&lt;/p&gt;
&lt;p&gt;追梦子: 回调函数才没有什么先执行后执行&lt;/p&gt;
&lt;p&gt;追梦子: 你想什么时候执行什么时候执行&lt;/p&gt;
&lt;p&gt;追梦子: 都是你自己来决定的&lt;/p&gt;
&lt;p&gt;追梦子: 虽然看似回调函数是最后执行，但这只是它的表像&lt;/p&gt;
&lt;p&gt;追梦子: 你那个ajax，回调函数后面也可以执行别的啊&lt;/p&gt;
&lt;p&gt;追梦子: 回调函数就是个很简单的东西，不要想复杂了&lt;/p&gt;
&lt;p&gt;小A: 我只能看表面&lt;/p&gt;
&lt;p&gt;小A: 我就觉得他是最后执行的&lt;/p&gt;
&lt;p&gt;追梦子: 把函数作为参数传入到另一个函数中。这个函数就是所谓的回调函数。&lt;/p&gt;
&lt;p&gt;追梦子: 就看他写的这句就好了&lt;/p&gt;
&lt;p&gt;小A: [强]&lt;/p&gt;
&lt;p&gt;追梦子: 其他的都是表面&lt;/p&gt;
&lt;p&gt;小A: [白眼]&lt;/p&gt;
&lt;p&gt;追梦子: 表面的东西，不同的人就会看成不同的东西&lt;/p&gt;
&lt;p&gt;追梦子: 就会产生误解&lt;/p&gt;
&lt;p&gt;小A: 好吧&lt;/p&gt;
&lt;p&gt;追梦子: 往往他只是说的某一方面，但你却看成是它的一切&lt;/p&gt;
&lt;p&gt;追梦子: 就像回调函数&lt;/p&gt;
&lt;p&gt;追梦子: 你昨天和我说回调函数，早上路上时想了下关于函数的&lt;/p&gt;
&lt;p&gt;小A: 然后呢&lt;/p&gt;
&lt;p&gt;追梦子: 发觉以前没意识到一件事，函数有个更重要的&lt;/p&gt;
&lt;p&gt;追梦子: 那就是可选择时机&lt;/p&gt;
&lt;p&gt;小A: 继续&lt;/p&gt;
&lt;p&gt;追梦子: 如果没有这点，异步就不太可能实现&lt;/p&gt;
&lt;p&gt;小A: 只要稍微什么一点 我就有点晕 我还是得多看看 多想想&lt;/p&gt;
&lt;p&gt;小A: 深入&lt;/p&gt;
&lt;p&gt;追梦子: 你想啊。函数是不是可以由你自己决定什么时候去执行&lt;/p&gt;
&lt;p&gt;小A: 当然 调用它就执行了&lt;/p&gt;
&lt;p&gt;追梦子: 如果没有这点，你说异步还可能吗&lt;/p&gt;
&lt;p&gt;追梦子: 如果没有这一点，所有代码就被直接执行了, 也就是只能是同步了&lt;/p&gt;
&lt;p&gt;小A: 但是 你只是告诉他什么时候执行 他什么时候执行完你是不知道的 就异步来说&lt;/p&gt;
&lt;p&gt;追梦子: 你没理解我的点&lt;/p&gt;
&lt;p&gt;小A: 我知道你的意思 咱们可以控制他什么时候去执行 也就实现了异步&lt;/p&gt;
&lt;p&gt;追梦子: 这样说也不对, 函数不等于异步, 我的意思是函数是实现异步的基础, 如果没有函数就无法实现异步, 但函数本身并不是异步, 异步的本质是通过多线程来实现的,或者是通过等待时机,以延迟执行来达到目的, 比如JS中的setTimeout, 所以异步不等于函数, 而我说的函数是实现异步的基础就在于, 如果没有函数, 而你又希望在做完某件事再去执行某段代码的话, 那你想想你的代码要么是被直接执行了, 要么是等那件事做完了再去执行另一段代码, 也就是同步的&lt;/p&gt;
&lt;p&gt;====&lt;/p&gt;
&lt;p&gt;一直以为函数就是代码片段的组合, 然而现在想想函数的作用不仅仅是代码的组合以及重复利用, 另一个目的是可选择执行的时机, 很难想像没有函数的JS会是什么样的, 我想那将会是另一门语言, 另一种的语法&lt;/p&gt;
&lt;p&gt;后来想了下, 我当时在聊天时说: &quot;如果你和对方左一句又一句，不按顺序来，那就是异步&quot; 这句其实并没有错, 只是没有表达清楚, 假如你和A两个人聊天, 你先问A了某个问题, 但你并没有等A回复, 而是接着又问A了另一个问题, 那就是异步了&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 13:09:00 +0000</pubDate>
<dc:creator>追梦子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pssp/p/8869928.html</dc:identifier>
</item>
<item>
<title>从源码看JDK提供的线程池（ThreadPoolExecutor） - MindMrWang</title>
<link>http://www.cnblogs.com/MindMrWang/p/8870033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MindMrWang/p/8870033.html</guid>
<description>&lt;h2 id=&quot;一丶什么是线程池&quot;&gt;一丶什么是线程池&lt;/h2&gt;
&lt;p&gt;（1）博主在听到线程池三个字的时候第一个想法就是数据库连接池，回忆一下，我们在学JavaWeb的时候怎么理解数据库连接池的，数据库创建连接和关闭连接是一个比较耗费资源的事情，对于那些数量多且时间短暂的任务，会导致频繁获取和释放连接，这样使得处理事务的效率大大降低，多以我们创建一个连接池，里面放了指定数目的连接，当应用需要数据库连接的时候去里面获取，使用完毕后再放到连接池里，这样就避免了重复的获取连接和释放连接，至于要获取什么样的连接池我们可以根据应用的特征，设置参数来决定。&lt;br/&gt;（2）线程池和连接池很相似，线程池的产生是为了避免重复的创建线程和回收线程。本着存在即合理，存在即有优点的理念（这个说法不普遍适用），线程池有如下三个优点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①降低资源消耗。通过重复利用已创建的线程降低线程创建、销毁线程造成的消耗。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;②提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;③提高线程的可管理性。线程是稀缺资源，如果入限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;二丶threadpoolexecutor的使用&quot;&gt;二丶ThreadPoolExecutor的使用&lt;/h2&gt;
&lt;p&gt;ThreadPoolExecutor是线程池的最核心的一个类，所以要了解线程池我们先来看看ThreadPoolExecutor类的实现。&lt;br/&gt;本着先学开车后学修车的理念，我们先通过范例来学习一下ThreadPoolExecutor的使用（以后对JDK源码框架的学习都会本着这个原则）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class ThreadPoolExecutorTest {
    public static void main(String[] args) {
        ThreadPoolExecutorTest task = new ThreadPoolExecutorTest();
        //corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 20, 300, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(4));
        for(int i=0;i &amp;lt; 15;i++){
            threadPool.execute(task.new MyTask(i));
        }
        threadPool.shutdown();
        System.out.println(&quot;end&quot;);
    }
    
        public class MyTask implements Runnable {
        private int taskNo;
        public MyTask(int taskNO){
            this.taskNo = taskNO;
        }
        public void run(){
            System.out.println(&quot;任务：&quot;+taskNo+&quot;正在执行&quot;);
            try {
                Thread.currentThread().sleep(4000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;任务：&quot;+taskNo+&quot;执行执行结束&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;任务：3正在执行
任务：10正在执行
任务：1正在执行
任务：9正在执行
任务：0正在执行
任务：4正在执行
任务：2正在执行
任务：11正在执行
任务：13正在执行
任务：12正在执行
任务：14正在执行
end
任务：1执行执行结束
任务：5正在执行
任务：9执行执行结束
任务：6正在执行
任务：11执行执行结束
任务：7正在执行
任务：3执行执行结束
任务：8正在执行
任务：10执行执行结束
任务：12执行执行结束
任务：2执行执行结束
任务：13执行执行结束
任务：14执行执行结束
任务：0执行执行结束
任务：4执行执行结束
任务：6执行执行结束
任务：5执行执行结束
任务：8执行执行结束
任务：7执行执行结束&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上的范例就是ThreadPoolExecutor的简单应用，首先需要创建一个任务类MyTask ，其次在主方法里创建ThreadPoolExecutor对象，接着用for循环来模拟运行多个线程，然后execute方法执行，最后调用shutdown方法结束。&lt;br/&gt;上面代码的实现和我们往常实现多线程有些区别，我们往常使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread threadA = new Thread（）；
thread.start();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来创建一个线程执行任务，在应用ThreadPoolExecutor时，我们不再自己创建，而是使用线程池为我们创建的线程。&lt;/p&gt;
&lt;p&gt;在创建线程池ThreadPoolExecutor对象时，有很多个构造参数，通过注释我们可以了解到，这些参数就是用来设置线程池的特征的。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三丶从源码来看threadpoolexecutor&quot;&gt;三丶从源码来看ThreadPoolExecutor&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1）ThreadPoolExecutor结构：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadPoolExecutor extends AbstractExecutorService {
    ...
}

public abstract class AbstractExecutorService implements ExecutorService {
    ...
}

public interface ExecutorService extends Executor{
    ...
}

public interface Executor {
    ...
}
//ForkJoinPool 也继承自AbstractExecutorService 
public class ForkJoinPool extends AbstractExecutorService {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;2）线程池处理任务处流程：&lt;/strong&gt;&lt;br/&gt;知道了ThreadPoolExecutor的继承关系后我们来了解一下ThreadPoolExecutor的设计结构和思想，这对我们后面理解ThreadPoolExecutor的源码有很大的帮助：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180416193631124?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzkyNjY5MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;（对队列的判断应该在线程池内部）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的这张图应该就能大概的描述ThreadPoolExecutor的实现了，同时也能够理解ThreadPoolExecutor的构造参数了。&lt;/p&gt;
&lt;p&gt;线程池在创建的时候会设置CorePoolSize，maximumPoolSize，workQueue等几个重要参数，CorePoolSize指的是核心线程池的大小，maximumPoolSize指的是线程池的线程数最大值，workQueue为线程池指定的阻塞队列。&lt;br/&gt;处理流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;主线程执行execute方法，提交任务到线程池，线程池判断核心线程池中的线程是否都在工作，如果不是则创建一个线程来执行新任务，如果都在工作，进入下一步。&lt;/li&gt;
&lt;li&gt;判断工作队列是否已满，如果不满，则将新任务加入到&lt;a href=&quot;https://blog.csdn.net/qq_39266910/article/details/79939581&quot;&gt;阻塞队列&lt;/a&gt;中，如果满了进入下一步。&lt;/li&gt;
&lt;li&gt;判断线程池中线程数是否小于maximumPoolSize，如果小于，创建新的线程来处理新任务，否则交给饱和策略。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;3）源码：&lt;/strong&gt;&lt;br/&gt;接下来我们跟着方法的执行流程来跟源码：&lt;br/&gt;源码从哪里开始跟？当然是从execute方法开始啦，毕竟这个是执行的开端呀（博主跟源码还是喜欢这样，这样慢慢跟下去，不太喜欢直接看构造，字段，方法，等看到了字段属性再跟下去看）。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;3.1 execute：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void execute(Runnable command) {
        //判断任务有效性
        if (command == null)
            throw new NullPointerException();
        //ctl是一个AtomicInteger类型数据
        //private final AtomicInteger ctl = 
        //new AtomicInteger(ctlOf(RUNNING, 0));
        //ctlOf方法下面是Runing代表的值和0的或操作
        //private static int ctlOf(int rs, int wc)
        // { return rs | wc; }
        //private static final int RUNNING = -1 &amp;lt;&amp;lt; COUNT_BITS;
        //COUNT_BITS = Integer.SIZE - 3;
        //所以这个c就是RUNNING值的句柄，额，大动干戈了...
        int c = ctl.get();
        //如果运行的线程数小于corePoolSize
        if (workerCountOf(c) &amp;lt; corePoolSize) {
            //如果线程池成功为command任务创建或分配新的线程
            //addWorker方法boolean参数用来判断是否在核心池加任务
            if (addWorker(command, true))
                //退出程序
                return;
            //更新Runing值
            c = ctl.get();
        }
        //private static boolean isRunning(int c) 
        //{return c &amp;lt; SHUTDOWN;}
        //SHUTDOWN值为0，如果小于这个值，表示运行停止
        //offer用来判断任务是否成功入队
        if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
            //再次获取RUNNING值
            int recheck = ctl.get();
            //如果command在任务队列中，remove方法将其移除
            if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
                //将command任务交给饱和策略
                reject(command);
            //如果程序遭到shutdown或shutdownNow方法停止，
            //那么这时会检测到无线程运行，这个时候不要添加任务处理
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //如果入队失败，那么交给饱和策略
        else if (!addWorker(command, false))
            reject(command);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相信这个方法已经不要我再多作什么赘述了吧（捂嘴笑.jpg）。&lt;br/&gt;这里我们再将ThreadPoolExecutor的一些字段列一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    private static final int COUNT_BITS = Integer.SIZE - 3;
    private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
    private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
    private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
    private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
    private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;

    // 这几个方法我也将它们看做字段了
    private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }
    private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }
    private static int ctlOf(int rs, int wc) { return rs | wc; }
    //总之，为了效率，源码的位运算常见的跟喝茶似的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有对照源码看博文的小伙伴可能会有很多疑问，相信你打开源码再看我的方法注释会更好的理解！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;3.2 addWorker：&lt;/strong&gt;&lt;br/&gt;看了上面的execute方法，相信我们可以看出来addWorker方法也算是核心了，addWorker方法担任了所有的将任务交给线程的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   //addWorker方法两个参数，第一个参数不用说，第二个之前我们说过
   //它是用来区分任务是将送达的地方（是否是核心线程池）
   private boolean addWorker(Runnable firstTask, boolean core) {
        /*说明：其实retry就是一个标记，标记程序跳出循环的时候从哪里开始执行，
        *功能类似于goto。retry一般都是跟随者for循环出现，第一个retry的下面
        *一行就是for循环，而且第二个retry的前面一般是 continue或是 break。*/
        retry:
        for (;;) {
            //获取RUNNING
            int c = ctl.get();
            //运行状态
            int rs = runStateOf(c);
            // Check if queue empty only if necessary.
            if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
                ! (rs == SHUTDOWN &amp;amp;&amp;amp;
                   firstTask == null &amp;amp;&amp;amp;
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                //下面可以看出Boolean类型参数core 作用了
                if (wc &amp;gt;= CAPACITY ||
                    wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
        //这里有个疑问，如果上面一直死循环，即使通过break跳出循环，那么根据
        //Retry特性，岂不是还要执行死循环，然后往复循环？
        //哦，知道了，当不满足上面的各种条件的时候
        //不就不用执行上面的代码了吗，这个...思维僵化了...

        boolean workerStarted = false;
        boolean workerAdded = false;
        
        Worker w = null;
        try {
            //从这里我们可以看出对线程的包装
            w = new Worker(firstTask);
            //这里创建了线程
            final Thread t = w.thread;
            //有效性判断
            if (t != null) {
                //这里要加锁了
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs &amp;lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        //workers为HashSet
                        //是用来存放被包装过的工作线程
                        workers.add(w);
                        int s = workers.size();
                        if (s &amp;gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                //当添加成功后就要启动了
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码我们可以发现，当任务交给线程执行的时候并不是直接的交给线程，线程池创建线程后会将线程封装成工作线程Worker，Worker工作完后还会继续去工作队列中获取任务来执行。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;3.3 Worker类：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable{
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以从下面这段Worker类的Run方法中窥到这一点：&lt;br/&gt;&lt;strong&gt;jdk1.8和1.7有很大的改动，有兴趣的朋友可以去对比一下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public void run() {
            runWorker(this);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;   final void runWorker(Worker w) {
       Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            //下面这行是重点
            //task不为空或者getTask（获取队列中任务）不为空的时候
            //对这个任务加锁进行处理
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &amp;amp;&amp;amp;
                      runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        //这里运行
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;3.4 submit：&lt;/strong&gt;&lt;br/&gt;既然讲到了execute方法，怎么能少了submit方法，当我们执行一个任务的时候，有的时候需要返回值，这个时候我们就需要用到submit方法了。&lt;br/&gt;其实我们通过源码可以发现submit方法内部也是调用execute方法，当调用submit方法的时候我们可以收到一个Future对象，我们可以调用Future对象的get方法来获得它的返回值。&lt;br/&gt;关于Future的知识，可以参考：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/cz123/p/7693064.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/cz123/p/7693064.html&lt;/a&gt;&lt;br/&gt;注：我在ThreadPoolExecutor中找submit方法的时候没找到，然后才发现ThreadPoolExecutor是直接继承他的父类AbstractExecutorService的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public Future&amp;lt;?&amp;gt; submit(Runnable task) {
        //验证任务有效性
        if (task == null) throw new NullPointerException();
        
        RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码我们可以看出将任务包装成一个RunnableFuture对象，然后将这个对象用execute执行。&lt;br/&gt;如果看过我上面推荐的博文，读者应该知道Callable和和Runnable的区别了：是否有返回值。&lt;/p&gt;
&lt;p&gt;关于这个Future的结构我们来理一下：&lt;br/&gt;&lt;strong&gt;FutureTask→（实现）RunnableFuture→（继承）Runnable，Future&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以看看newTaskFor方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&amp;lt;T&amp;gt;(runnable, value);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的底层其实就是new一个FutureTask对象而已，所以FutureTask才是真正的实现类哦！&lt;br/&gt;关于FutureTask的实现，我们会专门抽出时间去整理！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;3.5shutdown和shutdownNow：&lt;/strong&gt;&lt;br/&gt;我们可以通过shutdown和shutdownNow方法来关闭线程池，shutdown方法通过遍历工作线程HashSet，将运行状态（ctl）这设置为SHUTDOWN并调用interrupt方法中断所有线程，shutdownNow同样遍历所有线程，将将运行状态（ctl）这设置为STOP，并调用interrupt方法中断所有线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public void shutdown() {
        //需要加锁中断
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            //保证线程可中断
            checkShutdownAccess();
            //更改运行状态，底层为原子操作
            advanceRunState(SHUTDOWN);
            //这个方法会对全局变量workers（HashSet）进行遍历
            //对这个里的所有工作线程调用interrupt方法
            interruptIdleWorkers();
            //一个空方法
            //官方是这样说的：
            //used by ScheduledThreadPoolExecutor
            //to cancel delayed tasks.
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public List&amp;lt;Runnable&amp;gt; shutdownNow() {
        List&amp;lt;Runnable&amp;gt; tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            //保证线程可中断
            checkShutdownAccess();
            //ctl设置为STOP
            advanceRunState(STOP);
            interruptWorkers();
            //这个就是两个方法区别
            //这个方法将工作队列中的任务（还未执行）
            //取出放到list中
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
        return tasks;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.6 RejectedExecutionHandler：&lt;/strong&gt;&lt;br/&gt;最后我们来看看这个饱和策略，当线程和队列都满了过后，表明这个线程池处于饱和的状态，那么我们必须要采取一定的措施来处理这些任务，在默认的情况下我们会执行AbortPolicy，表示无法处理任务，抛出异常。&lt;br/&gt;同时JDK提供了以下的几种策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AbortPolicy：直接抛出异常&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy：用调用者的线程来执行任务&lt;/li&gt;
&lt;li&gt;DiscardOldestPolicy：丢弃队列里最近的任务，并执行这个任务&lt;/li&gt;
&lt;li&gt;DiscardPolicy:丢弃，不处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们也可以实现RejectedExecutionHandler接口进行自定义操作，例如有的时候我们需要将这种异常记录到日志当中，这个时候我们就需要自定义了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：通过对线程池的学习，自己又了解到不少自己不知道的知识，例如Future接口等，也通过学习，发现一些容器和锁真的很常见，自己平时应用的时候很少碰见，当然，大师的编程水平也值得我们这些小民学习！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 13:07:00 +0000</pubDate>
<dc:creator>MindMrWang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MindMrWang/p/8870033.html</dc:identifier>
</item>
<item>
<title>Java 内部类的意义及应用 - Single_Yam</title>
<link>http://www.cnblogs.com/yangming1996/p/8869081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangming1996/p/8869081.html</guid>
<description>&lt;p&gt;众所周知，我们的 C++ 程序语言是多继承制的，而多继承明显的好处就是，相对而言只需要写较少的代码即可完成一个类的定义，因为我们可以通过继承其它类来获取别人的实现。&lt;/p&gt;
&lt;p&gt;但是，它也有一个致命性的缺陷，容易出现「钻石继承结构」，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/16/CexocQ.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C 和 D 继承自 A，并得到 A 的 name 属性，那么如果有一个类 B 多继承自 C 和 D，请问 D 该如何取舍这两个相同的属性字段？&lt;/p&gt;
&lt;p&gt;一般这种情况下，编译器会提示错误，以警示程序员修改代码。当然，C++ 通过 virtual 关键字以虚拟继承的方式解决了这个问题，具体细节大家可以自行参照 C++ 的语法进行了解。&lt;/p&gt;
&lt;p&gt;但是，Java 从一开始就觉得 C++ 的多继承会是一个「麻烦」，所以 Java 是单根继承机制，不允许多继承。网上看到有人用一个词评论了 sun 公司的这种做法，觉得挺贴切的，叫「&lt;strong&gt;矫枉过正&lt;/strong&gt;」，多继承也不是一无是处，在一些需要大量复用代码的情境下，也不失为一个好的解决方式。&lt;/p&gt;
&lt;p&gt;所以，jdk 推出了「内部类」的概念，当然，内部类不仅仅弥补了 Java 不能多继承的一个不足，通过将一个类定义在另一个类的内部，也可以有效的隐藏该类的可见性，等等。&lt;/p&gt;
&lt;h3 id=&quot;接口-内部类-多继承&quot;&gt;接口 + 内部类 = 多继承&lt;/h3&gt;
&lt;p&gt;在这之前，Java 的继承机制主要由接口和单根继承实现，通过实现多个接口里的方法，看似能够实现多继承，但是并不总是高效的，因为一旦我们继承了一个接口就必然要实现它内部定义的所有方法。&lt;/p&gt;
&lt;p&gt;现在我们可以通过内部类多次继承某个具体类或者接口，省去一些不必要的实现动作。只能说 Java 的内部类完善了它的多继承机制，而不是主要实现，因为内部类终究是一种破坏封装性的设计，除非有很强的把控能力，&lt;strong&gt;否则还是越少用越好&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们看一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Father {
    public String powerFul = &quot;市长&quot;;
}

public class Mother {
    public String wealthy = &quot;一百万&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class Son {
    class Extends_Father extends Father{
    }

    class Extends_Mother extends Mother{
    }

    public void sayHello(){
        String father = new Extends_Father().powerFul;
        String mother = new Extends_Mother().wealthy;
        System.out.println(&quot;my father is:&quot; + father + &quot;my mother has:&quot; + mother);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，我们的 Son 类是不可能同时继承 Father 和 Mother 的，但是我们却可以通过在其内部定义内部类继承了 Father 和 Mother，必要的情况下，我们还能够重写继承而来的各个类的属性或者方法。&lt;/p&gt;
&lt;p&gt;这就是典型的一种通过内部类实现多继承的实现方式，但是同时你也会发现，单单从 Son 来外表看，你根本不知道它内部多继承了 Father 和 Mother，从而往往会给我们带来一些错觉。所以你看，内部类并不绝对是一个好东西，它破坏了封装性，用的不好反而会适得其反，让你的程序一团糟，所以谨慎！&lt;/p&gt;
&lt;p&gt;当然，并不是贬低它的价值，有些情况下它也能给你一种「四两拨千斤」的感觉，省去很多麻烦。下面我们看看几种不同的内部类类型。&lt;/p&gt;
&lt;h3 id=&quot;静态内部类&quot;&gt;静态内部类&lt;/h3&gt;
&lt;p&gt;静态内部类通过对定义在外部类内部的类加上关键字「static」进行修饰，以标示一个静态内部类，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class OuterClass {
    private static String name = &quot;hello world&quot;;
    private int age = 23;

    public static class MyInnerClass{
        private static String myName = &quot;single&quot;;
        private int myAge = 23;

        public void sayHello(){
            System.out.println(name);
            //编译器报错提示：不可访问的字段 age
            System.out.println(age);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，MyInnnerClass 作为一个内部类，它可以定义自己的静态属性，静态方法，实例属性，实例方法，和普通类一样。&lt;/p&gt;
&lt;p&gt;此外，由于 MyInnerClass 作为一个内部类，它对于外部类 OuterClass 中部分成员也是可见的，但并全部可见，不同类型的内部类可见的外部类成员不尽相同，例如我们的静态内部类对于外部类的以下成员时可见的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态属性&lt;/li&gt;
&lt;li&gt;静态方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，我们上述的例子中，外部类 OuterClass 的实例属性 age 对于静态内部类 MyInnerClass 是不可见的。&lt;/p&gt;
&lt;p&gt;那么 Java 是如何做到在一个类的内部定义另一个类的呢？&lt;/p&gt;
&lt;p&gt;实际上编译器在编译我们的外部类的时候，会扫描其内部是否还存在其他类型的定义，如果有那么会「搜集」这些类的代码，并按照某种特殊名称规则单独编译这些类。正如我们上述的 MyInnerClass 内部类会被单独编译成 OuterClass$MyInnerClass.class 文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/17/Cm2qpT.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，这里的特殊命名规则其实就是：&lt;strong&gt;外部类名 + $ + 内部类名&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么，既然内部类会被单独编译出来，那它如何保持与外部类的联系呢，我们反编译一下字节码文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/17/CmRCh6.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/17/CmRi9K.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于静态内部类内部只能访问它的外部内的静态成员，而对于访问权限可见的情况下，这两个类本质上毫无关联，但如果像我们此例中的外部类属性 name 而言，它本身被修饰为 private，不可见于外部的任何类。&lt;/p&gt;
&lt;p&gt;但是对于某个外部类的内部类而言，即便是被修饰为 private 的成员，它应当也是可见于内部类的任意位置的。&lt;/p&gt;
&lt;p&gt;所以我们的编译器「偷偷的」做了一件事情，为被修饰为 private 的静态字段 name 提供一个包范围可见的静态方法，返回对 name 的引用，正如我们这里的方法：&lt;strong&gt;access$000&lt;/strong&gt; 一样。&lt;/p&gt;
&lt;p&gt;你当然也可以猜测出，如果是修改 name 值的操作，想必也会对应一个这样的方法用于设置私有成员的属性值。&lt;/p&gt;
&lt;p&gt;如果你想要在外部直接创建一个静态内部类的实例，也是被允许的。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args){
    //创建静态内部类实例
    OuterClass.MyInnerClass innerClass = new OuterClass.MyInnerClass();
    innerClass.sayHello();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，这样的操作一般也不被推荐，因为一个内部类既然被定义在某个外围类的内部，那它一定是为这个外围类服务的，而你从外部越过外围类而单独创建内部类的实现显然是不符合面向对象设计思想的。&lt;/p&gt;
&lt;p&gt;静态内部类的应用场景其实还是很多的，但有一个基本的设计准则是，静态内部类不需要依赖外围类的实例，独立于外围类，为外围类提供服务。&lt;/p&gt;
&lt;p&gt;例如我们 Integer 类中的 IntegerCache 就是一个静态的内部类，它不需要访问外围类中任何成员，却通过内部定义的一些属性和方法为外围类提供缓存服务。&lt;/p&gt;
&lt;h3 id=&quot;成员内部类&quot;&gt;成员内部类&lt;/h3&gt;
&lt;p&gt;成员内部类不使用「static」关键字修饰，但却与「静态内部类」有着截然不同的特性。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class OuterClass {
    private static String tel = &quot;23434324&quot;;
    private int age = 23;

    public class MyInnerClass{
        //编译不通过，非静态的内部类是不允许拥有静态的属性和方法的
        private static String name;
        private String name2 = &quot;hello&quot;;

        public void sayHello(){
            System.out.println(tel);
            System.out.println(age);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成员内部类的实例创建需要依赖外围类，也就是没有外围类实例就不会有内部类实例，外围类的静态或非静态成员对于成员内部类而言全部可见。&lt;/p&gt;
&lt;p&gt;但是成员内部类之中不允许定义静态成员，原因也很简单，假如允许定义静态成员，那么我们下面这条语句必然是可行的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(OuterClass.MyInnerClass.name);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是我们说，既然成员内部类必须关联一个外围类实例，那么这种不需要依赖外围类实例即可操作内部类的方式是不是有点违背设计了呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;于是 Java 干脆不允许成员内部类中定义静态的成员。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，如果你想要从外部直接创建一个成员内部类的实例，你可以这样做：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args){
    OuterClass outerClass = new OuterClass();
    OuterClass.MyInnerClass myInnerClass = outerClass.new MyInnerClass();
    myInnerClass.sayHello();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，Java 并不推荐这样使用内部类，内部类更适合作为一种工具提供给它的外围类。&lt;/p&gt;
&lt;p&gt;接着，我们看看成员内部类的实现原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/17/CmqLIU.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内部类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/17/CmqXiF.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先看内部类的构造器，实际上每当实例化一个内部类实例的时候，都会传入一个外围类实例引用作为构造参数，内部类保存这个实例引用并通过它访问该引用所对应的外围类成员属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成员内部类与静态内部类最大的不同点就在于，成员内部类高度依赖一个外围类实例，并且不允许定义任何静态成员，而静态内部类与外围类趋于独立。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;局部内部类&quot;&gt;局部内部类&lt;/h3&gt;
&lt;p&gt;局部内部类就是在代码块中定义一个类，最典型的应用是在方法中定义一个类。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Method {
    private static String name;
    private int age;

    public void hello(){
        class MyInnerClass{
            public void sayHello(){
                System.out.println(name);
                System.out.println(age);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;局部内部类中是可以访问外围类的相关属性或者方法的，但是往往限制于外围的方法。如果方法是实例方法，那么方法内的内部类可以访问外围类的任意成员，如果方法是静态方法，那么方法内部的内部类只能访问外围类的静态成员。&lt;/p&gt;
&lt;p&gt;考虑另一种情况，当方法具有参数或方法内定义了局部变量，那么我们的局部内部类还能够访问到它们吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Method2 {
    public void hello(String name){
        int age = 23;
        class MyInnerClass{
            public void sayHello(){
                System.out.println(name);
                System.out.println(age);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;答案是能的，我们看一下它的反编译代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/17/CmzSQe.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的套路，通过构造器传入外围类实例以实现内部类对外围类成员的访问。除此之外，如果外围类的方法中有参数或者定义了局部变量，编译器会搜集并在构建局部内部类实例的时候全部传入。&lt;/p&gt;
&lt;p&gt;但是，这里有一个坑大家需要注意一下。虽然这里的 name 和 age 并没有被声明为 final，但是程序是不允许你修改它们的值的。也就是说，它们被默认添加了 final 修饰符。&lt;/p&gt;
&lt;p&gt;为什么这么做？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从我们反编译的结果来看，局部内部类中只保存的这些变量的数值，而不是内存地址，并且也不允许更改，那么如果外部的这些变量可更改，将直接导致每个新建内部类的实例具有不同的属性值，所以直接给声明为 final，不允许你修改。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（这个特性以前貌似是需要程序员手动添加 final 进行修饰的，现在好像是默认的，害我还郁闷了半天，为什么不加 final 也能通过编译。。后来手动改它的值，发现不能改）&lt;/p&gt;
&lt;h3 id=&quot;匿名内部类&quot;&gt;匿名内部类&lt;/h3&gt;
&lt;p&gt;匿名内部类，顾名思义，是没有名字的类，那么既然它没有名字，自然也就无法显式的创建出其实例对象了，所以匿名内部类适合那种只使用一次的情境，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/17/CnCYNR.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是一个典型的匿名内部类的使用，它等效于下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyObj extends Object{
    @Override 
    public String toString(){
        return &quot;hello world&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args){
    Object obj = new MyObj();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了一个只使用一次的类而单独创建一个 .java 文件，是否有些浪费和繁琐？&lt;/p&gt;
&lt;p&gt;在我看来，匿名内部类最大的好处就在于能够&lt;strong&gt;简化代码块&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;匿名类的基本使用语法格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new 父类/接口{
    //匿名类的实现
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;匿名内部类往往是对某个父类或者接口的继承与实现，我们再看一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args){
    Date date = new Date(123313){
        @Override
        public String toString(){
            return &quot;hello&quot;;
        }
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这里定义了一个匿名内部类，实现了父类 Date，并重写了其 toString 方法。我们反编译一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/04/17/CnAItH.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，我们匿名内部类的构造器会调用相对应的父类构造器进行父类成员的初始化动作。而匿名内部类的本质也就这样，只是你看不到名字而已，其实编译器还是会为它生成单独的一份 Class 文件并拥有唯一的类名的。&lt;/p&gt;
&lt;p&gt;其实你从编译器的层面上看，匿名内部类和一个实际的类型相差无几，它也能继承某个类并重写其中方法，实现某个接口的所有方法等。&lt;strong&gt;最吸引人的可能就是它无需单独创建类文件的简便性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说句实话，内部类在实际的开发中并不常见，甚至被某些公司抵制使用，因为一旦你使用的不好很可能导致整个项目代码混乱不堪，不易于排查错误。但是如果你用的好的话，往往会给你有一种「巧劲」，你就比如我们的 jdk 源码，几乎每个类中都定义有一至多个内部类，并且相互之间不存在问题，很高效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，内部类的使用还是适情况，适人而定，但是看的懂内部类却是你应当具有的能力，这也是本篇文章的目标。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;文章中的所有代码、图片、文件都云存储在我的 GitHub 上：&lt;/p&gt;
&lt;p&gt;(&lt;a href=&quot;https://github.com/SingleYam/overview_java&quot; class=&quot;uri&quot;&gt;https://github.com/SingleYam/overview_java&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号：扑在代码上的高尔基，所有文章都将同步在公众号上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180305113628126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 11:24:00 +0000</pubDate>
<dc:creator>Single_Yam</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangming1996/p/8869081.html</dc:identifier>
</item>
<item>
<title>容器进化史 - bakari</title>
<link>http://www.cnblogs.com/bakari/p/8868850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bakari/p/8868850.html</guid>
<description>&lt;p&gt;和虚拟机一样，容器技术也是一种资源隔离的虚拟化技术。我们追溯它的历史，会发现它的技术雏形早已有之。&lt;/p&gt;
&lt;h2 id=&quot;容器简史&quot;&gt;容器简史&lt;/h2&gt;
&lt;p&gt;容器概念始于 1979 年提出的 UNIX chroot，它是一个 UNIX 操作系统的系统调用，将一个进程及其子进程的根目录改变到文件系统中的一个新位置，让这些进程只能访问到这个新的位置，从而达到了进程隔离的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/431521/201804/431521-20180417190705758-685265443.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2000 年的时候 FreeBSD 开发了一个类似于 chroot 的容器技术 Jails，这是最早期，也是功能最多的容器技术。Jails 英译过来是监狱的意思，这个“监狱”（用沙盒更为准确）包含了文件系统、用户、网络、进程等的隔离。&lt;/p&gt;
&lt;p&gt;2001 Linux 也发布自己的容器技术 Linux VServer，2004 Solaris 也发布了 Solaris Containers，两者都将资源进行划分，形成一个个 zones，又叫做虚拟服务器。&lt;/p&gt;
&lt;p&gt;2005 年推出 OpenVZ，它通过对 Linux 内核进行补丁来提供虚拟化的支持，每个 OpenVZ 容器完整支持了文件系统、用户及用户组、进程、网络、设备和 IPC 对象的隔离。&lt;/p&gt;
&lt;p&gt;2007 年 Google 实现了 Control Groups( cgroups )，并加入到 Linux 内核中，这是划时代的，为后期容器的资源配额提供了技术保障。&lt;/p&gt;
&lt;p&gt;2008 年基于 cgroups 和 linux namespace 推出了第一个最为完善的 Linux 容器 LXC。&lt;/p&gt;
&lt;p&gt;2013 年推出到现在为止最为流行和使用最广泛的容器 Docker，相比其他早期的容器技术，Docker 引入了一整套容器管理的生态系统，包括分层的镜像模型，容器注册库，友好的 Rest API。&lt;/p&gt;
&lt;p&gt;2014 年 CoreOS 也推出了一个类似于 Docker 的容器 Rocket，CoreOS 一个更加轻量级的 Linux 操作系统，在安全性上比 Docker 更严格。&lt;/p&gt;
&lt;p&gt;2016 年微软也在 Windows 上提供了容器的支持，Docker 可以以原生方式运行在 Windows 上，而不是需要使用 Linux 虚拟机。&lt;/p&gt;
&lt;p&gt;基本上到这个时间节点，容器技术就已经很成熟了，再往后就是容器云的发展，由此也衍生出多种容器云的平台管理技术，其中以 kubernetes 最为出众，有了这样一些细粒度的容器集群管理技术，也为微服务的发展奠定了基石。因此，对于未来来说，应用的微服务化是一个较大的趋势。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要容器&quot;&gt;为什么需要容器&lt;/h2&gt;
&lt;p&gt;其一，这是技术演进的一种创新结果，其二，这是人们追求高效生产活动的一种工具。&lt;/p&gt;
&lt;p&gt;随着软件开发的发展，相比于早期的集中式应用部署方式，现在的应用基本都是采用分布式的部署方式，一个应用可能包含多种服务或多个模块，因此多种服务可能部署在多种环境中，如虚拟服务器、公有云、私有云等，由于多种服务之间存在一些依赖关系，所以可能存在应用在运行过程中的动态迁移问题，那这时如何保证不同服务在不同环境中都能平滑的适配，不需要根据环境的不同而去进行相应的定制，就显得尤为重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/431521/201804/431521-20180417190724392-1614965766.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就像货物的运输问题一样，如何将不同的货物放在不同的运输机器上，减少因货物的不同而频繁进行货物的装载和卸载，浪费大量的人力物力。&lt;/p&gt;
&lt;p&gt;为此人们发明了集装箱，将货物根据尺寸形状等的不同，用不同规格的集装箱装载，然后再放到运输机上运输，由于集装箱密封，只有货物到达目的地才需拆封，在运输过程能够再不同运输机上平滑过渡，所以避免了资源的浪费。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/431521/201804/431521-20180417190745639-522084984.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此集装箱被誉为是运输业与世界贸易最重要的发明。&lt;/p&gt;
&lt;p&gt;Docker 容器的思想就是采用集装箱思想，为应用提供了一个基于容器的标准化运输系统。Docker 可以将任何应用及其依赖打包成一个轻量级、可移植、自包含的容器。容器可以运行在几乎所有的操作系统上。这样容器就可以跑在任何环境中，因此才有了那句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Build Once, Run Anywhere&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种集装箱的思想我们也能从 Docker 的 Logo 中看出来，这不就是一堆集装箱吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/431521/201804/431521-20180417190812020-47235471.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：对云计算感兴趣的小伙伴可以关注我的微信公众号：aCloudDeveloper，专注云计算领域，坚持分享干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/431521/201804/431521-20180417190957867-965323687.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reference:&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/CloudMan6/p/6751516.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/CloudMan6/p/6751516.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Apr 2018 11:10:00 +0000</pubDate>
<dc:creator>bakari</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bakari/p/8868850.html</dc:identifier>
</item>
</channel>
</rss>