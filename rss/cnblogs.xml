<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用EF的三种方式（SqlServer数据库和Oracle数据库） - 从未太晚</title>
<link>http://www.cnblogs.com/kongsq/p/9785013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kongsq/p/9785013.html</guid>
<description>&lt;p&gt;SqlServer数据库&lt;/p&gt;
&lt;p&gt;1.DB First&lt;/p&gt;
&lt;p&gt;现有DB，生成edmx文件&lt;/p&gt;
&lt;p&gt;贴一下生成的model&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;auto-generated&amp;gt;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     此代码已从模板生成。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     手动更改此文件可能导致应用程序出现意外的行为。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     如果重新生成代码，将覆盖对此文件的手动更改。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;/auto-generated&amp;gt;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------------------------&lt;/span&gt;

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Ruanmou.EFDBFirst
{
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JD_Commodity_001
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Nullable&amp;lt;&lt;span&gt;long&lt;/span&gt;&amp;gt; ProductId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Nullable&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; CategoryId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Nullable&amp;lt;&lt;span&gt;decimal&lt;/span&gt;&amp;gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ImageUrl { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.Code First&lt;/p&gt;
&lt;p&gt;有数据库,从数据库获得model，就是这个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/527658/201810/527658-20181014013918390-1391531759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;贴一下生成的Model，和DB First的不太一样，长度attribute加上了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    [Table(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JD_Commodity_001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 特性&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JDCommodity001
    {
        [Key]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;? ProductId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[ForeignKey]&lt;/span&gt;
        [Column(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CategoryId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;? ClassId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [StringLength(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt;? Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [StringLength(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [StringLength(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ImageUrl { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果数据库字段或表名和model的不一样(比如想去掉下划线)可以有3种方式，方式1见上图，Model上或属性上加attribute&lt;/p&gt;
&lt;p&gt;方式2在 OnModelCreating 里添加映射，code first 的 OnModelCreating 和DB first的不一样， db 的什么也没写，截图下code first的OnModelCreating &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/527658/201810/527658-20181014014919674-288826604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码，启动时可以完成数据库和代码结构的同步&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(DbModelBuilder modelBuilder)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动时可以完成数据库和代码结构的同步
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new CreateDatabaseIfNotExists&amp;lt;codeFirstDbContext&amp;gt;();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认  不存在就创建
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new DropCreateDatabaseAlways&amp;lt;codeFirstDbContext&amp;gt;();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次都删除重建
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new DropCreateDatabaseIfModelChanges&amp;lt;codeFirstDbContext&amp;gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Database.SetInitializer&amp;lt;codeFirstDbContext&amp;gt;(new DropCreateDatabaseIfModelChanges&amp;lt;codeFirstDbContext&amp;gt;());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对不起  数据都没了。。   测试/快速部署  其实这里还可以完成数据初始化
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请一定小心&lt;/span&gt;
&lt;span&gt;
            modelBuilder.Entity&lt;/span&gt;&amp;lt;JDCommodity002&amp;gt;&lt;span&gt;()
                .ToTable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JD_Commodity_002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .Property(c &lt;/span&gt;=&amp;gt;&lt;span&gt; c.ClassId)
                .HasColumnName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CategoryId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2 链式API&lt;/span&gt;
&lt;span&gt;
            modelBuilder.Configurations.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; JDCommodity003Mapping());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3 映射文件&lt;/span&gt;
&lt;span&gt;
            modelBuilder.Entity&lt;/span&gt;&amp;lt;Category&amp;gt;&lt;span&gt;()
                .Property(e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.Code)
                .IsUnicode(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方式3 Mapping 的方式，写个Mapping 文件，上面的代码有，据说没什么人用&lt;/p&gt;

&lt;p&gt;Oracle数据库&lt;/p&gt;
&lt;p&gt;可能引用这个就可以用吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/527658/201810/527658-20181014015703507-1335985660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DB first ， OnModelCreating 什么也没写 model还是没有长度的attribute&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(DbModelBuilder modelBuilder)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnintentionalCodeFirstException();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是EF5&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;entityFramework&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework,&lt;br/&gt;Version=5.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;&lt;/span&gt;&lt;span&gt; requirePermission&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模型管理器管理外键，因为名字不一样看着不开心，全改成FK 开头的了用Powerdesigner改的，获取的更新，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/527658/201810/527658-20181014020922372-378160648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 18:13:00 +0000</pubDate>
<dc:creator>从未太晚</dc:creator>
<og:description>SqlServer数据库 1.DB First 现有DB，生成edmx文件 贴一下生成的model 2.Code First 有数据库,从数据库获得model，就是这个 贴一下生成的Model，和DB</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kongsq/p/9785013.html</dc:identifier>
</item>
<item>
<title>cd：切换目录 - 七月流星雨</title>
<link>http://www.cnblogs.com/scajy/p/9782274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/scajy/p/9782274.html</guid>
<description>&lt;p&gt;cd命令&lt;/p&gt;
&lt;blockquote readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;span&gt;　1、命令详解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　【功能说明】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　cd命令是“change directory”中每个单词的首字母缩写，其功能是从当前工作目录切换到指定的工作目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　【语法格式】&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;　　　　　　cd    [option]   [dir]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　cd    [选项]     [目录]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　　　　说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;注意cd命令以及后面的选项和目录，每个元素之间都至少要一个空格。&lt;/li&gt;
&lt;li&gt;cd命令后面的选项和目录等参数都有可以省略。默认情况下，单独执行cd命令，可切换到当前登录用户的家目录（由系统环境变量HOME定义）。&lt;/li&gt;
&lt;li&gt;cd是bash shell的内置命令，查看该命令对应的系统帮助需要使用help cd。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　　　【参数说明】&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;cd命令的参数选项及说明&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;参数选项&lt;/td&gt;
&lt;td&gt;解释说明（带“Δ”的为重点）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;-P&lt;/td&gt;
&lt;td&gt;     如果切换的目标目录是一个软链接，则会直接切换到软链接指向的真正物理目标目录，和pwd命令的-P选项功能类似，该参数不常用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;-L&lt;/td&gt;
&lt;td&gt;　  功能与-P相反，如果切换的目标目录是一个软链接，则直接切换到软链接所在的目录，和pwd命令的-L选项功能类似，该参数不常用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt; -&lt;/td&gt;
&lt;td&gt;　  当只使用“-”选项时，将会从当前目录切换到系统环境变量“OLDPWD” 对应值的目录路径，即当前用户上一次所在的目录路径   Δ&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt; ~&lt;/td&gt;
&lt;td&gt;　  当只使用“~”选项时，将会从当前目录切换到系统环境变量“HOME” 对应值的目录路径，即当前用户的家目录所在的路径         Δ&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt; ..&lt;/td&gt;
&lt;td&gt;　 当只使用“..”选项时，将会从当前目录切换到当前目录的上一级目录所在的路径    Δ&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;   2、使用范例&lt;/p&gt;
&lt;p&gt;　　范例1：进入系统/etc目录（cd  /etc）&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;　　　　[root@1-230 ~]# pwd&lt;br/&gt;　　　　/root　　　　　　　　　　#在linux系统中，每个用户都有自己的家目录，默认情况下，用户登录系统后会进入自己的家目录。root用户的家目录是/root，普通用户的家目录默认是/home/用户名/&lt;br/&gt;　　　　[root@1-230 ~]# cd /etc/             #切换到/etc/目录&lt;br/&gt;　　　　[root@1-230 etc]# pwd&lt;br/&gt;　　　　/etc　　　　　　　　　　　　　　　 #此时已经进入/etc目录了&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　范例2：切换到当前目录的上一级目录（cd  ..）&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;　　　　[root@1-230 etc]# cd /usr/local/src/                    #切换到/usr/local/src目录了&lt;br/&gt;　　　　[root@1-230 src]# pwd&lt;br/&gt;　　　　/usr/local/src&lt;br/&gt;　　　　[root@1-230 src]# cd ..　　　　　　　　　　　　   #“cd  ..”等同于上一级目录名，也可以写成“../”。&lt;br/&gt;　　　　[root@1-230 local]# pwd&lt;br/&gt;　　　　/usr/local　　　　　　　　　　　　　　　　　　　　#此时切换到了/usr/local&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　范例3：进入当前目录的父目录（cd ../../）&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;　　　　[root@1-230 ~]# cd /usr/local/src/&lt;br/&gt;　　　　[root@1-230 src]# pwd&lt;br/&gt;　　　　/usr/local/src&lt;br/&gt;　　　　[root@1-230 src]# cd ../../　　　　#退到当前目录的上两级目录，即可到“/usr”目录&lt;br/&gt;　　　　[root@1-230 usr]# pwd&lt;br/&gt;　　　　/usr&lt;/p&gt;
&lt;p&gt;　　　　提示：&lt;/p&gt;
&lt;p&gt;　　　　　　只要目录有足够多的层次，可以一直这样继续下去“cd  ../../../” ，知道退到“/” 为止。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　范例4：返回当前用户上一次所在的目录（cd  -）。&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;　　　　[root@1-230 /]# cd /usr/local/src/ &lt;br/&gt;　　　　[root@1-230 src]# pwd&lt;br/&gt;　　　　/usr/local/src&lt;br/&gt;　　　　[root@1-230 src]# cd       #cd命令不接收任何参数时，从环境变量HOME获取路径名，即切换到当前用户家目录。&lt;/p&gt;
&lt;p&gt;　　　　[root@1-230 ~]# pwd　　#当前用户的工作路径为/root&lt;br/&gt;　　　　/root&lt;br/&gt;　　　　[root@1-230 ~]# cd -　　#执行“cd  -”时，cd将根据环境变量OLDPWD的对应值获取路径名。&lt;br/&gt;　　　　/usr/local/src　　　　　　 #即切换到了当前用户上一次的工作路径“/usr/local/src”&lt;br/&gt;　　　　[root@1-230 src]# pwd&lt;br/&gt;　　　　/usr/local/src　　　　&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;　　范例5：进入当前用户的家目录（cd  ~）&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;　　　　[root@1-230 src]# pwd&lt;br/&gt;　　　　/usr/local/src&lt;br/&gt;　　　　[root@1-230 src]# cd ~　　　　#“~”键盘左上角Esc建下方的波浪符号，代表家目录。&lt;br/&gt;　　　　[root@1-230 ~]# pwd&lt;br/&gt;　　　　/root　　　　　　　　　　　　　  #切换到当前用户的家目录了。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 13 Oct 2018 16:07:00 +0000</pubDate>
<dc:creator>七月流星雨</dc:creator>
<og:description>cd命令 1、命令详解 【功能说明】 cd命令是“change directory”中每个单词的首字母缩写，其功能是从当前工作目录切换到指定的工作目录。 【语法格式】 cd [option] [dir</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/scajy/p/9782274.html</dc:identifier>
</item>
<item>
<title>Java线程池中submit()和execute之间的区别？ - 西北野狼</title>
<link>http://www.cnblogs.com/androidsuperman/p/9784821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/androidsuperman/p/9784821.html</guid>
<description>&lt;p&gt;一：&lt;br/&gt;submit()方法，可以提供Future &amp;lt; T &amp;gt; 类型的返回值。&lt;br/&gt;executor()方法，无返回值。&lt;/p&gt;
&lt;p&gt;execute无返回值&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();//抛掉异常
        int c = ctl.get();
        if (workerCountOf(c) &amp;lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;submit有Future返回值 :&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public Future&amp;lt;?&amp;gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;二：&lt;br/&gt;excute方法会抛出异常。&lt;br/&gt;sumbit方法不会抛出异常。除非你调用Future.get()。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;三：&lt;br/&gt;excute入参Runnable&lt;br/&gt;submit入参可以为Callable&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Executor {
    void execute(Runnable command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ExecutorService extends Executor {
　　...
　　&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);
 
　　&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result);
 
　　Future&amp;lt;?&amp;gt; submit(Runnable task);
　　...
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 13 Oct 2018 15:49:00 +0000</pubDate>
<dc:creator>西北野狼</dc:creator>
<og:description>一： submit()方法，可以提供Future 类型的返回值。 executor()方法，无返回值。 execute无返回值 _ _ _ 二： excute方法会抛出异常。 sumbit方法不会抛出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/androidsuperman/p/9784821.html</dc:identifier>
</item>
<item>
<title>c++面向对象程序设计总结（类的使用） - 两千个秘密</title>
<link>http://www.cnblogs.com/wpbing/p/9774818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wpbing/p/9774818.html</guid>
<description>&lt;p&gt;本篇算是学习c++有关类的知识的一些易错点吧.....&lt;/p&gt;
&lt;p&gt;并不是特别详细&lt;/p&gt;
&lt;p&gt;几点并不关于类的东西&lt;/p&gt;
&lt;p&gt;1.函数模板，用虚拟类型来实现模板的功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
template &lt;/span&gt;&amp;lt;typename t&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t为虚拟类型的名字，自己起的&lt;/span&gt;
&lt;span&gt;t maxx(t a,t b,t c)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(a,max(b,c));
} 

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a=&lt;span&gt;1.1&lt;/span&gt;,b=&lt;span&gt;2.2&lt;/span&gt;,c=&lt;span&gt;3.3&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不管为double 还是int都可以调用maxx &lt;/span&gt;
    cout&amp;lt;&amp;lt;maxx(a,b,c)&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a1=&lt;span&gt;1&lt;/span&gt;,b1=&lt;span&gt;2&lt;/span&gt;,c1=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
    cout&lt;/span&gt;&amp;lt;&amp;lt;maxx(a1,b1,c1)&amp;lt;&amp;lt;&lt;span&gt;endl;
 } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.关于函数默认的参数值要放到最右边&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; f1(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; c,&lt;span&gt;char&lt;/span&gt; d=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误，&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; f2(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; c,&lt;span&gt;int&lt;/span&gt; b=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;char&lt;/span&gt; d=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.内置函数&lt;/p&gt;
&lt;p&gt;函数最左边加上inline(我觉得没啥用)，规模很小的函数才用&lt;/p&gt;
&lt;p&gt;4.字符串&lt;/p&gt;
&lt;p&gt;sizeof(string) 为4，因为系统分配的是固定的字节数，存放的是字符串的地址&lt;/p&gt;
&lt;p&gt;.......（以后再补充把）&lt;/p&gt;


&lt;p&gt;开始类的学习&lt;/p&gt;
&lt;p&gt;1.三种类的类型&lt;/p&gt;
&lt;p&gt;public&lt;/p&gt;
&lt;p&gt;这个就不多说了，类的对外接口&lt;/p&gt;
&lt;p&gt;private&lt;/p&gt;
&lt;p&gt;想要访问只能通过该类中的函数来访问&lt;/p&gt;
&lt;p&gt;protected&lt;/p&gt;
&lt;p&gt;和private差不多，区别在于继承时，以后说&lt;/p&gt;

&lt;p&gt;2.类的声明和成员函数的分离（以后更新）&lt;/p&gt;

&lt;p&gt;3.构造函数&lt;/p&gt;
&lt;p&gt;没有返回值，名字和类名字一样#include&amp;lt;iostream&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; box{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        box(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ,&lt;span&gt;int&lt;/span&gt; ,&lt;span&gt;int&lt;/span&gt; );&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数 （有无默认参数都行）&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; w;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; l;
};
box::box(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c)
{
    h&lt;/span&gt;=a,w=b,l=&lt;span&gt;c;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实一般这样写
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; box::box(int a,int b,int c):h(a),w(b),l(c){}&lt;br/&gt;//注意如果是数组的话  则要写在大括号内&lt;br/&gt;&lt;/span&gt;//box::box(int a,int b,int c,char nam[]):h(a),w(b),l(c)&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;//{strcpy(name,nam);}&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以用另一个对象初始化另一个&lt;/p&gt;
&lt;p&gt;time t1;&lt;/p&gt;
&lt;p&gt;time t2=t1;   //注意是吧t1的数据成员复制到t2，而不调用t2的构造函数&lt;/p&gt;
&lt;p&gt;4.析构函数&lt;/p&gt;
&lt;p&gt;注意一点，先构造的后析构，相当于栈，先进后出&lt;/p&gt;
&lt;p&gt;静态局部对象，在函数结束时，并不释放，也就不调用析构函数&lt;/p&gt;
&lt;p&gt;5.对象数组&lt;/p&gt;
&lt;p&gt;box b[3] = (1 , 2 ,3)//这样其实不对，这三个实参则分别作为3个元素的第一个实参&lt;/p&gt;
&lt;p&gt;初始化应该&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
box a[&lt;span&gt;3&lt;/span&gt;]=&lt;span&gt;{
    box(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
    box(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;,&lt;span&gt;40&lt;/span&gt;&lt;span&gt;);
    box(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.对象指针&lt;/p&gt;
&lt;p&gt;先说下函数指针。。。。还有函数指针？？？？&lt;/p&gt;
&lt;p&gt;类型名（* 指针变量名）（参数列表）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; (* p)();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p是一个指向void型函数的指针 &lt;/span&gt;
p=fun;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fun函数入口地址付给p 注意没有括号&lt;/span&gt;
(*p)();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对象成员函数有些复杂&lt;/p&gt;
&lt;p&gt;要求    函数参数类型和个数匹配        函数返回值类型一样     所属的类一样&lt;/p&gt;
&lt;p&gt;void ( time:: *p )();//此时p为指向time类中的成员函数指针&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;time t;
 &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; (time:: *&lt;span&gt;p)();
 p &lt;/span&gt;= &amp;amp;&lt;span&gt;time::gettime();
 (t.&lt;/span&gt;*p)();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.this指针（指向当前对象）&lt;/p&gt;
&lt;p&gt;当前被调用的成员函数所在对象的起始地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; box::volume()
 {&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (h*l*w);}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际为{ return this-&amp;gt;h * this-&amp;gt;l * this-&amp;gt;w;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用时 如 a.volume() ,实际为将对象a的地址传给形参this指针&lt;/p&gt;

&lt;p&gt;8.常对象&lt;br/&gt;只能通过构造函数参数表来对其初始化,所有数据成员绝对不能被改变，并且只能调用它的常成员函数&lt;br/&gt;如果非要改变，要加上 mutable 如有一个计数变量count， 则要 mutable int count;&lt;/p&gt;
&lt;p&gt;非const数据成员 非const函数可引用和改变 const函数可引用不可改变&lt;br/&gt;const数据成员 非const函数可引用不可改变 const函数可引用不可改变&lt;br/&gt;const函数不可调用非const函数&lt;/p&gt;
&lt;p&gt;常指针 如&lt;br/&gt;Time t1;&lt;br/&gt;Time * const p = =&amp;amp;t1;&lt;br/&gt;p不可再改变&lt;br/&gt;常变量只能被常指针指向，，&lt;br/&gt;普通变量也可被常指针指向，但这时该普通变量就在这期间变成的常变量，不能改变&lt;/p&gt;
&lt;p&gt;复制构造函数&lt;br/&gt;Box box2(box);&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;9.静态数据成员&lt;/p&gt;
&lt;p&gt;数据声明前 加 static&lt;br/&gt;特点是可以被每个该同类对象所引用，只能在类体外进行初始化,在类外也可直接引用&lt;br/&gt;如 int Box::height = 10;//不必加static&lt;br/&gt;可以通过对象名来引用，也可以通过类名&lt;br/&gt;如&lt;br/&gt;cout&amp;lt;&amp;lt;a.count&amp;lt;&amp;lt;endl;&lt;br/&gt;cout&amp;lt;&amp;lt;Box::count&amp;lt;&amp;lt;endl;&lt;/p&gt;&lt;p&gt;10.友元&lt;br/&gt;友元函数可以使一般的，也可以是另一个类中的，可以访问私有数据成员&lt;br/&gt;友元类就是全家都是友元函数&lt;br/&gt;注意是单向的，注意不能传递&lt;/p&gt;
&lt;p&gt;11.类的模板&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
temple&amp;lt;&lt;span&gt;class&lt;/span&gt; t&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t 为虚拟变量名字 可以有多个，但都要加class 如：temple&amp;lt;class t1,class t2&amp;gt; &lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; compare{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
compare(t a,t b)
{
x&lt;/span&gt;=a,y=&lt;span&gt;b;
}
t max() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(a,b);
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
t x,y;
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;定义对象时为：&lt;br/&gt;compare&amp;lt;int&amp;gt; cmp(3,4);&lt;br/&gt;//多个时 compare&amp;lt;int ,double&amp;gt; cmp(3,4);&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;12.对运算符的重载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; yuan{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        yuan(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; b):x(a),y(b){};
        yuan &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; +(yuan &amp;amp;&lt;span&gt;t)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; yuan(x+t.x, y+&lt;span&gt;t.y);
        }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; x,y;
};             &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时如果有&lt;br/&gt;yuan c1(1,2),c2(1,2),c3;&lt;br/&gt;c3 = c1 + c2;&lt;br/&gt;则实际为 c3 = c1.operator(c2);&lt;/p&gt;
&lt;p&gt;但其实我觉得更方便的是通过友元函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; yuan{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        yuan(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; b):x(a),y(b){};
        friend yuan &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; +(yuan &amp;amp;t1,yuan &amp;amp;t2)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个其实挺灵活的，可以自行改变 &lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; yuan(t1.x+t2.x, t1.y+&lt;span&gt;t2.y);
        }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; x,y;
};             &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c3 = c1 + c2 则解释为operator +(c1,c2);&lt;/p&gt;

&lt;p&gt;13.继承&lt;/p&gt;
&lt;p&gt;派生类拥有基类的数据成员，其分配如下&lt;/p&gt;
&lt;p&gt;先说公有继承&lt;/p&gt;

&lt;p&gt;基类属性                               派生类    &lt;/p&gt;
&lt;p&gt;private                                  不可访问&lt;/p&gt;

&lt;p&gt;public          公有继承后        public&lt;/p&gt;

&lt;p&gt;protected                            protected&lt;/p&gt;

&lt;p&gt;私有继承&lt;/p&gt;
&lt;p&gt;基类属性                               派生类    &lt;/p&gt;
&lt;p&gt;private                                  不可访问&lt;/p&gt;

&lt;p&gt;public          私有继承后        private&lt;/p&gt;

&lt;p&gt;protected                            private&lt;/p&gt;
&lt;p&gt;保护继承&lt;/p&gt;
&lt;p&gt;保护成员：只有子女（派生类）可以访问，（友元函数也不行）&lt;/p&gt;
&lt;p&gt;基类属性                               派生类    &lt;/p&gt;
&lt;p&gt;private                                  不可访问&lt;/p&gt;

&lt;p&gt;public          保护继承后        protected&lt;/p&gt;

&lt;p&gt;protected                            protected&lt;/p&gt;

&lt;p&gt;14.有子对象的派生构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; display();
        Student(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; nam):num(n),name(nam){}
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name;
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Student1: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Student1(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n,&lt;span&gt;string&lt;/span&gt; nam,&lt;span&gt;int&lt;/span&gt; n1,&lt;span&gt;string&lt;/span&gt; nam1,&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; ad):
            Student(n,nam),monitor(n1,nam1),age(a),addr(ad){}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意初始化，一般用初始化表来 ，同样的，在多级派生中也是如此来构造&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show()
        {
            monitor.display();
        }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
        Student monitor;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;派生类中的子对象 &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; addr;
};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    
 } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 多级的形式&lt;/p&gt;
&lt;p&gt;派生类构造名: 基类1构造函数(参数表) , 基类2构造函数(参数表) , 基类3构造函数(参数表) &lt;/p&gt;
&lt;p&gt;{  派生类中新增的数据成员初始化语句 }&lt;/p&gt;
&lt;p&gt;15 . 关于多重继承的二义性问题&lt;/p&gt;
&lt;p&gt;就是继承的函数名  和   派生的函数名一样了&lt;/p&gt;
&lt;p&gt;假设有类A和类B，此时类C同时继承类A和类B，现在问题是  类A 类B  类C都有一个  叫display()的函数 &lt;/p&gt;
&lt;p&gt;C c1;&lt;/p&gt;
&lt;p&gt;c1.display()//此时该是谁呢，是最新的也就是c的display（）。这个会覆盖&lt;/p&gt;
&lt;p&gt;此时要想访问A的display（），则要限定作用域 。&lt;/p&gt;
&lt;p&gt;比如  c.A::display();&lt;/p&gt;
&lt;p&gt;16.虚基类&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1369734/201810/1369734-20181013152617764-309112285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;D 是 B 和 C 的派生类，B 和 C 又都是继承了A，这样会保留多份数据成员的拷贝&lt;/p&gt;
&lt;p&gt;虚基类是的在继承简介共同基类时只保留一份&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A
{
    A(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){}
    .....
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; B: &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; A
{
    B(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n):A(n){}
    ...
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; C: &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; A
{
    C(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n):C(n){}
    ...
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; D:&lt;span&gt;public&lt;/span&gt; B,&lt;span&gt;public&lt;/span&gt;&lt;span&gt; C
{
    D(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n):A(n),B(n),C(n){}//这个必须由最后的派生类中对直接基类和虚基类初始化
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;17.类型的转化&lt;/p&gt;
&lt;p&gt;派生类可以向基类对象赋值  （大材小用），也可以向积累对象的引用进行赋值或初始化&lt;/p&gt;
&lt;p&gt;派生类对象的地址可以赋给基类对象的指针变量，也就是说，指向基类对象的指针变量也可以用来指向派生类对象&lt;/p&gt;
&lt;p&gt;18.多态性&lt;/p&gt;
&lt;p&gt;分为两种 ，静态多态性和动态多态性（啥玩意啊，玩的怪花（小声bb））&lt;/p&gt;
&lt;p&gt;静态多态性 就是  函数重载   和运算符的重载&lt;/p&gt;
&lt;p&gt;动态  就是通过虚函数来实现的&lt;/p&gt;

&lt;p&gt; 说一下虚函数，作用还是要解决继承中的二义性问题，&lt;/p&gt;
&lt;p&gt;解决方法是想通过指针的方法来实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Student stu(...);
Graduate grad(...);//假设grad是stu的派生，且两者都有display函数
Student &lt;/span&gt;*p = &amp;amp;&lt;span&gt;stu;
p&lt;/span&gt;-&amp;gt;&lt;span&gt;display();
p &lt;/span&gt;= &amp;amp;grad;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;想通过变换指针指向来，但单单的这样做是不行的，因为这样做会把grad类型强制转化成student的类型 &lt;/span&gt;
p-&amp;gt;display();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决上述问题的方法是将Student类中的display（）函数前加上virtual&lt;/p&gt;
&lt;p&gt;　　注意问题是  成原函数 定义为虚函数后，其派生类都为虚函数&lt;/p&gt;
&lt;p&gt;　　使用方法是指向一个基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象&lt;/p&gt;

&lt;p&gt;19.虚析构函数&lt;/p&gt;
&lt;p&gt;如下面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Point{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        point();
        &lt;/span&gt;~&lt;span&gt;point();
}; 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Circle: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Point
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Circle();
        &lt;/span&gt;~&lt;span&gt;Circle();
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    Point &lt;/span&gt;*p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Circle;
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; p;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;new的一个对象，在释放的时候，只会执行基类的析构函数，而不执行派生类的&lt;/p&gt;
&lt;p&gt;解决方法是  在Point 的析构函数前加上 virtual&lt;/p&gt;
&lt;p&gt;个人理解（这个virtual  在继承中 都会遗传）&lt;/p&gt;
&lt;p&gt;20.纯虚函数&lt;/p&gt;
&lt;p&gt;先说一点吧，往往有一些类，他们不用来生成对象，唯一目的就是用它去建立派生类，叫做抽象类&lt;/p&gt;
&lt;p&gt;比如，点 可以派生出 园 ，圆可以派生出圆柱体  ，但这些都是 shape 的直接派生或者间接派生&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shape{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; area() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;;}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚函数&lt;/span&gt;
        &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; volume() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;;}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚函数&lt;/span&gt;
        &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shapeName() &lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 纯虚函数 形式为 virtual 函数类型 函数名字 (参数列表) =0;&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后来个差不多的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shape
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; area() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0.00&lt;/span&gt;&lt;span&gt;;}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; volume() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0.00&lt;/span&gt;&lt;span&gt;;}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShapeName() &lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Point: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Shape
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Point(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; a=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; b=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;): x(a), y(b){};
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetPoint(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;float&lt;/span&gt;&lt;span&gt; b)
        {
            x&lt;/span&gt;=a,y=&lt;span&gt;b;
        }
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; getX() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;}
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; getY() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt;&lt;span&gt; y;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShapeName() &lt;span&gt;const&lt;/span&gt; {cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;point&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;}
        friend ostream &lt;/span&gt;&amp;amp;&lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;,&lt;span&gt;const&lt;/span&gt; Point &amp;amp;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; x,y;
};
ostream &lt;/span&gt;&amp;amp;&lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;output,&lt;span&gt;const&lt;/span&gt; Point &amp;amp;&lt;span&gt;p)
{
        output&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;p.x&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;p.y&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; output;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Circle: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Point
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Circle(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; x=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; y=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; r=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;):Point(x,y),radius(r) {}
        
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetRaidus(&lt;span&gt;float&lt;/span&gt; r){ radius =&lt;span&gt; r;}
        
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; GetRadius() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt;&lt;span&gt; radius;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; area() &lt;span&gt;const&lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; &lt;span&gt;3.14&lt;/span&gt; * radius *&lt;span&gt; radius;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShapeName() &lt;span&gt;const&lt;/span&gt; {cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Circle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;}
        
        friend ostream &lt;/span&gt;&amp;amp;&lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;,&lt;span&gt;const&lt;/span&gt; Circle &amp;amp;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; radius;
};
ostream &lt;/span&gt;&amp;amp;&lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;&lt;span&gt;out&lt;/span&gt;,&lt;span&gt;const&lt;/span&gt; Circle &amp;amp;&lt;span&gt;c)
{
    &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;c.x&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;c.y&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;c.radius&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Yuan: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Circle
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Yuan(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; x=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; y=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; r=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; h=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;):Circle(x,y,r),height(h){}
        
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetHeight(&lt;span&gt;float&lt;/span&gt; h) {height =&lt;span&gt; h;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; area() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; * Circle::area() + &lt;span&gt;2&lt;/span&gt; * &lt;span&gt;3.14&lt;/span&gt; * radius *&lt;span&gt; height;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; vulume() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; Circle::area() *&lt;span&gt; height;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShapeName() &lt;span&gt;const&lt;/span&gt; {cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;}
        
        friend ostream &lt;/span&gt;&amp;amp;&lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;,&lt;span&gt;const&lt;/span&gt; Yuan &amp;amp;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; height;
};
ostream &lt;/span&gt;&amp;amp; &lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;&lt;span&gt;out&lt;/span&gt;,&lt;span&gt;const&lt;/span&gt; Yuan &amp;amp;&lt;span&gt;Y)
{
    &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;Y.x&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;Y.y&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],r=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;Y.radius&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;H=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;Y.height&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    Point point (&lt;/span&gt;&lt;span&gt;3.2&lt;/span&gt;,&lt;span&gt;4.5&lt;/span&gt;&lt;span&gt;);
    Circle circle(&lt;/span&gt;&lt;span&gt;2.4&lt;/span&gt;,&lt;span&gt;1.2&lt;/span&gt;,&lt;span&gt;5.6&lt;/span&gt;&lt;span&gt;);
    Yuan yuan(&lt;/span&gt;&lt;span&gt;3.4&lt;/span&gt;,&lt;span&gt;6.4&lt;/span&gt;,&lt;span&gt;5.2&lt;/span&gt;,&lt;span&gt;10.5&lt;/span&gt;&lt;span&gt;);
    point.ShapeName();
    cout&lt;/span&gt;&amp;lt;&amp;lt;point&amp;lt;&amp;lt;&lt;span&gt;endl;
    
    circle.ShapeName();
    cout&lt;/span&gt;&amp;lt;&amp;lt;circle&amp;lt;&amp;lt;&lt;span&gt;endl;
    
    yuan.ShapeName();
    cout&lt;/span&gt;&amp;lt;&amp;lt;yuan&amp;lt;&amp;lt;&lt;span&gt;endl;
    
    Shape &lt;/span&gt;*&lt;span&gt;pt;
    pt&lt;/span&gt;=&amp;amp;&lt;span&gt;point;
    pt&lt;/span&gt;-&amp;gt;&lt;span&gt;ShapeName();
    
    pt&lt;/span&gt;=&amp;amp;&lt;span&gt;circle;
    pt&lt;/span&gt;-&amp;gt;&lt;span&gt;ShapeName();
    pt&lt;/span&gt;=&amp;amp;&lt;span&gt;yuan;
    pt&lt;/span&gt;-&amp;gt;&lt;span&gt;ShapeName();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可能以和还会更新吧..............&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 15:29:00 +0000</pubDate>
<dc:creator>两千个秘密</dc:creator>
<og:description>本篇算是学习c++有关类的知识的一些易错点吧..... 并不是特别详细 几点并不关于类的东西 1.函数模板，用虚拟类型来实现模板的功能 2.关于函数默认的参数值要放到最右边 3.内置函数 函数最左边加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wpbing/p/9774818.html</dc:identifier>
</item>
<item>
<title>轻松使用 Redis slowlog - Nuss</title>
<link>http://www.cnblogs.com/Nuss/p/9784732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Nuss/p/9784732.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;54&quot;&gt;
&lt;p&gt;之前中秋项目搞活动，用户比较活跃 SE.Redis 频繁报 Timeout 异常，狂翻了一波 issues 发现提这个问题还蛮多的，作者非常频繁的提到使用 slowlog 这个命令进行排查，那么问题就来了，它是干嘛滴？&lt;/p&gt;
&lt;h2 id=&quot;hredisslowlog&quot;&gt;&lt;span&gt;Redis slowlog 是个什么&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;使用这个命令可以读取或重置 Redis 慢速查询日志。通俗讲就是 redis 可以把执行时间超过我们设定值的命令记录下来，slowlog 是记录到内存中的哦，所以非常快。&lt;/p&gt;
&lt;p&gt;这里的&lt;strong&gt;执行时间&lt;/strong&gt;不包括 I/O 操作,比如与客户端,发送应答等等,就是实际执行命令所需的时间(命令唯一执行的阶段，线程被阻塞且不能同时处理其他请求)。&lt;/p&gt;
&lt;h2 id=&quot;hredisslowlog-1&quot;&gt;&lt;span&gt;设置 Redis slowlog&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;可以通过配置 redis.conf 来完成。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;运行时，使用 CONFIG GET 和 CONFIG SET 命令配置。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里我们主要说的是第二种方式，您可以使用两个参数来配置慢日志：slowlog-log-slow-than * ,告诉 Redis, 记录超过 * &lt;strong&gt;微秒&lt;/strong&gt; 内的命令执行情况。&lt;/p&gt;
&lt;p&gt;需要注意的是，设置负数表示禁用 slowlog ，而设置 0 则强制记录每个命令的执行情况。&lt;br/&gt;以下是 slowlog 的设置使用说明：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs css&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;slowlog-log-slower-than&lt;/span&gt; 10000&lt;br/&gt;&quot;&lt;span class=&quot;hljs-selector-tag&quot;&gt;OK&lt;/span&gt;&quot;&lt;p&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;slowlog-log-slower-than&lt;/span&gt;&lt;br/&gt;1)  &quot;&lt;span class=&quot;hljs-selector-tag&quot;&gt;slowlog-log-slower-than&lt;/span&gt;&quot;&lt;br/&gt;2)  &quot;10000&quot;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么问题又来了，slowlog 是记录再内存中的，如果记录所有的命令 log 会不会把内容撑爆呢？&lt;/p&gt;
&lt;p&gt;答案是当然不会。slowlog 记录的 log 数是有最大长度限制的，我们可以通过 slowlog-max-len 来查询 slowlog 的最大长度。最小值为零。当一个新的命令被记录下来，并且如果已经达到它的最大长度时，最老的一个 log 将从队列中删除，FIFO 。&lt;/p&gt;
&lt;p&gt;另外，使用 slowlog len 命令可以查看当前已记录的数量。&lt;br/&gt;使用 slowlog reset 重置已记录的 slowlog 信息。&lt;/p&gt;
&lt;h2 id=&quot;hslowlog&quot;&gt;&lt;span&gt;如何阅读 slowlog&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们已经了解 slowlog 是记录在内存中的，所以您可以启用所有命令的日志记录即 slowlog-log-slow-than 配置参数设置为 0 便于监测性能。&lt;/p&gt;
&lt;p&gt;要读取 slowlog，使用 SLOWLOG GET 获取命令，它返回慢日志中的每一个条目。可以只返回N个最近的条目，将一个附加参数传递给命令（例如 SLOWLOG GET 2）。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs cs&quot; readability=&quot;2&quot;&gt;redis &lt;span class=&quot;hljs-number&quot;&gt;127.0&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6379&lt;/span&gt;&amp;gt; slowlog &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;             &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;1309448221&lt;/span&gt;     &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;             &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;ping&quot;&lt;/span&gt;                &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;1309448128&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;slowlog&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;get&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;127.0.0.1:58217&quot;&lt;/span&gt;         &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;worker-123&quot;&lt;/span&gt;              &lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，需要注意此命令需要 2.2.12及以上版本的 redis 才能支持。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 13 Oct 2018 15:19:00 +0000</pubDate>
<dc:creator>Nuss</dc:creator>
<og:description>之前中秋项目搞活动，用户比较活跃 SE.Redis 频繁报 Timeout 异常，狂翻了一波 issues 发现提这个问题还蛮多的，作者非常频繁的提到使用 slowlog 这个命令进行排查，那么问题就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Nuss/p/9784732.html</dc:identifier>
</item>
<item>
<title>未来公司的酒会 - mskitten</title>
<link>http://www.cnblogs.com/mozi-song/p/9784727.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mozi-song/p/9784727.html</guid>
<description>&lt;p&gt;面试的时候，未来老板加了我的微信。这几天，他发微信来说，我将来的大老板要从纽约飞过来，请全组人吃饭，邀请我也一起去。&lt;/p&gt;
&lt;p&gt;于是，我见到我的未来同事们啦。&lt;/p&gt;

&lt;p&gt;来到公司，第一感觉是节奏非常快，跟老板讲话的时候我的语速都有点跟不上。不过还好我聪明（？？），立刻就习惯了。&lt;/p&gt;
&lt;p&gt;同事们非常友善，也非常热情，每个人都从座位上站起来跟我握手。老板介绍了大组里三十多位同事的名字，但是我一个都没记住。只记住了有好几个女生，其中有好几个很漂亮。&lt;/p&gt;
&lt;p&gt;老板拉着我转完一圈以后，指着一个靠走道的座位说：这里就是你以后的座位，你可以先坐在这里，下班时我们叫你。当时是下午四点半，我坐了下来，手足无措，我还没从现在的公司离职呢……&lt;/p&gt;
&lt;p&gt;我的账号还没好，所以电脑开不了机。我装作看手机，打量着周围。有一个女生的笑声特别脆亮。老板指着她说：你来带mskitten周围转一下……&lt;/p&gt;
&lt;p&gt;那位女生笑眼弯弯地向我走来，带着我去楼下的果汁店买了两杯38元的果汁（她说没关系，老板请客……），然后我们走进公司的休息室坐下，她不停地说着，十分伶牙俐齿。而她具体说了什么，差不多全都不记得了。巨大的落地窗外面的云朵和浦东的风光，让我完全恍神……&lt;/p&gt;

&lt;p&gt;在与她的对话中，有两点让我确定了她不是表面看起来那么大大咧咧，也让我对新公司好感度爆棚。&lt;/p&gt;
&lt;p&gt;她说：公司是一个资源很丰富的地方，但是要提升自己，一定要有内在的动力。不会有人逼着你学习，但是老板们会很支持你参加各种培训，公司里也有很多原版书可以看，至于去不去利用，就看你自己。通常大家最大的问题是没时间学习。&lt;/p&gt;
&lt;p&gt;她还说（我问公司加班是否严重）：没有一个公司能保证永远不加班。我个人的看法是，只要加班能让你真的学到东西，偶尔加班也没关系。&lt;/p&gt;
&lt;p&gt;我觉得她非常真诚，三观也很正。&lt;/p&gt;
&lt;p&gt;我很感激她第一天就跟我说这些。我从未碰到一个愿意这样提点我的同事。&lt;/p&gt;
&lt;p&gt;所以她虽然看起来大大咧咧，但我打定主意认为她并不一般，值得交朋友。&lt;/p&gt;

&lt;p&gt;第16层的半层都是我们组的人，只有一个女生是产品经理。这个女生戴着眼镜，看到我的时候笑咪咪的，看起来脾气非常好的样子。&lt;/p&gt;
&lt;p&gt;下班时，大家说要走去吃饭的地方，她一脸愁苦：“能不能打车啊？”大家说高峰期不好打，于是她委屈巴拉地拎着包走在后面。&lt;/p&gt;
&lt;p&gt;走在路上。她一直在撒娇：“怎么这么远啊，走不动了……”然后旁边的女生就哄着她：“娘娘啊，再一段就到了，到了就可以吃好吃的了。”她于是提起劲来，快走两步，然后想到了什么，又颓然慢下来，说：“那家东西很难吃……大老板每次都定那家，一定是因为便宜……”&lt;/p&gt;
&lt;p&gt;上菜的时候，她说自己胖，吃了两口就拒绝再吃了。让她再吃点，她非常严肃地摆手说：“我真的饱了！”旁人劝了一阵，看她毫不动摇，于是埋头苦吃起来，她眼巴巴地望着。过了一会，服务生上了一个大披萨，桌子上只有靠近她的地方有位置放。她便自顾自地跟服务生说：“我真的吃不下了，我吃了好多了！放在这里吧。”然后拿了一大块……&lt;/p&gt;
&lt;p&gt;我要赶火车回家的时候，这个女生非常舍不得我走，在旁边各种出主意，叫我陪他们一起high到凌晨，第二天跟现在的公司请假。旁人劝着“来日方长，来日方长——”我这才站起来走了。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;1431316510719061435.gif&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.0546448087431694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z0aiaCia1F9LK5YVwbIftzktGq0Q8I3CM6ibheYk9icfOxLeCRE9IeQBeQorNvZFIVpf0bWjejKBLqTS6VoVLXyjibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;366&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一个健身的男生A，听说在公司的啤酒大赛上得了部门第一名，看起来已经不是第一次聊这个话题了，仍难掩得意之色。&lt;/p&gt;
&lt;p&gt;这个啤酒大赛十分奇葩，是某个英国同事私人提议和组织的。每个参赛者都有一名对应的裁判，参赛者必须喝完一定数量（很多）的啤酒，并且在半小时内不准吐，也不准去厕所。裁判记录参赛者喝完酒所用的时间，时间短者排名高。&lt;/p&gt;
&lt;p&gt;这个男生A，听说是只用了三分半，就喝光了全部啤酒，而其他人至少要二十分钟。&lt;/p&gt;
&lt;p&gt;另一个男生B，不知怎么的，对此事耿耿于怀，一定要当场与A一决高下。&lt;/p&gt;
&lt;p&gt;A说：你先去网站上看一下，把排在我后面的人都打败，再来单挑我吧！&lt;/p&gt;
&lt;p&gt;B说：我不喜欢一个人喝酒，我就要跟你单挑！而且我觉得啤酒比赛不合理，比的是胃口，而不是酒量！&lt;/p&gt;
&lt;p&gt;这时男生C插进来说：对哦，那个全公司第一名的美国佬只用了一分钟，他肚子大到坐在椅子上都能垂到地上……&lt;/p&gt;
&lt;p&gt;于是剩下的人怂恿一阵，笑一阵，完全不理站在角落的两位大老板。&lt;/p&gt;

&lt;p&gt;在今天之前，我全然想不到见到未来同事是什么感觉。&lt;/p&gt;
&lt;p&gt;我曾经面试过心仪的S公司，那时得到录取，就像梦幻一般。我想到可以去S公司上班，心里就砰砰直跳。&lt;/p&gt;
&lt;p&gt;像Altucher说的那样，“初恋的感觉”。&lt;/p&gt;
&lt;p&gt;而今天，从搭着写字楼的电梯到十六层见到未来的老板，到坐火车转地铁回到家里，我都很笃定，像双脚稳稳踏在粗糙的大地上。&lt;/p&gt;
&lt;p&gt;这是一种“我配得上来这里上班”的感觉。&lt;/p&gt;

&lt;p&gt;当我把我的辞职信发布在博客上时，得到了许多批评和冷水，最频繁出现的是“你会发现，下一家公司只有更差”。&lt;/p&gt;
&lt;p&gt;或许是我太盲目地乐观，又或许是我还没经历到他们所说的“更差”。我今天所观察到的事实，只是增添了我对未来的信心。&lt;/p&gt;
&lt;p&gt;对我来说，有一群志同道合的同事非常重要。我不喜欢跟混水摸鱼的人一起工作，也不喜欢跟为了表现自己勤奋而加班的人一起工作。&lt;/p&gt;
&lt;p&gt;在现在的公司，我是一个非常格格不入的人。我想学新的东西、想做出一些改变，想好好上班、好好生活、好好玩耍，想跟同事成为生活中的朋友，这在他们眼中看来，似乎都很怪诞。&lt;/p&gt;
&lt;p&gt;我还是努力着，但是感到很孤独。&lt;/p&gt;
&lt;p&gt;当我第一次坐下来，跟未来的同事碰杯，因为一个共同的领悟而哈哈大笑时，我心里突然“啪嗒”一下，有一个声音告诉我：这就是真正适合你的地方啊。&lt;/p&gt;
&lt;p&gt;我知道还是会有奇葩的同事，还是会有我不理解的公司制度，而且会有新的挑战——比我聪明也比我努力的程序员，在高处俯瞰我。&lt;/p&gt;
&lt;p&gt;但我知道，我是他们的同类。我会跟他们一起，去往更精彩的地方。&lt;/p&gt;
&lt;p&gt;这一刻，我是多么快乐啊。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 15:18:00 +0000</pubDate>
<dc:creator>mskitten</dc:creator>
<og:description>面试的时候，未来老板加了我的微信。这几天，他发微信来说，我将来的大老板要从纽约飞过来，请全组人吃饭，邀请我也一起去。 于是，我见到我的未来同事们啦。 来到公司，第一感觉是节奏非常快，跟老板讲话的时候我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mozi-song/p/9784727.html</dc:identifier>
</item>
<item>
<title>设计模式——代理模式 - Mr.yang.localhost</title>
<link>http://www.cnblogs.com/mr-yang-localhost/p/9746184.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-yang-localhost/p/9746184.html</guid>
<description>&lt;h2&gt;定义&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;为其他对象提供一种代理以控制对这个对象的访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　代理模式也叫委托模式，日常生活中很常见。帮别人做某某事情时候，自己就是别人的代理；让别人帮自己做什么事情时候，别人就是自己的代理。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;通用类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181007165545821-1992367803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;Subject抽象主题角色&lt;/h4&gt;
&lt;p&gt;　　抽象主题类是一个普通的业务类型的定义，规定要做什么事情。可以是一个抽象类也可以是一个接口。&lt;/p&gt;
&lt;h4&gt;RealSubject具体主题角色&lt;/h4&gt;
&lt;p&gt;　　被委托（被代理）的角色，是真正事情处理的执行者。&lt;/p&gt;
&lt;h4&gt;Proxy代理主题角色&lt;/h4&gt;
&lt;p&gt;　　委托类（代理类），负责对真实角色的调用，把所有主题限定的方法委托给具体主题角色，也可以在真实主题角色处理前做一些预处理，或在真实主题角色处理后做一些善后处理（比如Spring的AOP）。&lt;/p&gt;
&lt;h2&gt;普通代理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;小时候在家都是妈妈做饭，做饭需要洗菜，切菜，炒菜……有时候妈妈有事忙没按时回家，姐姐就偷偷代替妈妈给大家做饭。如果&lt;span&gt;将做饭简单理解为洗菜、切菜、炒菜三个步骤&lt;/span&gt;，从程序员的角度来记录做饭这件事就很简单了。妈妈和姐姐都需要洗菜、切菜然后再炒菜，所以可以规定炒菜的三个步骤，然后分别实现这三个步骤，所以可以简单表示为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181007163516254-1088827574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ICook定义了炒菜必须要经历的流程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICook {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*洗菜&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washFood();
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*切菜&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cutFood();
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*炒菜&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stirFood();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;妈妈（对于一家人来说，天天吃妈妈做的饭，妈妈就是一个Cooker）做饭的流程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cooker implements ICook {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washFood() {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;妈妈在洗菜……&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cutFood() {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;妈妈在切菜……&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stirFood() {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;妈妈在炒菜……&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一个能代理妈妈做饭（实现了ICook接口）的角色&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CookerProxy implements ICook {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICook cooker;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CookerProxy(ICook cooker){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cooker =&lt;span&gt; cooker;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.washFood();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cutFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.cutFood();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stirFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.stirFood();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;姐姐代替妈妈做饭&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
        Cooker cooker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cooker();
        ICook cook &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CookerProxy(cooker);
        cook.washFood();
        cook.cutFood();
        cook.stirFood();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;姐姐学会了妈妈的手艺，如果不是亲眼看到，还不知道是姐姐做的饭，这就是真实生活中一个简单的代理例子。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;强制代理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;普通代理是通过代理找到真实的对象，由真实对象去执行动作；但是强制代理却是要通过真实角色查找代理，否则不能访问。也就是不管是通过代理类还是直接new一个真实对象都不能访问，只有通过真实对象委托的代理才能访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是上面的那个例子，后来妈妈上班去了，中午不能回家做饭了，拿普通代理方式来说，只要是一个会做菜的人，就可以趁着妈妈不在冒充妈妈的身份替妈妈做菜，万一做的很难吃，岂不是把妈妈的招牌给毁了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是，妈妈想到了个办法，必须由她指定谁可以代替她做菜，不是由她亲自指定的人无法替她做菜：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181013105955982-429648037.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义了一个getProxy方法，由Cooker来指定自己的代理，并且代理自己做事之前，先验证下身份：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cooker &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICook {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICook cook;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washFood() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isProxy()) {
            System.out.println(&lt;/span&gt;&quot;妈妈在洗菜……&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;请妈妈指定的人来炒菜……&quot;&lt;span&gt;);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cutFood() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isProxy()) {
            System.out.println(&lt;/span&gt;&quot;妈妈在切菜……&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;请妈妈指定的人来炒菜……&quot;&lt;span&gt;);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stirFood() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isProxy()) {
            System.out.println(&lt;/span&gt;&quot;妈妈在炒菜……&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;请妈妈指定的人来炒菜……&quot;&lt;span&gt;);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ICook getProxy() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cook = &lt;span&gt;new&lt;/span&gt; CookerProxy(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cook;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Boolean isProxy() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.cook == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;只有通过Cooker对象获取（getProxy）代理才能做菜。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;代理扩展&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;姐姐做了几顿饭之后也开始不乐意了，凭什么我要占用玩的时间来给大家做饭？妈妈想了一个好主意，姐姐每做一顿饭可以从妈妈那里领到1块钱，于是姐姐又高高兴兴地给大家做饭了。做饭和付钱是两个单独的功能，是不能混在一起的，可以将上面类图稍作修改：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181013111900172-1299371844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样，在每次做好饭之后就可以记账应该拿到1元钱&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CookerProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICook, IPay {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICook cooker;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CookerProxy(ICook cooker){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cooker =&lt;span&gt; cooker;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.washFood();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cutFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.cutFood();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stirFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.stirFood();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.pay();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pay() {
        System.out.println(&lt;/span&gt;&quot;做完饭拿到了1元钱&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ICook getProxy() {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 可以指定代理的代理，暂时没有就是自己 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代理不仅可以实现主题的接口，还可以实现其他的接口，在目标行为基础之上做个性化处理。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;动态代理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;后来姐姐长大了，也出门在外了，我们也不能每次都等着吃饭，于是各自都学会了做饭，只要妈妈不在，谁方便了谁就做饭。也就是说，只有饭已经在被做了才知道是谁在做，更灵活了，这就不能提前指定谁来做饭了。对应程序中是：只有在运行时才知道真实类型是谁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将类图稍作修改，如下所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181013152033287-1780461290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;InvocationHandler是java提供的动态代理接口，CookerHandler实现了&lt;span&gt;InvocationHandler&lt;/span&gt;接口，这样可以动态指定代理，运行时才知道类型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CookerHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
    Class clazz &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    Object obj &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CookerHandler(Object _obj) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.obj =&lt;span&gt; _obj;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        Object result &lt;/span&gt;= method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.obj, args);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;动态代理客户端使用示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dynamicProxy(){
        proxy.dynamicproxy.ICook cook &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; proxy.dynamicproxy.Cooker();

        ClassLoader classLoader &lt;/span&gt;=&lt;span&gt; cook.getClass().getClassLoader();
        Class&lt;/span&gt;&amp;lt;?&amp;gt;[] interfaces =&lt;span&gt; cook.getClass().getInterfaces();
        CookerHandler handler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CookerHandler(cook);

        proxy.dynamicproxy.ICook proxyInstance &lt;/span&gt;=&lt;span&gt; (proxy.dynamicproxy.ICook) Proxy.newProxyInstance(classLoader, interfaces, handler);
        proxyInstance.washFood();
        proxyInstance.cutFood();
        proxyInstance.stirFood();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;动态代理可以参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/mr-yang-localhost/p/9244499.html&quot;&gt;Java动态代理之JDK实现和CGlib实现（简单易懂）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文示例代码：&lt;a href=&quot;https://github.com/yangyp8110/design-patterns/tree/master/src/main/java/proxy&quot; target=&quot;_blank&quot;&gt;Proxy Demo&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 15:17:00 +0000</pubDate>
<dc:creator>Mr.yang.localhost</dc:creator>
<og:description>定义 为其他对象提供一种代理以控制对这个对象的访问。 代理模式也叫委托模式，日常生活中很常见。帮别人做某某事情时候，自己就是别人的代理；让别人帮自己做什么事情时候，别人就是自己的代理。 通用类图 Su</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-yang-localhost/p/9746184.html</dc:identifier>
</item>
<item>
<title>【Mybtais】Mybatis 插件 Plugin开发（一）动态代理步步解析 - 年轻的老魏</title>
<link>http://www.cnblogs.com/oldwei/p/9784708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oldwei/p/9784708.html</guid>
<description>&lt;h2&gt;需求：&lt;/h2&gt;
&lt;p&gt;　　对原有系统中的方法进行‘拦截’，在方法执行的前后添加新的处理逻辑。&lt;/p&gt;
&lt;h2&gt;分析：&lt;/h2&gt;
&lt;p&gt;　　不是办法的办法就是，对原有的每个方法进行修改，添加上新的逻辑；如果需要拦截的方法比较少，选择此方法到是会节省成本。但是面对成百上千的方法怎么办？此时需要用到动态代理来实现。&lt;/p&gt;
&lt;h2&gt;场景：&lt;/h2&gt;
&lt;p&gt;　　例如：对原有的系统添加日志记录、添加性能分析等等。。。&lt;/p&gt;
&lt;h2&gt;举例：&lt;/h2&gt;
&lt;p&gt;　　如下，需要对Sleep对象的sleep方法进行“拦截”,并在此方法的执行前后添加新的逻辑。想知道‘睡觉前干了什么？睡觉后干了什么？’&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Sleep {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sleep();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepImpl implements Sleep{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sleep() {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我于&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).format(&lt;span&gt;new&lt;/span&gt; Date())+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始睡觉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建动态代理类，实现InvocationHandler接口即可。下面的wrap方法：传入要被代理的对象target。返回包装后的代理对象。$Proxy 打断点会看到这样的对象。针对下面的sleepProxy对象，sleepProxy.sleep()调用需要拦截的方法。实际上调用的是Plugin中的invoke方法。invoke方法中的method.invoke(target,args)是真是的调用被代理对象的sleep方法。所以直接在此语句的前后添加相应的逻辑即可满足需要。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Plugin implements InvocationHandler {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    Plugin(Object target){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
    }    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;睡觉前做的事&lt;/span&gt;
        Object result =&lt;span&gt; method.invoke(target, args);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;睡觉后做的事&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object wrap(Object target){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(), 
                target.getClass().getInterfaces(), 
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Plugin(target));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;要被代理的对象&lt;/span&gt;
        Sleep sleep = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SleepImpl();
&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;代理对象&lt;/span&gt;
        Sleep sleepProxy =&lt;span&gt; (Sleep)Plugin.wrap(sleep);
        sleepProxy.sleep();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，你以为就结束了？不 ，这个仅仅是 说了在睡觉 前后做了什么事，加入还想知道，你在睡觉前后吃了什么东西？当然睡觉后吃东西有点说不通。但 意会就可以了。还有其他巴拉巴拉的需求。你该怎么做?是不是要把所有的 新的逻辑都方法 Plugin中invoke方法中去？这样不合适吧！乱 乱 乱 这样。那咱们能不能抽象出来一个拦截接口，接口中有拦截后要做什么的方法。各种需求只需要实现这个拦截接口即可！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Interceptor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptBefore()throws Exception;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptAfter()throws Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepBeforeAndAfter implements Interceptor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptBefore() throws Exception {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;之前。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptAfter() throws Exception {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;之后。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后动态代理类Plugin需要修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 动态代理
 * 
 * @author 魏正迪
 * 2018年10月13日
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Plugin implements InvocationHandler {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Interceptor&amp;gt; iList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Interceptor&amp;gt;&lt;span&gt;();

    Plugin(Object target , List&lt;/span&gt;&amp;lt;Interceptor&amp;gt;&lt;span&gt; iList){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.iList =&lt;span&gt; iList;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Interceptor i :iList){
            i.interceptBefore();
        }
        Object result &lt;/span&gt;=&lt;span&gt; method.invoke(target, args);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Interceptor i :iList){
            i.interceptAfter();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object wrap(Object target,List&amp;lt;Interceptor&amp;gt;&lt;span&gt; iList){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(), 
                target.getClass().getInterfaces(), 
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Plugin(target,iList)
                );
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Sleep sleep &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SleepImpl();
        List&lt;/span&gt;&amp;lt;Interceptor&amp;gt; iList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Interceptor&amp;gt;&lt;span&gt;();
        iList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SleepBeforeAndAfter());
        Sleep sleepProxy &lt;/span&gt;=&lt;span&gt; (Sleep)Plugin.wrap(sleep,iList);
        sleepProxy.sleep();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在想对每个对象的方法进行拦截，直接实现Interceptor接口即可！实现其中的两个方法。此时我们新加的逻辑和原有的逻辑并没有什么交集。假如我们想在interceptor中的两个方法中使用被代理对象的各种属性，此时该怎么做？首先想到是将interceptor接口的两个方法添加参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepBeforeAndAfter implements Interceptor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptBefore(Object target, Method method, Object[] args)
            throws Exception {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;之前。。。interceptBefore(Object target, Method method, Object[] args)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptAfter(Object target, Method method, Object[] args)
            throws Exception {        
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;之后。。。interceptAfter(Object target, Method method, Object[] args)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，个人感觉没啥问题了【大牛如发现明显不符的请指出】。但但但但是我们奔着简单明了、面向对象的思想（其实就是mybatis源码插件设计）。我们做出进一步的精简。于是Invocation对象产生了。看到Method对象传进来了。我们是不是可以想到，我们不再 在Plugin中的invoke方法中调用method.invoke(target,args);了，而是在Intercetpor中处理完前后逻辑后进行调用。这样分工明确了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 拦截对象的包装
 * @author 魏正迪
 * 2018年10月13日
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Invocation {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object []args;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Method method;
    
    Invocation(Object target,Method method,Object[] args){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.args =&lt;span&gt; args;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.method =&lt;span&gt; method;
        
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 执行拦截对象的对应的方法
     * @return
     * @throws Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object process() throws Exception{
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; method.invoke(target, args);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时拦截器Interceptor应该是这样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Interceptor {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object intercept(Invocation invocation)throws Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepBeforeAndAfter implements Interceptor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object intercept(Invocation invocation) throws Exception{
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;拦截sleep方法要执行的方法之前&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Object result &lt;/span&gt;=&lt;span&gt; invocation.process();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;拦截sleep方法要执行的方法之后&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时Plugin应该是这样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Plugin implements InvocationHandler {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Interceptor interceptor;
    
    Plugin(Object target,Interceptor interceptor){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.interceptor =&lt;span&gt; interceptor;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {        
        Invocation invocation &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Invocation(target,method,args);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; interceptor.intercept(invocation);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object wrap(Object target,Interceptor interceptor){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(), 
                target.getClass().getInterfaces(), 
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Plugin(target,interceptor)
                );
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Sleep sleep &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SleepImpl();
        SleepBeforeAndAfter s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SleepBeforeAndAfter();
        Sleep sleepProxy1 &lt;/span&gt;=&lt;span&gt; (Sleep)Plugin.wrap(sleep,s);
        sleepProxy1.sleep();
        Sleep sleepProxy2 &lt;/span&gt;=&lt;span&gt; (Sleep)Plugin.wrap(sleepProxy1, s);
        sleepProxy2.sleep();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，mybatis插件开发的引言完毕！其实是使用了动态代理和责任链结合的方式。&lt;/p&gt;


</description>
<pubDate>Sat, 13 Oct 2018 15:14:00 +0000</pubDate>
<dc:creator>年轻的老魏</dc:creator>
<og:description>需求： 对原有系统中的方法进行‘拦截’，在方法执行的前后添加新的处理逻辑。 分析： 不是办法的办法就是，对原有的每个方法进行修改，添加上新的逻辑；如果需要拦截的方法比较少，选择此方法到是会节省成本。但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/oldwei/p/9784708.html</dc:identifier>
</item>
<item>
<title>【10.13】Bug Bounty Write-up 总结 - zoe宇</title>
<link>http://www.cnblogs.com/zz0eyu/p/9784423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zz0eyu/p/9784423.html</guid>
<description>&lt;p&gt;今天惯例邮箱收到了Twitter的邮件提醒有新的post，这种邮件每天都能收到几封，正好看到一个Bug Bounty的write up，比较感兴趣，看起来也在我的理解范围之内，这里对这篇write up和另一篇一起做一个总结，希望能对自己对于web security的学习和bug bounty的路程有所帮助。&lt;/p&gt;
&lt;h2&gt;write-up 地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/bugbountywriteup/add-description-to-instagram-posts-on-behalf-of-other-users-6500-7d55b4a24c5a&quot;&gt;Add description to Instagram Posts on behalf of other users - 6500$&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@tbmnull/making-an-xss-triggered-by-csp-bypass-on-twitter-561f107be3e5&quot;&gt;Making an XSS triggered by CSP bypass on Twitter&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Instagram的漏洞&lt;/h2&gt;
&lt;p&gt;一开始&lt;a href=&quot;https://medium.com/@JubaBaghdad?source=post_header_lockup&quot;&gt;作者Sarmad Hassan (Juba Baghdad)&lt;/a&gt;本来想在facebook的页面绕开instagram的验证策略，但是在之后浏览Instgram的官网过程中，发现了&lt;span&gt;Instgram显示的一个新功能&lt;/span&gt;IGTV，您可以通过这个功能发布一个竖屏视频，也可以浏览其他人发布的IGTV视频。&lt;/p&gt;
&lt;p&gt;在测试这个新功能时，作者发现视频发布后，&lt;span&gt;点击编辑选项并通过butpsuite拦截发出的请求&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
POST /media/1887820989027383407/edit/

caption=test&amp;amp;publish_mode=igtv&amp;amp;title=test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上请求中，路径中的1887820989027383407是一个media ID，而&lt;span&gt;作者发现这个ID存在于在Instrgram发布的所有照片、普通视频和IGTV视频中&lt;/span&gt;，而你可以在这些照片或视频中添加可选的Description，IGTV的描述就对用于请求中的caption选项。&lt;/p&gt;
&lt;p&gt;所以如果把media ID换成其他人发布的内容的ID呢？&lt;/p&gt;
&lt;p&gt;首先是怎样找到media ID，作者发现有两种方式&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查看发出内容的网页源码&lt;/li&gt;
&lt;li&gt;点击发出内容的like按钮，并拦截请求&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;之后的过程就很顺利了，只要其他人发布的内容中并没有添加描述，就可以通过这种方式进行修改。虽然修改media ID之后发出的请求返回了一个带有错误信息的响应，但是对应的其他人发布内容的description已经被改变了。&lt;/p&gt;
&lt;p&gt;从这一个漏洞中我可以学到&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;经常浏览关注网站的网页，查看是否有新的功能出现，这种新功能往往会存在漏洞&lt;/li&gt;
&lt;li&gt;在存在交互，有上传内容的地方，多拦截请求，查看请求中是否有值得注意的地方&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我觉得对于我自己来说，拦截请求这一块是很容易想到的，但更多可能会注意到其中的参数，而不是网址中的那个media ID，而且之后还要由此联想到去修改其他人发布的内容。&lt;/p&gt;
&lt;h2&gt;Twitter的XSS漏洞&lt;/h2&gt;
&lt;p&gt; 这个漏洞发现者&lt;a href=&quot;https://medium.com/@tbmnull?source=post_header_lockup&quot;&gt;tbmnull&lt;/a&gt;一开始就是在&lt;span&gt;挖掘Twitter的子域名&lt;/span&gt;，然后找到了这样一个可能存在xss的网址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https://careers.twitter.com/en/jobs-search.html?location=1&quot; onmouseover=”alert(1)&amp;amp;q=1&amp;amp;start=70&amp;amp;team=
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 但是由于&lt;span&gt;存在CSP&lt;/span&gt;，阻止了js代码的执行，弹窗无法弹出，所以关键在于怎样绕过CSP。&lt;/p&gt;
&lt;p&gt;作者花费了很多功夫找到了一个网址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https://analytics.twitter.com/tpm?tpm_cb=
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请求该网址，&lt;span&gt;响应的Content-Type是application/javascript，而且参数tpm_cb会直接反射到页面上&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;所以作者把这两个发现结合到一起，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https://careers.twitter.com/en/jobs-search.html?location=1&quot;&amp;gt;&amp;lt;script src=//analytics.twitter.com/tpm?tpm_cb=alert(document.domain)&amp;gt;//
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于两个网址同源，绕过了CSP对js脚本的限制，最终成功弹窗。&lt;/p&gt;
&lt;p&gt;这个漏洞的挖掘思路我个人觉得更符合一般漏洞挖掘的步骤，很多时间和精力+一点点运气，虽然作者在write-up中并没有多提，但是很显然这两个网址的发现是很不容易的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从子域名开始的漏洞挖掘方法，是否可以写一个爬虫，对网站的子域名进行总结，以及对各种url进行分析，分离出参数&lt;/li&gt;
&lt;li&gt;提交的请求中，网页中原本无法编辑（只能通过列表选择）的位置，也可以通过拦截请求进行修改&lt;/li&gt;
&lt;li&gt;XSS为什么没有发挥作用？是否可以绕过？&lt;/li&gt;
&lt;li&gt;怎样绕过CSP——同源是关键&lt;/li&gt;
&lt;li&gt;漏洞的挖掘需要很耐心和仔细，不要着急&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;以上，是我今天看的两篇write-up，感觉学习web security还是要多看这种实例，才能对各种漏洞有更清晰的认识和理解，之后希望每天都有时间看一两篇write-up，加油！&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 14:47:00 +0000</pubDate>
<dc:creator>zoe宇</dc:creator>
<og:description>今天惯例邮箱收到了Twitter的邮件提醒有新的post，这种邮件每天都能收到几封，正好看到一个Bug Bounty的write up，比较感兴趣，看起来也在我的理解范围之内，这里对这篇write u</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zz0eyu/p/9784423.html</dc:identifier>
</item>
<item>
<title>总结学习机器学习过程中用到的数据学知识 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/9784528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/9784528.html</guid>
<description>&lt;p&gt;现在机器学习行业持续加温，应届毕业生年薪持续走高，2019年毕业生算法岗年薪40万起，上不封顶，吸引着越来越多的人想往机器学习方向转。但是刚接触到算法时，看到那些数学公式都望而生畏，特别是公式的推导。今天本文就介绍机器学习会用到哪些数学知识，让那些想往机器学习方向转的同学心里有底，知道学习的方向。&lt;/p&gt;
&lt;p&gt;数学是机器学习的内功。作为机器学习的基石，数学知识无论如何是绕不开的，机器学习中大量的问题最终都可以归结为求解最优化问题，微积分、线性代数是最优化方法和理论的基础，很多机器学习算法的建模涉及到概率论，由此可见学好数学知识多么必要。不少准备或刚刚迈入机器学习的同学，在面临数学基础的学习时，会遇到两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不知道机器学习和深度学习到底要用到哪些数学知识&lt;/li&gt;
&lt;li&gt;无法真正理解这些数学知识，并用于机器学习的推导证明&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对此，Summer哥在本文中专门为大家解决这两个问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，在庞杂的数学系统内，哪些知识是在机器学习中真正有用的，对这些知识掌握到什么程度就足够了？&lt;/li&gt;
&lt;li&gt;其次，掌握了的数学知识怎么在机器学习领域内运用，即怎么从机器学习的角度去理解数学知识？&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;一机器学习所需要的数学知识&quot;&gt;一、机器学习所需要的数学知识&lt;/h5&gt;
&lt;p&gt;很多人对于机器学习中的数学知识，谈之色变，一想到实变函数、随机过程、泛函分析等等就不寒而栗。事实上，要理解和掌握绝大部分机器学习算法和理论，尤其是对做工程应用的人而言，真正所需要的数学知识不过尔尔，主要包括了：&lt;span&gt;微积分、线性代数、概率论、最优化方法&lt;/span&gt;&lt;br/&gt;下面我们来一一介绍一下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微积分&lt;/span&gt;&lt;br/&gt;先说微积分/高等数学。在机器学习中，微积分主要用到了微分部分，作用是求函数的极值，就是很多机器学习库中的求解器（solver）所实现的功能。在机器学习里会用到微积分中的以下知识点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导数和偏导数的定义与计算方法&lt;/li&gt;
&lt;li&gt;梯度向量的定义&lt;/li&gt;
&lt;li&gt;极值定理，可导函数在极值点处导数或梯度必须为0&lt;/li&gt;
&lt;li&gt;雅克比矩阵，这是向量到向量映射函数的偏导数构成的矩阵，在求导推导中会用到&lt;/li&gt;
&lt;li&gt;Hessian矩阵，这是2阶导数对多元函数的推广，与函数的极值有密切的联系&lt;/li&gt;
&lt;li&gt;凸函数的定义与判断方法&lt;br/&gt;泰勒展开公式&lt;/li&gt;
&lt;li&gt;拉格朗日乘数法，用于求解带等式约束的极值问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相比之下，积分、无穷级数、常微分方程、偏微分方程等在机器学习和深度学习中使用的相对较少。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线性代数&lt;/span&gt;&lt;br/&gt;相比之下，线性代数用的更多。在机器学习的几乎所有地方都有使用，具体用到的知识点有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;向量和它的各种运算，包括加法，减法，数乘，转置，内积&lt;/li&gt;
&lt;li&gt;向量和矩阵的范数，L1范数和L2范数&lt;/li&gt;
&lt;li&gt;矩阵和它的各种运算，包括加法，减法，乘法，数乘&lt;/li&gt;
&lt;li&gt;逆矩阵的定义与性质&lt;/li&gt;
&lt;li&gt;行列式的定义与计算方法&lt;/li&gt;
&lt;li&gt;二次型的定义&lt;/li&gt;
&lt;li&gt;矩阵的正定性&lt;/li&gt;
&lt;li&gt;矩阵的特征值与特征向量&lt;/li&gt;
&lt;li&gt;矩阵的奇异值分解&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;机器学习算法处理的数据一般都是向量、矩阵或者张量。经典的机器学习算法输入的数据都是样本的特征向量，深度学习算法在处理图像时输入的2维的矩阵或者3维的张量。掌握这些知识会使你游刃有余。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;概率论&lt;/span&gt;&lt;br/&gt;如果把机器学习所处理的样本数据看作随机变量/向量，我们就可以用概率论的观点对问题进行建模，这代表了机器学习中很大一类方法。在机器学习里用到的概率论知识点有:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;随机事件的概念，概率的定义与计算方法&lt;/li&gt;
&lt;li&gt;随机变量与概率分布，尤其是连续型随机变量的概率密度函数和分布函数&lt;/li&gt;
&lt;li&gt;条件概率与贝叶斯公式&lt;/li&gt;
&lt;li&gt;常用的概率分布，包括正态分布，伯努利二项分布，均匀分布&lt;/li&gt;
&lt;li&gt;随机变量的均值与方差，协方差&lt;/li&gt;
&lt;li&gt;随机变量的独立性&lt;/li&gt;
&lt;li&gt;最大似然估计&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最优化方法&lt;/span&gt;&lt;br/&gt;最后要说的是最优化，因为几乎所有机器学习算法归根到底都是在求解最优化问题。求解最优化问题的指导思想是在极值点出函数的导数/梯度必须为0。因此你必须理解梯度下降法，牛顿法这两种常用的算法，它们的迭代公式都可以从泰勒展开公式中得到。如果能知道坐标下降法、拟牛顿法就更好了。&lt;/p&gt;
&lt;p&gt;拉格朗日乘数法在机器学习中用的非常多，用于求解代等式约束的最优化问题，因此熟练的使用它是非常有必要的。&lt;/p&gt;
&lt;p&gt;凸优化是机器学习中经常会提及的一个概念，这是一类特殊的优化问题，它的优化变量的可行域是凸集，目标函数是凸函数。凸优化最好的性质是它的所有局部最优解就是全局最优解，因此求解时不会陷入局部最优解。如果一个问题被证明为是凸优化问题，基本上已经宣告此问题得到了解决。在机器学习中，线性回归、岭回归、支持向量机、logistic回归等很多算法求解的都是凸优化问题。&lt;/p&gt;
&lt;p&gt;拉格朗日对偶为带等式和不等式约束条件的优化问题构造拉格朗日函数，将其变为原问题，这两个问题是等价的。通过这一步变换，将带约束条件的问题转换成不带约束条件的问题。通过变换原始优化变量和拉格朗日乘子的优化次序，进一步将原问题转换为对偶问题，如果满足某种条件，原问题和对偶问题是等价的。这种方法的意义在于可以将一个不易于求解的问题转换成更容易求解的问题。在支持向量机中有拉格朗日对偶的应用。&lt;/p&gt;
&lt;p&gt;KKT条件是拉格朗日乘数法对带不等式约束问题的推广，它给出了带等式和不等式约束的优化问题在极值点处所必须满足的条件。在支持向量机中也有它的应用。&lt;/p&gt;
&lt;p&gt;看完这些，不少同学会安心不少，原来机器学习的数学基础知识大多已经学习过。除流形学习需要简单的微分几何概念之外，深层次的数学知识如实变函数，泛函分析等主要用在一些基础理论结果的证明上，即使不能看懂证明过程，也不影响我们使用具体的机器学习算法。概率图模型、流形学习中基于图的模型会用到图论的一些基本知识，如果学习过离散数学或者数据结构，这些概念很容易理解。&lt;/p&gt;
&lt;h5 id=&quot;二从机器学习的角度学习数学知识&quot;&gt;二、从机器学习的角度学习数学知识&lt;/h5&gt;
&lt;p&gt;不少同学对数学知识的掌握比较扎实，但是一转入机器学习中，就不知道从何下手应用。这就是缺乏了从机器学习的角度看待数学知识的素质。如何把数学知识运用到机器学习的算法中去呢？首先就是要熟知机器学习的算法和理论中对应着哪些数学知识？&lt;/p&gt;
&lt;p&gt;我们来看看典型算法和理论结论所用到的数学知识：&lt;img src=&quot;http://www.bigdata17.com/assets/images/jiqixuexishuxuezhishi.jpg&quot; title=&quot;机器学习数学知识&quot; alt=&quot;机器学习数学知识&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只有明白自己所学的数学知识可以应用到哪一块机器学习的算法或者理论中，才能更有针对的掌握对应的数学知识。另外无论是哪一门学问，都不是一蹴而就的，反反复复地去复习和运用知识，才能牢记掌握，机器学习中的数学知识也不例外。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 14:26:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>现在机器学习行业持续加温，应届毕业生年薪持续走高，2019年毕业生算法岗年薪40万起，上不封顶，吸引着越来越多的人想往机器学习方向转。但是刚接触到算法时，看到那些数学公式都望而生畏，特别是公式的推导。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/9784528.html</dc:identifier>
</item>
</channel>
</rss>