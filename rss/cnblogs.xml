<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>About Windows 10 SDK Preview Build 17110 - shaomeng</title>
<link>http://www.cnblogs.com/shaomeng/p/8546055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shaomeng/p/8546055.html</guid>
<description>&lt;p&gt;在 Windows Developer Day 活动同时，微软正式 Release 了 Windows 10 SDK Preview Build 17110。&lt;/p&gt;
&lt;p&gt;Windows 10 SDK Preview Build 17110 在 UI 设计，游戏，应用开发，应用发布和盈利等方向都有很多更新，下面我们在每个方向找出一些重点更新来详细看一下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UI 设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Adaptive and interactive toast notifications&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/design/shell/tiles-and-notifications/adaptive-interactive-toasts&quot; target=&quot;_blank&quot;&gt;Micrsoft Doc: Toast content &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自适应和可交互的应用通知可以提升应用的使用体验。本次 SDK 更新在通知方面的提升主要是通知中图片限制的调整，通知中的进度条和输入选项的增加。&lt;/p&gt;
&lt;p&gt;1. 图片尺寸限制&lt;/p&gt;
&lt;p&gt;图片来源包括：http://，ms-appx:///，ms-appdata:///&lt;/p&gt;
&lt;p&gt;对于网络图片，图片尺寸限制的单位是单个图片尺寸。16299 以后，normal connections 的限制是 3MB，metered connections 的限制是 1MB；而之前的限制统一是 200 KB。可以看到对网络图片的尺寸限制放宽了很多，很多高清晰度的图片也可以被使用。&lt;/p&gt;
&lt;p&gt;如果你的图片超过了这个尺寸限制，或者下载过程中失败，超时，通知会正常被显示，不过图片部分会被放弃。&lt;/p&gt;
&lt;p&gt;2. 进度条&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/design/shell/tiles-and-notifications/toast-progress-bar&quot; target=&quot;_blank&quot;&gt;Toast progress bar and data binding&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在某些场景，例如下载或其他过程进行时，需要在通知中显示进度条，让用户可以保持对进度的关注。进度条可以是不确定的或者确定的，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180318140816456-244735825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Design samples&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/design/downloads/index&quot; target=&quot;_blank&quot;&gt;Design toolkits and samples for UWP apps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Fluent Design 的演示 Sample - BuildCast 已经加入到 Design toolkits and samples 页面。展示了 Fluent Design 系统和 UWP 其他的功能。 &lt;/p&gt;
&lt;p&gt;BuildCast sample 也在 GitHub 开源：&lt;a href=&quot;https://github.com/Microsoft/BuildCast&quot; target=&quot;_blank&quot;&gt;https://github.com/Microsoft/BuildCast&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180318113205119-1569228480.jpg&quot; alt=&quot;&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外下列的工具箱都提供了控件和模板供 UWP 设计使用：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Embedded handwriting&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;文本控件加入了触控笔的支持，目前在 Windows 预览版系统中支持，用户可以使用触控笔直接在 TextBox，RichTextBox 和 AutoSuggestBox 控件中使用 Windows Ink 进行书写。在用户书写后，根据手写笔记转换成对应的文字，并保留手写的痕迹。&lt;/p&gt;
&lt;p&gt;大家可以在 Microsoft Store 下载 XAML Controls Gallery 应用来查看  TextBox 手写的 Demo，或者在 GitHub 下载 &lt;a href=&quot;https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/XamlUIBasics&quot; target=&quot;_blank&quot;&gt;Windows-universal-samples &lt;/a&gt;来查看控件的使用 Sample。&lt;/p&gt;
&lt;p&gt;来看看内置手写的官方演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180318101723293-104312791.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户可以在文本控件中任何位置进行书写，在候选窗口中识别出手写的结果并给用户推荐使用。用户可以选择一个结果，或在接受结果后继续书写。识别结果是逐个字母来识别的，所以识别结果不限于字典中的单词。在用户书写后，根据手写笔记转换成对应的文字，并保留手写的痕迹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180318102358138-352096965.png&quot; alt=&quot;&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户可以使用标准手势和操作来编辑文字：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 穿过或划掉 -- 穿过的动作去删除一个词或词的一部分&lt;/li&gt;
&lt;li&gt;连接 -- 在词之间画一个弧形来删除词之间的空格&lt;/li&gt;
&lt;li&gt;插入 -- 画一个插入符号可以插入一个空格&lt;/li&gt;
&lt;li&gt;重写 -- 在现有文字上书写可以替换它&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180318110627076-1111570161.png&quot; alt=&quot;&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用目标版本为 1803 或更新时才可以使用嵌入手写输入。把 &lt;span&gt;IsHandwritingViewEnabled  属性设置为 false 可以禁用这个功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;嵌入手写输入对于触屏设备会非常的方便易用，也会避免虚拟键盘操作的不方便。让触控笔的操作更加真实化，提高书写效率和体验。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Navigation view&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/design/controls-and-patterns/navigationview&quot; target=&quot;_blank&quot;&gt;Microsoft Doc: Navigation view&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Navigation View 控件提供了一个可收起的导航菜单作为 App 里的顶级导航，它实现自 nav pane 或  hamburger menu，可以针对不同的窗体尺寸自适应 pane 的显示模式。&lt;/p&gt;
&lt;p&gt;微软推荐在以下场景使用 Navigation View：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存在同一类型多个顶级导航元素，例如一个体育类 App 中包含不同的体育项目&lt;/li&gt;
&lt;li&gt;5-10 个顶级导航分类的场景&lt;/li&gt;
&lt;li&gt;提供一个易用的导航体验，容器中仅包含导航元素，不包含任何操作&lt;/li&gt;
&lt;li&gt;在小窗口时保留屏幕真实的观感&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 如果想了解更多关于导航的模式和基础概念，可以看这里：&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/design/basics/navigation-basics&quot; target=&quot;_blank&quot;&gt;Navigation design basics for UWP apps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NavigationView 控件有很多的内置行为实现自简单的 nav pane 模式。如果大家想要更多复杂的行为而 NavigationView 不支持，可以尝试 Master/Detail 模式。&lt;/p&gt;
&lt;p&gt;大家可以在 Microsoft Store 下载 XAML Controls Gallery 应用来查看  NavigationView 的 Demo，或者在 GitHub 下载 &lt;a href=&quot;https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/XamlUIBasics&quot; target=&quot;_blank&quot;&gt;Windows-universal-samples&lt;/a&gt; 来查看控件的使用 Sample。&lt;/p&gt;
&lt;p&gt;来看看 NavigationView 的 Demo：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180318100800270-401751095.jpg&quot; alt=&quot;&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;NavigationView &lt;/span&gt;&lt;span&gt;Loaded&lt;/span&gt;&lt;span&gt;=&quot;NavigationView_Loaded&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;0,12,0,0&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; SelectionChanged&lt;/span&gt;&lt;span&gt;=&quot;NavigationView_SelectionChanged&quot;&lt;/span&gt;&lt;span&gt;
x:Name&lt;/span&gt;&lt;span&gt;=&quot;nvSample&quot;&lt;/span&gt;&lt;span&gt;
IsSettingsVisible&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=settingsCheck,Path=IsChecked}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; IsTabStop&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt;
RS4Api:PaneTitle&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=paneText,Path=Text}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
RS4Api:IsBackButtonVisible&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=visibleCheck,Converter={StaticResource BooleanNegationToBackVisibilityConverter},Path=IsChecked}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
RS4Api:IsBackEnabled&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=enableCheck,Path=IsChecked}
Header=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is header text.&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;NavigationView.MenuItems&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;NavigationViewItem &lt;/span&gt;&lt;span&gt;Icon&lt;/span&gt;&lt;span&gt;=&quot;Play&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;Menu Item1&quot;&lt;/span&gt;&lt;span&gt; Tag&lt;/span&gt;&lt;span&gt;=&quot;SamplePage1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;NavigationViewItemSeparator&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;NavigationViewItem &lt;/span&gt;&lt;span&gt;Icon&lt;/span&gt;&lt;span&gt;=&quot;Save&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;Menu Item2&quot;&lt;/span&gt;&lt;span&gt; Tag&lt;/span&gt;&lt;span&gt;=&quot;SamplePage2&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;NavigationViewItem &lt;/span&gt;&lt;span&gt;Icon&lt;/span&gt;&lt;span&gt;=&quot;Refresh&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;Menu Item3&quot;&lt;/span&gt;&lt;span&gt; Tag&lt;/span&gt;&lt;span&gt;=&quot;SamplePage3&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;NavigationView.MenuItems&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Frame &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;contentFrame&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Frame&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;NavigationView&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;游戏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Getting started for game development&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/gaming/getting-started&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://docs.microsoft.com/en-us/windows/uwp/gaming/getting-started&lt;/span&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果大家对 Windows 或 Xbox 的游戏开发有兴趣，可以看一下这里的入门指引：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 获取软件和工具，包括 Windows 10 系统，Visual Studio 等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 准备好开发的硬件，在硬件设备上打开开发者模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 运行一个 Demo 检查工作结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 加入一个开发者计划&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 注册一个开发者账号，让你可以把游戏发布到应用商店&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Graphics adapters&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;新增了几个 DXGI API，影响图形适配偏好和移除&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IDXGIFactory6  接口提供一个方法，可以枚举出基于 GPU 偏好的图形适配器列表&lt;/li&gt;
&lt;li&gt;DXGIDeclareAdapterRemovalSupport  方法声明了适配器移除的支持&lt;/li&gt;
&lt;li&gt;DXGI_GPU_PREFERENCE 描述了用于 App 运行的 GPU 偏好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;应用开发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Adaptive Cards&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一种可以让开发者以更通用和统一的方式来对卡片对展示和交互的方式。&lt;/p&gt;
&lt;p&gt;详情见 &lt;a href=&quot;http://www.cnblogs.com/shaomeng/p/8550751.html&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;&lt;strong&gt;Windows Developer Day - Adaptive Cards&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;&lt;span&gt;App Resource Group&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;AppResourceGroupInfo 提供了新的方法，让用户可以发起过渡状态，让 App 进入暂停，激活和终止状态。&lt;/p&gt;
&lt;p&gt;对应的方法名分别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;StartResumeAsync() -- 发起状态变化，让 App 变为激活状态；&lt;/li&gt;
&lt;li&gt;StartSuspendAsync() -- 发起状态变化，让 App 变为暂停状态；&lt;/li&gt;
&lt;li&gt;StartTerminateAsync() -- 发起状态变化，让 App 变为终止状态；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;Broad file-system access&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/packaging/app-capability-declarations&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;App capability declarations&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/files/file-access-permissions&quot; target=&quot;_blank&quot;&gt;File access permissions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;broadFileSystemAccess  能力允许应用访问文件系统，在不使用 filepicker 的前提下。需要在 Manifest 的 capability 中进行设置。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Console UWP apps&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/launch-resume/console-uwp&quot; target=&quot;_blank&quot;&gt;Create a Universal Windows Platform console app&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开发者可以使用 C++ /WinRT 或 CX /UWP 来创建 Console App，像 DOS 或 PowerShell 一样运行在控制台。Console App 的输入和输出都来自控制台。UWP 的 Console App 可以发布到 Microsoft Store，在 app list 中有一个主入口，一个主磁贴可以被固定到开始菜单。&lt;/p&gt;
&lt;p&gt;开发 UWP Console App 之前，需要下载 Console App (Universal) Project Templates, 地址：&lt;a href=&quot;https://aka.ms/E2nzbv&quot; target=&quot;_blank&quot;&gt;Visual Studio Marketplace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载模板后，就可以使用 C++ /WinRT 或 CX /UWP 来创建 UWP Console App 了，开发过程和普通的 Console App 很类似。&lt;/p&gt;
&lt;p&gt;UWP Console App 可以访问应用所在目录和所有子目录，因为它的模板中在 manifest 中添加了 AppExecutionAlias 的扩展，这种扩展让用户可以在控制台中输入缩写来启动应用，应用不需要在系统的应用启动目录中。&lt;/p&gt;
&lt;p&gt;同时开发者可以添加更广的文件系统访问权限，只需要通过 broadFileSystemAccess 的能力设置，详情见上面的介绍。&lt;/p&gt;
&lt;p&gt;同时 UWP Console App 也支持多实例运行，因为它的模板中在 manifest 中添加了 SupportsMultipleInstances 能力。&lt;/p&gt;
&lt;p&gt;模板同时添加了 &lt;em&gt;SubSystem=&quot;console&quot;&lt;/em&gt; 能力，标志了当前 App 是一个 Console App，它支持传统 Windows 和 IoT 项目。&lt;/p&gt;
&lt;p&gt;官方提出的几个 UWP Console App 的注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只能使用  C++ /WinRT 或 CX /UWP 来开发&lt;/li&gt;
&lt;li&gt;目标必须是 桌面或 IoT 项目类型&lt;/li&gt;
&lt;li&gt;应用中不能创建窗体，所以 MessageBox 这样的窗体不能使用&lt;/li&gt;
&lt;li&gt;不支持后台任务&lt;/li&gt;
&lt;li&gt;不支持激活协议，如文件和协议等&lt;/li&gt;
&lt;li&gt;支持多实例，但不支持多实例重定向&lt;/li&gt;
&lt;li&gt;Win32 API 可用列表：&lt;a href=&quot;https://docs.microsoft.com/uwp/win32-and-com/win32-and-com-for-uwp-apps&quot; target=&quot;_blank&quot;&gt;Win32 and COM APIs for UWP apps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;Machine Learning&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;千呼万唤始出来的 Windows AI Platform 和 Windows Machine Learning。&lt;/p&gt;
&lt;p&gt;详情见 &lt;em&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/shaomeng/p/8540860.html&quot; target=&quot;_blank&quot;&gt;Windows Developer Day - Windows AI Platform&lt;/a&gt; &lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Multi-instance UWP apps&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/launch-resume/multi-instance-uwp&quot; target=&quot;_blank&quot;&gt;Create a multi-instance Universal Windows App&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;UWP App 可以通过配置来支持多实例，如果一个实例正在运行，一个运行的请求发过来，平台不会激活目前存在的实例，而是会创建一个新的实例，运行在一个单独的进程中，这个特性在 1803 版本开始被支持。 &lt;/p&gt;
&lt;p&gt;同样的，多实例特性需要在 Visual Studio 中安装新的项目模板：&lt;a href=&quot;https://aka.ms/E2nzbv&quot; target=&quot;_blank&quot;&gt;Multi-Instance App Project Templates.VSIX&lt;/a&gt;, 安装后，使用 C# 和 C++ 都可以创建项目。&lt;/p&gt;
&lt;p&gt;两个模板会被安装：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Multi-Instance UWP app -- 创建一个多实例的 App&lt;/li&gt;
&lt;li&gt;Multi-Instance Redirection UWP app -- 提供一个附加的逻辑，让用户可以选择启动新实例，或者选择目前激活的实例。可以想象一下 Office 打开或编辑文件时的场景。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两个模板都会在 manifest 文件中添加 SupportsMultipleInstances，其中 desktop4 和 iot2 前缀标志了项目只支持传统桌面 Windows 和 IoT 系统。manifest 配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Package
  &lt;/span&gt;&lt;span&gt;...
  xmlns:desktop4&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/manifest/desktop/windows10/4&quot;&lt;/span&gt;&lt;span&gt;
  xmlns:iot2&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/manifest/iot/windows10/2&quot;&lt;/span&gt;&lt;span&gt;  
  IgnorableNamespaces&lt;/span&gt;&lt;span&gt;=&quot;uap mp desktop4 iot2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  ...
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Applications&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Application &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;App&quot;&lt;/span&gt;&lt;span&gt;
      ...
      desktop4:SupportsMultipleInstances&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
      iot2:SupportsMultipleInstances&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Applications&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
   ...
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而 Multi-Instance Redirection UWP app 中对于当前实例的选择，在应用 OnLaunched() 和 OnActivated() 方法执行前的 Main() 方法中进行。这样就可以在任何其他代码执行前，决定哪个实例被激活。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; First, we'll get our activation event args, which are typically richer
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; than the incoming command-line args. We can use these in our app-defined
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; logic for generating the key for this instance.&lt;/span&gt;
        IActivatedEventArgs activatedArgs =&lt;span&gt; AppInstance.GetActivatedEventArgs();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; In some scenarios, the platform might indicate a recommended instance.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If so, we can redirect this activation to that instance instead, if we wish.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (AppInstance.RecommendedInstance != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            AppInstance.RecommendedInstance.RedirectActivationTo();
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Define a key for this instance, based on some app-specific logic.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the key is always unique, then the app will never redirect.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the key is always non-unique, then the app will always redirect&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; key = Guid.NewGuid().ToString(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; always unique.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;string key = &quot;Some-App-Defined-Key&quot;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; never unique.&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; instance =&lt;span&gt; AppInstance.FindOrRegisterInstanceForKey(key);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (instance.IsCurrentInstance)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we successfully registered this instance, we can now just
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; go ahead and do normal XAML initialization.&lt;/span&gt;
                &lt;span&gt;global&lt;/span&gt;::Windows.UI.Xaml.Application.Start((p) =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; App());
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Some other instance has registered for this key, so we'll 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; redirect this activation to that instance instead.&lt;/span&gt;
&lt;span&gt;                instance.RedirectActivationTo();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Screen capture&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/audio-video-camera/screen-capture&quot; target=&quot;_blank&quot;&gt;Microsoft Doc: Screen capture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 Windows 10 1803 版本后，SDK 提供 API 可以获取当前显示或应用窗口的图形帧，创建视频流或截屏。有了这个功能，开发者可以调用系统 UI 选择截图的范围，同时被截图的区域会有一个黄色的边框提示。具体实现方式，可以参考上面链接中的示例代码。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Windows Mixed Reality&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为支持高速发展的 Windows MR 平台，新的 API 被添加到 Windows.Graphic.Holographic 和 Windows.UI.Input.Spatial 命名空间。 &lt;/p&gt;
&lt;p&gt;Windows MR 是一个很有前景的平台，有兴趣的开发者可以在 &lt;a href=&quot;https://developer.microsoft.com/en-us/windows/mixed-reality&quot; target=&quot;_blank&quot;&gt;Windows Mixed Reality&lt;/a&gt; 获取更多信息。 &lt;/p&gt;

&lt;p&gt;&lt;span&gt;应用发布和盈利&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Enter free-form prices in a specific market's local currency&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/publish/set-and-schedule-app-pricing&quot; target=&quot;_blank&quot;&gt;Set and schedule app pricing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当开发者针对某个特性市场重新制定 App 的价格时，不再局限于标准的价格选择，而是可以选择自己输入特定的价格数值。&lt;/p&gt;

&lt;p&gt;目前的 17110 SDK 重点大致就是这些了，等 SDK 正式发布后，我们会再针对新的变化进行进一步的了解。&lt;/p&gt;
</description>
<pubDate>Sun, 18 Mar 2018 07:38:00 +0000</pubDate>
<dc:creator>shaomeng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shaomeng/p/8546055.html</dc:identifier>
</item>
<item>
<title>小白也能懂的手写体识别 - skyme</title>
<link>http://www.cnblogs.com/skyme/p/8595642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyme/p/8595642.html</guid>
<description>&lt;p&gt;如同所有语言的hello world一样，手写体识别就相当于深度学习里的hello world。&lt;/p&gt;
&lt;p&gt;TensorFlow是当前最流行的机器学习框架，有了它，开发人工智能程序就像Java编程一样简单。&lt;/p&gt;
&lt;h3&gt;MNIST&lt;/h3&gt;
&lt;p&gt;MNIST 数据集已经是一个被”嚼烂”了的数据集, 很多教程都会对它”下手”, 几乎成为一个 “典范”. 不过有些人可能对它还不是很了解, 下面来介绍一下.&lt;/p&gt;
&lt;p&gt;MNIST 数据集可在 &lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot;&gt;http://yann.lecun.com/exdb/mnist/&lt;/a&gt; 获取, 它包含了四个部分:&lt;/p&gt;
&lt;p&gt;   Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本) &lt;br/&gt;&lt;span&gt;      &lt;/span&gt; Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)&lt;br/&gt;        Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)&lt;br/&gt;        Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签)&lt;/p&gt;
&lt;p&gt;MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST). 训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据.&lt;/p&gt;
&lt;p&gt;tensorflow提供一个input_data.py文件，专门用于下载mnist数据，我们直接调用就可以了，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow.examples.tutorials.mnist.input_data
mnist &lt;/span&gt;= input_data.read_data_sets(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MNIST_data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, one_hot=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行完成后，会在当前目录下新建一个文件夹MNIST_data&lt;/p&gt;
&lt;p&gt;input_data文件会调用一个maybe_download函数，确保数据下载成功。这个函数还会判断数据是否已经下载，如果已经下载好了，就不再重复下载。&lt;/p&gt;

&lt;p&gt;把图片当成一枚枚像素来看，下图为手写体数字1的图片，它在计算机中的存储其实是一个二维矩阵，每个元素都是0~1之间的数字，0代表白色，1代表黑色，小数代表某种程度的灰色。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/133059/201803/133059-20180318153336094-40850518.png&quot;&gt;&lt;img title=&quot;image&quot; border=&quot;0&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/133059/201803/133059-20180318153336568-1376598027.png&quot; width=&quot;696&quot; height=&quot;309&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在，对于MNIST数据集中的图片来说，我们只要把它当成长度为784的向量就可以了（忽略它的二维结构，28×28=784）。我们的任务就是让这个向量经过一个函数后输出一个类别。就是下边这个函数，称为Softmax分类器。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/133059/201803/133059-20180318153337004-1217571980.png&quot;&gt;&lt;img title=&quot;image&quot; border=&quot;0&quot; alt=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/133059/201803/133059-20180318153337517-255442452.png&quot; width=&quot;715&quot; height=&quot;214&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个式子里的图片向量的长度只有3，用x表示。乘上一个系数矩阵W，再加上一个列向量b，然后输入softmax函数，输出就是分类结果y。W是一个权重矩阵，W的每一行与整个图片像素相乘的结果是一个分数score，分数越高表示图片越接近该行代表的类别。因此，W x + b 的结果其实是一个列向量，每一行代表图片属于该类的评分。通常分类的结果并非评分，而是概率，表示有多大的概率属于此类别。因此，Softmax函数的作用就是把评分转换成概率，并使总的概率为1。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;卷积神经网络&lt;/strong&gt;（Convolutional Neural Networks / CNNs / ConvNets）与普通神经网络非常相似，它们都由具有可学习的权重和偏置常量(biases)的神经元组成。每个神经元都接收一些输入，并做一些点积计算，输出是每个分类的分数，普通神经网络里的一些计算技巧到这里依旧适用。&lt;/p&gt;
&lt;p&gt;卷积神经网络利用输入是图片的特点，把神经元设计成三个维度 ： &lt;strong&gt;width&lt;/strong&gt;, &lt;strong&gt;height&lt;/strong&gt;, &lt;strong&gt;depth&lt;/strong&gt;(注意这个depth不是神经网络的深度，而是用来描述神经元的) 。比如输入的图片大小是 32 × 32 × 3 (rgb)，那么输入神经元就也具有 32×32×3 的维度。下面是图解：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; alt=&quot;这里写图片描述&quot; src=&quot;http://img.blog.csdn.net/20160404000039222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个卷积神经网络由很多层组成，它们的输入是三维的，输出也是三维的，有的层有参数，有的层不需要参数。&lt;/p&gt;
&lt;p&gt;卷积神经网络通常包含以下几种层：  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据输入层：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该层要做的处理主要是对原始图像数据进行预处理，其中包括：&lt;br/&gt;• 去均值：把输入数据各个维度都中心化为0，如下图所示，其目的就是把样本的中心拉回到坐标系原点上。&lt;br/&gt;• 归一化：幅度归一化到同样的范围，如下所示，即减少各维度数据取值范围的差异而带来的干扰，比如，我们有两个维度的特征A和B，A范围是0到10，而B范围是0到10000，如果直接使用这两个特征是有问题的，好的做法就是归一化，即A和B的数据都变为0到1的范围。&lt;br/&gt;• PCA/白化：用PCA降维；白化是对数据各个特征轴上的幅度归一化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;卷积层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;卷积神经网路中每层卷积层由若干卷积单元组成，每个卷积单元的参数都是通过反向传播算法优化得到的。卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网络能从低级特征中迭代提取更复杂的特征。 &lt;/p&gt;
&lt;p&gt;下面的动态图形象地展示了卷积层的计算过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1093303/201704/1093303-20170430194655881-1051795560.gif&quot;/&gt;&lt;br/&gt;    &lt;strong&gt;线性整流层（Rectified Linear Units layer, ReLU layer），&lt;/strong&gt;这一层神经的活性化函数（Activation function）使用线性整流（Rectified Linear Units, ReLU）f(x)=max(0,x）&lt;/p&gt;
&lt;p&gt;把卷积层输出结果做非线性映射。&lt;br/&gt;&lt;img alt=&quot;&quot; src=&quot;https://images2015.cnblogs.com/blog/1093303/201704/1093303-20170430194934006-705271151.jpg&quot; width=&quot;571&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;     &lt;strong&gt;池化层（Pooling layer），&lt;/strong&gt;通常在卷积层之后会得到维度很大的特征，将特征切成几个区域，取其最大值或平均值，得到新的、维度较小的特征。&lt;/p&gt;
&lt;p&gt;池化层的具体作用。&lt;/p&gt;
&lt;p&gt;1.特征不变性，也就是我们在图像处理中经常提到的特征的尺度不变性，池化操作就是图像的resize，平时一张狗的图像被缩小了一倍我们还能认出这是一张狗的照片，这说明这张图像中仍保留着狗最重要的特征，我们一看就能判断图像中画的是一只狗，图像压缩时去掉的信息只是一些无关紧要的信息，而留下的信息则是具有尺度不变性的特征，是最能表达图像的特征。&lt;/p&gt;
&lt;p&gt;2.特征降维，我们知道一幅图像含有的信息是很大的，特征也很多，但是有些信息对于我们做图像任务时没有太多用途或者有重复，我们可以把这类冗余信息去除，把最重要的特征抽取出来，这也是池化操作的一大作用。&lt;/p&gt;
&lt;p&gt;3.在一定程度上防止过拟合，更方便优化。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://images2015.cnblogs.com/blog/1093303/201704/1093303-20170430195028600-318072954.jpg&quot;/&gt;&lt;br/&gt;    池化层用的方法有Max pooling 和 average pooling，而实际用的较多的是Max pooling。&lt;br/&gt;     &lt;strong&gt;全连接层（ Fully-Connected layer）,&lt;/strong&gt; 把所有局部特征结合变成全局特征，用来计算最后每一类的得分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Caffe&lt;/strong&gt;&lt;br/&gt;• 源于Berkeley的主流CV工具包，支持C++,python,matlab&lt;br/&gt;• Model Zoo中有大量预训练好的模型供使用&lt;br/&gt;&lt;strong&gt;    Torch&lt;/strong&gt;&lt;br/&gt;• Facebook用的卷积神经网络工具包&lt;br/&gt;• 通过时域卷积的本地接口，使用非常直观&lt;br/&gt;• 定义新网络层简单&lt;br/&gt;&lt;strong&gt;    TensorFlow&lt;/strong&gt;&lt;br/&gt;• Google的深度学习框架&lt;br/&gt;• TensorBoard可视化很方便&lt;br/&gt;• 数据和模型并行化好，速度快&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
Spyder Editor

This is a temporary script file.
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-  &lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf  
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.examples.tutorials.mnist &lt;span&gt;import&lt;/span&gt;&lt;span&gt; input_data  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;number from 0 to 9:  &lt;/span&gt;
mnist=input_data.read_data_sets(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MNIST_data/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,one_hot=&lt;span&gt;True)  
  
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; add_layer(inputs,in_size,out_size,activation_function=&lt;span&gt;None):  
    Weights&lt;/span&gt;=&lt;span&gt;tf.Variable(tf.random_normal([in_size,out_size]))  
    bises&lt;/span&gt;=tf.Variable(tf.zeros([1,out_size])+0.1&lt;span&gt;)  
    Wx_plus_b&lt;/span&gt;=tf.matmul(inputs,Weights)+&lt;span&gt;bises  
  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; activation_function &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:  
        outputs&lt;/span&gt;=&lt;span&gt;Wx_plus_b  
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:  
        outputs&lt;/span&gt;=&lt;span&gt;activation_function(Wx_plus_b)  
  
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; outputs  
  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算准确度  &lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; compute_accuracy(x,y):  
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; prediction  
    y_pre&lt;/span&gt;=sess.run(prediction,feed_dict=&lt;span&gt;{xs:x})  
    correct_prediction&lt;/span&gt;=tf.equal(tf.argmax(y_pre,1),tf.argmax(y,1&lt;span&gt;))  
    accuracy&lt;/span&gt;=&lt;span&gt;tf.reduce_mean(tf.cast(correct_prediction,tf.float32))  
    result&lt;/span&gt;=sess.run(accuracy,feed_dict=&lt;span&gt;{xs:x,ys:y})  
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result  
  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;def placeholder for inputs  &lt;/span&gt;
xs=tf.placeholder(tf.float32,[None,784])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;28*28  &lt;/span&gt;
ys=tf.placeholder(tf.float32,[None,10])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;10个输出  &lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;add output layer  &lt;/span&gt;
prediction=add_layer(xs,784,10,tf.nn.softmax)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;softmax常用于分类  &lt;/span&gt;
&lt;span&gt;  
cross_entropy&lt;/span&gt;=tf.reduce_mean(-tf.reduce_sum(ys*tf.log(prediction),reduction_indices=[1&lt;span&gt;]))  
train&lt;/span&gt;=tf.train.GradientDescentOptimizer(0.3&lt;span&gt;).minimize(cross_entropy)  
  
sess&lt;/span&gt;=&lt;span&gt;tf.Session()  
sess.run(tf.initialize_all_variables())  
  
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(2000&lt;span&gt;):  
    batch_xs,batch_ys&lt;/span&gt;=mnist.train.next_batch(100&lt;span&gt;)  
    sess.run(train,feed_dict&lt;/span&gt;=&lt;span&gt;{xs:batch_xs,ys:batch_ys})  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i%100==&lt;span&gt;0:  
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(compute_accuracy(mnist.test.images,mnist.test.labels))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行看输出，准确度为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Extracting MNIST_data/train-images-idx3-&lt;span&gt;ubyte.gz
Extracting MNIST_data&lt;/span&gt;/train-labels-idx1-&lt;span&gt;ubyte.gz
Extracting MNIST_data&lt;/span&gt;/t10k-images-idx3-&lt;span&gt;ubyte.gz
Extracting MNIST_data&lt;/span&gt;/t10k-labels-idx1-&lt;span&gt;ubyte.gz
&lt;/span&gt;0.1007
0.6668
0.7603
0.7946
0.8198
0.8324
0.8416
0.8473
0.8544
0.8565
0.8634
0.8661
0.8654
0.8692
0.8725
0.8727
0.8748
0.8753
0.8771
0.8781
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;准确率为87%。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;上面的例子使用的是TensorFlow提供的数据集，我们可以自己手写一个数字，然后通过opencv对数字进行剪裁，然后输入模型看识别的结果。&lt;/p&gt;
&lt;p&gt;深度学习和nlp的可以加微信群交流，目前，我们正在参加nlp方面的比赛。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/133059/201803/133059-20180318153337963-1197293995.jpg&quot;&gt;&lt;img title=&quot;webwxgetmsgimg&quot; border=&quot;0&quot; alt=&quot;webwxgetmsgimg&quot; src=&quot;https://images2018.cnblogs.com/blog/133059/201803/133059-20180318153338446-1489641110.jpg&quot; width=&quot;322&quot; height=&quot;572&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Mar 2018 07:34:00 +0000</pubDate>
<dc:creator>skyme</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyme/p/8595642.html</dc:identifier>
</item>
<item>
<title>python web开发-flask调试模式 - 挨踢学霸</title>
<link>http://www.cnblogs.com/itxb/p/8595632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itxb/p/8595632.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;使用run()方式可以启动flask应用，但是每次修改代码之后，需要重新启动，这样对于调试就很不太方便。Flask的调试模式可以让代码在每次修改之后自动载入。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;有两种方法可以启用flask的调试模式&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接设置app的debug为true:&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;app.debug=true&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把debug=true作为参数，传入到run方法&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;app.run(debug=true)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;以第一种方法为例，当我们设置debug模式后，console窗口的输出会有相应的变化&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1301686/201803/1301686-20180318153227012-656806159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;现在访问应用的首页：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1301686/201803/1301686-20180318153230725-268765909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;修改一下首页的代码：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;@app.route(&lt;strong&gt;&quot;/&quot;&lt;/strong&gt;)&lt;br/&gt;&lt;strong&gt;def&lt;/strong&gt; index():&lt;br/&gt;    &lt;strong&gt;return&lt;/strong&gt; &lt;strong&gt;&quot;Index Page with Debug&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;修改后，可以看到console窗口的输出&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1301686/201803/1301686-20180318153236014-225676335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;然后直接刷新页面：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1301686/201803/1301686-20180318153239524-366614618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;修改已经生效！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Debug模式对于开发过程的调试非常方便，但是出于安全考试，生产环境，一定不要使用debug模式。&lt;/p&gt;
</description>
<pubDate>Sun, 18 Mar 2018 07:33:00 +0000</pubDate>
<dc:creator>挨踢学霸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itxb/p/8595632.html</dc:identifier>
</item>
<item>
<title>项目微管理10 - 工匠 - 沙场秋点兵</title>
<link>http://www.cnblogs.com/dxy1982/p/8595334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dxy1982/p/8595334.html</guid>
<description>&lt;p&gt;在这两年的政府报告中，“克强经济学”屡次提到一个词叫“工匠精神”。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;工匠精神&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;工匠精神，是指工匠对自己的产品精雕细琢，精益求精的精神理念。工匠们喜欢不断雕琢自己的产品，不断改善自己的工艺，享受着产品在双手中升华的过程。&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180318142248939-701010208.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;说到“工匠精神”，就不得不提一下它的代表人物-英国航海钟发明者：约翰·哈里森 。&lt;/p&gt;

&lt;p&gt;木匠出生的哈里森费时40余年，经过不断研究和试验，先后造出了五台航海钟，其中最优秀的“哈氏4号”，航行了64天，只慢了5秒，完美解决了航海经度定位问题。这就是典型的“工匠精神”，虽然同时他也是为了获得2万英镑的奖金。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180318142450772-1952817380.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;四代小的时候，还是各种工匠盛行的时候。记得有一年，四代家刚搬进新家以后，觉的客厅需要一套家具，于是找了邻村的一个木匠打了一套家具。这么多年了，这套家具家具还摆在这个老房子里，质量那是杠杠的。&lt;/p&gt;

&lt;p&gt;对于好的木匠来说，他时刻都会在可能的前提下，不断的完善家具的细节，因为他从师傅那就是这么学下来的，这就是他们传承下来的“火的意志”（《火隐忍者》语），这里有他们作为专业人士的责任感、对产品的敬畏感，对职业的荣誉感。&lt;/p&gt;

&lt;p&gt;当然了，也有息息相关的利益在里面，因为做不好就不会有客户，没有客户就要饿肚子。&lt;/p&gt;

&lt;p&gt;老实说，这些东西靠任何的培训和流程是无法传递的，只有靠师徒之间的情感交流和行为感染，才能传承和发扬。对于现在的很多公司来说，缺少的就是这种传帮带，这种工匠的精神。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;重构就是工匠精神的体现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;而重构就是工匠精神在软件开发中的体现，重构就是对代码精雕细琢，精益求精，不断打磨的过程。&lt;/p&gt;

&lt;p&gt;四代认为，软件代码设计具有两个特点：&lt;/p&gt;

&lt;p&gt;第一个特点是设计具有静态性，也就是说在某个时间点上，设计总是此刻软件功能的代码实现。在这个特定的时刻，团队基于目前掌握的需求和反馈，采用编程的基本技术和原理，实现了软件的功能；这份实现的代码就是设计，这就是设计的“静态性”，也可以称为“时效性”。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180318143814461-1115190287.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;但是软件总是处于变化中的，不管是需求，还是技术，团队成员也是处于变化中的，不管是数量，还是质量，为了应对这种情况，设计必须要具有第二个特点：动态性。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180318143830957-524017472.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;在软件的整个生命周期中，团队总是基于需求的不断变化，技术的不断更新，团队成员的不断更替，不断调整实现软件功能的设计和代码，这就是设计的“动态性”，也可以称为“迭代性”。&lt;/p&gt;

&lt;p&gt;代码规范，设计原则，设计模式，架构等技术之所以非常重要，就是因为它们在软件静态设计中起着至关重要的作用。&lt;/p&gt;

&lt;p&gt;而重构之所以非常重要，是因为它在软件动态演化中起着至关重要的作用，它真实的反映了软件从一个稳定的状态变化到另一个稳定状态的合理方式，非常符合哲学中“量变和质变”的基本原理：&lt;strong&gt;那就是通过不断的重构去促成代码的量变，最终达到软件质量的质变&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;而四代坚定的认为项目经理必须首先是一个优秀的程序员的非常重要的一个原因就在于此，因为不是优秀的程序员不可能认识到这些。&lt;/p&gt;

&lt;p&gt;基于这些看法，在每个Release的开发任务中，四代是这么定义“任务的完成状态”的：&lt;strong&gt;代码提交，测试通过，尝试重构，尝试改善用户体验&lt;/strong&gt;。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180318145127584-523076767.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;重构和迭代构成了软件开发的基本旋律，深刻的阐述了“工匠精神”，在开发过程中深刻意识到它们的重要性并合理的利用它们可以使得代码质量始终保持在一个良性循环的状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;克己&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;确实，在不考虑任何其他因素的前提下，我们可以无限重构下去，让软件无限的接近此刻最完美的设计。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180318144256240-1155458181.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;可惜的是，我们不是活在真空中，我们的客户像嗷嗷待哺的孩子一样，正眼巴巴的等待着我们产品的发布。而公司也一样，对任何功能的规划都是有时间节点的，因为公司也像等着米下锅的巧妇一样，急切的盼望着产品及时发布。&lt;/p&gt;

&lt;p&gt;所以在真正的研发过程中，PC团队的重构工作有几点是四代特别强调的：&lt;/p&gt;

&lt;p&gt;第一，哪些东西要重构，哪些东西不重构。&lt;/p&gt;

&lt;p&gt;简单的说，新提交的代码，违反代码规范的要重构，有更优方案的要重构。那么有不用重构的吗？有，已有代码在工作正常，不需要修改的时候坚决不要去重构，除非吃饱了实在没事干的时候，可以考虑一下。而实际上，在堆积如山的需求面前，就没有这种情况。&lt;/p&gt;

&lt;p&gt;第二，什么时间点推荐重构，什么时间点可以不重构。&lt;/p&gt;

&lt;p&gt;在PC团队，当代码发现应该要重构的时候，当天就最好重构完。那么任何时候都要立即重构吗？不，进入集成测试最后一阶段，面临发布的时候，不推荐重构，尤其是大范围重构。&lt;/p&gt;

&lt;p&gt;在集成测试最后一阶段，四代会划分出一个阶段，叫“&lt;strong&gt;代码提交申请阶段&lt;/strong&gt;”，这阶段，任何人要提交代码都要向四代申请，通过后才能提交。而集成测试结束后的临发布阶段，叫“&lt;strong&gt;代码提交禁止阶段&lt;/strong&gt;”，在这阶段，不允许提交代码，除非四代觉得有必要修复的BUG，要求团队修复它，才能提交代码。而这两个阶段，都不需要执行重构。&lt;/p&gt;

&lt;p&gt;第三，重构要分布到每个Release中。&lt;/p&gt;

&lt;p&gt;很多人都梦想经过一次大范围，大面积的重构，整个软件的状态立即变好了，而现实条件下，这几乎是不可能的。且不说整体重构的难度有多大，就说时间这一项，公司就等不了，那得花多少时间啊，客户还在等新功能呢！&lt;/p&gt;

&lt;p&gt;所以，&lt;strong&gt;重构要分开到每个Release中，持续的进行&lt;/strong&gt;。汤师爷曾经说过：步子迈的大了容易扯着蛋。真是至理名言啊！&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180318144602470-373050162.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;但是做到这些也还是不够的，因为代码质量只是软件质量的一个侧面，四代觉得他们团队还需要别的手段来保证软件的质量，还缺些什么呢？&lt;/p&gt;
</description>
<pubDate>Sun, 18 Mar 2018 07:02:00 +0000</pubDate>
<dc:creator>沙场秋点兵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dxy1982/p/8595334.html</dc:identifier>
</item>
<item>
<title>IIC协议学习笔记 - NingHeChuan</title>
<link>http://www.cnblogs.com/ninghechuan/p/8595423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ninghechuan/p/8595423.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　IIC&lt;/span&gt;&lt;span&gt;总线（Inter-Integrated Circuit）即集成电路总线，是PHILIPS公司设计出来的一种简单、双向、二线制、同步串行总线。IIC总线是一个多向控制总线，多个器件（从机）可以同时挂载到一个主机控制的一条总线上。每个连接在总线上的设备都是通过唯一的地址和其他器件通信，主机和从机的角色可互换，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;主机和从机的概念。主机就是负责整个系统的任务协调与分配，从机一般是通过接收主机的指令从而完成某些特定的任务，主机和从机之间通过总线连接，进行数据通讯。我们平时使用的个人电脑也就是这个概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　IIC&lt;/span&gt;&lt;span&gt;协议为半双工协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　全双工指在发送数据的同时也能够接收数据，两者同步进行。目前的网卡一般都支持全双工。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　半双工就是指一个时间段内只有一个动作发生，早期的对讲机、以及早期集线器等设备都是基于半双工的产品。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　还有一种单工通信是指通信线路上的数据按单一方向传送.。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　数据有效传输在scl信号的高电平期间，sda数据线保持稳定，在scl为低电平时允许sda数据线变化。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201803/1057546-20180318143520769-621707765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　起始条件在scl为高电平期间，sda出现下降沿，则为起始信号。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201803/1057546-20180318143531064-1731551699.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　结束条件在scl为高电平期间，sda出现上升沿，则为结束信号。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201803/1057546-20180318143537203-1759456029.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　总结：当scl为高电平的时候，sda为出现下降沿为start位， sda出现上升沿为stop位，所以在scl为高电平的时候sda应该保持稳定不能随意乱动。这就又回到了数据传输有效的条件，只有在scl为低电平期间，才允许数据变化，在高电平期间，不允许数据变化，否则就会出现起始位或结束位。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　应答（ACK，Acknowledgement）。即确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。主机每向从机发送完一个字节的数据，从机总是需要等待从机给出一个应答信号，来确认从机是否成功接收到了数据，从机应答主机所需要的时钟也是由主机提供的，应答出现在每一次主机完成8个数据位传输后紧跟着的时钟周期，低电平0表示应答，1表示非应答。，需要应答时，数据发出方将SDA总线设置为3态输入，由于IIC总线上有上拉电阻，因此此时总线默认高电平，若数据接收方正确接收到数据，则数据接收方将SDA总线拉低，以示正确应答。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;　　IIC&lt;/span&gt;&lt;span&gt;传输时时从MSB开始传输到LSB结束。MSB是Most Significant Bit的缩写，最高有效位。在二进制数中，MSB是最高加权位。与十进制数字中最左边的一位类似。通常，MSB位于二进制数的最左侧，LSB位于二进制数的最右侧。LSB，英文 least significant bit，中文义最低有效位。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;IIC&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;写时序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201803/1057546-20180318143544986-23527266.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;ID_Address, REG_Address, W_REG_Data&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;（1）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;产生start位&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（2）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;传送器件地址ID_Address，器件地址的最后一位为数据的传输方向位，R/W，低电平0表示主机往从机写数据（W），1表示主机从从机读数据（R）。ACK应答，应答是从机发送给主机的应答，这里不用管。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（3）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;传送写入器件寄存器地址，即数据要写入的位置。同样ACK应答不用管。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（4）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;传送要写入的数据。ACK应答不用管。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（5）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;产生stop信号。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;IIC&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;读时序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201803/1057546-20180318143554993-1676942962.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;{ID_Address + REG_Address} + {ID_Address + R_REG_Data}&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（1）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;产生start信号&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（2）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;传送器件地址（写ID_Address），ACK。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（3）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;传送字地址（写REG_Address），ACK。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（4）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;再次产生start信号&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（5）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;再传送一次器件地址，ACK。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（6）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;读取一个字节的数据，读数据最后结束前无应答ACK信号。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;（7）&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;产生stop信号。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　从时序图上可以看出，IIC读时序要写两次器件地址，刚开始接触的时候我也很疑惑 dummy write。我个人这样理解这里，首先传送器件地址到总线上找到器件，然后写入寄存器地址，也就是word address找到需要读取数据的地址，但并不是真正的写入数据所以叫做dummy wirte（假写）。然后再传输一次器件地址后开始读数据。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　IIC&lt;/span&gt;&lt;span&gt;协议在读写数据时，总是要发送器件地址，这里需要注意的是，不是主机给从机发送地址，而是主机给地址总线上发送地址，挂IIC总线上的所有从机都能收到地址，如果发过来的地址和自己的地址匹配上了，从机就会给主机一个应答，这样就建立起来了一个通讯。所以我在想，如果从机的器件是完全一样的，那么IIC协议就可以同时给多个从机，即对多个器件进行配置。这种理论上是可行的，但其实是不行的，IIC协议就是通过地址不同来判断给哪个器件传送数据的，如果两个器件的地址完全一样，器件会产生应答，那么两个器件就通过竞争判断给谁通信了，有随机性。即IIC协议一次只能和一个设备/器件进行通讯。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;IIC&lt;/span&gt;&lt;span&gt;读写时序补充&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;双字节地址写时序，写入器件地址，写入寄存器地址高位、低位，然后写数据。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201803/1057546-20180318143604516-987274017.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;多数据写时序，写入器件地址，写入寄存器地址，连续写入数据。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201803/1057546-20180318143611658-591157855.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;双字节地址多数据写时序，写入器件地址，写入寄存器地址高位、低位，然后连续写入数据。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201803/1057546-20180318143617473-1884009631.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;双字节地址&lt;/span&gt;&lt;span&gt;读时序，写入器件地址，写入寄存器地址高位、低位，然后再次写入器件地址，写入数据。读数据最后结束前无应答ACK信号。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201803/1057546-20180318143622571-929939173.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　多数据读时序，写入器件地址，写入寄存器地址，，然后再次写入器件地址，连续写入数据。读数据最后结束前无应答ACK信号。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201803/1057546-20180318143630358-370535921.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　双字节地址多数据读时序，写入器件地址，写入寄存器地址，，然后再次写入器件地址，连续写入数据。读数据最后结束前无应答ACK信号。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201803/1057546-20180318143636615-1875012322.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1057546/201706/1057546-20170611114905559-478053885.jpg&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt; 转载请注明出处：NingHeChuan（宁河川）&lt;/p&gt;
&lt;p&gt;个人微信订阅号：开源FPGA&lt;/p&gt;
&lt;p&gt;如果你想及时收到个人撰写的博文推送，可以扫描左边二维码（或者长按识别二维码）关注个人微信订阅号&lt;/p&gt;
&lt;p&gt;知乎ID：&lt;a href=&quot;https://www.zhihu.com/people/zhu-he-chuan/activities&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微博ID：&lt;a href=&quot;http://weibo.com/6059461073/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: IIC协议学习记录&quot; href=&quot;http://www.cnblogs.com/ninghechuan/p/8595423.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/ninghechuan/p/8595423.html&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Mar 2018 06:40:00 +0000</pubDate>
<dc:creator>NingHeChuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ninghechuan/p/8595423.html</dc:identifier>
</item>
<item>
<title>属性动画 ValueAnimator 运行原理全解析 - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/8595422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/8595422.html</guid>
<description>&lt;p&gt;最近下班时间都用来健身还有看书了，博客被晾了一段时间了，原谅我~~~~&lt;/p&gt;

&lt;p&gt;好，废话不多说，之前我们已经分析过 &lt;a href=&quot;https://www.jianshu.com/p/48317612c164&quot;&gt;View 动画 Animation 运行原理解析&lt;/a&gt;，那么这次就来学习下属性动画的运行原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q1：我们知道，Animation 动画内部其实是通过 ViewRootImpl 来监听下一个屏幕刷新信号，并且当接收到信号时，从 DecorView 开始遍历 View 树的绘制过程中顺带将 View 绑定的动画执行。那么，属性动画（Animator）原理也是这样么？如果不是，那么它又是怎么实现的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2：属性动画（Animator）区别于 Animation 动画的就是它是有对 View 的属性进行修改的，那么它又是怎么实现的，原理又是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q3：属性动画（Animator）调用了 &lt;code&gt;start()&lt;/code&gt; 之后做了些什么呢？何时开始处理当前帧的动画工作？内部又进行了哪些计算呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;属性动画的使用，常接触的其实就是两个类 &lt;strong&gt;ValueAnimator&lt;/strong&gt;， &lt;strong&gt;ObjectAnimator&lt;/strong&gt;。其实还有一个 &lt;strong&gt;View.animate()&lt;/strong&gt;，这个内部原理也是属性动画，而且它已经将常用的动画封装好了，使用起来很方便，但会有一个坑，我们留着下一篇来介绍，本篇着重介绍属性动画的运行原理。&lt;/p&gt;
&lt;p&gt;先看看基本的使用步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//1.ValueAnimator用法  
ValueAnimator animator = ValueAnimator.ofInt(500);
animator.setDuration(1000);
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
               int value = (int) animation.getAnimatedValue();
               mView.setX(value);  
         }
 });
animator.start();

//2.ObjectAnimator用法
ObjectAnimator animator = ObjectAnimator.ofInt(mView, &quot;X&quot;, 500).setDuration(1000).start();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样你就可以看到一个执行了 1s 的平移动画，那么接下去就该开始跟着源码走了，我们需要梳理清楚，这属性动画是什么时候开始执行，如何执行的，真正生效的地方在哪里，怎么持续 1s 的，内部是如何进行计算的。&lt;/p&gt;
&lt;p&gt;在之前分析 Animation 动画运行原理后，我们也接着分析了 &lt;a href=&quot;https://www.jianshu.com/p/0d00cb85fdf3&quot;&gt;Android 屏幕刷新机制&lt;/a&gt;，通过这两篇，我们知道了 Android 屏幕刷新的关键其实是 Choreographer 这个类，感兴趣的可以再回去看看，这里提几点里面的结论：&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;我们知道，Android 每隔 16.6ms 会刷新一次屏幕，也就是每过 16.6ms 底层会发出一个屏幕刷新信号，当我们的 app 接收到这个屏幕刷新信号时，就会去计算屏幕数据，也就是我们常说的测量、布局、绘制三大流程。这整个过程关键的一点是，app 需要先向底层注册监听下一个屏幕刷新信号事件，这样当底层发出刷新信号时，才可以找到上层 app 并回调它的方法来通知事件到达了，app 才可以接着去做计算屏幕数据之类的工作。&lt;/p&gt;
&lt;p&gt;而注册监听以及提供回调接口供底层调用的这些工作就都是由 Choreographer 来负责，Animation 动画的原理是通过当前 View 树的 ViewRootImpl 的 &lt;code&gt;scheduleTraversals()&lt;/code&gt; 方法来实现，这个方法的内部逻辑会走到 Choreographer 里去完成注册监听下一个屏幕刷新信号以及接收到事件之后的工作。&lt;/p&gt;
&lt;p&gt;需要跟屏幕刷新信号打交道的话，归根结底最后都是通过 Choreographer 这个类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，当我们在过属性动画（Animator）的流程源码时，我们就有一个初步的目标了，至少我们知道了需要跟踪到 Choreographer 里才可以停下来。至于属性动画的流程原理是跟 Animation 动画流程一样通过 ViewRootImpl 来实现的呢？还是其他的方式？这些就是我们这次过源码需要梳理出来的了，那么下面就开始过源码吧。&lt;/p&gt;

&lt;p&gt;ps：本篇分析的源码基于 android-25 版本，版本不一样，源码可能会有些差别，大伙自己过的时候注意一下。&lt;/p&gt;
&lt;p&gt;过动画源码的着手点应该都很简单，跟着 &lt;code&gt;start()&lt;/code&gt; 一步步追踪下去梳理清楚就可以了。&lt;/p&gt;
&lt;p&gt;我们知道 ObjectAnimator 是继承的 ValueAnimator，那么我们可以直接从 ValueAnimator 的 &lt;code&gt;start()&lt;/code&gt; 开始看，等整个流程梳理清楚后，再回过头看看 ObjectAnimator 的 &lt;code&gt;start()&lt;/code&gt; 多做了哪些事就可以了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-60cbc9493105a9ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#start.png&quot;/&gt;&lt;br/&gt;很简单，调用了内部的 &lt;code&gt;start(boolean)&lt;/code&gt; 方法，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-fe3b2cc9c5c9f898.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#start(boolean).png&quot;/&gt;&lt;br/&gt;前面无外乎就是一些变量的初始化，然后好像调用了很多方法，emmm，其实我们并没有必要每一行代码都去搞懂，我们主要是想梳理整个流程，那么单看方法命名也知道，我们下面就跟着 &lt;code&gt;startAnimation()&lt;/code&gt; 进去看看（但记得，如果后面跟不下去了，要回来这里看看我们跳过的方法是不是漏掉了一些关键的信息）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-2ef0af810900a398.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#startAnimation.png&quot;/&gt;&lt;br/&gt;这里调用了两个方法，&lt;code&gt;initAnimation()&lt;/code&gt; 和 &lt;code&gt;notifyStartListeners()&lt;/code&gt;，感觉这两处也只是一些变量的初始化而已，还是没涉及到流程的信息啊，不管了，也还是先跟进去确认一下看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-c4193e1187a53487.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#initAnimation.png&quot;/&gt;&lt;br/&gt;确实只是进行一些初始化工作而已，看看另外一个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-ec4eb9a42e7e6743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#notifyStartListeners.png&quot;/&gt;&lt;br/&gt;这里也只是通知动画开始，回调 listener 的接口而已。&lt;/p&gt;
&lt;p&gt;emmm，我们从 &lt;code&gt;start()&lt;/code&gt; 开始一路跟踪下来，发现到目前为止都只是在做动画的一些初始化工作而已，而且跟到这里很明显已经是尽头了，下去没有代码了，那么动画初始化之后的下一个步骤到底是在哪里进行的呢？还记得我们前面在 &lt;code&gt;start(boolean)&lt;/code&gt; 方法里跳过了一些方法么？也许关键就是在这里，那么再回头过去看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-0368e986f1aec412.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#start(boolean)2.png&quot;/&gt;&lt;br/&gt;我们刚才是根据方法命名，想当然的直接跟着 &lt;code&gt;startAnimation()&lt;/code&gt; 走下去了，既然这条路走到底没找到关键信息，那么就折回头看看其他方法。这里调用了 AnimationHandler 类的 &lt;code&gt;addAnimationFrameCallback()&lt;/code&gt;，新出现了一个类，看命名应该是专门处理动画相关的，而且还是单例类，跟进去看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-c9571db6762a9a1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AnimationHandler#addAnimationFrameCallback.png&quot;/&gt;&lt;br/&gt;首先第二个参数 delay 取决于我们是否调用了 &lt;code&gt;setStartDelay()&lt;/code&gt; 来设置动画的延迟执行，假设目前的动画都没有设置，那么 delay 也就是 0，所以这里着重看一下前面的代码。&lt;/p&gt;
&lt;p&gt;mAnimationCallbacks 是一个 ArrayList，每一项保存的是 AnimationFrameCallback 接口的对象，看命名这是一个回调接口，那么是谁在什么时候会对它进行回调呢？根据目前仅有的信息，我们并没有办法看出来，那么可以先放着，这里只要记住第一个参数之前传进来的是 this，也就是说如果这个接口被回调时，那么 ValueAnimator 对这个接口的实现将会被回调。&lt;/p&gt;
&lt;p&gt;接下去开始按顺序过代码了，当 mAnimationCallbacks 列表大小等于 0 时，将会调用一个方法，很明显，如果动画是第一次执行的话，那么这个列表大小应该就是 0，因为将 callback 对象添加到列表里的操作是在这个判断之后，所以这里我们可以跟进看看：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-90a74eb4a5f4e0a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AnimationHandler#getProvider.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-5563b60614c3155c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyFrameCallbackProvider#postFrameCallback.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哇，这么快就看到 Choreographer 了，感觉我们好像已经快接近真相了，继续跟下去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-203095f117c18d97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Choreographer#postFrameCallback.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-5f4bc75b01d32c82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Choreographer#postFrameCallbackDelayed.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以内部其实是调用了 &lt;code&gt;postCallbackDelayedInternal()&lt;/code&gt; 方法，如果有看过我写的上一篇博客 &lt;strong&gt;&lt;em&gt;Android 屏幕刷新机制&lt;/em&gt;&lt;/strong&gt;，到这里是不是已经差不多可以理清了，有时间的可以回去看看，我这里概括性地给出些结论。&lt;/p&gt;
&lt;p&gt;Choreographer 内部有几个队列，上面方法的第一个参数 CALLBACK_ANIMATION 就是用于区分这些队列的，而每个队列里可以存放 FrameCallback 对象，也可以存放 Runnable 对象。Animation 动画原理上就是通过 ViewRootImpl 生成一个 &lt;code&gt;doTraversal()&lt;/code&gt; 的 Runnable 对象（其实也就是遍历 View 树的工作）存放到 Choreographer 的队列里的。而这些队列里的工作，都是用于在接收到屏幕刷新信号时取出来执行的。但有一个关键点，Choreographer 要能够接收到屏幕刷新信号的事件，是需要先调用 Choreographer 的 &lt;code&gt;scheduleVsyncLocked()&lt;/code&gt; 方法来向底层注册监听下一个屏幕刷新信号事件的。&lt;/p&gt;
&lt;p&gt;而如果继续跟踪 &lt;code&gt;postCallbackDelayedInternal()&lt;/code&gt; 这个方法下去的话，你会发现，它最终就是走到了 &lt;code&gt;scheduleVsyncLocked()&lt;/code&gt; 里去，这些在上一篇博客 Android 屏幕刷新机制里已经梳理过了，这里就不详细讲了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么，到这里，我们就可以先来梳理一下目前的信息了：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 ValueAnimator 调用了 &lt;code&gt;start()&lt;/code&gt; 方法之后，首先会对一些变量进行初始化工作并通知动画开始了，然后 ValueAnimator 实现了 AnimationFrameCallback 接口，并通过 AnimationHander 将自身 this 作为参数传到 mAnimationCallbacks 列表里缓存起来。而 AnimationHandler 在 mAnimationCallbacks 列表大小为 0 时会通过内部类 MyFrameCallbackProvider 将一个 mFrameCallback 工作缓存到 Choreographer 的待执行队列里，并向底层注册监听下一个屏幕刷新信号事件。&lt;/p&gt;
&lt;p&gt;当屏幕刷新信号到的时候，Choreographer 的 &lt;code&gt;doFrame()&lt;/code&gt; 会去将这些待执行队列里的工作取出来执行，那么此时也就回调了 AnimationHandler 的 mFrameCallback 工作。&lt;/p&gt;
&lt;p&gt;那么到目前为止，我们能够确定，当动画第一次调用 &lt;code&gt;start()&lt;/code&gt;，这里的第一次应该是指项目里所有的属性动画里某个动画第一次调用 &lt;code&gt;start()&lt;/code&gt;，因为 AnimationHandler 是一个单例类，显然是为所有的属性动画服务的。如果是第一次调用了 &lt;code&gt;start()&lt;/code&gt;，那么就会去向底层注册监听下一个屏幕刷新信号的事件。所以动画的处理逻辑应该就是在接收到屏幕刷新信号之后回调到的 mFrameCallback 工作里会去间接的调用到的了。&lt;/p&gt;
&lt;p&gt;那么，接下去就继续看看，&lt;strong&gt;当接收到屏幕刷新信号之后，mFrameCallback 又继续做了什么&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-6902a27ce29d4321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AnimationHandler#mFrameCallback.png&quot;/&gt;&lt;br/&gt;其实就做了两件事，一件是去处理动画的相关工作，也就是说要找到动画真正执行的地方，跟着 &lt;code&gt;doAnimationFrame()&lt;/code&gt; 往下走应该就行了。而剩下的代码就是处理另外一件事：继续向底层注册监听下一个屏幕刷新信号。&lt;/p&gt;
&lt;p&gt;先讲讲第二件事，我们知道，动画是一个持续的过程，也就是说，每一帧都应该处理一个动画进度，直到动画结束。既然这样，我们就需要在动画结束之前的每一个屏幕刷新信号都能够接收到，所以在每一帧里都需要再去向底层注册监听下一个屏幕刷新信号事件。所以你会发现，上面代码里参数是 this，也就是 mFrameCallback 本身，结合一下之前的那个流程，这里可以得到的信息是：&lt;/p&gt;
&lt;p&gt;当第一个属性动画调用了 &lt;code&gt;start()&lt;/code&gt; 时，由于 mAnimationCallbacks 列表此时大小为 0，所以直接由 &lt;code&gt;addAnimationFrameCallback()&lt;/code&gt; 方法内部间接的向底层注册下一个屏幕刷新信号事件，然后将该动画加入到列表里。而当接收到屏幕刷新信号时，mFrameCallback 的 &lt;code&gt;doFrame()&lt;/code&gt; 会被回调，该方法内部做了两件事，一是去处理当前帧的动画，二则是根据列表的大小是否不为 0 来决定继续向底层注册监听下一个屏幕刷新信号事件，如此反复，直至列表大小为 0。&lt;/p&gt;
&lt;p&gt;所以，这里可以猜测一点，如果当前动画结束了，那么就需要将其从 mAnimationCallbacks 列表中移除，这点可以后面跟源码过程中来验证。&lt;br/&gt;那么，下去就是跟着 &lt;code&gt;doAnimationFrame()&lt;/code&gt; 来看看，属性动画是怎么执行的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-f3d2c7179c4b00ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AnimationHandler#doAnimationFrame.png&quot;/&gt;&lt;br/&gt;这里概括下其实就做了两件事：&lt;/p&gt;
&lt;p&gt;一是去循环遍历列表，取出每一个 ValueAnimator，然后判断动画是否有设置了延迟开始，或者说动画是否到时间该执行了，如果到时间执行了，那么就会去调用 ValueAnimator 的 &lt;code&gt;doAnimationFrame()&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;二是调用了 &lt;code&gt;cleanUpList()&lt;/code&gt; 方法，看命名就可以猜测是去清理列表，那么应该也就是处理掉已经结束的动画，因为 AnimationHandler 是为所有属性动画服务的，同一时刻也许有多个动画正在进行中，那么动画的结束肯定有先后，已经结束的动画肯定要从列表中移除，这样等所有动画都结束了，列表大小变成 0 了，mFrameCallback 才可以停止向底层注册监听下一个屏幕刷新信号事件，AnimationHandler 才可以进入空闲状态，不用再每一帧都去处理动画的工作。&lt;/p&gt;
&lt;p&gt;那么，我们优先看看 &lt;code&gt;cleanUpList()&lt;/code&gt;，因为感觉它的工作比较简单，那就先梳理掉：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-0fe44d5fcc44b216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AnimationHandler#cleanUpList.png&quot;/&gt;&lt;br/&gt;猜测正确，将列表中为 null 的对象都移除掉，那么我们就可以继续进一步猜测，动画如果结束的话，会将自身在这个列表中的引用赋值为 null，这点可以在稍微跟踪动画的流程中来进行确认。&lt;/p&gt;
&lt;p&gt;清理的工作梳理完，那么接下去就是继续去跟着动画的流程了，还记得我们上面提到了另一件事是遍历列表去调用每个动画 ValueAnimator 的 &lt;code&gt;doAnimationFrame()&lt;/code&gt; 来处理动画逻辑么，那么我们接下去就跟进这个方法看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-36ac0bcd52571982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#doAnimationFrame.png&quot;/&gt;&lt;br/&gt;上面省略了部分代码，省略的那些代码跟动画是否被暂停或重新开始有关，本篇优先梳理正常的动画流程，这些就先不关注了。&lt;/p&gt;
&lt;p&gt;稍微概括一下，这个方法内部其实就做了三件事：&lt;br/&gt;一是处理第一帧动画的一些工作；&lt;/p&gt;
&lt;p&gt;二是根据当前时间计算当前帧的动画进度，所以动画的核心应该就是在 &lt;code&gt;animateBaseOnTime()&lt;/code&gt; 这个方法里，意义就类似 Animation 动画的 &lt;code&gt;getTransformation()&lt;/code&gt;方法；&lt;/p&gt;
&lt;p&gt;三是判断动画是否已经结束了，结束了就去调用 &lt;code&gt;endAnimation()&lt;/code&gt;，按照我们之前的猜测，这个方法内应该就是将当前动画从 mAniamtionCallbacks 列表里移除。&lt;/p&gt;
&lt;p&gt;我们先来看动画结束之后的处理工作，因为上面才刚梳理了一部分，趁着现在大伙还有些印象，而且这部分工作会简单易懂点，先把简单的吃掉：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d81a2431999ae270.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#endAnimation.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很简单，两件事，一是去通知说动画结束了，二是调用了 AniamtionHandler 的 &lt;code&gt;removeCallback()&lt;/code&gt;，继续跟进看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-3cb106d909aeb520.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AnimationHandler#removeCallback.png&quot;/&gt;&lt;br/&gt;我们之前的猜测在这里得到验证了吧，如果动画结束，那么它会将其自身在 AnimationCallbacks 列表里的引用赋值为 null，然后移出列表的工作就交由 AnimationHandler 去做。我们说了，AnimationHandler 是为所有的属性动画服务的，那么当某个动画结束的话，就必须进行一些资源清理的工作，整个清理的流程逻辑就是我们目前梳理出来的这样。&lt;/p&gt;
&lt;p&gt;好，搞定了一个小点了，那么接下去继续看剩下的两件事，先看第一件，&lt;strong&gt;处理动画第一帧的工作问题&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;参考 Animation 动画的原理，第一帧的工作通常都是为了记录动画第一帧的时间戳，因为后续的每一帧里都需要根据当前时间以及动画第一帧的时间还有一个动画持续时长来计算当前帧动画所处的进度，Animation 动画我们梳理过了，所以这里在过第一帧的逻辑时应该就会比较有条理点。我们来看看，属性动画的第一帧的工作是不是跟 Animation 差不多：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a4fcedaa09c5f41a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#doAnimationFrame2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;emmm，看来比 Animation 动画复杂多了，大体上也是干了两件事：&lt;/p&gt;
&lt;p&gt;一是调用了 AnimationHandler 的 &lt;code&gt;addOneShotCommitCallback()&lt;/code&gt; 方法，具体是干嘛的我们等会来分析；&lt;/p&gt;
&lt;p&gt;二就是记录动画第一帧的时间了，mStartTime 变量就是表示第一帧的时间戳，后续的动画进度计算肯定需要用到这个变量。至于还有一个 mSeekFraction 变量，它的作用有点类似于我们用电脑看视频时，可以任意选择从某个进度开始观看。属性动画有提供了一个接口 &lt;code&gt;setCurrentPlayTime()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ValueAnimator animator = ValueAnimator.ofInt(0, 100);
animator.setDuration(4000);
animator.start();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举个例子，。这是一个持续 4s 从 0 增长到 100 的动画，如果我们调用了 &lt;code&gt;start()&lt;/code&gt;，那么 mSeekFraction 默认值是 -1，所以 mStartTime 就是用当前时间作为动画的第一帧时间。如果我们调用了 &lt;code&gt;setCurrentPlayTime(2000)&lt;/code&gt;，意思就是说，我们希望这个动画从 2s 开始，那么它就是一个持续 2s(4-2) 的从 50 增长到 100 的动画（假设插值器为线性），所以这个时候，mStartTime 就是以比当前时间还早 2s 作为动画的第一帧时间，后面根据 mStartTime 计算动画进度时，就会发现原来动画已经过了 2s 了。&lt;/p&gt;
&lt;p&gt;就像我们看电视时，我们不想看片头，所以直接选择从正片开始看，类似的道理。&lt;/p&gt;
&lt;p&gt;好了，还记得前面说了处理动画第一帧的工作大体上有两件事，另一件是调用了一个方法么。我们回头来看看，这里又是做了些什么：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-b15e728ecf78a2e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AnimationHandler#addOneShotCommitCallback.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只是将 ValueAnimator 添加到 AnimationHandler 里的另一个列表中去，可以过滤这个列表的变量名看看它都在哪些地方被使用到了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-476edd8214ea2e02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AnimationHandler#doAnimationFrame2.png&quot;/&gt;&lt;br/&gt;这地方还记得吧，我们上面分析的那一大堆工作都是跟着 &lt;code&gt;callback.doAnimationFrame(frameTime)&lt;/code&gt; 这行代码走进去的，虽然内部做的事我们还没全部分析完，但我们这里可以知道，等内部所有事都完成后，会退回到 AnimationHandler 的 &lt;code&gt;doAnimationFrame()&lt;/code&gt; 继续往下干活，所以再继续跟下去看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-0cfebf5690d83163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AnimationHandler#postCommitCallback.png&quot;/&gt;&lt;br/&gt;上面说过，Choreographer 内部有多个队列，每个队列里都可以存放 FrameCallback 对象，或者 Runnable 对象。这次是传到了另一个队列里，传进的是一个 Runnable 对象，我们看看这个 Runnable 做了些什么：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-451fa0f066aab715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AnimationHandler#commitAnimationFrame.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ValueAnimator 实现了 AnimationFrameCallback 接口，这里等于是回调了 ValueAnimator 的方法，然后将其从队列中移除。看看 ValueAnimator 的实现做了些什么：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-4e04ad4a44cc22e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#commitAnimationFrame.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好嘛，这里说穿了其实也是在修正动画的第一帧时间 mStartTime。那么，其实也就是说，ValueAnimator 的 &lt;code&gt;doAnimationFrame()&lt;/code&gt; 里处理第一帧工作的两件事全部都是用于计算动画的第一帧时间，只是一件是根据是否 &quot;跳过片头&quot;( &lt;code&gt;setCurrentPlayTime()&lt;/code&gt;) 计算，另一件则是这里的修正。&lt;/p&gt;
&lt;p&gt;那么，&lt;strong&gt;这里为什么要对第一帧时间 mStartTime 进行修正呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大伙有时间可以去看看 AnimationFrameCallback 接口的 &lt;code&gt;commitAnimationFrame()&lt;/code&gt; 方法注释，官方解释得特别清楚了，我这里就不贴图了，直接将我的理解写出来：&lt;/p&gt;
&lt;p&gt;其实，这跟属性动画通过 Choreographer 的实现原理有关。我们知道，屏幕的刷新信号事件都是由 Choreographer 负责，它内部有多个队列，这些队列里存放的工作都是用于在接收到信号时取出来处理。那么，这些队列有什么区别呢？&lt;/p&gt;
&lt;p&gt;其实也就是执行的先后顺序的区别，按照执行的先后顺序，我们假设这些队列的命名为：1队列 &amp;gt; 2队列 &amp;gt; 3队列。我们本篇分析的属性动画，AnimationHandler 封装的 mFrameCallback 工作就是放到 1队列里的；而之前分析的 Animation 动画，它通过 ViewRootImpl 封装的 &lt;code&gt;doTraversal()&lt;/code&gt; 工作是放到 2队列里的；而上面刚过完的修正动画第一帧时间的 Runnable 工作则是放到 3队列里的。&lt;/p&gt;
&lt;p&gt;也就是说，当接收到屏幕刷新信号后，属性动画会最先被处理。然后是去计算当前屏幕数据，也就是测量、布局、绘制三大流程。但是这样会有一个问题，如果页面太过复杂，绘制当前界面时花费了太多的时间，那么等到下一个屏幕刷新信号时，属性动画根据之前记录的第一帧时间戳计算动画进度时，会发现丢了开头的好几帧，明明动画没还执行过。所以，这就是为什么需要对动画第一帧时间进行修正。&lt;/p&gt;
&lt;p&gt;当然，如果动画已经开始了，在动画中间某一帧，就不会去修正了，这个修正，只是针对动画的第一帧时间。因为，如果是在第一帧发现绘制界面太耗时，丢了开头几帧，那么我们可以通过延后动画开始的时机来达到避免丢帧。但如果是在动画执行过程中才遇到绘制界面太耗时，那不管什么策略都无法避免丢帧了。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;小结1&quot;&gt;小结1：&lt;/h2&gt;
&lt;p&gt;好了，到这里，大伙先休息下，我们来梳理一下目前所有的信息，不然我估计大伙已经忘了上面讲过什么了：&lt;/p&gt;
&lt;ol readability=&quot;14&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;ValueAnimator 属性动画调用了 &lt;code&gt;start()&lt;/code&gt; 之后，会先去进行一些初始化工作，包括变量的初始化、通知动画开始事件；&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;然后通过 AnimationHandler 将其自身 this 添加到 mAnimationCallbacks 队列里，AnimationHandller 是一个单例类，为所有的属性动画服务，列表里存放着所有正在进行或准备开始的属性动画；&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;如果当前存在要运行的动画，那么 AnimationHandler 会去通过 Choreographer 向底层注册监听下一个屏幕刷新信号，当接收到信号时，它的 mFrameCallback 会开始进行工作，工作的内容包括遍历列表来分别处理每个属性动画在当前帧的行为，处理完列表中的所有动画后，如果列表还不为 0，那么它又会通过 Choreographer 再去向底层注册监听下一个屏幕刷新信号事件，如此反复，直至所有的动画都结束。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;AnimationHandler 遍历列表处理动画是在 &lt;code&gt;doAnimationFrame()&lt;/code&gt; 中进行，而具体每个动画的处理逻辑则是在各自，也就是 ValueAnimator 的 &lt;code&gt;doAnimationFrame()&lt;/code&gt; 中进行，各个动画如果处理完自身的工作后发现动画已经结束了，那么会将其在列表中的引用赋值为空，AnimationHandler 最后会去将列表中所有为 null 的都移除掉，来清理资源。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;每个动画 ValueAnimator 在处理自身的动画行为时，首先，如果当前是动画的第一帧，那么会根据是否有&quot;跳过片头&quot;（&lt;code&gt;setCurrentPlayTime()&lt;/code&gt;）来记录当前动画第一帧的时间 mStartTime 应该是什么。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;第一帧的动画其实也就是记录 mStartTime 的时间以及一些变量的初始化而已，动画进度仍然是 0，所以下一帧才是动画开始的关键，但由于属性动画的处理工作是在绘制界面之前的，那么有可能因为绘制耗时，而导致 mStartTime 记录的第一帧时间与第二帧之间隔得太久，造成丢了开头的多帧，所以如果是这种情况下，会进行 mStartTime 的修正。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;修正的具体做法则是当绘制工作完成后，此时，再根据当前时间与 mStartTime 记录的时间做比较，然后进行修正。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;如果是在动画过程中的某一帧才出现绘制耗时现象，那么，只能表示无能为力了，丢帧是避免不了的了，想要解决就得自己去分析下为什么绘制会耗时；而如果是在第一帧是出现绘制耗时，那么，系统还是可以帮忙补救一下，修正下 mStartTime 来达到避免丢帧。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好了，休息结束，我们继续，还有一段路要走，其实整个流程目前大体上已经出来了，只是缺少了当前帧的动画进度具体计算实现细节，这部分估计会更让人头大。&lt;/p&gt;
&lt;p&gt;之前分析 ValueAnimator 的 &lt;code&gt;doAnimationFrame()&lt;/code&gt; 时，我们将其概括出来主要做了三件事：一是处理第一帧动画的工作；二是根据当前时间计算并实现当年帧的动画工作；三是根据动画是否结束进行一些资源清理工作；一三我们都分析了，下面就来过过第二件事，&lt;code&gt;animateBasedOnTime()&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-b2248e27890e5eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#animateBaseOnTime.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这里开始，就是在计算当前帧的动画逻辑了，整个过程跟 Animation 动画基本上差不多。上面的代码里，我省略了一部分，那部分是用于根据是否设置的 mRepeatCount 来处理动画结束后是否需要重新开始，这些我们就不看了，我们着重梳理一个正常的流程下来即可。&lt;/p&gt;
&lt;p&gt;所以，概括一下，这个方法里其实也就是做了三件事：&lt;/p&gt;
&lt;p&gt;一是，根据当前时间以及动画第一帧时间还有动画持续的时长来计算当前的动画进度。&lt;/p&gt;
&lt;p&gt;二是，确保这个动画进度的取值在 0-1 之间，这里调用了两个方法来辅助计算，我们就不跟进去了，之所以有这么多的辅助计算，那是因为，属性动画支持 &lt;code&gt;setRepeatCount()&lt;/code&gt; 来设置动画的循环次数，而从始至终的动画第一帧的时间都是 mStrtTime 一个值，所以在第一个步骤中根据当前时间计算动画进度时会发现进度值是可能会超过 1 的，比如 1.5, 2.5, 3.5 等等，所以第二个步骤的辅助计算，就是将这些值等价换算到 0-1 之间。&lt;/p&gt;
&lt;p&gt;三就是最重要的了，当前帧的动画进度计算完毕之后，就是需要应用到动画效果上面了，所以 &lt;code&gt;animateValue()&lt;/code&gt; 方法的意义就是类似于 Animation 动画中的 &lt;code&gt;applyTransformation()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们都说，属性动画是通过修改属性值来达到动画效果的，那么我们就跟着 &lt;code&gt;animateValue()&lt;/code&gt; 进去看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-97fe4c2e674a1688.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ValueAnimator#animateValue.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里干的活我也大概的给划分成了三件事：&lt;/p&gt;
&lt;p&gt;一是，根据插值器来计算当前的真正的动画进度，插值器算是动画里比较重要的一个概念了，可能平时用的少，如果我们没有明确指定使用哪个插值器，那么系统通常会有一个默认的插值器。&lt;/p&gt;
&lt;p&gt;二是，根据插值器计算得到的实际动画进度值，来映射到我们需要的数值。这么说吧，就算经过了插值器计算之后，动画进度值也只是 0-1 区间内的某个值而已。而我们通常需要的并不是 0-1 的数值，比如我们希望一个 0-500 的变化，那么我们就需要自己在拿到 0-1 区间的进度值后来进行转换。第二个步骤，大体上的工作就是帮助我们处理这个工作，我们只需要告诉 ValueAnimator 我们需要 0-500 的变化，那么它在拿到进度值后会进行转换。&lt;/p&gt;
&lt;p&gt;三就只是通知动画的进度回调而已了。&lt;/p&gt;
&lt;p&gt;流程上差不多已经梳理出来了，不过我个人对于内部是如何根据拿到的 0-1 区间的进度值转换成我们指定区间的数值的工作挺感兴趣的，那么我们就稍微再深入去分析一下好了。这部分工作主要就是调用了 &lt;code&gt;mValues[i].calculateValue(fraction)&lt;/code&gt; 这一行代码来实现，mValues 是一个 PropertyValuesHolder 类型的数组，所以关键就是去看看这个类的 &lt;code&gt;calculateValue()&lt;/code&gt; 做了啥：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-ed2f4ce15f14d9b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;PropertyValuesHolder#calculateValue.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在使用 ValueAnimator 时，注册了动画进度回调，然后在回调里取当前的值时其实也就是取到上面那个 mAnimatedValue 变量的值，而这个变量的值是通过 &lt;code&gt;mKeyframes.getValue()&lt;/code&gt; 计算出来的，那么再继续跟进看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-6ae407edfc0f470d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;KeyFrames#getValue.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;KeyFrames 是一个接口，那么接下去就是要找找哪里实现了这个接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-72f3e29487b34f14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;PropertyValuesHolder#setIntValues.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体的找法，可以在 PropertyValuesHolder 这个类里利用 &lt;code&gt;Ctrl + F&lt;/code&gt; 过滤一下 &lt;code&gt;mKeyframes =&lt;/code&gt;来看一下它在哪些地方被实例化了。匹配到的地方很多，但都差不多，都是通过 KeyframeSet 的 ofXXX 方法实例化得到的对象，那么具体的实现应该就是在 KeyframeSet 这个类里了。&lt;/p&gt;
&lt;p&gt;在跟进去看之前，有一点想提一下，大伙应该注意到了吧，mKeyframes 实例化的这些地方，&lt;code&gt;ofInt()&lt;/code&gt;，&lt;code&gt;onFloat()&lt;/code&gt; 等等是不是很熟悉。没错，就是我们创建属性动画时相似的方法名， 其实 &lt;code&gt;ValueAnimator.ofInt()&lt;/code&gt; 内部会根据相应的方法来创建 mKeyframes 对象，也就是说，在实例化属性动画时，这些 mKeyframes 也顺便被实例化了。想确认的，大伙可以自己去跟下源码看看，我这里就不贴了。&lt;/p&gt;
&lt;p&gt;好了，接下去看看 KeyframeSet 这个类的 &lt;code&gt;ofInt()&lt;/code&gt; 方法，看看它内部具体是创建了什么：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-271400f60db0d636.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;KeyframeSet#ofInt.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里又涉及到新的机制了吧，Keyframe，KeyframeSet，Keyframes 这些大伙感兴趣可以去查查看，我也没有深入去了解。但看了别人的一些介绍，这里大概讲一下。直接从翻译上来看，这个也就是指关键帧，就像一部电影由多帧画面组成一样的道理，动画也是由一帧帧组成的。&lt;/p&gt;
&lt;p&gt;还记得，我们为啥会跟到这里来了么。动画在处理当前帧的工作时，会去计算当前帧的动画进度，然后根据这个 0-1 区间的进度，映射到我们需要的数值，而这个映射之后的数值就是通过 mKeyframes 的 &lt;code&gt;getValue()&lt;/code&gt; 里取到的，mKeyframes 是一个 KeyframeSet 对象，在创建属性动画时也顺带被创建了，而创建属性动画时，我们会传入一个我们想要的数值，如 &lt;code&gt;ValueAnimator.ofInt(100)&lt;/code&gt; 就表示我们想要的动画变化范围是 0-100，那么这个 100 在内部也会被传给 &lt;code&gt;KeyframeSet.ofInt(100)&lt;/code&gt;，然后就是进入到上面代码块里的创建工作了。&lt;/p&gt;
&lt;p&gt;在这个方法里，100 就是作为一个关键帧。那么，对于一个动画来说，什么才叫做关键帧呢？很明显，至少动画需要知道从哪开始，到哪结束，是吧？所以，对于一个动画来说，至少需要两个关键帧，如果我们调用 &lt;code&gt;ofInt(100)&lt;/code&gt; 只传进来一个数值时，那么内部它就默认认为起点是从 0 开始，传进来的 100 就是结束的关键帧，所以内部就会自己创建了两个关键帧。&lt;/p&gt;
&lt;p&gt;那么，这些关键帧又是怎么被动画用上的呢？这就是回到我们最初跟踪的 &lt;code&gt;mKeyframes.getValue()&lt;/code&gt; 这个方法里去了，看上面的代码块，&lt;code&gt;KeyframeSet.ofInt()&lt;/code&gt; 最后是创建了一个 IntKeyframeSet 对象，所以我们跟进这个类的 &lt;code&gt;getValue()&lt;/code&gt; 方法里看看它是怎么使用这些关键帧的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-c59da0d813fc3bb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;IntKeyframeSet#getValue.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以关键的工作就都在 &lt;code&gt;getIntValue()&lt;/code&gt; 这里了，参数传进来还记得是什么吧，就是经过插值器计算之后当前帧的动画进度值，0-1 区间的那个值，&lt;code&gt;getIntValue()&lt;/code&gt; 这个方法的代码有些多，我们一块一块来看，先看第一块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-85239064d60be497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;IntKeyframeSet#getIntValue.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当关键帧只有两帧时，我们常使用的 &lt;code&gt;ValueAnimator.ofInt(100)&lt;/code&gt;， 内部其实就是只创建了两个关键帧，一个是起点 0，一个是结束点 100。那么，在这种只有两帧的情况下，将 0-1 的动画进度值转换成我们需要的 0-100 区间内的值，系统的处理很简单，如果没有设置估值器，也就是 mEvaluator，那么就直接是按比例来转换，比如进度为 0.5，那按比例转换就是 (100 - 0) * 0.5 = 50。如果有设置估值器，那就按照估值器定的规则来，估值器其实就是类似于插值器，属性动画里才引入的概念，Animation 动画并没有，因为只有属性动画内部才帮我们做了值转换工作。&lt;/p&gt;
&lt;p&gt;上面是当关键帧只有两帧时的处理逻辑，那么当关键帧超过两帧的时候呢：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-b0ba7e86e2e0f250.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;IntKeyframeSet#getIntValue2.png&quot;/&gt;&lt;br/&gt;当关键帧超过两帧时，分三种情况来处理：第一帧的处理；最后一帧的处理；中间帧的处理；&lt;/p&gt;
&lt;p&gt;那么，什么时候关键帧会超过两帧呢？其实也就是我们这么使用的时候：&lt;code&gt;ValueAnimator.ofInt(0, 100, 0, -100, 0)&lt;/code&gt;，类似这种用法的时候关键帧就不止两个了，这时候数量就是根据参数的个数来决定的了。&lt;/p&gt;
&lt;p&gt;那么，我们再来详细看看三种情况的处理逻辑，首先是第一帧的处理逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-c0ed02e31c55342d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;IntKeyframeSet#getIntValue3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;fraction &amp;lt;= 0f 表示的应该不止是第一帧的意思，但除了理解成第一帧外，我不清楚其他场景是什么，暂时以第一帧来理解，这个应该影响不大。&lt;/p&gt;
&lt;p&gt;处理的逻辑其实也很简单，还记得当只有两个关键帧时是怎么处理的吧。那在处理第一帧的工作时，只需要将第二帧当成是最后一帧，那么第一帧和第二帧这样也就可以看成是只有两帧的场景了吧。但是参数 fraction 动画进度是以实际第一帧到最后一帧计算出来的，所以需要先对它进行转换，换算出它在第一帧到第二帧之间的进度，接下去的逻辑也就跟处理两帧时的逻辑是一样的了。&lt;/p&gt;
&lt;p&gt;同样的道理，在处理最后一帧时，只需要取出倒数第一帧跟倒数第二帧的信息，然后将进度换算到这两针之间的进度，接下去的处理逻辑也就是一样的了。代码我就不贴了。&lt;/p&gt;
&lt;p&gt;但处理中间帧的逻辑就不一样了，因为根据 0-1 的动画进度，我们可以很容易区分是处于第一帧还是最后一帧，无非一个就是 0，一个是 1。但是，当动画进度值在 0-1 之间时，我们并没有办法直接看出这个进度值是落在中间的哪两个关键帧之间，如果有办法计算出当前的动画进度处于哪两个关键帧之间，那么接下去的逻辑也就是一样的了，所以关键就是在于找出当前进度处于哪两个关键帧之间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-932636c134f75585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;IntKeyframeSet#getIntValue4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统的找法也很简单，从第一帧开始，按顺序遍历每一帧，然后去判断当前的动画进度跟这一帧保存的位置信息来找出当前进度是否就是落在某两个关键帧之间。因为每个关键帧保存的信息除了有它对应的值之外，还有一个是它在第一帧到最后一帧之间的哪个位置，至于这个位置的取值是什么，这就是由在创建这一系列关键帧时来控制的了。&lt;/p&gt;
&lt;p&gt;还记得是在哪里创建了这一系列的关键帧的吧，回去 KeyframeSet 的 &lt;code&gt;ofInt()&lt;/code&gt; 里看看：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-26e403bdc022eca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;KeyframeSet#ofInt2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在创建每个关键帧时，传入了两个参数，第一个参数就是表示这个关键帧在整个区域之间的位置，第二参数就是它表示的值是多少。看上面的代码， i 表示的是第几帧，numKeyframes 表示的是关键帧的总数量，所以 i/(numKeyframes - 1) 也就是表示这一系列关键帧是按等比例来分配的。&lt;/p&gt;
&lt;p&gt;比如说， &lt;code&gt;ValueAnimator.ofInt(0, 50, 100, 200)&lt;/code&gt;，这总共有四个关键帧，那么按等比例分配，第一帧就是在起点位置 0，第二帧在 1/3 位置，第三帧在 2/3 的位置，最后一帧就是在 1 的位置。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;小结2&quot;&gt;小结2：&lt;/h2&gt;
&lt;p&gt;到这里，我们再来梳理一下后面部分过的内容：&lt;/p&gt;
&lt;ol readability=&quot;17.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;当接收到屏幕刷新信号后，AnimationHandler 会去遍历列表，将所有待执行的属性动画都取出来去计算当前帧的动画行为。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;每个动画在处理当前帧的动画逻辑时，首先会先根据当前时间和动画第一帧时间以及动画的持续时长来初步计算出当前帧时动画所处的进度，然后会将这个进度值等价转换到 0-1 区间之内。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;接着，插值器会将这个经过初步计算之后的进度值根据设定的规则计算出实际的动画进度值，取值也是在 0-1 区间内。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;计算出当前帧动画的实际进度之后，会将这个进度值交给关键帧机制，来换算出我们需要的值，比如 ValueAnimator.ofInt(0, 100) 表示我们需要的值变化范围是从 0-100，那么插值器计算出的进度值是 0-1 之间的，接下去就需要借助关键帧机制来映射到 0-100 之间。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;关键帧的数量是由 ValueAnimator.ofInt(0, 1, 2, 3) 参数的数量来决定的，比如这个就有四个关键帧，第一帧和最后一帧是必须的，所以最少会有两个关键帧，如果参数只有一个，那么第一帧默认为 0，最后一帧就是参数的值。当调用了这个 ofInt() 方法时，关键帧组也就被创建了。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;当只有两个关键帧时，映射的规则是，如果没有设置估值器，那么就等比例映射，比如动画进度为 0.5，需要的值变化区间是 0-100，那么等比例映射后的值就是 50，那么我们在 onAnimationUpdate 的回调中通过 animation.getAnimatedValue() 获取到的值 50 就是这么来的。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;如果有设置估值器，那么就按估值器的规则来进行映射。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;当关键帧超过两个时，需要先找到当前动画进度是落于哪两个关键帧之间，然后将这个进度值先映射到这两个关键帧之间的取值，接着就可以将这两个关键帧看成是第一帧和最后一帧，那么就可以按照只有两个关键帧的情况下的映射规则来进行计算了。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;而进度值映射到两个关键帧之间的取值，这就需要知道每个关键帧在整个关键帧组中的位置信息，或者说权重。而这个位置信息是在创建每个关键帧时就传进来的。onInt() 的规则是所有关键帧按等比例来分配权重，比如有三个关键帧，第一帧是 0，那么第二帧就是 0.5， 最后一帧 1。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此，我们已经将整个流程梳理出来了，&lt;strong&gt;两部分小结&lt;/strong&gt;的内容整合起来就是这次梳理出来的整个属性动画从 &lt;code&gt;start()&lt;/code&gt; 之后，到我们在 onAnimationUpdate 回调中取到我们需要的值，再到动画结束后如何清理资源的整个过程中的原理解析。&lt;/p&gt;
&lt;p&gt;梳理清楚后，大伙应该就要清楚，属性动画是如何接收到屏幕刷新信号事件的？是如何反复接收到屏幕刷新信号事件直到整个动画执行结束？方式是否是有区别于 Animation 动画的？计算当前帧的动画工作都包括了哪些？是如何将 0-1 的动画进度映射到我们需要的值上面的？&lt;/p&gt;
&lt;p&gt;如果看完本篇，这些问题你心里都有谱了，那么就说明，本篇的主要内容你都吸收进去了。当然，如果有错的地方，欢迎指出来，毕竟内容确实很多，很有可能存在写错的地方没发现。&lt;/p&gt;
&lt;p&gt;来张时序图结尾：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-6d825c6da4d4a7a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;VauleAnimatior运行原理时序图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，有一点想提的是，我们本篇只是过完了 ValueAnimator 的整个流程原理，但这整个过程中，注意到了没有，我们并没有看到有任何一个地方涉及到了 ui 操作。在上一篇博客 &lt;strong&gt;&lt;em&gt;Android 屏幕刷新机制&lt;/em&gt;&lt;/strong&gt;中，我们也清楚了，界面的绘制其实就是交由 ViewRootImpl 来发起的，但很显然，ValueAnimator 跟 ViewRootImpl 并没有任何交集。&lt;/p&gt;
&lt;p&gt;那么，ValueAnimator 又是怎么实现动画效果的呢？其实，ValueAnimator 只是按照我们设定的变化区间(&lt;code&gt;ofInt(0, 100)&lt;/code&gt;)，持续时长(&lt;code&gt;setDuration(1000)&lt;/code&gt;)，插值器规则，估值器规则，内部在每一帧内通过一系列计算，转换等工作，最后输出每一帧一个数值而已。而如果要实现一个动画效果，那么我们只能在进度回调接口取到这个输出的值，然后手动应用到某个 View 上面(&lt;code&gt;mView.setX(&lt;/code&gt;))。所以，这种使用方式，本质上仍然是通过 View 的内部方法最终走到 ViewRootImpl 去触发界面的更新绘制。&lt;/p&gt;
&lt;p&gt;而 ObjectAnimator 却又不同了，它内部就有涉及到 ui 的操作，具体原理是什么，留待后续再分析。&lt;/p&gt;

&lt;p&gt;都说属性动画是通过改变属性值来达到动画效果的，计划写这一篇时，本来以为可以梳理清楚这点的，谁知道单单只是把 ValueAnimator 的流程原理梳理出来篇幅就这么长了，所以 ObjectAnimator 就另找时间再来梳理吧，这个问题就作为遗留问题了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q1：都说属性动画是通过改变属性值来达到动画效果的，那么它的原理是什么呢？&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-35fed4659c556352.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;QQ图片20180316094923.jpg&quot;/&gt;&lt;br/&gt;最近（2018.03）刚开通了公众号，想激励自己坚持写作下去，初期主要分享原创的Android或Android-Tv方面的小知识，感兴趣的可以点一波关注，谢谢支持~~&lt;/p&gt;
</description>
<pubDate>Sun, 18 Mar 2018 06:37:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/8595422.html</dc:identifier>
</item>
<item>
<title>Java环境变量，真的还有必要配吗？ - 陈本布衣</title>
<link>http://www.cnblogs.com/chenbenbuyi/p/8590222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenbenbuyi/p/8590222.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　作为年龄上堪称老鸟而技术上却是菜鸟的老菜鸟，为了祖国的编程事业，不惜拿出一个月工资，淘了一台配置稍高的二手笔记本，打算与老笔记本中的撸啊撸片彻底说再见，誓要在新机种开启一番撸啊撸的新事业。当然，撸代码离不开基本的环境搭建，每次新机上手都要百度一堆杂乱的似是而非的环境搭建教程，才勉强把开发环境搭建起来，时间耗费不少，但终是拾人牙慧，生搬硬套，从未能理解深层原理，将其内化吸收形成自己的技术积累；而环境搭建虽然基础，但编程界多少前辈大牛都是从此开始的，千万行代码的撸出也都依赖于此，所以，花时间总结一下，思考一番，确有必要。今天先来讲讲最最基本的&lt;strong&gt;环境变量&lt;/strong&gt;，博主度娘无数，收获不小，现分两个方面来探究&lt;strong&gt;环境变量&lt;/strong&gt;的问题：一是为什么要配置，二是如何配置。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　配置环境变量:Why?&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　为了回答为什么的问题，还是先将JDK下载好，然后布衣博主先一步步的试错完毕，然后再跟大家分享正确的姿势。&lt;span&gt;安装JDK首先肯定是去&lt;a title=&quot;JDK&quot; href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot; target=&quot;_blank&quot;&gt;Oracle官网&lt;/a&gt;下载适合自己的开发版本啦，或许是沉浸在JDK1.7的开发环境中太久了，不看官网不知道，一看尼玛JDK1.9都发布了，可怜布衣博主连JDK1.8长啥样都还没见过呢。伤心三秒，果断下载JDK1.8的版本来尝尝。下面是下载主页的重点内容，相信大家都知道具体操作：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1231169/201803/1231169-20180317214538690-1640049811.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1231169/201803/1231169-20180317214916299-1964189242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;安装JDK也很简单，先是JDK，然后是JRE,如果要自定义路径，注意两者不要安装在同一个包下面。然后，作为Java开发者，就会按基本套路开始配置起环境变量。如果仅仅是作为一个代码搬运工，百度有一堆环境变量的配置方式，傻瓜也会配置，但要想成为一个高阶一些的码农，在进行一个操作之前，总该知道你干这件事的缘由——为什么要配置环境变量，如果不配置又会怎样？平时看起来只是开发入门的基础操作，深究起来其实并不简单。有人会呵呵一笑很倾城——不配环境变量，我们怎么开发？欸，这样的问题，我只能说，编程这玩意儿，很多时候不动脑子是可以的，但是不动手却不行。布衣博主以前的固有思想也是觉得，配置环境变量是Java开发的固定姿势，可是今天为了深究环境变量这个问题，下载JDK1.8来折腾一番后发现，仅仅是安装好JDK和JRE，&lt;strong&gt;根本用不着配置什么环境变量就可以开发和跑项目了&lt;/strong&gt;，这是怎么回事？到环境变量配置页查看，会发现在path的值中有个C:\ProgramData\Oracle\Java\javapath路径值生成，如以下图中展示（注：图例一为Win10系统的环境变量配置界面，和Win7有很大不同）——&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1231169/201803/1231169-20180318121337115-1327749370.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1231169/201803/1231169-20180318121921514-508139080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;而在映射的路径文件夹中已经存在了可执行的java.exe&lt;/span&gt;,这似乎是说明新版JDK（1.8）在安装的时候就已经自动为我们添加好了环境配置。当博主删除该path映射的路径值&lt;span&gt;C:\ProgramData\Oracle\Java\javapath&lt;/span&gt;的时候，集成开发环境中的eclipse就无法正常打开了，但是IDEA依然能正常使用，添加之后eclipse恢复正常。接着将JDK1.8卸载，保留运行环境JRE，这个时候eclipse依然可以正常使用，因为Eclipse比较例外的是它自己内嵌了Java编译器，其作用等同于JDK中的javac，所以eclipse其实只需要依赖JRE就可以做开发并编译运行Java文件的，有了JDK只是为了方便查询源码，而这个时候IDEA少了JDK的支持就无法正常开发使用了。接着卸载JRE,这个时候开发工具肯定是没法使用了，关键是在环境变量的Path值&lt;span&gt;C:\ProgramData\Oracle\Java\javapath&lt;/span&gt;也消失了，对应路径下的文件也被删除了，这就说明在安装JRE的时候，是会为我们自动配置好环境变量的。环境变量都没配置就成功的布衣博主实在不甘心，卸载了JDK1.8之后又单独安装了JDK1.7继续尝试，安装完成后Path值并没有自动添加，博主也没有主动的去配置任何环境变量，但是打开Eclipse或者Idea等IDE，依然可以正常开发跑项目。尝试至此，似乎证明了长久以来大家配置环境变量只是思维和行为固化后的自以为是，纯粹是多此一举，对日常开发调试并没有卵用。难道，这么多程序员都在信奉了一个错误的认知而且丝毫不觉得有异？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;要搞解开这个疑惑，还是得搞清楚环境变量到底是干什么的，为什么要配置它。所谓环境变量，其实就是操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等。当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到环境变量的Path中指定的路径值去找。也就是说当执行可执行文件找不到位置的时候，就会去Path中配置的路径去找。因此可以设想如果直接在可执行文件所在文件夹取执行，那不就是找得到吗？为了证明，博主先打开cmd执行编译命令javac，返回不是内部或外部命令，当我们切换到JDK的bin目录C:\Program Files\Java\jdk1.8.0_162\bin路径去执行javac命令的时候，就能够成功执行，好像配置了环境变量一样——&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1231169/201803/1231169-20180318133207556-1396963808.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;　　&lt;span&gt;既然可以执行javac，那么我们就在该目录下测试编译一个Java文件。先用记事本编写测试代码 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test {&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main(String[] args) { System.out.println(&lt;/span&gt;&quot;博客园 陈本布衣&quot;&lt;span&gt;); } }&lt;/span&gt;&lt;/span&gt; ，文件名必须和类名保持一致Test.java,然后我们执行编译命令并运行文件——&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1231169/201803/1231169-20180318134335060-1793339583.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;可是正常情况下我的Java文件是不可能放在bin目录下的，所以我们接着配置好环境变量，使我们能够在任意目录编译Java文件——&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1231169/201803/1231169-20180318135110770-2087106493.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1231169/201803/1231169-20180318140334495-42043158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;　　配置环境变量的目的似乎达到了，仅仅是为了不用切换到JDK的bin目录就能执行编译命令的方便，可是，现在都是用集成开发环境如idea或eclipse等开发并编译Java程序，如果不是使用命令行javac的方式来编译Java程序，那么，广大的程序员们，你在搭建开发环境的时候，配置环境变量到底是因为什么？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　配置环境变量:How?&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　欸，本来前文阐述了环境变量的原理后，这里计划该写如何配置了，但是布衣博主在不断尝试之后发现环境变量在Java的开发环境中根本不是必须的配置，所以，这里的How就只能戛然而止了，实在不想多叨叨如何配置那不必要的玩意儿了。当然，或许我前文的尝试和总结很有问题，因为配置了多年环境变量的博主自己一直都还在怀疑上文的尝试是否正确，也&lt;strong&gt;诚心希望各路大神指出阐述中的问题&lt;/strong&gt;，共同来探讨环境变量配置的必要性和可用之处，以免误导他人；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原创博文，转载请注明出处和原文链接，谢谢！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　作者：陈本布衣&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Mar 2018 06:10:00 +0000</pubDate>
<dc:creator>陈本布衣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenbenbuyi/p/8590222.html</dc:identifier>
</item>
<item>
<title>CSS之盒子模型（由浅到深的理解） - 阿来丶</title>
<link>http://www.cnblogs.com/JiangLai/p/8595309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JiangLai/p/8595309.html</guid>
<description>&lt;h2&gt;&lt;span&gt;CSS--盒子模型(Box Model)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　CSS盒子模型本质上是一个盒子，对网页中绝大部分的HTML元素进行包装定位（外边距，边框，内边距以及实际内容）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　但是并不是所有的HTML元素都可以看作是盒子模型，例如图片（img）就不能看作是盒子模型，因为img中只能放图片，并不能添加其他的东西，所以它属于文字流。而盒子模型进行封装的元素大部分是文档流。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;盒子模型中主要的区域：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;盒子模型中主要包含元素的宽，高，外边距，边框，内边距以及实际内容。　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Width：主要区域的内容（content）的宽。&lt;/li&gt;
&lt;li&gt;Height：主要区域的内容（content）的宽。&lt;/li&gt;
&lt;li&gt;Margen：外边距。即整个元素和其他元素的距离。&lt;/li&gt;
&lt;li&gt;Border：元素的边框。&lt;/li&gt;
&lt;li&gt;Padding：内边距。即元素的边与内容的距离。&lt;/li&gt;
&lt;li&gt;Content：内容。也就是实际所看到的区域。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　下面的图片说明了盒子模型的区域：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318130200144-1334747621.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图为代码演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#test&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;                width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;                height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                background-color&lt;/span&gt;:&lt;span&gt; yellowgreen&lt;/span&gt;;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;                margin&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;                padding&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;                border&lt;/span&gt;:&lt;span&gt; 5px solid blue&lt;/span&gt;;
&lt;span&gt;8&lt;/span&gt;             }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318130557399-1580024937.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318130709619-1611485057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;盒子模型属性详解：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;margen/padding： 外边距/内边距&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;　　　只写&lt;span class=&quot;hljs-number&quot;&gt;1个值 ： 表示四周的外边距都是一个值。&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;　　 &lt;/code&gt;&lt;/span&gt; 写&lt;span class=&quot;hljs-number&quot;&gt;2个值： 第一个值表示上下，第二个值表示左右。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;　　　&lt;/code&gt;&lt;/span&gt; 写&lt;span class=&quot;hljs-number&quot;&gt;3个值： 分别表示上，右，下的值，左边的值默认等于右边。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;　　　　&lt;/code&gt;&lt;/span&gt;写&lt;span class=&quot;hljs-number&quot;&gt;4个值： 分别表示上，右，下，左的值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;　　　　&lt;/code&gt;&lt;/span&gt; auto： 放弃某个方向的主导权，交由它的对方向主导。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;　　　　　　　　　　　&lt;/code&gt;&lt;/span&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;　&lt;/code&gt;&lt;/span&gt;水平居中：margen：&lt;span class=&quot;hljs-number&quot;&gt;0 auto；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;　　　　　　　　　　　　&lt;/code&gt;&lt;/span&gt;竖直居中：margen：auto &lt;span class=&quot;hljs-number&quot;&gt;0；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;　　　　　　　　　　　　&lt;/code&gt;&lt;/span&gt;全局居中：margen：auto；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;　　　&lt;/span&gt;boder ：边框 （宽度，样式，颜色） 实线：solid 虚线： dashed 样式可以省略，但是原则上三个属性都要写，三个属性的顺序可以随意颠倒，没有先后要求。 　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;60&quot;&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;br/&gt;1.盒子模型可以随意指定任意方向的相关属性值。&lt;br/&gt;2.使用padding后会撑大div的可见区域，所以使用时应注意div的实际大小。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;64&quot;&gt;&lt;span&gt; 当父盒子包裹子盒子，给子盒子添加margen-top时，子盒子和夫盒子的上边线重合，导致两个盒子同时下来。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &amp;lt;div id=&quot;d1&quot;&amp;gt;&lt;br/&gt;&amp;lt;div id=&quot;d2&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;p&gt;　　　　　 #d1&lt;/p&gt;&lt;/span&gt;{&lt;span&gt;
                width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
                height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
                background-color&lt;/span&gt;:&lt;span&gt; yellowgreen&lt;/span&gt;;
            }&lt;span&gt;
            #d2&lt;/span&gt;{&lt;span&gt;
                width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
                height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
                background-color&lt;/span&gt;:&lt;span&gt; deepskyblue&lt;/span&gt;;&lt;span&gt;
                margin-top&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
            }
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;64&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318132105389-1586886951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;64&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;64&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;64&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;64&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;64&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;64&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【解决办法】&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、给父容器添加一定的padding-top ，会给父容器添加不必要的padding区域，不推荐。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、给父容器添加一定的上边框，会导致父容器产生不必要的边框，不推荐。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、给父容器或者子容器添加float属性。不推荐。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4、给&lt;span&gt;任何一个容器&lt;/span&gt;添加一个属性： overflow:hidden。&lt;span&gt;推荐使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;64&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318132447882-1244701127.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span&gt;&lt;strong&gt;border的补充：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;　&lt;strong&gt;border-radius: ：边框圆角。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;　　 &lt;span class=&quot;hljs-number&quot;&gt;1.共接收&lt;span class=&quot;hljs-number&quot;&gt;8个属性值，分别表示：左上，右上，右下，左下/左上，右上，右下，左下（X轴/Y轴）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;　　 &lt;span class=&quot;hljs-number&quot;&gt;2.省略Y轴默认与X轴相等。如果&lt;span class=&quot;hljs-number&quot;&gt;4个角写不全，默认对角相等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;　　 &lt;span class=&quot;hljs-number&quot;&gt;3.只写一个值，默认&lt;span class=&quot;hljs-number&quot;&gt;8个值均等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;　　 &lt;span class=&quot;hljs-number&quot;&gt;4.div为正方形，当圆角弧度大于等于其宽度的一半，那么该div将显示为圆形。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;代码如下：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;            #div1&lt;/span&gt;{
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                background-image&lt;/span&gt;:&lt;span&gt; url(img/cat.jpg)&lt;/span&gt;;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                border&lt;/span&gt;:&lt;span&gt; 5px solid #FF9E01&lt;/span&gt;;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                border-radius&lt;/span&gt;:&lt;span&gt; 1030px&lt;/span&gt;;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                background-repeat&lt;/span&gt;:&lt;span&gt; no-repeat&lt;/span&gt;;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                background-size&lt;/span&gt;:&lt;span&gt; 200px 200px&lt;/span&gt;;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                margin&lt;/span&gt;:&lt;span&gt; 10px 0px&lt;/span&gt;;
&lt;span&gt;10&lt;/span&gt;             }
&lt;span&gt;11&lt;/span&gt;             
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                #div2&lt;/span&gt;{
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                background-image&lt;/span&gt;:&lt;span&gt; url(img/cat.jpg)&lt;/span&gt;;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                border&lt;/span&gt;:&lt;span&gt; 5px solid #FF9E01&lt;/span&gt;;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                border-radius&lt;/span&gt;:&lt;span&gt; 60px 0px&lt;/span&gt;;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                background-repeat&lt;/span&gt;:&lt;span&gt; no-repeat&lt;/span&gt;;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                background-size&lt;/span&gt;:&lt;span&gt; 200px 200px&lt;/span&gt;;
&lt;span&gt;20&lt;/span&gt;             }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318131656272-48092232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318131723733-934211821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;strong&gt;border-image: ：&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;为元素边框添加背景图片&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;　　　第一个属性：图片的url地址。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;   第二个属性：为切线的大小。（ &lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;写法：第一个值/第二个值&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span&gt;　　　第一个值是切的图片宽度：上右下左，通过四条切线分为九宫格，四个角分别对应边框的四个角，四个角不会平铺拉伸。（不能带单位）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre data-source-line=&quot;72&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span&gt;    第二个值是边框的宽度：上右下左，边框的四条边框。可以自行设置平铺拉伸。（必须带单位）
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;第三个属性：四个角除外的图片属性。拉伸：stretch，铺满：&lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span&gt;round，平铺：repeat。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　例如：　　border-image:&lt;/span&gt;{&lt;span&gt;url(img/QQ图片20180312161643.png  27/27px repeat;&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#image&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;background-color: #Fd9d07;&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;                 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        border-image&lt;/span&gt;:&lt;span&gt; url(img/QQ图片20180312161643.png)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;                      27/27px
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;                      repeat&lt;/span&gt;;
&lt;span&gt;9&lt;/span&gt;         }                            
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318133252967-1852897782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;盒子阴影----box-shadow：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;26.5&quot;&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt;共接收6个属性值，并用空格分隔。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;水平阴影距离，可正可负。右正左负。（&lt;span&gt;必填）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;垂直阴影距离，可正可负。下正上负。（&lt;span&gt;必填）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;阴影模糊半径，只能为整数，默认为0，数值越大，阴影越模糊。&lt;/li&gt;
&lt;li&gt;阴影拓展半径，可正可负，默认为0，数值增大，阴影扩大，数值减小，阴影缩小。&lt;/li&gt;
&lt;li&gt;阴影颜色，默认为黑色。&lt;/li&gt;
&lt;li&gt;内外阴影，默认为外阴影，inset表示内阴影&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            #shadow&lt;/span&gt;{&lt;span&gt;
                width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
                height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
                background-color&lt;/span&gt;:&lt;span&gt; #F1B15A&lt;/span&gt;;&lt;span&gt;
                box-shadow&lt;/span&gt;:&lt;span&gt; 0px 0px 10px 0px red inset&lt;/span&gt;;
                
            }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318133627577-1312947755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;外围线---- outline：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在元素的边框以外，不占据任何空间，但&lt;span&gt;有可能会覆盖四周的内容&lt;/span&gt;，写法上与border一致。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;46&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318133819482-1002098843.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;下面来介绍CSS属性中比较重要的属性--浮动（float）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　浮动--float&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　规律1：标准流模型中的块级盒子，默认宽度是100%；而浮动的块级盒子，宽度不会自动伸展，而是由内容(文字、padding)撑开。浮动后的行级元素会变成块级元素， 可以设置宽度高度等属性值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318134449338-920191617.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　规律2：当一个盒子浮动后，标准流中的其他未浮动盒子将视浮动盒子不存在而占据浮动盒子（浮动盒子的背景会覆盖掉与之大小相同区域的未浮动盒子的背景），但是未浮动盒子中的文字内容，将会受到浮动盒子宽度的影响（浮动盒子不能盖住未浮动盒子的文字内容），也就是浮动可以打破文档流，但是不能打破文字流。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318134432339-1978083170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 规律3：可以使用clear属性使未浮动的盒子不受浮动盒子的影响。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;　clear：清除其他元素浮动对自身造成的影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　可选值：left(清除左浮动) right(清除左浮动) both（清除两个方向浮动）&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;&lt;span&gt;规律4：如果父盒子没有指定高度，而父盒子中的所有子盒子全部浮动，将导致父盒子的高度塌陷，也就是高度无法被子盒子撑开而变为0。&lt;/span&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318134607419-2076154661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决子盒子浮动父盒子塌陷的问题：&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.给父盒子添加overflow：hidden属性。[常用]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.让父盒子也浮动（前提是父盒子的宽度为100%）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.在父容器的最后添加一个高度为0的空div并且添加clear：both属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.使用伪对象选择器：：after生成一个空的元素&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;          #div4::after&lt;/span&gt;{&lt;span&gt;
                            display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
                            content&lt;/span&gt;:&lt;span&gt; &quot;&quot;&lt;/span&gt;;&lt;span&gt;
                            height&lt;/span&gt;:&lt;span&gt; 0px&lt;/span&gt;;&lt;span&gt;
                            clear&lt;/span&gt;:&lt;span&gt; both&lt;/span&gt;;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318134813105-2003402750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;盒模型分类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;CSS3的 box-sizing：Content-box： 标准盒模型（W3C盒子） 。设置的宽和高就是本身内容区域的宽和高，也就是content区域，padding，border等都不算在内，添加padding，border后可是区域会变大。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;Border-box： 怪异盒模型（IE盒子）。 设置的宽和高是可视化区域的所有的长度（content+padding+border），其中包含了padding，border等。如果添加了padding和border后，content区域会被亚索，可视区域不会变大。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318135335781-1099293081.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;手动改变盒子模型： &lt;br/&gt;　　　　&lt;br/&gt;　　　　　#div&lt;/span&gt;{&lt;span&gt;
   　　　　　　 box-sizing&lt;/span&gt;:&lt;span&gt; border-box&lt;/span&gt;;
　　　　　　　　}
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;span&gt;　　&lt;span&gt;定位---position：&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div readability=&quot;31&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;[相对定位]：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;　　　　1、使用&lt;span&gt;position：relative&lt;span&gt;。设置成相对定位。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2、使用top/right/bottom/left设置定位的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3、定位机制：&lt;/span&gt;&lt;/p&gt;
&lt;span&gt;　　　　　　1.相对定位是相对自己原来所属位置进行定位。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　2.相对定位不会释放掉原来自己所属的位置，也不会影响其他元素。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　3.如果left/right同时存在，left生效。top/bottom同时存在，top生效。&lt;/span&gt;&lt;p&gt;&lt;span&gt;　　　　4、关于Z轴的重叠次序：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　 1.定位元素，默认的Z轴高于普通文档流和浮动元素。&lt;br/&gt;　　　　　　 2.同为定位元素，后来者居上。&lt;br/&gt; 　　　　　　3.可以使用z-index调整上下层关系（只能使用在定位元素）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318135712112-763090393.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 　　　&lt;span&gt;&lt;span&gt;&lt;strong&gt;[绝对定位]：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　　　　　1、使用position：absolute。设置成绝对定位。&lt;br/&gt;　　　　　　2、定位机制：&lt;br/&gt;　　　　　　　　1.相对与第一个有定位的父元素进行定位。（第一个使用定位）&lt;br/&gt;　　　　　　　　2.如果元素没有已定位的祖先元素，那么它的位置相对于浏览器左上角定位。&lt;br/&gt;　　　　　　3、绝对定位文档流会彻底删除，原空间被释放。　&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318135832754-2143207049.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;span&gt;&lt;span&gt;&lt;strong&gt;[固定定位]：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　1、 使用&lt;span&gt;position：fixed&lt;span&gt;。设置成固定定位。是一种特殊的绝对定位。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、元素的位置相对于浏览器窗口左上角定位。即使窗口是滚动的它也不会移动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、固定定位使元素的位置与文档流无关，因此不占据空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、固定定位的元素和其他元素重叠。&lt;/span&gt; &lt;span&gt;　&lt;span&gt;&lt;strong&gt;[Z-index]&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;　　1. 使用z-index可以调整层叠顺序。数值越大，层叠越往上；z-index数值相等，后来者居上。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　2.  z-index只能作用于定位元素。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　3. 元素的z-index属性要考虑父容器的z-index约束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果父容器设置了z-index，那么子容器不能脱离父容器的约束，而必须与父容器处同一级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果父容器没有设置z-index，或者设置了z-index：auto。则子元素不受父容器约束。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　4. z-index：0与z-index：auto区别：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　z-index：auto和z-index：0处于同一层，且z-index：auto是默认值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　z-index：auto不约束子元素；z-index：0约束子元素。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;裁切 --- clip：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、clip属性只能用于裁切图片，显示图片的指定区域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、clip属性只能作用于absolute和fixed定位的元素上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、属性值只接受一个rect函数，函数传入四个值，分别表示上右下左。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;[注意]&lt;/span&gt;&lt;span&gt;：与其他的上右下左不同，上下为从原图的上方到想要区域的顶部和底部的距离，左右为从原图的左边到想要区域的左端和右端的距离。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;负边距应用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置元素在父容器中水平垂直居中，也可以增加元素的宽度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、设置子元素为定位元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、给子元素添加属性：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;left: 50%;
　　　　 top: 50%;
&lt;span&gt;　　　　 &lt;/span&gt;margin-left: -(width/2)px;
&lt;span&gt;　　　　 &lt;/span&gt;margin-top: -(height/2)px;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201803/1350478-20180318140419840-611303234.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 18 Mar 2018 06:05:00 +0000</pubDate>
<dc:creator>阿来丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JiangLai/p/8595309.html</dc:identifier>
</item>
<item>
<title>htop命令使用详解 - zangfans</title>
<link>http://www.cnblogs.com/zangfans/p/8595000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zangfans/p/8595000.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、htop 简介&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;13.20325203252&quot;&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    htop 是Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)，需要ncurses。&lt;/span&gt;&lt;span&gt;与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;htop相比较top的优势：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;&lt;span&gt;可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在启动上比top 更快。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;杀进程时不需要输入进程号。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;htop 支持鼠标选中操作（反应不太快）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;top 已不再维护。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://hisham.hm/htop/index.php?page=downloads&quot;&gt;htop下载&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;htop的作者&lt;span&gt;Hisham Muhammad在github上的项目&lt;/span&gt;：&lt;a href=&quot;https://github.com/hishamhm/htop&quot;&gt;https://github.com/hishamhm/htop&lt;/a&gt;&lt;/p&gt;
&lt;div&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;二、htop 安装&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;a. 源码包编译安装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div data-mode=&quot;JavaScript&quot; data-theme=&quot;default&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@zangfans ~]# tar zxvf htop-1.0.2.tar.gz
[root@zangfans ~]# cd htop-1.0.2
[root@zangfans ~]# yum -y install ncurses-devel
[root@zangfans ~]# yum -y install gcc
[root@zangfans ~]# ./configure
[root@zangfans ~]# make 
[root@zangfans ~]# make install
&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;b. 通过yum安装htop&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建一个阿里云yum仓库直接安装&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div data-mode=&quot;JavaScript&quot; data-theme=&quot;default&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
搭建aliyun仓库
[root@zangfans ~]# cd /etc/yum.repos.d
[root@zangfans ~]# vim zf.repo
[EPEL]
name=aliyun
baseurl=https://mirrors.aliyun.com/centos/6/os/x86_64/
gpgcheck=0
[root@zangfans ~]# yum cleanall
[root@zangfans ~]# yum makecache
[root@zangfans ~]# yum install htop
&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;三、htop 参数&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;键入htop 命令，打开htop&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div data-mode=&quot;JavaScript&quot; data-theme=&quot;default&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@zangfans ~]# htop
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122618709-478510096.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122618709-478510096.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;371&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;上面左上角显示CPU、内存、交换区的使用情况，右边显示任务、负载、开机时间，下面就是进程实时状况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;下面是 F1~F10 的功能和对应的字母快捷键。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;wiz-table-container&quot;&gt;
&lt;div class=&quot;wiz-table-body&quot;&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Shortcut Key&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Function Key&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Description&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;311&quot;&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;中文说明&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;h, ?&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;F1&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Invoke htop Help&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;311&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;查看htop使用说明&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;S&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;F2&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Htop Setup Menu&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;311&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;htop 设定&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;/&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;F3&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Search for a Process&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;311&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;搜索进程&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;\&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;F4&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Incremental process filtering&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;311&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;增量进程过滤器&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;t&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;F5&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Tree View&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;311&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;显示树形结构&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&amp;lt;, &amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;F6&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Sort by a column&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;311&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;选择排序方式&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;[&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;F7&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Nice - (change priority)&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;311&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;可减少nice值，这样就可以提高对应进程的优先级&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;]&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;F8&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Nice + (change priority)&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;311&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;可增加nice值，这样就可以降低对应进程的优先级&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;k&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;F9&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Kill a Process&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;311&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;可对进程传递信号&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;q&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;F10&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Quit htop&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;311&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;结束htop&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;命令行选项（COMMAND-LINE OPTIONS）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
-C --no-color　　　　 　　 使用一个单色的配色方案
-d --delay=DELAY　　　　 设置延迟更新时间，单位秒
-h --help　　　　　　  　　 显示htop 命令帮助信息
-u --user=USERNAME　　  只显示一个给定的用户的过程
-p --pid=PID,PID…　　　    只显示给定的PIDs
-s --sort-key COLUMN　    依此列来排序
-v –version　　　　　　　   显示版本信息
交互式命令（INTERACTIVE COMMANDS）
上下键或PgUP, PgDn 选定想要的进程，左右键或Home, End 移动字段，当然也可以直接用鼠标选定进程；
Space    标记/取消标记一个进程。命令可以作用于多个进程，例如 &quot;kill&quot;，将应用于所有已标记的进程
U    取消标记所有进程
s    选择某一进程，按s:用strace追踪进程的系统调用
l    显示进程打开的文件: 如果安装了lsof，按此键可以显示进程所打开的文件
I    倒转排序顺序，如果排序是正序的，则反转成倒序的，反之亦然
+, -    When in tree view mode, expand or collapse subtree. When a subtree is collapsed a &quot;+&quot; sign shows to the left of the process name.
a (在有多处理器的机器上)    设置 CPU affinity: 标记一个进程允许使用哪些CPU
u    显示特定用户进程
M    按Memory 使用排序
P    按CPU 使用排序
T    按Time+ 使用排序
F    跟踪进程: 如果排序顺序引起选定的进程在列表上到处移动，让选定条跟随该进程。这对监视一个进程非常有用：通过这种方式，你可以让一个进程在屏幕上一直可见。使用方向键会停止该功能。
K    显示/隐藏内核线程
H    显示/隐藏用户线程
Ctrl-L    刷新
Numbers    PID 查找: 输入PID，光标将移动到相应的进程上
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;20&quot;&gt;
&lt;div readability=&quot;36.5&quot;&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;四、htop 使用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;4.1. 显示自带帮助&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    鼠标点击Help或者按F1 显示自带帮助&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122619459-377539035.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122619459-377539035.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;459&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;4.2. htop 设定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    鼠标点击Setup或者按下F2 之后进入htop 设定的页面，Meters 页面设定了顶端的一些信息显示，顶端的显示又分为左右两侧，到底能显示些什么可以在最右侧那栏新增，要新增到上方左侧（F5）或是右侧（F6）都可以，这就是个人设定的范围了。这里多加了一个时钟。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122619677-101465307.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122619677-101465307.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;489&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    上方左右两栏的显示方式分为Text Bar Graph Led 四种&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122619860-1185852654.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122619860-1185852654.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;492&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    关于Display options 的设定，可要根据管理者自己的需要来设定。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122620049-2108646901.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122620049-2108646901.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;525&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;4.3. 搜索进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    鼠标点击Search 或者按下F3 或者输入&quot;/&quot;， 输入进程名进行搜索，例如搜索bash&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122620223-88278101.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122620223-88278101.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;95&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;4.4. 过滤器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    按下F4，进入过滤器，相当于关键字索引，不区分大小写，如果筛选条件一直保存，可以通过Esc键清除&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122620483-411504733.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122620483-411504733.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;403&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;4.5. 显示树形结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    输入&quot;t&quot;或按下F5，显示树形结构，效果和pstree命令差不多，父子进程可以列出来，命令集合的东西很多。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122620762-2077971772.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122620762-2077971772.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;326&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;4.6. 选择排序方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    按下F6 就可以指定目标条件显示&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122621288-896488729.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122621288-896488729.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;480&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;4.7 操作进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    F7调高优先级nice-和F8调低优先级nice+，F9kill选中的进程发信号&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122621488-844470968.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122621488-844470968.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;481&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;4.8. 显示某个用户的进程，在左侧选择用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    输入&quot;u&quot;，在左侧选择用户&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122621725-1578707717.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1270435/201803/1270435-20180318122621725-1578707717.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;406&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;五、Alias top&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;使用老式top命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;编辑/root/.bashrc文件此文件对当前用户生效，添加如下代码&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@zangfans ~]# vim /root/.bashrc
if [ -f /usr/local/bin/htop ]; then
   alias top=’/usr/local/bin/htop’
fi
[root@zangfans ~]# source /root/.bashrc
&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Sun, 18 Mar 2018 04:26:00 +0000</pubDate>
<dc:creator>zangfans</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zangfans/p/8595000.html</dc:identifier>
</item>
<item>
<title>面向对象（一）【“类与对象”的概念及特性】 - ZingpLiu</title>
<link>http://www.cnblogs.com/zingp/p/8584323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zingp/p/8584323.html</guid>
<description>
&lt;p&gt;&lt;span&gt;面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程范式，同时也是一种程序开发的抽象方针。在此不再累述编程范式的种种类别，重点讨论“类与对象”概念及特性。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1 类与对象的概念&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;类（class）： 对一类具有相同属性的对象的抽象。比如，牧羊犬、金毛、哈士奇都可抽象为“狗”类。类的定义包含了数据的形式以及对数据的操作。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对象（object）： 类的实例，每个对象都是其类中的一个实体。比如，我家的狗名字叫buck， 那么buck这条活生生的狗就是“狗”这个类的实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来看一下python中是如何定义一个类的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个 Dog 类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[{}]:Wang Wang Wang.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.name))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建对象buck&lt;/span&gt;
buck = Dog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;buck&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用对象中的talk()方法&lt;/span&gt;
buck.talk()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对上述定义类的代码中的某些关键字进行简单阐述：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;定义类： 通过class这个关键字定义一个类，类名叫Dog。&lt;br/&gt;属性： name变量就是Dog这个类封装的一个属性。&lt;br/&gt;方法： talk()函数就是Dog这个类中的方法。&lt;br/&gt;self: 注意这是个特殊参数，当类实例化之后self即是对象本身。&lt;br/&gt;创建对象：在类名之后添加括号，传入需要的参数，就创建了一个对象。&lt;br/&gt;访问对象中的属性或方法：通过 对象.属性 或者 对象.方法 的形式。&lt;br/&gt;__init__()：类的构造函数，创建对象会调用该方法，后面会详细解释。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单了解了类与对象的概念、定义类，创建对象、属性和方法等之后，我们接着阐述面向对象的三大特性：封装、继承、多态。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2 封装性&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;属性和方法都叫类的成员。&lt;span&gt;&lt;strong&gt;&lt;span&gt;封装（Encapsulation）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;是通过限制只有特定类的对象可以访问这一特定类的成员，其中有两点需要注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一是类抽象出一些成员封装在某个地方；二是通过某种形式可以访问这些成员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面的代码定义了一个Person类， 封装了人的name, age，还有一个自我介绍的hello() 方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.age &lt;/span&gt;=&lt;span&gt; age

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hello(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello, my name is %s, i'm %s years old&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (self.name, self.age))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 封装到某处&lt;/span&gt;
person1 = Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YouYuan Liu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 25&lt;span&gt;)
person2 &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeo Chen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 38&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 访问属性&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(person1.name)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; YouYuan Liu&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(person2.name)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Jeo Chen&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 访问方法&lt;/span&gt;
person1.hello()        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Hello, my name is YouYuan Liu, i'm 25 years old&lt;/span&gt;
person2.hello()        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Hello, my name is Jeo Chen, i'm 38 years old &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;2.1 封装到某处&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当执行 person1 = Person(&quot;YouYuan Liu&quot;, 25)时，self 等于 person1，并把 &quot;YouYuan Liu&quot; 和 25 分别封装到了self/person1 的name和age中；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当执行 person2 = Person(&quot;Jeo Chen&quot;, 38)时，self 等于 person2， 并把 &quot;Jeo Chen&quot; 和 38 分别封装到了self/person1 的name和age中。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2 访问封装的内容&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）访问属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过 对象.属性 的方式访问，如person1.name就是访问之前封装的person1这个对象的name属性，即&quot;YouYuan Liu&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）访问方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过 对象.方法  的方式访问，如person1.hello() 访问到了hello()方法，hello中调用了self.name 和self.age，实际上此处self=person1，通过self间接访问了属性。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3 继承性&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;3.1 单继承&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;继承性（Inheritance）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是指，在某种情况下，一个类会有“子类”。子类比原本的类（称为父类）要更加具体化。例如上例 “人(Person)”这个类，它可能会有“男人类(Man)”、“女人类(Woman)”这两个子类。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;子类会继承父类的属性和行为，并且也可包含它们自己的。如女人类(Woman)，会继承人(Person)的“姓名name”、“年龄age”以及“自我介绍hello()”等成员，也有自己独有的成员“生孩子birth_children()”。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下列代码演示了Python语法怎么实现继承：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.age &lt;/span&gt;=&lt;span&gt; age

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hello(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello, my name is %s, i'm %s years old&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (self.name, self.age))

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Man(Person):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 继承的第一种写法&lt;/span&gt;
        Person.&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Woman(Person):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 继承的第二种写法&lt;/span&gt;
        super(Woman, self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(name, age)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; birth_children(self, p):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[{}] birthed [{}]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(self.name, p))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意上述两种继承的写法。子类既继承了父类的所有成员，又有自己的独有成员：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
man1 = Man(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YouYuan Liu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 25&lt;span&gt;)
woman1 &lt;/span&gt;= Woman(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeo Chen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 38&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(man1.name)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; YouYuan Liu&lt;/span&gt;
man1.hello()         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Hello, my name is YouYuan Liu, i'm 25 years old&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(woman1.age)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;
&lt;span&gt;
woman1.birth_children(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;little Jeo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [Jeo Chen] birthed [little Jeo]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2 多继承&lt;/h3&gt;
&lt;p&gt; &lt;span&gt;继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。Python中是支持多重继承的，此处我们着重谈一下面试常考的多重继承顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）在Python3中多继承&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写下如下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        super(B, self).run()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; C(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        super(C, self).run()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; D(B, C):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        super(D, self).run()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; E(B, C):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;

a &lt;/span&gt;=&lt;span&gt; A()
b &lt;/span&gt;=&lt;span&gt; B()
c &lt;/span&gt;=&lt;span&gt; C()
d &lt;/span&gt;=&lt;span&gt; D()
e &lt;/span&gt;= E()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来我们运行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;b.run()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; run A&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; run B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里不难理解，因为在class B 的run()方法中，显式地调用了其父类（class A）的run()方法，所以，会先执行类A的run()方法，然后再执行类B的run()方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那我们接着运行下面的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;d.run()  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; run A&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; run C&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; run B&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; run D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这就有点难以理解了。按照我们“正常的思维”理解：调用D中的run()方法，不是应该找D的父类B的run()方法，然后B中的run()调用其父类A中的方法run()了吗，那么顺序应该是run A--&amp;gt;run B --&amp;gt;run D啊，这里第二个位置怎么多了个run C 呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这是为什么？为什么？Why？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这是因为Python3中的多继承是按照&quot;广度优先&quot;(Breadth-First Search)顺序继承的。什么是广度优先呢？我们将上面的A/B/C/D类继承关系画成一颗树：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/986023/201803/986023-20180318101115843-195290150.png&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;广度优先，就意味着继承顺序变成了D ---&amp;gt; B ---&amp;gt; C ---&amp;gt; A。展开而言，当调用D中的run()，由于D中run()主动调用父级run()即B中run()；B中run()主动调用父级run()即C中run()；C中run()主动调用父级run()即A中run()。所以自然打印顺序就成了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
run A ---&amp;gt; run C ---&amp;gt; run B ---&amp;gt; run D
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;好了，那么思考一下下面的代码会打印什么呢，你能解释打印结果吗？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）Python2中的多继承&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Python2中，经典类和新式类的继承顺序不同，经典类是按照深度优先顺序，而新式类是按照广度优先的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Python 2.x中默认都是经典类，只有显式继承了object才是新式类。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; python2.x中：&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 经典类 默认&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 新式类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Python 3.x中默认都是新式类，不必显式的继承object。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; python3.x中：&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以下均是新式类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4 多态性&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;多态（Polymorphism）是指由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。例如，狗和猫都有“叫()”这一方法，但是调用狗的“叫()”，狗会汪汪叫；调用猫的“叫()”，鸡则会喵喵叫。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在Python中崇尚鸭子类型：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wang wang!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cat(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Miao miao~~&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; animal_talk(obj):
    obj.talk()

dog &lt;/span&gt;=&lt;span&gt; Dog()
cat &lt;/span&gt;=&lt;span&gt; Cat()
animal_talk(dog)
animal_talk(cat)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Wang wang!&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Miao miao~~&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;有种“一个接口，多种实现”的感觉。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5 面向对象的优势&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;（1）程序的解耦  （2）代码的可复用 性 （3）代码清晰，易于理解，便于维护。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设现在我们要实现一个人的自我介绍，那么我们对比一下，不用面向对象，和用面向对象，有啥区别：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;5.1 不用面向对象&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(name, age, city):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I am {}, {} years old, from {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(name, age, city))

talk(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Liu yi fei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 30, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BJ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
talk(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Liu you yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 25, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
talk(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeo Chen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 38, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TW&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.2 面向对象&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, city):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.age &lt;/span&gt;=&lt;span&gt; age
        self.city &lt;/span&gt;=&lt;span&gt; city

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I am {}, {} years old, from {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.name, self.age, self.city))

obj1 &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Liu yi fei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 30, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BJ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
obj1.talk()
obj2 &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Liu you yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 25, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
obj2.talk()
obj3 &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeo Chen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 38, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TW&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
obj3.talk()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样一看，不用面向对象似乎代码更短、更简洁？ 那为啥还要用面向对象？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;但是， 我们想想啊，假设还有500个人，另外还有跑步run()，吃eat()，睡sleep()等10种方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不用面向对象的话，1个人的10中方法就会重复写10次:方法(&quot;name&quot;, &quot;age&quot;, &quot;city&quot;)了；而面向对象只需要写一次。当然这只是一个简单例子罢了，面向对象的优势远不止这些，在此不再多说。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6 小结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;类： 对一类具有相同属性的对象的抽象，如哈士奇、金毛都可抽象为狗类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象：类的实例。狗类的一个实例，如我家的狗 buck。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面向对象的三大特性：封装、继承、多态。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 18 Mar 2018 04:09:00 +0000</pubDate>
<dc:creator>ZingpLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zingp/p/8584323.html</dc:identifier>
</item>
</channel>
</rss>