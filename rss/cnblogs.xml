<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>HTML5游戏开发进阶指南读书笔记 - 90后幽默大叔</title>
<link>http://www.cnblogs.com/LiuDiJun/p/9837039.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LiuDiJun/p/9837039.html</guid>
<description>&lt;p&gt;创建游戏图层＃gamecanvas（游戏图层）、＃scorescreen（得分显示图层）、＃gamestartscreen（游戏开始图层）、＃levelselectscreen（关卡选择图层）、＃loadingscreen（资源加载图层）、＃endingscreen（游戏结束图层）所有图层共用.gamelayer，所有图层放于＃gamecontainer中。&lt;/p&gt;
&lt;p&gt;解决动画函数requestanimationframe兼容性问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 1 (function&lt;span&gt;(){
 2     var vendors = ['o','webkit','moz','ms'&lt;span&gt;];
 3     var lastTime = 0&lt;span&gt;;
 4     for(var i=0; i&amp;lt;vendors.length&amp;amp;&amp;amp;!window.requestAnimationFrame; i++&lt;span&gt;){  &lt;br/&gt;　　    //循环检测当前浏览器支持的方法名
 5         window.requestAnimationFrame = window[vendors[i]+'requestAnimationFrame'&lt;span&gt;];&lt;br/&gt;//将不同浏览器动画函数名统一
 6         window.cancelAnimationFrame = window[vendors[i]+'CancelAnimationFrame']||
 7                                       window[vendors[i]+'CancelRequestAnimationFrame'&lt;span&gt;];
 8 &lt;span&gt;    }
 9     if(!&lt;span&gt;window.requestAnimationFrame){&lt;br/&gt;　　　　//检测浏览器是否支持动画函数
10         window.requestAnimationFrame =function&lt;span&gt; (callback,element) {
11             var currTime = new&lt;span&gt; Date().getTime();
12             var timeToCall = Math.max(0,16-(currTime-&lt;span&gt;lastTime));&lt;br/&gt;　　　　　　　　　//理想刷新率为60hz（每1/60秒重绘一次），不断尝试修正刷新率。
13             var id =&lt;span&gt; window.setTimeout(callback(),timeToCall);&lt;br/&gt;　　　　　　　　 //timeToCall为0时各浏览器将采用最小调用单位时间。
14             lastTime =currTime+&lt;span&gt;timeToCall;&lt;br/&gt;　　　　　　　　 //执行后的时间。
15             return&lt;span&gt; id;
16 &lt;span&gt;        }
17 &lt;span&gt;    }
18     if (!&lt;span&gt;window.cancelAnimationFrame){
19         window.cancelAnimationFrame = function&lt;span&gt;(id){
20 &lt;span&gt;            clearTimeout(id);
21 &lt;span&gt;        }
22 &lt;span&gt;    }
23 
24 }());&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构建资源加载器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 1 var loader =&lt;span&gt; {
 2         totalCount : 0&lt;span&gt;,
 3         loadedCount : 0&lt;span&gt;,
 4         loaded : true&lt;span&gt;,
 5         soundFileExtn:'mp3'&lt;span&gt;,
 6         init:function&lt;span&gt;(){
 7             var audio = new&lt;span&gt; Audio();
 8             if&lt;span&gt;(audio.canPlayType){
 9                 loader.soundFileExtn = audio.canPlayType('audio/mpeg')?'.mp3'&lt;span&gt;:
10                 audio.canPlayType('audio/ogg')?'.ogg'&lt;span&gt;:undefined;
11 &lt;span&gt;            }
12 &lt;span&gt;        },
13         loadImg:function&lt;span&gt; (url) {
14           loader.totalCount++&lt;span&gt;;
15           loader.loaded = false&lt;span&gt;;
16           $('#loadingscreen'&lt;span&gt;).show();
17           var img =new&lt;span&gt; Image();
18           img.src =&lt;span&gt; url;
19           img.onload =&lt;span&gt; loader.itemLoaded;
20           return&lt;span&gt; img;
21 &lt;span&gt;        },
22         loadSound:function&lt;span&gt; (url) {
23             loader.totalCount++&lt;span&gt;;
24             loader.loaded = false&lt;span&gt;;
25             $('#loadingscreen'&lt;span&gt;).show();
26             var audio =new&lt;span&gt; Audio();
27             audio.src =&lt;span&gt; url;
28             audio.addEventListener(&quot;canplaythrough&quot;,loader.itemLoaded,false&lt;span&gt;);
29             return&lt;span&gt; audio;
30 &lt;span&gt;        },
31         itemLoaded:function&lt;span&gt; () {&lt;br/&gt;　　　　　　 //某单个资源加载完成后触发该函数
32             loader.loadedCount++&lt;span&gt;;
33             $('#loadingmessage').html('loaded: '+loader.loadedCount+' of '+&lt;span&gt;loader.totalCount)
34             if (loader.totalCount ==&lt;span&gt; loader.loadedCount){&lt;br/&gt;　　　　　　　　　　　//判断是否已全部加载完
35                 loader.loaded = true&lt;span&gt;;
36                 $('#loadingscreen'&lt;span&gt;).hide();
37 &lt;span&gt;            }
38             if&lt;span&gt; (loader.onload){
39 &lt;span&gt;                loader.onload();
40 &lt;span&gt;            }
41 &lt;span&gt;    }
42 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建关卡加载器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
 1 var level =&lt;span&gt; {
 2 &lt;span&gt;    data:[&lt;br/&gt;　　　　//创建data数组存储各关卡数据
 3 &lt;span&gt;        {
 4             foreground:'desert-foreground'&lt;span&gt;,
 5             background:'clouds-background'&lt;span&gt;,
 6 &lt;span&gt;        },
 7 &lt;span&gt;        {
 8             foreground:'desert-foreground'&lt;span&gt;,
 9             background:'clouds-background'&lt;span&gt;,
10 &lt;span&gt;        },
11 &lt;span&gt;        {
12             foreground:'desert-foreground'&lt;span&gt;,
13             background:'clouds-background'&lt;span&gt;,
14 &lt;span&gt;        }
15 &lt;span&gt;    ],
16     init:function&lt;span&gt; () {
17         var html=''&lt;span&gt;;
18         for(var i =0; i&amp;lt;level.data.length; i++&lt;span&gt;){
19             html +='&amp;lt;input type=&quot;button&quot; value=&quot;'+(i+1)+'&quot;&amp;gt;'&lt;span&gt;;
20 &lt;span&gt;        };
21         $('#levelselectscreen'&lt;span&gt;).html(html);
22         $('#levelselectscreen input').click(function&lt;span&gt; () {
23             level.load(this.value-1&lt;span&gt;);&lt;br/&gt;　　　　　　　　　//加载各关卡数据。
24             $('#levelselectscreen'&lt;span&gt;).hide();
25 &lt;span&gt;        })
26 &lt;span&gt;    },
27     load:function&lt;span&gt; (number) {
28         game.score = 0&lt;span&gt;;
29         $('#score').html(&quot;score:&quot;+&lt;span&gt;game.score);
30         game.currtLevel.foregroundImage = loader.loadImg(&quot;img/backgrounds/&quot;+level.data[number].foreground+&quot;.png&quot;&lt;span&gt;);
31         game.currtLevel.backgroundImage = loader.loadImg(&quot;img/backgrounds/&quot;+level.data[number].background+&quot;.png&quot;&lt;span&gt;);
32         //将当前关卡中的数据存储到game.currtLevel对象中。&lt;br/&gt;　　　　　　 game.slingshotImage = loader.loadImg(&quot;img/slingshot.png&quot;&lt;span&gt;);
33         game.slingshotFrontImage = loader.loadImg(&quot;img/slingshot-front.png&quot;&lt;span&gt;);
34         if&lt;span&gt; (loader.loaded){
35 &lt;span&gt;            game.start();&lt;br/&gt;　　　　　　　　  //当前关卡数据加载完成后执行game.start()。
36         } else&lt;span&gt;{
37             loader.onload =&lt;span&gt; game.start();
38 &lt;span&gt;        }
39 &lt;span&gt;    }
40 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构建鼠标对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 1 var mouse =&lt;span&gt; {
 2     x:0&lt;span&gt;,
 3     y:0&lt;span&gt;,
 4     down:false&lt;span&gt;,
 5     dragging:false&lt;span&gt;,
 6     init:function&lt;span&gt;(){&lt;br/&gt;//为在#gamecanvas上的鼠标事件绑定监听函数
 7         $('#gamecanvas'&lt;span&gt;).mousemove(mouse.mousemovehandler);
 8         $('#gamecanvas'&lt;span&gt;).mousedown(mouse.mousedownhandler);
 9         $('#gamecanvas'&lt;span&gt;).mouseup(mouse.mouseuphandler);
10         $('#gamecanvas'&lt;span&gt;).mouseout(mouse.mouseuphandler);
11 &lt;span&gt;    },
12     mousemovehandler:function&lt;span&gt; (ev) {
13         var offset = $('#gamecanvas'&lt;span&gt;).offset();
14         mouse.x = ev.pageX -&lt;span&gt; offset.left;
15         mouse.y = ev.pageY -&lt;span&gt; offset.right;&lt;br/&gt;　　       //获取鼠标在画布中的坐标
16         if&lt;span&gt;(mouse.down){&lt;br/&gt;　　　　　　//判断是否点击并移动
17             mouse.dragging = true&lt;span&gt;;
18 &lt;span&gt;        }
19 &lt;span&gt;    },
20     mousedownhandler:function&lt;span&gt; (ev) {
21         mouse.down = true&lt;span&gt;;
22         mouse.downX =&lt;span&gt; mouse.x;
23         mouse.downY =&lt;span&gt; mouse.y;
24 &lt;span&gt;        ev.originalEvent.preventDefault();
25 &lt;span&gt;    },
26     mouseuphandler:function&lt;span&gt; () {
27         mouse.down = false&lt;span&gt;;
28         mouse.dragging = false&lt;span&gt;;
29 &lt;span&gt;    }
30 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构建game对象&lt;/p&gt;
&lt;p&gt;初始化init( )：调用loader对象初始化函数检测浏览器支持的音频格式；&lt;/p&gt;
&lt;p&gt;调用level对象初始化函数获取内部定义的关卡数据，加载出＃levelselectscreen关卡按钮并为按钮绑定关卡资源加载函数，对应关卡资源加载完毕调用game对象的start函数；&lt;/p&gt;
&lt;p&gt;调用mouse对象初始化函数为鼠标行为绑定处理函数；&lt;/p&gt;
&lt;p&gt;获取＃gamecanvas绘制上下文；&lt;/p&gt;
&lt;p&gt;为game对象创建start函数&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
1 start:function&lt;span&gt; () {
2         $('.gamelayer'&lt;span&gt;).hide();
3         $('#gamecanvas'&lt;span&gt;).show();
4         $('#scorescreen'&lt;span&gt;).show();
5         game.mode = &quot;intro&quot;&lt;span&gt;;&lt;br/&gt;　　　　　　//进入'intro'状态
6         game.ended = false&lt;span&gt;;
7         game.animateFrame =&lt;span&gt; window.requestAnimationFrame(game.animate,game.canvas);&lt;br/&gt;　　　　   //执行game.animate函数，开始过场动画
8     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为game对象创建animate函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
 1 animate:function&lt;span&gt; () {
 2 &lt;span&gt;        game.handlePanning();&lt;br/&gt;　　　　　　　//确定game.offsetLeft大小和“方向”
 3         game.context.drawImage(game.currtLevel.backgroundImage,game.offsetLeft/4,0,640,480,0,0,640,480);
 4         game.context.drawImage(game.currtLevel.foregroundImage,game.offsetLeft,0,640,480,0,0,640,480&lt;span&gt;);&lt;br/&gt;　　　　　　 //动态绘制背景图
 5 &lt;span&gt;        game.context.drawImage(game.slingshotImage,game.slingshotX,game.slingshotY);
 6 &lt;span&gt;        game.context.drawImage(game.slingshotFrontImage,game.slingshotX,game.slingshotY);
 7         if(!&lt;span&gt;game.ended){&lt;br/&gt;　　　　    //若游戏未结束不断重绘
 8             game.animateFrame =&lt;span&gt; window.requestAnimationFrame(game.animate,game.canvas);
 9 &lt;span&gt;        }
10     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为game对象创建handlePanning函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 handlePanning:function&lt;span&gt;(){&lt;br/&gt;　　//通过game.mode游戏状态确定移动方式并切换游戏状态
 2         if(game.mode == &quot;intro&quot;&lt;span&gt;){
 3             if(game.panTo(700&lt;span&gt;)){&lt;br/&gt;　　　　　　　　　　　//“激活”，判断当前是否移动到指定位置并进入下一个游戏状态
 4                 game.mode = &quot;load-next-hero&quot;&lt;span&gt;;
 5 &lt;span&gt;            };
 6 &lt;span&gt;        }
 7         if(game.mode == &quot;wait-for-firing&quot;&lt;span&gt;){
 8             if&lt;span&gt;(mouse.dragging){
 9                 game.panTo(mouse.x+&lt;span&gt;game.offsetLeft);
10             }else&lt;span&gt; {
11 &lt;span&gt;                game.panTo(game.slingshotX);
12 &lt;span&gt;            }
13 &lt;span&gt;        }
14         if(game.mode == &quot;load-next-hero&quot;&lt;span&gt;){
15 &lt;span&gt;            game.panTo(game.slingshotX);
16             game.mode == &quot;wait-for-firing&quot;&lt;span&gt;;
17 &lt;span&gt;        }
18 
19     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为game对象创建panTo函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 panTo:function&lt;span&gt;(newcenter){
 2         if(Math.abs(newcenter-game.offsetLeft-game.canvas.width/4)&amp;gt;0 &amp;amp;&amp;amp; game.offsetLeft &amp;gt;= game.minoffset&amp;amp;&amp;amp;
 3            game.offsetLeft &amp;lt;=&lt;span&gt; game.maxoffset){&lt;br/&gt;　　　　　　 //判断当前中心位置是否位于两临界点间或在制定中心位置附近
 4             var deltaX = Math.round((newcenter-game.offsetLeft-game.canvas.width/4)/2&lt;span&gt;);&lt;br/&gt;　　　　　　　　 //初步确定单次移动量和移动方向
 5             if (Math.abs(deltaX)&amp;gt;&lt;span&gt;game.maxspeed){&lt;br/&gt;　　　　　　　　 //控制在maxspeed中
 6                 deltaX = game.maxspeed*Math.abs(deltaX)/deltaX;
 7 &lt;span&gt;            }
 8             console.log(&quot;deltaX=&quot;+&lt;span&gt;deltaX);
 9             game.offsetLeft +=&lt;span&gt; deltaX;
10             console.log(&quot;game.offsetLeft=&quot;+&lt;span&gt;game.offsetLeft);
11         }else&lt;span&gt;{&lt;br/&gt;　　　　　　　//完成指定中心位移return 结果停止位移（动画）
12             return true&lt;span&gt;;
13 &lt;span&gt;        }
14         if (game.offsetLeft &amp;lt;&lt;span&gt; game.minoffset) {&lt;br/&gt;　　　　　　 //超过零界点重置
15             game.offsetLeft =&lt;span&gt; game.minoffset;
16             return true&lt;span&gt;;
17 &lt;span&gt;        }
18         if (game.offsetLeft &amp;gt;&lt;span&gt; game.maxoffset) {
19             game.offsetLeft =&lt;span&gt; game.maxoffset;
20             return true&lt;span&gt;;
21 &lt;span&gt;        }
22         return false&lt;span&gt;;
23     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 23 Oct 2018 07:44:00 +0000</pubDate>
<dc:creator>90后幽默大叔</dc:creator>
<og:description>创建游戏图层＃gamecanvas（游戏图层）、＃scorescreen（得分显示图层）、＃gamestartscreen（游戏开始图层）、＃levelselectscreen（关卡选择图层）、＃lo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LiuDiJun/p/9837039.html</dc:identifier>
</item>
<item>
<title>模拟微信端进行投票手刷 - 阿里奇奇</title>
<link>http://www.cnblogs.com/devilgod/p/9837021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/devilgod/p/9837021.html</guid>
<description>&lt;p&gt;1 工具：&lt;/p&gt;
&lt;p&gt;　　手机 电脑 WIFI fiddler postman 谷歌浏览器 插件 User Agent Switcher  EditThisCookie&lt;/p&gt;

&lt;p&gt;1 首先 下载工具 fiddler 安装&lt;/p&gt;

&lt;p&gt;2当安装完成时打开 修改 Tools =&amp;gt; options 选择 Connections   打上对勾 重新启动  查看IP 记录下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488913/201810/1488913-20181023152946567-1771919020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





















&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488913/201810/1488913-20181023153052802-642694826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488913/201810/1488913-20181023153237361-1304987750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2 打开手机连接上WIFi链接  (测试手机本人为华为  )&lt;/p&gt;
&lt;p&gt;设置 无线和网络  WLAN中 按住显示出 修改网络   点击高级选项  输入刚才得到的ip  端口为8888&lt;/p&gt;
&lt;p&gt;链接完成时 就可以从fiddler 中查看微信端的链接了 ，此时可以获取cookies 和 相对应的数据&lt;/p&gt;
&lt;p&gt;可以进行抓包了&lt;/p&gt;
&lt;p&gt;3、修改谷歌浏览器模拟成 微信浏览器(因为本人操作没有成功。所需要刷的API并不需要微信认证 ，所以此步骤可以进行查看别的文章)&lt;/p&gt;
&lt;p&gt;4 通过抓包得到接口，然后查看需要的cookies和需要传入的数据，通过postman 进行修改 访问 成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488913/201810/1488913-20181023153937767-697293253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 如果有什么问题或者别的操作不当，可以浏览大家一起交流，它本身限制的是一天只能刷3次票。现在可以无限制刷了。当然了。图就不贴出来了，怕大家给人家刷爆了。&lt;/p&gt;

</description>
<pubDate>Tue, 23 Oct 2018 07:42:00 +0000</pubDate>
<dc:creator>阿里奇奇</dc:creator>
<og:description>1 工具： 手机 电脑 WIFI fiddler postman 谷歌浏览器 插件 User Agent Switcher EditThisCookie 1 首先 下载工具 fiddler 安装 2当</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/devilgod/p/9837021.html</dc:identifier>
</item>
<item>
<title>mysql查询表中最小可用id值 - dn96</title>
<link>http://www.cnblogs.com/dn96/p/9836952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dn96/p/9836952.html</guid>
<description>&lt;p&gt;今天在看实验室的项目时，碰到了一个让我“棘手”的问题，其实也是自己太笨了。先把&lt;code&gt;sql&lt;/code&gt;语句扔出来&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;// 这条语句在id没有1时，不能得到正确的查询结果。
select min(id+1) from oslist c where not exists (select id from oslist where id = c.id+1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;刚开始看到这条查询语句，完全是一脸懵X的状态，可能也是好久没碰&lt;code&gt;sql&lt;/code&gt;了。&lt;/p&gt;
&lt;h3 id=&quot;exists语法&quot;&gt;1 exists语法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sql&lt;/code&gt;语法中，&lt;code&gt;exists&lt;/code&gt;用来筛选结果。实际执行过程中，&lt;code&gt;exists&lt;/code&gt;语句是对外表作loop循环，每次loop循环再对内表进行查询操作。把外表的记录逐条代入到子查询，如果子查询结果集为空，说明不存在，反之，则存在。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;此处要注意的是，这里把外表的记录代入到子查询中，只是看得到的查询结果是否为&lt;code&gt;空&lt;/code&gt;，而不是做实质性的值比较。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;举个例子吧：&lt;/strong&gt;&lt;br/&gt;如果表oslist中的id为1，2，3，4，5，6，7，8，9，10，11，14，15。此处采用文章最开始的sql语句，使用&lt;strong&gt;自连接&lt;/strong&gt;。&lt;br/&gt;那么在查询过程如下：&lt;br/&gt;取id为1，看oslist中存在id = 2的否？，存在，则不纳入结果集；&lt;br/&gt;取id为2，看oslist中存在id = 3的否？，存在，则不纳入结果集；&lt;br/&gt;取id为3，看oslist中存在id = 4的否？，存在，则不纳入结果集；&lt;br/&gt;取id为4，看oslist中存在id = 5的否？，存在，则不纳入结果集；&lt;br/&gt;取id为5，看oslist中存在id = 6的否？，存在，则不纳入结果集；&lt;br/&gt;取id为6，看oslist中存在id = 7的否？，存在，则不纳入结果集；&lt;br/&gt;取id为7，看oslist中存在id = 8的否？，存在，则不纳入结果集；&lt;br/&gt;取id为8，看oslist中存在id = 9的否？，存在，则不纳入结果集；&lt;br/&gt;取id为9，看oslist中存在id = 10的否？，存在，则不纳入结果集；&lt;br/&gt;取id为10，看oslist中存在id = 11的否？，存在，则不纳入结果集；&lt;br/&gt;取id为11，看oslist中存在id = 12的否？，&lt;strong&gt;不存在&lt;/strong&gt;，则&lt;strong&gt;纳入&lt;/strong&gt;结果集；&lt;br/&gt;取id为14，看oslist中存在id = 15的否？，存在，则不纳入结果集；&lt;br/&gt;取id为15，看oslist中存在id = 16的否？，&lt;strong&gt;不存在&lt;/strong&gt;，则&lt;strong&gt;纳入&lt;/strong&gt;结果集；&lt;br/&gt;取（11+1）与（15+1）中值最小的那个，然后返回结果。&lt;br/&gt;结束查询。&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 07:38:00 +0000</pubDate>
<dc:creator>dn96</dc:creator>
<og:description>mysql使用自连接与exists语法，在查询表中最小可用id值时，出现的问题及分析。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dn96/p/9836952.html</dc:identifier>
</item>
<item>
<title>一步步教你轻松学支持向量机SVM算法之案例篇2 - 伏草惟存</title>
<link>http://www.cnblogs.com/baiboy/p/pybnc9.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baiboy/p/pybnc9.html</guid>
<description>&lt;center readability=&quot;0.64077669902913&quot;&gt;

&lt;p&gt;（&lt;a href=&quot;http://www.cnblogs.com/baiboy/&quot; target=&quot;_blank&quot;&gt;白宁超&lt;/a&gt; 2018年10月22日10:09:07）&lt;/p&gt;
&lt;/center&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：支持向量机即SVM(Support Vector Machine) ，是一种监督学习算法，属于分类的范畴。首先，支持向量机不是一种机器，而是一种机器学习算法。在数据挖掘的应用中，与无监督学习的聚类相对应和区别。广泛应用于机器学习，计算机视觉和数据挖掘当中。（本文原创，转载必须注明出处.）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;h3&gt;1 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc2.html&quot; target=&quot;_blank&quot;&gt;机器学习：一步步教你轻松学KNN模型算法&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;2 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc3.html&quot; target=&quot;_blank&quot;&gt;机器学习：一步步教你轻松学决策树算法&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;3 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc4-1.html&quot; target=&quot;_blank&quot;&gt;机器学习：一步步教你轻松学朴素贝叶斯模型算法理论篇1&lt;/a&gt; &lt;/h3&gt;
&lt;h3&gt;4 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc4-2.html&quot; target=&quot;_blank&quot;&gt;机器学习：一步步教你轻松学朴素贝叶斯模型实现篇2 &lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;5 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc4-3.html&quot; target=&quot;_blank&quot;&gt;机器学习：一步步教你轻松学朴素贝叶斯模型算法Sklearn深度篇3&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc4-2.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;6 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc5.html&quot; target=&quot;_blank&quot;&gt;机器学习：一步步教你轻松学逻辑回归模型算法&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;7 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc6.html&quot; target=&quot;_blank&quot;&gt;机器学习：一步步教你轻松学K-means聚类算法&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;8 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc7.html&quot; target=&quot;_blank&quot;&gt;机器学习：一步步教你轻松学关联规则Apriori算法&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;9 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc8.html&quot; target=&quot;_blank&quot;&gt;机器学习： 一步步教你轻松学支持向量机SVM算法之理论篇1&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;10 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc9.html&quot; target=&quot;_blank&quot;&gt;机器学习： 一步步教你轻松学支持向量机SVM算法之案例篇2&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;11 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc10.html&quot; target=&quot;_blank&quot;&gt;机器学习： 一步步教你轻松学主成分分析PCA降维算法&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;12 &lt;a href=&quot;https://www.cnblogs.com/baiboy/p/pybnc11.html&quot; target=&quot;_blank&quot;&gt;机器学习： 一步步教你轻松学支持向量机SVM降维算法&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.cnblogs.com/baiboy/p/dh.html&quot; target=&quot;_blank&quot;&gt;更多文章请点击这里&amp;gt;&amp;gt;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上节回顾，还记得如何基于svm进行分类？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ZEK1Mps.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;-&quot;&gt;怎么寻找最大间隔&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;点到超平面的距离&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;分隔超平面&lt;code&gt;函数间距&lt;/code&gt;: \(y(x)=w^Tx+b\)&lt;/li&gt;
&lt;li&gt;分类的结果： \(f(x)=sign(w^Tx+b)\) (sign表示&amp;gt;0为1，&amp;lt;0为-1，=0为0)&lt;/li&gt;
&lt;li&gt;点到超平面的&lt;code&gt;几何间距&lt;/code&gt;: \(d(x)=(w^Tx+b)/||w||\) （||w||表示w矩阵的二范数=&amp;gt; \(\sqrt{w^T*w}\), 点到超平面的距离也是类似的）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;拉格朗日乘子法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;类别标签用-1、1，是为了后期方便 \(label*(w^Tx+b)\) 的标识和距离计算；如果 \(label*(w^Tx+b)&amp;gt;0\) 表示预测正确，否则预测错误。&lt;/li&gt;
&lt;li&gt;现在目标很明确，就是要找到&lt;code&gt;w&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;，因此我们必须要找到最小间隔的数据点，也就是前面所说的&lt;code&gt;支持向量&lt;/code&gt;。
&lt;ul&gt;&lt;li&gt;让最小的距离取最大.(最小的距离：就是最小间隔的数据点；最大：就是最大间距，为了找出最优超平面--最终就是支持向量)&lt;/li&gt;
&lt;li&gt;目标函数：\(arg: max_{w, b} \left( min[label*(w^Tx+b)]*\frac{1}{||w||} \right) \)
&lt;ol&gt;&lt;li&gt;如果 \(label*(w^Tx+b)&amp;gt;0\) 表示预测正确，也称&lt;code&gt;函数间隔&lt;/code&gt;，\(||w||\) 可以理解为归一化，也称&lt;code&gt;几何间隔&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;令 \(label*(w^Tx+b)&amp;gt;=1\)， 因为0～1之间，得到的点是存在误判的可能性，所以要保障 \(min[label*(w^Tx+b)]=1\)，才能更好降低噪音数据影响。&lt;/li&gt;
&lt;li&gt;所以本质上是求 \(arg: max_{关于w, b} \frac{1}{||w||} \)；也就说，我们约束(前提)条件是: \(label*(w^Tx+b)=1\)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;新的目标函数求解： \(arg: max_{关于w, b} \frac{1}{||w||} \)
&lt;ul&gt;&lt;li&gt;=&amp;gt; 就是求: \(arg: min_{关于w, b} ||w|| \) (求矩阵会比较麻烦，如果x只是 \(\frac{1}{2}*x^2\) 的偏导数，那么。。同样是求最小值)&lt;/li&gt;
&lt;li&gt;=&amp;gt; 就是求: \(arg: min_{关于w, b} (\frac{1}{2}*||w||^2)\) (二次函数求导，求极值，平方也方便计算)&lt;/li&gt;
&lt;li&gt;本质上就是求线性不等式的二次优化问题(求分隔超平面，等价于求解相应的凸二次规划问题)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;通过拉格朗日乘子法，求二次优化问题
&lt;ul&gt;&lt;li&gt;假设需要求极值的目标函数 (objective function) 为 f(x,y)，限制条件为 φ(x,y)=M # M=1&lt;/li&gt;
&lt;li&gt;设g(x,y)=M-φ(x,y) # 临时φ(x,y)表示下文中 \(label*(w^Tx+b)\)&lt;/li&gt;
&lt;li&gt;定义一个新函数: F(x,y,λ)=f(x,y)+λg(x,y)&lt;/li&gt;
&lt;li&gt;a为λ（a&amp;gt;=0），代表要引入的拉格朗日乘子(Lagrange multiplier)&lt;/li&gt;
&lt;li&gt;那么： \(L(w,b,\alpha)=\frac{1}{2} * ||w||^2 + \sum_{i=1}^{n} \alpha_i * [1 - label * (w^Tx+b)]\)&lt;/li&gt;
&lt;li&gt;因为：\(label*(w^Tx+b)&amp;gt;=1, \alpha&amp;gt;=0\) , 所以 \(\alpha*[1-label*(w^Tx+b)]&amp;lt;=0\) , \(\sum_{i=1}^{n} \alpha_i * [1-label*(w^Tx+b)]&amp;lt;=0\)&lt;/li&gt;
&lt;li&gt;当 \(label*(w^Tx+b)&amp;gt;1\) 则 \(\alpha=0\) ，表示该点为&lt;span&gt;非支持向量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;相当于求解： \(max_{关于\alpha} L(w,b,\alpha) = \frac{1}{2} *||w||^2\)&lt;/li&gt;
&lt;li&gt;如果求： \( min_{关于w, b}\frac{1}{2} *||w||^2 \) , 也就是要求： \(min_{关于w, b} \left( max_{关于\alpha} L(w,b,\alpha)\right)\)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;现在转化到对偶问题的求解
&lt;ul&gt;&lt;li&gt;\(min_{关于w, b} \left(max_{关于\alpha} L(w,b,\alpha) \right) \) &amp;gt;= \(max_{关于\alpha} \left(min_{关于w, b}\ L(w,b,\alpha) \right) \)&lt;/li&gt;
&lt;li&gt;现在分2步&lt;/li&gt;
&lt;li&gt;先求： \(min_{关于w, b} L(w,b,\alpha)=\frac{1}{2} * ||w||^2 + \sum_{i=1}^n \alpha_i * [1 - label * (w^Tx+b)]\)&lt;/li&gt;
&lt;li&gt;就是求&lt;code&gt;L(w,b,a)&lt;/code&gt;关于[w, b]的偏导数, 得到&lt;code&gt;w和b的值&lt;/code&gt;，并化简为：&lt;code&gt;L和a的方程&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;参考： 如果公式推导还是不懂，也可以参考《统计学习方法》李航-P103&amp;lt;学习的对偶算法&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;终于得到课本上的公式： \(max_{\alpha} [ \sum_{i=1}^m \alpha_i - \frac{1}{2}\sum^m ·\alpha_i·\alpha_j·\langle x^{(i)}, x^{(j)} \rangle ]\)&lt;/li&gt;
&lt;li&gt;约束条件： \(a&amp;gt;=0\) 并且 \(\sum_{i=1}^{m} a_i·label_i=0\)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;拉格朗日乘子法理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要求\( f(x,y)\),在\( g(x,y)=c\)时的最大值时，我们可以引入新变量拉格朗日乘数\(\lambda\) ，这时我们只需要下列拉格朗日函数的极值,为了帮助大家更好的理解，请参照下图（绿线标出的是约束g(x,y) = c的点的轨迹。蓝线是f的等高线。箭头表示斜率，和等高线的法线平行。）：&lt;/p&gt;
&lt;p&gt;$$ {\mathcal {L}}(x,y,\lambda )=f(x,y)+\lambda \cdot {\Big (}g(x,y)-c{\Big )} $$&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/fzHbLV0.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;拉格朗日乘子证明过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设函数\( f(x,y)\)在 \( A\)点处有极值\( \kappa\)，且在\( A\)点的邻域内连续。则在\( A\)点处有\( f\left(x,y\right)=\kappa \)&lt;br/&gt;另有一常值函数:\( g\left(x,y\right)=c\)&lt;br/&gt;二函数在 \(A\)点处的全微分为&lt;br/&gt;$$&lt;br/&gt;\mathrm {d} f={\frac {\partial {f}}{\partial {x}}}\mathrm {d} x+{\frac {\partial {f}}{\partial {y}}}\mathrm {d} y=0&lt;br/&gt;$$&lt;br/&gt;$$&lt;br/&gt;\mathrm {d} g={\frac {\partial {g}}{\partial {x}}}\mathrm {d} x+{\frac {\partial {g}}{\partial {y}}}\mathrm {d} y=0&lt;br/&gt;$$&lt;/p&gt;
&lt;p&gt;由于\( \mathrm {d} x\)和\(\mathrm{d}y\)是任取的无穷小量，故该线性方程组的系数成比例，有&lt;/p&gt;
&lt;p&gt;$$&lt;br/&gt;{\dfrac {\dfrac {\partial {f}}{\partial {x}}}{\dfrac {\partial {g}}{\partial {x}}}}={\dfrac {\dfrac {\partial {f}}{\partial {y}}}{\dfrac {\partial {g}}{\partial {y}}}}=-\lambda&lt;br/&gt;$$&lt;br/&gt;即&lt;br/&gt;$$&lt;br/&gt;{\frac {\partial {f}}{\partial {y}}}+\lambda \cdot {\frac {\partial {g}}{\partial {y}}}=0&lt;br/&gt;{\frac {\partial {f}}{\partial {y}}}+\lambda \cdot {\frac {\partial {g}}{\partial {y}}}=0&lt;br/&gt;$$&lt;br/&gt;将上二式分别乘以\( \mathrm{d}x \)和\(\mathrm{d}y\)，再相加并积分，得到一新函数&lt;/p&gt;
&lt;p&gt;$$ {\mathcal {L}}(x,y,\lambda )=f(x,y)+\lambda \cdot g(x,y)$$&lt;br/&gt;那么，求原函数极值的问题就转化为求该函数极值的问题。类似地，这种求极值的方法也可以推广到多维函数 \(f\left(x_1,\ldots ,x_n\right)\)。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;拉格朗日乘子简单例子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;求此方程的最小值：\( f(x, y) = x^2 y\),同时未知数满足\(x^2 + y^2 = 1\)&lt;br/&gt;因为只有一个未知数的限制条件，我们只需要用一个乘数\(\lambda \).&lt;br/&gt;$$ g (x, y) = x^2 +y^2 -1 $$&lt;br/&gt;$$\Phi (x, y, \lambda) = f(x,y) + \lambda g(x, y) = x^2 y + \lambda (x^2 + y^2 - 1)$$&lt;/p&gt;
&lt;p&gt;将所有 \(\Phi\) 方程的偏微分设为零，得到一个方程组，最小值是以下方程组的解中的一个：&lt;/p&gt;
&lt;p&gt;$$2 x y + 2 \lambda x = 0$$&lt;br/&gt;$$ x^2 + 2 \lambda y = 0$$&lt;br/&gt;$$ x^2 + y^2 -1 = 0$$&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;松弛变量(slack variable)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/DKbNQKs.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道几乎所有的数据都不那么干净, 通过引入松弛变量来 &lt;code&gt;允许数据点可以处于分隔面错误的一侧&lt;/code&gt;。&lt;br/&gt;约束条件： \(C&amp;gt;=a&amp;gt;=0\) 并且 \(\sum_{i=1}^{m} a_i·label_i=0\)&lt;br/&gt;总的来说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常量C是 &lt;code&gt;惩罚因子&lt;/code&gt;, 表示离群点的权重（用于控制“最大化间隔”和“保证大部分点的函数间隔小于1.0” ）
&lt;ul&gt;&lt;li&gt;\(label*(w^Tx+b) &amp;gt; 1\) and alpha = 0 (在边界外，就是非支持向量)&lt;/li&gt;
&lt;li&gt;\(label*(w^Tx+b) = 1\) and 0&amp;lt; alpha &amp;lt; C (在分割超平面上，就支持向量)&lt;/li&gt;
&lt;li&gt;\(label*(w^Tx+b) &amp;lt; 1\) and alpha = C (在分割超平面内，是误差点 -&amp;gt; C表示它该受到的惩罚因子程度)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;C值越大，表示离群点影响越大，就越容易过度拟合；反之有可能欠拟合。&lt;/li&gt;
&lt;li&gt;我们看到，目标函数控制了离群点的数目和程度，使大部分样本点仍然遵守限制条件。&lt;/li&gt;
&lt;li&gt;例如：正类有10000个样本，而负类只给了100个（C越大表示100个负样本的影响越大，就会出现过度拟合，所以C决定了负样本对模型拟合程度的影响！，C就是一个非常关键的优化点！）&lt;/li&gt;
&lt;li&gt;这一结论十分直接，SVM中的主要工作就是要求解 alpha.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;smo-&quot;&gt;SMO 高效优化算法&lt;/h2&gt;
&lt;p&gt;SVM有很多种实现，最流行的一种实现是： &lt;code&gt;序列最小优化(Sequential Minimal Optimization, SMO)算法&lt;/code&gt;。下面还会介绍一种称为 &lt;code&gt;核函数(kernel)&lt;/code&gt; 的方式将SVM扩展到更多数据集上。 注意：&lt;code&gt;SVM几何含义比较直观，但其算法实现较复杂，牵扯大量数学公式的推导。&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;序列最小优化(Sequential Minimal Optimization, SMO)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;John Platt于1996年创建&lt;/li&gt;
&lt;li&gt;SMO用途：用于训练 SVM&lt;/li&gt;
&lt;li&gt;SMO目标：求出一系列 alpha 和 b,一旦求出 alpha，就很容易计算出权重向量 w 并得到分隔超平面。&lt;/li&gt;
&lt;li&gt;SMO思想：是将大优化问题分解为多个小优化问题来求解的。&lt;/li&gt;
&lt;li&gt;SMO原理：每次循环选择两个 alpha 进行优化处理，一旦找出一对合适的 alpha，那么就增大一个同时减少一个。
&lt;ul&gt;&lt;li&gt;这里指的合适必须要符合一定的条件
&lt;ol&gt;&lt;li&gt;这两个 alpha 必须要在间隔边界之外&lt;/li&gt;
&lt;li&gt;这两个 alpha 还没有进行过区间化处理或者不在边界上。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;之所以要同时改变2个 alpha；原因是我们有一个约束条件： \(\sum_{i=1}^{m} a_i·label_i=0\)；如果只是修改一个 alpha，很可能导致约束条件失效。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SMO 伪代码大致如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;创建一个 alpha 向量并将其初始化为0向量
当迭代次数小于最大迭代次数时(外循环)
    对数据集中的每个数据向量(内循环)：
        如果该数据向量可以被优化
            随机选择另外一个数据向量
            同时优化这两个向量
            如果两个向量都不能被优化，退出内循环
    如果所有向量都没被优化，增加迭代数目，继续下一次循环
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;svm-&quot;&gt;SVM 开发流程&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;收集数据：可以使用任意方法。
准备数据：需要数值型数据。
分析数据：有助于可视化分隔超平面。
训练算法：SVM的大部分时间都源自训练，该过程主要实现两个参数的调优。
测试算法：十分简单的计算过程就可以实现。
使用算法：几乎所有分类问题都可以使用SVM，值得一提的是，SVM本身是一个二类分类器，对多类问题应用SVM需要对代码做一些修改。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;svm-&quot;&gt;SVM 算法特点&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;优点：泛化（由具体的、个别的扩大为一般的，就是说：模型训练完后的新样本）错误率低，计算开销不大，结果易理解。
缺点：对参数调节和核函数的选择敏感，原始分类器不加修改仅适合于处理二分类问题。
使用数据类型：数值型和标称型数据。
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;这里是对小规模数据点进行分类&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;收集数据&lt;/h2&gt;
&lt;p&gt;文本文件格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;3.542485    1.977398    -1
3.018896    2.556416    -1
7.551510    -1.580030    1
2.114999    -0.004466    -1
8.127113    1.274372    1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;准备数据&lt;/h2&gt;
&lt;p&gt;'''对文件进行逐行解析，从而得到第行的类标签和整个数据矩阵'''&lt;br/&gt;def loadDataSet(fileName):&lt;br/&gt;dataMat = [];labelMat = []&lt;br/&gt;fr = open(fileName)&lt;br/&gt;for line in fr.readlines():&lt;br/&gt;lineArr = line.strip().split('\t')&lt;br/&gt;dataMat.append([float(lineArr[0]), float(lineArr[1])])&lt;br/&gt;labelMat.append(float(lineArr[2]))&lt;br/&gt;return dataMat, labelMat&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;训练算法&lt;/h2&gt;
&lt;p&gt;简化版SMO（序列最小优化）算法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;'''
简化版SMO（序列最小优化）算法
输入参数：
C   松弛变量(常量值)，允许有些数据点可以处于分隔面的错误一侧。控制最大化间隔和
    保证大部分的函数间隔小于1.0这两个目标权重。通过调节该参数达到不同的结果。
toler   容错率（在某个体系中能减小一些因素或选择对某个系统产生不稳定的概率。）
maxIter 退出前最大的循环次数
返回参数：
b       模型的常量值
alphas  拉格朗日乘子
'''
def smoSimple(dataMatIn, classLabels, C, toler, maxIter):
    dataMatrix = mat(dataMatIn)
    labelMat = mat(classLabels).transpose()
    m, n = shape(dataMatrix)
    # 初始化 b和alphas(alpha有点类似权重值。)
    b = 0;alphas = mat(zeros((m, 1)))
    # 没有任何alpha改变的情况下遍历数据的次数
    iter = 0
    while (iter &amp;lt; maxIter):
        # w = calcWs(alphas, dataMatIn, classLabels)
        # print(&quot;w:&quot;, w)

        # 记录alpha是否已经进行优化，每次循环时设为0，然后再对整个集合顺序遍历
        alphaPairsChanged = 0
        for i in range(m):
            # 我们预测的类别 y = w^Tx[i]+b; 其中因为 w = Σ(1~n) a[n]*lable[n]*x[n]
            fXi = float(multiply(alphas, labelMat).T*(dataMatrix*dataMatrix[i, :].T)) + b
            # 预测结果与真实结果比对，计算误差Ei
            Ei = fXi - float(labelMat[i])

            # 约束条件 (KKT条件是解决最优化问题的时用到的一种方法。我们这里提到的最优化问题通常是指对于给定的某一函数，求其在指定作用域上的全局最小值)
            # 0&amp;lt;=alphas[i]&amp;lt;=C，但由于0和C是边界值，我们无法进行优化，因为需要增加一个alphas和降低一个alphas。
            # 表示发生错误的概率：labelMat[i]*Ei 如果超出了 toler， 才需要优化。至于正负号，我们考虑绝对值就对了。
            '''
            # 检验训练样本(xi, yi)是否满足KKT条件
            yi*f(i) &amp;gt;= 1 and alpha = 0 (outside the boundary)
            yi*f(i) == 1 and 0&amp;lt;alpha&amp;lt; C (on the boundary)
            yi*f(i) &amp;lt;= 1 and alpha = C (between the boundary)
            '''
            if ((labelMat[i]*Ei &amp;lt; -toler) and (alphas[i] &amp;lt; C)) or ((labelMat[i]*Ei &amp;gt; toler) and (alphas[i] &amp;gt; 0)):
                # 如果满足优化的条件，我们就随机选取非i的一个点，进行优化比较
                j = selectJrand(i, m)
                # 预测j的结果
                fXj = float(multiply(alphas, labelMat).T*(dataMatrix*dataMatrix[j, :].T)) + b
                Ej = fXj - float(labelMat[j])
                alphaIold = alphas[i].copy()
                alphaJold = alphas[j].copy()

                # L和H用于将alphas[j]调整到0-C之间。如果L==H，就不做任何改变，直接执行continue语句
                # labelMat[i] != labelMat[j] 表示异侧，就相减，否则是同侧，就相加。
                if (labelMat[i] != labelMat[j]):
                    L = max(0, alphas[j] - alphas[i])
                    H = min(C, C + alphas[j] - alphas[i])
                else:
                    L = max(0, alphas[j] + alphas[i] - C)
                    H = min(C, alphas[j] + alphas[i])
                # 如果相同，就没发优化了
                if L == H:
                    # print(&quot;L==H&quot;)
                    continue

                # eta是alphas[j]的最优修改量，如果eta==0，需要退出for循环的当前迭代过程
                # 参考《统计学习方法》李航-P125~P128&amp;lt;序列最小最优化算法&amp;gt;
                eta = 2.0 * dataMatrix[i, :]*dataMatrix[j, :].T - dataMatrix[i, :]*dataMatrix[i, :].T - dataMatrix[j, :]*dataMatrix[j, :].T
                if eta &amp;gt;= 0:
                    # print(&quot;eta&amp;gt;=0&quot;)
                    continue

                # 计算出一个新的alphas[j]值
                alphas[j] -= labelMat[j]*(Ei - Ej)/eta
                # 并使用辅助函数，以及L和H对其进行调整
                alphas[j] = clipAlpha(alphas[j], H, L)
                # 检查alpha[j]是否只是轻微的改变，如果是的话，就退出for循环。
                if (abs(alphas[j] - alphaJold) &amp;lt; 0.00001):
                    # print(&quot;j not moving enough&quot;)
                    continue
                # 然后alphas[i]和alphas[j]同样进行改变，虽然改变的大小一样，但是改变的方向正好相反
                alphas[i] += labelMat[j]*labelMat[i]*(alphaJold - alphas[j])
                # 在对alpha[i], alpha[j] 进行优化之后，给这两个alpha值设置一个常数b。
                # w= Σ[1~n] ai*yi*xi =&amp;gt; b = yj- Σ[1~n] ai*yi(xi*xj)
                # 所以：  b1 - b = (y1-y) - Σ[1~n] yi*(a1-a)*(xi*x1)
                # 为什么减2遍？ 因为是 减去Σ[1~n]，正好2个变量i和j，所以减2遍
                b1 = b - Ei- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i, :]*dataMatrix[i, :].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[i, :]*dataMatrix[j, :].T
                b2 = b - Ej- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i, :]*dataMatrix[j, :].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[j, :]*dataMatrix[j, :].T
                if (0 &amp;lt; alphas[i]) and (C &amp;gt; alphas[i]):
                    b = b1
                elif (0 &amp;lt; alphas[j]) and (C &amp;gt; alphas[j]):
                    b = b2
                else:
                    b = (b1 + b2)/2.0
                alphaPairsChanged += 1
                # print(&quot;iter: %d i:%d, pairs changed %d&quot; % (iter, i, alphaPairsChanged))
        # 在for循环外，检查alpha值是否做了更新，如果在更新则将iter设为0后继续运行程序
        # 知道更新完毕后，iter次循环无变化，才推出循环。
        if (alphaPairsChanged == 0):
            iter += 1
        else:
            iter = 0
        # print(&quot;iteration number: %d&quot; % iter)
    return b, alphas
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SVM简化版，应用简化版SMO算法处理小规模数据集；SVM完整版，使用完整 Platt SMO算法加速优化，优化点：选择alpha的方式不同。具体代码实现下面提供&lt;span&gt;&lt;strong&gt;完整代码下载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-kernel-&quot;&gt;核函数(kernel) 使用&lt;/h2&gt;
&lt;p&gt;对于线性可分的情况，效果明显,对于非线性的情况也一样，此时需要用到一种叫&lt;code&gt;核函数(kernel)&lt;/code&gt;的工具将数据转化为分类器易于理解的形式。利用核函数将数据映射到高维空间,使用核函数可以将数据从某个特征空间到另一个特征空间的映射。（通常情况下：这种映射会将低维特征空间映射到高维空间。） 如果觉得特征空间很难理解,可以把核函数想象成一个包装器(wrapper)或者是接口(interface)，它能将数据从某个很难处理的形式转换成为另一个较容易处理的形式。经过空间转换后：低维需要解决的非线性问题，就变成了高维需要解决的线性问题。SVM 优化特别好的地方，在于所有的运算都可以写成内积(inner product: 是指2个向量相乘，得到单个标量 或者 数值)；内积替换成核函数的方式被称为&lt;code&gt;核技巧(kernel trick)&lt;/code&gt;或者&lt;code&gt;核&quot;变电&quot;(kernel substation)&lt;/code&gt;. 核函数并不仅仅应用于支持向量机，很多其他的机器学习算法也都用到核函数。最流行的核函数：径向基函数(radial basis function).&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;你的老板要求：你写的那个手写识别程序非常好，但是它占用内存太大。顾客无法通过无线的方式下载我们的应用。所以：我们可以考虑使用支持向量机，保留支持向量就行（knn需要保留所有的向量），就可以获得非常好的效果。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;收集数据：提供的文本文件&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;00000000000000001111000000000000
00000000000000011111111000000000
00000000000000011111111100000000
00000000000000011111111110000000
00000000000000011111111110000000
00000000000000111111111100000000
00000000000000111111111100000000
00000000000001111111111100000000
00000000000000111111111100000000
00000000000000111111111100000000
00000000000000111111111000000000
00000000000001111111111000000000
00000000000011111111111000000000
00000000000111111111110000000000
00000000001111111111111000000000
00000001111111111111111000000000
00000011111111111111110000000000
00000111111111111111110000000000
00000111111111111111110000000000
00000001111111111111110000000000
00000001111111011111110000000000
00000000111100011111110000000000
00000000000000011111110000000000
00000000000000011111100000000000
00000000000000111111110000000000
00000000000000011111110000000000
00000000000000011111110000000000
00000000000000011111111000000000
00000000000000011111111000000000
00000000000000011111111000000000
00000000000000000111111110000000
00000000000000000111111100000000
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;准备数据：基于二值图像构造向量&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;将 32*32的文本转化为 1*1024的矩阵&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;def img2vector(filename):
    returnVect = zeros((1, 1024))
    fr = open(filename)
    for i in range(32):
        lineStr = fr.readline()
        for j in range(32):
            returnVect[0, 32 * i + j] = int(lineStr[j])
    return returnVect

def loadImages(dirName):
    from os import listdir
    hwLabels = []
    print(dirName)
    trainingFileList = listdir(dirName)  # load the training set
    m = len(trainingFileList)
    trainingMat = zeros((m, 1024))
    for i in range(m):
        fileNameStr = trainingFileList[i]
        fileStr = fileNameStr.split('.')[0]  # take off .txt
        classNumStr = int(fileStr.split('_')[0])
        if classNumStr == 9:
            hwLabels.append(-1)
        else:
            hwLabels.append(1)
        trainingMat[i, :] = img2vector('%s/%s' % (dirName, fileNameStr))
    return trainingMat, hwLabels
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;分析数据：对图像向量进行目测&lt;/h2&gt;
&lt;h2 id=&quot;-&quot;&gt;训练算法&lt;/h2&gt;
&lt;p&gt;采用两种不同的核函数，并对径向基核函数采用不同的设置来运行SMO算法.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;'''核转换函数
X     dataMatIn数据集
A     dataMatIn数据集的第i行的数据
kTup  核函数的信息
'''
def kernelTrans(X, A, kTup):
    m, n = shape(X)
    K = mat(zeros((m, 1)))
    if kTup[0] == 'lin':
        # linear kernel:   m*n * n*1 = m*1
        K = X * A.T
    elif kTup[0] == 'rbf':
        for j in range(m):
            deltaRow = X[j, :] - A
            K[j] = deltaRow * deltaRow.T
        # 径向基函数的高斯版本
        K = exp(K / (-1 * kTup[1] ** 2))  # divide in NumPy is element-wise not matrix like Matlab
    else:
        raise NameError('Houston We Have a Problem -- That Kernel is not recognized')
    return K


&quot;&quot;&quot;
完整SMO算法外循环，与smoSimple有些类似，但这里的循环退出条件更多一些
Args:
    dataMatIn    数据集
    classLabels  类别标签
    C   松弛变量(常量值)，允许有些数据点可以处于分隔面的错误一侧。
        控制最大化间隔和保证大部分的函数间隔小于1.0这两个目标的权重。
        可以通过调节该参数达到不同的结果。
    toler   容错率
    maxIter 退出前最大的循环次数
    kTup    包含核函数信息的元组
Returns:
    b       模型的常量值
    alphas  拉格朗日乘子
&quot;&quot;&quot;
def smoP(dataMatIn, classLabels, C, toler, maxIter, kTup=('lin', 0)):
    # 创建一个 optStruct 对象
    oS = optStruct(mat(dataMatIn), mat(classLabels).transpose(), C, toler, kTup)
    iter = 0
    entireSet = True
    alphaPairsChanged = 0

    # 循环遍历：循环maxIter次 并且 （alphaPairsChanged存在可以改变 or 所有行遍历一遍）
    while (iter &amp;lt; maxIter) and ((alphaPairsChanged &amp;gt; 0) or (entireSet)):
        alphaPairsChanged = 0
        #  当entireSet=true or 非边界alpha对没有了；就开始寻找 alpha对，然后决定是否要进行else。
        if entireSet:
            # 在数据集上遍历所有可能的alpha
            for i in range(oS.m):
                # 是否存在alpha对，存在就+1
                alphaPairsChanged += innerL(i, oS)
                # print(&quot;fullSet, iter: %d i:%d, pairs changed %d&quot; % (iter, i, alphaPairsChanged))
            iter += 1

        # 对已存在 alpha对，选出非边界的alpha值，进行优化。
        else:
            # 遍历所有的非边界alpha值，也就是不在边界0或C上的值。
            nonBoundIs = nonzero((oS.alphas.A &amp;gt; 0) * (oS.alphas.A &amp;lt; C))[0]
            for i in nonBoundIs:
                alphaPairsChanged += innerL(i, oS)
                # print(&quot;non-bound, iter: %d i:%d, pairs changed %d&quot; % (iter, i, alphaPairsChanged))
            iter += 1
        # 如果找到alpha对，就优化非边界alpha值，否则，就重新进行寻找，如果寻找一遍 遍历所有的行还是没找到，就退出循环。
        if entireSet:
            entireSet = False  # toggle entire set loop
        elif alphaPairsChanged == 0:
            entireSet = True
        print(&quot;iteration number: %d&quot; % iter)
    return oS.b, oS.alphas
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;测试算法：便携一个函数来测试不同的和函数并计算错误率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;def testDigits(kTup=('rbf', 10)):

    # 1. 导入训练数据
    dataArr, labelArr = loadImages('input/6.SVM/trainingDigits')
    b, alphas = smoP(dataArr, labelArr, 200, 0.0001, 10000, kTup)
    datMat = mat(dataArr)
    labelMat = mat(labelArr).transpose()
    svInd = nonzero(alphas.A &amp;gt; 0)[0]
    sVs = datMat[svInd]
    labelSV = labelMat[svInd]
    # print(&quot;there are %d Support Vectors&quot; % shape(sVs)[0])
    m, n = shape(datMat)
    errorCount = 0
    for i in range(m):
        kernelEval = kernelTrans(sVs, datMat[i, :], kTup)
        # 1*m * m*1 = 1*1 单个预测结果
        predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b
        if sign(predict) != sign(labelArr[i]): errorCount += 1
    print(&quot;the training error rate is: %f&quot; % (float(errorCount) / m))

    # 2. 导入测试数据
    dataArr, labelArr = loadImages('input/6.SVM/testDigits')
    errorCount = 0
    datMat = mat(dataArr)
    labelMat = mat(labelArr).transpose()
    m, n = shape(datMat)
    for i in range(m):
        kernelEval = kernelTrans(sVs, datMat[i, :], kTup)
        # 1*m * m*1 = 1*1 单个预测结果
        predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b
        if sign(predict) != sign(labelArr[i]): errorCount += 1
    print(&quot;the test error rate is: %f&quot; % (float(errorCount) / m))
&lt;/code&gt;
&lt;/pre&gt;

&lt;ol&gt;&lt;li&gt;scikit中文社区：&lt;a href=&quot;http://sklearn.apachecn.org/cn/0.19.0/&quot;&gt;http://sklearn.apachecn.org/cn/0.19.0/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.apachecn.org/&quot;&gt;ApacheCN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub：&lt;a href=&quot;https://github.com/BaiNingchao/MachineLearning-1&quot;&gt;https://github.com/BaiNingchao/MachineLearning-1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;图书：《机器学习实战》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E6%88%98&quot;&gt;图书：《自然语言处理理论与实战》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;源码请进【机器学习和自然语言QQ群：436303759】文件下载：&lt;a href=&quot;http://shang.qq.com/wpa/qunwpa?idkey=ef3bbb679b06ac59b136c57ba9e7935ff9d3b10faeabde6e4efcafe523bbbf4d&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;自然语言处理和机器学习技术交流&quot; src=&quot;http://pub.idqqimg.com/wpa/images/group.png&quot; alt=&quot;自然语言处理和机器学习技术QQ交流&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/S5lgCKY.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文版权归作者所有，旨在技术交流使用。未经作者同意禁止转载，转载后需在文章页面明显位置给出原文连接，否则相关责任自行承担。&lt;/p&gt;
&lt;/blockquote&gt;









</description>
<pubDate>Tue, 23 Oct 2018 07:37:00 +0000</pubDate>
<dc:creator>伏草惟存</dc:creator>
<og:description>支持向量机即SVM(Support Vector Machine) ，是一种监督学习算法，属于分类的范畴。首先，支持向量机不是一种机器，而是一种机器学习算法。在数据挖掘的应用中，与无监督学习的聚类相对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baiboy/p/pybnc9.html</dc:identifier>
</item>
<item>
<title>17、SpringBoot------整合dubbo - 零度微笑</title>
<link>http://www.cnblogs.com/TimerHotel/p/springboot17.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TimerHotel/p/springboot17.html</guid>
<description>&lt;h2 id=&quot;安装运行zookeeper&quot;&gt;1.安装运行zookeeper&lt;/h2&gt;
&lt;h3 id=&quot;下载zookeeper&quot;&gt;（1）下载zookeeper&lt;/h3&gt;
&lt;p&gt;官网：http://zookeeper.apache.org/&lt;/p&gt;
&lt;h3 id=&quot;解压缩&quot;&gt;（2）解压缩&lt;/h3&gt;
&lt;h3 id=&quot;修改配置文件&quot;&gt;（3）修改配置文件&lt;/h3&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;拷贝zoo_sample.cfg重命名为zoo.cfg&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;修改配置文档&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# The number of milliseconds of each tick
tickTime=2000
# The number of ticks that the initial 
# synchronization phase can take
initLimit=10
# The number of ticks that can pass between 
# sending a request and getting an acknowledgement
syncLimit=5
# the directory where the snapshot is stored.
# do not use /tmp for storage, /tmp here is just 
# example sakes.
dataDir=../data
# the port at which the clients will connect
clientPort=2181
# the maximum number of client connections.
# increase this if you need to handle more clients
#maxClientCnxns=60
#
# Be sure to read the maintenance section of the 
# administrator guide before turning on autopurge.
#
# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance
#
# The number of snapshots to retain in dataDir
#autopurge.snapRetainCount=3
# Purge task interval in hours
# Set to &quot;0&quot; to disable auto purge feature
#autopurge.purgeInterval=1
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建data文件夹&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;cmd启动zkserver.sh&quot;&gt;（4）cmd启动zkServer.sh&lt;/h3&gt;
&lt;h2 id=&quot;安装dubbo-web管理客户端&quot;&gt;2.安装dubbo web管理客户端&lt;/h2&gt;
&lt;h3 id=&quot;下载duboo-ops&quot;&gt;（1）下载Duboo OPS&lt;/h3&gt;
&lt;p&gt;下载地址：https://github.com/apache/incubator-dubbo-ops/tree/master&lt;/p&gt;
&lt;h3 id=&quot;修改配置&quot;&gt;（2）修改配置&lt;/h3&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the &quot;License&quot;); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

server.port=7001
spring.velocity.cache=false
spring.velocity.charset=UTF-8
spring.velocity.layout-url=/templates/default.vm
spring.messages.fallback-to-system-locale=false
spring.messages.basename=i18n/message
spring.root.password=root
spring.guest.password=guest

dubbo.registry.address=zookeeper://127.0.0.1:2181
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;maven打包dubbo-admin&quot;&gt;（3）maven打包dubbo-admin&lt;/h3&gt;
&lt;h3 id=&quot;启动生成jar&quot;&gt;（4）启动生成jar&lt;/h3&gt;
&lt;h3 id=&quot;访问httplocalhost7001&quot;&gt;（5）访问http://localhost:7001/&lt;/h3&gt;
&lt;h2 id=&quot;安装dubbo监控服务中心&quot;&gt;3.安装dubbo监控服务中心&lt;/h2&gt;
&lt;h3 id=&quot;maven打包dubbo-monitor-simple&quot;&gt;（1）maven打包dubbo-monitor-simple&lt;/h3&gt;
&lt;h3 id=&quot;解压dubbo-monitor-simple-2.0.0-assembly.tar.gz&quot;&gt;（2）解压dubbo-monitor-simple-2.0.0-assembly.tar.gz&lt;/h3&gt;
&lt;h3 id=&quot;修改配置文件-1&quot;&gt;（3）修改配置文件&lt;/h3&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the &quot;License&quot;); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

dubbo.container=log4j,spring,registry,jetty-monitor
dubbo.application.name=simple-monitor
dubbo.application.owner=dubbo
#dubbo.registry.address=multicast://224.5.6.7:1234
dubbo.registry.address=zookeeper://127.0.0.1:2181
#dubbo.registry.address=redis://127.0.0.1:6379
#dubbo.registry.address=dubbo://127.0.0.1:9090
dubbo.protocol.port=7070
dubbo.jetty.port=8080
dubbo.jetty.directory=${user.home}/monitor
dubbo.charts.directory=${user.home}/monitor/charts
dubbo.statistics.directory=${user.home}/monitor/statistics
dubbo.log4j.file=logs/dubbo-monitor-simple.log
dubbo.log4j.level=WARN&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动start.bat&quot;&gt;（4）启动start.bat&lt;/h3&gt;
&lt;h3 id=&quot;访问httplocalhost8080&quot;&gt;（5）访问http://localhost:8080/&lt;/h3&gt;
&lt;h2 id=&quot;整合springboot&quot;&gt;4.整合springboot&lt;/h2&gt;
&lt;h3 id=&quot;新建maven项目d_api-一个公用service的api&quot;&gt;（1）新建Maven项目：d_api ：一个公用service的api&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;新建一个接口：HelloService&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.xm.dubbo.service;

public interface HelloService {

 String sayHello();

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;新建springboot项目hello_producer&quot;&gt;（2）新建Springboot项目：Hello_Producer&lt;/h3&gt;
&lt;p&gt;参考链接：https://github.com/apache/incubator-dubbo-spring-boot-project&lt;/p&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;添加依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
 xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
 &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

 &amp;lt;groupId&amp;gt;com.xm.dubbo&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;hello_producer&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
 &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

 &amp;lt;name&amp;gt;hello_producer&amp;lt;/name&amp;gt;
 &amp;lt;description&amp;gt;This is a Web about springcloud&amp;lt;/description&amp;gt;

 &amp;lt;parent&amp;gt;
     &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
     &amp;lt;version&amp;gt;2.0.6.RELEASE&amp;lt;/version&amp;gt;
     &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
 &amp;lt;/parent&amp;gt;

 &amp;lt;properties&amp;gt;
     &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
     &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
     &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
 &amp;lt;/properties&amp;gt;

 &amp;lt;dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;com.alibaba.boot&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;0.2.0&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
     &amp;lt;/dependency&amp;gt;

     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
         &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;com.xm.dubbo&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;d_api&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
 &amp;lt;/dependencies&amp;gt;

 &amp;lt;build&amp;gt;
     &amp;lt;plugins&amp;gt;
         &amp;lt;plugin&amp;gt;
             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
         &amp;lt;/plugin&amp;gt;
     &amp;lt;/plugins&amp;gt;
 &amp;lt;/build&amp;gt;


&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;修改配置文件&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;dubbo.application.name=hello_producer
dubbo.registry.protocol=zookeeper
dubbo.registry.address=127.0.0.1:2181
dubbo.scan.base-packages=com.xm.dubbo.service
dubbo.protocol.name=dubbo
dubbo.protocol.port=20080
dubbo.monitor.protocol=registry&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;新建HelloServiceImpl&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.xm.dubbo.service.impl;

import org.springframework.stereotype.Component;

import com.alibaba.dubbo.config.annotation.Service;
import com.xm.dubbo.service.HelloService;

@Service
@Component
public class HelloServiceImpl implements HelloService {

 @Override
 public String sayHello() {
     System.out.println(&quot;生产者已被调用！&quot;);
     return &quot;Hello dubbo!&quot;;
 }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;项目入口添加@EnableDubbo注解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.xm.dubbo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;

@EnableDubbo
@SpringBootApplication
public class HelloProducerApplication {

 public static void main(String[] args) {
     SpringApplication.run(HelloProducerApplication.class, args);
 }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;新建springboot项目hello_consumer&quot;&gt;（3）新建Springboot项目：Hello_Consumer&lt;/h3&gt;
&lt;ol readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;添加依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
 xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
 &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

 &amp;lt;groupId&amp;gt;com.xm.dubbo&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;hello_consumer&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
 &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

 &amp;lt;name&amp;gt;hello_consumer&amp;lt;/name&amp;gt;
 &amp;lt;description&amp;gt;This is a Web about springcloud&amp;lt;/description&amp;gt;

 &amp;lt;parent&amp;gt;
     &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
     &amp;lt;version&amp;gt;2.0.6.RELEASE&amp;lt;/version&amp;gt;
     &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
 &amp;lt;/parent&amp;gt;

 &amp;lt;properties&amp;gt;
     &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
     &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
     &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
 &amp;lt;/properties&amp;gt;

 &amp;lt;dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;com.alibaba.boot&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;0.2.0&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
     &amp;lt;/dependency&amp;gt;

     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
         &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;com.xm.dubbo&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;d_api&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
 &amp;lt;/dependencies&amp;gt;

 &amp;lt;build&amp;gt;
     &amp;lt;plugins&amp;gt;
         &amp;lt;plugin&amp;gt;
             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
         &amp;lt;/plugin&amp;gt;
     &amp;lt;/plugins&amp;gt;
 &amp;lt;/build&amp;gt;


&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;修改配置文件&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;server.port=8081

dubbo.application.name=hello_consumer
dubbo.registry.protocol=zookeeper
dubbo.registry.address=127.0.0.1:2181
dubbo.monitor.protocol=registry&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;新建HelloController&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.xm.dubbo.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import com.alibaba.dubbo.config.annotation.Reference;
import com.xm.dubbo.service.HelloService;

@RestController
public class HelloController {

 @Reference
 private HelloService helloService;

 @GetMapping(&quot;/hello&quot;)
 public String sayHello() {
     return helloService.sayHello();
 }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;项目入口添加@EnableDubbo注解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.xm.dubbo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;

@EnableDubbo
@SpringBootApplication
public class HelloConsumerApplication {

 public static void main(String[] args) {
     SpringApplication.run(HelloConsumerApplication.class, args);
 }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 23 Oct 2018 07:36:00 +0000</pubDate>
<dc:creator>零度微笑</dc:creator>
<og:description>SpringBoot整合Dubbo+Zookeaper 1.安装运行zookeeper （1）下载zookeeper 官网：http://zookeeper.apache.org/ （2）解压缩 （3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TimerHotel/p/springboot17.html</dc:identifier>
</item>
<item>
<title>深入源码分析Java线程池的实现原理 - Java架构</title>
<link>http://www.cnblogs.com/linxiran/p/9836945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linxiran/p/9836945.html</guid>
<description>[unable to retrieve full-text content]程序的运行，其本质上，是对系统资源（CPU、内存、磁盘、网络等等）的使用。如何高效的使用这些资源是我们编程优化演进的一个方向。今天说的线程池就是一种对CPU利用的优化手段。 网上有不少介绍如何使用线程池的文章，那我想说点什么呢？我希望通过学习线程池原理，明白所有池化技术的基本设计思路。遇到其他相似问</description>
<pubDate>Tue, 23 Oct 2018 07:34:00 +0000</pubDate>
<dc:creator>Java架构</dc:creator>
<og:description>SpringBoot整合Dubbo+Zookeaper 1.安装运行zookeeper （1）下载zookeeper 官网：http://zookeeper.apache.org/ （2）解压缩 （3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TimerHotel/p/springboot17.html</dc:identifier>
</item>
<item>
<title>基于.net core 2.0+mysql+AceAdmin搭建一套快速开发框架 - 梦亦晓</title>
<link>http://www.cnblogs.com/eggTwo/p/9564101.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eggTwo/p/9564101.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;.net core已经出来一段时间了，相信大家对.net core的概念已经很清楚了，这里就不再赘述。笔者目前也用.net core做过一些项目，并且将以前framework下的一些经验移植到了.net core下，并结合.net core本身的一些特性整理成此框架，以供学习参考。如有不足之处，欢迎指正。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 先睹为快，演示地址&lt;/span&gt;：&lt;span&gt;&lt;a href=&quot;http://cloud.eggtwo.com/main/index&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://cloud.eggtwo.com/main/index&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;框架介绍&lt;/h3&gt;
&lt;p&gt;先来一张整体分层结构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201808/559600-20180831100235800-1307662040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基础层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.Cloud.Core项目是核心项目，主要实现缓存的操作、dapper操作、EF Repository、PageList、日志等操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201808/559600-20180831100551708-1958045035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.Cloud.Utility属于帮助类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;领域层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.Cloud.Entity实体对象，存放数据库映射实体、Fluent API配置、枚举字典、DbContext等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201808/559600-20180831101101646-885202491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4.Cloud.UnitOfWork，操作数据库的网关，里面封装了对仓储的操作、dapper的操作、事务等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5.Cloud.Service 业务逻辑的实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201809/559600-20180912091520636-870662510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;6.Cloud.Dto 数据传输对象，实体对象不直接和表现层接触，通过dto互转&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表现层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;7.Cloud.Framework，表现层框架，封装了超类controller，全局授权过滤器，全局异常过滤器，ActionFilter,HtmlHelper等操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201808/559600-20180831101556370-94861762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8.Cloud.Boss 启动项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201809/559600-20180912091553839-64474612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;使用的技术&lt;/h3&gt;
&lt;p&gt; 基于.net core 2.0的asp.net core mvc&lt;/p&gt;
&lt;p&gt; 基于.net core 2.0的ef&lt;/p&gt;
&lt;p&gt;dapper&lt;/p&gt;
&lt;p&gt;mysql&lt;/p&gt;
&lt;p&gt; 前端框架&lt;a href=&quot;http://ace.jeka.by/#&quot; target=&quot;_blank&quot;&gt; aceAdmin&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;技术要点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.实体基类定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201809/559600-20180912091638817-46045928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 2.泛型仓储的封装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.1仓储接口的定义，泛型约束T必须是BaseEntity类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:false;&quot;&gt;
public interface IRepository&amp;lt;T&amp;gt; where T : BaseEntity
    {
        DatabaseFacade Database { get; }
        IQueryable&amp;lt;T&amp;gt; Entities { get; }
        int SaveChanges();
        Task&amp;lt;int&amp;gt; SaveChangesAsync();
        void Disposed();

        bool Delete(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true);
        bool Delete(T entity, bool isSaveChange = true);
        Task&amp;lt;bool&amp;gt; DeleteAsync(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true);
        Task&amp;lt;bool&amp;gt; DeleteAsync(T entity, bool isSaveChange = true);
      
        Task&amp;lt;T&amp;gt; GetAsync(Expression&amp;lt;Func&amp;lt;T, bool&amp;gt;&amp;gt; predicate = null);
        Task&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; GetListAsync(Expression&amp;lt;Func&amp;lt;T, bool&amp;gt;&amp;gt; predicate = null);
        T Get(object id);
        T Get(Expression&amp;lt;Func&amp;lt;T, bool&amp;gt;&amp;gt; predicate = null);
        Task&amp;lt;T&amp;gt; GetAsync(object id);
        Task&amp;lt;IQueryable&amp;lt;T&amp;gt;&amp;gt; LoadAsync(Expression&amp;lt;Func&amp;lt;T, bool&amp;gt;&amp;gt; predicate = null);

        bool Insert(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true);
        bool Insert(T entity, bool isSaveChange = true);
        Task&amp;lt;bool&amp;gt; InsertAsync(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true);
        Task&amp;lt;bool&amp;gt; InsertAsync(T entity, bool isSaveChange = true);
      
        bool Update(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true);
        bool Update(T entity, bool isSaveChange = true, List&amp;lt;string&amp;gt; updatePropertyList = null);
        Task&amp;lt;bool&amp;gt; UpdateAsync(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true);
        Task&amp;lt;bool&amp;gt; UpdateAsync(T entity, bool isSaveChange = true, List&amp;lt;string&amp;gt; updatePropertyList = null);


    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.2仓储接口的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:false;&quot;&gt;
  public class Repository&amp;lt;T&amp;gt; : IRepository&amp;lt;T&amp;gt; where T : BaseEntity
    {
        DbContext _dbContext;
        public Repository(DbContext dbContext)
        {
            _dbContext = dbContext;
        }
        public int SaveChanges()
        {
            return _dbContext.SaveChanges();
        }
        public async Task&amp;lt;int&amp;gt; SaveChangesAsync()
        {
            return await _dbContext.SaveChangesAsync();
        }
        public void Disposed()
        {
            throw new Exception(&quot;不允许在这里释放上下文，请在UnitOfWork中操作&quot;);
            _dbContext.Dispose();
        }
        #region 插入数据
        public bool Insert(T entity, bool isSaveChange = true)
        {
            _dbContext.Set&amp;lt;T&amp;gt;().Add(entity);
            if (isSaveChange)
            {
                return SaveChanges() &amp;gt; 0;
            }
            return false;
        }
        public async Task&amp;lt;bool&amp;gt; InsertAsync(T entity, bool isSaveChange = true)
        {
            _dbContext.Set&amp;lt;T&amp;gt;().Add(entity);
            if (isSaveChange)
            {
                return await SaveChangesAsync() &amp;gt; 0;
            }
            return false;
        }
        public bool Insert(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true)
        {
            _dbContext.Set&amp;lt;T&amp;gt;().AddRange(entitys);
            if (isSaveChange)
            {
                return SaveChanges() &amp;gt; 0;
            }
            return false;
        }
        public async Task&amp;lt;bool&amp;gt; InsertAsync(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true)
        {
            _dbContext.Set&amp;lt;T&amp;gt;().AddRange(entitys);
            if (isSaveChange)
            {
                return await SaveChangesAsync() &amp;gt; 0;
            }
            return false;
        }
        #endregion

        #region 更新数据
        public bool Update(T entity, bool isSaveChange = true, List&amp;lt;string&amp;gt; updatePropertyList = null)
        {
            if (entity==null)
            {
                return false;
            }
            _dbContext.Set&amp;lt;T&amp;gt;().Attach(entity);
            if (updatePropertyList==null)
            {
                _dbContext.Entry&amp;lt;T&amp;gt;(entity).State = EntityState.Modified;//全字段更新

            }
            else
            {
                updatePropertyList.ForEach(c =&amp;gt; {
                    _dbContext.Entry(entity).Property(c).IsModified = true; //部分字段更新的写法

                });

            }
            if (isSaveChange)
            {
                return SaveChanges() &amp;gt; 0;
            }
            return false;
        }
        public bool Update(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true)
        {
            if (entitys==null||entitys.Count==0)
            {
                return false;
            }
            entitys.ForEach(c =&amp;gt; {
                Update(c, false);
            });
            if (isSaveChange)
            {
                return SaveChanges() &amp;gt; 0;
            }
            return false;
        }
        public async Task&amp;lt;bool&amp;gt; UpdateAsync(T entity, bool isSaveChange = true, List&amp;lt;string&amp;gt; updatePropertyList = null)
        {
            if (entity == null)
            {
                return false;
            }
            _dbContext.Set&amp;lt;T&amp;gt;().Attach(entity);
            if (updatePropertyList == null)
            {
                _dbContext.Entry&amp;lt;T&amp;gt;(entity).State = EntityState.Modified;//全字段更新

            }
            else
            {
                updatePropertyList.ForEach(c =&amp;gt; {
                    _dbContext.Entry(entity).Property(c).IsModified = true; //部分字段更新的写法

                });

            }
            if (isSaveChange)
            {
                return await SaveChangesAsync() &amp;gt; 0;
            }
            return false;
        }
        public async Task&amp;lt;bool&amp;gt; UpdateAsync(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true)
        {
            if (entitys == null || entitys.Count == 0)
            {
                return false;
            }
            entitys.ForEach(c =&amp;gt; {
                _dbContext.Set&amp;lt;T&amp;gt;().Attach(c);
                _dbContext.Entry&amp;lt;T&amp;gt;(c).State = EntityState.Modified;
            });
            if (isSaveChange)
            {
                return await SaveChangesAsync() &amp;gt; 0;
            }
            return false;
        }
        #endregion

        #region 删除
        public bool Delete(T entity, bool isSaveChange = true)
        {
            _dbContext.Set&amp;lt;T&amp;gt;().Attach(entity);
            _dbContext.Set&amp;lt;T&amp;gt;().Remove(entity);
            return isSaveChange ? SaveChanges() &amp;gt; 0 : false;
        }
        public bool Delete(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true)
        {
            entitys.ForEach(entity =&amp;gt;
            {
                _dbContext.Set&amp;lt;T&amp;gt;().Attach(entity);
                _dbContext.Set&amp;lt;T&amp;gt;().Remove(entity);
            });
            return isSaveChange ? SaveChanges() &amp;gt; 0 : false;
        }

        public virtual async Task&amp;lt;bool&amp;gt; DeleteAsync(T entity, bool isSaveChange = true)
        {

            _dbContext.Set&amp;lt;T&amp;gt;().Attach(entity);
            _dbContext.Set&amp;lt;T&amp;gt;().Remove(entity);
            return isSaveChange ? await SaveChangesAsync() &amp;gt; 0 : false;
        }
        public virtual async Task&amp;lt;bool&amp;gt; DeleteAsync(List&amp;lt;T&amp;gt; entitys, bool isSaveChange = true)
        {
            entitys.ForEach(entity =&amp;gt;
            {
                _dbContext.Set&amp;lt;T&amp;gt;().Attach(entity);
                _dbContext.Set&amp;lt;T&amp;gt;().Remove(entity);
            });
            return isSaveChange ? await SaveChangesAsync() &amp;gt; 0 : false;
        }
        #endregion

        public IQueryable&amp;lt;T&amp;gt; Entities =&amp;gt; _dbContext.Set&amp;lt;T&amp;gt;().AsQueryable().AsNoTracking();
        //public async Task&amp;lt;IQueryable&amp;lt;T&amp;gt;&amp;gt; EntitiesAsync =&amp;gt; Task.Run(()=&amp;gt; _dbContext.Set&amp;lt;T&amp;gt;().AsQueryable().AsNoTracking()); 

        public DatabaseFacade Database =&amp;gt; _dbContext.Database;
        #region 查找
        public T Get(object id)
        {
            return _dbContext.Set&amp;lt;T&amp;gt;().Find(id);
        }
        public T Get(Expression&amp;lt;Func&amp;lt;T, bool&amp;gt;&amp;gt; predicate = null)
        {
            return _dbContext.Set&amp;lt;T&amp;gt;().Where(predicate).AsNoTracking().FirstOrDefault();
        }
        public async Task&amp;lt;T&amp;gt; GetAsync(object id)
        {
            return await _dbContext.Set&amp;lt;T&amp;gt;().FindAsync(id);
        }
        public async Task&amp;lt;T&amp;gt; GetAsync(Expression&amp;lt;Func&amp;lt;T, bool&amp;gt;&amp;gt; predicate = null)
        {
            return await _dbContext.Set&amp;lt;T&amp;gt;().Where(predicate).AsNoTracking().FirstOrDefaultAsync();
        }
        public async Task&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; GetListAsync(Expression&amp;lt;Func&amp;lt;T, bool&amp;gt;&amp;gt; predicate = null)
        {
            return await _dbContext.Set&amp;lt;T&amp;gt;().Where(predicate).AsNoTracking().ToListAsync();
        }
        public async Task&amp;lt;IQueryable&amp;lt;T&amp;gt;&amp;gt; LoadAsync(Expression&amp;lt;Func&amp;lt;T, bool&amp;gt;&amp;gt; predicate = null)
        {
            if (predicate == null)
            {
                predicate = c =&amp;gt; true;
            }
            return await Task.Run(() =&amp;gt; _dbContext.Set&amp;lt;T&amp;gt;().Where(predicate).AsNoTracking());
        }

        public void Dispose()
        {
            throw new NotImplementedException();
        }
        #endregion

    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3.表部分字段更新实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EF默认的更新方式是一个实体对应的表全部字段更新，那么我们想更新表的部分字段怎么处理？&lt;/p&gt;
&lt;p&gt;首先定义需要更新的字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
   public class PropertyExpression&amp;lt;T&amp;gt; where T : BaseEntity
    {
        private PropertyExpression() { }
        private static List&amp;lt;string&amp;gt; propertyList = new List&amp;lt;string&amp;gt;();
        public static PropertyExpression&amp;lt;T&amp;gt; Init
        {
            get
            {
                propertyList.Clear();
                return new PropertyExpression&amp;lt;T&amp;gt;();
            }
        }

        public PropertyExpression&amp;lt;T&amp;gt; Property(Expression&amp;lt;Func&amp;lt;T, object&amp;gt;&amp;gt; expr)
        {
            var rtn = &quot;&quot;;
            if (expr.Body is UnaryExpression)
            {
                rtn = ((MemberExpression)((UnaryExpression)expr.Body).Operand).Member.Name;
            }
            else if (expr.Body is MemberExpression)
            {
                rtn = ((MemberExpression)expr.Body).Member.Name;

            }
            else if (expr.Body is ParameterExpression)
            {
                rtn = ((ParameterExpression)expr.Body).Type.Name;
            }
            propertyList.Add(rtn);
            return this;
        }
        public List&amp;lt;string&amp;gt; ToList()
        {
            return propertyList;
        }

    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　EF更新的处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public bool Update(T entity, bool isSaveChange = true, List&amp;lt;string&amp;gt; updatePropertyList = null)
        {
            if (entity==null)
            {
                return false;
            }
            _dbContext.Set&amp;lt;T&amp;gt;().Attach(entity);
            if (updatePropertyList==null)
            {
                _dbContext.Entry&amp;lt;T&amp;gt;(entity).State = EntityState.Modified;//全字段更新

            }
            else
            {
                updatePropertyList.ForEach(c =&amp;gt; {
                    _dbContext.Entry(entity).Property(c).IsModified = true; //部分字段更新的写法

                });

            }
            if (isSaveChange)
            {
                return SaveChanges() &amp;gt; 0;
            }
            return false;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 var entity = _unitOfWork.SysRoleRep.Get(model.RoleId);
                    if (entity == null)
                    {
                        throw new Exception(&quot;要查找的对象不存在&quot;);
                    }
                    entity.Name = model.RoleName;
                    var updatedPropertyList = PropertyExpression&amp;lt;Sys_Role&amp;gt;.Init.Property(c =&amp;gt; c.Name).ToList();
                    _unitOfWork.SysRoleRep.Update(entity, true, updatedPropertyList);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.动态加载实体到DbContext&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public class EntityTypeConfiguration&amp;lt;T&amp;gt; : IEntityTypeConfiguration&amp;lt;T&amp;gt; where T : class
    {
        public void Configure(EntityTypeBuilder&amp;lt;T&amp;gt; builder)
        {
            RelyConfigure(builder);
        }
        public virtual void RelyConfigure(EntityTypeBuilder&amp;lt;T&amp;gt; builder)
        {

        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public class Sys_Error_LogConfiguration : EntityTypeConfiguration&amp;lt;Sys_Error_Log&amp;gt;
    {
        public override void RelyConfigure(EntityTypeBuilder&amp;lt;Sys_Error_Log&amp;gt; builder)
        {
            builder.ToTable(&quot;sys_error_log&quot;);
            builder.HasKey(x =&amp;gt; x.Id);
            base.RelyConfigure(builder);
        }

    }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  public class EfDbContext : DbContext
    {
        public EfDbContext(DbContextOptions&amp;lt;EfDbContext&amp;gt; options) : base(options)
        {

        }
        //配置数据库连接
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
           // optionsBuilder.UseSqlServer(&quot;xxxx connection string&quot;);
            base.OnConfiguring(optionsBuilder);
        }
       
        //第一次使用EF功能时执行一次，以后不再执行
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            //获取当前程序集中有基类并且基类是泛型的类
            var typesToRegister = Assembly.GetExecutingAssembly().GetTypes().Where(c =&amp;gt; c.BaseType != null &amp;amp;&amp;amp; c.BaseType.IsGenericType).ToList();
            foreach (var type in typesToRegister)
            {
                //泛型定义相同
                if (type.BaseType.GetGenericTypeDefinition() == typeof(EntityTypeConfiguration&amp;lt;&amp;gt;))
                {
                    dynamic configurationInstance = Activator.CreateInstance(type);
                    modelBuilder.ApplyConfiguration(configurationInstance);
                }


            }

           base.OnModelCreating(modelBuilder);
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5.&lt;strong&gt;工作单元&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工作单元是对仓储和事务的封装&lt;/p&gt;
&lt;p&gt;原理参考：https://docs.microsoft.com/zh-cn/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
   public class EfUnitOfWork : IUnitOfWork
    {
        private EfDbContext _dbContext;//每次请求上下文只会创建一个
        public EfUnitOfWork(EfDbContext context)
        {
            this._dbContext = context;
        }
        public int SaveChanges()
        {

            return _dbContext.SaveChanges();
        }
        public async Task&amp;lt;int&amp;gt; SaveChangesAsync()
        {
            return await _dbContext.SaveChangesAsync();
        }
        private bool disposed = false;

        protected virtual void Dispose(bool disposing)
        {
            if (!this.disposed)
            {
                if (disposing)
                {
                    _dbContext.Dispose();//随着工作单元的销毁而销毁
                }
            }
            this.disposed = true;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        public IDbContextTransaction BeginTransaction()
        {
            var scope = _dbContext.Database.BeginTransaction();
            return scope;
        }

        public List&amp;lt;T&amp;gt; SqlQuery&amp;lt;T&amp;gt;(string sql, object param = null) where T : class
        {
            var con= _dbContext.Database.GetDbConnection();
            if (con.State!= ConnectionState.Open)
            {
                con.Open();
            }
            var list= MysqlDapperReader.SqlQuery&amp;lt;T&amp;gt;(con, sql, param);
            return list;
            //throw new NotImplementedException();
        }

        public Task&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; SqlQueryAsync&amp;lt;T&amp;gt;(string sql, object param = null) where T : class
        {
            throw new NotImplementedException();
        }



        #region Sys Repository
        private IRepository&amp;lt;Sys_User&amp;gt; _sysUserRep;
        public IRepository&amp;lt;Sys_User&amp;gt; SysUserRep
        {
            get
            {
                if (_sysUserRep == null)
                {
                    //var s= HttpContext.Current.Items[&quot;currentUser&quot;];
                    //var s = HttpContext.Current.RequestServices.GetService&amp;lt;IRepository&amp;lt;Sys_User&amp;gt;&amp;gt;();
                    //HttpContext.RequestServices.GetService&amp;lt;IRepository&amp;lt;Sys_User&amp;gt;&amp;gt;();
                    _sysUserRep = new Repository&amp;lt;Sys_User&amp;gt;(_dbContext);
                }
                return _sysUserRep;
            }
        }
        private IRepository&amp;lt;Sys_Role&amp;gt; _sysRoleRep;
        public IRepository&amp;lt;Sys_Role&amp;gt; SysRoleRep
        {
            get
            {
                if (_sysRoleRep == null)
                {
                    _sysRoleRep = new Repository&amp;lt;Sys_Role&amp;gt;(_dbContext);
                }
                return _sysRoleRep;
            }
        }
        private IRepository&amp;lt;Sys_Role_User&amp;gt; _sysRoleUserRep;
        public IRepository&amp;lt;Sys_Role_User&amp;gt; SysRoleUserRep
        {
            get
            {
                if (_sysRoleUserRep == null)
                {
                    _sysRoleUserRep = new Repository&amp;lt;Sys_Role_User&amp;gt;(_dbContext);
                }
                return _sysRoleUserRep;
            }
        }

        private IRepository&amp;lt;Sys_Permission&amp;gt; _sysPermissionRep;
        public IRepository&amp;lt;Sys_Permission&amp;gt; SysPermissionRep
        {
            get
            {
                if (_sysPermissionRep == null)
                {
                    _sysPermissionRep = new Repository&amp;lt;Sys_Permission&amp;gt;(_dbContext);
                }
                return _sysPermissionRep;
            }
        }
        private IRepository&amp;lt;Sys_Module&amp;gt; _sysModuleRep;
        public IRepository&amp;lt;Sys_Module&amp;gt; SysModuleRep
        {
            get
            {
                if (_sysModuleRep == null)
                {
                    _sysModuleRep = new Repository&amp;lt;Sys_Module&amp;gt;(_dbContext);
                }
                return _sysModuleRep;
            }
        }

        private IRepository&amp;lt;Sys_Error_Log&amp;gt; _sysErrorLogRep;
        public IRepository&amp;lt;Sys_Error_Log&amp;gt; SysErrorLogRep
        {
            get
            {
                if (_sysErrorLogRep == null)
                {
                    _sysErrorLogRep = new Repository&amp;lt;Sys_Error_Log&amp;gt;(_dbContext);
                }
                return _sysErrorLogRep;
            }
        }

        private IRepository&amp;lt;Sys_Operation_Log&amp;gt; _sysOperationLogRep;
        public IRepository&amp;lt;Sys_Operation_Log&amp;gt; SysOperationLogRep
        {
            get
            {
                if (_sysOperationLogRep == null)
                {
                    _sysOperationLogRep = new Repository&amp;lt;Sys_Operation_Log&amp;gt;(_dbContext);
                }
                return _sysOperationLogRep;
            }
        } 
        #endregion

    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6.业务的实现方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　以前我是service中直接创建仓储然后用仓储操作数据库，方式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201809/559600-20180912102907747-1916698465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方式比较繁琐，后来我将创建仓储统一放在工作单元中进行，在service中直接创建UnitOfWork，方式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201809/559600-20180912103111204-1038356702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.Service的动态注册&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public static class AutoIocRegister
    {
        /// &amp;lt;summary&amp;gt;
        /// 动态注入IOC，注意类和接口的命名规则，接口在类名前面加&quot;I&quot;
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;assemblyName&quot;&amp;gt;程序集名称&amp;lt;/param&amp;gt;
        public static void BatchAddScoped(this IServiceCollection services, string assemblyName)
        {
            var libs = DependencyContext.Default.CompileLibraries;
            var serviceLib = libs.Where(c =&amp;gt; c.Name.Contains(assemblyName)).FirstOrDefault();
            var assembly = AssemblyLoadContext.Default.LoadFromAssemblyName(new AssemblyName(serviceLib.Name));
            var serviceClassList = assembly.GetTypes().Where(c =&amp;gt; c.IsClass).ToList();
            foreach (var item in serviceClassList)
            {
                var interfaceName = &quot;I&quot; + item.Name;
                var interfaceType = assembly.GetTypes().Where(c =&amp;gt; c.IsInterface &amp;amp;&amp;amp; c.Name == interfaceName).FirstOrDefault();
                if (interfaceType == null) continue;
                services.AddScoped(interfaceType, item);
            }
        }
    }　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 services.BatchAddScoped(&quot;Cloud.Service&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;8.日志记录：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;日志分操作日志和错误日志，可以设置在数据库和文本中同时记录：&lt;/p&gt;
&lt;p&gt;通过全局过滤器GlobalExceptionFilter和GlobalAuthorizeFilter处理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201809/559600-20180912103918104-370586455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;9.前端的封装（分页、弹出层、ajax等）&lt;/p&gt;
&lt;h3&gt;先放几张图吧，详细的以后再介绍&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201809/559600-20180910153622810-183651179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/559600/201809/559600-20180910153702075-312054860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 演示地址：&lt;a href=&quot;http://cloud.eggtwo.com/main/index&quot; target=&quot;_blank&quot;&gt;http://cloud.eggtwo.com/main/index&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 07:32:00 +0000</pubDate>
<dc:creator>梦亦晓</dc:creator>
<og:description>前言 .net core已经出来一段时间了，相信大家对.net core的概念已经很清楚了，这里就不再赘述。笔者目前也用.net core做过一些项目，并且将以前framework下的一些经验移植到了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eggTwo/p/9564101.html</dc:identifier>
</item>
<item>
<title>二叉搜索树 - 柳德维</title>
<link>http://www.cnblogs.com/liudw-0215/p/9835691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudw-0215/p/9835691.html</guid>
<description>&lt;h2&gt;　　前言：&lt;/h2&gt;
&lt;p&gt;　　　先立flag吧，18年每天一个算法或数据结构知识点的学习与总结！每周5个，大约会有50个吧，感觉基础的数据结构和算法都应该掌握了！但不能每天都写博客，时间有限，每周一篇或两篇进行分享，年底进行检验结果，加油！&lt;/p&gt;
&lt;p&gt;　　这次要介绍的是二叉搜索树，从名字也能看出它的实现和作用了，实现是以二叉树为基础来实现的，作用是进行数据查找。&lt;/p&gt;
&lt;h2&gt;　　一、二分查找&lt;/h2&gt;
&lt;p&gt;　　二分查找应该应熟悉了吧？要在&lt;span&gt;顺序储存结构&lt;/span&gt;中进行查找，跟最中间的数据进行比较，小的话去前半部分进行查找，否则，去后半部分去查找，其实，可以用迭代和递归分别来实现二分查找。&lt;/p&gt;
&lt;h3&gt;　　1、迭代法　　&lt;/h3&gt;
&lt;p&gt;　　首先，用迭代法来实现，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 二分查找法,在有序数组arr中,查找target
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果找到target,返回相应的索引index
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有找到target,返回-1&lt;/span&gt;
template&amp;lt;typename T&amp;gt;
&lt;span&gt;int&lt;/span&gt; binarySearch(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, T target){

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在arr[l...r]之中查找target&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; l = &lt;span&gt;0&lt;/span&gt;, r = n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;( l &amp;lt;=&lt;span&gt; r ){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int mid = (l + r)/2;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; mid = l + (r-l)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( arr[mid] ==&lt;span&gt; target )
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( arr[mid] &amp;gt;&lt;span&gt; target )
            r &lt;/span&gt;= mid - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            l &lt;/span&gt;= mid + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　需要注意的一点是：int mid = (l + r)/2;我注释的这个求mid会有一个bug,当l和r达到int的最大值时，会出现越界的问题。这也是算法的魅力，需要注意很多细节并有很多地方需要优化！学无止境！&lt;/p&gt;
&lt;h3&gt;　　2、递归法&lt;/h3&gt;
&lt;p&gt;　　用递归法实现，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用递归的方式写二分查找法&lt;/span&gt;
template&amp;lt;typename T&amp;gt;
&lt;span&gt;int&lt;/span&gt; __binarySearch2(T arr[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r, T target){

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( l &amp;gt;&lt;span&gt; r )
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid = (l+r)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( arr[mid] ==&lt;span&gt; target )
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( arr[mid] &amp;gt;&lt;span&gt; target )
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; __binarySearch2(arr, &lt;span&gt;0&lt;/span&gt;, mid-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, target);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; __binarySearch2(arr, mid+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, r, target);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用递归最重要的一点就是：要有结束条件&lt;/p&gt;
&lt;h3&gt;　　3、main函数测试两种方法&lt;/h3&gt;
&lt;p&gt;　　写一个main函数，进行简单的测试，数据量用的比较大，PS：用一个算法进行一下优化，一看数据量就几百，根本没必要优化，数据量不过万，谈算法意义并不大！&lt;/p&gt;
&lt;p&gt;main函数主要对两种算法进行时间对比：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('725515a7-5fad-405c-a18a-8a489dde7c24')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_725515a7-5fad-405c-a18a-8a489dde7c24&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_725515a7-5fad-405c-a18a-8a489dde7c24&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('725515a7-5fad-405c-a18a-8a489dde7c24',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_725515a7-5fad-405c-a18a-8a489dde7c24&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;* a = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; n ; i ++&lt;span&gt; )
        a[i] &lt;/span&gt;=&lt;span&gt; i;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试非递归二分查找法&lt;/span&gt;
    clock_t startTime =&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span&gt;2&lt;/span&gt;*n ; i ++&lt;span&gt; ){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v =&lt;span&gt; binarySearch(a, n, i);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( i &amp;lt;&lt;span&gt; n )
            assert( v &lt;/span&gt;==&lt;span&gt; i );
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            assert( v &lt;/span&gt;== -&lt;span&gt;1&lt;/span&gt;&lt;span&gt; );
    }
    clock_t endTime &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Binary Search (Without Recursion): &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;double&lt;/span&gt;(endTime - startTime) / CLOCKS_PER_SEC &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试递归的二分查找法&lt;/span&gt;
    startTime =&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span&gt;2&lt;/span&gt;*n ; i ++&lt;span&gt; ){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v =&lt;span&gt; binarySearch2(a, n, i);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( i &amp;lt;&lt;span&gt; n )
            assert( v &lt;/span&gt;==&lt;span&gt; i );
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            assert( v &lt;/span&gt;== -&lt;span&gt;1&lt;/span&gt;&lt;span&gt; );
    }
    endTime &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Binary Search (Recursion): &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;double&lt;/span&gt;(endTime - startTime) / CLOCKS_PER_SEC &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;


    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] a;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}       &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果如下：　　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201810/1249620-20181023111207942-1304012270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　会发现递归运行时间长，因为递归会反复调用，会耗时的。&lt;/p&gt;
&lt;h2&gt;　　二、二叉搜索树&lt;/h2&gt;
&lt;h3&gt;　　1、介绍&lt;/h3&gt;
&lt;p&gt;　　什么是二叉搜索树呢？&lt;/p&gt;
&lt;p&gt;　　首先，它是一颗二叉树：&lt;/p&gt;
&lt;p&gt;（1）若左子树不空，则左子树上所有结点的值均小于或等于它的&lt;a class=&quot;ed_inner_link&quot; href=&quot;https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=66940455&amp;amp;ss_c=ssc.citiao.link&quot; target=&quot;_blank&quot;&gt;根结点&lt;/a&gt;的值；&lt;/p&gt;
&lt;p&gt;（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；&lt;/p&gt;
&lt;p&gt;（3）左、右子树也分别为二叉排序树；&lt;/p&gt;
&lt;p&gt;　　如下图就是二叉搜索树：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201810/1249620-20181023112559236-1847600740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　2、构建一个BST类&lt;/h3&gt;
&lt;p&gt;　　先建一个BST类用于存放二叉搜索树，还包括一些构造函数、插入和查找等，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6a2ab0b8-553e-4fbf-be32-fa0a5773d66a')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_6a2ab0b8-553e-4fbf-be32-fa0a5773d66a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6a2ab0b8-553e-4fbf-be32-fa0a5773d66a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6a2ab0b8-553e-4fbf-be32-fa0a5773d66a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6a2ab0b8-553e-4fbf-be32-fa0a5773d66a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
template &amp;lt;typename Key, typename Value&amp;gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BST {

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Node {
        Key key;
        Value value;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key和value值相等&lt;/span&gt;
        Node *left;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子树&lt;/span&gt;
        Node *right;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子树
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结构体的构造函数&lt;/span&gt;
&lt;span&gt;        Node(Key key, Value value) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;left = &lt;span&gt;this&lt;/span&gt;-&amp;gt;right =&lt;span&gt; NULL;
        }

        Node(Node &lt;/span&gt;*&lt;span&gt;node) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;key = node-&amp;gt;&lt;span&gt;key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;value = node-&amp;gt;&lt;span&gt;value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;left = node-&amp;gt;&lt;span&gt;left;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;right = node-&amp;gt;&lt;span&gt;right;
        }
    };

    Node &lt;/span&gt;*&lt;span&gt;root;    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    BST() {    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类的构造函数&lt;/span&gt;
        root =&lt;span&gt; NULL;
        count &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;~&lt;span&gt;BST() {
        destroy(root);
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(Key key, Value value) {
        root &lt;/span&gt;=&lt;span&gt; insert(root, key, value);
    }

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; contain(Key key) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否包含&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; contain(root, key);
    }

    Value&lt;/span&gt;* search(Key key) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; search(root, key);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; preOrder() {
        preOrder(root);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inOrder() {
        inOrder(root);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postOrder() {
        postOrder(root);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 层序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; levelOrder() {

        queue&lt;/span&gt;&amp;lt;Node*&amp;gt;&lt;span&gt; q;
        q.push(root);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;q.empty()) {

            Node &lt;/span&gt;*node =&lt;span&gt; q.front();
            q.pop();

            cout &lt;/span&gt;&amp;lt;&amp;lt; node-&amp;gt;key &amp;lt;&amp;lt;&lt;span&gt; endl;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;&lt;span&gt;left)
                q.push(node&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;&lt;span&gt;right)
                q.push(node&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 寻找最小的键值&lt;/span&gt;
&lt;span&gt;    Key minimum() {
        assert(count &lt;/span&gt;!= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        Node&lt;/span&gt;* minNode =&lt;span&gt; minimum(root);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; minNode-&amp;gt;&lt;span&gt;key;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 寻找最大的键值&lt;/span&gt;
&lt;span&gt;    Key maximum() {
        assert(count &lt;/span&gt;!= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        Node&lt;/span&gt;* maxNode =&lt;span&gt; maximum(root);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; maxNode-&amp;gt;&lt;span&gt;key;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从二叉树中删除最小值所在节点&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeMin() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (root)
            root &lt;/span&gt;=&lt;span&gt; removeMin(root);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从二叉树中删除最大值所在节点&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeMax() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (root)
            root &lt;/span&gt;=&lt;span&gt; removeMax(root);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从二叉树中删除键值为key的节点&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove(Key key) {
        root &lt;/span&gt;=&lt;span&gt; remove(root, key);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　3、插入节点&lt;/h3&gt;
&lt;p&gt;　　首先，它是二叉树，都具有的性质是递归，所以用递归相对比较简单，画一张图如下供参考：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201810/1249620-20181023140748193-1611751111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　假如，先插入8，跟根节点12比较，比它小去左子树，跟节点5比较，比它大去右子树；再例如，插入13，跟根节点12比较，比它大去右子树；代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向以node为根的二叉搜索树中,插入节点(key, value)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回插入新节点后的二叉搜索树的根&lt;/span&gt;
    Node* insert(Node *&lt;span&gt;node, Key key, Value value) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; NULL) {
            count&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(key, value);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == node-&amp;gt;&lt;span&gt;key)
            node&lt;/span&gt;-&amp;gt;value =&lt;span&gt; value;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;lt; node-&amp;gt;&lt;span&gt;key)
            node&lt;/span&gt;-&amp;gt;left = insert(node-&amp;gt;&lt;span&gt;left, key, value);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key &amp;gt; node-&amp;gt;key&lt;/span&gt;
            node-&amp;gt;right = insert(node-&amp;gt;&lt;span&gt;right, key, value);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4、查找节点&lt;/h3&gt;
&lt;p&gt;　　跟插入的思想很像，也是不断比较，用递归的思想去查找，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在以node为根的二叉搜索树中查找key所对应的value&lt;/span&gt;
    Value* search(Node*&lt;span&gt; node, Key key) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; NULL)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == node-&amp;gt;&lt;span&gt;key)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;(node-&amp;gt;&lt;span&gt;value);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;lt; node-&amp;gt;&lt;span&gt;key)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; search(node-&amp;gt;&lt;span&gt;left, key);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key &amp;gt; node-&amp;gt;key&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; search(node-&amp;gt;&lt;span&gt;right, key);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5、三种遍历方法&lt;/h3&gt;
&lt;p&gt;　　三种方法分别是：先序遍历、中序遍历和后序遍历。画图讲解一下吧，如下图：　　PS：依旧是全网最丑图，不接受反驳！&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201810/1249620-20181023143959173-324986042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　三种遍历的本质：&lt;span&gt;访问路径一样，访问顺序不一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;先序遍历：根左右，先访问根节点、再左节点、其次右节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　中序遍历：左根右，先访问左节点、再根节点、其次右节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后序遍历：左右根，先访问左节点、再右节点、其次根节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用上面的图解释这句话，那条红线就是访问路径，三种遍历方式都是这条访问路径；用节点旁边的三个红点来表示访问和顺序，这么说，可能还是懵。&lt;/p&gt;
&lt;p&gt;　　拿先序来举个例子吧：访问路径一样，都从根节点12出发，遇到“先序红点”，直接输出12，然后是5，最后的先序结果上图下面的结果。　&lt;/p&gt;
&lt;h4&gt;　（1）先序遍历&lt;/h4&gt;
&lt;p&gt;　　先序遍历程序如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对以node为根的二叉搜索树进行先序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; preOrder(Node*&lt;span&gt; node) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !=&lt;span&gt; NULL) {
            cout &lt;/span&gt;&amp;lt;&amp;lt; node-&amp;gt;key &amp;lt;&amp;lt;&lt;span&gt; endl;
            preOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
            preOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　（2）中序遍历&lt;/h4&gt;
&lt;p&gt;　　中序遍历程序如下：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对以node为根的二叉搜索树进行中序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; inOrder(Node*&lt;span&gt; node) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !=&lt;span&gt; NULL) {
            inOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
            cout &lt;/span&gt;&amp;lt;&amp;lt; node-&amp;gt;key &amp;lt;&amp;lt;&lt;span&gt; endl;
            inOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　（3）后序遍历&lt;/h4&gt;
&lt;p&gt;　　后序遍历程序如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对以node为根的二叉搜索树进行后序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; postOrder(Node*&lt;span&gt; node) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !=&lt;span&gt; NULL) {
            postOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
            postOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
            cout &lt;/span&gt;&amp;lt;&amp;lt; node-&amp;gt;key &amp;lt;&amp;lt;&lt;span&gt; endl;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　6、总体程序&lt;/h3&gt;
&lt;p&gt;　　总体的程序如下，方便调试和使用，程序如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e83d2b6e-b1e5-4834-8b34-fbff614b59ed')&quot; readability=&quot;50&quot;&gt;&lt;img id=&quot;code_img_closed_e83d2b6e-b1e5-4834-8b34-fbff614b59ed&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e83d2b6e-b1e5-4834-8b34-fbff614b59ed&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e83d2b6e-b1e5-4834-8b34-fbff614b59ed',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e83d2b6e-b1e5-4834-8b34-fbff614b59ed&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;queue&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cassert&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;ctime&amp;gt;

&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

template &lt;/span&gt;&amp;lt;typename Key, typename Value&amp;gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BST {

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Node {
        Key key;
        Value value;
        Node &lt;/span&gt;*&lt;span&gt;left;
        Node &lt;/span&gt;*&lt;span&gt;right;

        Node(Key key, Value value) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;left = &lt;span&gt;this&lt;/span&gt;-&amp;gt;right =&lt;span&gt; NULL;
        }

        Node(Node &lt;/span&gt;*&lt;span&gt;node) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;key = node-&amp;gt;&lt;span&gt;key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;value = node-&amp;gt;&lt;span&gt;value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;left = node-&amp;gt;&lt;span&gt;left;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;right = node-&amp;gt;&lt;span&gt;right;
        }
    };

    Node &lt;/span&gt;*&lt;span&gt;root;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    BST() {
        root &lt;/span&gt;=&lt;span&gt; NULL;
        count &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;~&lt;span&gt;BST() {
        destroy(root);
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(Key key, Value value) {
        root &lt;/span&gt;=&lt;span&gt; insert(root, key, value);
    }

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; contain(Key key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; contain(root, key);
    }

    Value&lt;/span&gt;*&lt;span&gt; search(Key key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; search(root, key);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; preOrder() {
        preOrder(root);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inOrder() {
        inOrder(root);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postOrder() {
        postOrder(root);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 层序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; levelOrder() {

        queue&lt;/span&gt;&amp;lt;Node*&amp;gt;&lt;span&gt; q;
        q.push(root);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;q.empty()) {

            Node &lt;/span&gt;*node =&lt;span&gt; q.front();
            q.pop();

            cout &lt;/span&gt;&amp;lt;&amp;lt; node-&amp;gt;key &amp;lt;&amp;lt;&lt;span&gt; endl;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;&lt;span&gt;left)
                q.push(node&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;&lt;span&gt;right)
                q.push(node&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 寻找最小的键值&lt;/span&gt;
&lt;span&gt;    Key minimum() {
        assert(count &lt;/span&gt;!= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        Node&lt;/span&gt;* minNode =&lt;span&gt; minimum(root);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; minNode-&amp;gt;&lt;span&gt;key;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 寻找最大的键值&lt;/span&gt;
&lt;span&gt;    Key maximum() {
        assert(count &lt;/span&gt;!= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        Node&lt;/span&gt;* maxNode =&lt;span&gt; maximum(root);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; maxNode-&amp;gt;&lt;span&gt;key;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从二叉树中删除最小值所在节点&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeMin() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (root)
            root &lt;/span&gt;=&lt;span&gt; removeMin(root);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从二叉树中删除最大值所在节点&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeMax() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (root)
            root &lt;/span&gt;=&lt;span&gt; removeMax(root);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从二叉树中删除键值为key的节点&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove(Key key) {
        root &lt;/span&gt;=&lt;span&gt; remove(root, key);
    }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向以node为根的二叉搜索树中,插入节点(key, value)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回插入新节点后的二叉搜索树的根&lt;/span&gt;
    Node* insert(Node *&lt;span&gt;node, Key key, Value value) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; NULL) {
            count&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(key, value);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == node-&amp;gt;&lt;span&gt;key)
            node&lt;/span&gt;-&amp;gt;value =&lt;span&gt; value;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;lt; node-&amp;gt;&lt;span&gt;key)
            node&lt;/span&gt;-&amp;gt;left = insert(node-&amp;gt;&lt;span&gt;left, key, value);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key &amp;gt; node-&amp;gt;key&lt;/span&gt;
            node-&amp;gt;right = insert(node-&amp;gt;&lt;span&gt;right, key, value);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查看以node为根的二叉搜索树中是否包含键值为key的节点&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; contain(Node*&lt;span&gt; node, Key key) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; NULL)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == node-&amp;gt;&lt;span&gt;key)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;lt; node-&amp;gt;&lt;span&gt;key)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; contain(node-&amp;gt;&lt;span&gt;left, key);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key &amp;gt; node-&amp;gt;key&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; contain(node-&amp;gt;&lt;span&gt;right, key);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在以node为根的二叉搜索树中查找key所对应的value&lt;/span&gt;
    Value* search(Node*&lt;span&gt; node, Key key) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; NULL)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == node-&amp;gt;&lt;span&gt;key)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;(node-&amp;gt;&lt;span&gt;value);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;lt; node-&amp;gt;&lt;span&gt;key)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; search(node-&amp;gt;&lt;span&gt;left, key);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key &amp;gt; node-&amp;gt;key&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; search(node-&amp;gt;&lt;span&gt;right, key);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对以node为根的二叉搜索树进行前序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; preOrder(Node*&lt;span&gt; node) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !=&lt;span&gt; NULL) {
            cout &lt;/span&gt;&amp;lt;&amp;lt; node-&amp;gt;key &amp;lt;&amp;lt;&lt;span&gt; endl;
            preOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
            preOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对以node为根的二叉搜索树进行中序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; inOrder(Node*&lt;span&gt; node) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !=&lt;span&gt; NULL) {
            inOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
            cout &lt;/span&gt;&amp;lt;&amp;lt; node-&amp;gt;key &amp;lt;&amp;lt;&lt;span&gt; endl;
            inOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对以node为根的二叉搜索树进行后序遍历&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; postOrder(Node*&lt;span&gt; node) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !=&lt;span&gt; NULL) {
            postOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
            postOrder(node&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
            cout &lt;/span&gt;&amp;lt;&amp;lt; node-&amp;gt;key &amp;lt;&amp;lt;&lt;span&gt; endl;
        }
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; destroy(Node*&lt;span&gt; node) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !=&lt;span&gt; NULL) {
            destroy(node&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
            destroy(node&lt;/span&gt;-&amp;gt;&lt;span&gt;right);

            &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; node;
            count&lt;/span&gt;--&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在以node为根的二叉搜索树中,返回最小键值的节点&lt;/span&gt;
    Node* minimum(Node*&lt;span&gt; node) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;left ==&lt;span&gt; NULL)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; minimum(node-&amp;gt;&lt;span&gt;left);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在以node为根的二叉搜索树中,返回最大键值的节点&lt;/span&gt;
    Node* maximum(Node*&lt;span&gt; node) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;right ==&lt;span&gt; NULL)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; maximum(node-&amp;gt;&lt;span&gt;right);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除掉以node为根的二分搜索树中的最小节点
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回删除节点后新的二分搜索树的根&lt;/span&gt;
    Node* removeMin(Node*&lt;span&gt; node) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;left ==&lt;span&gt; NULL) {

            Node&lt;/span&gt;* rightNode = node-&amp;gt;&lt;span&gt;right;
            &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; node;
            count&lt;/span&gt;--&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rightNode;
        }

        node&lt;/span&gt;-&amp;gt;left = removeMin(node-&amp;gt;&lt;span&gt;left);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除掉以node为根的二分搜索树中的最大节点
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回删除节点后新的二分搜索树的根&lt;/span&gt;
    Node* removeMax(Node*&lt;span&gt; node) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;right ==&lt;span&gt; NULL) {

            Node&lt;/span&gt;* leftNode = node-&amp;gt;&lt;span&gt;left;
            &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; node;
            count&lt;/span&gt;--&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; leftNode;
        }

        node&lt;/span&gt;-&amp;gt;right = removeMax(node-&amp;gt;&lt;span&gt;right);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除掉以node为根的二分搜索树中键值为key的节点
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回删除节点后新的二分搜索树的根&lt;/span&gt;
    Node* remove(Node*&lt;span&gt; node, Key key) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; NULL)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key &amp;lt; node-&amp;gt;&lt;span&gt;key) {
            node&lt;/span&gt;-&amp;gt;left = remove(node-&amp;gt;&lt;span&gt;left, key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;gt; node-&amp;gt;&lt;span&gt;key) {
            node&lt;/span&gt;-&amp;gt;right = remove(node-&amp;gt;&lt;span&gt;right, key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key == node-&amp;gt;key&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt; (node-&amp;gt;left ==&lt;span&gt; NULL) {
                Node &lt;/span&gt;*rightNode = node-&amp;gt;&lt;span&gt;right;
                &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; node;
                count&lt;/span&gt;--&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rightNode;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;right ==&lt;span&gt; NULL) {
                Node &lt;/span&gt;*leftNode = node-&amp;gt;&lt;span&gt;left;
                &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; node;
                count&lt;/span&gt;--&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; leftNode;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; node-&amp;gt;left != NULL &amp;amp;&amp;amp; node-&amp;gt;right != NULL&lt;/span&gt;
            Node *successor = &lt;span&gt;new&lt;/span&gt; Node(minimum(node-&amp;gt;&lt;span&gt;right));
            count&lt;/span&gt;++&lt;span&gt;;

            successor&lt;/span&gt;-&amp;gt;right = removeMin(node-&amp;gt;&lt;span&gt;right);
            successor&lt;/span&gt;-&amp;gt;left = node-&amp;gt;&lt;span&gt;left;

            &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; node;
            count&lt;/span&gt;--&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; successor;
        }
    }
};


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; shuffle(&lt;span&gt;int&lt;/span&gt; arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {

    srand(time(NULL));
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = n - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = rand() % (i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        swap(arr[i], arr[x]);
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {

    srand(time(NULL));
    BST&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt; bst = BST&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; key = rand() %&lt;span&gt; n;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了后续测试方便,这里value值取和key值一样&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; value =&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cout&amp;lt;&amp;lt;key&amp;lt;&amp;lt;&quot; &quot;;&lt;/span&gt;
&lt;span&gt;        bst.insert(key, value);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; test remove
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove elements in random order&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; order[&lt;span&gt;10&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
        order[i] &lt;/span&gt;=&lt;span&gt; i;
    shuffle(order, n);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (bst.contain(order[i])) {
            bst.remove(order[i]);
            cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;After remove &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; order[i] &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; size = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; bst.size() &amp;lt;&amp;lt;&lt;span&gt; endl;
        }

    system(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);


    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;　　总结：　　&lt;/h2&gt;
&lt;p&gt;　　　坚持学习与分享！喜欢的帮忙推荐，有问题欢迎随时留言!&lt;/p&gt;



</description>
<pubDate>Tue, 23 Oct 2018 07:02:00 +0000</pubDate>
<dc:creator>柳德维</dc:creator>
<og:description>前言： 先立flag吧，18年每天一个算法或数据结构知识点的学习与总结！每周5个，大约会有50个吧，感觉基础的数据结构和算法都应该掌握了！但不能每天都写博客，时间有限，每周一篇或两篇进行分享，年底进行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudw-0215/p/9835691.html</dc:identifier>
</item>
<item>
<title>【Java】几道常见的秋招面试题 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/9836396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/9836396.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;只有光头才能变强&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Redis目前还在看，今天来分享一下我在秋招看过(遇到)的一些面试题(相对比较常见的)&lt;/p&gt;
&lt;h2 id=&quot;final关键字&quot;&gt;0、final关键字&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;简要说一下final关键字，final可以用来修饰什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这题我是在真实的面试中遇到的，当时答得不太好，现在来整理一下吧。&lt;/p&gt;
&lt;p&gt;final可以修饰类、方法、成员变量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当final修饰类的时候，说明该类不能被继承&lt;/li&gt;
&lt;li&gt;当final修饰方法的时候，说明该方法不能被重写
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在早期&lt;/strong&gt;，可能使用final修饰的方法，编译器针对这些方法的所有调用都转成内嵌调用，这样提高效率(但到现在一般我们不会去管这事了，编译器和JVM都越来越聪明了)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当final修饰成员变量时，有两种情况：
&lt;ul&gt;&lt;li&gt;如果修饰的是基本类型，说明这个变量的所代表数值永不能变(不能重新赋值)！&lt;/li&gt;
&lt;li&gt;如果修饰的是引用类型，该变量所的引用不能变，但引用所代表的对象内容是可变的！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得一说的是：&lt;strong&gt;并不是被final修饰的成员变量就一定是编译期常量了&lt;/strong&gt;。比如说我们可以写出这样的代码：&lt;code&gt;private final int java3y = new Randon().nextInt(20);&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;你有没有这样的编程经验，在编译器写代码时，某个场景下一定要将变量声明为final，否则会出现编译不通过的情况。为什么要这样设计？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在编写匿名内部类的时候就可能会出现这种情况，匿名内部类可能会使用到的变量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外部类实例变量&lt;/li&gt;
&lt;li&gt;方法或作用域内的局部变量&lt;/li&gt;
&lt;li&gt;方法的参数&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
class Outer {


    // string:外部类的实例变量
    String string = &quot;&quot;;


    //ch:方法的参数
    void outerTest(final char ch) {

        // integer:方法内局部变量
        final Integer integer = 1;
        new Inner() {
            void innerTest() {
                System.out.println(string);
                System.out.println(ch);
                System.out.println(integer);
            }
        };

    }
    public static void main(String[] args) {
        new Outer().outerTest(' ');
    }
    class Inner {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中我们可以看到：方法或作用域内的局部变量和方法参数都要&lt;strong&gt;显示使用final关键字来修饰&lt;/strong&gt;(在jdk1.7下)！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/23/1669f78ac28b0f33?w=941&amp;amp;h=705&amp;amp;f=png&amp;amp;s=19498&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果切换到jdk1.8编译环境下，可以通过编译的~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/23/1669f78b76adc99c?w=1235&amp;amp;h=565&amp;amp;f=png&amp;amp;s=28877&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们首先来说一下显示声明为final的原因：&lt;strong&gt;为了保持内部外部数据一致性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java只是实现了capture-by-value形式的闭包，也就是匿名函数内部会&lt;strong&gt;重新拷贝一份自由变量&lt;/strong&gt;，然后函数外部和函数内部就有&lt;strong&gt;两份&lt;/strong&gt;数据。&lt;/li&gt;
&lt;li&gt;要想实现内部外部数据一致性目的，只能要求&lt;strong&gt;两处变量不变&lt;/strong&gt;。JDK8之前要求使用final修饰，JDK8聪明些了，可以使用effectively final的方式&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么仅仅针对方法中的参数限制final，而访问外部类的属性就可以随意&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内部类中是保存着一个&lt;strong&gt;指向外部类实例的引用&lt;/strong&gt;，内部类访问外部类的成员变量都是通过这个引用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在内部类修改了这个引用的数据，外部类&lt;strong&gt;再&lt;/strong&gt;获取时拿到的数据是一致的！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那当你在匿名内部类里面尝试改变外部基本类型的变量的值的时候，或者改变外部引用变量的指向的时候，&lt;strong&gt;表面上&lt;/strong&gt;看起来好像都成功了，但&lt;strong&gt;实际上并不会影响到外部的变量&lt;/strong&gt;。所以，Java为了不让自己看起来那么奇怪，才加了这个final的限制。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;h2 id=&quot;一char和varchar的区别&quot;&gt;一、char和varchar的区别&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;char是固定长度，varchar长度可变。varchar：&lt;strong&gt;如果原先存储的位置无法满足其存储的需求&lt;/strong&gt;，就需要一些额外的操作，根据存储引擎的不同，有的会采用&lt;strong&gt;拆分机制&lt;/strong&gt;，有的采用&lt;strong&gt;分页机制&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;char的存储方式是：英文字符占1个字节，汉字占用2个字节；varchar的存储方式是：&lt;strong&gt;英文和汉字都占用2个字节&lt;/strong&gt;，两者的存储数据都非unicode的字符数据。&lt;/li&gt;
&lt;li&gt;char是固定长度，长度不够的情况下，用空格代替。varchar表示的是实际长度的数据类型&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;选用考量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果字段长度较&lt;strong&gt;短&lt;/strong&gt;和字符间长度&lt;strong&gt;相近甚至是相同的长度&lt;/strong&gt;，会采用char字符类型&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二多个线程顺序打印问题&quot;&gt;二、多个线程顺序打印问题&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;三个线程分别打印A，B，C，要求这三个线程一起运行，打印n次，输出形如“ABCABCABC....”的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原博主给出了4种方式，我认为信号量这种方式比较简单和容易理解，我这里&lt;strong&gt;粘贴&lt;/strong&gt;一下(具体的可到原博主下学习)..&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class PrintABCUsingSemaphore {
    private int times;
    private Semaphore semaphoreA = new Semaphore(1);
    private Semaphore semaphoreB = new Semaphore(0);
    private Semaphore semaphoreC = new Semaphore(0);

    public PrintABCUsingSemaphore(int times) {
        this.times = times;
    }

    public static void main(String[] args) {
        PrintABCUsingSemaphore printABC = new PrintABCUsingSemaphore(10);

        // 非静态方法引用  x::toString   和() -&amp;gt; x.toString() 是等价的！
        new Thread(printABC::printA).start();
        new Thread(printABC::printB).start();
        new Thread(printABC::printC).start();

        /*new Thread(() -&amp;gt; printABC.printA()).start();
        new Thread(() -&amp;gt; printABC.printB()).start();
        new Thread(() -&amp;gt; printABC.printC()).start();
*/
    }

    public void printA() {
        try {
            print(&quot;A&quot;, semaphoreA, semaphoreB);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void printB() {
        try {
            print(&quot;B&quot;, semaphoreB, semaphoreC);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void printC() {
        try {
            print(&quot;C&quot;, semaphoreC, semaphoreA);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void print(String name, Semaphore current, Semaphore next)
            throws InterruptedException {
        for (int i = 0; i &amp;lt; times; i++) {
            current.acquire();
            System.out.print(name);
            next.release();
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2018年9月14日18:15:36 yy笔试题就出了..&lt;/p&gt;
&lt;h2 id=&quot;三生产者和消费者&quot;&gt;三、生产者和消费者&lt;/h2&gt;
&lt;p&gt;在不少的面经都能看到它的身影哈~~~基本都是要求能够手写代码的。&lt;/p&gt;
&lt;p&gt;其实逻辑并不难，概括起来就两句话：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果生产者的队列满了(while循环判断是否满)，则等待。如果生产者的队列没满，则生产数据并&lt;strong&gt;唤醒&lt;/strong&gt;消费者进行消费。&lt;/li&gt;
&lt;li&gt;如果消费者的队列空了(while循环判断是否空)，则等待。如果消费者的队列没空，则消费数据并&lt;strong&gt;唤醒&lt;/strong&gt;生产者进行生产。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于原作者的代码，我修改了部分并给上我认为合适的注释(下面附上了原作者出处，感兴趣的同学可到原文学习)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产者：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import java.util.Random;
import java.util.Vector;
import java.util.concurrent.atomic.AtomicInteger;

public class Producer implements Runnable {

    // true---&amp;gt;生产者一直执行，false---&amp;gt;停掉生产者
    private volatile boolean isRunning = true;

    // 公共资源
    private final Vector sharedQueue;

    // 公共资源的最大数量
    private final int SIZE;

    // 生产数据
    private static AtomicInteger count = new AtomicInteger();

    public Producer(Vector sharedQueue, int SIZE) {
        this.sharedQueue = sharedQueue;
        this.SIZE = SIZE;
    }

    @Override
    public void run() {
        int data;
        Random r = new Random();

        System.out.println(&quot;start producer id = &quot; + Thread.currentThread().getId());
        try {
            while (isRunning) {
                // 模拟延迟
                Thread.sleep(r.nextInt(1000));

                // 当队列满时阻塞等待
                while (sharedQueue.size() == SIZE) {
                    synchronized (sharedQueue) {
                        System.out.println(&quot;Queue is full, producer &quot; + Thread.currentThread().getId()
                                + &quot; is waiting, size：&quot; + sharedQueue.size());
                        sharedQueue.wait();
                    }
                }

                // 队列不满时持续创造新元素
                synchronized (sharedQueue) {
                    // 生产数据
                    data = count.incrementAndGet();
                    sharedQueue.add(data);

                    System.out.println(&quot;producer create data:&quot; + data + &quot;, size：&quot; + sharedQueue.size());
                    sharedQueue.notifyAll();
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupted();
        }
    }

    public void stop() {
        isRunning = false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;消费者：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import java.util.Random;
import java.util.Vector;

public class Consumer implements Runnable {

    // 公共资源
    private final Vector sharedQueue;

    public Consumer(Vector sharedQueue) {
        this.sharedQueue = sharedQueue;
    }

    @Override
    public void run() {

        Random r = new Random();

        System.out.println(&quot;start consumer id = &quot; + Thread.currentThread().getId());
        try {
            while (true) {
                // 模拟延迟
                Thread.sleep(r.nextInt(1000));

                // 当队列空时阻塞等待
                while (sharedQueue.isEmpty()) {
                    synchronized (sharedQueue) {
                        System.out.println(&quot;Queue is empty, consumer &quot; + Thread.currentThread().getId()
                                + &quot; is waiting, size：&quot; + sharedQueue.size());
                        sharedQueue.wait();
                    }
                }
                // 队列不空时持续消费元素
                synchronized (sharedQueue) {
                    System.out.println(&quot;consumer consume data：&quot; + sharedQueue.remove(0) + &quot;, size：&quot; + sharedQueue.size());
                    sharedQueue.notifyAll();
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Main方法测试：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import java.util.Vector;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Test2 {


    public static void main(String[] args) throws InterruptedException {

        // 1.构建内存缓冲区
        Vector sharedQueue = new Vector();
        int size = 4;

        // 2.建立线程池和线程
        ExecutorService service = Executors.newCachedThreadPool();
        Producer prodThread1 = new Producer(sharedQueue, size);
        Producer prodThread2 = new Producer(sharedQueue, size);
        Producer prodThread3 = new Producer(sharedQueue, size);
        Consumer consThread1 = new Consumer(sharedQueue);
        Consumer consThread2 = new Consumer(sharedQueue);
        Consumer consThread3 = new Consumer(sharedQueue);
        service.execute(prodThread1);
        service.execute(prodThread2);
        service.execute(prodThread3);
        service.execute(consThread1);
        service.execute(consThread2);
        service.execute(consThread3);

        // 3.睡一会儿然后尝试停止生产者(结束循环)
        Thread.sleep(10 * 1000);
        prodThread1.stop();
        prodThread2.stop();
        prodThread3.stop();

        // 4.再睡一会儿关闭线程池
        Thread.sleep(3000);

        // 5.shutdown()等待任务执行完才中断线程(因为消费者一直在运行的，所以会发现程序无法结束)
        service.shutdown();


    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，上面原文中也说了可以使用阻塞队列来实现消费者和生产者。这就不用我们手动去写&lt;code&gt;wait/notify&lt;/code&gt;的代码了，会简单一丢丢。可以参考：&lt;/p&gt;
&lt;h2 id=&quot;四算法1&quot;&gt;四、算法[1]&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我现在需要实现一个栈，这个栈除了可以进行普通的push、pop操作以外，还可以进行getMin的操作，getMin方法被调用后，会返回当前栈的最小值，你会怎么做呢？你可以假设栈里面存的都是int整数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用一个min变量来记住最小值，每次push的时候，看看是否需要更新min。
&lt;ul&gt;&lt;li&gt;如果被pop出去的是min，第二次pop的时候，只能遍历一下栈内元素，重新找到最小值。&lt;/li&gt;
&lt;li&gt;总结：pop的时间复杂度是O(n)，push是O(1),空间是O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;辅助栈&lt;/strong&gt;来存储最小值。如果当前要push的值比辅助栈的min值要小，那在辅助栈push的值是最小值
&lt;ul&gt;&lt;li&gt;总结：push和pop的时间复杂度都是O(1)，空间是O(n)。典型以空间换时间的例子。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import java.util.ArrayList;
import java.util.List;

public class MinStack {

    private List&amp;lt;Integer&amp;gt; data = new ArrayList&amp;lt;Integer&amp;gt;();
    private List&amp;lt;Integer&amp;gt; mins = new ArrayList&amp;lt;Integer&amp;gt;();

    public void push(int num) {
        data.add(num);
        if (mins.size() == 0) {
            // 初始化mins
            mins.add(num);
        } else {
            // 辅助栈mins每次push当时最小值
            int min = getMin();
            if (num &amp;gt;= min) {
                mins.add(min);
            } else {
                mins.add(num);
            }
        }
    }

    public int pop() {
        // 栈空，异常，返回-1
        if (data.size() == 0) {
            return -1;
        }
        // pop时两栈同步pop
        mins.remove(mins.size() - 1);
        return data.remove(data.size() - 1);
    }

    public int getMin() {
        // 栈空，异常，返回-1
        if (mins.size() == 0) {
            return -1;
        }
        // 返回mins栈顶元素
        return mins.get(mins.size() - 1);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续优化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;栈为空的时候，返回-1很可能会带来歧义(万一人家push进去的值就有-1呢？)，这边我们可以使用Java Exception来进行优化&lt;/li&gt;
&lt;li&gt;算法的空间优化：上面的代码我们可以发现：data栈和mins栈的元素个数总是相等的，mins栈中存储几乎都是最小的值(此部分是重复的!)
&lt;ul&gt;&lt;li&gt;所以我们可以这样做：当push的时候，如果比min栈的值要小的，才放进mins栈。同理，当pop的时候，如果pop的值是mins的最小值，mins才出栈，否则mins不出栈！&lt;/li&gt;
&lt;li&gt;上述做法可以一定避免mins辅助栈有相同的元素！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，如果一直push的值是最小值，那我们的mins辅助栈还是会有大量的重复元素，此时我们可以使用&lt;strong&gt;索引&lt;/strong&gt;(mins辅助栈存储的是最小值索引，非具体的值)！&lt;/p&gt;
&lt;p&gt;最终代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import java.util.ArrayList;
import java.util.List;


public class MinStack {

    private List&amp;lt;Integer&amp;gt; data = new ArrayList&amp;lt;Integer&amp;gt;();
    private List&amp;lt;Integer&amp;gt; mins = new ArrayList&amp;lt;Integer&amp;gt;();

    public void push(int num) throws Exception {
        data.add(num);
        if(mins.size() == 0) {
            // 初始化mins
            mins.add(0);
        } else {
            // 辅助栈mins push最小值的索引
            int min = getMin();
            if (num &amp;lt; min) {
                mins.add(data.size() - 1);
            }
        }
    }

    public int pop() throws Exception {
        // 栈空，抛出异常
        if(data.size() == 0) {
            throw new Exception(&quot;栈为空&quot;);
        }
        // pop时先获取索引
        int popIndex = data.size() - 1;
        // 获取mins栈顶元素，它是最小值索引
        int minIndex = mins.get(mins.size() - 1);
        // 如果pop出去的索引就是最小值索引，mins才出栈
        if(popIndex == minIndex) {
            mins.remove(mins.size() - 1);
        }
        return data.remove(data.size() - 1);
    }

    public int getMin() throws Exception {
        // 栈空，抛出异常
        if(data.size() == 0) {
            throw new Exception(&quot;栈为空&quot;);
        }
        // 获取mins栈顶元素，它是最小值索引
        int minIndex = mins.get(mins.size() - 1);
        return data.get(minIndex);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;h2 id=&quot;五多线程下的hashmap&quot;&gt;五、多线程下的HashMap&lt;/h2&gt;
&lt;p&gt;众所周知，HashMap不是一个线程安全的类。但有可能在面试的时候会被问到：如果在多线程环境下使用HashMap会有什么现象发生呢？？&lt;/p&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;put()&lt;/code&gt;的时候导致的多线程数据不一致(丢失数据)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resize()&lt;/code&gt;操作会导致环形链表
&lt;ul&gt;&lt;li&gt;jdk1.8已解决环链的问题(声明两对指针，维护两个连链表)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;fail-fast机制，对当前HashMap同时进行删除/修改会抛出ConcurrentModificationException异常&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;h2 id=&quot;六spring和springboot区别&quot;&gt;六、Spring和Springboot区别&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一、SpringBoot是能够创建出独立的Spring应用程序的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;二、简化Spring配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Spring由于其繁琐的配置，一度被人成为“配置地狱”，各种XML、Annotation配置，让人眼花缭乱，而且如果出错了也很难找出原因。&lt;/li&gt;
&lt;li&gt;Spring Boot项目就是为了解决配置繁琐的问题，最大化的实现convention over configuration(&lt;strong&gt;约定大于配置&lt;/strong&gt;)。
&lt;ul&gt;&lt;li&gt;提供一系列的依赖包来把其它一些工作做成开箱即用其内置一个’Starter POM’，对项目构建进行了&lt;strong&gt;高度封装&lt;/strong&gt;，最大化简化项目构建的配置。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;三、嵌入式Tomcat，Jetty容器，无需部署WAR包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;七g1和cms&quot;&gt;七、G1和CMS&lt;/h2&gt;
&lt;p&gt;G1收集器的设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;G1是一个有&lt;strong&gt;整理内存&lt;/strong&gt;过程的垃圾收集器，&lt;strong&gt;不会产生很多内存碎片&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;CMS采用的是标记清除垃圾回收算法，可能会产生不少的内存碎片&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;G1的Stop The World(STW)更可控，G1在停顿时间上添加了&lt;strong&gt;预测机制&lt;/strong&gt;，用户可以&lt;strong&gt;指定期望停顿时间&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;拓展阅读：&lt;/p&gt;
&lt;h2 id=&quot;八海量数据解决方案&quot;&gt;八、海量数据解决方案&lt;/h2&gt;
&lt;p&gt;海量数据的处理也是一个经常考的知识点，无论在面试还是在笔试中都是比较常见的。有幸读了下面的文章，摘录了一些解决海量数据的思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bloom filter布隆过滤器
&lt;ul&gt;&lt;li&gt;适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Hashing
&lt;ul&gt;&lt;li&gt;适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;bit-map
&lt;ul&gt;&lt;li&gt;适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;堆
&lt;ul&gt;&lt;li&gt;适用范围：海量数据前n大，并且n比较小，堆可以放入内存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;双层桶划分----其实本质上就是【分而治之】的思想，重在“分”的技巧上！
&lt;ul&gt;&lt;li&gt;适用范围：第k大，中位数，不重复或重复的数字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;数据库索引
&lt;ul&gt;&lt;li&gt;适用范围：大数据量的增删改查&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;倒排索引(Inverted index)
&lt;ul&gt;&lt;li&gt;适用范围：搜索引擎，关键字查询&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;外排序
&lt;ul&gt;&lt;li&gt;适用范围：大数据的排序，去重&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;trie树
&lt;ul&gt;&lt;li&gt;适用范围：数据量大，重复多，但是数据种类小可以放入内存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分布式处理 mapreduce
&lt;ul&gt;&lt;li&gt;适用范围：数据量大，但是数据种类小可以放入内存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;详细可参考原文：&lt;/p&gt;
&lt;h2 id=&quot;九幂等性&quot;&gt;九、幂等性&lt;/h2&gt;
&lt;h3 id=&quot;http幂等性&quot;&gt;9.1HTTP幂等性&lt;/h3&gt;
&lt;p&gt;昨天去做了一套笔试题，经典的HTTP中&lt;code&gt;get/post&lt;/code&gt;的区别。今天回来搜了一下，发现跟之前的理解&lt;strong&gt;有点出入&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果一个人一开始就做Web开发，很可能&lt;strong&gt;把HTML对HTTP协议的使用方式，当成HTTP协议的唯一的合理使用方式。从而犯了以偏概全的错误&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单纯以HTTP协议规范来说，可能我们之前总结出的&lt;code&gt;GET/POST&lt;/code&gt;区别就没用了。(但通读完整篇文章，&lt;strong&gt;我个人认为&lt;/strong&gt;：如果面试中有&lt;code&gt;GET/POST&lt;/code&gt;区别，还是默认以Web开发场景下来回答较好，这也许是面试官想要的答案)&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;其中也学习到了幂等性这么一个概念，于是也做做笔记吧~~~&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &amp;gt; 0 identical requests is the same as for a single request.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从定义上看，HTTP方法的幂等性是&lt;strong&gt;指一次和多次请求某一个资源应该具有同样的副作用&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里简单说一下“副作用”的意思：指当你发送完一个请求以后，&lt;strong&gt;网站上的资源状态没有发生修改&lt;/strong&gt;，即认为这个请求是无副作用的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HTTP的&lt;code&gt;GET/POST/DELETE/PUT&lt;/code&gt;方法幂等的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;是幂等的，无副作用
&lt;ul&gt;&lt;li&gt;比如我想要获得订单ID为2的订单：&lt;code&gt;http://localhost/order/2&lt;/code&gt;，使用&lt;code&gt;GET&lt;/code&gt;&lt;strong&gt;多次获取&lt;/strong&gt;，这个ID为2的订单(资源)是&lt;strong&gt;不会发生变化&lt;/strong&gt;的！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELETE/PUT&lt;/code&gt;是幂等的，有副作用
&lt;ul&gt;&lt;li&gt;比如我想要删除或者更新ID为2的订单：&lt;code&gt;http://localhost/order/2&lt;/code&gt;，使用&lt;code&gt;PUT/DELETE&lt;/code&gt;&lt;strong&gt;多次请求&lt;/strong&gt;，这个ID为2的订单(资源)&lt;strong&gt;只会发生一次变化&lt;/strong&gt;(是有副作用的)！但继续多次刷新请求，&lt;strong&gt;订单ID为2的最终状态都是一致的&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt;是非幂等的，有副作用的
&lt;ul&gt;&lt;li&gt;比如我想要创建一个名称叫3y的订单：&lt;code&gt;http://localhost/order&lt;/code&gt;，使用&lt;code&gt;POST&lt;/code&gt;多次请求，此时可能就会&lt;strong&gt;创建多个名称为3y的订单&lt;/strong&gt;,这个订单(资源)是会多次变化的，&lt;strong&gt;每次请求的资源状态都会变化&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;题外话：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;HTTP协议本身是一种&lt;strong&gt;面向资源的应用层协议&lt;/strong&gt;，但对HTTP协议的使用实际上存在着两种不同的方式：一种是&lt;strong&gt;RESTful&lt;/strong&gt;的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定(&lt;strong&gt;充分利用了HTTP的方法&lt;/strong&gt;)；另一种&lt;strong&gt;是SOA的&lt;/strong&gt;，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;h3 id=&quot;接口幂等性&quot;&gt;9.2接口幂等性&lt;/h3&gt;
&lt;p&gt;在查阅资料的时候，可以发现很多博客都讲了&lt;strong&gt;接口的幂等性&lt;/strong&gt;。从上面我们也可以看出，&lt;code&gt;POST&lt;/code&gt;方法是非幂等的。但我们可以通过一些手段来令&lt;code&gt;POST&lt;/code&gt;方法的接口变成是幂等的。&lt;/p&gt;
&lt;p&gt;说了那么多，那接口设计成幂等的好处是什么？？？？&lt;/p&gt;
&lt;p&gt;举个例子说一下非幂等的坏处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3y大一的时候是要抢体育课的，但学校的抢课系统做得贼烂(延迟很高)。我想要抢到课，就开了10多个Chrome标签页去抢(即使某个Chrome标签页崩了，我还有另外的Chrome标签页是可用的)。我想抢到乒乓球或者羽毛球。&lt;/li&gt;
&lt;li&gt;抢课时间一到，我就轮着点击我要想抢的乒乓球或者羽毛球。如果系统设计得不好，这个请求是非幂等的(或者说事务控制得不好)，我手速足够快&amp;amp;&amp;amp;网络足够好，那我很可能抢到了多次乒乓球或者羽毛球的课程了。(这是不合理的，一个人只能选一门课，而我抢到了多门或者多次重复的课)&lt;/li&gt;
&lt;li&gt;涉及到商城的应用场景可能就是：用户下了多个重复的订单了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果我的抢课接口是幂等的话，那就不会出现这个问题了。因为幂等是多次请求某一个资源应该具有&lt;strong&gt;同样的&lt;/strong&gt;副作用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在数据库后台最多只会有一条记录，不存在抢到多门课的现象了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说白了，设计幂等性接口就是为了&lt;strong&gt;防止重复提交的&lt;/strong&gt;(数据库出现多条重复的数据)！&lt;/p&gt;
&lt;p&gt;网上有博主也分享了几条常见解决重复提交的方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;同步锁（单线程，在集群可能会失效）&lt;/li&gt;
&lt;li&gt;分布式锁如redis（实现复杂）&lt;/li&gt;
&lt;li&gt;业务字段加唯一约束（简单）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;令牌表+唯一约束（简单推荐）&lt;/strong&gt;----&amp;gt;实现幂等接口的一种手段&lt;/li&gt;
&lt;li&gt;mysql的insert ignore或者on duplicate key update（简单）&lt;/li&gt;
&lt;li&gt;共享锁+普通索引（简单）&lt;/li&gt;
&lt;li&gt;利用MQ或者Redis扩展（排队）&lt;/li&gt;
&lt;li&gt;其他方案如多版本控制MVCC 乐观锁 悲观锁 状态机等。。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;如果以上有理解错的地方，或者说有更好的理解方式，希望大家不吝在评论区下留言。共同进步！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果想看更多的&lt;strong&gt;原创&lt;/strong&gt;技术文章，欢迎大家关注我的&lt;strong&gt;微信公众号:Java3y&lt;/strong&gt;。Java技术&lt;strong&gt;群讨论&lt;/strong&gt;：742919422。公众号还有&lt;strong&gt;海量的视频资源&lt;/strong&gt;哦，关注即可免费领取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能感兴趣的链接：&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 06:23:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<og:description>前言 只有光头才能变强 Redis目前还在看，今天来分享一下我在秋招看过(遇到)的一些面试题(相对比较常见的) 0、final关键字 简要说一下final关键字，final可以用来修饰什么？ 这题我是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/9836396.html</dc:identifier>
</item>
<item>
<title>传统线程互斥技术—synchronized - 程序员私房菜</title>
<link>http://www.cnblogs.com/eson15/p/9836310.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eson15/p/9836310.html</guid>
<description>&lt;p&gt;在多个线程同时操作相同资源的时候，就会遇到并发的问题，如银行转账啊、售票系统啊等。为了避免这些问题的出现，我们可以使用synchronized关键字来解决，下面针对synchronized常见的用法做一个总结。首先写一个存在并发问题的程序，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TraditionalThreadSynchronized {

    public static void main(String[] args) {
        //在静态方法中不能new内部类的实例对象
        //private Outputer outputer = new Outputer();
        new TraditionalThreadSynchronized().init();
    }
    
    private void init() {
        final Outputer outputer = new Outputer();
        //线程1打印：duoxiancheng
        new Thread(new Runnable() {         
            @Override
            public void run() {
                while(true) {
                    try {
                        Thread.sleep(5);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    outputer.output1(&quot;duoxiancheng&quot;);
                }
                
            }
        }).start();;
        
        //线程2打印：eson15
        new Thread(new Runnable() {         
            @Override
            public void run() {
                while(true) {
                    try {
                        Thread.sleep(5);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    outputer.output1(&quot;eson15&quot;);
                }
                
            }
        }).start();;
    }
    
    static class Outputer {
        //自定义一个字符串打印方法，一个个字符的打印
        public void output1(String name) {
            int len = name.length();
            for(int i = 0; i &amp;lt; len; i++) {
                System.out.print(name.charAt(i));
            }
            System.out.println(&quot;&quot;);     
        }       
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在内部类Outputer中定义了一个打印字符串的方法，一个字符一个字符的打印，这样比较容易直观的看出并发问题，因为字符顺序打乱了就说明出现问题了。然后在init方法中开启两个线程，一个线程打印“duoxiancheng”，另一个线程打印“eson15”。看一下运行结果：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;eson15duoxianche&lt;br/&gt;ng&lt;br/&gt;eson15&lt;br/&gt;duoxiancheng&lt;br/&gt;duoxiancheng&lt;br/&gt;eson15&lt;br/&gt;esduoxiancheng&lt;br/&gt;on15&lt;br/&gt;duoxiancheng&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;已经出现问题了，为了解决这个问题，可以使用synchronized同步代码块来对公共部分进行同步操作，但是需要给它一把锁，这把锁是一个对象，可以是任意一个对象，但是前提是，两个线程使用的必须是同一个对象锁才可以，这很好理解。那么下面在&lt;code&gt;output1()&lt;/code&gt;方法中加入synchronized代码块：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static class Outputer {
    private String token = &quot;&quot;; //定义一个锁
    public void output1(String name) {
        synchronized(token) //任何一个对象都可以作为参数，但是该对象对于两个线程来说是同一个才行
        //如果用name就不行了，因为不同的线程进来name是不一样的，不是同一个name
        {
            int len = name.length();
            for(int i = 0; i &amp;lt; len; i++) {
                System.out.print(name.charAt(i));
            }
            System.out.println(&quot;&quot;);     
        }
    }
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过上面的改造，线程安全问题就基本解决了，但是还可以再往下引申，如果在方法上加synchronized关键字的话，那么这个同步锁是什么呢？我们在Outputer类中再写一个&lt;code&gt;output2()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static class Outputer {
    private String token = &quot;&quot;; //定义一个锁
    public void output1(String name) {
        synchronized(token) //任何一个对象都可以作为参数，但是该对象对于两个线程来说是同一个才行
        {
            int len = name.length();
            for(int i = 0; i &amp;lt; len; i++) {
                System.out.print(name.charAt(i));
            }
            System.out.println(&quot;&quot;);     
        }
    }   
    
    public synchronized void output2(String name) {
        
        int len = name.length();
        for(int i = 0; i &amp;lt; len; i++) {
            System.out.print(name.charAt(i));
        }
        System.out.println(&quot;&quot;);     
    }   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法内部实现逻辑一模一样，唯一不同的就是synchronized加在了方法上，那么我们让init()方法中的两个线程中，一个调用&lt;code&gt;output1(String name)&lt;/code&gt;方法，另一个调用&lt;code&gt;output2(String name)&lt;/code&gt;方法，从结果中能看出，线程安全问题又出现了。产生问题的原因不难发现：现在两个方法都加了synchronized，但是两个线程在调用两个不同的方法还是出现了问题，也就是说，还是各玩各的……那么问题就出在这个锁上，说明两者并没有使用同一把锁！&lt;br/&gt;如果我们把&lt;code&gt;output1()&lt;/code&gt;方法中synchronized中的token改成this，再运行就没问题了，这说明一点：&lt;strong&gt;synchronized关键字修饰方法的时候，同步锁是this，即等效于代码块&lt;/strong&gt;&lt;code&gt;synchronized(this) {...}&lt;/code&gt;。&lt;br/&gt;再继续往下引申，现在在Outputer类中再写一个静态方法&lt;code&gt;output3(String name)&lt;/code&gt;，并且也让synchronized去修饰这个静态方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static class Outputer {
    private String token = &quot;&quot;; //定义一个锁
    public void output1(String name) {
        synchronized(token) //任何一个对象都可以作为参数，但是该对象对于两个线程来说是同一个才行
        {
            int len = name.length();
            for(int i = 0; i &amp;lt; len; i++) {
                System.out.print(name.charAt(i));
            }
            System.out.println(&quot;&quot;);     
        }
    }   
    
    public static synchronized void output3(String name) {
        
        int len = name.length();
        for(int i = 0; i &amp;lt; len; i++) {
            System.out.print(name.charAt(i));
        }
        System.out.println(&quot;&quot;);     
        }   
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在init()方法中一个线程调用&lt;code&gt;output1()&lt;/code&gt;方法，另一个线程调用&lt;code&gt;output3()&lt;/code&gt;方法。毫无疑问，肯定又会出现线程安全问题。但是如何解决呢？因为static方法在类加载的时候就加载了，所以这个锁应该是类的字节码对象。那么将token改为&lt;code&gt;Outputer.class&lt;/code&gt;就解决问题了，这说明一点：&lt;strong&gt;synchronized关键字修饰static方法的时候，同步锁是该类的字节码对象，即等效于代码块&lt;/strong&gt;&lt;code&gt;synchronized(classname.class) {...}&lt;/code&gt;。&lt;br/&gt;　　&lt;br/&gt;最后再总结一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;同步代码块的锁是任意对象&lt;/strong&gt;。只要不同的线程都执行同一个同步代码块的时候，这个锁随便设。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步函数的锁是固定的this&lt;/strong&gt;。当需要和同步函数中的逻辑实行同步的时候，代码块中的锁必须为this。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态同步函数的锁是该函数所属类的字节码文件对象&lt;/strong&gt;。该对象可以用&lt;code&gt;this.getClass()&lt;/code&gt;方法获取，也可以使用 &lt;code&gt;当前类名.class&lt;/code&gt; 表示。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
<pubDate>Tue, 23 Oct 2018 06:07:00 +0000</pubDate>
<dc:creator>程序员私房菜</dc:creator>
<og:description>在多个线程同时操作相同资源的时候，就会遇到并发的问题，如银行转账啊、售票系统啊等。为了避免这些问题的出现，我们可以使用synchronized关键字来解决，下面针对synchronized常见的用法做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eson15/p/9836310.html</dc:identifier>
</item>
</channel>
</rss>