<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python安装BeautifulSoup库解析HTML页面 - 小小怪l</title>
<link>http://www.cnblogs.com/liuduanwu/p/9226928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuduanwu/p/9226928.html</guid>
<description>&lt;p&gt; BeautifulSoup三大特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;BeautifulSoup提供了一些简单的方法和Pythonic成语，用于浏览，搜索和修改解析树：一个解剖文档并提取所需内容的工具包。&lt;/span&gt;&lt;span&gt;编写应用程序并不需要太多代码&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;BeautifulSoup自动将传入文档转换为Unicode和传出文档为UTF-8。&lt;/span&gt;&lt;span&gt;您不必考虑编码，除非文档未指定编码，而美丽汤不能检测到编码。&lt;/span&gt;&lt;span&gt;然后您只需指定原始编码。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Beautiful Soup位于流行的Python解析器（如&lt;/span&gt;&lt;a href=&quot;http://lxml.de/&quot;&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;/a&gt;&lt;span&gt;和&lt;/span&gt;&lt;a href=&quot;http://code.google.com/p/html5lib/&quot;&gt;&lt;span&gt;html5lib）之上&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，允许您尝试不同的解析策略或交易速度以获得灵活性&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下载链接：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;https://share.weiyun.com/5f6ZawU&quot; target=&quot;_blank&quot;&gt;https://share.weiyun.com/5f6ZawU&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; （密码：fODC）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;安装BeautifulSoup：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;分以下几步：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　1.解压BeautifulSoup的安装包到python的安装目录，如下图&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318102/201806/1318102-20180625233739552-376521802.png&quot; alt=&quot;&quot; width=&quot;769&quot; height=&quot;492&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.在cmd中cd到BeautifulSoup的安装目录输入python  setup.py install 回车会出现如下图的加载：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318102/201806/1318102-20180625234206264-1066046207.png&quot; alt=&quot;&quot; width=&quot;771&quot; height=&quot;472&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候就证明安装成功了，还有最后一步。&lt;/p&gt;
&lt;p&gt;3.进入python-&amp;gt;Lib-&amp;gt;site-packages将bs4文件夹复制到Lib文件夹下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318102/201806/1318102-20180625234641154-1110333788.png&quot; alt=&quot;&quot; width=&quot;772&quot; height=&quot;278&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将python安装目录下的Tools-&amp;gt;scripts-&amp;gt;2to3.py文件复制到Lib下，这一步同上&lt;/p&gt;
&lt;p&gt;最后在cmd中cd到lib目录，然后写入python 2to3.py bs4 -w如下图即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318102/201806/1318102-20180625235021946-2029035446.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;491&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在eclipse上就可以正常的导入BeautifulSoup库了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318102/201806/1318102-20180625235237619-2002947997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jun 2018 15:54:00 +0000</pubDate>
<dc:creator>小小怪l</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuduanwu/p/9226928.html</dc:identifier>
</item>
<item>
<title>常用数字信号的产生（C实现）-均匀分布&amp;正态分布 - ziphe</title>
<link>http://www.cnblogs.com/ziphe-from-teacher-chen/p/9227000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ziphe-from-teacher-chen/p/9227000.html</guid>
<description>&lt;p&gt;小白博主开始学DSP之路，为了激励自己能坚持下去，写一系列博客来记录下来，也欢迎与大家一起讨论。介于我能力所限，这里学习目标定为，学习一个基础知识，写一个C语言程序实现，&lt;/p&gt;
&lt;p&gt;最后会形成一个C的函数库，方便调用。对于学习的知识内容，不会面面覆盖，一般只学习一种实现方法，较少涉及复杂数学理论的证明，但保证有理论可以证明，可以查阅数学相关知识自寻证明。&lt;/p&gt;
&lt;p&gt;对于所有的C程序，我会调通，供大家参考讨论，完整程序我放到github上，文章中会给出关键代码，程序只使用C语言，因为涉及数学与实现过程，C虽然繁琐，但是易于理解。&lt;/p&gt;
&lt;p&gt;这里从数字信号的产生做为出发点，欢迎大家关注，一起学习！&lt;/p&gt;
&lt;p&gt;这是第一篇博客，介绍均匀分布的随机数的产生和正态分布随机数的产生。&lt;/p&gt;
&lt;p&gt;一、均匀分布随机数产生方法简介&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/890898/201806/890898-20180625225433081-224167540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;混合同余法，产生（a,b）区间的均匀分布随机数
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a:区间下界    b:区间上界        *seed:随机数种子&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; uniform(&lt;span&gt;double&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt; b,&lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;*&lt;span&gt; seed)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;double&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     *seed = &lt;span&gt;2045&lt;/span&gt; * (*seed) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     *seed = *seed - (*seed/&lt;span&gt;1048576&lt;/span&gt;)*&lt;span&gt;1048576&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     t = (*seed)/&lt;span&gt;1048576.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     t = a + (b - a) *&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、正态分布随机数产生方法简介&lt;/p&gt;
&lt;p&gt;　　　　        &lt;img src=&quot;https://images2018.cnblogs.com/blog/890898/201806/890898-20180625233225592-851136112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;产生均值mean方差sigma的高斯分布随机数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uniform.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; gauss(&lt;span&gt;double&lt;/span&gt; mean,&lt;span&gt;double&lt;/span&gt; sigma,&lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;*&lt;span&gt; seed)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;double&lt;/span&gt;&lt;span&gt; x,y;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(x=&lt;span&gt;0&lt;/span&gt;,i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;12&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         x = x + uniform(&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;,seed);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     x = x - &lt;span&gt;6.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     y = mean + x *&lt;span&gt; sigma;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整代码参考：https://github.com/HeYingnan/dsp&lt;/p&gt;


</description>
<pubDate>Mon, 25 Jun 2018 15:53:00 +0000</pubDate>
<dc:creator>ziphe</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ziphe-from-teacher-chen/p/9227000.html</dc:identifier>
</item>
<item>
<title>网络编程入坑基础-BIO总结 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9226990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9226990.html</guid>
<description>&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《Java I/O》 -- 这本书没有翻译版，需要自己啃一下。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;《Java I/O》这本书主要介绍了IO和NIO的相关API使用，但是NIO部分并不是太专业，同系列的动物书《Java NIO》相对比较详细并且有译本，因此看本书的时候，我直接跳过了NIO部分。&lt;/p&gt;

&lt;p&gt;IO实际上是INPUT/OUTPUT(输入/输出)的简写，IO是任何计算机操作系统或编程语言的基础。Java中，IO相关的类库主要分布在java.io和java.nio两个包中。&lt;/p&gt;
&lt;h2 id=&quot;io分类&quot;&gt;IO分类&lt;/h2&gt;
&lt;p&gt;从目前来看，IO主要分为BIO、NIO和AIO。&lt;/p&gt;
&lt;p&gt;BIO，一般又称为OIO(Old IO)，意为Blocking-IO(阻塞IO)，在此参考书中称为Basic-IO(基础IO)。这篇文章主要正是针对BIO进行总结。BIO的核心API都是围绕InputStream(输入流)和OutputStream(输出流)，Reader和Writer，输入流和输出流都是&lt;strong&gt;面向字节&lt;/strong&gt;的，而Reader和Writer可以说是面向字符的。&lt;/p&gt;
&lt;p&gt;NIO，一般又叫New IO，意为Non-Blocking IO，即非阻塞IO，核心组件是Buffer、Channel、Selector。&lt;/p&gt;
&lt;p&gt;AIO，意为Asynchronous IO，即异步IO，基于NIO引入了新的异步通道的概念，主要提供了异步文件通道和异步套接字通道的实现。&lt;/p&gt;
&lt;p&gt;当然，这里只是简单说一下三种IO的概念，迟点读完了《Unix网络编程》后再做一次详细的总结。&lt;/p&gt;
&lt;h2 id=&quot;什么是流stream&quot;&gt;什么是流(Stream)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;流(Stream)是一个不定长度的有序的字节序列&lt;/strong&gt;(个人认为，这个是最准确和最精炼的流的定义)。Java中对流进行了抽象，输入流的抽象父类是java.io.InputStream(下面叫输入流)，输出流的抽象父类是java.io.OutputStream(下面叫输出流)，这两个父类定义了从字节来源读取字节的方法以及向目标源输出字节的统一方法，这样的好处是我们不需要刻意去知道流的输入源或者流的输出目的地到底是什么。而具体的输入来源或者输出目的地分别由InputStream或者OutputStream的具体子类确定。&lt;/p&gt;
&lt;p&gt;另外，在BIO里面，是没有&quot;字符流&quot;的概念(说实话，至少从我目前看到的资料来看没有出现过相关字眼，除了一些博客文章之外)，但是有提供了java.io.Reader(下面叫Reader)用于读取字符，java.io.Writer(下面叫Writer)用于写入字符。实际上在需要从外部来源读取字符或者输出字符到外部目标的时候，Reader是从字节源读取字节，再把读取到的字节数组转换为字符数组；Writer是把字符数组转换为字节数组，再输出到外部目标里面，最常见的是FileReader和FileWriter。在上述这种情况下，Reader和Writer都是使用了十分典型的装饰器模式，下面就以Reader和Writer对文件的操作为例，贴点源码再画个图说明这个问题。&lt;/p&gt;
&lt;p&gt;先看一下FileReader：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FileReader &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; InputStreamReader {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; FileReader(String fileName) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; FileNotFoundException {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileInputStream(fileName));
    }
    &lt;span class=&quot;co&quot;&gt;//暂时忽略其他代码&lt;/span&gt;
}


&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; InputStreamReader &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Reader {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; StreamDecoder sd;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; InputStreamReader(InputStream in, String charsetName) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; UnsupportedEncodingException {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(in);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (charsetName == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NullPointerException(&lt;span class=&quot;st&quot;&gt;&quot;charsetName&quot;&lt;/span&gt;);
        sd = StreamDecoder.&lt;span class=&quot;fu&quot;&gt;forInputStreamReader&lt;/span&gt;(in, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, charsetName);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;见InputStreamReader里面实例化的StreamDecoder实例，就是用于把byte数组转换为char数组，而byte数组来源于FileInputStream实例对应的文件中。&lt;/p&gt;
&lt;p&gt;再看一下FileWriter:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FileWriter &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; OutputStreamWriter {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; FileWriter(String fileName) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileOutputStream(fileName));
    }
    &lt;span class=&quot;co&quot;&gt;//暂时忽略其他代码&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; OutputStreamWriter &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Writer {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; StreamEncoder se;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; OutputStreamWriter(OutputStream out, String charsetName) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; UnsupportedEncodingException {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(out);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (charsetName == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NullPointerException(&lt;span class=&quot;st&quot;&gt;&quot;charsetName&quot;&lt;/span&gt;);
        se = StreamEncoder.&lt;span class=&quot;fu&quot;&gt;forOutputStreamWriter&lt;/span&gt;(out, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, charsetName);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;见OutputStreamWriter里面实例化的StreamEncoder实例，就是用于把char数组转换为byte数组，而byte数组存放在FileOutputStream实例中最终用于输出到目标文件。&lt;/p&gt;
&lt;p&gt;简单来看，大致就是下图的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/throwable/1241978/o_101.png&quot; alt=&quot;101.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，像一般只用于内存态的CharArrayWriter或者CharArrayReader等等，它们内部就维护着一个char数组，写入和输出的数据都是基于char数组。&lt;/p&gt;

&lt;h2 id=&quot;inputstream&quot;&gt;InputStream&lt;/h2&gt;
&lt;p&gt;java.io.InputStream是所有输入流的抽象父类，提供三个基本方法用于从流中数据字节。另外，它还提供关闭流、检查剩余可以读取的字节序列长度、跳过指定长度、标记流中的位置并重新设置当前读取位置、检查是否支持标记和重置。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//读取单字节数据，返回的是&quot;无符号的byte&quot;类型值[0,255]，因为不存在无符号byte类型，所以返回值是int&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;( ) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;co&quot;&gt;//读取字节数组到指定的byte数组中&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt; b[]) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;co&quot;&gt;//读取字节数组到指定的byte数组中，可以指定偏移量和总长度&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt; b[], &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; off, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;co&quot;&gt;//跳过指定长度的字节序列&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;skip&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException 
&lt;span class=&quot;co&quot;&gt;//返回剩余可读取的字节序列的长度&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;available&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;co&quot;&gt;//关闭输入流&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;co&quot;&gt;//标记&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;mark&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; readlimit)
&lt;span class=&quot;co&quot;&gt;//重置&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;reset&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;co&quot;&gt;//是否支持标记和重置&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;markSupported&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;读取&quot;&gt;读取&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;public abstract int read( )&lt;/code&gt;是抽象方法，必须由子类实现，它用于读取单字节数据，返回的是&quot;无符号的byte&quot;类型值[0,255](读取到的字节数值)，因为Java中不存在无符号byte类型，所以返回值是int。当读取到流的尾部，返回-1。相关的转换公式伪代码大致是：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt; b = xxxx;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = (b &amp;gt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) ? b : &lt;span class=&quot;dv&quot;&gt;256&lt;/span&gt; + b;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;public int read(byte b[], int off, int len)&lt;/code&gt;用于读取连续的数据块到一个指定的字节数组中，off是用于指定数据写入目标byte数组的起始偏移量，len是用于指定读取字节的最大长度(数量)，返回值是当前读取到的字节数值(注意范围是[0,255])。当读取到流的尾部，返回-1。&lt;strong&gt;注意此方法的返回值是读取到的字节序列的长度，有可能是目标字节数组的总长度，也有可能是来源的字节序列的总长度，这是因为预先建立的目标字节数组有可能不能容纳来源中的所有字节。&lt;/strong&gt;变体方法&lt;code&gt;public int read(byte b[])&lt;/code&gt;实际上是：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt; b[]) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(b, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, b.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;read方法都是阻塞方法，直到有可读字节、到达流的尾部返回-1或者抛出异常。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里举个栗子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        ByteArrayInputStream inputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayInputStream(&lt;span class=&quot;st&quot;&gt;&quot;abcdefg&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] array = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
        inputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(array, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(array, &lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/throwable/1241978/o_102.png&quot; alt=&quot;102.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里为了说明，偏移量off是指(将会被写入)目标byte数组写入数据时候的数组下标，读取字节序列的最大长度len是指将会读取到的字节序列的总长度，但是需要注意，读取字节序列的时候是从字节序列的首位开始读取(很容易误认为从off开始读取，其实off是控制写入的偏移量)。因此上面程序执行后控制台打印字符串：ab。&lt;/p&gt;
&lt;p&gt;值得注意的是InputStream的三个&lt;code&gt;read&lt;/code&gt;方法变体适用于它的所有子类。&lt;/p&gt;
&lt;h3 id=&quot;跳过&quot;&gt;跳过&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;public long skip(long bytesToSkip)&lt;/code&gt;用于指定跳过的字节序列长度，返回值是真正跳过的字节序列长度，有可能比指定的bytesToSkip小。遇到流的尾部，会直接返回-1。这个方法的作用是可以选择跳过一些不需要读取到内存的字节序列，以减少内存消耗。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{
        ByteArrayInputStream inputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayInputStream(&lt;span class=&quot;st&quot;&gt;&quot;abcdefg&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] array = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
        inputStream.&lt;span class=&quot;fu&quot;&gt;skip&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;);
        inputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(array,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, array.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(array,&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终输出：fg，也就是跳过了前面的5个字节。&lt;/p&gt;
&lt;h3 id=&quot;计算剩余可读字节序列长度&quot;&gt;计算剩余可读字节序列长度&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;public int available()&lt;/code&gt;方法用于返回在不阻塞的情况下可以读取的总字节序列长度，如果没有可读字节则返回0。这个方法使用在本地文件(例如读取磁盘文件数据的时候使用的FileInputStream)读取的时候返回的值是真实可信的，但是在使用网络流(例如套接字)则返回的值并不是真实的，因为网络流是非阻塞的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        ByteArrayInputStream inputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayInputStream(&lt;span class=&quot;st&quot;&gt;&quot;abcdefg&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; size = inputStream.&lt;span class=&quot;fu&quot;&gt;available&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] data = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[size];
        inputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(data);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(data, &lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后控制台输出：abcdefg。使用&lt;code&gt;available()&lt;/code&gt;方法可以提前预支需要写入的字节数组的长度，但是需要警惕该方法返回值是否真实，还有，是否有足够的内存初始化该长度的数组，否则有可能发生OOM。&lt;/p&gt;
&lt;h3 id=&quot;标记和重置&quot;&gt;标记和重置&lt;/h3&gt;
&lt;p&gt;并不是所有的InputStream子类都支持标记和重置，因此&lt;code&gt;public boolean markSupported()&lt;/code&gt;方法就是用于判断流实例是否支持标记和重置。如果&lt;code&gt;markSupported&lt;/code&gt;方法返回false而强制使用&lt;code&gt;mark&lt;/code&gt;或者&lt;code&gt;reset&lt;/code&gt;一般会抛出IOException。下面举个栗子说明一下怎么使用：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{
        ByteArrayInputStream inputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayInputStream(&lt;span class=&quot;st&quot;&gt;&quot;abcdefg&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] array = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
        &lt;span class=&quot;co&quot;&gt;//注意这里的readAheadLimit可以乱填,参考一下ByteArrayInputStream的源码&lt;/span&gt;
        inputStream.&lt;span class=&quot;fu&quot;&gt;mark&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10086&lt;/span&gt;);
        inputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(array,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;);
        inputStream.&lt;span class=&quot;fu&quot;&gt;reset&lt;/span&gt;();
        inputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(array,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(array,&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/throwable/1241978/o_103.png&quot; alt=&quot;103.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里用ByteArrayInputStream为例，pos总是指向字节数组中下一个需要读取的字节元素的下标，&lt;code&gt;mark()&lt;/code&gt;方法调用时候，pos的值被记录在mark变量中，而&lt;code&gt;reset()&lt;/code&gt;方法调用的时候，pos的值被重置为mark的值。上面的例子最终输出：abcdabcd。&lt;/p&gt;
&lt;h3 id=&quot;关闭&quot;&gt;关闭&lt;/h3&gt;
&lt;p&gt;输入流的关闭可以显式调用&lt;code&gt;close()&lt;/code&gt;方法，一般需要把关闭方法置于finally块中并且捕获其异常不进行异常抛出。关闭后的流不能再进行读取等操作，否则会抛出IOException。在Jdk1.7中引入了java.lang.AutoCloseable接口，实现了AutoCloseable接口的流可以使用try-resource的方式进行编码，这样就不需要显式关闭流。例如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; (FileInputStream inputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileInputStream(&lt;span class=&quot;st&quot;&gt;&quot;xxxx&quot;&lt;/span&gt;)){
    &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] buffer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
    inputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(buffer);
    &lt;span class=&quot;co&quot;&gt;//....&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;inputstream子类&quot;&gt;InputStream子类&lt;/h2&gt;
&lt;p&gt;InputStream的子类主要是用于区分不同的字节数据来源(或者直接叫数据源)。另外，InputStream的子类FilterInputStream使用了典型的装饰器模式，一般称这类流叫装饰(输入)流。常见的装饰流主要是FilterInputStream的子类，包括BufferedInputStream、PushbackInputStream等等(还有很多隐藏在sun包下)。下面最要挑几个常用的InputStream的子类来介绍一下使用方式。这里啰嗦再点一次：InputStream的三个&lt;code&gt;read&lt;/code&gt;方法变体适用于它的所有子类。&lt;/p&gt;
&lt;p&gt;下图是InputStream的主要子类，不包含sun包下隐藏的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/throwable/1241978/o_106.png&quot; alt=&quot;106.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面的分类只是按照个人的理解，并没有科学的根据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;废弃的子类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;StringBufferInputStream，本来是设计用于读取字符的，已过期，用StringReader替代。&lt;/li&gt;
&lt;li&gt;LineNumberInputStream，本来是设计用于读取字符并且附带行号记录的功能，已过期，用LineNumberReader替代。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;介质流：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ByteArrayInputStream，从byte数组中读取数据。&lt;/li&gt;
&lt;li&gt;FileInputStream，从本地磁盘文件中读取数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;装饰流：&lt;/strong&gt;&lt;br/&gt;ObjectInputStream和所有FilterInputStream的子类都是装饰输入流（装饰器模式的主角）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ObjectInputStream，可以用于读取对象，实际上是反序列化操作，但是对象类必须实现Serializable接口。&lt;/li&gt;
&lt;li&gt;PushbackInputStream，一般叫回退输入流，这个比较特殊，可以把读取进来的某些数据重新回退到输入流的缓冲区之中，也就是提供了回退机制。&lt;/li&gt;
&lt;li&gt;DataInputStream，提供从流中直接读取具体数据类型的功能。&lt;/li&gt;
&lt;li&gt;BufferedInputStream，缓冲输入流，为字节流读取提供基于内存的缓冲功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;管道流：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PipedInputStream，提供从与其它线程共用的管道中读取数据的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;合并流：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SequenceInputStream，用于合并多个输入字节流。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;内存输入流&quot;&gt;内存输入流&lt;/h3&gt;
&lt;p&gt;ByteArrayInputStream(字节数组输入流)主要是用于直接读取byte数组(它内部就维护了一个字节数组)，操作都是基于内存态的，它实现了InputStream的所有方法，也就是支持标记和重置。例子见前面的分析，这里不做多余举例。&lt;/p&gt;
&lt;h3 id=&quot;文件输入流&quot;&gt;文件输入流&lt;/h3&gt;
&lt;p&gt;FileInputStream主要用于读取文件内容为字节数组，不支持标记和重置，另外在JSR-51中它引入了FileChannel用于通过Channel读取数据。&lt;/p&gt;
&lt;p&gt;这里可能有疑惑，有时候可以用很小的byte数组用来做缓冲区完成文件的复制(文件的复制包括两个步骤，分别是源文件内容读取到内存中和内存中的数据写到目标文件中)，下面画个图解释一下整个复制过程。假设场景：源文件1.log里面有10字节数据，使用的缓冲字节数组的长度是6，目标是把1.log的内容拷贝到目标文件2.log中。先在磁盘D建立一个文件1.log，文件内容是：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;abcdefghij&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件拷贝的代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] buffer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;];
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; (FileInputStream inputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileInputStream(&lt;span class=&quot;st&quot;&gt;&quot;D:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;1.log&quot;&lt;/span&gt;);
             FileOutputStream outputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileOutputStream(&lt;span class=&quot;st&quot;&gt;&quot;D:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;2.log&quot;&lt;/span&gt;)) {
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) {
                &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len = inputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(buffer);
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (len &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                    &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
                }
                outputStream.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(buffer, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, len);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台输出：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Loop:&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,len:&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
Loop:&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,len:&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
Loop:&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,len:-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时可以看到磁盘D中新建了一个2.log文件，内容和1.log中完全一样，这里暂时先忽略OutputStream的使用方式，画图理解整个过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/throwable/1241978/o_104.png&quot; alt=&quot;104.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每次进行写入的时候是根据&lt;code&gt;read()&lt;/code&gt;方法返回的当前读取到的字节序列的长度并且指定写时偏移量为0，总长度为读取到的字节序列的长度实现的。所以缓冲字节数组中即使有上一次循环残余的脏字节，也不会影响此次循环的数据写入。&lt;/p&gt;
&lt;h3 id=&quot;回退输入流&quot;&gt;回退输入流&lt;/h3&gt;
&lt;p&gt;Java中输入流都是采用顺序的读取方式，即对于一个输入流来讲都是采用从字节序列头到字节序列尾的顺序读取的，如果在输入流读取到实际不需要的字节，则只能通过程序将这些不需要的字节忽略，为了解决这样的处理问题，在Java中提供了一种回退输入流PushbackInputStream，可以把读取到的字节重新回退到输入流的缓冲字节数组之中。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        String message = &lt;span class=&quot;st&quot;&gt;&quot;doge&quot;&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; (ByteArrayInputStream byteArrayInputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayInputStream(message.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;());
             PushbackInputStream pushbackInputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PushbackInputStream(byteArrayInputStream)) {
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((temp = pushbackInputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;()) != -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
                &lt;span class=&quot;co&quot;&gt;//如果读取到'o'&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (temp == 'o') {
                    &lt;span class=&quot;co&quot;&gt;//把'o'放回去缓冲字节数组&lt;/span&gt;
                    pushbackInputStream.&lt;span class=&quot;fu&quot;&gt;unread&lt;/span&gt;(temp);
                    &lt;span class=&quot;co&quot;&gt;//再读一次&lt;/span&gt;
                    temp = pushbackInputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;();
                    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;这是回退&amp;gt;&quot;&lt;/span&gt; + (&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;) temp + &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;/这是回退&amp;gt;&quot;&lt;/span&gt;);
                } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;) temp);
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;d&amp;lt;这是回退&amp;gt;o&amp;lt;/这是回退&amp;gt;ge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;unread()&lt;/code&gt;方法主要是把读取到的字节放回去(pos-1)的字节数组中的位置，很好理解，因为pos总是指向下一个读取到的字节元素。这里引用&lt;a href=&quot;https://blog.csdn.net/u013087513/article/details/52171078&quot;&gt;一篇文章&lt;/a&gt;的截图说明一下其处理机制：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/throwable/1241978/o_105.png&quot; alt=&quot;105.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;缓冲输入流&quot;&gt;缓冲输入流&lt;/h3&gt;
&lt;p&gt;BufferedInputStream继承自FilterInputStream，它是典型的装饰输入流，它内部提供了一个缓冲字节数组，默认长度是8192(也就是总容量是8KB)，当然也可以通过构造函数指定。读取数据的时候，源字节序列先填充到其内部的缓冲字节数组，然后在调用&lt;code&gt;read()&lt;/code&gt;等相关方法的时候，实际上是从缓冲字节数组中拷贝字节数据到目标字节数组中。当缓冲字节数组中的字节读取(拷贝)完毕之后，如果被读取的字节序列还有剩余，则再次调用底层输入流填充缓冲字节数组。这种做法等于从直接内存中读取数据，其效率每次都要访问磁盘文件高很多。当需要读取的字节序列的长度十分小或者本身使用的目标字节容量比BufferedInputStream提供的缓冲字节数组容量大的时候，使用BufferedInputStream的优势是不明显的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; (FileInputStream inputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileInputStream(&lt;span class=&quot;st&quot;&gt;&quot;D:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;1.log&quot;&lt;/span&gt;);
             BufferedInputStream bufferedInputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedInputStream(inputStream)) {
            &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] data = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;];
            bufferedInputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(data);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(data, &lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;数据输入流&quot;&gt;数据输入流&lt;/h3&gt;
&lt;p&gt;DataInputStream继承自FilterInputStream，它也是典型的装饰输入流，它允许应用程序以与机器无关方式从底层输入流中读取基本Java数据类型。它的方法列表如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] buffer, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; offset, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; length)
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] buffer)
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readBoolean&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readByte&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readChar&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readDouble&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readFloat&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readFully&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] dst)
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readFully&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] dst, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; offset, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; byteCount)
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readInt&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readLong&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readShort&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;readUTF&lt;/span&gt;(DataInput in)
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;readUTF&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readUnsignedByte&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;readUnsignedShort&lt;/span&gt;()
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;skipBytes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到所有的不需要缓冲字节数组的方法都是用于读取字节序列中的下一个字节或者下一个字节块(如果需要转换的话，则转换为相应的类型)。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        ByteArrayOutputStream bo = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayOutputStream();
        DataOutputStream outputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; DataOutputStream(bo);
        outputStream.&lt;span class=&quot;fu&quot;&gt;writeInt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;);
        outputStream.&lt;span class=&quot;fu&quot;&gt;writeBytes&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;doge&quot;&lt;/span&gt;);
        ByteArrayInputStream inputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayInputStream(bo.&lt;span class=&quot;fu&quot;&gt;toByteArray&lt;/span&gt;());
        DataInputStream dataInputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; DataInputStream(inputStream);
        &lt;span class=&quot;co&quot;&gt;//这里注意，因为写入的时候顺序是先int然后是byte，所以读取的时候必须先读取int再读取byte&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; age = dataInputStream.&lt;span class=&quot;fu&quot;&gt;readInt&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] nameChars = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;];
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;; i++) {
            nameChars[i] = dataInputStream.&lt;span class=&quot;fu&quot;&gt;readByte&lt;/span&gt;();
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;age int -&amp;gt;&quot;&lt;/span&gt; + age);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;name byte-&amp;gt;&quot;&lt;/span&gt; + &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(nameChars));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;管道输入流&quot;&gt;管道输入流&lt;/h3&gt;
&lt;p&gt;Java的管道输入与输出实际上使用的是一个循环缓冲数组来实现，这个数组默认大小为1024字节。输入流PipedInputStream从这个循环缓冲数组中读数据，输出流PipedOutputStream往这个循环缓冲数组中写入数据。当这个缓冲数组已满的时候，输出流PipedOutputStream所在的线程将阻塞；当这个缓冲数组首次为空的时候，输入流PipedInputStream所在的线程将阻塞。但是在实际用起来的时候，却会发现并不是那么好用。一般PipedInputStream和PipedOutputStream是成对出现的，否则没有意义。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        PipedInputStream pipedInputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PipedInputStream();
        PipedOutputStream pipedOutputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PipedOutputStream(pipedInputStream);
        Thread sender = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                pipedOutputStream.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello,doge&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
        });
        Thread receiver = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; {
            &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] data = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;//这里会阻塞&lt;/span&gt;
                pipedInputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(data);
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Receive message -&amp;gt; &quot;&lt;/span&gt; + &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(data,&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
        });
        receiver.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        sender.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(Integer.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面只是举例所以显式创建线程，如果在实际使用中最好别这样做。&lt;/p&gt;
&lt;h3 id=&quot;合并输入流&quot;&gt;合并输入流&lt;/h3&gt;
&lt;p&gt;SequenceInputStream会将与之相连接的流集组合成一个输入流并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。合并流的作用是将多个源合并合一个源，也就是说它是一个字节流的合并工具。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{
        ByteArrayInputStream inputStream1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayInputStream(&lt;span class=&quot;st&quot;&gt;&quot;hello,&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
        ByteArrayInputStream inputStream2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayInputStream(&lt;span class=&quot;st&quot;&gt;&quot;doge&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
        Vector vector = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Vector&amp;lt;InputStream&amp;gt;();
        vector.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(inputStream1);
        vector.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(inputStream2);
        SequenceInputStream sequenceInputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SequenceInputStream(vector.&lt;span class=&quot;fu&quot;&gt;elements&lt;/span&gt;());
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] data = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
        &lt;span class=&quot;co&quot;&gt;//注意这里先读取&quot;hello,&quot;，长度为6，起始位置为0&lt;/span&gt;
        sequenceInputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(data,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;//第二次读取&quot;doge&quot;，长度为4，起始位置为6(data数组下标)&lt;/span&gt;
        sequenceInputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(data,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(data,&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;outputstream&quot;&gt;OutputStream&lt;/h2&gt;
&lt;p&gt;java.io.OutputStream是所有输出流的抽象父类，提供三个基本方法用于写入字节序列，另外还提供关闭流、flush(强制清空缓冲区的字节数组并且将之马上写入到目标中)两个方法。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//单字节数据写入，实际上是&quot;无符号的byte&quot;，范围是[0,255]&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; b) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;co&quot;&gt;//下面的write方法的变体&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] data) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;co&quot;&gt;//写入指定的字节数组，可以指定偏移量和总长度&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] data, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; offset, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; length) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;co&quot;&gt;// 强制清空缓冲区的字节数组并且将之马上写入到目标中&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;flush&lt;/span&gt;( ) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;co&quot;&gt;//关闭流&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;( ) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;写入&quot;&gt;写入&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;public abstract void write(int b)&lt;/code&gt;是抽象方法，必须由子类实现。它用于写入单字节数据，写入的字节是&quot;无符号的byte&quot;类型值[0,255]，因为Java中不存在无符号byte类型，所以入参是int类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public void write(byte[] data, int offset, int length)&lt;/code&gt;用于写入一个连续的数据块(即一个连续的字节序列)到目标中，offset是指写入的目标字节数组data的偏移量，可以理解为data这个字节数组写入时候的起始索引，而length是需要写入的字节序列的最大长度(这个长度有可能比data这个字节数组的总长度要小)。画个图说明一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/throwable/1241978/o_107.png&quot; alt=&quot;107.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public void write(byte[] data)&lt;/code&gt;方法只是&lt;code&gt;write(byte[] data, int offset, int length)&lt;/code&gt;的变体，源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt; b[]) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(b, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, b.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;flush&quot;&gt;flush&lt;/h3&gt;
&lt;p&gt;很多时候我们需要使用缓冲流来提高写入的性能，使用缓冲流的时候，并不是每次调用&lt;code&gt;write&lt;/code&gt;方法就直接写目标中写入字节序列，而是当缓冲字节数组(下面称为缓冲区)填充满了之后再一次性把缓冲区中的所有字节写到目标中。&lt;code&gt;flush()&lt;/code&gt;方法被调用的时候，不管缓冲区是否已经填充满，直接把缓冲区的所有字节写入到目标中并且清空缓冲区。其实可以通过源码查看，在FileOutputStream中，&lt;code&gt;flush()&lt;/code&gt;方法是空实现，也就是调用它不会产生任何效果，但是在BufferedOutputStream中它就起到前面说到的效果。当然，如果调用了&lt;code&gt;close()&lt;/code&gt;方法会强制把缓冲区的数据写入到目标，表面上可以这样理解，&lt;code&gt;close()&lt;/code&gt;方法调用的时候必定会触发&lt;code&gt;flush()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;关闭-1&quot;&gt;关闭&lt;/h3&gt;
&lt;p&gt;输出流的关闭可以显式调用&lt;code&gt;close()&lt;/code&gt;方法，一般需要把关闭方法置于finally块中并且捕获其异常不进行异常抛出。关闭后的流不能再进行读取等操作，否则会抛出IOException。在Jdk1.7中引入了java.lang.AutoCloseable接口，实现了AutoCloseable接口的流可以使用try-resource的方式进行编码，这样就不需要显式关闭流。例如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; (FileOutputStream outputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileOutputStream(&lt;span class=&quot;st&quot;&gt;&quot;xxxx&quot;&lt;/span&gt;)){
    &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] buffer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
    &lt;span class=&quot;co&quot;&gt;//填充buffer&lt;/span&gt;
    outputStream.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(buffer);
    &lt;span class=&quot;co&quot;&gt;//....&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上一节中提到过，调用了&lt;code&gt;close()&lt;/code&gt;方法会强制把缓冲区的数据写入到目标，所以一定要注意必须确保输出流的关闭，一方面可以释放相关的句柄以避免资源被大量占用导致OOM等，另一方面可以避免没有显式调用&lt;code&gt;flush()&lt;/code&gt;下导致内存数据没有成功写入到目标中(发生了内存数据的丢失)。&lt;/p&gt;
&lt;h2 id=&quot;outputstream子类&quot;&gt;OutputStream子类&lt;/h2&gt;
&lt;p&gt;下图是OutputStream的主要子类，不包含sun包下隐藏的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/throwable/1241978/o_108.png&quot; alt=&quot;108.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面的分类只是按照个人的理解，并没有科学的根据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管道流：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PipedOutputStream，提供从与其它线程共用的管道中写入数据的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;介质流：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ByteArrayOutputStream，提供写入数据到内存中的字节数组的功能。&lt;/li&gt;
&lt;li&gt;FileOutputStream，提供写入数据到磁盘文件的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;装饰流：&lt;/strong&gt;&lt;br/&gt;主要包括ObjectOutputStream和FilterOutputStream的子类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ObjectOutputStream，提供对象序列化功能。&lt;/li&gt;
&lt;li&gt;PrintStream，打印流，提供打印各种类型的数据的功能，System.out是标准输出，是PrintStream的实例。&lt;/li&gt;
&lt;li&gt;DataOutputStream，数据输出流，提供直接写入具体数据类型的功能。&lt;/li&gt;
&lt;li&gt;BufferedOutputStream，缓冲输出流，为输出数据提供字节缓冲区。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为输出流和输入流是基本对称的，下面只介绍一个特例：PrintStream。&lt;/p&gt;
&lt;h3 id=&quot;打印流&quot;&gt;打印流&lt;/h3&gt;
&lt;p&gt;PrintStream也使用了典型的装饰器模式，它为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。与其他输出流不同，PrintStream永远不会抛出IOException，异常情况仅仅可通过checkError方法返回的布尔值进行判断。另外，PrintStream的构造函数可以通过autoFlush这个布尔值参数设置是否自动flush，这意味着可在写入byte数组之后自动调用flush方法(其实是任何写入操作，因为具体类型的写入操作最终也会转换为byte数组的写入)。其实，PrintStream的API设计是十分优秀的，但是它吞下所有异常的这一设计有点不太友好。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; (ByteArrayOutputStream outputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayOutputStream();
             PrintStream printStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PrintStream(outputStream)) {
            printStream.&lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;I am doge,&quot;&lt;/span&gt;);
            printStream.&lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;);
            printStream.&lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot; years old!&quot;&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(outputStream.&lt;span class=&quot;fu&quot;&gt;toByteArray&lt;/span&gt;(), &lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;I am doge,25 years old!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不得不说，打印流用起来真是十分爽。&lt;/p&gt;

&lt;p&gt;这里小结一下InputStream和OutputStream，以FileInputStream和FileOutputStream，仅仅代表个人的见解。&lt;/p&gt;
&lt;p&gt;先在假设Windows系统的D盘有一个文件，文件名称是access.log，内容是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hello,doge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过文件的绝对路径实例化FileInputStream：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;FileInputStream fileInputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileInputStream(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;D:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;access.log&quot;&lt;/span&gt;, File.&lt;span class=&quot;fu&quot;&gt;separator&lt;/span&gt;));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，我们就可以通过FileInputStream读取D:\access.log中的内容，首先我们要先新建一个字节数组用于存放读取的内容，因为&quot;Hello,doge&quot;的长度为10，所以我们建立长度为10的字节数组即可：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] data = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着我们通过FileInputStream的read(byte b[])方法读取文件内容，写入到新创建的空字节数组data中：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;fileInputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(data);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里值得注意的是：FileInputStream的read(byte b[])当读取到文件的末尾的时候，会返回-1，这里读取过程其实最好写成一个循环：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len;
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((len = fileInputStream.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(data)) != -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;){
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样之后，文件内容就能够读取到data中，可以尝试打印data的内容：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(data,&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，这里仅仅是演示如何读取文件内容，但是实际生产环境中，文件的内容有可能极大，如果要新建一个极大的byte数组，一次性读完整个文件，有可能会导致大量内存被占用导致内存溢出。因此，在读取大文件的时候，可以考虑分行、限制每次读取长度或者分段多次读取，在这里读取大文件不做深入分析，后面会写一篇实战的文章。&lt;/p&gt;
&lt;p&gt;对于OutputStream，写入数据过程大致和InputStream的读取数据过程相反，以FileOutputStream为例子，假设我们要向D:\access.log文件中写入文件内容，写入的内容为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Today is Sunday.&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似，先通过文件绝对路径新建FileOutputStream实例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;FileOutputStream fileOutputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileOutputStream(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;D:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;access.log&quot;&lt;/span&gt;, File.&lt;span class=&quot;fu&quot;&gt;separator&lt;/span&gt;));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，我们需要准备写入目标文件的字节数组内容：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] outputData = &lt;span class=&quot;st&quot;&gt;&quot;Today is Sunday.&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后调用FileOutputStream的write(byte b[])方法即可：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;fileOutputStream.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(outputData);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用完成的后，会发现文件中原来的&quot;Hello,doge&quot;内容被抹掉，替换为&quot;Today is Sunday.&quot;，这是因为&lt;br/&gt;FileOutputStream实例没有指定为追加模式，于是直接把字节数组的内容直接写进去文件，覆盖掉原来的内容。如果想实现文件内容追加，要使用FileOutputStream的另一个构造函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//如果指定append为true，则写入的数据的方式是追加，而不是覆盖，默认是覆盖&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; FileOutputStream(String name, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; append){
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;FileOutputStream fileOutputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileOutputStream(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;D:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;access.log&quot;&lt;/span&gt;, File.&lt;span class=&quot;fu&quot;&gt;separator&lt;/span&gt;),&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时候要留多个心眼，观察一下OutputStream的具体子类的构造，可能会有惊喜。&lt;/p&gt;
&lt;p&gt;输入输出流的分析大致到这里，其实它们的API还是挺容易使用的。&lt;/p&gt;

&lt;h2 id=&quot;reader&quot;&gt;Reader&lt;/h2&gt;
&lt;p&gt;java.io.Reader是所有的字符读取器(Reader暂时不知道怎么翻译，先这样叫)的抽象父类。Reader的核心功能是从来源中读取字节序列并且转换为char数组。它主要提供下面的方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(java.&lt;span class=&quot;fu&quot;&gt;nio&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;CharBuffer&lt;/span&gt; target) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; cbuf[]) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException 
&lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; cbuf[], &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; off, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;skip&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException 
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ready&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException    
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;markSupported&lt;/span&gt;()   
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;mark&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; readAheadLimit) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;reset&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大部分方法与InputStream中的方法相似，实际效果也是基本一致，这里主要分析一下&lt;code&gt;ready()&lt;/code&gt;和&lt;code&gt;read()&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3 id=&quot;ready&quot;&gt;ready&lt;/h3&gt;
&lt;p&gt;当此方法返回true的时候，保证下一次调用&lt;code&gt;read()&lt;/code&gt;方法的时候不会阻塞输入，但是当此方法返回false，并不能保证下一次调用&lt;code&gt;read()&lt;/code&gt;方法的时候一定会阻塞输入。这个方法的作用是用来判断编码转换器是否已经把字节序列转换为char序列，如果有可用的char序列，此方法返回true，此时可以进行char的读取。其实，个人更建议使用&lt;code&gt;read()&lt;/code&gt;方法阻塞和返回值是否为-1来做相关判断。&lt;/p&gt;
&lt;h3 id=&quot;读取-1&quot;&gt;读取&lt;/h3&gt;
&lt;p&gt;read方法都是阻塞方法，直到有可读字节、到达流的尾部返回-1或者抛出异常。其实在最开始前已经说过，实际上Reader读取的还是字节，中间通过编码转换把byte序列转换成char序列，下面就直接描述为&quot;读取char序列&quot;或者&quot;读取char数组&quot;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public int read(java.nio.CharBuffer target)&lt;/code&gt;把读取到的char序列写入到指定的CharBuffer实例中，返回写入的char序列的长度，底层依赖到&lt;code&gt;read(char cbuf[], int off, int len)&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public int read()&lt;/code&gt;方法是单字符读取方法，返回值的范围是[0,65535]，当方法返回-1说明已经到达流的尾部，得到的int值可以直接强转为char类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;abstract public int read(char cbuf[], int off, int len)&lt;/code&gt;方法是读取一段char序列或者一块char数据，可以指定写入到目标char数组cbuf的偏移量和写入的总字符长度。注意到此方法是抽象方法，必须由子类实现。&lt;code&gt;public int read(char cbuf[])&lt;/code&gt;方法只是&lt;code&gt;read(char cbuf[], int off, int len)&lt;/code&gt;的变体，源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; cbuf[]) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(cbuf, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, cbuf.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;reader的主要子类&quot;&gt;Reader的主要子类&lt;/h2&gt;
&lt;p&gt;下图是Reader的主要子类，不包含sun包下隐藏的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/throwable/1241978/o_109.png&quot; alt=&quot;109.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介质Reader：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CharArrayReader，从Char数组读取数据。&lt;/li&gt;
&lt;li&gt;StringReader，从字符串中读取数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;装饰Reader：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BufferedReader，读取数据时提供基于内存的char数组缓冲区，并且提供了基于行读取的功能。&lt;/li&gt;
&lt;li&gt;LineNumberReader，继承于BufferedReader，添加了设置行号和获取行号的功能。&lt;/li&gt;
&lt;li&gt;PushbackReader，提供回退功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;管道Reader：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PipedReader，提供基于线程的管道数据读取的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;转换Reader：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;InputStreamReader，比较特殊，它的构造函数入参为InputStream，也就是它是InputStream转化为Reader的桥梁，也可以理解为读取到的byte序列转换为char序列的转换器。&lt;/li&gt;
&lt;li&gt;FileReader，承于InputStreamReader，提供基文件数据读取的更便捷的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，如果来源中仅仅存在字符，可以优先使用Reader进行数据读取，如果遇到像图片一类的二进制序列，只能考虑使用InputStream。&lt;/p&gt;
&lt;h3 id=&quot;chararrayreader&quot;&gt;CharArrayReader&lt;/h3&gt;
&lt;p&gt;CharArrayReader提供从Char数组中读取数据的功能。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;[] input = &lt;span class=&quot;st&quot;&gt;&quot;Hello,doge&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;toCharArray&lt;/span&gt;();
        CharArrayReader charArrayReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; CharArrayReader(input);
        &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;[] readData = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
        charArrayReader.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(readData);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(readData));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;stringreader&quot;&gt;StringReader&lt;/h3&gt;
&lt;p&gt;StringReader提供从字符串读取数据的功能。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{
        StringReader stringReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; StringReader(&lt;span class=&quot;st&quot;&gt;&quot;Hello,doge&quot;&lt;/span&gt;);
        &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;[] readData = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
        stringReader.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(readData);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(readData));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;bufferedreader&quot;&gt;BufferedReader&lt;/h3&gt;
&lt;p&gt;BufferedReader读取数据时提供基于内存的缓冲区，并且提供了基于行读取的功能，换行功能是换行符进行判断，例如&quot;\n&quot;或者&quot;\r&quot;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; (StringReader stringReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; StringReader(&lt;span class=&quot;st&quot;&gt;&quot;Hello,doge!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;Today is Sunday!&quot;&lt;/span&gt;);
             BufferedReader bufferedReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(stringReader)) {
            String value;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((value = bufferedReader.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;()) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(value);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台输出：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Hello,doge!
Today is Sunday!&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BufferedReader提供的&lt;code&gt;readLine()&lt;/code&gt;方法返回被装饰Reader下一行的字符串内容，如果读取到流的尾部，则返回null。&lt;/p&gt;
&lt;h3 id=&quot;linenumberreader&quot;&gt;LineNumberReader&lt;/h3&gt;
&lt;p&gt;LineNumberReader继承于BufferedReader，读取数据时提供基于内存的缓冲区，并且提供了基于行读取的功能，增加了设置行号和获取行号的功能。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; (StringReader stringReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; StringReader(&lt;span class=&quot;st&quot;&gt;&quot;Hello,doge!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;Today is Sunday!&quot;&lt;/span&gt;);
             LineNumberReader bufferedReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LineNumberReader(stringReader)) {
            String value;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((value = bufferedReader.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;()) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(bufferedReader.&lt;span class=&quot;fu&quot;&gt;getLineNumber&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;:&quot;&lt;/span&gt; + value);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台输出：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:Hello,doge!
&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:Today is Sunday!&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;pushbackreader&quot;&gt;PushbackReader&lt;/h3&gt;
&lt;p&gt;PushbackReader类似于PushbackInputStream，提供数据回退的功能。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        StringReader stringReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; StringReader(&lt;span class=&quot;st&quot;&gt;&quot;hello,doge&quot;&lt;/span&gt;);
        PushbackReader pushbackReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PushbackReader(stringReader);
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len;
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((len = pushbackReader.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;()) != -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (len == 'o') {
                &lt;span class=&quot;co&quot;&gt;//回退当前char&lt;/span&gt;
                pushbackReader.&lt;span class=&quot;fu&quot;&gt;unread&lt;/span&gt;(len);
                &lt;span class=&quot;co&quot;&gt;//再次读取&lt;/span&gt;
                len = pushbackReader.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;();
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;回退字符&amp;gt;&quot;&lt;/span&gt; + (&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;) len + &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;/回退字符&amp;gt;&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;) len);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;pipedreader&quot;&gt;PipedReader&lt;/h3&gt;
&lt;p&gt;PipedReader和PipedWriter与PipedInputStream和PipedOutputStream一样，都可以用于管道通信。PipedWriter是字符管道输出流，继承于Writer；PipedReader是字符管道输入流，继承于Reader，PipedWriter和PipedReader的作用是可以通过管道进行线程间的通讯。两者必须要配套使用，否则意义不大。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{
        PipedReader pipedReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PipedReader();
        PipedWriter pipedWriter = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PipedWriter(pipedReader);
        Thread sender = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                pipedWriter.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello,doge&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
        });
        Thread receiver = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; {
            &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;[] data = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                pipedReader.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(data);
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;receive data -&amp;gt; &quot;&lt;/span&gt; + &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(data));
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
        });
        receiver.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        sender.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(Integer.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;inputstreamreader&quot;&gt;InputStreamReader&lt;/h3&gt;
&lt;p&gt;InputStreamReader是InputStream转化为Reader的桥梁，也可以理解为读取到的byte序列转换为char序列的转换器，可以在构造器中指定具体的编码类型，如果不指定的话将采用底层操作系统的默认编码类型，例如GBK。它的实例化依赖于InputStream的实例，InputStream转化为Reader，就可以使用装饰流操作InputStreamReader实例，这样的话能够大大简化读取数据的操作。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; (ByteArrayInputStream byteArrayInputStream = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayInputStream(&lt;span class=&quot;st&quot;&gt;&quot;Hello,doge!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;Today is Sunday!&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;));
             InputStreamReader inputStreamReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InputStreamReader(byteArrayInputStream, &lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;);
             BufferedReader bufferedReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(inputStreamReader)) {
            String value;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((value = bufferedReader.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;()) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(value);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;filereader&quot;&gt;FileReader&lt;/h3&gt;
&lt;p&gt;FileReader继承于InputStreamReader，它内部原理是通过FileInputStream转化为Reader，作用是简化了读取文件字符的功能。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; (FileReader fileReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileReader(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;D:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;access.log&quot;&lt;/span&gt;, File.&lt;span class=&quot;fu&quot;&gt;separator&lt;/span&gt;));
            BufferedReader bufferedReader = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BufferedReader(fileReader)){
            String value;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((value = bufferedReader.&lt;span class=&quot;fu&quot;&gt;readLine&lt;/span&gt;()) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(value);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;writer&quot;&gt;Writer&lt;/h2&gt;
&lt;p&gt;java.io.Writer是所有的字符写入器(Writer暂时不知道怎么翻译，先这样叫)的抽象父类。Writer的核心功能是把char序列转化为byte序列写入到目标中，char序列转化为byte序列的过程对开发者来说是无感知的。它主要提供下面的方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; cbuf[]) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; cbuf[], &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; off, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(String str) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(String str, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; off, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Writer &lt;span class=&quot;fu&quot;&gt;append&lt;/span&gt;(CharSequence csq) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Writer &lt;span class=&quot;fu&quot;&gt;append&lt;/span&gt;(CharSequence csq, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; start, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; end)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Writer &lt;span class=&quot;fu&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; c) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;flush&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException
&lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;读取或者追加&quot;&gt;读取或者追加&lt;/h3&gt;
&lt;p&gt;追加方法&lt;code&gt;append()&lt;/code&gt;最终都会调用到&lt;code&gt;write()&lt;/code&gt;方法，它们只是为了方便构建链式编程(追加方法都返回this)。所有的&lt;code&gt;append()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;方法都是&lt;code&gt;abstract public void write(char cbuf[], int off, int len)&lt;/code&gt;方法的变体而已，写入char数组再转换为字节序列到目标中，可以指定char数组的偏移量和写入的总长度。注意到，&lt;code&gt;write(int c)&lt;/code&gt;方法，实际上char和int可以相互转换，在此方法中，参数int会直接转换为char类型。int转换为char的时候，只会取低16位，高16位会被忽略，并且它是无符号的，也就是char的范围是[0,65535]，这正是Unicode编码的码点范围。&lt;/p&gt;
&lt;h3 id=&quot;flush-1&quot;&gt;flush&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flush()&lt;/code&gt;方法调用之后会立即把char序列转换为byte序列写入到目标中，类似于OutputStream的flush方法。&lt;/p&gt;
&lt;h3 id=&quot;关闭-2&quot;&gt;关闭&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;close()&lt;/code&gt;方法用于关闭流，此方法调用后必定先进行flushing，也就是效果类似于首先先调用&lt;code&gt;flush()&lt;/code&gt;方法，然后释放流相关的资源和句柄等，类似于OutputStream的close方法。&lt;/p&gt;
&lt;h2 id=&quot;writer的主要子类&quot;&gt;Writer的主要子类&lt;/h2&gt;
&lt;p&gt;下图是Writer的主要子类，不包含sun包下隐藏的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/throwable/1241978/o_110.png&quot; alt=&quot;110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Writer的子类的和Reader的子类是基本对称的，下面只介绍特例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打印Writer：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PrintWriter，提供基于多种数类型格式化的输出功能，使用方式其实跟PrintStream大致相同。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里再啰嗦一句，Writer的所有子类都实现了父类Writer中的方法，它们都是相当有效和易用的API。&lt;/p&gt;
&lt;h3 id=&quot;printwriter&quot;&gt;PrintWriter&lt;/h3&gt;
&lt;p&gt;PrintWriter提供基于多种数类型格式化的输出功能，它使用了装饰器模式。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; (StringWriter stringWriter = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; StringWriter();
             PrintWriter printWriter = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PrintWriter(stringWriter)) {
            printWriter.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hello,doge&quot;&lt;/span&gt;);
            printWriter.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10086&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(stringWriter.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;());
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hello,doge
10086&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;IO是网络编程的基础，如果想要写出高性能的中间件，必须深入理解IO相关的知识。这篇文章仅仅说到了一些皮毛，主要是通过阅读书中的内容，对IO的一些基础认知进行整理，对BIO相关的一些API进行基于例子的使用讲解。这本书中关于套接字相关的内容并不详细，在《Java NIO》有更深入的分析(但是两本书很多内容是重叠的，有点蛋疼)，后面会写另一篇NIO的总结，主要包括NIO的特性以及URL、URI、URLConnection、套接字相关的内容等等。如果有更深入的收获，后面再写具体的文章分享。&lt;/p&gt;
&lt;p&gt;（本文完）&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jun 2018 15:48:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9226990.html</dc:identifier>
</item>
<item>
<title>python3解析库pyquery - Py.qi</title>
<link>http://www.cnblogs.com/zhangxinqi/p/9219476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxinqi/p/9219476.html</guid>
<description>&lt;p&gt;pyquery是一个类似jquery的python库，它实现能够在xml文档中进行jQuery查询，pyquery使用lxml解析器进行快速在xml和html文档上操作，它提供了和jQuery类似的语法来解析HTML文档，支持CSS选择器，使用非常方便&lt;/p&gt;
&lt;h3&gt;1、pyquery安装&lt;/h3&gt;
&lt;p&gt;pip方式安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$pip install pyquery

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;它依赖cssselect和lxml包&lt;/span&gt;
pyquery==1.4&lt;span&gt;.0
  &lt;/span&gt;- cssselect [required: &amp;gt;0.7.9, installed: 1.0.3] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;CSS选择器并将它转换为XPath表达式&lt;/span&gt;
  - lxml [required: &amp;gt;=2.1, installed: 4.2.2] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;处理xml和html解析库&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;验证安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
In [1]: &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyquery

In [&lt;/span&gt;2&lt;span&gt;]: pyquery.text
Out[&lt;/span&gt;2]: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pyquery.text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/root/pp1/.venv/lib/python3.6/site-packages/pyquery/text.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、pyquery对象初始化&lt;/h3&gt;
&lt;p&gt;pyquery首先需要传入HTML文本来初始化一个pyquery对象，它的初始化方式有多种，如直接传入字符串，传入URL或者传入文件名&lt;/p&gt;
&lt;p&gt;（1）字符串初始化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq

html&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div id=&quot;wenzhangziti&quot; class=&quot;article 389862&quot;&amp;gt;&lt;br/&gt;&amp;lt;p&amp;gt;人生是一条没有尽头的路，不要留恋逝去的梦，把命运掌握在自己手中，让我们来掌握自己的命运，别让别人的干扰与诱惑，别让功名与利禄，来打翻我们这坛陈酿已久的命运之酒！&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
doc&lt;/span&gt;=&lt;span&gt;pq(html)   &lt;span&gt;#初始化并创建pyquery对象
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(doc))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text())

&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pyquery.pyquery.PyQuery&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
人生是一条没有尽头的路，不要留恋逝去的梦，把命运掌握在自己手中，让我们来掌握自己的命运，别让别人的干扰与诱惑，别让功名与利禄，来打翻我们这坛陈酿已久的命运之酒！
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）URL初始化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq

doc&lt;/span&gt;=pq(url=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/zhangxinqi/p/9218395.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(doc))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pyquery.pyquery.PyQuery&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;title&amp;gt;python3解析库BeautifulSoup4 - Py.qi - 博客园&amp;lt;/title&amp;gt;&amp;amp;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;13;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PyQuery能够从url加载一个html文档，之际上是默认情况下调用python的urllib库去请求响应，如果requests已安装的话它将使用requests来请求响应，那我们就可以使用request的请求参数来构造请求了，实际请求如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests

doc&lt;/span&gt;=pq(requests.get(url=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/zhangxinqi/p/9218395.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(doc))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出同上一样&lt;/span&gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pyquery.pyquery.PyQuery&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;title&amp;gt;python3解析库BeautifulSoup4 - Py.qi - 博客园&amp;lt;/title&amp;gt;&amp;amp;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;13;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）通过文件初始化&lt;/p&gt;
&lt;p&gt;通过本地的HTML文件来构造PyQuery对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq

doc&lt;/span&gt;=pq(filename=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;demo.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,parser=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;doc=pq(open('demo.html','r',encoding='utf-8').read(),parser='html')  #注意：在读取有中文的HTML文件时，请使用此方法，否则会报解码错误&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(doc))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、CSS选择器&lt;/h3&gt;
&lt;p&gt;在使用属性选择器中，使用属性选择特定的标签，标签和CSS标识必须引用为字符串，它会过滤筛选符合条件的节点打印输出，返回的是一个PyQuery类型对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
html&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div id=&quot;container&quot;&amp;gt;
    &amp;lt;ul class=&quot;list&quot;&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;first item&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-0 active&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;&amp;lt;span class=&quot;bold&quot;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1 active&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
doc&lt;/span&gt;=pq(html,parser=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#container .list .item-0 a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.list .item-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1 active&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、查找节点&lt;/h3&gt;
&lt;p&gt;PyQuery使用查询函数来查询节点，同jQuery中的函数用法完全相同&lt;/p&gt;
&lt;p&gt;(1)查找子节点和子孙节点&lt;/p&gt;
&lt;p&gt;使用find()方法获取子孙节点，children()获取子节点，使用以上的HTML代码测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests

doc&lt;/span&gt;=pq(html,parser=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;find:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).children(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)获取父节点和祖先节点&lt;/p&gt;
&lt;p&gt;parent()方法获取父节点，parents()获取祖先节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;doc(.list).parent()
doc(.list).parents()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)获取兄弟节点&lt;/p&gt;
&lt;p&gt;siblings()方法用来获取兄弟节点，可以嵌套使用，传入CSS选择器即可继续匹配&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.list .item-0 .active&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).siblings(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.active&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5、遍历&lt;/h3&gt;
&lt;p&gt;对于pyquery的选择结果可能是多个字节，也可能是单个节点，类型都是PyQuery类型，它没有返回列表等形式，对于当个节点我们可指直接打印输出或者直接转换成字符串，而对于多个节点的结果，我们需要遍历来获取所有节点可以使用items()方法，它会返回一个生成器，循环得到的每个节点类型依然是PyQuery类型，所以我们可以继续方法来选择节点或属性，内容等&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
lis=doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).items()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lis:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(i(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;继续获取节点下的子节点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6、获取信息&lt;/h3&gt;
&lt;p&gt;attr()方法用来获取属性，如返回的结果有多个时可以调用items()方法来遍历获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.item-0.active a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).attr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;多属性值中间不能有空格&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;text()方法用来获取文本内容，它只返回内部的文本信息不包括HTML文本内容，如果想返回包括HTML的文本内容可以使用html()方法，如果结果有多个，text()方法会方法所有节点的文本信息内容并将它们拼接用空格分开返回字符串内容，html()方法只会返回第一个节点的HTML文本，如果要获取所有就需要使用items()方法来遍历获取了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq
html&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div id=&quot;container&quot;&amp;gt;
    &amp;lt;ul class=&quot;list&quot;&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;first item&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-0 active&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;&amp;lt;span class=&quot;bold&quot;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1 active&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
doc&lt;/span&gt;=pq(html,parser=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).text())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取li节点下的所有文本信息&lt;/span&gt;
lis=doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).items()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lis:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,i.html()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取所有li节点下的HTML文本&lt;/span&gt;

&lt;span&gt;#
&lt;/span&gt;&lt;span&gt;text: first item second item third item fourth item fifth item
html: first item
html: &lt;/span&gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&lt;span&gt;
html: &lt;/span&gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&lt;span&gt;
html: &lt;/span&gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&lt;span&gt;
html: &lt;/span&gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7、节点操作&lt;/h3&gt;
&lt;p&gt;pyquery提供了一系列方法来对节点进行动态修改，如添加一个class，移除某个节点，修改某个属性的值&lt;/p&gt;
&lt;p&gt;addClass()增加Class，removeClass()删除Class&lt;/p&gt;
&lt;p&gt;attr()增加属性和值，text()增加文本内容，html()增加HTML文本，remove()移除&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
html&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div id=&quot;container&quot;&amp;gt;
    &amp;lt;ul class=&quot;list&quot;&amp;gt;
         &amp;lt;li id=&quot;1&quot;&amp;gt;first item&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-2 active&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;&amp;lt;span class=&quot;bold&quot;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-3 active&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-4&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
doc&lt;/span&gt;=pq(html,parser=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).add_class(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myclass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;增加Class&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.item-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).remove_class(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除Class&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).attr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;link&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加属性name=link&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加文本&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).html(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;span&amp;gt;changed item&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加HTML文本&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.item-2.active a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).remove(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除节点&lt;/span&gt;

&lt;span&gt;#
&lt;/span&gt;&amp;lt;li id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/li&amp;gt;
         
&amp;lt;li id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myclass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/li&amp;gt;
         
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         
&amp;lt;li id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myclass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/li&amp;gt;
         
&amp;lt;li id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myclass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;hello world&amp;lt;/li&amp;gt;
         
&amp;lt;li id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myclass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span&amp;gt;changed item&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;after()在节点后添加值&lt;/p&gt;
&lt;p&gt;before()在节点之前插入值&lt;/p&gt;
&lt;p&gt;append()将值添加到每个节点&lt;/p&gt;
&lt;p&gt;contents()返回文本节点内容&lt;/p&gt;
&lt;p&gt;empty()删除节点内容&lt;/p&gt;
&lt;p&gt;remove_attr()删除属性&lt;/p&gt;
&lt;p&gt;val()设置或获取属性值&lt;/p&gt;
&lt;p&gt;另外还有很多节点操作方法，它们和jQuery的用法完全一致，详细请参考：&lt;a href=&quot;http://pyquery.readthedocs.io/en/latest/api.html&quot; target=&quot;_blank&quot;&gt;http://pyquery.readthedocs.io/en/latest/api.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;8、伪类选择器&lt;/h3&gt;
&lt;p&gt;CSS选择器之所以强大，是因为它支持多种多样的伪类选择器，如：选择第一个节点，最后一个节点，奇偶数节点等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq

html&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div id=&quot;container&quot;&amp;gt;
    &amp;lt;ul class=&quot;list&quot;&amp;gt;
         &amp;lt;li id=&quot;1&quot;&amp;gt;first item&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-2 active&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;&amp;lt;span class=&quot;bold&quot;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-3 active&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-4&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
     &amp;lt;/ul&amp;gt;
     &amp;lt;div&amp;gt;&amp;lt;input type=&quot;text&quot; value=&quot;username&quot;/&amp;gt;&amp;lt;/div&amp;gt; 
&amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
doc&lt;/span&gt;=pq(html,parser=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第一个li节点:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li:first-child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一个li节点&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;最后一个li节点:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li:last_child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;最后一个li节点&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第二个li节点:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li:nth-child(2)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第二个li节点&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第三个之后的所有li节点:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li:gt(2)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第三个之后的所有li节点&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;偶数的所有li节点:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li:nth-child(2n)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;偶数的所有li节点&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;包含文本内容的节点:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li:contains(second)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;包含文本内容的节点&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;索引第一个节点：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li:eq(0)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;奇数节点:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li:even&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;偶数节点:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li:odd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;第一个li节点: &amp;lt;li id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/li&amp;gt;&lt;span&gt;
         
最后一个li节点: &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
     
第二个li节点: &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
         
第三个之后的所有li节点: &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-3 active&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
     
偶数的所有li节点: &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-3 active&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
         
包含文本内容的节点: &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
         
索引第一个节点： &lt;/span&gt;&amp;lt;li id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/li&amp;gt;&lt;span&gt;
         
奇数节点: &lt;/span&gt;&amp;lt;li id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-2 active&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
     
偶数节点: &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-3 active&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多伪类参考：&lt;a href=&quot;http://pyquery.readthedocs.io/en/latest/pseudo_classes.html&quot; target=&quot;_blank&quot;&gt;http://pyquery.readthedocs.io/en/latest/pseudo_classes.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多css选择器参考：&lt;a href=&quot;http://www.w3school.com.cn/cssref/css_selectors.asp&quot; target=&quot;_blank&quot;&gt;http://www.w3school.com.cn/cssref/css_selectors.asp&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;9、实例应用&lt;/h3&gt;
&lt;p&gt; 抓取http://www.mzitu.com网站美女图片12万张用时28分钟，总大小9G，主要受网络带宽影响，下载数据有点慢&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; requests.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RequestException
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageFile
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; io &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BytesIO
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Pool,freeze_support
ImageFile.LOAD_TRUNCATED_IMAGES &lt;/span&gt;=&lt;span&gt; True

headers&lt;/span&gt;=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.62 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Referer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.mzitu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

img_headers&lt;/span&gt;=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.62 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Referer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://i.meizitu.net&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保持会话请求&lt;/span&gt;
sesion=&lt;span&gt;requests.Session()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取首页所有URL并返回列表&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_url(url):
    list_url &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        html&lt;/span&gt;=sesion.get(url,headers=&lt;span&gt;headers).text
        doc&lt;/span&gt;=pq(html,parser=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        url_path&lt;/span&gt;=doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#pins &amp;gt; li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).children(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; url_path.items():
            list_url.append(i.attr(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; RequestException as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get_url_RequestException:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get_url_Exception:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list_url

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;组合首页中每个地址的图片分页返回列表&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; list_get_pages(list_url):
    list_url_fen&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list_url:
            doc_children &lt;/span&gt;= pq(sesion.get(i,headers=headers).text,parser=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            img_number &lt;/span&gt;= doc_children(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;body &amp;gt; div.main &amp;gt; div.content &amp;gt; div.pagenavi &amp;gt; a:nth-child(7) &amp;gt; span&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text()
            number&lt;/span&gt;=&lt;span&gt;int(img_number.strip())
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(1,number+1&lt;span&gt;):
                list_url_fen.append(i&lt;/span&gt;+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;str(j))
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;list_get_pages_ValueError:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; RequestException as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;list_get_pages_RequestException&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;list_get_pages_Exception:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list_url_fen

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取image地址并下载图片&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_image(url):
    im_path&lt;/span&gt;=&lt;span&gt;''&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        html&lt;/span&gt;=sesion.get(url, headers=&lt;span&gt;headers).text
        doc&lt;/span&gt;=pq(html,parser=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        im_path&lt;/span&gt;=doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.main-image a img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).attr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        image_names &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;.join(im_path.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[-3&lt;span&gt;:])
        image_path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\images\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; image_names
        with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;img_url.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
            f.write(im_path &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        r&lt;/span&gt;=requests.get(im_path,headers=&lt;span&gt;img_headers)
        b&lt;/span&gt;=&lt;span&gt;BytesIO(r.content)
        i&lt;/span&gt;=&lt;span&gt;Image.open(b)
        i.save(image_path)
        b.close()
        i.close()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print('下载图片:{}成功！'.format(image_names))&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt; RequestException as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RequestException:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; OSError as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;OSError:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt; Exception as e:   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;必须捕获所有异常，运行中有一些链接地址不符合抓取规律，需要捕获异常使程序正常运行&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Exception:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; im_path


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;主调用函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(item):
    url1&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.mzitu.com/page/{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(item) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;分页地址&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;开始下载地址：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(url1))
    获取首页链接地址
    html&lt;/span&gt;=&lt;span&gt;get_url(url1)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取分页链接地址&lt;/span&gt;
    list_fenurl =&lt;span&gt; list_get_pages(html)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;根据分页链接地址获取图片并下载&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list_fenurl:
        get_image(i)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; len(list_fenurl)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;统计下载数&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    freeze_support()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;windows下进程调用时必须添加&lt;/span&gt;
    pool=Pool()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建进程池&lt;/span&gt;
    start=&lt;span&gt;time.time()
    count&lt;/span&gt;=pool.map(main,[i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,185)])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;多进程运行翻页主页&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(sum(count),count)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取总的下载数&lt;/span&gt;
    end=&lt;span&gt;time.time()
    data&lt;/span&gt;=time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%M:%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,time.localtime(end-start))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取程序运行时间&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;程序运行时间:{}分{}秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(*data.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;学习阶段，代码写得通用性很差，以后改进！&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;运行结果&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;会有几个报错都忽略了是获取文件名时的分割问题和在图片很少的情况下导致获取不到单分页图片的数目，先忽略以后有时间再改正&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;Exception: 'NoneType' object has no attribute 'split'&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;list_get_pages_ValueError: invalid literal for int() with base 10: '下一页»'&lt;/span&gt;
&lt;span&gt;
开始下载地址：http:&lt;/span&gt;//www.mzitu.com/page/137&lt;span&gt;
OSError: image file &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; truncated (22 bytes &lt;span&gt;not&lt;/span&gt;&lt;span&gt; processed)
开始下载地址：http:&lt;/span&gt;//www.mzitu.com/page/138
125571&lt;span&gt; 
程序运行时间:28分27秒

进程完成，退出码 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pyquery相关链接：&lt;/p&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/gawel/pyquery&quot; target=&quot;_blank&quot;&gt;https://github.com/gawel/pyquery&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PyPI：&lt;a href=&quot;https://pypi.python.org/pypi/pyquery&quot; target=&quot;_blank&quot;&gt;https://pypi.python.org/pypi/pyquery&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;http://pyquery.readthedocs.io&quot; target=&quot;_blank&quot;&gt;http://pyquery.readthedocs.io&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jun 2018 15:32:00 +0000</pubDate>
<dc:creator>Py.qi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxinqi/p/9219476.html</dc:identifier>
</item>
<item>
<title>使用react全家桶制作博客后台管理系统 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/9213436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/9213436.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　笔者在做一个完整的博客上线项目，包括&lt;a href=&quot;https://xiaohuochai.cc&quot; target=&quot;_blank&quot;&gt;前台&lt;/a&gt;、&lt;a href=&quot;https://admin.xiaohuochai.cc&quot; target=&quot;_blank&quot;&gt;后台&lt;/a&gt;、&lt;a href=&quot;https://api.xiaohuochai.cc&quot; target=&quot;_blank&quot;&gt;后端接口&lt;/a&gt;和服务器配置。本文将详细介绍使用react全家桶制作的博客后台管理系统&lt;/p&gt;

&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;　　该项目是基于react全家桶（React、React-router-dom、redux、styled-components）开发的一套博客后台管理系统，用于&lt;a href=&quot;https://xiaohuochai.cc&quot; target=&quot;_blank&quot;&gt;前端小站&lt;/a&gt;的管理，主要功能包括游客浏览、文章管理、类别管理、评论通知、推荐设置和用户管理&lt;/p&gt;
&lt;p&gt;【访问地址】&lt;/p&gt;
&lt;p&gt;　　域名：&lt;a href=&quot;https://admin.xiaohuochai.cc&quot; target=&quot;_blank&quot;&gt;https://admin.xiaohuochai.cc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　Github: &lt;a href=&quot;https://github.com/littlematch0123/blog-admin&quot; target=&quot;_blank&quot;&gt;https://github.com/littlematch0123/blog-admin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　或者可以直接扫描二维码访问&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625103050051-1466577225.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;【项目介绍】&lt;/p&gt;
&lt;p&gt;　　采用移动优先的响应式布局，移动端、桌面端均可适配；字体大小使用em单位，桌面端的文字相应变大；移动端大量使用滑屏操作，桌面端通过光标设置、自定义滚动条、回车确定等，提升交互体验&lt;/p&gt;
&lt;p&gt;　　根据HTML标签内容模型，使用语义化标签，尽量减少标签层级，尽量使用React.Fragment来代替div&lt;/p&gt;
&lt;p&gt;　　采用统一的色调处理，除了黑白两色外，所有页面共使用了8种颜色，保证了页面颜色素雅、统一&lt;/p&gt;
&lt;p&gt;　　使用service worker实现了离线缓存，配置了robots，禁止搜索引擎抓取页面&lt;/p&gt;
&lt;p&gt;　　使用styled-components插件，实现css in JS。所有图标资源均采用svg格式，并存储到common/BaseImg组件中，方便管理，图片资源均上传到七牛云图床，使用外链访问。最终，html、css、image都使用js管理&lt;/p&gt;
&lt;p&gt;　　没有引用第三方组件库，如bootstrap或蚂蚁设计，而是自己开发了项目中所需的公共组件。在common目录下，封装了头像、筛选框、全屏、loading、遮罩、搜索框、滑屏、联动选择等组件，方便开发&lt;/p&gt;
&lt;p&gt;　　功能组件按照功能（Post、Comment...）而不是角色（controllers、models、views）分类，将展示组件component和容器组件container整合为一个文件&lt;/p&gt;
&lt;p&gt;　　状态管理借鉴了vuex的管理模式，action-types、action、reducer、selecter、state整合到每个模块目录的module.js文件下。为了方便扩展，所有的state都设置了filter字段&lt;/p&gt;
&lt;p&gt;　　使用配置数据，实现了数据和应用分离，配置数据包括API调用地址和颜色值，以常量的形式存储在constants目录下&lt;/p&gt;
&lt;p&gt;　　使用esLint规范JS代码，代码风格参照airbnb规范，所有命名采用驼峰写法，公共组件以Base为前缀，函数大多以get或set为前缀，事件函数以on为前缀，异步函数以async为后缀，布尔值基本以do或is为前缀&lt;/p&gt;
&lt;p&gt;　　使用styleLint规范CSS代码，按照布局类属性、盒模型属性、文本类属性、修饰类属性的顺序编写代码，并使用order插件进行校验&lt;/p&gt;
&lt;p&gt;　　使用react最新版本的方法，包括createRef()、getDerivedStateFromProps生命周期、 &lt;code&gt;React.Fragment&lt;/code&gt;语法糖等&lt;/p&gt;
&lt;p&gt;　　进行了代码优化，包括减少请求数量（文件合并 、小图片使用Base64、使用301而不是302重定向、静态资源使用强缓存、接口资源使用协商缓存、使用离线缓存、长缓存优化、CSS内联），减小资源大小（文件压缩、andriod下使用webp格式图片、开启gzip），优化网络连接（使用DNS预解析、使用keep-alive持久连接、使用HTTP2管道化连接），优化资源加载（优化资源加载位置、图片懒加载），减少重绘回流（减少兄弟选择器、动画元素硬件渲染、使用函数节流、及时清理环境）&lt;/p&gt;
&lt;p&gt;　　该项目的一个隐藏彩蛋是摇一摇功能，可以直接摇到前台页面，当然也可以再摇回来&lt;/p&gt;
&lt;p&gt;　　最终优化评分如下所示&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625132659233-854689018.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;功能演示&lt;/h3&gt;
&lt;p&gt;　　功能主要包括游客浏览、评论通知、用户管理、推荐设置、文章管理和类别管理&lt;/p&gt;
&lt;p&gt;【游客浏览】&lt;/p&gt;
&lt;p&gt;　　在没有管理员帐号的情况下，可以点击游客浏览进入后台。但是，游客只有浏览权限，没有操作权限&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625104013883-199756835.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【评论通知】&lt;/p&gt;
&lt;p&gt;　　有新评论未查看时，右上角快捷菜单上会出现评论通知的按钮。查看评论后，通知按钮消失&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625142309107-437319422.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【用户管理】&lt;/p&gt;
&lt;p&gt;　　用户管理包括查看所有用户信息、查看用户点赞情况、查看用户评论情况、按用户名拼音排序、按点赞数排序、按评论数排序以及设置用户状态&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625201123003-348209543.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【推荐管理】&lt;/p&gt;
&lt;p&gt;　　推荐管理包括文章推荐和专题推荐两类&lt;/p&gt;
&lt;p&gt;　　1、文章推荐&lt;/p&gt;
&lt;p&gt;　　文章推荐的功能包括更改推荐文章、更改背景图和更改次序&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625200703692-1017342521.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　2、专题推荐&lt;/p&gt;
&lt;p&gt;　　专题推荐的功能包括更改推荐专题、更改专题说明和更改次序&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625200914868-1515887277.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【文章管理】&lt;/p&gt;
&lt;p&gt;　　文章管理包括文章筛选、文章搜索、新建文章、编辑文章、删除文章、设置配图、查看点赞等功能&lt;/p&gt;
&lt;p&gt;　　1、文章筛选&lt;/p&gt;
&lt;p&gt;　　初始页显示全部文章，设置类别后，只显示筛选后的文章，文章查阅完成后，可返回文章筛选页&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625112313854-961506633.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　2、文章搜索&lt;/p&gt;
&lt;p&gt;　　初始页只显示搜索框，设置搜索词后，显示出相关文章，但每次只显示16篇，下拉刷新后，可继续显示。文章查阅完成后，可返回文章搜索页&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625112637550-729650932.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　3、新建文章&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625113010843-1483147296.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　4、编辑文章&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625113209829-1745002731.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　5、设置配图&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625114054851-2072865730.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　6、查看点赞和评论并删除文章&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625114225296-408828701.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【类别管理】&lt;/p&gt;
&lt;p&gt;　　类别管理包括查看类别、添加类别、编辑类别、删除类别&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625200129290-1138533364.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;目录结构&lt;/h3&gt;
&lt;p&gt;　　src目录下，包括assets(静态资源)、common(公共组件)、components(功能组件)、constants(常量配置)、store(redux)和utils(工具方法)这6个目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- assets // 存放静态资源，包括通用CSS和图片
    global.css // 全局CSS
    login_bg.jpg // 登录框背景图
- common // 存放公共组件
    BaseArticle.js // 文章组件
    BaseAvatar.js // 头像组件
&lt;span&gt;    ...
- components // 存放功能组件
    Category // 类别组件
      AddCategory.js // 类别添加组件
      DeleteCategory.js // 类别删除组件
      UpdateCategory.js // 类别更新组件      
      Category.js // 类别路由组件
      CategoryForm.js // 类别基础组件
      CategoryItem.js // 类别项组件
      CategoryItemList.js // 类别列表组件
      CategoryRootList.js // 类别根列表组件
      module.js //类别状态管理
&lt;span&gt;      ...
- constants // 存放常量配置
    API.js // 存放API调用地址
    Colors.js // 存放颜色值
- store // 存放redux
&lt;span&gt;    index.js
- utils // 存放工具方法
    async.js // fetch方法
    history.js // 路由方法
    util.js // 其他工具方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【公共组件】&lt;/p&gt;
&lt;p&gt;　　没有引用第三方组件库，如bootstrap或蚂蚁设计，而是自己开发了项目中所需的公共组件&lt;/p&gt;
&lt;p&gt;　　封装了文章组件、头像组件、返回组件、徽章组件、按钮组件、卡片组件、筛选框组件、全屏组件、图片组件、输入框组件、loading组件、遮罩组件、搜索框组件、滑屏组件、多行输入框组件、标题组件、面包屑组件、按钮组组件、反色按钮组件、自适应按钮组件、密码框组件和联动选择组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
BaseArticle.js  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文章组件&lt;/span&gt;
BaseAvatar.js &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头像组件&lt;/span&gt;
BaseBack.js &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回组件&lt;/span&gt;
BaseBadge.js  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 徽章组件&lt;/span&gt;
BaseButton.js &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按钮组件&lt;/span&gt;
BaseCard.js &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 卡片组件&lt;/span&gt;
BaseFilterList.js &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 筛选框组件&lt;/span&gt;
BaseFullScreen.js &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全屏组件&lt;/span&gt;
BaseImg.js  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图片组件&lt;/span&gt;
BaseInput.js  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入框组件&lt;/span&gt;
BaseLoading.js  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loading组件&lt;/span&gt;
BaseMask.js &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遮罩组件&lt;/span&gt;
BaseSearchBox.js  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 搜索框组件&lt;/span&gt;
BaseSwipeItem.js  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滑屏组件&lt;/span&gt;
BaseTextArea.js &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多行输入框组件&lt;/span&gt;
BaseTitle.js  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标题组件&lt;/span&gt;
BreadCrumb.js &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 面包屑组件&lt;/span&gt;
ButtonBox.js  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按钮组组件&lt;/span&gt;
ButtonInverted.js &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反色按钮组件&lt;/span&gt;
ButtonWithAutoWidth.js  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自适应按钮组件&lt;/span&gt;
InputPassword.js  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 密码框组件&lt;/span&gt;
LinkageSelector.js &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 联动选择组件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【功能组件】&lt;/p&gt;
&lt;p&gt;　　按照功能来设置目录，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;弹出框(Alert)
登录框(Auth)
类别管理(Category)
评论管理(Comment)
主页(Home)
点赞管理(Like)
文章管理(Post)
七牛传图(Qiniu)
推荐设置(Recommend)
页面尺寸(Size)
用户管理(User)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;整体思路&lt;/h3&gt;
&lt;p&gt;【全屏布局】&lt;/p&gt;
&lt;p&gt;　　使用设置高度的全屏布局方式，主要通过calc来实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &amp;lt;section style={{ height: `${wrapHeight}px` }}&amp;gt;
    &amp;lt;HomeHeader /&amp;gt;
    &amp;lt;Inner&amp;gt;&lt;span&gt;
        ...
    &lt;/span&gt;&amp;lt;/Inner&amp;gt;
    &amp;lt;HomeNav /&amp;gt;
  &amp;lt;/section&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; Header =&lt;span&gt; styled.header`
  height: 50px;
`
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Inner =&lt;span&gt; styled.main`
  height: calc(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;% -&lt;span&gt; 100px);
  background: ${PRIMARY_BG_COLOR};
`
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; List =&lt;span&gt; styled.nav`
  height: 50px;
`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【层级管理】&lt;/p&gt;
&lt;p&gt;　　项目的层级z-index，只使用0-3&lt;/p&gt;
&lt;p&gt;　　全屏的弹出框优化级最高，设置为3；侧边栏设置为2；页面元素默认为0，如有需要，要设置为1&lt;/p&gt;
&lt;p&gt;【全局弹出层】&lt;/p&gt;
&lt;p&gt;　　在入口文件app.js中设置全局的弹出层和loading，所有组件都可以共用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; app.js&lt;/span&gt;
&lt;span&gt;  render() {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; { doShowLoading, alertText, hideAlertText } = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;React.Fragment&amp;gt;&lt;span&gt;
        { doShowLoading &lt;/span&gt;&amp;amp;&amp;amp; &amp;lt;AlertWithLoading /&amp;gt;&lt;span&gt; }
        { &lt;/span&gt;!!alertText &amp;amp;&amp;amp; &amp;lt;AlertWithText text={alertText} onExit={hideAlertText} /&amp;gt;&lt;span&gt;}
        &lt;/span&gt;&amp;lt;Router history={history} &amp;gt;&lt;span&gt;
            ...
        &lt;/span&gt;&amp;lt;/Router&amp;gt;
      &amp;lt;/React.Fragment&amp;gt;&lt;span&gt;
    )
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【路由管理】&lt;/p&gt;
&lt;p&gt;　　react-router-dom第四版采用了动态路由，在组件目录内，以组件同名文件保存该组件内的路由&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; category.js&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; Category = () =&amp;gt;&lt;span&gt;
  (
    &lt;/span&gt;&amp;lt;Switch&amp;gt;
      &amp;lt;Route exact path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/categories&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; component={CategoryRootList} /&amp;gt;
      &amp;lt;Route exact path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/categories/:id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; component={CategoryItemList} /&amp;gt;
      &amp;lt;Route path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/categories/:id/add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; component={AddCategory} /&amp;gt;
      &amp;lt;Route path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/categories/:id/update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; component={UpdateCategory} /&amp;gt;
      &amp;lt;Route path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/categories/:id/delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; component={DeleteCategory} /&amp;gt;
    &amp;lt;/Switch&amp;gt;&lt;span&gt;
  )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【状态管理】&lt;/p&gt;
&lt;p&gt;　　参照vuex的状态管理方式，将每个组件的状态管理命名为module.js，保存在当前组件目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
import auth &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/Auth/module&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import size &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/Size/module&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import alert &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/Alert/module&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import categories &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/Category/module&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import posts &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/Post/PostsModule&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import post &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/Post/PostModule&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import comments &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/Comment/module&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import likes &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/Like/module&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import qiniu &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/Qiniu/module&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import users &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/User/module&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;const&lt;/span&gt; rootReducer =&lt;span&gt; combineReducers({
  auth, size, alert, categories, posts, post, comments, likes, qiniu, users
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　每个模块的状态都设置有filter字段，方便扩展&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; action-types&lt;/span&gt;
export &lt;span&gt;const&lt;/span&gt; SET_COMMENTS_FILTER = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SET_COMMENTS_FILTER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; state&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; initialState =&lt;span&gt; {
  filter: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
  docs: []
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; action&lt;/span&gt;
export &lt;span&gt;const&lt;/span&gt; setCommentsFilter = filter =&amp;gt; dispatch =&amp;gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
  resolve()
  dispatch({ type: SET_COMMENTS_FILTER, filter })
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reducer&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; comments = (state = initialState, action) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SET_COMMENTS_FILTER:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { ...state, filter: action.filter }

}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; comments

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; selector&lt;/span&gt;
export &lt;span&gt;const&lt;/span&gt; getCommentsFilter = state =&amp;gt; state.comments.filter
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【数据传递】&lt;/p&gt;
&lt;p&gt;　　组件间的数据传递方式一般有三种，一种是使用react中的函数传参，另一种是使用路由的location属性，还有一种是通过redux&lt;/p&gt;
&lt;p&gt;　　1、函数传参&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
// PostRecommendItem
&amp;lt;&lt;span&gt;BaseSearchBox
  searchText=&lt;span&gt;{title}
  datas=&lt;span&gt;{posts}
  onInput={this&lt;span&gt;.onInput}
  onBack={() =&amp;gt; { this.setState({ doShowSearchBox: false&lt;span&gt; }) }}
/&amp;gt;&lt;span&gt;

  onInput = data =&amp;gt;&lt;span&gt; {
    this.setState({ doShowSearchBox: false&lt;span&gt; })
    const { updatePostAsync, showAlertText } = this&lt;span&gt;.props
    const { prevData, datas } = this&lt;span&gt;.statethis&lt;span&gt;.setState({
        datas: datas.map(t =&amp;gt;&lt;span&gt; {
          if (t.number === data.number) return&lt;span&gt; data
          return&lt;span&gt; t
        })
      })
　　　　...&lt;span&gt;
  }

// BaseSearchBox
&amp;lt;List innerRef={this.scrollRef}&amp;gt;&lt;span&gt;
  {resultDatas.map(t =&amp;gt;
    &amp;lt;Item key={t._id} onClick={() =&amp;gt; { onInput &amp;amp;&amp;amp; onInput(t) }}&amp;gt;{t.title}&amp;lt;/Item&amp;gt;&lt;span&gt;)}
  {resultDatas.length &amp;gt;= limitNumber &amp;amp;&amp;amp; !doNeedMoreDatas &amp;amp;&amp;amp;
    &amp;lt;ExtendedItem&amp;gt;已经到底了...&amp;lt;/ExtendedItem&amp;gt;&lt;span&gt;}
&amp;lt;/List&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、location传递state&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
// CommentForm
&lt;span&gt;  constructor(props) {
    super(props)
    const { operate, location } =&lt;span&gt; props
    if (operate === 'update' &amp;amp;&amp;amp;&lt;span&gt; location.state) {
      const { content } =&lt;span&gt; location.state.comment
      this.state =&lt;span&gt; { content }
    } else&lt;span&gt; {
      this.state = { content: ''&lt;span&gt; }
    }
  }

// CommentList
history.push({ pathname: `${BasePostUrl}/comments/${t._id}/update`, state: { comment: t } })&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、使用redux&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
//CategoryForm.js
&lt;span&gt;  componentDidMount() {
    const { operate, match, setCategoriesFilter } = this&lt;span&gt;.props
    setCategoriesFilter(Number(match.params.id)).then(() =&amp;gt;&lt;span&gt; {
      if (operate === 'update'&lt;span&gt;) {
        const { category } = this&lt;span&gt;.props
        const { name, description } =&lt;span&gt; category
        if&lt;span&gt; (name) {
          this&lt;span&gt;.setState({ name, description })
        } else&lt;span&gt; {
          history.push(`/categories/${getParentNumber(Number(match.params&lt;span&gt;.id))}`)
        }
      }
    })
  }
const mapStateToProps = state =&amp;gt;&lt;span&gt; ({
  category: getCategoryByFilter(state)
})
export default connect(mapStateToProps, { setCategoriesFilter })(CategoryForm)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;项目优化&lt;/h3&gt;
&lt;p&gt;【子页面刷新】&lt;/p&gt;
&lt;p&gt;　　子页面刷新时，可能会出现得不到从父级传递过来的数据的情况，笔者的处理是跳转到父级页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  componentDidMount() {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; { operate, location, match } = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (operate === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;location.state) {
      history.push(`&lt;/span&gt;/posts/${match.&lt;span&gt;params&lt;/span&gt;.postId}/&lt;span&gt;comments`)
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【reselect】&lt;/p&gt;
&lt;p&gt;　　通过reselect来保存状态，减少状态查询，提升性能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;const&lt;/span&gt; getRecommendedCategories =&lt;span&gt; createSelector(getCategories,
  datas &lt;/span&gt;=&amp;gt; datas.filter(t =&amp;gt; t.recommend).sort((a, b) =&amp;gt; a.index - b.index))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【promise】&lt;/p&gt;
&lt;p&gt;　　为action添加Promise，方便状态改变后的处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;const&lt;/span&gt; setCategoriesFilter = filter =&amp;gt; dispatch =&amp;gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
  resolve()
  dispatch({ type: SET_CATEGORIES_FILTER, filter })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【组件共用】&lt;/p&gt;
&lt;p&gt;　　由于编辑和新建组件用到的元素是一样的，只不过，新建组件时内容为空，编辑组件时需要添加内容，这时就可以复用组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const AddCategory = ({ match }) =&amp;gt; &amp;lt;CategoryForm match={match} operate=&quot;add&quot; /&amp;gt;
const UpdateCategory = ({ match }) =&amp;gt; &amp;lt;CategoryForm match={match} operate=&quot;update&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【清理环境】&lt;/p&gt;
&lt;p&gt;　　如果使用addEventListener绑定了事件处理函数，在组件销毁的时候，要及时清理环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  componentDidMount() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.scrollRef.current.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scroll&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, throttle(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onScroll))
  }
  componentWillUnmount() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.scrollRef.current.removeEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scroll&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, throttle(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onScroll))
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【生命周期函数】&lt;/p&gt;
&lt;p&gt;　　1、使用getDerivedStateFromProps生命周期函数时，如果不设置constructor，会有如下警告&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Did not properly initialize state during construction. Expected state to be an &lt;span&gt;object&lt;/span&gt;, but it was undefined.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　添加空state即可解决&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  constructor(props) {
    super(props)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {}
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、使用componentDidMount生命周期函数时，如果在该函数中直接使用this.setState()，会有如下警告&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Do not use setState &lt;span&gt;in&lt;/span&gt; componentDidMount  react/no-did-mount-&lt;span&gt;set&lt;/span&gt;-state
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将state设置转移到then方法，或者另一个函数中即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentDidMount() {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.test()
}
test() {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState({ name: &lt;span&gt;''&lt;/span&gt;&lt;span&gt; })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【应用和数据分离】&lt;/p&gt;
&lt;p&gt;　　使用配置数据，实现数据和应用分离，配置数据包括API调用地址和颜色值，以常量的形式存储在constants目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; API.js&lt;/span&gt;
&lt;span&gt;let API_HOSTNAME
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;development&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
  API_HOSTNAME &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/local&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
  API_HOSTNAME &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BASE_AUTH_URL = `${API_HOSTNAME}/auth/&lt;span&gt;admin`
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BASE_USER_URL = `${API_HOSTNAME}/&lt;span&gt;users`
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BASE_POST_URL = `${API_HOSTNAME}/&lt;span&gt;posts`
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BASE_TOPIC_URL = `${API_HOSTNAME}/&lt;span&gt;topics`
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BASE_CATEGORY_URL = `${API_HOSTNAME}/&lt;span&gt;categories`
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BASE_LIKE_URL = `${API_HOSTNAME}/&lt;span&gt;likes`
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BASE_COMMENT_URL = `${API_HOSTNAME}/&lt;span&gt;comments`
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BASE_RECOMMEND_URL = `${API_HOSTNAME}/&lt;span&gt;recommends`
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BASE_QINIU_URL = `${API_HOSTNAME}/&lt;span&gt;qiniu`
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; STATIC = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://static.xiaohuochai.site&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; CLIENT_URL = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.xiaohuochai.cc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Colors.js&lt;/span&gt;
export &lt;span&gt;const&lt;/span&gt; PRIMARY_COLOR = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#00a8e5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; DARK_COLOR = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#0066cc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; ERROR_COLOR = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#f67280&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; PRIMARY_BG_COLOR = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#fafafa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; TRANSPARENT_BG_COLOR = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rgba(7, 17, 27, .4)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; DARK_BG_COLOR = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#f5f5f5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; PRIMARY_LINE_COLOR = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#eee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; DARK_LINE_COLOR = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#ebedf0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【函数节流】&lt;/p&gt;
&lt;p&gt;　　为触发频率较高的函数使用函数节流&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 函数节流
 * @param {fn} function test(){}
 * @return {fn} function test(){}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; throttle = (fn, wait = &lt;span&gt;100&lt;/span&gt;) =&amp;gt;&lt;span&gt; function func(...args) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fn.timer) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
  fn.timer &lt;/span&gt;= setTimeout(() =&amp;gt;&lt;span&gt; {
    fn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args)
    fn.timer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
  }, wait)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;功能实现&lt;/h3&gt;
&lt;p&gt;【登录设置】&lt;/p&gt;
&lt;p&gt;　　将用户信息保存到sessionStorage中并检测，如果不存在，则跳转到登录页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;Router history={history} &amp;gt;
  &amp;lt;Switch&amp;gt;
    &amp;lt;Route path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; component={AuthLogin} /&amp;gt;
    &amp;lt;&lt;span&gt;Route
      path&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      render&lt;/span&gt;={props =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sessionStorage.getItem(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &amp;amp;&amp;amp; sessionStorage.getItem(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)) {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Home {...props} /&amp;gt;&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Redirect to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;
      }}
    &lt;/span&gt;/&amp;gt;
  &amp;lt;/Switch&amp;gt;
&amp;lt;/Router&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【全角空格占位】&lt;/p&gt;
&lt;p&gt;　　使用全角空格占位，从而使文字对齐&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;Label htmlFor=&quot;username&quot;&amp;gt;用户名：&amp;lt;/Label&amp;gt;
&amp;lt;Label htmlFor=&quot;password&quot;&amp;gt;&amp;amp;emsp;密码：&amp;lt;/Label&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【一像素边框】&lt;/p&gt;
&lt;p&gt;　　将伪元素高度设置为1px，然后用 transform缩小到原来的一半&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div {
  position: relative;
  &lt;/span&gt;&amp;amp;&lt;span&gt;::after {
    position: absolute;
    left: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    right: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    height: 1px;
    transform: scaleY(.&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    content: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
  }
`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【缓动弹出层】&lt;/p&gt;
&lt;p&gt;　　过渡弹出层有两种实现方式，包括transition和animation，该项目使用transition的方式实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;StyledMask className={doShowMenuList ? 'mask-show' : ''} /&amp;gt;
&amp;lt;StyledList className={doShowMenuList ? 'transform-show' : ''} /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const StyledList =&lt;span&gt; styled(HomeMenuList)`
  transform: translateY(-100%&lt;span&gt;);
  transition: .2s;
`
const StyledMask =&lt;span&gt; styled(BaseMask)`
  z-index: 2&lt;span&gt;;
  display: none;
`
const MenuBox =&lt;span&gt; styled.div`
  cursor: pointer;
  &amp;amp; .transform-&lt;span&gt;show {
    transform: translateY(0&lt;span&gt;);
  }
  &amp;amp; .mask-&lt;span&gt;show {
    display: block;
  }
`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【图标管理】&lt;/p&gt;
&lt;p&gt;　　所有的图标都使用SVG格式，存储在common/BaseImg.js文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; BaseImg.js&lt;/span&gt;&lt;span&gt;
...
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Home = props =&amp;gt;&lt;span&gt; (
  &lt;/span&gt;&amp;lt;svg height={&lt;span&gt;24&lt;/span&gt;} viewBox=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0 0 24 24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; width={&lt;span&gt;24&lt;/span&gt;} {...props}&amp;gt;
    &amp;lt;path d=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;path d=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M0 0h24v24H0z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; fill=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/svg&amp;gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【搜索实现】&lt;/p&gt;
&lt;p&gt;　　处理搜索功能时，需要特别处理正则表达式中的元字符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;static&lt;/span&gt;&lt;span&gt; getReg(searchText) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RegExp(searchText.replace(/[[(){}^$|?*+.\\-]/g, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\$&amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果，将间隔符-放在中间，大写字母，如V会被匹配为/V&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RegExp(searchText.replace(/[[(){}^$|?*+.-\\]/g, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\$&amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时的-被识别为范围间隔符，相当于.到\之间的字符，正好包括了所有的大写字母，所以。一定要把-放在最后&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625215213824-457733458.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【滑屏实现】&lt;/p&gt;
&lt;p&gt;　　滑屏主要通过touch事件来实现，一般地，有两种形式。一种是当前元素滑动，另一种是其他元素滑动。该项目采用较简单的第二种&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;static&lt;/span&gt;&lt;span&gt; checkSwipe(absMove, duration) {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; THRESHOLD = &lt;span&gt;10&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; SHORTESTTIME = &lt;span&gt;300&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 距离大于10，且时间小于300ms，才算做一次滑动&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; Boolean(absMove &amp;gt; THRESHOLD &amp;amp;&amp;amp; duration &amp;lt;&lt;span&gt; SHORTESTTIME)
  }
  onTouchStart &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.startTime = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime()
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.startX = e.targetTouches[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].pageX
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.startY = e.targetTouches[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].pageY
  }
  onTouchEnd &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; { pageX, pageY } = e.changedTouches[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果y轴移动距离大于元素高度，说明手指已经移出元素本身，则取消滑动&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (pageY - &lt;span&gt;this&lt;/span&gt;.startY &amp;gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientHeight) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; moveX = pageX - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.startX
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; duration = &lt;span&gt;new&lt;/span&gt; Date().getTime() - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.startTime
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果符合滑动要求，且向左滑动，则控制条滑出&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (BaseSwipeItem.checkSwipe(Math.abs(moveX), duration) &amp;amp;&amp;amp; moveX &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState({ doShowControlBox: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; })
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState({ doShowControlBox: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; })
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【密码框实现】&lt;/p&gt;
&lt;p&gt;　　密码框的右侧一般都有一个小图标用于显示密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;Wrap className={className} {...rest} &amp;gt;
  &amp;lt;&lt;span&gt;StyledInput
    id&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    textIndent&lt;/span&gt;=&lt;span&gt;{textIndent}
    color&lt;/span&gt;=&lt;span&gt;{color}
    value&lt;/span&gt;=&lt;span&gt;{value}
    onChange&lt;/span&gt;=&lt;span&gt;{onChange}
    type&lt;/span&gt;={doShowPassword ? &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
  &lt;/span&gt;/&amp;gt;&lt;span&gt;
  { doShowPassword &lt;/span&gt;?
    &amp;lt;Visibility onClick={onChangeStatus} /&amp;gt;&lt;span&gt;
    : &lt;/span&gt;&amp;lt;VisibilityOff onClick={onChangeStatus} /&amp;gt;&lt;span&gt;
  }
&lt;/span&gt;&amp;lt;/Wrap&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【fetch函数封装】&lt;/p&gt;
&lt;p&gt;　　该项目是基于create-react-app构建的，自带fetch功能。封装fetch函数到utils目录下的async.js文件中，将loading组件、alert组件整合到fetch函数的整个数据获取过程中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
import { showLoading, hideLoading, showAlertText, hideAlertText } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/Alert/module&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { logout } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/components/Auth/module&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;const&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; = ({ dispatch, url, method, data, headers, success, fail, doHideAlert }) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 显示loading&lt;/span&gt;
&lt;span&gt;  dispatch(showLoading())
  let fetchObj &lt;/span&gt;=&lt;span&gt; {}
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method) {
    fetchObj &lt;/span&gt;=&lt;span&gt; {
      method,
      body: JSON.stringify(data),
      headers: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Headers({ ...headers, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; })
    }
  }
  fetch(url, fetchObj).then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭loading&lt;/span&gt;
&lt;span&gt;    dispatch(hideLoading())
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res.json()
  }).then(json &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成功&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (json.code === &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;!doHideAlert &amp;amp;&amp;amp;&lt;span&gt; dispatch(showAlertText(json.message))
      setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        dispatch(hideAlertText())
      }, &lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
      success &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; success(json.result)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义错误&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (json.code === &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
      dispatch(showAlertText(json.message))
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 系统错误&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (json.code === &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
      dispatch(showAlertText(json.message))
      fail &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; fail(json.err)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 认证失败&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (json.code === &lt;span&gt;3&lt;/span&gt;&lt;span&gt;) {
      dispatch(showAlertText(json.message))
      dispatch(logout)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 权限不足&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (json.code === &lt;span&gt;4&lt;/span&gt;&lt;span&gt;) {
      dispatch(showAlertText(json.message))
    }
  }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(() =&amp;gt;&lt;span&gt; {
    dispatch(showAlertText(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;服务器故障&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
  })
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【组件内路由】&lt;/p&gt;
&lt;p&gt;　　如果要在组件内使用路由功能，可封装utils/history.js文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; utils/history.js&lt;/span&gt;
import createBrowserHistory &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;history/createBrowserHistory&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; customHistory =&lt;span&gt; createBrowserHistory()
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; customHistory
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Router中使用history={history}，而不是BrowserRouter&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; app.js&lt;/span&gt;
import history &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/utils/history&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;lt;Router history={history} &amp;gt;
  &amp;lt;Switch&amp;gt;
    &amp;lt;Route path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; component={AuthLogin} /&amp;gt;
    &amp;lt;&lt;span&gt;Route
      path&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      render&lt;/span&gt;={props =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sessionStorage.getItem(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &amp;amp;&amp;amp; sessionStorage.getItem(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)) {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Home {...props} /&amp;gt;&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Redirect to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;
      }}
    &lt;/span&gt;/&amp;gt;
  &amp;lt;/Switch&amp;gt;
&amp;lt;/Router&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，在组件中引用即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import  history  &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@/utils/history&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳转到首页&lt;/span&gt;
history.push(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;兼容处理&lt;/h3&gt;
&lt;p&gt;【虚拟键盘】&lt;/p&gt;
&lt;p&gt;　　andriod下，虚拟键盘会影响可视区域的高度；而IOS下，不会影响&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
可视区域高度 = document.documentElement.clientHeight - 虚拟键盘的高度;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　bug重现如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201806/740839-20180625211706171-1115723840.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　所以，要将包含input域的页面高度设为固定&lt;/p&gt;
&lt;p&gt;　　在页面初始化时，获取页面高度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; app.js&lt;/span&gt;
&lt;span&gt;  componentDidMount() {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; { setWrapSize } = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; { clientHeight, clientWidth } =&lt;span&gt; document.documentElement
    setWrapSize({ clientHeight, clientWidth })
    window.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orientationchange&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setSize)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后通过行间样式，将此高度设置到包含input域的页面上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; BaseFullScreen&lt;/span&gt;
&amp;lt;Wrap className={className} style={{ height: `${wrapHeight}px` }} {...rest}&amp;gt;{children}&amp;lt;/Wrap&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【取消自动大写】&lt;/p&gt;
&lt;p&gt;　　IOS下，input域会自动大写首字母，设置autoCapitallize=&quot;off&quot;即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; BaseInput = ({ value, onChange, ...rest }) =&amp;gt;
  &amp;lt;Input {...rest} value={value} onChange={onChange} autoComplete=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; autoCapitalize=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 【光标颜色】&lt;/p&gt;
&lt;p&gt;　　默认情况下，光标颜色与字体颜色color相同，但也可以通过caret-color属性来单独设置&lt;/p&gt;
&lt;p&gt;　　但是，IOS的光标不支持caret-color，与字体颜色无关，默认为紫蓝色。所以，尽量不要设置蓝色或紫色背景，否则光标看不清楚&lt;/p&gt;
&lt;p&gt;【页面放大】&lt;/p&gt;
&lt;p&gt;　　IOS下，input获取焦点时会放大，meta设置user-scalable=no，可取消放大效果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1, user-scalable=no, shrink-to-fit=no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【圆角】&lt;/p&gt;
&lt;p&gt;　　IOS下，input域只显示底边框时，会出现两个底部底边圆角效果，设置border-radius:0即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
border-radius:&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【轮廓outline】&lt;/p&gt;
&lt;p&gt;　　android浏览器下，input域处于焦点状态时，默认会有一圈淡黄色的轮廓outline效果&lt;/p&gt;
&lt;p&gt;　　通过设置outline:none可将其去除&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
outline: none
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【点击背景】&lt;/p&gt;
&lt;p&gt;　　在移动端，点击可点击元素时，android下会出现淡蓝色背景，IOS下会出现灰色背景&lt;/p&gt;
&lt;p&gt;　　bug重现如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/bg.gif&quot; alt=&quot;&quot; width=&quot;160&quot; height=&quot;151&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　可以通过-webkt-tap-hightlight-color属性的设置，取消点击时出现的背景效果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
*&lt;span&gt; {
  &lt;/span&gt;-webkit-tap-highlight-color: rgba(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【局部不滚动】&lt;/p&gt;
&lt;p&gt;　　IOS下，可能会出现局部滚动不流畅，甚至局部不滚动的bug&lt;/p&gt;
&lt;p&gt;　　通过在该元素上设置overflow-scrolling属性为touch即可解决&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div {
  &lt;/span&gt;-webkit-overflow-&lt;span&gt;scrolling: touch;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【高度无效】&lt;/p&gt;
&lt;p&gt;　　在IOS下，设置height:100%，如果父级的flex值为1，而没有设置具体高度，则100%高度设置无效&lt;/p&gt;
&lt;p&gt;　　处理方法是，在父级通过计算来设置具体高度height，如height: calc(100% - 100px)&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;【shrink-to-fit=no】&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　IOS9+系统下，使用Viewport元标记&quot;width=device-width&quot;会导致页面缩小以适应溢出视口边界的内容。可以通过添加&quot;shrink-to-fit=no&quot;到meta标签来覆盖此行为，增加的值将阻止页面缩放以适应视口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no，shrink-to-fit=no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 25 Jun 2018 15:31:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/9213436.html</dc:identifier>
</item>
<item>
<title>常见游戏服务器业务逻辑和模板 - Ron Ngai</title>
<link>http://www.cnblogs.com/rond/p/9226799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rond/p/9226799.html</guid>
<description>&lt;h3 id=&quot;背景&quot;&gt;0. 背景&lt;/h3&gt;
&lt;p&gt;服务器框架设计者，如果设计的好，考虑到了这几种情况，无论是对于游戏服务器逻辑清晰度，还是对于写业务逻辑的程序员来说，是非常友好的。游戏服务器业务逻辑写多了，一个游戏策划提出的需求归纳到服务器业务逻辑开发上面，也就无非几种情况需要处理。&lt;/p&gt;
&lt;h3 id=&quot;业务逻辑模板&quot;&gt;1. 业务逻辑模板&lt;/h3&gt;
&lt;p&gt;下面给出代码模板，无论何种语言开发，大体都类似。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode lua&quot;&gt;
&lt;code class=&quot;sourceCode lua&quot;&gt;
&lt;span class=&quot;co&quot;&gt;-- 数据结构&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- tbPlayer 常见字段&lt;/span&gt;
tbPlayer &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;{&lt;/span&gt;
    dSocketId &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    time_rec  &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;{&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- 常见时间&lt;/span&gt;
        birth        &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
        login       &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
        offline     &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
        dailyResets &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;{[{&lt;/span&gt;H&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;M&lt;span class=&quot;ot&quot;&gt;}]&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; V&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;...}&lt;/span&gt;
        weeklyReset &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;},&lt;/span&gt;
    sysA &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; tbAInfo&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- 某系统&lt;/span&gt;
    sysB &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; tbBInfo&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- 某系统&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- 业务系统常见字段&lt;/span&gt;
tbAInfo &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;{&lt;/span&gt;
    lastTime &lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- 上一次刷新时间&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; born&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;tbPlayer&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- todo 创建&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- 初始化数据，预处理数据&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; loadData&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;tbPlayer&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- todo 获取数据&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; saveData&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;tbPlayer&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- todo 保存数据&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- 定时？即时&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; onLogin&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;tbPlayer&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- todo 登录数据预处理&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; offline&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;tbPlayer&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- todo 下线数据处理&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- 登出/离线&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; sendOnLogin&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;tbPlayer&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- todo 登录协议同步&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- 通常 dailyReset也会默认调用该函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; dailyReset&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;tbPlayer&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; tbTime&lt;span class=&quot;ot&quot;&gt;={&lt;/span&gt;dHour&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; dMinute&lt;span class=&quot;ot&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- todo 每日重置&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- 0点，也有其他时段的需求&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;2. 数据结构&lt;/h3&gt;
&lt;p&gt;一般游戏服是将数据直接存在内存里面，可能有些做法是即时保存，有些是定时保存。也有跟传统网站开发类似的，每次业务逻辑需要数据的时候，从数据库取出来，修改之后再存进去。毕竟游戏类型颇多，不同的游戏采用不同的持久化策略是很常见的。以上说的三种，再项目中，笔者都见到过。&lt;/p&gt;
&lt;p&gt;关于游戏业务的数据结构的设计，个人经验说下。首先跟时间相关的数据主要有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;birth 建号时间&lt;/li&gt;
&lt;li&gt;login 上线时间&lt;/li&gt;
&lt;li&gt;offline 下线时间&lt;/li&gt;
&lt;li&gt;dailyResets 每日重置时间，存在多个时间点&lt;/li&gt;
&lt;li&gt;weeklyReset 每周重置时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大多数业务逻辑都需要围绕在以上几个时间点来进行。这几个地方处理的好，是能够大幅度提高程序员的开发效率的。&lt;br/&gt;dailyResets和weeklyReset时间点记录都是为了实现每日重置，每周重置的逻辑。&lt;br/&gt;每日重置需要注意下，可能存在多个时间点。凌晨0点是进行每日重置最常见的时间点。但是也有些游戏为了照顾玩家休息，或者为了降低服务器在0点的压力，将部分或全部重置设置为其他时间点的，例如凌晨3点，凌晨5点。&lt;br/&gt;每周重置的情况比较少存在多个的，一般选择周一凌晨0点。&lt;/p&gt;
&lt;p&gt;很多游戏都会为了前期的七日留存做很多工作，建号时间也往往在这些地方需要。当然这是个很有用的字段，无论是对于业务逻辑，还是对于游戏数据分析，都需要建号时间。&lt;/p&gt;
&lt;p&gt;上线时间是最常见的时间了，一般游戏只在玩家在线的时候处理逻辑。玩家一旦下线，很少再会对玩家数据进行处理。等到玩家再次上线的时候，才会对数据进行处理计算。补回那些玩家不在线，而又需要执行的数据。如每日邮件，每日奖励这种，我们不会真的每天都会将玩家数据从数据库取出来进行处理，而且等到玩家上线的时候再运算那些不在线时期发生的事情。而这些处理，都依赖于玩家的上次上线时间来计算。&lt;/p&gt;
&lt;p&gt;下线时间用的没有上线时间那么多，但是也不少。&lt;/p&gt;
&lt;h3 id=&quot;常见逻辑&quot;&gt;3. 常见逻辑&lt;/h3&gt;
&lt;h4 id=&quot;建号-born&quot;&gt;3.1. 建号 born&lt;/h4&gt;
&lt;p&gt;玩家的一切都起源于建号。建号需要进行一些数据初始化，如一些基础装备，基础属性。&lt;/p&gt;
&lt;h4 id=&quot;持久化-loaddata和savedata&quot;&gt;3.2. 持久化 loadData和saveData&lt;/h4&gt;
&lt;p&gt;玩家登录的时候，我们需要把数据从数据库拿出到游戏服务器的内存里面。再数据发生改变之后，又需要存储到数据库进行存档，以防服务器崩溃发生数据丢失。但是每次发生改变如果都进行存储的话，无疑对数据库的压力会很大。为了权衡性能和数据安全，一般需要制定存储策略，如定时存储，或者定时存储加部分数据即时存储。不同的数据重要程度不一样，可以采用不同的存储策略。&lt;/p&gt;
&lt;h4 id=&quot;玩家上线-onlogin和sendonlogin&quot;&gt;3.3. 玩家上线 onLogin和sendOnLogin&lt;/h4&gt;
&lt;p&gt;为什么需要将上线的操作拆分&lt;code&gt;onLogin&lt;/code&gt;和&lt;code&gt;sendOnLogin&lt;/code&gt;两个函数。两者的区别是，前者用于进行数据预处理。补回类似刚刚说的，每日邮件啊，每日奖励那些处理。后者是再数据预处理执行完了之后，进行该业务逻辑的协议同步。将数据预处理和协议同步分开是非常有必要和方便的。另外如果某个系统依赖于别的系统，该系统的onLogin操作需要放在别的系统的onLogin之后。&lt;/p&gt;
&lt;h4 id=&quot;玩家下线和断线重连-offline和reconnect&quot;&gt;3.4. 玩家下线和断线重连 offline和reconnect&lt;/h4&gt;
&lt;p&gt;玩家下线往往存在非常规操作，所以下线一般没有协议同步，只有数据处理。下线一般放在与客户端socket断开的地方处理。下线也可以决定是否进行存档。需要特别注意的是，再手游里面，断线是非常容易发生的。所以需要考虑断线重连的情况。是否立即存库其实也跟断线重连的设计相关。如果保留玩家的数据再内存一段时间，如1分钟，30分钟，offline的操作在手游里面就会极大的变少。可以根据下线成本自行考虑把。但是操作是必不可少的，只是执行的数量的问题。&lt;/p&gt;
&lt;h3 id=&quot;结尾&quot;&gt;4. 结尾&lt;/h3&gt;
&lt;p&gt;以上是个人经验总结出来的业务逻辑开发场景。只是单纯将业务逻辑的常见，此处不讨论游戏服务器的框架设计，如网络，日志，协议，持久化等。这些其实才是游戏服务器设计者的大头。&lt;/p&gt;
&lt;p&gt;好记性不如烂笔头。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jun 2018 14:56:00 +0000</pubDate>
<dc:creator>Ron Ngai</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rond/p/9226799.html</dc:identifier>
</item>
<item>
<title>【网页加速】lua redis的二次升级 - ZepheryWen</title>
<link>http://www.cnblogs.com/w1570631036/p/9226519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w1570631036/p/9226519.html</guid>
<description>&lt;p&gt;之前发过openresty的相关文章，也是用于加速网页速度的，但是上次没有优化好代码，这次整理了下，优化了nginx的配置和lua的代码，感兴趣的话可以看看上篇的文章：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/w1570631036/p/8449373.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/w1570631036/p/8449373.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了学习，不断的给自己的服务器装东西，又是logstash，又是kafka，导致主站网络负载、cpu消耗过大，再加上tomcat这个本身就特别占用内存的东西，只要稍微刷新一下网站，就能感受到蜗牛般的速度，实在受不了，前段时间给网站加了n多层缓存，依旧没有改观多少，想了想，算了，一直都这么卡，还不如直接将动态的网站直接变成静态网页存储在redis里面，然后关掉tomcat，貌似没有改观多少，但是在xshell里面敲命令没那么卡了，这里，也提出了一种别样的网站加速方法——redis存储静态网页。&lt;br/&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/2018625185735.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一总体流程如下&quot;&gt;一、总体流程如下&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/201862519474.png!/scale/60&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.一次请求过来，通过openresty的nginx来访问lua脚本；&lt;br/&gt;2.读取redis中是否存在该uri对应的静态网页，如果有，则直接返回，否则回源到tomcat，然后将响应的内容保存到redis里面。&lt;/p&gt;
&lt;h2 id=&quot;二nginx的设置&quot;&gt;二、nginx的设置&lt;/h2&gt;
&lt;p&gt;openresty中自带了nginx，所以只需要配置一下即可，我们最终的目前是拦截所有以html结尾的请求，如果是以其他后缀结尾的，比如do，则可以直接回滚到tomat里面去。&lt;br/&gt;由于篇幅的关系，只粘贴部分nginx配置，想看全的请转至：&lt;a href=&quot;https://github.com/Zephery/micro-service/blob/master/conf/nginx/mynginxconfig.ngx&quot;&gt;mynginxconfig.ngx&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;    server {
        listen       80;
        # listen       443 ssl;   # ssl
        server_name  www.wenzhihuai.com;
        location  ~ .*\.(html)$ {       //拦截所有以html结尾的请求，调用lua脚本
            ...
            charset utf8;
            proxy_pass_request_headers off ;
            # 关闭缓存lua脚本，调试的时候专用
            lua_code_cache off;
            content_by_lua_file /opt/lua/hello.lua;
        }
        location / {        //nginx是按顺序匹配的，如果上面的不符合，那么将回滚tomcat
            default_type    text/html;
            root   html;
            index  index.html index.htm;
            ...
            # websocket
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection &quot;upgrade&quot;;
            proxy_pass http://backend;
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;三lua脚本&quot;&gt;三、lua脚本&lt;/h2&gt;
&lt;p&gt;为了方便key的操作，经过测试，即使uri带有各种字符，比如 ? . html = &amp;amp;等，都是可以直接设置为redis中的key的，所以，不是那么的需要考虑redis的key违反规则，可以直接将uri设置为key。具体流程如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;local key = request_uri
首先，key为请求访问的uri
local resp, err = red:get(key)
去redis上查找有没有
if resp == ngx.null then
    如果没有
    ngx.req.set_header(&quot;Accept&quot;, &quot;text/html,application/xhtml+xml,application/xml;&quot;)
    ngx.req.set_header(&quot;Accept-Encoding&quot;, &quot;&quot;)
    这里，特别需要注意的是，要把头部的信息去掉，这里之前说过。（如果不去掉，就是gzip加密返回，然后再经过一层gzip加密返回给用户，导致用户看到的是gzip压缩过的乱码）
    local targetURL = string.gsub(uri, &quot;html&quot;, &quot;do&quot;)
    这里讲html替换为do，即：不拦截*.do的请求，其可以直接访问tomcat
    local respp = ngx.location.capture(targetURL, { method = ngx.HTTP_GET, args = uri_args })
    开始回源到tomcat
    red:set(key, respp.body)
    将uri（key）和响应的内容设到redis里面去
    red:expire(key, 600)
    lua redis并没有提供在set的时候同时设置过期时间，所以，额外加一行设置过期时间
    ngx.print(respp.body)
    将响应的内容输出给用户
    return
end
ngx.print(resp)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;四测试&quot;&gt;四、测试&lt;/h2&gt;
&lt;p&gt;进行一次测试，以访问&lt;a href=&quot;http://www.wenzhihuai.com/jaowejoifjefoijoifaew.html&quot; class=&quot;uri&quot;&gt;http://www.wenzhihuai.com/jaowejoifjefoijoifaew.html&lt;/a&gt; 为例，我的网站并没有设置这个uri，所以，访问的时候，会统一调到错误页面，之后，会在redis中看到有这条记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20186252030.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该地址已经成功被缓存到redis里面去，点击其他页面，可以看到，只要是点击的页面，都被缓存到redis里面去了。总体来说，如果不设置过期时间，可以把整个网页静态化缓存到redis里面，甚至是可以关闭tomcat了，但是这种做法只适用于万年不变的页面，至于用于企业的话，，，，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后记：&lt;br/&gt;其实我有个疑问，我的代码里，并没有设置lua断开redis的连接，不知道会不会有影响，而且它这个是指每次请求过来，都需要重新连接redis么？光是TCP三次握手就耗时不少啊，不知道怎么优化这些信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全部代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;27&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;local redis = require &quot;resty.redis&quot;
local red = redis:new()
local request_uri = ngx.var.request_uri
local ngx_log = ngx.log
local ngx_ERR = ngx.ERR

local function close_redis(red)
    if not red then
        return
    end
    local pool_max_idle_time = 10000
    local pool_size = 100
    red:set(&quot;pool_size&quot;, pool_size)
    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)
    if not ok then
        ngx_log(ngx_ERR, &quot;set redis keepalive error : &quot;, err)
    end
end

local uri = ngx.var.uri

red:set_timeout(1000)
red:connect(&quot;119.23.46.71&quot;, 6340)
red:auth(&quot;root&quot;)
local uri_args = ngx.req.get_uri_args()

local key = request_uri
local resp, err = red:get(key)

if resp == ngx.null then
    ngx.req.set_header(&quot;Accept&quot;, &quot;text/html,application/xhtml+xml,application/xml;&quot;)
    ngx.req.set_header(&quot;Accept-Encoding&quot;, &quot;&quot;)
    local targetURL = string.gsub(uri, &quot;html&quot;, &quot;do&quot;)
    local respp = ngx.location.capture(targetURL, { method = ngx.HTTP_GET, args = uri_args })
    red:set(key, respp.body)
    red:expire(key, 600)
    ngx.print(respp.body)
    return
end
ngx.print(resp)
close_redis(red)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 25 Jun 2018 14:54:00 +0000</pubDate>
<dc:creator>ZepheryWen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w1570631036/p/9226519.html</dc:identifier>
</item>
<item>
<title>Android 布局巧用之include、merge、ViewStub - 程序猿tx</title>
<link>http://www.cnblogs.com/taixiang/p/9221258.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taixiang/p/9221258.html</guid>
<description>&lt;blockquote readability=&quot;1.171875&quot;&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/bTA2gztUzqvqER2rz56RRQ&quot; class=&quot;uri&quot;&gt;https://mp.weixin.qq.com/s/bTA2gztUzqvqER2rz56RRQ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信大家经常听到&lt;code&gt;include&lt;/code&gt;、&lt;code&gt;merge&lt;/code&gt;、&lt;code&gt;ViewStub&lt;/code&gt;这样的标签，官方也提到这三种布局可用于布局的优化。今天就介绍下这三种布局的使用，记录下来，便于后续app中的使用。&lt;/p&gt;
&lt;h4 id=&quot;include布局重用&quot;&gt;&lt;code&gt;include&lt;/code&gt;布局重用&lt;/h4&gt;
&lt;p&gt;app开发过程中，会遇到不同页面里有相同的布局，这时我们可以将这些通用的布局提取出来到一个单独的&lt;code&gt;layout&lt;/code&gt;文件里，再使用&lt;code&gt;&amp;lt;include&amp;gt;&lt;/code&gt;标签引入到相应的页面布局文件里，主要通过&lt;code&gt;include&lt;/code&gt;的&lt;code&gt;layout&lt;/code&gt;属性引用。&lt;br/&gt;举个栗子&lt;br/&gt;&lt;code&gt;include&lt;/code&gt;的布局：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/container&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;&amp;gt;

    &amp;lt;TextView
        android:id=&quot;@+id/tv1&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;这里是来自include布局&quot; /&amp;gt;

&amp;lt;/RelativeLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;activity&lt;/code&gt;的布局：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&amp;gt;

    &amp;lt;TextView
        android:id=&quot;@+id/tv2&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;以下的内容来自include标签&quot; /&amp;gt;

    &amp;lt;include
        android:id=&quot;@+id/container&quot;
        layout=&quot;@layout/include_layout&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@+id/tv&quot;
        android:layout_marginTop=&quot;10dp&quot; /&amp;gt;

&amp;lt;/RelativeLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个标签在日常工作使用还是很常见的。这里有几点需要注意下：&lt;br/&gt;1、如果给&lt;code&gt;include&lt;/code&gt;标签 和 &lt;code&gt;include&lt;/code&gt;所加载的布局 都添加id的话，那么id要保持一致，如例子中都是&lt;code&gt;container&lt;/code&gt;，否则是在代码中获取不到&lt;code&gt;RelativeLayout&lt;/code&gt;容器的。 当然我们可以避免这样的问题，只需要给其中一项添加id属性就可以。&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;include&lt;/code&gt;布局里元素的id 要和 &lt;code&gt;include&lt;/code&gt;所在页面布局里的其他元素id 不同，如例子中的两个&lt;code&gt;textview&lt;/code&gt;，如果把id设置相同了，程序运行起来并不会报错，但是&lt;code&gt;textview&lt;/code&gt;的赋值只会赋值给其中的一个。&lt;/p&gt;
&lt;p&gt;3、如果需要给&lt;code&gt;include&lt;/code&gt;标签设置位置属性的话，如例子中的&lt;code&gt;layout_below&lt;/code&gt;、&lt;code&gt;layout_marginTop&lt;/code&gt;，这时候 &lt;strong&gt;必须&lt;/strong&gt; 同时设置&lt;code&gt;include&lt;/code&gt;标签的宽高属性&lt;code&gt;layout_width&lt;/code&gt;、&lt;code&gt;layout_height&lt;/code&gt;，否则编译器是会报错的。一般情况不需要设置&lt;code&gt;include&lt;/code&gt;的其他属性，直接加载布局文件 &lt;code&gt;&amp;lt;include layout=&quot;@layout/....&quot;/&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4、布局中可以包含两个相同的include标签,如下代码所示 两个&lt;code&gt;include&lt;/code&gt;都加载&lt;code&gt;layout=&quot;@layout/include_layout&quot;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&amp;gt;

    &amp;lt;TextView
        android:id=&quot;@+id/tv&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;以下的内容来自include标签&quot; /&amp;gt;

    &amp;lt;include
        android:id=&quot;@+id/container&quot;
        layout=&quot;@layout/include_layout&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@+id/tv&quot;
        android:layout_marginTop=&quot;10dp&quot; /&amp;gt;

    &amp;lt;include
        android:id=&quot;@+id/container2&quot;
        layout=&quot;@layout/include_layout&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;80dp&quot; /&amp;gt;

&amp;lt;/RelativeLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以设置不同&lt;code&gt;include&lt;/code&gt;的id属性，引用的时候如下可以正常显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;View view = findViewById(R.id.container2);
TextView textView = view.findViewById(R.id.tv);
textView.setText(&quot;这里是来自 第二个 include布局&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;merge减少视图层级&quot;&gt;merge减少视图层级&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;merge&lt;/code&gt;标签可用于减少视图层级来优化布局，可以配合&lt;code&gt;include&lt;/code&gt;使用，如果&lt;code&gt;include&lt;/code&gt;标签的父布局 和 &lt;code&gt;include&lt;/code&gt;布局的根容器是相同类型的，那么根容器的可以使用&lt;code&gt;merge&lt;/code&gt;代替。&lt;br/&gt;页面布局&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&amp;gt;

    &amp;lt;TextView
        android:id=&quot;@+id/tv&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;以下的内容不是来自merge标签&quot; /&amp;gt;

    &amp;lt;include
        layout=&quot;@layout/merge_layout&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;20dp&quot; /&amp;gt;

&amp;lt;/LinearLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看没有使用&lt;code&gt;merge&lt;/code&gt;的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;&amp;gt;

    &amp;lt;TextView
        android:id=&quot;@+id/tv&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;这里是不是来自merge布局&quot; /&amp;gt;

&amp;lt;/LinearLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看下view层的结构：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/23/1642b65942b86075?w=948&amp;amp;h=279&amp;amp;f=png&amp;amp;s=26599&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看使用了&lt;code&gt;merge&lt;/code&gt;的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt;

    &amp;lt;TextView
        android:id=&quot;@+id/tv&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;这里是来自merge布局&quot; /&amp;gt;

&amp;lt;/merge&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;view层结构：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/23/1642b67ee31863e6?w=909&amp;amp;h=240&amp;amp;f=png&amp;amp;s=23357&quot;/&gt;&lt;br/&gt;可以看到对比，减少了一层的&lt;code&gt;LinearLayout&lt;/code&gt;的嵌套，需要注意的是使用&lt;code&gt;merge&lt;/code&gt;的布局，在&lt;code&gt;include&lt;/code&gt;的标签设置距离属性没有生效，可以将一些间距属性设置到&lt;code&gt;include&lt;/code&gt;布局里元素上，具体看项目需求使用。&lt;/p&gt;
&lt;h4 id=&quot;viewstub按需加载&quot;&gt;ViewStub按需加载&lt;/h4&gt;
&lt;p&gt;按需加载 顾名思义需要的时候再去加载，不需要的时候可以不用加载，节约内存使用。通常情况我们会使用&lt;code&gt;setVisibility&lt;/code&gt;方法来控制视图的显示和隐藏，但是这种情况视图已经加载了。&lt;br/&gt;比如app中页面里某个布局只需要在特定的情况下才显示，其余情况下可以不用加载显示，这时候可以使用&lt;code&gt;ViewStub&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;layout&lt;/code&gt;属性是需要加载布局&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&amp;gt;

    &amp;lt;ViewStub
        android:id=&quot;@+id/viewstub&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;20dp&quot;
        android:layout=&quot;@layout/viewstub_layout&quot; /&amp;gt;

&amp;lt;/LinearLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是 &lt;code&gt;ViewStub&lt;/code&gt;的&lt;code&gt;inflate()&lt;/code&gt;方法只能被调用一次，一旦调用后，&lt;code&gt;ViewStub&lt;/code&gt;将从视图中移除，被对应的&lt;code&gt;layout&lt;/code&gt;布局取代，同时会保留&lt;code&gt;ViewStub&lt;/code&gt;上设置的属性效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ViewStub viewstub = findViewById(R.id.viewstub);
viewstub.inflate();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这篇关于&lt;code&gt;include&lt;/code&gt;、&lt;code&gt;merge&lt;/code&gt;、&lt;code&gt;ViewStub&lt;/code&gt;的使用就介绍到这里了，具体使用情况还得视项目而定。&lt;/p&gt;
&lt;p&gt;最后附上github地址&lt;a href=&quot;https://github.com/taixiang/include&quot; class=&quot;uri&quot;&gt;https://github.com/taixiang/include&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的博客：&lt;a href=&quot;https://blog.manjiexiang.cn/&quot; class=&quot;uri&quot;&gt;https://blog.manjiexiang.cn/&lt;/a&gt;&lt;br/&gt;更多精彩欢迎关注微信号：春风十里不如认识你&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7569533-cfeb1f55473a2143.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jun 2018 14:32:00 +0000</pubDate>
<dc:creator>程序猿tx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taixiang/p/9221258.html</dc:identifier>
</item>
<item>
<title>[区块链] 拜占庭将军问题 [BFT] - 勋爵</title>
<link>http://www.cnblogs.com/X-knight/p/9157533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-knight/p/9157533.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;背景：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　拜占庭将军问题很多人可能听过，但不知道具体是什么意思。那么究竟什么是拜占庭将军问题呢? 本文从最通俗的故事讲起，并对该问题进行抽象，并告诉大家拜占庭将军问题为什么在区块链领域作为一个重点研究问题。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span class=&quot;bjh-p&quot;&gt;什么是拜占庭将军问题：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　“拜占庭将军问题”也被称为“拜占庭容错”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　拜占庭将军问题是Leslie Lamport（2013年的图灵讲得住）用来为描述分布式系统一致性问题（Distributed Consensus）在论文中抽象出来一个著名的例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　这个例子大意是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。这10支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于6支军队在同一时间一起发起进攻，从而赢取战斗？&lt;/span&gt;&lt;span class=&quot;bjh-p&quot;&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注：“  拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，已经假定了信道是没有问题的。 ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;h2&gt; &lt;strong&gt;&lt;span class=&quot;bjh-p&quot;&gt;通俗分析：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　单从上面的说明可能无法理解这个问题的复杂性，我们来简单分析一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　先看在没有叛徒情况下，假如一个将军A提一个进攻提议（如：明日下午1点进攻，你愿意加入吗？）由通信兵通信分别告诉其他的将军，如果幸运中的幸运，他收到了其他6位将军以上的同意，发起进攻。如果不幸，其他的将军也在此时发出不同的进攻提议（如：明日下午2点、3点进攻，你愿意加入吗？），由于时间上的差异，不同的将军收到（并认可）的进攻提议可能是不一样的，这是可能出现A提议有3个支持者，B提议有4个支持者，C提议有2个支持者等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　再加一点复杂性，在有叛徒情况下，一个叛徒会向不同的将军发出不同的进攻提议（通知A明日下午1点进攻， 通知B明日下午2点进攻等等），一个叛徒也会可能同意多个进攻提议（即同意下午1点进攻又同意下午2点进攻）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　叛徒发送前后不一致的进攻提议，被称为“拜占庭错误”，而能够处理拜占庭错误的这种容错性称为「Byzantine fault tolerance」，简称为BFT。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h2 class=&quot;ziti&quot;&gt;&lt;strong&gt;问题抽象：&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;ziti&quot;&gt;　　求解拜占庭将军问题，隐含要满足以下两个条件：&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　1）每个忠诚的将军必须收到相同的命令值vi（vi是第i个将军的命令）。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　2）如果第i个将军是忠诚的，那么他发送的命令和每个忠诚将军收到的vi相同。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　于是，拜占庭将军问题的可以描述为：一个发送命令的将军要发送一个命令给其余n-1个将军，使得：&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　IC1.所有忠诚的接收命令的将军遵守相同的命令；&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　IC2.如果发送命令的将军是忠诚的，那么所有忠诚的接收命令的将军遵守所接收的命令。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　Lamport对拜占庭将军问题的研究表明，当n&amp;gt;3m时，即叛徒的个数m小于将军总数n的1/3时，通过口头同步通信（假设通信是可靠的），可以构造同时满足IC1和IC2的解决方案，即将军们可以达成一致的命令。但如果通信是可认证、防篡改伪造的（如采用PKI认证，消息签名等），则在任意多的叛徒（至少得有两个忠诚将军）的情况下都可以找到解决方案。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　而在异步通信情况下，情况就没有这么乐观。Fischer-Lynch-Paterson定理证明了，只要有一个叛徒存在，拜占庭将军问题就无解。翻译成分布式计算语言，在一个多进程异步系统中，只要有一个进程不可靠，那么就不存在一个协议，此协议能保证有限时间内使所有进程达成一致。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　由此可见，拜占庭将军问题在一个分布式系统中，是一个非常有挑战性的问题。因为分布式系统不能依靠同步通信，否则性能和效率将非常低。因此寻找一种实用的解决拜占庭将军问题的算法一直是分布式计算领域中的一个重要问题。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p class=&quot;ziti&quot;&gt;在这里，我们先给出分布式计算中有关拜占庭缺陷和故障的两个定义：&lt;/p&gt;
&lt;p class=&quot;ziti6&quot;&gt;&lt;span class=&quot;yanse&quot;&gt;　　&lt;strong&gt;定义1&lt;/strong&gt;：拜占庭缺陷（Byzantine Fault）：任何观察者从不同角度看，表现出不同症状的缺陷。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ziti6&quot;&gt;&lt;span class=&quot;yanse&quot;&gt;　　&lt;strong&gt;定义2：&lt;/strong&gt;拜占庭故障（Byzantine Failure）：在需要共识的系统中由于拜占庭缺陷导致丧失系统服务。&lt;/span&gt;　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;ziti&quot;&gt;　　在分布式系统中，不是所有的缺陷或故障都能称作拜占庭缺陷或故障。像死机、丢消息等缺陷或故障不能算为拜占庭缺陷或故障。拜占庭缺陷或故障是最严重缺陷或故障，拜占庭缺陷有不可预测、任意性的缺陷，例如遭黑客破坏，中木马的服务器就是一个拜占庭服务器。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　在一个有拜占庭缺陷存在的分布式系统中，所有的进程都有一个初始值。在这种情况下，共识问题（Consensus Problem），就是要寻找一个算法和协议，使得该协议满足以下三个属性。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　1）&lt;strong&gt;一致性（Agreement）&lt;/strong&gt;：所有的非缺陷进程都必须同意同一个值。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　2）&lt;strong&gt;正确性（Validity）&lt;/strong&gt;：如果所有的非缺陷的进程有相同的初始值，那么所有非缺陷的进程所同意的值必须是同一个初始值。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　3）&lt;strong&gt;可结束性（Termination）&lt;/strong&gt;：每个非缺陷的进程必须最终确定一个值。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　根据Fischer-Lynch-Paterson的理论，在异步通信的分布式系统中，只要有一个拜占庭缺陷的进程，就不可能找到一个共识算法，可同时满足上述要求的一致性、正确性和可结束性要求。在实际情况下，根据不同的假设条件，有很多不同的共识算法被设计出来。这些算法各有优势和局限。算法的假设条件有以下几种情况：&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　1）故障模型：非拜占庭故障/拜占庭故障。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　2）通信类型：同步/异步。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　3）通信网络连接：节点间直连数。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　4）信息发送者身份：实名/匿名。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　5）通信通道稳定性：通道可靠/不可靠。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt;　　6）消息认证性：认证消息/非认证消息。&lt;/p&gt;
&lt;p class=&quot;ziti&quot;&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;&lt;span class=&quot;bjh-p&quot;&gt;中本聪的解决方案：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　在出现比特币之前，解决分布式系统一致性问题主要是Lamport提出的Paxos算法或其衍生算法。Paxos类算法仅适用于&lt;strong&gt;中心化的分布式系统&lt;/strong&gt;，这样的系统的没有不诚实的节点（不会发送虚假错误消息，但允许出现网络不通或宕机出现的消息延迟）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　中本聪在比特币中创造性的引入了“工作量证明（POW : Proof of Work）”来解决这个问题，有兴趣可进一步阅读&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/X-knight/p/9157814.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;工作量证明&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;（猛击！）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　通过工作量证明就增加了发送信息的成本，降低节点发送消息速率，这样就以保证在一个时间只有一个节点(或是很少)在进行广播，同时在广播时会附上自己的签名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　这个过程就像一位将军A在向其他的将军（B、C、D…）发起一个进攻提议一样，将军B、C、D…看到将军A签过名的进攻提议书，如果是诚实的将军就会立刻同意进攻提议，而不会发起自己新的进攻提议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　以上就是比特币网络中是单个区块（账本）达成共识的方法（取得一致性）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　理解了单个区块取得一致性的方法，那么整个区块链（总账本）如果达成一致也好理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　我们稍微把将军问题改一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　假设攻下一个城堡需要多次的进攻，每次进攻的提议必须基于之前最多次数的胜利进攻下提出的（只有这样敌方已有损失最大，我方进攻胜利的可能性就更大），这样约定之后，将军A在收到进攻提议时，就会检查一下这个提议是不是基于最多的胜利提出的，如果不是（基于最多的胜利）将军A就不会同意这样的提议，如果是的，将军A就会把这次提议记下来。&lt;/span&gt;&lt;span class=&quot;bjh-p&quot;&gt;这就是&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=9158445&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;比特币网络最长链选择&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt; （&lt;/span&gt;猛击！）&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt; &lt;strong&gt;&lt;span class=&quot;bjh-p&quot;&gt;经济学分析&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　工作量证明其实相当于提高了做叛徒（发布虚假区块）的成本，在工作量证明下，只有第一个完成证明的节点才能广播区块，竞争难度非常大，需要很高的算力，如果不成功其算力就白白的耗费了（算力是需要成本的），如果有这样的算力作为诚实的节点，同样也可以获得很大的收益（这就是矿工所作的工作），这也实际就不会有做叛徒的动机，整个系统也因此而更稳定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;　　矿工挖矿获得比特币奖励以及记账所得的交易费用使得矿工更希望维护网络的正常运行，而任何破坏网络的非诚信行为都会损害矿工自身的利益。因此，即使有些比特币矿池具备强大的算力，它们都没有作恶的动机，反而有动力维护比特币的正常运行，因为这和它们的切实利益相关。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　注：原始的拜占庭容错系统由于需要展示其理论上的可行性而&lt;span&gt;&lt;strong&gt;缺乏实用性&lt;/strong&gt;。&lt;/span&gt;另外，还&lt;span&gt;&lt;strong&gt;需要额外的时钟同步机制支持&lt;/strong&gt;，&lt;strong&gt;算法的复杂度也是随节点增加而指数级增加&lt;/strong&gt;。实用拜占庭容错系统&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/X-knight/p/9157814.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;（PBFT）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（猛击！）&lt;/strong&gt;降低了拜占庭协议的运行复杂度，从指数级别降低到多项式级别（Polynomial），使拜占庭协议在分布式系统中应用成为可能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;ziti&quot;&gt;&lt;strong&gt;总结：&lt;/strong&gt;共识算法的核心就是解决拜占庭将军问题（分布式网络一致性问题）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;h2&gt; &lt;span&gt;&lt;strong&gt;REFERENCE&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ol type=&quot;1&quot; readability=&quot;0&quot;&gt;&lt;li lang=&quot;en-us&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;fnote&quot;&gt;Lamport L，Shostak R，Pease M.The Byzantine generals problem.ACM Trans.on Programming Languages and Systems，1982，4（3）：382-401.&lt;/p&gt;
&lt;/li&gt;
&lt;li lang=&quot;en-us&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;fnote&quot;&gt;Lamport L，Shostak R，Pease M.The Byzantine generals problem.ACM Trans.on Programming Languages and Systems，1982，4（3）：382-401.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Fischer，M.J.，Lynch，N.A.，Paterson，M.：Impossibility of distributed consensus with one faulty process.J.ACM 32（2），374-382（1985）&lt;/li&gt;
&lt;li lang=&quot;en-us&quot;&gt;《区块链技术指南》&lt;a href=&quot;http://book.jd.com/writer/%E9%82%B9%E5%9D%87_1.html&quot; target=&quot;_blank&quot; data-name=&quot;邹均&quot;&gt;邹均&lt;/a&gt;，&lt;a href=&quot;http://book.jd.com/writer/%E5%BC%A0%E6%B5%B7%E5%AE%81_1.html&quot; target=&quot;_blank&quot; data-name=&quot;张海宁&quot;&gt;张海宁&lt;/a&gt;，&lt;a href=&quot;http://book.jd.com/writer/%E5%94%90%E5%B1%B9_1.html&quot; target=&quot;_blank&quot; data-name=&quot;唐屹&quot;&gt;唐屹&lt;/a&gt;，&lt;a href=&quot;http://book.jd.com/writer/%E6%9D%8E%E7%A3%8A_1.html&quot; target=&quot;_blank&quot; data-name=&quot;李磊&quot;&gt;李磊&lt;/a&gt; 著&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;p lang=&quot;en-us&quot;&gt;&lt;strong&gt;【时间仓促，如有错误，欢迎指正！ ||   欢迎留下您的评语！  大家一起探讨、学习区块链!】&lt;/strong&gt;&lt;/p&gt;
&lt;p lang=&quot;en-us&quot;&gt;&lt;strong&gt;【转载请注明出处！&lt;/strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-knight/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/X-knight/&lt;/a&gt;】&lt;/p&gt;
&lt;hr/&gt;&lt;p lang=&quot;en-us&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Mon, 25 Jun 2018 14:15:00 +0000</pubDate>
<dc:creator>勋爵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-knight/p/9157533.html</dc:identifier>
</item>
<item>
<title>论文笔记：空间变换网络（Spatial Transformer Networks） - PilgrimHui</title>
<link>http://www.cnblogs.com/liaohuiqiang/p/9226335.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liaohuiqiang/p/9226335.html</guid>
<description>&lt;p&gt;&lt;strong&gt;2015, NIPS&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;Max Jaderberg, Karen Simonyan, Andrew Zisserman, Koray Kavukcuoglu&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;Google DeepMind&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么提出（Why）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;一个理想中的模型：&lt;/strong&gt;我们希望鲁棒的图像处理模型具有空间不变性，当目标发生某种转化后，模型依然能给出同样的正确的结果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;什么是空间不变性：&lt;/strong&gt;举例来说，&lt;strong&gt;如下图所示&lt;/strong&gt;，假设一个模型能准确把左图中的人物分类为凉宫春日，当这个目标做了放大、旋转、平移后，模型仍然能够正确分类，我们就说这个模型在这个任务上具有尺度不变性，旋转不变性，平移不变性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CNN在这方面的能力是不足的：&lt;/strong&gt;maxpooling的机制给了CNN一点点这样的能力，当目标在池化单元内任意变换的话，激活的值可能是相同的，这就带来了一点点的不变性。但是池化单元一般都很小（一般是2*2），只有在深层的时候特征被处理成很小的feature map的时候这种情况才会发生&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spatial Transformer：&lt;/strong&gt;本文提出的空间变换网络STN（Spatial Transformer Networks）可以使得模型具有空间不变性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201806/1160281-20180625211721942-288674029.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STN是什么（What）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;STN对feature map（包括输入图像）进行空间变换，输出一张新的图像。&lt;/li&gt;
&lt;li&gt;我们希望STN对feature map进行变换后能把图像纠正到成理想的图像，然后丢进NN去识别，举例来说，&lt;strong&gt;如下图所示&lt;/strong&gt;，输入模型的图像可能是摆着各种姿势，摆在不同位置的凉宫春日，我们希望STN把它纠正到图像的正中央，放大，占满整个屏幕，然后再丢进CNN去识别。&lt;/li&gt;
&lt;li&gt;这个网络可以作为单独的模块，可以在CNN的任何地方插入，所以STN的输入不止是输入图像，可以是CNN中间层的feature map&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201806/1160281-20180625211733476-710894259.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STN是怎么做的（How）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;如下图所示&lt;/strong&gt;，STN的输入为U，输出为V，因为输入可能是中间层的feature map，所以画成了立方体（多channel），STN主要分为下述三个步骤&lt;/li&gt;
&lt;li&gt;Localisation net：是一个自己定义的网络，它输入U，输出变化参数&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;，这个参数用来映射U和V的坐标关系&lt;/li&gt;
&lt;li&gt;Grid generator：根据V中的坐标点和变化参数&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;，计算出U中的坐标点。这里是因为V的大小是自己先定义好的，当然可以得到V的所有坐标点，而填充V中每个坐标点的像素值的时候，要从U中去取，所以根据V中每个坐标点和变化参数&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;进行运算，得到一个坐标。在sampler中就是根据这个坐标去U中找到像素值，这样子来填充V&lt;/li&gt;
&lt;li&gt;Sampler：要做的是填充V，根据Grid generator得到的一系列坐标和原图U（因为像素值要从U中取）来填充，因为计算出来的坐标可能为小数，要用另外的方法来填充，比如双线性插值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201806/1160281-20180625211745670-2041077599.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面针对每个模块阐述一下&lt;br/&gt;&lt;strong&gt;(1) Localisation net&lt;/strong&gt;&lt;br/&gt;这个模块就是输入U，输出一个变化参数&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;，那么这个&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;具体是指什么呢？&lt;br/&gt;我们知道线性代数里，图像的平移，旋转和缩放都可以用矩阵运算来做&lt;br/&gt;举例来说，如果想放大图像中的目标，可以这么运算，把(x,y)中的像素值填充到(x',y')上去，比如把原来(2,2)上的像素点，填充到(4,4)上去。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\begin{bmatrix}x^{'}\\ y^{'}\end{bmatrix}=\begin{bmatrix}2 &amp;amp;0\\0&amp;amp;2\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}0\\ 0\end{bmatrix}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果想旋转图像中的目标，可以这么运算（可以在极坐标系中推出来，相关证明放在最后的附录中）&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\begin{bmatrix}x^{'}\\ y^{'}\end{bmatrix}=\begin{bmatrix}cos \Theta &amp;amp; -sin \Theta\\ sin \Theta&amp;amp; cos\Theta\end{bmatrix} \begin{bmatrix}x\\ y\end{bmatrix}+\begin{bmatrix}0\\ 0\end{bmatrix}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这些都是属于仿射变换（affine transformation）&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\begin{bmatrix}x^{'}\\ y^{'}\end{bmatrix}=\begin{bmatrix}a &amp;amp; b \\ c&amp;amp; d\end{bmatrix} \begin{bmatrix}x\\ y\end{bmatrix}+\begin{bmatrix}e\\ f\end{bmatrix}\)&lt;/span&gt;&lt;br/&gt;在仿射变化中，变化参数就是这6个变量，&lt;span class=&quot;math inline&quot;&gt;\(\Theta = \{a,b,c,d,e,f\}\)&lt;/span&gt;（此&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;跟上述旋转变化里的角度&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;无关）&lt;br/&gt;这6个变量就是用来映射输入图和输出图之间的坐标点的关系的，我们在第二步grid generator就要根据这个变化参数，来获取原图的坐标点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) Grid generator&lt;/strong&gt;&lt;br/&gt;有了第一步的变化参数，这一步是做个矩阵运算，这个运算是以目标图V的所有坐标点为自变量，以$ \Theta $为参数做一个矩阵运算，得到输入图U的坐标点。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{pmatrix}x_{i}^{s}\\ y_{i}^{s}\end{pmatrix}=\Theta \begin{pmatrix}x_{i}^{t}\\ y_{i}^{t}\\ 1\end{pmatrix} =\begin{bmatrix} \Theta _{11} &amp;amp; \Theta _{12} &amp;amp; \Theta _{13}\\ \Theta _{21} &amp;amp; \Theta _{22} &amp;amp; \Theta _{23} \end{bmatrix}\begin{pmatrix} x_{i}^{t}\\ y_{i}^{t} \\ 1 \end{pmatrix}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中$ {(x_{i}^{t},y_{i}^{t})}$记为输出图V中的第i个坐标点，V中的长宽可以和U不一样，自己定义的，所以这里用i来标识第几个坐标点&lt;br/&gt;$ {(x_{i}^{s},y_{i}^{s})}$记为输入图U中的点，这里的i是从V中对应过来的，跟U没有关系&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3) Sampler&lt;/strong&gt;&lt;br/&gt;由于在第二步计算出了V中每个点对应到U的坐标点，在这一步就可以直接根据V的坐标点取得对应到U中坐标点的像素值来进行填充，而不需要经过矩阵运算。需要注意的是，填充并不是直接填充，首先计算出来的坐标可能是小数，要处理一下，其次填充的时候往往要考虑周围的其它像素值。填充根据的公式如下。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[V_{i}=\sum _n \sum _m U_{nm}*k(x_{i}^{s}-m;\phi _x)*k(y_{i}^{s}-n;\phi _y)\]&lt;/span&gt;&lt;br/&gt;其中n和m会遍历原图U的所有坐标点，&lt;span class=&quot;math inline&quot;&gt;\(U_{nm}\)&lt;/span&gt;指原图U中某个点的像素值，k()为取样核，两个&lt;span class=&quot;math inline&quot;&gt;\(\phi\)&lt;/span&gt;为参数，&lt;span class=&quot;math inline&quot;&gt;\((x_{i}^{s},y_{i}^{s})\)&lt;/span&gt;表示V中第i个点要到U图中找的对应点的坐标，k表示使用不同的方法来填充，通常会使用双线性插值，则会得到下面的公式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[V_{i}=\sum _n \sum _m U_{nm}*max(0, 1 - |x_{i}^{s}-m|)*max(0, 1 - |y_{i}^{s}-n|)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;举例来说，我要填充目标图V中的（2，2）这个点的像素值，经过以下计算得到（1.6，2.4）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{pmatrix}x_{i}^{s}\\ y_{i}^{s}\end{pmatrix} =\begin{bmatrix} \Theta _{11} &amp;amp; \Theta _{12} &amp;amp; \Theta _{13}\\ \Theta _{21} &amp;amp; \Theta _{22} &amp;amp; \Theta _{23} \end{bmatrix}\begin{pmatrix} x_{i}^{t}\\ y_{i}^{t} \\ 1 \end{pmatrix}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{pmatrix}1.6\\ 2.4\end{pmatrix} =\begin{bmatrix} 0 &amp;amp; 0.5 &amp;amp; 0.6\\ 1 &amp;amp; 0 &amp;amp; 0.4 \end{bmatrix}\begin{pmatrix} 2\\ 2 \\ 1 \end{pmatrix}\]&lt;/span&gt;&lt;br/&gt;如果四舍五入后直接填充，则难以做梯度下降。&lt;br/&gt;我们知道做梯度下降时，梯度的表现就是权重发生一点点变化的时候，输出的变化会如何。&lt;br/&gt;如果用四舍五入后直接填充，那么（1.6，2.4）四舍五入后变成（2，2）&lt;br/&gt;当&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;（我们求导的时候是需要对&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;求导的）有一点点变化的时候，（1.6，2.4）可能变成了（1.9，2.1）四舍五入后还是变成（2，2），输出并没有变化，梯度没有改变，这个时候没法用梯度下降来优化&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果采用上面双线性插值的公式来填充，在这个例子里就会考虑（2，2）周围的四个点来填充，这样子，当&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;有一点点变化的时，式子的输出就会有变化，因为$(x_{i}^{s},y_{i}^{s}) $的变化会引起V的变化。注意下式中U的下标，第一个下标是纵坐标，第二个下标才是横坐标。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[V = U_{21}(1-0.6)(1-0.4)+ U_{22}(1-0.4)(1-0.4)+ U_{31}(1-0.6)(1-0.6)+ U_{32}(1-0.4)(1-0.6)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4) STN小结&lt;/strong&gt;&lt;br/&gt;简单总结一下，&lt;strong&gt;如下图所示&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Localization net根据输入图，计算得到一个&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Grid generator根据输出图的坐标点和&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;，计算出输入图的坐标点，举例来说想知道输出图上（2，2）应该填充什么坐标点，则跟&lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt;运算，得到（1.6，2.4）&lt;/li&gt;
&lt;li&gt;Sampler根据自己定义的填充规则（一般用双线性插值）来填充，比如（2，2）坐标对应到输入图上的坐标为（1.6，2.4），那么就要根据输入图上（1.6，2.4）周围的四个坐标点（1，2），（1，3），（2，2），（2，3）的像素值来填充。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201806/1160281-20180625211806711-110849845.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【实验】Distorted MNIST&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201806/1160281-20180625211821382-124120649.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【实验】SVHN: Street View House Numbers&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201806/1160281-20180625211828072-105388157.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【 实验】CUB-200-2011 birds dataset&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201806/1160281-20180625211835639-1308442329.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jun 2018 14:08:00 +0000</pubDate>
<dc:creator>PilgrimHui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liaohuiqiang/p/9226335.html</dc:identifier>
</item>
</channel>
</rss>