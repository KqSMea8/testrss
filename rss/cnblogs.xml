<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux安装git和maven的详细过程 - 宋宋宋哥</title>
<link>http://www.cnblogs.com/SongG-blogs/p/8808005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SongG-blogs/p/8808005.html</guid>
<description>&lt;p&gt;一、使用yum安装git&lt;/p&gt;
&lt;p&gt;当前安装环境是centos6.5&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412141259866-662648172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于在CentOS6的yum源中已经有git的版本了，可以直接使用yum源进行安装&lt;/p&gt;
&lt;p&gt;yum -y install git&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412141430489-975159729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于centos6的yum源中安装的git版本是1.7.1的，Github等需要的Git版本最低都不能低于1.7.2 。所以我们一般不用上面的方法，而是下载git源码编译安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412141659248-972241648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、编译安装git&lt;/p&gt;
&lt;p&gt;1、更新系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412142118026-540544198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412143145348-495972998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更新成功，版本从6.5跟新到6.9&lt;/p&gt;
&lt;p&gt;2、安装依赖包&lt;/p&gt;
&lt;p&gt;yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412144541563-399845612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、下载git源码并解压&lt;/p&gt;
&lt;p&gt;wget https://github.com/git/git/archive/v2.3.0.zip&lt;/p&gt;
&lt;p&gt;unzip v2.3.0.zip&lt;/p&gt;
&lt;p&gt;4、编译安装&lt;/p&gt;
&lt;p&gt;将其安装在“/usr/local/git”目录下。&lt;/p&gt;
&lt;p&gt;cd git-2.3.0&lt;/p&gt;
&lt;p&gt;make prefix=/usr/local/git all&lt;/p&gt;
&lt;p&gt;make prefix=/usr/local/git install&lt;/p&gt;
&lt;p&gt;git --version&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412150638981-1308617914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用whereis命令查看一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412150835895-1879018574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;因为它默认使用了&quot;/usr/bin&quot;下的git,所以还是1.7.1版本，这里需要我们把编译安装的git路径放到环境变量里，替换&quot;/usr/bin&quot;下的git&lt;/p&gt;

&lt;p&gt;修改文件profile&lt;/p&gt;
&lt;p&gt;vim /etc/profile&lt;/p&gt;
&lt;p&gt;然后在文件的最后一行，添加下面的内容，然后保存退出。&lt;/p&gt;
&lt;p&gt;export PATH=/usr/local/git/bin:$PATH&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412151039371-611870518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;不想重启系统，使用source命令立即生效&lt;/p&gt;
&lt;p&gt;source /etc/profile&lt;/p&gt;
&lt;p&gt;然后再查看一次git 版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412151204892-885484141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装成功&lt;/p&gt;

&lt;p&gt;三、安装maven&lt;/p&gt;
&lt;p&gt;1、下载maven安装包并解压&lt;/p&gt;
&lt;p&gt;wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz&lt;/p&gt;
&lt;p&gt;（没有安装wget命令,使用yum -y install wget安装）&lt;/p&gt;
&lt;p&gt;tar -zxvf apache-maven-3.5.2-bin.tar.gz&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412151815336-382886474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、配置maven环境变量，编辑 profile文件&lt;/p&gt;
&lt;p&gt;添加环境变量&lt;/p&gt;
&lt;p&gt;vim  /etc/profile&lt;/p&gt;

&lt;p&gt;export MAVEN_HOME=/usr/local/apache-maven-3.5.2&lt;br/&gt;export MAVEN_HOME&lt;br/&gt;export PATH=$PATH:$MAVEN_HOME/bin&lt;/p&gt;
&lt;p&gt;使用source ，让改动生效&lt;/p&gt;
&lt;p&gt;source /etc/profile&lt;/p&gt;

&lt;p&gt;查看版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172366/201804/1172366-20180412152321174-188474329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装成功&lt;/p&gt;

&lt;p&gt;备注：&lt;/p&gt;
&lt;p&gt;一、在使用git拉取代码时候需要配置ssh key&lt;/p&gt;
&lt;pre&gt;
1、生成ssh key，公钥添加到gitlab，用于账号认证。生成过一次就不需要再次生成了。运行命令后（无空格），按3次回车即可
&lt;/pre&gt;
&lt;pre readability=&quot;10&quot;&gt;
ssh-keygen&lt;br/&gt;2、拷贝公钥文件&lt;p&gt;cat ~/.ssh/id_rsa.pub&lt;/p&gt;&lt;p&gt;由于是使用码云管理项目，在码云里面添加ssh key,就可以拉取代码&lt;/p&gt;&lt;p&gt;二、比较常用的git以及maven命令&lt;br/&gt;git clone 地址 拉取项目&lt;br/&gt;git checkout dev/master 切换分支&lt;br/&gt;git pull origin dev 拉取最新代码（dev分支）&lt;br/&gt;git status 查看当前代码状态&lt;br/&gt;git add .  &lt;br/&gt;git commit -m 'xxxxx'&lt;br/&gt;git push origin dev&lt;br/&gt;mvn clean install 
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;/pre&gt;

</description>
<pubDate>Thu, 12 Apr 2018 07:25:00 +0000</pubDate>
<dc:creator>宋宋宋哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SongG-blogs/p/8808005.html</dc:identifier>
</item>
<item>
<title>深入浅出Lua虚拟机 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/8807734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/8807734.html</guid>
<description>&lt;p class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer?fromSource=waitui&quot;&gt;腾讯云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;作者：郑小辉 | 腾讯 游戏客户端开发高级工程师&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;写在前面：本文所有的文字都是我手工一个一个敲的，以及本文后面分享的Demo代码都是我一行一行码的，在我之前已经有非常多的前辈研究过Lua虚拟机了，所以本文很多思想必然是踏在这些巨人的肩膀上的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;本文标题是”深入浅出Lua虚拟机”，其实重点在浅出这两字上。毕竟作者的技术水平有限。但是听说名字要起的屌一点文章才有人看，故而得名。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;谨以此文奉献给那些对Lua虚拟机有兴趣的人。希望本文能达到一个抛砖引玉的效果。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Lua的执行流程：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;Lua代码的整个流程：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如下图所示：程序员编码lua文件-&amp;gt;语法词法分析生成Lua的字节码文件(对应Lua工具链的Luac.exe)-&amp;gt;Lua虚拟机解析字节码，并执行其中的指令集-&amp;gt;输出结果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://ask.qcloudimg.com/draft/1122790/34o0rev0dg.png?imageView2/0/w/1620&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1122790/34o0rev0dg.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;蓝色和绿色的部分是本文所试图去讲的内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;词法语法分析：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;我不准备讲Lua的所有词法分析过程，毕竟如果浪费太多时间来写这个的话一会策划同学要提刀来问我需求的开发进度如何了，所以长话短说，我就根据自己对Lua的理解，以某一个具体的例子来做分析：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Lua代码块：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt;If &lt;span class=&quot;cm-variable&quot;&gt;a &amp;lt; &lt;span class=&quot;cm-variable&quot;&gt;b &lt;span class=&quot;cm-keyword&quot;&gt;then &lt;span class=&quot;cm-variable&quot;&gt;a = &lt;span class=&quot;cm-variable&quot;&gt;c &lt;span class=&quot;cm-keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;这句话咱们程序员能看懂，可是计算机就跟某些男程序员家里负责貌美如花的老婆一样，只知道这是一串用英文字符拼出来的一行没有任何意义的字符串而已。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;为了让计算机能够读懂这句话，那么我们要做的第一件事情就是分词：既然你看不懂。我就先把一句话拆成一个一个单词，而且我告诉你每个单词的含义是什么。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;分词的结果大概长下面这样：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt;    分词结果         类型（意义）&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    if             Type_If  (if 关键字)&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    a             Type_Var (这是一个变量)&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &amp;lt;             Type_OpLess(这是一个小于号)&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    b             Type_Var(这是一个变量)&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    then          Type_Then(Then关键字)&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    a             Type_Var (这是一个变量)&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    =             Type_OpEqual(这是一个等号)&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    c             Type_Var(这是一个变量)&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    end           Type_End(End关键字)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;好了。现在计算机终于明白了。原来你写的这行代码里面有9个字，而且每个字的意思我都懂了。所以现在问题是，计算机理解了这句话了吗？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;计算机依然不理解。就好像“吃饭”这句话，计算机理解了 “吃”是动词，张开嘴巴的意思。“饭”是名词，指的米饭的意思。但是你把吃饭放在一起，计算机并不知道这是“张开嘴巴，把饭放进嘴里，并且咽到胃里”的意思。因为计算机只知道“张开嘴巴”和“米饭”两件事，这两件事有什么联系，计算机并不能理解。有人会说了：简单：吃+其他字 这种结构就让计算机笼统的理解为把后一个词代表的东西放进嘴巴里的意思就好了啊？这种情况适合”吃饭”这个词，但是如果这样你让计算机怎么理解“吃惊”这个词呢？所以这里引出下一个话题：语义解析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;关于语义解析这块，如果大家想要了解的更深入，可以去了解一下AST(抽象语法树)。然而对于我们这个例子，我们用简单的方式模拟着去理解就好了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;对于Lua而言，每一个关键字都有自己特别的结构。所以Lua的关键字将成为语义解析的重点。我们现在涉及到的if这个例子：我们可以简单的用伪代码表述这个解析过程：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;对于if语句我们可以抽象成这种结构：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;If condition(条件表达式) then dosth(语句块) end&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;所以对if语句块进行解析的伪代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;br/&gt;&lt;span&gt;       ReadTokenWord();&lt;br/&gt;&lt;span&gt;       If(tokenWord.type == Type_If) then&lt;br/&gt;&lt;span&gt;          ReadCondition()   //读取条件表达式&lt;br/&gt;&lt;span&gt;          ReadThen()       //读取关键字then&lt;br/&gt;&lt;span&gt;          ReadCodeBlock()   //读取逻辑代码块&lt;br/&gt;&lt;span&gt;          ReadEnd()        //读取关键字End&lt;br/&gt;&lt;span&gt;      End&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;所以为了让计算机理解，我们还是得把这个东西变成数据结构。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;因为我只是做一个Demo而已，所以我用了先验知识。也就是我假定我们的If语句块逻辑结构是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;If 小于条件表达式 then 赋值表达式 End&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;所以在我的Demo里转成C++数据结构就是IfStateMent大概是这样：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://ask.qcloudimg.com/draft/1122790/1e6qmtf6xx.png?imageView2/0/w/1620&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1122790/1e6qmtf6xx.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;OK,所以现在，我们整个词法语法分析都做完了。但是真正的Lua虚拟机并不能执行我们的ifStateMent这种东西。Lua源码里的实现也是类似这种TokenType 和 结构化的 if Statement whileStatement等等，并且Lua没有生成完整的语法树。Lua源码的实现里面，它是解析一些语句，生成临时的语法树，然后翻译成指令集的。并不会等所有的语句都解析完了再翻译的。语义解析和翻译成指令集是并行的一个过程。贴一个源码里面关于语义解析的部分实现：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://ask.qcloudimg.com/draft/1122790/ehoq39y6va.png?imageView2/0/w/1620&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1122790/ehoq39y6va.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;OK，现在咱们已经把我们程序员输入的Lua代码变成了一个数据结构(计算机能读懂)。下一步我们要把这个数据结构再变成Lua虚拟机能认识的东西，这个东西就是 Lua 指令集！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;至于转换的过程，对于我们这个例子，大概是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;br/&gt;&lt;span&gt;    If a &amp;lt; b then a = c end&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;先理解条件 a&amp;lt;b：一种基于寄存器的指令设计大概是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;a,b均为变量。假定我们的可用的寄存器索引值从10（0-9号寄存器都已经被占用了）开始：又假定我们有一个常量索引表：0号常量：字符’a’,1号常量：字符串’b’。那么a&amp;lt;b可以被翻译为这样：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;4.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;LoadK 10，0 ：将_G[ConstVar[0]]载入10号寄存器： R[10] = _G[“a”]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;LoadK 11，1 ：将_G[ConstVar[1]]载入11号寄存器： R[11] = _G[“b”]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;LT 10,11 : 比较R[10]&amp;lt;R[11]是否成立，如果成立，则跳过下一条指令(++PC),否则执行下一条指令。LT后面跟着的一条指令必然是JMP指令。就是如果R[10]&amp;lt;R[11]成立，则不执行JMP，直接执行JMP后面的一条指令(a=c的语句块对应的指令集)，否则直接跳过下面的一个语句块(跳过a=c的赋值过程)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;同理，继续进行a=c的翻译等等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;所以If a &amp;lt; b then a = c end在我写的demo里面最后被翻译成了：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://ask.qcloudimg.com/draft/1122790/zmfq5kuk7q.png?imageView2/0/w/1620&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1122790/zmfq5kuk7q.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;OK，我们现在大概明白了从Lua代码怎么变成指令集的这件事了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;现在我们来具体看一下Lua5.1的指令集：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Lua的指令集是定长的，每一条指令都是32位，其中大概长这样：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://ask.qcloudimg.com/draft/1122790/0hu9f86ds0.png?imageView2/0/w/1620&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1122790/0hu9f86ds0.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;每一条指令的低六位 都是指令的指令码，比如 0代表MOVE，12代表Add。Lua总共有37条指令，分别是&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;41&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;MOVE，LOADK，LOADBOOL,LOADNIL,GETUPVAL,GETGLOBAL,GETTABLE,SETGLOBAL,SETUPVAL,SETTABLE,NEWTABLE,SELF,ADD,SUB,MUL,DIV,MOD,POW,UNM,NOT,LEN,CONCAT,JMP,EQ,LT,LE,TEST,TESTSET,CALL,TAILCALL,RETURN,FORLOOP,TFORLOOP,SETLIST,CLOSE,CLOSURE,VARARG.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;我们发现图上还有iABC，iABx，iAsBx。这个意思是有的指令格式是 OPCODE，A，B，C的格式，有的指令是OPCODE A，BX格式，有的是OPCODE A，sBX格式。sBx和bx的区别是bx是一个无符号整数，而sbx表示的是一个有符号的数，也就是sbx可以是负数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;我不打算详细的讲每一条指令，我还是举个例子：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;指令编码 0x 00004041 这条指令怎么解析：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;0x4041 = 0000 0000 0000 0000 0100 0000 0100 0001&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;低六位（0~5）是opcode：000001 = 1 = LoadK指令（0~37分别对应了我上面列的38条指令，按顺序来的，0是Move，1是loadk，2是loadbool.....37是vararg）。LoadK指令格式是iABC(C没用上，仅ab有用)格式。所以我们再继续读ab。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;a = 低6~13位 为 00000001 = 1所以a=1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;b = 低14~22位 为000000001 = 1所以b=1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;所以0x4041 = LOADK 1, 1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;指令码如何解析我也在demo里面写了，代码大概是这样：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://ask.qcloudimg.com/draft/1122790/2azqgn5857.png?imageView2/0/w/1620&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1122790/2azqgn5857.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;那么Lua文件经过Luac的编译后生成的Lua字节码，Lua字节码文件里面除了包含指令集之外又有哪些东西呢？当然不会像我上面的那个词法语法解析那个demo那么弱智拉。所以下面我们就讲一下Lua字节码文件的结构：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Lua字节码文件(*.lua.bytes)包含了：文件头+顶层函数：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;文件头结构：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://ask.qcloudimg.com/draft/1122790/uwg3ibqfdv.png?imageView2/0/w/1620&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1122790/uwg3ibqfdv.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;顶层函数和其他普通函数都拥有同样的结构：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://ask.qcloudimg.com/draft/1122790/kk2uu9cyc9.png?imageView2/0/w/1620&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1122790/kk2uu9cyc9.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;所以我们是可以轻松自己写代码去解析的。后文提供的Demo源码里面我也已经实现了字节码文件的解析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;Demo中的例子是涉及到的Lua源代码以及最终解析字节码得到的信息分别是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://ask.qcloudimg.com/draft/1122790/8sit9xrekc.png?imageView2/0/w/1620&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1122790/8sit9xrekc.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://ask.qcloudimg.com/draft/1122790/4vxhrwzg5w.png?imageView2/0/w/1620&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1122790/4vxhrwzg5w.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;OK，本文现在就剩最后一点点东西了：Lua虚拟机是怎么执行这些指令的呢?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;大概是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;br/&gt;&lt;span&gt;    While(指令不为空)&lt;br/&gt;&lt;span&gt;       执行指令&lt;br/&gt;&lt;span&gt;       取下一条要执行的指令&lt;br/&gt;&lt;span&gt;    End&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;每一条指令应该怎么执行呢？？？如果大家还有印象的话，咱们前文语义解析完之后转指令集是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;a &amp;lt; b&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;LoadK 10，0 ：将_G[ConstVar[0]]载入10号寄存器： R[10] = _G[“a”]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;LoadK 11，1 ：将_G[ConstVar[1]]载入11号寄存器： R[11] = _G[“b”]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;LT 10,11 : 比较R[10]&amp;lt;R[11]是否成立，如果成立，则跳过下一条指令(++PC),否则执行下一条指令。LT后面跟着的一条指令必然是JMP指令。就是如果R[10]&amp;lt;R[11]成立，则不执行JMP，直接执行JMP后面的一条指令(a=c的语句块)，否则直接跳过下面的一个语句块(跳过a=c的赋值过程)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;那当然是指令后面的文字就已经详细的描述了指令的执行逻辑拉，嘿嘿。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;为了真正的执行起来，所以我们在数据结构上设计需要 1，寄存器：2，常量表：3，全局变量表：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;为了能执行我们demo里面的例子：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;我实现了这段代码涉及到的所有指令&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_LOADK] = &amp;amp;LuaVM::LoadK;&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_SETGLOBAL] = &amp;amp;LuaVM::SetGlobal;&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_GETGLOBAL] = &amp;amp;LuaVM::GetGlobal;&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_ADD] = &amp;amp;LuaVM::_Add;&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_SUB] = &amp;amp;LuaVM::_Sub;&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_MUL] = &amp;amp;LuaVM::_Mul;&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_DIV] = &amp;amp;LuaVM::_Div;&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_CALL] = &amp;amp;LuaVM::_Call;&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_MOD] = &amp;amp;LuaVM::_Mod;&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_LT] = &amp;amp;LuaVM::_LT;&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_JMP] = &amp;amp;LuaVM::_JMP;&lt;br/&gt;&lt;span&gt;insExecute[(int)OP_RETURN] = &amp;amp;LuaVM::_Return;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;以Add为例：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;br/&gt;&lt;span&gt;bool LuaVM::_Add(LuaInstrunction ins)&lt;br/&gt;&lt;span&gt;{&lt;br/&gt;&lt;span&gt;    //R(A):=RK(B)+RK(C) :::&lt;br/&gt;&lt;span&gt;    //Todo：必要的参数合法性检查：如果有问题则抛异常  &lt;br/&gt;&lt;span&gt;    // 将ins.bValue代表的数据和ins.cValue代表的数据相加的结果赋值给索引值为ins.aValue的寄存器&lt;br/&gt;&lt;span&gt;    luaRegisters[ins.aValue].SetValue(0, GetBK(ins.bValue) + GetBK(ins.cValue));&lt;br/&gt;&lt;span&gt;    return true;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;下面是程序的运行效果截图：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://ask.qcloudimg.com/draft/1122790/ivgdd8b6vx.png?imageView2/0/w/1620&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1122790/ivgdd8b6vx.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;看完整个过程，其实可以思考这个问题：为什么Lua执行效率会远远低于C程序？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;个人愚见：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;3.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;真假寄存器：Lua指令集涉及到的寄存器是模拟的寄存器，其实质还是内存上的一个数据。访问速度取决于CPU对内存的访问速度。而C程序最后可以用win32指令集or Arm指令集来执行。这里面涉及到的寄存器EBX，ESP等都是CPU上面的与非门，其访问速度=CPU的频率(和cpu访问内存的速度对比简直一个天上一个地上)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;指令集运行的平台：Lua指令集运行的平台是Lua虚拟机。而C程序指令集运行的直接是硬件支持的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;C里面的数据直接对应的就是内存地址。而Lua里面的数据对应的是一个描述这个数据的数据结构。所以隔了这么一层，效率也大打折扣了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;比如Lua的Gc操作等等这些东西都是C程序不需要去做的。。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;OK，最后献上我写的这个demo的源代码：这份源代码是我在清明节在家的时候瞎写的。也就是说代码并没有经过耐心的整理，而且清明节有人找我出去喝酒，导致我有很长一段时间都处于“我艹快点码完我要出去喝了”这种心不在焉的状态，所以有些编码格式和结构设计都处处能看到随性的例子~毕竟只是一个demo嘛。人生在世，要有佛性，随缘就好！如果各位真的想进一步理解关于Lua虚拟机的东西，那么我推荐诸位有空耐着性子去读一读Lua虚拟机的源代码~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;最后，诚挚感谢所有看到了最后这句话的同学。谢谢你们耐着性子看完了一个技术菜鸡的长篇废话。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;此文已由作者授权腾讯云+社区发布，需要源码的同学请点击：&lt;span&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1092005?fromSource=waitui&quot;&gt;https://cloud.tencent.com/developer/article/1092005?fromSource=waitui&lt;/a&gt;&lt;span&gt;下载源码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;问答&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/45936?fromSource=waitui&quot;&gt;&lt;span&gt;#在Lua是什么意思？&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1005003?fromSource=waitui&quot;&gt;&lt;span&gt;Lua 性能剖析&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1075350?fromSource=waitui&quot;&gt;&lt;span&gt;使用lua小技巧&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1009211?fromSource=waitui&quot;&gt;&lt;span&gt;Openresty最佳案例 | Lua入门&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://images2018.cnblogs.com/blog/1112679/201803/1112679-20180330104936874-1573429539.jpg&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112679/201803/1112679-20180330104936874-1573429539.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Apr 2018 06:54:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/8807734.html</dc:identifier>
</item>
<item>
<title>一个条件判断引发的思考 - 陈宏鸿</title>
<link>http://www.cnblogs.com/aspwebchh/p/8807654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aspwebchh/p/8807654.html</guid>
<description>&lt;p&gt;&lt;span&gt;有一套web系统，会部署到不同的服务器上分别运行，这套系统类似于市面上的OA系统一样， OA开发商会给不同的企业客户部署一套独立的互不关联的系统，我维护的这套系统也差不多，分别被部署在互不关联的服务器上，当然，这些系统的代码是同一套，功能也都是相同的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前两天，有客户反馈，他们系统的某个功能无法正常使用。我开始排查问题，发现部署在其它服务器的系统这个功能都是正常的，唯独这个客户的系统存在问题。而据我所知，这套系统功能上对于所有客户都是一视同仁的，是不存对于不同客户有不同功能的情况，因为部署在所有服务器上的代码是同一份。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刚开始以为问题是代码不同步导致的， 后来反复确认出问题的那套系统的代码的确是最新。可为什么大家的代码都是一样的偏偏就它有问题呢？ 而出现的这个问题是纯业务逻辑上的问题，跟服务器环境是不相关的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反复查看代码， 反复检查配置文件，反复在开发环境中调试，始终找不出个所以然来， 百思不得其解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终我不得不祭出只有在尝试了所有方法后依然无法奏效万不得已才会去使用的杀手锏：线上调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我登上服务器，编辑代码文件，在我认为容易定位到问题所在的代码位置加上打印数据的语句， 然后运行出问题的功能，观察出问题的数据。在这里我要感谢运维，感谢PHP，没有他们的帮助，我还要绕个大圈圈才能干这事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后以我观察到的数据为线索， 一步步的向上追踪问题代码， 最终发现， 在某一个很深的角落里， 静静的躺着这样一段代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$_SERVER&lt;/span&gt;[&quot;SERVER_NAME&quot;] == &quot;192.168.110.233&quot; || &lt;span&gt;$_SERVER&lt;/span&gt;[&quot;SERVER_NAME&quot;] == www.xxx.com&quot;&lt;span&gt;){

//问题系统消失的功能的代码

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;看到这段代码我心里万马奔腾， 气不打一处来， 并且狠狠的骂了一句：CMNLGB。 紧接着，一股深深的无力感涌上心头。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使我受尽折磨，并且付出一下午美好时光的BUG居然是由这么一个在正常的代码中绝不因该出现的脑残的条件判断引起了。 不值得啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我很想怼写着段代码的程序员，但是这个任务我完不成了， 因为她离职了，我就是从她手里接手这套系统的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是我去除代码中的这个条件判断，同步代码，出问题的系统能正常运行了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;冷静下来以后， 我思考这个问题。 毫无疑问，对于这个问题，写出这段代码的程序员当时面对的需求应该是让某个功能只在部分服务器上部署的系统中体现， 于是这个脑残的条件判断应运而生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是我实现这个功能，我可能会在配置文件里加一个具有描述性名称的flag，然后在代码中读取这个flag进行条件判断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而，这样做能从根本上解决问题吗？ 显然不能。 假如我面对的是这个改进版本的条件判断，顶多能让我有几率加速定位到问题所在，也就是我查看配置文件并且眼尖看到了这个配置项目就能明白事情的真相。如果我不去看配置文件，或者没有看到这个配置项，那么到达目标的路径依旧不会有变化，而且这是大概率事件，因为这次出现的问题的特殊性，很难让人将它和配置文件中的配置项联系到一起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那如何做才能从根本上避免这个问题？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为项目维护一份文档？ 不太现实，代码都来不及写， 哪有时间写文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;离职交接时把注意事项说清楚？ 不太现实， 离职交接都是交接一些宏观的内容，代码上的细节不可能在这个范围之内。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;规范化项目管理， 功能迭代流程，更新系统功能需要审核？ 不太现实，部门中这样的项目大大小小几十个，这样做成本太高了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不给做这样的需求？ 更加不现实，人家需求方分分钟投诉到大领导那， 让我们吃不了兜着走。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;那究竟怎样做才能避免这类问题，才能让我愉快的写代码， 求各位大神支招， 在下感激不尽。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Apr 2018 06:42:00 +0000</pubDate>
<dc:creator>陈宏鸿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aspwebchh/p/8807654.html</dc:identifier>
</item>
<item>
<title>Spring Cloud之——Config（配置中心） - 牛初九</title>
<link>http://www.cnblogs.com/boboooo/p/8796636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boboooo/p/8796636.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Spring Cloud Config（配置中心）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　大家好，有一段时间没有写技术博客了。由于工作上的事情，这方面很难分配时间。近几年随着服务化的兴起，一批服务化的框架应运而生，像dubbo，thrift，spring-cloud等。在国内使用dubbo的公司非常多，dubbo也是java程序员面试时必备知识点，而且它的官方文档写的非常清晰易懂，这都使得dubbo的普及非常容易。thrift是apache贡献的，似乎也流行了一段时间，小编对这个框架不是很了解。随后spring-cloud一经推出，便在技术圈流行起来，这段时间小编也在学习spring-cloud，将学到的东西和大家分享一下，如果有不对的地方，还请大家多多指正。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持。使用Config Server，您可以为所有环境中的应用程序管理其外部属性。它非常适合spring应用，也可以使用在其他语言的应用上。随着应用程序通过从开发到测试和生产的部署流程，您可以管理这些环境之间的配置，并确定应用程序具有迁移时需要运行的一切。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Spring Cloud Config服务端特性&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;HTTP，为外部配置提供基于资源的API（键值对，或者等价的YAML内容）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;属性值的加密和解密（对称加密和非对称加密）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过使用@EnableConfigServer在Spring boot应用中非常简单的嵌入。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　Config客户端的特性（特指Spring应用）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;绑定Config服务端，并使用远程的属性源初始化Spring环境。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;属性值的加密和解密（对称加密和非对称加密）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　入门示例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　只要classpath下有Spring Boot Actuator和Spring Config Client，Spring Boot应用就会尝试连接配置服务http://localhost:8888，这个地址是spring.cloud.config.uri的默认地址。如果你想修改这个地址，你可以在bootstrap.[yml或properties]中设置spring.cloud.config.uri或者通过系统属性或者通过环境变量。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@Configuration
@EnableAutoConfiguration
@RestController
public class Application {

  @Value(&quot;${config.name}&quot;)
  String name = &quot;World&quot;;

  @RequestMapping(&quot;/&quot;)
  public String home() {
    return &quot;Hello &quot; + name;
  }

  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }

}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上面例子中的config.name可以来自本地的配置文件，也可以来自远程的配置服务。默认情况下，远程的配置服务将优先使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了运行你自己的配置服务中心，你可以使用spring-cloud-config-server依赖，和@EnableConfigServer注解。如果你设置了spring.config.name=configserver，应用将会运行在8888端口，并且从一个样本仓库提供数据。你需要设置spring.cloud.config.server.git.uri来指定你自己的配置数据。默认的，它是一个git仓库，也可以配置成本地的文件系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Spring Cloud Config服务端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　服务器为外部配置（键称值对或等效的YAML内容）提供了基于资源的HTTP。它可以在Spring Boot应用中使用@EnableConfigServer内嵌。例子如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@SpringBootApplication
@EnableConfigServer
public class SpringCloudConfigServerApplication {

        public static void main(String[] args) {
                SpringApplication.run(SpringCloudConfigServerApplication.class, args);
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　像所有的Spring Boot应用一样，它默认运行在8080端口，你可以通过多种方式将其切换到8888端口。最简单的可以设置spring.config.name=configserver（在Config Server的jar包有一个configserver.yml），它设置了一个默认的配置仓库。另外一种方式是使用你自己的application.properties，这也是小编推荐的方式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;server.port: 8888
spring.cloud.config.server.git.uri: git地址
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　git地址中是你的YAML或者properties文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　环境仓库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你想在哪里存储配置数据？支持这种行为的策略是EnvironmentRepository，它服务于Environment实例。这个Environment是Spring Environment的一个浅副本。Environment通过3个变量被参数化。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;{application}映射客户端的&quot;spring.application.name&quot;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;{profile}映射客户端的&quot;spring.profiles.active&quot;（逗号分隔列表）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;{label}它是服务端的特性，标记版本的一组配置文件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　仓库的实现通常表现的像Spring boot加载配置文件一样，&quot;spring.config.name&quot;等于{application}参数， &quot;spring.profiles.active&quot; 等于{profile}参数。profiles的优先规则和正常的规则是一样的，活动的profiles优于默认的。如果有多个profiles，则最后一个胜出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　客户端的配置实例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;spring:
  application:
    name: foo
  profiles:
    active: dev,mysql
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在Spring Boot应用中，这些参数也可以通过环境变量或者命令行参数设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　git后端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　EnvironmentRepository的默认实现是使用git后端，它对管理更新、物理环境和审核更改非常的方便。要改变仓库的地址，你可以在配置服务端设置&quot;spring.cloud.config.server.git.uri&quot;属性（在application.properties文件中）。如果你用file:开头设置它，它将从本地仓库运行，这样可以在没有服务端的情况下非常快速和简单的启动。这种情况，服务端将直接在本地仓库中运行。为了扩展配置服务并使它高可用，你需要把服务的所有实例指向同一个仓库，因此只有共享文件系统可以工作。即使在这种情况下，最好使用共享文件系统存储库的ssh:协议，以便服务器可以将其克隆并使用本地工作副本作为缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该仓库的实现将HTTP资源中的{label}参数映射到git的标签（提交id、分支名称或者tag）。如果git分支或者tag名称中包含“/”，则HTTP URL中的label要使用特殊字符“(_)”代替。例如：如果分支的名称是foo/bar，则HTTP中的label的格式为foo(_)bar。这个特殊字符也可以用到{application}参数中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　git URI中的占位符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Spring Cloud Config Server支持在git URL中使用占位符，使用{application} 和 {profile}（如果使用{label}，请记住它是使用在git标签中的）。因此你可以轻松的支持“一个应用一个仓库”的原则。如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/myorg/{application}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　或者一个环境一个仓库的原则，使用{profile}代替{application}。另外在{application}参数中使用特殊字符&quot;(_)&quot;可以支持多组织。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/{application}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　{application}参数的格式为&quot;organization(_)application&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　模式匹配和多仓库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在{application}和{profile}参数中使用模式匹配可以支持更多复杂的需求。模式的格式是一组逗号分隔的{application}/{profile}，其中的参数可以使用通配符。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          repos:
            simple: https://github.com/simple/config-repo
            special:
              pattern: special*/dev*,*special*/dev*
              uri: https://github.com/special/config-repo
            local:
              pattern: local*
              uri: file:/home/configsvc/config-repo
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　如果{application}/{profile}没有匹配到任何模式，它将使用默认的仓库地址:spring.cloud.config.server.git.uri。上面的例子中，&quot;simple&quot;仓库匹配的是“simple/*”（它仅仅匹配一个仓库simple，在所有的环境下）。&quot;local&quot;仓库将匹配所有{application}的名字以“local”开头的，并且也是在所有的环境下。“/*”前缀自动添加到所有没有设置{profile}的模式中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　每一个仓库也可以在子目录下存储配置文件，模式匹配也可以用于搜索这些目录，需要制定searchPaths，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          searchPaths: foo,bar*
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上面的例子中，将在foo和以bar开头的目录中，搜索配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　默认地，服务器在第一次请求配置文件时克隆远程的仓库，服务器也可以配置在启动的时候克隆仓库，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;spring:
  cloud:
    config:
      server:
        git:
          uri: https://git/common/config-repo.git
          repos:
            team-a:
                pattern: team-a-*
                cloneOnStart: true
                uri: http://git/team-a/config-repo.git
            team-b:
                pattern: team-b-*
                cloneOnStart: false
                uri: http://git/team-b/config-repo.git
            team-c:
                pattern: team-c-*
                uri: http://git/team-a/config-repo.git
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在上面的例子team-a的仓库将在服务端启动时进行克隆，其他的仓库将在第一次请求时克隆。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　认证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果远程的git仓库需要用户名和密码，可以参照下面的例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          username: trolley
          password: strongpassword
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　到此，Spring Cloud Config服务端就介绍到这里，还有一些不常用的功能在这里就不介绍了，大家可以参照spring cloud官网。Spring Cloud Config服务端的代码示例可以参照我的GitHub地址：https://github.com/bigbugliu/spring-cloud-config-server。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、Spring Cloud Config 客户端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Spring Boot应用可以立即使用Spring Config Server。只要在classpath中有Spring Cloud Config Client的jar包，这个应用就会请求配置的服务端。他将使用绑定的配置服务器（spring.cloud.config.uri中配置的）的属性初始化spring环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在某些情况下，如果服务无法连接到配置服务器，则可能希望启动服务失败。&lt;span class=&quot;xyuu-text-highlight&quot;&gt;如果这是所需的行为，请设置引导配置属性&lt;code&gt;spring.cloud.config.failFast=true&lt;/code&gt;，客户端将以异常停止。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果您希望配置服务器在您的应用程序启动时可能偶尔不可用，您可以要求它在发生故障后继续尝试。首先，您需要设置spring.cloud.config.failFast=true，然后您需要将spring-retry和spring-boot-starter-aop添加到您的类路径中。默认行为是重试6次，初始退避间隔为1000ms，指数乘数为1.1，用于后续退避。您可以使用spring.cloud.config.retry.*配置属性配置这些属性（和其他）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　详细代码请参考我的GitHub：https://github.com/bigbugliu/spring-boot-demo。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring Cloud Config就介绍完了，欢迎大家在评论区讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Apr 2018 06:37:00 +0000</pubDate>
<dc:creator>牛初九</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/boboooo/p/8796636.html</dc:identifier>
</item>
<item>
<title>一大波 Android 刘海屏来袭，全网最全适配技巧！ - 承香墨影</title>
<link>http://www.cnblogs.com/plokmju/p/android_liuhaiping.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plokmju/p/android_liuhaiping.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b8598494cdac4?w=900&amp;amp;h=500&amp;amp;f=jpeg&amp;amp;s=143335&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一序&quot;&gt;一、序&lt;/h2&gt;
&lt;p&gt;Hi，大家好，我是承香墨影！&lt;/p&gt;
&lt;p&gt;Apple 一直在引领设计的潮流，自从 iPhone X 发布之后，&quot;刘海屏&quot; 就一直存在争议。不过不管你怎样，Android 也要跻入 &quot;刘海屏&quot; 的行列，尤其是 Android P 发布之后，也从系统级支持顶部凹槽屏幕设计。&lt;/p&gt;
&lt;p&gt;很多厂商也在逐渐推出 “刘海屏” 设计的手机，在国内比较常见的就是 OPPO R15 和 华为 P20。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b859848b3165e?w=720&amp;amp;h=730&amp;amp;f=jpeg&amp;amp;s=154734&quot;/&gt;&lt;/p&gt;
&lt;p&gt;屏幕不一样了，迎来的就是一些适配上的问题。今天就来聊聊，Android 的 “刘海屏”，以及我们如何去适配它。&lt;/p&gt;
&lt;h2 id=&quot;二刘海屏的背景介绍&quot;&gt;二、刘海屏的背景介绍&lt;/h2&gt;
&lt;h3 id=&quot;背景介绍&quot;&gt;2.1 背景介绍&lt;/h3&gt;
&lt;p&gt;刘海屏的外观，我想大家应该都有概念，不过不同厂商刘海屏的实现方式也有所不太，这一点需要先有个概念。&lt;/p&gt;
&lt;p&gt;就现在市场上的情况来说，会区分成两类，一类是标准的 Android P Api，另外一类就是厂商在 Android P 以下的系统，做的特殊适配。&lt;/p&gt;
&lt;p&gt;例如：华为 P20 就是采用的 Android P 标准 Api 的方式，而 OPPO R15 就不一样了，它有自己的适配 Api。&lt;/p&gt;
&lt;h3 id=&quot;那些需要单独适配&quot;&gt;2.2 那些需要单独适配&lt;/h3&gt;
&lt;p&gt;就算是增加了刘海屏，你也可以发现，大部分都是“切割”的状态栏的区域，所以就面临了三种情况。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;有状态栏的页面，不会收到刘海屏的影响。&lt;/li&gt;
&lt;li&gt;全屏未适配刘海屏的页面，系统会对刘海屏区域进行切割，让整体 UI 页面做下移处理，避开刘海屏的显示。&lt;/li&gt;
&lt;li&gt;全屏已适配刘海屏的页面，可以兼容刘海屏，做到真正的全屏显示。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;后面会单独讲解这几种方式的区别。&lt;/p&gt;
&lt;h3 id=&quot;抢先体验-android-p&quot;&gt;2.3 抢先体验 Android P&lt;/h3&gt;
&lt;p&gt;在手边没有对应系统的设备的时候，模拟器是一条不错的路，最近 Google 也发布了 Android P 的模拟器，还有一个办法就是找一些支持真机云测的平台，租用一台需要的远程设备，也是一个解决方案。&lt;/p&gt;
&lt;p&gt;我这里选择 Android P 的模拟器，有需要自己更新 SDK ，无脑下载更新就好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b8598894b1cbb?w=1494&amp;amp;h=440&amp;amp;f=jpeg&amp;amp;s=121366&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刘海的凹槽区域，大部分是为了给摄像头或者其他传感器留出区域。而在没有刘海的设备或者模拟器上，可以通过开发者选项里的 “Simulate a display with a cutout”，开启刘海屏的支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b8598493066aa?w=1440&amp;amp;h=2560&amp;amp;f=jpeg&amp;amp;s=183699&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你把所有的模式都试过一遍，你会发现，其实刘海屏的刘海，在 Android P 上，是有多种样式的，并非统一的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b859849067a06?w=1830&amp;amp;h=1624&amp;amp;f=jpeg&amp;amp;s=223598&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b8598491dec75?w=1830&amp;amp;h=1624&amp;amp;f=jpeg&amp;amp;s=230904&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;刘海屏的适配&quot;&gt;2.4 刘海屏的适配&lt;/h3&gt;
&lt;p&gt;2.2 也讲清楚了，刘海屏的切割区域，都存在于状态栏上，所以在有状态栏的页面上，是无需我们特殊处理的，系统会帮我们处理好。&lt;/p&gt;
&lt;p&gt;而对于全屏的页面，就需要单独的处理了。我这里，简单做了一个全屏页面，每个横条都是等宽的这样能看到布局上的差异。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b85987fd5f543?w=2048&amp;amp;h=1215&amp;amp;f=jpeg&amp;amp;s=60642&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从左至右分别是：关闭刘海屏、开启刘海屏但不支持、适配刘海屏。&lt;/p&gt;
&lt;p&gt;一个全屏的页面，当没有支持刘海屏又碰到了刘海屏，会导致 UI 下沉，如果这不是一个列表的布局，底部的控件就会被遮挡。&lt;/p&gt;
&lt;p&gt;例如下面这样的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b85987ff18f9b?w=639&amp;amp;h=645&amp;amp;f=jpeg&amp;amp;s=50605&quot; alt=&quot;图片来自：华为适配指南&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一些被刘海遮挡区域的效果，其实主要是依赖 UI 设计师来规避了，不要在可能出现刘海切割的地方，设计可操作的区域，影响用户操作。&lt;/p&gt;
&lt;h2 id=&quot;三技术适配刘海屏&quot;&gt;三、技术适配刘海屏&lt;/h2&gt;
&lt;p&gt;说那么多，最终我们还是需要用技术的方式来适配刘海屏。Android P 的刘海屏，是有标准的 Api 来进行适配，而对于一些厂商自己的刘海屏设备，例如：OPPO R15，就需要遵循它的开发文档进行单独适配。&lt;/p&gt;
&lt;p&gt;Android P 为最新的刘海屏，提供了专门的 Api 来支持：DisplayCutout。&lt;/p&gt;
&lt;h3 id=&quot;开启刘海屏&quot;&gt;3.1 开启刘海屏&lt;/h3&gt;
&lt;p&gt;我们在全屏的页面，需要单独开启支持刘海屏。而 Google 提供的适配方案，可以设置是否在全屏模式下，使用刘海屏的区域。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WindowManager.LayoutParams lp
                =getWindow().getAttributes();
lp.layoutInDisplayCutoutMode =
                WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS;
getWindow().setAttributes(lp);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新的布局属性 &lt;code&gt;layoutInDisplayCutoutMode&lt;/code&gt; 包含三种可选的模式，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static final int LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS = 1;
public static final int LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT = 0;
public static final int LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER = 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;刘海屏的高度&quot;&gt;3.2 刘海屏的高度&lt;/h3&gt;
&lt;p&gt;在全屏模式下，我们需要有办法获取到刘海屏凹槽的高度，才可以做到设计和布局的时候，留出安全距离。&lt;/p&gt;
&lt;p&gt;虽然 Google 要求，刘海屏的凹槽，必须和刘海的高度保持一致，而刘海屏又被隐藏在状态栏了，所以有一个思路是直接获取状态栏的高度，来判断刘海之外，可布局的安全区域。&lt;/p&gt;
&lt;p&gt;不过 Android P 已经预留出了标准的测量 刘海屏凹槽 的 Api：&lt;code&gt;DisplayCutout&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b8598804040e3?w=792&amp;amp;h=886&amp;amp;f=jpeg&amp;amp;s=87276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刘海屏的凹槽，就在屏幕的中间，所以只有 &lt;code&gt;getSafeInsetTop()&lt;/code&gt; 方法返回的结果，是我们需要的，而其他的 &lt;code&gt;getSafeInsetXxx()&lt;/code&gt; 方法，直接返回的是 0 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;view.postDelayed(new Runnable() {
    @Override
    public void run() {
        DisplayCutout displayCutout = view.getRootWindowInsets().getDisplayCutout();
        Log.i(&quot;cxmyDev&quot;, &quot;SafeInsetBottom:&quot; + displayCutout.getSafeInsetBottom());
        Log.i(&quot;cxmyDev&quot;, &quot;SafeInsetLeft:&quot; + displayCutout.getSafeInsetLeft());
        Log.i(&quot;cxmyDev&quot;, &quot;SafeInsetRight:&quot; + displayCutout.getSafeInsetRight());
        Log.i(&quot;cxmyDev&quot;, &quot;SafeInsetTop:&quot; + displayCutout.getSafeInsetTop());
    }
}, 100);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到的结果，也可以看一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;I/cxmyDev: SafeInsetBottom:0
I/cxmyDev: SafeInsetLeft:0
I/cxmyDev: SafeInsetRight:0
I/cxmyDev: SafeInsetTop:112&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;非标准-api&quot;&gt;3.3 非标准 Api&lt;/h3&gt;
&lt;p&gt;像 OPPO 这样的厂商，实现刘海屏的方式，也并不是按照 Android P 的标准做的，它完全是自己修改了刘海屏的实现方式。不过好在，都是会提供完备的适配文档，这就需要我们直接阅读他们提供的开发文档来进行适配。&lt;/p&gt;
&lt;blockquote readability=&quot;2.9615384615385&quot;&gt;
&lt;p&gt;oppo 的刘海屏适配文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://open.oppomobile.com/wiki/doc#id=10139&quot; class=&quot;uri&quot;&gt;https://open.oppomobile.com/wiki/doc#id=10139&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于 OPPO 而言，它刘海的高度是固定的，就是 80px。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b859880be4618?w=400&amp;amp;h=561&amp;amp;f=jpeg&amp;amp;s=16629&quot;/&gt;&lt;/p&gt;
&lt;p&gt;判断当前设备是否是刘海屏，也提供了对应的 Api，可以用以下方法获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;context.getPackageManager().hasSystemFeature(“com.oppo.feature.screen.heteromorphism”)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回 true 为刘海屏，但是这种方法只能识别 OPPO 品牌所支持的刘海屏。&lt;/p&gt;
&lt;h2 id=&quot;四结语&quot;&gt;四、结语&lt;/h2&gt;
&lt;p&gt;看完本篇文章，我想你对 Android 的刘海屏也有一定的认识了。这是一个全新的适配技术，现在还不确定不同厂商会不会对其微调，所以你要是碰到什么问题，不妨在留言区留言讨论。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;今天在公众号后台回复成长『&lt;strong&gt;成长&lt;/strong&gt;』，将会得到我整理的一些学习资料，也能回复『&lt;strong&gt;加群&lt;/strong&gt;』，一起学习进步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/12/162b859885519038?w=1000&amp;amp;h=400&amp;amp;f=jpeg&amp;amp;s=27637&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Apr 2018 05:39:00 +0000</pubDate>
<dc:creator>承香墨影</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plokmju/p/android_liuhaiping.html</dc:identifier>
</item>
<item>
<title>测试驱动开发实践5————testSave之修改文档分类 - 云开发</title>
<link>http://www.cnblogs.com/cloud-dev/p/ce-shi-qu-dong-kai-fa-shi-jian5testSave-zhi-xiu-ga.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloud-dev/p/ce-shi-qu-dong-kai-fa-shi-jian5testSave-zhi-xiu-ga.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;【内容指引】&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;1.确定“修改文档分类”的微服务接口及所需的参数&lt;br/&gt;2.设计测试用例及测试用例合并&lt;br/&gt;3.为测试用例赋值并驱动开发&lt;/p&gt;
&lt;p&gt;上一篇我们通过17个测试用例完成了“新增文档分类”这个业务的单元测试。本篇接着示范如何对修改文档分类的业务编写测试代码：&lt;/p&gt;
&lt;h2 id=&quot;toc_0&quot;&gt;一、确定“修改文档分类”的微服务接口及所需的参数&lt;/h2&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;1.接口&lt;/h3&gt;
&lt;p&gt;“文档”微服务的Rest接口“/category/modify”&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;2.所需参数&lt;/h3&gt;
&lt;p&gt;修改文档分类时，不允许修改该分类所属的项目(projectId)，仅允许修改分类名称和排序。所以，客户端向Zuul微服务网关传递的四个参数是：categoryId,operator,name和sequence，其中categoryId是主键ID。&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;二、设计测试用例及测试用例合并&lt;/h2&gt;
&lt;p&gt;运用上一篇介绍的测试用例设计技巧设计出初步的测试用例。上一篇中我们针对每个测试用例编写了测试代码。实际上，&lt;span&gt;我们可以在一个测试用例中对多个参数进行测试。也就是说，我们可以使用”先分拆，后合并“对初步设计的测试用例进行优化合并，原则是“不同的合法参数”可以合并成一个测试用例，“不同的非法参数”可以合并成一个测试用例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初步的修改测试用例&lt;/strong&gt;&lt;br/&gt;修改用例1:全部参数使用合法中间值&lt;br/&gt;categoryId=8L；&lt;br/&gt;name=&quot;修改用例1文档分类&quot;;&lt;br/&gt;sequence=&quot;5&quot;;&lt;br/&gt;operator=&quot;2L&quot;;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;用例解说&lt;/em&gt;：我们在前面新增文档分类时的“用例1”全部采用合法中间值，操作成功后在数据库产生了一条记录，主键ID为8L，这里“修改用例1”测试对这条数据的修改，所以“categoryId=8L”。其它三个参数均采用了与新增用例1不同但是合法的中间值。&lt;/p&gt;
&lt;p&gt;修改用例2:name采用合法边界值Min：name=&quot;改&quot;;&lt;br/&gt;(其它参数沿用修改用例1的合法中间值)&lt;br/&gt;修改用例3:name采用合法边界值Min+:name=&quot;修改&quot;;&lt;br/&gt;修改用例4:name采用合法边界值Max:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试&quot;;&lt;br/&gt;修改用例5:name采用合法边界值Max-:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测&quot;;&lt;br/&gt;修改用例6:name采用非法等价类：空值；&lt;br/&gt;修改用例7:name采用非法边界值Max+:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测超长&quot;;&lt;br/&gt;修改用例8:name同项目下唯一性逻辑校验：name=“文档分类一”(采用SetUp()中相同的值)；&lt;br/&gt;修改用例9:sequence采用合法边界值Min：sequence=1；&lt;br/&gt;修改用例10:sequence采用合法边界值Min+：sequence=2；&lt;br/&gt;修改用例11:sequence采用合法边界值Max：sequence=Integer.MAX_VALUE；&lt;br/&gt;修改用例12:sequence采用合法边界值Max-：sequence=Integer.MAX_VALUE-1；&lt;br/&gt;修改用例13:sequence采用非法等价类：空值；&lt;br/&gt;修改用例14:sequence采用非法边界值Min-：sequence=0；&lt;br/&gt;修改用例15:sequence采用非法边界值：sequence=-1；&lt;br/&gt;修改用例16:sequence采用非法边界值Max+：sequence=Integer.MAX_VALUE+1；&lt;br/&gt;修改用例17:sequence采用非法等价类：abc(字符)；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化的修改测试用例&lt;/strong&gt;&lt;br/&gt;修改用例1:全部参数使用合法中间值&lt;br/&gt;categoryId=8L；&lt;br/&gt;name=&quot;修改用例1文档分类&quot;;&lt;br/&gt;sequence=&quot;5&quot;;&lt;br/&gt;operator=&quot;2L&quot;;&lt;br/&gt;修改用例2:name采用合法边界值Min：name=&quot;改&quot;，sequence采用合法边界值Min：sequence=1;&lt;br/&gt;(其它参数沿用修改用例1的合法中间值)&lt;br/&gt;修改用例3:name采用合法边界值Min+:name=&quot;修改&quot;，sequence采用合法边界值Min+：sequence=2;&lt;br/&gt;修改用例4:name采用合法边界值Max:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试&quot;，sequence采用合法边界值Max：sequence=Integer.MAX_VALUE;&lt;br/&gt;修改用例5:name采用合法边界值Max-:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测&quot;，sequence采用合法边界值Max-：sequence=Integer.MAX_VALUE-1;&lt;br/&gt;修改用例6:name采用非法等价类：空值，sequence采用非法等价类：空值；&lt;br/&gt;修改用例7:name采用非法边界值Max+:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测超长&quot;，sequence采用非法边界值Max+：sequence=Integer.MAX_VALUE+1;&lt;br/&gt;修改用例8:name同项目下唯一性逻辑校验：name=“文档分类一”(采用SetUp()中相同的值)；&lt;br/&gt;修改用例9:sequence采用非法边界值Min-：sequence=0；&lt;br/&gt;修改用例10:sequence采用非法边界值：sequence=-1；&lt;br/&gt;修改用例11:sequence采用非法等价类：abc(字符)；&lt;/p&gt;
&lt;p&gt;现在优化成11个测试用例了，减少了测试代码编写量。&lt;/p&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;二、根据业务规则设计测试用例&lt;/h2&gt;
&lt;p&gt;打开单元测试类，定位到“测试修改文档分类”处：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180412132632598-1345930521.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;消灭第一个“//TODO”：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 列出修改文档分类测试用例清单
         *
         修改用例1:全部参数使用合法中间值
         categoryId=8L；
         name=&quot;修改用例1文档分类&quot;;
         sequence=&quot;5&quot;;
         operator=&quot;2L&quot;;
         
         修改用例2:name采用合法边界值Min：name=&quot;改&quot;，sequence采用合法边界值Min：sequence=1;
         (其它参数沿用修改用例1的合法中间值)
         
         修改用例3:name采用合法边界值Min+:name=&quot;修改&quot;，sequence采用合法边界值Min+：sequence=2;
         
         修改用例4:name采用合法边界值Max:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试&quot;，sequence采用合法边界值Max：sequence=Integer.MAX_VALUE;
         
         修改用例5:name采用合法边界值Max-:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测&quot;，sequence采用合法边界值Max-：sequence=Integer.MAX_VALUE-1;
         
         修改用例6:name采用非法等价类：空值，sequence采用非法等价类：空值；
         
         修改用例7:name采用非法边界值Max+:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测超长&quot;，sequence采用非法边界值Max+：sequence=Integer.MAX_VALUE+1;
         
         修改用例8:name同项目下唯一性逻辑校验：name=“文档分类一”(采用SetUp()中相同的值)；
         
         修改用例9:sequence采用非法边界值Min-：sequence=0；
         
         修改用例10:sequence采用非法边界值：sequence=-1；
         
         修改用例11:sequence采用非法等价类：abc(字符)；
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;三、为测试用例赋值并驱动开发&lt;/h2&gt;
&lt;p&gt;先在“云开发”平台初始化代码的基础上写“修改用例1”：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改用例1:全部参数使用合法中间值&lt;/span&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------------测试用例赋值开始---------------------*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        category &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Category();
        category.setCategoryId(&lt;/span&gt;8L&lt;span&gt;);
        category.setName(&lt;/span&gt;&quot;修改用例1文档分类&quot;&lt;span&gt;);
        category.setSequence(&lt;/span&gt;5&lt;span&gt;);

        Long operator2 &lt;/span&gt;= 2L&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------------测试用例赋值结束---------------------*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mockMvc.perform(
                MockMvcRequestBuilders.post(&lt;/span&gt;&quot;/category/modify&quot;&lt;span&gt;)
                        .param(&lt;/span&gt;&quot;categoryId&quot;&lt;span&gt;,id.toString())
                        .param(&lt;/span&gt;&quot;name&quot;&lt;span&gt;,category.getName())
                        .param(&lt;/span&gt;&quot;sequence&quot;&lt;span&gt;,category.getSequence().toString())
                        .param(&lt;/span&gt;&quot;operator&quot;&lt;span&gt;,operator2.toString())
                )
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印结果&lt;/span&gt;
&lt;span&gt;                .andDo(print())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查状态码为200&lt;/span&gt;
&lt;span&gt;                .andExpect(status().isOk())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查内容有&quot;category&quot;&lt;/span&gt;
                .andExpect(content().string(containsString(&quot;category&quot;&lt;span&gt;)))
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查返回的数据节点&lt;/span&gt;
                .andExpect(jsonPath(&quot;$.category.categoryId&quot;&lt;span&gt;).value(id))
                .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.name&quot;&lt;span&gt;).value(category.getName()))
                .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.sequence&quot;&lt;span&gt;).value(category.getSequence()))
                .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.creationTime&quot;&lt;span&gt;).isNotEmpty())
                .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.creatorUserId&quot;&lt;span&gt;).value(operator))
                .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.lastModificationTime&quot;&lt;span&gt;).isNotEmpty())
                .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.lastModifierUserId&quot;&lt;span&gt;).value(operator2))
                .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.isDeleted&quot;).value(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
                .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.deletionTime&quot;&lt;span&gt;).isEmpty())
                .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.deleterUserId&quot;).value(0&lt;span&gt;))
                .andReturn();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行单元测试，现在testSave变绿了，说明“修改用例1”测试已通过：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180412132632752-255547551.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;接下来我们编写其它修改用例，其中还可以进一步将多个测试用例的代码通过数组和for循环来写，减少重复的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改用例2:name采用合法边界值Min：name=&quot;改&quot;，sequence采用合法边界值Min：sequence=1;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改用例3:name采用合法边界值Min+:name=&quot;修改&quot;，sequence采用合法边界值Min+：sequence=2
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改用例4:name采用合法边界值Max:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试&quot;，
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sequence采用合法边界值Max：sequence=Integer.MAX_VALUE;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改用例5:name采用合法边界值Max-:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测&quot;，
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sequence采用合法边界值Max-：sequence=Integer.MAX_VALUE-1;&lt;/span&gt;
&lt;span&gt;
        String[] names &lt;/span&gt;= {&quot;改&quot;,&quot;修改&quot;,&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试&quot;,&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测&quot;&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] sequences = {1, 2, Integer.MAX_VALUE, Integer.MAX_VALUE-1&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i &amp;lt; 4;i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------------测试用例赋值开始---------------------*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            category.setName(&lt;/span&gt;&quot;改&quot;&lt;span&gt;);
            category.setSequence(&lt;/span&gt;1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------------测试用例赋值结束---------------------*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mockMvc.perform(
                    MockMvcRequestBuilders.post(&lt;/span&gt;&quot;/category/modify&quot;&lt;span&gt;)
                            .param(&lt;/span&gt;&quot;categoryId&quot;&lt;span&gt;, id.toString())
                            .param(&lt;/span&gt;&quot;name&quot;&lt;span&gt;, category.getName())
                            .param(&lt;/span&gt;&quot;sequence&quot;&lt;span&gt;, category.getSequence().toString())
                            .param(&lt;/span&gt;&quot;operator&quot;&lt;span&gt;, operator2.toString())
            )
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印结果&lt;/span&gt;
&lt;span&gt;                    .andDo(print())
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查状态码为200&lt;/span&gt;
&lt;span&gt;                    .andExpect(status().isOk())
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查内容有&quot;category&quot;&lt;/span&gt;
                    .andExpect(content().string(containsString(&quot;category&quot;&lt;span&gt;)))
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查返回的数据节点&lt;/span&gt;
                    .andExpect(jsonPath(&quot;$.category.categoryId&quot;&lt;span&gt;).value(id))
                    .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.name&quot;&lt;span&gt;).value(category.getName()))
                    .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.sequence&quot;&lt;span&gt;).value(category.getSequence()))
                    .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.creationTime&quot;&lt;span&gt;).isNotEmpty())
                    .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.creatorUserId&quot;&lt;span&gt;).value(operator))
                    .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.lastModificationTime&quot;&lt;span&gt;).isNotEmpty())
                    .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.lastModifierUserId&quot;&lt;span&gt;).value(operator2))
                    .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.isDeleted&quot;).value(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
                    .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.deletionTime&quot;&lt;span&gt;).isEmpty())
                    .andExpect(jsonPath(&lt;/span&gt;&quot;$.category.deleterUserId&quot;).value(0&lt;span&gt;))
                    .andReturn();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改用例7:name采用非法边界值Max+:name=&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测超长&quot;，
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sequence采用非法边界值Max+：sequence=Integer.MAX_VALUE+1;&lt;/span&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------------测试用例赋值开始---------------------*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        category.setName(&lt;/span&gt;&quot;测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测试修改文档分类测超长&quot;&lt;span&gt;);
        category.setSequence(Integer.MAX_VALUE&lt;/span&gt;+1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------------测试用例赋值结束---------------------*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mockMvc.perform(
                MockMvcRequestBuilders.post(&lt;/span&gt;&quot;/category/modify&quot;&lt;span&gt;)
                        .param(&lt;/span&gt;&quot;categoryId&quot;&lt;span&gt;,id.toString())
                        .param(&lt;/span&gt;&quot;name&quot;&lt;span&gt;,category.getName())
                        .param(&lt;/span&gt;&quot;sequence&quot;&lt;span&gt;,category.getSequence().toString())
                        .param(&lt;/span&gt;&quot;operator&quot;&lt;span&gt;,operator2.toString())
        )
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印结果&lt;/span&gt;
&lt;span&gt;                .andDo(print())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查状态码为200&lt;/span&gt;
&lt;span&gt;                .andExpect(status().isOk())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查内容有&quot;formErrors&quot;&lt;/span&gt;
                .andExpect(content().string(containsString(&quot;formErrors&quot;&lt;span&gt;)))
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查返回的数据节点&lt;/span&gt;
                .andExpect(content().string(containsString(&quot;Length.category.name&quot;&lt;span&gt;)))
                .andExpect(content().string(containsString(&lt;/span&gt;&quot;Min.category.sequence&quot;&lt;span&gt;)))
                .andReturn();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改用例8:name同项目下唯一性逻辑校验：name=“文档分类一”(采用SetUp()中相同的值)；&lt;/span&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------------测试用例赋值开始---------------------*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        category.setName(&lt;/span&gt;&quot;文档分类一&quot;&lt;span&gt;);
        category.setSequence(&lt;/span&gt;5&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------------测试用例赋值结束---------------------*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mockMvc.perform(
                MockMvcRequestBuilders.post(&lt;/span&gt;&quot;/category/modify&quot;&lt;span&gt;)
                        .param(&lt;/span&gt;&quot;categoryId&quot;&lt;span&gt;,id.toString())
                        .param(&lt;/span&gt;&quot;name&quot;&lt;span&gt;,category.getName())
                        .param(&lt;/span&gt;&quot;sequence&quot;&lt;span&gt;,category.getSequence().toString())
                        .param(&lt;/span&gt;&quot;operator&quot;&lt;span&gt;,operator2.toString())
                )
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印结果&lt;/span&gt;
&lt;span&gt;                .andDo(print())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查状态码为200&lt;/span&gt;
&lt;span&gt;                .andExpect(status().isOk())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查内容有&quot;errorMessage&quot;&lt;/span&gt;
                .andExpect(content().string(containsString(&quot;\&quot;errorMessage\&quot; : \&quot;[10001]&quot;&lt;span&gt;)))
                .andReturn();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改用例9:sequence采用非法边界值Min-：sequence=0；
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改用例10:sequence采用非法边界值：sequence=-1；&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=-1;i&amp;lt;=0;i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------------测试用例赋值开始---------------------*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            category.setSequence(i);
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;---------------------测试用例赋值结束---------------------*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mockMvc.perform(
                    MockMvcRequestBuilders.post(&lt;/span&gt;&quot;/category/modify&quot;&lt;span&gt;)
                            .param(&lt;/span&gt;&quot;categoryId&quot;&lt;span&gt;, id.toString())
                            .param(&lt;/span&gt;&quot;name&quot;&lt;span&gt;, category.getName())
                            .param(&lt;/span&gt;&quot;sequence&quot;&lt;span&gt;, category.getSequence().toString())
                            .param(&lt;/span&gt;&quot;operator&quot;&lt;span&gt;, operator2.toString())
            )
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印结果&lt;/span&gt;
&lt;span&gt;                    .andDo(print())
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查状态码为200&lt;/span&gt;
&lt;span&gt;                    .andExpect(status().isOk())
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查内容有&quot;formErrors&quot;&lt;/span&gt;
                    .andExpect(content().string(containsString(&quot;formErrors&quot;&lt;span&gt;)))
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查返回的数据节点&lt;/span&gt;
                    .andExpect(content().string(containsString(&quot;Min.category.sequence&quot;&lt;span&gt;)))
                    .andReturn();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改用例11:sequence采用非法等价类：abc(字符)；&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mockMvc.perform(
                MockMvcRequestBuilders.post(&lt;/span&gt;&quot;/category/modify&quot;&lt;span&gt;)
                        .param(&lt;/span&gt;&quot;categoryId&quot;&lt;span&gt;, id.toString())
                        .param(&lt;/span&gt;&quot;name&quot;&lt;span&gt;, category.getName())
                        .param(&lt;/span&gt;&quot;sequence&quot;, &quot;abc&quot;&lt;span&gt;)
                        .param(&lt;/span&gt;&quot;operator&quot;&lt;span&gt;, operator2.toString())
        )
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印结果&lt;/span&gt;
&lt;span&gt;                .andDo(print())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查状态码为200&lt;/span&gt;
&lt;span&gt;                .andExpect(status().isOk())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查内容有&quot;formErrors&quot;&lt;/span&gt;
                .andExpect(content().string(containsString(&quot;formErrors&quot;&lt;span&gt;)))
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查返回的数据节点&lt;/span&gt;
                .andExpect(content().string(containsString(&quot;typeMismatch.category.sequence&quot;&lt;span&gt;)))
                .andReturn();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中“修改用例8”需要修改服务实现类代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180412132633441-2012757216.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;最终上述用例全部测试通过。&lt;/p&gt;

</description>
<pubDate>Thu, 12 Apr 2018 05:27:00 +0000</pubDate>
<dc:creator>云开发</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloud-dev/p/ce-shi-qu-dong-kai-fa-shi-jian5testSave-zhi-xiu-ga.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 2.0 项目实战（8）Core下缓存操作、序列化操作、JSON操作等Helper集合类 - 郑州-在路上</title>
<link>http://www.cnblogs.com/oorz/p/8805073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oorz/p/8805073.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;本文目录&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.  前沿&lt;br/&gt;2.CacheHelper基于Microsoft.Extensions.Caching.Memory封装&lt;br/&gt;3.XmlHelper快速操作xml文档&lt;br/&gt;4.SerializationHelper文件序列化操作&lt;br/&gt;5.JsonHelper基于Newtonsoft.Json封装&lt;br/&gt;6.ByteConvertHelper byte转换操作类&lt;br/&gt;7. 总结&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1.  前沿&lt;/h2&gt;
&lt;p&gt;　　Net Core2.0以前缓存操作、XML操作文档、处理JSON、序列化等都整理过相关帮助类，方便项目全局开发调用，但这些Helper在Net Core下面需要做调整才能使用，下面是我开发过程中整理的几个帮助类，可单独使用，仅供参考。&lt;/p&gt;
&lt;h2&gt;2.  CacheHelper基于Microsoft.Extensions.Caching.Memory封装&lt;/h2&gt;
&lt;p&gt;　　在net core2.0下System.Web.Caching不在提供支持，取而代之的是Microsoft.Extensions.Caching.Memory，现在就基于新的类库做扩展封装。注意：netcore2.0文件依赖缓存好像没有扩展，修改文件信息后缓存自动更新功能暂未整合。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;using System.Web.Caching;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;netcore2.0不再提供支持&lt;/span&gt;

&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Caching.Memory;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; NC.Common
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 为当前 HTTP 请求获取 Cache 对象。
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CacheHelper
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; MemoryCache cache = &lt;span&gt;new&lt;/span&gt; MemoryCache(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryCacheOptions());
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建缓存项的文件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;缓存Key&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;obj&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;object对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                cache.Set(key, value);
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建缓存项过期
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;缓存Key&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;obj&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;object对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expires&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;过期时间(秒)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;object&lt;/span&gt; value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expires)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                cache.Set(key, value, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryCacheEntryOptions()
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置缓存时间，如果被访问重置缓存时间。设置相对过期时间x秒&lt;/span&gt;
&lt;span&gt;                    .SetSlidingExpiration(TimeSpan.FromSeconds(expires)));
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dotnetcore2.0 文件依赖缓存好像没有，暂未找到。&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;// 创建缓存项的文件依赖
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;缓存Key&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;&amp;lt;param name=&quot;obj&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;object对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;&amp;lt;param name=&quot;fileName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件绝对路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;public static void Set(string key, object obj, string fileName)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建缓存依赖项
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    CacheDependency dep = new CacheDependency(fileName);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建缓存
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    HttpContext.Current.Cache.Insert(key, obj, dep);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取缓存对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;缓存Key&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;object对象&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; val = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; cache.TryGetValue(key, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; val))
            {

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; val;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取缓存对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;T对象&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;缓存Key&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T Get&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; obj =&lt;span&gt; Get(key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T) : (T)obj;
        }


        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 移除缓存项的文件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;缓存Key&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Remove(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
        {
            cache.Remove(key);
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.  XmlHelper快速操作xml文档&lt;/h2&gt;
&lt;p&gt;　　这里封装常见的对xml的操作和读取方法，追加节点，删除节点操作处理方法。配合序列化Hepler类处理。Core项目中实际使用过程中现仅用到SerializationHelper，里面序列化了xml并操作。由于xmlhelper做好了分享出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Xml;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; NC.Common
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; XmlHelper
    {
        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; --增、删、改操作--

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 追加节点
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filePath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;XML文档绝对路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;xPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;范例: @&quot;Skill/First/SkillItem&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;xmlNode&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;XmlNode节点&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AppendChild(&lt;span&gt;string&lt;/span&gt; filePath, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; xPath, XmlNode xmlNode)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                XmlDocument doc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlDocument();
                doc.Load(filePath);
                XmlNode xn &lt;/span&gt;=&lt;span&gt; doc.SelectSingleNode(xPath);
                XmlNode n &lt;/span&gt;= doc.ImportNode(xmlNode, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                xn.AppendChild(n);
                doc.Save(filePath);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从XML文档中读取节点追加到另一个XML文档中
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filePath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;需要读取的XML文档绝对路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;xPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;范例: @&quot;Skill/First/SkillItem&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;toFilePath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;被追加节点的XML文档绝对路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;toXPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;范例: @&quot;Skill/First/SkillItem&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AppendChild(&lt;span&gt;string&lt;/span&gt; filePath, &lt;span&gt;string&lt;/span&gt; xPath, &lt;span&gt;string&lt;/span&gt; toFilePath, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; toXPath)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                XmlDocument doc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlDocument();
                doc.Load(toFilePath);
                XmlNode xn &lt;/span&gt;=&lt;span&gt; doc.SelectSingleNode(toXPath);

                XmlNodeList xnList &lt;/span&gt;=&lt;span&gt; ReadNodes(filePath, xPath);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xnList != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (XmlElement xe &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xnList)
                    {
                        XmlNode n &lt;/span&gt;= doc.ImportNode(xe, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                        xn.AppendChild(n);
                    }
                    doc.Save(toFilePath);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 修改节点的InnerText的值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filePath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;XML文件绝对路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;xPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;范例: @&quot;Skill/First/SkillItem&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;节点的值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; UpdateNodeInnerText(&lt;span&gt;string&lt;/span&gt; filePath, &lt;span&gt;string&lt;/span&gt; xPath, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                XmlDocument doc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlDocument();
                doc.Load(filePath);
                XmlNode xn &lt;/span&gt;=&lt;span&gt; doc.SelectSingleNode(xPath);
                XmlElement xe &lt;/span&gt;=&lt;span&gt; (XmlElement)xn;
                xe.InnerText &lt;/span&gt;=&lt;span&gt; value;
                doc.Save(filePath);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 读取XML文档
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filePath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;XML文件绝对路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; XmlDocument LoadXmlDoc(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; filePath)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                XmlDocument doc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlDocument();
                doc.Load(filePath);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; doc;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt; 增、删、改操作

        &lt;span&gt;#region&lt;/span&gt; --读取XML的所有子节点--
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 读取XML的所有子节点
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filePath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;XML文件绝对路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;xPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;范例: @&quot;Skill/First/SkillItem&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; XmlNodeList ReadNodes(&lt;span&gt;string&lt;/span&gt; filePath, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; xPath)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                XmlDocument doc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlDocument();
                doc.Load(filePath);
                XmlNode xn &lt;/span&gt;=&lt;span&gt; doc.SelectSingleNode(xPath);
                XmlNodeList xnList &lt;/span&gt;= xn.ChildNodes;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到该节点的子节点&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; xnList;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt; 扩展方法&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上用的是try catch这种处理，如果使用using可以参考一下链接：https://www.cnblogs.com/Chary/p/No0000DE.html&lt;/p&gt;
&lt;h2&gt;4.  SerializationHelper文件序列化操作&lt;/h2&gt;
&lt;p&gt;　　对xml文件进行序列化并操作，可以参考。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Xml.Serialization;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; NC.Common
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SerializationHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SerializationHelper() { }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 反序列化
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;type&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;对象类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filename&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Load(Type type, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; filename)
        {
            FileStream fs &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; open the stream...&lt;/span&gt;
                fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                XmlSerializer serializer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlSerializer(type);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; serializer.Deserialize(fs);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fs != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    fs.Close();
            }
        }


        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 序列化
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;obj&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filename&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Save(&lt;span&gt;object&lt;/span&gt; obj, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; filename)
        {
            FileStream fs &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; serialize it...&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                fs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(filename, FileMode.Create, FileAccess.Write, FileShare.ReadWrite);
                XmlSerializer serializer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlSerializer(obj.GetType());
                serializer.Serialize(fs, obj);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fs != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    fs.Close();
            }

        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　调用案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_1e5524f9-41b8-4b52-bc15-50193a444895&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1e5524f9-41b8-4b52-bc15-50193a444895&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1e5524f9-41b8-4b52-bc15-50193a444895&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#region&lt;/span&gt;--站点配置文件--
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  读取配置文件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; NC.Model.siteconfig loadConfig()
        {
            NC.Model.siteconfig model &lt;/span&gt;= CacheHelper.Get&amp;lt;NC.Model.siteconfig&amp;gt;&lt;span&gt;(JHKeys.CACHE_SYS_CONFIG);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (model == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;netcore2.0文件依赖缓存没有，暂时只能修改文件后手动清空一次缓存
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Utils.GetXmlMapPath(JHKeys.FILE_SYS_XML_CONFING);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CacheHelper是NET Core下Microsoft.Extensions.Caching.Memory缓存帮助类&lt;/span&gt;
                CacheHelper.Set(JHKeys.CACHE_SYS_CONFIG, (NC.Model.siteconfig)SerializationHelper.Load(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(NC.Model.siteconfig), Utils.GetXmlMapPath(JHKeys.FILE_SYS_XML_CONFING)));
                model &lt;/span&gt;= CacheHelper.Get&amp;lt;NC.Model.siteconfig&amp;gt;&lt;span&gt;(JHKeys.CACHE_SYS_CONFIG);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; model;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  保存配置文件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; NC.Model.siteconfig saveConifg(NC.Model.siteconfig model)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; saveConifg(model, Utils.GetXmlMapPath(JHKeys.FILE_SYS_XML_CONFING));
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; lockHelper = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 写入站点配置文件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; NC.Model.siteconfig saveConifg(NC.Model.siteconfig model, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; configFilePath)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清缓存&lt;/span&gt;
&lt;span&gt;CacheHelper.Remove(JHKeys.CACHE_SYS_CONFIG);
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (lockHelper)
            {
                SerializationHelper.Save(model, configFilePath);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; model;
        }
&lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;站点配置文件&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;5.  JsonHelper基于Newtonsoft.Json封装&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43.5&quot;&gt;&lt;img id=&quot;code_img_closed_e467bded-a2d8-4327-9f50-4ee1351810cf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e467bded-a2d8-4327-9f50-4ee1351810cf&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e467bded-a2d8-4327-9f50-4ee1351810cf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Newtonsoft.Json;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; NC.Common
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; JSON帮助类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JsonHelper
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 对象转JSON 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;obj&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;JSON格式的字符串&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt; 
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ObjectToJSON(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b =&lt;span&gt; Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(obj));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Encoding.UTF8.GetString(b);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {

                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JSONHelper.ObjectToJSON(): &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 数据表转键值对集合
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 把DataTable转成 List集合, 存每一行 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 集合中放的是键值对字典,存每一列 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dt&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;数据表&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;哈希表数组&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt; 
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; DataTableToList(DataTable dt)
        {
            List&lt;/span&gt;&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; list
                 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DataRow dr &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dt.Rows)
            {
                Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; dic = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DataColumn dc &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dt.Columns)
                {
                    dic.Add(dc.ColumnName, dr[dc.ColumnName]);
                }
                list.Add(dic);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 数据集转键值对数组字典 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dataSet&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;数据集&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;键值对数组字典&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt; 
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, List&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; DataSetToDic(DataSet ds)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, List&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, List&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DataTable dt &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ds.Tables)
                result.Add(dt.TableName, DataTableToList(dt));

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 数据表转JSON 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dataTable&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;数据表&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;JSON字符串&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt; 
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; DataTableToJSON(DataTable dt)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ObjectToJSON(DataTableToList(dt));
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; JSON文本转对象,泛型方法 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;jsonText&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;JSON文本&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;指定类型的对象&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt; 
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T JSONToObject&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; jsonText)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JavaScriptSerializer jss = new JavaScriptSerializer();&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;T&amp;gt;&lt;span&gt;(jsonText);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return jss.Deserialize&amp;lt;T&amp;gt;(jsonText);&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JSONHelper.JSONToObject(): &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将JSON文本转换为数据表数据 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;jsonText&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;JSON文本&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;数据表字典&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt; 
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, List&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; TablesDataFromJSON(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; jsonText)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JSONToObject&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, List&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;(jsonText);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将JSON文本转换成数据行 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;jsonText&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;JSON文本&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;数据行的字典&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; DataRowFromJSON(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; jsonText)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JSONToObject&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;(jsonText);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;JsonHelper&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;6.  ByteConvertHelper byte转换操作类&lt;/h2&gt;
&lt;p&gt;　　　　Byte转换操作类这里主要配合session存储使用，net core 2.0存储session 类型为object，先转成byte存储，读取再通过byte转object。&lt;/p&gt;
&lt;p&gt;　　　　例如Session存储值是字符串；设置session：HttpContext.Session.SetString(&quot;name&quot;,&quot;hello world!&quot;);  获取session：string str = HttpContext.Session.GetString(&quot;name&quot;); &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Newtonsoft.Json;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; NC.Common
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; byte转换操作类，主要用于Session存储
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ByteConvertHelper
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将对象转换为byte数组
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;obj&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;被转换对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;转换后byte数组&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] Object2Bytes(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] serializedResult =&lt;span&gt; Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(obj));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; serializedResult;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将byte数组转换成对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buff&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;被转换byte数组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;转换完成后的对象&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Bytes2Object(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] buff)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;(Encoding.UTF8.GetString(buff));
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将byte数组转换成对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buff&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;被转换byte数组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;转换完成后的对象&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T Bytes2Object&amp;lt;T&amp;gt;(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] buff)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;T&amp;gt;&lt;span&gt;(Encoding.UTF8.GetString(buff));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　调用实例参考《&lt;a href=&quot;http://www.cnblogs.com/oorz/p/8632147.html&quot;&gt;Asp.Net Core 2.0 项目实战（11） 基于OnActionExecuting全局过滤器，页面操作权限过滤控制到按钮级&lt;/a&gt;》中的&amp;lt;3.5 Session相关操作&amp;gt;。&lt;/p&gt;
&lt;h2&gt;7.  总结&lt;/h2&gt;
&lt;p&gt;　　以上帮助类只是为了快速开发，文中有些帮助类是由webform项目升级改造的，适合自己项目的一些封装，仅供参考。需要做成帮助类全局调用的Helper还有很多，欢迎大家多多交流，谢谢！&lt;/p&gt;

</description>
<pubDate>Thu, 12 Apr 2018 04:51:00 +0000</pubDate>
<dc:creator>郑州-在路上</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/oorz/p/8805073.html</dc:identifier>
</item>
<item>
<title>Tumblr：我们是如何从 PHP 5 升级到 PHP 7 的 - Summer2018</title>
<link>http://www.cnblogs.com/summerblue/p/8807012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerblue/p/8807012.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/162383/201804/162383-20180412121145985-115750485.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Tumblr 团队经常在寻找新的方式来提升网站的性能。这意味着要给访问量大的代码增加缓存，找到更快的 CDN 配置，或者升级基础软件。&lt;/p&gt;
&lt;p&gt;最近，通过一次跨团队的努力，我们将全部 web 服务器战舰从 PHP 5 升级到了 PHP 7。整个升级是一次有趣的项目，有一些非常酷的结果，所以我们想分享给你。&lt;/p&gt;
&lt;h2 id=&quot;时间表&quot;&gt;时间表&lt;/h2&gt;
&lt;p&gt;这起源于 2015 年秋的一个黑客日（hackday，类似于黑客马拉松）项目。&lt;a href=&quot;https://tmblr.co/mBWgO3jg4lxBdIkQDX2pSSg&quot;&gt;@oli&lt;/a&gt; 和 &lt;a href=&quot;https://tmblr.co/m2kWeuYiN6mUDTT9_3vCoFg&quot;&gt;@trav&lt;/a&gt; 在 &lt;code&gt;PHP7 RC&lt;/code&gt; 上运行 &lt;code&gt;Tumblr&lt;/code&gt; . 此时, 很多 &lt;code&gt;PHP&lt;/code&gt; 扩展还不支持 &lt;code&gt;PHP 7&lt;/code&gt;, 但是有一些非官方的 &lt;code&gt;forks&lt;/code&gt; 已经在（非常）试验性的支持了，就算是这样，它还是跑起来了。&lt;/p&gt;
&lt;p&gt;这个春天，&lt;code&gt;PHP7&lt;/code&gt; 开始变得更加稳定了，我们决定是时候开始密切关注升级了，我们做的第一件事就是打包新版本，这样安装就变得简单并且一致。同时，我们也把我们内部的 &lt;code&gt;PHP&lt;/code&gt; 扩展放进了新版本里，这样所有东西都准备好了，随时可用。&lt;/p&gt;
&lt;p&gt;我们编写了一个小脚本来升级（或者降级）开发服务器，然后，春末夏初，开始了测试（更多内容请往下看），&lt;code&gt;PHP&lt;/code&gt; 包的构建迭代，性能测试和评估，随着它的稳定，我们开始吸引更多的开发者在支持 &lt;code&gt;PHP7&lt;/code&gt; 的机器上进行他们的日常开发。&lt;/p&gt;
&lt;p&gt;最后，在 8 月底，我们对我们的测试充满自信， 于是我们在生产服务器上的一小部分使用了 &lt;code&gt;PHP7&lt;/code&gt; 。两周后，随着逐步增加，所有响应用户请求的服务器都更新了！&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;当我们进行升级时，测试所有代码并确保它们以相同的方式运行是非常重要的，我们有一些方法来解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fetsy%2Fphan&amp;amp;t=NTQ1NWM3ZDQ0NTBlOTAxMTE0NmMxMjRkNTBhMjAzMzViZTUzNjI2NCxHTWc0TExPNQ%3D%3D&amp;amp;b=t%3ACwoihvyyOxn8Mk5TUS0KDg&amp;amp;p=https%3A%2F%2Fengineering.tumblr.com%2Fpost%2F152998126990%2Fphp-7-at-tumblr&amp;amp;m=0&quot;&gt;Phan&lt;/a&gt;. 在这个项目中，我们用它在代码库中查找与 &lt;code&gt;PHP7&lt;/code&gt; 不兼容的代码，有了它，找到并且解决这些问题变得非常容易。&lt;/p&gt;
&lt;p&gt;我们还有一些单元和集成测试来帮忙确定哪些方面不能像以前一样有效的工作，由于这个项目还在正常开发，我们需要确保没有添加任何没有通过 &lt;code&gt;PHP7&lt;/code&gt; 验证的代码。所以我们用 &lt;code&gt;CI&lt;/code&gt; 任务来跑所有的 &lt;code&gt;PHP 5&lt;/code&gt; 和 &lt;code&gt;PHP7&lt;/code&gt; 的测试&lt;/p&gt;
&lt;h2 id=&quot;结果&quot;&gt;结果&lt;/h2&gt;
&lt;p&gt;那么在项目结束时，最后的结果是什么？好吧，有两件事对我们有很大的改进，一个是性能另一个是语言的特征。&lt;/p&gt;
&lt;h2 id=&quot;性能&quot;&gt;性能&lt;/h2&gt;
&lt;p&gt;当我们把 PHP7 推到首批服务器上时，很明显我们更关注的是各种图表，以确保事情能够顺利的进行。正如我们上面提到的，我们正在寻找性能的改进，但是实际结果是惊人的。几乎第一时间发现了延迟下降了一半，服务器上的 CPU 负载至少减少了50%还要多。我们的服务器服务速度比原来的快两倍，而且是只用了一半的 CPU 资源来完成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lccdn.phphub.org/uploads/images/201804/09/1/vKcLJT8uD0.png?imageView2/2/w/1240/h/0&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lccdn.phphub.org/uploads/images/201804/09/1/US1FpFQBjc.png?imageView2/2/w/1240/h/0&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上这些是处理 API 服务的部分图表。正如你所看到的，延迟下降到不到一半，平均峰值负荷现在低于以前的最低点！&lt;/p&gt;
&lt;h2 id=&quot;语言功能&quot;&gt;语言功能&lt;/h2&gt;
&lt;p&gt;PHP 7 还带来了许多有趣的新功能，可以让 Tumblr 的开发人员的生活变得更轻松。 一些亮点是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标量类型提示：PHP 在历史上对于类型安全来说相当差，PHP 7 引入了标量类型提示，它确保传递的值符合特定类型（string，bool，int，float 等）。&lt;/li&gt;
&lt;li&gt;返回类型声明：现在，使用 PHP 7，函数可以具有语言将执行的显式返回类型。 这减少了对一些样板代码的需求并手动检查函数的返回值。&lt;/li&gt;
&lt;li&gt;匿名类：非常类似于匿名函数（闭包），匿名类在运行时构建，可以模拟类，符合接口，甚至可以扩展其他类。 这些对于记录类等实用对象很有用，并且在单元测试中很有用。&lt;/li&gt;
&lt;li&gt;各种安全和性能增强。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;PHP 7 真牛逼！&lt;/p&gt;
&lt;blockquote readability=&quot;3&quot;&gt;
&lt;p&gt;更多现代化 PHP 知识，请前往 &lt;a href=&quot;https://laravel-china.org/topics/9737&quot;&gt;Laravel / PHP 知识社区&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 12 Apr 2018 04:15:00 +0000</pubDate>
<dc:creator>Summer2018</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/summerblue/p/8807012.html</dc:identifier>
</item>
<item>
<title>Java基础中一些容易被忽视的语法小细节总结 - Dreamer-1</title>
<link>http://www.cnblogs.com/Dreamer-1/p/8805743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dreamer-1/p/8805743.html</guid>
<description>&lt;p&gt;一：语法细节&lt;/p&gt;
&lt;p&gt;1. Java中的命名规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;package：统一使用小写字母&lt;/li&gt;
&lt;li&gt;class：首字母大写，使用驼峰标识&lt;/li&gt;
&lt;li&gt;method：首字母小写，使用驼峰标识&lt;/li&gt;
&lt;li&gt;field：首字母小写，使用驼峰标识&lt;/li&gt;
&lt;li&gt;static field：统一使用大写字母，并用下划线分割单词&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2. import和import static&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;import com.xxx：常规导入某个包下的类&lt;/li&gt;
&lt;li&gt;import static com.xxx：会导入某个包下的类的所有静态方法，这样之后再使用该类的静态方法时，可以直接使用方法名调用，而不必使用 &lt;strong&gt;类名.方法名&lt;/strong&gt; 来调用静态方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142059906-1412398994.png&quot;&gt;&lt;img title=&quot;clip_image001[5]&quot; src=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142100359-547081780.png&quot; alt=&quot;clip_image001[5]&quot; width=&quot;539&quot; height=&quot;250&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. println和print&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;System.out.println：在下次打印时自动换行&lt;/li&gt;
&lt;li&gt;System.out.print：在下次打印时不自动换行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4. Java访问权限修饰符&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142100843-1472014366.png&quot;&gt;&lt;img title=&quot;clip_image001[7]&quot; src=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142101265-1755999651.png&quot; alt=&quot;clip_image001[7]&quot; width=&quot;501&quot; height=&quot;179&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每个编译单元（即一个&lt;strong&gt;.java&lt;/strong&gt;文件）都只能有一个public类，表示每一个编译单元都有一个单一的公共接口，用public类来展现。&lt;/p&gt;
&lt;p&gt;5. final关键字&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;final 修饰的基本数据类型一旦初始化则数值恒定不变&lt;/li&gt;
&lt;li&gt;final 修饰的对象引用表示：该引用一旦被初始化指向某个对象，就无法再将它改变为指向另一个对象（注意引用指向的对象自身是可以改变的）&lt;/li&gt;
&lt;li&gt;final 修饰的类不允许被任何子类继承&lt;/li&gt;
&lt;li&gt;final 修饰的方法将会被锁定，任何子类都无法修改它&lt;/li&gt;
&lt;li&gt;声明为 final 的域可以在一开始不给定初值，但是编译器会确保该域在使用前必须初始化&lt;/li&gt;
&lt;li&gt;由 static final 修饰的域将会占据一段不能改变的存储空间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;二：基本数据类型&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p align=&quot;center&quot;&gt;基本类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;89&quot;&gt;
&lt;p align=&quot;center&quot;&gt;大小&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;
&lt;p align=&quot;center&quot;&gt;初始值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;117&quot;&gt;
&lt;p align=&quot;center&quot;&gt;包装类&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot;&gt;
&lt;p align=&quot;center&quot;&gt;最小值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;155&quot;&gt;
&lt;p align=&quot;center&quot;&gt;最大值&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p align=&quot;center&quot;&gt;boolean&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;89&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;
&lt;p align=&quot;center&quot;&gt;false&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;117&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Boolean&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;155&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p align=&quot;center&quot;&gt;char&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;89&quot;&gt;
&lt;p align=&quot;center&quot;&gt;16-bit&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;
&lt;p align=&quot;center&quot;&gt;'\u0000'&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;117&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Character&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot;&gt;
&lt;p align=&quot;center&quot;&gt;‘\u0000’&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;（0）&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;155&quot;&gt;
&lt;p align=&quot;center&quot;&gt;‘\uffff’&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;（65535）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p align=&quot;center&quot;&gt;byte&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;89&quot;&gt;
&lt;p align=&quot;center&quot;&gt;8-bit&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;117&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Byte&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot;&gt;
&lt;p align=&quot;center&quot;&gt;-128&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;155&quot;&gt;
&lt;p align=&quot;center&quot;&gt;127&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p align=&quot;center&quot;&gt;short&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;89&quot;&gt;
&lt;p align=&quot;center&quot;&gt;16-bit&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;117&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Short&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot;&gt;
&lt;p align=&quot;center&quot;&gt;- 2^15&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;（负的2的15次方）&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;155&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2^15 - 1&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p align=&quot;center&quot;&gt;int&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;89&quot;&gt;
&lt;p align=&quot;center&quot;&gt;32-bit&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;117&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Integer&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot;&gt;
&lt;p align=&quot;center&quot;&gt;- 2^31&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;155&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2^31 - 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p align=&quot;center&quot;&gt;float&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;89&quot;&gt;
&lt;p align=&quot;center&quot;&gt;32-bit&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0.0f&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;117&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Float&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot;&gt;
&lt;p align=&quot;center&quot;&gt;IEEE754&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;155&quot;&gt;
&lt;p align=&quot;center&quot;&gt;IEEE754&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p align=&quot;center&quot;&gt;double&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;89&quot;&gt;
&lt;p align=&quot;center&quot;&gt;64-bit&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0.0d&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;117&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Double&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot;&gt;
&lt;p align=&quot;center&quot;&gt;IEEE754&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;155&quot;&gt;
&lt;p align=&quot;center&quot;&gt;IEEE754&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p align=&quot;center&quot;&gt;long&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;89&quot;&gt;
&lt;p align=&quot;center&quot;&gt;64-bit&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0L&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;117&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Long&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot;&gt;
&lt;p align=&quot;center&quot;&gt;- 2^63&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;155&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2^63 - 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;1. 创建基本数据类型不需要 new 操作符。&lt;/p&gt;
&lt;p&gt;2. 当基本类型变量作为&lt;strong&gt;类的成员变量&lt;/strong&gt;使用时，才会在初始化时被赋予初值；作为方法体中的&lt;strong&gt;局部变量&lt;/strong&gt;时，则&lt;strong&gt;必须要被初始化&lt;/strong&gt;才能使用。&lt;/p&gt;
&lt;p&gt;3. 对象引用的默认初始值为null。&lt;/p&gt;
&lt;p&gt;4. float / double 转换为整型时，总是对该数字执行&lt;strong&gt;截尾&lt;/strong&gt;操作（四舍五入效果实现需要使用 java.lang.Math.round() 方法）。&lt;/p&gt;
&lt;p&gt;5. 用于高精度计算的类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BigInteger（支持任意大小的整数值）&lt;/li&gt;
&lt;li&gt;BigDecimal（支持任意精度的定点数）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（定点数：指参与运算的数的小数点位置固定不变）&lt;/p&gt;
&lt;p&gt;能作用于 int / float 的操作同样也能作用于 BigInteger / BigDecimal，只是 BigInteger / BigDecimal 需以方法调用的方式使用，而不是以运算符的形式来使用。&lt;/p&gt;
&lt;p&gt;6. 基本类型之间比较是否相同可以直接使用“&lt;strong&gt;==&lt;/strong&gt;”；&lt;/p&gt;
&lt;p&gt;   对象之间比较是否相同需要使用 &lt;strong&gt;equals()&lt;/strong&gt; 方法；对象之间如果使用“==”操作符比较，实际比较的是两个对象的&lt;strong&gt;引用地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;7. 算术运算中，表达式中出现的最大数据类型决定了表达式最终结果的数据类型（比如：一个float值与一个double值相乘，结果值是double类型）；&lt;/p&gt;
&lt;p&gt;   char / byte/ short 中任意一个或一个以上进行算术运算（如 ’a’+’b’ ），都会获得一个 int 型的结果；&lt;/p&gt;
&lt;p&gt;   从较大范围的类型向较小范围的类型转换时，可能引发某些信息的丢失。&lt;/p&gt;


&lt;p&gt;三：Java中对象的四种引用类型&lt;/p&gt;
&lt;p&gt;1. StrongReference -- 强引用&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142101671-1134990094.png&quot;&gt;&lt;img title=&quot;clip_image001&quot; src=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142102046-1387041562.png&quot; alt=&quot;clip_image001&quot; width=&quot;279&quot; height=&quot;38&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;强引用是最普遍的引用，垃圾回收器不会回收强引用的对象；当内存空间不足时，JVM 宁愿抛出 OutOfMemoryError 也不会回收强引用对象以释放部分内存空间；&lt;/p&gt;
&lt;p&gt;强引用对象 o 不使用时可以通过如下方式弱化引用：&lt;a href=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142102515-97322339.png&quot;&gt;&lt;img title=&quot;clip_image002&quot; src=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142102921-566736623.png&quot; alt=&quot;clip_image002&quot; width=&quot;295&quot; height=&quot;41&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（现在的JVM垃圾回收机制其实已经足够智能，不必特意在o无用时将其手动置为null）&lt;/p&gt;

&lt;p&gt;2. SoftReference -- 软引用&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142103281-56737771.png&quot;&gt;&lt;img title=&quot;clip_image001[4]&quot; src=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142103687-2517891.png&quot; alt=&quot;clip_image001[4]&quot; width=&quot;563&quot; height=&quot;56&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果一个对象只具有软引用，则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当内存空间&lt;strong&gt;足够&lt;/strong&gt;时，垃圾回收器&lt;strong&gt;不会&lt;/strong&gt;回收该对象；&lt;/li&gt;
&lt;li&gt;当内存空间&lt;strong&gt;不足&lt;/strong&gt;时，垃圾回收器就&lt;strong&gt;会&lt;/strong&gt;回收该对象；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用场景：软引用可以用来实现内存敏感的高速缓存：&lt;/p&gt;
&lt;p&gt;例如：浏览器中的后退按钮按下时，之前的网页内容是应该重新获取还是从缓存中取出呢？&lt;/p&gt;
&lt;p&gt;如果一个网页在浏览结束时就进行内容的回收，则每次按后退按钮时都要重新构建之前的页面内容；如果将浏览过的网页都存储在内存（缓存）中，会造成大量的资源浪费；这时候就可以考虑使用软引用来指向过去浏览过的网页内容。&lt;/p&gt;

&lt;p&gt;3. WeakReference -- 弱引用&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142104000-1594651154.png&quot;&gt;&lt;img title=&quot;clip_image001[6]&quot; src=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142104328-1135651799.png&quot; alt=&quot;clip_image001[6]&quot; width=&quot;502&quot; height=&quot;21&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;弱引用与软引用区别：只具有弱引用的对象拥有更短的生命周期；当垃圾回收器扫描到只具有弱引用的对象时，无论当前内存空间是否足够，都会回收它；&lt;/p&gt;
&lt;p&gt;使用场景：一个对象只是偶尔使用，希望在使用时能随时获取，但也不想影响对该对象的垃圾收集，则可以考虑使用弱引用来指向该对象。&lt;/p&gt;

&lt;p&gt;4. PhantomReference -- 虚引用&lt;/p&gt;
&lt;p&gt;虚引用不会决定对象的生命周期，如果一个对象仅仅持有虚引用，那它就像没有任何引用一样，随时可能被垃圾收集器回收；&lt;/p&gt;
&lt;p&gt;虚引用必须和引用队列联合使用，主要用来跟踪对象被垃圾收集器回收的活动过程。&lt;/p&gt;

&lt;p&gt;5. 对比&lt;/p&gt;
&lt;p&gt;StrongReference（强引用） &lt;strong&gt;&amp;gt;&lt;/strong&gt; SoftReference（软引用） &lt;strong&gt;&amp;gt;&lt;/strong&gt; WeakReference（弱引用） &lt;strong&gt;&amp;gt;&lt;/strong&gt; PhantomReference（虚引用）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142104843-2033124148.png&quot;&gt;&lt;img title=&quot;clip_image001[8]&quot; src=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142105421-603328433.png&quot; alt=&quot;clip_image001[8]&quot; width=&quot;454&quot; height=&quot;237&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;四：关于方法的一些细节&lt;/p&gt;
&lt;p&gt;1. 重载方法与重写方法&lt;/p&gt;
&lt;p&gt;a）重载方法（Overload）&lt;/p&gt;
&lt;p&gt;     多用于同一个类中；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重载方法的&lt;strong&gt;方法名完全相同&lt;/strong&gt;，&lt;strong&gt;参数列表不同&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值不能参与区分&lt;/strong&gt;重载方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;b）重写方法（Overwrite）&lt;/p&gt;
&lt;p&gt;     多用于继承父类的子类或接口实现类中；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重写方法中，子类的方法名、参数列表、返回值、访问修饰符应该与父类中的完全一致&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2. 在没有为类提供构造器的情况下，编译器会自动为该类添加一个默认构造器；但是一旦为类指定了构造器，则编译器就不会再自动添加默认构造器了。&lt;/p&gt;
&lt;p&gt;3. 方法的&lt;strong&gt;方法名&lt;/strong&gt;和&lt;strong&gt;参数列表&lt;/strong&gt;组合起来作为“&lt;strong&gt;方法的特征签名&lt;/strong&gt;”，唯一的标识出某个方法；&lt;/p&gt;
&lt;p&gt;4. &lt;strong&gt;static&lt;/strong&gt; 的域或方法不跟类的对象绑定，可以通过类名或方法名直接调用（不能在 static 方法中调用非静态方法）；&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;非static&lt;/strong&gt; 的域或方法必须通过类的对象来调用；&lt;/p&gt;
&lt;p&gt;    static 关键字不能用于局部变量。&lt;/p&gt;
&lt;p&gt;5. 在方法体的传入参数中：&lt;strong&gt;基本数据类型在传递时是值传递（传递原值的拷贝值），对象在传递时是引用传递&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;6. 方法体内的局部变量存储在方法栈中，类的成员变量存储在堆中。&lt;/p&gt;
&lt;p&gt;7. 可变参数列表&lt;/p&gt;
&lt;p&gt;语法格式：MethodName(类型… 参数名称)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用示例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142105906-1101535340.png&quot;&gt;&lt;img title=&quot;clip_image001[3]&quot; src=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142106296-939756590.png&quot; alt=&quot;clip_image001[3]&quot; width=&quot;1155&quot; height=&quot;401&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;五：控制语句&lt;/p&gt;
&lt;p&gt;1. break和continue&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;break：用于&lt;strong&gt;强行退出当前循环&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;continue：用于&lt;strong&gt;停止本次迭代，然后返回起始处开始下一次迭代&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2. 带标签的break和continue&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;break outer：中断当前循环并跳出标签所指的循环&lt;/li&gt;
&lt;li&gt;continue outer：重新跳到标签的位置，并开始标签之后声明的循环&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用法示例：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142106953-1872928527.png&quot;&gt;&lt;img title=&quot;clip_image001[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/946400/201711/946400-20171124142107453-1974550370.png&quot; alt=&quot;clip_image001[1]&quot; width=&quot;1095&quot; height=&quot;683&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用带标签的 break / continue 的原因是：为了跳出或重新开始&lt;strong&gt;多层嵌套循环&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;3. switch&lt;/p&gt;
&lt;p&gt;switch 语句可以用于实现多路选择，但是要注意 &lt;strong&gt;break 穿刺问题&lt;/strong&gt;（即如果上一个 case 里没有 break 语句，则该 case 执行完成后会顺势执行下一个 case 语句块）。&lt;/p&gt;
</description>
<pubDate>Thu, 12 Apr 2018 02:23:00 +0000</pubDate>
<dc:creator>Dreamer-1</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dreamer-1/p/8805743.html</dc:identifier>
</item>
<item>
<title>真正理解拉格朗日乘子法和 KKT 条件 - xinchen1111</title>
<link>http://www.cnblogs.com/xinchen1111/p/8804858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinchen1111/p/8804858.html</guid>
<description>&lt;p&gt;    这篇博文中直观上讲解了拉格朗日乘子法和 KKT 条件，对偶问题等内容。&lt;br/&gt;    首先从无约束的优化问题讲起，一般就是要使一个表达式取到最小值：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[min \quad f(x)\]&lt;/span&gt;&lt;br/&gt;    如果问题是 &lt;span class=&quot;math inline&quot;&gt;\(max \quad f(x)\)&lt;/span&gt; 也可以通过取反转化为求最小值 &lt;span class=&quot;math inline&quot;&gt;\(min \quad-f(x)\)&lt;/span&gt;，这个是一个习惯。对于这类问题在高中就学过怎么做。只要对它的每一个变量求导，然后让偏导为零，解方程组就行了。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1189614/201804/1189614-20180409222801202-1630842805.png&quot; width=&quot;35%&quot; alt=&quot;二维线性可分示例图&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;center&gt;极值点示意图&lt;/center&gt;
&lt;br/&gt;    所以在极值点处一定满足 &lt;span class=&quot;math inline&quot;&gt;\(\frac {df(x)}{dx}=0\)&lt;/span&gt;（只是必要条件，比如 &lt;span class=&quot;math inline&quot;&gt;\(f(x)=x^3\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(x=0\)&lt;/span&gt; 处就不是极值点），然后对它进行求解，再代入验证是否真的是极值点就行了。对于有些问题可以直接通过这种方法求出解析解（如最小二乘法）。&lt;br/&gt;    但是也有很多问题解不出来或者很难解，所以就需要梯度下降法、牛顿法、坐标下降法之类的数值迭代算法了（感知机 、logistic 回归中用到）。&lt;br/&gt;    对于这些迭代算法就像下面这张图一样，我们希望找到其中的最小值。一个比较直观的想法是先找一个起点，然后不断向最低点靠近。就先把一个小球放到一个碗里一样。&lt;br/&gt;&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1189614/201804/1189614-20180409222844005-1090929262.bmp&quot; width=&quot;48%&quot; alt=&quot;迭代算法&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;center&gt;迭代算法&lt;/center&gt;
&lt;br/&gt;    一开始要找一个起始点，然后确定走的方向和距离，最后还要知道什么时候停止。这三步中最难的应该是确定走的方向。走的慢点还可以接受，要是方向错了就找不到最小值了~。所以走的距离可以简单的设为一个比较小的值。起始点可以随机选一个 &lt;span class=&quot;math inline&quot;&gt;\((x_0,y_0)\)&lt;/span&gt;。关键是方向，可以选择 &lt;span class=&quot;math inline&quot;&gt;\((x_0,y_0)\)&lt;/span&gt; 处的梯度的反方向，这是函数在这个点下降最快的方向（原因可以看&lt;a href=&quot;https://www.zhihu.com/question/36301367&quot;&gt;知乎&lt;/a&gt;中忆臻的回答）。它是一个向量，然后它的大小就是走的距离，为了防止太大而走过头，导致不断在最小值附近震荡，需要乘上一个比较小的值（称为学习率），最终的停止条件就是梯度的大小很接近于 0（在极值点处的梯度大小就是 0）就行了。这种方法依靠梯度确定下降方向的方法叫做梯度下降法。&lt;br/&gt;对 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 求极小值的流程就是：
&lt;ol&gt;&lt;li&gt;随机选定 &lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;得到函数在 &lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt; 的梯度，然后从 &lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt; 向前走一步。计算式是：&lt;span class=&quot;math inline&quot;&gt;\(x_0^{new}=x_0^{old} - \alpha\nabla f(x)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;重复第 2 步，直到梯度接近于 0（小于一个事先设定的很小的数），或者到达指定的迭代上限。&lt;/li&gt;
&lt;/ol&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1189614/201804/1189614-20180409222921051-1966980537.bmp&quot; width=&quot;25%&quot; alt=&quot;梯度下降法&quot;/&gt;&lt;/div&gt;
&lt;center&gt;梯度下降法&lt;/center&gt;
&lt;p&gt;    除了这种方法之外，其中第 2 步还可以这样做，固定 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;, 把它作为常数。就变成只有一个变量的优化问题了，直接求导为 0 就可以得到最优点，向前走到 &lt;span class=&quot;math inline&quot;&gt;\((x_0, y_1)\)&lt;/span&gt; 处，然后固定 &lt;span class=&quot;math inline&quot;&gt;\(y_1\)&lt;/span&gt;, 对 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 进行相同的操作。这种每次只优化一个变量的方法叫做坐标下降法。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1189614/201804/1189614-20180409222942020-1292610452.bmp&quot; width=&quot;25%&quot; alt=&quot;坐标下降法&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;center&gt;坐标下降法&lt;/center&gt;
&lt;br/&gt;    然后就是进一步的，我们可能要在满足一定约束条件的情况下最小化目标函数，比如有一个等式约束：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*} min \quad f(x)\\ &amp;amp; s.t. \quad h(x) = 0 \end{align*}\]&lt;/span&gt;&lt;br/&gt;    解决这个的时候问题不能先用上面的方法求出 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 的极值点，然后留下满足方程 &lt;span class=&quot;math inline&quot;&gt;\(h(x)=0\)&lt;/span&gt; 的。因为这个问题的解可能根本不是 &lt;span class=&quot;math inline&quot;&gt;\(min \quad f(x)\)&lt;/span&gt; 的解，它们是没有关系的。那么还是要从问题本身去找线索：&lt;br/&gt;&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1189614/201804/1189614-20180409223000822-1093207370.png&quot; width=&quot;35%&quot; alt=&quot;带约束的极值&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;center&gt;带约束的极值&lt;/center&gt;
&lt;br/&gt;    如图，其中的圆圈是指目标函数 &lt;span class=&quot;math inline&quot;&gt;\(f(x，y)\)&lt;/span&gt; 投影在平面上的等值线，表示在同一个圆圈上，黑线是约束条件 &lt;span class=&quot;math inline&quot;&gt;\(h(x)=0\)&lt;/span&gt; 的函数图像。所以等值线与函数图像重合的点其实就是所有满足约束的点。那么极值点只有可能在等值线与函数图像相切的地方取到，因为如果在相交的地方取到，那么沿着 &lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt; 的图像往前走或者往后走，一定还有其它的等值线与它相交，也就是 &lt;span class=&quot;math inline&quot;&gt;\(f(x,y)\)&lt;/span&gt; 的值还能变大和变小，所以交点不是极值点，只有相切的时候才有可能是极值点(不可能同时变大和变小了)。在相切的地方 &lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt; 的梯度和 &lt;span class=&quot;math inline&quot;&gt;\(f(x,y)\)&lt;/span&gt; 的梯度应该是在同一条直线上的。（这一点可以这么想，在切点处两个函数的梯度都与切平面垂直，所以在一条直线上）&lt;br/&gt;    所以满足条件的极值点一定满足：&lt;span class=&quot;math inline&quot;&gt;\(\nabla f(x,y)=\lambda \nabla h(x,y)\)&lt;/span&gt; ( &lt;span class=&quot;math inline&quot;&gt;\(\lambda = 0\)&lt;/span&gt; 是允许的，表示 f(x,y) 的极值点处)，然后和原来的等式方程 &lt;span class=&quot;math inline&quot;&gt;\(h(x,y)=0\)&lt;/span&gt; 联立，然后只要解出这个方程组，就可以得到问题的解析解了。当然也存在解不出来的情况，就需要用罚函数法之类的方法求数值解了。&lt;br/&gt;    为了方便和好记，就把原来的优化问题写成 &lt;span class=&quot;math inline&quot;&gt;\(f(x,y) + \lambda h(x,y)\)&lt;/span&gt; 的形式，然后分别对 &lt;span class=&quot;math inline&quot;&gt;\(\lambda,x,y\)&lt;/span&gt; 求偏导，并且令偏导为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 就行了，和之前得到的方程组是一样的。这种方法叫拉格朗日乘数法。&lt;br/&gt;    如果有多个等式约束怎么办呢，如下图：&lt;br/&gt;&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1189614/201804/1189614-20180409223020563-581635895.png&quot; width=&quot;40%&quot; alt=&quot;多个约束的极值&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;center&gt;多个约束的极值&lt;/center&gt;
&lt;br/&gt;    这里的平面和球面分别代表了两个约束 &lt;span class=&quot;math inline&quot;&gt;\(h_1(x)\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(h_2(x)\)&lt;/span&gt;，那么这个问题的可行域就是它们相交的那个圆。这里蓝色箭头表示平面的梯度，黑色箭头表示球面的梯度，那么相交的圆的梯度就是它们的线性组合（只是直观上的~），所以在极值点的地方目标函数的梯度和约束的梯度的线性组合在一条直线上。所以就满足：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\nabla f(x) = \lambda \sum_{i=1}^{2}\mu_{i}\nabla h_i(x)=\sum_{i=1}^{2}\lambda_{i}\nabla h_i(x)\\ h_1(x)=0\\ h_2(x)=0\]&lt;/span&gt;&lt;br/&gt;    大于2个约束的情况也一样。为了好记，将原来的约束的问题写成 &lt;span class=&quot;math inline&quot;&gt;\(L(x,\lambda)=f(x)+\sum_{i-1}^{n}\lambda_{i}\nabla h_{i}(x)\)&lt;/span&gt;的形式，然后对 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt; 求偏导，然后让它们为 0。结果像上面一样直接列方程组是一样的。这个可以看做是一种简记，或者是对偶问题，这个函数叫做拉格朗日函数。&lt;br/&gt;    再进一步，如果问题中既有等式约束，又有不等式约束怎么办呢？对于：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*} min \quad f(x)\\ &amp;amp; s.t. \quad h(x) = 0\\ &amp;amp;\quad \quad \quad g(x) \leq 0 \end{align*}\]&lt;/span&gt;&lt;br/&gt;    当然也同样约定不等式是 &lt;span class=&quot;math inline&quot;&gt;\(\leq\)&lt;/span&gt;，如果是 &lt;span class=&quot;math inline&quot;&gt;\(\geq\)&lt;/span&gt; 只要取反就行了。对于这个问题先不看等式约束，对于不等式约束和目标函数的图：&lt;br/&gt;&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1189614/201804/1189614-20180409223040318-1100903285.png&quot; width=&quot;35%&quot; alt=&quot;不等式约束&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;center&gt;不等式约束&lt;/center&gt;
&lt;br/&gt;    阴影部分就是可行域，也就是说可行域从原来的一条线变成了一块区域。那么能取到极值点的地方可能有两种情况：
&lt;ol&gt;&lt;li&gt;还是在 &lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt; 和 等值线相切的地方&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 的极值点本身就在可行域里面。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;    因为如果不是相切，那么同样的，对任意一个在可行域中的点，如果在它附近往里走或者往外走，&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 一般都会变大或者变小，所以绝大部分点都不会是极值点。除非这个点刚好在交界处，且和等值线相切；或者这个点在可行域内部，但是本身就是 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 的极值点。如下图（维基百科上的图~）：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1189614/201804/1189614-20180409223309966-1127532199.png&quot; width=&quot;45%&quot; alt=&quot;不等式约束下的极值&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;center&gt;不等式约束下的极值&lt;/center&gt;
&lt;br/&gt;    对于第一种情况，不等式约束就变成等式约束了，对&lt;span class=&quot;math inline&quot;&gt;\(f(x) + \lambda h(x) + \mu g(x)\)&lt;/span&gt; 用拉格朗日乘子法：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\nabla f(x)+\lambda \nabla h(x)+\mu \nabla g(x) = 0\\ h(x)=0\\ g(x)=0\\ \mu \geq 0\]&lt;/span&gt;&lt;br/&gt;    这里需要解释一下，为什么不是 &lt;span class=&quot;math inline&quot;&gt;\(\mu \neq0\)&lt;/span&gt; 而是 &lt;span class=&quot;math inline&quot;&gt;\(\mu \geq 0\)&lt;/span&gt;。后面的约束比前面的更强。看“不等式约束”那个图，我们已经知道了问题中的可行域是在 &lt;span class=&quot;math inline&quot;&gt;\(g(x)\leq0\)&lt;/span&gt; 一侧，而 &lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt; 的梯度是指向大于 0 的一侧，也就是不是可行域的一侧。而求的问题是极小值，所以 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 在交点处的梯度是指向可行域的一侧，也就是说两个梯度一定是相反的。所以也就可以确定这里的系数一定是大于 0 的。而等式约束由于不知道 &lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt; 的梯度方向，只能约束为 &lt;span class=&quot;math inline&quot;&gt;\(\lambda \neq 0\)&lt;/span&gt;，那么为什么 &lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt; 还能等于 0 呢，因为极值点可能刚好在 &lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt; 上。&lt;br/&gt;    对于第二种情况，不等式约束就相当于没有，对 $f(x) + \lambda h(x) $ 用拉格朗日乘子法：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\nabla f(x)+\lambda \nabla h(x)= 0\\ h(x)=0\\ g(x) \leq 0\]&lt;/span&gt;&lt;br/&gt;    最好把两种情况用同一组方程表示出来。对比一下两个问题，不同的是第一种情况中有 &lt;span class=&quot;math inline&quot;&gt;\(\mu \geq 0\)&lt;/span&gt; 且 &lt;span class=&quot;math inline&quot;&gt;\(g(x)=0\)&lt;/span&gt;, 第二种情况 &lt;span class=&quot;math inline&quot;&gt;\(\mu = 0\)&lt;/span&gt; 且 &lt;span class=&quot;math inline&quot;&gt;\(g(x) \leq 0\)&lt;/span&gt; 综合两种情况，可以写成 &lt;span class=&quot;math inline&quot;&gt;\(\mu g(x) = 0\)&lt;/span&gt; 且 &lt;span class=&quot;math inline&quot;&gt;\(\mu \geq 0\)&lt;/span&gt; 且 &lt;span class=&quot;math inline&quot;&gt;\(g(x) \leq 0\)&lt;/span&gt;：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\nabla f(x)+\lambda \nabla h(x)+\mu \nabla g(x) = 0\\ \mu g(x) = 0\\ h(x)=0\\ g(x) \leq 0\]&lt;/span&gt;&lt;br/&gt;    这个就是 KKT 条件。它的含义是这个优化问题的极值点一定满足这组方程组。（不是极值点也可能会满足，但是不会存在某个极值点不满足的情况）它也是原来的优化问题取得极值的必要条件，解出来了极值点之后还是要代入验证的。但是因为约束比较多，情况比较复杂，KKT 条件并不是对于任何情况都是满足的。要满足 KKT 条件需要有一些规范性条件（Regularity conditions），就是要求约束条件的质量不能太差，常见的比如：
&lt;ol&gt;&lt;li&gt;LCQ：如果 &lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt; 都是形如 &lt;span class=&quot;math inline&quot;&gt;\(Ax+b\)&lt;/span&gt; 的仿射函数，那么极值一定满足 KKT 条件。&lt;/li&gt;
&lt;li&gt;LICQ：起作用的 &lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt; 函数（即 &lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt; 相当于等式约束的情况）和 &lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt; 函数在极值点处的梯度要线性无关，那么极值一定满足 KKT 条件。&lt;/li&gt;
&lt;li&gt;Slater 条件：如果优化问题是个凸优化问题，且至少存在一个点满足 &lt;span class=&quot;math inline&quot;&gt;\(h(x) = 0\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(g(x) = 0\)&lt;/span&gt;，极值一定满足 KKT 条件。并且满足强对偶性质（下面会讲）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;     这里的 Slater 条件比较重要，因为它可以推导出强对偶性质（下面会讲到，它比 KKT 条件还好）。它需要原问题是凸优化问题。所谓凸优化就是这个优化问题的优化函数是&lt;a href=&quot;https://baike.baidu.com/item/%E5%87%B8%E5%87%BD%E6%95%B0&quot;&gt;凸函数&lt;/a&gt;，并且可行域是&lt;a href=&quot;https://baike.baidu.com/item/%E5%87%B8%E9%9B%86&quot;&gt;凸集&lt;/a&gt;。可行域数凸集就要求其中的 &lt;span class=&quot;math inline&quot;&gt;\(h(x)\leq0\)&lt;/span&gt; 的条件中 &lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt; 必须也是凸函数，而 &lt;span class=&quot;math inline&quot;&gt;\(g(x) \leq0\)&lt;/span&gt; 中的 &lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt; 必须是 &lt;span class=&quot;math inline&quot;&gt;\(Ax+b\)&lt;/span&gt; 形式的，也就是仿射函数（比如二维的情况，可行域就在 &lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt; 这条曲线上，那么 &lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt; 必须得是直线才能满足凸集的定义）。&lt;br/&gt;     其它条件还有很多，可以看&lt;a href=&quot;https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions&quot;&gt;维基百科&lt;/a&gt;。&lt;br/&gt;    如果有多组等式约束 &lt;span class=&quot;math inline&quot;&gt;\(g_i(x) =0 \quad (i=1,..,n)\)&lt;/span&gt;, 和不等式约束 &lt;span class=&quot;math inline&quot;&gt;\(h_i(x) \neq0 \quad (i=1,..,n)\)&lt;/span&gt;也是一样，只要做个线性组合就行了：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\nabla f(x)+\sum_{i=1}^{n}\lambda_i \nabla h_i(x)+\sum_{i=1}^{n}\mu_i \nabla g_i(x) = 0\\ \mu_i g(x)_i = 0\\ h_i(x)=0\\ g_i(x) \leq 0\\ i = 1,2,...,n\]&lt;/span&gt;&lt;br/&gt;    问题到这里就大致解决了，KKT 条件虽然从理论上给出了极值的必要条件，但是一般实际解的时候直接方程也是很困难的（特别是约束很多的时候），一般也会采用罚函数法等数值方法。&lt;br/&gt;    为了更好的解决这个优化问题，数学家还找到了它的对偶问题。找一个优化问题的对偶问题的一般因为是对偶问题比原问题更好解决，并且对偶问题的解和原问题是一样的。上面的拉格朗日函数也可以看做原问题的对偶问题。&lt;br/&gt;    为了去掉问题中的约束，可以把它们作为惩罚项加到目标函数中 &lt;span class=&quot;math inline&quot;&gt;\(min_{x}f(x) + M h(x) + N g(x)\)&lt;/span&gt; 其中 M, N 是两个很大的正数，在数值解法中可以直接这样做，这个就是罚函数法的思路 。不过在理论推导时这样做是不严谨的，除非 M, N 为无穷大。所以就把原问题改写 &lt;span class=&quot;math inline&quot;&gt;\(L(x,\mu,\lambda) = min_{x}max_{\mu,\lambda}f(x) + \lambda h(x) + \mu g(x)\)&lt;/span&gt; 。这个式子可以这么理解，现在外层给定任意一个 &lt;span class=&quot;math inline&quot;&gt;\(x_{0}\)&lt;/span&gt; 值，然后内层在给定的 &lt;span class=&quot;math inline&quot;&gt;\(x_{0}\)&lt;/span&gt; 下优化那个函数，让它最小。然后外层选能够让内层得到的值最大的一个 &lt;span class=&quot;math inline&quot;&gt;\(x_{0}\)&lt;/span&gt;，得到的函数表达式就是：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(x,\mu,\lambda)= \left\{\begin{matrix} f(x) &amp;amp; (x \quad满足约束)\\ \infty &amp;amp; (x \quad不满足约束)\\ \end{matrix}\right. \]&lt;/span&gt;&lt;br/&gt;所以外层选的那个 &lt;span class=&quot;math inline&quot;&gt;\(x_{0}\)&lt;/span&gt; 一定满足约束，否则，内层的 max 的时候会让 $\mu $ 或者 &lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt; 为无穷大。外层不会选那些能让内层得到无穷大的 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 值。这样改写就和原来的带约束形式完全一致了，但是形式不同。这样可以利用 &lt;span class=&quot;math inline&quot;&gt;\(max \quad min f(x) \leq min \quad max(f(x))\)&lt;/span&gt; 这个公式（这个很好理解，&lt;span class=&quot;math inline&quot;&gt;\(min f(x) \leq min\quad max f(x)\)&lt;/span&gt;, 然后就有这个公式了），得到原问题的最小值的一个下界，就是:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[min_{x}max_{\mu,\lambda}f(x) + \lambda h(x) + \mu g(x) &amp;gt;= max_{\mu,\lambda}min_{x}f(x) + \lambda h(x) + \mu g(x) \]&lt;/span&gt;&lt;br/&gt;    前面的就是原函数，后面的是它的一个下界。那么为什么要这样做呢? 是因为后面的一定是一个凸规划，比较好解决。但是这个只是一个下界，它们之间还是有一定的差距。这个差距叫对偶误差（duality gap）。对偶误差如果为 0 其实是一个非常好的性质，表示可以直接求解后面的问题得到原问题的解，这种性质叫强对偶性质，否则就只是弱对偶。&lt;br/&gt;    强对偶性质非常好，但是要求也很苛刻，比 KKT 条件要苛刻。如果问题满足强对偶一定也满足 KKT 条件，反之不一定。对于这类优化问题，KKT 条件、强对偶、规范性条件之间的关系是：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1189614/201804/1189614-20180409223329500-1534246794.png&quot; width=&quot;55%&quot; alt=&quot;RC、KKT 和强对偶的关系&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;center&gt;RC、KKT 和强对偶的关系&lt;/center&gt;
&lt;br/&gt;    对于强对偶 推出 KKT 可以参看&lt;a href=&quot;http://blog.pluskid.org/?p=702&quot;&gt;这篇博客&lt;/a&gt;。
&lt;p&gt;    这篇博文到这里就结束了，这些优化方法都是很经典的方法，在 SVM 的推导中也用到了。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;对机器学习感兴趣的新手或者大牛，如果有觉得对别人有帮助的，高质量的网页，大家可以通过 chrome 插件分享给其他人。在&lt;a href=&quot;http://xingkoong.com/collect/home.php/Home/download/download&quot;&gt;这里安装分享插件&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangchaoyang/articles/2726873.html&quot;&gt;拉格朗日乘数法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions&quot;&gt;Karush–Kuhn–Tucker conditions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.pluskid.org/?p=702&quot;&gt;支持向量机：Duality&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;如需转载，请注明出处.&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/xinchen1111/p/8804858.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xinchen1111/p/8804858.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Apr 2018 01:02:00 +0000</pubDate>
<dc:creator>xinchen1111</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinchen1111/p/8804858.html</dc:identifier>
</item>
</channel>
</rss>