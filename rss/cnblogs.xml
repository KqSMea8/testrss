<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>多个线程实现顺序打印数据，（可自定义线程一次打印数量和总数量） - 宇的季节</title>
<link>http://www.cnblogs.com/chenkeyu/p/7944879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenkeyu/p/7944879.html</guid>
<description>&lt;p&gt;　　最近看到一道面试题：让3个线程顺序打印数字，如线程1打印1-5，线程2打印6-10，线程3打印11-15,然后是线程1打印16-20...一直打印到75结束。&lt;/p&gt;
&lt;p&gt;　　这到题主要问题有两点：&lt;/p&gt;
&lt;p&gt;　　　　第一点是不能让线程打印的过程中出现其他线程&lt;/p&gt;
&lt;p&gt;　　　　第二点是要实现线程进入的过程是有序的，如上123123..这样。&lt;/p&gt;
&lt;p&gt;　　我先是把基本的功能实现了，后来发现可以改造一下，做成可扩展的，即每次打印的数量可自定义，总的数量可自定义，并且保证线程的顺序是有序的，下面是具体代码：&lt;/p&gt;
&lt;p&gt;　　PrintQueue.java 文件，同步线程，控制打印顺序，也是最主要的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cky;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedHashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PrintQueue {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; targetNum=0;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要打印的目标数量&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; printOnce=0;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一次要打印的次数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nowNum=1;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;目前打印到的数量&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; targetNum    要打印的目标数量
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; printOnce 一次要打印的次数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; PrintQueue(&lt;span&gt;int&lt;/span&gt; targetNum, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; printOnce) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.targetNum =&lt;span&gt; targetNum;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.printOnce =&lt;span&gt; printOnce;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nextThreadNum=0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下次要执行线程的下标&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threadCount=0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总的线程数量
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;map集合，存放线程，键是具体线程，值存放线程打印的顺序&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;Thread,Integer&amp;gt; threads=&lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;Thread,Integer&amp;gt;&lt;span&gt;();
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加线程&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setThread(Thread thread) {
        threads.put(thread, threadCount);
        threadCount&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行线程&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Thread thread : threads.keySet()) {
            thread.start();
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printNum() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前线程&lt;/span&gt;
        Thread currentThread=&lt;span&gt;Thread.currentThread();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前线程坐标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; currentNum=&lt;span&gt;threads.get(currentThread);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否为期望线程&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(currentNum==&lt;span&gt;nextThreadNum) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;printOnce;i++&lt;span&gt;) {
                System.out.println(&lt;/span&gt;&quot;当前线程：&quot;+currentThread.getName()+&quot;:&quot;+nowNum++&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(nowNum&amp;gt;&lt;span&gt;targetNum) {
                    System.out.println(&lt;/span&gt;&quot;工作完成&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.wait();
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;期望线程名+1&lt;/span&gt;
            nextThreadNum=(++nextThreadNum)%&lt;span&gt;threadCount;
        }
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　RunTest.java  很简单的Runable接口实现，功能就是请求打印&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cky;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; RunTest &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    PrintQueue ps;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RunTest(PrintQueue ps ) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ps=&lt;span&gt;ps;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                ps.printNum();
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ThreadDemo.java 测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cky;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String [] args) {
        //设置一共打印20个，每个线程一次只打印3个&lt;br/&gt;　　　　　PrintQueue ps&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; PrintQueue(20, 3&lt;span&gt;);&lt;br/&gt;　　　　　//添加线程
        ps.setThread(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; RunTest(ps),&quot;王大锤&quot;&lt;span&gt;));
        ps.setThread(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; RunTest(ps),&quot;张全蛋&quot;&lt;span&gt;));
        ps.setThread(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; RunTest(ps),&quot;二狗&quot;&lt;span&gt;));
        ps.run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1003414/201712/1003414-20171201233250995-794947247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 01 Dec 2017 15:33:00 +0000</pubDate>
<dc:creator>宇的季节</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenkeyu/p/7944879.html</dc:identifier>
</item>
<item>
<title>【读书笔记】《Maven实战》 第7章 生命周期与插件 - Ye_yang</title>
<link>http://www.cnblogs.com/yeyang/p/7944875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yeyang/p/7944875.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;meta name=&quot;referrer&quot; content=&quot;same-origin&quot;/&gt;&lt;title&gt;【读书笔记】《Maven实战》 第7章 生命周期与插件 - Ye_yang - 博客园&lt;/title&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=ChDk9h03-S75WEqNhGvXkWireJ5cCWdK1xRM9NIXfnM1&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/LessIsMore/bundle-LessIsMore.css?v=K-SPbyFTmacJSNw1O1LzZFcIaS56dT8uEKlXYOxLR9k1&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/LessIsMore/bundle-LessIsMore-mobile.css?v=d9LctKHRIQp9rreugMcQ1-UJuq_j1fo0GZXTXj8Bqrk1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;http://www.cnblogs.com/yeyang/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;http://www.cnblogs.com/yeyang/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;http://www.cnblogs.com/yeyang/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot;&gt;

&lt;div id=&quot;home&quot;&gt;

&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7.1什么是生命周期&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;软件开发人员每天都在对项目进行清理、编译、测试及部署，Maven生命周期是对所有构建过程进行抽象和统一，含项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7.2生命周期详解&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7.2.1三套相互独立的生命周期&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;clean：目的是清理项目&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;default：目的是构建项目&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;site：目的是建立项目站点&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;两个原则&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;a）三套生命周期相互独立，不会相互影响&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;b）每个生命周期包含一些阶段(phase)，阶段间有顺序且后面的阶段依赖于前面的阶段&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7.2.2clean生命周期&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;1）pre-clean 执行一些清理前需要完成的工作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;2）clean 清理上一次构建生成的文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;3）post-clean 执行一些清理后需要完成的工作&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7.2.3 default生命周期&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;定义了真正构建是所需执行的所有步骤，是所有生命周期中最核心的部分&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;Maven官网参考：&lt;a class=&quot;content-link&quot; href=&quot;http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html&quot;&gt;http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;1）validate&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;2）initialize&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;3）generate-sources&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;4）process-sources：处理项目的主资源文件。一般来说，是对src/main/resouces目录的内容进行变量替换等工作后，负责到项目输出的主classpath目录中。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;5）generate-resources&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;6）process-resources&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7）compile：编译项目的主代码。一般来说，是编译src/main/java下的java文件至项目输出的主classpath目录中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;8）process-classes&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;9）generate-test-sources&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;10）process-test-sources：处理项目测试资源文件。一般来说，是对src/test/resources目录的内容进行变量替换等工作，复制到项目输出的测试classpath目录中。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;11）generate-test-resources&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;12）process-test-resources&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;13）test-compile：编译项目的测试代码。一般来说，是编译src/test/java下的java文件到项目输出的测试classpath目录中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;14）process-test-compile&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;15）test：使用单元测试框架运行测试，测试代码不会被打包或部署&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;16）prepare-package&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;17）package：接受编译好的代码，打包成可发布的格式，如jar&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;18）pre-integration-test&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;19）integration-test&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;20）post-integration-test&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;21）verify&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;22）install：将包安装到Maven本地仓库&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;23）deploy：将包复制到远程仓库&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7.2.4site生命周期&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;1）pre-site：执行一些生成项目站点之前需要完成的工作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;2）site：生成项目站点文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;3）post-site：执行一些在生成项目站点之后需要完成的工作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;4）site-deploy：将生成的项目站点发布到服务器上&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7.2.5 命令行与生命周期&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;命令行中的命令根据7.2.1中的【两个原则】，可知具体执行了哪些阶段&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;示例1：mvn clean：执行了7.2.2clean生命周期1）2）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;示例2：mvn test：执行了7.2.3default生命周期1）至15）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;示例3：mvn clean install：执行了7.2.2clean生命周期1）2），执行了7.2.3default生命周期1）至22）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;示例4：mvn clean deploy site-deploy：执行了7.2.2clean生命周期1）2），执行了7.2.3default生命周期1）至23）全部阶段，执行了7.2.4site生命周期1）至4）全部阶段&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7.3插件目标&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;一个Maven插件能够完成多个任务，每个任务就是一个插件目标&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;示例：maven-dependency-plugin插件，有analyze、tree、list等十几个目标。(使用【插件前缀：插件目标】的格式，dependency:analyze、dependency:tree、dependency:list)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7.4插件绑定&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;【生命周期】的【阶段】与【插件】的【目标】绑定，完成构建任务。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;注意：&lt;span&gt;【插件】的【目标】与&lt;span&gt;【生命周期】的【阶段】的绑定是在配置pom.xml时完成的，而不是插件在编写时已经设置好的！。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7.4.1内置绑定&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;clean生命周期阶段与插件目标的绑定关系&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;【clean】生命周期的【clean】阶段与【maven-clean-plugin】插件的【clean】目标绑定&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt; &lt;/span&gt;&lt;/span&gt;
&lt;div&gt;&lt;img class=&quot;confluence-embedded-image attach-img confluence-external-resource&quot; src=&quot;https://img.mubu.com/document_image/d944821e-867a-4061-a2b5-dec199162988-375749.jpg&quot; alt=&quot;&quot; data-image-src=&quot;https://img.mubu.com/document_image/d944821e-867a-4061-a2b5-dec199162988-375749.jpg&quot;/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;site生命周期阶段与插件目标的绑定关系&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;【site】生命周期的【site】阶段与【mvn-site-plugin】插件的【site】目标绑定&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;【site】生命周期的【site-deploy】阶段与【mvn-site-plugin】插件的【deploy】目标绑定&lt;/span&gt;&lt;/span&gt;
&lt;div&gt;&lt;img class=&quot;confluence-embedded-image attach-img confluence-external-resource&quot; src=&quot;https://img.mubu.com/document_image/603db251-f795-40b1-8991-c0529223a132-375749.jpg&quot; alt=&quot;&quot; data-image-src=&quot;https://img.mubu.com/document_image/603db251-f795-40b1-8991-c0529223a132-375749.jpg&quot;/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;default生命周期阶段与插件目标的绑定关系&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;项目的打包类型（如jar、war）会影响构建的具体过程&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;7.4.2自定义绑定&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;示例：使用maven-source-plugin插件创建项目的源码jar包&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt; &lt;/span&gt;&lt;/span&gt;
&lt;div&gt;&lt;img class=&quot;confluence-embedded-image attach-img confluence-external-resource&quot; src=&quot;https://img.mubu.com/document_image/1efb2498-e7a5-4197-a4ee-d5021102473d-375749.jpg&quot; alt=&quot;&quot; data-image-src=&quot;https://img.mubu.com/document_image/1efb2498-e7a5-4197-a4ee-d5021102473d-375749.jpg&quot;/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;配置了id为attach-sources的任务，设置phase为verify将其绑定到(【default】生命周期)【verify】阶段，设置goal为jar-no-fork指定了执行【maven-source-plugin】插件的【jar-no-fork】目标。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;查看插件帮助信息：mvn help:describe -Dplugin=org.apache.maven.plugins:maven-source-plugin:2.1.1 -Ddetail&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;&lt;span class=&quot;content mubu-node&quot;&gt;绑定原则：&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;children&quot;&gt;&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;1）当插件目标被绑定到不同的生命周期阶段，执行顺序由生命周期阶段的先后顺序决定。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;content mubu-node&quot;&gt;2）如果多个目标被绑定到同一个阶段，插件生命的先后顺序决定了目标的执行顺序。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2017-12-01 23:32&lt;/span&gt; &lt;a href=&quot;http://www.cnblogs.com/yeyang/&quot;&gt;Ye_yang&lt;/a&gt; 阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;) 评论() &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=7944875&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/yeyang/p/7944875.html#&quot; onclick=&quot;AddToWz(7944875);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;


&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Fri, 01 Dec 2017 15:32:00 +0000</pubDate>
<dc:creator>Ye_yang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yeyang/p/7944875.html</dc:identifier>
</item>
<item>
<title>EntityFramework For Mysql 动态切换数据源 - nele</title>
<link>http://www.cnblogs.com/nele/p/7944838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nele/p/7944838.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;1.简介&lt;/h2&gt;
&lt;p&gt;在工作中遇到一个问题。项目有三个数据库（三个数据库表结构一样），用户可以选择使用哪个数据库。其实就是动态切换数据库连接。&lt;/p&gt;
&lt;h2 id=&quot;entityframework-for-mysql&quot;&gt;2.EntityFramework For Mysql&lt;/h2&gt;
&lt;p&gt;先来简单的介绍下mysql使用EntityFramework来操作数据库。&lt;br/&gt;直接上代码：&lt;/p&gt;
&lt;h4 id=&quot;先建个项目安装mysqlentityframework相关包&quot;&gt;(1).先建个项目，安装mysql，entityframework相关包&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-f55d52a1d0a9265a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;nuget安装&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;建立实体和对应的数据库表&quot;&gt;(2).建立实体和对应的数据库表&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-d48cbd94a7ebd4f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;人员实体&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-e9fba8386f87a49a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;文章实体&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-3562ee47eeef43b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;建表语句&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;编写数据库连接字符串编写context实体&quot;&gt;(3).编写数据库连接字符串，编写context实体&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-1c9a369c416ec422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;数据库连接字符串&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-5cea09dc4d394e20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;context实体类&quot;/&gt;&lt;br/&gt;这样就可以来使用Entityframework来访问mysql数据了。&lt;/p&gt;
&lt;h4 id=&quot;简单测试&quot;&gt;(4).简单测试&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-f807a3fa33cb8013.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;测试代码&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-cc0dc3eac8202882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;person测试结果&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-a6b5d124f73d4af9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;article测试结果&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;动态切换数据库&quot;&gt;3.动态切换数据库&lt;/h2&gt;
&lt;h4 id=&quot;在建一个blog1数据库表如blog数据库&quot;&gt;(1).在建一个blog1数据库，表如blog数据库。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-4f4fbfed5f748183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;两个数据库&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;对context进行改造&quot;&gt;(2).对context进行改造&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-e4e07ec1396a22af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;context改造后&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;改造测试&quot;&gt;(3).改造测试&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-f6a1ac115c28d082.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;测试blog1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-9b6f651bd0e6ef8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;blog1表&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-fda0c74c7d3be712.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;blog&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-5b524330654d8e3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;blog表&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么可以直接传链接字符串&quot;&gt;4.为什么可以直接传链接字符串&lt;/h2&gt;
&lt;p&gt;从DbContext构造函数的方法签名可以看出端倪。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-ee8cf00a9bdb8e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;DbContext构造函数&quot;/&gt;&lt;br/&gt;可以看出我们传数据库连接字符串名字和直接传数据库连接字符串都是可以的。EntityFramework会去做判断，如果是name，再去配置文件取数据库连接字符串和providerName。如果是数据库连接字符串则直接拿来用。&lt;/p&gt;
&lt;h2 id=&quot;遇到的坑&quot;&gt;5.遇到的坑&lt;/h2&gt;
&lt;p&gt;其实EntityFramework对mysql的支持并不是很好，还有些bug。我在进行以上实验的时候遇到了一个问题。当我直接将数据库连接字符串的传到父类的构造函数时，报了： Keyword not supported:'port'错误。经过一番查找，最终找到三个方案：&lt;a href=&quot;https://stackoverflow.com/questions/45217166/c-sharp-entity-framework-keyword-not-supported-port&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/45217166/c-sharp-entity-framework-keyword-not-supported-port&lt;/a&gt;。&lt;br/&gt;遇到坑的童鞋们可以去看下。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 15:18:00 +0000</pubDate>
<dc:creator>nele</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nele/p/7944838.html</dc:identifier>
</item>
<item>
<title>php数据类型 - 韦大大</title>
<link>http://www.cnblogs.com/average/p/7944707.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/average/p/7944707.html</guid>
<description>&lt;p&gt;记得上篇中最后用&lt;strong&gt;var_dump&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 函数打印出来的数据前面显示的是数据类型，这篇就对php的数据类型做个简单说明。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;PHP的数据类型有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;color_h1&quot;&gt;String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;color_h1&quot;&gt;好，下面我们来一一具体介绍：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;PHP 字符串&lt;/h3&gt;
&lt;p&gt;一个字符串是一串字符的序列，就像 &quot;Hello world!&quot;。&lt;/p&gt;
&lt;p&gt;你可以将任何文本放在单引号和双引号中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$x = &quot;Hello world!&quot;; 
echo $x; echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = 'Hello world!'; 
echo $x; 
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
Hello world!
Hello world!
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;PHP 整型&lt;/h3&gt;
&lt;p&gt;整数是一个没有小数的数字。&lt;/p&gt;
&lt;p&gt;整数规则:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整数必须至少有一个数字 (0-9)&lt;/li&gt;
&lt;li&gt;整数不能包含逗号或空格&lt;/li&gt;
&lt;li&gt;整数是没有小数点的&lt;/li&gt;
&lt;li&gt;整数可以是正数或负数&lt;/li&gt;
&lt;li&gt;整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在以下实例中我们将测试不同的数字。 PHP var_dump() 函数返回变量的数据类型和值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$x = 5985; 
var_dump($x); 
echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = -345; // 负数 
var_dump($x); 
echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = 0x8C; // 十六进制数 
var_dump($x); 
echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = 047; // 八进制数 
var_dump($x); 
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
int(5985) 
int(-345) 
int(140) 
int(39)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;PHP 浮点型&lt;/h3&gt;
&lt;p&gt;浮点数是带小数部分的数字，或是指数形式。&lt;/p&gt;
&lt;p&gt;在以下实例中我们将测试不同的数字。 PHP var_dump() 函数返回变量的数据类型和值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$x = 10.365; 
var_dump($x); 
echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = 2.4e3; 
var_dump($x); 
echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = 8E-5; 
var_dump($x); 
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
float(10.365) 
float(2400) 
float(8.0E-5)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;PHP 布尔型&lt;/h3&gt;
&lt;p&gt;布尔型可以是 TRUE 或 FALSE。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$x=true;
    

        
$y=false;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;布尔型通常用于条件判断。&lt;/p&gt;
&lt;h3&gt;PHP 数组&lt;/h3&gt;
&lt;p&gt;数组可以在一个变量中存储多个值。&lt;/p&gt;
&lt;p&gt;在以下实例中创建了一个数组， 然后使用 PHP var_dump() 函数返回数组的数据类型和值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); 
var_dump($cars); 
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
array(3) { [0]=&amp;gt; string(5) &quot;Volvo&quot; [1]=&amp;gt; string(3) &quot;BMW&quot; [2]=&amp;gt; string(6) &quot;Toyota&quot; }  
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;PHP 对象&lt;/h3&gt;
&lt;p&gt;对象数据类型也可以用于存储数据。&lt;/p&gt;
&lt;p&gt;在 PHP 中，对象必须声明。&lt;/p&gt;
&lt;p&gt;首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。// 关于类更详细的解释请看：http://www.php.cn/php-weizijiaocheng-360220.html&lt;/p&gt;
&lt;p&gt;然后我们在类中定义数据类型，然后在实例化的类中使用数据类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php
class Point2D {
    var $x, $y;
    var $label;

    function Point2D($x, $y)//跟类名相同的情况下，在类被实例化以后
    {
        $this-&amp;gt;x = $x;
        $this-&amp;gt;y = $y;
    }

    function setLabel($label)
    {
        $this-&amp;gt;label = $label;
    }

    function getPoint()
    {
        return array(&quot;x&quot; =&amp;gt; $this-&amp;gt;x,
                     &quot;y&quot; =&amp;gt; $this-&amp;gt;y,
                     &quot;label&quot; =&amp;gt; $this-&amp;gt;label);
    }
}

// &quot;$label&quot; 已声明，但未定义
$p1 = new Point2D(1.233, 3.445);//声明类对象
print_r(get_object_vars($p1));

$p1-&amp;gt;setLabel(&quot;point #1&quot;);
print_r(get_object_vars($p1));

?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上实例中PHP关键字this就是指向当前对象实例的指针，不指向任何其他对象或类。　　&lt;/p&gt;
&lt;p&gt;这里用到了函数get_object_vars() —&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;dc-title&quot;&gt;返回由对象属性组成的关联数组。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
Array
 (
     [x] =&amp;gt; 1.233
     [y] =&amp;gt; 3.445
     [label] =&amp;gt;
 )

 Array
 (
     [x] =&amp;gt; 1.233
     [y] =&amp;gt; 3.445
     [label] =&amp;gt; point #1
 )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　由于类和对象这块知识点比较绕，我计划下篇专门剖析一下&lt;/p&gt;
&lt;h3&gt;PHP NULL 值&lt;/h3&gt;
&lt;p&gt;NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。&lt;/p&gt;
&lt;p&gt;NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。&lt;/p&gt;
&lt;p&gt;可以通过设置变量值为 NULL 来清空变量数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$x=&quot;Hello world!&quot;; 
$x=null; 
var_dump($x); 
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;


&lt;p&gt;PHP的数据类型就到这里了，由于今天知识点较多，所以用的时间有点多，搞的好累，嘿嘿，，，你也休息下吧。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 14:34:00 +0000</pubDate>
<dc:creator>韦大大</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/average/p/7944707.html</dc:identifier>
</item>
<item>
<title>《Linux命令行与shell脚本编程大全》第十七章 创建函数 - xcywt</title>
<link>http://www.cnblogs.com/xcywt/p/7944596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcywt/p/7944596.html</guid>
<description>&lt;p&gt;可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用它了。&lt;/p&gt;
&lt;h2&gt;17.1 基本的脚本函数&lt;/h2&gt;
&lt;p&gt;函数：是一个脚本代码块，可以为其命名并在代码中任何位置重用。&lt;/p&gt;
&lt;h3&gt;17.1.1 创建函数&lt;/h3&gt;
&lt;p&gt;有两种格式：name 是函数名&lt;/p&gt;
&lt;p&gt;1）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;function name&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;{&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;         commands&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;}&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）这种就比较接近c语言风格了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;name()&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;{&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;         commands&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;}&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;17.1.2 使用函数&lt;/h3&gt;
&lt;p&gt;跟其他shell命令一样，在行中指定函数名就好了。&lt;/p&gt;
&lt;p&gt;在函数定义前使用函数，会收到一条错误消息。&lt;/p&gt;
&lt;p&gt;函数名是唯一的，如果重定义了函数，新的会覆盖旧的，并且不会产生任何错误消息。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;em&gt;  1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  3 function fun&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  4 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  5         echo &quot;hahahaha, i am a function&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  6 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  7&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  8 count=1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  9 while [ $count -lt 5 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 10 do&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 11         fun&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 12         count=$[ $count + 1 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 13 done&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 14&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 15 fun2  # Error fun2 not define&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 16 fun2() #&lt;/em&gt; &lt;em&gt;声明函数的另外一种方式&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 17 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 18         echo &quot;I am Fun2, hahaha&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 19 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 20 fun2&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;17.2 返回值&lt;/h2&gt;
&lt;p&gt;函数运行结束会返回一个退出状态码，有3种方法为函数生成退出状态码。&lt;/p&gt;
&lt;h3&gt;17.2.1 默认退出状态码&lt;/h3&gt;
&lt;p&gt;在函数结束时用 $? 来确定函数的退出状态码。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;…&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;fun&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;echo “return code:$?”&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;…&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果函数最后执行的语句失败了，这里就会返回非0，最后成功了（不管前面有没有失败）返回都是0.&lt;/p&gt;

&lt;h3&gt;17.2.2 使用return命令&lt;/h3&gt;
&lt;p&gt;bashshell使用return命令来退出函数并返回特定的退出状态码。return允许指定一个整数值来定义函数的退出状态码。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;函数一结束就要立即取返回值&lt;/p&gt;
&lt;p&gt;退出状态码必须是0 – 255.（大于255会产生一个错误值）&lt;/p&gt;

&lt;h3&gt;17.2.3 使用函数输出&lt;/h3&gt;
&lt;p&gt;可以将函数输出（&lt;span&gt;任何类型的函数输出&lt;/span&gt;）保存到shell变量中。&lt;/p&gt;
&lt;p&gt;语法：&lt;span&gt;&lt;em&gt;result=$(fun)&lt;/em&gt; &lt;/span&gt; 这个命令会将fun函数的输出赋给$result变量&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;em&gt;  1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  3 function fun&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  4 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  5         echo &quot;hahahaha, i am a function&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  6         return 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  7 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  8&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  9 fun&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 10 echo &quot;fun return $?&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 11&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 12 function fun2&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 13 {&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 14         echo &quot;This is Function fun2&quot;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 15         read -p &quot;Enter a value:&quot; num&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 16         echo $[ $num * 2 ]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 17 }&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 18&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 19 #fun2 #&lt;/em&gt; &lt;em&gt;如果加上这句就会调两次了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 20 &lt;span&gt;&lt;strong&gt;result=$(fun2)&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 21 &lt;span&gt;echo &quot;fun2 return:$&lt;strong&gt;result&lt;/strong&gt;&quot;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 这样就可以返回浮点数和字符串了。&lt;/p&gt;

&lt;h2&gt;17.3 在函数中使用变量&lt;/h2&gt;
&lt;p&gt;介绍一些处理shell脚本函数内外变量的方法&lt;/p&gt;

&lt;h3&gt;17.3.1 向函数传递参数&lt;/h3&gt;
&lt;p&gt;就跟向脚本传递参数一样，可以用$# $0 $1 $2&lt;/p&gt;
&lt;p&gt;注意脚本主体的$1 $2 和传到函数里面的并不相同。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;32&quot;&gt;
&lt;p&gt;&lt;em&gt;  1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  2 function add&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  3 {&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  4         if [ $# -eq 0 ] || [ $# -gt 2 ]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  5         then&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  6                 echo -1&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  7         elif [ $# -eq 1 ]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  8         then&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  9                 echo $[ $1 + $1 ]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 10         else&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 11                 echo $[ $1 + $2 ]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 12         fi&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 13 }&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 14&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 15 #ret=$(add)&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 16 #ret=$(add 34) #&lt;/em&gt; &lt;em&gt;这里说明的如何传入参数&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 17 ret=$(add 23 18)&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 18 if [ $ret -eq -1 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 19 then&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 20         echo &quot;Function add Error&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 21 else&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 22         echo &quot;The value = $ret&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 23 fi&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 24&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 25 if [ $# -eq 2 ] #&lt;/em&gt; &lt;em&gt;这个的脚本主体接收的参数个数&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 26 then&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 27         &lt;strong&gt;&lt;span&gt;echo &quot;The value is $(add $1 $2)&quot; #&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt; &lt;strong&gt;&lt;span&gt;将脚本主体的参数传给里面的函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 28 else&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 29         echo &quot;Input Error&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 30 fi&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;17.3.2 在函数中处理变量&lt;/h3&gt;
&lt;p&gt;变量的作用域比较麻烦。作用域是变量可见的区域。&lt;/p&gt;
&lt;p&gt;函数中定义的变量和普通变量的作用域不同，也就是说对脚本的其他部分来说它们是隐藏的&lt;/p&gt;
&lt;p&gt;函数使用两种类型的变量：&lt;strong&gt;&lt;span&gt;全局变量和局部变量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.全局变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;是指在shell脚本中任何地方都有效的变量。&lt;/p&gt;
&lt;p&gt;在脚本主体部分定义了全局变量，那么在函数内可以读取它的值。&lt;/p&gt;
&lt;p&gt;在函数内定义了全局变量，在脚本的主体部分也可以读取它的值。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，在脚本中定义的任何变量都是全局变量&lt;/span&gt;。函数外定义的变量可在函数内访问&lt;/p&gt;
&lt;p&gt;这样要特别注意变量的使用。很容易就改变了变量。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.局部变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以在函数内部使用的任何变量都声明成局部变量。&lt;/p&gt;
&lt;p&gt;在变量声明前加上local关键字就好了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;local temp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;em&gt;  1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2 function fun&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  3 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  4         &lt;strong&gt;#temp=$[ $value + 5 ] #&lt;/strong&gt;&lt;/em&gt; &lt;strong&gt;&lt;em&gt;如果这个是全局变量下面的结果就会异常&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;  5         local temp=$[ $value + 5 ]&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  6         ret=$[ $temp * 2 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  7 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  8&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  9 temp=4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 10 value=6&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 11 &lt;strong&gt;fun&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 12 echo &quot;fun: ret = $ret&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 13 if [ $temp -gt $value ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 14 then&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 15         echo &quot;temp is big&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 16 else&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 17         echo &quot;value is big&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 18 fi&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h2&gt;17.4 数组变量和函数&lt;/h2&gt;
&lt;p&gt;第6章讨论了数组来在单个变量中保存多个值的高级用法&lt;/p&gt;

&lt;h3&gt;17.4.1 向函数传数组参数&lt;/h3&gt;
&lt;p&gt;复习一下数组的用法：&lt;/p&gt;
&lt;p&gt;定义方法1：初始化数组 array=(a b c)&lt;/p&gt;
&lt;p&gt;定义方法2：新建数组并添加原色  array[数组]=元素&lt;/p&gt;
&lt;p&gt;定义方法3：将命令输出作为数组元素 array=($(command))&lt;/p&gt;
&lt;p&gt;数组操作：&lt;/p&gt;
&lt;p&gt;1）获取所有元素：echo ${array[*]}&lt;/p&gt;
&lt;p&gt;2）获取第n个元素： echo ${array[n]}    n为数组下标&lt;/p&gt;
&lt;p&gt;3）添加元素：array[3]=d&lt;/p&gt;
&lt;p&gt;4）删除元素：unset array[n] n为数组下标&lt;/p&gt;


&lt;p&gt;1. 数组作为参数传递时不能用 $arrayName。&lt;/p&gt;
&lt;p&gt;应该这样： fun ${arrName[*]}&lt;/p&gt;
&lt;p&gt;还可以加上双引号。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;&lt;em&gt;  1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2 function testit&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  3 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  4         echo &quot;The param are:$@, Param count:$#&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  5         thisarray=$1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  6         echo &quot;The received array is:${thisarray[*]}&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  7&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  8         for param in &quot;$@&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  9         do&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 10                 echo &quot;Param = $param&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 11         done&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 12 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 13&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 14 myarray=(13 25 35 45 55 65)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 15 echo &quot;The original array is: ${myarray[*]}&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 16 &lt;span&gt;testit &quot;${myarray[*]}&quot;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 17 testit ${myarray[*]}&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 有双引号时，函数接受的参数个数为1.&lt;/p&gt;

&lt;h3&gt;17.4.2 从函数返回参数&lt;/h3&gt;
&lt;p&gt;函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;31&quot;&gt;
&lt;p&gt;&lt;em&gt;  1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2 function fun&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  3 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  4         local origarray&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  5         local newarray&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  6         local count&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  7         local i&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  8         origarray=($(echo &quot;$@&quot;))&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  9         newarray=($(echo &quot;$@&quot;))&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 10         count=$[ $# - 1 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 11         for (( i = 0; i &amp;lt;= count; i++ ))&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 12         {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 13                 newarray[$i]=$[ ${origarray[$i]} * 2 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 14         }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 15         echo ${newarray[*]}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 16 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 17&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 18 myarr=(1 2 3 4 5 6 7 8 9 10 11 12 13 14)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 19 echo &quot;original arr is: ${myarr[*]}&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 20 arg1=$(echo ${myarr[*]}) #&lt;/em&gt; &lt;em&gt;这里的用命令输出定义数组&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 21 ret=($(fun $arg1))&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 22 echo &quot;new arr is: ${ret[*]}&quot;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用arg1变量将数组值传给函数fun。函数将该数组重组到新的数组变量中。&lt;/p&gt;
&lt;p&gt;脚本用fun函数的输出来重新生成一个新的数组变量&lt;/p&gt;

&lt;h2&gt;17.5 函数递归&lt;/h2&gt;
&lt;p&gt;函数的返回值直接用echo传递了。&lt;/p&gt;
&lt;p&gt;例子：求阶乘（注意书上的例子p369 中间部分的 result ** 写错了）&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;em&gt;  1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2 function &lt;span&gt;fun1&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  3 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  4         if [ $1 -eq 1 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  5         then&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  6                 echo 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  7         else&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  8                 local temp=$[ $1 - 1 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  9                 local ret=$(&lt;span&gt;fun1&lt;/span&gt; $temp)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 10                 echo $[ $ret * $1 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 11         fi&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 12 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 13&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 14 read -p &quot;Enter value:&quot; value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 15 ret=$(&lt;span&gt;fun1&lt;/span&gt; $value)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 16 echo &quot;ret = $ret&quot;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;17.6 创建库&lt;/h2&gt;
&lt;p&gt;允许创建函数库文件，然后在多个脚本中引用该库文件。&lt;/p&gt;
&lt;p&gt;假设有个脚本，myfuncs。里面定义了一些函数：&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;em&gt; 1 function &lt;span&gt;addem&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  3         echo $[ $1 + $2 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  4 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  5&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  6 function &lt;span&gt;multem&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  7 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  8         echo $[ $1 * $2 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  9 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 10&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 11&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 12 function &lt;span&gt;divem&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 13 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 14         if [ $2 -ne 0 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 15         then&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 16                 echo $[ $1 / $2 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 17         else&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 18                 echo -1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 19         fi&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 20 }&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;shell函数仅在定义它的shell会话中有效。&lt;/p&gt;
&lt;p&gt;如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中运行这个脚本。&lt;/p&gt;
&lt;p&gt;它会为那个新的shell定义这里面的函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。&lt;/p&gt;
&lt;p&gt;如何使用：使用函数库的关键在于source命令，source命令会在当前的shell上下文中执行命令。而不是创建一个新的shell。&lt;/p&gt;
&lt;p&gt;source命令有个快捷的别名，称作点操作符。&lt;/p&gt;
&lt;p&gt;如何使用： &lt;span&gt;. ./myfuncs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里假定在同一目录，如果不在，则需要指定相应的路径名。&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;em&gt;1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2 &lt;strong&gt;&lt;span&gt;. ./myfuncs&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  4 value1=10&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  5 value2=5&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  6 echo &quot;Add Test ret = $(&lt;span&gt;addem&lt;/span&gt; $value1 $value2)&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  7 echo &quot;Mult Test ret = $(&lt;span&gt;multem&lt;/span&gt; $value1 $value2)&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  8 echo &quot;Div Test ret = $(&lt;span&gt;divem&lt;/span&gt; $value1 $value2)&quot;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;17.7 在命令行上使用函数&lt;/h2&gt;
&lt;h3&gt;17.7.1 在命令行上创建函数&lt;/h3&gt;
&lt;p&gt;可以在命令行界面的提示符下直接使用函数。&lt;/p&gt;
&lt;p&gt;用起来就跟命令一样。而且一旦定义的函数，就可以在整个系统中使用它了，不需要管PATH环境变量了。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171201214913183-511453059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1）必须在每个命令后面加上分号，这样才能知道哪里是命令的起止&lt;/p&gt;
&lt;p&gt;2）不能创建跟内建命令或其他命令相同的函数，否则会覆盖原来的命令&lt;/p&gt;

&lt;h3&gt;17.7.2 在.bashrc文件中定义函数&lt;/h3&gt;
&lt;p&gt;在命令行数定义shell函数明显的缺点是退出shell时，函数就消失了。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;span&gt;将函数定义在一个特定的位置，这个位置在每次启动一个新的shell的时候都由shell重新载入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最佳地点就是&lt;span&gt;&lt;strong&gt;.bashrc&lt;/strong&gt;&lt;strong&gt;。bash shell&lt;/strong&gt;&lt;strong&gt;在每次启动时都会在主目录查找这个文件&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 直接定义函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;直接在.bashrc后面加上&lt;/p&gt;
&lt;p&gt;&lt;em&gt;function addem&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;         echo $[ $1 + $2 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这样在系统上任意地方使用这个函数了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.读取函数文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以用source命令将库文件中的函数添加到.bashrc中&lt;/p&gt;
&lt;p&gt;直接在.bashrc后面加上&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;.  /home/xcy/myfuncs&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样就可以用myfuncs里面的函数了。&lt;/p&gt;

&lt;h2&gt;17.8 实例&lt;/h2&gt;
&lt;p&gt;本节介绍GNU shtool shell 脚本函数库。shtool库提供了一些简单的shell脚本库。这里暂时不写了。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 13:57:00 +0000</pubDate>
<dc:creator>xcywt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcywt/p/7944596.html</dc:identifier>
</item>
<item>
<title>webpack之前端性能优化（史上最全，不断更新中。。。） - 前端小豪</title>
<link>http://www.cnblogs.com/ssh-007/p/7944491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ssh-007/p/7944491.html</guid>
<description>&lt;p&gt;最近在用webpack优化首屏加载性能，通过几种插件之后我们上线前后的速度快了一倍，在此就简单的分享下吧，先上个优化前后首屏渲染的对比图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201190406120-1110971834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到总下载时间从3800ms缩短到1600ms。&lt;/p&gt;
&lt;p&gt;我们在用webpack时一般都会选择多入口文件吧，为的就是将自己的源码跟第三方库代码分离。这是之前的代码，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;entry: {
        entry: &lt;/span&gt;'./src/main.js'&lt;span&gt;,
        vendor: [&lt;/span&gt;'vue', 'vue-router', 'vuex', 'element-ui','echarts'&lt;span&gt;]
},
output: {
        path: config.build.assetsRoot,
        filename: utils.assetsPath(&lt;/span&gt;'js/[name].[chunkhash].js'&lt;span&gt;),
        chunkFilename: utils.assetsPath(&lt;/span&gt;'js/[id].[chunkhash].js'&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;echarts非常大，所以打包时的vendor.js大概为1.2MB（经过gzip压缩之后），而且首页没有用到echarts，所以我之后使用了externals将第三方库以cdn的方式去引入，下面是优化过的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;entry: {
        entry: &lt;/span&gt;'./src/main.js'&lt;span&gt;,
        vendor: [&lt;/span&gt;'vue', 'vue-router', 'vuex', 'element-ui'&lt;span&gt;]
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的output为base中的output，不是生产的output&lt;/span&gt;
&lt;span&gt;    output: {
        path: config.build.assetsRoot,
        filename: &lt;/span&gt;'[name].js'&lt;span&gt;,
        libraryTarget: &lt;/span&gt;&quot;umd&quot;&lt;span&gt;,
        publicPath: process.env.NODE_ENV &lt;/span&gt;=== 'production' ?&lt;span&gt;
            config.build.assetsPublicPath : config.dev.assetsPublicPath
    },
    externals: {
        echarts: &lt;/span&gt;'echarts'&lt;span&gt;,
        _: &lt;/span&gt;'lodash'&lt;span&gt;
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201191224870-949519890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201191155870-445757937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这就是优化前后的对比。&lt;/p&gt;
&lt;p&gt;然后我们要到html中以script标签的形式去引externals中的cdn。之后就可以在相应的文件中import了，他的好处是不管你在多少vue文件中引用多少次，他都不会打包到所有的trunk(这里的trunk'指的是按需加载，一会详细说明)中，这是用webpack-bundle-analyzer插件展示的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; BundleAnalyzerPlugin = require('webpack-bundle-analyzer'&lt;span&gt;).BundleAnalyzerPlugin;
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BundleAnalyzerPlugin({
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  可以是`server`，`static`或`disabled`。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  在`server`模式下，分析器将启动HTTP服务器来显示软件包报告。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  在“静态”模式下，会生成带有报告的单个HTML文件。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  在`disabled`模式下，你可以使用这个插件来将`generateStatsFile`设置为`true`来生成Webpack Stats JSON文件。&lt;/span&gt;
            analyzerMode: 'server'&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  将在“服务器”模式下使用的主机启动HTTP服务器。&lt;/span&gt;
            analyzerHost: '127.0.0.1'&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  将在“服务器”模式下使用的端口启动HTTP服务器。&lt;/span&gt;
            analyzerPort: 8888&lt;span&gt;, 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  路径捆绑，将在`static`模式下生成的报告文件。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  相对于捆绑输出目录。&lt;/span&gt;
            reportFilename: 'report.html'&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  模块大小默认显示在报告中。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  应该是`stat`，`parsed`或者`gzip`中的一个。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  有关更多信息，请参见“定义”一节。&lt;/span&gt;
            defaultSizes: 'parsed'&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  在默认浏览器中自动打开报告&lt;/span&gt;
            openAnalyzer: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  如果为true，则Webpack Stats JSON文件将在bundle输出目录中生成&lt;/span&gt;
            generateStatsFile: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  如果`generateStatsFile`为`true`，将会生成Webpack Stats JSON文件的名字。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  相对于捆绑输出目录。&lt;/span&gt;
            statsFilename: 'stats.json'&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  stats.toJson（）方法的选项。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  例如，您可以使用`source：false`选项排除统计文件中模块的来源。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  在这里查看更多选项：https：  //github.com/webpack/webpack/blob/webpack-1/lib/Stats.js#L21&lt;/span&gt;
            statsOptions: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
            logLevel: &lt;/span&gt;'info' &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日志级别。可以是'信息'，'警告'，'错误'或'沉默'。&lt;/span&gt;
        })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201192034558-1469528317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201191707448-1637409634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们会看到，没用externals和用了externals后所有的js中都不会出现类似echarts和lodash的库出现(就算你import一万次他都不会打包一次，厉害吧~~)。&lt;/p&gt;
&lt;p&gt;对于externals再说两点——&lt;/p&gt;
&lt;p&gt;1.externals中的key是import中使用的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import lodash from &quot;_&quot;&lt;span&gt;;
import echarts from &lt;/span&gt;&quot;echarts&quot;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.externals中的value是window下调用的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201192452261-1394398647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再来聊聊为什么output使用trunkhash不用trunk，这是为了持久化缓存。简单说下两者的区别——&lt;/p&gt;
&lt;p&gt;trunk：每次build之后的版本，就是说所有的build之后的文件hash值一致,比如我只改了一个文件，最后所有的文件hash都会变，这样所有的文件都不会走cache，这样缓存就失去了意义。&lt;/p&gt;
&lt;p&gt;trunkhash：根据每个文件生成不同的hash值，当文件变化时hash会改变且只会改变相应的文件&lt;/p&gt;
&lt;p&gt;然后我们肯定是要用到CommonsChunkPlugin，这个插件是用来抽取公共代码的，基本上99%的配置都是长这样子或者类似这样子用两个不同的commonschunkPlugin，但这从某方面来说并没有实现真正意义上的持久化缓存，这个一会我会通过webpack打包原理来详细解释其中的原因。。。。。。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.CommonsChunkPlugin({
       names: [&lt;/span&gt;'vendor','manifest'&lt;span&gt;]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 在没用这个插件之前，我们的main.js和vendor.js会是这样子。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201194807651-807059573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家会看到我们这两个文件会有公共的部分，比如vue和element-ui，所以我们要抽取公共代码到vendor中，所以我们可以先这样配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.CommonsChunkPlugin({
       name: &lt;/span&gt;'vendor'&lt;span&gt;,
}),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这样的话虽然可以提取公共代码，但我们会把runtime（webpack运行时的代码，一会在打包原理中会再次提到）也放到vendor中，这里面会维护一个trunk的文件列表，类似于这样，就是说我们改任意的代码，这个table里面的hash会变，所以vendor的hash也会变&lt;/p&gt;
&lt;p&gt;，所以这没有实现真正的持久化缓存。这个hash table是按需缓存的打包出来的trunk包，一般都是通过require.ensure(就是vue-router中配置的page对应页面，按需加载)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201195347870-642223794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 所以我们就把name改为names，就是上面那个配置。因为使用这个插件，我们会把公共代码抽到第一个name中，把runtime放到最后一个name中，也就是我们所谓的“manifest”文件。&lt;/p&gt;
&lt;p&gt;并且这个文件会比较小，通常都是2kb左右，所以build后会生成一个script标签，但这样的话就多了一个http请求，所以我们可以用另外一个插件（InlineManifestWebpackPlugin）将manifest.js内联进去。就会长这样子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201200922354-1453932581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再回到我们的CommonsChunkPlugin，现在我们随便改任何已存在的文件，vendor.js的hash都不会变，是的，貌似这就实现了持久化缓存。但是当我们新增一个模块，并且在入口文件中import一下，我们的vendor就会跟main一起变。很奇怪对吧，我们明明已经做了自己的源码跟第三方库分离，为什么vendor还会变（到现在应该没有任何一篇博客对此进行详细的说明）。下面我就详细的给大家解释下我的看法，如果大家发现有不对的地方还请指正。&lt;/p&gt;
&lt;p&gt;再解释为什么之前，我们先简单了解下webpack的打包规则。&lt;/p&gt;
&lt;p&gt;webpack一个entry对应一个bundle，这个bundle包括入口文件和其依赖的模块。其他按需加载的则打包成其他的bundle。还有一个比较重要的文件时manifest，它是最先加载的，负责打包其他的bundle并按需加载和执行。&lt;/p&gt;
&lt;p&gt;manifest是一个自执行函数，熟悉angular的同学看第一行应该很了解，因为anguar1.3版本的源码中启动就是angular.bootstrap，对，这里也是一样。里面的modules变量就是对应模块函数，它是webpack处理的基本单位，就是说对应打包前的一个文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201202636823-688005064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是js源文件， &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201203722464-1035454331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201203741683-76263375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是打包后的文件，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201203651448-1270606044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 所有的模块函数索引都是连续的（每个js文件生成一个trunkid！！！！！），像这种 /* 4 */ 对应的就是js文件，他通过打包就变成了一个个trunkid，仔细看会看到咱们打包前js文件里的export和require依赖都会统一转换成webpack模块。咱们说的webpackJsonp就是除manifest之外打包其他的文件的函数体。&lt;/p&gt;
&lt;p&gt;简单说下main吧，这个图的trunkid是连续的，为了在一张图上显示，我截掉了trunk3-7.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201204743808-146504773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面一共有三个参数，第一个是我当前文件的trunkid，它是唯一标识符，就是指main的trunkid，第二个就是打包的所有文件的模块函数，第三个是我要立即执行的trunkid模块函数。&lt;/p&gt;
&lt;p&gt;ok，介绍这些就足够了。&lt;/p&gt;
&lt;p&gt;然后我们再回过头来看看为什么我们所谓的commonschunkPlugin会变。刚才说过，有几个js就有几个trunkid。&lt;/p&gt;
&lt;p&gt;所以当我们新加一个js并引入到main入口时，webpack再次打包，我的main文件会多一个模块函数，刚刚说过trunkid是依次递增的而且不会重复。所以对应的vendor的id会+1，就是这么细微的变化导致hash变了。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201205734401-862046361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201205953245-1737961377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201210055995-1086689758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 大家仔细看，这两个vendor都是10272行，唯一的不同就是我要自执行这个vendor库，这里我引用的jquery，所以这个文件只有jquery，自执行肯定要有模块函数，trunkid+1，所以hash会变。我们再好好回忆一下，其实这也说明了这个插件的意义，我就是要抽出公共的库，OK，这个插件做到了，但是因为webpack打包机制，不同文件生成不同turnkid，所以这是美中不足的一点。再回想一下，我们一般是不会随便修改main.js的，所以从另一角度上来说这就是实现了持久化缓存。但我如果就是想保持vendor的hash不变要怎么办呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201210555636-2071637536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这段代码就可以实现，没错，如果你对vue-cli了如指掌，这就是vue-cli的官方demo，至于为什么可以，这个我后续会跟大家解释（实在是写不动了。。。）。&lt;/p&gt;
&lt;p&gt;最后再给大家介绍一个超级好用的东西，就是cdn。我们现在的需求是想让图片走cdn，让js走线上路径，但官方的解释是通过修改config文件做cdn变化，这样做的话我的所有输出都会走cdn，那所有的ajax请求就跨域了呀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201211048589-2013556343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一开始我的解决方案是，在源文件中挨个替换，这样会比较慢，更重要的是，cdn图片也是有hash值的，当我以后替换图片时，还得重新改相应的hash。有什么方法能让他自动去获取hash呢。&lt;/p&gt;
&lt;p&gt;没错，我们需要在url-loader中单独配置cdn，做到js访问线上路径，静态资源使用cdn，两者互不影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728583/201712/728583-20171201211334948-122602695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单提醒一下，url-loader不能检测到js中的background，所以我们凡是在js中引用的地址，必须在外面先import这张图片，url-loader才会解析并打包。&lt;/p&gt;
&lt;p&gt;今天就先到这里吧，改天继续。。。。。&lt;/p&gt;

</description>
<pubDate>Fri, 01 Dec 2017 13:18:00 +0000</pubDate>
<dc:creator>前端小豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ssh-007/p/7944491.html</dc:identifier>
</item>
<item>
<title>13. ZooKeeper最佳实践 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/7944437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/7944437.html</guid>
<description>&lt;p&gt;以下列举了运行和管理ZooKeeper ensemble的一些最佳实践：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ZooKeeper数据目录包含快照和事务日志文件。如果&lt;code&gt;autopurge&lt;/code&gt;选项未启用，定期清理目录是一个好习惯。另外，管理员可能希望保留这些文件的备份，具体取决于应用程序的需要。但是，由于ZooKeeper是一个复制服务，我们只需要备份整个ensemble中一台服务器的数据即可。&lt;/li&gt;
&lt;li&gt;ZooKeeper使用Apache log4j作为其日志记录基础设施。随着日志文件的规模越来越大，建议使用内置的log4j特性来设置日志文件的&lt;code&gt;auto-rollover&lt;/code&gt;功能。&lt;/li&gt;
&lt;li&gt;客户端在其连接字符串中使用的ZooKeeper服务器列表必须与每个ZooKeeper服务器所拥有的ZooKeeper服务器列表相匹配。如果列表不匹配，可能会出现奇怪的行为。&lt;/li&gt;
&lt;li&gt;每个Zookeeper服务器配置文件中的服务器列表应该与ensemble的其他成员一致。&lt;/li&gt;
&lt;li&gt;如前所述，ZooKeeper事务日志必须在专用设备中进行配置。这对于从ZooKeeper获得最佳性能非常重要。&lt;/li&gt;
&lt;li&gt;应该谨慎选择Java堆大小。在ZooKeeper服务器中不应该允许交换（swapping）。如果ZooKeeper服务器拥有相当高的内存(RAM)，情况会更好。&lt;/li&gt;
&lt;li&gt;系统监视工具（如&lt;code&gt;vmstat&lt;/code&gt;）可用于监视虚拟内存统计信息，并根据应用程序的需要决定所需内存的最佳大小。无论如何，应该避免交换。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 01 Dec 2017 13:03:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/7944437.html</dc:identifier>
</item>
<item>
<title>初入职场者面试中的问题 - metoy</title>
<link>http://www.cnblogs.com/qingquanzi/p/7900514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingquanzi/p/7900514.html</guid>
<description>&lt;p&gt;&lt;span&gt;我面过很多的人，也被很多的人面过。这里我将结合我多年的经历，跟大家分享下，我看到的初入职场的面试者，身上存在的一系列问题。避免这些问题，将使你的面试成功率达到百分之九十。（不得不承认，剩下的百分之十还有运气和缘分的成分）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、过于谦卑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;切勿“拍马”面试官，“过谦”自己。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我观察过很多的初入职场者，大多数人有这样一种心态：刻意放低自己，夸大对方。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初入职场者，往往会因为对方是自己的面试官，技术牛，经验多，而故意谦虚自己，并借此夸奖对方。你或许想谦虚一下，顺便说几句面试官的好话，以博取面试官的好感。甚至有时为了表示对面试官的尊重而“毕恭毕敬”。但事与愿违，这反而营造了一种不自然、拘谨的交流情绪。情绪是相互的，你的不自然拘谨，也会阻碍面试官和你自然的交流。你的过谦会让面试官认为是你的能力不行，你的拘谨，会被面试官认为是不善沟通，难以融入团队。所以，只有在放开、自然的状态下，面试官才能更好的去了解你。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面试最重要的是营造一个平等自然地对话状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、自信不足&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不知你是否见过这种现象：某些人技术不比你好，但却更容易拿到offer。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种现象往往是因为一个人面试中表现的是否自信导致的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自信很重要，你的自信表达，会让面试官也对你充满信心；你的唯唯诺诺，也会让面试官怀疑你的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记得当年我刚来北京那会，条件差，一个宿舍住好几个人。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有一天，宿舍一个哥们，兴奋地跟我们说拿到offer了，要了八千。这在当时一个初入职场者，八千还是挺高的。当时的我，自认技术比较扎实，比他强，但也不过都六千左右的offer。于是很好奇的请教：你是怎么做到的，怎么面的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他说：我跟面试官说，我曾经跟IBM合作，做过一个大型的电商系统。。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;别说，这哥们还真有一套，说起谎来真的是面不慌心不跳。他的这种自信，居然让面试官都信以为真。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然了，这里也看得出，面试官也是个水货，也是这哥们走了那百分之十的运气。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我极其不鼓励初入职场的面试者说谎、吹嘘，因为稍微有点水平的面试官，很容易识破。一旦识破，那就被打上人品问题的标签。我更鼓励面试者，实事求是，并且自信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不会就说不会，没必要因此而不自信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面试本来就是不平等的，面试官以自己会的知识，来考察你可能没接触过得知识，不会真的在正常不过了。或许你来提问面试官，也大有可能把面试官给难住。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有必要因为面试官比自己牛而不自信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初入职场者，往往会以为面试官技术比较牛，而变得唯唯诺诺，回答问题没有自信。有的时候面试官还会故意考验你：你确定吗？。不少面试者，就是在这样的反问下，变得不知所以然，彻底崩溃。其实，面试官比你技术好、经验多，也没什么了不起，想想看，等你像他那样也工作几年，你或许比面试官还要牛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于面试要自信，再增么强调也不为过。自信会传染，你的自信，感染到别人，就成了别人对你的相信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你还是紧张，无法自信，那就表面尊重面试官，在心里鄙视面试官：这有啥了不起，我学了我也会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、博而不专&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;博而不专这个词，还是我看《天龙八部》里，乔峰说鸠摩智的台词。(不知九零后能否听懂^_^)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;那就拿乔峰和鸠摩智来举例说明：乔峰专注于自家武学，不贪多，而成万人敌；鸠摩智恰恰相反，一会学少林的，一会学大理段氏，还去偷学姑苏慕容的，最终在于乔峰的一役中，被打的口吐鲜血。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实学技术也是这样，最忌讳样样会，样样一知半解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我发现，培训机构出来的学生最容易是博而不专。为什么这么说呢：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一方面，培训机构的课程周期大都是四个月，但讲得内容，还相当丰富，除了讲Java基础，还讲了一大堆的框架，像spring、mybatis、struts2、hibernate、lucene等。在这短暂的时间内，教那么多的东西，势必就导致，每一样停留在仅仅学会如何使用上，而本身的基础还没深度。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;另一方面，培训机构的讲师大都是传统软件公司出身，缺少互联网的工作经验，自身的技术深度也不够。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面试官最看重的是技术深度，面试官不会因为你不会而否定你，但是会因为你会的却没深度而否定你。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有的面试者，简历上写的东西一大堆。以为会的多，面试通过的几率就大，其实这正好相反。会的多，给面试者的初步印象：大概率是博而不专。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在我负责帮团队找几个候选人时，在一个技术群发现了一个人，很多人都像他提问问题，而且他也有很多的技术文章，于是我就联系他，问他对来阿里工作是否感兴趣。他说很感兴趣，然后我就让他整理了份简历。他的简历上写了一大堆的技术框架，会的远比我多多了，像什么nutch、lucene、elasticsearh、hadoop等等吧。看了简历我初步断定这个人可能得让我失望了，大概率是样样会，样样半瓶子水。抱着试试看的心态，进行了一轮电话面试。问了几个多线程，数据库的基础知识，他就败下阵来。那我只好礼貌的说：你的大体情况我了解了，后续我评估下再联系你吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我知道很多面试者不愿意听面试官说这种话，但是面试官也是没办法。面试官更希望，即使这一系列的框架你都没接触过，只要你把相关的基础掌握扎实了有深度了，都是可以的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学技术必须先有深度，在寻广度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我为什么这么说呢？技术是最容易触类旁通的东西，一个技术掌握的有深度了，在学习其他技术，门槛极低。反过来，则不然。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有圈友可能会问，面试问的那么深，但这些东西工作中大部分都用不到啊？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这里我来回答下大部分初学者的这个疑问。传统软件公司，大部分是在了解业务知识的基础上进行一些增删改查，所以技术场景简单，可能对技术深度要求不高。但是互联网公司不同，互联网公司技术复杂，遇到的技术问题也复杂，在解决问题时就用到了面试中问到的这些有深度的问题。掌握的有深度，也是在你遇到问题时有解决思路的前提。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;解决问题的能力，最能检测一个人的技术深度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有人说：我能独立完成一个项目的开发，从前端到后端。我会：呵呵。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有人说：我会Java，会c#，会php。我也会：呵呵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里我要告诫初入职场的你：切勿贪多嚼不烂。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;简历上，只要把自己掌握牢靠有深度的技术写上就可以了。不要贪多，会一点就往简历上写。否则被问住，会大大折损你给面试官的印象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;面试官也没啥了不起，不卑不亢，平等自然交流最好。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;问题回答不上来也不必灰心，保持自信，毕竟任何人都有没接触过的知识、不会的问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;技术要掌握扎实，有些深度。你会的技术，就尽量不要让面试官把你问住。容易被问住的，就没必要写到简历上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是我创建的一个技术学习交流圈子，可以微信扫码加入：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;加入连接：&lt;a href=&quot;https://t.xiaomiquan.com/aEQVNJe&quot;&gt;https://t.xiaomiquan.com/aEQVNJe&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;也欢迎加我qq咨询：936419373。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 12:05:00 +0000</pubDate>
<dc:creator>metoy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingquanzi/p/7900514.html</dc:identifier>
</item>
<item>
<title>Jenkins与网站代码上线解决方案 - 惨绿少年</title>
<link>http://www.cnblogs.com/clsn/p/7944116.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clsn/p/7944116.html</guid>
<description>&lt;h2&gt;1.1 &lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201191826104-357945560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Jenkins&lt;span&gt;是一个用&lt;/span&gt;Java&lt;span&gt;编写的开源的&lt;span&gt;&lt;span&gt;持续集成&lt;/span&gt;&lt;/span&gt;工具。在与&lt;/span&gt;Oracle&lt;span&gt;发生争执后，项目从&lt;/span&gt;Hudson&lt;span&gt;项目独立。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Jenkins&lt;span&gt;提供了软件开发的&lt;span&gt;&lt;span&gt;持续集成&lt;/span&gt;&lt;/span&gt;服务。它运行在&lt;/span&gt;Servlet&lt;span&gt;容器中（例如&lt;/span&gt;Apache Tomcat&lt;span&gt;）。它支持软件配置管理（&lt;/span&gt;SCM&lt;span&gt;）工具（包括&lt;/span&gt;AccuRev SCM&lt;span&gt;、&lt;/span&gt;CVS&lt;span&gt;、&lt;/span&gt;Subversion&lt;span&gt;、&lt;/span&gt;Git&lt;span&gt;、&lt;/span&gt;Perforce&lt;span&gt;、&lt;/span&gt;Clearcase&lt;span&gt;和&lt;/span&gt;RTC&lt;span&gt;），可以执行基于&lt;/span&gt;Apache Ant&lt;span&gt;和&lt;/span&gt;Apache Maven&lt;span&gt;的项目，以及任意的&lt;/span&gt;Shell&lt;span&gt;脚本和&lt;/span&gt;Windows&lt;span&gt;批处理命令。&lt;/span&gt;Jenkins&lt;span&gt;的主要开发者是川口耕介。&lt;/span&gt;Jenkins&lt;span&gt;是在&lt;/span&gt;MIT&lt;span&gt;许可证下发布的自由软件。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.1.1 Jenkins&lt;span&gt;功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1&lt;span&gt;、持续的软件版本发布&lt;/span&gt;/&lt;span&gt;测试项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、监控外部调用执行的工作。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.2 &lt;span&gt;怎么理解持续集成、持续交付、持续部署呢？&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1.2.1 &lt;span&gt;持续集成&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;持续集成（英语：&lt;/span&gt;&lt;em&gt;Continuous integration&lt;/em&gt;&lt;span&gt;，缩写为&lt;/span&gt; &lt;strong&gt;CI&lt;/strong&gt;&lt;span&gt;），一种软件工程流程，将所有工程师对于软件的工作复本，每天集成数次到共用主线（&lt;/span&gt;mainline&lt;span&gt;）上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个名称最早由葛来迪·布区（&lt;/span&gt;Grady Booch&lt;span&gt;）在他的布区方法中提出，但是他并没有提到要每天集成数次。之后成为极限编程（&lt;/span&gt;extreme programming&lt;span&gt;，缩写为&lt;/span&gt;XP&lt;span&gt;）的一部分。在测试驱动开发（&lt;/span&gt;TDD&lt;span&gt;）的作法中，通常还会搭配自动单元测试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;持续集成的提出，主要是为了解决软件进行系统集成时面临的各项问题，极限编程称这些问题为集成地狱（&lt;/span&gt;integration hell&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201191840448-1304029709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;持续集成主要是强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。简单来讲就是：频繁地（一天多次）将代码集成到主干。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;持续集成目的在产生以下效益如：&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ü &lt;/span&gt;&lt;span&gt;及早发现集成错误且由于修订的内容较小所以易于追踪，这可以节省项目的时间与成本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ü &lt;/span&gt;&lt;span&gt;避免发布日期的前一分钟发生混乱，当每个人都会尝试为他们所造成的那一点点不兼容的版本做检查。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ü &lt;/span&gt;&lt;span&gt;当单元测试失败或发生错误，若开发人员需要在不除错的情况下还原代码库到一个没有问题的状态，只需要放弃一小部分的更改&lt;/span&gt; (&lt;span&gt;因为集成的次数频繁&lt;/span&gt;)&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ü &lt;/span&gt;&lt;span&gt;让&lt;/span&gt; &quot;&lt;span&gt;最新&lt;/span&gt;&quot; &lt;span&gt;的程序可保持可用的状态供测试、展示或发布用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ü &lt;/span&gt;&lt;span&gt;频繁的提交代码会促使开发人员创建模块化，低复杂性的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ü &lt;/span&gt;&lt;span&gt;防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.2.2 &lt;span&gt;持续交付&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;持续交付（英语：&lt;/span&gt;&lt;em&gt;Continuous delivery&lt;/em&gt;&lt;span&gt;，缩写为&lt;/span&gt; &lt;strong&gt;CD&lt;/strong&gt;&lt;span&gt;），是一种软件工程手法，让软件产品的产出过程在一个短周期内完成，以保证软件可以稳定、持续的保持在随时可以释出的状况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它的目标在于让软件的建置、测试与释出变得更快以及更频繁。这种方式可以&lt;span&gt;减少软件开发的成本与时间，减少风险&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201191850511-1013536040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（&lt;/span&gt;&lt;em&gt;production-like environments&lt;/em&gt;&lt;span&gt;）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的&lt;/span&gt; Staging &lt;span&gt;环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.2.3 &lt;span&gt;持续部署&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;持续部署（英语：&lt;/span&gt;&lt;em&gt;Continuous Deployment&lt;/em&gt;&lt;span&gt;，缩写为&lt;/span&gt; &lt;strong&gt;CD&lt;/strong&gt;&lt;span&gt;），是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有时候，持续部署也与持续交付混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201191900433-349001067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;持续部署即在持续交付的基础上，把部署到生产环境的过程自动化。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;关键字：&lt;/span&gt; &lt;strong&gt;CI/CD&lt;/strong&gt; &lt;span&gt;持续集成&lt;/span&gt;/&lt;span&gt;持续交付&lt;/span&gt;/&lt;span&gt;持续部署&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;1.3 &lt;span&gt;安装配置&lt;/span&gt;JENKINS&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;了解网&lt;/span&gt;Jenkins&lt;span&gt;后，现在进行&lt;/span&gt;Jenkins&lt;span&gt;的安装&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.3.1 &lt;span&gt;环境说明&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;推荐的硬件配置&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1 GB&lt;span&gt;的&lt;/span&gt;RAM&lt;/p&gt;
&lt;p&gt;50 GB&lt;span&gt;的驱动器空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;系统环境&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cat /etc/redhat-release &lt;/span&gt;
CentOS Linux release 7.4.1708&lt;span&gt; (Core) 
[root@Jenkins &lt;/span&gt;~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; uname -r&lt;/span&gt;
3.10.0-693&lt;span&gt;.el7.x86_64
[root@Jenkins &lt;/span&gt;~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; getenforce &lt;/span&gt;
&lt;span&gt;Disabled
[root@Jenkins &lt;/span&gt;~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; systemctl status firewalld.service &lt;/span&gt;
● firewalld.service - firewalld -&lt;span&gt; dynamic firewall daemon
   Loaded: loaded (&lt;/span&gt;/usr/lib/systemd/system/&lt;span&gt;firewalld.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:firewalld(&lt;/span&gt;1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;软件要求&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 8--&lt;span&gt;无论是&lt;/span&gt;Java&lt;span&gt;运行时环境（&lt;/span&gt;JRE&lt;span&gt;）还是&lt;/span&gt;Java&lt;span&gt;开发工具包（&lt;/span&gt;JDK&lt;span&gt;）都可以。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以使用open jdk&lt;/span&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; yum -y install java-1.8.0-openjdk java-1.8.0-openjdk-devel&lt;/span&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; java -version&lt;/span&gt;
openjdk version &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.8.0_151&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
OpenJDK Runtime Environment (build &lt;/span&gt;1.8.0_151-&lt;span&gt;b12)
OpenJDK &lt;/span&gt;64-Bit Server VM (build 25.151-b12, mixed mode)&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.3.2 &lt;span&gt;安装&lt;/span&gt;Jenkins&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;软件下载&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
官方仓库  https://pkg.jenkins.io/redhat-stable/&lt;span&gt;
清华大学开源软件镜像站  https:&lt;/span&gt;//mirrors.tuna.tsinghua.edu.cn/jenkins/redhat/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         &lt;span&gt;下载相应的数据包即可，我这里使用的是&lt;/span&gt;jenkins-2.73.1-1.1.noarch.rpm&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;安装&lt;/span&gt;jenkins&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -ivh jenkins-2.73.1-1.1.noarch.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;启动&lt;/span&gt;jenkins&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/etc/init.d/jenkins start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;检查端口信息&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; netstat -lntp&lt;/span&gt;
&lt;span&gt;Active Internet connections (only servers)
Proto Recv&lt;/span&gt;-Q Send-Q Local Address           Foreign Address         State       PID/&lt;span&gt;Program name    
tcp        0      0 &lt;/span&gt;0.0.0.0:22              0.0.0.0:*               LISTEN      1213/&lt;span&gt;sshd           
tcp6       0      0 :::&lt;/span&gt;8080                 :::*                    LISTEN      1672/&lt;span&gt;java           
tcp6       0      0 :::&lt;/span&gt;22                   :::*                    LISTEN      1213/sshd  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;RPM&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;包安装的内容&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; rpm -ql jenkins&lt;/span&gt;
/etc/init.d/jenkins         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动文件&lt;/span&gt;
/etc/logrotate.d/jenkins    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 日志分割配置文件&lt;/span&gt;
/etc/sysconfig/jenkins      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; jenkins主配置文件&lt;/span&gt;
/usr/lib/jenkins            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存放war包目录&lt;/span&gt;
/usr/lib/jenkins/jenkins.war   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; war 包 &lt;/span&gt;
/usr/sbin/rcjenkins         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 命令&lt;/span&gt;
/var/cache/jenkins          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; war包解压目录 jenkins网页代码目录&lt;/span&gt;
/var/lib/jenkins            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; jenkins 工作目录&lt;/span&gt;
/var/log/jenkins             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 日志&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;配置文件说明&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; grep &quot;^[a-Z]&quot; /etc/sysconfig/jenkins&lt;/span&gt;
JENKINS_HOME=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/lib/jenkins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;jenkins工作目录&lt;/span&gt;
JENKINS_JAVA_CMD=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
JENKINS_USER&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jenkins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; jenkinx启动用户&lt;/span&gt;
JENKINS_JAVA_OPTIONS=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Djava.awt.headless=true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
JENKINS_PORT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 端口&lt;/span&gt;
JENKINS_LISTEN_ADDRESS=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
JENKINS_HTTPS_PORT&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
JENKINS_HTTPS_KEYSTORE&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
JENKINS_HTTPS_KEYSTORE_PASSWORD&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
JENKINS_HTTPS_LISTEN_ADDRESS&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
JENKINS_DEBUG_LEVEL&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
JENKINS_ENABLE_ACCESS_LOG&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
JENKINS_HANDLER_MAX&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最大连接&lt;/span&gt;
JENKINS_HANDLER_IDLE=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
JENKINS_ARGS&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.3.3 web&lt;span&gt;界面安装&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;浏览器访问&lt;/span&gt;: http://10.0.0.64:8080&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192116854-809260260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;解锁&lt;/span&gt;Jenkins&lt;span&gt;，密码从命令行中获取&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cat /var/lib/jenkins/secrets/initialAdminPassword&lt;/span&gt;
3afe5ad49a794ac2b1a72811f5eb3c9b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         &lt;span&gt;输入授权密码，然后点击下一步&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192138448-1309799150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;稍等一会来导安装插件选择的页面，将此页面关闭，在安装完成&lt;/span&gt;Jenkins&lt;span&gt;后安装插件。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192147370-911465434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;关闭安装插件选择后，选择开始使用&lt;/span&gt;Jenkins&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192204573-1739948470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装完成，显示界面&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192213120-1148654989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;安装&lt;/span&gt;&lt;span&gt;Jenkins&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;插件&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统管理&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;管理插件&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192222058-1591608429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;选择自己需要的插件进行安装即可，也可选择全部安装。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8814329e-1707-4f65-9b1d-7e940998d6c9')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_8814329e-1707-4f65-9b1d-7e940998d6c9&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8814329e-1707-4f65-9b1d-7e940998d6c9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8814329e-1707-4f65-9b1d-7e940998d6c9',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8814329e-1707-4f65-9b1d-7e940998d6c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; # 插件安装完成后插件安装目录的内容&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; [root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  ls /var/lib/jenkins/plugins/&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; ace-editor                     credentials.jpi           github-branch-source      jquery-detached.jpi  pam-auth                              pipeline-model-extensions.jpi     ssh-credentials.jpi      workflow-basic-&lt;span&gt;steps.jpi
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; ace-editor.jpi                 display-url-api           github-branch-source.jpi  jsch                 pam-auth.jpi                          pipeline-rest-api                 ssh.jpi                  workflow-&lt;span&gt;cps
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; ant                            display-url-api.jpi       github.jpi                jsch.jpi             pipeline-build-step                   pipeline-rest-api.jpi             ssh-slaves               workflow-cps-&lt;span&gt;global&lt;/span&gt;-&lt;span&gt;lib
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; antisamy-markup-formatter      docker-commons            git.jpi                   junit                pipeline-build-step.jpi               pipeline-stage-step               ssh-slaves.jpi           workflow-cps-&lt;span&gt;global&lt;/span&gt;-&lt;span&gt;lib.jpi
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; antisamy-markup-formatter.jpi  docker-commons.jpi        gitlab-plugin             junit.jpi            pipeline-github-lib                   pipeline-stage-step.jpi           structs                  workflow-&lt;span&gt;cps.jpi
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; ant.jpi                        docker-workflow           gitlab-plugin.jpi         ldap                 pipeline-github-lib.jpi               pipeline-stage-tags-metadata      structs.jpi              workflow-durable-task-&lt;span&gt;step
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; authentication-tokens          docker-workflow.jpi       git-server                ldap.jpi             pipeline-graph-analysis               pipeline-stage-tags-metadata.jpi  subversion               workflow-durable-task-&lt;span&gt;step.jpi
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; authentication-tokens.jpi      durable-task              git-server.jpi            mailer               pipeline-graph-analysis.jpi           pipeline-stage-view               subversion.jpi           workflow-&lt;span&gt;job
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; bouncycastle-api               durable-task.jpi          gradle                    mailer.jpi           pipeline-input-step                   pipeline-stage-view.jpi           timestamper              workflow-&lt;span&gt;job.jpi
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; bouncycastle-api.jpi           email-ext                 gradle.jpi                mapdb-api            pipeline-input-step.jpi               plain-credentials                 timestamper.jpi          workflow-&lt;span&gt;multibranch
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; branch-api                     email-ext.jpi             handlebars                mapdb-api.jpi        pipeline-milestone-step               plain-credentials.jpi             token-macro              workflow-&lt;span&gt;multibranch.jpi
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; branch-api.jpi                 external-monitor-job      handlebars.jpi            matrix-auth          pipeline-milestone-step.jpi           resource-disposer                 token-macro.jpi          workflow-scm-&lt;span&gt;step
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; build-timeout                  external-monitor-job.jpi  icon-shim                 matrix-auth.jpi      pipeline-model-api                    resource-disposer.jpi             windows-slaves           workflow-scm-&lt;span&gt;step.jpi
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; build-timeout.jpi              git                       icon-shim.jpi             matrix-project       pipeline-model-api.jpi                scm-api                           windows-slaves.jpi       workflow-step-&lt;span&gt;api
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; cloudbees-folder               git-client                jackson2-api              matrix-project.jpi   pipeline-model-declarative-agent      scm-api.jpi                       workflow-aggregator      workflow-step-&lt;span&gt;api.jpi
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; cloudbees-folder.jpi           git-client.jpi            jackson2-api.jpi          maven-plugin         pipeline-model-declarative-agent.jpi  script-security                   workflow-aggregator.jpi  workflow-&lt;span&gt;support
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; credentials                    github                    javadoc                   maven-plugin.jpi     pipeline-model-definition             script-security.jpi               workflow-api             workflow-&lt;span&gt;support.jpi
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; credentials-binding            github-api                javadoc.jpi               momentjs             pipeline-model-definition.jpi         ssh                               workflow-api.jpi         ws-&lt;span&gt;cleanup
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; credentials-binding.jpi        github-api.jpi            jquery-detached           momentjs.jpi         pipeline-model-extensions             ssh-credentials                   workflow-basic-steps     ws-cleanup.jpi
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;插件安装完成后插件安装目录的内容&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;         &lt;strong&gt;&lt;span&gt;&lt;span&gt;至此&lt;/span&gt;&lt;span&gt;Jenkins&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;安装完成&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;1.3.4 Jenkins&lt;span&gt;配置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;配置&lt;/span&gt;jenkins&lt;span&gt;并发执行数量，提高执行效率&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192306823-988507252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;系统管理&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;系统设置&lt;/span&gt; &amp;gt;&amp;gt; Maven&lt;span&gt;项目配置&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192315401-1452910755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;设置邮件，能够在测试完成后，主动发邮件告知测试情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统管理&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;系统设置&lt;/span&gt; &amp;gt;&amp;gt; Jenkins Location&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192328948-1079923173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;向下拉，找到邮件通知，配置邮件的&lt;/span&gt;smtp&lt;span&gt;信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                  &lt;span&gt;配置完成后点击&lt;/span&gt; Test configuration &lt;span&gt;进行测试，测试成功后，点击保存&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192337073-2130267234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.4 Jenkins&lt;span&gt;使用&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1.4.1 &lt;span&gt;创建一个新的任务&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;创建一个新的任务&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192354042-830010134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;输入项目的名称，选择构建只有分风格的软件&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192401401-883929242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.4.2 &lt;span&gt;将&lt;/span&gt;Jenkins&lt;span&gt;与&lt;/span&gt;gitlab&lt;span&gt;联合&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;gitlab&lt;span&gt;的详细安装方法参照：&lt;/span&gt; http://www.cnblogs.com/clsn/p/7929958.html&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建公钥和私钥&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ssh-keygen &lt;/span&gt;
Generating public/&lt;span&gt;private rsa key pair.

Enter file &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty &lt;span&gt;for&lt;/span&gt;&lt;span&gt; no passphrase): 
Enter same passphrase again: 
Your identification has been saved &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; /root/.ssh/&lt;span&gt;id_rsa.
Your public key has been saved &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; /root/.ssh/&lt;span&gt;id_rsa.pub.
The key fingerprint &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt;:
SHA256:5SGYye8oxCKFJjddb4W8JC0RAQhBWCvuG8aZL8eMJs4 root@Jenkins
The key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s randomart image is:&lt;/span&gt;
+---[RSA 2048]----+
|==....=* ..      |
|...o oo==.       |
|+.= . =++.o      |
|++ o   o.+ .     |
|... o   S .      |
|o.oo   o         |
| B+ . . .        |
|++++ .           |
|+Eo.             |
+----[SHA256]-----+&lt;span&gt;
[root@Jenkins &lt;/span&gt;~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cat .ssh/id_rsa.pub &lt;/span&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cat .ssh/id_rsa&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;在&lt;/span&gt;gitlab&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;中添加公钥&lt;/span&gt;id_rsa.pub&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192426354-684435689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;在&lt;/span&gt;jenkins&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;中添加私钥&lt;/span&gt;id_rsa&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;在首页中，点击项目名称的下拉监听&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192438933-1952523900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;选择源码管理，先将&lt;/span&gt;gitlab&lt;span&gt;的项目地址复制过来&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192448667-1624864487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;选择&lt;/span&gt;SSH&lt;span&gt;密钥和证书，然后选择直接输入，将私钥复制到下框中即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;添加完成后，点击保存&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192456448-898723804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;选择刚才创建的证书，完成后，选择构建&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192504808-1018752536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;选择构建&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;拉到最底部，选择使用&lt;/span&gt;shell&lt;span&gt;脚本&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192512214-519514729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;脚本内容&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192518948-2060407751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;创建测试环境&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; mkdir  -p /data/www&lt;/span&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; chown -R jenkins.jenkins /data/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         &lt;span&gt;选择构建后的操作，让每次构建完成后都将结果发送给管理员&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192536214-662773016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.4.3 &lt;span&gt;测试手动集成&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;回到主页，点击右侧的按钮进行测试&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192552839-1669748311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;部署完成&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192558886-1289295614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;查看部署日志&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192606261-1352544543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看部署结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@Jenkins ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ll /data/www/&lt;/span&gt;
总用量 4
-rw-r--r-- 1 jenkins jenkins 4 11月 30 21:22&lt;span&gt; flag
&lt;/span&gt;-rw-r--r-- 1 jenkins jenkins 0 11月 30 21:22 README.md
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.4.4 &lt;span&gt;自动测试（&lt;/span&gt;gitlab&lt;span&gt;主动通知&lt;/span&gt;Jenkins&lt;span&gt;测试）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;该功能会使用到一个插件&lt;/span&gt; &lt;strong&gt;gitlab plugin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置&lt;/span&gt;gitlab&lt;span&gt;认证&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192624433-157495203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;添加一个新的凭证&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192631683-372513748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;从&lt;/span&gt;gitlab&lt;span&gt;的设置中将&lt;/span&gt; token&lt;span&gt;复制过来&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192639495-710452368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;将复制的&lt;/span&gt;token&lt;span&gt;粘贴到&lt;/span&gt;api token&lt;span&gt;中，点&lt;/span&gt;ok&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192651667-606045732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;在系统配置中找到&lt;/span&gt;&lt;strong&gt;Gitlab&lt;/strong&gt; &lt;span&gt;将信息进行填写，&lt;/span&gt;Credentials &lt;span&gt;选择刚刚创建对的即可&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192700729-449236192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开项目，编辑项目的构建触发器&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192710183-1810385177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;gitlab&lt;span&gt;上配置连接&lt;/span&gt;jenkins &lt;span&gt;，将&lt;/span&gt;Jenkins&lt;span&gt;的&lt;/span&gt;Secret token &lt;span&gt;与&lt;/span&gt;Build URL &lt;span&gt;复制到&lt;/span&gt;gitlab&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192718448-1860661215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;保存之前先进程测试，测试成功后进行保存&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192726448-895582851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;在&lt;/span&gt;gitlab&lt;span&gt;进行上传文件，可以测试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在日志中显示是&lt;/span&gt; &lt;span&gt;Started&lt;/span&gt; &lt;span&gt;​&lt;/span&gt;&lt;span&gt;by&lt;/span&gt; &lt;span&gt;​&lt;/span&gt;&lt;span&gt;GitLab&lt;/span&gt; &lt;span&gt;​&lt;/span&gt;&lt;span&gt;push&lt;/span&gt; &lt;span&gt;​&lt;/span&gt;&lt;span&gt;by&lt;/span&gt; &lt;span&gt;​&lt;/span&gt;&lt;span&gt;Administrator&lt;/span&gt; &lt;span&gt;即表示自动集成成功&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192733104-716903443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.5 &lt;span&gt;代码上线方案&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1.5.1 &lt;span&gt;早期手动部署代码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;纯手动&lt;/span&gt;scp&lt;span&gt;上传代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;纯手动登陆，&lt;/span&gt;Git pull &lt;span&gt;或者&lt;/span&gt;SVN update&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;纯手动&lt;/span&gt;xftp&lt;span&gt;上传代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开发发送压缩包，&lt;/span&gt;rz&lt;span&gt;上传，解压部署代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全程运维参与，占用大量时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果节点多，上线速度慢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;人为失误多，目录管理混乱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回滚不及时，或者难以回退。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;上线方案示意图：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192743261-564020995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.5.2 &lt;span&gt;合理化上线方案&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;      1&lt;span&gt;、开发人员需在个人电脑搭建&lt;/span&gt;LAMP&lt;span&gt;环境测试开发好的网站代码，并且在办公室或&lt;/span&gt; IDC&lt;span&gt;机房的测试环境测试通过，最好有专职测试人员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、程序代码上线要规定时间，例如：三天上线一次，如网站需经常更新可每天下午&lt;/span&gt; 17&lt;span&gt;点上线，这个看网站业务性质而定，原则就是影响用户体验最小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;、代码上线之前需备份，网站程序出了问题方便回退，另外，从上线技巧上讲，上传代码时尽可能先传到服务器网站临时目录，传完整后一步&lt;/span&gt;mv&lt;span&gt;过去，或者通过&lt;/span&gt;In&lt;span&gt;做软链接&lt;/span&gt;— &lt;span&gt;线上更新代码的思路。如果严格更新，把应用服务器从集群节点平滑下线，然后更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4&lt;span&gt;、尽量由运维人员管理上线，对于代码的功能性，开发人员更在意，而对于代码的性&lt;/span&gt; &lt;span&gt;能优化和上线后服务器的稳定，运维更在意服务器的稳定，因此，如果网站宕机问题归运维管，就要让运维上线，这样更规范科学。否则，开发随意更新，出了问题运维负责，这样就错了，运维永远无法抬头。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1190037/201712/1190037-20171201192752386-122301749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;图·&lt;/span&gt;web&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;代码规范化上线流程图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;1.5.3 &lt;span&gt;大型企业上线制度和流程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;JAVA&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;代码环境&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;上线时，有数台机器同时需要更新或者分批更新&lt;/span&gt; &lt;span&gt;↓&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;).本地开发人员取svn代码。当天上线提交到trunk，否则，长期项目单开分支开发，然后在合并主线(trunk)
&lt;/span&gt;2&lt;span&gt;).办公内网开发测试时，由开发人员或配置管理员通过部署平台jenkins实现统一部署，（即在部署平台上控制开发机器从svn取代码，编译，打包，发布到开发机，包名如idc_dep.war）.
&lt;/span&gt;3&lt;span&gt;).开发人员通知或和测试人员一起测试程序，没有问题后，由配置管理员打上新的tag标记。这里要注意，不同环境的配置文件是随代码同时发布的。
&lt;/span&gt;4&lt;span&gt;).配置管理员，根据上一步的tag标记，checkout出上线代码，并配置好IDC测试环境的所有配置，执行编译，打包(mvn,ant)(php不需要打包)，然后发布到IDC内的统一分发服务器。
&lt;/span&gt;5&lt;span&gt;).配置管理员或SA上线人员，把分发的程序代码内容推送到相关测试服务器（包名如idc_test.war），然后通知开发及测试人员进行测试。如果有问题向上回退，继续修改。
&lt;/span&gt;6&lt;span&gt;).如果IDC测试没有问题，继续打好tag标记，此时，配置管理员，根据上步的tag标记，checkout出测试好的代码，并配置好IDC正式环境的所有配置，执行编译，打包(mvn,ant)(php不需要打包)，然后发布到IDC内的统一分发服务器主机，准备批量发布。
&lt;/span&gt;7).配置管理员或SA上线人员，把分发的内容推送到相关正式服务器（包名如idc_product.war）,然后通知开发及测试人员进行测试。如果有问题直接发布回滚指令。  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　 IDC&lt;span&gt;正式上线的过程对于&lt;/span&gt;JAVA&lt;span&gt;程序，可以是&lt;/span&gt;&lt;span&gt;&lt;span&gt;AB&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;组分组上线&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的思路，即平滑下线一半的服务器，然后发布更新代码，重启测试，无问题后，挂上更新后的服务器，同时再平滑下线另一半的服务器，然后发布更新代码测试（或者直接发布后，重启，挂上线）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.5.4 php&lt;span&gt;程序代码上线的具体方案&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 　　&lt;span&gt;对于&lt;/span&gt;PHP&lt;span&gt;上线方法：发布代码时（也需要测试流程）可以直接发布到正式线临时目录&lt;/span&gt; &lt;span&gt;，然后&lt;/span&gt;mv&lt;span&gt;或更改&lt;/span&gt;link&lt;span&gt;的方式发布到正式上线目录&lt;/span&gt; &lt;span&gt;，不需要重启&lt;/span&gt;http&lt;span&gt;服务。这是新朗，赶集的上线方案。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.5.5 JAVA&lt;span&gt;程序代码上线的具体方案&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;java&lt;span&gt;上线方法&lt;/span&gt;:&lt;span&gt;较大公司需要分组平滑上线（如从负载均衡器上摘掉一半的服务器），发布代码后，重启服务器测试，没问题后，挂上上好线的一半，再下另外一半。如果前端有&lt;/span&gt;DNS&lt;span&gt;智能解析，上线还可以分地区上线若干服务器，逐渐普及到全国的服务器，这个被称为“灰度发布”，在后面门户网站上线的知识里我们在讲解。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.5.6 &lt;span&gt;代码上线解决方案注意事项&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:fsharp;gutter:false;&quot;&gt;
 1).上线的流程里，办公室测试环境--&amp;gt;IDC测试环境--&amp;gt;正式生产环境，所有环境中的所有软件均应版本统一，其次尽量单一，否则将后患无穷，开发测试成功，IDC测试就可能有问题（如:操作系统，web服务器，jdk,php,tomcat,resin等版本）
 2).开发团队小组办公内部测试环境测试（该测试环境属于开发小组维护，或定时自动更新代码），代码有问题返回给某开发人员重新开发。
 3).有专门的测试工程师，程序有问题直接返回给开发人员（此时返回的一般为程序的BUG，称为BUG库），无问题进行IDC测试
 4).IDC测试由测试人员和运维人员参与，叫IDCtest,进行程序的压力测试，有问题直接返回给开发人员，无问题进行线上环境上线。
 5).数台服务器代码分发上线方案举例（JAVA程序）
  　　 A:假设同业务服务器有6台，将服务器分为A,B两组，A组三台，B组三台，先对A组进行从负载均衡器上平滑下线，B组正常提供服务，避免服务器因上线影响业务。
  　　 B:下线过程是通过脚本将A组服务器从RS池（LVS,NGINX,HAPROXY,F5等均有平滑方案）中踢出，避免负裁均衡器将请求发送给A组服务器（此时的时间应该为网站流量少时，一般为晚上）
  　　 C:将代码分发到A组服务器的站点目录下，对A组服务器上线并重启服务，并由专业的测试人员进行访问测试，测试成功后，挂上A组的服务器，同时下线B组服务器，B组代码上线操作测试等和A组相同，期间也要观察上线提供服务的服务器状况，有问题及时回滚。
6).特别说明：如果是PHP程序，则上线可以简单化，直接将上线代码（最好全量）发布到所有上线服务器的特定目录后，分发完成后，一次性mv或ln到站点目录，当然测试也是少不了的。测试除了人员测试外，还有各种测试脚本测试各个相关业务接口。
7).大多数门户公司的前端页面都已经静态化或者cache了，因此，动态的部分访问平时就不会特别多，流量低谷时就更少了。再加上是平滑上下线，因此基本上
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.6 &lt;span&gt;参考文献&lt;/span&gt;&lt;/h2&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;1.&lt;span&gt;  &lt;/span&gt; https://zh.wikipedia.org/wiki/&lt;span&gt;持續整合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;  &lt;/span&gt; https://www.zhihu.com/question/23444990/answer/89426003&lt;/p&gt;
&lt;p&gt;3.&lt;span&gt;  &lt;/span&gt; https://www.mindtheproduct.com/2016/02/what-the-hell-are-ci-cd-and-devops-a-cheatsheet-for-the-rest-of-us/&lt;/p&gt;
&lt;p&gt;4.&lt;span&gt;  &lt;/span&gt; http://t.cn/RYKgMtc&lt;/p&gt;
&lt;p&gt;5.&lt;span&gt;  &lt;/span&gt; http://www.cnblogs.com/can-H/articles/7346724.html&lt;/p&gt;
&lt;p&gt;6.&lt;span&gt;  &lt;/span&gt; https://www.abcdocker.com/abcdocker/2041&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Fri, 01 Dec 2017 11:31:00 +0000</pubDate>
<dc:creator>惨绿少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clsn/p/7944116.html</dc:identifier>
</item>
<item>
<title>JavaScript（五）：函数（闭包，eval） - why_not_try</title>
<link>http://www.cnblogs.com/why-not-try/p/7944126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/why-not-try/p/7944126.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.函数的申明&lt;/strong&gt;：三种方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;function命令&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数表达式：变量赋值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Function构造函数&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;method 1: function命令&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     console.log('hello function'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;method 2:函数表达式,赋值给变量&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; test1=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){//这是个匿名函数
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     console.log('hello function1'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;};//注意这里有分号
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;method 3:Function构造函数&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; test2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Function(
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     'return &quot;hello function2&quot;'
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;test();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;test1();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; console.log(test2());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171201093231508-581353290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二种方法：函数表达式，如果函数不是匿名函数，而是加上相应的函数名，则只在函数内部有效。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; test3=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; x(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; x;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处有效&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;console.log(test3());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; console.log(x());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错 is not defined;外部访问无效&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以引申可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样：内部和外部均能访问test4&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; test4=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test4(){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; test4;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; console.log(test4());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;好处&lt;/strong&gt;：可以在函数体内部调用自身；方便排错（除错工具显示函数调用栈时，一层一层往上抛，将显示函数名，而不是匿名函数）&lt;/p&gt;

&lt;p&gt;第三种方法：Function构造函数：可以&lt;strong&gt;不加new&lt;/strong&gt;，返回结果一样；可以传递多个参数，只有最后的这个参数被当做函数体。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;建议：不要使用该Function构造函数来申明函数！不直观。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; test5=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Function(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     'return &quot;hello Function construct&quot;'
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;效果相当于 不加new&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; var test5=Function(&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     'return &quot;hello Function construct&quot;'&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; );&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; test6=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Function(
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     'a',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数参数&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     'b',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数参数&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     'return a&amp;lt;b ? a: b'&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数体&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; console.log(test5());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hello Function construct&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; console.log(test6(10,100));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数可以重复申明，但是后申明的函数会覆盖前面申明的函数。而且由于函数名的提升，前面的函数在任何时候均无效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一等公民&lt;/strong&gt;：因为函数&lt;strong&gt;与其它数据类型的地位平等&lt;/strong&gt;，因此称作第一等公民！&lt;/p&gt;
&lt;p&gt;JavasScript将函数看作一种值，与数值、字符串、布尔值等等其它值地位相等。凡是可以使用值的地方，均能使用函数。如：将函数赋值给变量；将函数赋值给对象的属性（键）；将函数作为参数传入其它函数；将函数作为另一个函数的返回结果！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; console.log('函数是第一等公民'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; print(s){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    console.log(s);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将函数赋值给变量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; test7=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     console.log('将函数赋值给变量'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将函数赋值给对象的属性&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     x:1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    y:print
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将函数作为参数传入另一个函数;将函数作为另一个函数结果返回&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; test8(print){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; print;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; print('haha---'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;test7();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; obj.y('xixi---'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; test8(print)('nicai---');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171201101738492-1398187396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数名的提升&lt;/strong&gt;：JavaScript引擎将函数名等同视为变量名，所以采用function命令申明函数时，&lt;strong&gt;函数会像变量提升一样，提升至代码头部&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; test9();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于函数申明之后，然后调用&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; test9(){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     console.log('test 9'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171201103320508-345406699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面相当于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; test9(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     console.log('test 9'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; test9();
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 01 Dec 2017 11:20:00 +0000</pubDate>
<dc:creator>why_not_try</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/why-not-try/p/7944126.html</dc:identifier>
</item>
</channel>
</rss>