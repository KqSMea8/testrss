<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>vue计算属性详解——小白速会 - 柴小智</title>
<link>http://www.cnblogs.com/chaixiaozhi/p/8688820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaixiaozhi/p/8688820.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、什么是计算属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模板内的表达式非常便利，但是设计它们的初衷是用于&lt;strong&gt;简单运算的&lt;/strong&gt;。在模板中放入太多的逻辑会让模板过重且难以维护。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  {{ message.split('').reverse().join('') }}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的表达式包含3个操作，并不是很清晰，所以遇到复杂逻辑时应该使用Vue特带的计算属性computed来进行处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、计算属性的用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们把上面的例子用计算属性的方式重写一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Original message: &quot;{{ message }}&quot;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;　　//我们把复杂处理放在了计算属性里面了&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;'#example'&lt;span&gt;,
    data: {
        message: &lt;/span&gt;'Hello'&lt;span&gt;
    },
    computed: {&lt;/span&gt;
        reversedMessage: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; `this` 指向 vm 实例&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.message.split('').reverse().join(''&lt;span&gt;)
        }
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div id=&quot;example&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;Original message: &quot;Hello&quot;&lt;/p&gt;
&lt;p&gt;Computed reversed message: &quot;olleH&quot;&lt;/p&gt;

&lt;p&gt;除了上例简单的用法，&lt;strong&gt;计算属性还可以依赖多个Vue 实例的数据，&lt;/strong&gt;只要其中任一数据变化，计算属性就会重新执行，视图也会更新。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;add()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;补充货物1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;总价为：{{price}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({        
       el: &lt;/span&gt;'#app'&lt;span&gt;, 
   data: {
       package1: {
           count: &lt;/span&gt;5&lt;span&gt;,
           price: &lt;/span&gt;5&lt;span&gt;
       },
       package2: {
           count: &lt;/span&gt;10&lt;span&gt;,
           price: &lt;/span&gt;10&lt;span&gt;
       }
    },
    computed: {
     price: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.package1.count*&lt;span&gt;this&lt;/span&gt;.package1.price+&lt;span&gt;this&lt;/span&gt;.package2.count*&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.package2.price　　&lt;span&gt;//总价随着货物或价格的改变会重新计算&lt;/span&gt;
     }
    },
    methods: {   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象的方法&lt;/span&gt;
        add: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.package1.count++&lt;span&gt;
        }
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;计算属性还有两个很实用的小技巧容易被忽略：&lt;strong&gt;一是计算属性可以依赖其他计算属性;  二是计算属性不仅可以依赖当前Vue 实例的数据，还可以依赖其他&lt;span&gt;实例的数据&lt;/span&gt;，&lt;/strong&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ reverseText}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
   el: &lt;/span&gt;'#app1'&lt;span&gt;,
 data: {
      text: &lt;/span&gt;'computed'&lt;span&gt;
    }
});

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;'#app2'&lt;span&gt;,
    computed: {
        reverseText: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;app1&lt;/span&gt;.text.split('').reverse().join('');  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用app1的数据进行计算&lt;/span&gt;
&lt;span&gt;        }
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div id=&quot;example&quot; readability=&quot;31&quot;&gt;
&lt;p&gt;每一个计算属性都包含一个getter 和一个setter ，我们上面的两个示例都是计算属性的默认用法， 只是利用了getter 来读取。&lt;/p&gt;
&lt;p&gt;在你需要时，也可以提供一个setter 函数， 当手动修改计算属性的值就像修改一个普通数据那样时，就会触发setter 函数，执行一些自定义的操作，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;var vm = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; Vue({
    el: '#demo'&lt;span data-mce-=&quot;&quot;&gt;,
    data: {
        firstName: 'Foo'&lt;span data-mce-=&quot;&quot;&gt;,
        lastName: 'Bar'&lt;span data-mce-=&quot;&quot;&gt;
    },
    computed: {
        fullName: {
            &lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt;//&lt;/span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt; getter&lt;/span&gt;
            get: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; () {
                &lt;span data-mce-=&quot;&quot;&gt;return &lt;span data-mce-=&quot;&quot;&gt;this.firstName + ' ' + &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.lastName
            },
            &lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt;//&lt;/span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt; setter&lt;/span&gt;
            set: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; (newValue) {
                &lt;span data-mce-=&quot;&quot;&gt;var names = newValue.split(' '&lt;span data-mce-=&quot;&quot;&gt;);
                &lt;span data-mce-=&quot;&quot;&gt;this.firstName = names[0&lt;span data-mce-=&quot;&quot;&gt;];
                &lt;span data-mce-=&quot;&quot;&gt;this.lastName = names[names.length - 1&lt;span data-mce-=&quot;&quot;&gt;];
            }
        }
    }
});
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt;现在再运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;绝大多数情况下，我们只会用默认的getter 方法来读取一个计算属性，在业务中很少用到setter,所以在声明一个计算属性时，可以直接使用默认的写法，不必将getter 和setter 都声明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、计算属性缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的例子，除了使用计算属性外，我们也可以通过在表达式中调用方法来达到同样的效果，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{reverseTitle()}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在组件中&lt;/span&gt;
&lt;span&gt;methods: {
  reverseTitle: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.title.split('').reverse().join(''&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以将同一函数定义为一个方法而不是一个计算属性，两种方式的最终结果确实是完全相同的。只是一个使用&lt;span&gt;reverseTitle()&lt;/span&gt;取值，一个使用&lt;span&gt;reverseTitle&lt;/span&gt;取值。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;然而，不同的是&lt;strong&gt;计算属性是基于它们的依赖进行缓存的&lt;/strong&gt;。&lt;span&gt;计算属性只有在它的相关依赖发生改变时才会重新求值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就意味着只要 title还没有发生改变，多次访问 reverseTitle计算属性会立即返回之前的计算结果，而不必再次执行函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个小例子：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{reverseTitle}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{reverseTitle1()}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;add()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;补充货物1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;总价为：{{price}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    computed: {
      reverseTitle: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.title.split('').reverse().join(''&lt;span&gt;)　　&lt;span&gt;//而使用计算属性，只要title没变，页面渲染是不会重新进这里来计算的，而是使用了缓存。&lt;/span&gt;
      },
     price: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.package1.count*&lt;span&gt;this&lt;/span&gt;.package1.price+&lt;span&gt;this&lt;/span&gt;.package2.count*&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.package2.price
     }
    },
    methods: {   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象的方法&lt;/span&gt;
        add: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.package1.count++&lt;span&gt;
        },
        reverseTitle1: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.title.split('').reverse().join(''&lt;span&gt;)　　&lt;span&gt;//点击补充货物，也会进这个方法，再次计算。不是刷新，而是只要页面渲染，就会进方法里重新计算。&lt;/span&gt;
        }
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相比之下，每当触发重新渲染时，调用方法将&lt;strong&gt;总会&lt;/strong&gt;再次执行函数。 &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 &lt;strong&gt;A&lt;/strong&gt;，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 &lt;strong&gt;A&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;如果没有缓存，我们将不可避免的多次执行 &lt;strong&gt;A&lt;/strong&gt; 的 getter！如果你不希望有缓存，请用方法来替代。&lt;/p&gt;

</description>
<pubDate>Sun, 01 Apr 2018 23:37:00 +0000</pubDate>
<dc:creator>柴小智</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaixiaozhi/p/8688820.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 Canvas 实现的文字动画特效 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/8609542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/8609542.html</guid>
<description>&lt;p&gt;文字是网页中最基本的元素，一般我们在网页上都是展示的静态文字，但是就效果来说，还是比较枯燥的。文字淡入淡出的动画效果在项目中非常实用，如果有某些关键的文字，可以通过这种动态的效果来提醒用户阅读。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201803/591709-20180320161217871-1782454002.gif&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个 Demo 是不断重复地设置文字的大小和透明度，这些英文字母也是我自己利用 HT 的矢量绘制的，总的来说效果还是不错的。&lt;/p&gt;

&lt;p&gt;代码总共一百来行，比较简单，前面说过我的英文字母是用矢量绘制的，用矢量绘制图形的好处非常多，比如图片缩放不会失真，这样在不同的 Retina 显示屏上我也不需要提供不同尺寸的图片；还有就是用 JSON 的方式来描述矢量，格式比较简洁等等。&lt;/p&gt;
&lt;h2&gt;矢量图片&lt;/h2&gt;
&lt;p&gt;接下来绘制这些矢量图片（这里只拿出第一个 H 进行说明）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48.265917602996&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;width&quot;: 10,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置矢量的宽&lt;/span&gt;
    &quot;height&quot;: 10,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置矢量的高&lt;/span&gt;
    &quot;comps&quot;: [&lt;span&gt;//&lt;/span&gt;&lt;span&gt;矢量图形的组件Array数组，每个数组对象为一个独立的&lt;a href=&quot;http://hightopo.com/guide/guide/core/vector/ht-vector-guide.html#ref_type&quot; target=&quot;_blank&quot;&gt;组件类型&lt;/a&gt;，数组的顺序为组件绘制先后顺序&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&quot;type&quot;: &quot;text&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本类型&lt;/span&gt;
        &quot;text&quot;: &quot;H&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本内容&lt;/span&gt;
        &quot;color&quot;: &quot;rgb(69,69,69)&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本颜色&lt;/span&gt;
        &quot;align&quot;: &quot;center&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本在矢量中的对齐方式&lt;/span&gt;
        &quot;opacity&quot;: {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本透明度&lt;/span&gt;
            &quot;func&quot;: &quot;attr@text.opacity&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置业务属性，对文本进行透明度的数据绑定&lt;/span&gt;
            &quot;value&quot;: 1&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果func中的值为空或者undefined，那么就直接用这个值&lt;/span&gt;
&lt;span&gt;        },
        &lt;/span&gt;&quot;clipDirection&quot;: &quot;bottom&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;裁切方向为“从上到下”&lt;/span&gt;
        &quot;rect&quot;: [&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定组件绘制在矢量中的矩形边界&lt;/span&gt;
            0,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代表左上角坐标x&lt;/span&gt;
            0,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代表左上角坐标y&lt;/span&gt;
            10,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代表组件的width&lt;/span&gt;
            10&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代表组件的height&lt;/span&gt;
&lt;span&gt;        ]
    }]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;绘制矢量图形是通过 JSON 格式来书写的，主要的参数有三个：width、height 以及 comps。这三个参数都必须要写上，其中 width 为矢量图形的宽度，height 为矢量图形的高度，comps 里面是一个 Array 数组，数组中是一个个独立的对象，可以对这个对象设置一些预定义参数，也可设置一些可选的参数信息。&lt;/p&gt;
&lt;p&gt;这里我将所有的文本信息存储在一个数组中，方便调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
arr =&lt;span&gt; [
    {label: &lt;/span&gt;'H', image: 'symbols/H.json'&lt;span&gt;},
    {label: &lt;/span&gt;'T', image: 'symbols/T.json'&lt;span&gt;},
    {label: &lt;/span&gt;'f', image: 'symbols/f.json'&lt;span&gt;},
    {label: &lt;/span&gt;'o', image: 'symbols/o.json'&lt;span&gt;},
    {label: &lt;/span&gt;'r', image: 'symbols/r.json'&lt;span&gt;},
    {label: &lt;/span&gt;'W', image: 'symbols/W.json'&lt;span&gt;},
    {label: &lt;/span&gt;'e', image: 'symbols/e.json'&lt;span&gt;},
    {label: &lt;/span&gt;'b', image: 'symbols/b.json'&lt;span&gt;},
];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个 label 对象为矢量图形的名称，第二个 image 对象我们设置的是 json 格式的图片，但是实际上可以为 img、canvas 对象或图片 url 或 base64 字符串。&lt;/p&gt;
&lt;h2&gt;创建节点对象&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180401184745130-242742834.png&quot; alt=&quot;&quot; width=&quot;68&quot; height=&quot;80&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对象的图片已经生成，接下来就是创建对象了，这里英文字母总共 8 个，那么我们创建 8 个节点对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;p&gt;  var s = 80;&lt;br/&gt;  arr.forEach(function(obj, index) {&lt;br/&gt;      var text = obj.label;&lt;br/&gt;      name = 't' + text;&lt;br/&gt;      window[name] = createNode(obj.image, 100+s*index, 100);&lt;br/&gt;  });&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function createNode(image, x, y) {//节点对象声明
    var node = new ht.Node();//这个类为 ht 中定义的节点
    node.setSize(0, 0);//设置节点大小
    if(image) node.setImage(image);//设置节点图片
    if(x &amp;amp;&amp;amp; y) node.setPosition(x, y);//设置节点摆放位置
&lt;span&gt;
    dm.add(node);//将节点添加进数据容器 datamodel 中
    return&lt;span&gt; node;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于上面的 ht.Node 节点的生成，其实这个只是 HT 封装好的类，这个类上面有很多很方便的 API。然后将这个生成的节点添加进数据容器 dm 中，这个数据容器又是整个拓扑图 gv 的数据容器。&lt;/p&gt;
&lt;h2&gt;拓扑图生成&lt;/h2&gt;
&lt;p&gt;来看看如何生成这个拓扑图吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
dm = &lt;span&gt;new&lt;/span&gt; ht.DataModel();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据容器&lt;/span&gt;
gv = &lt;span&gt;new&lt;/span&gt; ht.graph.GraphView(dm);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拓扑图 通过 gv.getView() 可获得这个拓扑图的底层 div&lt;/span&gt;
gv.addToDOM();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将 gv 添加进 body 中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上 HT 的原理就是在一个 div 中的 canvas 上绘制图形，也就是说这个 gv 就是一个 canvas。&lt;/p&gt;
&lt;p&gt;然后通过 getView 获取这个 canvas 的底层 div，这样我们就能将这个 div 添加到 html 页面的任何地方了，addToDOM 的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
addToDOM = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){   
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
        view &lt;/span&gt;= self.getView(),   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取底层div&lt;/span&gt;
        style =&lt;span&gt; view.style;
    document.body.appendChild(view);      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将底层div添加到body中      &lt;/span&gt;
    style.left = '0';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为 HT 默认将组件的position设置为absolute 所以要设置位置&lt;/span&gt;
    style.right = '0'&lt;span&gt;;
    style.top &lt;/span&gt;= '0'&lt;span&gt;;
    style.bottom &lt;/span&gt;= '0'&lt;span&gt;;      
    window.addEventListener(&lt;/span&gt;'resize', &lt;span&gt;function&lt;/span&gt; () { self.iv(); }, &lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口大小变化触发事件，调用最外层组件invalidate（即iv）函数进行更新。&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在刷新页面，你会看到一片空白，为什么？因为前面设置节点的大小为 0 啊，怎么会显示，这个 Demo 的效果就是从无到有，又从有到无。那接下来看看如何“从无到有”。&lt;/p&gt;
&lt;h2&gt;文本动画&lt;/h2&gt;
&lt;p&gt;就像我刚刚说过的，要想让节点显示，肯定是需要设置节点的大小为我们肉眼可视的范围才会出现，但是我的目的不仅是从无到有，也是从小到大，这个能够一气呵成么？感觉好像代码内容简单，但是代码量却不小的一个任务，我定义了一个函数用来将节点从无到有，从小到大：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
function&lt;span&gt; setSize(node) {
    if&lt;span&gt;(node) {
         var s = 80&lt;span&gt;,
              size = node.getSize().width;//获取节点当前的大小中的宽度，因为我知道宽高都是一样的，所以简写了
        var sw = s -&lt;span&gt; size;
        ht.Default.startAnim({//HT 封装的动画函数，内容也是 JSON 格式的对象
            duration: 1000,// 动画周期毫秒数
            easing: function(t) { return t*t },//动画缓动函数
            action: function(v, t) {//action函数必须提供，实现动画过程中的属性变化 第一个参数v代表通过easing(t)函数运算后的值，t代表当前动画进行的进度[0~1]，一般属性变化根据v参数进行 
                node.setSize(//设置节点的大小  (有一个缓动的过程 通过 sw*v 实现的)
                    size + sw*&lt;span&gt;v, 
                    size + sw*&lt;span&gt;v 
                ); 
            } 
        }); 
    } 
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从大到小，从有到无的过程也跟上面类似，我就不赘述了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201803/591709-20180320161217871-1782454002.gif&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;72&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要让这些字母按照时间的先后顺序出现和消失，肯定需要用到 setTimeout 方法，要想实现一次的显示消失是非常容易的，但是我在实现的过程掉到了 setTimeout 的一个陷阱中，只能说自己学艺不精吧。因为我们需要给不同的字母设置不同的出现和消失时间，一般比较简单的方法就是设置一个固定的值，然后乘以对应节点专属的 index：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
function&lt;span&gt; animateIn() {
    for(let i = 0; i &amp;lt; arr.length; i++&lt;span&gt;) {
        var name = 't' +&lt;span&gt; arr[i];
    animateLetterIn(window[name], i);//这个部分设置动画
&lt;span&gt;    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可是如果我直接在 for 循环中设置 setTimeout 的时间为动态变化的，那么这个动态变化的值肯定是只取 for 循环的最后一个值，所以我将 setTimeout 的方法抽取出来作为一个单独的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
function&lt;span&gt; animateLetterIn(node, i) {
    setTimeout(function&lt;span&gt;() {
        setSize(node);
    }, i * 200);//这时候这个 i 取的就是节点对应的 i 而不是最后一个值了

    if(i === arr.length - 1) {//当节点为最后一个节点时，设置节点淡出动画
        setTimeout(function&lt;span&gt;() {
        animateOut();//节点淡出动画
    }, (arr.length + 3) * 200&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;节点淡出动画也是类似的方法，只是需要循环调用这些动画函数，这样才能做到无限循环字母的大小控制。&lt;/p&gt;

</description>
<pubDate>Sun, 01 Apr 2018 23:31:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/8609542.html</dc:identifier>
</item>
<item>
<title>外部 Storage Provider - 每天5分钟玩转 Docker 容器技术（149） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8685547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8685547.html</guid>
<description>&lt;p&gt;&lt;span&gt;如果 Kubernetes 部署在诸如 AWS、GCE、Azure 等公有云上，可以直接使用云硬盘作为 Volume，下面是 AWS Elastic Block Store 的例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180401071224235-1320839316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要在 Pod 中使用 ESB volume，必须先在 AWS 中创建，然后通过 volume-id 引用。其他云硬盘的使用方法可参考各公有云厂商的官方文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kubernetes Volume 也可以使用主流的分布式存，比如 Ceph、GlusterFS 等，下面是 Ceph 的例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180401071237044-1985625861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Ceph 文件系统的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/some/path/in/side/cephfs&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 目录被 mount 到容器路径 /test-ceph。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相对于 emptyDir 和 hostPath，这些 Volume 类型的最大特点就是不依赖 Kubernetes。Volume 的底层基础设施由独立的存储系统管理，与 Kubernetes 集群是分离的。数据被持久化后，即使整个 Kubernetes 崩溃也不会受损。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，运维这样的存储系统通常不是项简单的工作，特别是对可靠性、高可用和扩展性有较高要求时。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Volume 提供了非常好的数据持久化方案，不过在可管理性上还有不足。下一节我们将学习具有更高管理性的存储方案：PersistentVolume &amp;amp; PersistentVolumeClaim。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;书籍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Kubernetes》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/26225745440.html&quot;&gt;https://item.jd.com/26225745440.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 21:33:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8685547.html</dc:identifier>
</item>
<item>
<title>聊聊阿里面试的三个层次 - 陈树义</title>
<link>http://www.cnblogs.com/chanshuyi/p/alibaba_review_3_level.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanshuyi/p/alibaba_review_3_level.html</guid>
<description>&lt;p&gt;最近去阿里的菜鸟国际做了一次面试交流，发现大公司对于面试者的知识结构考核非常严谨，可以作为我们日常工作学习的指导。虽然很多人说面试问到的东西在实际工作中很少用到，甚至有「面试造火箭，工作拧螺丝」的说法。但从面试中，其实可以看得出来现在的公司对于面试者的知识体系要求。如果我们能在工作中就按着这样的要求去不断提升，那么在面试的时候必然也能游刃有余。&lt;/p&gt;
&lt;p&gt;一般来说，阿里的面试会有两轮的技术电面，分别交叉检验你的技术基础。后面还有两轮的现场技术面试，主要检验你的项目经验。但从知识体系的角度来看，阿里面试对于知识的考核可以分为三个层次：&lt;strong&gt;对于基础知识的考核、对于项目经验的考核、对于项目深度的考核。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础知识考核&quot;&gt;基础知识考核&lt;/h2&gt;
&lt;p&gt;在这个层次上，主要考核你对 Java 语言本身原理的理解以及各种框架的原理理解。&lt;/p&gt;
&lt;p&gt;对于 Java 开发岗位上来说，这些知识点包括但不限于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集合 HashMap 的原理，与 Hashtable、ConcurrentHashMap 的区别？&lt;/li&gt;
&lt;li&gt;Java 线程池的核心属性以及处理流程&lt;/li&gt;
&lt;li&gt;Java 并发包原理、Synchronized关键字、锁&lt;/li&gt;
&lt;li&gt;线程的生命周期&lt;/li&gt;
&lt;li&gt;JVM类加载机制&lt;/li&gt;
&lt;li&gt;JVM内存模型&lt;/li&gt;
&lt;li&gt;JVM分代以及垃圾回收机制&lt;/li&gt;
&lt;li&gt;Spring Bean 容器生命周期&lt;/li&gt;
&lt;li&gt;Spring AOP 原理&lt;/li&gt;
&lt;li&gt;Dubbo 请求流程以及原理&lt;/li&gt;
&lt;li&gt;数据库 SQL 优化、数据库索引、索引原理&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面只是说了很少的一部分而已，如果想查看更多，可以点击&lt;a href=&quot;https://mp.weixin.qq.com/s/hiIBQu6mAPzYa7QgTNacUA&quot;&gt;Java面试通关要点&lt;/a&gt;了解更多。&lt;/p&gt;
&lt;p&gt;看到这么多的知识点，我一下子就懵逼了，这么多得看到什么时候才看得完啊？但后面我想明白了，其实你不需要全部都懂，但需要了解大部分知识点，并且在这大部分知识点中，还需要有部分是了解得非常深入的。如果达到这个水平，基本上都能通过考核。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于基础知识的考核多出现在阿里的前两轮电话面试上。对于这块，你事前把网上常见的面试题目看一遍，多面试几次基本上都没有问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目理解程度&quot;&gt;项目理解程度&lt;/h2&gt;
&lt;p&gt;当你成功通过基础知识的考核之后，你会进入下一关的考验：项目的理解程度。&lt;/p&gt;
&lt;p&gt;面试官首先会让你选择一个你最拿手的项目，画出架构图，之后的一切问题都从这个架构图触发。当你画出架构图之后，你肯定需要解释清楚每个模块的作用，每个框架的原理以及与其他框架的区别。&lt;/p&gt;
&lt;p&gt;例如我就用我做过的一个搜索项目作为经典项目，与面试官探讨。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;项目中用到了 Kafka 这个框架，那么面试官就会问 Kafka 和 RocketMQ 之间的区别是什么，它们两个有什么不同？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;项目中还用到了 Canal 这个阿里巴巴开源的框架，那么面试官自然会问这个东西是干嘛的，原理是怎样的？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;项目中还用到了 Zookeeper 作为协调者，那么 Zookeeper 在这个项目中的作用是什么，扮演了什么角色？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;对于「项目理解程度」的考核会发生在技术面试的三四轮。在这个层次上，你必须要有一个拿得出手的项目，并且对其中的所有框架以及原理都了如指掌，否则你会被虐惨。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目思考深度&quot;&gt;项目思考深度&lt;/h2&gt;
&lt;p&gt;通过上一轮对于「项目理解程度」的考核后，基本上你对整个项目都会有一个全面的认识，应用层面上的问题基本上不会难倒你了。但在「项目思考深度」的考核上，就不仅仅只是考核应用层面上的问题了。&lt;/p&gt;
&lt;p&gt;还是用我做过的一个搜索项目作为例子，其中 Canal 这个开源框架暂时是没有实现集群这个功能的，那么面试官就问了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你如何去改造这个项目，从而实现 Canal 的集群功能？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个时候，你会发现你懵逼了，因为你从来没有去思考过这个问题。你所有的工作内容都是在想如何使用开源框架，而没有进一步思考这些开源框架好不好，有什么可以改进的地方。&lt;/p&gt;
&lt;p&gt;所以，在这一个层次上考核的是你对开源框架的思考深度，这些框架到底好不好，好在哪里，不好在哪里，有什么可以改进的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于「项目思考深度」的考核同样发生在技术面试的三四轮。在这个层次上，你不仅要对项目本身理解足够深刻，还要跳出项目本身，去思考开源框架本身的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;当我们回过头来总结，你会发现这三个层次都是层层递进的，而且逐步深入。虽然这是面试中总结出来的经验，但是这却是一个很好的学习指引。读者可以自己自查，看看自己现在是处于哪个层次，这样在工作中也可以不断地向更高层次迈进。&lt;/p&gt;
&lt;p&gt;对于我来说，我缺乏的是对于项目的思考深度，很多时候都是业界觉得好，那我就用了。但是作为一个高级开发，甚至是一个即将成为架构师的高级开发来说，你必须知道为什么要用这些框架？它有什么问题，我们能不能做得更好？只有这样，我们才能有所成长。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 16:56:00 +0000</pubDate>
<dc:creator>陈树义</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chanshuyi/p/alibaba_review_3_level.html</dc:identifier>
</item>
<item>
<title>构建微服务开发环境1————如何安装JDK - 云开发</title>
<link>http://www.cnblogs.com/cloud-dev/p/gou-jian-wei-fu-wu-kai-fa-huan-jing1ru-he-an-zhuan.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloud-dev/p/gou-jian-wei-fu-wu-kai-fa-huan-jing1ru-he-an-zhuan.html</guid>
<description>&lt;p&gt;【内容指引】&lt;br/&gt;下载JDK；&lt;br/&gt;Mac系统安装JDK；&lt;br/&gt;Mac系统配置环境变量；&lt;br/&gt;Windows系统安装JDK；&lt;br/&gt;Windows系统配置环境变量。&lt;/p&gt;
&lt;h2 id=&quot;toc_0&quot;&gt;一、下载JDK&lt;/h2&gt;
&lt;p&gt;1.访问Oracle官网 &lt;a&gt;http://www.oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002847189-1463966237.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;浏览到首页的底部菜单 ,然后如下图所示点击链接“Download Java for developers”:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402003044775-333390475.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;2.目前最新版JDK是“Java SE 10”。这里我们以安装“Java SE 8u161”为例演示JDK安装方法，点击下图所示“JDK DOWNLOAD”按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002848691-731017998.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;3.选择“Accept Lisence Agreement”同意协议:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002849737-1910017533.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;4.下载链接JDK：&lt;br/&gt;根据你的电脑操作系统选择适用的JDK。如下图所示，分别是64位Mac系统和64位Windows系统的JDK，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002848956-861669200.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;二、Mac系统安装JDK&lt;/h2&gt;
&lt;p&gt;1.下载完成后点击安装包，按提示即可完成安装：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002850159-2002439726.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002856222-1573747155.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002856644-667767967.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002859472-1719513538.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002902972-89730485.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;2.打开Finder,可以在下图所示的路径中找到安装好的jdk 1.8.0_161.jdk:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002903368-102142406.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;3.其中Contents下的Home文件夹，是该JDK的根目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002907565-1170254198.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;bin目录&lt;/em&gt;&lt;/span&gt;下存放JDK用于开发的一些终端命令工具。常见的工具如：&lt;br/&gt;“javac”的作用是将java源文件编译为class文件(即自解码文件)；&lt;br/&gt;“java”命令的作用是运行class文件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;db目录&lt;/em&gt;&lt;/span&gt;下是java开发的一个开源的关系型数据库；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;include目录&lt;/em&gt;&lt;/span&gt;下是一些C语言的头文件；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;jre目录&lt;/em&gt;&lt;/span&gt;下JDK所依赖的java运行时；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;lib目录&lt;/em&gt;&lt;/span&gt;下存放JDK开发工具所依赖的一些库文件；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;man目录&lt;/em&gt;&lt;/span&gt;下存放JDK开发工具的说明文档。&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;三、Mac系统配置环境变量&lt;/h2&gt;
&lt;p&gt;1.在英文输入法的状态下，按键盘“Command + 空格”组合键，调出聚焦搜索，在这里可以快速启动终端，输入ter,然后回车，即可打开终端：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002905192-43128193.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002906972-1234137245.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;2.如果你是第一次配置环境变量，可以使用“touch .bash_profile” 创建一个.bash_profile的隐藏配置文件(如果你是编辑已存在的配置文件，则直接使用&quot;open -e .bash_profile&quot;命令)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002909506-1966428132.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;3.输入“open -e .bash_profile”命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002914362-135615110.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;4.输入如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/&lt;span&gt;Home
PATH&lt;/span&gt;=\(JAVA_HOME/&lt;span&gt;bin:\)PATH:.
CLASSPATH&lt;/span&gt;=\(JAVA_HOME/lib/tools.jar:\)JAVA_HOME/lib/&lt;span&gt;dt.jar:.
export JAVA_HOME
export PATH
export CLASSPATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后保存关闭该窗口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002912081-1283281692.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;5.使用&quot;source .bash_profile&quot;使配置生效，然后输入”java -version”，如果看到jdk版本为1.8则说明配置已经生效：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002916237-1715291936.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;四、Windows系统安装JDK&lt;/h2&gt;
&lt;p&gt;1.下载完成后点击安装包，按提示即可完成安装：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002915973-1238596641.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002919472-654913303.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002920862-1988433408.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002920611-2008739148.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002922675-178450630.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002922103-1049471589.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002924362-1552587821.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;五、Windows系统配置环境变量&lt;/h2&gt;
&lt;p&gt;1.打开我的电脑，按照如下操作顺序：“鼠标右键--&amp;gt;属性--&amp;gt;高级系统设置--&amp;gt;高级--&amp;gt;环境变量”:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002923910-1247270280.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;2.在选择环境变量过后，我们可以看到如下界面，此时再选择“系统变量--&amp;gt;新建”，此时将会弹出新建系统变量的对话框，在变量名处输入“JAVA_HOME”，在变量值中输入JAVA的安装路径，点击确定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002923498-1849747359.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;3.在完成上一步之后，继续在环境变量中双击Path，将会弹出“编辑环境变量”的对话框，在原有路径中加入以下内容：“%JAVA_HOME%\bin;”，之后点击确定，JAVA的环境变量就算是配置完成了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402002927378-764797329.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;4.检验环境变量是否配置成功&lt;br/&gt;经过上述步骤，我们想要知道是否已经成功搭建起了JAVA的开发环境，于是我们进入DOS窗口，输入&quot;java -version&quot;,显示java版本为“1.8.0_161”则代表JAVA开发环境已搭建成功！&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 16:30:00 +0000</pubDate>
<dc:creator>云开发</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloud-dev/p/gou-jian-wei-fu-wu-kai-fa-huan-jing1ru-he-an-zhuan.html</dc:identifier>
</item>
<item>
<title>ES6 --------- const - gxlself</title>
<link>http://www.cnblogs.com/gxlself/p/8689224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gxlself/p/8689224.html</guid>
<description>&lt;p&gt;对于es6使用的也挺频繁,但是有些东西真的使用得注意:&lt;/p&gt;
&lt;p&gt;const使用注意:&lt;/p&gt;
&lt;p&gt;　　1. 声明的变量不能再被声明,或者改变值类型,否则将会报错.报错的信息分别是:&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;pre class=&quot;syntaxbox&quot;&gt;
TypeError: invalid assignment to const &quot;x&quot; (Firefox)
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre class=&quot;syntaxbox&quot;&gt;
TypeError: Assignment to constant variable. (Chrome)
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre class=&quot;syntaxbox&quot;&gt;
TypeError: Redeclaration of const 'x' (IE/Edge)
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　eg: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const a = 2;&lt;br/&gt;a = 3;&lt;br/&gt;// 将会报上述类型错误(具体和李玉兰器有关)&lt;br/&gt;const a = 3;&lt;br/&gt;// Uncaught SyntaxError: Identifier 'c' has already been declared&lt;br/&gt;// 重新声明也会报错,提示你c已经被声明
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2. const声明的引用类型,虽然变量不可变,但是对象内部却可以被影响,这一点如果不注意,在开发中就会很尴尬~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const a = {&lt;br/&gt;　　name : 'Mike'&lt;br/&gt;}&lt;br/&gt;a.name = 'Tom'&lt;br/&gt;// 此时a的属性name的值已经改变&lt;br/&gt;console.log(a)&lt;br/&gt;//{name: &quot;Tom&quot;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同理:数组也是&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
const a = [1,2,3]&lt;br/&gt;a.shift()&lt;br/&gt;console.log(a)&lt;br/&gt;// [2,3]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3. const也存在块级作用域,作用域内声明的变量可以与全局变量同名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const a = 5&lt;span&gt;;
   console.log(a)
   &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(){
        const a &lt;/span&gt;= 3&lt;span&gt;
        console.log(a)
   }
   test()

   {
       const a &lt;/span&gt;= 4&lt;span&gt;;
       console.log(a)
   }&lt;p&gt;分别输出: 5   3   4&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　总结:&lt;/p&gt;
&lt;p&gt;　　　　const声明的变量是唯一的(同一作用域),它声明的值类型不可变,引用类型却可以改变...&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 16:01:00 +0000</pubDate>
<dc:creator>gxlself</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gxlself/p/8689224.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构（数组篇01） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8686676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8686676.html</guid>
<description>&lt;p&gt;　　 在开始正式的内容之前，不得不说说js中的数据类型和数据结构，以及一些比较容易让人混淆的概念。那么为什么要从数组说起？数组在js中是最常见的内存数据结构，数组数据结构在js中拥有很多的方法，很多初学者记不清数组的大多数用法，只知道push，pop，shift等最基本的几个。所以，本系列（数组篇）会尽可能的让大家对数组有一个透彻的了解。也方便后面其他数据结构的学习和使用。&lt;/p&gt;
&lt;p&gt;　　 可能很多web前端开发者都会有一个疑问，那就是，数组和对象究竟是数据类型？还是数据结构？那么我们就带着这样的疑问，开始下面的学习，希望看完这篇文章之后，你模糊的概念会变得清晰一些。&lt;/p&gt;
&lt;p&gt; 　　首先，在js中，数据类型分为两种，&lt;strong&gt;基本类型&lt;/strong&gt;（原始类型）和复杂类型，其中，基本类型是：&lt;strong&gt;String&lt;/strong&gt;（字符串），&lt;strong&gt;Number&lt;/strong&gt;（数值），&lt;strong&gt;Boolean&lt;/strong&gt;（布尔值），还有&lt;strong&gt;undefined&lt;/strong&gt;和&lt;strong&gt;null&lt;/strong&gt;。复杂类型是&lt;strong&gt;Objecct&lt;/strong&gt;（对象）。&lt;/p&gt;
&lt;p&gt;　　说到这里大家可能会有些疑问，只有这六种类型？那&lt;strong&gt;数组&lt;/strong&gt;（Array），&lt;strong&gt;正则&lt;/strong&gt;（RegExp），&lt;strong&gt;日期&lt;/strong&gt;（Date）算是什么？他们都是Object（对象）的一个分支，换句话说它们都属于Object类型，这也正是js与众不同的地方——万物皆对象。而下面要聊的包括队列，栈，链表，集合，树，图等数据结构在js中的展现方式，也都是通过对象和原型来实现的。本文无意去详细的描述数据类型和数据结构的种类以及在js中的体现形式。所以点到为止。&lt;/p&gt;
&lt;p&gt;　　故事已经开始，请大家系好安全带，跟着我驰骋在在这篇广阔的土地上——&lt;strong&gt;数组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　先解释一下什么是数组吧，所谓数组，&lt;strong&gt;是有序的元素序列&lt;/strong&gt;。&lt;span class=&quot;sup--normal&quot; data-sup=&quot;1&quot;&gt; 若将有限个类型相同的变量的集合命名，那么这个“名”称为数组名。组成数组的各个变量称为数组的分量，&lt;strong&gt;也称为数组的元素&lt;/strong&gt;，有时也称为下标变量。&lt;strong&gt;用于区分数组的各个元素的数字编号称为下标&lt;/strong&gt;。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起来的一种形式。&lt;span class=&quot;sup--normal&quot; data-sup=&quot;1&quot;&gt;这些无序排列的同类数据元素的集合称为数组。简单来说&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;数组就是用于储存多个相同类型数据的集合。（当然，js中的数组也可以存储不同类型数据，但是！不建议这样做！）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　一、数组的创建和初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;相信很多小伙伴都知道创建一个数组十分容易：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arr = [];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样我们就创建了一个数组，我们还可以用new关键字来创建并初始化一个数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个空数组&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; newArr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个指定长度的数组&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; newLenArr = &lt;span&gt;new&lt;/span&gt; Array(4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个具有指定参数的数组&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; numArr = &lt;span&gt;new&lt;/span&gt; Array(1,2,3,4);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然，通过new关键字创建并初始化数组的方式并不推荐，这里只是给大家介绍一下。其实我们通过上面第一种方式来创建数组的本质就是通过new来实例化一个Array对象。OK，这里不多说它的实现原理，还是回到数组本身来吧。&lt;/p&gt;
&lt;p&gt;　　那么我们如何读取数组中的数据呢？很简单，我就一句话带过了，也就是通过中括号（[ ]）arr[2]，来传递数值的位置，获取到对应位置的值，也可以通过这种方式来重新赋值。&lt;/p&gt;
&lt;p&gt;　　二、&lt;strong&gt;数组的增删&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　接下来说说如何使用js数组自带的方法来实现数组头尾的增删：&lt;strong&gt;push(数组尾部插入元素)，unshift(数组头部插入元素)，pop(数组尾部删除元素)和shift(数组头部删除元素)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1、push方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果我不想使用push方法，有没有什么方式可以在数组的尾部插入一个元素呢？其实很简单，我们只需要把值赋给数组中最后一个空位上的元素就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4&lt;span&gt;];
nums[nums.length] &lt;/span&gt;= 5;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们通过length属性，获取该数组的长度是5，但是我们数组对应的下标是从0开始的，通过这样的方式，也就给数组的尾部插入了一个新的元素。当然，其实我们可以更方便的使用push来给数组的尾部插入一个元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4&lt;span&gt;];
nums.push(&lt;/span&gt;5);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也可以得到同样的结果。当然，push也可以传入多个参数，依次的从尾部插入数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4&lt;span&gt;];
nums.push(&lt;/span&gt;5,6,6&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0,1,2,3,4,5,6,6]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、&lt;strong&gt;unshift方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　那么同样的，如何在不使用原生方法的前提下给数组的头部添加一个元素呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5,6&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = nums.length;i &amp;gt;= 0;i--&lt;span&gt;){
  nums[i] &lt;/span&gt;= nums[i - 1&lt;span&gt;];      
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[undefined, 0, 1, 2, 3, 4, 5, 6]&lt;/span&gt;
nums[0] = -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[-1, 0, 1, 2, 3, 4, 5, 6]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实际上，&lt;strong&gt;我们通过循环遍历，把nums数组中的每一位所对应的下标增加一个，也就是向后移动一位，那么这就导致了头部的位置空出（它的位置是存在的），但是此时我们并没有给空出的位置所对应的下标赋值，所以它的长度增加了值确实undefined，赋值之后，才会得到我们想要的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　下面我们还是用unshift方法来给数组的头部插入新值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5&lt;span&gt;];
nums.unshift(&lt;/span&gt;-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[-1, 0, 1, 2, 3, 4, 5]&lt;/span&gt;
nums.unshift(-2,-3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[-2, -3, -1, 0, 1, 2, 3, 4, 5]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么要注意一点，在使用unshift传入多个参数的时候，&lt;strong&gt;他会把第一个参数放在数组的头部（以此类推），也就是说unshift方法会把所有的参数依照顺序插入数组，并不是我们想当然的那样从第一个参数依次添加进数组。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3、&lt;/strong&gt;pop方法&lt;/p&gt;
&lt;p&gt;　　如果我想要删除数组尾部的元素，我们可以使用pop方法，其实我们还是可以用js来模拟一下pop：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5&lt;span&gt;];
nums.length &lt;/span&gt;= nums.length - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0, 1, 2, 3, 4]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以通过手动让数组的长度减少一位，就可以实现删除数组尾部的元素，当然也可以减少两位三位等。&lt;/p&gt;
&lt;p&gt;　　实际上，在日常开发中通常都会使用pop方法来删除数组尾部的元素（&lt;strong&gt;pop()方法没有参数，只是删除数组尾部的元素。&lt;/strong&gt;）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5&lt;span&gt;];
nums.pop()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [0, 1, 2, 3, 4]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;4、shift方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　那么接下来我们看看如何从数组的首位删除元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; nums.length; i++&lt;span&gt;) {
    nums[i] &lt;/span&gt;= nums[i + 1&lt;span&gt;]
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [1, 2, 3, 4, 5, undefined]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，我们最后一位是undefined，也就是说在最后一次的循环里，i + 1引用了一个数组里还未初始化的位置（开辟了空间但是未赋值），所以，这样的方式只是依次覆盖了上一位的值，并没有真正的删除元素。如果想要删除首位的元素，这就需要用到shift方法了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5&lt;span&gt;];
nums.shift();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [1, 2, 3, 4, 5]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;5、splice方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　最后，我们看看如何使用splice()方法，在数组的任意位置添加和删除元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5,6,7&lt;span&gt;];
nums.splice(&lt;/span&gt;2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0, 1]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;如果只加一个参数，说明删除从下标2开始的所有的后面的元素&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5,6,7&lt;span&gt;];
nums.splice(&lt;/span&gt;2,1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0, 1, 3, 4, 5, 6, 7]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;如果加入两个参数，则为删除从下标2开始的后面的几个元素。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5,6,7&lt;span&gt;];
nums.splice(&lt;/span&gt;2,1,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0, 1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 3, 4, 5, 6, 7]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;三个或多个参数，意味着删除从下标2（第一个参数）开始的后面的1个（第二个参数）元素，并在下标2的后面加入从第三个参数开始的后面的所有参数，把第二个参数设置为0就可以不删除元素从而实现从任意位置添加元素&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再多说一点，我们还可以使用delete操作符来删除数组中的元素，但是实际上，delete只是删除了对应下标上所存储的值，并没有同时把存储值得空间也删除掉，会导致对应位置上的值为undefined：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5,6,7&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt; nums[2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0, 1,  undefined, 3, 4, 5, 6, 7]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么数组的一些基本用法就先介绍到这里，后面应该还有两篇左右的长度来介绍数组。花费如此的篇幅，实在是数组真的极为重要，还请大家不要着急。当真正的学会了数组之后，再去看栈，队列这种数据结构，其实就很简单了。&lt;/p&gt;
&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 16:00:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8686676.html</dc:identifier>
</item>
<item>
<title>RPC原理解析 - 牧梦者</title>
<link>http://www.cnblogs.com/swordfall/p/8683905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swordfall/p/8683905.html</guid>
<description>&lt;h2&gt;1.RPC原理解析&lt;/h2&gt;
&lt;h3&gt;1.1 什么是RPC&lt;/h3&gt;
&lt;p&gt;RPC(Remote Procedure Call Protocol) ——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP/IP或UDP，为通信程序之间携带信息数据。RPC将原来的本地调用转变为调用远端的服务器上的方法，给系统的处理能力和吞吐量带来了近似于无限制提升的可能。在OSI网络通信模型中，RPC跨域了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。&lt;/p&gt;
&lt;h3&gt;1.2 RPC架构&lt;/h3&gt;
&lt;p&gt;一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端(Client)，服务的调用方。&lt;/li&gt;
&lt;li&gt;客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。&lt;/li&gt;
&lt;li&gt;服务端(Server)，真正的服务提供者。&lt;/li&gt;
&lt;li&gt;服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1.3 RPC调用过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217276/201803/1217276-20180331214614230-1725924377.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(1) 客户端（client）以本地调用方式（即以接口的方式）调用服务；&lt;/p&gt;
&lt;p&gt;(2) 客户端存根（client stub）接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）；&lt;/p&gt;
&lt;p&gt;(3) 客户端通过sockets将消息发送到服务端；&lt;/p&gt;
&lt;p&gt;(4) 服务端存根( server stub）收到消息后进行解码（将消息对象反序列化）；&lt;/p&gt;
&lt;p&gt;(5) 服务端存根( server stub）根据解码结果调用本地的服务；&lt;/p&gt;
&lt;p&gt;(6) 本地服务执行并将结果返回给服务端存根( server stub）；&lt;/p&gt;
&lt;p&gt;(7) 服务端存根( server stub）将返回结果打包成消息（将结果消息对象序列化）；&lt;/p&gt;
&lt;p&gt;(8) 服务端（server）通过sockets将消息发送到客户端；&lt;/p&gt;
&lt;p&gt;(9) 客户端存根（client stub）接收到结果消息，并进行解码（将结果消息发序列化）；&lt;/p&gt;
&lt;p&gt;(10) 客户端（client）得到最终结果。&lt;/p&gt;
&lt;p&gt;RPC的目标是要把2、3、4、7、8、9这些步骤都封装起来。&lt;/p&gt;
&lt;p&gt;注意：无论是何种类型的数据，最终都需要转换成二进制流在网络上进行传输，数据的发送方需要将对象转换为二进制流，而数据的接收方则需要把二进制流再恢复为对象。&lt;/p&gt;
&lt;h2&gt;2. 自定义RPC框架范例&lt;/h2&gt;
&lt;p&gt;设计框架视图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217276/201804/1217276-20180401233816781-1488735676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与1.3架构图相比较，rpc-sample-client相当于client-functions，通过接口方法发起请求；而rpc-client相当于client-stub，负责把方法和参数序列化并发送给查找到的服务器。rpc-server相当于server stub，负责把客户端发送过来的消息反序列化，并通过反射调用本地服务，再把本地服务返回的结果序列化发送给客户端；rpc-sample-server则相当于server-functions，提供本地服务并返回得出的结果给rpc-server。rpc-client等待接收rpc-server返回的结果，并将结果反序列化，再把反序列化最终得到的结果返回给rpc-sample-client。&lt;/p&gt;
&lt;p&gt;rpc-common提供基于netty的序列化与反序列化方法，并封装rpc请求和rpc响应，序列化和反序列的对象就是封装好的RpcRequest和RpcResponse。rpc-registry则是基于zookeeper设计的分布式服务器动态上下线通知的应用程序，通过rpc-registry可以查找服务器或者注册服务器，用于均衡负载。&lt;/p&gt;
&lt;p&gt;rpc-client与rpc-server之间的通信是基于netty的，netty底层也是sockets设计，但是效率比sockets高。&lt;/p&gt;
&lt;p&gt;范例github地址：&lt;/p&gt;
&lt;p&gt;https://github.com/qiushangwenyue/CustomRpcFramework.git&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 15:59:00 +0000</pubDate>
<dc:creator>牧梦者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/swordfall/p/8683905.html</dc:identifier>
</item>
<item>
<title>简述区块链（1）- 也许只有这一篇 - Dexter Di</title>
<link>http://www.cnblogs.com/DexterDi/p/8689095.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DexterDi/p/8689095.html</guid>
<description>&lt;p&gt;一、唠叨两句&lt;/p&gt;
&lt;p&gt;最近一直在考虑一个事情，就是怎么给不太了解技术的人讲清楚区块链。我先试着写下来，然后在逐步打磨吧，目标就是让哪些说看区块链看的云里雾里的同学能对区块链有一些认知。&lt;/p&gt;

&lt;p&gt;二、定义&lt;/p&gt;
&lt;p&gt;简单的给区块链下个定义：基于加密算法的，去中心化的分布式账本技术。这里有三个关键词：加密算法、去中心化、分布式账本，下面我就尝试从三个关键词为线索，介绍一下区块链的概念。&lt;/p&gt;

&lt;p&gt;三、分布式账本&lt;/p&gt;
&lt;p&gt;比特币是一个点对点的电子现金系统，既然是现金系统，那么就得记账呗，这大概就是这个账本的由来，就是流水账嘛，张三给了李四一百块钱，王五给了张三五十块钱，blabla。这种东西，就是一条一条的数据，记录在文件里，数据库里等等。区块链的账本存储，当然就是区块和链了。分布式账本，就是在说不仅存一份数据，每个全节点都存一份数据，只要不是全部节点挂掉，总有节点可提供数据的。&lt;/p&gt;
&lt;p&gt;1. 区块：块由区块头和区块体组成，区块头包含一些前一个区块的Hash啊，当前区块中所有交易的默克尔树根啊，时间戳啊，随机数啊，等等。区块体里就是一笔笔的交易。&lt;/p&gt;
&lt;p&gt;简单说下默克尔树，比如当前区块有4比交易A，B，C，D，AB取hash，CD取hash，两个Hash结果再取hash，就形成了默克尔树，树根可以理解为一个checksum，任何一个交易改一点，整棵默克尔树就都变化了，可以保证没有篡改，这个树还可以支持轻钱包SPV验证。&lt;/p&gt;
&lt;p&gt;2. 交易：每一笔交易主要包含了一个或多个Input和Output，Input记录的是引用到的前一笔未花费交易的索引，Output记录的是将资产转移到那个地址。这里讲脚本的时候，还要讲。&lt;/p&gt;
&lt;p&gt;3. 链：刚才讲了区块头包含了前一个区块的Hash，这东西就是为了把区块连接起来，成为一个链，链上的交易顺序不能认为严格的前后关系，但是基本可以认为是有一个追溯的结构。作为程序猿，你会想需要遍历链，怎么整，拿到创世块，它没有前一个区块Hash，取到它的默克尔树根作为key去存储里面找下一个区块，如此往复。&lt;/p&gt;

&lt;p&gt;四、去中心化&lt;/p&gt;
&lt;p&gt;我想把这部分通过和一般NoSql数据库的一些方式做对比，NoSql数据库为了达到读的并发性能和数据的安全，通常都会保存多个副本，ReplicaSet的概念。同时对于写的数据，总要先找个主节点写，写完了再同步给副本集，选主的时候，数据一致的时候，都需要几个节点达成共识，通常会有Paxos，Raft这样的算法来保证。把这部分放大到公网上，就基本可以映射到区块链上了，区块链的各个全节点都保持一个完整账本，全网的ReplicaSet；获得记账权要记账写块了，谁来写，区块链上通过PoW，PoS，DPos等等共识算法来达成共识，又和Paxos，Raft对应上了。&lt;/p&gt;
&lt;p&gt;说到共识了，我们想一下记账权这个事，就是挖矿，首先是个经济问题，我干嘛要挖啊，你得给我奖励，比特币系统中获得了记账权生成了区块，就能获得比特币的奖励，比特币价格高，当然可以激励记账这个事了，那么问题来了，这个经济问题变成了一个博弈问题了，这么赚钱，凭啥你挖啊。这时候就得有个算法来规定好游戏玩法，比特币怎么个玩法PoW，就是来个数学谜题，谁算出来谁记账。这个数学谜题可以简单这么理解，就是你生成的块，加上一个随机数位可以调节，然后基于一种Hash算法，你生成出来的结果必须小于某某数，这个某某数就是难度，可以动态调节的，现在比特币的这个难度很高，所以你也就别跟矿主彪啦。那为什么叫PoW了，就是工作量证明，因为这个Hash之间没有关联型，我上次随机数计算的结果和我这次随机数计算的结果之间没有半分钱关联，这也就是为啥算力规模越来越大了，可以并行计算，算力越大，概率越大。你要非较真说，其实理论上，你可能很少计算就刚好碰到了正确结果，没错，这事就可以类比高考了，你说有没有神蒙，蒙得高分，有，但是大体上这个考分大概其能证明你努力过吧。&lt;/p&gt;

&lt;p&gt;五、加密算法&lt;/p&gt;
&lt;p&gt;非对称加密大伙都明白，不多讲了，利用非对称加密的签名验签可以实现区块链最关键的特点，确权。只有我用我的私钥签名过的数据，你用我的公钥才能验证通过，其他谁想仿造都不行，所以这钱就只能是我来花了。说到确权，这事可大了，区块链为啥火，就是因为确权，数字资产能确权了，这意味着什么？意味着互联网变成了价值互联网了，价值可以传递了。&lt;/p&gt;
&lt;p&gt;那这签名验签的用哪儿了，也没见哪儿使啊，别急，刚才咱介绍交易的时候不是留了一个箭头么，这交易上记的不仅仅是转移到对方的地址，而是一个脚本。如果就一地址搁那，都说是自己的，那不乱套了，这钱谁能用，得确权，这就需要脚本系统了。&lt;/p&gt;
&lt;p&gt;首先说说比特币的地址啊，地址咋生成，下图讲的特清楚，我从网上拷的。你说好好一图，我随便用，不能卖钱，为啥，不就是因为没法确权嘛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/217273/201804/217273-20180401225722109-1877825991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们简单说说这个比特币的脚本系统，它是基于栈的脚本系统。这里我暂时不展开，仅已最常用的比特币锁定脚本P2PKH脚本作为例子讲讲。&lt;/p&gt;
&lt;p&gt;锁定脚本&lt;/p&gt;
&lt;p&gt;DUP HASH160 [Public Key Hash] EqualVerify CheckSig&lt;/p&gt;
&lt;p&gt;花钱的时候你得通过锁定脚本的验证，这个就是一个确权的过程，你要想验证通过你得提供解锁脚本&lt;/p&gt;
&lt;p&gt;[Sig] [Public Key]&lt;/p&gt;
&lt;p&gt;简单说下验证过程吧，下面这堆脚本基于栈执行&lt;/p&gt;
&lt;p&gt;[Sig] [Public Key] DUP HASH160 [Public Key Hash] EqualVerify CheckSig&lt;/p&gt;
&lt;p&gt;1. [Sig]入栈&lt;/p&gt;
&lt;p&gt;2. [Public Key]入栈&lt;/p&gt;
&lt;p&gt;3. DUP复制栈顶[Public Key]再入栈&lt;/p&gt;
&lt;p&gt;4. 拿出栈顶[Public Key]执行HASH160（这个正是Public Key Hash的算法），入栈&lt;/p&gt;
&lt;p&gt;5. 锁定脚本里的常量[Public Key Hash]入栈&lt;/p&gt;
&lt;p&gt;6. 取出栈顶里脚本里的[Public Key Hash]和计算出来的比较，相等就继续&lt;/p&gt;
&lt;p&gt;7. 这下栈里从底到顶分别是[Sig][Public Key]，CheckSig拿出栈里这俩验签，通过钱就是你的，请用。&lt;/p&gt;

&lt;p&gt;比特币的脚本指令很多，你可以自己写脚本出来，就是有点麻烦，写汇编似的，但是这东西也是个好东西，直接就引出了后面的智能合约来了，&lt;/p&gt;

&lt;p&gt;六、小结&lt;/p&gt;
&lt;p&gt;今天主要从加密算法，去中心化和分布式账本三个方面简单介绍了一下区块链，感觉没达到我的预期让没接触过的突然开窍的感觉，后面打磨打磨吧的再。本文里主要以比特币作为实例进行介绍的，我觉得比特币最牛逼的地方就是确权和智能合约，打开了无限遐想。公链上开发，很多选择，我其实不太喜欢比特币，开发起来太麻烦，而且就现在这个币值，搞些大宗交易，跨境大额转账啥的还成，其他的，呵呵吧，但是币王还是币王，这里面的原理还是值得细细琢磨的。&lt;/p&gt;

</description>
<pubDate>Sun, 01 Apr 2018 15:28:00 +0000</pubDate>
<dc:creator>Dexter Di</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DexterDi/p/8689095.html</dc:identifier>
</item>
<item>
<title>Django--基本篇：项目结构与设计模式（MVC） - gentelman_邵</title>
<link>http://www.cnblogs.com/gentleman-shao/p/8689057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gentleman-shao/p/8689057.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;Django在项目开发中有着结构清晰、层次明显、容易编写理解查阅demo的优点，那么我们来个小案例具体看看。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　 &lt;/strong&gt;  一、项目结构简析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们按照上一篇中的开发流程步骤创建一个新项目myblog，项目下有应用home、存放html文件templates的、运行项目生成的db.sqlite3和manage.py文件。在一个项目下可以创建多个应用，每个应用可以进行一项业务(下图)，我这里用home应用文件来处理前端，myadmin应用文件来处理后端。这里需要注意的是在settings.py文件中INSTALLED_APPS列表内添加‘myadmin.apps.MyadminConfig’。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1337988/201804/1337988-20180401193028522-1016011713.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们现在templates文件夹下面创建index.html文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
你好，这是我的myblog项目中的index页面
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在项目下的url模块中进行路由的适配如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;myadmin应用路由适配&lt;/span&gt;
    url(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,views.index),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在myadmin应用下的views模块下构建index函数如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index(request):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用 Template 对象 的 render() 方法并传递context来填充模板&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myadmin/index.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行项目&lt;img src=&quot;https://images2018.cnblogs.com/blog/1337988/201804/1337988-20180401225624556-741055178.png&quot; alt=&quot;&quot;/&gt;，那我们的案例就是完成了Starting development server at http://127.0.0.1:8000/可以访问啦&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1337988/201804/1337988-20180401230038037-149939530.png&quot; alt=&quot;&quot; width=&quot;955&quot; height=&quot;119&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：设计模式MVC（又称‘MVT’）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模型（Model）：提供数据访问接口和模块，我们可以在model中创建表结构，包括数据字段、元数据、数据关系等定义及操作；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;视图（View）：Django的视图层封装了http request和response的一系列操作和数据流，主要包括URL映射机制和绑定模板等，对于页面中的事件机制、数据更新、逻辑判断主要是在view层中的函数处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模板（Template）：是一套Django自己的页面渲染模板语言，用于若干内置的tags和filters定义页面的生成方式，编写呈现页面的html文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们从 上面的项目结构中就能看出Django框架利用MVC的设计模式层次清晰、各模块的分工合理，所以是python语言用来进行web最普遍和优秀的框架。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 15:19:00 +0000</pubDate>
<dc:creator>gentelman_邵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gentleman-shao/p/8689057.html</dc:identifier>
</item>
</channel>
</rss>