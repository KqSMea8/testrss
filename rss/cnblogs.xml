<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>linux系统下解决getch()输入数值不回显示 - 醉饮千觞</title>
<link>http://www.cnblogs.com/binglmm/p/7806936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binglmm/p/7806936.html</guid>
<description>&lt;p&gt;  在linux系统下开发C 程序却会遇到系统不支持conio.h头文件，无法使用getch()不回显函数。下面就演示如何构建函数实现数值输入不回显。&lt;/p&gt;&lt;div readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;  
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; #include &amp;lt;termios.h&amp;gt;  
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;  
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; #include &amp;lt;errno.h&amp;gt;  
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ECHOFLAGS (ECHO | ECHOE | ECHOK | ECHONL)  
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数set_disp_mode用于控制是否开启输入回显功能  
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果option为0，则关闭回显，为1则打开回显  &lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; set_disp_mode(&lt;span&gt;int&lt;/span&gt; fd,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; option)  
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;{  
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; err;  
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; termios term;  
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;(tcgetattr(fd,&amp;amp;term)==-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){  
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;      perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot get the attribution of the terminal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;   }  
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(option)  
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;         term.c_lflag|=&lt;span&gt;ECHOFLAGS;  
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;    &lt;span&gt;else&lt;/span&gt;  
&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;         term.c_lflag &amp;amp;=~&lt;span&gt;ECHOFLAGS;  
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;    err=tcsetattr(fd,TCSAFLUSH,&amp;amp;&lt;span&gt;term);  
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;(err==-&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; err==&lt;span&gt;EINTR){  
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;         perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot set the attribution of the terminal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;   }  
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;}  
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数getpasswd用于获得用户输入的密码，并将其存储在指定的字符数组中  &lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getpasswd(&lt;span&gt;char&lt;/span&gt;* passwd, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size)  
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;{  
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; c;  
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;     
&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please Input password:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;     
&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;    &lt;span&gt;do&lt;/span&gt;&lt;span&gt;{  
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;       c=&lt;span&gt;getchar();  
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;|c!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){  
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;          passwd[n++] =&lt;span&gt; c;  
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;      }  
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;    }&lt;span&gt;while&lt;/span&gt;(c != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; c !=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; n &amp;lt; (size - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));  
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;    passwd[n] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;  
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;}  
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()  
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;{  
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt; *p,passwd[&lt;span&gt;20&lt;/span&gt;],name[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;];  
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please Input name:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;    scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,name);  
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;    getchar();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将回车符屏蔽掉  
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先关闭输出回显，这样输入密码时就不会显示输入的字符信息  &lt;/span&gt;
&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;    set_disp_mode(STDIN_FILENO,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用getpasswd函数获得用户输入的密码  &lt;/span&gt;
&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;    getpasswd(passwd, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(passwd));    
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;    p=&lt;span&gt;passwd;  
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(*p!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;      p++&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;    *p=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nYour name is: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,name);  
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nYour passwd is: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, passwd);  
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Press any key continue ...\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;    set_disp_mode(STDIN_FILENO,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt; &lt;span&gt;   getchar();  
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;}  
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt;  
&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;  
&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;说明：Linux下C编程遇到要输入密码的问题，可输入的时候密码总不能让人看见吧，本来想用getch()来解决输入密码无回显的问题的，不料Linux-C中不支持getch()，我也没有找到功能类似的函数代替，上面这个例子达到了预期的效果。&lt;/p&gt;</description>
<pubDate>Wed, 08 Nov 2017 15:31:00 +0000</pubDate>
<dc:creator>醉饮千觞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/binglmm/p/7806936.html</dc:identifier>
</item>
<item>
<title>Unity 游戏框架搭建 (十九) 简易对象池 - 凉鞋的笔记</title>
<link>http://www.cnblogs.com/liangxiegame/p/Unity-you-xi-kuang-jia-da-jian-shi-jiu-jian-yi-dui.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangxiegame/p/Unity-you-xi-kuang-jia-da-jian-shi-jiu-jian-yi-dui.html</guid>
<description>&lt;p&gt;在Unity中我们经常会用到对象池，使用对象池无非就是解决两个问题:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一是减少new时候寻址造成的消耗，该消耗的原因是内存碎片。&lt;/li&gt;
&lt;li&gt;二是减少Object.Instantiate时内部进行序列化和反序列化而造成的CPU消耗。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;想进一步了解对象池模式优化原理的同学可以参阅: &lt;a href=&quot;http://gpp.tkchu.me/object-pool.html&quot;&gt;对象池模式:http://gpp.tkchu.me/object-pool.html&lt;/a&gt;，本篇主要讲如何实现一个精简并且灵活的对象池。&lt;/p&gt;
&lt;h4 id=&quot;toc_0&quot;&gt;设计：&lt;/h4&gt;
&lt;p&gt;首先我们要弄清楚本篇对象池的几个概念，否则直接上代码大家会一头雾水。&lt;br/&gt;从字面上理解对象池，池的意思就是容器。我们可以从池中获取一个对象(一条鱼)，也可以向池中放入一个对象(一条鱼)。获取的操作我们叫Allocate(分配),而放入一个对象我们叫Recycle(回收)(ps:也有很多习惯叫Spawn和Despawn的,这个看自己习惯了)。所以我们可以定义池的接口为如下:&lt;br/&gt;``` C#&lt;br/&gt;public interface IPool&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    bool Recycle(T obj);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;为什么要用泛型呢？因为笔者开头说过，本篇主要讲如何实现一个精简并且灵活的对象池。这个灵活很大一部分是通过泛型体现的。

前面有说过，池是容器的意思，在C#中可以是List,Queue或者Stack甚至是数组。所以对象池本身要维护一个容器。本篇我们选取Stack来作为池容器，原因是当我们在Allocate和Recycle时并不关心缓存的存储的顺序，只要求缓存对象的地址是连续的。代码如下所示:
``` C#
    using System.Collections.Generic;

    public abstract class Pool&amp;lt;T&amp;gt; : IPool&amp;lt;T&amp;gt;
    {
          ...
        protected Stack&amp;lt;T&amp;gt; mCacheStack = new Stack&amp;lt;T&amp;gt;();
          ...
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Pool是个抽象类，为什么呢? 因为笔者开头说过，本篇主要讲如何实现一个精简并且灵活的对象池。这个灵活很大一部分是通过抽象类体现的。&lt;/p&gt;
&lt;p&gt;现在对象的存取和缓存接口都设计好了，那么这些对象是从哪里来的呢？我们分析下，创建对象我们知道有两种方式，反射构造方法和new一个对象。对象池的一个重要功能就是缓存，要想实现缓存就要求对象可以在对象池内部进行创建。所以我们要抽象出一个对象的工厂，代码如下所示:&lt;br/&gt;&lt;code&gt;C#&lt;br/&gt;public interface IObjectFactory&amp;lt;T&amp;gt;&lt;br/&gt;{&lt;br/&gt;T Create();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;br/&gt;那么大家要问为什么要用工厂? 因为笔者开头说过，本篇主要讲如何实现一个精简并且灵活的对象池。这个灵活很大一部分是通过工厂体现的。&lt;/p&gt;
&lt;p&gt;OK，现在对象的创建，存取，缓存的接口都设计好了。下面放出Pool的全部代码。&lt;br/&gt;``` C#&lt;br/&gt;using System.Collections.Generic;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class Pool&amp;lt;T&amp;gt; : IPool&amp;lt;T&amp;gt;
{
    #region ICountObserverable
    /// &amp;lt;summary&amp;gt;
    /// Gets the current count.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;The current count.&amp;lt;/value&amp;gt;
    public int CurCount
    {
        get { return mCacheStack.Count; }
    }
    #endregion

    protected IObjectFactory&amp;lt;T&amp;gt; mFactory;

    protected Stack&amp;lt;T&amp;gt; mCacheStack = new Stack&amp;lt;T&amp;gt;();

    /// &amp;lt;summary&amp;gt;
    /// default is 5
    /// &amp;lt;/summary&amp;gt;
    protected int mMaxCount = 5;

    public virtual T Allocate()
    {
        return mCacheStack.Count == 0
            ? mFactory.Create()
            : mCacheStack.Pop();
    }

    public abstract bool Recycle(T obj);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
代码不多，设计阶段基本就这样。下面介绍如何实现一个简易的对象池。

#### 对象池实现

首先要实现一个对象的创建器,代码如下所示:
``` C#
    using System;

    public class CustomObjectFactory&amp;lt;T&amp;gt; : IObjectFactory&amp;lt;T&amp;gt;
    {
        public CustomObjectFactory(Func&amp;lt;T&amp;gt; factoryMethod)
        {
            mFactoryMethod = factoryMethod;
        }
        
        protected Func&amp;lt;T&amp;gt; mFactoryMethod;

        public T Create()
        {
            return mFactoryMethod();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比较简单，只是维护了一个返回值为T的委托(如果说得有误请指正)。&lt;br/&gt;对象池实现:&lt;br/&gt;``` C#&lt;br/&gt;using System;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// unsafe but fast
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
public class SimpleObjectPool&amp;lt;T&amp;gt; : Pool&amp;lt;T&amp;gt;
{
    readonly Action&amp;lt;T&amp;gt; mResetMethod;

    public SimpleObjectPool(Func&amp;lt;T&amp;gt; factoryMethod, Action&amp;lt;T&amp;gt; resetMethod = null,int initCount = 0)
    {
        mFactory = new CustomObjectFactory&amp;lt;T&amp;gt;(factoryMethod);
        mResetMethod = resetMethod;

        for (int i = 0; i &amp;lt; initCount; i++)
        {
            mCacheStack.Push(mFactory.Create());
        }
    }

    public override bool Recycle(T obj)
    {
        mResetMethod.InvokeGracefully(obj);
        mCacheStack.Push(obj);
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;实现也很简单，这里不多说了。

#### 如何使用?
``` C#
            var fishPool = new SimpleObjectPool&amp;lt;Fish&amp;gt;(() =&amp;gt; new Fish(), null, 100);

            Log.I(&quot;fishPool.CurCount:{0}&quot;, fishPool.CurCount);

            var fishOne = fishPool.Allocate();
            
            Log.I(&quot;fishPool.CurCount:{0}&quot;, fishPool.CurCount);

            fishPool.Recycle(fishOne);
            
            Log.I(&quot;fishPool.CurCount:{0}&quot;, fishPool.CurCount);

            for (int i = 0; i &amp;lt; 10; i++)
            {
                fishPool.Allocate();
            }
            
            Log.I(&quot;fishPool.CurCount:{0}&quot;, fishPool.CurCount);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fishPool.CurCount:100
fishPool.CurCount:99
fishPool.CurCount:100
fishPool.CurCount:90
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK，本篇就介绍到这里&lt;/p&gt;
&lt;h4 id=&quot;toc_1&quot;&gt;相关链接:&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liangxiegame/QFramework&quot;&gt;QFramework地址&lt;/a&gt;:&lt;a href=&quot;https://github.com/liangxiegame/QFramework&quot;&gt;https://github.com/liangxiegame/QFramework&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明地址:&lt;a href=&quot;http://liangxiegame.com/&quot;&gt;凉鞋的笔记&lt;/a&gt;&lt;a href=&quot;http://liangxiegame.com/&quot;&gt;http://liangxiegame.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微信公众号:liangxiegame&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://liangxiegame.com/content/images/2017/06/qrcode_for_gh_32f0f3669ac8_430.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 08 Nov 2017 15:20:00 +0000</pubDate>
<dc:creator>凉鞋的笔记</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liangxiegame/p/Unity-you-xi-kuang-jia-da-jian-shi-jiu-jian-yi-dui.html</dc:identifier>
</item>
<item>
<title>让普通 Java 类自动感知 Activity Lifecycle - -Reset</title>
<link>http://www.cnblogs.com/-reset/p/7806852.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-reset/p/7806852.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;在 Android 开发中，我们都很熟悉 Activity 的 Lifecycle，并且会在特定的 Lifecycle 下执行特定的操作。当然，我们清楚 Lifecycle 本身是带有 Android 特质的，那尝试设想下，如果 &lt;code&gt;普通的 Java Class 也能自动感知 Lifecycle 呢&lt;/code&gt; ？咋一听这个想法似乎背后意义不大，但在实际探索中，我们发现这个特性能为我们达成一些之前未考虑到或者不易实现的优化。&lt;strong&gt;java学习群669823128&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文分享下我们基于这个思想所开发的框架： &lt;code&gt;AutoLifecycle&lt;/code&gt; 及其带来的一些有意思的实践。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优化一：当Activity进入onDestroy时，自动取消网络请求返回&lt;/li&gt;
&lt;li&gt;优化二：自动将网络请求时机提前到View渲染之前，提高页面打开速度&lt;/li&gt;
&lt;li&gt;优化三：MVP改进，让Presenter和View自动bind/unBind&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注：下文提到的 &lt;code&gt;Lifecycle-Aware&lt;/code&gt; 就是这里指代的 &lt;code&gt;让普通 Java Class 自动获取 Lifecycle&lt;/code&gt; 。&lt;/p&gt;
&lt;h2&gt;实践及优化&lt;/h2&gt;
&lt;h3&gt;优化一：当Activity进入onDestroy时，自动取消网络请求返回&lt;/h3&gt;
&lt;p&gt;在网络请求时，相信大家都有一个经验：在每个网络结果回来时，我们做的第一件事不是显示数据，而是写个if-else判断Activity还在不在。&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs dart&quot;&gt;
mTopApiObservable
  ...
  .subscribe(&lt;span class=&quot;hljs-keyword&quot;&gt;new Subscriber&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;Object&amp;gt;() {
      &lt;span class=&quot;hljs-meta&quot;&gt;@Override
      public &lt;span class=&quot;hljs-keyword&quot;&gt;void onNext(&lt;span class=&quot;hljs-built_in&quot;&gt;Object data) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if(activity == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;return; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;由于网络请求都是异步的，所以不得不做这样的判断，来防止不可预测的空指针问题或内存泄漏问题。&lt;/p&gt;
&lt;p&gt;既然你总是担心 &lt;code&gt;Activity&lt;/code&gt; 还在不在，那么如果我们通过 &lt;code&gt;Lifecycle-Aware让每个网络请求能自动感知Activity的onDestroy事件&lt;/code&gt; ，&lt;/p&gt;
&lt;p&gt;并在 &lt;code&gt;onDestroy&lt;/code&gt; 时，自动把网络请求结果 &lt;code&gt;取消掉不再返回&lt;/code&gt; ，那就能够消除这个担忧了。&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs dart&quot;&gt;
mTopApiObservable
  ...
  .compose(bindUntilEvent(ActivityLifecycle.DESTROY)) 
&lt;/pre&gt;
&lt;p&gt;其中最关键的就是 &lt;code&gt;compose(bindUntilEvent(ActivityLifecycle.DESTROY))&lt;/code&gt; 这句，它能达到的效果是：一旦 &lt;code&gt;Activity&lt;/code&gt; 发生 &lt;code&gt;onDestroy&lt;/code&gt; 时， &lt;code&gt;Observer&lt;/code&gt; 的数据就会停止向 &lt;code&gt;Subscriber&lt;/code&gt; 里流动。从而保证 &lt;code&gt;onNext&lt;/code&gt; 无需担心 &lt;code&gt;Activity&lt;/code&gt; 已 &lt;code&gt;Destroy&lt;/code&gt; 这种情况。&lt;/p&gt;
&lt;p&gt;在上面网络请求的实践里，你还可以根据自己的情况把 &lt;code&gt;Destroy&lt;/code&gt; 换成 &lt;code&gt;Stop&lt;/code&gt; / &lt;code&gt;Pause&lt;/code&gt; 等，而且可以看出，这种自动取消机制可适用于任何 &lt;code&gt;Observable&lt;/code&gt; ，不仅仅是网络请求。&lt;/p&gt;
&lt;h3&gt;优化二：自动将网络请求提前到View Inflate之前，加速页面渲染&lt;/h3&gt;
&lt;p&gt;先说下这项优化的原理。&lt;/p&gt;
&lt;p&gt;通常，我们会在 &lt;code&gt;Activity&lt;/code&gt; 的 &lt;code&gt;onCreate&lt;/code&gt; 里依次执行下面的代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs less&quot;&gt;
&lt;span class=&quot;hljs-variable&quot;&gt;@Override
protected void onCreate(Bundle savedInstanceState) {
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;super&lt;span class=&quot;hljs-selector-class&quot;&gt;.onCreate(savedInstanceState);
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;setContentView(R.layout.XXX);   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;即在 &lt;code&gt;Inflate View&lt;/code&gt; 和 &lt;code&gt;初始化View&lt;/code&gt; 之后，才发起网络请求去加载数据。&lt;/p&gt;
&lt;p&gt;而实际上，网络请求是不占用主线程的，如果能在 &lt;code&gt;Inflate View&lt;/code&gt; 之前就在其他线程发起网络请求，可以把整个页面显示耗时缩短 &lt;code&gt;100ms-200ms&lt;/code&gt; 。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img0.tuicool.com/uQzi6vn.png!web&quot; alt=&quot;&quot;/&gt;&lt;p&gt;LoadBeforeInflate优化效果&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;现在有了 &lt;code&gt;AutoLifecycle&lt;/code&gt; 框架，我们就可以很轻松实现：让Presenter自动监听 &lt;code&gt;Inflate View&lt;/code&gt;这个生命周期，在那时发起网络请求即可。&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs java&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;NewPresenter {

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;NewPresenter&lt;span class=&quot;hljs-params&quot;&gt;(IView iView) {
        ...
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们的Activity也不用手动调用 &lt;code&gt;presenter.loadDataFromServer();&lt;/code&gt; 了，因为Presenter内会在感知到 &lt;code&gt;Inflate View&lt;/code&gt; 事件时自动发起网络请求。&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs java&quot;&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@Override
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onCreate&lt;span class=&quot;hljs-params&quot;&gt;(Bundle savedInstanceState) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate(savedInstanceState);
    setContentView(R.layout.XXX);
    findViewByIds();
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;经过测试，在保证单个网络请求耗时相同的情况下，页面从 &lt;code&gt;onCreate&lt;/code&gt; 到 &lt;code&gt;显示数据&lt;/code&gt; 的渲染耗时可以从 &lt;code&gt;550ms&lt;/code&gt; 缩短到 &lt;code&gt;367ms&lt;/code&gt; ，也就是 &lt;code&gt;30%-40%&lt;/code&gt; 的优化，效果是非常不错的，而且代码也更加简洁清晰。&lt;/p&gt;
&lt;div&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/f2iAfmA.png!web&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;通过简单的注册 &lt;code&gt;AutoLifecycle&lt;/code&gt; ， &lt;code&gt;Presenter&lt;/code&gt; 能够自动感知到所有 &lt;code&gt;Lifecycle&lt;/code&gt; ，甚至包括自定义的特殊 &lt;code&gt;Lifecycle&lt;/code&gt; ，如下图：&lt;/p&gt;
&lt;div&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img0.tuicool.com/ieu6fmN.png!web&quot; alt=&quot;&quot;/&gt;&lt;p&gt;LifecycleAwarePresenter&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;优化三：MVP改进，让Presenter和View自动bind/unBind&lt;/h3&gt;
&lt;p&gt;第一项优化比较直接，可以先让大家形成一个直观印象。&lt;/p&gt;
&lt;p&gt;我们项目是采用MVP项目，对于 &lt;code&gt;Presenter&lt;/code&gt; 的使用存在一段固定代码，即在 &lt;code&gt;onCreate&lt;/code&gt; 时调用&lt;code&gt;bindView()&lt;/code&gt; ，在 &lt;code&gt;onDestroy&lt;/code&gt; 时调用 &lt;code&gt;unBindView()&lt;/code&gt; 。如下图：&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs scala&quot;&gt;
public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;OldActivity &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;BaseActivity {

    &lt;span class=&quot;hljs-type&quot;&gt;BasePresenter mPresenter = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-type&quot;&gt;BasePresenter();

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-keyword&quot;&gt;protected void onCreate(&lt;span class=&quot;hljs-meta&quot;&gt;@Nullable &lt;span class=&quot;hljs-type&quot;&gt;Bundle savedInstanceState) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate(savedInstanceState);
        mPresenter.bindView(&lt;span class=&quot;hljs-keyword&quot;&gt;this); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;那么，既然我们现在能 &lt;code&gt;让一个普通类自动感知Lifecycle&lt;/code&gt; ，那其实也就能让 &lt;code&gt;Presenter&lt;/code&gt; 在感知到&lt;code&gt;onCreate&lt;/code&gt; 时 &lt;code&gt;自动bindView&lt;/code&gt; ，在感知到 &lt;code&gt;onDestroy&lt;/code&gt; 时 &lt;code&gt;自动unBindView&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;改进后的代码如下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs scala&quot;&gt;
public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;NewActivity &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;BaseActivity {

    &lt;span class=&quot;hljs-type&quot;&gt;NewPresenter mPresenter;

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-keyword&quot;&gt;protected void onCreate(&lt;span class=&quot;hljs-meta&quot;&gt;@Nullable &lt;span class=&quot;hljs-type&quot;&gt;Bundle savedInstanceState) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate(savedInstanceState);
        mPresenter = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-type&quot;&gt;NewPresenter(&lt;span class=&quot;hljs-keyword&quot;&gt;this); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;其实，在大家的平常开发中，还会存在许多类似 &lt;code&gt;Presenter&lt;/code&gt; 的类： &lt;code&gt;需要在某个特定的Lifecycle下执行一些动作&lt;/code&gt; 。这时就可以基于 &lt;code&gt;Lifecycle-Aware&lt;/code&gt; 来让这个普通类自动去执行，而不是去每个&lt;code&gt;Activity/Fragment&lt;/code&gt; 里写一遍，提高类的内聚性。&lt;/p&gt;
&lt;h2&gt;AutoLifecycle的核心原理&lt;/h2&gt;
&lt;p&gt;(TL;DR)&lt;/p&gt;
&lt;p&gt;下面介绍下 &lt;code&gt;AutoLifecycle&lt;/code&gt; 的关键实现部分，感兴趣的读者可以参考。&lt;/p&gt;
&lt;h3&gt;1. 让Activity对外发送Lifecycle事件&lt;/h3&gt;
&lt;p&gt;使用过 &lt;code&gt;RxJava&lt;/code&gt; 的同学知道里面有一个 &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html&quot; rel=&quot;nofollow,noindex&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;PublishSubject&lt;/code&gt; &lt;/a&gt;，基于观察者模式，主动发送并接受消息。这里我们用 &lt;code&gt;PublishSubject&lt;/code&gt; 来发送Lifecycle事件。见如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/zeMzaaI.png!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;这里的Lifecycle事件可以自己定义，比如前面提到的PRE_INFLATE事件，是在setContentView之前发送，类似：&lt;/h4&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img1.tuicool.com/eiIB7jz.png!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. 感知某个Lifecycle的发生并自动执行回调&lt;/h3&gt;
&lt;p&gt;上面提了， &lt;code&gt;PublishSubject&lt;/code&gt; 不仅能发送消息，还能接受自己的消息。基于这个特点，我们便可以监听每一个LifecycleEvent。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/VbYjQvb.png!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的参数Observable是我们希望被回调的函数，IContextLifecycle是指定的Lifecycle。即当指定的Lifecycle Event发生时，会自动subscribe提供的Observable。&lt;/p&gt;
&lt;p&gt;基于这个功能，便可以实现上面场景一和场景二里的 &lt;code&gt;@AutoLifecycleEvent&lt;/code&gt; 注解了，即把 &lt;code&gt;@AutoLifecycleEvent&lt;/code&gt; 标注的函数包装成一个Observable，通过这个 &lt;code&gt;executeOn&lt;/code&gt; 来注册函数的执行生命周期即可。&lt;/p&gt;
&lt;h3&gt;3. 监听Lifecycle并取消网络请求结果&lt;/h3&gt;
&lt;p&gt;在场景三里，我们为网络请求的 &lt;code&gt;Observable&lt;/code&gt; 提供了一个 &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html&quot; rel=&quot;nofollow,noindex&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Transformer&lt;/code&gt; &lt;/a&gt;，它能在监听到某个Lifecycle发生时，停止数据流的向下流动。该 &lt;code&gt;Transformer&lt;/code&gt; 的核心实现是：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img1.tuicool.com/neaaYr6.png!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，当指定的Lifecycle一旦发生，我们网络请求Observable就会停止向下传递数据。&lt;/p&gt;
&lt;h3&gt;4. 支持自定义Lifecycle，支持Activity/Fragment/DialogFrament等&lt;/h3&gt;
&lt;p&gt;可以看出， &lt;code&gt;AutoLifecycle&lt;/code&gt; 除了支持常规的生命周期，还能支持自定义的特殊生命周期，比如View Inflate前。&lt;/p&gt;
&lt;p&gt;另外，上面都是以Activity为例，不过显然这套框架可以灵活扩展，不局限于Activity，还能适用于Fragment、DialogFrament等。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Lifecycle-Aware&lt;/code&gt; 思想是Google官方提出来的概念：赋予普通类自动感知生命周期的能力。而本文也是基于这个思想，提供了一些具体实践和优化的思路，读者同学可以根据自己的情况做更多的改进和尝试。&lt;strong&gt;java学习群669823128&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Nov 2017 15:13:00 +0000</pubDate>
<dc:creator>-Reset</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-reset/p/7806852.html</dc:identifier>
</item>
<item>
<title>HTTPS协议，TLS协议 - snowater</title>
<link>http://www.cnblogs.com/snowater/p/7804889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowater/p/7804889.html</guid>
<description>&lt;h3&gt;一、HTTPS 协议&lt;/h3&gt;
&lt;p&gt;HTTPS协议其实就是HTTP over TSL，TSL(Transport Layer Security) 传输层安全协议是https协议的核心。&lt;/p&gt;
&lt;p&gt;TSL可以理解为SSL (Secure Socket Layer)安全套接字层的后续版本。&lt;/p&gt;
&lt;p&gt;TSL握手协议如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108204533294-1339745312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（注：图片来源于google图片）&lt;/p&gt;
&lt;p&gt;在建立TCP连接后，开始建立TLS连接。下面抓包分析TLS握手过程，抓包图片来源于&lt;a href=&quot;http://www.freebuf.com/articles/network/116497.html&quot; target=&quot;_blank&quot;&gt;传输层安全协议抓包分析之SSL/TLS&lt;/a&gt; (自己没抓到这么完整的包，只能搬运过来了，摔)&lt;/p&gt;
&lt;p&gt;a. client端发起握手请求，会向服务器发送一个ClientHello消息，该消息包括其所支持的SSL/TLS版本、Cipher Suite加密算法列表（告知服务器自己支持哪些加密算法）、sessionID、随机数等内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108210913731-381290333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b. 服务器收到请求后会向client端发送ServerHello消息，其中包括：&lt;/p&gt;
&lt;p&gt;SSL/TLS版本；&lt;/p&gt;
&lt;p&gt;session ID，因为是首次连接会新生成一个session id发给client；&lt;/p&gt;
&lt;p&gt;Cipher Suite，sever端从Client Hello消息中的Cipher Suite加密算法列表中选择使用的加密算法；&lt;/p&gt;
&lt;p&gt;Radmon 随机数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108211404888-25605470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;c.经过ServerHello消息确定TLS协议版本和选择加密算法之后，就可以开始发送证书给client端了。证书中包含公钥、签名、证书机构等信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108212037372-893214258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;d.服务器向client发送ServerKeyExchange消息，消息中包含了服务器这边的EC Diffie-Hellman算法相关参数。此消息一般只在选择使用DHE 和DH_anon等加密算法组合时才会由服务器发出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108212528247-743481578.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;e. server端发送ServerHelloDone消息，表明服务器端握手消息已经发送完成了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108212652544-470476594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;f.client端收到server发来的证书，会去验证证书，当认为证书可信之后，会向server发送ClientKeyExchange消息，消息中包含客户端这边的EC Diffie-Hellman算法相关参数，然后服务器和客户端都可根据接收到的对方参数和自身参数运算出Premaster secret，为生成会话密钥做准备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108212742997-638983083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; g.此时client端和server端都可以根据之前通信内容计算出Master Secret（加密传输所使用的对称加密秘钥），client端通过发送此消息告知server端开始使用加密方式发送消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108213240841-1040450792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; h.客户端使用之前握手过程中获得的服务器随机数、客户端随机数、Premaster secret计算生成会话密钥master secret，然后使用该会话密钥加密之前所有收发握手消息的Hash和MAC值，发送给服务器，以验证加密通信是否可用。服务器将使用相同的方法生成相同的会话密钥以解密此消息，校验其中的Hash和MAC值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108213303466-1978167763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; i.服务器发送ChangeCipherSpec消息，通知客户端此消息以后服务器会以加密方式发送数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108213315263-1721933592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; j.sever端使用会话密钥加密（生成方式与客户端相同，使用握手过程中获得的服务器随机数、客户端随机数、Premaster secret计算生成）之前所有收发握手消息的Hash和MAC值，发送给客户端去校验。若客户端服务器都校验成功，握手阶段完成，双方将按照SSL记录协议的规范使用协商生成的会话密钥加密发送数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108213325309-1347694901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;二、session ID的复用&lt;/h3&gt;
&lt;p&gt;根据&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot; target=&quot;_blank&quot;&gt;rfc5246&lt;/a&gt;，client和server建立TLS握手过程如下所示：&lt;/p&gt;
&lt;pre class=&quot;newpage&quot;&gt;
      Client                                               Server

      ClientHello                  --------&amp;gt;
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &amp;lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&amp;gt;
                                               [ChangeCipherSpec]
                                   &amp;lt;--------             Finished
      Application Data             &amp;lt;-------&amp;gt;     Application Data

             Figure 1.  Message flow for a full handshake
&lt;/pre&gt;
&lt;pre class=&quot;newpage&quot;&gt;
* Indicates optional or situation-dependent messages that are not
   always sent.
&lt;/pre&gt;
&lt;p&gt;client在向server发送ClientHello消息的时候，会传送Session ID给server端，server端收到session Id后会去session缓存中查找是否有相同值。如果找到相同值，则server直接发送一个具有相同session ID的ServerHello消息给client端（此时不必新建Session ID），然后双方各发一次ChangeCipherSpec消息后直接进入Finished消息互发阶段，具体如下图所示：&lt;/p&gt;
&lt;pre class=&quot;newpage&quot;&gt;
      Client                                                Server

      ClientHello                   --------&amp;gt;
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    &amp;lt;--------             Finished
      [ChangeCipherSpec]
      Finished                      --------&amp;gt;
      Application Data              &amp;lt;-------&amp;gt;     Application Data

          Figure 2.  Message flow for an abbreviated handshake
&lt;/pre&gt;
&lt;p&gt;client和server通过缓存Session ID可以快速建立TLS握手，但是这么做也有一些弊端，例如：1）负载均衡中，多机之间往往没有同步 Session 信息，如果客户端两次请求没有落在同一台机器上就无法找到匹配的信息；2）服务端存储 Session ID 对应的信息不好控制失效时间，太短起不到作用，太长又占用服务端大量资源。而 Session Ticket（会话记录单）可以解决这些问题，Session Ticket 是用只有服务端知道的安全密钥加密过的会话信息，最终保存在浏览器端。浏览器如果在 ClientHello 时带上了 Session Ticket，只要服务器能成功解密就可以完成快速握手。&lt;/p&gt;
&lt;h3&gt;三、数字证书的验证&lt;/h3&gt;
&lt;p&gt;client端收到server端发过来的证书，首先必须要做的事验证证书是否可信。如何验证证书是否可信呢？为了解决这个问题，我们先来了解下证书的组成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108221111716-1100586299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这里面我们能看到证书包含以下内容：&lt;/p&gt;
&lt;p&gt;(1) Validity也即有效期，有效期包含生效时间和失效时间，是一个时间区间；&lt;/p&gt;
&lt;p&gt;(2) 公钥信息Subject Public Key Info，包括公钥的加密算法和公钥内容；&lt;/p&gt;
&lt;p&gt;(3) Fingerprints信息，fingerprints用于验证证书的完整性，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(此处证书使用了SHA-1和SHA-256算法)计算整个证书的hash值(指纹)并和证书放在一起，client在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值相同，则说明证书未被修改过；如果hash值不一致，则表明证书内容被篡改过；&lt;/p&gt;
&lt;p&gt;(4) 证书的签名：Certificate Signature Value和Certificate Signature Algorithm，对证书签名所使用的Hash算法和Hash值；&lt;/p&gt;
&lt;p&gt;(5) 除此之外我们还能看到证书中包含签发该证书的CA机构和该证书是签发给哪个组织/公司信息以及Fingerprints信息等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108224731684-426513846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，为签名过程和client端验证过程。中间方框为一个数字证书，在制作数字证书时，会将证书中的部分内容进行一次Hash得到一个Hash值，然后证书认证机构简称CA会使用私钥将该Hash值加密为Certificate Signature。&lt;/p&gt;
&lt;p&gt;当证书发送给Client端之后，Client端首先会使用同样的Hash算法获得一个证书的hash值H1。通常浏览器和操作系统中集成了CA机构的公钥信息，浏览器收到证书后可以使用这些公钥解密Certificate Signature内容，得到一个hash值H2。&lt;/p&gt;
&lt;p&gt;比较H1和H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。 &lt;/p&gt;
&lt;h3&gt;四、非对称加解密&lt;/h3&gt;
&lt;p&gt;非对称加密包含一个密钥对：公钥和私钥。公钥可以公开，私钥必须安全保存。&lt;/p&gt;
&lt;p&gt;建立HTTPS连接以后，client（浏览器）已经获得server段的公钥，此时client端向server端发送数据都会使用公钥进行加密。server端收到加密的信息之后，可以使用私钥进行解密。client端用公钥加密的消息只有使用与公钥对应的私钥才能解密，否则无法解密。&lt;/p&gt;
&lt;p&gt;server端同样需要将消息用自己的私钥进行加密，然后发送给client端，client端可以通过之前获得的公钥解密消息。&lt;/p&gt;
&lt;p&gt;client端加密消息后，之后私钥持有方能解密，保证了用户提交敏感信息的安全性。而server端加密消息发送给client端，这一过程可以避免第三方篡改web内容，比如插入广告等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171108182600294-174828072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;https://tools.ietf.org/html/rfc5246#page-6&lt;/p&gt;
&lt;p&gt;http://www.freebuf.com/articles/network/116497.html&lt;/p&gt;
&lt;p&gt;https://imququ.com/post/optimize-tls-handshake.html&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/wzzvictory/article/details/9015155&lt;/p&gt;

</description>
<pubDate>Wed, 08 Nov 2017 14:52:00 +0000</pubDate>
<dc:creator>snowater</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowater/p/7804889.html</dc:identifier>
</item>
<item>
<title>如何运用GitHub来提高生产效率 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/7806719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/7806719.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;这是一篇GitHub的入门级文章，主要针对git的初学者。我们将讨论初学者最关心的一些问题，如：为什么我们要使用GitHub，它的应用有哪些，如何运用它去帮助我们提高工作效率，以及它的基本用法有哪些。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;希望看到文中的相关资源链接的朋友，可以直接访问我的中文blog：https://www.terencexie.com 。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在展开讨论GitHub之前，其实需要澄清一个在初学者脑中不太清晰的概念：GitHub和git是一回事吗？&lt;/p&gt;
&lt;p&gt;其他人我不知道，但我第一次接触GitHub的时候，几乎没有注意到GitHub和git是两个东西。更夸张的是，我甚至直接在脑中无理由暴力脑补“嗯，说不定git是GitHub的一个简称。”现在想来当然极其可笑，但作为新人不得不面对的一个现实是：新人之所以是新人不是因为他在某一方面很薄弱，而是各方面都千疮百孔。像这样的不经过任何调查、也没有任何官方文档或者实验数据作支持，冒然做出一个推论并把它奉为一种真实，是进一步走向混乱的重要因素。&lt;/p&gt;
&lt;p&gt;git和GitHub其实是两个有联系但却根本不同的东西。用一种不太严格的说法，可以这样理解它们的关系：GitHub是支持git的remote端（服务器端）的一个服务。它就好比是你的云端服务，用于保存你本地的&lt;strong&gt;代码版本控制&lt;/strong&gt;的所有记录。再介绍了git之后，我们会再一次澄清和展开这个概念。&lt;/p&gt;
&lt;h2&gt;什么是git&lt;/h2&gt;
&lt;p&gt;git是写出Linux内核的大神Linus，捣鼓出来的代码版本控制工具。虽然其动机是服务于代码，但其实对非开发者的普通用户，也是很有用的工具。&lt;/p&gt;
&lt;p&gt;什么叫做版本控制？&lt;/p&gt;
&lt;p&gt;我们可以从比较熟悉的&lt;strong&gt;游戏存档&lt;/strong&gt;谈起。在玩RPG游戏的时候，一个非常重要的基础功能便是能够存储当前的游戏状态。因为你几乎不可能在完全不停止的情况下一次性通关。停止你游戏story展开的因素有很多，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你玩游戏的进度很慢，到了睡觉时间，也就不得不停止，下次再战。&lt;/li&gt;
&lt;li&gt;你悲剧地遭遇了电脑的突然中断，不得不重新进入游戏。&lt;/li&gt;
&lt;li&gt;一切都很顺利，但你却不幸被游戏中的大boss干掉了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了游戏存档功能，一方面你可以再一次从你中断的地方继续游戏，另一方面，如果你的游戏有多条分支线story，你可以从分支的地方继续开始，选择另一条路线体验不同的经历。&lt;/p&gt;
&lt;p&gt;那么，git干的其实是同样的事情。git其实就是为&lt;strong&gt;特定的文件目录&lt;/strong&gt;下的所有文件，提供一个&lt;strong&gt;存档功能&lt;/strong&gt;（这个特定的文件目录，就是运行了&lt;code&gt;git init&lt;/code&gt;命令的文件目录）。在git的视角之下，每一个时间点的文件目录状态，都可以作为一个存储节点（同游戏存档一样）。而像这样的可以存储一个文件的各个时间节点的文件状态的功能，就叫做&lt;strong&gt;版本控制&lt;/strong&gt;。如果从使用Facebook的角度来讲，&lt;code&gt;git&lt;/code&gt;提供的功能就是为这个文件目录提供一个&lt;strong&gt;时间线&lt;/strong&gt;，将这个文件目录下发生的所有事情全部记载下来，起到一个类似于游戏存档的功能。&lt;/p&gt;
&lt;p&gt;例如，假设我们在运行了&lt;code&gt;git init&lt;/code&gt;命令的文件目录&lt;code&gt;MyDirectory&lt;/code&gt;下有两个文件&lt;code&gt;File1.txt&lt;/code&gt;和&lt;code&gt;File2.txt&lt;/code&gt;。&lt;code&gt;File1.txt&lt;/code&gt;和&lt;code&gt;File2.txt&lt;/code&gt;这两个文件各包含两行文字，如下图。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;wp-image-239 size-medium&quot; title=&quot;图1.0&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.0&lt;/p&gt;
&lt;p&gt;作为初级程序员的教程，这里需要多说几句，解释一下为什么这个例子可以&lt;em&gt;不失一般性&lt;/em&gt;，作为其它所有文件的代表。因为所有的文件在其底层的存储方式都是字节序列。从计算机的角度来看，所有的文件就是一行行的文字而已。所以，如果理解了&lt;code&gt;git&lt;/code&gt;如何去处理一个人类可以识别的文本文件。那么，对于任何文件来讲，其原理也是相同的，不过是处理一行行计算机认识的文字，即一堆0、1序列文字流。&lt;/p&gt;
&lt;p&gt;如图1.0，这里便可以作为&lt;code&gt;MyDirectory&lt;/code&gt;的一个当前时间点的文件状态。当&lt;code&gt;MyDirectory&lt;/code&gt;下的任何一个文件有所改动，&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;size-medium wp-image-242&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem2-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.1&lt;/p&gt;
&lt;p&gt;那么此刻的状态，就好比是游戏当中的主角在地图上移动了一个位置，可以作为另一个时间点的文件状态（图1.1）来做存储。&lt;/p&gt;
&lt;p&gt;可以发现，到目前为止的讨论，都和GitHub无关、和remote端的服务器没有关系。因为&lt;code&gt;git&lt;/code&gt;的使用可以仅仅限于本地，和网路连接无关。因而，对于普通用户来说，完全可以使用&lt;code&gt;git&lt;/code&gt;来为你的办公文件、私人文件做存档。&lt;strong&gt;存档&lt;/strong&gt;与&lt;strong&gt;备份&lt;/strong&gt;的不同在于，后者只能够存储一个文件状态，而前者却可以存储多个文件状态，也即是将整个文件的时间线全部存储下来。有了它，你便能够去了解这个文件的整个衍化、生长历史，从而对它有更加深层次的认识和理解。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;git&lt;/code&gt;的优质教程我会推荐两个，一个是Udacity的课程&lt;a href=&quot;https://www.udacity.com/course/how-to-use-git-and-github--ud775&quot;&gt;How to Use Git and GitHub&lt;/a&gt;，另一个是git的官方文档教程&lt;a href=&quot;https://git-scm.com/book/en/v2&quot;&gt;Pro Git&lt;/a&gt;，里面提供了可以下载的多种格式的电子版。&lt;/p&gt;
&lt;h2&gt;常用的git命令&lt;/h2&gt;
&lt;h3&gt;为文件目录提供版本控制功能&lt;/h3&gt;
&lt;p&gt;最开始的命令当然是&lt;code&gt;git init&lt;/code&gt;，用于为一个文件目录提供版本控制的&lt;code&gt;git&lt;/code&gt;功能。例如，想要为文件目录&lt;code&gt;/Users/Terence/Documents&lt;/code&gt;提供版本控制的功能，那么只需要两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将命令行切换到目标文件目录下：&lt;code&gt;cd /Users/Terence/Documents &lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;运行&lt;code&gt;git init&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时， &lt;code&gt;/Users/Terence/Documents&lt;/code&gt;目录便具备了版本控制功能（其实质是在这个目录下创建了一个&lt;code&gt;.git&lt;/code&gt;隐藏文件夹）。&lt;/p&gt;
&lt;h3&gt;版本控制下的文件修改和提交&lt;/h3&gt;
&lt;p&gt;接下来要讨论具备了&lt;code&gt;git&lt;/code&gt;监控的文件目录下，一个文件会呈现的几个状态。在&lt;code&gt;git&lt;/code&gt;的体系下，一个文件可以具备四种状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Untracked&lt;/li&gt;
&lt;li&gt;Unmodified&lt;/li&gt;
&lt;li&gt;Modified&lt;/li&gt;
&lt;li&gt;Staged&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同状态的同一个文件可以同时彼此独立存在。下面根据&lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository&quot;&gt;Pro Git 2.2&lt;/a&gt;上的一个文件的周期图来做讲解。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot; wp-image-243&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/Gitlifecycle-300x124.png&quot; alt=&quot;&quot; width=&quot;401&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Git File Lifecycle&lt;/p&gt;
&lt;p&gt;下面以从上到下的顺序讲解这几个箭头相关联的状态切换。&lt;/p&gt;
&lt;p&gt;首先是文件的&lt;code&gt;untracked&lt;/code&gt;状态，指的是还未被纳入&lt;code&gt;git&lt;/code&gt;存档体系的文件。虽然这个文件目录通过&lt;code&gt;git init&lt;/code&gt;具备了存档的功能，但还未指定哪些文件的时间线可以被存档。于是这些未被纳入存档的文件的状态便是&lt;code&gt;untracked&lt;/code&gt;。 通过命令&lt;code&gt;git add &amp;lt;filename&amp;gt;&lt;/code&gt;便可以将它纳入&lt;strong&gt;待存档&lt;/strong&gt;（&lt;code&gt;staged&lt;/code&gt;）的状态。（这里可以跳跃一个步骤，提前讲解它最后的状态切换，从通过命令&lt;code&gt;git commit &amp;lt;filename&amp;gt;&lt;/code&gt;让&lt;strong&gt;待存档&lt;/strong&gt;（&lt;code&gt;staged&lt;/code&gt;）状态的文件进入到&lt;code&gt;git&lt;/code&gt;库。此时就变成了&lt;code&gt;git&lt;/code&gt;库的&lt;code&gt;unmodified&lt;/code&gt;状态。）&lt;/p&gt;
&lt;p&gt;再来是文件的&lt;code&gt;unmodified&lt;/code&gt;（未修改）状态。一般在&lt;code&gt;git&lt;/code&gt;界面中将文件名显示为蓝色。一个文件要成为&lt;code&gt;unmodified&lt;/code&gt;状态，首要的前提是它已经被纳入了存档体系、并且它已经被存档。也就是说，它一定是从&lt;strong&gt;待存档&lt;/strong&gt;（&lt;code&gt;staged&lt;/code&gt;）的状态，通过执行命令&lt;code&gt;git commit &amp;lt;filename&amp;gt;&lt;/code&gt;（提交到&lt;code&gt;git&lt;/code&gt;库，也就是把当前的这个状态存储好）后所处的状态。&lt;/p&gt;
&lt;p&gt;然后是文件的&lt;code&gt;modified&lt;/code&gt;状态，也就是对一个文件做了修改后的状态。一般在&lt;code&gt;git&lt;/code&gt;的界面将文件名显示为红色。例如，假设图1.0都所有文件都是&lt;code&gt;unmodified&lt;/code&gt;状态，我们对File2.txt做了修改成为图1.1。此时，File2.txt就是&lt;code&gt;modified&lt;/code&gt;状态。&lt;/p&gt;
&lt;p&gt;最后是文件的&lt;code&gt;staged&lt;/code&gt;状态，也就是&lt;strong&gt;待存储&lt;/strong&gt;状态。一般在&lt;code&gt;git&lt;/code&gt;界面中将文件名显示为绿色。这个&lt;code&gt;staged&lt;/code&gt;状态是非常微妙的一个状态，它能够与&lt;code&gt;modified&lt;/code&gt;状态同时存在。&lt;/p&gt;
&lt;p&gt;举个例子：现在我们假设在图1.1的基础上运行了命令&lt;code&gt;git add File2.txt&lt;/code&gt;，那么此时的文件状态就变成了：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;size-medium wp-image-248&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem3-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.2&lt;/p&gt;
&lt;p&gt;也就是&lt;strong&gt;Yoga&lt;/strong&gt;那一行变成了黑色，也就是&lt;code&gt;unmodified&lt;/code&gt;状态。如果我们对它再做修改，添加文本&lt;strong&gt;L1&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;size-medium wp-image-249&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem4-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.3&lt;/p&gt;
&lt;p&gt;也就是说，此时添加了&lt;strong&gt;L1&lt;/strong&gt;的那一行全部变成了红色。你或许会提出一个疑问，我明明只添加了字符&lt;strong&gt;L1&lt;/strong&gt;，为什么整行都受到了影响？这是因为，&lt;code&gt;git&lt;/code&gt;是以行为单位来考察文件是否有变化。每一行做相应对比，只要有不同，就把整个一行当作有变动的内容处理。&lt;/p&gt;
&lt;p&gt;再运行&lt;code&gt;git add File2.txt&lt;/code&gt;，得到：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;size-medium wp-image-250&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem5-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.4&lt;/p&gt;
&lt;p&gt;可以看到，已处于暂存状态&lt;code&gt;staged&lt;/code&gt;的做了改动的那一行变成了绿色。&lt;/p&gt;
&lt;p&gt;微妙的地方来了，如果此时我们&lt;strong&gt;不提交&lt;/strong&gt;我们这个暂存状态&lt;code&gt;staged&lt;/code&gt;，而是继续修改&lt;code&gt;File2.txt&lt;/code&gt;，将刚加入的字符串&lt;strong&gt;L1&lt;/strong&gt;删去，则我们会得到这个文件的两个状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个处于&lt;code&gt;staged&lt;/code&gt;的图1.4的状态；&lt;/li&gt;
&lt;li&gt;另一个则是处于&lt;code&gt;modified&lt;/code&gt;的状态图1.5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img class=&quot;size-medium wp-image-251&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem6-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.5&lt;/p&gt;
&lt;p&gt;注意，这里图1.5和图1.1虽然是一样的，但表针的意思完全不同。图1.1是从&lt;strong&gt;没有Yoga&lt;/strong&gt;的状态，添加了Yoga字符串后形成的。而图1.5是从状态&lt;strong&gt;Yoga. L1&lt;/strong&gt;删除了字符串L1后形成的。&lt;/p&gt;
&lt;p&gt;此刻，如果我们再运行命令&lt;code&gt;git commit File2.txt&lt;/code&gt;，我们提交到&lt;code&gt;git&lt;/code&gt;仓库的代码将会成为具备&lt;strong&gt;Yoga. L1&lt;/strong&gt;的图1.6&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;size-medium wp-image-252&quot; src=&quot;https://www.terencexie.com/wp-content/uploads/2017/11/FileSystem7-300x182.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1.6&lt;/p&gt;
&lt;p&gt;同时，&lt;code&gt;File2.txt&lt;/code&gt;依旧会保持&lt;code&gt;modified&lt;/code&gt;的状态图1.5。&lt;/p&gt;
&lt;p&gt;希望这个例子能够帮你看出这里的微妙差别。&lt;/p&gt;
&lt;p&gt;总结起来，我们这里涉及到的命令有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;git init&lt;/code&gt;让文件目录具备&lt;code&gt;git&lt;/code&gt;存储功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add &amp;lt;filename&amp;gt;&lt;/code&gt;将未被跟踪的文件（&lt;code&gt;untracked&lt;/code&gt;），或者&lt;code&gt;modified&lt;/code&gt;的文件，添加进暂存状态（&lt;code&gt;staged&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit &amp;lt;filename&amp;gt;&lt;/code&gt;将暂存状态的文件（&lt;code&gt;staged&lt;/code&gt;）添加到&lt;code&gt;git&lt;/code&gt;仓库，成为&lt;code&gt;unmodified&lt;/code&gt;状态。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;什么是GitHub&lt;/h2&gt;
&lt;p&gt;GitHub是一家公司，它提供的服务是为用户提供&lt;code&gt;git&lt;/code&gt;的远程（云端）的&lt;code&gt;git&lt;/code&gt;仓储。其想法就是，你本地有一份文件的版本控制仓库，里面保存了所有文件的时间线。但是，如果你更换了一台电脑，想要再次重现以前那台机器的版本控制仓库，就会很麻烦。于是，一个解决方案便是，为何不将我的这个仓库系统放到云端。既可以随时将本地的修改放到云端，纳入正式的代码库，也可以在本地保留一份自己的代码仓库，做自己的修改。&lt;/p&gt;
&lt;p&gt;更具吸引力的是，一旦你的代码放在了云端，你就可以同其他人合作，在世界的不同地方推进同一个项目。大家保留各自对代码的修改，让云端的代码库成为大家认可的main stream正式存储仓库。大家可以在得到彼此的认同后（也就是后面要讲到的对&lt;code&gt;Pull Request (PR)&lt;/code&gt;的处理），将自己的这份代码修改签入到云端的仓储库，也就是GitHub了。&lt;/p&gt;
&lt;p&gt;所以，从这个角度讲，GitHub是一个提供了云端的代码版本控制的&lt;code&gt;git&lt;/code&gt;仓库平台。从这个意义上讲，GitHub确实是技术人员的社交平台，社交平台中的发朋友圈、发Facebook状态消息等价于不断地展现自己对代码的修改更新。大家是在通过自己的项目状态，来展现各自的工作进展以及最新的项目进展。仔细研究这些版本控制的历史，就能够还原出这个项目、这个工程师的整个成长历史。&lt;/p&gt;
&lt;p&gt;在我看来，使用GitHub的目的无非是两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;学习他人的代码，并希望重现这个项目的结果，或者作出自己的贡献；&lt;/li&gt;
&lt;li&gt;或者是将自己的工作迁移到GitHub上，使得自己的工作能够得到一个云端的备份，或者能够更方便与在不同地理位置的人合作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里，我想展开谈一下这两点的细节和初学者的疑问点。它们本身并不需要太高深的技术来解决。只是，它们会成为初学者的一道屏障。澄清这些模糊的概念，可以极大地提高初学者对GitHub的掌握效率。&lt;/p&gt;
&lt;h2&gt;使用GitHub学习他人的代码&lt;/h2&gt;
&lt;p&gt;写代码如同写文章，要做出好的工作，需要有大量的高质量阅读作前提。GitHub上有大量的优秀项目供人阅读。Programming的各种精髓和技巧，便藏在这一个个优秀的代码细节中。&lt;/p&gt;
&lt;p&gt;通过一般的参考资料，很容易将这些优质的代码&lt;code&gt;clone&lt;/code&gt;到本地，或者更加简单粗暴直接download整个项目的压缩包到你的本地文件目录。&lt;/p&gt;
&lt;p&gt;然后，问题来了：源代码也到手了，可是，怎么把这堆代码变成所需要的目标软件产品呢？编译、运行？可是，从哪里去编译、运行呢？&lt;/p&gt;
&lt;p&gt;这个问题的提出，其实涉及到&lt;strong&gt;学校的小项目&lt;/strong&gt;和真正的&lt;strong&gt;工业界的大项目&lt;/strong&gt;的实践区别。或许在学校学习&lt;code&gt;C&lt;/code&gt;、&lt;code&gt;Java&lt;/code&gt;、&lt;code&gt;Python&lt;/code&gt;的时候，只需要在命令行或者IDE 界面点击个运行就可以了。&lt;/p&gt;
&lt;p&gt;可是，在真实的复杂项目中，编译代码会涉及到更多的细节和步骤。在编译之前需要更多的环境配置、资源准备以及脚本运行。举一些例子，当你的项目足够复杂后：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要编译的的源代码本身或者部分，是需要通过某个文本文档去生成的。而如何从这个文本文档中提取出需要的信息再生成相应的代码，又是由一个脚本所控制的。&lt;/li&gt;
&lt;li&gt;在编译你的源代码前，需要你提供一些第三方的代码库或者代码包。比如&lt;code&gt;Java&lt;/code&gt;的第三方&lt;code&gt;jar&lt;/code&gt;包。而这些第三方的资源文件，是需要你提前准备呢？还是可以通过一个脚本自动获得呢？&lt;/li&gt;
&lt;li&gt;上面提到的工具脚本，或许是由&lt;strong&gt;某个/某几个&lt;/strong&gt;特定语言编写的。你当前环境中，是否提供了支持这些语言的环境呢？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面提到的这些问题和可能性，远远不是仅凭借源代码就可以推断出来的。所以，拿到这堆源代码不知所措，其实是很正常的。&lt;/p&gt;
&lt;p&gt;那么如何解决这个问题呢？&lt;/p&gt;
&lt;p&gt;我的回答是，看你的运气。&lt;/p&gt;
&lt;p&gt;如果你恰好遇到的项目是由习惯不大好或者是不喜欢写文档的程序员写的，或者这个项目的贡献者本身不希望你知道编译环境，估计你也就只能看着这堆代码发呆了。&lt;/p&gt;
&lt;p&gt;如果你运气不坏，那么，真正的严肃项目，会在它自己的文档（通常是这个项目根目录的&lt;code&gt;README&lt;/code&gt;文件）详细说明如何部署编译环境：它包括需要提前准备哪些编译工具、哪些第三方的代码库、如何调用编译的脚本等等。&lt;/p&gt;
&lt;p&gt;所以，当你在GitHub上看到一个项目时，先别急着做download的动作。先仔细阅读这个项目的文档，看看它是否足够优秀。通常，文档的质量和项目的质量成正相关。用业界俗语来解释原因就是：写文档就是写代码，文档写不好，代码通常也是一团糟。&lt;/p&gt;
&lt;h2&gt;如何在GitHub上工作&lt;/h2&gt;
&lt;p&gt;如果仅仅是简单的把GitHub当作自己的一个代码备份库，其实实践操作并不复杂。无非是不断地在本地修改好代码，再将自己认可的代码签入到远程端的GitHub代码库。&lt;/p&gt;
&lt;p&gt;真正有意思的，是在GitHub上与他人合作，一起完成同一个项目。&lt;/p&gt;
&lt;p&gt;要能够一起合作，首先需要在你的项目中添加你合作者的GitHub账号。这个只需要在GitHub的项目界面中，点击&lt;code&gt;Settings —&amp;gt; Collaborators&lt;/code&gt;，在里面添加你的合作者。这样，你的合作者便获得了对这个项目的更改权限，才有资格对这个GitHub上的项目仓库提交代码。&lt;/p&gt;
&lt;p&gt;如果你们同属于某一个GitHub上的Organization，那么这个Organization的管理员通常会设定其成员，自动拥有这个Organization下所有项目的更改权限。&lt;/p&gt;
&lt;p&gt;下面谈谈GitHub上的工作流程。作为&lt;code&gt;git&lt;/code&gt;的核心，它是以&lt;code&gt;branch&lt;/code&gt;做核心驱动的。&lt;code&gt;master&lt;/code&gt;branch作为主分支，一定要保证它是可以运行的和经过测试的。而你可以在其它的&lt;code&gt;branch&lt;/code&gt;上做自己的feature开发、实验和测试，而完全不会影响代码库的主分支&lt;code&gt;master&lt;/code&gt;branch。&lt;/p&gt;
&lt;p&gt;那么，在GitHub上是同样的。当几个人组成一个团队合作一个项目时，每个成员不应该轻易地直接提交代码到&lt;code&gt;master branch&lt;/code&gt;，即便是你有这样的权限。作为良好的实践规范，你永远应该在自己的私人分支上做代码修改和实验，然后将这个分支&lt;code&gt;push&lt;/code&gt;到GitHub，在GitHub上对这个分支执行&lt;code&gt;Pull Request&lt;/code&gt;来让团队的其他人员review你的代码。当reviewer认可了你的代码后，你才能把你的修改分支&lt;code&gt;merge&lt;/code&gt;到&lt;code&gt;master&lt;/code&gt;。也就是说，&lt;strong&gt;任何人对&lt;code&gt;master&lt;/code&gt;的代码提交之前，必须有其他人的code review这一步；没有其他人的coder review，你不可以向&lt;code&gt;master&lt;/code&gt;分支提交代码即便是你有这个权限&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而在这个&lt;code&gt;Pull Request&lt;/code&gt;的过程中，审核者和被审核者可以对代码的每一行做深入的讨论。每一行代码都可以插入相应的评论，供大家去做深入研究。这些讨论，是整个代码设计的精髓，也是代码功底提升的真正关键。再次回到那句老话，写文档即写代码，它传达的精神便是：你的思想和看法才是支撑整个代码的核心。而某种具体编程语言的书写只是这种思想的一种表达。你只有先整理好了思路、要解决的问题的脉络，你才可以写出清晰的代码。&lt;/p&gt;
&lt;p&gt;甚至，在所谓的合作而其实是师傅带徒弟的过程中，这些code review的价值会远远高于push code。因为push code只是一个结果，而code review的comments讨论，才是帮助你指正问题、更改坏习惯的核心所在。&lt;/p&gt;
&lt;p&gt;而往往初学者又不太明白这一点，误以为这些comments的讨论是配菜，对这些comments的讨论极其不耐烦，一心只想把code签入到代码库。所以，作为mentor他其实是有责任向自己的apprentice指出这个差异与优先级的。&lt;/p&gt;
&lt;p&gt;让我们再强调一次，无论作为学徒还是作为平等的合作者，那些review过程中的comments交流才是整个代码的核心，它们是整个项目的指导思想与精神纲领。只有在review的过程中将问题一步步弄清楚了，你才能够更加容易和自信地修改代码，才能够保证代码库的质量水准。任何轻视code review或者review中的comments的行为，都是一种天真的自我欺骗。你需要拿出同写代码一样的严肃认真，来对待整个code review，来对待review过程中的comments交流。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484036&amp;amp;idx=1&amp;amp;sn=1657bfb9cbb1f45362320f7cf5a80560&amp;amp;chksm=ec20e538db576c2ea67ce43a99ade18b20179029201ed54d597f1a0d6ab5c0f067292bed59bf&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;打造让用户为自己尖叫的产品&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484032&amp;amp;idx=1&amp;amp;sn=5fd326c2a78858015e1a2326072cdb46&amp;amp;chksm=ec20e53cdb576c2afab8e268b58c446f4dfba5fb313cda2dcb5fe2dfd53f3c7459f7ed876c8d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;2017年10月写字总结&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484025&amp;amp;idx=1&amp;amp;sn=67bd3768a5739ab8f12f6b275aae3847&amp;amp;chksm=ec20e5c5db576cd3b9354b46678aa85d9eaab8f07d1d3465fa54d8557c9e670ac68bf7271ae4&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;平台框架-101&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPJg8BcFPOe0ibTXw7w4PxMOUQicquOuUmwrQibzU1jAV5q828bIOib5iau8WK4rFSKwIQwicrKZhyJCibLA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPJg8BcFPOe0ibTXw7w4PxMOUQicquOuUmwrQibzU1jAV5q828bIOib5iau8WK4rFSKwIQwicrKZhyJCibLA/0?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VIP赞赏专区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPJg8BcFPOe0ibTXw7w4PxMOzjdGuTU4pNRFGropHlR1t7ibgYZregHGUiaTIFqO8YHaU13aE6CEQWNw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; width=&quot;57%&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPJg8BcFPOe0ibTXw7w4PxMOzjdGuTU4pNRFGropHlR1t7ibgYZregHGUiaTIFqO8YHaU13aE6CEQWNw/0?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1152&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Nov 2017 14:45:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/7806719.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core中的OWASP Top 10 十大风险-失效的访问控制与Session管理 - 东城慕水</title>
<link>http://www.cnblogs.com/chen-jie/p/owasp-top-10-asp-net-core-broken-authentication-session-management.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chen-jie/p/owasp-top-10-asp-net-core-broken-authentication-session-management.html</guid>
<description>&lt;p&gt;&lt;strong&gt;不定时更新翻译系列，此系列更新毫无时间规律，文笔菜翻译菜求各位看官老爷们轻喷，如觉得我翻译有问题请挪步原博客地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本博文翻译自：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://dotnetcoretutorials.com/2017/10/16/owasp-top-10-asp-net-core-broken-authentication-session-management/&quot;&gt;&lt;strong&gt;https://dotnetcoretutorials.com/2017/10/16/owasp-top-10-asp-net-core-broken-authentication-session-management/&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在我们之前关于OWASP Top 10的文章中，我们讨论了SQL注入。SQL注入有一个非常明确的解释和例子，但这次我们讲的个关于“失效的访问控制和Session管理”有一个更开放的结尾。它涵盖了从糟糕的密码存储系统(纯文本，弱哈希)到通过Session暴露用户的所有内容(例如，URL中的Session字符串)，我们演示的所有方法都是相对简单的，例如超时验证session。&lt;/p&gt;
&lt;p&gt;和往常一样，虽然我们在这里讨论的话题是如何保护ASP.net Core应用程序让它有个好的开始，但这绝不是我们保护道路的尽头。特别是当涉及到密码的哈希时。这是一款总是与最新的威胁保持同步的游戏，我们需要时刻更新我们的的应用程序。&lt;/p&gt;
&lt;p&gt;让我们开始吧！&lt;/p&gt;
&lt;h3 id=&quot;密码哈希化&quot;&gt;密码哈希化&lt;/h3&gt;
&lt;p&gt;不言而喻，存储在数据库中的所有密码应该被哈希化并且具有单独的salt（稍后更多关于单独的salt的信息）。在任何情况下，密码都不能以纯文本形式存储。当您存储纯文本密码时，您不仅会冒着被黑客攻击的风险，而且网站上的用户帐户可能会被盗用，但由于人们倾向于在多个网站上使用相同的密码，所以在他们使用的每个网站上，你都有可能成为用户痛苦的来源。&lt;/p&gt;
&lt;h4 id=&quot;使用-asp.net-core-identity&quot;&gt;使用 ASP.net Core Identity&lt;/h4&gt;
&lt;p&gt;如果您使用ASP.net Core Identity框架，你将会有安全的密码哈希和使用的单独的salt。Identity使用PBKDF2哈希函数来输入密码，并且它们会为每个用户生成一个随机salt。理想情况下，如果你不确定你在做什么，那就现在开始使用吧! &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?tabs=visual-studio%2Caspnetcore2x&quot;&gt;微软在启动和运行框架方面确实有很好的文档&lt;/a&gt;.。&lt;/p&gt;
&lt;h4 id=&quot;让我们开始动手吧&quot;&gt;让我们开始动手吧&lt;/h4&gt;
&lt;p&gt;虽然现在开始使用ASP.net Core Identity框架是绝对可取的，但有时你需要自己动手。但你自己动手的版本只能扩展C＃代码用来验证，&lt;strong&gt;在任何情况下你都不应该“发明”自己的哈希算法来存储密码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;OWASP建议使用4种不同的单向哈希函数来存储密码。他们分别是Argon2，PBKDF2，scrypt和bcrypt。如果你打算编写你自己的认证层，你必须使用其中的一个。&lt;/p&gt;
&lt;h3 id=&quot;什么是salt&quot;&gt;什么是Salt？&lt;/h3&gt;
&lt;p&gt;Salt是在哈希之前向您的密码添加随机字符串的行为。这样，即使相同的密码被哈希化，所得到的哈希值将会不同...是不是有些疑惑？我们用一个例子。本例中我将使用PBKDF2哈希函数。&lt;/p&gt;
&lt;p&gt;比方说，我正在使用密码 apples4tea 。当我哈希化密码时我得到的结果： &lt;code&gt;09ADB1C51A54C33C11CD3AE113D820305EFA53A173C2FF4A3150B5EC934E76FF&lt;/code&gt; 。现在，如果第二个用户注册到我的网站并使用相同的密码，他们将得到完全相同的哈希值。您可以在这里使用&lt;a href=&quot;https://asecuritysite.com/encryption/PBKDF2z&quot;&gt;PBKDF2在线计算器&lt;/a&gt;来自己测试。为什么这不好？因为这意味着任何黑客基本上都可以“预先计算”密码哈希值（例如，现在就拿一个最流行的密码列表），然后在数据库中简单地进行字符串比较。&lt;/p&gt;
&lt;p&gt;在此基础上，这意味着共享相同密码的所有用户具有相同的哈希值。当一个用户的密码被“破解”或者甚至被猜出时，任何使用相同密码的人现在也都泄露了他们的密码。&lt;/p&gt;
&lt;p&gt;现在我为用户添加一个随机Salt值，我将它连接到密码的开始处。第一次我的Salt值是 &lt;code&gt;H786Bnh54A&lt;/code&gt; 。哈希化后&lt;code&gt;H786Bnh54Aapples4tea&lt;/code&gt;的完整字符串 给了我 &lt;code&gt;DfsjpycJwtWkOu8UcP8YXC / G09HES8LU + kku0iSllO4 =&lt;/code&gt;的哈希值 。另一个用户注册到该站点，并随机生成一个Salt值给他们 &lt;code&gt;76HNhg67Ac&lt;/code&gt; 。现在我们使用相同的密码对salt进行哈希化，最后得到一个哈希值 &lt;code&gt;RP62 + SmFCJLeQzROTtk5HpMId0zuFtsPeBFuBLpH / Sc =&lt;/code&gt;。现在我们有相同的密码，但有不同的哈希值。&lt;/p&gt;
&lt;p&gt;众所周知，Adobe在2013年有一个巨大的数据泄露，泄露了用户的密码。密码并不是每个用户都加了Salt值，最糟糕的是，所有密码提示都存储在密码的旁边。也就是说，如果一个提示帮助您猜测一个用户密码，那么使用相同密码的任何用户在数据库中都会有相同的哈希值! &lt;a href=&quot;https://nakedsecurity.sophos.com/2013/11/04/anatomy-of-a-password-disaster-adobes-giant-sized-cryptographic-blunder/&quot;&gt;Sophos在这里做了一个很好的报告&lt;/a&gt;.&lt;br/&gt;&lt;img src=&quot;https://i1.wp.com/dotnetcoretutorials.com/wp-content/uploads/2017/10/encryptic.png?resize=473%2C541&quot; title=&quot;encryptic&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你使用的是ASP.net Identity，那么salt会和密码一起存储在数据库中的同一列（因为salt每次都是相同的长度，所以我们只把这些字符当作salt来计算，其余部分就是哈希值）。在先前的ASP迭代中（在.NET完整框架中），salt存储在一个单独的列中。然而只要每个用户都有salt，而不是整个应用程序范围内拥有，就都可以。&lt;/p&gt;
&lt;h3 id=&quot;暴露session标识符&quot;&gt;暴露Session标识符&lt;/h3&gt;
&lt;p&gt;在以前的ASP.net版本中，你可以有一个“无cookie”的session。然后，您会看到与以下网址相似的网址：&lt;code&gt;http：//www.example.com/(S(lit3py55t21z5v55vlm25s55))/orderform.aspx&lt;/code&gt; 。会话数据实际上包含在URL中而不是cookie中。由于多种原因，这造成了严重的后果。想象一下把这个URL发给一个朋友，现在他们可以访问你的会话数据！更糟糕的是，如果您点击此页面上的任何出站链接，引用链接头将被设置为包含您的session。&lt;/p&gt;
&lt;p&gt;在ASP.net Core中无cookie的sessions实际上从来没有实现，所以你不会看到这样的URL。但这并不意味着人们不会用自己的方式实现类似的东西。简而言之，通过任何方式给予另一个用户的URL都不能突然冒充用户。&lt;/p&gt;
&lt;h3 id=&quot;通过未加密的连接发送数据&quot;&gt;通过未加密的连接发送数据&lt;/h3&gt;
&lt;p&gt;实际上有一个关于加密连接的完整的OWASP Top 10文章，但是这里值得特别提一下。即使你的密码全部被用户salt哈希化，而且你也不会在URL中暴露Session标识符，但是如果你容易受到“中间人”攻击的话，这意味着根本没有安全。一个用户连接到一些不可靠的开放wifi，可能意味着他们在登录时无意中泄露了我们的明文密码。&lt;/p&gt;
&lt;p&gt;SSL意味着您从用户计算机到服务器进行加密，无论它需要什么路由 - 包括狡猾的wifi。鉴于免费的SSL提供商如Let's Encrypt的出现，甚至像Cloudflare这样的网站提供免费的SSL。没有理由不利用SSL来保护您的用户。&lt;/p&gt;
&lt;h3 id=&quot;锁定超时等等&quot;&gt;锁定，超时，等等&lt;/h3&gt;
&lt;p&gt;最后，我们在本文中已经讨论了ASP.net Core Identity。但我想再次指出的是，良好的习惯对这有多大的影响。我们来看看通常放置在您的Configure Services方法中的Identity的设置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.Configure&amp;lt;IdentityOptions&amp;gt;(options =&amp;gt;
{
    // Password settings
    options.Password.RequireDigit = true;
    options.Password.RequiredLength = 8;
    options.Password.RequireNonAlphanumeric = false;
    options.Password.RequireUppercase = true;
    options.Password.RequireLowercase = false;
    options.Password.RequiredUniqueChars = 6;
 
 
    options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(30);
    options.Lockout.MaxFailedAccessAttempts = 10;
 
    options.SignIn.RequireConfirmedEmail = true;
    
    options.User.RequireUniqueEmail = true;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看你在这里的选项。有很好的密码执行选项（尽管你可以提出一些论点：但不要过分要求像字母数字这样的东西，因为人们倾向于把它们写在纸上...），如果他们锁定用户帐户不断输入错误的密码，甚至需要电子邮件确认（这也是身份框架的一部分）。&lt;/p&gt;
&lt;p&gt;而在cookies如何存储在用户机器上，我们有这些选项：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.ConfigureApplicationCookie(options =&amp;gt;
{
    options.Cookie.HttpOnly = true;
    options.Cookie.Expiration = TimeSpan.FromHours(1)
    options.SlidingExpiration = true;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又一次很棒的实践。用户cookie在默认情况下应该总是有一个过期值。一个来自OWASP的例子甚至明确指出了在攻击的例子中公共计算机session超时的问题:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i1.wp.com/dotnetcoretutorials.com/wp-content/uploads/2017/10/AttackScenario.png?resize=720%2C55&quot; title=&quot;AttackScenario&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在此基础上，我们应该尽可能使用HttpOnly cookie。当一个cookie被设置为HttpOnly时，这意味着它不能通过Javascript访问（因此，可能存在XSS漏洞），并且只能在作为请求的一部分发送时才能被访问。&lt;/p&gt;
&lt;p&gt;我之所以使用这些例子，是因为它们是在进行身份验证和session管理时最佳实践指南。即使您决定自己动手，您也应该调查Identity给您的是什么，这样您就可以复制一些或所有的功能，并且始终保持对框架最新的的改进。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;身份验证和session管理是一个广泛的话题，我认为它被一些呆滞的遗留应用程序所困扰。通常，当我向新的开发人员展示诸如session标识符之类的东西时，他们无法想象为什么有人会这样做。“人们真的认为那是安全的吗?”这是我与之合作的一名初级开发人员的和我说过的话。我认为这是这个话题的本质，我们需要站在新安全的前沿，在认证和使用session的时候，我们要保持领先&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎转载，转载请注明翻译原文出处(本文章)，原文出处(原博客地址)，然后谢谢观看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果觉得我的翻译对您有帮助，请点击推荐支持：）&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Nov 2017 14:44:00 +0000</pubDate>
<dc:creator>东城慕水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chen-jie/p/owasp-top-10-asp-net-core-broken-authentication-session-management.html</dc:identifier>
</item>
<item>
<title>计算方法（一）——计算机求积分方法，机械求积法 - coding==1？</title>
<link>http://www.cnblogs.com/jake9402/p/7806660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jake9402/p/7806660.html</guid>
<description>

&lt;h3&gt;&lt;span&gt;转载请注明出处！&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;一、引言&lt;/h3&gt;
&lt;p&gt;　&lt;span&gt;　随着人工智能的兴起，在计算机领域又一次掀起了数学热，不管是传统的机器学习，还是现在的深度学习，都离不开积分的支撑，那计算机在底层到底是怎样求积分的呢?小编同大家一起探讨。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;二、理论推导&lt;/h3&gt;
&lt;p&gt;　　　　&lt;span&gt;我们知道，在我们所学的微积分中我们是通过牛顿-莱布尼兹公式进行求解，然而在实际运用中我们往往会遇到比较复杂的函数，他们的原函数我们往往是找不到的，这个时候我们应该怎么求解呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们不难想的办法是定义法，也就是把区间进行划分，当分点非常多的时候我们就可以用矩形面积代替曲线所围成的面积，然而我们为了得到精度很高的结果往往需要划分等多区间，这样计算的次数将大大增加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那应该怎么优化呢？这里我们介绍一种求积分的办法：机械求积法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　机械求积分法前戏：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　 在微积分中我们求定积分时不仅有牛顿-莱布尼兹公式，同时还有积分中值定理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　　　若函数&lt;img title=&quot;&quot; src=&quot;https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D32/sign=ecebdb93013b5bb5bad726fc37d3f49b/a9d3fd1f4134970af491ca1797cad1c8a7865d2c.jpg&quot; alt=&quot;&quot; width=&quot;32&quot; height=&quot;18&quot; align=&quot;absmiddle&quot;/&gt;在&lt;a href=&quot;https://baike.baidu.com/item/%E9%97%AD%E5%8C%BA%E9%97%B4&quot; target=&quot;_blank&quot;&gt;闭区间&lt;/a&gt; &lt;img title=&quot;&quot; src=&quot;https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D31/sign=c7de85d8f503918fd3d13bcb503d9cb2/91ef76c6a7efce1b39ef1af2ad51f3deb58f65c6.jpg&quot; alt=&quot;&quot; width=&quot;31&quot; height=&quot;17&quot; align=&quot;absmiddle&quot;/&gt; 上连续,，则在积分区间&lt;img title=&quot;&quot; src=&quot;https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D31/sign=c7de85d8f503918fd3d13bcb503d9cb2/91ef76c6a7efce1b39ef1af2ad51f3deb58f65c6.jpg&quot; alt=&quot;&quot; width=&quot;31&quot; height=&quot;17&quot; align=&quot;absmiddle&quot;/&gt;上至少存在一个点&lt;img title=&quot;&quot; src=&quot;https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D8/sign=824a5dbfd2a20cf44290f3ee768039/c9fcc3cec3fdfc03498d3980d63f8794a4c22615.jpg&quot; alt=&quot;&quot; width=&quot;8&quot; height=&quot;8&quot; align=&quot;absmiddle&quot;/&gt;，使下式成立&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171108214347450-601802761.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　其中，a、b、&lt;img title=&quot;&quot; src=&quot;https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D8/sign=824a5dbfd2a20cf44290f3ee768039/c9fcc3cec3fdfc03498d3980d63f8794a4c22615.jpg&quot; alt=&quot;&quot; width=&quot;8&quot; height=&quot;8&quot; align=&quot;absmiddle&quot;/&gt;满足：a≤&lt;img title=&quot;&quot; src=&quot;https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D8/sign=824a5dbfd2a20cf44290f3ee768039/c9fcc3cec3fdfc03498d3980d63f8794a4c22615.jpg&quot; alt=&quot;&quot; width=&quot;8&quot; height=&quot;8&quot; align=&quot;absmiddle&quot;/&gt;≤b。&lt;sup&gt;[&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　我们从上式子出发，将求积分的问题转化为找某一个&lt;img title=&quot;&quot; src=&quot;https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D8/sign=824a5dbfd2a20cf44290f3ee768039/c9fcc3cec3fdfc03498d3980d63f8794a4c22615.jpg&quot; alt=&quot;&quot; width=&quot;8&quot; height=&quot;8&quot; align=&quot;absmiddle&quot;/&gt;的问题，那怎么替代呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　假设我们的函数是一个0次函数也就是一个F(x) = C 是一个常函数时候，在[a,b]区间的定积分就是(a-b)*f(a),也就是矩形面积，这样我们的f(&lt;img title=&quot;&quot; src=&quot;https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D8/sign=824a5dbfd2a20cf44290f3ee768039/c9fcc3cec3fdfc03498d3980d63f8794a4c22615.jpg&quot; alt=&quot;&quot; width=&quot;8&quot; height=&quot;8&quot; align=&quot;absmiddle&quot;/&gt;)=f(a)，我们继续加入是一次的呢？F(x) = ax + b&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　我们很容易想到这个图形是一个梯形。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171108215050825-539397551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;　因而其积分=(b-a)*[f(a)+f(b)]/2，这就是我们的梯形公式，这里的f(&lt;img title=&quot;&quot; src=&quot;https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D8/sign=824a5dbfd2a20cf44290f3ee768039/c9fcc3cec3fdfc03498d3980d63f8794a4c22615.jpg&quot; alt=&quot;&quot; width=&quot;8&quot; height=&quot;8&quot; align=&quot;absmiddle&quot;/&gt;)=[f(a)+f(b)]/2,那问题来了，要是函数是一个不规则的曲线呢？那我们该怎么做呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171108215314184-207205407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;很容易想到的就是把区间细分成很多个小区间，然后在每个区间找一个合适的f(&lt;img title=&quot;&quot; src=&quot;https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D8/sign=824a5dbfd2a20cf44290f3ee768039/c9fcc3cec3fdfc03498d3980d63f8794a4c22615.jpg&quot; alt=&quot;&quot; width=&quot;8&quot; height=&quot;8&quot; align=&quot;absmiddle&quot;/&gt;),然后再求积分，再求和就好了，是的这就是们的思路，这个办法就是机械求积法。我们下面给出定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;&lt;strong&gt;机械求积法：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171108215948059-433579684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;三、代数精度概念&lt;/h3&gt;
&lt;p&gt;　　 &lt;span&gt;在知道机械求积公式之后，那我们怎么检验一个求积公式的好坏的？这里我们引入代数精度的概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　如果某个求积公式对于次数不超过m的多项式均能准确成立，而对于m+1次的的多项式不准确成立，则称该公式具有m次代数精度。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　（代数精度越高，越精确）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;我们来看看梯形公式的代数精度：(在验证时候只要取1,x,x^2,x^3.......等就行了，其他都可以由这几个组合而成)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　F(x) = (b-a)*[f(a)+f(b)]/2,当 f(x) = 1时候，设a=0,b=1,显然成立,而f(x) = x 时，用牛顿-莱布尼兹公式算得：x^2/2|&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;/span&gt; = &lt;span&gt;0.5,而用梯形公式得到的也是0.5，&lt;span&gt;这样对于f(x) = x时也精确成立，而当f(x) = x^2时候则不成了，那么我们就说&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　梯形公式具有一次代数精度，其他的代数精度的确定方法也同上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;四、插值型求积公式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　我们在第二部分时候知道，我们的目的就是不断的划分区间直到有办法精确的求出积分（找到f(&lt;img title=&quot;&quot; src=&quot;https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D8/sign=824a5dbfd2a20cf44290f3ee768039/c9fcc3cec3fdfc03498d3980d63f8794a4c22615.jpg&quot; alt=&quot;&quot; width=&quot;8&quot; height=&quot;8&quot; align=&quot;absmiddle&quot;/&gt;)),此外呢，我们还可以通过插值法拟合曲线，把问题转化为数值问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　（没有接触插值法的可以移步） &lt;a href=&quot;http://www.cnblogs.com/jake9402/p/7572260.html&quot;&gt;见鬼吧拉格朗日插值法&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　这里我们用插值得到的插值多项式子替代原函&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171108222301981-943494391.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1201753/201711/1201753-20171108222645278-1488365223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这就是插值型积分公式，这样我们就通过插值法可以减少运算，然而这并不是我们最终要的，这只是个开始，更牛的还在后头，请持续关注Jack计算方法系列博客。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;转载请注明出处！&lt;/span&gt;&lt;/p&gt;



</description>
<pubDate>Wed, 08 Nov 2017 14:32:00 +0000</pubDate>
<dc:creator>coding==1？</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jake9402/p/7806660.html</dc:identifier>
</item>
<item>
<title>vue 响应式原理 - 阿林十一</title>
<link>http://www.cnblogs.com/alsy/p/7801029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alsy/p/7801029.html</guid>
<description>&lt;p&gt;Vue 采用声明式编程替代过去的类 Jquery 的命令式编程，并且能够侦测数据的变化，更新视图。这使得我们可以只关注数据本身，而不用手动处理数据到视图的渲染，避免了繁琐的 DOM 操作，提高了开发效率。不过理解其工作原理同样重要，这样可以回避一些常见的问题，下面我们来介绍一下 Vue 是如何侦测数据并响应视图的。&lt;/p&gt;
&lt;h3 id=&quot;h3-3&quot;&gt;Object.defineProperty&lt;/h3&gt;
&lt;p&gt;Vue 数据响应核心就是使用了 &lt;code&gt;Object.defineProperty &lt;/code&gt;方法（ IE9 + ) 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {};
Object.defineProperty(obj, &lt;/span&gt;'msg'&lt;span&gt;, {
  get () {
    console.log(&lt;/span&gt;'get'&lt;span&gt;);
  },
  set (newVal) {
    console.log(&lt;/span&gt;'set'&lt;span&gt;, newVal);
  }
});
obj.msg &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; get&lt;/span&gt;
obj.msg = 'hello world' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set hello world&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取 obj 对象中 msg 的值时会调用 get 方法，给 msg 赋值时会调用 set 方法，并接收新值作为其参数。&lt;/p&gt;
&lt;p&gt;这里提一句，在 Vue 中我们调用数据是直接 this.xxx ，而数据其实是 this.data.xxx，原来 Vue 在初始化数据的时候会遍历 data 并代理这些数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
Object.keys(&lt;span&gt;this&lt;/span&gt;.data).forEach((key) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.proxyKeys(key);
});

proxyKeys (key) {
    Object.defineProperty(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, key, {
        enumerable: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        configurable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        get() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data[key];
        },
        set(newVal) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data[key] =&lt;span&gt; newVal;
        }
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面可以看到，取 this.key 的值其实是取 this.data.key 的值，赋值同理。&lt;/p&gt;
&lt;p&gt;现在，我们已经知道如何去检测数据的变化，并且做出一些响应了。&lt;/p&gt;
&lt;h3 id=&quot;h3-4&quot;&gt;观察者模式 ( 发布者-订阅者模式 )&lt;/h3&gt;
&lt;p&gt;vue 的响应式系统依赖于三个重要的类：Dep 类、Watcher 类、Observer 类。&lt;/p&gt;
&lt;p&gt;Dep 类作为发布者的角色，Watcher 类作为订阅者的角色，Observer 类则是连接发布者和订阅者的纽带，决定订阅和发布的时机。&lt;/p&gt;
&lt;p&gt;我们先看下面的代码，来对发布者和订阅者有个初步的了解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Dep {
    constructor() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subs =&lt;span&gt; [];
    }

    addSub(watcher) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subs.push(watcher);
    }

    notify() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subs.forEach(watcher =&amp;gt;&lt;span&gt; {
            watcher.update();
        });
    }
}

class Watcher {
    constructor() { 
    }

    update() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收通知后的处理方法&lt;/span&gt;
&lt;span&gt;    }
}

const dep &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dep(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布者 dep&lt;/span&gt;
const watcher1 = &lt;span&gt;new&lt;/span&gt; Watcher(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅者1 watcher1&lt;/span&gt;
const watcher2 = &lt;span&gt;new&lt;/span&gt; Watcher(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅者2 watcher2&lt;/span&gt;
dep.addSub(watcher1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; watcher1 订阅 dep&lt;/span&gt;
dep.addSub(watcher2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; watcher2 订阅 dep&lt;/span&gt;
dep.notify(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; dep 发送通知&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面我们定义了一个发布者 dep，两个订阅者 watcher1、watcher2。让 watcher1、watcher2 都订阅 dep，当 dep 发送通知时，watcher1、watcher2 都能做出各自的响应。&lt;/p&gt;
&lt;p&gt;现在我们已经了解了发布者和订阅者的关系，那么剩下的就是订阅和发布的时机。什么时候订阅？什么时候发布？想到上面提到的 Object.defineProperty ，想必你已经有了答案。&lt;/p&gt;
&lt;p&gt;我们来看 Observer 类的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Observer {
    constructor(data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.walk();
    }

    walk() {
        Object.keys(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data).forEach(key =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.defineReactive(&lt;span&gt;this&lt;/span&gt;.data, key, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data[key]);
        });
    }

    defineReactive(data, key, value) {
        const dep &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dep();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( value &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; value === 'object'&lt;span&gt; ) {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Observer(value);
        }

        Object.defineProperty(data, key, {
            enumerable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            configurable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            get() {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Dep.target) {
                    dep.addSub(Dep.target); // 订阅者订阅 Dep.target 即当前 Watcher 类的实例（订阅者）
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
            },
            set(newVal) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newVal ===&lt;span&gt; value) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
                value &lt;/span&gt;=&lt;span&gt; newVal;
                dep.notify(); // 发布者发送通知
            }
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 Observer 类中，为 data 的每个属性都实例化一个 Dep 类，即发布者。并且在取值时让订阅者（有多个，因为 data 中的每个属性都可以被应用在多个地方）订阅，在赋值时发布者发布通知，让订阅者做出各自的响应。&lt;/p&gt;
&lt;p&gt;这里需要提的是 Dep.target，这其实是 Watcher 类的实例，我们可以看看 Watcher 的详细代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Watcher {
    constructor(vm, exp, cb) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vm = vm;
        &lt;span&gt;this&lt;/span&gt;.exp = exp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; data 属性名&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.cb = cb; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调函数&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将自己添加到订阅器&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.value = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getValue();
    }

    update() {
        const value &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.vm.data[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.exp];
        const oldValue &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value !==&lt;span&gt; oldValue) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cb.call(&lt;span&gt;this&lt;/span&gt;.vm, value, oldValue); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行回调函数&lt;/span&gt;
&lt;span&gt;        }
    }

    getValue() {
        Dep.target &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将自己赋值给 Dep.target&lt;/span&gt;
        const value = &lt;span&gt;this&lt;/span&gt;.vm.data[&lt;span&gt;this&lt;/span&gt;.exp]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取值操作触发订阅者订阅&lt;/span&gt;
        Dep.target = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Watcher 类在构造函数中执行了一个 getValue 方法，将自己赋值给 Dep.target ，并且执行了取值操作，这样就成功的完成了订阅操作。一旦数据发生变化，即有了赋值操作，发布者就会发送通知，订阅者就会执行自己的 update 方法来响应这次数据变化。&lt;/p&gt;
&lt;h3 id=&quot;h3-4&quot;&gt;数据的双向绑定&lt;/h3&gt;
&lt;p&gt;数据的双向绑定即数据和视图之间的同步，视图随着数据变化而变化，反之亦然。我们知道 Vue 是支持数据的双向绑定的，主要应用于表单，是通过 v-model 指令来实现的。而通过上面介绍的知识我们是可以知道如何实现视图随着数据变化的，那么如何让数据也随着视图变化而变化呢？其实也很简单，只要给有 v-model 指令的节点监听相应的事件即可，在事件回调中来改变相应的数据。这一切都 Compile 类中完成，假设有一个 input 标签应用了 v-model 指令，在开始编译模板时，遇到 v-model 指令时会执行：更新 dom 节点的值，订阅者订阅，事件监听。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;compileModel (node, vm, exp) {
    let val &lt;/span&gt;=&lt;span&gt; vm[exp];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新内容&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.modelUpdater(node, val);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加订阅&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt; Watcher(vm, exp, (value) =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据改变时的回调函数&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.modelUpdater(node, value);
    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件监听&lt;/span&gt;
    node.addEventListener('input', (e) =&amp;gt;&lt;span&gt; {
        const newValue &lt;/span&gt;=&lt;span&gt; e.target.value;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (val ===&lt;span&gt; newValue) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        vm[exp] &lt;/span&gt;=&lt;span&gt; newValue;
        val &lt;/span&gt;=&lt;span&gt; newValue;
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们在文本框中输入数据时，会给原有 data 中的某个属性 a 赋值，这时候会触发发布者发起通知，那么所有属性 a 的订阅者都能够同步到最新的数据。&lt;/p&gt;
&lt;p&gt;最后，附上一个小 &lt;a title=&quot;demo&quot; href=&quot;http://jsfiddle.net/ao5rcnny/8/?utm_source=website&amp;amp;utm_medium=embed&amp;amp;utm_campaign=ao5rcnny&quot; target=&quot;_blank&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Nov 2017 13:12:00 +0000</pubDate>
<dc:creator>阿林十一</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alsy/p/7801029.html</dc:identifier>
</item>
<item>
<title>Spring框架学习之注解配置与AOP思想 - Single_Yam</title>
<link>http://www.cnblogs.com/yangming1996/p/7806079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangming1996/p/7806079.html</guid>
<description>&lt;p&gt;     上篇我们介绍了Spring中有关高级依赖关系配置的内容，也可以调用任意方法的返回值作为属性注入的值，它解决了Spring配置文件的动态性不足的缺点。而本篇，我们将介绍Spring的又一大核心思想，AOP，也就是面向切面编程。这是对面向对象编程的一个扩展，即便问世不长，但是已经成为当下最流行的编程思想之一。本篇主要涉及以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring中的后置处理器&lt;/li&gt;
&lt;li&gt;&quot;零配置&quot;实现Bean的配置&lt;/li&gt;
&lt;li&gt;Spring AOP&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一、后置处理器&lt;/strong&gt;&lt;br/&gt;为了实现良好的扩展性，Spring允许我们扩展它的IOC容器，它提供了两种后置处理器来支持我们对容器进行扩展。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bean后置处理器：该处理器会对容器中的bean进行增强&lt;/li&gt;
&lt;li&gt;容器后置处理器：该处理器针对容器，对容器进行额外增强&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1、Bean后置处理器&lt;/strong&gt;&lt;br/&gt;Bean后置处理器需要继承接口BeanPostProcessor，并实现它的如下两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public Object postProcessBeforeInitialization(Object o, String s)：在当前bean实例初始化属性注入的之前回调&lt;/li&gt;
&lt;li&gt;public Object postProcessAfterInitialization(Object o, String s)：在当前bean实例初始化属性注入之后回调&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当整个容器在加载的时候，会扫描整个容器中的bean，如果发现有bean实现了接口BeanPostProcessor，那么就将该bean注册为Bean后置处理器，一旦其他bean实例化完成之后，将逐个调用后置处理器进行bean实例的增强。&lt;/p&gt;
&lt;p&gt;在这两个方法中，传入了同样的两个参数，第一个参数表示即将被后处理的bean实例，第二个参数是该实例在容器中的 id属性。postProcessBeforeInitialization方法指明在容器创建实例之后，但是在实际初始化属性之前回调，此处传过来的bean实例是一个完整的实例，它包含还未实际初始化的属性的值信息，该方法的返回值就是最终保存在容器中的实例。&lt;/p&gt;
&lt;p&gt;postProcessAfterInitialization方法是类似的，它会在容器初始化属性结束后回调，在该方法中，我们也可以修改该bean的信息，最终返回的bean将作为容器中真实存在的bean，对应于传入的该bean的引用，相当于修改了该bean实例。&lt;/p&gt;
&lt;p&gt;我们简单看个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//定义两个类，并定义两个属性name和age
//容器中配置两个bean实例
&amp;lt;bean id=&quot;programmer&quot; class=&quot;Test_spring.Programmer&quot; p:name=&quot;single&quot; p:age=&quot;22&quot; /&amp;gt;

&amp;lt;bean id=&quot;coder&quot; class=&quot;Test_spring.Coder&quot; p:name=&quot;walker&quot; p:age=&quot;21&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//定义Bean后置处理器
public class MyBeanProcess implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object o, String s) throws BeansException {
        //属性初始化之前
        if(o instanceof Programmer){
            Programmer programmer = (Programmer) o;
            programmer.setAge(50);
        }else if(o instanceof Coder) {
            Coder coder = (Coder) o;
            coder.setAge(60);
        }
        return o;
    }
    @Override
    public Object postProcessAfterInitialization(Object o, String s) throws BeansException {
        //属性初始化之后
        if(o instanceof Programmer){
            Programmer programmer = (Programmer) o;
            System.out.println(programmer.getName() + &quot;,&quot; + programmer.getAge());
        }else if(o instanceof Coder) {
            Coder coder = (Coder) o;
            System.out.println(coder.getName() + &quot;,&quot; + coder.getAge());
        }
        return o;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//将该Bean后置处理器实例配置在容器中
&amp;lt;bean class=&quot;Test_spring.MyBeanProcess&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看最终的输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171106211128076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序很简单，在实际初始化属性之前，我们分别修改两个bean实例的age属性，又在属性初始化结束时，打印了他们的信息。Bean的后处理器一般就这么用，当然此处的例子有点大材小用了，根据实际情况适时选择使用即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、容器后置处理器&lt;/strong&gt;&lt;br/&gt;Bean后置处理器负责增强处理所有的bean实例，而容器后置处理器则只负责处理容器本身。容器后置处理器必须实现接口 BeanFactoryPostProcessor，并实现其一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void postProcessBeanFactory(ConfigurableListableBeanFactory var1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过实现该方法体，我们可以做到对Spring容器进行扩展，通常来说，我们也很少自己去扩展Spring容器，毕竟难度有点大。我们会使用Spring为我们内置的容器后处理器，例如：属性占位符配置器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&amp;gt;
    &amp;lt;property name=&quot;locations&quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;!--多个属性文件都可以一起进行读取--&amp;gt;
            &amp;lt;value&amp;gt;db.properties&amp;lt;/value&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&quot;Dbcon&quot; class=&quot;Test_spring.DbCon&quot;
      p:driverClass=&quot;${jdbc.driverClassName}&quot;
      p:conUrl=&quot;${jdbc.url}&quot;
      p:userName=&quot;${jdbc.username}&quot;
      p:pwd=&quot;${jdbc.password}&quot;
/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//属性文件名：db.properties
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql:///test
jdbc.username=root
jdbc.password=123456&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中，我们使用Spring为我们提供的一个属性占位配置器，PropertyPlaceholderConfigurer。在实例化容器中的bean实例之前，容器会调用PropertyPlaceholderConfigurer容器后置处理器读取指定的Properties文件并保存在Spring配置信息中。&lt;/p&gt;
&lt;p&gt;于是，我们可以使用${....}来获取被加载属性文件中的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、注解配置Bean实例&lt;/strong&gt;&lt;br/&gt;一直以来，我们都是使用的XML形式来配置我们的bean实例，但在潮流的推动下，大部分的Java框架也开始倾向于使用简单的注解来配置我们的bean实例。Spring也已经完全支持注解配置了。那么本小节就将学习下使用注解对bean实例的配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、标识Bean类&lt;/strong&gt;&lt;br/&gt;在XML中，一个bean元素代表一个bean实例，它的class属性指定了它的类型，id指定了它的名称。而在我们注解中，使用以下几种注解来标识Bean类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Component：标识一个普通Bean&lt;/li&gt;
&lt;li&gt;@Controller：标识一个控制器组件&lt;/li&gt;
&lt;li&gt;@Service：标识一个业务组件&lt;/li&gt;
&lt;li&gt;@Repository：标识一个DAO组件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;mailto:我们这里主要使用注解@Component来标识Bean类&quot;&gt;我们这里主要使用注解@Component来标识Bean类&lt;/a&gt;，其他的三种类型的注解在整合第三方框架的时候再做详细介绍。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component(&quot;teacher&quot;)
public class Teacher {
    private String name;
    private int age;
    //省略setter方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码等效于以下的XML配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;teacher&quot; class=&quot;Test_spring.Teacher&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，如果想要Spring的注解生效，还需要在XML中配置扫描器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--配置注解扫描器--&amp;gt;
&amp;lt;context:component-scan base-package=&quot;Test_spring&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;base-package属性告诉Spring容器，应该从哪个包开始扫描所有被Spring注解修饰的类。这样我们就可以在容器外通过getBean获取到该实例了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Teacher teacher = (Teacher) context.getBean(&quot;teacher&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、指定Bean实例的作用域&lt;/strong&gt;&lt;br/&gt;XML中指定bean作用域通常使用scope属性来指定，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;coder&quot; class=&quot;Test_spring.Coder&quot; scope=&quot;singleton&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Spring注解中，指定bean实例的作用域相对简单很多。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Scope(&quot;singleton&quot;)
@Component(value = &quot;teacher&quot;)
public class Teacher {
    ........
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;mailto:直接使用@Scope注解进行作用域指定即可&quot;&gt;直接使用@Scope注解进行作用域指定即可&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、配置属性依赖&lt;/strong&gt;&lt;br/&gt;Spring中，&lt;a href=&quot;mailto:我们使用注解@Resources来给属性注入依赖&quot;&gt;我们使用注解@Resources来给属性注入依赖&lt;/a&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//容器中配置coder的bean实例
&amp;lt;bean id=&quot;coder&quot; class=&quot;Test_spring.Coder&quot; p:name=&quot;single&quot; p:age=&quot;22&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;@Component(value = &quot;teacher&quot;)
public class Teacher {
    private String name;
    private int age;
    private Coder coder;

    @Resource(name = &quot;coder&quot;)
    public void setCoder(Coder coder) {
        this.coder = coder;
    }
    //省略其他setter方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@Resource的name属性指向的容器中已经配置的bean实例id，它实现了和ref一样的语义，需要特别注意的是，@Resource注解是修饰在setter方法上的，而非直接修饰实例属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、管理Bean实例的生命周期&lt;/strong&gt;&lt;br/&gt;在XML中，我们使用init-method和destory-method来管理bean的两个特殊时间点。当然，使用注解的话会清晰很多。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component(value = &quot;teacher&quot;)
public class Teacher {
    private String name;
    private int age;
    //省略setter方法

    @PostConstruct
    public void init(){
        System.out.println(&quot;initialize all properties...&quot;);
    }

    @PreDestroy
    public void destory(){
        System.out.println(&quot;destory this bean ....&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;mailto:我们使注解@PostConstruct标识初始化属性之后回调的方法&quot;&gt;我们使注解@PostConstruct标识初始化属性之后回调的方法&lt;/a&gt;，&lt;a href=&quot;mailto:使用注解@PreDestroy指定在bean实例销毁之前回调的方法&quot;&gt;使用注解@PreDestroy指定在bean实例销毁之前回调的方法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;常用的注解基本上就&lt;/p&gt;
</description>
<pubDate>Wed, 08 Nov 2017 12:42:00 +0000</pubDate>
<dc:creator>Single_Yam</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangming1996/p/7806079.html</dc:identifier>
</item>
<item>
<title>Linux下打造全方位立体监控系统 - 小柒2012</title>
<link>http://www.cnblogs.com/smallSevens/p/7805842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smallSevens/p/7805842.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要介绍如何使用Grafana和Prometheus以及node_exporter对Linux服务器性能进行监控。下面两张图分别是两台服务器监控信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务器A&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/109211/201711/109211-20171108195203200-2115387316.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务器B&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/109211/201711/109211-20171108195209356-33187716.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;Prometheus是一个开源的服务监控系统，它通过HTTP协议从远程的机器收集数据并存储在本地的时序数据库上。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多维数据模型（时序列数据由metric名和一组key/value组成）&lt;/li&gt;
&lt;li&gt;在多维度上灵活的查询语言(PromQl)&lt;/li&gt;
&lt;li&gt;不依赖分布式存储，单主节点工作.&lt;/li&gt;
&lt;li&gt;通过基于HTTP的pull方式采集时序数据&lt;/li&gt;
&lt;li&gt;可以通过push gateway进行时序列数据推送(pushing)&lt;/li&gt;
&lt;li&gt;可以通过服务发现或者静态配置去获取要采集的目标服务器&lt;/li&gt;
&lt;li&gt;多种可视化图表及仪表盘支持&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Prometheus通过安装在远程机器上的exporter来收集监控数据，后面我们将使用到node_exporter收集系统数据。&lt;/p&gt;
&lt;p&gt;架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/109211/201711/109211-20171108195218247-411955402.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Grafana 是一个开箱即用的可视化工具，具有功能齐全的度量仪表盘和图形编辑器，有灵活丰富的图形化选项，可以混合多种风格，支持多个数据源特点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/109211/201711/109211-20171108195226841-772465907.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;架构&quot;&gt;架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/109211/201711/109211-20171108204229731-1852980668.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;h3 id=&quot;exporter&quot;&gt;Exporter&lt;/h3&gt;
&lt;p&gt;下载并解压：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#下载
wget https://github.com/prometheus/node_exporter/releases/download/v0.14.0/node_exporter-0.15.0.linux-amd64.tar.gz -O node_exporter-0.15.0.linux-amd64.tar.gz
# 可自定义解压目录
tar -xvf node_exporter-0.15.0.linux-amd64.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行node_exporter：&lt;br/&gt;&lt;code&gt;## 后台运行 ./node_exporter &amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;prometheus&quot;&gt;Prometheus&lt;/h3&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://prometheus.io/download&quot; class=&quot;uri&quot;&gt;https://prometheus.io/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;执行以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## 下载
wget https://github.com/prometheus/prometheus/releases/download/v2.0.0-rc.3/prometheus-2.0.0-rc.3.linux-amd64.tar.gz
## 可自定义解压目录
tar -xvf prometheus-2.0.0-rc.3.linux-amd64.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置prometheus，vi prometheus.yml&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode yaml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;global:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;scrape_interval:&lt;/span&gt;     15s
  &lt;span class=&quot;fu&quot;&gt;evaluation_interval:&lt;/span&gt; 15s
  
  &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;job_name:&lt;/span&gt; prometheus
    &lt;span class=&quot;fu&quot;&gt;static_configs:&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;targets:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'localhost:9090'&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;labels:&lt;/span&gt;
          &lt;span class=&quot;fu&quot;&gt;instance:&lt;/span&gt; prometheus
          
  &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;job_name:&lt;/span&gt; linux1
    &lt;span class=&quot;fu&quot;&gt;static_configs:&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;targets:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'192.168.1.120:9100'&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;labels:&lt;/span&gt;
          &lt;span class=&quot;fu&quot;&gt;instance:&lt;/span&gt; sys1
          
  &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;job_name:&lt;/span&gt; linux2
    &lt;span class=&quot;fu&quot;&gt;static_configs:&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;targets:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'192.168.1.130:9100'&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;labels:&lt;/span&gt;
          &lt;span class=&quot;fu&quot;&gt;instance:&lt;/span&gt; sys2&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IP对应的是我们内网的服务器，端口则是对应的exporter的监听端口。&lt;/p&gt;
&lt;p&gt;运行Prometheus&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./prometheus 
level=info ts=2017-11-07T02:39:50.220187934Z caller=main.go:215 msg=&quot;Starting Prometheus&quot; version=&quot;(version=2.0.0-rc.2, branch=HEAD, revision=ce63a5a8557bb33e2030a7756c58fd773736b592)&quot;
level=info ts=2017-11-07T02:39:50.22025258Z caller=main.go:216 build_context=&quot;(go=go1.9.1, user=root@a6d2e4a7b8da, date=20171025-18:42:54)&quot;
level=info ts=2017-11-07T02:39:50.220270139Z caller=main.go:217 host_details=&quot;(Linux 3.10.0-514.16.1.el7.x86_64 #1 SMP Wed Apr 12 15:04:24 UTC 2017 x86_64 iZ2ze74fkxrls31tr2ia2fZ (none))&quot;
level=info ts=2017-11-07T02:39:50.223171565Z caller=web.go:380 component=web msg=&quot;Start listening for connections&quot; address=0.0.0.0:9090
......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功以后我们可以通过Prometheus内置了web界面访问，&lt;a href=&quot;http://ip:9090/&quot; class=&quot;uri&quot;&gt;http://ip:9090&lt;/a&gt; ，如果出现以下界面，说明配置成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/109211/201711/109211-20171108195248325-988586810.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;grafana&quot;&gt;Grafana&lt;/h3&gt;
&lt;p&gt;执行以下安装命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## 安装依赖grafana运行需要go环境
yum install  go -y
## 安装 grafana
yum install https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-4.6.1-1.x86_64.rpm -y&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装包信息：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;二进制文件： /usr/sbin/grafana-server&lt;br/&gt;init.d 脚本： /etc/init.d/grafana-server&lt;br/&gt;环境变量文件： /etc/sysconfig/grafana-server&lt;br/&gt;配置文件： /etc/grafana/grafana.ini&lt;br/&gt;启动项： grafana-server.service&lt;br/&gt;日志文件：/var/log/grafana/grafana.log&lt;br/&gt;默认配置的sqlite3数据库：/var/lib/grafana/grafana.db&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可以执行以下启动命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service grafana-server start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动grafana，并设置开机启动：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;systemctl daemon-reload
systemctl start grafana-server
systemctl status grafana-server
systemctl enable grafana-server.service&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务器端图像（PNG）渲染是可选的功能，但在共享可视化时非常有用，例如在警报通知中。&lt;br/&gt;如果图像缺少文本，请确保已安装字体包。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install fontconfig
yum install freetype*
yum install urw-fonts&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问Grafana通过Nginx代理，默认登录用户名密码：admin/admin，需及时修改。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
        listen       80;
        server_name  grafana.52itstyle.com;

        charset utf-8;

        location / {
            default_type text/html;
            proxy_pass http://127.0.0.1:3000;
        }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编辑配置文件/etc/grafana/grafana.ini ，修改dashboards.json段落下两个参数的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[dashboards.json]
enabled = true
path = /var/lib/grafana/dashboards&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装仪表盘JSON模版:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/percona/grafana-dashboards.git
cp -r grafana-dashboards/dashboards /var/lib/grafana/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，通过service grafana-server start命令启动服务，访问地址：&lt;a href=&quot;http://grafana.52itstyle.com/&quot; class=&quot;uri&quot;&gt;http://grafana.52itstyle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.52itstyle.com/usr/uploads/2017/11/838793369.png&quot; alt=&quot;5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在Data Sources选项中添加数据源：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/109211/201711/109211-20171108195301294-2033357234.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加成功以后，我们就可以查看到文章开头的效果图了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;讲道理，这一套东西还是很强大的，各种开源组间一整合完美搭建出一套监控系统。当然了以上仅仅是系统的一个监控，Grafana以及exporter组间还可以实现对Nginx、MySql、Redis以及MongDB的监控。&lt;/p&gt;
&lt;p&gt;监控不是目的，目的是出现问题能够及时发现并解决问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.52itstyle.com/archives/2014/&quot; title=&quot;Grafana系统监控之邮件报警功能&quot;&gt;Grafana系统监控之邮件报警功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.52itstyle.com/archives/2029/&quot; title=&quot;Grafana系统监控之钉钉报警功能&quot;&gt;Grafana系统监控之钉钉报警功能&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://grafana.com/&quot; class=&quot;uri&quot;&gt;https://grafana.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://prometheus.io/&quot; class=&quot;uri&quot;&gt;https://prometheus.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/prometheus&quot; class=&quot;uri&quot;&gt;https://github.com/prometheus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/prometheus/node_exporter&quot; class=&quot;uri&quot;&gt;https://github.com/prometheus/node_exporter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/percona/grafana-dashboards&quot; class=&quot;uri&quot;&gt;https://github.com/percona/grafana-dashboards&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.percona.com/blog/2016/02/29/graphing-mysql-performance-with-prometheus-and-grafana/&quot; class=&quot;uri&quot;&gt;https://www.percona.com/blog/2016/02/29/graphing-mysql-performance-with-prometheus-and-grafana/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Nov 2017 11:55:00 +0000</pubDate>
<dc:creator>小柒2012</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smallSevens/p/7805842.html</dc:identifier>
</item>
</channel>
</rss>