<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASM字节码框架学习之动态代理 - HuMingChuan</title>
<link>http://www.cnblogs.com/humc/p/8444568.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/humc/p/8444568.html</guid>
<description>&lt;p&gt;ASM字节码操纵框架，可以直接以二进制的形式来来修改已经存在的类或者创建新的类。ASM封装了操作字节码的大部分细节，并提供了非常方便的接口来对字节码进行操作。ASM框架是全功能的，使用ASM字节码框架，可以方便地对类增加成员，修改方法，创建新的类等。关于ASM的学习，可以参考：&lt;a href=&quot;https://www.atatech.org/articles/41841#13&quot;&gt;Learn ASM CoreApi&lt;/a&gt;。作为学习ASM框架的第一篇总结，本文的主要内容是使用ASM框架实现一个简单的JDK动态代理和CGLIB代理。&lt;/p&gt;

&lt;h2 id=&quot;被代理类&quot;&gt;被代理类&lt;/h2&gt;
&lt;p&gt;被代理类非常简单。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; CalculatorInterface {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j);
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sub&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j);
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Calculator &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; CalculatorInterface {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; i + j;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sub&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; i - j;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;代理类目标代码原型&quot;&gt;代理类目标代码原型&lt;/h2&gt;
&lt;p&gt;CGLIB版本的代理类如下，直接从Calculator继承。如果是JDK版本的，则改为实现CalculatorInterface即可。&lt;br/&gt;这里简化了，对要拦截的方法的个数写死了(m1,m2)，实际在生成字节码的时候并没有写死。&lt;br/&gt;这一份代码，就是我要用字节码方式生成的代码。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CalculatorProxy &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Calculator {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; InvocationHandler handler;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Object target
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Method m1;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Method m2;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CalculatorProxy&lt;/span&gt;(Object o, InvocationHandler h, Method targetMethod1, Method targetMethod2) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;();
        target = o;
        handler = h;
        m1 = targetMethod1;
        m2 = targetMethod2;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;)handler.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, m1, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[] {i, j});
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable throwable) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; UndeclaredThrowableException(throwable);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;代理工厂&quot;&gt;代理工厂&lt;/h2&gt;
&lt;p&gt;代理工厂类似JDK的Proxy对象，只需要向代理工厂对象提供被代理对象和一个InvocationHandler即可使用CGLIB的方式来生成代理类，如果要使用JDK的方式来生成代理对象，则需要再额外提供一下待实现接口。使用newProxy方法得到代理对象。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; AopProxy {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;AopProxy&lt;/span&gt;(Object target, InvocationHandler handler) {
        ...
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;AopProxy&lt;/span&gt;(Object target, InvocationHandler handler, Class&amp;lt;?&amp;gt;[] interfaces) {
        ...
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;newProxy&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{
    } 
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;基本指令&quot;&gt;基本指令&lt;/h2&gt;
&lt;p&gt;使用ASM生成一个类最复杂的地方在于方法体的生成，相当于直接写字节码。生成上文的目标类需要用到如下指令：&lt;br/&gt;&lt;strong&gt;这个表格说的指令参数，并不是真正的JVM指令的参数，而是使用ASM框架生成相应字节码时需要传递的参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;27.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;ILOAD&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;index: unsigned byte&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;从局部变量表中加载下标为index的&lt;strong&gt;int&lt;/strong&gt;到操作数栈&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;无参数出栈，结果入栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;ALOAD&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;index: unsigned byte&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;将栈顶的引用写入到局部变量表中下标为index的&lt;strong&gt;引用&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;无参数出栈，结果入栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;ASTORE&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;index: unsigned byte&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;从局部变量表中加载下标为index的&lt;strong&gt;引用&lt;/strong&gt;到操作数栈&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;objectRef 引用 出栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td align=&quot;center&quot;&gt;INVOKESPECIAL&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;owner: string 类名&lt;br/&gt;name: string 方法名&lt;br/&gt;desc:方法签名&lt;br/&gt;itf:boolean 是否是接口（false）&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;调用构造器，私有方法，或显示调用父类的方法，&lt;strong&gt;静态绑定&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;objectRef:实例对象 出栈&lt;br/&gt;arg1:第一个参数 出栈&lt;br/&gt;arg...&lt;br/&gt;有返回的话入栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td align=&quot;center&quot;&gt;INVOKEVIRTUAL&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;owner: string 类名&lt;br/&gt;name: string 方法名&lt;br/&gt;desc:方法签名&lt;br/&gt;itf:boolean 是否是接口（false）&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;根据对象类型多态调用，&lt;strong&gt;动态绑定&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;objectRef:实例对象 出栈&lt;br/&gt;arg1:第一个参数 出栈&lt;br/&gt;arg...&lt;br/&gt;有返回的话入栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td align=&quot;center&quot;&gt;INVOKEINTERFACE&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;owner: string 类名&lt;br/&gt;name: string 方法名&lt;br/&gt;desc:方法签名&lt;br/&gt;itf:boolean 是否是接口（true）&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;根据对象类型多态调用，&lt;strong&gt;动态绑定&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;objectRef:实例对象 出栈&lt;br/&gt;arg1:第一个参数 出栈&lt;br/&gt;arg...&lt;br/&gt;有返回的话入栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td align=&quot;center&quot;&gt;NEW&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;name: string&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;构造一个类型为name的对象，分配内存，并完成成员初始化，但是并不调用构造方法&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;无参数出栈，结果入栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;PUTFIELD&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;owner: string 类名&lt;br/&gt;name: string 成员名&lt;br/&gt;desc: string 成员类型描述&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;设置一个field值&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;objectRef 实例对象 出栈&lt;br/&gt;value 成员的值 出栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;GETFIELD&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;owner: string 类名&lt;br/&gt;name: string 成员名&lt;br/&gt;desc: string 成员类型描述&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;读取一个field值&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;objectRef 实例对象 出栈&lt;br/&gt;value 成员的值 入栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td align=&quot;center&quot;&gt;ANEWARRAY&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;type: string 类型名称&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新建引用类型为type的数组&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;count：int 数组长度 出栈&lt;br/&gt;arrayref：数组引用 入栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;DUP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;无参&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;复制栈顶的数据&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;value 栈顶的值 出栈&lt;br/&gt;value 栈顶的值 入栈两次&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;center&quot;&gt;AASTORE&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;无参&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;将引用存入数组指定位置&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;arrayRef 数组引用 出栈&lt;br/&gt;index 下标 出栈&lt;br/&gt;value 引用 出栈&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;INVOKEVIRTUAL 和 INVOKEINTERFACE的区别见：&lt;a href=&quot;https://stackoverflow.com/questions/1504633/what-is-the-point-of-invokeinterface&quot;&gt;链接&lt;/a&gt;。如果调用一个方法的时候，能够确定这个方法在方法表中的位置，就调用INVOKEVIRTUAL，如果不能，就调用INVOKEINTERFACE。具体一点来说：如果一个变量的静态类型是接口，就使用INVOKEINTERFACE，如果是类，就使用INVOKEVIRTUAL。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;方法调用基本知识&quot;&gt;方法调用基本知识&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;调用一个方法之前，需要确保方法需要的参数都已经加载到操作数栈中。如果是实例方法，需要将隐含的this也加载到栈中。&lt;/li&gt;
&lt;li&gt;参数入栈的顺序和参数声明的顺序一致。实际弹出参数时，和声明顺序相反。（后进先出）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;关键代码生成&quot;&gt;关键代码生成&lt;/h2&gt;
&lt;h3 id=&quot;获取要代理的方法&quot;&gt;获取要代理的方法&lt;/h3&gt;
&lt;p&gt;比较简单，兼容了基于接口和基于类的代理两种场景&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private List&amp;lt;Method&amp;gt; getProxyMethods() {
    List&amp;lt;Method&amp;gt; methods = new LinkedList&amp;lt;&amp;gt;();
    List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; superClassList = interfaceList;
    if (superClassList.isEmpty()) {  //如果没有指定接口，就代理父类的所有公有方法
        superClassList = Collections.singletonList(targetClass);
    }
    for (final Class&amp;lt;?&amp;gt; aClass : superClassList) {
        methods.addAll(filterObjectMethods(aClass.getMethods())); //将来自Object的方法过滤掉
    }
    return methods;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;写入类描述&quot;&gt;写入类描述&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;ClassWriter cw = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ClassWriter&lt;/span&gt;(ClassWriter.&lt;span class=&quot;fu&quot;&gt;COMPUTE_FRAMES&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;//COMPUTE_FRAMES能够帮我们省去很多麻烦&lt;/span&gt;
cw.&lt;span class=&quot;fu&quot;&gt;visit&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;V1_8&lt;/span&gt;,                  &lt;span class=&quot;co&quot;&gt;//字节码版本&lt;/span&gt;
        Opcodes.&lt;span class=&quot;fu&quot;&gt;ACC_PUBLIC&lt;/span&gt;,            &lt;span class=&quot;co&quot;&gt;//类是public的&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(className),  &lt;span class=&quot;co&quot;&gt;//类名&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;,                          &lt;span class=&quot;co&quot;&gt;//类的签名&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;getSuperClassName&lt;/span&gt;(),          &lt;span class=&quot;co&quot;&gt;//父类&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;getInterfaceNames&lt;/span&gt;());          &lt;span class=&quot;co&quot;&gt;//要实现的接口&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;写入域&quot;&gt;写入域&lt;/h3&gt;
&lt;p&gt;生成如下几个域：target，handler，以及和要拦截的方法个数对应的Method域m1,m2...&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;writeFields&lt;/span&gt;(ClassWriter cw, List&amp;lt;Method&amp;gt; methods) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;//为每一个要代理的方法，生成一个Method类型的成员，用于后面保存目标对象的方法&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Method method : methods) {
        cw.&lt;span class=&quot;fu&quot;&gt;visitField&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ACC_PRIVATE&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;m&quot;&lt;/span&gt; + i++, &lt;span class=&quot;st&quot;&gt;&quot;Ljava/lang/reflect/Method;&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;visitEnd&lt;/span&gt;();
    }
    &lt;span class=&quot;co&quot;&gt;//生成一个handler成员，保存回调接口&lt;/span&gt;
    cw.&lt;span class=&quot;fu&quot;&gt;visitField&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ACC_PRIVATE&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;handler&quot;&lt;/span&gt;,
                  &lt;span class=&quot;fu&quot;&gt;convertClassNameToDesc&lt;/span&gt;(InvocationHandler.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;()),
                  &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;visitEnd&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;//生成一个target成员，保存被代理对象&lt;/span&gt;
    cw.&lt;span class=&quot;fu&quot;&gt;visitField&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ACC_PRIVATE&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;target&quot;&lt;/span&gt;,
                  &lt;span class=&quot;fu&quot;&gt;convertClassNameToDesc&lt;/span&gt;(Object.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;()),
                  &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;visitEnd&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;写构造方法&quot;&gt;写构造方法&lt;/h3&gt;
&lt;p&gt;1 生成方法签名并调用父类构造方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;MethodVisitor mv =
    cw.&lt;span class=&quot;fu&quot;&gt;visitMethod&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ACC_PUBLIC&lt;/span&gt;,
                  &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/span&gt;,
                  &lt;span class=&quot;st&quot;&gt;&quot;(Ljava/lang/Object;Ljava/lang/reflect/InvocationHandler;[Ljava/lang/reflect/Method;)V&quot;&lt;/span&gt;,
                  &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ALOAD&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;//调用构造方法需要传入隐式参数this&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitMethodInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;INVOKESPECIAL&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(superClass.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;()), &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;()V&quot;&lt;/span&gt;,
                  &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2 初始化target和handler&lt;br/&gt;从局部变量表中加载数据并赋值到各field种即可，构造函数的入参为：target,handler,method[]，因此target和handler在局部变量表中的位置是1和2. 使用javap -v -p -l classfile 可以查看相关信息。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//初始化targe&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ALOAD&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//this&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ALOAD&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//局部变量target&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitFieldInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;PUTFIELD&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(className), &lt;span class=&quot;st&quot;&gt;&quot;target&quot;&lt;/span&gt;,
                  &lt;span class=&quot;fu&quot;&gt;convertClassNameToDesc&lt;/span&gt;(Object.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;()));
&lt;span class=&quot;co&quot;&gt;//初始化handler&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ALOAD&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;//this&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ALOAD&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;//局部变量handler&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitFieldInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;PUTFIELD&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(className), &lt;span class=&quot;st&quot;&gt;&quot;handler&quot;&lt;/span&gt;,
                  &lt;span class=&quot;fu&quot;&gt;convertClassNameToDesc&lt;/span&gt;(InvocationHandler.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;()));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3 初始化method域&lt;br/&gt;构造函数的第三个参数时Method数组，需要将这些值依次保存到多个method域中。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//初始化mi&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Method method : methods) {
    mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ALOAD&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;//加载this，为putfield指令做准备&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ALOAD&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 加载入参method数组&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitLdcInsn&lt;/span&gt;(i - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//将i-1作为常量载入，这个常量和上面的method数组是AALoad质量的操作数，表示要加载数组中某个位置的值&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;AALOAD&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//aaload指令消耗了上面的两个操作数，并将结果放入到操作数栈顶，这个结果和this将被putfield使用&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitFieldInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;PUTFIELD&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(className), &lt;span class=&quot;st&quot;&gt;&quot;m&quot;&lt;/span&gt; + i,
                      &lt;span class=&quot;fu&quot;&gt;convertClassNameToDesc&lt;/span&gt;(Method.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;()));
    i++;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4 完成构造函数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;mv.&lt;span class=&quot;fu&quot;&gt;visitInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;RETURN&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;//写入return指令&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitMaxs&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//计算栈和局部变量的大小，传入的参数会被忽略，因为ClassWriter被设置了COMPUTE_FRAMES，操作数栈大小，局部变量表大小，还有StackMapFrame都会在此时被重新计算。&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitEnd&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;写入要代理的方法&quot;&gt;写入要代理的方法&lt;/h3&gt;
&lt;p&gt;写方法构造一个类最复杂的地方，需要非常小心地处理操作数栈，否则很容易出各种奇怪的问题。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;writeMethods&lt;/span&gt;(ClassWriter cw, List&amp;lt;Method&amp;gt; methods) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Method x : methods) {
        &lt;span class=&quot;fu&quot;&gt;writeMethod&lt;/span&gt;(cw, x, i++);  &lt;span class=&quot;co&quot;&gt;//写入方法，i表示是第几个方法，用来和method域对应&lt;/span&gt;
    }
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;writeMethod&lt;/span&gt;(ClassWriter cw, Method method, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i) {
大招都在这里了
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;写入方法描述&quot;&gt;写入方法描述&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;String name = method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;();  &lt;span class=&quot;co&quot;&gt;//方法名称&lt;/span&gt;
String desc = DescHelper.&lt;span class=&quot;fu&quot;&gt;getDesc&lt;/span&gt;(method); &lt;span class=&quot;co&quot;&gt;//方法描述，包含形参列表和返回值类型&lt;/span&gt;
Class&amp;lt;?&amp;gt;[] exceptionTypes = method.&lt;span class=&quot;fu&quot;&gt;getExceptionTypes&lt;/span&gt;();
List&amp;lt;String&amp;gt; exceptionDescList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; exceptionType : exceptionTypes) {
    exceptionDescList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(DescHelper.&lt;span class=&quot;fu&quot;&gt;getDesc&lt;/span&gt;(exceptionType)); &lt;span class=&quot;co&quot;&gt;//异常声明&lt;/span&gt;
}
MethodVisitor mv =
    cw.&lt;span class=&quot;fu&quot;&gt;visitMethod&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ACC_PUBLIC&lt;/span&gt;, name, desc, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;,
                  exceptionDescList.&lt;span class=&quot;fu&quot;&gt;toArray&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String[exceptionDescList.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;()])); &lt;span class=&quot;co&quot;&gt;//写入方法签名&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitCode&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;写入方法体&quot;&gt;写入方法体&lt;/h4&gt;
&lt;p&gt;方法体核心代码其实就一句话：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (Integer)&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;m1&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[]{i,j});
    ...
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用invoke方法，invoke方法需要的参数含handler自己的this引用在内，总共有四个：this,proxy,method,args。这四个参数需要先计算好并放依次入操作数栈之后，才能调用invoke方法。接下来就按照准备这几个参数的顺序来说明怎么生成字节码。&lt;/p&gt;
&lt;h5 id=&quot;准备参数this&quot;&gt;准备参数：this&lt;/h5&gt;
&lt;p&gt;域handler的引用，其实就是handler.invoke方法需要的this指针。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ALOAD&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;//加载this参数&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitFieldInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;GETFIELD&lt;/span&gt;,
                  &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(className), &lt;span class=&quot;co&quot;&gt;//指定field的owner&lt;/span&gt;
                  &lt;span class=&quot;st&quot;&gt;&quot;handler&quot;&lt;/span&gt;, &lt;span class=&quot;co&quot;&gt;//指定field的名称&lt;/span&gt;
                  &lt;span class=&quot;fu&quot;&gt;convertClassNameToDesc&lt;/span&gt;(invocationHandlerClassName)); &lt;span class=&quot;co&quot;&gt;//指定field的描述&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GETFIELD执行完之后，handler的引用会被放到操作数栈顶。此时，invoke方法第一个参数：this准备就绪。&lt;/p&gt;
&lt;h5 id=&quot;准备参数proxy&quot;&gt;准备参数：proxy&lt;/h5&gt;
&lt;p&gt;handler.invoke 需要的proxy参数，是指代理对象的引用。有于handler.invoke是在代理对象中执行的代码，因此代理对象就是当前方法的this指针。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ALOAD&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;//加载this指针。此时，invoke方法的第二个参数：proxy准备就绪。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;准备参数method&quot;&gt;准备参数：method&lt;/h5&gt;
&lt;p&gt;生成类的代码是通用的，并不清楚当前是在生成哪一个代理方法，因此需要使用哪个method域取决于入参i。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ALOAD&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;//加载this，为GETFIELD指令准备操作数栈&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitFieldInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;GETFIELD&lt;/span&gt;,
                  &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(className),  &lt;span class=&quot;co&quot;&gt;//域的owner&lt;/span&gt;
                  &lt;span class=&quot;st&quot;&gt;&quot;m&quot;&lt;/span&gt; + i,  &lt;span class=&quot;co&quot;&gt;//域的名称&lt;/span&gt;
                  &lt;span class=&quot;fu&quot;&gt;convertClassNameToDesc&lt;/span&gt;(Method.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;())); &lt;span class=&quot;co&quot;&gt;//域的描述&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GETFIELD指令执行完成之后，响应的method域就进入操作数栈。此时invoke方法的第三个参数：method准备就绪。&lt;/p&gt;
&lt;h5 id=&quot;准备参数args&quot;&gt;准备参数args&lt;/h5&gt;
&lt;p&gt;args参数是一个数组，当前上下文int add(i,j)中并不存在，需要手动构造出来。&lt;br/&gt;代码：new Object[]{i,j} 的生成步骤如下：&lt;br/&gt;1 调用new指令&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; parameterCount = method.&lt;span class=&quot;fu&quot;&gt;getParameterCount&lt;/span&gt;();
mv.&lt;span class=&quot;fu&quot;&gt;visitLdcInsn&lt;/span&gt;(parameterCount);  &lt;span class=&quot;co&quot;&gt;//将数组大小作为常量加载的操作数栈中&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitTypeInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ANEWARRAY&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(Object.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;()));  &lt;span class=&quot;co&quot;&gt;//生成数组，栈顶的int参数出栈，数组引用入栈&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行完ANEWARRAY指令之后，数组的引用Arrayref位于栈顶。&lt;br/&gt;2 填入数组值&lt;br/&gt;由于数组元素是Object，对于基本类型需要装箱，装箱之后再加入到数组中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; paramIndex = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; paramClass : method.&lt;span class=&quot;fu&quot;&gt;getParameterTypes&lt;/span&gt;()) {
    mv.&lt;span class=&quot;fu&quot;&gt;visitInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;DUP&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//备份一下栈顶的Arrayref，aastore指令会消耗掉这个参数，aastore指令的第一个操作数&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitLdcInsn&lt;/span&gt;(paramIndex); &lt;span class=&quot;co&quot;&gt;//aastore 的第二个操作数，数组下标&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ILOAD&lt;/span&gt;, paramIndex + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;//载入局部变量 ，第一次载入i，第二次载入j&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitMethodInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;INVOKESTATIC&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(Integer.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;())
        , &lt;span class=&quot;st&quot;&gt;&quot;valueOf&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;(I)Ljava/lang/Integer;&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//装箱，valueOf会消耗到栈顶元素并返回一个Integer对象入栈&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;AASTORE&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;//装箱操作生成aastore指令的第三个参数 ，数组元素值，之后，就可以进行指令调用了。这个指令会导致操作数栈出栈三次。&lt;/span&gt;
    paramIndex++;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AASTORE执行完之前，入栈三个操作数，执行完之后，三个操作数出栈，操作数栈不变，Arrayref依然位于栈顶。此时handler.invoke的方法就全部准备就绪了。&lt;/p&gt;
&lt;h5 id=&quot;调用invoke方法&quot;&gt;调用invoke方法&lt;/h5&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;mv.&lt;span class=&quot;fu&quot;&gt;visitMethodInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;INVOKEINTERFACE&lt;/span&gt;,
                  invocationHandlerClassName,
                  INVOKE, INVOKE_DESC, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;INVOKEINTERFACE按照invoke方法的参数列表，依次将需要的参数出栈。执行完之后，将结果入栈。根据invoke方法的签名，结果Object类型，是一个引用。&lt;/p&gt;
&lt;h5 id=&quot;unbox&quot;&gt;unbox&lt;/h5&gt;
&lt;p&gt;add方法的返回值是int，invoke方法的返回值是Object，需要unbox才能返回。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;mv.&lt;span class=&quot;fu&quot;&gt;visitTypeInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;CHECKCAST&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;java/lang/Integer&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//类型检查&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitMethodInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;INVOKEVIRTUAL&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;java/lang/Integer&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;intValue&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;()I&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//调用intValue方法，object引用出栈，结果入栈。&lt;/span&gt;
mv.&lt;span class=&quot;fu&quot;&gt;visitInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;IRETURN&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;//返回栈顶的整数&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;异常处理&quot;&gt;异常处理&lt;/h5&gt;
&lt;p&gt;由于InvocationHandler的invoke方法抛出Throwable异常，需要捕获，因此，实际生成的add方法，还需要捕获异常。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;writeMethod&lt;/span&gt;(ClassWriter cw, Method method, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i) {
    ...
    mv.&lt;span class=&quot;fu&quot;&gt;visitCode&lt;/span&gt;();
    Label begin = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Label(); &lt;span class=&quot;co&quot;&gt;//方法入口加一个labe &lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitLabel&lt;/span&gt;(begin);
  ...
    Label end = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Label();  &lt;span class=&quot;co&quot;&gt;//方法出口加一个label&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitLabel&lt;/span&gt;(end);
&lt;span class=&quot;co&quot;&gt;//加入try catch，并指明捕获的异常类型&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitTryCatchBlock&lt;/span&gt;(begin, end, end, &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(Throwable.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;()));
    mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ASTORE&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//将异常存入到局部变量&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//构造UndeclaredThrowableException对象&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitTypeInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;NEW&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(UndeclaredThrowableException.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;()));
&lt;span class=&quot;co&quot;&gt;//准备UndeclaredThrowableException构造方法的参数&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;DUP&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;//准备UndeclaredThrowableException构造器的this参数&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitVarInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ALOAD&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;//准备UndeclaredThrowableException构造器的undeclaredThrowable参数&lt;/span&gt;
    mv.&lt;span class=&quot;fu&quot;&gt;visitMethodInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;INVOKESPECIAL&lt;/span&gt;,
                      &lt;span class=&quot;fu&quot;&gt;convertClassName&lt;/span&gt;(UndeclaredThrowableException.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getCanonicalName&lt;/span&gt;()),
                      &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/span&gt;,
                      &lt;span class=&quot;st&quot;&gt;&quot;(Ljava/lang/Throwable;)V&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
    mv.&lt;span class=&quot;fu&quot;&gt;visitInsn&lt;/span&gt;(Opcodes.&lt;span class=&quot;fu&quot;&gt;ATHROW&lt;/span&gt;);  抛出UndeclaredThrowableException对象
    mv.&lt;span class=&quot;fu&quot;&gt;visitMaxs&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    mv.&lt;span class=&quot;fu&quot;&gt;visitEnd&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，动态代理类就生成完了。生成的动态代理类如下：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/852245/201802/852245-20180212145946343-1795096079.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用ASM字节码框架生成代码，可以先自己用Java代码写出目标代码，然后转成字节码来查看。也可以使用ASMifer工具来生成ASM代码。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;java jdk.internal.org.objectweb.asm.util.ASMifier classfilename&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ASMifier很好用，但是它生成的ASM代码，是针对一个给定的类的硬编码，不一定符合业务逻辑，但是非常值得参考。&lt;br/&gt;另外，对于JVM字节码指令有不清楚的地方，可以参考文档：&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html&quot;&gt;JVM虚拟机指令集&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Feb 2018 06:56:00 +0000</pubDate>
<dc:creator>HuMingChuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/humc/p/8444568.html</dc:identifier>
</item>
<item>
<title>深入理解js构造函数 - maqingyuan</title>
<link>http://www.cnblogs.com/maqingyuan/p/8444565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maqingyuan/p/8444565.html</guid>
<description>&lt;p&gt;第一行，创建一个空对象obj。&lt;/p&gt;
&lt;p&gt;第二行，将这个空对象的__proto__成员指向了构造函数对象的prototype成员对象，这是最关键的一步，具体细节将在下文描述。&lt;/p&gt;
&lt;p&gt;第三行，将构造函数的作用域赋给新对象，因此CA函数中的this指向新对象obj，然后再调用CO函数。于是我们就给obj对象赋值了一个成员变量p，这个成员变量的值是” I’min constructed object”。&lt;/p&gt;
&lt;p&gt;第四行，返回新对象obj。当构造函数里包含返回语句时情况比较特殊，这种情况会在下文中说到。&lt;/p&gt;

&lt;h2&gt;正确定义JavaScript构造函数&lt;/h2&gt;
&lt;p&gt;不同于其它的主流编程语言，JavaScript的构造函数并不是作为类的一个特定方法存在的；当任意一个普通函数用于创建&lt;strong&gt;一类&lt;/strong&gt;对象时，它就被称作构造函数，或构造器。一个函数要作为一个真正意义上的构造函数，需要满足下列条件：&lt;/p&gt;
&lt;p&gt;1、 在函数内部对新对象（this）的属性进行设置，通常是添加属性和方法。&lt;/p&gt;
&lt;p&gt;2、 构造函数可以包含返回语句（不推荐），但返回值必须是this，或者其它非对象类型的值。&lt;/p&gt;
&lt;p&gt;上文定义的构造函数CO就是一个标准的、简单的构造函数。下面例子定义的函数C1返回了一个对象，我们可以使用new表达式来调用它，该表达式可以正确返回一个对象：&lt;/p&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div id=&quot;highlighter_894414&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;7&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;function C1(){&lt;/code&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;var o = {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;     &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;p:”I’m p in C1”&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;o;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var o1 =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;C1();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;alert(o1.p);&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;但这种方式并不是值得推荐的方式，因为对象o1的原型是函数C1内部定义的对象o的原型，也就是Object.prototype。这种方式相当于执行了正常new表达式的前三步，而在第四步的时候返回了C1函数的返回值。该方式同样不便于创建大量相同类型的对象，不利于使用继承等高级特性，并且容易造成混乱，应该摒弃。&lt;/p&gt;
&lt;p&gt;一个构造函数在某些情况下完全可以作为普通的功能函数来使用，这是JavaScript灵活性的一个体现。下例定义的C2就是一个“多用途”函数：&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div id=&quot;highlighter_894269&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;9&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;function C2(a, b){&lt;/code&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p = a + b;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.alertP = function(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;      &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alert(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var c2 =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;C2(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;c2.alertP();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;alert(C2(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;));&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;该函数既可以用作构造函数来构造一个对象，也可以作为普通的函数来使用。用作普通函数时，它接收两个参数，并返回两者的相加的结果。为了代码的可读性和可维护性，建议作为构造函数的函数不要掺杂除构造作用以外的代码；同样的，一般的功能函数也不要用作构造对象。&lt;/p&gt;

&lt;h2&gt;为什么要使用构造函数&lt;/h2&gt;
&lt;p&gt;根据上文的定义，在表面上看来，构造函数似乎只是对一个新创建的对象进行初始化，增加一些成员变量和方法；然而构造函数的作用远不止这些。为了说明使用构造函数的意义，我们先来回顾一下前文提到的例子。执行var o2 = new CO();创建对象的时候，发生了四件事情：&lt;/p&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div id=&quot;highlighter_550422&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;7&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;var obj  ={};&lt;/code&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;obj.__proto__ = CO.prototype;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;CO.call(obj);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;obj;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;我们说最重要的是第二步，将新生成的对象的__prop__属性赋值为构造函数的prototype属性，使得通过构造函数创建的所有对象可以共享相同的原型。这意味着同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的对象。关于原型（prototype）和继承的细节，笔者会再另一篇文章中深入说明。&lt;/p&gt;
&lt;p&gt;在JavaScript标准中，并没有__prop__这个属性，不过它现在已经是一些主流的JavaScript执行环境默认的一个标准属性，用于指向构造函数的原型。该属性是默认不可见的，而且在各执行环境中实现的细节不尽相同，例如IE浏览器中不存在该属性。我们只要知道JavaScript对象内部存在指向构造函数原型的指针就可以了，这个指针是在调用new表达式的时候自动赋值的，并且我们不应该去修改它。&lt;/p&gt;
&lt;p&gt;在构造对象的四个步骤中，我们可以看到，除第二步以外，别的步骤我们无须借助new表达式去实现，因此new表达式不仅仅是对这四个步骤的简化，也是要实现继承的必经之路。&lt;/p&gt;

&lt;h2&gt;容易混淆的地方&lt;/h2&gt;
&lt;p&gt;关于JavaScript的构造函数，有一个容易混淆的地方，那就是原型的constructor属性。在JavaScript中，每一个函数都有默认的原型对象属性prototype，该对象默认包含了两个成员属性：constructor和__proto__。关于原型的细节就不在本文赘述了，我们现在关心的是这个constructor属性。&lt;/p&gt;
&lt;p&gt;按照面向对象的习惯性思维，我们说构造函数相当于“类”的定义，从而可能会认为constructor属性就是该类实际意义上的构造函数，在new表达式创建一个对象的时候，会直接调用constructor来初始化对象，那就大错特错了。new表达式执行的实际过程已经在上文中介绍过了（四个步骤），其中用于初始化对象的是第三步，调用的初始化函数正是“类函数”本身，而不是constructor。如果没有考虑过这个问题，这一点可能不太好理解，那就让我们举个例子来说明一下吧：&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div id=&quot;highlighter_535261&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;9&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;function C3(a, b){&lt;/code&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p = a + b;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.alertP = function(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alert(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function fake(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;100&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;C3.prototype.constructor = fake;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var c3 =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;C3(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;c3.alertP();&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;上述代码手动改变了C3原型中的constructor函数，然而却没有对c3对象的创建产生实质的影响，可见在new表达式中，起初始化对象作用的只能是构造函数本身。那么constructor属性的作用是什么呢？一般来说，我们可以使用constructor属性来测试对象的类型：&lt;/p&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div id=&quot;highlighter_341493&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;7&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;var myArray = [&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;];&lt;/code&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;(myArray.constructor == Array);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这招对于简单的对象是管用的，涉及到继承或者跨窗口等复杂情况时，可能就没那么灵光了：&lt;/p&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div id=&quot;highlighter_473660&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;7&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;function f() {&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.foo =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;}&lt;/code&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function s() {&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.bar =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;; }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;s.prototype =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;f();&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var son =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;s();&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;(son.constructor == s);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;(son.constructor == f);&lt;/code&gt; &lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样的结果可能跟你的预期不相一致，所以使用constructor属性的时候一定要小心，或者干脆不要用它。&lt;/p&gt;

&lt;p&gt;引用地址：&lt;a href=&quot;http://www.2cto.com/kf/201402/281841.html&quot; target=&quot;_blank&quot;&gt;http://www.2cto.com/kf/201402/281841.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 06:54:00 +0000</pubDate>
<dc:creator>maqingyuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maqingyuan/p/8444565.html</dc:identifier>
</item>
<item>
<title>Redis进阶实践之十 Redis哨兵集群模式 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/8444546.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/8444546.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;             上一篇文章我们详细的讲解了Redis的主从集群模式，其实这个集群模式配置很简单，只需要在Slave的节点上进行配置，Master主节点的配置不需要做任何更改，但是有一点，Master和Slave两个节点的持久化配置尽量保持一致，否则会有奇怪的问题出现。从今天开始我们开始讲Redis集群模式的第二模式，也就是“哨兵”模式，该模式是从Redis的2.6版本开始提供的，但是当时这个版本的模式是不稳定的，直到Redis的2.8版本以后，这个哨兵模式才稳定下来，在生产环境中，如果想要使用Redis的哨兵模式，也会尽量使用Redis的2.8版本之后的版本。无论是主从模式，还是哨兵模式，这两个模式都有一个问题，不能水平扩容，并且这两个模式的高可用特性都会受到Master主节点内存的限制。还有一点，实现哨兵模式的配置也不简单，甚至可以说有些繁琐，所以在工业场景里这两个模式都不建议使用，如果要使用必须有相关的问题的解决方案，以免后续带来的问题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、Redis Sentinel简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;             Sentinel(哨兵)进程是用于监控redis集群中Master主服务器工作的状态，在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用，其已经被集成在redis2.6+的版本中，Redis的哨兵模式到了2.8版本之后就稳定了下来。一般在生产环境也建议使用Redis的2.8版本的以后版本。哨兵(Sentinel) 是一个分布式系统，你可以在一个架构中运行多个哨兵(sentinel) 进程，这些进程使用流言协议(gossipprotocols)来接收关于Master主服务器是否下线的信息，并使用投票协议(Agreement Protocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master。每个哨兵(Sentinel)进程会向其它哨兵(Sentinel)、Master、Slave定时发送消息，以确认对方是否”活”着，如果发现对方在指定配置时间(可配置的)内未得到回应，则暂时认为对方已掉线，也就是所谓的”主观认为宕机” ，英文名称：Subjective Down，简称SDOWN。有主观宕机，肯定就有客观宕机。当“哨兵群”中的多数Sentinel进程在对Master主服务器做出 SDOWN 的判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的Master Server下线判断，这种方式就是“客观宕机”，英文名称是：Objectively Down， 简称 ODOWN。通过一定的vote算法，从剩下的slave从服务器节点中，选一台提升为Master服务器节点，然后自动修改相关配置，并开启故障转移（failover）。&lt;/p&gt;&lt;p&gt;            哨兵(sentinel) 虽然有一个单独的可执行文件 redis-sentinel ,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定 --sentinel 选项来启动哨兵(sentinel)，哨兵(sentinel) 的一些设计思路和zookeeper非常类似。&lt;/p&gt;&lt;p&gt;           Sentinel集群之间会互相通信，沟通交流redis节点的状态，做出相应的判断并进行处理，这里的主观下线状态和客观下线状态是比较重要的状态，它们决定了是否进行故障转移，可以 通过订阅指定的频道信息，当服务器出现故障得时候通知管理员，客户端可以将 Sentinel 看作是一个只提供了订阅功能的 Redis 服务器，你不可以使用 PUBLISH 命令向这个服务器发送信息，但你可以用 SUBSCRIBE 命令或者 PSUBSCRIBE 命令， 通过订阅给定的频道来获取相应的事件提醒。一个频道能够接收和这个频道的名字相同的事件。 比如说， 名为 +sdown 的频道就可以接收所有实例进入主观下线（SDOWN）状态的事件。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;      1、Sentinel（哨兵）进程的作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;              1】、监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。&lt;/p&gt;&lt;p&gt;              2】、提醒(Notification)：当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。&lt;/p&gt;&lt;p&gt;              3】、自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作，它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。&lt;/p&gt;&lt;p&gt;      &lt;br/&gt;&lt;span&gt;&lt;strong&gt;       2、Sentinel（哨兵）进程的工作方式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;             1】、每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。&lt;/p&gt;&lt;p&gt;             2】、如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。&lt;/p&gt;&lt;p&gt;             3】、如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态。&lt;/p&gt;&lt;p&gt;             4】、当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）。&lt;/p&gt;&lt;p&gt;             5】、在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。&lt;/p&gt;&lt;p&gt;             6】、当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。&lt;/p&gt;&lt;p&gt;             7】、若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;       3、哨兵模式的环境：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;             1】、Master主服务器配置信息：IP:192.168.127.128, Port:6379，OS:Linux&lt;/p&gt;&lt;p&gt;             2】、Slave从服务器的配置信息：IP:192.168.127.129 Port:6379，OS:Linux&lt;/p&gt;&lt;p&gt;             3】、在Slave从服务器上安装了一个哨兵进程（Sentinel），在Master服务器也安装了一个哨兵进程（Sentinel）。&lt;/p&gt;&lt;p&gt;             由于两个Redis服务器都是安装在Linux操作系统上，而且这两个Redis服务器会在Master主服务器发生故障的时候会进行切换，必须保证两个Redis服务器的端口号已经增加进了防火墙，或者把两个Linux操作系统的防火墙关闭，否则会提示Master-link-Status:down，没有连接上Master主服务器。解决办法有两个：第一个办法是关闭两个Linux操作系统的防火墙；第二个办法是把各个Redis服务的端口号增加到防火墙里面，允许通过该端口号进行通信。可以先使用命令 【firewall-cmd --query-port=6379/tcp】,如果结果是 No，那就继续执行以下命令【firewall-cmd --add-port=6379/tcp】，命令执行后，返回Success，表示增加成功。这样两个Linux系统上的Redis服务器就可以顺利切换，执行哨兵模式的操作。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、哨兵模式的配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;      下面是我使用的配置，需要修改的配置项我写了出来，没有更改的配置项就是用默认值，就不会写出来：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;      1、###### Master config（redis.conf）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;1.1&lt;/span&gt;&lt;span&gt;、### NETWORK 设置：

                  bind &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定IP地址，可以通过ifconfig 获取Ip地址(在Linux系统下)&lt;/span&gt;
&lt;span&gt;
                  port &lt;/span&gt;&lt;span&gt;6379&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保持默认值，也可以修改&lt;/span&gt;
&lt;span&gt;
                  timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Client 端空闲断开连接的时间&lt;/span&gt;


         &lt;span&gt;1.2&lt;/span&gt;&lt;span&gt;、### GENERAL 设置：

                  daemonize yes   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认值是no，把值修改为yes，以后台模式运行&lt;/span&gt;
&lt;span&gt;
                  logfile &lt;/span&gt;/root/application/program/redis-tool/logs/redis.log  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日志文件的位置&lt;/span&gt;


         &lt;span&gt;1.3&lt;/span&gt;&lt;span&gt;、### SNAPSHOTTING 设置：

                  dir &lt;/span&gt;/root/application/program/redis-tool/datas   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SNAPSHOTTING文件的路径&lt;/span&gt;


         &lt;span&gt;1.4&lt;/span&gt;&lt;span&gt;、### APPEND ONLY MODE 设置：

                  appendonly yes  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认值是No，意思是不使用AOF增量持久化的方式，使用RDB全量持久化的方式。把No值改成Yes，使用AOF增量持久化的方式&lt;/span&gt;
&lt;span&gt;
                  appendfsync always&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;      2、###### Slave Config（redis.conf）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;2.1&lt;/span&gt;&lt;span&gt;、### NETWORK 设置：

                   bind &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.129&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定IP地址，可以通过ifconfig 获取Ip地址(在Linux系统下)&lt;/span&gt;
&lt;span&gt;
                   port &lt;/span&gt;&lt;span&gt;6379&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保持默认值，也可以修改&lt;/span&gt;
&lt;span&gt;
                   timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Client 端空闲断开连接的时间&lt;/span&gt;


          &lt;span&gt;2.2&lt;/span&gt;&lt;span&gt;、### GENERAL 设置：

                   daemonize yes    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认值是no，把值修改为yes，以后台模式运行&lt;/span&gt;
&lt;span&gt;
                   logfile &lt;/span&gt;/root/application/program/redis/logs/redis.log  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日志文件的位置&lt;/span&gt;


          &lt;span&gt;2.3&lt;/span&gt;&lt;span&gt;、### SNAPSHOTTING 设置：

                   dir &lt;/span&gt;/root/application/program/redis/datas  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SNAPSHOTTING文件的路径&lt;/span&gt;


          &lt;span&gt;2.4&lt;/span&gt;&lt;span&gt;、### REPLICATION 设置：

                   slaveof &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt; &lt;span&gt;6379&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主服务器的Ip地址和Port端口号&lt;/span&gt;
&lt;span&gt;
                   slave&lt;/span&gt;-serve-stale-data no  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果slave 无法与master 同步，设置成slave不可读，方便监控脚本发现问题。&lt;/span&gt;


          &lt;span&gt;2.5&lt;/span&gt;&lt;span&gt;、### APPEND ONLY MODE 设置：

                   appendonly yes  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认值是No，意思是不使用AOF增量持久化的方式，使用RDB全量持久化的方式。把No值改成Yes，使用AOF增量持久化的方式&lt;/span&gt;
&lt;span&gt;
                   appendfsync always&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;      3、###### Sentinel Config（sentinel.conf，192.168.127.129 Slave从服务器）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
          
          &lt;span&gt;3.1&lt;/span&gt;&lt;span&gt;、 ### Port 设置：

                port &lt;/span&gt;&lt;span&gt;26379&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;哨兵端口号保持不变，可以修改，但是我没有修改&lt;/span&gt;


          &lt;span&gt;3.2&lt;/span&gt;&lt;span&gt;、### dir 设置：

                dir &lt;/span&gt;/root/application/program/redis/sentinel/  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;哨兵程序的日志路径&lt;/span&gt;


          &lt;span&gt;3.3&lt;/span&gt;&lt;span&gt;、### Sentinel Monitor 设置：

                sentinel monitor mymaster  &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.129&lt;/span&gt; &lt;span&gt;6379&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;


          &lt;span&gt;3.4&lt;/span&gt;、### Down-After-&lt;span&gt;Milliseconds 设置：

                sentinel down&lt;/span&gt;-after-milliseconds mymaster &lt;span&gt;5000&lt;/span&gt;

                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;哨兵程序每5秒检测一次Master是否正常&lt;/span&gt;


          &lt;span&gt;3.5&lt;/span&gt;、### Parallel-&lt;span&gt;Syncs 设置：

               sentinel parallel&lt;/span&gt;-syncs mymaster &lt;span&gt;1&lt;/span&gt;


          &lt;span&gt;3.5&lt;/span&gt;、### Failover-&lt;span&gt;Timeout 设置：

               sentinel failover&lt;/span&gt;-timeout mymaster &lt;span&gt;60000&lt;/span&gt;


          &lt;span&gt;3.5&lt;/span&gt;、### 启动：redis-&lt;span&gt;sentinel

                   redis&lt;/span&gt;-server sentinel.conf --sentinel &amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(&amp;amp;有这可以Ctrl +C退到命令行，没有这个就直接退出哨兵进程)&lt;/span&gt;
&lt;span&gt;
                   redis&lt;/span&gt;-sentinel /path/to/sentinel.conf &amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于 redis-sentinel 程序， 你可以用以下命令来启动 Sentinel 系统&lt;/span&gt;


          &lt;span&gt;3.6&lt;/span&gt;、### 关闭：redis-&lt;span&gt;sentinel

                  pkill redis&lt;/span&gt;-server   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个会关掉Redis服务器和Sentinel（哨兵）进程&lt;/span&gt;
&lt;span&gt;
                  kill 进程号     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以关掉指定进程号的进程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;      4、###### 模式测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;               4.1、在Sentinel.conf配置文件设置 sentinel monitor：&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;                         &lt;img src=&quot;https://images2017.cnblogs.com/blog/1048776/201802/1048776-20180212142552015-1775905582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;               4.2、在Sentinel.conf配置文件设置 sentinel down-after-milliseconds：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                           &lt;img src=&quot;https://images2017.cnblogs.com/blog/1048776/201802/1048776-20180212142619577-1975926283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;               4.3、在Sentinel.conf配置文件设置 sentinel parallel-syncs：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                           &lt;img src=&quot;https://images2017.cnblogs.com/blog/1048776/201802/1048776-20180212142706859-206167147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;               4.4、Master 主服务器的配置详情：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                          &lt;img src=&quot;https://images2017.cnblogs.com/blog/1048776/201802/1048776-20180212142726702-2142172748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;               4.5、Slave 从服务器配置详情：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                         &lt;img src=&quot;https://images2017.cnblogs.com/blog/1048776/201802/1048776-20180212142905093-1030996721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;               4.6、启动Sentinel（哨兵）进程，开始对Master主服务器进行监控：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                          &lt;img src=&quot;https://images2017.cnblogs.com/blog/1048776/201802/1048776-20180212143032577-579317662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;               4.7、我们人为模仿Master主服务器宕机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                           &lt;img src=&quot;https://images2017.cnblogs.com/blog/1048776/201802/1048776-20180212143331062-62063474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;               4.8、实现Master主服务器和Slave从服务器的切换：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                          &lt;img src=&quot;https://images2017.cnblogs.com/blog/1048776/201802/1048776-20180212143420515-795218721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;               4.9、主从切换后，主服务器变成了Slave 从服务器，详情如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                            &lt;img src=&quot;https://images2017.cnblogs.com/blog/1048776/201802/1048776-20180212143459124-481880861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;               4.10、主从切换后，从服务器变成了Master 主服务器，详情如下：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                          &lt;img src=&quot;https://images2017.cnblogs.com/blog/1048776/201802/1048776-20180212143519046-1395602341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;           注意：&lt;/p&gt;&lt;p&gt;                ① INFO&lt;br/&gt;                    sentinel的基本状态信息&lt;/p&gt;&lt;p&gt;               ②SENTINEL masters&lt;br/&gt;                   列出所有被监视的主服务器，以及这些主服务器的当前状态&lt;/p&gt;&lt;p&gt;               ③ SENTINEL slaves&lt;br/&gt;                   列出给定主服务器的所有从服务器，以及这些从服务器的当前状态&lt;/p&gt;&lt;p&gt;               ④SENTINEL get-master-addr-by-name&lt;br/&gt;                    返回给定名字的主服务器的 IP 地址和端口号&lt;/p&gt;&lt;p&gt;               ⑤SENTINEL reset&lt;br/&gt;                    重置所有名字和给定模式 pattern 相匹配的主服务器。重置操作清除主服务器目前的所有状态， 包括正在执行中的故障转移， 并移除目前已经发现和关联的， 主服务器的所有从服务器和 Sentinel 。&lt;/p&gt;&lt;p&gt;               ⑥SENTINEL failover&lt;br/&gt;                   当主服务器失效时， 在不询问其他 Sentinel 意见的情况下， 强制开始一次自动故障迁移，但是它会给其他sentinel发送一个最新的配置，其他sentinel会根据这个配置进行更新&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、主观下线和客观下线&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;           下面我们来解释一下两个“下线”的概念，一个是“主观下线”，另一个就是“客观下线”。&lt;/p&gt;&lt;p&gt;            &lt;strong&gt;主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;            客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的服务器下线判断。（一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;           如果一个服务器没有在 master-down-after-milliseconds 选项所指定的时间内，对向它发送 PING 命令的 Sentinel（哨兵）进程返回一个有效回复（valid reply），那么  Sentinel（哨兵）进程就会将这个服务器标记为主观下线。&lt;/p&gt;&lt;p&gt;           服务器对 PING 命令的有效回复可以是以下三种回复的其中一种：&lt;/p&gt;&lt;p&gt;               1、返回 +PONG 。&lt;/p&gt;&lt;p&gt;               2、返回 -LOADING 错误。&lt;/p&gt;&lt;p&gt;              3、返回 -MASTERDOWN 错误。&lt;/p&gt;&lt;p&gt;             如果服务器返回除以上三种回复之外的其他回复，又或者在指定时间内没有回复 PING 命令，那么 Sentinel（哨兵）进程认为服务器返回的回复无效（non-valid）。&lt;/p&gt;&lt;p&gt;             如果一个服务器在 master-down-after-milliseconds 毫秒内，一直返回无效回复才会被 Sentinel 标记为主观下线。&lt;/p&gt;&lt;p&gt;             举个例子，如果 master-down-after-milliseconds 选项的值为 30000 毫秒（30 秒），那么只要服务器能在每 29 秒之内返回至少一次有效回复， 这个服务器就仍然会被认为是处于正常状态的。&lt;/p&gt;&lt;p&gt;            &lt;span&gt;&lt;strong&gt;从“主观下线”状态切换到“客观下线”状态并没有使用严格的法定人数算法（strong quorum algorithm），而是使用了流言协议，该协议解释为：如果 Sentinel（哨兵）进程在给定的时间范围内，从其他 Sentinel（哨兵）进程那里接收到了足够数量的主服务器下线报告， 那么 Sentinel（哨兵）进程就会将主服务器的状态从“主观下线”改变为“客观下线”。如果之后其他 Sentinel（哨兵）进程不再报告主服务器已下线，那么“客观下线”状态就会被移除。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;           &lt;span&gt;&lt;strong&gt;“客观下线”条件只适用于主服务器：对于任何其他类型的 Redis 实例，  Sentinel（哨兵）进程在将它们判断为下线前不需要进行协商，所以Slave从服务器或者其他 Sentinel（哨兵）进程永远不会达到“客观下线”条件。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            只要有一个 Sentinel（哨兵）进程发现某个主服务器进入了“客观下线”状态，这个 Sentinel（哨兵）进程就可能会被其他 Sentinel（哨兵）进程推选出，并对失效的主服务器执行自动故障迁移操作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、Sentinel（哨兵）配置文件简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;          在Redis的源码中包含了一个名为 sentinel.conf 的文件， 这个文件就是带有注释的Sentinel（哨兵）的配置文件的示例。&lt;/p&gt;&lt;p&gt;          如果想要运行一个“哨兵”程序，以下配置项是最少配置：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;            sentinel monitor mymaster 127.0.0.1 6379 1&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;            sentinel down-after-milliseconds mymaster 60000&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;            sentinel failover-timeout mymaster 180000&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;            sentinel parallel-syncs mymaster 1&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;          第一行配置表示 Sentinel（哨兵）进程去监视一个名为 mymaster 的主服务器，这个主服务器的 IP 地址为 127.0.0.1 ， 端口号为 6379，而将这个主服务器判断为失效至少需要 1 个 Sentinel（哨兵）进程的同意。如果在架构系统中已经配置类多个Sentinel（哨兵）进程，在同意“Master主服务器”下线的 Sentinel（哨兵）进程的数量不达标的情况下，Sentinel（哨兵）进程就不会执行自动故障迁移。在设置多Sentinel（哨兵）进程的情况下，无论设置多少个 Sentinel（哨兵）进程同意才能判断一个服务器失效，一个 Sentinel 都需要获得架构系统中多数 Sentinel（哨兵）进程的支持， 才能发起一次自动故障迁移，并预留一个给定的配置纪元 （configuration Epoch ，一个配置纪元就是一个新主服务器配置的版本号）。如果您只配置了一个Sentinel（哨兵）进程来做监控，那一个Sentinel（哨兵）进程也可以决定“Master主服务器”是否下线。&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;       其他选项的基本格式如下：sentinel &amp;lt;选项的名字&amp;gt; &amp;lt;主服务器的名字&amp;gt; &amp;lt;选项的值&amp;gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;           配置选项的解释如下：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;            1、down-after-milliseconds ： Sentinel（哨兵）进程判断服务器已经掉线所需的毫秒数。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                如果被监控的服务器在给定的毫秒数之内，并没有返回 Sentinel（哨兵）进程发送的 PING 命令的回复，或者返回一个错误，那么 Sentinel（哨兵）进程将这个服务器标记为主观下线（subjectively down，简称 SDOWN ）。如果在架构系统中配置了多个Sentinel（哨兵）进程的情况下，只有一个Sentinel（哨兵）进程将服务器标记为主观下线并不一定会引起服务器的自动故障迁移，只有在足够数量的 Sentinel（哨兵）进程都将一个服务器标记为主观下线之后，服务器才会被标记为客观下线（objectively down， 简称 ODOWN ），这时才回执行自动故障迁移。另外一种情况是，在架构系统中只配置了一个Sentinel（哨兵）进程的话，那这Sentinel（哨兵）进程也可以决定被监控的服务器的是否“下线”。&lt;/p&gt;&lt;p&gt;                将服务器标记为客观下线所需的 Sentinel（哨兵）进程数量由对主服务器的配置决定。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;           2、parallel-syncs ：在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步，这个数字越小，完成故障转移所需的时间就越长。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;               如果“Slave从服务器”被设置为允许使用过期数据集（参见对 redis.conf 文件中对 slave-serve-stale-data 选项的说明），那么你可能不希望所有“Slave从服务器”都在同一时间向新的“Master主服务器”发送同步请求， 因为尽管复制过程的绝大部分步骤都不会阻塞“Slave从服务器”，但“Slave从服务器”在载入“Master主服务器”发来的 RDB 文件时， 仍然会造成“Slave从服务器”在一段时间内不能处理命令请求，如果全部“Slave从服务器”一起对新的“Master主服务器”进行同步， 那么就可能会造成所有“Slave从服务器”在短时间内全部不可用的情况出现。&lt;/p&gt;&lt;p&gt;               你可以通过将这个值设为 1 来保证每次只有一个Slave从服务器处于不能处理命令请求的状态。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;           3、failover-timeout：实现主从切换，完成故障转移的所需要的最大时间值。若Sentinel（哨兵）进程在该配置值内未能完成故障转移的操作（即故障时master/slave自动切换），则认为本次故障转移操作失败。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;           4、notification-script: 指定Sentinel（哨兵）进程检测到Master-Name所指定的“Master主服务器”的实例异常的时候，所要调用的报警脚本。该配置项可选，但线上系统建议配置。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、哨兵模式的优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;     　　优点：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       　　 1、哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。&lt;/p&gt;&lt;p&gt;       　　 2、主从可以切换，故障可以转移，系统可用性更好。&lt;/p&gt;&lt;p&gt;       　　 3、哨兵模式是主从模式的升级，系统更健壮，可用性更高。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;     　　缺点：&lt;/strong&gt;&lt;br/&gt;       &lt;br/&gt;        　　1、Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;七、结束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;           今天就写到这里了，Redis的哨兵模式是以主从模式为基础的，所以说，主从模式拥有的一些缺点，在哨兵模式下也具有。哨兵模式主要是监控Master主服务器的运行情况，当然也会监控Slave从服务器的运行情况，如果Master主服务器发生了故障，该模式可以保证Slave从服务器顺利升级为Master主服务器继续提供服务，以此提高系统的高可用性。虽然哨兵模式比主从模式提高了不少系统的高可用性，但是该模式不能水平扩容，不能动态的增、删节点，这也是限制哨兵模式广泛应用的主要原因。Redis也看到了这个情况，所在在Redis的3.x以后的版本提供了一个更加强大集群模式，那就是Cluster集群模式，这个模式也是我们下一篇文章的主题。&lt;/p&gt;
</description>
<pubDate>Mon, 12 Feb 2018 06:48:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/8444546.html</dc:identifier>
</item>
<item>
<title>Java是值传递还是引用传递-总结 - Chan'sBlog</title>
<link>http://www.cnblogs.com/chansblogs/p/8444524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chansblogs/p/8444524.html</guid>
<description>&lt;p&gt;这个话题一直是Java程序员的一个热议话题，争论不断，但是不论是你百度搜也好还是去看官方的文档中所标明的也好，得到的都只有一个结论：&lt;span&gt;&lt;strong&gt;Java只有值传递&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;在这里就不贴代码细致解释了，让我们来看看一些论据：&lt;/p&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/872578/201802/872578-20180212133311952-1289188857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“Java总是&lt;strong&gt;值传递&lt;/strong&gt;的。不幸的是，他们(sun)决定称 '一个对象的地址' 为 '&lt;em&gt;引用&lt;/em&gt;'。当我们传递一个对象的值的时候，我们传递的是他的&lt;em&gt;引用&lt;/em&gt;。这会迷惑初学者。”&lt;/p&gt;

&lt;p&gt;2.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/872578/201802/872578-20180212133808187-915907339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“问题的关键是，'&lt;em&gt;引用&lt;/em&gt;'这个词在表达'&lt;em&gt;通过引用传递&lt;/em&gt;'时有着与我们通常在Java中的'&lt;em&gt;引用&lt;/em&gt;'一词完全不同的意思。&lt;/p&gt;
&lt;p&gt;在Java中'&lt;em&gt;引用&lt;/em&gt;'通常意味着'&lt;em&gt;对一个对象的引用&lt;/em&gt;'。但在编程语言理论中技术术语'&lt;em&gt;引用/值传递&lt;/em&gt;'是说的'&lt;em&gt;一个存储着变量的存储单元的引用&lt;/em&gt;'，这是完全不同的。”&lt;/p&gt;

&lt;p&gt;3.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/872578/201802/872578-20180212135104062-594419245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;摘自Ken Arnold和James Gosling的(前者不太熟后者我知道是Java之父)《Java程序设计语言 第二版(ps:虽然现在都出第四版了)》：&lt;/p&gt;
&lt;p&gt;“有些人会错误的说：Java中的对象都是&quot;引用传递&quot;。&quot;引用传递&quot;这个术语正确的意思是党一个参数传递给一个函数的时候，调用函数获得一个原始值的引用，而不是他的值的一个拷贝(鄙人愚见:这里所说的&lt;em&gt;对原始值的引用&lt;/em&gt;即是我们常说的'&lt;em&gt;传递的对象的一个拷贝&lt;/em&gt;')。如果这个函数修改了它的参数，在调用代码中的值也会被改变，因为参数与参数都是用的相同的内存槽。很确定的，Java只有一种传&lt;em&gt;值方式&lt;/em&gt; - 这有助于保持事情的简单性。”&lt;/p&gt;

&lt;p&gt;4.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/872578/201802/872578-20180212141326874-245804350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“对于那些需要更多的(证据)来被信服的：你不能用Java直接写一个交换函数去交换两个作为参数传递的值，不论他们是对象还是单纯的值。至今交换函数对于那些允许&lt;em&gt;引用传递&lt;/em&gt;的语言来说都是微不足道的。&lt;/p&gt;
&lt;p&gt;因此Java是值传递的，包括指向一个方法的对象的指针。就这么简单。&lt;/p&gt;
&lt;p&gt;真正的问题在于Java喜欢称自己没有指针；这是它作为一个安全的语言出名的一部分。因此尽管它实际上有指针(比C++更安全)，它必须称之为&quot;指针&quot;以外的东西。Sun选择称之为&quot;引用&quot;，尽管它不是业余的企业在区分&quot;指针&quot;和&quot;引用&quot;时通常所以为的意思。Java&quot;&lt;em&gt;引用&lt;/em&gt;&quot;不像C++&quot;&lt;em&gt;引用&lt;/em&gt;&quot;。Java有指向对象的指针，它的值会被传递给方法。”&lt;/p&gt;

&lt;p&gt;=============================== 分割线 ===============================&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;“&lt;span&gt;&lt;strong&gt;Java总是值传递的&lt;/strong&gt;&lt;/span&gt;”。我们所以为的按引用传递，其实传递的还是引用中地址的值(并且是它的一个拷贝)，也可以理解为指针的值。让我们所疑惑的，只是“引用”这个词的含义，在Java中的引用和我们广以为的引用是有所不同的。&lt;/p&gt;

&lt;p&gt;ps：若对本文哪里有不同见解或有所疑惑，可以指出来，一同探讨，若有错误之处还请多多见谅，提出来好做修正，感谢。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;1.Stack Overflow：&lt;a class=&quot;question-hyperlink&quot; href=&quot;https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value&quot;&gt;Is Java “pass-by-reference” or “pass-by-value”?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.Wiki: &lt;a href=&quot;http://c2.com/cgi/fullSearch?search=JavaPassesByValue&quot; rel=&quot;nofollow&quot;&gt;Java Passes By Value&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.知乎上也有个挺清晰的分析：&lt;a title=&quot;Java 到底是值传递还是引用传递？&quot; href=&quot;https://www.zhihu.com/question/31203609/answer/50992895&quot; target=&quot;_blank&quot;&gt;Java 到底是值传递还是引用传递？&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 06:40:00 +0000</pubDate>
<dc:creator>Chan&amp;#39;sBlog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chansblogs/p/8444524.html</dc:identifier>
</item>
<item>
<title>浅谈JavaScript的事件（事件类型） - 水击三千</title>
<link>http://www.cnblogs.com/ggz19/p/8444495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ggz19/p/8444495.html</guid>
<description>&lt;p&gt;　　Web浏览器能够发生的事件有很多种类型，不同的事件类型有不同的事件信息。DOM3级的事件类型主要包括：UI事件，用户与页面上的元素交互时触发；焦点事件，元素获得或失去焦点触发；鼠标事件，用户通过鼠标在页面上执行操作时触发；滚轮事件，使用鼠标滚轮时触发；文本事件，当在文档中输入文本时触发；键盘事件，用户通过键盘在页面上操作触发；合成事件，当为IME输入字符时触发；变动事件，底层DOM结构发生变化时触发。&lt;/p&gt;
&lt;p&gt;　　UI事件的触发并不一定是由用户操作触发的，包括：load，页面完全加载后在window上触发该事件、当所有框架都加载完毕时触发、当图片加载完毕时在img上触发、当嵌入的元素加载完成时在object上面触发；unload事件，当页面完全卸载后在window上面触发、当所有框架都卸载完成时在框架集上触发、当嵌入的内容卸载完毕后在object上触发；abort事件，在用户停止下载过程时，如果嵌入的内容未加载完成，则在object上面触发；error事件，当发生JavaScript脚本错误时触发，当无法加载图像时，在img元素上触发，当无法加载嵌入内容时在object上触发，当框架无法加载时触发；select事件，当用户选择文本框的内容时触发；resize事件，当浏览器窗口大小改变时触发；scroll事件，当用户滚动带滚动条的元素时触发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; EventUtil.addEvent(window,&quot;load&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                 console.log(document.getElementById(&quot;aa&quot;).innerHTML);//222&lt;span&gt;3&lt;/span&gt;             });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码添加了load事件，当页面加载完成后就会触发该事件。使用load事件能够确保事件是在页面元素加载完成后触发，不活出现错误。如果我们在页面元素位加载完成，就去获取页面上的元素，则会产生错误。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; img=document.getElementById(&quot;imgtest&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             EventUtil.addEvent(img,&quot;load&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 event=EventUtil.getEvent(event);&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                 console.log(event.currentTarget.src);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码在img的图片加载完成后，会触发load事件，在load事件中，我们获取了event对象，并通过event对象的属性currentTarget取得了事件处理程序操作的元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; sc = document.createElement(&quot;script&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             sc.src=&quot;js/checkboxdemo.js&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             EventUtil.addEvent(sc,&quot;load&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 console.log(&quot;loaded&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             document.head.appendChild(sc);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码，动态向head添加脚本文件，并且绑定了load事件。&lt;/p&gt;
&lt;p&gt;　　unload事件是与load事件对立的一个事件，这个事件在完全卸载后触发。当用户从一个页面切换到另一个页面就会触发该事件。需要注意的是，在unload事件中不能dom元素进行操作，因为当unload事件执行的时候，所有的页面元素都已经不存在。&lt;/p&gt;
&lt;p&gt;　　当浏览器大小发生改变的时候会触发resize事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; EventUtil.addEvent(window,&quot;resize&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                 alert(&quot;resize&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　需要注意的是不要再resize中添加大量的计算代码，因为在浏览器窗口改变的时候，resize事件会被频繁的触发，会影响浏览器的性能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;焦点事件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　焦点事件会在页面获得或失去焦点时触发。利用这些事件，并于document.hasFocus()方法和document.activeElement属性配合，可以知晓用户在页面上的行为。有6个焦点事件：blur事件，元素失去焦点时触发事件，不会冒泡；focus事件，元素获得焦点时触发，不会冒泡；focusin事件，元素获得焦点时触发，会冒泡；focusout事件，元素失去焦点时触发，会冒泡。当用户在页面上由一个元素移动到另一个元素事件触发的顺序为：focusout事件，在失去焦点的元素上触发；focusin事件，在获得焦点的元素上触发；blur事件，在失去焦点的元素上触发；focus事件，在获得焦点的元素上触发。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;鼠标与滚轮事件&lt;/strong&gt;　　&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　鼠标事件是WEB开发中最常用的事件。DOM3级中定义了9个鼠标事件：click事件，用户单击鼠标左键触发的事件或者按下enter键触发；dbclick事件，用户双击鼠标左键的时候触发；mousedown事件，用户按下鼠标按钮时触发；mouseenter事件，用户光标从元素外部首次移动到元素范围之内触发。这个事件不冒泡，而且光标在移动到后代元素上不会触发；mouseleave事件，在位于元素上方的事件移动到元素范围之外时触发；mousemove事件，鼠标在元素内部移动时重复重复；mouseout事件，在鼠标指针位于一个元素上方然后用于将其移入另一个元素时触发；mouseover事件，鼠标位于元素外部，然后用户首次将其移入元素内部触发；mouseup事件，释放鼠标时触发。&lt;/p&gt;
&lt;p&gt;　　只有在同一个元素上触发mousedown和mouseup事件，才会触发click事件。只有触发两次click事件，才会触发dbclick事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; img=document.getElementById(&quot;imgtest&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             EventUtil.addEvent(img,&quot;mousedown&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                console.log(event.type);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             EventUtil.addEvent(img,&quot;mouseup&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                console.log(event.type);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             EventUtil.addEvent(img,&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                console.log(event.type);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             EventUtil.addEvent(img,&quot;dblclick&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                console.log(event.type);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码在img上注册了mousedown、mouseup、click、dblclick事件。当双击img的时候，依次输出：mousedown、mouseup、click、mousedown、mouseup、click、dblclick。&lt;/p&gt;
&lt;p&gt;　　鼠标滚轮事件就是mousewheel事件，这个事件跟踪鼠标滚轮。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; EventUtil.addEvent(document.getElementById(&quot;imgtest&quot;),&quot;mousemove&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 event=&lt;span&gt;EventUtil.getEvent();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; pageX=&lt;span&gt;event.pageX,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 pageY=&lt;span&gt;event.pageY;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;event.pageX){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     pageX=event.clientX+(document.body.scrollLeft||&lt;span&gt;document.documentElement.scrollLeft);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;pageY){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     pageY=event.clientY+(document.body.scrollTop||&lt;span&gt;document.documentElement.scrollTop);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 console.log(pageX+&quot;,&quot;+&lt;span&gt;pageY);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码能够实时显示鼠标的页面位置信息。即使有了滚动条，依然能够正确计算。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;键盘与文本事件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　用户在使用键盘时会触发键盘事件，有3个事件：keydown事件，当用户按下键盘上任意键时触发，如果按住不放会重复触发此事件；keypress事件，当用户按下键盘上的字符键时触发，如果按住不放会重复触发此事件；keyup事件，当释放键盘上的键时触发。&lt;/p&gt;
&lt;p&gt;　　用户按下键盘上的字符键时，首先会触发keydown事件，然后是keypress事件，最后触发keyup事件。其中keydown和keypress是在文本框发生变化之前触发，keyup是在文本框变化之后触发。如果按下的是非字符集，则会触发keydown和keyup事件。&lt;/p&gt;
&lt;p&gt;　　在发生keydown和keyup事件时，event对象的keyCode属性会包含一个代码，与键盘上一个特定的键对应。对数字字母字符集，keyCode的属性值与ASCII码中的小写字母或数字的编码相同。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; EventUtil.addEvent(document.getElementById(&quot;inputtext&quot;),&quot;keyup&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             event=&lt;span&gt;EventUtil.getEvent(event);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;            console.log(event.keyCode);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         })
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;复合事件&lt;/strong&gt;　　&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　复合事件是DOM3级中新增加的一类事件，用于处理IME的输入序列。IME可以让用户输入在键盘上找不到的字符。IME通常需要同时多个字符来确定一个字符，比如中文的输入。包括3个事件：compositionstart事件，IME打开时触发，表示要输入了；compositionupdate事件，插入新字符时触发；compositionend事件，在IME复合系统关闭时触发，返回正常输入状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; textbox=document.getElementById(&quot;inputtext&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         EventUtil.addEvent(textbox,&quot;compositionstart&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             event=&lt;span&gt;EventUtil.getEvent(event);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            console.log(event.data);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         EventUtil.addEvent(textbox,&quot;compositionupdate&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             event=&lt;span&gt;EventUtil.getEvent(event);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            console.log(event.data);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         EventUtil.addEvent(textbox,&quot;compositionend&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             event=&lt;span&gt;EventUtil.getEvent(event);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            console.log(event.data);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         });
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 12 Feb 2018 06:29:00 +0000</pubDate>
<dc:creator>水击三千</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ggz19/p/8444495.html</dc:identifier>
</item>
<item>
<title>使用xUnit为.net core程序进行单元测试(4) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8444423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8444423.html</guid>
<description>&lt;p&gt;第1部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/8283610.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/8283610.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第2部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/8287588.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/8287588.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第3部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/8438019.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/8438019.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请使用这个项目的代码: &lt;a href=&quot;https://pan.baidu.com/s/1i7d8z2H&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1i7d8z2H&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打开PlayerCharacterShould.cs&lt;/p&gt;
&lt;p&gt;添加几个Fact测试方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TakeZeroDamage()
        {
            _sut.TakeDamage(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            Assert.Equal(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;, _sut.Health);
        }

        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TakeSmallDamage()
        {
            _sut.TakeDamage(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            Assert.Equal(&lt;/span&gt;&lt;span&gt;99&lt;/span&gt;&lt;span&gt;, _sut.Health);
        }
        
        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TakeMediumDamage()
        {
            _sut.TakeDamage(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
            Assert.Equal(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;, _sut.Health);
        }

        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TakeMinimum1Damage()
        {
            _sut.TakeDamage(&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;&lt;span&gt;);
            Assert.Equal(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, _sut.Health);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Build, Run tests. 都Pass了.&lt;/p&gt;
&lt;p&gt;仔细看下这4个方法, 他们其实是做了同样的事情, 只不过输入的数据和期待的结果不同而已. &lt;/p&gt;
&lt;p&gt;所以我们应该重构一下这段代码.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;Theory:&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;针对上述情况, 我们就不再使用Fact属性标签了, 而是需要使用Theory.&lt;/p&gt;
&lt;p&gt;Theory标签会告诉xUnit, 它下面的测试方法会被执行多次, 而每次执行必须为这个方法提供必要的测试数据. &lt;/p&gt;
&lt;p&gt;如何为其添加测试数据呢? 首先要为测试方法添加参数, 使用参数来代替具体的数值:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [&lt;span&gt;Theory&lt;/span&gt;]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TakeDamage(&lt;span&gt;int damage, int&lt;/span&gt;&lt;span&gt;&lt;span&gt; expectedHealth&lt;/span&gt;)
        {
            _sut.TakeDamage(&lt;span&gt;damage&lt;/span&gt;);
            Assert.Equal(&lt;span&gt;expectedHealth&lt;/span&gt;, _sut.Health);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们需要告诉xUnit这个测试方法的参数来自哪里.&lt;/p&gt;
&lt;p&gt;1. 最简单的办法是使用&lt;strong&gt;&lt;span&gt;InlineData&lt;/span&gt;属性标签:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;        [Theory]
&lt;/strong&gt;        &lt;span&gt;[InlineData(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;0, 100)]
        [InlineData(1, 99)]
        [InlineData(50, 50)]
        [InlineData(101, 1)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TakeDamage(&lt;span&gt;int&lt;/span&gt; damage, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedHealth)
        {
            _sut.TakeDamage(damage);
            Assert.Equal(expectedHealth, _sut.Health);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面我添加了四组测试数据, 每对数据按顺序对应测试方法的两个参数. (InlineData的参数类型是params object[])&lt;/p&gt;
&lt;p&gt;然后Build, 查看Test Explorer:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180212133427109-885244595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会发现这里面多出来了4个测试, 分别对应那4个InlineData.&lt;/p&gt;
&lt;p&gt;Run Tests, 都会Pass的.&lt;/p&gt;
&lt;p&gt;现在就可以把那四个Fact测试方法删除了.&lt;/p&gt;
&lt;p&gt;尽管InlineData使用起来还是很方便, 但是在某些情境下还是灵活性欠佳, 请您查看NonPlayerCharacterShould.cs里面的代码. 取消里面的注释:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NonPlayerCharacterShould
    {
        [Theory]
        [InlineData(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;)]
        [InlineData(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;99&lt;/span&gt;&lt;span&gt;)]
        [InlineData(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;&lt;span&gt;)]
        [InlineData(&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TakeDamage(&lt;span&gt;int&lt;/span&gt; damage, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedHealth)
        {
            NonPlayerCharacter sut &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonPlayerCharacter();

            sut.TakeDamage(damage);

            Assert.Equal(expectedHealth, sut.Health);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先Build, Run Tests, 都Pass.&lt;/p&gt;
&lt;p&gt;这个Theory的四组参数和上面的是一样的.&lt;/p&gt;
&lt;p&gt;2.为了共享这几组测试数据, 可以使用&lt;strong&gt;&lt;span&gt;MemberData&lt;/span&gt;&lt;/strong&gt;属性标签, 首先创建一个类InternalHealthDamageTestData.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InternalHealthDamageTestData
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; List&amp;lt;&lt;span&gt;object&lt;/span&gt;[]&amp;gt; Data = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;object&lt;/span&gt;[]&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] {&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;99&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] {&lt;span&gt;50&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;&lt;span&gt;},
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] {&lt;span&gt;101&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
        };

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;object&lt;/span&gt;[]&amp;gt; TestData =&amp;gt;&lt;span&gt; Data;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面的数据和之前的那四组数据是一样的.&lt;/p&gt;
&lt;p&gt;然后修改NonPlayerCharacterShould里面的代码, 把InlineData都去掉:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NonPlayerCharacterShould
    {
        [Theory]
        &lt;span&gt;[MemberData(nameof(InternalHealthDamageTestData.TestData), MemberType &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= typeof(InternalHealthDamageTestData))]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TakeDamage(&lt;span&gt;int&lt;/span&gt; damage, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedHealth)
        {
            NonPlayerCharacter sut &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonPlayerCharacter();

            sut.TakeDamage(damage);

            Assert.Equal(expectedHealth, sut.Health);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里改成了MemberData, 它的参数很多, 第一个参数是数据提供类的属性名字, 这个属性类型要求是IEnumberable的, 所以这里应该写&quot;TestData&quot;, 不过最好还是使用nameof, 这样如果更改了数据类的属性名称, 那么编译时就会报错, 而不会导致测试失败.&lt;/p&gt;
&lt;p&gt;然后还需要设置MemberType属性, 表明数据提供类的类型.&lt;/p&gt;
&lt;p&gt;Clean Solution, Build, 可以看到还是有4个测试, Run Tests, 都会Pass的.&lt;/p&gt;
&lt;p&gt;针对PlayerCharacterShould, 也这样修改. 这样测试数据就得到了共享.&lt;/p&gt;
&lt;p&gt;3. &lt;strong&gt;&lt;span&gt;外部数据&lt;/span&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;查看一下项目里面的TestData.csv: 里面还是这四组数据:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;99&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再创建一个类ExternalHealthDamageTestData.cs来取出csv中的数据:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExternalHealthDamageTestData
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;object&lt;/span&gt;[]&amp;gt;&lt;span&gt; TestData
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] csvLines = File.ReadAllLines(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestData.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testCases = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;object&lt;/span&gt;[]&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; csvLine &lt;span&gt;in&lt;/span&gt;&lt;span&gt; csvLines)
                {
                    IEnumerable&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; values = csvLine.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).Select(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;.Parse);
                    &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;[] testCase = values.Cast&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;().ToArray();
                    testCases.Add(testCase);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; testCases;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改一下NonPlayerCharacterShould和PlayerCharacterShould相关测试方法的属性标签:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NonPlayerCharacterShould
    {
        [Theory]
        [MemberData(nameof(&lt;span&gt;External&lt;/span&gt;HealthDamageTestData.TestData), MemberType &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(&lt;span&gt;External&lt;/span&gt;HealthDamageTestData))]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TakeDamage(&lt;span&gt;int&lt;/span&gt; damage, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedHealth)
        {
            NonPlayerCharacter sut &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonPlayerCharacter();

            sut.TakeDamage(damage);

            Assert.Equal(expectedHealth, sut.Health);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [Theory]
        [MemberData(nameof(&lt;span&gt;External&lt;/span&gt;HealthDamageTestData.TestData), MemberType &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(&lt;span&gt;External&lt;/span&gt;HealthDamageTestData))]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TakeDamage(&lt;span&gt;int&lt;/span&gt; damage, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedHealth)
        {
            _sut.TakeDamage(damage);
            Assert.Equal(expectedHealth, _sut.Health);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Build, 查看Test Explorer:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180212135953781-1385398477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对他们中的任意一个类, 只能发现一个相关的测试, 而不是四个测试.&lt;/p&gt;
&lt;p&gt;Run Tests的话, 会报错:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180212140106921-158750845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它找不到TestData.csv, 这是因为我们需要更改一下csv文件的属性, 把它改成Copy always:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180212140235406-123967231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择Rebuild Solution, 这样才能保证csv文件被copy到正确的位置.&lt;/p&gt;
&lt;p&gt;再查看Test Explorer:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201802/986268-20180212140354874-533625470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时就会看到4组测试了, Run Tests, 都会Pass的.&lt;/p&gt;
&lt;p&gt;如果再添加一组数据, 还是需要Rebuild Solution的, 然后新的测试会出现在Test Explorer里面.&lt;/p&gt;
&lt;p&gt;4.&lt;span&gt;&lt;strong&gt;CustomDataAttribute 自定义数据属性标签&lt;/strong&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;使用自定义的标签可以把测试数据在test case和class之间共享, 而且会提高测试的可读性.&lt;/p&gt;
&lt;p&gt;建立一个类 HealthDamageDataAttribute.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HealthDamageDataAttribute : DataAttribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;object&lt;/span&gt;[]&amp;gt;&lt;span&gt; GetData(MethodInfo testMethod)
        {
            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt; };
            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;99&lt;/span&gt;&lt;span&gt; };
            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;&lt;span&gt; };
            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;101&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; };
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要实现xUnit的DataAttribute这个抽象类.&lt;/p&gt;
&lt;p&gt;修改NonPlayerCharacterShould和PlayerCharacterShould的相关方法, 把上面的自定义标签写上去:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NonPlayerCharacterShould
    {
        [Theory]
        &lt;span&gt;[HealthDamageData]
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TakeDamage(&lt;span&gt;int&lt;/span&gt; damage, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedHealth)
        {
            NonPlayerCharacter sut &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonPlayerCharacter();

            sut.TakeDamage(damage);

            Assert.Equal(expectedHealth, sut.Health);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Build, 然后再Test Explorer还是可以看到四组测试, 如果再想添加一组测试, 只需重新Build即可.&lt;/p&gt;
&lt;p&gt;测试同样都会Pass的.&lt;/p&gt;
&lt;p&gt;同样自定义标签可以整合外部数据, 这个很简单, 您自己来写一下吧.&lt;/p&gt;

&lt;p&gt;这个xUnit简介就到此为止了, 想要深入了解的话, 还是看官方文档吧. &lt;/p&gt;
</description>
<pubDate>Mon, 12 Feb 2018 06:23:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8444423.html</dc:identifier>
</item>
<item>
<title>2048小游戏代码解析 C语言版 - 金色旭光</title>
<link>http://www.cnblogs.com/goldsunshine/p/8440497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goldsunshine/p/8440497.html</guid>
<description>&lt;p&gt;&lt;span&gt;2048小游戏，也算是风靡一时的益智游戏。其背后实现的逻辑比较简单，代码量不算多，而且趣味性强，适合作为有语言基础的童鞋来加强编程训练。本篇分析2048小游戏的C语言实现代码。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;游戏截图：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180211093855373-1724057758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;span&gt;游戏实现原理：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;使用终端图形库文件curses绘制终端里的图形。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用一个二维数组保存4 x 4 空格中的变量。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;键盘输入控制移动，经过逻辑判断，二维数组数据变化。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;二维数组数据变化后交给图形函数显示出来。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;库文件&lt;span&gt;curses&lt;/span&gt;介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;curses是一种终端图形绘制库，利用curses可以在终端中绘制多种图形。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单demo&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span readability=&quot;1&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;curses.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    initscr();
    border(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);    
    move(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;&lt;span&gt;);
    printw(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    refresh();
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; ch=&lt;span&gt;getch();
    endwin();
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;;
}&lt;p&gt;&lt;span&gt;编译：gcc curses_demo.c -lcurses&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180211100703998-1869407971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;深入学习请查询相关资料。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2048实现代码分析&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;根据2048实现原理，代码要实现的主要有三件事：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;图形绘制&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;游戏逻辑操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;图形加载逻辑结果&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;主程序代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;2048&lt;/span&gt;&lt;span&gt; C语言版代码分析

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-------------头文件--------------------&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;curses.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;time.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;signal.h&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------------------&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------全局变量-------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 游戏主界面是一个 4*4 的 16 宫格，使用二维数组进行表示，用 0 表示空格&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;4&lt;/span&gt;][&lt;span&gt;4&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 16 宫格中空格的个数&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; empty;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 涉及到新产生的数字的位置的两个变量&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; old_y, old_x;


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有的C语言代码就是在这三个函数中&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化函数&lt;/span&gt;
&lt;span&gt;    init();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;游戏运行时函数&lt;/span&gt;
&lt;span&gt;    play();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束函数，清屏
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;endwin()来关闭 curses 模式.&lt;/span&gt;
&lt;span&gt;    endwin();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;span&gt;&lt;strong&gt;main()函数代码分析&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;头文件+全局变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;头文件中包含的库文件如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&amp;lt;stdio.h&amp;gt; 标准输入输出&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;stdlib.h&amp;gt; 设计到内存操作函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;curses.h&amp;gt; 绘制图形库文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;time.h&amp;gt; 时间函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;unistd.h&amp;gt; 睡眠函数库文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;signal.h&amp;gt; 信号相关操作库文件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180211102449357-908957835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;主函数代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主函数中共有三个子函数，其中复杂的为前两个，第三个为curses关闭的函数，没有任何逻辑。init()函数的作用是游戏准备，绘图函数等。play()函数是游戏运行的主要逻辑函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180211102127732-1786460146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面分别分析init()函数和play()函数的实现。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;init()函数&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;必要的curses库开启函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;设置游戏开始时空格数为15&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;产生两个随机数x、y作为第一个数字的位置下标&lt;/li&gt;
&lt;li&gt;调用draw()函数来绘制图形&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180211102839873-751082376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有的图形绘制都是依靠draw()函数来完成的。下面来分析该函数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;draw()函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用两个双层循环绘制4*4窗格。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用draw_one()函数将全局变量数组a[][]中的数据显示在空格中。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180211103040888-1972473555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; draw()_one()函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;将a[][]中的数字转换成c[]中的字符&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;循环c[]输出字符，并显示在图形中&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180211103200998-1882862187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;&lt;strong&gt;play()函数代码&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;play函数是整个游戏的主题函数，负责移动，判断等逻辑。游戏的逻辑主要分两个步骤来完成，以向左移动为例来说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180212132652562-365118367.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、&lt;span&gt;循环16个窗口，从(0,0)开始，如果(0,1)和(0,0)相同，则两个相加，并将(0,1)置为0。然后继续判断(0,2)和现在的(0,0)是否相同，相同则相加到(0,0)中。直到(0,0)右边都判断完成结束。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、以上步骤只是完成一个窗口(0,0)的判断，使用循环将16个都完成相加。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3、所有的完成相加之后可能的情况是下面这样的，还须将所有的数字都移到左边。以图中(1,1)为例，循环到(1,1)时，判断左边的窗口是否为0，如果为0，则向左移动一个，继续判断左边是否为0，直到移动到最左边。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180212133647546-1030614526.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;具体的代码分析：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用一个死循环while(1)来循环接收输入，判断等。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ch=getch()接收输入，switch case来判断输入的内容。&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180211103259810-1472364660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;具体分析其中一个，以向左移动为例：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;循环判断每一个空格中的数字&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果为0，则继续下一次循环；如果不为0，则判断其右边的格子中数字是否相同。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果右边格子中的数字和当前格子中相同，那么相加，继续判断右边的右边直到数组到底。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有相同的数字都相加结束之后，将所有的数字整体向左移动。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;68&lt;/span&gt;:    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左移方向键&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; &lt;span&gt;4&lt;/span&gt;; y++&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;; ) 
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果a[y][x]中的值为0，则跳过该次循环&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(a[y][x] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) 
            {
                x&lt;/span&gt;++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            } 
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果a[y][x]中的值不为0，则&lt;/span&gt;
&lt;span&gt;            {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环的思想是，以传入的坐标为基点，向右边搜索，如果右边的和基点相等，则将两个点相加
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相加之后继续向后搜索，还有相等的则继续相加。直到超出范围而退出。
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一次循环继续搜索。&lt;/span&gt;


                &lt;span&gt;for&lt;/span&gt;(i = x + &lt;span&gt;1&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt;) 
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断a[y][x+1]，即该空格的右边的对应位置是否为0，如果为0则退出本次循环&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(a[y][i] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) 
                    {
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不为0，则判断是否相等，如果相等则相加，然后将后面一个置0，退出循环&lt;/span&gt;
&lt;span&gt;                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a[y][x] ==&lt;span&gt; a[y][i]) 
                        {
                            a[y][x] &lt;/span&gt;+=&lt;span&gt; a[y][i];
                            a[y][i] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;


                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当有相加产生之后，会多出一个空格。这里体现空格的减少。&lt;/span&gt;
                            empty++&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
                        {
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当该次循环退出之前，只是完成了该基点的一次搜索，所以要向右边移动一个，继续下一次的业务。&lt;/span&gt;
                x =&lt;span&gt; i;
            }
        }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当所有的相加都完成之后，要将数据整体向左移动，体现在数据全都左移。
        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将所有的数值向左移&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; &lt;span&gt;4&lt;/span&gt;; y++&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; &lt;span&gt;4&lt;/span&gt;; x++&lt;span&gt;) 
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果该位为0，则不动，因为需要移动的是有数值的项&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(a[y][x] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) 
            {
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            } 
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果该为不为0，则向左移动一位，前提是判断该位的左边是空位&lt;/span&gt;
            {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前面是左边是空位，则移动到空位上，继续判断左边的左边是不是空位，如果是则继续移动，直到所有的都移动完成。 &lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt;(i = x; (i &amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; (a[y][i-&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0&lt;/span&gt;); i--&lt;span&gt;) 
                {
                    a[y][i&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; a[y][i];
                    a[y][i] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一旦移动过，就将move置1，方便后面空格中生成新的数据&lt;/span&gt;
                    move = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当switch case结束之后，要完成当前状态的检验：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;判断空格的剩余数，如果剩余小于等于0，则游戏结束&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果不等于0，则判断空格是否等于上次或者有移动，两者有一个成立，就要生成新的数字&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;产生新数字的下标a[x][y]中的x、y，直到该x、y对应的数组a[][]上为空值时才成功&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;判断该x、y是否为最佳出现地点&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;生成不等于0或者2的时候退出。（不明白的这里的逻辑）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在第四步中使用了函数cnt_value()来判断下一个数字出现的最佳地点，后面单独分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180211103540888-1481544042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;cnt_value()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该函数主要选择出下一个数字的最佳出现地点，原则就是周围的空格数最多。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以上一步骤产生的x、y为起点，算出其左右的空格数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;循环所有的空格，统计其周围8个空格的空格数。如果有空格数大于起点的，则生成新的数字。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;cnt_one()为具体计算某一个空格周围8个格子的空格数的函数。逻辑简单，不做具体分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180211104514123-636546597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; cnt_one()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1060878/201802/1060878-20180211104535998-1961174879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;整个逻辑都很正常，除了这最后的cnt_value()函数，这里要找出四周空格最多的一个窗口，而直接将随机产生的窗口作为周围空格最多的就不合理了(max并非最多)。后面只要出现空格数大于该窗口的就选为下一个数字出现的窗格，实际获取的并未最多空格的下标。应该是统计出4*4窗格中周围空格数最多的，然后在最多的窗口处出现下一个数字。不知道是我分析有误还是代码如此？如果有读者看出还请指正。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Feb 2018 06:20:00 +0000</pubDate>
<dc:creator>金色旭光</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goldsunshine/p/8440497.html</dc:identifier>
</item>
<item>
<title>flask入门与发送邮件与QQ邮箱 - 前程明亮</title>
<link>http://www.cnblogs.com/0zcl/p/8443544.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0zcl/p/8443544.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言:&lt;/span&gt;&lt;/strong&gt; 快两个月没写博客了, 原因是懒了, 没有最初写博客那种看到阅读量上涨, 别人给自己文章点赞后的开心. 心态也发生了不少变化. 有机会再来写写. 前两个月我去厦门某公司实习, 本着去厦门玩一玩还有先了解下公司情况, 11月底就去厦门了. 这两个月最大的变化是我自己变得更会玩了, 蛮开心的. 公司2月13号才放假员工过春节, 我就先请假回家了, 2月9号就到家了. 这几天在家除了吃和睡, 也随便看看flask, 感觉flask真的是很简单呀. 我看的是下面这本书, 我才看一两天, 书写得很好, 当然有一很坑. 接下来我会写一些文章来总结我学flask的过程, 因为我已经大致学过django了, flask与django大致是一样的, 所以我只挑我感得有意思有坑的写, 建议小白还是看书学比较系统.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212120925702-1181990934.png&quot; alt=&quot;&quot; width=&quot;563&quot; height=&quot;665&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;一、功能讲解&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;因为是初学flask, 讲一下我现在的小项目的功能.当你访问网址时(请忽略192.168.90.63:30102), 这是我用公司内部镜像暴露端口出来给我访问的. 你没有VPN, 也是访问不了的. 你访问这个界面时, 你被当成了陌生人, 被要求输入名字. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212121617531-769651772.png&quot; alt=&quot;&quot; width=&quot;821&quot; height=&quot;342&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK, 接下来我输入zcl, 点击提交按钮后, 出现如下图. 显示(Happy to see you again), 这是因为点击提交按钮后会把你的名字存到数据库, zcl用户之前已经存到数据库了, 当你再次输入zcl时, 出显示Happy to see you again.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212122013374-248697225.png&quot; alt=&quot;&quot; width=&quot;829&quot; height=&quot;245&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那如果我输入一个数据库中不存在的用户, 会发生什么情况呢? 比如我输入big SB&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212122511952-354822139.png&quot; alt=&quot;&quot; width=&quot;837&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是代码, 看不懂也没关系. 我来讲, 当你输入big SB, 再点击提交, 后台会根据用户名big SB去数据库查这个用户. 很显然, 查不到, 所以下面的第5行代码user为None。既然数据库中没有big SB这个用户, 那就来创建这个用户, 再保存到数据库中呗. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但我还不满足, 我还想实现一个发邮件的功能. 比如&lt;span&gt;项目的管理员用户是:zcl, 当有新用户产生(类似big SB用户)时, 会必送一个邮件给zcl用户&lt;/span&gt;. 在这实践过程中, 发现这功能有坑, 故下面详细讲下flask发邮件这个功能&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    form &lt;/span&gt;=&lt;span&gt; NameForm()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; form.validate_on_submit():
        user &lt;/span&gt;= User.query.filter_by(username=&lt;span&gt;form.name.data).first()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            user &lt;/span&gt;= User(username=&lt;span&gt;form.name.data)
            db.session.add(user)
            db.session.commit()
            session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;known&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; False
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FLASKY_ADMIN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
                send_email(app.config[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FLASKY_ADMIN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;New User&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mail/new_user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, user=&lt;span&gt;user)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;known&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; True
        session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; form.name.data
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(url_for(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render_template(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, form=form, name=session.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
                           known&lt;/span&gt;=session.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;known&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, False))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;二、发送邮件效果&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;先来看效果, 我实现自己给自己的邮箱帐号发送一份邮件, 来说明增加的是哪个新用户.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212123635687-327367848.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;159&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;三、具体实现&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、导入第三方库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;from&lt;/span&gt; flask_mail &lt;span&gt;import&lt;/span&gt; Mail, Message&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Flask-Mail 连接到简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）服务器，并把邮件交给这个服务器发送。如果不进行配置，Flask-Mail 会连接 localhost 上的端口 25，无需验证即可发送电子邮件。表 6-1 列出了可用来设置 SMTP 服务器的配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212124554484-445551493.png&quot; alt=&quot;&quot; width=&quot;663&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在开发过程中，如果连接到外部 SMTP 服务器，则可能更方便.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、写配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可能看不懂这此配置文件, 没关系, 我下面会讲.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体实现时, app.config['FLASKY_MAIL_SENDER'] = '1274828542@qq.com'会发送邮件给管理员app.config['FLASKY_ADMIN'] = '1274828542@qq.com'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第9行与发送邮件主题相关. 既然&lt;span&gt;发送者要发送邮件, 那他肯定需要登录邮箱呀! 所以就必然需要密码&lt;/span&gt;.故app.config['MAIL_PASSWORD'] = 'kjhymbxowmey****'是密码(&lt;span&gt;为了避免我的密码泄露, 不显示后面4位数&lt;/span&gt;).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1~3行为什么是465, smtp.qq.com, True, 下面会讲. &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MAIL_SERVER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; this is email server&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MAIL_PORT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = 465  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; this is the port of email server&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MAIL_USE_SSL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MAIL_USERNAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1274828542@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; app.config['MAIL_PASSWORD'] = 'abcdefg'  # 为了避免我的密码泄露, 这不是我邮箱的真正密码&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MAIL_PASSWORD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kjhymbxowmey****&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; this is email password(这是什么?下面会讲)&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FLASKY_MAIL_SENDER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1274828542@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; this is sender&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FLASKY_ADMIN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1274828542@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; this is the email of admin&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FLASKY_MAIL_SUBJECT_PREFIX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[Flasky]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; this is subject of email we will send&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上, 我想发邮件到我的QQ邮箱. 便调用以下方法.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;def&lt;/span&gt; send_email(to, subject, template, **&lt;span&gt;kwargs):
    msg &lt;/span&gt;= Message(app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FLASKY_MAIL_SUBJECT_PREFIX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] +&lt;span&gt; subject,
                  sender&lt;/span&gt;=app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FLASKY_MAIL_SENDER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], recipients=&lt;span&gt;[to])
    msg.body &lt;/span&gt;= render_template(template + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, **&lt;span&gt;kwargs)
    msg.html &lt;/span&gt;= render_template(template + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, **&lt;span&gt;kwargs)
    mail.send(msg)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3、发送邮件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            &lt;span&gt;if&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FLASKY_ADMIN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
                send_email(app.config[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FLASKY_ADMIN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;New User&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mail/new_user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, user=user)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;四、坑总结与配置讲解&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、邮箱没有开启SMTP服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最开始我的邮件是发不出去的. app.config['MAIL_PORT'] = 465也是按书上来的, 我只知道是一个端口. 邮件发不出去, 怎么办. 看了网上一些文章, &lt;span&gt;发现我的QQ邮箱可能没有开启SMTP服务&lt;/span&gt;. 哇擦，这也太坑了吧. 登入QQ邮箱, 设置-&amp;gt;帐户.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212125612156-712027335.png&quot; alt=&quot;&quot; width=&quot;408&quot; height=&quot;149&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果, 我没有开启, 下图是我开启后的截图, 我之前是没有开启的. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212125724702-1450546309.png&quot; alt=&quot;&quot; width=&quot;894&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 开启时还需要发短信才给通过验证, 通过后就可以开启了.通过后会显示如下授权码, &lt;span&gt;请务必把你QQ邮箱的授权码记下来!&lt;/span&gt;!!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212134803077-1152729009.png&quot; alt=&quot;&quot; width=&quot;714&quot; height=&quot;466&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;2、配置讲解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;密码错误也是一个坑. 在讲这个坑之前, 先来讲下邮箱配置的1~3行为什么是465, smtp.qq.com, True.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入下图红色方框内的链接:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212132003827-958634226.png&quot; alt=&quot;&quot; width=&quot;811&quot; height=&quot;149&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重点来了:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MAIL_SERVER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; this is email server&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MAIL_PORT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = 465  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; this is the port of email server&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MAIL_USE_SSL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用SSL, 所以第3行为True; 发送邮件的服务器是smtp.qq.com, 所以第一行也是smtp.qq.com; 当然第二行你写587我想也是可以的(没试过)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212132058327-1035335121.png&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;210&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、密码错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为我的邮箱密码是abcdefg; 所以最开始是这样写的, 但是依旧发不出邮件. 太TM伤心了.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MAIL_PASSWORD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'abcdefg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;出现了一个错误:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;关于&lt;span&gt;发邮件报错535 Error：authentication failed&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这时让我不得不怀疑, 这&lt;span&gt;密码是不是错误了, 但不可能呀, 我密码就是abcdefg. 这就陷入死胡同了&lt;/span&gt;. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直到看到这篇文章: &lt;a href=&quot;http://blog.csdn.net/huochen1994/article/details/51282093&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/huochen1994/article/details/51282093&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用163邮箱服务器来发送邮件,我们需要开启&lt;strong&gt;POP3/SMTP服务&lt;/strong&gt;,这时163邮件会让我们设置客户端授权码，这个&lt;span&gt;授权码替代上面代码部分的&lt;code&gt;passwd&lt;/code&gt;即可成功发送邮件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是这将密码更改如下(开启SMTP服务时, 我已经让你记下授权码了!!):&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MAIL_PASSWORD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kjhymbxowmey****&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; this is email password&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;收到邮件的那一刻, 开心是真的.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038183/201802/1038183-20180212123635687-327367848.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;159&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近感觉, 在一个城市工作两三个月, 然后再换一个城市工作两三个月. 会很好玩.&lt;/p&gt;
&lt;p&gt;转发请注明出处: &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: flask入门与发送邮件与QQ邮箱&quot; href=&quot;http://www.cnblogs.com/0zcl/p/8443544.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/0zcl/p/8443544.html&lt;/a&gt; , 不然我也拿你没办法~_~&lt;/p&gt;
</description>
<pubDate>Mon, 12 Feb 2018 05:51:00 +0000</pubDate>
<dc:creator>前程明亮</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0zcl/p/8443544.html</dc:identifier>
</item>
<item>
<title>Android开发常用的插件及工具 - 蓝之风</title>
<link>http://www.cnblogs.com/vaiyanzi/p/8444365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vaiyanzi/p/8444365.html</guid>
<description>&lt;p&gt;1、&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;,这个不管是做安卓还是其他，只要是开发就必上的网站，也是天朝没有墙掉为数不多的网站&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;http://stackoverflow.com/&quot;&gt;Stack OverFlow&lt;/a&gt;,这个和上面一样，国外非常著名的问答网站，在上面基本上很多问题都可以得到解决&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;http://www.genymotion.com/&quot;&gt;Genymotion&lt;/a&gt;模拟器，搞开发怎么能少了它呢，史上最快的模拟器，没有之一， 秒杀安卓原生模拟器好几条街。这个谁用谁知道，不过就是新版不支持ARM结构，需要自己另外安装扩展包才可以。&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;http://www.collab.net/giteyeapp&quot;&gt;GitEye&lt;/a&gt;,一款图形画得GIT客户端工具，当然你也可以选择这个 &lt;a href=&quot;http://www.sourcetreeapp.com/&quot;&gt;SourceTree&lt;/a&gt;,MAC下超好用的客户端，支持GIT及HG，配合&lt;a href=&quot;https://bitbucket.org/&quot;&gt;BitBucket&lt;/a&gt; 使用那是相当的爽，支持Git Flow及HG Flow开发,唯一的缺憾就是不支持SVN啊。&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;http://jsonview.com/&quot;&gt;JsonView&lt;/a&gt;,一款直接在浏览器格式化JSON的chrome插件，有了这个再也不用 手动复制一长串的字符串跑到&lt;a href=&quot;http://www.kjson.com/jsoneditor/&quot;&gt;Kjson&lt;/a&gt;网站上去手动格式化了，那真不是一般的方便。&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm&quot;&gt;PostMan插件&lt;/a&gt;,当然有了上面那个之后，你怎么能少了这个， 一款模拟HTTP请求的chrome插件神器。&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&quot;http://gradleplease.appspot.com/&quot;&gt;Gradle Please&lt;/a&gt;,一款帮助寻找Manven中央库中的开源库包，让你更方便的查找自己需要的第三方库。这个是&lt;a href=&quot;https://github.com/eveliotc/gradleplease-workflow&quot;&gt;GitHub地址&lt;/a&gt;方便不能FQ的童鞋&lt;/p&gt;
&lt;p&gt;8、&lt;a href=&quot;http://angrytools.com/android/button/&quot;&gt;Android Button Maker&lt;/a&gt;,在线生成按钮Shape的网站，一些简单的图片就可以不需要麻烦UI切图了，我们自己代码就可以搞定&lt;/p&gt;
&lt;p&gt;9、&lt;a href=&quot;http://coh.io/adpi/&quot;&gt;android dpi calculator&lt;/a&gt;,可以计算安卓各个资源目录下的DPI值&lt;/p&gt;
&lt;p&gt;10、&lt;a href=&quot;http://romannurik.github.io/AndroidAssetStudio/&quot;&gt;Android Asset Studio&lt;/a&gt;,一款可以在线生成安卓HOLO风格图片资源的网站， 当然它能做的还不止这个，自己去发现吧，作者是谷歌的工程师&lt;/p&gt;
&lt;p&gt;11、&lt;a href=&quot;https://github.com/inmite/android-butterknife-zelezny&quot;&gt;ButterKnife Plugin&lt;/a&gt;,一款IDEA插件，这个要配合这个开源库使用&lt;a href=&quot;https://github.com/JakeWharton/butterknife&quot;&gt;ButterKnife&lt;/a&gt;使用，一个注解库，源至于Dragger,出自大神JakeWharton之手。&lt;/p&gt;
&lt;p&gt;12、&lt;a href=&quot;https://github.com/mcharmas/android-parcelable-intellij-plugin&quot;&gt;Parcelable&lt;/a&gt;,安卓数据序列化插件，记得之前不到万不得已是不会用 Parcelable来序列化的，因为他写起来实在是太麻烦了，自从有了一款插件，妈妈再也不用担心我写arcelable序列化数据了，这是咋用咋爽啊&lt;/p&gt;
&lt;p&gt;13、&lt;a href=&quot;https://github.com/jeromevdl/android-holo-colors-idea-plugin&quot;&gt;Android Holo Colors&lt;/a&gt;,可以很方便的生成HOLO风格的图片资源&lt;/p&gt;
&lt;p&gt;14、&lt;a href=&quot;https://github.com/inmite/android-selector-chapek&quot;&gt;SelectorChapek for Android&lt;/a&gt;,一款可以自动生成selector的插件，门槛比较高的就是对图片资源的命名规则比较复杂&lt;/p&gt;
&lt;p&gt;15、&lt;a href=&quot;https://github.com/jkaving/intellij-colors-solarized&quot;&gt;Solarized Colorscheme for IntelliJ IDEA&lt;/a&gt;,一款比较好看的IDEA主题，效果不错哦，可以尝试下&lt;/p&gt;
&lt;p&gt;16 、&lt;a href=&quot;http://inloop.github.io/svg2android/&quot; target=&quot;_blank&quot;&gt;Android SVG to VectorDrawable&lt;/a&gt;，在线将SVG 转化成 android VectorDrawable 资源&lt;/p&gt;
&lt;p&gt;17、&lt;a href=&quot;https://github.com/google/material-design-icons&quot; target=&quot;_blank&quot;&gt;Material design icons&lt;/a&gt;, Material design icons 库&lt;/p&gt;
&lt;p&gt;18、&lt;a href=&quot;https://jsonblob.com/&quot; target=&quot;_blank&quot;&gt;JSON Blob&lt;/a&gt;，Json 在线编辑工具，并且提供API 是APP开发MOCK数据提供的利器&lt;/p&gt;
&lt;p&gt;19、&lt;a href=&quot;https://github.com/Trinea/android-open-project/&quot; target=&quot;_blank&quot;&gt;android 开源组件及项目库&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Feb 2018 05:45:00 +0000</pubDate>
<dc:creator>蓝之风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vaiyanzi/p/8444365.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——32.合理地结合泛型和可变参数 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8444200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8444200.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Java 5中，可变参数方法（条目 53）和泛型都被添加到平台中，所以你可能希望它们能够正常交互; 可悲的是，他们并没有。 可变参数的目的是允许客户端将一个可变数量的参数传递给一个方法，但这是一个脆弱的抽象（ leaky abstraction）：当你调用一个可变参数方法时，会创建一个数组来保存可变参数；那个应该是实现细节的数组是可见的。 因此，当可变参数具有泛型或参数化类型时，会导致编译器警告混淆。&lt;/p&gt;
&lt;p&gt;回顾条目 28，非具体化（ non-reifiable）的类型是其运行时表示比其编译时表示具有更少信息的类型，并且几乎所有泛型和参数化类型都是不可具体化的。 如果某个方法声明其可变参数为非具体化的类型，则编译器将在该声明上生成警告。 如果在推断类型不可确定的可变参数参数上调用该方法，那么编译器也会在调用中生成警告。 警告看起来像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;warning: [unchecked] Possible heap pollution from
    parameterized vararg type List&amp;lt;String&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当参数化类型的变量引用不属于该类型的对象时会发生堆污染（Heap pollution）[JLS，4.12.2]。 它会导致编译器的自动生成的强制转换失败，违反了泛型类型系统的基本保证。&lt;/p&gt;
&lt;p&gt;例如，请考虑以下方法，该方法是第127页上的代码片段的一个不太明显的变体：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Mixing generics and varargs can violate type safety!
static void dangerous(List&amp;lt;String&amp;gt;... stringLists) {
    List&amp;lt;Integer&amp;gt; intList = List.of(42);
    Object[] objects = stringLists;
    objects[0] = intList;             // Heap pollution
    String s = stringLists[0].get(0); // ClassCastException
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此方法没有可见的强制转换，但在调用一个或多个参数时抛出ClassCastException异常。 它的最后一行有一个由编译器生成的隐形转换。 这种转换失败，表明类型安全性已经被破坏，并且&lt;strong&gt;将值保存在泛型可变参数数组参数中是不安全的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个例子引发了一个有趣的问题：为什么声明一个带有泛型可变参数的方法是合法的，当明确创建一个泛型数组是非法的时候呢？ 换句话说，为什么前面显示的方法只生成一个警告，而127页上的代码片段会生成一个错误？ 答案是，具有泛型或参数化类型的可变参数参数的方法在实践中可能非常有用，因此语言设计人员选择忍受这种不一致。 事实上，Java类库导出了几个这样的方法，包括&lt;code&gt;Arrays.asList(T... a)&lt;/code&gt;，&lt;code&gt;Collections.addAll(Collection&amp;lt;? super T&amp;gt; c, T... elements)&lt;/code&gt;，&lt;code&gt;EnumSet.of(E first, E... rest)&lt;/code&gt;。 与前面显示的危险方法不同，这些类库方法是类型安全的。&lt;/p&gt;
&lt;p&gt;在Java 7中，&lt;code&gt;SafeVarargs&lt;/code&gt;注解已添加到平台，以允许具有泛型可变参数的方法的作者自动禁止客户端警告。 实质上，&lt;strong&gt;&lt;code&gt;SafeVarargs&lt;/code&gt;注解构成了作者对类型安全的方法的承诺&lt;/strong&gt;。 为了交换这个承诺，编译器同意不要警告用户调用可能不安全的方法。&lt;/p&gt;
&lt;p&gt;除非它实际上是安全的，否则注意不要使用&lt;code&gt;@SafeVarargs&lt;/code&gt;注解标注一个方法。 那么需要做些什么来确保这一点呢？ 回想一下，调用方法时会创建一个泛型数组，以容纳可变参数。 如果方法没有在数组中存储任何东西（它会覆盖参数）并且不允许对数组的引用进行转义（这会使不受信任的代码访问数组），那么它是安全的。 换句话说，如果可变参数数组仅用于从调用者向方法传递可变数量的参数——毕竟这是可变参数的目的——那么该方法是安全的。&lt;/p&gt;
&lt;p&gt;值得注意的是，你可以违反类型安全性，即使不会在可变参数数组中存储任何内容。 考虑下面的泛型可变参数方法，它返回一个包含参数的数组。 乍一看，它可能看起来像一个方便的小工具：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// UNSAFE - Exposes a reference to its generic parameter array!
static &amp;lt;T&amp;gt; T[] toArray(T... args) {
    return args;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法只是返回它的可变参数数组。 该方法可能看起来并不危险，但它是！ 该数组的类型由传递给方法的参数的编译时类型决定，编译器可能没有足够的信息来做出正确的判断。 由于此方法返回其可变参数数组，它可以将堆污染传播到调用栈上。&lt;/p&gt;
&lt;p&gt;为了具体说明，请考虑下面的泛型方法，它接受三个类型&lt;code&gt;T&lt;/code&gt;的参数，并返回一个包含两个参数的数组，随机选择：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static &amp;lt;T&amp;gt; T[] pickTwo(T a, T b, T c) {
    switch(ThreadLocalRandom.current().nextInt(3)) {
      case 0: return toArray(a, b);
      case 1: return toArray(a, c);
      case 2: return toArray(b, c);
    }
    throw new AssertionError(); // Can't get here
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法本身不是危险的，除了调用具有泛型可变参数的&lt;code&gt;toArray&lt;/code&gt;方法之外，不会产生警告。&lt;/p&gt;
&lt;p&gt;编译此方法时，编译器会生成代码以创建一个将两个&lt;code&gt;T&lt;/code&gt;实例传递给&lt;code&gt;toArray&lt;/code&gt;的可变参数数组。 这段代码分配了一个&lt;code&gt;Object []&lt;/code&gt;类型的数组，它是保证保存这些实例的最具体的类型，而不管在调用位置传递给&lt;code&gt;pickTwo&lt;/code&gt;的对象是什么类型。 &lt;code&gt;toArray&lt;/code&gt;方法只是简单地将这个数组返回给&lt;code&gt;pickTwo&lt;/code&gt;，然后&lt;code&gt;pickTwo&lt;/code&gt;将它返回给调用者，所以&lt;code&gt;pickTwo&lt;/code&gt;总是返回一个&lt;code&gt;Object []&lt;/code&gt;类型的数组。&lt;/p&gt;
&lt;p&gt;现在考虑这个测试&lt;code&gt;pickTw&lt;/code&gt;的&lt;code&gt;main&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    String[] attributes = pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法没有任何问题，因此它编译时不会产生任何警告。 但是当运行它时，抛出一个ClassCastException异常，尽管不包含可见的转换。 你没有看到的是，编译器已经生成了一个隐藏的强制转换为由&lt;code&gt;pickTwo&lt;/code&gt;返回的值的&lt;code&gt;String []&lt;/code&gt;类型，以便它可以存储在属性中。 转换失败，因为&lt;code&gt;Object []&lt;/code&gt;不是&lt;code&gt;String []&lt;/code&gt;的子类型。 这种故障相当令人不安，因为它从实际导致堆污染（&lt;code&gt;toArray&lt;/code&gt;）的方法中移除了两个级别，并且在实际参数存储在其中之后，可变参数数组未被修改。&lt;/p&gt;
&lt;p&gt;这个例子是为了让人们认识到&lt;strong&gt;给另一个方法访问一个泛型的可变参数数组是不安全的&lt;/strong&gt;，除了两个例外：将数组传递给另一个可变参数方法是安全的，这个方法是用&lt;code&gt;@SafeVarargs&lt;/code&gt;正确标注的， 将数组传递给一个非可变参数的方法是安全的，该方法仅计算数组内容的一些方法。&lt;/p&gt;
&lt;p&gt;这里是安全使用泛型可变参数的典型示例。 此方法将任意数量的列表作为参数，并按顺序返回包含所有输入列表元素的单个列表。 由于该方法使用&lt;code&gt;@SafeVarargs&lt;/code&gt;进行标注，因此在声明或其调用站位置上不会生成任何警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Safe method with a generic varargs parameter
@SafeVarargs
static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; flatten(List&amp;lt;? extends T&amp;gt;... lists) {
    List&amp;lt;T&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
    for (List&amp;lt;? extends T&amp;gt; list : lists)
        result.addAll(list);
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;决定何时使用&lt;code&gt;SafeVarargs&lt;/code&gt;注解的规则很简单：在每种方法上使用&lt;code&gt;@SafeVarargs&lt;/code&gt;，并使用泛型或参数化类型的可变参数，这样用户就不会因不必要的和令人困惑的编译器警告而担忧。 这意味着你不应该写危险或者&lt;code&gt;toArray&lt;/code&gt;等不安全的可变参数方法。 每次编译器警告你可能会受到来自你控制的方法中泛型可变参数的堆污染时，请检查该方法是否安全。 提醒一下，在下列情况下，泛型可变参数方法是安全的：&lt;br/&gt;1.它不会在可变参数数组中存储任何东西&lt;/p&gt;
&lt;p&gt;2.它不会使数组（或克隆）对不可信代码可见。 如果违反这些禁令中的任何一项，请修复。&lt;/p&gt;
&lt;p&gt;请注意，&lt;code&gt;SafeVarargs&lt;/code&gt;注解只对不能被重写的方法是合法的，因为不可能保证每个可能的重写方法都是安全的。 在Java 8中，注解仅在静态方法和final实例方法上合法; 在Java 9中，它在私有实例方法中也变为合法。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;SafeVarargs&lt;/code&gt;注解的替代方法是采用条目 28的建议，并用&lt;code&gt;List&lt;/code&gt;参数替换可变参数（这是一个变相的数组）。 下面是应用于我们的&lt;code&gt;flatten&lt;/code&gt;方法时，这种方法的样子。 请注意，只有参数声明被更改了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// List as a typesafe alternative to a generic varargs parameter
static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; flatten(List&amp;lt;List&amp;lt;? extends T&amp;gt;&amp;gt; lists) {
    List&amp;lt;T&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
    for (List&amp;lt;? extends T&amp;gt; list : lists)
        result.addAll(list);
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后可以将此方法与静态工厂方法&lt;code&gt;List.of&lt;/code&gt;结合使用，以允许可变数量的参数。 请注意，这种方法依赖于&lt;code&gt;List.of&lt;/code&gt;声明使用&lt;code&gt;@SafeVarargs&lt;/code&gt;注解：&lt;br/&gt;audience = flatten(List.of(friends, romans, countrymen));&lt;/p&gt;
&lt;p&gt;这种方法的优点是编译器可以证明这种方法是类型安全的。 不必使用&lt;code&gt;SafeVarargs&lt;/code&gt;注解来证明其安全性，也不用担心在确定安全性时可能会犯错。 主要缺点是客户端代码有点冗长，运行可能会慢一些。&lt;/p&gt;
&lt;p&gt;这个技巧也可以用在不可能写一个安全的可变参数方法的情况下，就像第147页的&lt;code&gt;toArray&lt;/code&gt;方法那样。它的列表模拟是&lt;code&gt;List.of&lt;/code&gt;方法，所以我们甚至不必编写它; Java类库作者已经为我们完成了这项工作。 &lt;code&gt;pickTwo&lt;/code&gt;方法然后变成这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; pickTwo(T a, T b, T c) {
    switch(rnd.nextInt(3)) {
      case 0: return List.of(a, b);
      case 1: return List.of(a, c);
      case 2: return List.of(b, c);
    }
    throw new AssertionError();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt;方变成这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    List&amp;lt;String&amp;gt; attributes = pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的代码是类型安全的，因为它只使用泛型，不是数组。&lt;/p&gt;
&lt;p&gt;总而言之，可变参数和泛型不能很好地交互，因为可变参数机制是在数组上面构建的脆弱的抽象，并且数组具有与泛型不同的类型规则。 虽然泛型可变参数不是类型安全的，但它们是合法的。 如果选择使用泛型（或参数化）可变参数编写方法，请首先确保该方法是类型安全的，然后使用&lt;code&gt;@SafeVarargs&lt;/code&gt;注解对其进行标注，以免造成使用不愉快。&lt;/p&gt;
</description>
<pubDate>Mon, 12 Feb 2018 03:52:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8444200.html</dc:identifier>
</item>
</channel>
</rss>